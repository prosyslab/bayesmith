/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 39 "types.h"
typedef char *at_string;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 26 "types.h"
enum __anonenum_at_bool_696322153 {
    false = 0,
    true = 1
} ;
#line 26 "types.h"
typedef enum __anonenum_at_bool_696322153 at_bool;
#line 42 "types.h"
typedef void *at_address;
#line 45 "types.h"
typedef float at_real;
#line 48 "types.h"
struct _at_coord {
   unsigned short x ;
   unsigned short y ;
};
#line 48 "types.h"
typedef struct _at_coord at_coord;
#line 53 "types.h"
struct _at_real_coord {
   at_real x ;
   at_real y ;
   at_real z ;
};
#line 53 "types.h"
typedef struct _at_real_coord at_real_coord;
#line 50 "autotrace.h"
enum _at_msg_type ;
#line 50 "autotrace.h"
typedef enum _at_msg_type at_msg_type;
#line 223
enum _at_msg_type {
    AT_MSG_FATAL = 1,
    AT_MSG_WARNING = 2
} ;
#line 17 "exception.h"
struct _at_exception_type ;
#line 17 "exception.h"
typedef struct _at_exception_type at_exception_type;
#line 18 "exception.h"
struct _at_exception_type {
   at_msg_type msg_type ;
   void (*client_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ;
   at_address *client_data ;
};
#line 11 "vector.h"
struct __anonstruct_vector_type_148829389 {
   at_real dx ;
   at_real dy ;
   at_real dz ;
};
#line 11 "vector.h"
typedef struct __anonstruct_vector_type_148829389 vector_type;
#line 43 "autotrace.h"
struct _at_bitmap_type ;
#line 43 "autotrace.h"
typedef struct _at_bitmap_type at_bitmap_type;
#line 44
struct _at_color_type ;
#line 44 "autotrace.h"
typedef struct _at_color_type at_color_type;
#line 50
enum _at_msg_type ;
#line 53 "autotrace.h"
struct _at_color_type {
   unsigned char r ;
   unsigned char g ;
   unsigned char b ;
};
#line 215 "autotrace.h"
struct _at_bitmap_type {
   unsigned short height ;
   unsigned short width ;
   unsigned char *bitmap ;
   unsigned int np ;
};
#line 14 "bitmap.h"
typedef at_bitmap_type bitmap_type;
#line 9 "color.h"
typedef at_color_type color_type;
#line 39 "thin-image.c"
typedef unsigned char Pixel[3];
#line 45 "autotrace.h"
enum _at_polynomial_degree ;
#line 45 "autotrace.h"
typedef enum _at_polynomial_degree at_polynomial_degree;
#line 46
struct _at_spline_type ;
#line 46 "autotrace.h"
typedef struct _at_spline_type at_spline_type;
#line 47
struct _at_spline_list_type ;
#line 47 "autotrace.h"
typedef struct _at_spline_list_type at_spline_list_type;
#line 48
struct _at_spline_list_array_type ;
#line 48 "autotrace.h"
typedef struct _at_spline_list_array_type at_spline_list_array_type;
#line 61
enum _at_polynomial_degree {
    AT_LINEARTYPE = 1,
    AT_QUADRATICTYPE = 2,
    AT_CUBICTYPE = 3,
    AT_PARALLELELLIPSETYPE = 4,
    AT_ELLIPSETYPE = 5,
    AT_CIRCLETYPE = 6
} ;
#line 78 "autotrace.h"
struct _at_spline_type {
   at_real_coord v[4] ;
   at_polynomial_degree degree ;
   at_real linearity ;
};
#line 87 "autotrace.h"
struct _at_spline_list_type {
   at_spline_type *data ;
   unsigned int length ;
   at_bool clockwise ;
   at_color_type color ;
   at_bool open ;
};
#line 98 "autotrace.h"
struct _at_spline_list_array_type {
   at_spline_list_type *data ;
   unsigned int length ;
   unsigned short height ;
   unsigned short width ;
   at_color_type *background_color ;
   at_bool centerline ;
   at_bool preserve_width ;
   at_real width_weight_factor ;
};
#line 11 "spline.h"
typedef at_polynomial_degree polynomial_degree;
#line 12 "spline.h"
typedef at_spline_type spline_type;
#line 38 "spline.h"
typedef at_spline_list_type spline_list_type;
#line 50 "autotrace.h"
enum _at_msg_type ;
#line 12 "pxl-outline.h"
struct __anonstruct_pixel_outline_type_1003476238 {
   at_coord *data ;
   unsigned int length ;
   at_bool clockwise ;
   color_type color ;
   at_bool open ;
};
#line 12 "pxl-outline.h"
typedef struct __anonstruct_pixel_outline_type_1003476238 pixel_outline_type;
#line 39 "pxl-outline.h"
struct __anonstruct_pixel_outline_list_type_435182123 {
   pixel_outline_type *data ;
   unsigned int length ;
};
#line 39 "pxl-outline.h"
typedef struct __anonstruct_pixel_outline_list_type_435182123 pixel_outline_list_type;
#line 28 "pxl-outline.c"
enum __anonenum_edge_type_821818412 {
    TOP = 1,
    LEFT = 2,
    BOTTOM = 3,
    RIGHT = 0,
    NO_EDGE = 4
} ;
#line 28 "pxl-outline.c"
typedef enum __anonenum_edge_type_821818412 edge_type;
#line 38
enum __anonenum_direction_type_995552381 {
    NORTH = 0,
    NORTHWEST = 1,
    WEST = 2,
    SOUTHWEST = 3,
    SOUTH = 4,
    SOUTHEAST = 5,
    EAST = 6,
    NORTHEAST = 7
} ;
#line 38 "pxl-outline.c"
typedef enum __anonenum_direction_type_995552381 direction_type;
#line 42 "autotrace.h"
struct _at_output_opts_type ;
#line 42 "autotrace.h"
typedef struct _at_output_opts_type at_output_opts_type;
#line 45
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 210 "autotrace.h"
struct _at_output_opts_type {
   int dpi ;
};
#line 45
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 30 "/usr/include/pstoedit/pstoedll.h"
struct DriverDescription_S {
   char const   *symbolicname ;
   char const   *explanation ;
   char const   *suffix ;
   char const   *additionalInfo ;
   int backendSupportsSubPaths ;
   int backendSupportsCurveto ;
   int backendSupportsMerging ;
   int backendSupportsText ;
   int backendSupportsImages ;
   int backendSupportsMultiplePages ;
};
#line 45 "autotrace.h"
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 242 "autotrace.h"
typedef int (*at_output_write_func)(FILE * , at_string name , int llx , int lly ,
                                    int urx , int ury , at_output_opts_type *opts ,
                                    at_spline_list_array_type shape , void (*msg_func)(at_string msg ,
                                                                                       at_msg_type msg_type ,
                                                                                       at_address client_data ) ,
                                    at_address msg_data );
#line 45
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 45
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 45
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 34 "output-mif.c"
struct __anonstruct_ColorT_74960170 {
   char *tag ;
   color_type c ;
};
#line 34 "output-mif.c"
typedef struct __anonstruct_ColorT_74960170 ColorT;
#line 39 "output-mif.c"
struct __anonstruct_BboxT_194817022 {
   int llx ;
   int lly ;
   int urx ;
   int ury ;
   at_real dpi ;
};
#line 39 "output-mif.c"
typedef struct __anonstruct_BboxT_194817022 BboxT;
#line 45 "autotrace.h"
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 55 "output-fig.c"
struct __anonstruct_fig_hash_961093920 {
   unsigned int colour ;
   unsigned int alternate ;
};
#line 60 "output-fig.c"
struct __anonstruct_fig_colour_map_852451852 {
   unsigned char r ;
   unsigned char g ;
   unsigned char b ;
   int alternate ;
};
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 45 "autotrace.h"
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 45 "autotrace.h"
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 45
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 45
enum _at_polynomial_degree ;
#line 77 "output-emf.c"
typedef unsigned long UI32;
#line 78 "output-emf.c"
typedef unsigned short UI16;
#line 79 "output-emf.c"
typedef unsigned char UI8;
#line 83 "output-emf.c"
struct EMFColorListType {
   UI32 colref ;
   struct EMFColorListType *next ;
};
#line 83 "output-emf.c"
typedef struct EMFColorListType EMFColorList;
#line 91 "output-emf.c"
struct __anonstruct_EMFStats_582275743 {
   int ncolors ;
   int nrecords ;
   int filesize ;
};
#line 91 "output-emf.c"
typedef struct __anonstruct_EMFStats_582275743 EMFStats;
#line 45 "autotrace.h"
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 63 "output-dxf.c"
struct xypnt_t {
   int xp ;
   int yp ;
};
#line 63 "output-dxf.c"
typedef struct xypnt_t xypnt;
#line 68 "output-dxf.c"
struct xypnt_point_t {
   xypnt point ;
   struct xypnt_point_t *next_point ;
};
#line 68 "output-dxf.c"
typedef struct xypnt_point_t xypnt_point_rec;
#line 73 "output-dxf.c"
struct xypnt_head_t {
   xypnt_point_rec *first_point ;
   xypnt_point_rec *last_point ;
   xypnt_point_rec *current_point ;
   struct xypnt_head_t *next_head ;
};
#line 73 "output-dxf.c"
typedef struct xypnt_head_t xypnt_head_rec;
#line 79 "output-dxf.c"
struct Colors_t {
   int red ;
   int green ;
   int blue ;
};
#line 45 "autotrace.h"
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 54 "output-dr2d.c"
struct Chunk {
   unsigned char ID[4] ;
   unsigned int Size ;
   unsigned char *Data ;
};
#line 45 "autotrace.h"
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 50 "output.c"
struct output_format_entry {
   char const   *name ;
   char const   *descr ;
   int (*writer)(FILE * , at_string name , int llx , int lly , int urx , int ury ,
                 at_output_opts_type *opts , at_spline_list_array_type shape , void (*msg_func)(at_string msg ,
                                                                                                at_msg_type msg_type ,
                                                                                                at_address client_data ) ,
                 at_address msg_data ) ;
};
#line 45 "autotrace.h"
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 50
enum _at_msg_type ;
#line 38 "quantize.h"
typedef unsigned long ColorFreq;
#line 39 "quantize.h"
typedef ColorFreq *Histogram;
#line 41 "quantize.h"
struct __anonstruct_QuantizeObj_563054050 {
   int desired_number_of_colors ;
   int actual_number_of_colors ;
   color_type cmap[256] ;
   ColorFreq freq[256] ;
   Histogram histogram ;
};
#line 41 "quantize.h"
typedef struct __anonstruct_QuantizeObj_563054050 QuantizeObj;
#line 52 "median.c"
struct __anonstruct_box_36690010 {
   int Rmin ;
   int Rmax ;
   int Gmin ;
   int Gmax ;
   int Bmin ;
   int Bmax ;
   int volume ;
   long colorcount ;
};
#line 52 "median.c"
typedef struct __anonstruct_box_36690010 box;
#line 52 "median.c"
typedef struct __anonstruct_box_36690010 *boxptr;
#line 40 "autotrace.h"
struct _at_fitting_opts_type ;
#line 40 "autotrace.h"
typedef struct _at_fitting_opts_type at_fitting_opts_type;
#line 41
struct _at_input_opts_type ;
#line 41 "autotrace.h"
typedef struct _at_input_opts_type at_input_opts_type;
#line 45
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 118 "autotrace.h"
struct _at_fitting_opts_type {
   at_color_type *background_color ;
   unsigned int color_count ;
   at_real corner_always_threshold ;
   unsigned int corner_surround ;
   at_real corner_threshold ;
   at_real error_threshold ;
   unsigned int filter_iterations ;
   at_real line_reversion_threshold ;
   at_real line_threshold ;
   at_bool remove_adjacent_corners ;
   unsigned int tangent_surround ;
   unsigned int despeckle_level ;
   at_real despeckle_tightness ;
   at_bool centerline ;
   at_bool preserve_width ;
   at_real width_weight_factor ;
};
#line 205 "autotrace.h"
struct _at_input_opts_type {
   at_color_type *background_color ;
};
#line 236 "autotrace.h"
typedef at_bitmap_type (*at_input_read_func)(at_string name , at_input_opts_type *opts ,
                                             void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                              at_address client_data ) ,
                                             at_address msg_data );
#line 73 "getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 50 "autotrace.h"
enum _at_msg_type ;
#line 55 "input-tga.c"
struct tga_header {
   unsigned char idLength ;
   unsigned char colorMapType ;
   unsigned char imageType ;
   unsigned char colorMapIndexLo ;
   unsigned char colorMapIndexHi ;
   unsigned char colorMapLengthLo ;
   unsigned char colorMapLengthHi ;
   unsigned char colorMapSize ;
   unsigned char xOriginLo ;
   unsigned char xOriginHi ;
   unsigned char yOriginLo ;
   unsigned char yOriginHi ;
   unsigned char widthLo ;
   unsigned char widthHi ;
   unsigned char heightLo ;
   unsigned char heightHi ;
   unsigned char bpp ;
   unsigned char descriptor ;
};
#line 97 "input-tga.c"
struct __anonstruct_tga_footer_517022796 {
   unsigned int extensionAreaOffset ;
   unsigned int developerDirectoryOffset ;
   char signature[16] ;
   char dot ;
   char null ;
};
#line 50 "autotrace.h"
enum _at_msg_type ;
#line 42 "input-pnm.c"
struct _PNMScanner {
   FILE *fd ;
   char cur ;
   int eof ;
   char *inbuf ;
   int inbufsize ;
   int inbufvalidsize ;
   int inbufpos ;
};
#line 42 "input-pnm.c"
typedef struct _PNMScanner PNMScanner;
#line 53 "input-pnm.c"
struct _PNMInfo {
   unsigned int xres ;
   unsigned int yres ;
   int maxval ;
   int np ;
   int asciibody ;
   void (*loader)(PNMScanner * , struct _PNMInfo * , unsigned char * , at_exception_type *excep ) ;
};
#line 53 "input-pnm.c"
typedef struct _PNMInfo PNMInfo;
#line 106 "input-pnm.c"
struct struct_pnm_types {
   char name ;
   int np ;
   int asciibody ;
   int maxval ;
   void (*loader)(PNMScanner * , struct _PNMInfo * , unsigned char *pixel_rgn , at_exception_type *excep ) ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 50 "autotrace.h"
enum _at_msg_type ;
#line 391 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 393 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 394 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 400 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 409 "/usr/include/zconf.h"
typedef void *voidpf;
#line 84 "/usr/include/zlib.h"
struct internal_state ;
#line 86 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 86 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 1122 "/usr/local/include/pngconf.h"
typedef unsigned int png_uint_32;
#line 1123 "/usr/local/include/pngconf.h"
typedef int png_int_32;
#line 1128 "/usr/local/include/pngconf.h"
typedef unsigned short png_uint_16;
#line 1130 "/usr/local/include/pngconf.h"
typedef unsigned char png_byte;
#line 1135 "/usr/local/include/pngconf.h"
typedef size_t png_size_t;
#line 1201 "/usr/local/include/pngconf.h"
typedef png_int_32 png_fixed_point;
#line 1204 "/usr/local/include/pngconf.h"
typedef void *png_voidp;
#line 1205 "/usr/local/include/pngconf.h"
typedef png_byte *png_bytep;
#line 1208 "/usr/local/include/pngconf.h"
typedef png_uint_16 *png_uint_16p;
#line 1210 "/usr/local/include/pngconf.h"
typedef char const   *png_const_charp;
#line 1211 "/usr/local/include/pngconf.h"
typedef char *png_charp;
#line 1215 "/usr/local/include/pngconf.h"
typedef FILE *png_FILE_p;
#line 1223 "/usr/local/include/pngconf.h"
typedef png_byte **png_bytepp;
#line 1226 "/usr/local/include/pngconf.h"
typedef png_uint_16 **png_uint_16pp;
#line 1229 "/usr/local/include/pngconf.h"
typedef char **png_charpp;
#line 1526 "/usr/local/include/pngconf.h"
typedef png_size_t png_alloc_size_t;
#line 374 "/usr/local/include/png.h"
struct png_color_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
};
#line 374 "/usr/local/include/png.h"
typedef struct png_color_struct png_color;
#line 380 "/usr/local/include/png.h"
typedef png_color *png_colorp;
#line 383 "/usr/local/include/png.h"
struct png_color_16_struct {
   png_byte index ;
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 gray ;
};
#line 383 "/usr/local/include/png.h"
typedef struct png_color_16_struct png_color_16;
#line 391 "/usr/local/include/png.h"
typedef png_color_16 *png_color_16p;
#line 394 "/usr/local/include/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 394 "/usr/local/include/png.h"
typedef struct png_color_8_struct png_color_8;
#line 409 "/usr/local/include/png.h"
struct png_sPLT_entry_struct {
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 alpha ;
   png_uint_16 frequency ;
};
#line 409 "/usr/local/include/png.h"
typedef struct png_sPLT_entry_struct png_sPLT_entry;
#line 417 "/usr/local/include/png.h"
typedef png_sPLT_entry *png_sPLT_entryp;
#line 425 "/usr/local/include/png.h"
struct png_sPLT_struct {
   png_charp name ;
   png_byte depth ;
   png_sPLT_entryp entries ;
   png_int_32 nentries ;
};
#line 425 "/usr/local/include/png.h"
typedef struct png_sPLT_struct png_sPLT_t;
#line 432 "/usr/local/include/png.h"
typedef png_sPLT_t *png_sPLT_tp;
#line 444 "/usr/local/include/png.h"
struct png_text_struct {
   int compression ;
   png_charp key ;
   png_charp text ;
   png_size_t text_length ;
   png_size_t itxt_length ;
   png_charp lang ;
   png_charp lang_key ;
};
#line 444 "/usr/local/include/png.h"
typedef struct png_text_struct png_text;
#line 463 "/usr/local/include/png.h"
typedef png_text *png_textp;
#line 483 "/usr/local/include/png.h"
struct png_time_struct {
   png_uint_16 year ;
   png_byte month ;
   png_byte day ;
   png_byte hour ;
   png_byte minute ;
   png_byte second ;
};
#line 483 "/usr/local/include/png.h"
typedef struct png_time_struct png_time;
#line 502 "/usr/local/include/png.h"
struct png_unknown_chunk_t {
   png_byte name[5] ;
   png_byte *data ;
   png_size_t size ;
   png_byte location ;
};
#line 502 "/usr/local/include/png.h"
typedef struct png_unknown_chunk_t png_unknown_chunk;
#line 512 "/usr/local/include/png.h"
typedef png_unknown_chunk *png_unknown_chunkp;
#line 555 "/usr/local/include/png.h"
struct png_info_struct {
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 valid ;
   png_size_t rowbytes ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   png_uint_16 num_trans ;
   png_byte bit_depth ;
   png_byte color_type ;
   png_byte compression_type ;
   png_byte filter_type ;
   png_byte interlace_type ;
   png_byte channels ;
   png_byte pixel_depth ;
   png_byte spare_byte ;
   png_byte signature[8] ;
   float gamma ;
   png_byte srgb_intent ;
   int num_text ;
   int max_text ;
   png_textp text ;
   png_time mod_time ;
   png_color_8 sig_bit ;
   png_bytep trans_alpha ;
   png_color_16 trans_color ;
   png_color_16 background ;
   png_int_32 x_offset ;
   png_int_32 y_offset ;
   png_byte offset_unit_type ;
   png_uint_32 x_pixels_per_unit ;
   png_uint_32 y_pixels_per_unit ;
   png_byte phys_unit_type ;
   png_uint_16p hist ;
   float x_white ;
   float y_white ;
   float x_red ;
   float y_red ;
   float x_green ;
   float y_green ;
   float x_blue ;
   float y_blue ;
   png_charp pcal_purpose ;
   png_int_32 pcal_X0 ;
   png_int_32 pcal_X1 ;
   png_charp pcal_units ;
   png_charpp pcal_params ;
   png_byte pcal_type ;
   png_byte pcal_nparams ;
   png_uint_32 free_me ;
   png_unknown_chunkp unknown_chunks ;
   png_size_t unknown_chunks_num ;
   png_charp iccp_name ;
   png_charp iccp_profile ;
   png_uint_32 iccp_proflen ;
   png_byte iccp_compression ;
   png_sPLT_tp splt_palettes ;
   png_uint_32 splt_palettes_num ;
   png_byte scal_unit ;
   double scal_pixel_width ;
   double scal_pixel_height ;
   png_charp scal_s_width ;
   png_charp scal_s_height ;
   png_bytepp row_pointers ;
   png_fixed_point int_gamma ;
   png_fixed_point int_x_white ;
   png_fixed_point int_y_white ;
   png_fixed_point int_x_red ;
   png_fixed_point int_y_red ;
   png_fixed_point int_x_green ;
   png_fixed_point int_y_green ;
   png_fixed_point int_x_blue ;
   png_fixed_point int_y_blue ;
};
#line 555 "/usr/local/include/png.h"
typedef struct png_info_struct png_info;
#line 818 "/usr/local/include/png.h"
typedef png_info *png_infop;
#line 819 "/usr/local/include/png.h"
typedef png_info const   *png_const_infop;
#line 820 "/usr/local/include/png.h"
typedef png_info **png_infopp;
#line 919 "/usr/local/include/png.h"
struct png_row_info_struct {
   png_uint_32 width ;
   png_size_t rowbytes ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte channels ;
   png_byte pixel_depth ;
};
#line 919 "/usr/local/include/png.h"
typedef struct png_row_info_struct png_row_info;
#line 929 "/usr/local/include/png.h"
typedef png_row_info *png_row_infop;
#line 938
struct png_struct_def ;
#line 938 "/usr/local/include/png.h"
typedef struct png_struct_def png_struct;
#line 939 "/usr/local/include/png.h"
typedef png_struct *png_structp;
#line 940 "/usr/local/include/png.h"
typedef png_struct const   *png_const_structp;
#line 1014 "/usr/local/include/png.h"
struct png_struct_def {
   jmp_buf jmpbuf ;
   void (*longjmp_fn)(struct __jmp_buf_tag * , int  ) ;
   void (*error_fn)(png_structp  , png_const_charp  ) ;
   void (*warning_fn)(png_structp  , png_const_charp  ) ;
   png_voidp error_ptr ;
   void (*write_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
   void (*read_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
   png_voidp io_ptr ;
   void (*read_user_transform_fn)(png_structp  , png_row_infop  , png_bytep  ) ;
   void (*write_user_transform_fn)(png_structp  , png_row_infop  , png_bytep  ) ;
   png_voidp user_transform_ptr ;
   png_byte user_transform_depth ;
   png_byte user_transform_channels ;
   png_uint_32 mode ;
   png_uint_32 flags ;
   png_uint_32 transformations ;
   z_stream zstream ;
   png_bytep zbuf ;
   png_size_t zbuf_size ;
   int zlib_level ;
   int zlib_method ;
   int zlib_window_bits ;
   int zlib_mem_level ;
   int zlib_strategy ;
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 num_rows ;
   png_uint_32 usr_width ;
   png_size_t rowbytes ;
   png_alloc_size_t user_chunk_malloc_max ;
   png_uint_32 iwidth ;
   png_uint_32 row_number ;
   png_bytep prev_row ;
   png_bytep row_buf ;
   png_bytep sub_row ;
   png_bytep up_row ;
   png_bytep avg_row ;
   png_bytep paeth_row ;
   png_row_info row_info ;
   png_uint_32 idat_size ;
   png_uint_32 crc ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   png_uint_16 num_trans ;
   png_byte chunk_name[5] ;
   png_byte compression ;
   png_byte filter ;
   png_byte interlaced ;
   png_byte pass ;
   png_byte do_filter ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte usr_bit_depth ;
   png_byte pixel_depth ;
   png_byte channels ;
   png_byte usr_channels ;
   png_byte sig_bytes ;
   png_uint_16 filler ;
   png_byte background_gamma_type ;
   float background_gamma ;
   png_color_16 background ;
   png_color_16 background_1 ;
   void (*output_flush_fn)(png_structp  ) ;
   png_uint_32 flush_dist ;
   png_uint_32 flush_rows ;
   int gamma_shift ;
   float gamma ;
   float screen_gamma ;
   png_bytep gamma_table ;
   png_bytep gamma_from_1 ;
   png_bytep gamma_to_1 ;
   png_uint_16pp gamma_16_table ;
   png_uint_16pp gamma_16_from_1 ;
   png_uint_16pp gamma_16_to_1 ;
   png_color_8 sig_bit ;
   png_color_8 shift ;
   png_bytep trans_alpha ;
   png_color_16 trans_color ;
   void (*read_row_fn)(png_structp  , png_uint_32  , int  ) ;
   void (*write_row_fn)(png_structp  , png_uint_32  , int  ) ;
   void (*info_fn)(png_structp  , png_infop  ) ;
   void (*row_fn)(png_structp  , png_bytep  , png_uint_32  , int  ) ;
   void (*end_fn)(png_structp  , png_infop  ) ;
   png_bytep save_buffer_ptr ;
   png_bytep save_buffer ;
   png_bytep current_buffer_ptr ;
   png_bytep current_buffer ;
   png_uint_32 push_length ;
   png_uint_32 skip_length ;
   png_size_t save_buffer_size ;
   png_size_t save_buffer_max ;
   png_size_t buffer_size ;
   png_size_t current_buffer_size ;
   int process_mode ;
   int cur_palette ;
   png_size_t current_text_size ;
   png_size_t current_text_left ;
   png_charp current_text ;
   png_charp current_text_ptr ;
   png_bytep palette_lookup ;
   png_bytep quantize_index ;
   png_uint_16p hist ;
   png_charp time_buffer ;
   png_uint_32 free_me ;
   png_voidp user_chunk_ptr ;
   int (*read_user_chunk_fn)(png_structp  , png_unknown_chunkp  ) ;
   int num_chunk_list ;
   png_bytep chunk_list ;
   png_byte rgb_to_gray_status ;
   png_uint_16 rgb_to_gray_red_coeff ;
   png_uint_16 rgb_to_gray_green_coeff ;
   png_uint_16 rgb_to_gray_blue_coeff ;
   png_uint_32 mng_features_permitted ;
   png_fixed_point int_gamma ;
   png_byte filter_type ;
   png_voidp mem_ptr ;
   png_voidp (*malloc_fn)(png_structp  , png_alloc_size_t  ) ;
   void (*free_fn)(png_structp  , png_voidp  ) ;
   png_bytep big_row_buf ;
   png_bytep quantize_sort ;
   png_bytep index_to_palette ;
   png_bytep palette_to_index ;
   png_byte compression_type ;
   png_uint_32 user_width_max ;
   png_uint_32 user_height_max ;
   png_uint_32 user_chunk_cache_max ;
   png_unknown_chunk unknown_chunk ;
   png_uint_32 old_big_row_buf_size ;
   png_uint_32 old_prev_row_size ;
   png_charp chunkdata ;
   png_uint_32 io_state ;
};
#line 1383 "/usr/local/include/png.h"
typedef png_struct **png_structpp;
#line 50 "autotrace.h"
enum _at_msg_type ;
#line 43 "input.c"
struct input_format_entry {
   char const   *name ;
   char const   *descr ;
   at_bitmap_type (*reader)(at_string name , at_input_opts_type *opts , void (*msg_func)(at_string msg ,
                                                                                         at_msg_type msg_type ,
                                                                                         at_address client_data ) ,
                            at_address msg_data ) ;
};
#line 50 "autotrace.h"
enum _at_msg_type ;
#line 42 "input-bmp.c"
struct Bitmap_File_Head_Struct {
   char zzMagic[2] ;
   unsigned long bfSize ;
   unsigned short zzHotX ;
   unsigned short zzHotY ;
   unsigned long bfOffs ;
   unsigned long biSize ;
};
#line 52 "input-bmp.c"
struct Bitmap_Head_Struct {
   unsigned long biWidth ;
   unsigned long biHeight ;
   unsigned short biPlanes ;
   unsigned short biBitCnt ;
   unsigned long biCompr ;
   unsigned long biSizeIm ;
   unsigned long biXPels ;
   unsigned long biYPels ;
   unsigned long biClrUsed ;
   unsigned long biClrImp ;
};
#line 50 "autotrace.h"
enum _at_msg_type ;
#line 17 "image-proc.h"
struct __anonstruct_distance_map_type_313585256 {
   unsigned int height ;
   unsigned int width ;
   float **weight ;
   float **d ;
};
#line 17 "image-proc.h"
typedef struct __anonstruct_distance_map_type_313585256 distance_map_type;
#line 117 "getopt.c"
enum __anonenum_ordering_681854793 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 45 "autotrace.h"
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 14 "fit.h"
typedef at_fitting_opts_type fitting_opts_type;
#line 16 "curve.h"
struct __anonstruct_point_type_420216370 {
   at_real_coord coord ;
   at_real t ;
};
#line 16 "curve.h"
typedef struct __anonstruct_point_type_420216370 point_type;
#line 27 "curve.h"
struct curve {
   point_type *point_list ;
   unsigned int length ;
   at_bool cyclic ;
   vector_type *start_tangent ;
   vector_type *end_tangent ;
   struct curve *previous ;
   struct curve *next ;
};
#line 38 "curve.h"
typedef struct curve *curve_type;
#line 96 "curve.h"
struct __anonstruct_curve_list_type_407288144 {
   curve_type *data ;
   unsigned int length ;
   at_bool clockwise ;
   at_bool open ;
};
#line 96 "curve.h"
typedef struct __anonstruct_curve_list_type_407288144 curve_list_type;
#line 123 "curve.h"
struct __anonstruct_curve_list_array_type_863723917 {
   curve_list_type *data ;
   unsigned int length ;
};
#line 123 "curve.h"
typedef struct __anonstruct_curve_list_array_type_863723917 curve_list_array_type;
#line 56 "fit.c"
struct index_list {
   unsigned int *data ;
   unsigned int length ;
};
#line 56 "fit.c"
typedef struct index_list index_list_type;
#line 50 "autotrace.h"
enum _at_msg_type ;
#line 50
enum _at_msg_type ;
#line 45
enum _at_polynomial_degree ;
#line 50
enum _at_msg_type ;
#line 11 "image-header.h"
struct __anonstruct_image_header_type_316371847 {
   unsigned short hres ;
   unsigned short vres ;
   unsigned short width ;
   unsigned short height ;
   unsigned short depth ;
   unsigned int format ;
};
#line 11 "image-header.h"
typedef struct __anonstruct_image_header_type_316371847 image_header_type;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 775
extern void perror(char const   *__s ) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 92 "xstd.h"
FILE *xfopen(at_string filename___0 , at_string mode ) ;
#line 93
void xfclose(FILE *f , at_string filename___0 ) ;
#line 94
void xfseek(FILE *f , long offset , int wherefrom , at_string filename___0 ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 10 "xstd.c"
FILE *xfopen(at_string filename___0 , at_string mode ) 
{ 
  FILE *f ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 15
  tmp___0 = strcmp((char const   *)filename___0, "-");
  }
#line 15
  if (tmp___0 == 0) {
#line 16
    f = stdin;
  } else {
    {
#line 19
    f = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)mode);
    }
#line 20
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 21
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 21
        perror((char const   *)filename___0);
#line 21
        tmp = __errno_location();
#line 21
        exit(*tmp);
        }
#line 21
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 24
  return (f);
}
}
#line 28 "xstd.c"
void xfclose(FILE *f , at_string filename___0 ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 31
  if ((unsigned long )f != (unsigned long )stdin) {
    {
#line 33
    tmp___0 = fclose(f);
    }
#line 33
    if (tmp___0 == -1) {
      {
#line 34
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 34
        perror((char const   *)filename___0);
#line 34
        tmp = __errno_location();
#line 34
        exit(*tmp);
        }
#line 34
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 36
  return;
}
}
#line 38 "xstd.c"
void xfseek(FILE *f , long offset , int wherefrom , at_string filename___0 ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 41
  tmp___0 = fseek(f, offset, wherefrom);
  }
#line 41
  if (tmp___0 < 0) {
    {
#line 42
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 42
      perror((char const   *)filename___0);
#line 42
      tmp = __errno_location();
#line 42
      exit(*tmp);
      }
#line 42
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 43
  return;
}
}
#line 28 "exception.h"
void at_exception_fatal(at_exception_type *exception , at_string const   message ) ;
#line 18 "vector.h"
vector_type make_vector(at_real_coord const   c ) ;
#line 21
at_real_coord vector_to_point(vector_type const   v ) ;
#line 27
at_real magnitude(vector_type const   v ) ;
#line 28
vector_type normalize(vector_type const   v ) ;
#line 30
vector_type Vadd(vector_type const   v1 , vector_type const   v2 ) ;
#line 31
at_real Vdot(vector_type const   v1 , vector_type const   v2 ) ;
#line 32
vector_type Vmult_scalar(vector_type const   v , at_real const   r ) ;
#line 33
at_real Vangle(vector_type const   in_vector , vector_type const   out_vector , at_exception_type *exp___0 ) ;
#line 38
at_real_coord Vadd_point(at_real_coord const   c , vector_type const   v ) ;
#line 42
at_real_coord Vsubtract_point(at_real_coord const   c , vector_type const   v ) ;
#line 47
at_coord Vadd_int_point(at_coord const   c , vector_type const   v ) ;
#line 51
vector_type Vabs(vector_type const   v ) ;
#line 56
vector_type Psubtract(at_real_coord const   c1 , at_real_coord const   c2 ) ;
#line 60
at_real_coord Padd(at_real_coord const   coord1 , at_real_coord const   coord2 ) ;
#line 62
at_real_coord Pmult_scalar(at_real_coord const   coord , at_real const   r ) ;
#line 66
vector_type IPsubtract(at_coord const   coord1 , at_coord const   coord2 ) ;
#line 68
at_coord IPsubtractP(at_coord const   c1 , at_coord const   c2 ) ;
#line 70
at_coord IPadd(at_coord const   c1 , at_coord const   c2 ) ;
#line 72
at_coord IPmult_scalar(at_coord const   c , int const   i ) ;
#line 73
at_real_coord IPmult_real(at_coord const   c , at_real const   r ) ;
#line 75
at_bool IPequal(at_coord const   c1 , at_coord const   c2 ) ;
#line 14 "epsilon-equal.h"
at_bool epsilon_equal(at_real v1 , at_real v2 ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acos)(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 396 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 15 "vector.c"
static at_real acos_d(at_real v , at_exception_type *excep ) ;
#line 26 "vector.c"
vector_type make_vector(at_real_coord const   c ) 
{ 
  vector_type v ;

  {
#line 31
  v.dx = (at_real )c.x;
#line 32
  v.dy = (at_real )c.y;
#line 33
  v.dz = (at_real )c.z;
#line 35
  return (v);
}
}
#line 41 "vector.c"
at_real_coord vector_to_point(vector_type const   v ) 
{ 
  at_real_coord coord ;

  {
#line 46
  coord.x = (at_real )v.dx;
#line 47
  coord.y = (at_real )v.dy;
#line 49
  return (coord);
}
}
#line 53 "vector.c"
at_real magnitude(vector_type const   v ) 
{ 
  double tmp ;

  {
  {
#line 56
  tmp = sqrt((double )((v.dx * v.dx + v.dy * v.dy) + v.dz * v.dz));
  }
#line 56
  return ((at_real )tmp);
}
}
#line 60 "vector.c"
vector_type normalize(vector_type const   v ) 
{ 
  vector_type new_v ;
  at_real m ;
  at_real tmp ;

  {
  {
#line 64
  tmp = magnitude(v);
#line 64
  m = tmp;
  }
#line 68
  if ((double )m > 0.0) {
#line 70
    new_v.dx = (at_real )(v.dx / (at_real const   )m);
#line 71
    new_v.dy = (at_real )(v.dy / (at_real const   )m);
#line 72
    new_v.dz = (at_real )(v.dz / (at_real const   )m);
  } else {
#line 76
    new_v.dx = (at_real )v.dx;
#line 77
    new_v.dy = (at_real )v.dy;
#line 78
    new_v.dz = (at_real )v.dz;
  }
#line 81
  return (new_v);
}
}
#line 85 "vector.c"
vector_type Vadd(vector_type const   v1 , vector_type const   v2 ) 
{ 
  vector_type new_v ;

  {
#line 90
  new_v.dx = (at_real )(v1.dx + v2.dx);
#line 91
  new_v.dy = (at_real )(v1.dy + v2.dy);
#line 92
  new_v.dz = (at_real )(v1.dz + v2.dz);
#line 94
  return (new_v);
}
}
#line 98 "vector.c"
at_real Vdot(vector_type const   v1 , vector_type const   v2 ) 
{ 


  {
#line 101
  return ((at_real )((v1.dx * v2.dx + v1.dy * v2.dy) + v1.dz * v2.dz));
}
}
#line 105 "vector.c"
vector_type Vmult_scalar(vector_type const   v , at_real const   r ) 
{ 
  vector_type new_v ;

  {
#line 110
  new_v.dx = (at_real )(v.dx * r);
#line 111
  new_v.dy = (at_real )(v.dy * r);
#line 112
  new_v.dz = (at_real )(v.dz * r);
#line 114
  return (new_v);
}
}
#line 121 "vector.c"
at_real Vangle(vector_type const   in_vector , vector_type const   out_vector , at_exception_type *exp___0 ) 
{ 
  vector_type v1 ;
  vector_type tmp ;
  vector_type v2 ;
  vector_type tmp___0 ;
  at_real tmp___1 ;
  at_real tmp___2 ;

  {
  {
#line 126
  tmp = normalize(in_vector);
#line 126
  v1 = tmp;
#line 127
  tmp___0 = normalize(out_vector);
#line 127
  v2 = tmp___0;
#line 129
  tmp___1 = Vdot((vector_type const   )v2, (vector_type const   )v1);
#line 129
  tmp___2 = acos_d(tmp___1, exp___0);
  }
#line 129
  return (tmp___2);
}
}
#line 133 "vector.c"
at_real_coord Vadd_point(at_real_coord const   c , vector_type const   v ) 
{ 
  at_real_coord new_c ;

  {
#line 138
  new_c.x = (at_real )(c.x + v.dx);
#line 139
  new_c.y = (at_real )(c.y + v.dy);
#line 140
  new_c.z = (at_real )(c.z + v.dz);
#line 141
  return (new_c);
}
}
#line 145 "vector.c"
at_real_coord Vsubtract_point(at_real_coord const   c , vector_type const   v ) 
{ 
  at_real_coord new_c ;

  {
#line 150
  new_c.x = (at_real )(c.x - v.dx);
#line 151
  new_c.y = (at_real )(c.y - v.dy);
#line 152
  new_c.z = (at_real )(c.z - v.dz);
#line 153
  return (new_c);
}
}
#line 157 "vector.c"
at_coord Vadd_int_point(at_coord const   c , vector_type const   v ) 
{ 
  at_coord a ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 162
  if ((at_real )c.x + (at_real )v.dx > (at_real )0) {
#line 162
    tmp___0 = 1;
  } else {
#line 162
    if ((at_real )c.x + (at_real )v.dx < (at_real )0) {
#line 162
      tmp = -1;
    } else {
#line 162
      tmp = 0;
    }
#line 162
    tmp___0 = tmp;
  }
#line 162
  a.x = (unsigned short )((int )((double )((int )((at_real )c.x + (at_real )v.dx)) + .5 * (double )tmp___0));
#line 163
  if ((at_real )c.y + (at_real )v.dy > (at_real )0) {
#line 163
    tmp___2 = 1;
  } else {
#line 163
    if ((at_real )c.y + (at_real )v.dy < (at_real )0) {
#line 163
      tmp___1 = -1;
    } else {
#line 163
      tmp___1 = 0;
    }
#line 163
    tmp___2 = tmp___1;
  }
#line 163
  a.y = (unsigned short )((int )((double )((int )((at_real )c.y + (at_real )v.dy)) + .5 * (double )tmp___2));
#line 164
  return (a);
}
}
#line 168 "vector.c"
vector_type Vabs(vector_type const   v ) 
{ 
  vector_type new_v ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 173
  tmp = fabs((double )v.dx);
#line 173
  new_v.dx = (at_real )tmp;
#line 174
  tmp___0 = fabs((double )v.dy);
#line 174
  new_v.dy = (at_real )tmp___0;
#line 175
  tmp___1 = fabs((double )v.dz);
#line 175
  new_v.dz = (at_real )tmp___1;
  }
#line 176
  return (new_v);
}
}
#line 182 "vector.c"
at_real_coord Padd(at_real_coord const   coord1 , at_real_coord const   coord2 ) 
{ 
  at_real_coord sum ;

  {
#line 187
  sum.x = (at_real )(coord1.x + coord2.x);
#line 188
  sum.y = (at_real )(coord1.y + coord2.y);
#line 189
  sum.z = (at_real )(coord1.z + coord2.z);
#line 191
  return (sum);
}
}
#line 195 "vector.c"
at_real_coord Pmult_scalar(at_real_coord const   coord , at_real const   r ) 
{ 
  at_real_coord answer ;

  {
#line 200
  answer.x = (at_real )(coord.x * r);
#line 201
  answer.y = (at_real )(coord.y * r);
#line 202
  answer.z = (at_real )(coord.z * r);
#line 204
  return (answer);
}
}
#line 208 "vector.c"
vector_type Psubtract(at_real_coord const   c1 , at_real_coord const   c2 ) 
{ 
  vector_type v ;

  {
#line 213
  v.dx = (at_real )(c1.x - c2.x);
#line 214
  v.dy = (at_real )(c1.y - c2.y);
#line 215
  v.dz = (at_real )(c1.z - c2.z);
#line 217
  return (v);
}
}
#line 224 "vector.c"
vector_type IPsubtract(at_coord const   coord1 , at_coord const   coord2 ) 
{ 
  vector_type v ;

  {
#line 229
  v.dx = (at_real )((int const   )coord1.x - (int const   )coord2.x);
#line 230
  v.dy = (at_real )((int const   )coord1.y - (int const   )coord2.y);
#line 231
  v.dz = (at_real )0.0;
#line 233
  return (v);
}
}
#line 237 "vector.c"
at_coord IPsubtractP(at_coord const   c1 , at_coord const   c2 ) 
{ 
  at_coord c ;

  {
#line 242
  c.x = (unsigned short )((int const   )c1.x - (int const   )c2.x);
#line 243
  c.y = (unsigned short )((int const   )c1.y - (int const   )c2.y);
#line 245
  return (c);
}
}
#line 249 "vector.c"
at_coord IPadd(at_coord const   c1 , at_coord const   c2 ) 
{ 
  at_coord c ;

  {
#line 254
  c.x = (unsigned short )((int const   )c1.x + (int const   )c2.x);
#line 255
  c.y = (unsigned short )((int const   )c1.y + (int const   )c2.y);
#line 257
  return (c);
}
}
#line 261 "vector.c"
at_coord IPmult_scalar(at_coord const   c , int const   i ) 
{ 
  at_coord a ;

  {
#line 266
  a.x = (unsigned short )((int const   )c.x * i);
#line 267
  a.y = (unsigned short )((int const   )c.y * i);
#line 269
  return (a);
}
}
#line 273 "vector.c"
at_real_coord IPmult_real(at_coord const   c , at_real const   r ) 
{ 
  at_real_coord a ;

  {
#line 278
  a.x = (at_real )((at_real const   )c.x * r);
#line 279
  a.y = (at_real )((at_real const   )c.y * r);
#line 281
  return (a);
}
}
#line 285 "vector.c"
at_bool IPequal(at_coord const   c1 , at_coord const   c2 ) 
{ 


  {
#line 288
  if ((int const   )c1.x == (int const   )c2.x) {
#line 288
    if ((int const   )c1.y == (int const   )c2.y) {
#line 289
      return ((at_bool )1);
    } else {
#line 291
      return ((at_bool )0);
    }
  } else {
#line 291
    return ((at_bool )0);
  }
}
}
#line 294 "vector.c"
static at_real acos_d(at_real v , at_exception_type *excep ) 
{ 
  at_real a ;
  at_bool tmp ;
  at_bool tmp___0 ;
  int *tmp___1 ;
  double tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 299
  tmp___0 = epsilon_equal(v, (at_real )1.0);
  }
#line 299
  if (tmp___0) {
#line 300
    v = (at_real )1.0;
  } else {
    {
#line 301
    tmp = epsilon_equal(v, (at_real )(- 1.0));
    }
#line 301
    if (tmp) {
#line 302
      v = (at_real )(- 1.0);
    }
  }
  {
#line 304
  tmp___1 = __errno_location();
#line 304
  *tmp___1 = 0;
#line 305
  tmp___2 = acos((double )v);
#line 305
  a = (at_real )tmp___2;
#line 306
  tmp___5 = __errno_location();
  }
#line 306
  if (*tmp___5 == 34) {
    {
#line 308
    tmp___3 = __errno_location();
#line 308
    tmp___4 = strerror(*tmp___3);
#line 308
    at_exception_fatal(excep, (at_string const   )tmp___4);
    }
#line 309
    return ((at_real )0.0);
  } else {
    {
#line 306
    tmp___6 = __errno_location();
    }
#line 306
    if (*tmp___6 == 33) {
      {
#line 308
      tmp___3 = __errno_location();
#line 308
      tmp___4 = strerror(*tmp___3);
#line 308
      at_exception_fatal(excep, (at_string const   )tmp___4);
      }
#line 309
      return ((at_real )0.0);
    }
  }
#line 313
  return ((a * (at_real )180.0) / (at_real )3.14159265358979323846);
}
}
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 312 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "thin-image.h"
void thin_image(bitmap_type *image , color_type const   *bg , at_exception_type *exp ) ;
#line 19 "logreport.h"
FILE *at_log_file ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 42 "thin-image.c"
void thin3(bitmap_type *image , unsigned char *colour ) ;
#line 43
void thin1(bitmap_type *image , unsigned char colour ) ;
#line 60 "thin-image.c"
static unsigned int masks[4]  = {      128U,      2U,      32U,      8U};
#line 72 "thin-image.c"
static unsigned char todelete[512]  = 
#line 72
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1};
#line 106 "thin-image.c"
static color_type background  =    {(unsigned char)255, (unsigned char)255, (unsigned char)255};
#line 109 "thin-image.c"
void thin_image(bitmap_type *image , color_type const   *bg , at_exception_type *exp ) 
{ 
  long m ;
  long n ;
  long num_pixels ;
  bitmap_type bm ;
  unsigned int spp ;
  unsigned int width ;
  unsigned int height ;
  void *tmp ;
  Pixel *ptr ;
  Pixel bg_color ;
  Pixel p ;
  unsigned char *ptr___0 ;
  unsigned char bg_color___0 ;
  unsigned char c ;

  {
#line 118
  spp = image->np;
#line 118
  width = (unsigned int )image->width;
#line 118
  height = (unsigned int )image->height;
#line 123
  if (bg) {
#line 123
    background = (color_type )*bg;
  }
#line 125
  bm.height = image->height;
#line 126
  bm.width = image->width;
#line 127
  bm.np = image->np;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 128
    tmp = malloc((size_t )((height * width) * spp));
#line 128
    bm.bitmap = (unsigned char *)tmp;
    }
#line 128
    if (! bm.bitmap) {
      {
#line 128
      __assert_fail("bm.bitmap", "thin-image.c", 128U, "thin_image");
      }
    }
#line 128
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  memcpy((void */* __restrict  */)bm.bitmap, (void const   */* __restrict  */)image->bitmap,
         (size_t )((height * width) * spp));
#line 132
  num_pixels = (long )(height * width);
  }
  {
#line 135
  if (spp == 3U) {
#line 135
    goto case_3;
  }
#line 163
  if (spp == 1U) {
#line 163
    goto case_1;
  }
#line 186
  goto switch_default;
  case_3: /* CIL Label */ 
#line 137
  ptr = (Pixel *)bm.bitmap;
#line 139
  bg_color[0] = background.r;
#line 140
  bg_color[1] = background.g;
#line 141
  bg_color[2] = background.b;
#line 143
  n = num_pixels - 1L;
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 143
    if (! (n >= 0L)) {
#line 143
      goto while_break___0;
    }
    {
#line 147
    memcpy((void */* __restrict  */)(p), (void const   */* __restrict  */)(*(ptr + n)),
           sizeof(Pixel ));
    }
#line 148
    if ((int )p[0] == (int )bg_color[0]) {
#line 148
      if ((int )p[1] == (int )bg_color[1]) {
#line 148
        if (! ((int )p[2] == (int )bg_color[2])) {
#line 148
          goto _L___0;
        }
      } else {
#line 148
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 151
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 151
        if (at_log_file) {
          {
#line 151
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Thinning colour (%x, %x, %x)\n",
                  (int )p[0], (int )p[1], (int )p[2]);
          }
        }
#line 151
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 152
      m = n - 1L;
      {
#line 152
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 152
        if (! (m >= 0L)) {
#line 152
          goto while_break___2;
        }
#line 154
        if ((int )(*(ptr + m))[0] == (int )p[0]) {
#line 154
          if ((int )(*(ptr + m))[1] == (int )p[1]) {
#line 154
            if ((int )(*(ptr + m))[2] == (int )p[2]) {
              {
#line 155
              memcpy((void */* __restrict  */)(*(ptr + m)), (void const   */* __restrict  */)(bg_color),
                     sizeof(Pixel ));
              }
            }
          }
        }
#line 152
        m --;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 157
      thin3(image, (unsigned char *)(p));
      }
    }
#line 143
    n --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 160
  goto switch_break;
  case_1: /* CIL Label */ 
#line 165
  ptr___0 = bm.bitmap;
#line 168
  if ((int )background.r == (int )background.g) {
#line 168
    if ((int )background.g == (int )background.b) {
#line 169
      bg_color___0 = background.r;
    } else {
#line 170
      bg_color___0 = (unsigned char )((((double )background.r * 0.30 + (double )background.g * 0.59) + (double )background.b * 0.11) + 0.5);
    }
  } else {
#line 170
    bg_color___0 = (unsigned char )((((double )background.r * 0.30 + (double )background.g * 0.59) + (double )background.b * 0.11) + 0.5);
  }
#line 172
  n = num_pixels - 1L;
  {
#line 172
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 172
    if (! (n >= 0L)) {
#line 172
      goto while_break___3;
    }
#line 174
    c = *(ptr___0 + n);
#line 175
    if ((int )c != (int )bg_color___0) {
      {
#line 177
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 177
        if (at_log_file) {
          {
#line 177
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Thinning colour %x\n",
                  (int )c);
          }
        }
#line 177
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 178
      m = n - 1L;
      {
#line 178
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 178
        if (! (m >= 0L)) {
#line 178
          goto while_break___5;
        }
#line 179
        if ((int )*(ptr___0 + m) == (int )c) {
#line 179
          *(ptr___0 + m) = bg_color___0;
        }
#line 178
        m --;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 180
      thin1(image, c);
      }
    }
#line 172
    n --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 183
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 188
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 188
    if (at_log_file) {
      {
#line 188
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"thin_image: %u-plane images are not supported",
              spp);
      }
    }
#line 188
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 189
  at_exception_fatal(exp, (at_string const   )"thin_image: wrong plane images are passed");
  }
#line 190
  goto cleanup;
  switch_break: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 194
  free((void *)bm.bitmap);
  }
#line 195
  return;
}
}
#line 198 "thin-image.c"
void thin3(bitmap_type *image , unsigned char *colour ) 
{ 
  Pixel *ptr ;
  Pixel *y_ptr ;
  Pixel *y1_ptr ;
  Pixel bg_color ;
  unsigned int xsize ;
  unsigned int ysize ;
  unsigned int x ;
  unsigned int y ;
  unsigned int i ;
  unsigned int pc ;
  unsigned int count ;
  unsigned int p ;
  unsigned int q ;
  unsigned char *qb ;
  unsigned int m ;
  void *tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 205
  pc = 0U;
#line 206
  count = 1U;
#line 213
  bg_color[0] = background.r;
#line 214
  bg_color[1] = background.g;
#line 215
  bg_color[2] = background.b;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (at_log_file) {
      {
#line 217
      fputs((char const   */* __restrict  */)" Thinning image.....\n ", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 217
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  xsize = (unsigned int )image->width;
#line 219
  ysize = (unsigned int )image->height;
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 220
    tmp = malloc((unsigned long )xsize * sizeof(unsigned char ));
#line 220
    qb = (unsigned char *)tmp;
    }
#line 220
    if (! qb) {
      {
#line 220
      __assert_fail("qb", "thin-image.c", 220U, "thin3");
      }
    }
#line 220
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 221
  *(qb + (xsize - 1U)) = (unsigned char)0;
#line 222
  ptr = (Pixel *)image->bitmap;
  {
#line 224
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 224
    if (! count) {
#line 224
      goto while_break___1;
    }
#line 225
    pc ++;
#line 226
    count = 0U;
#line 228
    i = 0U;
    {
#line 228
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 228
      if (! (i < 4U)) {
#line 228
        goto while_break___2;
      }
#line 230
      m = masks[i];
#line 233
      if ((int )(*(ptr + 0))[0] == (int )*(colour + 0)) {
#line 233
        if ((int )(*(ptr + 0))[1] == (int )*(colour + 1)) {
#line 233
          if ((int )(*(ptr + 0))[2] == (int )*(colour + 2)) {
#line 233
            tmp___1 = 1;
          } else {
#line 233
            tmp___1 = 0;
          }
        } else {
#line 233
          tmp___1 = 0;
        }
      } else {
#line 233
        tmp___1 = 0;
      }
#line 233
      p = (unsigned int )tmp___1;
#line 234
      x = 0U;
      {
#line 234
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 234
        if (! (x < xsize - 1U)) {
#line 234
          goto while_break___3;
        }
#line 235
        if ((int )(*(ptr + (x + 1U)))[0] == (int )*(colour + 0)) {
#line 235
          if ((int )(*(ptr + (x + 1U)))[1] == (int )*(colour + 1)) {
#line 235
            if ((int )(*(ptr + (x + 1U)))[2] == (int )*(colour + 2)) {
#line 235
              tmp___2 = 1;
            } else {
#line 235
              tmp___2 = 0;
            }
          } else {
#line 235
            tmp___2 = 0;
          }
        } else {
#line 235
          tmp___2 = 0;
        }
#line 235
        p = ((p << 1) & 6U) | (unsigned int )tmp___2;
#line 235
        *(qb + x) = (unsigned char )p;
#line 234
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 239
      y_ptr = ptr;
#line 239
      y1_ptr = ptr + xsize;
#line 240
      y = 0U;
      {
#line 240
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 240
        if (! (y < ysize - 1U)) {
#line 240
          goto while_break___4;
        }
#line 242
        q = (unsigned int )*(qb + 0);
#line 243
        if ((int )(*(y1_ptr + 0))[0] == (int )*(colour + 0)) {
#line 243
          if ((int )(*(y1_ptr + 0))[1] == (int )*(colour + 1)) {
#line 243
            if ((int )(*(y1_ptr + 0))[2] == (int )*(colour + 2)) {
#line 243
              tmp___3 = 1;
            } else {
#line 243
              tmp___3 = 0;
            }
          } else {
#line 243
            tmp___3 = 0;
          }
        } else {
#line 243
          tmp___3 = 0;
        }
#line 243
        p = ((q << 2) & 216U) | (unsigned int )tmp___3;
#line 245
        x = 0U;
        {
#line 245
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 245
          if (! (x < xsize - 1U)) {
#line 245
            goto while_break___5;
          }
#line 246
          q = (unsigned int )*(qb + x);
#line 247
          if ((int )(*(y1_ptr + (x + 1U)))[0] == (int )*(colour + 0)) {
#line 247
            if ((int )(*(y1_ptr + (x + 1U)))[1] == (int )*(colour + 1)) {
#line 247
              if ((int )(*(y1_ptr + (x + 1U)))[2] == (int )*(colour + 2)) {
#line 247
                tmp___4 = 1;
              } else {
#line 247
                tmp___4 = 0;
              }
            } else {
#line 247
              tmp___4 = 0;
            }
          } else {
#line 247
            tmp___4 = 0;
          }
#line 247
          p = (((p << 1) & 438U) | ((q << 3) & 72U)) | (unsigned int )tmp___4;
#line 249
          *(qb + x) = (unsigned char )p;
#line 250
          if (i != 2U) {
#line 250
            goto _L;
          } else
#line 250
          if (x != 0U) {
            _L: /* CIL Label */ 
#line 250
            if ((p & m) == 0U) {
#line 250
              if (todelete[p]) {
                {
#line 251
                count ++;
#line 252
                memcpy((void */* __restrict  */)(*(y_ptr + x)), (void const   */* __restrict  */)(bg_color),
                       sizeof(Pixel ));
                }
              }
            }
          }
#line 245
          x ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 257
        p = (p << 1) & 438U;
#line 258
        if (i != 3U) {
#line 258
          if ((p & m) == 0U) {
#line 258
            if (todelete[p]) {
              {
#line 259
              count ++;
#line 260
              memcpy((void */* __restrict  */)(*(y_ptr + (xsize - 1U))), (void const   */* __restrict  */)(bg_color),
                     sizeof(Pixel ));
              }
            }
          }
        }
#line 240
        y ++;
#line 240
        y_ptr += xsize;
#line 240
        y1_ptr += xsize;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 264
      if (i != 1U) {
#line 267
        q = (unsigned int )*(qb + 0);
#line 268
        p = (q << 2) & 216U;
#line 270
        y_ptr = ptr + xsize * (ysize - 1U);
#line 271
        x = 0U;
        {
#line 271
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 271
          if (! (x < xsize)) {
#line 271
            goto while_break___6;
          }
#line 272
          q = (unsigned int )*(qb + x);
#line 273
          p = ((p << 1) & 438U) | ((q << 3) & 72U);
#line 274
          if (i != 2U) {
#line 274
            goto _L___0;
          } else
#line 274
          if (x != 0U) {
            _L___0: /* CIL Label */ 
#line 274
            if ((p & m) == 0U) {
#line 274
              if (todelete[p]) {
                {
#line 275
                count ++;
#line 276
                memcpy((void */* __restrict  */)(*(y_ptr + x)), (void const   */* __restrict  */)(bg_color),
                       sizeof(Pixel ));
                }
              }
            }
          }
#line 271
          x ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 228
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 281
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 281
      if (at_log_file) {
        {
#line 281
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"ThinImage: pass %d, %d pixels deleted\n",
                pc, count);
        }
      }
#line 281
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 283
  free((void *)qb);
  }
#line 284
  return;
}
}
#line 287 "thin-image.c"
void thin1(bitmap_type *image , unsigned char colour ) 
{ 
  unsigned char *ptr ;
  unsigned char *y_ptr ;
  unsigned char *y1_ptr ;
  unsigned char bg_color ;
  unsigned int xsize ;
  unsigned int ysize ;
  unsigned int x ;
  unsigned int y ;
  unsigned int i ;
  unsigned int pc ;
  unsigned int count ;
  unsigned int p ;
  unsigned int q ;
  unsigned char *qb ;
  unsigned int m ;
  void *tmp ;

  {
#line 294
  pc = 0U;
#line 295
  count = 1U;
#line 302
  if ((int )background.r == (int )background.g) {
#line 302
    if ((int )background.g == (int )background.b) {
#line 303
      bg_color = background.r;
    } else {
#line 304
      bg_color = (unsigned char )((((double )background.r * 0.30 + (double )background.g * 0.59) + (double )background.b * 0.11) + 0.5);
    }
  } else {
#line 304
    bg_color = (unsigned char )((((double )background.r * 0.30 + (double )background.g * 0.59) + (double )background.b * 0.11) + 0.5);
  }
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (at_log_file) {
      {
#line 306
      fputs((char const   */* __restrict  */)" Thinning image.....\n ", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 306
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  xsize = (unsigned int )image->width;
#line 308
  ysize = (unsigned int )image->height;
  {
#line 309
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 309
    tmp = malloc((unsigned long )xsize * sizeof(unsigned char ));
#line 309
    qb = (unsigned char *)tmp;
    }
#line 309
    if (! qb) {
      {
#line 309
      __assert_fail("qb", "thin-image.c", 309U, "thin1");
      }
    }
#line 309
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 310
  *(qb + (xsize - 1U)) = (unsigned char)0;
#line 311
  ptr = image->bitmap;
  {
#line 313
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 313
    if (! count) {
#line 313
      goto while_break___1;
    }
#line 314
    pc ++;
#line 315
    count = 0U;
#line 317
    i = 0U;
    {
#line 317
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 317
      if (! (i < 4U)) {
#line 317
        goto while_break___2;
      }
#line 319
      m = masks[i];
#line 322
      p = (unsigned int )((int )*(ptr + 0) == (int )colour);
#line 323
      x = 0U;
      {
#line 323
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 323
        if (! (x < xsize - 1U)) {
#line 323
          goto while_break___3;
        }
#line 324
        p = ((p << 1) & 6U) | (unsigned int )((int )*(ptr + (x + 1U)) == (int )colour);
#line 324
        *(qb + x) = (unsigned char )p;
#line 323
        x ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 327
      y_ptr = ptr;
#line 327
      y1_ptr = ptr + xsize;
#line 328
      y = 0U;
      {
#line 328
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 328
        if (! (y < ysize - 1U)) {
#line 328
          goto while_break___4;
        }
#line 330
        q = (unsigned int )*(qb + 0);
#line 331
        p = ((q << 2) & 216U) | (unsigned int )((int )*(y1_ptr + 0) == (int )colour);
#line 333
        x = 0U;
        {
#line 333
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 333
          if (! (x < xsize - 1U)) {
#line 333
            goto while_break___5;
          }
#line 334
          q = (unsigned int )*(qb + x);
#line 335
          p = (((p << 1) & 438U) | ((q << 3) & 72U)) | (unsigned int )((int )*(y1_ptr + (x + 1U)) == (int )colour);
#line 336
          *(qb + x) = (unsigned char )p;
#line 337
          if ((p & m) == 0U) {
#line 337
            if (todelete[p]) {
#line 338
              count ++;
#line 339
              *(y_ptr + x) = bg_color;
            }
          }
#line 333
          x ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 344
        p = (p << 1) & 438U;
#line 345
        if ((p & m) == 0U) {
#line 345
          if (todelete[p]) {
#line 346
            count ++;
#line 347
            *(y_ptr + (xsize - 1U)) = bg_color;
          }
        }
#line 328
        y ++;
#line 328
        y_ptr += xsize;
#line 328
        y1_ptr += xsize;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 352
      q = (unsigned int )*(qb + 0);
#line 353
      p = (q << 2) & 216U;
#line 355
      y_ptr = ptr + xsize * (ysize - 1U);
#line 356
      x = 0U;
      {
#line 356
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 356
        if (! (x < xsize)) {
#line 356
          goto while_break___6;
        }
#line 357
        q = (unsigned int )*(qb + x);
#line 358
        p = ((p << 1) & 438U) | ((q << 3) & 72U);
#line 359
        if ((p & m) == 0U) {
#line 359
          if (todelete[p]) {
#line 360
            count ++;
#line 361
            *(y_ptr + x) = bg_color;
          }
        }
#line 356
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 317
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 365
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 365
      if (at_log_file) {
        {
#line 365
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"thin1: pass %d, %d pixels deleted\n",
                pc, count);
        }
      }
#line 365
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 367
  free((void *)qb);
  }
#line 368
  return;
}
}
#line 6 "strgicmp.h"
at_bool strgicmp(char const   *s1 , char const   *s2 ) ;
#line 7
at_bool strgnicmp(char const   *s1 , char const   *s2 , size_t len ) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 8 "strgicmp.c"
at_bool strgicmp(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 10
  if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 11
    return ((at_bool )0);
  } else
#line 10
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 11
    return ((at_bool )0);
  }
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if ((int const   )*s1 != 0) {
#line 13
      if (! ((int const   )*s2 != 0)) {
#line 13
        goto while_break;
      }
    } else {
#line 13
      goto while_break;
    }
    {
#line 15
    tmp = tolower((int )*s1);
#line 15
    tmp___0 = tolower((int )*s2);
    }
#line 15
    if (tmp != tmp___0) {
#line 16
      goto while_break;
    }
#line 17
    s1 ++;
#line 18
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  if ((int const   )*s1 == 0) {
#line 20
    if ((int const   )*s2 == 0) {
#line 21
      return ((at_bool )1);
    } else {
#line 23
      return ((at_bool )0);
    }
  } else {
#line 23
    return ((at_bool )0);
  }
}
}
#line 26 "strgicmp.c"
at_bool strgnicmp(char const   *s1 , char const   *s2 , size_t len ) 
{ 
  long i ;
  int tmp ;
  int tmp___0 ;

  {
#line 28
  i = 0L;
#line 30
  if ((unsigned long )s1 == (unsigned long )((void *)0)) {
#line 31
    return ((at_bool )0);
  } else
#line 30
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
#line 31
    return ((at_bool )0);
  }
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if ((int const   )*s1 != 0) {
#line 33
      if (! ((int const   )*s2 != 0)) {
#line 33
        goto while_break;
      }
    } else {
#line 33
      goto while_break;
    }
    {
#line 35
    tmp = tolower((int )*s1);
#line 35
    tmp___0 = tolower((int )*s2);
    }
#line 35
    if (tmp != tmp___0) {
#line 36
      goto while_break;
    } else
#line 35
    if ((size_t )i == len) {
#line 36
      goto while_break;
    }
#line 37
    s1 ++;
#line 38
    s2 ++;
#line 39
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  if ((int const   )*s1 == 0) {
#line 41
    if ((int const   )*s2 == 0) {
#line 42
      return ((at_bool )1);
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if (len == (size_t )i) {
#line 42
    return ((at_bool )1);
  } else {
#line 44
    return ((at_bool )0);
  }
}
}
#line 23 "logreport.h"
void flush_log_output(void) ;
#line 549 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 30 "spline.h"
void print_spline(FILE *f , spline_type s ) ;
#line 33
at_real_coord evaluate_spline(spline_type s , at_real t ) ;
#line 64
spline_list_type *new_spline_list(void) ;
#line 65
spline_list_type empty_spline_list(void) ;
#line 66
spline_list_type *new_spline_list_with_spline(spline_type spline ) ;
#line 67
void free_spline_list(spline_list_type spline_list ) ;
#line 70
void append_spline(spline_list_type *l , spline_type s ) ;
#line 73
void concat_spline_lists(spline_list_type *s1 , spline_list_type s2 ) ;
#line 85
at_spline_list_array_type new_spline_list_array(void) ;
#line 86
void append_spline_list(at_spline_list_array_type *l , spline_list_type s ) ;
#line 87
void free_spline_list_array(at_spline_list_array_type *spline_list_array ) ;
#line 16 "spline.c"
void print_spline(FILE *f , spline_type s ) 
{ 


  {
#line 19
  if (! ((unsigned int )s.degree == 1U)) {
#line 19
    if (! ((unsigned int )s.degree == 3U)) {
      {
#line 19
      __assert_fail("SPLINE_DEGREE (s) == LINEARTYPE || SPLINE_DEGREE (s) == CUBICTYPE",
                    "spline.c", 19U, "print_spline");
      }
    }
  }
#line 21
  if ((unsigned int )s.degree == 1U) {
    {
#line 22
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(%.3f,%.3f)--(%.3f,%.3f).\n",
            (double )s.v[0].x, (double )s.v[0].y, (double )s.v[3].x, (double )s.v[3].y);
    }
  } else
#line 26
  if ((unsigned int )s.degree == 3U) {
    {
#line 27
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"(%.3f,%.3f)..ctrls(%.3f,%.3f)&(%.3f,%.3f)..(%.3f,%.3f).\n",
            (double )s.v[0].x, (double )s.v[0].y, (double )s.v[1].x, (double )s.v[1].y,
            (double )s.v[2].x, (double )s.v[2].y, (double )s.v[3].x, (double )s.v[3].y);
    }
  }
#line 32
  return;
}
}
#line 39 "spline.c"
at_real_coord evaluate_spline(spline_type s , at_real t ) 
{ 
  spline_type V[4] ;
  int i ;
  int j ;
  at_real one_minus_t ;
  polynomial_degree degree ;
  at_real_coord t1 ;
  at_real_coord tmp ;
  at_real_coord t2 ;
  at_real_coord tmp___0 ;
  at_real_coord temp ;
  at_real_coord tmp___1 ;

  {
#line 44
  one_minus_t = (at_real )1.0 - t;
#line 45
  degree = s.degree;
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! ((unsigned int )i <= (unsigned int )degree)) {
#line 47
      goto while_break;
    }
#line 49
    V[0].v[i].x = s.v[i].x;
#line 50
    V[0].v[i].y = s.v[i].y;
#line 51
    V[0].v[i].z = s.v[i].z;
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  j = 1;
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    if (! ((unsigned int )j <= (unsigned int )degree)) {
#line 54
      goto while_break___0;
    }
#line 55
    i = 0;
    {
#line 55
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 55
      if (! ((unsigned int )i <= (unsigned int )degree - (unsigned int )j)) {
#line 55
        goto while_break___1;
      }
      {
#line 57
      tmp = Pmult_scalar((at_real_coord const   )V[j - 1].v[i], (at_real const   )one_minus_t);
#line 57
      t1 = tmp;
#line 58
      tmp___0 = Pmult_scalar((at_real_coord const   )V[j - 1].v[i + 1], (at_real const   )t);
#line 58
      t2 = tmp___0;
#line 59
      tmp___1 = Padd((at_real_coord const   )t1, (at_real_coord const   )t2);
#line 59
      temp = tmp___1;
#line 60
      V[j].v[i].x = temp.x;
#line 61
      V[j].v[i].y = temp.y;
#line 62
      V[j].v[i].z = temp.z;
#line 55
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 54
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 65
  return (V[degree].v[0]);
}
}
#line 71 "spline.c"
spline_list_type *new_spline_list(void) 
{ 
  spline_list_type *answer ;
  void *tmp ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    tmp = malloc(sizeof(spline_list_type ));
#line 76
    answer = (spline_list_type *)tmp;
    }
#line 76
    if (! answer) {
      {
#line 76
      __assert_fail("answer", "spline.c", 76U, "new_spline_list");
      }
    }
#line 76
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  *answer = empty_spline_list();
  }
#line 78
  return (answer);
}
}
#line 81 "spline.c"
spline_list_type empty_spline_list(void) 
{ 
  spline_list_type answer ;

  {
#line 85
  answer.data = (at_spline_type *)((void *)0);
#line 86
  answer.length = 0U;
#line 87
  return (answer);
}
}
#line 92 "spline.c"
spline_list_type *new_spline_list_with_spline(spline_type spline ) 
{ 
  spline_list_type *answer ;
  void *tmp ;

  {
  {
#line 97
  answer = new_spline_list();
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    tmp = malloc(sizeof(spline_type ));
#line 98
    answer->data = (at_spline_type *)tmp;
    }
#line 98
    if (! answer->data) {
      {
#line 98
      __assert_fail("((*answer).data)", "spline.c", 98U, "new_spline_list_with_spline");
      }
    }
#line 98
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  *(answer->data + 0) = spline;
#line 100
  answer->length = 1U;
#line 102
  return (answer);
}
}
#line 110 "spline.c"
void free_spline_list(spline_list_type spline_list ) 
{ 


  {
#line 113
  if ((unsigned long )spline_list.data != (unsigned long )((void *)0)) {
    {
#line 114
    free((void *)spline_list.data);
    }
  }
#line 115
  return;
}
}
#line 120 "spline.c"
void append_spline(spline_list_type *l , spline_type s ) 
{ 
  at_address new_mem ;
  void *tmp___0 ;
  void *tmp___2 ;

  {
#line 123
  if (! ((unsigned long )l != (unsigned long )((void *)0))) {
    {
#line 123
    __assert_fail("l != NULL", "spline.c", 123U, "append_spline");
    }
  }
#line 125
  (l->length) ++;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if ((unsigned long )l->data == (unsigned long )((void *)0)) {
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 126
        tmp___0 = malloc((unsigned long )l->length * sizeof(spline_type ));
#line 126
        new_mem = tmp___0;
        }
#line 126
        if (! new_mem) {
          {
#line 126
          __assert_fail("new_mem", "spline.c", 126U, "append_spline");
          }
        }
#line 126
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 126
      tmp___2 = realloc((void *)l->data, (unsigned long )l->length * sizeof(spline_type ));
#line 126
      new_mem = tmp___2;
      }
#line 126
      if (! new_mem) {
        {
#line 126
        __assert_fail("new_mem", "spline.c", 126U, "append_spline");
        }
      }
    }
#line 126
    l->data = (at_spline_type *)new_mem;
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  *(l->data + (l->length - 1U)) = s;
#line 128
  return;
}
}
#line 134 "spline.c"
void concat_spline_lists(spline_list_type *s1 , spline_list_type s2 ) 
{ 
  unsigned int this_spline ;
  unsigned int new_length ;
  at_address new_mem ;
  void *tmp___0 ;
  void *tmp___2 ;
  unsigned int tmp___4 ;

  {
#line 140
  if (! ((unsigned long )s1 != (unsigned long )((void *)0))) {
    {
#line 140
    __assert_fail("s1 != NULL", "spline.c", 140U, "concat_spline_lists");
    }
  }
#line 142
  new_length = s1->length + s2.length;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if ((unsigned long )s1->data == (unsigned long )((void *)0)) {
      {
#line 144
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 144
        tmp___0 = malloc((unsigned long )new_length * sizeof(spline_type ));
#line 144
        new_mem = tmp___0;
        }
#line 144
        if (! new_mem) {
          {
#line 144
          __assert_fail("new_mem", "spline.c", 144U, "concat_spline_lists");
          }
        }
#line 144
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 144
      tmp___2 = realloc((void *)s1->data, (unsigned long )new_length * sizeof(spline_type ));
#line 144
      new_mem = tmp___2;
      }
#line 144
      if (! new_mem) {
        {
#line 144
        __assert_fail("new_mem", "spline.c", 144U, "concat_spline_lists");
        }
      }
    }
#line 144
    s1->data = (at_spline_type *)new_mem;
#line 144
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  this_spline = 0U;
  {
#line 146
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 146
    if (! (this_spline < s2.length)) {
#line 146
      goto while_break___1;
    }
#line 147
    tmp___4 = s1->length;
#line 147
    (s1->length) ++;
#line 147
    *(s1->data + tmp___4) = *(s2.data + this_spline);
#line 146
    this_spline ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 154 "spline.c"
at_spline_list_array_type new_spline_list_array(void) 
{ 
  at_spline_list_array_type answer ;

  {
#line 159
  answer.data = (at_spline_list_type *)((void *)0);
#line 160
  answer.length = 0U;
#line 162
  return (answer);
}
}
#line 168 "spline.c"
void free_spline_list_array(at_spline_list_array_type *spline_list_array ) 
{ 
  unsigned int this_list ;

  {
#line 173
  this_list = 0U;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (this_list < spline_list_array->length)) {
#line 173
      goto while_break;
    }
    {
#line 176
    free_spline_list(*(spline_list_array->data + this_list));
#line 173
    this_list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  if ((unsigned long )spline_list_array->data != (unsigned long )((void *)0)) {
    {
#line 179
    free((void *)spline_list_array->data);
    }
  }
  {
#line 181
  flush_log_output();
  }
#line 182
  return;
}
}
#line 187 "spline.c"
void append_spline_list(at_spline_list_array_type *l , spline_list_type s ) 
{ 
  at_address new_mem ;
  void *tmp ;
  void *tmp___1 ;

  {
#line 190
  (l->length) ++;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if ((unsigned long )l->data == (unsigned long )((void *)0)) {
      {
#line 191
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 191
        tmp = malloc((unsigned long )l->length * sizeof(spline_list_type ));
#line 191
        new_mem = tmp;
        }
#line 191
        if (! new_mem) {
          {
#line 191
          __assert_fail("new_mem", "spline.c", 191U, "append_spline_list");
          }
        }
#line 191
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 191
      tmp___1 = realloc((void *)l->data, (unsigned long )l->length * sizeof(spline_list_type ));
#line 191
      new_mem = tmp___1;
      }
#line 191
      if (! new_mem) {
        {
#line 191
        __assert_fail("new_mem", "spline.c", 191U, "append_spline_list");
        }
      }
    }
#line 191
    l->data = (at_spline_list_type *)new_mem;
#line 191
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  *(l->data + (l->length - 1U)) = s;
#line 193
  return;
}
}
#line 27 "exception.h"
at_bool at_exception_got_fatal(at_exception_type *exception ) ;
#line 26 "bitmap.h"
bitmap_type new_bitmap(unsigned short width , unsigned short height ) ;
#line 29
void free_bitmap(bitmap_type *b ) ;
#line 16 "color.h"
color_type GET_COLOR(at_bitmap_type bitmap , unsigned int row , unsigned int col ) ;
#line 52 "pxl-outline.h"
pixel_outline_list_type find_outline_pixels(bitmap_type bitmap , color_type *bg_color ,
                                            void (*notify_progress)(at_real percentage ,
                                                                    at_address client_data ) ,
                                            at_address progress_data , at_bool (*test_cancel)(at_address client_data ) ,
                                            at_address testcancel_data , at_exception_type *exp ) ;
#line 59
pixel_outline_list_type find_centerline_pixels(bitmap_type bitmap , color_type bg_color ,
                                               void (*notify_progress)(at_real percentage ,
                                                                       at_address client_data ) ,
                                               at_address progress_data , at_bool (*test_cancel)(at_address client_data ) ,
                                               at_address testcancel_data , at_exception_type *exp ) ;
#line 66
void free_pixel_outline_list(pixel_outline_list_type *outline_list ) ;
#line 59 "pxl-outline.c"
static pixel_outline_type find_one_outline(bitmap_type bitmap , edge_type original_edge ,
                                           unsigned short original_row , unsigned short original_col ,
                                           bitmap_type *marked , at_bool clockwise ,
                                           at_bool ignore___0 , at_exception_type *exp ) ;
#line 61
static pixel_outline_type find_one_centerline(bitmap_type bitmap , direction_type search_dir ,
                                              unsigned short original_row , unsigned short original_col ,
                                              bitmap_type *marked ) ;
#line 63
static void append_pixel_outline(pixel_outline_list_type *outline_list , pixel_outline_type outline ) ;
#line 65
static pixel_outline_type new_pixel_outline(void) ;
#line 66
static void free_pixel_outline(pixel_outline_type *outline ) ;
#line 67
static void concat_pixel_outline(pixel_outline_type *o1 , pixel_outline_type const   *o2 ) ;
#line 69
static void append_outline_pixel(pixel_outline_type *o , at_coord c ) ;
#line 70
static at_bool is_marked_edge(edge_type edge , unsigned short row , unsigned short col ,
                              bitmap_type marked ) ;
#line 71
static at_bool is_outline_edge(edge_type edge , bitmap_type bitmap , unsigned short row ,
                               unsigned short col , color_type color , at_exception_type *exp ) ;
#line 73
static at_bool is_unmarked_outline_edge(unsigned short row , unsigned short col ,
                                        edge_type edge , bitmap_type bitmap , bitmap_type marked ,
                                        color_type color , at_exception_type *exp ) ;
#line 76
static void mark_edge(edge_type edge , unsigned short row , unsigned short col , bitmap_type *marked ) ;
#line 79
static at_bool is_marked_dir(unsigned short row , unsigned short col , direction_type dir ,
                             bitmap_type marked ) ;
#line 80
static at_bool is_other_dir_marked(unsigned short row , unsigned short col , direction_type dir ,
                                   bitmap_type marked ) ;
#line 81
static void mark_dir(unsigned short row , unsigned short col , direction_type dir ,
                     bitmap_type *marked ) ;
#line 82
static at_bool next_unmarked_pixel(unsigned short *row , unsigned short *col , direction_type *dir ,
                                   bitmap_type bitmap , bitmap_type *marked ) ;
#line 85
at_bool is_valid_dir(unsigned short row , unsigned short col , direction_type dir ,
                     bitmap_type bitmap , bitmap_type marked ) ;
#line 87
static at_coord next_point(bitmap_type bitmap , edge_type *edge , unsigned short *row ,
                           unsigned short *col , color_type color , at_bool clockwise ,
                           bitmap_type marked , at_exception_type *exp ) ;
#line 89
static unsigned int num_neighbors(unsigned short row , unsigned short col , bitmap_type bitmap ) ;
#line 97 "pxl-outline.c"
pixel_outline_list_type find_outline_pixels(bitmap_type bitmap , color_type *bg_color ,
                                            void (*notify_progress)(at_real percentage ,
                                                                    at_address client_data ) ,
                                            at_address progress_data , at_bool (*test_cancel)(at_address client_data ) ,
                                            at_address testcancel_data , at_exception_type *exp ) 
{ 
  pixel_outline_list_type outline_list ;
  unsigned short row ;
  unsigned short col ;
  bitmap_type marked ;
  bitmap_type tmp ;
  unsigned int max_progress ;
  edge_type edge ;
  color_type color ;
  at_bool is_background ;
  pixel_outline_type outline ;
  at_bool tmp___0 ;
  at_bool tmp___1 ;
  at_bool tmp___2 ;
  int tmp___3 ;
  at_bool tmp___4 ;
  pixel_outline_type outline___0 ;
  at_bool tmp___5 ;
  at_bool tmp___6 ;
  at_bool tmp___7 ;
  at_bool tmp___8 ;
  at_bool tmp___9 ;
  at_bool tmp___10 ;
  at_bool tmp___11 ;

  {
  {
#line 105
  tmp = new_bitmap(bitmap.width, bitmap.height);
#line 105
  marked = tmp;
#line 106
  max_progress = (unsigned int )((int )bitmap.height * (int )bitmap.width);
#line 108
  outline_list.length = 0U;
#line 109
  outline_list.data = (pixel_outline_type *)((void *)0);
#line 111
  row = (unsigned short)0;
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((int )row < (int )bitmap.height)) {
#line 111
      goto while_break;
    }
#line 113
    col = (unsigned short)0;
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 113
      if (! ((int )col < (int )bitmap.width)) {
#line 113
        goto while_break___0;
      }
#line 119
      if (notify_progress) {
        {
#line 120
        (*notify_progress)((at_real )((int )row * (int )bitmap.width + (int )col) / ((at_real )max_progress * (at_real )3.0),
                           progress_data);
        }
      }
      {
#line 125
      color = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
      }
#line 126
      if (bg_color) {
#line 126
        if ((int )color.r == (int )bg_color->r) {
#line 126
          if ((int )color.g == (int )bg_color->g) {
#line 126
            if ((int )color.b == (int )bg_color->b) {
#line 126
              tmp___3 = 1;
            } else {
#line 126
              tmp___3 = 0;
            }
          } else {
#line 126
            tmp___3 = 0;
          }
        } else {
#line 126
          tmp___3 = 0;
        }
      } else {
#line 126
        tmp___3 = 0;
      }
#line 126
      is_background = (at_bool )tmp___3;
#line 126
      if (is_background) {
        _L: /* CIL Label */ 
        {
#line 145
        tmp___2 = at_exception_got_fatal(exp);
        }
#line 145
        if (tmp___2) {
#line 145
          goto cleanup;
        }
      } else {
        {
#line 126
        edge = (edge_type )1;
#line 126
        tmp___4 = is_unmarked_outline_edge(row, col, edge, bitmap, marked, color,
                                           exp);
        }
#line 126
        if (tmp___4) {
          {
#line 132
          tmp___0 = at_exception_got_fatal(exp);
          }
#line 132
          if (tmp___0) {
#line 132
            goto cleanup;
          }
          {
#line 134
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 134
            if (at_log_file) {
              {
#line 134
              fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"#%u: (counterclockwise)",
                      outline_list.length);
              }
            }
#line 134
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 136
          outline = find_one_outline(bitmap, edge, row, col, & marked, (at_bool )0,
                                     (at_bool )0, exp);
#line 137
          tmp___1 = at_exception_got_fatal(exp);
          }
#line 137
          if (tmp___1) {
#line 137
            goto cleanup;
          }
          {
#line 139
          outline.clockwise = (at_bool )0;
#line 140
          append_pixel_outline(& outline_list, outline);
          }
          {
#line 142
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 142
            if (at_log_file) {
              {
#line 142
              fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" [%u].\n",
                      outline.length);
              }
            }
#line 142
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 126
          goto _L;
        }
      }
#line 149
      if ((int )row != 0) {
        {
#line 151
        color = GET_COLOR(bitmap, (unsigned int )((int )row - 1), (unsigned int )col);
        }
#line 152
        if (bg_color) {
#line 152
          if ((int )color.r == (int )bg_color->r) {
#line 152
            if ((int )color.g == (int )bg_color->g) {
#line 152
              if ((int )color.b == (int )bg_color->b) {
                _L___0: /* CIL Label */ 
                {
#line 182
                tmp___8 = at_exception_got_fatal(exp);
                }
#line 182
                if (tmp___8) {
#line 182
                  goto cleanup;
                }
              } else {
#line 152
                goto _L___1;
              }
            } else {
#line 152
              goto _L___1;
            }
          } else {
#line 152
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 152
          edge = (edge_type )3;
#line 152
          tmp___9 = is_unmarked_outline_edge((unsigned short )((int )row - 1), col,
                                             edge, bitmap, marked, color, exp);
          }
#line 152
          if (tmp___9) {
            {
#line 158
            tmp___5 = at_exception_got_fatal(exp);
            }
#line 158
            if (tmp___5) {
#line 158
              goto cleanup;
            }
#line 161
            if (is_background) {
              {
#line 163
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 163
                if (at_log_file) {
                  {
#line 163
                  fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"#%u: (clockwise)",
                          outline_list.length);
                  }
                }
#line 163
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 165
              outline___0 = find_one_outline(bitmap, edge, (unsigned short )((int )row - 1),
                                             col, & marked, (at_bool )1, (at_bool )0,
                                             exp);
#line 167
              tmp___6 = at_exception_got_fatal(exp);
              }
#line 167
              if (tmp___6) {
#line 167
                goto cleanup;
              }
              {
#line 169
              outline___0.clockwise = (at_bool )1;
#line 170
              append_pixel_outline(& outline_list, outline___0);
              }
              {
#line 172
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 172
                if (at_log_file) {
                  {
#line 172
                  fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" [%u].\n",
                          outline___0.length);
                  }
                }
#line 172
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
              {
#line 176
              outline___0 = find_one_outline(bitmap, edge, (unsigned short )((int )row - 1),
                                             col, & marked, (at_bool )1, (at_bool )1,
                                             exp);
#line 178
              tmp___7 = at_exception_got_fatal(exp);
              }
#line 178
              if (tmp___7) {
#line 178
                goto cleanup;
              }
            }
          } else {
#line 152
            goto _L___0;
          }
        }
      }
#line 184
      if (test_cancel) {
        {
#line 184
        tmp___10 = (*test_cancel)(testcancel_data);
        }
#line 184
        if (tmp___10) {
          {
#line 186
          free_pixel_outline_list(& outline_list);
          }
#line 187
          goto cleanup;
        }
      }
#line 113
      col = (unsigned short )((int )col + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 111
    row = (unsigned short )((int )row + 1);
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 192
  free_bitmap(& marked);
#line 193
  flush_log_output();
#line 194
  tmp___11 = at_exception_got_fatal(exp);
  }
#line 194
  if (tmp___11) {
    {
#line 195
    free_pixel_outline_list(& outline_list);
    }
  }
#line 196
  return (outline_list);
}
}
#line 204 "pxl-outline.c"
static pixel_outline_type find_one_outline(bitmap_type bitmap , edge_type original_edge ,
                                           unsigned short original_row , unsigned short original_col ,
                                           bitmap_type *marked , at_bool clockwise ,
                                           at_bool ignore___0 , at_exception_type *exp ) 
{ 
  pixel_outline_type outline ;
  unsigned short row ;
  unsigned short col ;
  edge_type edge ;
  at_coord pos ;
  int tmp ;
  int tmp___0 ;
  at_bool tmp___1 ;
  at_bool tmp___2 ;

  {
#line 211
  row = original_row;
#line 211
  col = original_col;
#line 212
  edge = original_edge;
#line 215
  if ((unsigned int )edge == 0U) {
#line 215
    tmp = 1;
  } else
#line 215
  if ((unsigned int )edge == 3U) {
#line 215
    tmp = 1;
  } else {
#line 215
    tmp = 0;
  }
#line 215
  pos.x = (unsigned short )((int )col + tmp);
#line 216
  if ((unsigned int )edge == 1U) {
#line 216
    tmp___0 = 1;
  } else
#line 216
  if ((unsigned int )edge == 0U) {
#line 216
    tmp___0 = 1;
  } else {
#line 216
    tmp___0 = 0;
  }
#line 216
  pos.y = (unsigned short )((((int )bitmap.height - (int )row) - 1) + tmp___0);
#line 218
  if (! ignore___0) {
    {
#line 219
    outline = new_pixel_outline();
    }
  }
  {
#line 220
  outline.color = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! ignore___0) {
      {
#line 227
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 227
        if (at_log_file) {
          {
#line 227
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" (%d,%d)",
                  (int )pos.x, (int )pos.y);
          }
        }
#line 227
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 228
      append_outline_pixel(& outline, pos);
      }
    }
    {
#line 231
    mark_edge(edge, row, col, marked);
#line 232
    pos = next_point(bitmap, & edge, & row, & col, outline.color, clockwise, *marked,
                     exp);
#line 233
    tmp___1 = at_exception_got_fatal(exp);
    }
#line 233
    if (tmp___1) {
#line 233
      goto cleanup;
    }
#line 222
    if (! ((unsigned int )edge != 4U)) {
#line 222
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 238
  tmp___2 = at_exception_got_fatal(exp);
  }
#line 238
  if (tmp___2) {
    {
#line 239
    free_pixel_outline(& outline);
    }
  }
#line 240
  return (outline);
}
}
#line 243 "pxl-outline.c"
at_bool is_valid_dir(unsigned short row , unsigned short col , direction_type dir ,
                     bitmap_type bitmap , bitmap_type marked ) 
{ 
  at_bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  color_type tmp___42 ;
  color_type tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  color_type tmp___58 ;
  color_type tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  color_type tmp___74 ;
  color_type tmp___75 ;
  int tmp___76 ;

  {
  {
#line 246
  tmp = is_marked_dir(row, col, dir, marked);
  }
#line 246
  if (tmp) {
#line 246
    tmp___76 = 0;
  } else {
#line 246
    if ((unsigned int )dir % 2U != 0U) {
#line 246
      if ((unsigned int )dir - 1U == 0U) {
#line 246
        tmp___1 = -1;
      } else {
#line 246
        if ((unsigned int )dir - 1U == 4U) {
#line 246
          tmp___0 = 1;
        } else {
#line 246
          tmp___0 = 0;
        }
#line 246
        tmp___1 = tmp___0;
      }
#line 246
      if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 246
        tmp___3 = -1;
      } else {
#line 246
        if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 246
          tmp___2 = 1;
        } else {
#line 246
          tmp___2 = 0;
        }
#line 246
        tmp___3 = tmp___2;
      }
#line 246
      tmp___6 = tmp___1 + tmp___3;
    } else {
#line 246
      if ((unsigned int )dir == 0U) {
#line 246
        tmp___5 = -1;
      } else {
#line 246
        if ((unsigned int )dir == 4U) {
#line 246
          tmp___4 = 1;
        } else {
#line 246
          tmp___4 = 0;
        }
#line 246
        tmp___5 = tmp___4;
      }
#line 246
      tmp___6 = tmp___5;
    }
#line 246
    if (tmp___6 + (int )row > 0) {
#line 246
      if ((unsigned int )dir % 2U != 0U) {
#line 246
        if ((unsigned int )dir - 1U == 2U) {
#line 246
          tmp___8 = -1;
        } else {
#line 246
          if ((unsigned int )dir - 1U == 6U) {
#line 246
            tmp___7 = 1;
          } else {
#line 246
            tmp___7 = 0;
          }
#line 246
          tmp___8 = tmp___7;
        }
#line 246
        if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 246
          tmp___10 = -1;
        } else {
#line 246
          if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 246
            tmp___9 = 1;
          } else {
#line 246
            tmp___9 = 0;
          }
#line 246
          tmp___10 = tmp___9;
        }
#line 246
        tmp___13 = tmp___8 + tmp___10;
      } else {
#line 246
        if ((unsigned int )dir == 2U) {
#line 246
          tmp___12 = -1;
        } else {
#line 246
          if ((unsigned int )dir == 6U) {
#line 246
            tmp___11 = 1;
          } else {
#line 246
            tmp___11 = 0;
          }
#line 246
          tmp___12 = tmp___11;
        }
#line 246
        tmp___13 = tmp___12;
      }
#line 246
      if (tmp___13 + (int )col > 0) {
#line 246
        if ((unsigned int )dir % 2U != 0U) {
#line 246
          if ((unsigned int )dir - 1U == 0U) {
#line 246
            tmp___15 = -1;
          } else {
#line 246
            if ((unsigned int )dir - 1U == 4U) {
#line 246
              tmp___14 = 1;
            } else {
#line 246
              tmp___14 = 0;
            }
#line 246
            tmp___15 = tmp___14;
          }
#line 246
          if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 246
            tmp___17 = -1;
          } else {
#line 246
            if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 246
              tmp___16 = 1;
            } else {
#line 246
              tmp___16 = 0;
            }
#line 246
            tmp___17 = tmp___16;
          }
#line 246
          tmp___20 = tmp___15 + tmp___17;
        } else {
#line 246
          if ((unsigned int )dir == 0U) {
#line 246
            tmp___19 = -1;
          } else {
#line 246
            if ((unsigned int )dir == 4U) {
#line 246
              tmp___18 = 1;
            } else {
#line 246
              tmp___18 = 0;
            }
#line 246
            tmp___19 = tmp___18;
          }
#line 246
          tmp___20 = tmp___19;
        }
#line 246
        if (tmp___20 + (int )row < (int )bitmap.height) {
#line 246
          if ((unsigned int )dir % 2U != 0U) {
#line 246
            if ((unsigned int )dir - 1U == 2U) {
#line 246
              tmp___22 = -1;
            } else {
#line 246
              if ((unsigned int )dir - 1U == 6U) {
#line 246
                tmp___21 = 1;
              } else {
#line 246
                tmp___21 = 0;
              }
#line 246
              tmp___22 = tmp___21;
            }
#line 246
            if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 246
              tmp___24 = -1;
            } else {
#line 246
              if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 246
                tmp___23 = 1;
              } else {
#line 246
                tmp___23 = 0;
              }
#line 246
              tmp___24 = tmp___23;
            }
#line 246
            tmp___27 = tmp___22 + tmp___24;
          } else {
#line 246
            if ((unsigned int )dir == 2U) {
#line 246
              tmp___26 = -1;
            } else {
#line 246
              if ((unsigned int )dir == 6U) {
#line 246
                tmp___25 = 1;
              } else {
#line 246
                tmp___25 = 0;
              }
#line 246
              tmp___26 = tmp___25;
            }
#line 246
            tmp___27 = tmp___26;
          }
#line 246
          if (tmp___27 + (int )col < (int )bitmap.width) {
#line 246
            if ((unsigned int )dir % 2U != 0U) {
#line 246
              if ((unsigned int )dir - 1U == 2U) {
#line 246
                tmp___29 = -1;
              } else {
#line 246
                if ((unsigned int )dir - 1U == 6U) {
#line 246
                  tmp___28 = 1;
                } else {
#line 246
                  tmp___28 = 0;
                }
#line 246
                tmp___29 = tmp___28;
              }
#line 246
              if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 246
                tmp___31 = -1;
              } else {
#line 246
                if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 246
                  tmp___30 = 1;
                } else {
#line 246
                  tmp___30 = 0;
                }
#line 246
                tmp___31 = tmp___30;
              }
#line 246
              tmp___34 = tmp___29 + tmp___31;
            } else {
#line 246
              if ((unsigned int )dir == 2U) {
#line 246
                tmp___33 = -1;
              } else {
#line 246
                if ((unsigned int )dir == 6U) {
#line 246
                  tmp___32 = 1;
                } else {
#line 246
                  tmp___32 = 0;
                }
#line 246
                tmp___33 = tmp___32;
              }
#line 246
              tmp___34 = tmp___33;
            }
#line 246
            if ((unsigned int )dir % 2U != 0U) {
#line 246
              if ((unsigned int )dir - 1U == 0U) {
#line 246
                tmp___36 = -1;
              } else {
#line 246
                if ((unsigned int )dir - 1U == 4U) {
#line 246
                  tmp___35 = 1;
                } else {
#line 246
                  tmp___35 = 0;
                }
#line 246
                tmp___36 = tmp___35;
              }
#line 246
              if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 246
                tmp___38 = -1;
              } else {
#line 246
                if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 246
                  tmp___37 = 1;
                } else {
#line 246
                  tmp___37 = 0;
                }
#line 246
                tmp___38 = tmp___37;
              }
#line 246
              tmp___41 = tmp___36 + tmp___38;
            } else {
#line 246
              if ((unsigned int )dir == 0U) {
#line 246
                tmp___40 = -1;
              } else {
#line 246
                if ((unsigned int )dir == 4U) {
#line 246
                  tmp___39 = 1;
                } else {
#line 246
                  tmp___39 = 0;
                }
#line 246
                tmp___40 = tmp___39;
              }
#line 246
              tmp___41 = tmp___40;
            }
            {
#line 246
            tmp___42 = GET_COLOR(bitmap, (unsigned int )(tmp___41 + (int )row), (unsigned int )(tmp___34 + (int )col));
#line 246
            tmp___43 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
            }
#line 246
            if ((int )tmp___42.r == (int )tmp___43.r) {
#line 246
              if ((unsigned int )dir % 2U != 0U) {
#line 246
                if ((unsigned int )dir - 1U == 2U) {
#line 246
                  tmp___45 = -1;
                } else {
#line 246
                  if ((unsigned int )dir - 1U == 6U) {
#line 246
                    tmp___44 = 1;
                  } else {
#line 246
                    tmp___44 = 0;
                  }
#line 246
                  tmp___45 = tmp___44;
                }
#line 246
                if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 246
                  tmp___47 = -1;
                } else {
#line 246
                  if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 246
                    tmp___46 = 1;
                  } else {
#line 246
                    tmp___46 = 0;
                  }
#line 246
                  tmp___47 = tmp___46;
                }
#line 246
                tmp___50 = tmp___45 + tmp___47;
              } else {
#line 246
                if ((unsigned int )dir == 2U) {
#line 246
                  tmp___49 = -1;
                } else {
#line 246
                  if ((unsigned int )dir == 6U) {
#line 246
                    tmp___48 = 1;
                  } else {
#line 246
                    tmp___48 = 0;
                  }
#line 246
                  tmp___49 = tmp___48;
                }
#line 246
                tmp___50 = tmp___49;
              }
#line 246
              if ((unsigned int )dir % 2U != 0U) {
#line 246
                if ((unsigned int )dir - 1U == 0U) {
#line 246
                  tmp___52 = -1;
                } else {
#line 246
                  if ((unsigned int )dir - 1U == 4U) {
#line 246
                    tmp___51 = 1;
                  } else {
#line 246
                    tmp___51 = 0;
                  }
#line 246
                  tmp___52 = tmp___51;
                }
#line 246
                if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 246
                  tmp___54 = -1;
                } else {
#line 246
                  if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 246
                    tmp___53 = 1;
                  } else {
#line 246
                    tmp___53 = 0;
                  }
#line 246
                  tmp___54 = tmp___53;
                }
#line 246
                tmp___57 = tmp___52 + tmp___54;
              } else {
#line 246
                if ((unsigned int )dir == 0U) {
#line 246
                  tmp___56 = -1;
                } else {
#line 246
                  if ((unsigned int )dir == 4U) {
#line 246
                    tmp___55 = 1;
                  } else {
#line 246
                    tmp___55 = 0;
                  }
#line 246
                  tmp___56 = tmp___55;
                }
#line 246
                tmp___57 = tmp___56;
              }
              {
#line 246
              tmp___58 = GET_COLOR(bitmap, (unsigned int )(tmp___57 + (int )row),
                                   (unsigned int )(tmp___50 + (int )col));
#line 246
              tmp___59 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
              }
#line 246
              if ((int )tmp___58.g == (int )tmp___59.g) {
#line 246
                if ((unsigned int )dir % 2U != 0U) {
#line 246
                  if ((unsigned int )dir - 1U == 2U) {
#line 246
                    tmp___61 = -1;
                  } else {
#line 246
                    if ((unsigned int )dir - 1U == 6U) {
#line 246
                      tmp___60 = 1;
                    } else {
#line 246
                      tmp___60 = 0;
                    }
#line 246
                    tmp___61 = tmp___60;
                  }
#line 246
                  if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 246
                    tmp___63 = -1;
                  } else {
#line 246
                    if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 246
                      tmp___62 = 1;
                    } else {
#line 246
                      tmp___62 = 0;
                    }
#line 246
                    tmp___63 = tmp___62;
                  }
#line 246
                  tmp___66 = tmp___61 + tmp___63;
                } else {
#line 246
                  if ((unsigned int )dir == 2U) {
#line 246
                    tmp___65 = -1;
                  } else {
#line 246
                    if ((unsigned int )dir == 6U) {
#line 246
                      tmp___64 = 1;
                    } else {
#line 246
                      tmp___64 = 0;
                    }
#line 246
                    tmp___65 = tmp___64;
                  }
#line 246
                  tmp___66 = tmp___65;
                }
#line 246
                if ((unsigned int )dir % 2U != 0U) {
#line 246
                  if ((unsigned int )dir - 1U == 0U) {
#line 246
                    tmp___68 = -1;
                  } else {
#line 246
                    if ((unsigned int )dir - 1U == 4U) {
#line 246
                      tmp___67 = 1;
                    } else {
#line 246
                      tmp___67 = 0;
                    }
#line 246
                    tmp___68 = tmp___67;
                  }
#line 246
                  if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 246
                    tmp___70 = -1;
                  } else {
#line 246
                    if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 246
                      tmp___69 = 1;
                    } else {
#line 246
                      tmp___69 = 0;
                    }
#line 246
                    tmp___70 = tmp___69;
                  }
#line 246
                  tmp___73 = tmp___68 + tmp___70;
                } else {
#line 246
                  if ((unsigned int )dir == 0U) {
#line 246
                    tmp___72 = -1;
                  } else {
#line 246
                    if ((unsigned int )dir == 4U) {
#line 246
                      tmp___71 = 1;
                    } else {
#line 246
                      tmp___71 = 0;
                    }
#line 246
                    tmp___72 = tmp___71;
                  }
#line 246
                  tmp___73 = tmp___72;
                }
                {
#line 246
                tmp___74 = GET_COLOR(bitmap, (unsigned int )(tmp___73 + (int )row),
                                     (unsigned int )(tmp___66 + (int )col));
#line 246
                tmp___75 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
                }
#line 246
                if ((int )tmp___74.b == (int )tmp___75.b) {
#line 246
                  tmp___76 = 1;
                } else {
#line 246
                  tmp___76 = 0;
                }
              } else {
#line 246
                tmp___76 = 0;
              }
            } else {
#line 246
              tmp___76 = 0;
            }
          } else {
#line 246
            tmp___76 = 0;
          }
        } else {
#line 246
          tmp___76 = 0;
        }
      } else {
#line 246
        tmp___76 = 0;
      }
    } else {
#line 246
      tmp___76 = 0;
    }
  }
#line 246
  return ((at_bool )tmp___76);
}
}
#line 254 "pxl-outline.c"
pixel_outline_list_type find_centerline_pixels(bitmap_type bitmap , color_type bg_color ,
                                               void (*notify_progress)(at_real percentage ,
                                                                       at_address client_data ) ,
                                               at_address progress_data , at_bool (*test_cancel)(at_address client_data ) ,
                                               at_address testcancel_data , at_exception_type *exp ) 
{ 
  pixel_outline_list_type outline_list ;
  short row ;
  short col ;
  bitmap_type marked ;
  bitmap_type tmp ;
  unsigned int max_progress ;
  direction_type dir ;
  pixel_outline_type outline ;
  at_bool clockwise ;
  color_type tmp___0 ;
  color_type tmp___1 ;
  color_type tmp___2 ;
  at_bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  at_bool tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  unsigned int tmp___35 ;
  at_bool tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  at_bool tmp___51 ;
  at_bool tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  at_bool tmp___67 ;
  unsigned int tmp___68 ;
  unsigned int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  unsigned int tmp___84 ;
  at_bool tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  at_bool tmp___100 ;
  at_bool tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  at_bool tmp___116 ;
  unsigned int tmp___117 ;
  unsigned int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  unsigned int tmp___133 ;
  at_bool tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  at_bool tmp___149 ;
  at_bool tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  at_bool tmp___165 ;
  unsigned int tmp___166 ;
  unsigned int tmp___167 ;
  int tmp___168 ;
  int tmp___169 ;
  int tmp___170 ;
  int tmp___171 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  int tmp___177 ;
  int tmp___178 ;
  int tmp___179 ;
  int tmp___180 ;
  int tmp___181 ;
  unsigned int tmp___182 ;
  at_bool tmp___183 ;
  int tmp___184 ;
  int tmp___185 ;
  int tmp___186 ;
  int tmp___187 ;
  int tmp___188 ;
  int tmp___189 ;
  int tmp___190 ;
  int tmp___191 ;
  int tmp___192 ;
  int tmp___193 ;
  int tmp___194 ;
  int tmp___195 ;
  int tmp___196 ;
  int tmp___197 ;
  at_bool tmp___198 ;
  char const   *tmp___199 ;
  pixel_outline_type partial_outline ;
  at_bool okay ;
  char const   *tmp___200 ;
  at_bool tmp___201 ;

  {
  {
#line 262
  tmp = new_bitmap(bitmap.width, bitmap.height);
#line 262
  marked = tmp;
#line 263
  max_progress = (unsigned int )((int )bitmap.height * (int )bitmap.width);
#line 265
  outline_list.length = 0U;
#line 266
  outline_list.data = (pixel_outline_type *)((void *)0);
#line 268
  row = (short)0;
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! ((int )row < (int )bitmap.height)) {
#line 268
      goto while_break;
    }
#line 270
    col = (short)0;
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 270
      if (! ((int )col < (int )bitmap.width)) {
#line 270
        goto while_break___0;
      }
#line 272
      dir = (direction_type )6;
#line 274
      clockwise = (at_bool )0;
#line 276
      if (notify_progress) {
        {
#line 277
        (*notify_progress)((at_real )((int )row * (int )bitmap.width + (int )col) / ((at_real )max_progress * (at_real )3.0),
                           progress_data);
        }
      }
      {
#line 280
      tmp___0 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
      }
#line 280
      if ((int )tmp___0.r == (int )bg_color.r) {
        {
#line 280
        tmp___1 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
        }
#line 280
        if ((int )tmp___1.g == (int )bg_color.g) {
          {
#line 280
          tmp___2 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
          }
#line 280
          if ((int )tmp___2.b == (int )bg_color.b) {
#line 282
            col = (short )((int )col + 1);
#line 283
            goto __Cont;
          }
        }
      }
      {
#line 286
      tmp___150 = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                               marked);
      }
#line 286
      if (tmp___150) {
#line 286
        if ((unsigned int )dir % 2U != 0U) {
#line 286
          if ((unsigned int )dir - 1U == 2U) {
#line 286
            tmp___152 = -1;
          } else {
#line 286
            if ((unsigned int )dir - 1U == 6U) {
#line 286
              tmp___151 = 1;
            } else {
#line 286
              tmp___151 = 0;
            }
#line 286
            tmp___152 = tmp___151;
          }
#line 286
          if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 286
            tmp___154 = -1;
          } else {
#line 286
            if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 286
              tmp___153 = 1;
            } else {
#line 286
              tmp___153 = 0;
            }
#line 286
            tmp___154 = tmp___153;
          }
#line 286
          tmp___157 = tmp___152 + tmp___154;
        } else {
#line 286
          if ((unsigned int )dir == 2U) {
#line 286
            tmp___156 = -1;
          } else {
#line 286
            if ((unsigned int )dir == 6U) {
#line 286
              tmp___155 = 1;
            } else {
#line 286
              tmp___155 = 0;
            }
#line 286
            tmp___156 = tmp___155;
          }
#line 286
          tmp___157 = tmp___156;
        }
#line 286
        if ((unsigned int )dir % 2U != 0U) {
#line 286
          if ((unsigned int )dir - 1U == 0U) {
#line 286
            tmp___159 = -1;
          } else {
#line 286
            if ((unsigned int )dir - 1U == 4U) {
#line 286
              tmp___158 = 1;
            } else {
#line 286
              tmp___158 = 0;
            }
#line 286
            tmp___159 = tmp___158;
          }
#line 286
          if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 286
            tmp___161 = -1;
          } else {
#line 286
            if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 286
              tmp___160 = 1;
            } else {
#line 286
              tmp___160 = 0;
            }
#line 286
            tmp___161 = tmp___160;
          }
#line 286
          tmp___164 = tmp___159 + tmp___161;
        } else {
#line 286
          if ((unsigned int )dir == 0U) {
#line 286
            tmp___163 = -1;
          } else {
#line 286
            if ((unsigned int )dir == 4U) {
#line 286
              tmp___162 = 1;
            } else {
#line 286
              tmp___162 = 0;
            }
#line 286
            tmp___163 = tmp___162;
          }
#line 286
          tmp___164 = tmp___163;
        }
        {
#line 286
        tmp___165 = is_valid_dir((unsigned short )(tmp___164 + (int )row), (unsigned short )(tmp___157 + (int )col),
                                 dir, bitmap, marked);
        }
#line 286
        if (tmp___165) {
          _L___5: /* CIL Label */ 
          {
#line 286
          tmp___167 = num_neighbors((unsigned short )row, (unsigned short )col, bitmap);
          }
#line 286
          if (tmp___167 > 4U) {
#line 286
            goto _L___4;
          } else {
#line 286
            if ((unsigned int )dir % 2U != 0U) {
#line 286
              if ((unsigned int )dir - 1U == 2U) {
#line 286
                tmp___169 = -1;
              } else {
#line 286
                if ((unsigned int )dir - 1U == 6U) {
#line 286
                  tmp___168 = 1;
                } else {
#line 286
                  tmp___168 = 0;
                }
#line 286
                tmp___169 = tmp___168;
              }
#line 286
              if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 286
                tmp___171 = -1;
              } else {
#line 286
                if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 286
                  tmp___170 = 1;
                } else {
#line 286
                  tmp___170 = 0;
                }
#line 286
                tmp___171 = tmp___170;
              }
#line 286
              tmp___174 = tmp___169 + tmp___171;
            } else {
#line 286
              if ((unsigned int )dir == 2U) {
#line 286
                tmp___173 = -1;
              } else {
#line 286
                if ((unsigned int )dir == 6U) {
#line 286
                  tmp___172 = 1;
                } else {
#line 286
                  tmp___172 = 0;
                }
#line 286
                tmp___173 = tmp___172;
              }
#line 286
              tmp___174 = tmp___173;
            }
#line 286
            if ((unsigned int )dir % 2U != 0U) {
#line 286
              if ((unsigned int )dir - 1U == 0U) {
#line 286
                tmp___176 = -1;
              } else {
#line 286
                if ((unsigned int )dir - 1U == 4U) {
#line 286
                  tmp___175 = 1;
                } else {
#line 286
                  tmp___175 = 0;
                }
#line 286
                tmp___176 = tmp___175;
              }
#line 286
              if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 286
                tmp___178 = -1;
              } else {
#line 286
                if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 286
                  tmp___177 = 1;
                } else {
#line 286
                  tmp___177 = 0;
                }
#line 286
                tmp___178 = tmp___177;
              }
#line 286
              tmp___181 = tmp___176 + tmp___178;
            } else {
#line 286
              if ((unsigned int )dir == 0U) {
#line 286
                tmp___180 = -1;
              } else {
#line 286
                if ((unsigned int )dir == 4U) {
#line 286
                  tmp___179 = 1;
                } else {
#line 286
                  tmp___179 = 0;
                }
#line 286
                tmp___180 = tmp___179;
              }
#line 286
              tmp___181 = tmp___180;
            }
            {
#line 286
            tmp___182 = num_neighbors((unsigned short )(tmp___181 + (int )row), (unsigned short )(tmp___174 + (int )col),
                                      bitmap);
            }
#line 286
            if (tmp___182 > 4U) {
#line 286
              goto _L___4;
            } else {
              {
#line 286
              tmp___183 = is_other_dir_marked((unsigned short )row, (unsigned short )col,
                                              dir, marked);
              }
#line 286
              if (tmp___183) {
#line 286
                if ((unsigned int )dir % 2U != 0U) {
#line 286
                  if ((unsigned int )dir - 1U == 2U) {
#line 286
                    tmp___185 = -1;
                  } else {
#line 286
                    if ((unsigned int )dir - 1U == 6U) {
#line 286
                      tmp___184 = 1;
                    } else {
#line 286
                      tmp___184 = 0;
                    }
#line 286
                    tmp___185 = tmp___184;
                  }
#line 286
                  if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 286
                    tmp___187 = -1;
                  } else {
#line 286
                    if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 286
                      tmp___186 = 1;
                    } else {
#line 286
                      tmp___186 = 0;
                    }
#line 286
                    tmp___187 = tmp___186;
                  }
#line 286
                  tmp___190 = tmp___185 + tmp___187;
                } else {
#line 286
                  if ((unsigned int )dir == 2U) {
#line 286
                    tmp___189 = -1;
                  } else {
#line 286
                    if ((unsigned int )dir == 6U) {
#line 286
                      tmp___188 = 1;
                    } else {
#line 286
                      tmp___188 = 0;
                    }
#line 286
                    tmp___189 = tmp___188;
                  }
#line 286
                  tmp___190 = tmp___189;
                }
#line 286
                if ((unsigned int )dir % 2U != 0U) {
#line 286
                  if ((unsigned int )dir - 1U == 0U) {
#line 286
                    tmp___192 = -1;
                  } else {
#line 286
                    if ((unsigned int )dir - 1U == 4U) {
#line 286
                      tmp___191 = 1;
                    } else {
#line 286
                      tmp___191 = 0;
                    }
#line 286
                    tmp___192 = tmp___191;
                  }
#line 286
                  if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 286
                    tmp___194 = -1;
                  } else {
#line 286
                    if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 286
                      tmp___193 = 1;
                    } else {
#line 286
                      tmp___193 = 0;
                    }
#line 286
                    tmp___194 = tmp___193;
                  }
#line 286
                  tmp___197 = tmp___192 + tmp___194;
                } else {
#line 286
                  if ((unsigned int )dir == 0U) {
#line 286
                    tmp___196 = -1;
                  } else {
#line 286
                    if ((unsigned int )dir == 4U) {
#line 286
                      tmp___195 = 1;
                    } else {
#line 286
                      tmp___195 = 0;
                    }
#line 286
                    tmp___196 = tmp___195;
                  }
#line 286
                  tmp___197 = tmp___196;
                }
                {
#line 286
                tmp___198 = is_other_dir_marked((unsigned short )((int )row + tmp___197),
                                                (unsigned short )((int )col + tmp___190),
                                                dir, marked);
                }
#line 286
                if (tmp___198) {
                  _L___4: /* CIL Label */ 
                  {
#line 294
                  dir = (direction_type )5;
#line 295
                  tmp___101 = is_valid_dir((unsigned short )row, (unsigned short )col,
                                           dir, bitmap, marked);
                  }
#line 295
                  if (tmp___101) {
#line 295
                    if ((unsigned int )dir % 2U != 0U) {
#line 295
                      if ((unsigned int )dir - 1U == 2U) {
#line 295
                        tmp___103 = -1;
                      } else {
#line 295
                        if ((unsigned int )dir - 1U == 6U) {
#line 295
                          tmp___102 = 1;
                        } else {
#line 295
                          tmp___102 = 0;
                        }
#line 295
                        tmp___103 = tmp___102;
                      }
#line 295
                      if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 295
                        tmp___105 = -1;
                      } else {
#line 295
                        if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 295
                          tmp___104 = 1;
                        } else {
#line 295
                          tmp___104 = 0;
                        }
#line 295
                        tmp___105 = tmp___104;
                      }
#line 295
                      tmp___108 = tmp___103 + tmp___105;
                    } else {
#line 295
                      if ((unsigned int )dir == 2U) {
#line 295
                        tmp___107 = -1;
                      } else {
#line 295
                        if ((unsigned int )dir == 6U) {
#line 295
                          tmp___106 = 1;
                        } else {
#line 295
                          tmp___106 = 0;
                        }
#line 295
                        tmp___107 = tmp___106;
                      }
#line 295
                      tmp___108 = tmp___107;
                    }
#line 295
                    if ((unsigned int )dir % 2U != 0U) {
#line 295
                      if ((unsigned int )dir - 1U == 0U) {
#line 295
                        tmp___110 = -1;
                      } else {
#line 295
                        if ((unsigned int )dir - 1U == 4U) {
#line 295
                          tmp___109 = 1;
                        } else {
#line 295
                          tmp___109 = 0;
                        }
#line 295
                        tmp___110 = tmp___109;
                      }
#line 295
                      if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 295
                        tmp___112 = -1;
                      } else {
#line 295
                        if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 295
                          tmp___111 = 1;
                        } else {
#line 295
                          tmp___111 = 0;
                        }
#line 295
                        tmp___112 = tmp___111;
                      }
#line 295
                      tmp___115 = tmp___110 + tmp___112;
                    } else {
#line 295
                      if ((unsigned int )dir == 0U) {
#line 295
                        tmp___114 = -1;
                      } else {
#line 295
                        if ((unsigned int )dir == 4U) {
#line 295
                          tmp___113 = 1;
                        } else {
#line 295
                          tmp___113 = 0;
                        }
#line 295
                        tmp___114 = tmp___113;
                      }
#line 295
                      tmp___115 = tmp___114;
                    }
                    {
#line 295
                    tmp___116 = is_valid_dir((unsigned short )(tmp___115 + (int )row),
                                             (unsigned short )(tmp___108 + (int )col),
                                             dir, bitmap, marked);
                    }
#line 295
                    if (tmp___116) {
                      _L___3: /* CIL Label */ 
                      {
#line 295
                      tmp___118 = num_neighbors((unsigned short )row, (unsigned short )col,
                                                bitmap);
                      }
#line 295
                      if (tmp___118 > 4U) {
#line 295
                        goto _L___2;
                      } else {
#line 295
                        if ((unsigned int )dir % 2U != 0U) {
#line 295
                          if ((unsigned int )dir - 1U == 2U) {
#line 295
                            tmp___120 = -1;
                          } else {
#line 295
                            if ((unsigned int )dir - 1U == 6U) {
#line 295
                              tmp___119 = 1;
                            } else {
#line 295
                              tmp___119 = 0;
                            }
#line 295
                            tmp___120 = tmp___119;
                          }
#line 295
                          if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 295
                            tmp___122 = -1;
                          } else {
#line 295
                            if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 295
                              tmp___121 = 1;
                            } else {
#line 295
                              tmp___121 = 0;
                            }
#line 295
                            tmp___122 = tmp___121;
                          }
#line 295
                          tmp___125 = tmp___120 + tmp___122;
                        } else {
#line 295
                          if ((unsigned int )dir == 2U) {
#line 295
                            tmp___124 = -1;
                          } else {
#line 295
                            if ((unsigned int )dir == 6U) {
#line 295
                              tmp___123 = 1;
                            } else {
#line 295
                              tmp___123 = 0;
                            }
#line 295
                            tmp___124 = tmp___123;
                          }
#line 295
                          tmp___125 = tmp___124;
                        }
#line 295
                        if ((unsigned int )dir % 2U != 0U) {
#line 295
                          if ((unsigned int )dir - 1U == 0U) {
#line 295
                            tmp___127 = -1;
                          } else {
#line 295
                            if ((unsigned int )dir - 1U == 4U) {
#line 295
                              tmp___126 = 1;
                            } else {
#line 295
                              tmp___126 = 0;
                            }
#line 295
                            tmp___127 = tmp___126;
                          }
#line 295
                          if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 295
                            tmp___129 = -1;
                          } else {
#line 295
                            if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 295
                              tmp___128 = 1;
                            } else {
#line 295
                              tmp___128 = 0;
                            }
#line 295
                            tmp___129 = tmp___128;
                          }
#line 295
                          tmp___132 = tmp___127 + tmp___129;
                        } else {
#line 295
                          if ((unsigned int )dir == 0U) {
#line 295
                            tmp___131 = -1;
                          } else {
#line 295
                            if ((unsigned int )dir == 4U) {
#line 295
                              tmp___130 = 1;
                            } else {
#line 295
                              tmp___130 = 0;
                            }
#line 295
                            tmp___131 = tmp___130;
                          }
#line 295
                          tmp___132 = tmp___131;
                        }
                        {
#line 295
                        tmp___133 = num_neighbors((unsigned short )(tmp___132 + (int )row),
                                                  (unsigned short )(tmp___125 + (int )col),
                                                  bitmap);
                        }
#line 295
                        if (tmp___133 > 4U) {
#line 295
                          goto _L___2;
                        } else {
                          {
#line 295
                          tmp___134 = is_other_dir_marked((unsigned short )row, (unsigned short )col,
                                                          dir, marked);
                          }
#line 295
                          if (tmp___134) {
#line 295
                            if ((unsigned int )dir % 2U != 0U) {
#line 295
                              if ((unsigned int )dir - 1U == 2U) {
#line 295
                                tmp___136 = -1;
                              } else {
#line 295
                                if ((unsigned int )dir - 1U == 6U) {
#line 295
                                  tmp___135 = 1;
                                } else {
#line 295
                                  tmp___135 = 0;
                                }
#line 295
                                tmp___136 = tmp___135;
                              }
#line 295
                              if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 295
                                tmp___138 = -1;
                              } else {
#line 295
                                if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 295
                                  tmp___137 = 1;
                                } else {
#line 295
                                  tmp___137 = 0;
                                }
#line 295
                                tmp___138 = tmp___137;
                              }
#line 295
                              tmp___141 = tmp___136 + tmp___138;
                            } else {
#line 295
                              if ((unsigned int )dir == 2U) {
#line 295
                                tmp___140 = -1;
                              } else {
#line 295
                                if ((unsigned int )dir == 6U) {
#line 295
                                  tmp___139 = 1;
                                } else {
#line 295
                                  tmp___139 = 0;
                                }
#line 295
                                tmp___140 = tmp___139;
                              }
#line 295
                              tmp___141 = tmp___140;
                            }
#line 295
                            if ((unsigned int )dir % 2U != 0U) {
#line 295
                              if ((unsigned int )dir - 1U == 0U) {
#line 295
                                tmp___143 = -1;
                              } else {
#line 295
                                if ((unsigned int )dir - 1U == 4U) {
#line 295
                                  tmp___142 = 1;
                                } else {
#line 295
                                  tmp___142 = 0;
                                }
#line 295
                                tmp___143 = tmp___142;
                              }
#line 295
                              if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 295
                                tmp___145 = -1;
                              } else {
#line 295
                                if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 295
                                  tmp___144 = 1;
                                } else {
#line 295
                                  tmp___144 = 0;
                                }
#line 295
                                tmp___145 = tmp___144;
                              }
#line 295
                              tmp___148 = tmp___143 + tmp___145;
                            } else {
#line 295
                              if ((unsigned int )dir == 0U) {
#line 295
                                tmp___147 = -1;
                              } else {
#line 295
                                if ((unsigned int )dir == 4U) {
#line 295
                                  tmp___146 = 1;
                                } else {
#line 295
                                  tmp___146 = 0;
                                }
#line 295
                                tmp___147 = tmp___146;
                              }
#line 295
                              tmp___148 = tmp___147;
                            }
                            {
#line 295
                            tmp___149 = is_other_dir_marked((unsigned short )((int )row + tmp___148),
                                                            (unsigned short )((int )col + tmp___141),
                                                            dir, marked);
                            }
#line 295
                            if (tmp___149) {
                              _L___2: /* CIL Label */ 
                              {
#line 303
                              dir = (direction_type )4;
#line 304
                              tmp___52 = is_valid_dir((unsigned short )row, (unsigned short )col,
                                                      dir, bitmap, marked);
                              }
#line 304
                              if (tmp___52) {
#line 304
                                if ((unsigned int )dir % 2U != 0U) {
#line 304
                                  if ((unsigned int )dir - 1U == 2U) {
#line 304
                                    tmp___54 = -1;
                                  } else {
#line 304
                                    if ((unsigned int )dir - 1U == 6U) {
#line 304
                                      tmp___53 = 1;
                                    } else {
#line 304
                                      tmp___53 = 0;
                                    }
#line 304
                                    tmp___54 = tmp___53;
                                  }
#line 304
                                  if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 304
                                    tmp___56 = -1;
                                  } else {
#line 304
                                    if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 304
                                      tmp___55 = 1;
                                    } else {
#line 304
                                      tmp___55 = 0;
                                    }
#line 304
                                    tmp___56 = tmp___55;
                                  }
#line 304
                                  tmp___59 = tmp___54 + tmp___56;
                                } else {
#line 304
                                  if ((unsigned int )dir == 2U) {
#line 304
                                    tmp___58 = -1;
                                  } else {
#line 304
                                    if ((unsigned int )dir == 6U) {
#line 304
                                      tmp___57 = 1;
                                    } else {
#line 304
                                      tmp___57 = 0;
                                    }
#line 304
                                    tmp___58 = tmp___57;
                                  }
#line 304
                                  tmp___59 = tmp___58;
                                }
#line 304
                                if ((unsigned int )dir % 2U != 0U) {
#line 304
                                  if ((unsigned int )dir - 1U == 0U) {
#line 304
                                    tmp___61 = -1;
                                  } else {
#line 304
                                    if ((unsigned int )dir - 1U == 4U) {
#line 304
                                      tmp___60 = 1;
                                    } else {
#line 304
                                      tmp___60 = 0;
                                    }
#line 304
                                    tmp___61 = tmp___60;
                                  }
#line 304
                                  if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 304
                                    tmp___63 = -1;
                                  } else {
#line 304
                                    if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 304
                                      tmp___62 = 1;
                                    } else {
#line 304
                                      tmp___62 = 0;
                                    }
#line 304
                                    tmp___63 = tmp___62;
                                  }
#line 304
                                  tmp___66 = tmp___61 + tmp___63;
                                } else {
#line 304
                                  if ((unsigned int )dir == 0U) {
#line 304
                                    tmp___65 = -1;
                                  } else {
#line 304
                                    if ((unsigned int )dir == 4U) {
#line 304
                                      tmp___64 = 1;
                                    } else {
#line 304
                                      tmp___64 = 0;
                                    }
#line 304
                                    tmp___65 = tmp___64;
                                  }
#line 304
                                  tmp___66 = tmp___65;
                                }
                                {
#line 304
                                tmp___67 = is_valid_dir((unsigned short )(tmp___66 + (int )row),
                                                        (unsigned short )(tmp___59 + (int )col),
                                                        dir, bitmap, marked);
                                }
#line 304
                                if (tmp___67) {
                                  _L___1: /* CIL Label */ 
                                  {
#line 304
                                  tmp___69 = num_neighbors((unsigned short )row, (unsigned short )col,
                                                           bitmap);
                                  }
#line 304
                                  if (tmp___69 > 4U) {
#line 304
                                    goto _L___0;
                                  } else {
#line 304
                                    if ((unsigned int )dir % 2U != 0U) {
#line 304
                                      if ((unsigned int )dir - 1U == 2U) {
#line 304
                                        tmp___71 = -1;
                                      } else {
#line 304
                                        if ((unsigned int )dir - 1U == 6U) {
#line 304
                                          tmp___70 = 1;
                                        } else {
#line 304
                                          tmp___70 = 0;
                                        }
#line 304
                                        tmp___71 = tmp___70;
                                      }
#line 304
                                      if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 304
                                        tmp___73 = -1;
                                      } else {
#line 304
                                        if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 304
                                          tmp___72 = 1;
                                        } else {
#line 304
                                          tmp___72 = 0;
                                        }
#line 304
                                        tmp___73 = tmp___72;
                                      }
#line 304
                                      tmp___76 = tmp___71 + tmp___73;
                                    } else {
#line 304
                                      if ((unsigned int )dir == 2U) {
#line 304
                                        tmp___75 = -1;
                                      } else {
#line 304
                                        if ((unsigned int )dir == 6U) {
#line 304
                                          tmp___74 = 1;
                                        } else {
#line 304
                                          tmp___74 = 0;
                                        }
#line 304
                                        tmp___75 = tmp___74;
                                      }
#line 304
                                      tmp___76 = tmp___75;
                                    }
#line 304
                                    if ((unsigned int )dir % 2U != 0U) {
#line 304
                                      if ((unsigned int )dir - 1U == 0U) {
#line 304
                                        tmp___78 = -1;
                                      } else {
#line 304
                                        if ((unsigned int )dir - 1U == 4U) {
#line 304
                                          tmp___77 = 1;
                                        } else {
#line 304
                                          tmp___77 = 0;
                                        }
#line 304
                                        tmp___78 = tmp___77;
                                      }
#line 304
                                      if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 304
                                        tmp___80 = -1;
                                      } else {
#line 304
                                        if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 304
                                          tmp___79 = 1;
                                        } else {
#line 304
                                          tmp___79 = 0;
                                        }
#line 304
                                        tmp___80 = tmp___79;
                                      }
#line 304
                                      tmp___83 = tmp___78 + tmp___80;
                                    } else {
#line 304
                                      if ((unsigned int )dir == 0U) {
#line 304
                                        tmp___82 = -1;
                                      } else {
#line 304
                                        if ((unsigned int )dir == 4U) {
#line 304
                                          tmp___81 = 1;
                                        } else {
#line 304
                                          tmp___81 = 0;
                                        }
#line 304
                                        tmp___82 = tmp___81;
                                      }
#line 304
                                      tmp___83 = tmp___82;
                                    }
                                    {
#line 304
                                    tmp___84 = num_neighbors((unsigned short )(tmp___83 + (int )row),
                                                             (unsigned short )(tmp___76 + (int )col),
                                                             bitmap);
                                    }
#line 304
                                    if (tmp___84 > 4U) {
#line 304
                                      goto _L___0;
                                    } else {
                                      {
#line 304
                                      tmp___85 = is_other_dir_marked((unsigned short )row,
                                                                     (unsigned short )col,
                                                                     dir, marked);
                                      }
#line 304
                                      if (tmp___85) {
#line 304
                                        if ((unsigned int )dir % 2U != 0U) {
#line 304
                                          if ((unsigned int )dir - 1U == 2U) {
#line 304
                                            tmp___87 = -1;
                                          } else {
#line 304
                                            if ((unsigned int )dir - 1U == 6U) {
#line 304
                                              tmp___86 = 1;
                                            } else {
#line 304
                                              tmp___86 = 0;
                                            }
#line 304
                                            tmp___87 = tmp___86;
                                          }
#line 304
                                          if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 304
                                            tmp___89 = -1;
                                          } else {
#line 304
                                            if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 304
                                              tmp___88 = 1;
                                            } else {
#line 304
                                              tmp___88 = 0;
                                            }
#line 304
                                            tmp___89 = tmp___88;
                                          }
#line 304
                                          tmp___92 = tmp___87 + tmp___89;
                                        } else {
#line 304
                                          if ((unsigned int )dir == 2U) {
#line 304
                                            tmp___91 = -1;
                                          } else {
#line 304
                                            if ((unsigned int )dir == 6U) {
#line 304
                                              tmp___90 = 1;
                                            } else {
#line 304
                                              tmp___90 = 0;
                                            }
#line 304
                                            tmp___91 = tmp___90;
                                          }
#line 304
                                          tmp___92 = tmp___91;
                                        }
#line 304
                                        if ((unsigned int )dir % 2U != 0U) {
#line 304
                                          if ((unsigned int )dir - 1U == 0U) {
#line 304
                                            tmp___94 = -1;
                                          } else {
#line 304
                                            if ((unsigned int )dir - 1U == 4U) {
#line 304
                                              tmp___93 = 1;
                                            } else {
#line 304
                                              tmp___93 = 0;
                                            }
#line 304
                                            tmp___94 = tmp___93;
                                          }
#line 304
                                          if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 304
                                            tmp___96 = -1;
                                          } else {
#line 304
                                            if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 304
                                              tmp___95 = 1;
                                            } else {
#line 304
                                              tmp___95 = 0;
                                            }
#line 304
                                            tmp___96 = tmp___95;
                                          }
#line 304
                                          tmp___99 = tmp___94 + tmp___96;
                                        } else {
#line 304
                                          if ((unsigned int )dir == 0U) {
#line 304
                                            tmp___98 = -1;
                                          } else {
#line 304
                                            if ((unsigned int )dir == 4U) {
#line 304
                                              tmp___97 = 1;
                                            } else {
#line 304
                                              tmp___97 = 0;
                                            }
#line 304
                                            tmp___98 = tmp___97;
                                          }
#line 304
                                          tmp___99 = tmp___98;
                                        }
                                        {
#line 304
                                        tmp___100 = is_other_dir_marked((unsigned short )((int )row + tmp___99),
                                                                        (unsigned short )((int )col + tmp___92),
                                                                        dir, marked);
                                        }
#line 304
                                        if (tmp___100) {
                                          _L___0: /* CIL Label */ 
                                          {
#line 312
                                          dir = (direction_type )3;
#line 313
                                          tmp___3 = is_valid_dir((unsigned short )row,
                                                                 (unsigned short )col,
                                                                 dir, bitmap, marked);
                                          }
#line 313
                                          if (tmp___3) {
#line 313
                                            if ((unsigned int )dir % 2U != 0U) {
#line 313
                                              if ((unsigned int )dir - 1U == 2U) {
#line 313
                                                tmp___5 = -1;
                                              } else {
#line 313
                                                if ((unsigned int )dir - 1U == 6U) {
#line 313
                                                  tmp___4 = 1;
                                                } else {
#line 313
                                                  tmp___4 = 0;
                                                }
#line 313
                                                tmp___5 = tmp___4;
                                              }
#line 313
                                              if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 313
                                                tmp___7 = -1;
                                              } else {
#line 313
                                                if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 313
                                                  tmp___6 = 1;
                                                } else {
#line 313
                                                  tmp___6 = 0;
                                                }
#line 313
                                                tmp___7 = tmp___6;
                                              }
#line 313
                                              tmp___10 = tmp___5 + tmp___7;
                                            } else {
#line 313
                                              if ((unsigned int )dir == 2U) {
#line 313
                                                tmp___9 = -1;
                                              } else {
#line 313
                                                if ((unsigned int )dir == 6U) {
#line 313
                                                  tmp___8 = 1;
                                                } else {
#line 313
                                                  tmp___8 = 0;
                                                }
#line 313
                                                tmp___9 = tmp___8;
                                              }
#line 313
                                              tmp___10 = tmp___9;
                                            }
#line 313
                                            if ((unsigned int )dir % 2U != 0U) {
#line 313
                                              if ((unsigned int )dir - 1U == 0U) {
#line 313
                                                tmp___12 = -1;
                                              } else {
#line 313
                                                if ((unsigned int )dir - 1U == 4U) {
#line 313
                                                  tmp___11 = 1;
                                                } else {
#line 313
                                                  tmp___11 = 0;
                                                }
#line 313
                                                tmp___12 = tmp___11;
                                              }
#line 313
                                              if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 313
                                                tmp___14 = -1;
                                              } else {
#line 313
                                                if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 313
                                                  tmp___13 = 1;
                                                } else {
#line 313
                                                  tmp___13 = 0;
                                                }
#line 313
                                                tmp___14 = tmp___13;
                                              }
#line 313
                                              tmp___17 = tmp___12 + tmp___14;
                                            } else {
#line 313
                                              if ((unsigned int )dir == 0U) {
#line 313
                                                tmp___16 = -1;
                                              } else {
#line 313
                                                if ((unsigned int )dir == 4U) {
#line 313
                                                  tmp___15 = 1;
                                                } else {
#line 313
                                                  tmp___15 = 0;
                                                }
#line 313
                                                tmp___16 = tmp___15;
                                              }
#line 313
                                              tmp___17 = tmp___16;
                                            }
                                            {
#line 313
                                            tmp___18 = is_valid_dir((unsigned short )(tmp___17 + (int )row),
                                                                    (unsigned short )(tmp___10 + (int )col),
                                                                    dir, bitmap, marked);
                                            }
#line 313
                                            if (tmp___18) {
                                              _L: /* CIL Label */ 
                                              {
#line 313
                                              tmp___20 = num_neighbors((unsigned short )row,
                                                                       (unsigned short )col,
                                                                       bitmap);
                                              }
#line 313
                                              if (tmp___20 > 4U) {
#line 321
                                                col = (short )((int )col + 1);
#line 322
                                                goto __Cont;
                                              } else {
#line 313
                                                if ((unsigned int )dir % 2U != 0U) {
#line 313
                                                  if ((unsigned int )dir - 1U == 2U) {
#line 313
                                                    tmp___22 = -1;
                                                  } else {
#line 313
                                                    if ((unsigned int )dir - 1U == 6U) {
#line 313
                                                      tmp___21 = 1;
                                                    } else {
#line 313
                                                      tmp___21 = 0;
                                                    }
#line 313
                                                    tmp___22 = tmp___21;
                                                  }
#line 313
                                                  if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 313
                                                    tmp___24 = -1;
                                                  } else {
#line 313
                                                    if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 313
                                                      tmp___23 = 1;
                                                    } else {
#line 313
                                                      tmp___23 = 0;
                                                    }
#line 313
                                                    tmp___24 = tmp___23;
                                                  }
#line 313
                                                  tmp___27 = tmp___22 + tmp___24;
                                                } else {
#line 313
                                                  if ((unsigned int )dir == 2U) {
#line 313
                                                    tmp___26 = -1;
                                                  } else {
#line 313
                                                    if ((unsigned int )dir == 6U) {
#line 313
                                                      tmp___25 = 1;
                                                    } else {
#line 313
                                                      tmp___25 = 0;
                                                    }
#line 313
                                                    tmp___26 = tmp___25;
                                                  }
#line 313
                                                  tmp___27 = tmp___26;
                                                }
#line 313
                                                if ((unsigned int )dir % 2U != 0U) {
#line 313
                                                  if ((unsigned int )dir - 1U == 0U) {
#line 313
                                                    tmp___29 = -1;
                                                  } else {
#line 313
                                                    if ((unsigned int )dir - 1U == 4U) {
#line 313
                                                      tmp___28 = 1;
                                                    } else {
#line 313
                                                      tmp___28 = 0;
                                                    }
#line 313
                                                    tmp___29 = tmp___28;
                                                  }
#line 313
                                                  if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 313
                                                    tmp___31 = -1;
                                                  } else {
#line 313
                                                    if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 313
                                                      tmp___30 = 1;
                                                    } else {
#line 313
                                                      tmp___30 = 0;
                                                    }
#line 313
                                                    tmp___31 = tmp___30;
                                                  }
#line 313
                                                  tmp___34 = tmp___29 + tmp___31;
                                                } else {
#line 313
                                                  if ((unsigned int )dir == 0U) {
#line 313
                                                    tmp___33 = -1;
                                                  } else {
#line 313
                                                    if ((unsigned int )dir == 4U) {
#line 313
                                                      tmp___32 = 1;
                                                    } else {
#line 313
                                                      tmp___32 = 0;
                                                    }
#line 313
                                                    tmp___33 = tmp___32;
                                                  }
#line 313
                                                  tmp___34 = tmp___33;
                                                }
                                                {
#line 313
                                                tmp___35 = num_neighbors((unsigned short )(tmp___34 + (int )row),
                                                                         (unsigned short )(tmp___27 + (int )col),
                                                                         bitmap);
                                                }
#line 313
                                                if (tmp___35 > 4U) {
#line 321
                                                  col = (short )((int )col + 1);
#line 322
                                                  goto __Cont;
                                                } else {
                                                  {
#line 313
                                                  tmp___36 = is_other_dir_marked((unsigned short )row,
                                                                                 (unsigned short )col,
                                                                                 dir,
                                                                                 marked);
                                                  }
#line 313
                                                  if (tmp___36) {
#line 313
                                                    if ((unsigned int )dir % 2U != 0U) {
#line 313
                                                      if ((unsigned int )dir - 1U == 2U) {
#line 313
                                                        tmp___38 = -1;
                                                      } else {
#line 313
                                                        if ((unsigned int )dir - 1U == 6U) {
#line 313
                                                          tmp___37 = 1;
                                                        } else {
#line 313
                                                          tmp___37 = 0;
                                                        }
#line 313
                                                        tmp___38 = tmp___37;
                                                      }
#line 313
                                                      if (((unsigned int )dir + 1U) % 8U == 2U) {
#line 313
                                                        tmp___40 = -1;
                                                      } else {
#line 313
                                                        if (((unsigned int )dir + 1U) % 8U == 6U) {
#line 313
                                                          tmp___39 = 1;
                                                        } else {
#line 313
                                                          tmp___39 = 0;
                                                        }
#line 313
                                                        tmp___40 = tmp___39;
                                                      }
#line 313
                                                      tmp___43 = tmp___38 + tmp___40;
                                                    } else {
#line 313
                                                      if ((unsigned int )dir == 2U) {
#line 313
                                                        tmp___42 = -1;
                                                      } else {
#line 313
                                                        if ((unsigned int )dir == 6U) {
#line 313
                                                          tmp___41 = 1;
                                                        } else {
#line 313
                                                          tmp___41 = 0;
                                                        }
#line 313
                                                        tmp___42 = tmp___41;
                                                      }
#line 313
                                                      tmp___43 = tmp___42;
                                                    }
#line 313
                                                    if ((unsigned int )dir % 2U != 0U) {
#line 313
                                                      if ((unsigned int )dir - 1U == 0U) {
#line 313
                                                        tmp___45 = -1;
                                                      } else {
#line 313
                                                        if ((unsigned int )dir - 1U == 4U) {
#line 313
                                                          tmp___44 = 1;
                                                        } else {
#line 313
                                                          tmp___44 = 0;
                                                        }
#line 313
                                                        tmp___45 = tmp___44;
                                                      }
#line 313
                                                      if (((unsigned int )dir + 1U) % 8U == 0U) {
#line 313
                                                        tmp___47 = -1;
                                                      } else {
#line 313
                                                        if (((unsigned int )dir + 1U) % 8U == 4U) {
#line 313
                                                          tmp___46 = 1;
                                                        } else {
#line 313
                                                          tmp___46 = 0;
                                                        }
#line 313
                                                        tmp___47 = tmp___46;
                                                      }
#line 313
                                                      tmp___50 = tmp___45 + tmp___47;
                                                    } else {
#line 313
                                                      if ((unsigned int )dir == 0U) {
#line 313
                                                        tmp___49 = -1;
                                                      } else {
#line 313
                                                        if ((unsigned int )dir == 4U) {
#line 313
                                                          tmp___48 = 1;
                                                        } else {
#line 313
                                                          tmp___48 = 0;
                                                        }
#line 313
                                                        tmp___49 = tmp___48;
                                                      }
#line 313
                                                      tmp___50 = tmp___49;
                                                    }
                                                    {
#line 313
                                                    tmp___51 = is_other_dir_marked((unsigned short )((int )row + tmp___50),
                                                                                   (unsigned short )((int )col + tmp___43),
                                                                                   dir,
                                                                                   marked);
                                                    }
#line 313
                                                    if (tmp___51) {
#line 321
                                                      col = (short )((int )col + 1);
#line 322
                                                      goto __Cont;
                                                    }
                                                  }
                                                }
                                              }
                                            } else {
                                              {
#line 313
                                              tmp___19 = num_neighbors((unsigned short )row,
                                                                       (unsigned short )col,
                                                                       bitmap);
                                              }
#line 313
                                              if (tmp___19 > 2U) {
#line 321
                                                col = (short )((int )col + 1);
#line 322
                                                goto __Cont;
                                              } else {
#line 313
                                                goto _L;
                                              }
                                            }
                                          } else {
#line 321
                                            col = (short )((int )col + 1);
#line 322
                                            goto __Cont;
                                          }
                                        }
                                      }
                                    }
                                  }
                                } else {
                                  {
#line 304
                                  tmp___68 = num_neighbors((unsigned short )row, (unsigned short )col,
                                                           bitmap);
                                  }
#line 304
                                  if (tmp___68 > 2U) {
#line 304
                                    goto _L___0;
                                  } else {
#line 304
                                    goto _L___1;
                                  }
                                }
                              } else {
#line 304
                                goto _L___0;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      {
#line 295
                      tmp___117 = num_neighbors((unsigned short )row, (unsigned short )col,
                                                bitmap);
                      }
#line 295
                      if (tmp___117 > 2U) {
#line 295
                        goto _L___2;
                      } else {
#line 295
                        goto _L___3;
                      }
                    }
                  } else {
#line 295
                    goto _L___2;
                  }
                }
              }
            }
          }
        } else {
          {
#line 286
          tmp___166 = num_neighbors((unsigned short )row, (unsigned short )col, bitmap);
          }
#line 286
          if (tmp___166 > 2U) {
#line 286
            goto _L___4;
          } else {
#line 286
            goto _L___5;
          }
        }
      } else {
#line 286
        goto _L___4;
      }
      {
#line 328
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 328
        if (at_log_file) {
#line 328
          if (clockwise) {
#line 328
            tmp___199 = "";
          } else {
#line 328
            tmp___199 = "counter";
          }
          {
#line 328
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"#%u: (%sclockwise) ",
                  outline_list.length, tmp___199);
          }
        }
#line 328
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 331
      outline = find_one_centerline(bitmap, dir, (unsigned short )row, (unsigned short )col,
                                    & marked);
      }
#line 337
      if (outline.open) {
#line 340
        okay = (at_bool )0;
#line 342
        if ((unsigned int )dir == 6U) {
          {
#line 344
          dir = (direction_type )4;
#line 345
          okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                              marked);
          }
#line 345
          if (! okay) {
            {
#line 347
            dir = (direction_type )3;
#line 348
            okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                                marked);
            }
#line 348
            if (! okay) {
              {
#line 350
              dir = (direction_type )5;
#line 351
              okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir,
                                  bitmap, marked);
              }
            }
          }
        } else
#line 355
        if ((unsigned int )dir == 5U) {
          {
#line 357
          dir = (direction_type )3;
#line 358
          okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                              marked);
          }
#line 358
          if (! okay) {
            {
#line 360
            dir = (direction_type )6;
#line 361
            okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                                marked);
            }
#line 361
            if (! okay) {
              {
#line 363
              dir = (direction_type )4;
#line 364
              okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir,
                                  bitmap, marked);
              }
            }
          }
        } else
#line 368
        if ((unsigned int )dir == 4U) {
          {
#line 370
          dir = (direction_type )6;
#line 371
          okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                              marked);
          }
#line 371
          if (! okay) {
            {
#line 373
            dir = (direction_type )5;
#line 374
            okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                                marked);
            }
#line 374
            if (! okay) {
              {
#line 376
              dir = (direction_type )3;
#line 377
              okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir,
                                  bitmap, marked);
              }
            }
          }
        } else
#line 381
        if ((unsigned int )dir == 3U) {
          {
#line 383
          dir = (direction_type )5;
#line 384
          okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                              marked);
          }
#line 384
          if (! okay) {
            {
#line 386
            dir = (direction_type )6;
#line 387
            okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir, bitmap,
                                marked);
            }
#line 387
            if (! okay) {
              {
#line 389
              dir = (direction_type )4;
#line 390
              okay = is_valid_dir((unsigned short )row, (unsigned short )col, dir,
                                  bitmap, marked);
              }
            }
          }
        }
#line 394
        if (okay) {
          {
#line 396
          partial_outline = find_one_centerline(bitmap, dir, (unsigned short )row,
                                                (unsigned short )col, & marked);
#line 398
          concat_pixel_outline(& outline, (pixel_outline_type const   *)(& partial_outline));
          }
#line 399
          if (partial_outline.data) {
            {
#line 400
            free((void *)partial_outline.data);
            }
          }
        } else {
#line 403
          col = (short )((int )col + 1);
        }
      }
#line 410
      outline.clockwise = clockwise;
#line 411
      if (outline.length > 1U) {
        {
#line 412
        append_pixel_outline(& outline_list, outline);
        }
      }
      {
#line 413
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 413
        if (at_log_file) {
#line 413
          if (outline.open) {
#line 413
            tmp___200 = " open";
          } else {
#line 413
            tmp___200 = " closed";
          }
          {
#line 413
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"(%s)",
                  tmp___200);
          }
        }
#line 413
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 414
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 414
        if (at_log_file) {
          {
#line 414
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" [%u].\n",
                  outline.length);
          }
        }
#line 414
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 415
      if (outline.length == 1U) {
        {
#line 416
        free_pixel_outline(& outline);
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 268
    row = (short )((int )row + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  if (test_cancel) {
    {
#line 419
    tmp___201 = (*test_cancel)(testcancel_data);
    }
#line 419
    if (tmp___201) {
#line 421
      if (outline_list.length != 0U) {
        {
#line 422
        free_pixel_outline_list(& outline_list);
        }
      }
#line 423
      goto cleanup;
    }
  }
  cleanup: 
  {
#line 426
  free_bitmap(& marked);
#line 427
  flush_log_output();
  }
#line 428
  return (outline_list);
}
}
#line 432 "pxl-outline.c"
static pixel_outline_type find_one_centerline(bitmap_type bitmap , direction_type search_dir ,
                                              unsigned short original_row , unsigned short original_col ,
                                              bitmap_type *marked ) 
{ 
  pixel_outline_type outline ;
  pixel_outline_type tmp ;
  direction_type original_dir ;
  unsigned short row ;
  unsigned short col ;
  unsigned short prev_row ;
  unsigned short prev_col ;
  at_coord pos ;
  at_bool tmp___0 ;

  {
  {
#line 436
  tmp = new_pixel_outline();
#line 436
  outline = tmp;
#line 437
  original_dir = search_dir;
#line 438
  row = original_row;
#line 438
  col = original_col;
#line 442
  outline.open = (at_bool )0;
#line 443
  outline.color = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
#line 448
  pos.x = col;
#line 448
  pos.y = (unsigned short )(((int )bitmap.height - (int )row) - 1);
  }
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (at_log_file) {
      {
#line 449
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" (%d,%d)",
              (int )pos.x, (int )pos.y);
      }
    }
#line 449
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 450
  append_outline_pixel(& outline, pos);
  }
  {
#line 452
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 454
    prev_row = row;
#line 454
    prev_col = col;
#line 458
    tmp___0 = next_unmarked_pixel(& row, & col, & search_dir, bitmap, marked);
    }
#line 458
    if (! tmp___0) {
#line 461
      outline.open = (at_bool )1;
#line 462
      goto while_break___0;
    }
#line 467
    if ((int )prev_row == (int )original_row) {
#line 467
      if (! ((int )prev_col == (int )original_col)) {
        {
#line 468
        mark_dir(prev_row, prev_col, search_dir, marked);
        }
      }
    } else {
      {
#line 468
      mark_dir(prev_row, prev_col, search_dir, marked);
      }
    }
    {
#line 469
    mark_dir(row, col, (direction_type )(((unsigned int )search_dir + 4U) % 8U), marked);
    }
#line 472
    if ((int )row == (int )original_row) {
#line 472
      if ((int )col == (int )original_col) {
#line 473
        goto while_break___0;
      }
    }
#line 476
    pos.x = col;
#line 476
    pos.y = (unsigned short )(((int )bitmap.height - (int )row) - 1);
    {
#line 477
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 477
      if (at_log_file) {
        {
#line 477
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" (%d,%d)",
                (int )pos.x, (int )pos.y);
        }
      }
#line 477
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 478
    append_outline_pixel(& outline, pos);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 480
  mark_dir(original_row, original_col, original_dir, marked);
  }
#line 481
  return (outline);
}
}
#line 487 "pxl-outline.c"
static void append_pixel_outline(pixel_outline_list_type *outline_list , pixel_outline_type outline ) 
{ 
  at_address new_mem ;
  void *tmp ;
  void *tmp___1 ;

  {
#line 491
  (outline_list->length) ++;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if ((unsigned long )outline_list->data == (unsigned long )((void *)0)) {
      {
#line 492
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 492
        tmp = malloc((unsigned long )outline_list->length * sizeof(pixel_outline_type ));
#line 492
        new_mem = tmp;
        }
#line 492
        if (! new_mem) {
          {
#line 492
          __assert_fail("new_mem", "pxl-outline.c", 492U, "append_pixel_outline");
          }
        }
#line 492
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 492
      tmp___1 = realloc((void *)outline_list->data, (unsigned long )outline_list->length * sizeof(pixel_outline_type ));
#line 492
      new_mem = tmp___1;
      }
#line 492
      if (! new_mem) {
        {
#line 492
        __assert_fail("new_mem", "pxl-outline.c", 492U, "append_pixel_outline");
        }
      }
    }
#line 492
    outline_list->data = (pixel_outline_type *)new_mem;
#line 492
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  *(outline_list->data + (outline_list->length - 1U)) = outline;
#line 494
  return;
}
}
#line 499 "pxl-outline.c"
void free_pixel_outline_list(pixel_outline_list_type *outline_list ) 
{ 
  unsigned int this_outline ;
  pixel_outline_type o ;

  {
#line 504
  this_outline = 0U;
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! (this_outline < outline_list->length)) {
#line 504
      goto while_break;
    }
    {
#line 506
    o = *(outline_list->data + this_outline);
#line 507
    free_pixel_outline(& o);
#line 504
    this_outline ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  outline_list->length = 0U;
#line 511
  if ((unsigned long )outline_list->data != (unsigned long )((void *)0)) {
    {
#line 513
    free((void *)outline_list->data);
#line 514
    outline_list->data = (pixel_outline_type *)((void *)0);
    }
  }
  {
#line 517
  flush_log_output();
  }
#line 518
  return;
}
}
#line 524 "pxl-outline.c"
static pixel_outline_type new_pixel_outline(void) 
{ 
  pixel_outline_type pixel_outline ;

  {
#line 529
  pixel_outline.length = 0U;
#line 530
  pixel_outline.data = (at_coord *)((void *)0);
#line 531
  pixel_outline.open = (at_bool )0;
#line 533
  return (pixel_outline);
}
}
#line 536 "pxl-outline.c"
static void free_pixel_outline(pixel_outline_type *outline ) 
{ 


  {
#line 539
  if (outline->data) {
    {
#line 541
    free((void *)outline->data);
#line 542
    outline->data = (at_coord *)((void *)0);
#line 543
    outline->length = 0U;
    }
  }
#line 545
  return;
}
}
#line 550 "pxl-outline.c"
static void concat_pixel_outline(pixel_outline_type *o1 , pixel_outline_type const   *o2 ) 
{ 
  int src ;
  int dst ;
  unsigned int o1_length ;
  unsigned int o2_length ;
  at_address new_mem ;
  void *tmp ;
  void *tmp___1 ;

  {
#line 555
  if (! o1) {
#line 555
    return;
  } else
#line 555
  if (! o2) {
#line 555
    return;
  } else
#line 555
  if (o2->length <= 1U) {
#line 555
    return;
  }
#line 557
  o1_length = o1->length;
#line 558
  o2_length = (unsigned int )o2->length;
#line 559
  o1->length += o2_length - 1U;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if ((unsigned long )o1->data == (unsigned long )((void *)0)) {
      {
#line 562
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 562
        tmp = malloc((unsigned long )o1->length * sizeof(at_coord ));
#line 562
        new_mem = tmp;
        }
#line 562
        if (! new_mem) {
          {
#line 562
          __assert_fail("new_mem", "pxl-outline.c", 562U, "concat_pixel_outline");
          }
        }
#line 562
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 562
      tmp___1 = realloc((void *)o1->data, (unsigned long )o1->length * sizeof(at_coord ));
#line 562
      new_mem = tmp___1;
      }
#line 562
      if (! new_mem) {
        {
#line 562
        __assert_fail("new_mem", "pxl-outline.c", 562U, "concat_pixel_outline");
        }
      }
    }
#line 562
    o1->data = (at_coord *)new_mem;
#line 562
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  src = (int )(o1_length - 1U);
#line 565
  dst = (int )(o1->length - 1U);
  {
#line 565
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 565
    if (! (src >= 0)) {
#line 565
      goto while_break___1;
    }
#line 566
    *(o1->data + dst) = *(o1->data + src);
#line 565
    src --;
#line 565
    dst --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 568
  src = (int )(o2_length - 1U);
#line 568
  dst = 0;
  {
#line 568
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 568
    if (! (src > 0)) {
#line 568
      goto while_break___2;
    }
#line 569
    *(o1->data + dst) = *(o2->data + src);
#line 568
    src --;
#line 568
    dst ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 570
  return;
}
}
#line 575 "pxl-outline.c"
static void append_outline_pixel(pixel_outline_type *o , at_coord c ) 
{ 
  at_address new_mem ;
  void *tmp ;
  void *tmp___1 ;

  {
#line 578
  (o->length) ++;
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    if ((unsigned long )o->data == (unsigned long )((void *)0)) {
      {
#line 579
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 579
        tmp = malloc((unsigned long )o->length * sizeof(at_coord ));
#line 579
        new_mem = tmp;
        }
#line 579
        if (! new_mem) {
          {
#line 579
          __assert_fail("new_mem", "pxl-outline.c", 579U, "append_outline_pixel");
          }
        }
#line 579
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 579
      tmp___1 = realloc((void *)o->data, (unsigned long )o->length * sizeof(at_coord ));
#line 579
      new_mem = tmp___1;
      }
#line 579
      if (! new_mem) {
        {
#line 579
        __assert_fail("new_mem", "pxl-outline.c", 579U, "append_outline_pixel");
        }
      }
    }
#line 579
    o->data = (at_coord *)new_mem;
#line 579
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  *(o->data + (o->length - 1U)) = c;
#line 581
  return;
}
}
#line 586 "pxl-outline.c"
static at_bool is_unmarked_outline_edge(unsigned short row , unsigned short col ,
                                        edge_type edge , bitmap_type bitmap , bitmap_type marked ,
                                        color_type color , at_exception_type *exp ) 
{ 
  at_bool tmp ;
  at_bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 591
  tmp = is_marked_edge(edge, row, col, marked);
  }
#line 591
  if (tmp) {
#line 591
    tmp___1 = 0;
  } else {
    {
#line 591
    tmp___0 = is_outline_edge(edge, bitmap, row, col, color, exp);
    }
#line 591
    if (tmp___0) {
#line 591
      tmp___1 = 1;
    } else {
#line 591
      tmp___1 = 0;
    }
  }
#line 591
  return ((at_bool )tmp___1);
}
}
#line 600 "pxl-outline.c"
static at_bool is_outline_edge(edge_type edge , bitmap_type bitmap , unsigned short row ,
                               unsigned short col , color_type color , at_exception_type *exp ) 
{ 
  color_type tmp ;
  color_type tmp___0 ;
  color_type tmp___1 ;
  color_type tmp___2 ;
  color_type tmp___3 ;
  color_type tmp___4 ;
  int tmp___5 ;
  color_type tmp___6 ;
  color_type tmp___7 ;
  color_type tmp___8 ;
  int tmp___9 ;
  color_type tmp___10 ;
  color_type tmp___11 ;
  color_type tmp___12 ;
  int tmp___13 ;
  color_type tmp___14 ;
  color_type tmp___15 ;
  color_type tmp___16 ;
  int tmp___17 ;

  {
  {
#line 606
  tmp = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
  }
#line 606
  if ((int )tmp.r == (int )color.r) {
    {
#line 606
    tmp___0 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
    }
#line 606
    if ((int )tmp___0.g == (int )color.g) {
      {
#line 606
      tmp___1 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
      }
#line 606
      if (! ((int )tmp___1.b == (int )color.b)) {
#line 607
        return ((at_bool )0);
      }
    } else {
#line 607
      return ((at_bool )0);
    }
  } else {
#line 607
    return ((at_bool )0);
  }
  {
#line 611
  if ((unsigned int )edge == 2U) {
#line 611
    goto case_2;
  }
#line 614
  if ((unsigned int )edge == 1U) {
#line 614
    goto case_1;
  }
#line 617
  if ((unsigned int )edge == 0U) {
#line 617
    goto case_0;
  }
#line 621
  if ((unsigned int )edge == 3U) {
#line 621
    goto case_3;
  }
#line 626
  goto switch_default;
  case_2: /* CIL Label */ 
#line 612
  if ((int )col == 0) {
#line 612
    tmp___5 = 1;
  } else {
    {
#line 612
    tmp___2 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )((int )col - 1));
    }
#line 612
    if ((int )tmp___2.r == (int )color.r) {
      {
#line 612
      tmp___3 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )((int )col - 1));
      }
#line 612
      if ((int )tmp___3.g == (int )color.g) {
        {
#line 612
        tmp___4 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )((int )col - 1));
        }
#line 612
        if ((int )tmp___4.b == (int )color.b) {
#line 612
          tmp___5 = 0;
        } else {
#line 612
          tmp___5 = 1;
        }
      } else {
#line 612
        tmp___5 = 1;
      }
    } else {
#line 612
      tmp___5 = 1;
    }
  }
#line 612
  return ((at_bool )tmp___5);
  case_1: /* CIL Label */ 
#line 615
  if ((int )row == 0) {
#line 615
    tmp___9 = 1;
  } else {
    {
#line 615
    tmp___6 = GET_COLOR(bitmap, (unsigned int )((int )row - 1), (unsigned int )col);
    }
#line 615
    if ((int )tmp___6.r == (int )color.r) {
      {
#line 615
      tmp___7 = GET_COLOR(bitmap, (unsigned int )((int )row - 1), (unsigned int )col);
      }
#line 615
      if ((int )tmp___7.g == (int )color.g) {
        {
#line 615
        tmp___8 = GET_COLOR(bitmap, (unsigned int )((int )row - 1), (unsigned int )col);
        }
#line 615
        if ((int )tmp___8.b == (int )color.b) {
#line 615
          tmp___9 = 0;
        } else {
#line 615
          tmp___9 = 1;
        }
      } else {
#line 615
        tmp___9 = 1;
      }
    } else {
#line 615
      tmp___9 = 1;
    }
  }
#line 615
  return ((at_bool )tmp___9);
  case_0: /* CIL Label */ 
#line 618
  if ((int )col == (int )bitmap.width - 1) {
#line 618
    tmp___13 = 1;
  } else {
    {
#line 618
    tmp___10 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )((int )col + 1));
    }
#line 618
    if ((int )tmp___10.r == (int )color.r) {
      {
#line 618
      tmp___11 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )((int )col + 1));
      }
#line 618
      if ((int )tmp___11.g == (int )color.g) {
        {
#line 618
        tmp___12 = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )((int )col + 1));
        }
#line 618
        if ((int )tmp___12.b == (int )color.b) {
#line 618
          tmp___13 = 0;
        } else {
#line 618
          tmp___13 = 1;
        }
      } else {
#line 618
        tmp___13 = 1;
      }
    } else {
#line 618
      tmp___13 = 1;
    }
  }
#line 618
  return ((at_bool )tmp___13);
  case_3: /* CIL Label */ 
#line 622
  if ((int )row == (int )bitmap.height - 1) {
#line 622
    tmp___17 = 1;
  } else {
    {
#line 622
    tmp___14 = GET_COLOR(bitmap, (unsigned int )((int )row + 1), (unsigned int )col);
    }
#line 622
    if ((int )tmp___14.r == (int )color.r) {
      {
#line 622
      tmp___15 = GET_COLOR(bitmap, (unsigned int )((int )row + 1), (unsigned int )col);
      }
#line 622
      if ((int )tmp___15.g == (int )color.g) {
        {
#line 622
        tmp___16 = GET_COLOR(bitmap, (unsigned int )((int )row + 1), (unsigned int )col);
        }
#line 622
        if ((int )tmp___16.b == (int )color.b) {
#line 622
          tmp___17 = 0;
        } else {
#line 622
          tmp___17 = 1;
        }
      } else {
#line 622
        tmp___17 = 1;
      }
    } else {
#line 622
      tmp___17 = 1;
    }
  }
#line 622
  return ((at_bool )tmp___17);
  switch_default: /* CIL Label */ 
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (at_log_file) {
      {
#line 627
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"is_outline_edge: Bad edge value(%d)",
              (unsigned int )edge);
      }
    }
#line 627
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 628
  at_exception_fatal(exp, (at_string const   )"is_outline_edge: Bad edge value");
  }
  switch_break: /* CIL Label */ ;
  }
#line 631
  return ((at_bool )0);
}
}
#line 639 "pxl-outline.c"
static void mark_edge(edge_type edge , unsigned short row , unsigned short col , bitmap_type *marked ) 
{ 


  {
#line 642
  *((marked->bitmap + ((unsigned int )row * marked->np) * (unsigned int )marked->width) + (unsigned int )col * marked->np) = (unsigned char )((int )*((marked->bitmap + ((unsigned int )row * marked->np) * (unsigned int )marked->width) + (unsigned int )col * marked->np) | (1 << (unsigned int )edge));
#line 643
  return;
}
}
#line 648 "pxl-outline.c"
static void mark_dir(unsigned short row , unsigned short col , direction_type dir ,
                     bitmap_type *marked ) 
{ 


  {
#line 651
  *((marked->bitmap + ((unsigned int )row * marked->np) * (unsigned int )marked->width) + (unsigned int )col * marked->np) = (unsigned char )((int )*((marked->bitmap + ((unsigned int )row * marked->np) * (unsigned int )marked->width) + (unsigned int )col * marked->np) | (1 << (unsigned int )dir));
#line 652
  return;
}
}
#line 657 "pxl-outline.c"
static at_bool is_marked_dir(unsigned short row , unsigned short col , direction_type dir ,
                             bitmap_type marked ) 
{ 


  {
#line 660
  return ((at_bool )(((int )*((marked.bitmap + ((unsigned int )row * marked.np) * (unsigned int )marked.width) + (unsigned int )col * marked.np) & (1 << (unsigned int )dir)) != 0));
}
}
#line 664 "pxl-outline.c"
static at_bool is_other_dir_marked(unsigned short row , unsigned short col , direction_type dir ,
                                   bitmap_type marked ) 
{ 


  {
#line 667
  return ((at_bool )(((int )*((marked.bitmap + ((unsigned int )row * marked.np) * (unsigned int )marked.width) + (unsigned int )col * marked.np) & ((255 - (1 << (unsigned int )dir)) - (1 << ((unsigned int )dir + 4U) % 8U))) != 0));
}
}
#line 671 "pxl-outline.c"
static at_bool next_unmarked_pixel(unsigned short *row , unsigned short *col , direction_type *dir ,
                                   bitmap_type bitmap , bitmap_type *marked ) 
{ 
  color_type color ;
  unsigned int orig_row ;
  unsigned int orig_col ;
  direction_type orig_dir ;
  direction_type test_dir ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  at_bool tmp___13 ;
  at_bool tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  at_bool tmp___29 ;

  {
  {
#line 676
  orig_row = (unsigned int )*row;
#line 676
  orig_col = (unsigned int )*col;
#line 677
  orig_dir = *dir;
#line 677
  test_dir = *dir;
#line 679
  color = GET_COLOR(bitmap, (unsigned int )*row, (unsigned int )*col);
  }
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 682
    tmp___13 = is_valid_dir((unsigned short )orig_row, (unsigned short )orig_col,
                            test_dir, bitmap, *marked);
    }
#line 682
    if (tmp___13) {
#line 684
      if ((unsigned int )test_dir % 2U != 0U) {
#line 684
        if ((unsigned int )test_dir - 1U == 0U) {
#line 684
          tmp___0 = -1;
        } else {
#line 684
          if ((unsigned int )test_dir - 1U == 4U) {
#line 684
            tmp = 1;
          } else {
#line 684
            tmp = 0;
          }
#line 684
          tmp___0 = tmp;
        }
#line 684
        if (((unsigned int )test_dir + 1U) % 8U == 0U) {
#line 684
          tmp___2 = -1;
        } else {
#line 684
          if (((unsigned int )test_dir + 1U) % 8U == 4U) {
#line 684
            tmp___1 = 1;
          } else {
#line 684
            tmp___1 = 0;
          }
#line 684
          tmp___2 = tmp___1;
        }
#line 684
        tmp___5 = tmp___0 + tmp___2;
      } else {
#line 684
        if ((unsigned int )test_dir == 0U) {
#line 684
          tmp___4 = -1;
        } else {
#line 684
          if ((unsigned int )test_dir == 4U) {
#line 684
            tmp___3 = 1;
          } else {
#line 684
            tmp___3 = 0;
          }
#line 684
          tmp___4 = tmp___3;
        }
#line 684
        tmp___5 = tmp___4;
      }
#line 684
      *row = (unsigned short )(orig_row + (unsigned int )tmp___5);
#line 685
      if ((unsigned int )test_dir % 2U != 0U) {
#line 685
        if ((unsigned int )test_dir - 1U == 2U) {
#line 685
          tmp___7 = -1;
        } else {
#line 685
          if ((unsigned int )test_dir - 1U == 6U) {
#line 685
            tmp___6 = 1;
          } else {
#line 685
            tmp___6 = 0;
          }
#line 685
          tmp___7 = tmp___6;
        }
#line 685
        if (((unsigned int )test_dir + 1U) % 8U == 2U) {
#line 685
          tmp___9 = -1;
        } else {
#line 685
          if (((unsigned int )test_dir + 1U) % 8U == 6U) {
#line 685
            tmp___8 = 1;
          } else {
#line 685
            tmp___8 = 0;
          }
#line 685
          tmp___9 = tmp___8;
        }
#line 685
        tmp___12 = tmp___7 + tmp___9;
      } else {
#line 685
        if ((unsigned int )test_dir == 2U) {
#line 685
          tmp___11 = -1;
        } else {
#line 685
          if ((unsigned int )test_dir == 6U) {
#line 685
            tmp___10 = 1;
          } else {
#line 685
            tmp___10 = 0;
          }
#line 685
          tmp___11 = tmp___10;
        }
#line 685
        tmp___12 = tmp___11;
      }
#line 685
      *col = (unsigned short )(orig_col + (unsigned int )tmp___12);
#line 686
      *dir = test_dir;
#line 687
      goto while_break;
    }
#line 690
    if ((unsigned int )orig_dir == (unsigned int )test_dir) {
#line 691
      test_dir = (direction_type )(((unsigned int )orig_dir + 2U) % 8U);
    } else
#line 692
    if (((unsigned int )orig_dir + 2U) % 8U == (unsigned int )test_dir) {
#line 693
      test_dir = (direction_type )(((unsigned int )orig_dir + 6U) % 8U);
    } else
#line 694
    if (((unsigned int )orig_dir + 6U) % 8U == (unsigned int )test_dir) {
#line 695
      test_dir = (direction_type )(((unsigned int )orig_dir + 1U) % 8U);
    } else
#line 696
    if (((unsigned int )orig_dir + 1U) % 8U == (unsigned int )test_dir) {
#line 697
      test_dir = (direction_type )(((unsigned int )orig_dir + 7U) % 8U);
    } else
#line 698
    if (((unsigned int )orig_dir + 7U) % 8U == (unsigned int )test_dir) {
#line 699
      test_dir = (direction_type )(((unsigned int )orig_dir + 3U) % 8U);
    } else
#line 700
    if (((unsigned int )orig_dir + 3U) % 8U == (unsigned int )test_dir) {
#line 701
      test_dir = (direction_type )(((unsigned int )orig_dir + 5U) % 8U);
    } else
#line 702
    if (((unsigned int )orig_dir + 5U) % 8U == (unsigned int )test_dir) {
#line 703
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 706
  if ((unsigned int )*row != orig_row) {
#line 706
    goto _L;
  } else
#line 706
  if ((unsigned int )*col != orig_col) {
    _L: /* CIL Label */ 
    {
#line 706
    tmp___14 = is_other_dir_marked((unsigned short )orig_row, (unsigned short )orig_col,
                                   test_dir, *marked);
    }
#line 706
    if (tmp___14) {
#line 706
      if ((unsigned int )test_dir % 2U != 0U) {
#line 706
        if ((unsigned int )test_dir - 1U == 2U) {
#line 706
          tmp___16 = -1;
        } else {
#line 706
          if ((unsigned int )test_dir - 1U == 6U) {
#line 706
            tmp___15 = 1;
          } else {
#line 706
            tmp___15 = 0;
          }
#line 706
          tmp___16 = tmp___15;
        }
#line 706
        if (((unsigned int )test_dir + 1U) % 8U == 2U) {
#line 706
          tmp___18 = -1;
        } else {
#line 706
          if (((unsigned int )test_dir + 1U) % 8U == 6U) {
#line 706
            tmp___17 = 1;
          } else {
#line 706
            tmp___17 = 0;
          }
#line 706
          tmp___18 = tmp___17;
        }
#line 706
        tmp___21 = tmp___16 + tmp___18;
      } else {
#line 706
        if ((unsigned int )test_dir == 2U) {
#line 706
          tmp___20 = -1;
        } else {
#line 706
          if ((unsigned int )test_dir == 6U) {
#line 706
            tmp___19 = 1;
          } else {
#line 706
            tmp___19 = 0;
          }
#line 706
          tmp___20 = tmp___19;
        }
#line 706
        tmp___21 = tmp___20;
      }
#line 706
      if ((unsigned int )test_dir % 2U != 0U) {
#line 706
        if ((unsigned int )test_dir - 1U == 0U) {
#line 706
          tmp___23 = -1;
        } else {
#line 706
          if ((unsigned int )test_dir - 1U == 4U) {
#line 706
            tmp___22 = 1;
          } else {
#line 706
            tmp___22 = 0;
          }
#line 706
          tmp___23 = tmp___22;
        }
#line 706
        if (((unsigned int )test_dir + 1U) % 8U == 0U) {
#line 706
          tmp___25 = -1;
        } else {
#line 706
          if (((unsigned int )test_dir + 1U) % 8U == 4U) {
#line 706
            tmp___24 = 1;
          } else {
#line 706
            tmp___24 = 0;
          }
#line 706
          tmp___25 = tmp___24;
        }
#line 706
        tmp___28 = tmp___23 + tmp___25;
      } else {
#line 706
        if ((unsigned int )test_dir == 0U) {
#line 706
          tmp___27 = -1;
        } else {
#line 706
          if ((unsigned int )test_dir == 4U) {
#line 706
            tmp___26 = 1;
          } else {
#line 706
            tmp___26 = 0;
          }
#line 706
          tmp___27 = tmp___26;
        }
#line 706
        tmp___28 = tmp___27;
      }
      {
#line 706
      tmp___29 = is_other_dir_marked((unsigned short )(orig_row + (unsigned int )tmp___28),
                                     (unsigned short )(orig_col + (unsigned int )tmp___21),
                                     test_dir, *marked);
      }
#line 706
      if (tmp___29) {
#line 711
        return ((at_bool )0);
      } else {
#line 709
        return ((at_bool )1);
      }
    } else {
#line 709
      return ((at_bool )1);
    }
  } else {
#line 711
    return ((at_bool )0);
  }
}
}
#line 717 "pxl-outline.c"
static unsigned int num_neighbors(unsigned short row , unsigned short col , bitmap_type bitmap ) 
{ 
  unsigned int dir ;
  unsigned int count ;
  color_type color ;
  color_type tmp ;
  int delta_r ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int delta_c ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned int test_row ;
  unsigned int test_col ;
  color_type tmp___14 ;
  color_type tmp___15 ;
  color_type tmp___16 ;

  {
  {
#line 720
  count = 0U;
#line 721
  tmp = GET_COLOR(bitmap, (unsigned int )row, (unsigned int )col);
#line 721
  color = tmp;
#line 722
  dir = 0U;
  }
  {
#line 722
  while (1) {
    while_continue: /* CIL Label */ ;
#line 722
    if (! (dir <= 7U)) {
#line 722
      goto while_break;
    }
#line 724
    if (dir % 2U != 0U) {
#line 724
      if (dir - 1U == 0U) {
#line 724
        tmp___1 = -1;
      } else {
#line 724
        if (dir - 1U == 4U) {
#line 724
          tmp___0 = 1;
        } else {
#line 724
          tmp___0 = 0;
        }
#line 724
        tmp___1 = tmp___0;
      }
#line 724
      if ((dir + 1U) % 8U == 0U) {
#line 724
        tmp___3 = -1;
      } else {
#line 724
        if ((dir + 1U) % 8U == 4U) {
#line 724
          tmp___2 = 1;
        } else {
#line 724
          tmp___2 = 0;
        }
#line 724
        tmp___3 = tmp___2;
      }
#line 724
      tmp___6 = tmp___1 + tmp___3;
    } else {
#line 724
      if (dir == 0U) {
#line 724
        tmp___5 = -1;
      } else {
#line 724
        if (dir == 4U) {
#line 724
          tmp___4 = 1;
        } else {
#line 724
          tmp___4 = 0;
        }
#line 724
        tmp___5 = tmp___4;
      }
#line 724
      tmp___6 = tmp___5;
    }
#line 724
    delta_r = tmp___6;
#line 725
    if (dir % 2U != 0U) {
#line 725
      if (dir - 1U == 2U) {
#line 725
        tmp___8 = -1;
      } else {
#line 725
        if (dir - 1U == 6U) {
#line 725
          tmp___7 = 1;
        } else {
#line 725
          tmp___7 = 0;
        }
#line 725
        tmp___8 = tmp___7;
      }
#line 725
      if ((dir + 1U) % 8U == 2U) {
#line 725
        tmp___10 = -1;
      } else {
#line 725
        if ((dir + 1U) % 8U == 6U) {
#line 725
          tmp___9 = 1;
        } else {
#line 725
          tmp___9 = 0;
        }
#line 725
        tmp___10 = tmp___9;
      }
#line 725
      tmp___13 = tmp___8 + tmp___10;
    } else {
#line 725
      if (dir == 2U) {
#line 725
        tmp___12 = -1;
      } else {
#line 725
        if (dir == 6U) {
#line 725
          tmp___11 = 1;
        } else {
#line 725
          tmp___11 = 0;
        }
#line 725
        tmp___12 = tmp___11;
      }
#line 725
      tmp___13 = tmp___12;
    }
#line 725
    delta_c = tmp___13;
#line 726
    test_row = (unsigned int )((int )row + delta_r);
#line 727
    test_col = (unsigned int )((int )col + delta_c);
#line 728
    if (test_row < (unsigned int )bitmap.height) {
#line 728
      if (test_col < (unsigned int )bitmap.width) {
        {
#line 728
        tmp___14 = GET_COLOR(bitmap, test_row, test_col);
        }
#line 728
        if ((int )tmp___14.r == (int )color.r) {
          {
#line 728
          tmp___15 = GET_COLOR(bitmap, test_row, test_col);
          }
#line 728
          if ((int )tmp___15.g == (int )color.g) {
            {
#line 728
            tmp___16 = GET_COLOR(bitmap, test_row, test_col);
            }
#line 728
            if ((int )tmp___16.b == (int )color.b) {
#line 730
              count ++;
            }
          }
        }
      }
    }
#line 722
    dir ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 732
  return (count);
}
}
#line 738 "pxl-outline.c"
static at_bool is_marked_edge(edge_type edge , unsigned short row , unsigned short col ,
                              bitmap_type marked ) 
{ 
  int tmp ;

  {
#line 741
  if ((unsigned int )edge == 4U) {
#line 741
    tmp = 0;
  } else {
#line 741
    tmp = ((int )*((marked.bitmap + ((unsigned int )row * marked.np) * (unsigned int )marked.width) + (unsigned int )col * marked.np) & (1 << (unsigned int )edge)) != 0;
  }
#line 741
  return ((at_bool )tmp);
}
}
#line 745 "pxl-outline.c"
static at_coord next_point(bitmap_type bitmap , edge_type *edge , unsigned short *row ,
                           unsigned short *col , color_type color , at_bool clockwise ,
                           bitmap_type marked , at_exception_type *exp ) 
{ 
  at_coord pos ;
  at_bool tmp ;
  at_bool tmp___0 ;
  at_bool tmp___1 ;
  at_bool tmp___2 ;
  at_bool tmp___3 ;
  at_bool tmp___4 ;
  at_bool tmp___5 ;
  at_bool tmp___6 ;
  at_bool tmp___7 ;
  at_bool tmp___8 ;
  at_bool tmp___9 ;
  at_bool tmp___10 ;
  at_bool tmp___11 ;
  at_bool tmp___12 ;
  at_bool tmp___13 ;
  at_bool tmp___14 ;
  at_bool tmp___15 ;
  at_bool tmp___16 ;
  at_bool tmp___17 ;
  at_bool tmp___18 ;
  at_bool tmp___19 ;
  at_bool tmp___20 ;
  at_bool tmp___21 ;
  at_bool tmp___22 ;
  at_bool tmp___23 ;
  at_bool tmp___24 ;
  at_bool tmp___25 ;
  at_bool tmp___26 ;
  at_bool tmp___27 ;
  at_bool tmp___28 ;
  at_bool tmp___29 ;
  at_bool tmp___30 ;
  at_bool tmp___31 ;
  at_bool tmp___32 ;
  at_bool tmp___33 ;
  at_bool tmp___34 ;
  at_bool tmp___35 ;
  at_bool tmp___36 ;
  at_bool tmp___37 ;
  at_bool tmp___38 ;
  at_bool tmp___39 ;
  at_bool tmp___40 ;
  at_bool tmp___41 ;
  at_bool tmp___42 ;
  at_bool tmp___43 ;
  at_bool tmp___44 ;
  at_bool tmp___45 ;
  at_bool tmp___46 ;
  at_bool tmp___47 ;
  at_bool tmp___48 ;
  at_bool tmp___49 ;
  at_bool tmp___50 ;
  at_bool tmp___51 ;
  at_bool tmp___52 ;
  at_bool tmp___53 ;
  at_bool tmp___54 ;
  at_bool tmp___55 ;
  at_bool tmp___56 ;
  at_bool tmp___57 ;
  at_bool tmp___58 ;
  at_bool tmp___59 ;
  at_bool tmp___60 ;
  at_bool tmp___61 ;
  at_bool tmp___62 ;
  at_bool tmp___63 ;
  at_bool tmp___64 ;
  at_bool tmp___65 ;
  at_bool tmp___66 ;
  at_bool tmp___67 ;
  at_bool tmp___68 ;
  at_bool tmp___69 ;
  at_bool tmp___70 ;
  at_bool tmp___71 ;
  at_bool tmp___72 ;
  at_bool tmp___73 ;
  at_bool tmp___74 ;
  at_bool tmp___75 ;
  at_bool tmp___76 ;
  at_bool tmp___77 ;
  at_bool tmp___78 ;
  at_bool tmp___79 ;
  at_bool tmp___80 ;
  at_bool tmp___81 ;
  at_bool tmp___82 ;
  at_bool tmp___83 ;
  at_bool tmp___84 ;
  at_bool tmp___85 ;
  at_bool tmp___86 ;

  {
#line 749
  pos.x = (unsigned short)0;
#line 749
  pos.y = (unsigned short)0;
#line 751
  if (! clockwise) {
    {
#line 754
    if ((unsigned int )*edge == 1U) {
#line 754
      goto case_1;
    }
#line 793
    if ((unsigned int )*edge == 0U) {
#line 793
      goto case_0;
    }
#line 832
    if ((unsigned int )*edge == 3U) {
#line 832
      goto case_3;
    }
#line 871
    if ((unsigned int )*edge == 2U) {
#line 871
      goto case_2;
    }
#line 909
    goto switch_default;
    case_1: /* CIL Label */ 
#line 756
    if ((int )*col >= 1) {
      {
#line 756
      tmp = is_marked_edge((edge_type )1, *row, (unsigned short )((int )*col - 1),
                           marked);
      }
#line 756
      if (! tmp) {
        {
#line 756
        tmp___0 = is_outline_edge((edge_type )1, bitmap, *row, (unsigned short )((int )*col - 1),
                                  color, exp);
        }
#line 756
        if (tmp___0) {
#line 761
          *col = (unsigned short )((int )*col - 1);
#line 762
          pos.x = *col;
#line 763
          pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 764
          goto switch_break;
        }
      }
    }
    {
#line 766
    tmp___1 = at_exception_got_fatal(exp);
    }
#line 766
    if (tmp___1) {
#line 766
      goto cleanup;
    }
#line 768
    if ((int )*col >= 1) {
#line 768
      if ((int )*row >= 1) {
        {
#line 768
        tmp___2 = is_marked_edge((edge_type )0, (unsigned short )((int )*row - 1),
                                 (unsigned short )((int )*col - 1), marked);
        }
#line 768
        if (! tmp___2) {
          {
#line 768
          tmp___3 = is_outline_edge((edge_type )0, bitmap, (unsigned short )((int )*row - 1),
                                    (unsigned short )((int )*col - 1), color, exp);
          }
#line 768
          if (tmp___3) {
            {
#line 768
            tmp___4 = is_marked_edge((edge_type )2, (unsigned short )((int )*row - 1),
                                     *col, marked);
            }
#line 768
            if (tmp___4) {
              {
#line 768
              tmp___5 = is_marked_edge((edge_type )1, *row, (unsigned short )((int )*col - 1),
                                       marked);
              }
#line 768
              if (! tmp___5) {
#line 768
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              {
#line 768
              tmp___6 = is_marked_edge((edge_type )3, (unsigned short )((int )*row - 1),
                                       *col, marked);
              }
#line 768
              if (tmp___6) {
                {
#line 768
                tmp___7 = is_marked_edge((edge_type )0, *row, (unsigned short )((int )*col - 1),
                                         marked);
                }
#line 768
                if (! tmp___7) {
#line 768
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 774
                *edge = (edge_type )0;
#line 775
                *col = (unsigned short )((int )*col - 1);
#line 776
                *row = (unsigned short )((int )*row - 1);
#line 777
                pos.x = (unsigned short )((int )*col + 1);
#line 778
                pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 779
                goto switch_break;
              }
            }
          }
        }
      }
    }
    {
#line 781
    tmp___8 = at_exception_got_fatal(exp);
    }
#line 781
    if (tmp___8) {
#line 781
      goto cleanup;
    }
    {
#line 782
    tmp___9 = is_marked_edge((edge_type )2, *row, *col, marked);
    }
#line 782
    if (! tmp___9) {
      {
#line 782
      tmp___10 = is_outline_edge((edge_type )2, bitmap, *row, *col, color, exp);
      }
#line 782
      if (tmp___10) {
#line 785
        *edge = (edge_type )2;
#line 786
        pos.x = *col;
#line 787
        pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 788
        goto switch_break;
      }
    }
    {
#line 790
    tmp___11 = at_exception_got_fatal(exp);
    }
#line 790
    if (tmp___11) {
#line 790
      goto cleanup;
    }
#line 791
    *edge = (edge_type )4;
#line 792
    goto switch_break;
    case_0: /* CIL Label */ 
#line 795
    if ((int )*row >= 1) {
      {
#line 795
      tmp___12 = is_marked_edge((edge_type )0, (unsigned short )((int )*row - 1),
                                *col, marked);
      }
#line 795
      if (! tmp___12) {
        {
#line 795
        tmp___13 = is_outline_edge((edge_type )0, bitmap, (unsigned short )((int )*row - 1),
                                   *col, color, exp);
        }
#line 795
        if (tmp___13) {
#line 800
          *row = (unsigned short )((int )*row - 1);
#line 801
          pos.x = (unsigned short )((int )*col + 1);
#line 802
          pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 803
          goto switch_break;
        }
      }
    }
    {
#line 805
    tmp___14 = at_exception_got_fatal(exp);
    }
#line 805
    if (tmp___14) {
#line 805
      goto cleanup;
    }
#line 807
    if ((int )*col + 1 < (int )marked.width) {
#line 807
      if ((int )*row >= 1) {
        {
#line 807
        tmp___15 = is_marked_edge((edge_type )3, (unsigned short )((int )*row - 1),
                                  (unsigned short )((int )*col + 1), marked);
        }
#line 807
        if (! tmp___15) {
          {
#line 807
          tmp___16 = is_outline_edge((edge_type )3, bitmap, (unsigned short )((int )*row - 1),
                                     (unsigned short )((int )*col + 1), color, exp);
          }
#line 807
          if (tmp___16) {
            {
#line 807
            tmp___17 = is_marked_edge((edge_type )2, *row, (unsigned short )((int )*col + 1),
                                      marked);
            }
#line 807
            if (tmp___17) {
              {
#line 807
              tmp___18 = is_marked_edge((edge_type )3, (unsigned short )((int )*row - 1),
                                        *col, marked);
              }
#line 807
              if (! tmp___18) {
#line 807
                goto _L___2;
              }
            } else {
              _L___2: /* CIL Label */ 
              {
#line 807
              tmp___19 = is_marked_edge((edge_type )1, *row, (unsigned short )((int )*col + 1),
                                        marked);
              }
#line 807
              if (tmp___19) {
                {
#line 807
                tmp___20 = is_marked_edge((edge_type )0, (unsigned short )((int )*row - 1),
                                          *col, marked);
                }
#line 807
                if (! tmp___20) {
#line 807
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
#line 813
                *edge = (edge_type )3;
#line 814
                *col = (unsigned short )((int )*col + 1);
#line 815
                *row = (unsigned short )((int )*row - 1);
#line 816
                pos.x = (unsigned short )((int )*col + 1);
#line 817
                pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 818
                goto switch_break;
              }
            }
          }
        }
      }
    }
    {
#line 820
    tmp___21 = at_exception_got_fatal(exp);
    }
#line 820
    if (tmp___21) {
#line 820
      goto cleanup;
    }
    {
#line 821
    tmp___22 = is_marked_edge((edge_type )1, *row, *col, marked);
    }
#line 821
    if (! tmp___22) {
      {
#line 821
      tmp___23 = is_outline_edge((edge_type )1, bitmap, *row, *col, color, exp);
      }
#line 821
      if (tmp___23) {
#line 824
        *edge = (edge_type )1;
#line 825
        pos.x = *col;
#line 826
        pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 827
        goto switch_break;
      }
    }
    {
#line 829
    tmp___24 = at_exception_got_fatal(exp);
    }
#line 829
    if (tmp___24) {
#line 829
      goto cleanup;
    }
#line 830
    *edge = (edge_type )4;
#line 831
    goto switch_break;
    case_3: /* CIL Label */ 
#line 834
    if ((int )*col + 1 < (int )marked.width) {
      {
#line 834
      tmp___25 = is_marked_edge((edge_type )3, *row, (unsigned short )((int )*col + 1),
                                marked);
      }
#line 834
      if (! tmp___25) {
        {
#line 834
        tmp___26 = is_outline_edge((edge_type )3, bitmap, *row, (unsigned short )((int )*col + 1),
                                   color, exp);
        }
#line 834
        if (tmp___26) {
#line 839
          *col = (unsigned short )((int )*col + 1);
#line 840
          pos.x = (unsigned short )((int )*col + 1);
#line 841
          pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 842
          goto switch_break;
        }
      }
    }
    {
#line 844
    tmp___27 = at_exception_got_fatal(exp);
    }
#line 844
    if (tmp___27) {
#line 844
      goto cleanup;
    }
#line 846
    if ((int )*col + 1 < (int )marked.width) {
#line 846
      if ((int )*row + 1 < (int )marked.height) {
        {
#line 846
        tmp___28 = is_marked_edge((edge_type )2, (unsigned short )((int )*row + 1),
                                  (unsigned short )((int )*col + 1), marked);
        }
#line 846
        if (! tmp___28) {
          {
#line 846
          tmp___29 = is_outline_edge((edge_type )2, bitmap, (unsigned short )((int )*row + 1),
                                     (unsigned short )((int )*col + 1), color, exp);
          }
#line 846
          if (tmp___29) {
            {
#line 846
            tmp___30 = is_marked_edge((edge_type )1, (unsigned short )((int )*row + 1),
                                      *col, marked);
            }
#line 846
            if (tmp___30) {
              {
#line 846
              tmp___31 = is_marked_edge((edge_type )2, *row, (unsigned short )((int )*col + 1),
                                        marked);
              }
#line 846
              if (! tmp___31) {
#line 846
                goto _L___4;
              }
            } else {
              _L___4: /* CIL Label */ 
              {
#line 846
              tmp___32 = is_marked_edge((edge_type )0, (unsigned short )((int )*row + 1),
                                        *col, marked);
              }
#line 846
              if (tmp___32) {
                {
#line 846
                tmp___33 = is_marked_edge((edge_type )3, *row, (unsigned short )((int )*col + 1),
                                          marked);
                }
#line 846
                if (! tmp___33) {
#line 846
                  goto _L___3;
                }
              } else {
                _L___3: /* CIL Label */ 
#line 852
                *edge = (edge_type )2;
#line 853
                *col = (unsigned short )((int )*col + 1);
#line 854
                *row = (unsigned short )((int )*row + 1);
#line 855
                pos.x = *col;
#line 856
                pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 857
                goto switch_break;
              }
            }
          }
        }
      }
    }
    {
#line 859
    tmp___34 = at_exception_got_fatal(exp);
    }
#line 859
    if (tmp___34) {
#line 859
      goto cleanup;
    }
    {
#line 860
    tmp___35 = is_marked_edge((edge_type )0, *row, *col, marked);
    }
#line 860
    if (! tmp___35) {
      {
#line 860
      tmp___36 = is_outline_edge((edge_type )0, bitmap, *row, *col, color, exp);
      }
#line 860
      if (tmp___36) {
#line 863
        *edge = (edge_type )0;
#line 864
        pos.x = (unsigned short )((int )*col + 1);
#line 865
        pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 866
        goto switch_break;
      }
    }
    {
#line 868
    tmp___37 = at_exception_got_fatal(exp);
    }
#line 868
    if (tmp___37) {
#line 868
      goto cleanup;
    }
#line 869
    *edge = (edge_type )4;
#line 870
    goto switch_break;
    case_2: /* CIL Label */ 
#line 873
    if ((int )*row + 1 < (int )marked.height) {
      {
#line 873
      tmp___38 = is_marked_edge((edge_type )2, (unsigned short )((int )*row + 1),
                                *col, marked);
      }
#line 873
      if (! tmp___38) {
        {
#line 873
        tmp___39 = is_outline_edge((edge_type )2, bitmap, (unsigned short )((int )*row + 1),
                                   *col, color, exp);
        }
#line 873
        if (tmp___39) {
#line 878
          *row = (unsigned short )((int )*row + 1);
#line 879
          pos.x = *col;
#line 880
          pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 881
          goto switch_break;
        }
      }
    }
    {
#line 883
    tmp___40 = at_exception_got_fatal(exp);
    }
#line 883
    if (tmp___40) {
#line 883
      goto cleanup;
    }
#line 885
    if ((int )*col >= 1) {
#line 885
      if ((int )*row + 1 < (int )marked.height) {
        {
#line 885
        tmp___41 = is_marked_edge((edge_type )1, (unsigned short )((int )*row + 1),
                                  (unsigned short )((int )*col - 1), marked);
        }
#line 885
        if (! tmp___41) {
          {
#line 885
          tmp___42 = is_outline_edge((edge_type )1, bitmap, (unsigned short )((int )*row + 1),
                                     (unsigned short )((int )*col - 1), color, exp);
          }
#line 885
          if (tmp___42) {
            {
#line 885
            tmp___43 = is_marked_edge((edge_type )0, *row, (unsigned short )((int )*col - 1),
                                      marked);
            }
#line 885
            if (tmp___43) {
              {
#line 885
              tmp___44 = is_marked_edge((edge_type )1, (unsigned short )((int )*row + 1),
                                        *col, marked);
              }
#line 885
              if (! tmp___44) {
#line 885
                goto _L___6;
              }
            } else {
              _L___6: /* CIL Label */ 
              {
#line 885
              tmp___45 = is_marked_edge((edge_type )3, *row, (unsigned short )((int )*col - 1),
                                        marked);
              }
#line 885
              if (tmp___45) {
                {
#line 885
                tmp___46 = is_marked_edge((edge_type )2, (unsigned short )((int )*row + 1),
                                          *col, marked);
                }
#line 885
                if (! tmp___46) {
#line 885
                  goto _L___5;
                }
              } else {
                _L___5: /* CIL Label */ 
#line 891
                *edge = (edge_type )1;
#line 892
                *col = (unsigned short )((int )*col - 1);
#line 893
                *row = (unsigned short )((int )*row + 1);
#line 894
                pos.x = *col;
#line 895
                pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 896
                goto switch_break;
              }
            }
          }
        }
      }
    }
    {
#line 898
    tmp___47 = at_exception_got_fatal(exp);
    }
#line 898
    if (tmp___47) {
#line 898
      goto cleanup;
    }
    {
#line 899
    tmp___48 = is_marked_edge((edge_type )3, *row, *col, marked);
    }
#line 899
    if (! tmp___48) {
      {
#line 899
      tmp___49 = is_outline_edge((edge_type )3, bitmap, *row, *col, color, exp);
      }
#line 899
      if (tmp___49) {
#line 902
        *edge = (edge_type )3;
#line 903
        pos.x = (unsigned short )((int )*col + 1);
#line 904
        pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 905
        goto switch_break;
      }
    }
    {
#line 907
    tmp___50 = at_exception_got_fatal(exp);
    }
#line 907
    if (tmp___50) {
#line 907
      goto cleanup;
    }
    switch_default: /* CIL Label */ 
#line 910
    *edge = (edge_type )4;
#line 911
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 916
    if ((unsigned int )*edge == 1U) {
#line 916
      goto case_1___0;
    }
#line 953
    if ((unsigned int )*edge == 0U) {
#line 953
      goto case_0___0;
    }
#line 990
    if ((unsigned int )*edge == 3U) {
#line 990
      goto case_3___0;
    }
#line 1027
    if ((unsigned int )*edge == 2U) {
#line 1027
      goto case_2___0;
    }
#line 1063
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 917
    tmp___51 = is_marked_edge((edge_type )2, *row, *col, marked);
    }
#line 917
    if (! tmp___51) {
      {
#line 917
      tmp___52 = is_outline_edge((edge_type )2, bitmap, *row, *col, color, exp);
      }
#line 917
      if (tmp___52) {
#line 920
        *edge = (edge_type )2;
#line 921
        pos.x = *col;
#line 922
        pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 923
        goto switch_break___0;
      }
    }
    {
#line 925
    tmp___53 = at_exception_got_fatal(exp);
    }
#line 925
    if (tmp___53) {
#line 925
      goto cleanup;
    }
#line 927
    if ((int )*col >= 1) {
      {
#line 927
      tmp___54 = is_marked_edge((edge_type )1, *row, (unsigned short )((int )*col - 1),
                                marked);
      }
#line 927
      if (! tmp___54) {
        {
#line 927
        tmp___55 = is_outline_edge((edge_type )1, bitmap, *row, (unsigned short )((int )*col - 1),
                                   color, exp);
        }
#line 927
        if (tmp___55) {
#line 932
          *col = (unsigned short )((int )*col - 1);
#line 933
          pos.x = *col;
#line 934
          pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 935
          goto switch_break___0;
        }
      }
    }
    {
#line 937
    tmp___56 = at_exception_got_fatal(exp);
    }
#line 937
    if (tmp___56) {
#line 937
      goto cleanup;
    }
#line 939
    if ((int )*col >= 1) {
#line 939
      if ((int )*row >= 1) {
        {
#line 939
        tmp___57 = is_marked_edge((edge_type )0, (unsigned short )((int )*row - 1),
                                  (unsigned short )((int )*col - 1), marked);
        }
#line 939
        if (! tmp___57) {
          {
#line 939
          tmp___58 = is_outline_edge((edge_type )0, bitmap, (unsigned short )((int )*row - 1),
                                     (unsigned short )((int )*col - 1), color, exp);
          }
#line 939
          if (tmp___58) {
#line 943
            *edge = (edge_type )0;
#line 944
            *col = (unsigned short )((int )*col - 1);
#line 945
            *row = (unsigned short )((int )*row - 1);
#line 946
            pos.x = (unsigned short )((int )*col + 1);
#line 947
            pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 948
            goto switch_break___0;
          }
        }
      }
    }
    {
#line 950
    tmp___59 = at_exception_got_fatal(exp);
    }
#line 950
    if (tmp___59) {
#line 950
      goto cleanup;
    }
#line 951
    *edge = (edge_type )4;
#line 952
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 954
    tmp___60 = is_marked_edge((edge_type )1, *row, *col, marked);
    }
#line 954
    if (! tmp___60) {
      {
#line 954
      tmp___61 = is_outline_edge((edge_type )1, bitmap, *row, *col, color, exp);
      }
#line 954
      if (tmp___61) {
#line 957
        *edge = (edge_type )1;
#line 958
        pos.x = *col;
#line 959
        pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 960
        goto switch_break___0;
      }
    }
    {
#line 962
    tmp___62 = at_exception_got_fatal(exp);
    }
#line 962
    if (tmp___62) {
#line 962
      goto cleanup;
    }
#line 964
    if ((int )*row >= 1) {
      {
#line 964
      tmp___63 = is_marked_edge((edge_type )0, (unsigned short )((int )*row - 1),
                                *col, marked);
      }
#line 964
      if (! tmp___63) {
        {
#line 964
        tmp___64 = is_outline_edge((edge_type )0, bitmap, (unsigned short )((int )*row - 1),
                                   *col, color, exp);
        }
#line 964
        if (tmp___64) {
#line 969
          *row = (unsigned short )((int )*row - 1);
#line 970
          pos.x = (unsigned short )((int )*col + 1);
#line 971
          pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 972
          goto switch_break___0;
        }
      }
    }
    {
#line 974
    tmp___65 = at_exception_got_fatal(exp);
    }
#line 974
    if (tmp___65) {
#line 974
      goto cleanup;
    }
#line 976
    if ((int )*col + 1 < (int )marked.width) {
#line 976
      if ((int )*row >= 1) {
        {
#line 976
        tmp___66 = is_marked_edge((edge_type )3, (unsigned short )((int )*row - 1),
                                  (unsigned short )((int )*col + 1), marked);
        }
#line 976
        if (! tmp___66) {
          {
#line 976
          tmp___67 = is_outline_edge((edge_type )3, bitmap, (unsigned short )((int )*row - 1),
                                     (unsigned short )((int )*col + 1), color, exp);
          }
#line 976
          if (tmp___67) {
#line 980
            *edge = (edge_type )3;
#line 981
            *col = (unsigned short )((int )*col + 1);
#line 982
            *row = (unsigned short )((int )*row - 1);
#line 983
            pos.x = (unsigned short )((int )*col + 1);
#line 984
            pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 985
            goto switch_break___0;
          }
        }
      }
    }
    {
#line 987
    tmp___68 = at_exception_got_fatal(exp);
    }
#line 987
    if (tmp___68) {
#line 987
      goto cleanup;
    }
#line 988
    *edge = (edge_type )4;
#line 989
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 991
    tmp___69 = is_marked_edge((edge_type )0, *row, *col, marked);
    }
#line 991
    if (! tmp___69) {
      {
#line 991
      tmp___70 = is_outline_edge((edge_type )0, bitmap, *row, *col, color, exp);
      }
#line 991
      if (tmp___70) {
#line 994
        *edge = (edge_type )0;
#line 995
        pos.x = (unsigned short )((int )*col + 1);
#line 996
        pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 997
        goto switch_break___0;
      }
    }
    {
#line 999
    tmp___71 = at_exception_got_fatal(exp);
    }
#line 999
    if (tmp___71) {
#line 999
      goto cleanup;
    }
#line 1001
    if ((int )*col + 1 < (int )marked.width) {
      {
#line 1001
      tmp___72 = is_marked_edge((edge_type )3, *row, (unsigned short )((int )*col + 1),
                                marked);
      }
#line 1001
      if (! tmp___72) {
        {
#line 1001
        tmp___73 = is_outline_edge((edge_type )3, bitmap, *row, (unsigned short )((int )*col + 1),
                                   color, exp);
        }
#line 1001
        if (tmp___73) {
#line 1006
          *col = (unsigned short )((int )*col + 1);
#line 1007
          pos.x = (unsigned short )((int )*col + 1);
#line 1008
          pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 1009
          goto switch_break___0;
        }
      }
    }
    {
#line 1011
    tmp___74 = at_exception_got_fatal(exp);
    }
#line 1011
    if (tmp___74) {
#line 1011
      goto cleanup;
    }
#line 1013
    if ((int )*col + 1 < (int )marked.width) {
#line 1013
      if ((int )*row + 1 < (int )marked.height) {
        {
#line 1013
        tmp___75 = is_marked_edge((edge_type )2, (unsigned short )((int )*row + 1),
                                  (unsigned short )((int )*col + 1), marked);
        }
#line 1013
        if (! tmp___75) {
          {
#line 1013
          tmp___76 = is_outline_edge((edge_type )2, bitmap, (unsigned short )((int )*row + 1),
                                     (unsigned short )((int )*col + 1), color, exp);
          }
#line 1013
          if (tmp___76) {
#line 1017
            *edge = (edge_type )2;
#line 1018
            *col = (unsigned short )((int )*col + 1);
#line 1019
            *row = (unsigned short )((int )*row + 1);
#line 1020
            pos.x = *col;
#line 1021
            pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 1022
            goto switch_break___0;
          }
        }
      }
    }
    {
#line 1024
    tmp___77 = at_exception_got_fatal(exp);
    }
#line 1024
    if (tmp___77) {
#line 1024
      goto cleanup;
    }
#line 1025
    *edge = (edge_type )4;
#line 1026
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 1028
    tmp___78 = is_marked_edge((edge_type )3, *row, *col, marked);
    }
#line 1028
    if (! tmp___78) {
      {
#line 1028
      tmp___79 = is_outline_edge((edge_type )3, bitmap, *row, *col, color, exp);
      }
#line 1028
      if (tmp___79) {
#line 1031
        *edge = (edge_type )3;
#line 1032
        pos.x = (unsigned short )((int )*col + 1);
#line 1033
        pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 1034
        goto switch_break___0;
      }
    }
    {
#line 1036
    tmp___80 = at_exception_got_fatal(exp);
    }
#line 1036
    if (tmp___80) {
#line 1036
      goto cleanup;
    }
#line 1038
    if ((int )*row + 1 < (int )marked.height) {
      {
#line 1038
      tmp___81 = is_marked_edge((edge_type )2, (unsigned short )((int )*row + 1),
                                *col, marked);
      }
#line 1038
      if (! tmp___81) {
        {
#line 1038
        tmp___82 = is_outline_edge((edge_type )2, bitmap, (unsigned short )((int )*row + 1),
                                   *col, color, exp);
        }
#line 1038
        if (tmp___82) {
#line 1043
          *row = (unsigned short )((int )*row + 1);
#line 1044
          pos.x = *col;
#line 1045
          pos.y = (unsigned short )(((int )bitmap.height - (int )*row) - 1);
#line 1046
          goto switch_break___0;
        }
      }
    }
    {
#line 1048
    tmp___83 = at_exception_got_fatal(exp);
    }
#line 1048
    if (tmp___83) {
#line 1048
      goto cleanup;
    }
#line 1050
    if ((int )*col >= 1) {
#line 1050
      if ((int )*row + 1 < (int )marked.height) {
        {
#line 1050
        tmp___84 = is_marked_edge((edge_type )1, (unsigned short )((int )*row + 1),
                                  (unsigned short )((int )*col - 1), marked);
        }
#line 1050
        if (! tmp___84) {
          {
#line 1050
          tmp___85 = is_outline_edge((edge_type )1, bitmap, (unsigned short )((int )*row + 1),
                                     (unsigned short )((int )*col - 1), color, exp);
          }
#line 1050
          if (tmp___85) {
#line 1054
            *edge = (edge_type )1;
#line 1055
            *col = (unsigned short )((int )*col - 1);
#line 1056
            *row = (unsigned short )((int )*row + 1);
#line 1057
            pos.x = *col;
#line 1058
            pos.y = (unsigned short )((int )bitmap.height - (int )*row);
#line 1059
            goto switch_break___0;
          }
        }
      }
    }
    {
#line 1061
    tmp___86 = at_exception_got_fatal(exp);
    }
#line 1061
    if (tmp___86) {
#line 1061
      goto cleanup;
    }
    switch_default___0: /* CIL Label */ 
#line 1064
    *edge = (edge_type )4;
#line 1065
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  cleanup: 
#line 1068
  return (pos);
}
}
#line 25 "output-svg.h"
int output_svg_writer(FILE *file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) ;
#line 28 "output-svg.c"
static void out_splines(FILE *file , at_spline_list_array_type shape , int height ) 
{ 
  unsigned int this_list ;
  spline_list_type list ;
  color_type last_color ;
  unsigned int this_spline ;
  spline_type first ;
  char const   *tmp ;
  char const   *tmp___0 ;
  spline_type s ;

  {
#line 33
  last_color.r = (unsigned char)0;
#line 33
  last_color.g = (unsigned char)0;
#line 33
  last_color.b = (unsigned char)0;
#line 35
  this_list = 0U;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (this_list < shape.length)) {
#line 35
      goto while_break;
    }
#line 41
    list = *(shape.data + this_list);
#line 42
    first = *(list.data + 0);
#line 44
    if (this_list == 0U) {
#line 44
      goto _L___1;
    } else
#line 44
    if ((int )list.color.r == (int )last_color.r) {
#line 44
      if ((int )list.color.g == (int )last_color.g) {
#line 44
        if (! ((int )list.color.b == (int )last_color.b)) {
#line 44
          goto _L___1;
        }
      } else {
#line 44
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 46
      if (this_list > 0U) {
#line 48
        if (! shape.centerline) {
#line 48
          if (! list.open) {
            {
#line 48
            fputs((char const   */* __restrict  */)"z", (FILE */* __restrict  */)file);
            }
          }
        }
        {
#line 49
        fputs((char const   */* __restrict  */)"\"/>\n", (FILE */* __restrict  */)file);
        }
      }
#line 51
      if (shape.centerline) {
#line 51
        tmp = "fill";
      } else
#line 51
      if (list.open) {
#line 51
        tmp = "fill";
      } else {
#line 51
        tmp = "stroke";
      }
#line 51
      if (shape.centerline) {
#line 51
        tmp___0 = "stroke";
      } else
#line 51
      if (list.open) {
#line 51
        tmp___0 = "stroke";
      } else {
#line 51
        tmp___0 = "fill";
      }
      {
#line 51
      fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"<path style=\"%s:#%02x%02x%02x; %s:none;\" d=\"",
              tmp___0, (int )list.color.r, (int )list.color.g, (int )list.color.b,
              tmp);
      }
    }
    {
#line 56
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"M%g %g",
            (double )first.v[0].x, (double )((at_real )height - first.v[0].y));
#line 58
    this_spline = 0U;
    }
    {
#line 58
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 58
      if (! (this_spline < list.length)) {
#line 58
        goto while_break___0;
      }
#line 61
      s = *(list.data + this_spline);
#line 64
      if ((unsigned int )s.degree == 1U) {
        {
#line 66
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"L%g %g",
                (double )s.v[3].x, (double )((at_real )height - s.v[3].y));
        }
      } else {
        {
#line 71
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"C%g %g %g %g %g %g",
                (double )s.v[1].x, (double )((at_real )height - s.v[1].y), (double )s.v[2].x,
                (double )((at_real )height - s.v[2].y), (double )s.v[3].x, (double )((at_real )height - s.v[3].y));
        }
      }
#line 76
      last_color = list.color;
#line 58
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 35
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  if (! shape.centerline) {
#line 79
    if (! list.open) {
      {
#line 79
      fputs((char const   */* __restrict  */)"z", (FILE */* __restrict  */)file);
      }
    }
  }
#line 80
  if (shape.length > 0U) {
    {
#line 81
    fputs((char const   */* __restrict  */)"\"/>\n", (FILE */* __restrict  */)file);
    }
  }
#line 82
  return;
}
}
#line 85 "output-svg.c"
int output_svg_writer(FILE *file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) 
{ 
  int width ;
  int height ;

  {
  {
#line 92
  width = urx - llx;
#line 93
  height = ury - lly;
#line 94
  fputs((char const   */* __restrict  */)"<?xml version=\"1.0\" standalone=\"yes\"?>\n",
        (FILE */* __restrict  */)file);
#line 95
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"<svg width=\"%d\" height=\"%d\">\n",
          width, height);
#line 97
  out_splines(file, shape, height);
#line 98
  fputs((char const   */* __restrict  */)"</svg>\n", (FILE */* __restrict  */)file);
  }
#line 100
  return (0);
}
}
#line 25 "output-sk.h"
int output_sk_writer(FILE *file , at_string name , int llx , int lly , int urx , int ury ,
                     at_output_opts_type *opts , at_spline_list_array_type shape ,
                     void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                     at_address msg_data ) ;
#line 28 "output-sk.c"
static void out_splines___0(FILE *file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  spline_list_type list ;
  color_type last_color ;
  unsigned int this_spline ;
  spline_type first ;
  char const   *tmp ;
  char const   *tmp___0 ;
  spline_type s ;

  {
#line 34
  last_color.r = (unsigned char)0;
#line 34
  last_color.g = (unsigned char)0;
#line 34
  last_color.b = (unsigned char)0;
#line 36
  this_list = 0U;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (this_list < shape.length)) {
#line 36
      goto while_break;
    }
#line 42
    list = *(shape.data + this_list);
#line 43
    first = *(list.data + 0);
#line 45
    if (this_list == 0U) {
#line 45
      goto _L___1;
    } else
#line 45
    if ((int )list.color.r == (int )last_color.r) {
#line 45
      if ((int )list.color.g == (int )last_color.g) {
#line 45
        if (! ((int )list.color.b == (int )last_color.b)) {
#line 45
          goto _L___1;
        }
      } else {
#line 45
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 47
      if (this_list > 0U) {
#line 47
        if (! shape.centerline) {
          {
#line 48
          fputs((char const   */* __restrict  */)"bC()\n", (FILE */* __restrict  */)file);
          }
        }
      }
#line 49
      if (shape.centerline) {
#line 49
        tmp = "lp((%g,%g,%g))\n";
      } else
#line 49
      if (list.open) {
#line 49
        tmp = "lp((%g,%g,%g))\n";
      } else {
#line 49
        tmp = "fp((%g,%g,%g))\n";
      }
      {
#line 49
      fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)tmp,
              (double )list.color.r / 255.0, (double )list.color.g / 255.0, (double )list.color.b / 255.0);
      }
#line 52
      if (shape.centerline) {
#line 52
        tmp___0 = "fe()\n";
      } else
#line 52
      if (list.open) {
#line 52
        tmp___0 = "fe()\n";
      } else {
#line 52
        tmp___0 = "le()\n";
      }
      {
#line 52
      fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)file);
#line 53
      last_color = list.color;
#line 54
      fputs((char const   */* __restrict  */)"b()\n", (FILE */* __restrict  */)file);
      }
    }
    {
#line 57
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"bs(%g,%g,0)\n",
            (double )first.v[0].x, (double )first.v[0].y);
#line 60
    this_spline = 0U;
    }
    {
#line 60
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 60
      if (! (this_spline < list.length)) {
#line 60
        goto while_break___0;
      }
#line 63
      s = *(list.data + this_spline);
#line 65
      if ((unsigned int )s.degree == 1U) {
        {
#line 66
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"bs(%g,%g,0)\n",
                (double )s.v[3].x, (double )s.v[3].y);
        }
      } else {
        {
#line 68
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"bc(%g,%g,%g,%g,%g,%g,0)\n",
                (double )s.v[1].x, (double )s.v[1].y, (double )s.v[2].x, (double )s.v[2].y,
                (double )s.v[3].x, (double )s.v[3].y);
        }
      }
#line 60
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 36
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  if (shape.length > 0U) {
#line 74
    if (! shape.centerline) {
      {
#line 75
      fputs((char const   */* __restrict  */)"bC()\n", (FILE */* __restrict  */)file);
      }
    }
  }
#line 76
  return;
}
}
#line 79 "output-sk.c"
int output_sk_writer(FILE *file , at_string name , int llx , int lly , int urx , int ury ,
                     at_output_opts_type *opts , at_spline_list_array_type shape ,
                     void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                     at_address msg_data ) 
{ 


  {
  {
#line 85
  fputs((char const   */* __restrict  */)"##Sketch 1 0\n", (FILE */* __restrict  */)file);
#line 86
  fputs((char const   */* __restrict  */)"document()\n", (FILE */* __restrict  */)file);
#line 87
  fputs((char const   */* __restrict  */)"layer(\'Layer 1\',1,1,0,0)\n", (FILE */* __restrict  */)file);
#line 88
  fputs((char const   */* __restrict  */)"guess_cont()\n", (FILE */* __restrict  */)file);
#line 90
  out_splines___0(file, shape);
  }
#line 91
  return (0);
}
}
#line 43 "/usr/include/pstoedit/pstoedll.h"
static unsigned int const   pstoeditdllversion  =    (unsigned int const   )301;
#line 91 "/usr/include/pstoedit/pstoedit.h"
extern int pstoedit_plainC(int argc , char const   * const  *argv , char const   * const  psinterpreter ) ;
#line 100
extern struct DriverDescription_S *getPstoeditDriverInfo_plainC(void) ;
#line 120
extern int pstoedit_checkversion(unsigned int callersversion ) ;
#line 144 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) tmpnam)(char *__s ) ;
#line 477
extern int fgetc(FILE *__stream ) ;
#line 517
extern int fputc(int __c , FILE *__stream ) ;
#line 26 "output-pstoedit.h"
at_output_write_func output_pstoedit_get_writer(at_string const   suffix ) ;
#line 27
at_bool output_pstoedit_is_writer(int (*writer)(FILE * , at_string name , int llx ,
                                                int lly , int urx , int ury , at_output_opts_type *opts ,
                                                at_spline_list_array_type shape ,
                                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                                 at_address client_data ) ,
                                                at_address msg_data ) ) ;
#line 28
int output_pstoedit_invoke_writer(int (*writer)(FILE * , at_string name , int llx ,
                                                int lly , int urx , int ury , at_output_opts_type *opts ,
                                                at_spline_list_array_type shape ,
                                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                                 at_address client_data ) ,
                                                at_address msg_data ) , FILE *file ,
                                  at_string name , int llx , int lly , int urx , int ury ,
                                  at_output_opts_type *opts , at_spline_list_array_type shape ,
                                  void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                   at_address client_data ) , at_address msg_data ) ;
#line 35
at_bool output_pstoedit_is_unusable_writer(at_string const   name ) ;
#line 25 "output-p2e.h"
int output_p2e_writer(FILE *ps_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) ;
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 55 "output-pstoedit.c"
static char **pstoedit_suffix_table  =    (char **)((void *)0);
#line 56
static void pstoedit_suffix_table_init(void) ;
#line 57
static at_string pstoedit_suffix_table_lookup_deep(at_string const   suffix ) ;
#line 58
static at_bool pstoedit_suffix_table_lookup_shallow(void const   *suffix ) ;
#line 59
static at_string const   get_symbolicname(at_string const   suffix ) ;
#line 61
static int output_pstoedit_writer(at_string const   suffix , FILE *file , at_string name ,
                                  int llx , int lly , int urx , int ury , at_output_opts_type *opts ,
                                  at_spline_list_array_type shape , void (*msg_func)(at_string msg ,
                                                                                     at_msg_type msg_type ,
                                                                                     at_address client_data ) ,
                                  at_address msg_data ) ;
#line 69
static void remove_temporary_file(at_string const   tmpfile_name ) ;
#line 70
static FILE *make_temporary_file(char *template , char *mode ) ;
#line 72 "output-pstoedit.c"
static void pstoedit_suffix_table_init(void) 
{ 
  struct DriverDescription_S *dd_start ;
  struct DriverDescription_S *dd_tmp ;
  void *tmp ;
  void *tmp___1 ;

  {
#line 77
  if ((unsigned long )pstoedit_suffix_table != (unsigned long )((void *)0)) {
#line 78
    return;
  }
  {
#line 80
  pstoedit_checkversion((unsigned int )pstoeditdllversion);
#line 81
  dd_start = getPstoeditDriverInfo_plainC();
  }
#line 82
  if (dd_start) {
#line 84
    dd_tmp = dd_start;
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;
#line 85
      if (! dd_tmp->symbolicname) {
#line 85
        goto while_break;
      }
#line 86
      dd_tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 87
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 87
      tmp = malloc((sizeof(char *) * 2UL) * (unsigned long )(dd_tmp - dd_start) + 1UL);
#line 87
      pstoedit_suffix_table = (char **)tmp;
      }
#line 87
      if (! pstoedit_suffix_table) {
        {
#line 87
        __assert_fail("pstoedit_suffix_table", "output-pstoedit.c", 87U, "pstoedit_suffix_table_init");
        }
      }
#line 87
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 92
    dd_tmp = dd_start;
    {
#line 93
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 93
      if (! dd_tmp->symbolicname) {
#line 93
        goto while_break___1;
      }
      {
#line 99
      *(pstoedit_suffix_table + 2L * (dd_tmp - dd_start)) = strdup(dd_tmp->symbolicname);
#line 100
      *(pstoedit_suffix_table + (2L * (dd_tmp - dd_start) + 1L)) = strdup(dd_tmp->suffix);
#line 101
      dd_tmp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 103
    *(pstoedit_suffix_table + 2L * (dd_tmp - dd_start)) = (char *)((void *)0);
#line 104
    free((void *)dd_start);
    }
  } else {
    {
#line 108
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 108
      tmp___1 = malloc(sizeof(char *));
#line 108
      pstoedit_suffix_table = (char **)tmp___1;
      }
#line 108
      if (! pstoedit_suffix_table) {
        {
#line 108
        __assert_fail("pstoedit_suffix_table", "output-pstoedit.c", 108U, "pstoedit_suffix_table_init");
        }
      }
#line 108
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 109
    *(pstoedit_suffix_table + 0) = (char *)((void *)0);
  }
#line 111
  return;
}
}
#line 113 "output-pstoedit.c"
static at_string pstoedit_suffix_table_lookup_deep(at_string const   suffix ) 
{ 
  char **tmp ;
  int tmp___0 ;

  {
#line 118
  if ((unsigned long )pstoedit_suffix_table == (unsigned long )((void *)0)) {
    {
#line 119
    pstoedit_suffix_table_init();
    }
  }
#line 125
  tmp = pstoedit_suffix_table;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((unsigned long )*tmp != (unsigned long )((void *)0))) {
#line 125
      goto while_break;
    }
    {
#line 131
    tmp___0 = strcmp((char const   *)suffix, (char const   *)*tmp);
    }
#line 131
    if (0 == tmp___0) {
#line 132
      return (*tmp);
    }
#line 125
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return ((at_string )((void *)0));
}
}
#line 137 "output-pstoedit.c"
static at_bool pstoedit_suffix_table_lookup_shallow(void const   *suffix ) 
{ 
  char **tmp ;

  {
#line 142
  if ((unsigned long )pstoedit_suffix_table == (unsigned long )((void *)0)) {
    {
#line 143
    pstoedit_suffix_table_init();
    }
  }
#line 145
  tmp = pstoedit_suffix_table;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! ((unsigned long )*tmp != (unsigned long )((void *)0))) {
#line 145
      goto while_break;
    }
#line 146
    if ((unsigned long )*tmp == (unsigned long )suffix) {
#line 147
      return ((at_bool )1);
    }
#line 145
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return ((at_bool )0);
}
}
#line 151 "output-pstoedit.c"
at_output_write_func output_pstoedit_get_writer(at_string const   suffix ) 
{ 
  at_string tmp ;

  {
  {
#line 154
  tmp = pstoedit_suffix_table_lookup_deep(suffix);
  }
#line 154
  return ((int (*)(FILE * , at_string name , int llx , int lly , int urx , int ury ,
                   at_output_opts_type *opts , at_spline_list_array_type shape , void (*msg_func)(at_string msg ,
                                                                                                  at_msg_type msg_type ,
                                                                                                  at_address client_data ) ,
                   at_address msg_data ))tmp);
}
}
#line 157 "output-pstoedit.c"
at_bool output_pstoedit_is_writer(int (*writer)(FILE * , at_string name , int llx ,
                                                int lly , int urx , int ury , at_output_opts_type *opts ,
                                                at_spline_list_array_type shape ,
                                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                                 at_address client_data ) ,
                                                at_address msg_data ) ) 
{ 
  at_bool tmp ;

  {
  {
#line 160
  tmp = pstoedit_suffix_table_lookup_shallow((void const   *)writer);
  }
#line 160
  return (tmp);
}
}
#line 163 "output-pstoedit.c"
int output_pstoedit_invoke_writer(int (*writer)(FILE * , at_string name , int llx ,
                                                int lly , int urx , int ury , at_output_opts_type *opts ,
                                                at_spline_list_array_type shape ,
                                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                                 at_address client_data ) ,
                                                at_address msg_data ) , FILE *file ,
                                  at_string name , int llx , int lly , int urx , int ury ,
                                  at_output_opts_type *opts , at_spline_list_array_type shape ,
                                  void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                   at_address client_data ) , at_address msg_data ) 
{ 
  int tmp ;

  {
  {
#line 172
  tmp = output_pstoedit_writer((at_string const   )writer, file, name, llx, lly, urx,
                               ury, opts, shape, msg_func, msg_data);
  }
#line 172
  return (tmp);
}
}
#line 188 "output-pstoedit.c"
static int output_pstoedit_writer(at_string const   suffix , FILE *file , at_string name ,
                                  int llx , int lly , int urx , int ury , at_output_opts_type *opts ,
                                  at_spline_list_array_type shape , void (*msg_func)(at_string msg ,
                                                                                     at_msg_type msg_type ,
                                                                                     at_address client_data ) ,
                                  at_address msg_data ) 
{ 
  char tmpfile_name_p2e[18] ;
  char tmpfile_name_pstoedit[18] ;
  char *symbolicname ;
  FILE *tmpfile___0 ;
  int result ;
  int c ;
  int argc ;
  char *argv[6] ;
  at_bool tmp ;
  at_string tmp___0 ;

  {
  {
#line 197
  tmpfile_name_p2e[0] = (char )'/';
#line 197
  tmpfile_name_p2e[1] = (char )'t';
#line 197
  tmpfile_name_p2e[2] = (char )'m';
#line 197
  tmpfile_name_p2e[3] = (char )'p';
#line 197
  tmpfile_name_p2e[4] = (char )'/';
#line 197
  tmpfile_name_p2e[5] = (char )'a';
#line 197
  tmpfile_name_p2e[6] = (char )'t';
#line 197
  tmpfile_name_p2e[7] = (char )'-';
#line 197
  tmpfile_name_p2e[8] = (char )'b';
#line 197
  tmpfile_name_p2e[9] = (char )'o';
#line 197
  tmpfile_name_p2e[10] = (char )'-';
#line 197
  tmpfile_name_p2e[11] = (char )'X';
#line 197
  tmpfile_name_p2e[12] = (char )'X';
#line 197
  tmpfile_name_p2e[13] = (char )'X';
#line 197
  tmpfile_name_p2e[14] = (char )'X';
#line 197
  tmpfile_name_p2e[15] = (char )'X';
#line 197
  tmpfile_name_p2e[16] = (char )'X';
#line 197
  tmpfile_name_p2e[17] = (char )'\000';
#line 198
  tmpfile_name_pstoedit[0] = (char )'/';
#line 198
  tmpfile_name_pstoedit[1] = (char )'t';
#line 198
  tmpfile_name_pstoedit[2] = (char )'m';
#line 198
  tmpfile_name_pstoedit[3] = (char )'p';
#line 198
  tmpfile_name_pstoedit[4] = (char )'/';
#line 198
  tmpfile_name_pstoedit[5] = (char )'a';
#line 198
  tmpfile_name_pstoedit[6] = (char )'t';
#line 198
  tmpfile_name_pstoedit[7] = (char )'-';
#line 198
  tmpfile_name_pstoedit[8] = (char )'f';
#line 198
  tmpfile_name_pstoedit[9] = (char )'o';
#line 198
  tmpfile_name_pstoedit[10] = (char )'-';
#line 198
  tmpfile_name_pstoedit[11] = (char )'X';
#line 198
  tmpfile_name_pstoedit[12] = (char )'X';
#line 198
  tmpfile_name_pstoedit[13] = (char )'X';
#line 198
  tmpfile_name_pstoedit[14] = (char )'X';
#line 198
  tmpfile_name_pstoedit[15] = (char )'X';
#line 198
  tmpfile_name_pstoedit[16] = (char )'X';
#line 198
  tmpfile_name_pstoedit[17] = (char )'\000';
#line 201
  result = 0;
#line 211
  argv[0] = (char *)"pstoedit";
#line 211
  argv[1] = (char *)"-f";
#line 211
  argv[2] = (char *)0;
#line 211
  argv[3] = (char *)"-bo";
#line 211
  argv[4] = (char *)0;
#line 211
  argv[5] = (char *)0;
#line 213
  argc = (int )(sizeof(argv) / sizeof(char *));
#line 215
  tmp = pstoedit_suffix_table_lookup_shallow((void const   *)suffix);
  }
#line 215
  if (0U == (unsigned int )tmp) {
#line 217
    if (msg_func) {
      {
#line 218
      (*msg_func)((at_string )"Suffix for pstoedit backend driver is wrong", (at_msg_type )2,
                  msg_data);
      }
    }
#line 220
    return (-1);
  }
  {
#line 223
  tmp___0 = (at_string )get_symbolicname(suffix);
#line 223
  symbolicname = (char *)tmp___0;
  }
#line 224
  if (! symbolicname) {
#line 226
    if (msg_func) {
      {
#line 227
      (*msg_func)((at_string )"Symbolicname for pstoedit backend driver is wrong",
                  (at_msg_type )2, msg_data);
      }
    }
#line 229
    return (-1);
  }
  {
#line 232
  tmpfile___0 = make_temporary_file(tmpfile_name_p2e, (char *)"w");
  }
#line 233
  if ((unsigned long )((void *)0) == (unsigned long )tmpfile___0) {
#line 235
    result = -1;
#line 236
    goto remove_tmp_p2e;
  }
  {
#line 242
  output_p2e_writer(tmpfile___0, tmpfile_name_p2e, llx, lly, urx, ury, opts, shape,
                    msg_func, msg_data);
#line 245
  fclose(tmpfile___0);
#line 247
  tmpfile___0 = make_temporary_file(tmpfile_name_pstoedit, (char *)"r");
  }
#line 248
  if ((unsigned long )((void *)0) == (unsigned long )tmpfile___0) {
#line 250
    result = -1;
#line 251
    goto remove_tmp_pstoedit;
  }
  {
#line 257
  argv[2] = symbolicname;
#line 258
  argv[4] = tmpfile_name_p2e;
#line 259
  argv[5] = tmpfile_name_pstoedit;
#line 260
  pstoedit_plainC(argc, (char const   * const  *)(argv), (char const   */* const  */)((void *)0));
  }
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 266
    c = fgetc(tmpfile___0);
    }
#line 266
    if (! (-1 != c)) {
#line 266
      goto while_break;
    }
    {
#line 267
    fputc(c, file);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 268
  fclose(tmpfile___0);
  }
  remove_tmp_pstoedit: 
  {
#line 271
  remove_temporary_file((at_string const   )(tmpfile_name_pstoedit));
  }
  remove_tmp_p2e: 
  {
#line 273
  remove_temporary_file((at_string const   )(tmpfile_name_p2e));
#line 274
  free((void *)symbolicname);
  }
#line 275
  return (result);
}
}
#line 278 "output-pstoedit.c"
at_bool output_pstoedit_is_unusable_writer(at_string const   name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 281
  tmp = strcmp((char const   *)name, "sam");
  }
#line 281
  if (0 == tmp) {
#line 291
    return ((at_bool )1);
  } else {
    {
#line 281
    tmp___0 = strcmp((char const   *)name, "dbg");
    }
#line 281
    if (0 == tmp___0) {
#line 291
      return ((at_bool )1);
    } else {
      {
#line 281
      tmp___1 = strcmp((char const   *)name, "gs");
      }
#line 281
      if (0 == tmp___1) {
#line 291
        return ((at_bool )1);
      } else {
        {
#line 281
        tmp___2 = strcmp((char const   *)name, "psf");
        }
#line 281
        if (0 == tmp___2) {
#line 291
          return ((at_bool )1);
        } else {
          {
#line 281
          tmp___3 = strcmp((char const   *)name, "fps");
          }
#line 281
          if (0 == tmp___3) {
#line 291
            return ((at_bool )1);
          } else {
            {
#line 281
            tmp___4 = strcmp((char const   *)name, "ps");
            }
#line 281
            if (0 == tmp___4) {
#line 291
              return ((at_bool )1);
            } else {
              {
#line 281
              tmp___5 = strcmp((char const   *)name, "spsc");
              }
#line 281
              if (0 == tmp___5) {
#line 291
                return ((at_bool )1);
              } else {
                {
#line 281
                tmp___6 = strcmp((char const   *)name, "debug");
                }
#line 281
                if (0 == tmp___6) {
#line 291
                  return ((at_bool )1);
                } else {
                  {
#line 281
                  tmp___7 = strcmp((char const   *)name, "dump");
                  }
#line 281
                  if (0 == tmp___7) {
#line 291
                    return ((at_bool )1);
                  } else {
                    {
#line 281
                    tmp___8 = strcmp((char const   *)name, "ps2as");
                    }
#line 281
                    if (0 == tmp___8) {
#line 291
                      return ((at_bool )1);
                    } else {
#line 293
                      return ((at_bool )0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
#line 300 "output-pstoedit.c"
static at_string const   get_symbolicname(at_string const   suffix ) 
{ 
  at_string symbolicname ;
  struct DriverDescription_S *dd_start ;
  struct DriverDescription_S *dd_tmp ;
  int tmp ;
  int tmp___0 ;

  {
#line 303
  symbolicname = (at_string )((void *)0);
#line 306
  if (! suffix) {
#line 307
    return ((at_string const   )((void *)0));
  }
  {
#line 309
  dd_start = getPstoeditDriverInfo_plainC();
  }
#line 310
  if (dd_start) {
#line 312
    dd_tmp = dd_start;
    {
#line 313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 313
      if (! dd_tmp->symbolicname) {
#line 313
        goto while_break;
      }
      {
#line 315
      tmp___0 = strcmp(dd_tmp->suffix, (char const   *)suffix);
      }
#line 315
      if (0 == tmp___0) {
        {
#line 317
        symbolicname = strdup(dd_tmp->symbolicname);
        }
#line 318
        goto while_break;
      } else {
        {
#line 320
        tmp = strcmp(dd_tmp->symbolicname, (char const   *)suffix);
        }
#line 320
        if (0 == tmp) {
          {
#line 322
          symbolicname = strdup((char const   *)suffix);
          }
#line 323
          goto while_break;
        } else {
#line 326
          dd_tmp ++;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 328
    free((void *)dd_start);
    }
  }
#line 330
  return ((at_string const   )symbolicname);
}
}
#line 334 "output-pstoedit.c"
static FILE *make_temporary_file(char *template , char *mode ) 
{ 
  char *tmpname ;
  FILE *tmp ;

  {
  {
#line 347
  tmpname = tmpnam(template);
  }
#line 348
  if ((unsigned long )template == (unsigned long )((void *)0)) {
#line 349
    return ((FILE *)((void *)0));
  }
  {
#line 350
  tmp = fopen((char const   */* __restrict  */)tmpname, (char const   */* __restrict  */)mode);
  }
#line 350
  return (tmp);
}
}
#line 354 "output-pstoedit.c"
static void remove_temporary_file(at_string const   tmpfile_name ) 
{ 


  {
  {
#line 358
  remove((char const   *)tmpfile_name);
  }
#line 362
  return;
}
}
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 29 "output-pdf.h"
int output_pdf_writer(FILE *pdf_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) ;
#line 384 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 142 "output-pdf.c"
static int output_pdf_header(FILE *pdf_file , at_string name , int llx , int lly ,
                             int urx , int ury ) 
{ 


  {
  {
#line 145
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "%PDF-1.2");
#line 146
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "1 0 obj");
#line 147
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   << /Type /Catalog");
#line 148
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "      /Outlines 2 0 R");
#line 149
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "      /Pages 3 0 R");
#line 150
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   >>");
#line 151
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "endobj");
#line 152
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "2 0 obj");
#line 153
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   << /Type /Outlines");
#line 154
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "      /Count 0");
#line 155
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   >>");
#line 156
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "endobj");
#line 157
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "3 0 obj");
#line 158
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   << /Type /Pages");
#line 159
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "      /Kids [4 0 R]");
#line 160
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "      /Count 1");
#line 161
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   >>");
#line 162
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "endobj");
#line 163
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "4 0 obj");
#line 164
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   << /Type /Page");
#line 165
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "      /Parent 3 0 R");
#line 166
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"      /MediaBox [%d %d %d %d]\n",
          llx, lly, urx, ury);
#line 167
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "      /Contents 5 0 R");
#line 168
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "      /Resources << /ProcSet 6 0 R >>");
#line 169
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   >>");
#line 170
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "endobj");
  }
#line 172
  return (0);
}
}
#line 179 "output-pdf.c"
static int output_pdf_tailor(FILE *pdf_file , size_t length , int llx , int lly ,
                             int urx , int ury ) 
{ 
  char temp[40] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 185
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "6 0 obj");
#line 186
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   [/PDF]");
#line 187
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "endobj");
#line 188
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "xref");
#line 189
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "0 7");
#line 190
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "0000000000 65535 f ");
#line 191
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "0000000009 00000 n ");
#line 192
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "0000000092 00000 n ");
#line 193
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "0000000150 00000 n ");
#line 194
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "0000000225 00000 n ");
#line 195
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%d",
          llx);
#line 196
  tmp = (size_t )366;
#line 197
  tmp___0 = strlen((char const   *)(temp));
#line 197
  tmp += tmp___0;
#line 198
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%d",
          lly);
#line 199
  tmp___1 = strlen((char const   *)(temp));
#line 199
  tmp += tmp___1;
#line 200
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%d",
          urx);
#line 201
  tmp___2 = strlen((char const   *)(temp));
#line 201
  tmp += tmp___2;
#line 202
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%d",
          ury);
#line 203
  tmp___3 = strlen((char const   *)(temp));
#line 203
  tmp += tmp___3;
#line 204
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%010d 00000 n \n",
          tmp);
#line 205
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%d",
          length);
#line 206
  tmp___4 = strlen((char const   *)(temp));
#line 206
  tmp += (50UL + length) + tmp___4;
#line 207
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%010d 00000 n \n",
          tmp);
#line 208
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "trailer");
#line 209
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   << /Size 7");
#line 210
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "      /Root 1 0 R");
#line 211
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "   >>");
#line 212
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "startxref");
#line 213
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%d\n",
          tmp + 25UL);
#line 214
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "%%EOF");
  }
#line 216
  return (0);
}
}
#line 223 "output-pdf.c"
static void out_splines___1(FILE *pdf_file , at_spline_list_array_type shape , size_t *length ) 
{ 
  char temp[40] ;
  unsigned int this_list ;
  spline_list_type list ;
  color_type last_color ;
  unsigned int this_spline ;
  spline_type first ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  char const   *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  size_t tmp___55 ;
  size_t tmp___56 ;
  spline_type s ;
  char const   *tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  size_t tmp___82 ;
  char const   *tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  size_t tmp___108 ;
  size_t tmp___109 ;
  char const   *tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  size_t tmp___135 ;
  char const   *tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  size_t tmp___161 ;
  size_t tmp___162 ;
  char const   *tmp___175 ;
  int tmp___176 ;
  int tmp___177 ;
  int tmp___182 ;
  int tmp___183 ;
  int tmp___184 ;
  int tmp___185 ;
  int tmp___186 ;
  int tmp___187 ;
  size_t tmp___188 ;
  char const   *tmp___201 ;
  int tmp___202 ;
  int tmp___203 ;
  int tmp___208 ;
  int tmp___209 ;
  int tmp___210 ;
  int tmp___211 ;
  int tmp___212 ;
  int tmp___213 ;
  size_t tmp___214 ;
  size_t tmp___215 ;
  char const   *tmp___228 ;
  int tmp___229 ;
  int tmp___230 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  int tmp___238 ;
  int tmp___239 ;
  int tmp___240 ;
  size_t tmp___241 ;
  char const   *tmp___254 ;
  int tmp___255 ;
  int tmp___256 ;
  int tmp___261 ;
  int tmp___262 ;
  int tmp___263 ;
  int tmp___264 ;
  int tmp___265 ;
  int tmp___266 ;
  size_t tmp___267 ;
  size_t tmp___268 ;
  char const   *tmp___269 ;
  size_t tmp___270 ;
  unsigned int this_spline___0 ;
  spline_type first___0 ;
  char const   *tmp___271 ;
  char const   *tmp___272 ;
  char const   *tmp___285 ;
  int tmp___286 ;
  int tmp___287 ;
  int tmp___292 ;
  int tmp___293 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  char const   *tmp___310 ;
  int tmp___311 ;
  int tmp___312 ;
  int tmp___317 ;
  int tmp___318 ;
  int tmp___319 ;
  int tmp___320 ;
  int tmp___321 ;
  int tmp___322 ;
  spline_type s___0 ;
  char const   *tmp___335 ;
  int tmp___336 ;
  int tmp___337 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  int tmp___347 ;
  char const   *tmp___360 ;
  int tmp___361 ;
  int tmp___362 ;
  int tmp___367 ;
  int tmp___368 ;
  int tmp___369 ;
  int tmp___370 ;
  int tmp___371 ;
  int tmp___372 ;
  char const   *tmp___385 ;
  int tmp___386 ;
  int tmp___387 ;
  int tmp___392 ;
  int tmp___393 ;
  int tmp___394 ;
  int tmp___395 ;
  int tmp___396 ;
  int tmp___397 ;
  char const   *tmp___410 ;
  int tmp___411 ;
  int tmp___412 ;
  int tmp___417 ;
  int tmp___418 ;
  int tmp___419 ;
  int tmp___420 ;
  int tmp___421 ;
  int tmp___422 ;
  char const   *tmp___435 ;
  int tmp___436 ;
  int tmp___437 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  int tmp___446 ;
  int tmp___447 ;
  char const   *tmp___460 ;
  int tmp___461 ;
  int tmp___462 ;
  int tmp___467 ;
  int tmp___468 ;
  int tmp___469 ;
  int tmp___470 ;
  int tmp___471 ;
  int tmp___472 ;
  char const   *tmp___485 ;
  int tmp___486 ;
  int tmp___487 ;
  int tmp___492 ;
  int tmp___493 ;
  int tmp___494 ;
  int tmp___495 ;
  int tmp___496 ;
  int tmp___497 ;
  char const   *tmp___510 ;
  int tmp___511 ;
  int tmp___512 ;
  int tmp___517 ;
  int tmp___518 ;
  int tmp___519 ;
  int tmp___520 ;
  int tmp___521 ;
  int tmp___522 ;
  char const   *tmp___523 ;

  {
#line 230
  last_color.r = (unsigned char)0;
#line 230
  last_color.g = (unsigned char)0;
#line 230
  last_color.b = (unsigned char)0;
#line 232
  this_list = 0U;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! (this_list < shape.length)) {
#line 232
      goto while_break;
    }
#line 238
    list = *(shape.data + this_list);
#line 239
    first = *(list.data + 0);
#line 241
    if (this_list == 0U) {
#line 241
      goto _L___1;
    } else
#line 241
    if ((int )list.color.r == (int )last_color.r) {
#line 241
      if ((int )list.color.g == (int )last_color.g) {
#line 241
        if (! ((int )list.color.b == (int )last_color.b)) {
#line 241
          goto _L___1;
        }
      } else {
#line 241
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 243
      if (this_list > 0U) {
#line 245
        if (shape.centerline) {
#line 245
          tmp = "S";
        } else
#line 245
        if (list.open) {
#line 245
          tmp = "S";
        } else {
#line 245
          tmp = "f";
        }
        {
#line 245
        sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s\n",
                tmp);
#line 245
        tmp___0 = strlen((char const   *)(temp));
#line 245
        *length += tmp___0;
#line 246
        sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s\n",
                "h");
#line 246
        tmp___1 = strlen((char const   *)(temp));
#line 246
        *length += tmp___1;
        }
      }
#line 248
      if (shape.centerline) {
#line 248
        tmp___2 = "RG";
      } else
#line 248
      if (list.open) {
#line 248
        tmp___2 = "RG";
      } else {
#line 248
        tmp___2 = "rg";
      }
      {
#line 248
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%.3f %.3f %.3f %s\n",
              (double )list.color.r / 255.0, (double )list.color.g / 255.0, (double )list.color.b / 255.0,
              tmp___2);
#line 248
      tmp___3 = strlen((char const   *)(temp));
#line 248
      *length += tmp___3;
#line 251
      last_color = list.color;
      }
    }
    {
#line 253
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 253
      if ((at_real )6.0 * first.v[0].x > (at_real )0) {
#line 253
        tmp___18 = 1;
      } else {
#line 253
        if ((at_real )6.0 * first.v[0].x < (at_real )0) {
#line 253
          tmp___17 = -1;
        } else {
#line 253
          tmp___17 = 0;
        }
#line 253
        tmp___18 = tmp___17;
      }
#line 253
      first.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].x)) + .5 * (double )tmp___18)) / (at_real )6.0;
#line 253
      if ((at_real )6.0 * first.v[0].x > (at_real )0) {
#line 253
        tmp___28 = 1;
      } else {
#line 253
        if ((at_real )6.0 * first.v[0].x < (at_real )0) {
#line 253
          tmp___27 = -1;
        } else {
#line 253
          tmp___27 = 0;
        }
#line 253
        tmp___28 = tmp___27;
      }
#line 253
      first.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].x)) + .5 * (double )tmp___28)) / (at_real )6.0;
#line 253
      if (first.v[0].x > (at_real )0) {
#line 253
        tmp___26 = 1;
      } else {
#line 253
        if ((at_real )6.0 * first.v[0].x > (at_real )0) {
#line 253
          tmp___25 = 1;
        } else {
#line 253
          if ((at_real )6.0 * first.v[0].x < (at_real )0) {
#line 253
            tmp___24 = -1;
          } else {
#line 253
            tmp___24 = 0;
          }
#line 253
          tmp___25 = tmp___24;
        }
#line 253
        first.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].x)) + .5 * (double )tmp___25)) / (at_real )6.0;
#line 253
        if (first.v[0].x < (at_real )0) {
#line 253
          tmp___23 = -1;
        } else {
#line 253
          tmp___23 = 0;
        }
#line 253
        tmp___26 = tmp___23;
      }
#line 253
      if (first.v[0].x == (at_real )((int )((double )((int )first.v[0].x) + .5 * (double )tmp___26))) {
#line 253
        tmp___16 = "%.0f ";
      } else {
#line 253
        tmp___16 = "%.3f ";
      }
      {
#line 253
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___16,
              (double )first.v[0].x);
#line 253
      tmp___29 = strlen((char const   *)(temp));
#line 253
      *length += tmp___29;
      }
#line 253
      if ((at_real )6.0 * first.v[0].y > (at_real )0) {
#line 253
        tmp___44 = 1;
      } else {
#line 253
        if ((at_real )6.0 * first.v[0].y < (at_real )0) {
#line 253
          tmp___43 = -1;
        } else {
#line 253
          tmp___43 = 0;
        }
#line 253
        tmp___44 = tmp___43;
      }
#line 253
      first.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].y)) + .5 * (double )tmp___44)) / (at_real )6.0;
#line 253
      if ((at_real )6.0 * first.v[0].y > (at_real )0) {
#line 253
        tmp___54 = 1;
      } else {
#line 253
        if ((at_real )6.0 * first.v[0].y < (at_real )0) {
#line 253
          tmp___53 = -1;
        } else {
#line 253
          tmp___53 = 0;
        }
#line 253
        tmp___54 = tmp___53;
      }
#line 253
      first.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].y)) + .5 * (double )tmp___54)) / (at_real )6.0;
#line 253
      if (first.v[0].y > (at_real )0) {
#line 253
        tmp___52 = 1;
      } else {
#line 253
        if ((at_real )6.0 * first.v[0].y > (at_real )0) {
#line 253
          tmp___51 = 1;
        } else {
#line 253
          if ((at_real )6.0 * first.v[0].y < (at_real )0) {
#line 253
            tmp___50 = -1;
          } else {
#line 253
            tmp___50 = 0;
          }
#line 253
          tmp___51 = tmp___50;
        }
#line 253
        first.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].y)) + .5 * (double )tmp___51)) / (at_real )6.0;
#line 253
        if (first.v[0].y < (at_real )0) {
#line 253
          tmp___49 = -1;
        } else {
#line 253
          tmp___49 = 0;
        }
#line 253
        tmp___52 = tmp___49;
      }
#line 253
      if (first.v[0].y == (at_real )((int )((double )((int )first.v[0].y) + .5 * (double )tmp___52))) {
#line 253
        tmp___42 = "%.0f ";
      } else {
#line 253
        tmp___42 = "%.3f ";
      }
      {
#line 253
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___42,
              (double )first.v[0].y);
#line 253
      tmp___55 = strlen((char const   *)(temp));
#line 253
      *length += tmp___55;
#line 253
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s",
              "m\n");
#line 253
      tmp___56 = strlen((char const   *)(temp));
#line 253
      *length += tmp___56;
      }
#line 253
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 255
    this_spline = 0U;
    {
#line 255
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 255
      if (! (this_spline < list.length)) {
#line 255
        goto while_break___1;
      }
#line 258
      s = *(list.data + this_spline);
#line 260
      if ((unsigned int )s.degree == 1U) {
        {
#line 261
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 261
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 261
            tmp___71 = 1;
          } else {
#line 261
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 261
              tmp___70 = -1;
            } else {
#line 261
              tmp___70 = 0;
            }
#line 261
            tmp___71 = tmp___70;
          }
#line 261
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___71)) / (at_real )6.0;
#line 261
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 261
            tmp___81 = 1;
          } else {
#line 261
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 261
              tmp___80 = -1;
            } else {
#line 261
              tmp___80 = 0;
            }
#line 261
            tmp___81 = tmp___80;
          }
#line 261
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___81)) / (at_real )6.0;
#line 261
          if (s.v[3].x > (at_real )0) {
#line 261
            tmp___79 = 1;
          } else {
#line 261
            if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 261
              tmp___78 = 1;
            } else {
#line 261
              if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 261
                tmp___77 = -1;
              } else {
#line 261
                tmp___77 = 0;
              }
#line 261
              tmp___78 = tmp___77;
            }
#line 261
            s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___78)) / (at_real )6.0;
#line 261
            if (s.v[3].x < (at_real )0) {
#line 261
              tmp___76 = -1;
            } else {
#line 261
              tmp___76 = 0;
            }
#line 261
            tmp___79 = tmp___76;
          }
#line 261
          if (s.v[3].x == (at_real )((int )((double )((int )s.v[3].x) + .5 * (double )tmp___79))) {
#line 261
            tmp___69 = "%.0f ";
          } else {
#line 261
            tmp___69 = "%.3f ";
          }
          {
#line 261
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___69,
                  (double )s.v[3].x);
#line 261
          tmp___82 = strlen((char const   *)(temp));
#line 261
          *length += tmp___82;
          }
#line 261
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 261
            tmp___97 = 1;
          } else {
#line 261
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 261
              tmp___96 = -1;
            } else {
#line 261
              tmp___96 = 0;
            }
#line 261
            tmp___97 = tmp___96;
          }
#line 261
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___97)) / (at_real )6.0;
#line 261
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 261
            tmp___107 = 1;
          } else {
#line 261
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 261
              tmp___106 = -1;
            } else {
#line 261
              tmp___106 = 0;
            }
#line 261
            tmp___107 = tmp___106;
          }
#line 261
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___107)) / (at_real )6.0;
#line 261
          if (s.v[3].y > (at_real )0) {
#line 261
            tmp___105 = 1;
          } else {
#line 261
            if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 261
              tmp___104 = 1;
            } else {
#line 261
              if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 261
                tmp___103 = -1;
              } else {
#line 261
                tmp___103 = 0;
              }
#line 261
              tmp___104 = tmp___103;
            }
#line 261
            s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___104)) / (at_real )6.0;
#line 261
            if (s.v[3].y < (at_real )0) {
#line 261
              tmp___102 = -1;
            } else {
#line 261
              tmp___102 = 0;
            }
#line 261
            tmp___105 = tmp___102;
          }
#line 261
          if (s.v[3].y == (at_real )((int )((double )((int )s.v[3].y) + .5 * (double )tmp___105))) {
#line 261
            tmp___95 = "%.0f ";
          } else {
#line 261
            tmp___95 = "%.3f ";
          }
          {
#line 261
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___95,
                  (double )s.v[3].y);
#line 261
          tmp___108 = strlen((char const   *)(temp));
#line 261
          *length += tmp___108;
#line 261
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s",
                  "l\n");
#line 261
          tmp___109 = strlen((char const   *)(temp));
#line 261
          *length += tmp___109;
          }
#line 261
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 263
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 263
          if ((at_real )6.0 * s.v[1].x > (at_real )0) {
#line 263
            tmp___124 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[1].x < (at_real )0) {
#line 263
              tmp___123 = -1;
            } else {
#line 263
              tmp___123 = 0;
            }
#line 263
            tmp___124 = tmp___123;
          }
#line 263
          s.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].x)) + .5 * (double )tmp___124)) / (at_real )6.0;
#line 263
          if ((at_real )6.0 * s.v[1].x > (at_real )0) {
#line 263
            tmp___134 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[1].x < (at_real )0) {
#line 263
              tmp___133 = -1;
            } else {
#line 263
              tmp___133 = 0;
            }
#line 263
            tmp___134 = tmp___133;
          }
#line 263
          s.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].x)) + .5 * (double )tmp___134)) / (at_real )6.0;
#line 263
          if (s.v[1].x > (at_real )0) {
#line 263
            tmp___132 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[1].x > (at_real )0) {
#line 263
              tmp___131 = 1;
            } else {
#line 263
              if ((at_real )6.0 * s.v[1].x < (at_real )0) {
#line 263
                tmp___130 = -1;
              } else {
#line 263
                tmp___130 = 0;
              }
#line 263
              tmp___131 = tmp___130;
            }
#line 263
            s.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].x)) + .5 * (double )tmp___131)) / (at_real )6.0;
#line 263
            if (s.v[1].x < (at_real )0) {
#line 263
              tmp___129 = -1;
            } else {
#line 263
              tmp___129 = 0;
            }
#line 263
            tmp___132 = tmp___129;
          }
#line 263
          if (s.v[1].x == (at_real )((int )((double )((int )s.v[1].x) + .5 * (double )tmp___132))) {
#line 263
            tmp___122 = "%.0f ";
          } else {
#line 263
            tmp___122 = "%.3f ";
          }
          {
#line 263
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___122,
                  (double )s.v[1].x);
#line 263
          tmp___135 = strlen((char const   *)(temp));
#line 263
          *length += tmp___135;
          }
#line 263
          if ((at_real )6.0 * s.v[1].y > (at_real )0) {
#line 263
            tmp___150 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[1].y < (at_real )0) {
#line 263
              tmp___149 = -1;
            } else {
#line 263
              tmp___149 = 0;
            }
#line 263
            tmp___150 = tmp___149;
          }
#line 263
          s.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].y)) + .5 * (double )tmp___150)) / (at_real )6.0;
#line 263
          if ((at_real )6.0 * s.v[1].y > (at_real )0) {
#line 263
            tmp___160 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[1].y < (at_real )0) {
#line 263
              tmp___159 = -1;
            } else {
#line 263
              tmp___159 = 0;
            }
#line 263
            tmp___160 = tmp___159;
          }
#line 263
          s.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].y)) + .5 * (double )tmp___160)) / (at_real )6.0;
#line 263
          if (s.v[1].y > (at_real )0) {
#line 263
            tmp___158 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[1].y > (at_real )0) {
#line 263
              tmp___157 = 1;
            } else {
#line 263
              if ((at_real )6.0 * s.v[1].y < (at_real )0) {
#line 263
                tmp___156 = -1;
              } else {
#line 263
                tmp___156 = 0;
              }
#line 263
              tmp___157 = tmp___156;
            }
#line 263
            s.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].y)) + .5 * (double )tmp___157)) / (at_real )6.0;
#line 263
            if (s.v[1].y < (at_real )0) {
#line 263
              tmp___155 = -1;
            } else {
#line 263
              tmp___155 = 0;
            }
#line 263
            tmp___158 = tmp___155;
          }
#line 263
          if (s.v[1].y == (at_real )((int )((double )((int )s.v[1].y) + .5 * (double )tmp___158))) {
#line 263
            tmp___148 = "%.0f ";
          } else {
#line 263
            tmp___148 = "%.3f ";
          }
          {
#line 263
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___148,
                  (double )s.v[1].y);
#line 263
          tmp___161 = strlen((char const   *)(temp));
#line 263
          *length += tmp___161;
#line 263
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s",
                  " ");
#line 263
          tmp___162 = strlen((char const   *)(temp));
#line 263
          *length += tmp___162;
          }
#line 263
          if ((at_real )6.0 * s.v[2].x > (at_real )0) {
#line 263
            tmp___177 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[2].x < (at_real )0) {
#line 263
              tmp___176 = -1;
            } else {
#line 263
              tmp___176 = 0;
            }
#line 263
            tmp___177 = tmp___176;
          }
#line 263
          s.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].x)) + .5 * (double )tmp___177)) / (at_real )6.0;
#line 263
          if ((at_real )6.0 * s.v[2].x > (at_real )0) {
#line 263
            tmp___187 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[2].x < (at_real )0) {
#line 263
              tmp___186 = -1;
            } else {
#line 263
              tmp___186 = 0;
            }
#line 263
            tmp___187 = tmp___186;
          }
#line 263
          s.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].x)) + .5 * (double )tmp___187)) / (at_real )6.0;
#line 263
          if (s.v[2].x > (at_real )0) {
#line 263
            tmp___185 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[2].x > (at_real )0) {
#line 263
              tmp___184 = 1;
            } else {
#line 263
              if ((at_real )6.0 * s.v[2].x < (at_real )0) {
#line 263
                tmp___183 = -1;
              } else {
#line 263
                tmp___183 = 0;
              }
#line 263
              tmp___184 = tmp___183;
            }
#line 263
            s.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].x)) + .5 * (double )tmp___184)) / (at_real )6.0;
#line 263
            if (s.v[2].x < (at_real )0) {
#line 263
              tmp___182 = -1;
            } else {
#line 263
              tmp___182 = 0;
            }
#line 263
            tmp___185 = tmp___182;
          }
#line 263
          if (s.v[2].x == (at_real )((int )((double )((int )s.v[2].x) + .5 * (double )tmp___185))) {
#line 263
            tmp___175 = "%.0f ";
          } else {
#line 263
            tmp___175 = "%.3f ";
          }
          {
#line 263
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___175,
                  (double )s.v[2].x);
#line 263
          tmp___188 = strlen((char const   *)(temp));
#line 263
          *length += tmp___188;
          }
#line 263
          if ((at_real )6.0 * s.v[2].y > (at_real )0) {
#line 263
            tmp___203 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[2].y < (at_real )0) {
#line 263
              tmp___202 = -1;
            } else {
#line 263
              tmp___202 = 0;
            }
#line 263
            tmp___203 = tmp___202;
          }
#line 263
          s.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].y)) + .5 * (double )tmp___203)) / (at_real )6.0;
#line 263
          if ((at_real )6.0 * s.v[2].y > (at_real )0) {
#line 263
            tmp___213 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[2].y < (at_real )0) {
#line 263
              tmp___212 = -1;
            } else {
#line 263
              tmp___212 = 0;
            }
#line 263
            tmp___213 = tmp___212;
          }
#line 263
          s.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].y)) + .5 * (double )tmp___213)) / (at_real )6.0;
#line 263
          if (s.v[2].y > (at_real )0) {
#line 263
            tmp___211 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[2].y > (at_real )0) {
#line 263
              tmp___210 = 1;
            } else {
#line 263
              if ((at_real )6.0 * s.v[2].y < (at_real )0) {
#line 263
                tmp___209 = -1;
              } else {
#line 263
                tmp___209 = 0;
              }
#line 263
              tmp___210 = tmp___209;
            }
#line 263
            s.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].y)) + .5 * (double )tmp___210)) / (at_real )6.0;
#line 263
            if (s.v[2].y < (at_real )0) {
#line 263
              tmp___208 = -1;
            } else {
#line 263
              tmp___208 = 0;
            }
#line 263
            tmp___211 = tmp___208;
          }
#line 263
          if (s.v[2].y == (at_real )((int )((double )((int )s.v[2].y) + .5 * (double )tmp___211))) {
#line 263
            tmp___201 = "%.0f ";
          } else {
#line 263
            tmp___201 = "%.3f ";
          }
          {
#line 263
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___201,
                  (double )s.v[2].y);
#line 263
          tmp___214 = strlen((char const   *)(temp));
#line 263
          *length += tmp___214;
#line 263
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s",
                  " ");
#line 263
          tmp___215 = strlen((char const   *)(temp));
#line 263
          *length += tmp___215;
          }
#line 263
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 263
            tmp___230 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 263
              tmp___229 = -1;
            } else {
#line 263
              tmp___229 = 0;
            }
#line 263
            tmp___230 = tmp___229;
          }
#line 263
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___230)) / (at_real )6.0;
#line 263
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 263
            tmp___240 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 263
              tmp___239 = -1;
            } else {
#line 263
              tmp___239 = 0;
            }
#line 263
            tmp___240 = tmp___239;
          }
#line 263
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___240)) / (at_real )6.0;
#line 263
          if (s.v[3].x > (at_real )0) {
#line 263
            tmp___238 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 263
              tmp___237 = 1;
            } else {
#line 263
              if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 263
                tmp___236 = -1;
              } else {
#line 263
                tmp___236 = 0;
              }
#line 263
              tmp___237 = tmp___236;
            }
#line 263
            s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___237)) / (at_real )6.0;
#line 263
            if (s.v[3].x < (at_real )0) {
#line 263
              tmp___235 = -1;
            } else {
#line 263
              tmp___235 = 0;
            }
#line 263
            tmp___238 = tmp___235;
          }
#line 263
          if (s.v[3].x == (at_real )((int )((double )((int )s.v[3].x) + .5 * (double )tmp___238))) {
#line 263
            tmp___228 = "%.0f ";
          } else {
#line 263
            tmp___228 = "%.3f ";
          }
          {
#line 263
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___228,
                  (double )s.v[3].x);
#line 263
          tmp___241 = strlen((char const   *)(temp));
#line 263
          *length += tmp___241;
          }
#line 263
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 263
            tmp___256 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 263
              tmp___255 = -1;
            } else {
#line 263
              tmp___255 = 0;
            }
#line 263
            tmp___256 = tmp___255;
          }
#line 263
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___256)) / (at_real )6.0;
#line 263
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 263
            tmp___266 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 263
              tmp___265 = -1;
            } else {
#line 263
              tmp___265 = 0;
            }
#line 263
            tmp___266 = tmp___265;
          }
#line 263
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___266)) / (at_real )6.0;
#line 263
          if (s.v[3].y > (at_real )0) {
#line 263
            tmp___264 = 1;
          } else {
#line 263
            if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 263
              tmp___263 = 1;
            } else {
#line 263
              if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 263
                tmp___262 = -1;
              } else {
#line 263
                tmp___262 = 0;
              }
#line 263
              tmp___263 = tmp___262;
            }
#line 263
            s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___263)) / (at_real )6.0;
#line 263
            if (s.v[3].y < (at_real )0) {
#line 263
              tmp___261 = -1;
            } else {
#line 263
              tmp___261 = 0;
            }
#line 263
            tmp___264 = tmp___261;
          }
#line 263
          if (s.v[3].y == (at_real )((int )((double )((int )s.v[3].y) + .5 * (double )tmp___264))) {
#line 263
            tmp___254 = "%.0f ";
          } else {
#line 263
            tmp___254 = "%.3f ";
          }
          {
#line 263
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)tmp___254,
                  (double )s.v[3].y);
#line 263
          tmp___267 = strlen((char const   *)(temp));
#line 263
          *length += tmp___267;
#line 263
          sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s",
                  " c \n");
#line 263
          tmp___268 = strlen((char const   *)(temp));
#line 263
          *length += tmp___268;
          }
#line 263
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 255
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 232
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  if (shape.length > 0U) {
#line 270
    if (shape.centerline) {
#line 270
      tmp___269 = "S";
    } else
#line 270
    if (list.open) {
#line 270
      tmp___269 = "S";
    } else {
#line 270
      tmp___269 = "f";
    }
    {
#line 270
    sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s\n",
            tmp___269);
#line 270
    tmp___270 = strlen((char const   *)(temp));
#line 270
    *length += tmp___270;
    }
  }
  {
#line 272
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "5 0 obj");
#line 273
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"   << /Length %d >>\n",
          *length);
#line 274
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "stream");
#line 276
  last_color.r = (unsigned char)0;
#line 277
  last_color.g = (unsigned char)0;
#line 278
  last_color.b = (unsigned char)0;
#line 280
  this_list = 0U;
  }
  {
#line 280
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 280
    if (! (this_list < shape.length)) {
#line 280
      goto while_break___4;
    }
#line 286
    list = *(shape.data + this_list);
#line 287
    first___0 = *(list.data + 0);
#line 289
    if (this_list == 0U) {
#line 289
      goto _L___4;
    } else
#line 289
    if ((int )list.color.r == (int )last_color.r) {
#line 289
      if ((int )list.color.g == (int )last_color.g) {
#line 289
        if (! ((int )list.color.b == (int )last_color.b)) {
#line 289
          goto _L___4;
        }
      } else {
#line 289
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 291
      if (this_list > 0U) {
#line 293
        if (shape.centerline) {
#line 293
          tmp___271 = "S";
        } else
#line 293
        if (list.open) {
#line 293
          tmp___271 = "S";
        } else {
#line 293
          tmp___271 = "f";
        }
        {
#line 293
        fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
                tmp___271);
#line 294
        fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
                "h");
        }
      }
#line 296
      if (shape.centerline) {
#line 296
        tmp___272 = "RG";
      } else
#line 296
      if (list.open) {
#line 296
        tmp___272 = "RG";
      } else {
#line 296
        tmp___272 = "rg";
      }
      {
#line 296
      fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%.3f %.3f %.3f %s\n",
              (double )list.color.r / 255.0, (double )list.color.g / 255.0, (double )list.color.b / 255.0,
              tmp___272);
#line 299
      last_color = list.color;
      }
    }
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      if ((at_real )6.0 * first___0.v[0].x > (at_real )0) {
#line 301
        tmp___287 = 1;
      } else {
#line 301
        if ((at_real )6.0 * first___0.v[0].x < (at_real )0) {
#line 301
          tmp___286 = -1;
        } else {
#line 301
          tmp___286 = 0;
        }
#line 301
        tmp___287 = tmp___286;
      }
#line 301
      first___0.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first___0.v[0].x)) + .5 * (double )tmp___287)) / (at_real )6.0;
#line 301
      if ((at_real )6.0 * first___0.v[0].x > (at_real )0) {
#line 301
        tmp___297 = 1;
      } else {
#line 301
        if ((at_real )6.0 * first___0.v[0].x < (at_real )0) {
#line 301
          tmp___296 = -1;
        } else {
#line 301
          tmp___296 = 0;
        }
#line 301
        tmp___297 = tmp___296;
      }
#line 301
      first___0.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first___0.v[0].x)) + .5 * (double )tmp___297)) / (at_real )6.0;
#line 301
      if (first___0.v[0].x > (at_real )0) {
#line 301
        tmp___295 = 1;
      } else {
#line 301
        if ((at_real )6.0 * first___0.v[0].x > (at_real )0) {
#line 301
          tmp___294 = 1;
        } else {
#line 301
          if ((at_real )6.0 * first___0.v[0].x < (at_real )0) {
#line 301
            tmp___293 = -1;
          } else {
#line 301
            tmp___293 = 0;
          }
#line 301
          tmp___294 = tmp___293;
        }
#line 301
        first___0.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first___0.v[0].x)) + .5 * (double )tmp___294)) / (at_real )6.0;
#line 301
        if (first___0.v[0].x < (at_real )0) {
#line 301
          tmp___292 = -1;
        } else {
#line 301
          tmp___292 = 0;
        }
#line 301
        tmp___295 = tmp___292;
      }
#line 301
      if (first___0.v[0].x == (at_real )((int )((double )((int )first___0.v[0].x) + .5 * (double )tmp___295))) {
#line 301
        tmp___285 = "%.0f ";
      } else {
#line 301
        tmp___285 = "%.3f ";
      }
      {
#line 301
      fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)tmp___285,
              (double )first___0.v[0].x);
      }
#line 301
      if ((at_real )6.0 * first___0.v[0].y > (at_real )0) {
#line 301
        tmp___312 = 1;
      } else {
#line 301
        if ((at_real )6.0 * first___0.v[0].y < (at_real )0) {
#line 301
          tmp___311 = -1;
        } else {
#line 301
          tmp___311 = 0;
        }
#line 301
        tmp___312 = tmp___311;
      }
#line 301
      first___0.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first___0.v[0].y)) + .5 * (double )tmp___312)) / (at_real )6.0;
#line 301
      if ((at_real )6.0 * first___0.v[0].y > (at_real )0) {
#line 301
        tmp___322 = 1;
      } else {
#line 301
        if ((at_real )6.0 * first___0.v[0].y < (at_real )0) {
#line 301
          tmp___321 = -1;
        } else {
#line 301
          tmp___321 = 0;
        }
#line 301
        tmp___322 = tmp___321;
      }
#line 301
      first___0.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first___0.v[0].y)) + .5 * (double )tmp___322)) / (at_real )6.0;
#line 301
      if (first___0.v[0].y > (at_real )0) {
#line 301
        tmp___320 = 1;
      } else {
#line 301
        if ((at_real )6.0 * first___0.v[0].y > (at_real )0) {
#line 301
          tmp___319 = 1;
        } else {
#line 301
          if ((at_real )6.0 * first___0.v[0].y < (at_real )0) {
#line 301
            tmp___318 = -1;
          } else {
#line 301
            tmp___318 = 0;
          }
#line 301
          tmp___319 = tmp___318;
        }
#line 301
        first___0.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first___0.v[0].y)) + .5 * (double )tmp___319)) / (at_real )6.0;
#line 301
        if (first___0.v[0].y < (at_real )0) {
#line 301
          tmp___317 = -1;
        } else {
#line 301
          tmp___317 = 0;
        }
#line 301
        tmp___320 = tmp___317;
      }
#line 301
      if (first___0.v[0].y == (at_real )((int )((double )((int )first___0.v[0].y) + .5 * (double )tmp___320))) {
#line 301
        tmp___310 = "%.0f ";
      } else {
#line 301
        tmp___310 = "%.3f ";
      }
      {
#line 301
      fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)tmp___310,
              (double )first___0.v[0].y);
#line 301
      fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s",
              "m\n");
      }
#line 301
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 303
    this_spline___0 = 0U;
    {
#line 303
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 303
      if (! (this_spline___0 < list.length)) {
#line 303
        goto while_break___6;
      }
#line 306
      s___0 = *(list.data + this_spline___0);
#line 308
      if ((unsigned int )s___0.degree == 1U) {
        {
#line 309
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 309
          if ((at_real )6.0 * s___0.v[3].x > (at_real )0) {
#line 309
            tmp___337 = 1;
          } else {
#line 309
            if ((at_real )6.0 * s___0.v[3].x < (at_real )0) {
#line 309
              tmp___336 = -1;
            } else {
#line 309
              tmp___336 = 0;
            }
#line 309
            tmp___337 = tmp___336;
          }
#line 309
          s___0.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].x)) + .5 * (double )tmp___337)) / (at_real )6.0;
#line 309
          if ((at_real )6.0 * s___0.v[3].x > (at_real )0) {
#line 309
            tmp___347 = 1;
          } else {
#line 309
            if ((at_real )6.0 * s___0.v[3].x < (at_real )0) {
#line 309
              tmp___346 = -1;
            } else {
#line 309
              tmp___346 = 0;
            }
#line 309
            tmp___347 = tmp___346;
          }
#line 309
          s___0.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].x)) + .5 * (double )tmp___347)) / (at_real )6.0;
#line 309
          if (s___0.v[3].x > (at_real )0) {
#line 309
            tmp___345 = 1;
          } else {
#line 309
            if ((at_real )6.0 * s___0.v[3].x > (at_real )0) {
#line 309
              tmp___344 = 1;
            } else {
#line 309
              if ((at_real )6.0 * s___0.v[3].x < (at_real )0) {
#line 309
                tmp___343 = -1;
              } else {
#line 309
                tmp___343 = 0;
              }
#line 309
              tmp___344 = tmp___343;
            }
#line 309
            s___0.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].x)) + .5 * (double )tmp___344)) / (at_real )6.0;
#line 309
            if (s___0.v[3].x < (at_real )0) {
#line 309
              tmp___342 = -1;
            } else {
#line 309
              tmp___342 = 0;
            }
#line 309
            tmp___345 = tmp___342;
          }
#line 309
          if (s___0.v[3].x == (at_real )((int )((double )((int )s___0.v[3].x) + .5 * (double )tmp___345))) {
#line 309
            tmp___335 = "%.0f ";
          } else {
#line 309
            tmp___335 = "%.3f ";
          }
          {
#line 309
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)tmp___335,
                  (double )s___0.v[3].x);
          }
#line 309
          if ((at_real )6.0 * s___0.v[3].y > (at_real )0) {
#line 309
            tmp___362 = 1;
          } else {
#line 309
            if ((at_real )6.0 * s___0.v[3].y < (at_real )0) {
#line 309
              tmp___361 = -1;
            } else {
#line 309
              tmp___361 = 0;
            }
#line 309
            tmp___362 = tmp___361;
          }
#line 309
          s___0.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].y)) + .5 * (double )tmp___362)) / (at_real )6.0;
#line 309
          if ((at_real )6.0 * s___0.v[3].y > (at_real )0) {
#line 309
            tmp___372 = 1;
          } else {
#line 309
            if ((at_real )6.0 * s___0.v[3].y < (at_real )0) {
#line 309
              tmp___371 = -1;
            } else {
#line 309
              tmp___371 = 0;
            }
#line 309
            tmp___372 = tmp___371;
          }
#line 309
          s___0.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].y)) + .5 * (double )tmp___372)) / (at_real )6.0;
#line 309
          if (s___0.v[3].y > (at_real )0) {
#line 309
            tmp___370 = 1;
          } else {
#line 309
            if ((at_real )6.0 * s___0.v[3].y > (at_real )0) {
#line 309
              tmp___369 = 1;
            } else {
#line 309
              if ((at_real )6.0 * s___0.v[3].y < (at_real )0) {
#line 309
                tmp___368 = -1;
              } else {
#line 309
                tmp___368 = 0;
              }
#line 309
              tmp___369 = tmp___368;
            }
#line 309
            s___0.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].y)) + .5 * (double )tmp___369)) / (at_real )6.0;
#line 309
            if (s___0.v[3].y < (at_real )0) {
#line 309
              tmp___367 = -1;
            } else {
#line 309
              tmp___367 = 0;
            }
#line 309
            tmp___370 = tmp___367;
          }
#line 309
          if (s___0.v[3].y == (at_real )((int )((double )((int )s___0.v[3].y) + .5 * (double )tmp___370))) {
#line 309
            tmp___360 = "%.0f ";
          } else {
#line 309
            tmp___360 = "%.3f ";
          }
          {
#line 309
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)tmp___360,
                  (double )s___0.v[3].y);
#line 309
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s",
                  "l\n");
          }
#line 309
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
        {
#line 311
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 311
          if ((at_real )6.0 * s___0.v[1].x > (at_real )0) {
#line 311
            tmp___387 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[1].x < (at_real )0) {
#line 311
              tmp___386 = -1;
            } else {
#line 311
              tmp___386 = 0;
            }
#line 311
            tmp___387 = tmp___386;
          }
#line 311
          s___0.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[1].x)) + .5 * (double )tmp___387)) / (at_real )6.0;
#line 311
          if ((at_real )6.0 * s___0.v[1].x > (at_real )0) {
#line 311
            tmp___397 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[1].x < (at_real )0) {
#line 311
              tmp___396 = -1;
            } else {
#line 311
              tmp___396 = 0;
            }
#line 311
            tmp___397 = tmp___396;
          }
#line 311
          s___0.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[1].x)) + .5 * (double )tmp___397)) / (at_real )6.0;
#line 311
          if (s___0.v[1].x > (at_real )0) {
#line 311
            tmp___395 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[1].x > (at_real )0) {
#line 311
              tmp___394 = 1;
            } else {
#line 311
              if ((at_real )6.0 * s___0.v[1].x < (at_real )0) {
#line 311
                tmp___393 = -1;
              } else {
#line 311
                tmp___393 = 0;
              }
#line 311
              tmp___394 = tmp___393;
            }
#line 311
            s___0.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[1].x)) + .5 * (double )tmp___394)) / (at_real )6.0;
#line 311
            if (s___0.v[1].x < (at_real )0) {
#line 311
              tmp___392 = -1;
            } else {
#line 311
              tmp___392 = 0;
            }
#line 311
            tmp___395 = tmp___392;
          }
#line 311
          if (s___0.v[1].x == (at_real )((int )((double )((int )s___0.v[1].x) + .5 * (double )tmp___395))) {
#line 311
            tmp___385 = "%.0f ";
          } else {
#line 311
            tmp___385 = "%.3f ";
          }
          {
#line 311
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)tmp___385,
                  (double )s___0.v[1].x);
          }
#line 311
          if ((at_real )6.0 * s___0.v[1].y > (at_real )0) {
#line 311
            tmp___412 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[1].y < (at_real )0) {
#line 311
              tmp___411 = -1;
            } else {
#line 311
              tmp___411 = 0;
            }
#line 311
            tmp___412 = tmp___411;
          }
#line 311
          s___0.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[1].y)) + .5 * (double )tmp___412)) / (at_real )6.0;
#line 311
          if ((at_real )6.0 * s___0.v[1].y > (at_real )0) {
#line 311
            tmp___422 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[1].y < (at_real )0) {
#line 311
              tmp___421 = -1;
            } else {
#line 311
              tmp___421 = 0;
            }
#line 311
            tmp___422 = tmp___421;
          }
#line 311
          s___0.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[1].y)) + .5 * (double )tmp___422)) / (at_real )6.0;
#line 311
          if (s___0.v[1].y > (at_real )0) {
#line 311
            tmp___420 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[1].y > (at_real )0) {
#line 311
              tmp___419 = 1;
            } else {
#line 311
              if ((at_real )6.0 * s___0.v[1].y < (at_real )0) {
#line 311
                tmp___418 = -1;
              } else {
#line 311
                tmp___418 = 0;
              }
#line 311
              tmp___419 = tmp___418;
            }
#line 311
            s___0.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[1].y)) + .5 * (double )tmp___419)) / (at_real )6.0;
#line 311
            if (s___0.v[1].y < (at_real )0) {
#line 311
              tmp___417 = -1;
            } else {
#line 311
              tmp___417 = 0;
            }
#line 311
            tmp___420 = tmp___417;
          }
#line 311
          if (s___0.v[1].y == (at_real )((int )((double )((int )s___0.v[1].y) + .5 * (double )tmp___420))) {
#line 311
            tmp___410 = "%.0f ";
          } else {
#line 311
            tmp___410 = "%.3f ";
          }
          {
#line 311
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)tmp___410,
                  (double )s___0.v[1].y);
#line 311
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s",
                  " ");
          }
#line 311
          if ((at_real )6.0 * s___0.v[2].x > (at_real )0) {
#line 311
            tmp___437 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[2].x < (at_real )0) {
#line 311
              tmp___436 = -1;
            } else {
#line 311
              tmp___436 = 0;
            }
#line 311
            tmp___437 = tmp___436;
          }
#line 311
          s___0.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[2].x)) + .5 * (double )tmp___437)) / (at_real )6.0;
#line 311
          if ((at_real )6.0 * s___0.v[2].x > (at_real )0) {
#line 311
            tmp___447 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[2].x < (at_real )0) {
#line 311
              tmp___446 = -1;
            } else {
#line 311
              tmp___446 = 0;
            }
#line 311
            tmp___447 = tmp___446;
          }
#line 311
          s___0.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[2].x)) + .5 * (double )tmp___447)) / (at_real )6.0;
#line 311
          if (s___0.v[2].x > (at_real )0) {
#line 311
            tmp___445 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[2].x > (at_real )0) {
#line 311
              tmp___444 = 1;
            } else {
#line 311
              if ((at_real )6.0 * s___0.v[2].x < (at_real )0) {
#line 311
                tmp___443 = -1;
              } else {
#line 311
                tmp___443 = 0;
              }
#line 311
              tmp___444 = tmp___443;
            }
#line 311
            s___0.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[2].x)) + .5 * (double )tmp___444)) / (at_real )6.0;
#line 311
            if (s___0.v[2].x < (at_real )0) {
#line 311
              tmp___442 = -1;
            } else {
#line 311
              tmp___442 = 0;
            }
#line 311
            tmp___445 = tmp___442;
          }
#line 311
          if (s___0.v[2].x == (at_real )((int )((double )((int )s___0.v[2].x) + .5 * (double )tmp___445))) {
#line 311
            tmp___435 = "%.0f ";
          } else {
#line 311
            tmp___435 = "%.3f ";
          }
          {
#line 311
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)tmp___435,
                  (double )s___0.v[2].x);
          }
#line 311
          if ((at_real )6.0 * s___0.v[2].y > (at_real )0) {
#line 311
            tmp___462 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[2].y < (at_real )0) {
#line 311
              tmp___461 = -1;
            } else {
#line 311
              tmp___461 = 0;
            }
#line 311
            tmp___462 = tmp___461;
          }
#line 311
          s___0.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[2].y)) + .5 * (double )tmp___462)) / (at_real )6.0;
#line 311
          if ((at_real )6.0 * s___0.v[2].y > (at_real )0) {
#line 311
            tmp___472 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[2].y < (at_real )0) {
#line 311
              tmp___471 = -1;
            } else {
#line 311
              tmp___471 = 0;
            }
#line 311
            tmp___472 = tmp___471;
          }
#line 311
          s___0.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[2].y)) + .5 * (double )tmp___472)) / (at_real )6.0;
#line 311
          if (s___0.v[2].y > (at_real )0) {
#line 311
            tmp___470 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[2].y > (at_real )0) {
#line 311
              tmp___469 = 1;
            } else {
#line 311
              if ((at_real )6.0 * s___0.v[2].y < (at_real )0) {
#line 311
                tmp___468 = -1;
              } else {
#line 311
                tmp___468 = 0;
              }
#line 311
              tmp___469 = tmp___468;
            }
#line 311
            s___0.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[2].y)) + .5 * (double )tmp___469)) / (at_real )6.0;
#line 311
            if (s___0.v[2].y < (at_real )0) {
#line 311
              tmp___467 = -1;
            } else {
#line 311
              tmp___467 = 0;
            }
#line 311
            tmp___470 = tmp___467;
          }
#line 311
          if (s___0.v[2].y == (at_real )((int )((double )((int )s___0.v[2].y) + .5 * (double )tmp___470))) {
#line 311
            tmp___460 = "%.0f ";
          } else {
#line 311
            tmp___460 = "%.3f ";
          }
          {
#line 311
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)tmp___460,
                  (double )s___0.v[2].y);
#line 311
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s",
                  " ");
          }
#line 311
          if ((at_real )6.0 * s___0.v[3].x > (at_real )0) {
#line 311
            tmp___487 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[3].x < (at_real )0) {
#line 311
              tmp___486 = -1;
            } else {
#line 311
              tmp___486 = 0;
            }
#line 311
            tmp___487 = tmp___486;
          }
#line 311
          s___0.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].x)) + .5 * (double )tmp___487)) / (at_real )6.0;
#line 311
          if ((at_real )6.0 * s___0.v[3].x > (at_real )0) {
#line 311
            tmp___497 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[3].x < (at_real )0) {
#line 311
              tmp___496 = -1;
            } else {
#line 311
              tmp___496 = 0;
            }
#line 311
            tmp___497 = tmp___496;
          }
#line 311
          s___0.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].x)) + .5 * (double )tmp___497)) / (at_real )6.0;
#line 311
          if (s___0.v[3].x > (at_real )0) {
#line 311
            tmp___495 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[3].x > (at_real )0) {
#line 311
              tmp___494 = 1;
            } else {
#line 311
              if ((at_real )6.0 * s___0.v[3].x < (at_real )0) {
#line 311
                tmp___493 = -1;
              } else {
#line 311
                tmp___493 = 0;
              }
#line 311
              tmp___494 = tmp___493;
            }
#line 311
            s___0.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].x)) + .5 * (double )tmp___494)) / (at_real )6.0;
#line 311
            if (s___0.v[3].x < (at_real )0) {
#line 311
              tmp___492 = -1;
            } else {
#line 311
              tmp___492 = 0;
            }
#line 311
            tmp___495 = tmp___492;
          }
#line 311
          if (s___0.v[3].x == (at_real )((int )((double )((int )s___0.v[3].x) + .5 * (double )tmp___495))) {
#line 311
            tmp___485 = "%.0f ";
          } else {
#line 311
            tmp___485 = "%.3f ";
          }
          {
#line 311
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)tmp___485,
                  (double )s___0.v[3].x);
          }
#line 311
          if ((at_real )6.0 * s___0.v[3].y > (at_real )0) {
#line 311
            tmp___512 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[3].y < (at_real )0) {
#line 311
              tmp___511 = -1;
            } else {
#line 311
              tmp___511 = 0;
            }
#line 311
            tmp___512 = tmp___511;
          }
#line 311
          s___0.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].y)) + .5 * (double )tmp___512)) / (at_real )6.0;
#line 311
          if ((at_real )6.0 * s___0.v[3].y > (at_real )0) {
#line 311
            tmp___522 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[3].y < (at_real )0) {
#line 311
              tmp___521 = -1;
            } else {
#line 311
              tmp___521 = 0;
            }
#line 311
            tmp___522 = tmp___521;
          }
#line 311
          s___0.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].y)) + .5 * (double )tmp___522)) / (at_real )6.0;
#line 311
          if (s___0.v[3].y > (at_real )0) {
#line 311
            tmp___520 = 1;
          } else {
#line 311
            if ((at_real )6.0 * s___0.v[3].y > (at_real )0) {
#line 311
              tmp___519 = 1;
            } else {
#line 311
              if ((at_real )6.0 * s___0.v[3].y < (at_real )0) {
#line 311
                tmp___518 = -1;
              } else {
#line 311
                tmp___518 = 0;
              }
#line 311
              tmp___519 = tmp___518;
            }
#line 311
            s___0.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s___0.v[3].y)) + .5 * (double )tmp___519)) / (at_real )6.0;
#line 311
            if (s___0.v[3].y < (at_real )0) {
#line 311
              tmp___517 = -1;
            } else {
#line 311
              tmp___517 = 0;
            }
#line 311
            tmp___520 = tmp___517;
          }
#line 311
          if (s___0.v[3].y == (at_real )((int )((double )((int )s___0.v[3].y) + .5 * (double )tmp___520))) {
#line 311
            tmp___510 = "%.0f ";
          } else {
#line 311
            tmp___510 = "%.3f ";
          }
          {
#line 311
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)tmp___510,
                  (double )s___0.v[3].y);
#line 311
          fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s",
                  " c \n");
          }
#line 311
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 303
      this_spline___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 280
    this_list ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 317
  if (shape.length > 0U) {
#line 318
    if (shape.centerline) {
#line 318
      tmp___523 = "S";
    } else
#line 318
    if (list.open) {
#line 318
      tmp___523 = "S";
    } else {
#line 318
      tmp___523 = "f";
    }
    {
#line 318
    fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
            tmp___523);
    }
  }
  {
#line 319
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "endstream");
#line 320
  fprintf((FILE */* __restrict  */)pdf_file, (char const   */* __restrict  */)"%s\n",
          "endobj");
  }
#line 322
  return;
}
}
#line 325 "output-pdf.c"
int output_pdf_writer(FILE *pdf_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) 
{ 
  int result ;
  size_t length ;

  {
  {
#line 333
  length = (size_t )0;
#line 343
  result = output_pdf_header(pdf_file, name, llx, lly, urx, ury);
  }
#line 344
  if (result != 0) {
#line 345
    return (result);
  }
  {
#line 347
  out_splines___1(pdf_file, shape, & length);
#line 349
  output_pdf_tailor(pdf_file, length, llx, lly, urx, ury);
  }
#line 351
  return (0);
}
}
#line 94 "output-p2e.c"
static int output_p2e_header(FILE *ps_file , at_string name , int llx , int lly ,
                             int urx , int ury , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  unsigned int with_curves ;
  unsigned int this_spline ;
  spline_list_type list ;
  spline_type s ;

  {
#line 97
  with_curves = 1U;
#line 99
  this_list = 0U;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (this_list < shape.length)) {
#line 99
      goto while_break;
    }
#line 104
    list = *(shape.data + this_list);
#line 106
    this_spline = 0U;
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! (this_spline < list.length)) {
#line 106
        goto while_break___0;
      }
#line 109
      s = *(list.data + this_spline);
#line 111
      if ((unsigned int )s.degree != 1U) {
#line 113
        with_curves = 0U;
#line 114
        this_list = shape.length;
#line 115
        goto while_break___0;
      }
#line 106
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 99
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%!PS-Adobe-3.0");
#line 122
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%%%%Title: flattened PostScript generated by autotrace: %s\n",
          name);
#line 123
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%Creator: pstoedit");
#line 124
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%BoundingBox: (atend)");
#line 125
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%Pages: (atend)");
#line 126
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%EndComments");
#line 127
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%BeginProlog");
#line 128
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/setPageSize { pop pop } def");
#line 129
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/ntranslate { neg exch neg exch translate } def");
#line 130
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/setshowparams { pop pop pop} def");
#line 131
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/awidthshowhex { dup /ASCIIHexDecode filter exch length 2 div cvi string readstring pop awidthshow } def");
#line 132
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/backendconstraints { pop pop } def");
#line 133
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/pstoedit.newfont { 80 string cvs  findfont  dup length dict begin {1 index /FID ne {def} {pop pop} ifelse} forall  /Encoding ISOLatin1Encoding def   dup 80 string cvs /FontName exch def  currentdict end  definefont pop } def");
#line 134
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/imagestring 1 string def");
#line 135
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%EndProlog");
#line 136
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%BeginSetup");
#line 137
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "% textastext doflatten backendconstraints  ");
#line 138
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%d 0 backendconstraints\n",
          with_curves);
#line 139
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%EndSetup");
  }
#line 141
  return (0);
}
}
#line 147 "output-p2e.c"
static void out_splines___2(FILE *ps_file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  unsigned int pathnr ;
  spline_list_type list ;
  color_type last_color ;
  unsigned int this_spline ;
  spline_type first ;
  int c ;
  int m ;
  int y ;
  int k ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  spline_type s ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char const   *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char const   *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  char const   *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  char const   *tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char const   *tmp___51 ;

  {
  {
#line 151
  pathnr = 1U;
#line 153
  last_color.r = (unsigned char)0;
#line 153
  last_color.g = (unsigned char)0;
#line 153
  last_color.b = (unsigned char)0;
#line 155
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          " 612 792 setPageSize");
#line 156
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          " 0 setlinecap");
#line 157
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          " 10.0 setmiterlimit");
#line 158
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          " 0 setlinejoin");
#line 159
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          " [ ] 0.0 setdash");
#line 160
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          " 1.0 setlinewidth");
#line 162
  this_list = 0U;
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (this_list < shape.length)) {
#line 162
      goto while_break;
    }
#line 168
    list = *(shape.data + this_list);
#line 169
    first = *(list.data + 0);
#line 172
    if (this_list == 0U) {
#line 172
      goto _L___1;
    } else
#line 172
    if ((int )list.color.r == (int )last_color.r) {
#line 172
      if ((int )list.color.g == (int )last_color.g) {
#line 172
        if (! ((int )list.color.b == (int )last_color.b)) {
#line 172
          goto _L___1;
        }
      } else {
#line 172
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 176
      if (shape.centerline) {
#line 176
        tmp = "stroke";
      } else
#line 176
      if (list.open) {
#line 176
        tmp = "stroke";
      } else {
#line 176
        tmp = "fill";
      }
      {
#line 176
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
              tmp);
#line 177
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"\n\n%% %d pathnumber\n",
              pathnr);
      }
#line 178
      if (shape.centerline) {
#line 178
        tmp___0 = "% strokedpath";
      } else
#line 178
      if (list.open) {
#line 178
        tmp___0 = "% strokedpath";
      } else {
#line 178
        tmp___0 = "% filledpath";
      }
      {
#line 178
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
              tmp___0);
#line 179
      pathnr ++;
#line 186
      k = 255 - (int )list.color.r;
#line 186
      c = k;
#line 187
      m = 255 - (int )list.color.g;
      }
#line 188
      if (m < k) {
#line 189
        k = m;
      }
#line 190
      y = 255 - (int )list.color.b;
#line 191
      if (y < k) {
#line 192
        k = y;
      }
      {
#line 193
      c -= k;
#line 194
      m -= k;
#line 195
      y -= k;
#line 196
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%.3f %.3f %.3f %.3f %s\n",
              (double )c / 255.0, (double )m / 255.0, (double )y / 255.0, (double )k / 255.0,
              "setcmykcolor");
#line 198
      last_color = list.color;
      }
    }
    {
#line 201
    fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
            "newpath");
    }
    {
#line 202
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 202
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
              " ");
      }
#line 202
      if (first.v[0].x > (at_real )0) {
#line 202
        tmp___5 = 1;
      } else {
#line 202
        if (first.v[0].x < (at_real )0) {
#line 202
          tmp___4 = -1;
        } else {
#line 202
          tmp___4 = 0;
        }
#line 202
        tmp___5 = tmp___4;
      }
#line 202
      if (first.v[0].x == (at_real )((int )((double )((int )first.v[0].x) + .5 * (double )tmp___5))) {
#line 202
        tmp___3 = "%.0f ";
      } else {
#line 202
        tmp___3 = "%.3f ";
      }
      {
#line 202
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___3,
              (double )first.v[0].x);
      }
#line 202
      if (first.v[0].y > (at_real )0) {
#line 202
        tmp___10 = 1;
      } else {
#line 202
        if (first.v[0].y < (at_real )0) {
#line 202
          tmp___9 = -1;
        } else {
#line 202
          tmp___9 = 0;
        }
#line 202
        tmp___10 = tmp___9;
      }
#line 202
      if (first.v[0].y == (at_real )((int )((double )((int )first.v[0].y) + .5 * (double )tmp___10))) {
#line 202
        tmp___8 = "%.0f ";
      } else {
#line 202
        tmp___8 = "%.3f ";
      }
      {
#line 202
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___8,
              (double )first.v[0].y);
#line 202
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
              "moveto\n");
      }
#line 202
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 204
    this_spline = 0U;
    {
#line 204
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 204
      if (! (this_spline < list.length)) {
#line 204
        goto while_break___1;
      }
#line 207
      s = *(list.data + this_spline);
#line 209
      if ((unsigned int )s.degree == 1U) {
        {
#line 210
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 210
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
                  " ");
          }
#line 210
          if (s.v[3].x > (at_real )0) {
#line 210
            tmp___15 = 1;
          } else {
#line 210
            if (s.v[3].x < (at_real )0) {
#line 210
              tmp___14 = -1;
            } else {
#line 210
              tmp___14 = 0;
            }
#line 210
            tmp___15 = tmp___14;
          }
#line 210
          if (s.v[3].x == (at_real )((int )((double )((int )s.v[3].x) + .5 * (double )tmp___15))) {
#line 210
            tmp___13 = "%.0f ";
          } else {
#line 210
            tmp___13 = "%.3f ";
          }
          {
#line 210
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___13,
                  (double )s.v[3].x);
          }
#line 210
          if (s.v[3].y > (at_real )0) {
#line 210
            tmp___20 = 1;
          } else {
#line 210
            if (s.v[3].y < (at_real )0) {
#line 210
              tmp___19 = -1;
            } else {
#line 210
              tmp___19 = 0;
            }
#line 210
            tmp___20 = tmp___19;
          }
#line 210
          if (s.v[3].y == (at_real )((int )((double )((int )s.v[3].y) + .5 * (double )tmp___20))) {
#line 210
            tmp___18 = "%.0f ";
          } else {
#line 210
            tmp___18 = "%.3f ";
          }
          {
#line 210
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___18,
                  (double )s.v[3].y);
#line 210
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
                  "lineto\n");
          }
#line 210
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 212
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 212
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
                  " ");
          }
#line 212
          if (s.v[1].x > (at_real )0) {
#line 212
            tmp___25 = 1;
          } else {
#line 212
            if (s.v[1].x < (at_real )0) {
#line 212
              tmp___24 = -1;
            } else {
#line 212
              tmp___24 = 0;
            }
#line 212
            tmp___25 = tmp___24;
          }
#line 212
          if (s.v[1].x == (at_real )((int )((double )((int )s.v[1].x) + .5 * (double )tmp___25))) {
#line 212
            tmp___23 = "%.0f ";
          } else {
#line 212
            tmp___23 = "%.3f ";
          }
          {
#line 212
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___23,
                  (double )s.v[1].x);
          }
#line 212
          if (s.v[1].y > (at_real )0) {
#line 212
            tmp___30 = 1;
          } else {
#line 212
            if (s.v[1].y < (at_real )0) {
#line 212
              tmp___29 = -1;
            } else {
#line 212
              tmp___29 = 0;
            }
#line 212
            tmp___30 = tmp___29;
          }
#line 212
          if (s.v[1].y == (at_real )((int )((double )((int )s.v[1].y) + .5 * (double )tmp___30))) {
#line 212
            tmp___28 = "%.0f ";
          } else {
#line 212
            tmp___28 = "%.3f ";
          }
          {
#line 212
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___28,
                  (double )s.v[1].y);
#line 212
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
                  " ");
          }
#line 212
          if (s.v[2].x > (at_real )0) {
#line 212
            tmp___35 = 1;
          } else {
#line 212
            if (s.v[2].x < (at_real )0) {
#line 212
              tmp___34 = -1;
            } else {
#line 212
              tmp___34 = 0;
            }
#line 212
            tmp___35 = tmp___34;
          }
#line 212
          if (s.v[2].x == (at_real )((int )((double )((int )s.v[2].x) + .5 * (double )tmp___35))) {
#line 212
            tmp___33 = "%.0f ";
          } else {
#line 212
            tmp___33 = "%.3f ";
          }
          {
#line 212
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___33,
                  (double )s.v[2].x);
          }
#line 212
          if (s.v[2].y > (at_real )0) {
#line 212
            tmp___40 = 1;
          } else {
#line 212
            if (s.v[2].y < (at_real )0) {
#line 212
              tmp___39 = -1;
            } else {
#line 212
              tmp___39 = 0;
            }
#line 212
            tmp___40 = tmp___39;
          }
#line 212
          if (s.v[2].y == (at_real )((int )((double )((int )s.v[2].y) + .5 * (double )tmp___40))) {
#line 212
            tmp___38 = "%.0f ";
          } else {
#line 212
            tmp___38 = "%.3f ";
          }
          {
#line 212
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___38,
                  (double )s.v[2].y);
#line 212
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
                  " ");
          }
#line 212
          if (s.v[3].x > (at_real )0) {
#line 212
            tmp___45 = 1;
          } else {
#line 212
            if (s.v[3].x < (at_real )0) {
#line 212
              tmp___44 = -1;
            } else {
#line 212
              tmp___44 = 0;
            }
#line 212
            tmp___45 = tmp___44;
          }
#line 212
          if (s.v[3].x == (at_real )((int )((double )((int )s.v[3].x) + .5 * (double )tmp___45))) {
#line 212
            tmp___43 = "%.0f ";
          } else {
#line 212
            tmp___43 = "%.3f ";
          }
          {
#line 212
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___43,
                  (double )s.v[3].x);
          }
#line 212
          if (s.v[3].y > (at_real )0) {
#line 212
            tmp___50 = 1;
          } else {
#line 212
            if (s.v[3].y < (at_real )0) {
#line 212
              tmp___49 = -1;
            } else {
#line 212
              tmp___49 = 0;
            }
#line 212
            tmp___50 = tmp___49;
          }
#line 212
          if (s.v[3].y == (at_real )((int )((double )((int )s.v[3].y) + .5 * (double )tmp___50))) {
#line 212
            tmp___48 = "%.0f ";
          } else {
#line 212
            tmp___48 = "%.3f ";
          }
          {
#line 212
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___48,
                  (double )s.v[3].y);
#line 212
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
                  " curveto\n");
          }
#line 212
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 204
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 217
    if (! list.open) {
      {
#line 217
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
              "closepath");
      }
    }
#line 162
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  if (shape.length > 0U) {
#line 220
    if (shape.centerline) {
#line 220
      tmp___51 = "stroke";
    } else
#line 220
    if (list.open) {
#line 220
      tmp___51 = "stroke";
    } else {
#line 220
      tmp___51 = "fill";
    }
    {
#line 220
    fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
            tmp___51);
    }
  }
#line 221
  return;
}
}
#line 224 "output-p2e.c"
int output_p2e_writer(FILE *ps_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) 
{ 
  int result ;

  {
  {
#line 233
  result = output_p2e_header(ps_file, name, llx, lly, urx, ury, shape);
  }
#line 234
  if (result != 0) {
#line 234
    return (result);
  }
  {
#line 236
  out_splines___2(ps_file, shape);
#line 238
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "showpage");
#line 239
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%%%%BoundingBox: %d %d %d %d\n",
          llx, lly, urx, ury);
#line 240
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%Page: 1 1");
#line 241
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "% normal end reached by pstoedit.pro");
#line 242
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%Trailer");
#line 243
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%Pages: 1");
#line 244
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%EOF");
  }
#line 246
  return (0);
}
}
#line 439 "autotrace.h"
char const   *at_version(at_bool long_format ) ;
#line 25 "output-mif.h"
int output_mif_writer(FILE *ps_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) ;
#line 47 "output-mif.c"
BboxT cbox  ;
#line 54 "output-mif.c"
static char buffer[15]  ;
#line 52 "output-mif.c"
static char const   *colorstring(int r , int g , int b ) 
{ 


  {
#line 55
  if (r == 0) {
#line 55
    if (g == 0) {
#line 55
      if (b == 0) {
#line 56
        return ("Black");
      } else {
#line 55
        goto _L___12;
      }
    } else {
#line 55
      goto _L___12;
    }
  } else
  _L___12: /* CIL Label */ 
#line 57
  if (r == 255) {
#line 57
    if (g == 0) {
#line 57
      if (b == 0) {
#line 58
        return ("Red");
      } else {
#line 57
        goto _L___10;
      }
    } else {
#line 57
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 59
  if (r == 0) {
#line 59
    if (g == 255) {
#line 59
      if (b == 0) {
#line 60
        return ("Green");
      } else {
#line 59
        goto _L___8;
      }
    } else {
#line 59
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 61
  if (r == 0) {
#line 61
    if (g == 0) {
#line 61
      if (b == 255) {
#line 62
        return ("Blue");
      } else {
#line 61
        goto _L___6;
      }
    } else {
#line 61
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 63
  if (r == 255) {
#line 63
    if (g == 255) {
#line 63
      if (b == 0) {
#line 64
        return ("Yellow");
      } else {
#line 63
        goto _L___4;
      }
    } else {
#line 63
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 65
  if (r == 255) {
#line 65
    if (g == 0) {
#line 65
      if (b == 255) {
#line 66
        return ("Magenta");
      } else {
#line 65
        goto _L___2;
      }
    } else {
#line 65
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 67
  if (r == 0) {
#line 67
    if (g == 255) {
#line 67
      if (b == 255) {
#line 68
        return ("Cyan");
      } else {
#line 67
        goto _L___0;
      }
    } else {
#line 67
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 69
  if (r == 255) {
#line 69
    if (g == 255) {
#line 69
      if (b == 255) {
#line 70
        return ("White");
      } else {
        {
#line 72
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"R%.3dG%.3dB%.3d",
                r, g, b);
        }
      }
    } else {
      {
#line 72
      sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"R%.3dG%.3dB%.3d",
              r, g, b);
      }
    }
  } else {
    {
#line 72
    sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"R%.3dG%.3dB%.3d",
            r, g, b);
    }
  }
#line 74
  return ((char const   *)(buffer));
}
}
#line 80 "output-mif.c"
static at_real bezpnt(at_real t , at_real z1 , at_real z2 , at_real z3 , at_real z4 ) 
{ 
  at_real temp ;
  at_real t1 ;

  {
#line 84
  if (t < (at_real )0.0) {
#line 84
    t = (at_real )0.0;
  }
#line 85
  if (t > (at_real )1.0) {
#line 85
    t = (at_real )1.0;
  }
#line 86
  t1 = (at_real )1.0 - t;
#line 87
  temp = ((((t1 * t1) * t1) * z1 + ((((at_real )3.0 * t) * t1) * t1) * z2) + ((((at_real )3.0 * t) * t) * t1) * z3) + ((t * t) * t) * z4;
#line 88
  return (temp);
}
}
#line 94 "output-mif.c"
static void print_coord(FILE *f , at_real x , at_real y ) 
{ 


  {
  {
#line 96
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  <Point %.2f %.2f>\n",
          ((double )x * 72.0) / (double )cbox.dpi, ((double )(((at_real )cbox.ury - y) + (at_real )1) * 72.0) / (double )cbox.dpi);
  }
#line 98
  return;
}
}
#line 103 "output-mif.c"
int output_mif_writer(FILE *ps_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) 
{ 
  unsigned int this_list ;
  int i ;
  ColorT col_tbl[256] ;
  int n_ctbl ;
  color_type curr_color ;
  char const   *tmp ;
  spline_list_type list ;
  char const   *tmp___0 ;
  int c ;
  int m ;
  int y ;
  int k ;
  unsigned int this_spline ;
  at_bool smooth ;
  spline_list_type list___0 ;
  spline_type first ;
  char const   *tmp___1 ;
  spline_type s ;
  at_real temp ;
  at_real dt ;
  at_real tmp___2 ;
  at_real tmp___3 ;
  double tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 112
  n_ctbl = 0;
#line 113
  curr_color.r = (unsigned char)0;
#line 113
  curr_color.g = (unsigned char)0;
#line 113
  curr_color.b = (unsigned char)0;
#line 116
  cbox.llx = llx;
#line 117
  cbox.lly = lly;
#line 118
  cbox.urx = urx;
#line 119
  cbox.ury = ury;
#line 120
  cbox.dpi = (at_real )opts->dpi;
#line 122
  tmp = at_version((at_bool )1);
#line 122
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"<MIFFile 4.00> #%s\n<Units Upt>\n<ColorCatalog\n",
          tmp);
#line 124
  this_list = 0U;
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (this_list < shape.length)) {
#line 124
      goto while_break;
    }
#line 125
    list = *(shape.data + this_list);
#line 126
    if (list.clockwise) {
#line 126
      if ((unsigned long )shape.background_color != (unsigned long )((void *)0)) {
#line 126
        curr_color = *(shape.background_color);
      } else {
#line 126
        curr_color = list.color;
      }
    } else {
#line 126
      curr_color = list.color;
    }
#line 128
    i = 0;
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 128
      if (! (i < n_ctbl)) {
#line 128
        goto while_break___0;
      }
#line 129
      if ((int )curr_color.r == (int )col_tbl[i].c.r) {
#line 129
        if ((int )curr_color.g == (int )col_tbl[i].c.g) {
#line 129
          if ((int )curr_color.b == (int )col_tbl[i].c.b) {
#line 129
            goto while_break___0;
          }
        }
      }
#line 128
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 131
    if (i >= n_ctbl) {
      {
#line 132
      tmp___0 = colorstring((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 132
      col_tbl[n_ctbl].tag = strdup(tmp___0);
#line 133
      col_tbl[n_ctbl].c = curr_color;
#line 134
      n_ctbl ++;
      }
    }
#line 124
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 137
    if (! (i < n_ctbl)) {
#line 137
      goto while_break___1;
    }
#line 139
    k = 255 - (int )col_tbl[i].c.r;
#line 139
    c = k;
#line 140
    m = 255 - (int )col_tbl[i].c.g;
#line 141
    if (m < k) {
#line 141
      k = m;
    }
#line 142
    y = 255 - (int )col_tbl[i].c.b;
#line 143
    if (y < k) {
#line 143
      k = y;
    }
    {
#line 144
    c -= k;
#line 145
    m -= k;
#line 146
    y -= k;
#line 147
    fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)" <Color <ColorTag %s><ColorCyan %d><ColorMagenta %d><ColorYellow %d><ColorBlack %d>>\n",
            col_tbl[i].tag, (c * 100) / 255, (m * 100) / 255, (y * 100) / 255, (k * 100) / 255);
#line 137
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 152
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)">\n");
#line 154
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"<Frame\n <Pen 15>\n <Fill 15>\n <PenWidth  0.2 pt>\n <Separation 0>\n <BRect  0.0 pt 0.0 pt %.1f pt %.1f pt>\n",
          ((double )(urx - llx) * 72.0) / (double )cbox.dpi, ((double )(ury - lly) * 72.0) / (double )cbox.dpi);
#line 163
  this_list = 0U;
  }
  {
#line 163
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 163
    if (! (this_list < shape.length)) {
#line 163
      goto while_break___2;
    }
#line 167
    list___0 = *(shape.data + this_list);
#line 168
    first = *(list___0.data + 0);
#line 170
    i = 0;
    {
#line 170
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 170
      if (! (i < n_ctbl)) {
#line 170
        goto while_break___3;
      }
#line 171
      if ((int )curr_color.r == (int )col_tbl[i].c.r) {
#line 171
        if ((int )curr_color.g == (int )col_tbl[i].c.g) {
#line 171
          if ((int )curr_color.b == (int )col_tbl[i].c.b) {
#line 171
            goto while_break___3;
          }
        }
      }
#line 170
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 173
    if (shape.centerline) {
#line 173
      tmp___1 = "<PolyLine <Fill 15><Pen 0>";
    } else
#line 173
    if (list___0.open) {
#line 173
      tmp___1 = "<PolyLine <Fill 15><Pen 0>";
    } else {
#line 173
      tmp___1 = "<Polygon <Fill 0><Pen 15>";
    }
    {
#line 173
    fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)" %s\n",
            tmp___1);
#line 177
    fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"  <ObColor `%s\'>\n",
            col_tbl[i].tag);
#line 179
    print_coord(ps_file, first.v[0].x, first.v[0].y);
#line 180
    smooth = (at_bool )0;
#line 181
    this_spline = 0U;
    }
    {
#line 181
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 181
      if (! (this_spline < list___0.length)) {
#line 181
        goto while_break___4;
      }
#line 182
      s = *(list___0.data + this_spline);
#line 184
      if ((unsigned int )s.degree == 1U) {
        {
#line 185
        print_coord(ps_file, s.v[3].x, s.v[3].y);
        }
      } else {
#line 188
        dt = (at_real )(1.0 / 7.0);
#line 190
        temp = dt;
        {
#line 190
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 190
          tmp___4 = fabs((double )(temp - (at_real )1.0));
          }
#line 190
          if (! (tmp___4 < (double )dt)) {
#line 190
            goto while_break___5;
          }
          {
#line 191
          tmp___2 = bezpnt(temp, s.v[0].y, s.v[1].y, s.v[2].y, s.v[3].y);
#line 191
          tmp___3 = bezpnt(temp, s.v[0].x, s.v[1].x, s.v[2].x, s.v[3].x);
#line 191
          print_coord(ps_file, tmp___3, tmp___2);
#line 190
          temp += dt;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 181
      this_spline ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 197
    if (smooth) {
#line 197
      tmp___5 = "Yes";
    } else {
#line 197
      tmp___5 = "No";
    }
    {
#line 197
    fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"  <Smoothed %s>\n",
            tmp___5);
#line 198
    fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)" >\n");
#line 163
    this_list ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 200
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)">\n");
  }
#line 201
  return (0);
}
}
#line 25 "exception.h"
at_exception_type at_exception_new(void (*client_func)(at_string msg , at_msg_type msg_type ,
                                                       at_address client_data ) ,
                                   at_address client_data ) ;
#line 25 "output-fig.h"
int output_fig_writer(FILE *file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) ;
#line 46 "output-fig.c"
static at_real bezpnt___0(at_real t , at_real z1 , at_real z2 , at_real z3 , at_real z4 ) ;
#line 47
static void out_fig_splines(FILE *file , at_spline_list_array_type shape , int llx ,
                            int lly , int urx , int ury , at_exception_type *exp ) ;
#line 49
static int get_fig_colour(color_type this_colour , at_exception_type *exp ) ;
#line 50
static void fig_col_init(void) ;
#line 55 "output-fig.c"
static struct __anonstruct_fig_hash_961093920 fig_hash[544]  ;
#line 60 "output-fig.c"
static struct __anonstruct_fig_colour_map_852451852 fig_colour_map[544]  ;
#line 65 "output-fig.c"
static int LAST_FIG_COLOUR  =    32;
#line 69 "output-fig.c"
static float glob_min_x  ;
#line 69 "output-fig.c"
static float glob_max_x  ;
#line 69 "output-fig.c"
static float glob_min_y  ;
#line 69 "output-fig.c"
static float glob_max_y  ;
#line 70 "output-fig.c"
static float loc_min_x  ;
#line 70 "output-fig.c"
static float loc_max_x  ;
#line 70 "output-fig.c"
static float loc_min_y  ;
#line 70 "output-fig.c"
static float loc_max_y  ;
#line 71 "output-fig.c"
static int glo_bbox_flag  =    0;
#line 71 "output-fig.c"
static int loc_bbox_flag  =    0;
#line 71 "output-fig.c"
static int fig_depth  ;
#line 73 "output-fig.c"
static void fig_new_depth(void) 
{ 


  {
#line 75
  if (glo_bbox_flag == 0) {
#line 76
    glob_max_y = loc_max_y;
#line 76
    glob_min_y = loc_min_y;
#line 77
    glob_max_y = loc_max_y;
#line 77
    glob_min_y = loc_min_y;
#line 78
    glob_max_x = loc_max_x;
#line 78
    glob_min_x = loc_min_x;
#line 79
    glo_bbox_flag = 1;
  } else
#line 81
  if (loc_max_y <= glob_min_y) {
#line 81
    goto _L;
  } else
#line 81
  if (loc_min_y >= glob_max_y) {
#line 81
    goto _L;
  } else
#line 81
  if (loc_max_x <= glob_min_x) {
#line 81
    goto _L;
  } else
#line 81
  if (loc_min_x >= glob_max_x) {
    _L: /* CIL Label */ 
#line 86
    if (loc_max_y > glob_max_y) {
#line 86
      glob_max_y = loc_max_y;
    }
#line 87
    if (loc_min_y < glob_min_y) {
#line 87
      glob_min_y = loc_min_y;
    }
#line 88
    if (loc_max_x > glob_max_x) {
#line 88
      glob_max_x = loc_max_x;
    }
#line 89
    if (loc_min_x < glob_min_x) {
#line 89
      glob_min_x = loc_min_x;
    }
  } else {
#line 92
    glob_max_y = loc_max_y;
#line 92
    glob_min_y = loc_min_y;
#line 93
    glob_max_x = loc_max_x;
#line 93
    glob_min_x = loc_min_x;
#line 94
    if (fig_depth) {
#line 94
      fig_depth --;
    }
  }
#line 97
  loc_bbox_flag = 0;
#line 98
  return;
}
}
#line 100 "output-fig.c"
static void fig_addtobbox(float x , float y ) 
{ 


  {
#line 102
  if (loc_bbox_flag == 0) {
#line 103
    loc_max_y = y;
#line 103
    loc_min_y = y;
#line 104
    loc_max_x = x;
#line 104
    loc_min_x = x;
#line 105
    loc_bbox_flag = 1;
  } else {
#line 107
    if (loc_max_y < y) {
#line 107
      loc_max_y = y;
    }
#line 108
    if (loc_min_y > y) {
#line 108
      loc_min_y = y;
    }
#line 109
    if (loc_max_x < x) {
#line 109
      loc_max_x = x;
    }
#line 110
    if (loc_min_x > x) {
#line 110
      loc_min_x = x;
    }
  }
#line 112
  return;
}
}
#line 117 "output-fig.c"
static at_real bezpnt___0(at_real t , at_real z1 , at_real z2 , at_real z3 , at_real z4 ) 
{ 
  at_real temp ;
  at_real t1 ;

  {
#line 121
  if (t < (at_real )0.0) {
#line 121
    t = (at_real )0.0;
  }
#line 122
  if (t > (at_real )1.0) {
#line 122
    t = (at_real )1.0;
  }
#line 123
  t1 = (at_real )1.0 - t;
#line 124
  temp = ((((t1 * t1) * t1) * z1 + ((((at_real )3.0 * t) * t1) * t1) * z2) + ((((at_real )3.0 * t) * t) * t1) * z3) + ((t * t) * t) * z4;
#line 125
  return (temp);
}
}
#line 128 "output-fig.c"
static void out_fig_splines(FILE *file , at_spline_list_array_type shape , int llx ,
                            int lly , int urx , int ury , at_exception_type *exp ) 
{ 
  unsigned int this_list ;
  int fig_colour ;
  int fig_fill ;
  int fig_width ;
  int fig_subt ;
  int fig_spline_close ;
  int i ;
  int *spline_colours ;
  void *tmp ;
  spline_list_type list ;
  color_type curr_color ;
  at_color_type tmp___1 ;
  unsigned int this_spline ;
  spline_list_type list___0 ;
  int *pointx ;
  int *pointy ;
  at_real *contrl ;
  int pointcount ;
  int is_spline ;
  int j ;
  int maxlength ;
  void *tmp___2 ;
  void *tmp___4 ;
  void *tmp___6 ;
  spline_type s ;
  at_real temp ;
  at_real tmp___8 ;
  at_real tmp___9 ;

  {
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 143
    tmp = malloc(sizeof(int ) * (unsigned long )shape.length);
#line 143
    spline_colours = (int *)tmp;
    }
#line 143
    if (! spline_colours) {
      {
#line 143
      __assert_fail("spline_colours", "output-fig.c", 143U, "out_fig_splines");
      }
    }
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  fig_col_init();
#line 149
  this_list = 0U;
  }
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if (! (this_list < shape.length)) {
#line 149
      goto while_break___0;
    }
#line 152
    list = *(shape.data + this_list);
#line 153
    if (list.clockwise) {
#line 153
      if ((unsigned long )shape.background_color != (unsigned long )((void *)0)) {
#line 153
        tmp___1 = *(shape.background_color);
      } else {
#line 153
        tmp___1 = list.color;
      }
    } else {
#line 153
      tmp___1 = list.color;
    }
    {
#line 153
    curr_color = tmp___1;
#line 154
    *(spline_colours + this_list) = get_fig_colour(curr_color, exp);
#line 149
    this_list ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 157
  if (LAST_FIG_COLOUR > 32) {
#line 158
    i = 32;
    {
#line 158
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 158
      if (! (i < LAST_FIG_COLOUR)) {
#line 158
        goto while_break___1;
      }
      {
#line 159
      fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"0 %d #%.2x%.2x%.2x\n",
              i, (int )fig_colour_map[i].r, (int )fig_colour_map[i].g, (int )fig_colour_map[i].b);
#line 158
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 164
  fig_depth = (int )(shape.length + 20U);
#line 165
  if (fig_depth > 999) {
#line 165
    fig_depth = 999;
  }
#line 167
  this_list = 0U;
  {
#line 167
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 167
    if (! (this_list < shape.length)) {
#line 167
      goto while_break___2;
    }
#line 171
    list___0 = *(shape.data + this_list);
#line 176
    pointcount = 0;
#line 176
    is_spline = 0;
#line 177
    maxlength = (int )(list___0.length * 5U + 1U);
    {
#line 179
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 179
      tmp___2 = malloc((unsigned long )maxlength * sizeof(int ));
#line 179
      pointx = (int *)tmp___2;
      }
#line 179
      if (! pointx) {
        {
#line 179
        __assert_fail("pointx", "output-fig.c", 179U, "out_fig_splines");
        }
      }
#line 179
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 180
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 180
      tmp___4 = malloc((unsigned long )maxlength * sizeof(int ));
#line 180
      pointy = (int *)tmp___4;
      }
#line 180
      if (! pointy) {
        {
#line 180
        __assert_fail("pointy", "output-fig.c", 180U, "out_fig_splines");
        }
      }
#line 180
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 181
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 181
      tmp___6 = malloc((unsigned long )maxlength * sizeof(at_real ));
#line 181
      contrl = (at_real *)tmp___6;
      }
#line 181
      if (! contrl) {
        {
#line 181
        __assert_fail("contrl", "output-fig.c", 181U, "out_fig_splines");
        }
      }
#line 181
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 183
    if (list___0.clockwise) {
#line 183
      fig_colour = 7;
    } else {
#line 184
      fig_colour = *(spline_colours + this_list);
    }
#line 186
    fig_spline_close = 5;
#line 188
    this_spline = 0U;
    {
#line 188
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 188
      if (! (this_spline < list___0.length)) {
#line 188
        goto while_break___6;
      }
#line 191
      s = *(list___0.data + this_spline);
#line 193
      if (pointcount == 0) {
        {
#line 194
        *(pointx + pointcount) = (int )((double )s.v[0].x * 15.0 + 300.0);
#line 195
        *(pointy + pointcount) = (int )((double )((at_real )ury - s.v[0].y) * 15.0 + 300.0);
#line 196
        *(contrl + pointcount) = (at_real )0.0;
#line 197
        fig_addtobbox(s.v[0].x, s.v[0].y);
#line 198
        pointcount ++;
        }
      }
#line 202
      if ((unsigned int )s.degree == 1U) {
        {
#line 204
        *(pointx + pointcount) = (int )((double )s.v[3].x * 15.0 + 300.0);
#line 205
        *(pointy + pointcount) = (int )((double )((at_real )ury - s.v[3].y) * 15.0 + 300.0);
#line 206
        *(contrl + pointcount) = (at_real )0.0;
#line 207
        fig_addtobbox(s.v[0].x, s.v[0].y);
#line 208
        pointcount ++;
        }
      } else {
#line 214
        temp = (at_real )0.2;
        {
#line 214
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 214
          if (! (temp < (at_real )0.9)) {
#line 214
            goto while_break___7;
          }
          {
#line 215
          tmp___8 = bezpnt___0(temp, s.v[0].x, s.v[1].x, s.v[2].x, s.v[3].x);
#line 215
          *(pointx + pointcount) = (int )((double )tmp___8 * 15.0 + 300.0);
#line 218
          tmp___9 = bezpnt___0(temp, s.v[0].y, s.v[1].y, s.v[2].y, s.v[3].y);
#line 218
          *(pointy + pointcount) = (int )((double )((at_real )ury - tmp___9) * 15.0 + 300.0);
#line 221
          *(contrl + pointcount) = (at_real )(- 1.0);
#line 222
          pointcount ++;
#line 214
          temp += (at_real )0.2;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 224
        *(pointx + pointcount) = (int )((double )s.v[3].x * 15.0 + 300.0);
#line 225
        *(pointy + pointcount) = (int )((double )((at_real )ury - s.v[3].y) * 15.0 + 300.0);
#line 226
        *(contrl + pointcount) = (at_real )0.0;
#line 227
        fig_addtobbox(s.v[0].x, s.v[0].y);
#line 228
        fig_addtobbox(s.v[1].x, s.v[1].y);
#line 229
        fig_addtobbox(s.v[2].x, s.v[2].y);
#line 230
        fig_addtobbox(s.v[3].x, s.v[3].y);
#line 231
        pointcount ++;
#line 232
        is_spline = 1;
        }
      }
#line 188
      this_spline ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 235
    if (shape.centerline) {
#line 236
      fig_fill = -1;
#line 236
      fig_width = 1;
#line 236
      fig_spline_close = 4;
    } else {
#line 239
      fig_fill = 20;
#line 239
      fig_width = 0;
#line 239
      fig_spline_close = 5;
    }
#line 241
    if (is_spline != 0) {
      {
#line 242
      fig_new_depth();
#line 243
      fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"3 %d 0 %d %d %d %d 0 %d 0.00 0 0 0 %d\n",
              fig_spline_close, fig_width, fig_colour, fig_colour, fig_depth, fig_fill,
              pointcount);
#line 247
      j = 0;
#line 248
      i = 0;
      }
      {
#line 248
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 248
        if (! (i < pointcount)) {
#line 248
          goto while_break___8;
        }
#line 249
        j ++;
#line 249
        if (j == 1) {
          {
#line 249
          fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\t");
          }
        }
        {
#line 250
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d %d ",
                *(pointx + i), *(pointy + i));
        }
#line 251
        if (j == 8) {
          {
#line 251
          fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\n");
#line 251
          j = 0;
          }
        }
#line 248
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 253
      if (j != 0) {
        {
#line 253
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\n");
        }
      }
#line 254
      j = 0;
#line 256
      i = 0;
      {
#line 256
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 256
        if (! (i < pointcount)) {
#line 256
          goto while_break___9;
        }
#line 257
        j ++;
#line 257
        if (j == 1) {
          {
#line 257
          fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\t");
          }
        }
        {
#line 258
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%f ",
                (double )*(contrl + i));
        }
#line 259
        if (j == 8) {
          {
#line 259
          fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\n");
#line 259
          j = 0;
          }
        }
#line 256
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 261
      if (j != 0) {
        {
#line 261
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\n");
        }
      }
    } else {
#line 264
      fig_subt = 3;
#line 265
      if (pointcount == 2) {
#line 266
        if (*(pointx + 0) == *(pointx + 1)) {
#line 266
          if (*(pointy + 0) == *(pointy + 1)) {
            {
#line 268
            fig_new_depth();
#line 269
            fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"2 1 0 1 %d %d %d 0 -1 0.000 0 0 -1 0 0 1\n",
                    fig_colour, fig_colour, fig_depth);
#line 271
            fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\t%d %d\n",
                    *(pointx + 0), *(pointy + 0));
            }
          } else {
            {
#line 274
            fig_new_depth();
#line 275
            fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"2 1 0 1 %d %d %d 0 -1 0.000 0 0 -1 0 0 2\n",
                    fig_colour, fig_colour, fig_depth);
#line 277
            fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\t%d %d %d %d\n",
                    *(pointx + 0), *(pointy + 0), *(pointx + 1), *(pointy + 1));
            }
          }
        } else {
          {
#line 274
          fig_new_depth();
#line 275
          fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"2 1 0 1 %d %d %d 0 -1 0.000 0 0 -1 0 0 2\n",
                  fig_colour, fig_colour, fig_depth);
#line 277
          fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\t%d %d %d %d\n",
                  *(pointx + 0), *(pointy + 0), *(pointx + 1), *(pointy + 1));
          }
        }
      } else
#line 281
      if (pointcount == 3) {
#line 281
        if (*(pointx + 0) == *(pointx + 2)) {
#line 281
          if (*(pointy + 0) == *(pointy + 2)) {
            {
#line 284
            fig_new_depth();
#line 285
            fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"2 1 0 1 %d %d %d 0 -1 0.000 0 0 -1 0 0 2\n",
                    fig_colour, fig_colour, fig_depth);
#line 287
            fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\t%d %d %d %d\n",
                    *(pointx + 0), *(pointy + 0), *(pointx + 1), *(pointy + 1));
            }
          } else {
#line 281
            goto _L___1;
          }
        } else {
#line 281
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 290
        if (*(pointx + 0) != *(pointx + (pointcount - 1))) {
#line 290
          goto _L;
        } else
#line 290
        if (*(pointy + 0) != *(pointy + (pointcount - 1))) {
          _L: /* CIL Label */ 
#line 292
          if (shape.centerline) {
#line 293
            fig_subt = 1;
          } else {
#line 296
            *(pointx + pointcount) = *(pointx + 0);
#line 297
            *(pointy + pointcount) = *(pointy + 0);
#line 298
            pointcount ++;
          }
        }
        {
#line 301
        fig_new_depth();
#line 302
        fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"2 %d 0 %d %d %d %d 0 %d 0.00 0 0 0 0 0 %d\n",
                fig_subt, fig_width, fig_colour, fig_colour, fig_depth, fig_fill,
                pointcount);
#line 305
        j = 0;
#line 306
        i = 0;
        }
        {
#line 306
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 306
          if (! (i < pointcount)) {
#line 306
            goto while_break___10;
          }
#line 307
          j ++;
#line 307
          if (j == 1) {
            {
#line 307
            fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\t");
            }
          }
          {
#line 308
          fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d %d ",
                  *(pointx + i), *(pointy + i));
          }
#line 309
          if (j == 8) {
            {
#line 309
            fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\n");
#line 309
            j = 0;
            }
          }
#line 306
          i ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 311
        if (j != 0) {
          {
#line 311
          fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\n");
          }
        }
      }
    }
#line 316
    if (fig_depth < 0) {
#line 316
      fig_depth = 0;
    }
    {
#line 317
    free((void *)pointx);
#line 318
    free((void *)pointy);
#line 319
    free((void *)contrl);
#line 167
    this_list ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 321
  free((void *)spline_colours);
  }
#line 322
  return;
}
}
#line 325 "output-fig.c"
int output_fig_writer(FILE *file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) 
{ 
  at_exception_type exp ;
  at_exception_type tmp ;

  {
  {
#line 332
  tmp = at_exception_new(msg_func, msg_data);
#line 332
  exp = tmp;
#line 334
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"#FIG 3.2\nLandscape\nCenter\nInches\nLetter\n100.00\nSingle\n-2\n1200 2\n");
#line 337
  out_fig_splines(file, shape, llx, lly, urx, ury, & exp);
  }
#line 338
  return (0);
}
}
#line 348 "output-fig.c"
static void fig_col_init(void) 
{ 
  int i ;

  {
#line 352
  i = 0;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (i < 544)) {
#line 352
      goto while_break;
    }
#line 352
    fig_hash[i].colour = 0U;
#line 352
    fig_colour_map[i].alternate = 0;
#line 352
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  fig_hash[0].colour = 0U;
#line 357
  fig_colour_map[0].r = (unsigned char)0;
#line 358
  fig_colour_map[0].g = (unsigned char)0;
#line 359
  fig_colour_map[0].b = (unsigned char)0;
#line 361
  fig_hash[543].colour = 7U;
#line 362
  fig_colour_map[7].r = (unsigned char)255;
#line 363
  fig_colour_map[7].g = (unsigned char)255;
#line 364
  fig_colour_map[7].b = (unsigned char)255;
#line 366
  fig_hash[255].colour = 4U;
#line 367
  fig_colour_map[4].r = (unsigned char)255;
#line 368
  fig_colour_map[4].g = (unsigned char)0;
#line 369
  fig_colour_map[4].b = (unsigned char)0;
#line 371
  fig_hash[161].colour = 2U;
#line 372
  fig_colour_map[2].r = (unsigned char)0;
#line 373
  fig_colour_map[2].g = (unsigned char)255;
#line 374
  fig_colour_map[2].b = (unsigned char)0;
#line 376
  fig_hash[127].colour = 1U;
#line 377
  fig_colour_map[1].r = (unsigned char)0;
#line 378
  fig_colour_map[1].g = (unsigned char)0;
#line 379
  fig_colour_map[1].b = (unsigned char)255;
#line 381
  fig_hash[198].colour = 3U;
#line 382
  fig_colour_map[3].r = (unsigned char)0;
#line 383
  fig_colour_map[3].g = (unsigned char)255;
#line 384
  fig_colour_map[3].b = (unsigned char)255;
#line 386
  fig_hash[382].colour = 5U;
#line 387
  fig_colour_map[5].r = (unsigned char)255;
#line 388
  fig_colour_map[5].g = (unsigned char)0;
#line 389
  fig_colour_map[5].b = (unsigned char)255;
#line 391
  fig_hash[416].colour = 6U;
#line 392
  fig_colour_map[6].r = (unsigned char)255;
#line 393
  fig_colour_map[6].g = (unsigned char)255;
#line 394
  fig_colour_map[6].b = (unsigned char)0;
#line 395
  return;
}
}
#line 402 "output-fig.c"
static int get_fig_colour(color_type this_colour , at_exception_type *exp ) 
{ 
  int hash ;
  int i ;
  int this_ind ;
  int tmp ;

  {
#line 406
  hash = (((int )this_colour.r & 255) + ((int )this_colour.g & 161)) + ((int )this_colour.b & 127);
#line 409
  if (hash == 0) {
#line 409
    if ((int )fig_colour_map[0].r == (int )this_colour.r) {
#line 409
      if ((int )fig_colour_map[0].g == (int )this_colour.g) {
#line 409
        if ((int )fig_colour_map[0].b == (int )this_colour.b) {
#line 410
          return (0);
        }
      }
    }
  }
#line 412
  if (fig_hash[hash].colour == 0U) {
#line 413
    fig_hash[hash].colour = (unsigned int )LAST_FIG_COLOUR;
#line 414
    fig_colour_map[LAST_FIG_COLOUR].r = this_colour.r;
#line 415
    fig_colour_map[LAST_FIG_COLOUR].g = this_colour.g;
#line 416
    fig_colour_map[LAST_FIG_COLOUR].b = this_colour.b;
#line 417
    LAST_FIG_COLOUR ++;
#line 418
    if (LAST_FIG_COLOUR >= 543) {
      {
#line 419
      while (1) {
        while_continue: /* CIL Label */ ;
#line 419
        if (at_log_file) {
          {
#line 419
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Output-Fig: too many colours: %d",
                  LAST_FIG_COLOUR);
          }
        }
#line 419
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 420
      at_exception_fatal(exp, (at_string const   )"Output-Fig: too many colours");
      }
#line 421
      return (0);
    }
#line 423
    return ((int )fig_hash[hash].colour);
  } else {
#line 425
    i = 0;
#line 426
    this_ind = (int )fig_hash[hash].colour;
    figcolloop: 
#line 429
    if ((int )fig_colour_map[this_ind].r == (int )this_colour.r) {
#line 429
      if ((int )fig_colour_map[this_ind].g == (int )this_colour.g) {
#line 429
        if ((int )fig_colour_map[this_ind].b == (int )this_colour.b) {
#line 430
          return (this_ind);
        }
      }
    }
#line 433
    if (fig_colour_map[this_ind].alternate == 0) {
#line 434
      fig_colour_map[this_ind].alternate = LAST_FIG_COLOUR;
#line 435
      fig_colour_map[LAST_FIG_COLOUR].r = this_colour.r;
#line 436
      fig_colour_map[LAST_FIG_COLOUR].g = this_colour.g;
#line 437
      fig_colour_map[LAST_FIG_COLOUR].b = this_colour.b;
#line 438
      LAST_FIG_COLOUR ++;
#line 439
      if (LAST_FIG_COLOUR >= 543) {
        {
#line 440
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 440
          if (at_log_file) {
            {
#line 440
            fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Output-Fig: too many colours: %d",
                    LAST_FIG_COLOUR);
            }
          }
#line 440
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 441
        at_exception_fatal(exp, (at_string const   )"Output-Fig: too many colours");
        }
#line 442
        return (0);
      }
#line 444
      return (fig_colour_map[this_ind].alternate);
    }
#line 447
    this_ind = fig_colour_map[this_ind].alternate;
#line 449
    tmp = i;
#line 449
    i ++;
#line 449
    if (tmp > 543) {
      {
#line 450
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 450
        if (at_log_file) {
          {
#line 450
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Output-Fig: too many colours (loop): %d",
                  i);
          }
        }
#line 450
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 451
      at_exception_fatal(exp, (at_string const   )"Output-Fig: too many colours (loop)");
      }
#line 452
      return (0);
    }
#line 455
    goto figcolloop;
  }
}
}
#line 25 "output-er.h"
int output_er_writer(FILE *file , at_string name , int llx , int lly , int urx , int ury ,
                     at_output_opts_type *opts , at_spline_list_array_type shape ,
                     void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                     at_address msg_data ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 142
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 31 "output-er.c"
static at_string now(void) ;
#line 38 "output-er.c"
static int output_er_header(FILE *er_file , at_string name , int llx , int lly , int urx ,
                            int ury ) 
{ 
  at_string time___0 ;

  {
  {
#line 43
  time___0 = now();
#line 43
  fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"#Elastic Reality Shape File\n\n#Date: %s\n\n",
          time___0);
#line 46
  free((void *)time___0);
#line 48
  fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"ImageSize = {\n\tWidth = %d\n\tHeight = %d\n}\n\n",
          urx - llx, ury - lly);
  }
#line 51
  return (0);
}
}
#line 56 "output-er.c"
static void out_splines___3(FILE *er_file , at_spline_list_array_type shape , unsigned int width ,
                            unsigned int height , at_output_opts_type *opts ) 
{ 
  unsigned int this_list ;
  unsigned int corresp_pt ;
  double x0 ;
  double y0 ;
  double x1 ;
  double y1 ;
  double x2 ;
  double y2 ;
  double corresp_length ;
  unsigned int this_spline ;
  spline_type prev ;
  spline_list_type list ;
  unsigned int length ;
  unsigned int out_length ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  spline_type s ;
  at_real w ;
  spline_type s___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 64
  this_list = 0U;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (this_list < shape.length)) {
#line 64
      goto while_break;
    }
#line 70
    list = *(shape.data + this_list);
#line 71
    length = list.length;
#line 72
    if (list.open) {
#line 72
      tmp = length + 1U;
    } else
#line 72
    if (length == 1U) {
#line 72
      tmp = length + 1U;
    } else {
#line 72
      tmp = length;
    }
    {
#line 72
    out_length = tmp;
#line 74
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"Shape = {\n");
#line 75
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t#Shape Number %d\n",
            this_list + 1U);
#line 76
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tGroup = Default\n");
#line 77
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tType = Source\n");
#line 78
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tRoll = A\n");
#line 79
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tOpaque = True\n");
#line 80
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tLocked = False\n");
#line 81
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tWarp = True\n");
#line 82
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tCookieCut = True\n");
#line 83
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tColorCorrect = True\n");
#line 84
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tPrecision = 10\n");
    }
#line 85
    if (list.open) {
#line 85
      tmp___0 = "False";
    } else {
#line 85
      tmp___0 = "True";
    }
    {
#line 85
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tClosed = %s\n",
            tmp___0);
#line 86
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tTween = Linear\n");
#line 87
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tBPoints = %d\n",
            out_length);
#line 88
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tCPoints = %d\n",
            4);
#line 89
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tFormKey = {\n");
#line 90
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\tFrame = 1\n");
#line 91
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\tPointList = {\n");
#line 93
    prev = *(list.data + (list.length - 1U));
    }
#line 94
    if (list.open) {
#line 95
      prev.degree = (polynomial_degree )-1;
    } else
#line 94
    if (length == 1U) {
#line 95
      prev.degree = (polynomial_degree )-1;
    }
#line 97
    this_spline = 0U;
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      if (! (this_spline < length)) {
#line 97
        goto while_break___0;
      }
#line 99
      s = *(list.data + this_spline);
#line 101
      if ((unsigned int )prev.degree == 4294967295U) {
#line 102
        x0 = (double )s.v[0].x;
#line 102
        y0 = (double )s.v[0].y;
      } else
#line 103
      if ((unsigned int )prev.degree == 3U) {
#line 104
        x0 = (double )prev.v[2].x;
#line 104
        y0 = (double )prev.v[2].y;
      } else {
#line 106
        x0 = (double )s.v[0].x;
#line 106
        y0 = (double )s.v[0].y;
      }
#line 108
      x1 = (double )s.v[0].x;
#line 108
      y1 = (double )s.v[0].y;
#line 110
      if ((unsigned int )s.degree == 3U) {
#line 111
        x2 = (double )s.v[1].x;
#line 111
        y2 = (double )s.v[1].y;
      } else {
#line 113
        x2 = (double )s.v[0].x;
#line 113
        y2 = (double )s.v[0].y;
      }
      {
#line 115
      fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\t\t(%f, %f), (%f, %f), (%f, %f),\n",
              x0 / (double )width, y0 / (double )height, x1 / (double )width, y1 / (double )height,
              x2 / (double )width, y2 / (double )height);
#line 119
      prev = s;
#line 97
      this_spline ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 122
    if (list.open) {
#line 122
      goto _L;
    } else
#line 122
    if (length == 1U) {
      _L: /* CIL Label */ 
      {
#line 124
      x0 = (double )prev.v[2].x;
#line 124
      y0 = (double )prev.v[2].y;
#line 125
      x1 = (double )prev.v[3].x;
#line 125
      x2 = x1;
#line 125
      y1 = (double )prev.v[3].y;
#line 125
      y2 = y1;
#line 127
      fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\t\t(%f, %f), (%f, %f), (%f, %f),\n",
              x0 / (double )width, y0 / (double )height, x1 / (double )width, y1 / (double )height,
              x2 / (double )width, y2 / (double )height);
      }
    }
    {
#line 133
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\t}\n\n\t}\n\n");
    }
#line 135
    if (shape.centerline) {
#line 135
      if (shape.preserve_width) {
        {
#line 137
        w = (at_real )1.0 / shape.width_weight_factor;
#line 139
        fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tWeightKey = {\n");
#line 140
        fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\tFrame = 1\n");
#line 141
        fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\tPointList = {\n");
#line 142
        prev = *(list.data + (list.length - 1U));
        }
#line 143
        if (list.open) {
#line 144
          prev.degree = (polynomial_degree )-1;
        } else
#line 143
        if (length == 1U) {
#line 144
          prev.degree = (polynomial_degree )-1;
        }
#line 145
        this_spline = 0U;
        {
#line 145
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 145
          if (! (this_spline < length)) {
#line 145
            goto while_break___1;
          }
#line 147
          s___0 = *(list.data + this_spline);
#line 149
          if ((unsigned int )prev.degree == 4294967295U) {
#line 150
            x0 = (double )s___0.v[0].z;
          } else
#line 151
          if ((unsigned int )prev.degree == 3U) {
#line 152
            x0 = (double )prev.v[2].z;
          } else {
#line 154
            x0 = (double )s___0.v[0].z;
          }
#line 156
          x1 = (double )s___0.v[0].z;
#line 158
          if ((unsigned int )s___0.degree == 3U) {
#line 159
            x2 = (double )s___0.v[1].z;
          } else {
#line 161
            x2 = (double )s___0.v[0].z;
          }
          {
#line 163
          fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\t\t%g, %g, %g,\n",
                  x0 * (double )w, x1 * (double )w, x2 * (double )w);
#line 165
          prev = s___0;
#line 145
          this_spline ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 167
        if (list.open) {
          {
#line 169
          x0 = (double )prev.v[2].z;
#line 170
          x1 = (double )prev.v[3].z;
#line 170
          x2 = x1;
#line 171
          fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\t\t%g, %g, %g,\n",
                  x0 * (double )w, x1 * (double )w, x2 * (double )w);
          }
        } else
#line 167
        if (length == 1U) {
          {
#line 169
          x0 = (double )prev.v[2].z;
#line 170
          x1 = (double )prev.v[3].z;
#line 170
          x2 = x1;
#line 171
          fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\t\t%g, %g, %g,\n",
                  x0 * (double )w, x1 * (double )w, x2 * (double )w);
          }
        }
        {
#line 174
        fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\t}\n\n\t}\n\n");
        }
      }
    }
    {
#line 177
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\tCorrKey = {\n");
#line 178
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\tFrame = 1\n");
#line 179
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\tPointList = {\n");
#line 180
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\t\t\t0");
    }
#line 181
    if (list.open) {
#line 181
      tmp___1 = 1.0;
    } else {
#line 181
      tmp___1 = 2.0;
    }
#line 181
    corresp_length = (double )out_length - tmp___1;
#line 182
    corresp_pt = 1U;
    {
#line 182
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 182
      if (! (corresp_pt < 4U)) {
#line 182
        goto while_break___2;
      }
#line 184
      if (list.open) {
#line 184
        tmp___2 = 1.0;
      } else {
#line 184
        tmp___2 = 0.0;
      }
      {
#line 184
      fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)", %g",
              (corresp_length * (double )corresp_pt) / ((double )4 - tmp___2));
#line 182
      corresp_pt ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 188
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"\n\t\t}\n\n\t}\n\n");
#line 191
    fprintf((FILE */* __restrict  */)er_file, (char const   */* __restrict  */)"}\n\n");
#line 64
    this_list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  return;
}
}
#line 195 "output-er.c"
int output_er_writer(FILE *file , at_string name , int llx , int lly , int urx , int ury ,
                     at_output_opts_type *opts , at_spline_list_array_type shape ,
                     void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                     at_address msg_data ) 
{ 
  int result ;
  unsigned int width ;
  unsigned int height ;

  {
  {
#line 205
  result = output_er_header(file, name, llx, lly, urx, ury);
  }
#line 206
  if (result != 0) {
#line 206
    return (result);
  }
  {
#line 208
  width = (unsigned int )(urx - llx);
#line 209
  height = (unsigned int )(ury - lly);
#line 210
  out_splines___3(file, shape, width, height, opts);
  }
#line 212
  return (0);
}
}
#line 215 "output-er.c"
static at_string now(void) 
{ 
  at_string time_string ;
  time_t t ;
  time_t tmp ;
  void *tmp___0 ;
  char *tmp___2 ;

  {
  {
#line 219
  tmp = time((time_t *)0);
#line 219
  t = tmp;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 221
    tmp___0 = malloc((size_t )26);
#line 221
    time_string = (at_string )tmp___0;
    }
#line 221
    if (! time_string) {
      {
#line 221
      __assert_fail("time_string", "output-er.c", 221U, "now");
      }
    }
#line 221
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  tmp___2 = ctime((time_t const   *)(& t));
#line 222
  strcpy((char */* __restrict  */)time_string, (char const   */* __restrict  */)tmp___2);
#line 223
  *(time_string + 24) = (char)0;
  }
#line 225
  return (time_string);
}
}
#line 25 "output-eps.h"
int output_eps_writer(FILE *ps_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) ;
#line 33 "output-eps.c"
static at_string now___0(void) ;
#line 96 "output-eps.c"
static int output_eps_header(FILE *ps_file , at_string name , int llx , int lly ,
                             int urx , int ury ) 
{ 
  at_string time___0 ;
  char const   *tmp ;

  {
  {
#line 101
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%!PS-Adobe-3.0 EPSF-3.0");
#line 102
  tmp = at_version((at_bool )1);
#line 102
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%%%%Creator: Adobe Illustrator by %s\n",
          tmp);
#line 103
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%%%%Title: %s\n",
          name);
#line 104
  time___0 = now___0();
#line 104
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%%%%CreationDate: %s\n",
          time___0);
#line 105
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%%%%BoundingBox: %d %d %d %d\n",
          llx, lly, urx, ury);
#line 106
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%DocumentData: Clean7Bit");
#line 107
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%EndComments");
#line 109
  free((void *)time___0);
#line 119
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%BeginProlog");
#line 120
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/bd { bind def } bind def");
#line 121
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/incompound false def");
#line 122
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/m { moveto } bd");
#line 123
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/l { lineto } bd");
#line 124
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/c { curveto } bd");
#line 125
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/F { incompound not {fill} if } bd");
#line 126
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/f { closepath F } bd");
#line 127
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/S { stroke } bd");
#line 128
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/*u { /incompound true def } bd");
#line 129
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/*U { /incompound false def f} bd");
#line 130
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/k { setcmykcolor } bd");
#line 131
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "/K { k } bd");
#line 132
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%EndProlog");
#line 133
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%BeginSetup");
#line 134
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%EndSetup");
  }
#line 136
  return (0);
}
}
#line 142 "output-eps.c"
static void out_splines___4(FILE *ps_file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  spline_list_type list ;
  color_type last_color ;
  unsigned int this_spline ;
  int c ;
  int m ;
  int y ;
  int k ;
  spline_type first ;
  char const   *tmp ;
  char const   *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char const   *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  spline_type s ;
  char const   *tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  char const   *tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  char const   *tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  char const   *tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  char const   *tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___169 ;
  int tmp___170 ;
  int tmp___171 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___174 ;
  char const   *tmp___187 ;
  int tmp___188 ;
  int tmp___189 ;
  int tmp___194 ;
  int tmp___195 ;
  int tmp___196 ;
  int tmp___197 ;
  int tmp___198 ;
  int tmp___199 ;
  char const   *tmp___212 ;
  int tmp___213 ;
  int tmp___214 ;
  int tmp___219 ;
  int tmp___220 ;
  int tmp___221 ;
  int tmp___222 ;
  int tmp___223 ;
  int tmp___224 ;
  char const   *tmp___237 ;
  int tmp___238 ;
  int tmp___239 ;
  int tmp___244 ;
  int tmp___245 ;
  int tmp___246 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  char const   *tmp___250 ;

  {
#line 148
  last_color.r = (unsigned char)0;
#line 148
  last_color.g = (unsigned char)0;
#line 148
  last_color.b = (unsigned char)0;
#line 150
  this_list = 0U;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (this_list < shape.length)) {
#line 150
      goto while_break;
    }
#line 157
    list = *(shape.data + this_list);
#line 158
    first = *(list.data + 0);
#line 160
    if (this_list == 0U) {
#line 160
      goto _L___1;
    } else
#line 160
    if ((int )list.color.r == (int )last_color.r) {
#line 160
      if ((int )list.color.g == (int )last_color.g) {
#line 160
        if (! ((int )list.color.b == (int )last_color.b)) {
#line 160
          goto _L___1;
        }
      } else {
#line 160
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 162
      if (this_list > 0U) {
        {
#line 163
        fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
                "*U");
        }
      }
#line 164
      k = 255 - (int )list.color.r;
#line 164
      c = k;
#line 165
      m = 255 - (int )list.color.g;
#line 166
      if (m < k) {
#line 167
        k = m;
      }
#line 168
      y = 255 - (int )list.color.b;
#line 169
      if (y < k) {
#line 170
        k = y;
      }
#line 171
      c -= k;
#line 172
      m -= k;
#line 173
      y -= k;
#line 175
      if (shape.centerline) {
#line 175
        tmp = "K";
      } else
#line 175
      if (list.open) {
#line 175
        tmp = "K";
      } else {
#line 175
        tmp = "k";
      }
      {
#line 175
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%.3f %.3f %.3f %.3f %s\n",
              (double )c / 255.0, (double )m / 255.0, (double )y / 255.0, (double )k / 255.0,
              tmp);
#line 178
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
              "*u");
#line 179
      last_color = list.color;
      }
    }
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      if ((at_real )6.0 * first.v[0].x > (at_real )0) {
#line 181
        tmp___14 = 1;
      } else {
#line 181
        if ((at_real )6.0 * first.v[0].x < (at_real )0) {
#line 181
          tmp___13 = -1;
        } else {
#line 181
          tmp___13 = 0;
        }
#line 181
        tmp___14 = tmp___13;
      }
#line 181
      first.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].x)) + .5 * (double )tmp___14)) / (at_real )6.0;
#line 181
      if ((at_real )6.0 * first.v[0].x > (at_real )0) {
#line 181
        tmp___24 = 1;
      } else {
#line 181
        if ((at_real )6.0 * first.v[0].x < (at_real )0) {
#line 181
          tmp___23 = -1;
        } else {
#line 181
          tmp___23 = 0;
        }
#line 181
        tmp___24 = tmp___23;
      }
#line 181
      first.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].x)) + .5 * (double )tmp___24)) / (at_real )6.0;
#line 181
      if (first.v[0].x > (at_real )0) {
#line 181
        tmp___22 = 1;
      } else {
#line 181
        if ((at_real )6.0 * first.v[0].x > (at_real )0) {
#line 181
          tmp___21 = 1;
        } else {
#line 181
          if ((at_real )6.0 * first.v[0].x < (at_real )0) {
#line 181
            tmp___20 = -1;
          } else {
#line 181
            tmp___20 = 0;
          }
#line 181
          tmp___21 = tmp___20;
        }
#line 181
        first.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].x)) + .5 * (double )tmp___21)) / (at_real )6.0;
#line 181
        if (first.v[0].x < (at_real )0) {
#line 181
          tmp___19 = -1;
        } else {
#line 181
          tmp___19 = 0;
        }
#line 181
        tmp___22 = tmp___19;
      }
#line 181
      if (first.v[0].x == (at_real )((int )((double )((int )first.v[0].x) + .5 * (double )tmp___22))) {
#line 181
        tmp___12 = "%.0f ";
      } else {
#line 181
        tmp___12 = "%.3f ";
      }
      {
#line 181
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___12,
              (double )first.v[0].x);
      }
#line 181
      if ((at_real )6.0 * first.v[0].y > (at_real )0) {
#line 181
        tmp___39 = 1;
      } else {
#line 181
        if ((at_real )6.0 * first.v[0].y < (at_real )0) {
#line 181
          tmp___38 = -1;
        } else {
#line 181
          tmp___38 = 0;
        }
#line 181
        tmp___39 = tmp___38;
      }
#line 181
      first.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].y)) + .5 * (double )tmp___39)) / (at_real )6.0;
#line 181
      if ((at_real )6.0 * first.v[0].y > (at_real )0) {
#line 181
        tmp___49 = 1;
      } else {
#line 181
        if ((at_real )6.0 * first.v[0].y < (at_real )0) {
#line 181
          tmp___48 = -1;
        } else {
#line 181
          tmp___48 = 0;
        }
#line 181
        tmp___49 = tmp___48;
      }
#line 181
      first.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].y)) + .5 * (double )tmp___49)) / (at_real )6.0;
#line 181
      if (first.v[0].y > (at_real )0) {
#line 181
        tmp___47 = 1;
      } else {
#line 181
        if ((at_real )6.0 * first.v[0].y > (at_real )0) {
#line 181
          tmp___46 = 1;
        } else {
#line 181
          if ((at_real )6.0 * first.v[0].y < (at_real )0) {
#line 181
            tmp___45 = -1;
          } else {
#line 181
            tmp___45 = 0;
          }
#line 181
          tmp___46 = tmp___45;
        }
#line 181
        first.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].y)) + .5 * (double )tmp___46)) / (at_real )6.0;
#line 181
        if (first.v[0].y < (at_real )0) {
#line 181
          tmp___44 = -1;
        } else {
#line 181
          tmp___44 = 0;
        }
#line 181
        tmp___47 = tmp___44;
      }
#line 181
      if (first.v[0].y == (at_real )((int )((double )((int )first.v[0].y) + .5 * (double )tmp___47))) {
#line 181
        tmp___37 = "%.0f ";
      } else {
#line 181
        tmp___37 = "%.3f ";
      }
      {
#line 181
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___37,
              (double )first.v[0].y);
#line 181
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
              "m\n");
      }
#line 181
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 183
    this_spline = 0U;
    {
#line 183
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 183
      if (! (this_spline < list.length)) {
#line 183
        goto while_break___1;
      }
#line 186
      s = *(list.data + this_spline);
#line 188
      if ((unsigned int )s.degree == 1U) {
        {
#line 189
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 189
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 189
            tmp___64 = 1;
          } else {
#line 189
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 189
              tmp___63 = -1;
            } else {
#line 189
              tmp___63 = 0;
            }
#line 189
            tmp___64 = tmp___63;
          }
#line 189
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___64)) / (at_real )6.0;
#line 189
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 189
            tmp___74 = 1;
          } else {
#line 189
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 189
              tmp___73 = -1;
            } else {
#line 189
              tmp___73 = 0;
            }
#line 189
            tmp___74 = tmp___73;
          }
#line 189
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___74)) / (at_real )6.0;
#line 189
          if (s.v[3].x > (at_real )0) {
#line 189
            tmp___72 = 1;
          } else {
#line 189
            if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 189
              tmp___71 = 1;
            } else {
#line 189
              if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 189
                tmp___70 = -1;
              } else {
#line 189
                tmp___70 = 0;
              }
#line 189
              tmp___71 = tmp___70;
            }
#line 189
            s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___71)) / (at_real )6.0;
#line 189
            if (s.v[3].x < (at_real )0) {
#line 189
              tmp___69 = -1;
            } else {
#line 189
              tmp___69 = 0;
            }
#line 189
            tmp___72 = tmp___69;
          }
#line 189
          if (s.v[3].x == (at_real )((int )((double )((int )s.v[3].x) + .5 * (double )tmp___72))) {
#line 189
            tmp___62 = "%.0f ";
          } else {
#line 189
            tmp___62 = "%.3f ";
          }
          {
#line 189
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___62,
                  (double )s.v[3].x);
          }
#line 189
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 189
            tmp___89 = 1;
          } else {
#line 189
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 189
              tmp___88 = -1;
            } else {
#line 189
              tmp___88 = 0;
            }
#line 189
            tmp___89 = tmp___88;
          }
#line 189
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___89)) / (at_real )6.0;
#line 189
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 189
            tmp___99 = 1;
          } else {
#line 189
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 189
              tmp___98 = -1;
            } else {
#line 189
              tmp___98 = 0;
            }
#line 189
            tmp___99 = tmp___98;
          }
#line 189
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___99)) / (at_real )6.0;
#line 189
          if (s.v[3].y > (at_real )0) {
#line 189
            tmp___97 = 1;
          } else {
#line 189
            if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 189
              tmp___96 = 1;
            } else {
#line 189
              if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 189
                tmp___95 = -1;
              } else {
#line 189
                tmp___95 = 0;
              }
#line 189
              tmp___96 = tmp___95;
            }
#line 189
            s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___96)) / (at_real )6.0;
#line 189
            if (s.v[3].y < (at_real )0) {
#line 189
              tmp___94 = -1;
            } else {
#line 189
              tmp___94 = 0;
            }
#line 189
            tmp___97 = tmp___94;
          }
#line 189
          if (s.v[3].y == (at_real )((int )((double )((int )s.v[3].y) + .5 * (double )tmp___97))) {
#line 189
            tmp___87 = "%.0f ";
          } else {
#line 189
            tmp___87 = "%.3f ";
          }
          {
#line 189
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___87,
                  (double )s.v[3].y);
#line 189
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
                  "l\n");
          }
#line 189
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 191
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 191
          if ((at_real )6.0 * s.v[1].x > (at_real )0) {
#line 191
            tmp___114 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[1].x < (at_real )0) {
#line 191
              tmp___113 = -1;
            } else {
#line 191
              tmp___113 = 0;
            }
#line 191
            tmp___114 = tmp___113;
          }
#line 191
          s.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].x)) + .5 * (double )tmp___114)) / (at_real )6.0;
#line 191
          if ((at_real )6.0 * s.v[1].x > (at_real )0) {
#line 191
            tmp___124 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[1].x < (at_real )0) {
#line 191
              tmp___123 = -1;
            } else {
#line 191
              tmp___123 = 0;
            }
#line 191
            tmp___124 = tmp___123;
          }
#line 191
          s.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].x)) + .5 * (double )tmp___124)) / (at_real )6.0;
#line 191
          if (s.v[1].x > (at_real )0) {
#line 191
            tmp___122 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[1].x > (at_real )0) {
#line 191
              tmp___121 = 1;
            } else {
#line 191
              if ((at_real )6.0 * s.v[1].x < (at_real )0) {
#line 191
                tmp___120 = -1;
              } else {
#line 191
                tmp___120 = 0;
              }
#line 191
              tmp___121 = tmp___120;
            }
#line 191
            s.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].x)) + .5 * (double )tmp___121)) / (at_real )6.0;
#line 191
            if (s.v[1].x < (at_real )0) {
#line 191
              tmp___119 = -1;
            } else {
#line 191
              tmp___119 = 0;
            }
#line 191
            tmp___122 = tmp___119;
          }
#line 191
          if (s.v[1].x == (at_real )((int )((double )((int )s.v[1].x) + .5 * (double )tmp___122))) {
#line 191
            tmp___112 = "%.0f ";
          } else {
#line 191
            tmp___112 = "%.3f ";
          }
          {
#line 191
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___112,
                  (double )s.v[1].x);
          }
#line 191
          if ((at_real )6.0 * s.v[1].y > (at_real )0) {
#line 191
            tmp___139 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[1].y < (at_real )0) {
#line 191
              tmp___138 = -1;
            } else {
#line 191
              tmp___138 = 0;
            }
#line 191
            tmp___139 = tmp___138;
          }
#line 191
          s.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].y)) + .5 * (double )tmp___139)) / (at_real )6.0;
#line 191
          if ((at_real )6.0 * s.v[1].y > (at_real )0) {
#line 191
            tmp___149 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[1].y < (at_real )0) {
#line 191
              tmp___148 = -1;
            } else {
#line 191
              tmp___148 = 0;
            }
#line 191
            tmp___149 = tmp___148;
          }
#line 191
          s.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].y)) + .5 * (double )tmp___149)) / (at_real )6.0;
#line 191
          if (s.v[1].y > (at_real )0) {
#line 191
            tmp___147 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[1].y > (at_real )0) {
#line 191
              tmp___146 = 1;
            } else {
#line 191
              if ((at_real )6.0 * s.v[1].y < (at_real )0) {
#line 191
                tmp___145 = -1;
              } else {
#line 191
                tmp___145 = 0;
              }
#line 191
              tmp___146 = tmp___145;
            }
#line 191
            s.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].y)) + .5 * (double )tmp___146)) / (at_real )6.0;
#line 191
            if (s.v[1].y < (at_real )0) {
#line 191
              tmp___144 = -1;
            } else {
#line 191
              tmp___144 = 0;
            }
#line 191
            tmp___147 = tmp___144;
          }
#line 191
          if (s.v[1].y == (at_real )((int )((double )((int )s.v[1].y) + .5 * (double )tmp___147))) {
#line 191
            tmp___137 = "%.0f ";
          } else {
#line 191
            tmp___137 = "%.3f ";
          }
          {
#line 191
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___137,
                  (double )s.v[1].y);
#line 191
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
                  " ");
          }
#line 191
          if ((at_real )6.0 * s.v[2].x > (at_real )0) {
#line 191
            tmp___164 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[2].x < (at_real )0) {
#line 191
              tmp___163 = -1;
            } else {
#line 191
              tmp___163 = 0;
            }
#line 191
            tmp___164 = tmp___163;
          }
#line 191
          s.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].x)) + .5 * (double )tmp___164)) / (at_real )6.0;
#line 191
          if ((at_real )6.0 * s.v[2].x > (at_real )0) {
#line 191
            tmp___174 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[2].x < (at_real )0) {
#line 191
              tmp___173 = -1;
            } else {
#line 191
              tmp___173 = 0;
            }
#line 191
            tmp___174 = tmp___173;
          }
#line 191
          s.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].x)) + .5 * (double )tmp___174)) / (at_real )6.0;
#line 191
          if (s.v[2].x > (at_real )0) {
#line 191
            tmp___172 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[2].x > (at_real )0) {
#line 191
              tmp___171 = 1;
            } else {
#line 191
              if ((at_real )6.0 * s.v[2].x < (at_real )0) {
#line 191
                tmp___170 = -1;
              } else {
#line 191
                tmp___170 = 0;
              }
#line 191
              tmp___171 = tmp___170;
            }
#line 191
            s.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].x)) + .5 * (double )tmp___171)) / (at_real )6.0;
#line 191
            if (s.v[2].x < (at_real )0) {
#line 191
              tmp___169 = -1;
            } else {
#line 191
              tmp___169 = 0;
            }
#line 191
            tmp___172 = tmp___169;
          }
#line 191
          if (s.v[2].x == (at_real )((int )((double )((int )s.v[2].x) + .5 * (double )tmp___172))) {
#line 191
            tmp___162 = "%.0f ";
          } else {
#line 191
            tmp___162 = "%.3f ";
          }
          {
#line 191
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___162,
                  (double )s.v[2].x);
          }
#line 191
          if ((at_real )6.0 * s.v[2].y > (at_real )0) {
#line 191
            tmp___189 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[2].y < (at_real )0) {
#line 191
              tmp___188 = -1;
            } else {
#line 191
              tmp___188 = 0;
            }
#line 191
            tmp___189 = tmp___188;
          }
#line 191
          s.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].y)) + .5 * (double )tmp___189)) / (at_real )6.0;
#line 191
          if ((at_real )6.0 * s.v[2].y > (at_real )0) {
#line 191
            tmp___199 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[2].y < (at_real )0) {
#line 191
              tmp___198 = -1;
            } else {
#line 191
              tmp___198 = 0;
            }
#line 191
            tmp___199 = tmp___198;
          }
#line 191
          s.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].y)) + .5 * (double )tmp___199)) / (at_real )6.0;
#line 191
          if (s.v[2].y > (at_real )0) {
#line 191
            tmp___197 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[2].y > (at_real )0) {
#line 191
              tmp___196 = 1;
            } else {
#line 191
              if ((at_real )6.0 * s.v[2].y < (at_real )0) {
#line 191
                tmp___195 = -1;
              } else {
#line 191
                tmp___195 = 0;
              }
#line 191
              tmp___196 = tmp___195;
            }
#line 191
            s.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].y)) + .5 * (double )tmp___196)) / (at_real )6.0;
#line 191
            if (s.v[2].y < (at_real )0) {
#line 191
              tmp___194 = -1;
            } else {
#line 191
              tmp___194 = 0;
            }
#line 191
            tmp___197 = tmp___194;
          }
#line 191
          if (s.v[2].y == (at_real )((int )((double )((int )s.v[2].y) + .5 * (double )tmp___197))) {
#line 191
            tmp___187 = "%.0f ";
          } else {
#line 191
            tmp___187 = "%.3f ";
          }
          {
#line 191
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___187,
                  (double )s.v[2].y);
#line 191
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
                  " ");
          }
#line 191
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 191
            tmp___214 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 191
              tmp___213 = -1;
            } else {
#line 191
              tmp___213 = 0;
            }
#line 191
            tmp___214 = tmp___213;
          }
#line 191
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___214)) / (at_real )6.0;
#line 191
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 191
            tmp___224 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 191
              tmp___223 = -1;
            } else {
#line 191
              tmp___223 = 0;
            }
#line 191
            tmp___224 = tmp___223;
          }
#line 191
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___224)) / (at_real )6.0;
#line 191
          if (s.v[3].x > (at_real )0) {
#line 191
            tmp___222 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 191
              tmp___221 = 1;
            } else {
#line 191
              if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 191
                tmp___220 = -1;
              } else {
#line 191
                tmp___220 = 0;
              }
#line 191
              tmp___221 = tmp___220;
            }
#line 191
            s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___221)) / (at_real )6.0;
#line 191
            if (s.v[3].x < (at_real )0) {
#line 191
              tmp___219 = -1;
            } else {
#line 191
              tmp___219 = 0;
            }
#line 191
            tmp___222 = tmp___219;
          }
#line 191
          if (s.v[3].x == (at_real )((int )((double )((int )s.v[3].x) + .5 * (double )tmp___222))) {
#line 191
            tmp___212 = "%.0f ";
          } else {
#line 191
            tmp___212 = "%.3f ";
          }
          {
#line 191
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___212,
                  (double )s.v[3].x);
          }
#line 191
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 191
            tmp___239 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 191
              tmp___238 = -1;
            } else {
#line 191
              tmp___238 = 0;
            }
#line 191
            tmp___239 = tmp___238;
          }
#line 191
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___239)) / (at_real )6.0;
#line 191
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 191
            tmp___249 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 191
              tmp___248 = -1;
            } else {
#line 191
              tmp___248 = 0;
            }
#line 191
            tmp___249 = tmp___248;
          }
#line 191
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___249)) / (at_real )6.0;
#line 191
          if (s.v[3].y > (at_real )0) {
#line 191
            tmp___247 = 1;
          } else {
#line 191
            if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 191
              tmp___246 = 1;
            } else {
#line 191
              if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 191
                tmp___245 = -1;
              } else {
#line 191
                tmp___245 = 0;
              }
#line 191
              tmp___246 = tmp___245;
            }
#line 191
            s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___246)) / (at_real )6.0;
#line 191
            if (s.v[3].y < (at_real )0) {
#line 191
              tmp___244 = -1;
            } else {
#line 191
              tmp___244 = 0;
            }
#line 191
            tmp___247 = tmp___244;
          }
#line 191
          if (s.v[3].y == (at_real )((int )((double )((int )s.v[3].y) + .5 * (double )tmp___247))) {
#line 191
            tmp___237 = "%.0f ";
          } else {
#line 191
            tmp___237 = "%.3f ";
          }
          {
#line 191
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)tmp___237,
                  (double )s.v[3].y);
#line 191
          fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s",
                  " c \n");
          }
#line 191
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 183
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 196
    if (shape.length > 0U) {
#line 197
      if (shape.centerline) {
#line 197
        tmp___250 = "S";
      } else
#line 197
      if (list.open) {
#line 197
        tmp___250 = "S";
      } else {
#line 197
        tmp___250 = "f";
      }
      {
#line 197
      fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
              tmp___250);
      }
    }
#line 150
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  if (shape.length > 0U) {
    {
#line 200
    fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
            "*U");
    }
  }
#line 201
  return;
}
}
#line 204 "output-eps.c"
int output_eps_writer(FILE *ps_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) 
{ 
  int result ;

  {
  {
#line 213
  result = output_eps_header(ps_file, name, llx, lly, urx, ury);
  }
#line 214
  if (result != 0) {
#line 215
    return (result);
  }
  {
#line 217
  out_splines___4(ps_file, shape);
#line 219
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%Trailer");
#line 220
  fprintf((FILE */* __restrict  */)ps_file, (char const   */* __restrict  */)"%s\n",
          "%%EOF");
  }
#line 221
  return (0);
}
}
#line 225 "output-eps.c"
static at_string now___0(void) 
{ 
  at_string time_string ;
  time_t t ;
  time_t tmp ;
  void *tmp___0 ;
  char *tmp___2 ;

  {
  {
#line 229
  tmp = time((time_t *)0);
#line 229
  t = tmp;
  }
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 231
    tmp___0 = malloc((size_t )26);
#line 231
    time_string = (at_string )tmp___0;
    }
#line 231
    if (! time_string) {
      {
#line 231
      __assert_fail("time_string", "output-eps.c", 231U, "now");
      }
    }
#line 231
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 232
  tmp___2 = ctime((time_t const   *)(& t));
#line 232
  strcpy((char */* __restrict  */)time_string, (char const   */* __restrict  */)tmp___2);
#line 233
  *(time_string + 24) = (char)0;
  }
#line 235
  return (time_string);
}
}
#line 26 "output-epd.h"
int output_epd_writer(FILE *epd_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) ;
#line 34 "output-epd.c"
static at_string now___1(void) ;
#line 94 "output-epd.c"
static int output_epd_header(FILE *epd_file , at_string name , int llx , int lly ,
                             int urx , int ury ) 
{ 
  at_string time___0 ;
  char const   *tmp ;

  {
  {
#line 99
  fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%s\n",
          "%EPD-1.0");
#line 100
  tmp = at_version((at_bool )1);
#line 100
  fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%% Created by %s\n",
          tmp);
#line 101
  fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%% Title: %s\n",
          name);
#line 102
  time___0 = now___1();
#line 102
  fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%% CreationDate: %s\n",
          time___0);
#line 103
  fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%%BBox(%d,%d,%d,%d)\n",
          llx, lly, urx, ury);
#line 105
  free((void *)time___0);
  }
#line 107
  return (0);
}
}
#line 113 "output-epd.c"
static void out_splines___5(FILE *epd_file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  spline_list_type list ;
  color_type last_color ;
  unsigned int this_spline ;
  spline_type first ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  spline_type s ;
  char const   *tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  char const   *tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  char const   *tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  char const   *tmp___138 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  char const   *tmp___163 ;
  int tmp___164 ;
  int tmp___165 ;
  int tmp___170 ;
  int tmp___171 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___174 ;
  int tmp___175 ;
  char const   *tmp___188 ;
  int tmp___189 ;
  int tmp___190 ;
  int tmp___195 ;
  int tmp___196 ;
  int tmp___197 ;
  int tmp___198 ;
  int tmp___199 ;
  int tmp___200 ;
  char const   *tmp___213 ;
  int tmp___214 ;
  int tmp___215 ;
  int tmp___220 ;
  int tmp___221 ;
  int tmp___222 ;
  int tmp___223 ;
  int tmp___224 ;
  int tmp___225 ;
  char const   *tmp___238 ;
  int tmp___239 ;
  int tmp___240 ;
  int tmp___245 ;
  int tmp___246 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  char const   *tmp___251 ;

  {
#line 118
  last_color.r = (unsigned char)0;
#line 118
  last_color.g = (unsigned char)0;
#line 118
  last_color.b = (unsigned char)0;
#line 120
  this_list = 0U;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (this_list < shape.length)) {
#line 120
      goto while_break;
    }
#line 126
    list = *(shape.data + this_list);
#line 127
    first = *(list.data + 0);
#line 129
    if (this_list == 0U) {
#line 129
      goto _L___1;
    } else
#line 129
    if ((int )list.color.r == (int )last_color.r) {
#line 129
      if ((int )list.color.g == (int )last_color.g) {
#line 129
        if (! ((int )list.color.b == (int )last_color.b)) {
#line 129
          goto _L___1;
        }
      } else {
#line 129
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 131
      if (this_list > 0U) {
#line 133
        if (shape.centerline) {
#line 133
          tmp = "S";
        } else
#line 133
        if (list.open) {
#line 133
          tmp = "S";
        } else {
#line 133
          tmp = "f";
        }
        {
#line 133
        fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%s\n",
                tmp);
#line 134
        fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%s\n",
                "h");
        }
      }
#line 136
      if (shape.centerline) {
#line 136
        tmp___0 = "RG";
      } else
#line 136
      if (list.open) {
#line 136
        tmp___0 = "RG";
      } else {
#line 136
        tmp___0 = "rg";
      }
      {
#line 136
      fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%.3f %.3f %.3f %s\n",
              (double )list.color.r / 255.0, (double )list.color.g / 255.0, (double )list.color.b / 255.0,
              tmp___0);
#line 139
      last_color = list.color;
      }
    }
    {
#line 141
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 141
      if ((at_real )6.0 * first.v[0].x > (at_real )0) {
#line 141
        tmp___15 = 1;
      } else {
#line 141
        if ((at_real )6.0 * first.v[0].x < (at_real )0) {
#line 141
          tmp___14 = -1;
        } else {
#line 141
          tmp___14 = 0;
        }
#line 141
        tmp___15 = tmp___14;
      }
#line 141
      first.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].x)) + .5 * (double )tmp___15)) / (at_real )6.0;
#line 141
      if ((at_real )6.0 * first.v[0].x > (at_real )0) {
#line 141
        tmp___25 = 1;
      } else {
#line 141
        if ((at_real )6.0 * first.v[0].x < (at_real )0) {
#line 141
          tmp___24 = -1;
        } else {
#line 141
          tmp___24 = 0;
        }
#line 141
        tmp___25 = tmp___24;
      }
#line 141
      first.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].x)) + .5 * (double )tmp___25)) / (at_real )6.0;
#line 141
      if (first.v[0].x > (at_real )0) {
#line 141
        tmp___23 = 1;
      } else {
#line 141
        if ((at_real )6.0 * first.v[0].x > (at_real )0) {
#line 141
          tmp___22 = 1;
        } else {
#line 141
          if ((at_real )6.0 * first.v[0].x < (at_real )0) {
#line 141
            tmp___21 = -1;
          } else {
#line 141
            tmp___21 = 0;
          }
#line 141
          tmp___22 = tmp___21;
        }
#line 141
        first.v[0].x = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].x)) + .5 * (double )tmp___22)) / (at_real )6.0;
#line 141
        if (first.v[0].x < (at_real )0) {
#line 141
          tmp___20 = -1;
        } else {
#line 141
          tmp___20 = 0;
        }
#line 141
        tmp___23 = tmp___20;
      }
#line 141
      if (first.v[0].x == (at_real )((int )((double )((int )first.v[0].x) + .5 * (double )tmp___23))) {
#line 141
        tmp___13 = "%.0f ";
      } else {
#line 141
        tmp___13 = "%.3f ";
      }
      {
#line 141
      fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)tmp___13,
              (double )first.v[0].x);
      }
#line 141
      if ((at_real )6.0 * first.v[0].y > (at_real )0) {
#line 141
        tmp___40 = 1;
      } else {
#line 141
        if ((at_real )6.0 * first.v[0].y < (at_real )0) {
#line 141
          tmp___39 = -1;
        } else {
#line 141
          tmp___39 = 0;
        }
#line 141
        tmp___40 = tmp___39;
      }
#line 141
      first.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].y)) + .5 * (double )tmp___40)) / (at_real )6.0;
#line 141
      if ((at_real )6.0 * first.v[0].y > (at_real )0) {
#line 141
        tmp___50 = 1;
      } else {
#line 141
        if ((at_real )6.0 * first.v[0].y < (at_real )0) {
#line 141
          tmp___49 = -1;
        } else {
#line 141
          tmp___49 = 0;
        }
#line 141
        tmp___50 = tmp___49;
      }
#line 141
      first.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].y)) + .5 * (double )tmp___50)) / (at_real )6.0;
#line 141
      if (first.v[0].y > (at_real )0) {
#line 141
        tmp___48 = 1;
      } else {
#line 141
        if ((at_real )6.0 * first.v[0].y > (at_real )0) {
#line 141
          tmp___47 = 1;
        } else {
#line 141
          if ((at_real )6.0 * first.v[0].y < (at_real )0) {
#line 141
            tmp___46 = -1;
          } else {
#line 141
            tmp___46 = 0;
          }
#line 141
          tmp___47 = tmp___46;
        }
#line 141
        first.v[0].y = (at_real )((int )((double )((int )((at_real )6.0 * first.v[0].y)) + .5 * (double )tmp___47)) / (at_real )6.0;
#line 141
        if (first.v[0].y < (at_real )0) {
#line 141
          tmp___45 = -1;
        } else {
#line 141
          tmp___45 = 0;
        }
#line 141
        tmp___48 = tmp___45;
      }
#line 141
      if (first.v[0].y == (at_real )((int )((double )((int )first.v[0].y) + .5 * (double )tmp___48))) {
#line 141
        tmp___38 = "%.0f ";
      } else {
#line 141
        tmp___38 = "%.3f ";
      }
      {
#line 141
      fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)tmp___38,
              (double )first.v[0].y);
#line 141
      fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%s",
              "m\n");
      }
#line 141
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 143
    this_spline = 0U;
    {
#line 143
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 143
      if (! (this_spline < list.length)) {
#line 143
        goto while_break___1;
      }
#line 146
      s = *(list.data + this_spline);
#line 148
      if ((unsigned int )s.degree == 1U) {
        {
#line 149
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 149
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 149
            tmp___65 = 1;
          } else {
#line 149
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 149
              tmp___64 = -1;
            } else {
#line 149
              tmp___64 = 0;
            }
#line 149
            tmp___65 = tmp___64;
          }
#line 149
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___65)) / (at_real )6.0;
#line 149
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 149
            tmp___75 = 1;
          } else {
#line 149
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 149
              tmp___74 = -1;
            } else {
#line 149
              tmp___74 = 0;
            }
#line 149
            tmp___75 = tmp___74;
          }
#line 149
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___75)) / (at_real )6.0;
#line 149
          if (s.v[3].x > (at_real )0) {
#line 149
            tmp___73 = 1;
          } else {
#line 149
            if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 149
              tmp___72 = 1;
            } else {
#line 149
              if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 149
                tmp___71 = -1;
              } else {
#line 149
                tmp___71 = 0;
              }
#line 149
              tmp___72 = tmp___71;
            }
#line 149
            s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___72)) / (at_real )6.0;
#line 149
            if (s.v[3].x < (at_real )0) {
#line 149
              tmp___70 = -1;
            } else {
#line 149
              tmp___70 = 0;
            }
#line 149
            tmp___73 = tmp___70;
          }
#line 149
          if (s.v[3].x == (at_real )((int )((double )((int )s.v[3].x) + .5 * (double )tmp___73))) {
#line 149
            tmp___63 = "%.0f ";
          } else {
#line 149
            tmp___63 = "%.3f ";
          }
          {
#line 149
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)tmp___63,
                  (double )s.v[3].x);
          }
#line 149
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 149
            tmp___90 = 1;
          } else {
#line 149
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 149
              tmp___89 = -1;
            } else {
#line 149
              tmp___89 = 0;
            }
#line 149
            tmp___90 = tmp___89;
          }
#line 149
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___90)) / (at_real )6.0;
#line 149
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 149
            tmp___100 = 1;
          } else {
#line 149
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 149
              tmp___99 = -1;
            } else {
#line 149
              tmp___99 = 0;
            }
#line 149
            tmp___100 = tmp___99;
          }
#line 149
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___100)) / (at_real )6.0;
#line 149
          if (s.v[3].y > (at_real )0) {
#line 149
            tmp___98 = 1;
          } else {
#line 149
            if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 149
              tmp___97 = 1;
            } else {
#line 149
              if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 149
                tmp___96 = -1;
              } else {
#line 149
                tmp___96 = 0;
              }
#line 149
              tmp___97 = tmp___96;
            }
#line 149
            s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___97)) / (at_real )6.0;
#line 149
            if (s.v[3].y < (at_real )0) {
#line 149
              tmp___95 = -1;
            } else {
#line 149
              tmp___95 = 0;
            }
#line 149
            tmp___98 = tmp___95;
          }
#line 149
          if (s.v[3].y == (at_real )((int )((double )((int )s.v[3].y) + .5 * (double )tmp___98))) {
#line 149
            tmp___88 = "%.0f ";
          } else {
#line 149
            tmp___88 = "%.3f ";
          }
          {
#line 149
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)tmp___88,
                  (double )s.v[3].y);
#line 149
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%s",
                  "l\n");
          }
#line 149
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 151
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 151
          if ((at_real )6.0 * s.v[1].x > (at_real )0) {
#line 151
            tmp___115 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[1].x < (at_real )0) {
#line 151
              tmp___114 = -1;
            } else {
#line 151
              tmp___114 = 0;
            }
#line 151
            tmp___115 = tmp___114;
          }
#line 151
          s.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].x)) + .5 * (double )tmp___115)) / (at_real )6.0;
#line 151
          if ((at_real )6.0 * s.v[1].x > (at_real )0) {
#line 151
            tmp___125 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[1].x < (at_real )0) {
#line 151
              tmp___124 = -1;
            } else {
#line 151
              tmp___124 = 0;
            }
#line 151
            tmp___125 = tmp___124;
          }
#line 151
          s.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].x)) + .5 * (double )tmp___125)) / (at_real )6.0;
#line 151
          if (s.v[1].x > (at_real )0) {
#line 151
            tmp___123 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[1].x > (at_real )0) {
#line 151
              tmp___122 = 1;
            } else {
#line 151
              if ((at_real )6.0 * s.v[1].x < (at_real )0) {
#line 151
                tmp___121 = -1;
              } else {
#line 151
                tmp___121 = 0;
              }
#line 151
              tmp___122 = tmp___121;
            }
#line 151
            s.v[1].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].x)) + .5 * (double )tmp___122)) / (at_real )6.0;
#line 151
            if (s.v[1].x < (at_real )0) {
#line 151
              tmp___120 = -1;
            } else {
#line 151
              tmp___120 = 0;
            }
#line 151
            tmp___123 = tmp___120;
          }
#line 151
          if (s.v[1].x == (at_real )((int )((double )((int )s.v[1].x) + .5 * (double )tmp___123))) {
#line 151
            tmp___113 = "%.0f ";
          } else {
#line 151
            tmp___113 = "%.3f ";
          }
          {
#line 151
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)tmp___113,
                  (double )s.v[1].x);
          }
#line 151
          if ((at_real )6.0 * s.v[1].y > (at_real )0) {
#line 151
            tmp___140 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[1].y < (at_real )0) {
#line 151
              tmp___139 = -1;
            } else {
#line 151
              tmp___139 = 0;
            }
#line 151
            tmp___140 = tmp___139;
          }
#line 151
          s.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].y)) + .5 * (double )tmp___140)) / (at_real )6.0;
#line 151
          if ((at_real )6.0 * s.v[1].y > (at_real )0) {
#line 151
            tmp___150 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[1].y < (at_real )0) {
#line 151
              tmp___149 = -1;
            } else {
#line 151
              tmp___149 = 0;
            }
#line 151
            tmp___150 = tmp___149;
          }
#line 151
          s.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].y)) + .5 * (double )tmp___150)) / (at_real )6.0;
#line 151
          if (s.v[1].y > (at_real )0) {
#line 151
            tmp___148 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[1].y > (at_real )0) {
#line 151
              tmp___147 = 1;
            } else {
#line 151
              if ((at_real )6.0 * s.v[1].y < (at_real )0) {
#line 151
                tmp___146 = -1;
              } else {
#line 151
                tmp___146 = 0;
              }
#line 151
              tmp___147 = tmp___146;
            }
#line 151
            s.v[1].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[1].y)) + .5 * (double )tmp___147)) / (at_real )6.0;
#line 151
            if (s.v[1].y < (at_real )0) {
#line 151
              tmp___145 = -1;
            } else {
#line 151
              tmp___145 = 0;
            }
#line 151
            tmp___148 = tmp___145;
          }
#line 151
          if (s.v[1].y == (at_real )((int )((double )((int )s.v[1].y) + .5 * (double )tmp___148))) {
#line 151
            tmp___138 = "%.0f ";
          } else {
#line 151
            tmp___138 = "%.3f ";
          }
          {
#line 151
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)tmp___138,
                  (double )s.v[1].y);
#line 151
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%s",
                  " ");
          }
#line 151
          if ((at_real )6.0 * s.v[2].x > (at_real )0) {
#line 151
            tmp___165 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[2].x < (at_real )0) {
#line 151
              tmp___164 = -1;
            } else {
#line 151
              tmp___164 = 0;
            }
#line 151
            tmp___165 = tmp___164;
          }
#line 151
          s.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].x)) + .5 * (double )tmp___165)) / (at_real )6.0;
#line 151
          if ((at_real )6.0 * s.v[2].x > (at_real )0) {
#line 151
            tmp___175 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[2].x < (at_real )0) {
#line 151
              tmp___174 = -1;
            } else {
#line 151
              tmp___174 = 0;
            }
#line 151
            tmp___175 = tmp___174;
          }
#line 151
          s.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].x)) + .5 * (double )tmp___175)) / (at_real )6.0;
#line 151
          if (s.v[2].x > (at_real )0) {
#line 151
            tmp___173 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[2].x > (at_real )0) {
#line 151
              tmp___172 = 1;
            } else {
#line 151
              if ((at_real )6.0 * s.v[2].x < (at_real )0) {
#line 151
                tmp___171 = -1;
              } else {
#line 151
                tmp___171 = 0;
              }
#line 151
              tmp___172 = tmp___171;
            }
#line 151
            s.v[2].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].x)) + .5 * (double )tmp___172)) / (at_real )6.0;
#line 151
            if (s.v[2].x < (at_real )0) {
#line 151
              tmp___170 = -1;
            } else {
#line 151
              tmp___170 = 0;
            }
#line 151
            tmp___173 = tmp___170;
          }
#line 151
          if (s.v[2].x == (at_real )((int )((double )((int )s.v[2].x) + .5 * (double )tmp___173))) {
#line 151
            tmp___163 = "%.0f ";
          } else {
#line 151
            tmp___163 = "%.3f ";
          }
          {
#line 151
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)tmp___163,
                  (double )s.v[2].x);
          }
#line 151
          if ((at_real )6.0 * s.v[2].y > (at_real )0) {
#line 151
            tmp___190 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[2].y < (at_real )0) {
#line 151
              tmp___189 = -1;
            } else {
#line 151
              tmp___189 = 0;
            }
#line 151
            tmp___190 = tmp___189;
          }
#line 151
          s.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].y)) + .5 * (double )tmp___190)) / (at_real )6.0;
#line 151
          if ((at_real )6.0 * s.v[2].y > (at_real )0) {
#line 151
            tmp___200 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[2].y < (at_real )0) {
#line 151
              tmp___199 = -1;
            } else {
#line 151
              tmp___199 = 0;
            }
#line 151
            tmp___200 = tmp___199;
          }
#line 151
          s.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].y)) + .5 * (double )tmp___200)) / (at_real )6.0;
#line 151
          if (s.v[2].y > (at_real )0) {
#line 151
            tmp___198 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[2].y > (at_real )0) {
#line 151
              tmp___197 = 1;
            } else {
#line 151
              if ((at_real )6.0 * s.v[2].y < (at_real )0) {
#line 151
                tmp___196 = -1;
              } else {
#line 151
                tmp___196 = 0;
              }
#line 151
              tmp___197 = tmp___196;
            }
#line 151
            s.v[2].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[2].y)) + .5 * (double )tmp___197)) / (at_real )6.0;
#line 151
            if (s.v[2].y < (at_real )0) {
#line 151
              tmp___195 = -1;
            } else {
#line 151
              tmp___195 = 0;
            }
#line 151
            tmp___198 = tmp___195;
          }
#line 151
          if (s.v[2].y == (at_real )((int )((double )((int )s.v[2].y) + .5 * (double )tmp___198))) {
#line 151
            tmp___188 = "%.0f ";
          } else {
#line 151
            tmp___188 = "%.3f ";
          }
          {
#line 151
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)tmp___188,
                  (double )s.v[2].y);
#line 151
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%s",
                  " ");
          }
#line 151
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 151
            tmp___215 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 151
              tmp___214 = -1;
            } else {
#line 151
              tmp___214 = 0;
            }
#line 151
            tmp___215 = tmp___214;
          }
#line 151
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___215)) / (at_real )6.0;
#line 151
          if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 151
            tmp___225 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 151
              tmp___224 = -1;
            } else {
#line 151
              tmp___224 = 0;
            }
#line 151
            tmp___225 = tmp___224;
          }
#line 151
          s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___225)) / (at_real )6.0;
#line 151
          if (s.v[3].x > (at_real )0) {
#line 151
            tmp___223 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[3].x > (at_real )0) {
#line 151
              tmp___222 = 1;
            } else {
#line 151
              if ((at_real )6.0 * s.v[3].x < (at_real )0) {
#line 151
                tmp___221 = -1;
              } else {
#line 151
                tmp___221 = 0;
              }
#line 151
              tmp___222 = tmp___221;
            }
#line 151
            s.v[3].x = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].x)) + .5 * (double )tmp___222)) / (at_real )6.0;
#line 151
            if (s.v[3].x < (at_real )0) {
#line 151
              tmp___220 = -1;
            } else {
#line 151
              tmp___220 = 0;
            }
#line 151
            tmp___223 = tmp___220;
          }
#line 151
          if (s.v[3].x == (at_real )((int )((double )((int )s.v[3].x) + .5 * (double )tmp___223))) {
#line 151
            tmp___213 = "%.0f ";
          } else {
#line 151
            tmp___213 = "%.3f ";
          }
          {
#line 151
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)tmp___213,
                  (double )s.v[3].x);
          }
#line 151
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 151
            tmp___240 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 151
              tmp___239 = -1;
            } else {
#line 151
              tmp___239 = 0;
            }
#line 151
            tmp___240 = tmp___239;
          }
#line 151
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___240)) / (at_real )6.0;
#line 151
          if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 151
            tmp___250 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 151
              tmp___249 = -1;
            } else {
#line 151
              tmp___249 = 0;
            }
#line 151
            tmp___250 = tmp___249;
          }
#line 151
          s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___250)) / (at_real )6.0;
#line 151
          if (s.v[3].y > (at_real )0) {
#line 151
            tmp___248 = 1;
          } else {
#line 151
            if ((at_real )6.0 * s.v[3].y > (at_real )0) {
#line 151
              tmp___247 = 1;
            } else {
#line 151
              if ((at_real )6.0 * s.v[3].y < (at_real )0) {
#line 151
                tmp___246 = -1;
              } else {
#line 151
                tmp___246 = 0;
              }
#line 151
              tmp___247 = tmp___246;
            }
#line 151
            s.v[3].y = (at_real )((int )((double )((int )((at_real )6.0 * s.v[3].y)) + .5 * (double )tmp___247)) / (at_real )6.0;
#line 151
            if (s.v[3].y < (at_real )0) {
#line 151
              tmp___245 = -1;
            } else {
#line 151
              tmp___245 = 0;
            }
#line 151
            tmp___248 = tmp___245;
          }
#line 151
          if (s.v[3].y == (at_real )((int )((double )((int )s.v[3].y) + .5 * (double )tmp___248))) {
#line 151
            tmp___238 = "%.0f ";
          } else {
#line 151
            tmp___238 = "%.3f ";
          }
          {
#line 151
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)tmp___238,
                  (double )s.v[3].y);
#line 151
          fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%s",
                  " c \n");
          }
#line 151
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 143
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 120
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  if (shape.length > 0U) {
#line 158
    if (shape.centerline) {
#line 158
      tmp___251 = "S";
    } else
#line 158
    if (list.open) {
#line 158
      tmp___251 = "S";
    } else {
#line 158
      tmp___251 = "f";
    }
    {
#line 158
    fprintf((FILE */* __restrict  */)epd_file, (char const   */* __restrict  */)"%s\n",
            tmp___251);
    }
  }
#line 159
  return;
}
}
#line 162 "output-epd.c"
int output_epd_writer(FILE *epd_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) 
{ 
  int result ;

  {
  {
#line 171
  result = output_epd_header(epd_file, name, llx, lly, urx, ury);
  }
#line 172
  if (result != 0) {
#line 173
    return (result);
  }
  {
#line 175
  out_splines___5(epd_file, shape);
  }
#line 177
  return (0);
}
}
#line 181 "output-epd.c"
static at_string now___1(void) 
{ 
  at_string time_string ;
  time_t t ;
  time_t tmp ;
  void *tmp___0 ;
  char *tmp___2 ;

  {
  {
#line 185
  tmp = time((time_t *)0);
#line 185
  t = tmp;
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    tmp___0 = malloc((size_t )26);
#line 187
    time_string = (at_string )tmp___0;
    }
#line 187
    if (! time_string) {
      {
#line 187
      __assert_fail("time_string", "output-epd.c", 187U, "now");
      }
    }
#line 187
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  tmp___2 = ctime((time_t const   *)(& t));
#line 188
  strcpy((char */* __restrict  */)time_string, (char const   */* __restrict  */)tmp___2);
#line 189
  *(time_string + 24) = (char)0;
  }
#line 191
  return (time_string);
}
}
#line 652 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 100 "output-emf.c"
static EMFColorList *color_list  =    (EMFColorList *)((void *)0);
#line 101 "output-emf.c"
static UI32 *color_table  =    (UI32 *)((void *)0);
#line 102 "output-emf.c"
static float y_offset  ;
#line 106 "output-emf.c"
static int SearchColor(EMFColorList *head , UI32 colref ) 
{ 


  {
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 108
      goto while_break;
    }
#line 110
    if (head->colref == colref) {
#line 111
      return (1);
    }
#line 112
    head = head->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return (0);
}
}
#line 117 "output-emf.c"
static void AddColor(EMFColorList **head , UI32 colref ) 
{ 
  EMFColorList *temp ;
  void *tmp ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 121
    tmp = malloc(sizeof(EMFColorList ));
#line 121
    temp = (EMFColorList *)tmp;
    }
#line 121
    if (! temp) {
      {
#line 121
      __assert_fail("temp", "output-emf.c", 121U, "AddColor");
      }
    }
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  temp->colref = colref;
#line 124
  temp->next = *head;
#line 125
  *head = temp;
#line 126
  return;
}
}
#line 128 "output-emf.c"
static void ColorListToColorTable(EMFColorList **head , UI32 **table , int len ) 
{ 
  EMFColorList *temp ;
  int i ;
  void *tmp ;

  {
#line 131
  i = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 133
    tmp = malloc(sizeof(UI32 ) * (unsigned long )len);
#line 133
    *table = (UI32 *)tmp;
    }
#line 133
    if (! *table) {
      {
#line 133
      __assert_fail("*table", "output-emf.c", 133U, "ColorListToColorTable");
      }
    }
#line 133
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! ((unsigned long )*head != (unsigned long )((void *)0))) {
#line 135
      goto while_break___0;
    }
    {
#line 137
    temp = *head;
#line 138
    *head = (*head)->next;
#line 139
    *(*table + i) = temp->colref;
#line 140
    i ++;
#line 141
    free((void *)temp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "output-emf.c"
static int ColorLookUp(UI32 colref , UI32 *table , int len ) 
{ 
  int i ;

  {
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < len)) {
#line 149
      goto while_break;
    }
#line 151
    if (colref == *(table + i)) {
#line 152
      return (i);
    }
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return (0);
}
}
#line 159 "output-emf.c"
static at_bool write32(FILE *fdes , UI32 data ) 
{ 
  size_t count ;
  UI8 outch ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 161
  count = (size_t )0;
#line 164
  outch = (UI8 )(data & 255UL);
#line 165
  tmp = fwrite((void const   */* __restrict  */)(& outch), (size_t )1, (size_t )1,
               (FILE */* __restrict  */)fdes);
#line 165
  count += tmp;
#line 167
  outch = (UI8 )((data >> 8) & 255UL);
#line 168
  tmp___0 = fwrite((void const   */* __restrict  */)(& outch), (size_t )1, (size_t )1,
                   (FILE */* __restrict  */)fdes);
#line 168
  count += tmp___0;
#line 170
  outch = (UI8 )((data >> 16) & 255UL);
#line 171
  tmp___1 = fwrite((void const   */* __restrict  */)(& outch), (size_t )1, (size_t )1,
                   (FILE */* __restrict  */)fdes);
#line 171
  count += tmp___1;
#line 173
  outch = (UI8 )((data >> 24) & 255UL);
#line 174
  tmp___2 = fwrite((void const   */* __restrict  */)(& outch), (size_t )1, (size_t )1,
                   (FILE */* __restrict  */)fdes);
#line 174
  count += tmp___2;
  }
#line 176
  if (count == sizeof(UI32 )) {
#line 176
    tmp___3 = 1;
  } else {
#line 176
    tmp___3 = 0;
  }
#line 176
  return ((at_bool )tmp___3);
}
}
#line 179 "output-emf.c"
static at_bool write16(FILE *fdes , UI16 data ) 
{ 
  size_t count ;
  UI8 outch ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 181
  count = (size_t )0;
#line 184
  outch = (UI8 )((int )data & 255);
#line 185
  tmp = fwrite((void const   */* __restrict  */)(& outch), (size_t )1, (size_t )1,
               (FILE */* __restrict  */)fdes);
#line 185
  count += tmp;
#line 187
  outch = (UI8 )(((int )data >> 8) & 255);
#line 188
  tmp___0 = fwrite((void const   */* __restrict  */)(& outch), (size_t )1, (size_t )1,
                   (FILE */* __restrict  */)fdes);
#line 188
  count += tmp___0;
  }
#line 190
  if (count == sizeof(UI16 )) {
#line 190
    tmp___1 = 1;
  } else {
#line 190
    tmp___1 = 0;
  }
#line 190
  return ((at_bool )tmp___1);
}
}
#line 195 "output-emf.c"
static int WriteMoveTo(FILE *fdes , at_real_coord *pt ) 
{ 
  int recsize ;

  {
#line 197
  recsize = (int )(sizeof(UI32 ) * 4UL);
#line 199
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 201
    write32(fdes, (UI32 )27);
#line 202
    write32(fdes, (UI32 )recsize);
#line 203
    write32(fdes, (UI32 )(pt->x * (at_real )1.0));
#line 204
    write32(fdes, (UI32 )(y_offset - pt->y * (at_real )1.0));
    }
  }
#line 206
  return (recsize);
}
}
#line 209 "output-emf.c"
static int WriteLineTo(FILE *fdes , spline_type *spl ) 
{ 
  int recsize ;

  {
#line 211
  recsize = (int )(sizeof(UI32 ) * 4UL);
#line 213
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 215
    write32(fdes, (UI32 )54);
#line 216
    write32(fdes, (UI32 )recsize);
#line 217
    write32(fdes, (UI32 )(spl->v[3].x * (at_real )1.0));
#line 218
    write32(fdes, (UI32 )(y_offset - spl->v[3].y * (at_real )1.0));
    }
  }
#line 220
  return (recsize);
}
}
#line 249 "output-emf.c"
static int MyWritePolyLineTo(FILE *fdes , spline_type *spl , int nlines ) 
{ 
  int i ;
  int recsize ;
  int tmp ;

  {
  {
#line 252
  tmp = WriteLineTo((FILE *)((void *)0), (spline_type *)((void *)0));
#line 252
  recsize = nlines * tmp;
  }
#line 254
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
#line 256
    i = 0;
    {
#line 256
    while (1) {
      while_continue: /* CIL Label */ ;
#line 256
      if (! (i < nlines)) {
#line 256
        goto while_break;
      }
      {
#line 258
      WriteLineTo(fdes, spl + i);
#line 256
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 261
  return (recsize);
}
}
#line 295 "output-emf.c"
static int WritePolyBezierTo16(FILE *fdes , spline_type *spl , int ncurves ) 
{ 
  int i ;
  int recsize ;

  {
#line 298
  recsize = (int )(sizeof(UI32 ) * 7UL + (sizeof(UI16 ) * (unsigned long )ncurves) * 6UL);
#line 300
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 302
    write32(fdes, (UI32 )88);
#line 303
    write32(fdes, (UI32 )recsize);
#line 304
    write32(fdes, (UI32 )0);
#line 305
    write32(fdes, (UI32 )0);
#line 306
    write32(fdes, (UI32 )4294967295U);
#line 307
    write32(fdes, (UI32 )4294967295U);
#line 308
    write32(fdes, (UI32 )ncurves * 3UL);
#line 310
    i = 0;
    }
    {
#line 310
    while (1) {
      while_continue: /* CIL Label */ ;
#line 310
      if (! (i < ncurves)) {
#line 310
        goto while_break;
      }
      {
#line 312
      write16(fdes, (UI16 )((spl + i)->v[1].x * (at_real )1.0));
#line 313
      write16(fdes, (UI16 )(y_offset - (spl + i)->v[1].y * (at_real )1.0));
#line 314
      write16(fdes, (UI16 )((spl + i)->v[2].x * (at_real )1.0));
#line 315
      write16(fdes, (UI16 )(y_offset - (spl + i)->v[2].y * (at_real )1.0));
#line 316
      write16(fdes, (UI16 )((spl + i)->v[3].x * (at_real )1.0));
#line 317
      write16(fdes, (UI16 )(y_offset - (spl + i)->v[3].y * (at_real )1.0));
#line 310
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 320
  return (recsize);
}
}
#line 324 "output-emf.c"
static int WriteSetPolyFillMode(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 326
  recsize = (int )(sizeof(UI32 ) * 3UL);
#line 328
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 330
    write32(fdes, (UI32 )19);
#line 331
    write32(fdes, (UI32 )recsize);
#line 332
    write32(fdes, (UI32 )1);
    }
  }
#line 334
  return (recsize);
}
}
#line 337 "output-emf.c"
static int WriteBeginPath(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 339
  recsize = (int )(sizeof(UI32 ) * 2UL);
#line 341
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 343
    write32(fdes, (UI32 )59);
#line 344
    write32(fdes, (UI32 )recsize);
    }
  }
#line 346
  return (recsize);
}
}
#line 349 "output-emf.c"
static int WriteEndPath(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 351
  recsize = (int )(sizeof(UI32 ) * 2UL);
#line 353
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 355
    write32(fdes, (UI32 )60);
#line 356
    write32(fdes, (UI32 )recsize);
    }
  }
#line 358
  return (recsize);
}
}
#line 361 "output-emf.c"
static int WriteFillPath(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 363
  recsize = (int )(sizeof(UI32 ) * 6UL);
#line 365
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 367
    write32(fdes, (UI32 )62);
#line 368
    write32(fdes, (UI32 )recsize);
#line 369
    write32(fdes, (UI32 )0);
#line 370
    write32(fdes, (UI32 )0);
#line 371
    write32(fdes, (UI32 )4294967295U);
#line 372
    write32(fdes, (UI32 )4294967295U);
    }
  }
#line 374
  return (recsize);
}
}
#line 377 "output-emf.c"
static int WriteStrokePath(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 379
  recsize = (int )(sizeof(UI32 ) * 6UL);
#line 381
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 383
    write32(fdes, (UI32 )64);
#line 384
    write32(fdes, (UI32 )recsize);
#line 385
    write32(fdes, (UI32 )0);
#line 386
    write32(fdes, (UI32 )0);
#line 387
    write32(fdes, (UI32 )4294967295U);
#line 388
    write32(fdes, (UI32 )4294967295U);
    }
  }
#line 390
  return (recsize);
}
}
#line 425 "output-emf.c"
static int WriteCreateSolidPen(FILE *fdes , int hndNum , UI32 colref ) 
{ 
  int recsize ;

  {
#line 427
  recsize = (int )(sizeof(UI32 ) * 7UL);
#line 429
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 431
    write32(fdes, (UI32 )38);
#line 432
    write32(fdes, (UI32 )recsize);
#line 433
    write32(fdes, (UI32 )hndNum);
#line 434
    write32(fdes, (UI32 )0);
#line 435
    write32(fdes, (UI32 )0);
#line 436
    write32(fdes, (UI32 )0);
#line 437
    write32(fdes, colref);
    }
  }
#line 439
  return (recsize);
}
}
#line 442 "output-emf.c"
static int WriteCreateSolidBrush(FILE *fdes , int hndNum , UI32 colref ) 
{ 
  int recsize ;

  {
#line 444
  recsize = (int )(sizeof(UI32 ) * 6UL);
#line 446
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 448
    write32(fdes, (UI32 )39);
#line 449
    write32(fdes, (UI32 )recsize);
#line 450
    write32(fdes, (UI32 )hndNum);
#line 451
    write32(fdes, (UI32 )0);
#line 452
    write32(fdes, colref);
#line 453
    write32(fdes, (UI32 )0);
    }
  }
#line 456
  return (recsize);
}
}
#line 459 "output-emf.c"
static int WriteSelectObject(FILE *fdes , int hndNum ) 
{ 
  int recsize ;

  {
#line 461
  recsize = (int )(sizeof(UI32 ) * 3UL);
#line 463
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 465
    write32(fdes, (UI32 )37);
#line 466
    write32(fdes, (UI32 )recsize);
#line 467
    write32(fdes, (UI32 )hndNum);
    }
  }
#line 469
  return (recsize);
}
}
#line 472 "output-emf.c"
static int WriteEndOfMetafile(FILE *fdes ) 
{ 
  int recsize ;

  {
#line 474
  recsize = (int )(sizeof(UI32 ) * 5UL);
#line 476
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 478
    write32(fdes, (UI32 )14);
#line 479
    write32(fdes, (UI32 )recsize);
#line 480
    write32(fdes, (UI32 )0);
#line 481
    write32(fdes, (UI32 )recsize - sizeof(UI32 ));
#line 482
    write32(fdes, (UI32 )recsize);
    }
  }
#line 485
  return (recsize);
}
}
#line 488 "output-emf.c"
static int WriteHeader(FILE *fdes , at_string name , int width , int height , int fsize ,
                       int nrec , int nhand ) 
{ 
  int i ;
  int recsize ;
  size_t desclen ;
  char const   *editor ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 492
  tmp = at_version((at_bool )1);
#line 492
  editor = tmp;
#line 494
  tmp___0 = strlen(editor);
#line 494
  tmp___1 = strlen((char const   *)name);
#line 494
  desclen = (tmp___0 + tmp___1) + 3UL;
#line 495
  recsize = (int )((sizeof(UI32 ) * 25UL + desclen * 2UL) + (desclen * 2UL) % 4UL);
  }
#line 497
  if ((unsigned long )fdes != (unsigned long )((void *)0)) {
    {
#line 499
    write32(fdes, (UI32 )1);
#line 500
    write32(fdes, (UI32 )recsize);
#line 502
    write32(fdes, (UI32 )0);
#line 503
    write32(fdes, (UI32 )0);
#line 504
    write32(fdes, (UI32 )width);
#line 505
    write32(fdes, (UI32 )height);
#line 507
    write32(fdes, (UI32 )0);
#line 508
    write32(fdes, (UI32 )0);
#line 509
    write32(fdes, (((UI32 )width * 320UL) * 100UL) / 1280UL);
#line 510
    write32(fdes, (((UI32 )height * 240UL) * 100UL) / 1024UL);
#line 512
    write32(fdes, (UI32 )1179469088);
#line 514
    write32(fdes, (UI32 )65536);
#line 516
    write32(fdes, (UI32 )fsize);
#line 518
    write32(fdes, (UI32 )nrec);
#line 520
    write16(fdes, (UI16 )nhand);
#line 522
    write16(fdes, (UI16 )0);
#line 524
    write32(fdes, desclen);
#line 526
    write32(fdes, (UI32 )100);
#line 528
    write32(fdes, (UI32 )0);
#line 530
    write32(fdes, (UI32 )1280);
#line 531
    write32(fdes, (UI32 )1024);
#line 532
    write32(fdes, (UI32 )320);
#line 533
    write32(fdes, (UI32 )240);
#line 535
    write32(fdes, (UI32 )0);
#line 536
    write32(fdes, (UI32 )0);
#line 537
    write32(fdes, (UI32 )0);
#line 539
    i = 0;
    }
    {
#line 539
    while (1) {
      while_continue: /* CIL Label */ ;
#line 539
      if (! *(editor + i)) {
#line 539
        goto while_break;
      }
      {
#line 541
      write16(fdes, (UI16 )((int const   )*(editor + i) & 127));
#line 539
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 543
    write16(fdes, (UI16 )0);
#line 544
    i = 0;
    }
    {
#line 544
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 544
      if (! *(name + i)) {
#line 544
        goto while_break___0;
      }
      {
#line 546
      write16(fdes, (UI16 )((int )*(name + i) & 127));
#line 544
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 548
    write32(fdes, (UI32 )0);
    }
#line 549
    if ((desclen * 2UL) % 4UL) {
      {
#line 550
      write16(fdes, (UI16 )0);
      }
    }
  }
#line 552
  return (recsize);
}
}
#line 557 "output-emf.c"
static void GetEmfStats(EMFStats *stats , at_string name , at_spline_list_array_type shape ) 
{ 
  unsigned int i ;
  unsigned int j ;
  int ncolors ;
  int ncolorchng ;
  int nrecords ;
  int filesize ;
  UI32 last_color ;
  UI32 curr_color ;
  spline_list_type curr_list ;
  spline_type curr_spline ;
  int last_degree ;
  int nlines ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 560
  ncolors = 0;
#line 561
  ncolorchng = 0;
#line 562
  nrecords = 0;
#line 563
  filesize = 0;
#line 564
  last_color = (UI32 )4294967295U;
#line 571
  i = 0U;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (i < shape.length)) {
#line 571
      goto while_break;
    }
#line 573
    curr_list = *(shape.data + i);
#line 574
    curr_color = (UI32 )((((int )curr_list.color.r & 255) | (((int )curr_list.color.g & 255) << 8)) | (((int )curr_list.color.b & 255) << 16));
#line 575
    if (i == 0U) {
#line 575
      goto _L;
    } else
#line 575
    if (curr_color != last_color) {
      _L: /* CIL Label */ 
      {
#line 577
      ncolorchng ++;
#line 578
      tmp = SearchColor(color_list, curr_color);
      }
#line 578
      if (! tmp) {
        {
#line 580
        ncolors ++;
#line 581
        AddColor(& color_list, curr_color);
        }
      }
      {
#line 583
      last_color = curr_color;
#line 585
      nrecords += 3;
#line 586
      tmp___0 = WriteBeginPath((FILE *)((void *)0));
#line 586
      tmp___1 = WriteEndPath((FILE *)((void *)0));
#line 586
      tmp___2 = WriteFillPath((FILE *)((void *)0));
#line 586
      filesize += (tmp___0 + tmp___1) + tmp___2;
      }
    }
    {
#line 589
    nrecords ++;
#line 590
    tmp___3 = WriteMoveTo((FILE *)((void *)0), (at_real_coord *)((void *)0));
#line 590
    filesize += tmp___3;
#line 592
    j = 0U;
#line 593
    last_degree = -1;
    }
    {
#line 596
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 596
      if (! (j < curr_list.length)) {
#line 596
        goto while_break___0;
      }
#line 598
      nlines = 0;
#line 599
      curr_spline = *(curr_list.data + j);
#line 600
      last_degree = (int )curr_spline.degree;
      {
#line 604
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 604
        if (! (last_degree == (int )curr_spline.degree)) {
#line 604
          goto while_break___1;
        }
#line 606
        nlines ++;
#line 607
        j ++;
#line 608
        if (j >= curr_list.length) {
#line 609
          goto while_break___1;
        }
#line 610
        curr_spline = *(curr_list.data + j);
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 614
      if ((unsigned int )((polynomial_degree )last_degree) == 1U) {
#line 614
        goto case_1;
      }
#line 619
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 616
      nrecords += nlines;
#line 617
      tmp___4 = MyWritePolyLineTo((FILE *)((void *)0), (spline_type *)((void *)0),
                                  nlines);
#line 617
      filesize += tmp___4;
      }
#line 618
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 621
      nrecords ++;
#line 622
      tmp___5 = WritePolyBezierTo16((FILE *)((void *)0), (spline_type *)((void *)0),
                                    nlines);
#line 622
      filesize += tmp___5;
      }
#line 623
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 571
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 629
  nrecords += ncolors * 2;
#line 630
  tmp___6 = WriteCreateSolidPen((FILE *)((void *)0), 0, (UI32 )0);
#line 630
  tmp___7 = WriteCreateSolidBrush((FILE *)((void *)0), 0, (UI32 )0);
#line 630
  filesize += (tmp___6 + tmp___7) * ncolors;
#line 633
  nrecords += ncolorchng * 2;
#line 634
  tmp___8 = WriteSelectObject((FILE *)((void *)0), 0);
#line 634
  filesize += (tmp___8 * ncolorchng) * 2;
#line 636
  nrecords += 2;
#line 637
  tmp___9 = WriteEndOfMetafile((FILE *)((void *)0));
#line 637
  tmp___10 = WriteHeader((FILE *)((void *)0), name, 0, 0, 0, 0, 0);
#line 637
  filesize += tmp___9 + tmp___10;
#line 640
  nrecords ++;
#line 641
  tmp___11 = WriteSetPolyFillMode((FILE *)((void *)0));
#line 641
  filesize += tmp___11;
#line 643
  stats->ncolors = ncolors;
#line 644
  stats->nrecords = nrecords;
#line 645
  stats->filesize = filesize;
#line 648
  ColorListToColorTable(& color_list, & color_table, ncolors);
  }
#line 649
  return;
}
}
#line 654 "output-emf.c"
static void OutputEmf(FILE *fdes , EMFStats *stats , at_string name , int width ,
                      int height , at_spline_list_array_type shape ) 
{ 
  unsigned int i ;
  unsigned int j ;
  int color_index ;
  UI32 last_color ;
  UI32 curr_color ;
  spline_list_type curr_list ;
  spline_type curr_spline ;
  int last_degree ;
  int nlines ;

  {
  {
#line 658
  last_color = (UI32 )4294967295U;
#line 665
  WriteHeader(fdes, name, width, height, stats->filesize, stats->nrecords, stats->ncolors * 2 + 1);
#line 667
  y_offset = (at_real )1.0 * (at_real )height;
#line 669
  i = 0U;
  }
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
#line 669
    if (! (i < (unsigned int )stats->ncolors)) {
#line 669
      goto while_break;
    }
    {
#line 671
    WriteCreateSolidPen(fdes, (int )(i * 2U + 1U), *(color_table + i));
#line 672
    WriteCreateSolidBrush(fdes, (int )(i * 2U + 2U), *(color_table + i));
#line 669
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 676
  WriteSetPolyFillMode(fdes);
#line 679
  i = 0U;
  }
  {
#line 679
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 679
    if (! (i < shape.length)) {
#line 679
      goto while_break___0;
    }
#line 681
    curr_list = *(shape.data + i);
#line 684
    curr_color = (UI32 )((((int )curr_list.color.r & 255) | (((int )curr_list.color.g & 255) << 8)) | (((int )curr_list.color.b & 255) << 16));
#line 685
    if (i == 0U) {
#line 685
      goto _L;
    } else
#line 685
    if (curr_color != last_color) {
      _L: /* CIL Label */ 
#line 687
      if (i > 0U) {
        {
#line 690
        WriteEndPath(fdes);
        }
#line 692
        if (shape.centerline) {
          {
#line 694
          WriteStrokePath(fdes);
          }
        } else {
          {
#line 697
          WriteFillPath(fdes);
          }
        }
      }
      {
#line 700
      WriteBeginPath(fdes);
#line 702
      color_index = ColorLookUp(curr_color, color_table, stats->ncolors);
      }
#line 703
      if (shape.centerline) {
        {
#line 704
        WriteSelectObject(fdes, color_index * 2 + 1);
        }
      } else {
        {
#line 706
        WriteSelectObject(fdes, -2147483640);
        }
      }
      {
#line 707
      WriteSelectObject(fdes, color_index * 2 + 2);
#line 708
      last_color = curr_color;
      }
    }
    {
#line 711
    curr_spline = *(curr_list.data + 0);
#line 712
    WriteMoveTo(fdes, & curr_spline.v[0]);
#line 715
    j = 0U;
    }
    {
#line 718
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 718
      if (! (j < curr_list.length)) {
#line 718
        goto while_break___1;
      }
#line 720
      nlines = 0;
#line 721
      curr_spline = *(curr_list.data + j);
#line 722
      last_degree = (int )curr_spline.degree;
      {
#line 726
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 726
        if (! (last_degree == (int )curr_spline.degree)) {
#line 726
          goto while_break___2;
        }
#line 728
        nlines ++;
#line 729
        j ++;
#line 730
        if (j >= curr_list.length) {
#line 731
          goto while_break___2;
        }
#line 732
        curr_spline = *(curr_list.data + j);
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 736
      if ((unsigned int )((polynomial_degree )last_degree) == 1U) {
#line 736
        goto case_1;
      }
#line 740
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 738
      MyWritePolyLineTo(fdes, curr_list.data + (j - (unsigned int )nlines), nlines);
      }
#line 739
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 742
      WritePolyBezierTo16(fdes, curr_list.data + (j - (unsigned int )nlines), nlines);
      }
#line 743
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 679
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 747
  if (shape.length > 0U) {
    {
#line 750
    WriteEndPath(fdes);
    }
#line 752
    if (shape.centerline) {
      {
#line 754
      WriteStrokePath(fdes);
      }
    } else {
      {
#line 757
      WriteFillPath(fdes);
      }
    }
  }
  {
#line 761
  WriteEndOfMetafile(fdes);
#line 764
  free((void *)color_table);
  }
#line 765
  return;
}
}
#line 768 "output-emf.c"
int output_emf_writer(FILE *file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ) 
{ 
  EMFStats stats ;

  {
  {
#line 784
  GetEmfStats(& stats, name, shape);
#line 787
  OutputEmf(file, & stats, name, urx, ury, shape);
  }
#line 789
  return (0);
}
}
#line 25 "output-dxf.h"
int output_dxf12_writer(FILE *dxf_file , at_string name , int llx , int lly , int urx ,
                        int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                        void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                        at_address msg_data ) ;
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 88 "output-dxf.c"
struct Colors_t dxftable[255]  = 
#line 88 "output-dxf.c"
  {      {255, 0, 0}, 
        {255, 255, 0}, 
        {0, 255, 0}, 
        {0, 255, 255}, 
        {0, 0, 255}, 
        {255, 0, 255}, 
        {255, 255, 255}, 
        {255, 255, 255}, 
        {255, 255, 255}, 
        {255, 9, 0}, 
        {255, 128, 128}, 
        {166, 0, 0}, 
        {166, 83, 83}, 
        {128, 0, 0}, 
        {128, 64, 64}, 
        {77, 0, 0}, 
        {77, 38, 38}, 
        {38, 0, 0}, 
        {38, 19, 19}, 
        {255, 64, 0}, 
        {255, 160, 128}, 
        {166, 42, 0}, 
        {166, 104, 83}, 
        {128, 32, 0}, 
        {128, 80, 64}, 
        {77, 19, 0}, 
        {77, 48, 38}, 
        {38, 10, 0}, 
        {38, 24, 19}, 
        {256, 128, 0}, 
        {256, 192, 0}, 
        {166, 83, 0}, 
        {166, 125, 83}, 
        {128, 64, 0}, 
        {128, 96, 64}, 
        {77, 38, 0}, 
        {77, 58, 38}, 
        {38, 19, 0}, 
        {38, 29, 19}, 
        {255, 192, 0}, 
        {255, 224, 128}, 
        {166, 125, 0}, 
        {166, 146, 83}, 
        {128, 96, 0}, 
        {128, 112, 64}, 
        {77, 58, 0}, 
        {77, 67, 38}, 
        {38, 29, 0}, 
        {38, 34, 19}, 
        {255, 255, 0}, 
        {255, 255, 128}, 
        {166, 166, 0}, 
        {166, 166, 83}, 
        {128, 128, 0}, 
        {128, 128, 64}, 
        {77, 77, 0}, 
        {77, 77, 38}, 
        {38, 38, 0}, 
        {38, 38, 19}, 
        {192, 255, 0}, 
        {224, 255, 128}, 
        {125, 166, 0}, 
        {146, 166, 83}, 
        {96, 128, 0}, 
        {112, 128, 64}, 
        {58, 77, 0}, 
        {67, 77, 38}, 
        {29, 38, 0}, 
        {34, 38, 19}, 
        {128, 255, 0}, 
        {192, 255, 128}, 
        {83, 166, 0}, 
        {125, 166, 83}, 
        {64, 128, 0}, 
        {96, 128, 64}, 
        {38, 77, 0}, 
        {58, 77, 38}, 
        {19, 38, 0}, 
        {29, 38, 19}, 
        {64, 255, 0}, 
        {160, 255, 128}, 
        {42, 160, 0}, 
        {104, 160, 80}, 
        {32, 128, 0}, 
        {80, 128, 64}, 
        {19, 77, 0}, 
        {48, 77, 38}, 
        {10, 38, 0}, 
        {24, 38, 19}, 
        {0, 255, 0}, 
        {128, 255, 128}, 
        {0, 166, 0}, 
        {83, 166, 83}, 
        {0, 128, 0}, 
        {64, 128, 64}, 
        {0, 77, 0}, 
        {38, 77, 38}, 
        {0, 38, 0}, 
        {19, 38, 19}, 
        {0, 255, 64}, 
        {128, 255, 160}, 
        {0, 166, 42}, 
        {83, 166, 118}, 
        {0, 128, 32}, 
        {64, 128, 80}, 
        {0, 77, 19}, 
        {38, 77, 48}, 
        {0, 38, 10}, 
        {19, 38, 24}, 
        {0, 255, 128}, 
        {128, 255, 192}, 
        {0, 166, 83}, 
        {83, 166, 125}, 
        {0, 128, 64}, 
        {64, 128, 96}, 
        {0, 77, 38}, 
        {38, 77, 58}, 
        {0, 38, 19}, 
        {19, 38, 29}, 
        {0, 255, 192}, 
        {128, 255, 224}, 
        {0, 166, 125}, 
        {83, 166, 146}, 
        {0, 128, 96}, 
        {64, 128, 112}, 
        {0, 77, 58}, 
        {38, 77, 67}, 
        {0, 38, 29}, 
        {19, 38, 34}, 
        {0, 255, 255}, 
        {128, 255, 255}, 
        {0, 166, 166}, 
        {83, 166, 166}, 
        {0, 128, 128}, 
        {64, 128, 128}, 
        {0, 77, 77}, 
        {38, 77, 77}, 
        {0, 38, 38}, 
        {19, 38, 38}, 
        {0, 192, 255}, 
        {128, 224, 255}, 
        {0, 125, 166}, 
        {83, 146, 166}, 
        {0, 96, 128}, 
        {64, 112, 128}, 
        {0, 58, 77}, 
        {38, 67, 77}, 
        {0, 29, 38}, 
        {19, 34, 38}, 
        {0, 128, 255}, 
        {128, 192, 255}, 
        {0, 83, 166}, 
        {83, 125, 166}, 
        {0, 64, 128}, 
        {64, 96, 128}, 
        {0, 38, 77}, 
        {38, 58, 77}, 
        {0, 19, 38}, 
        {19, 29, 38}, 
        {0, 64, 255}, 
        {128, 160, 255}, 
        {0, 42, 166}, 
        {83, 104, 166}, 
        {0, 32, 128}, 
        {64, 80, 128}, 
        {0, 19, 77}, 
        {38, 48, 77}, 
        {0, 10, 38}, 
        {19, 24, 38}, 
        {0, 0, 255}, 
        {128, 128, 255}, 
        {0, 0, 166}, 
        {83, 83, 166}, 
        {0, 0, 128}, 
        {64, 64, 128}, 
        {0, 0, 77}, 
        {38, 38, 77}, 
        {0, 0, 38}, 
        {19, 19, 38}, 
        {64, 0, 255}, 
        {160, 128, 255}, 
        {42, 0, 166}, 
        {104, 83, 166}, 
        {32, 0, 128}, 
        {80, 64, 128}, 
        {19, 0, 77}, 
        {48, 38, 77}, 
        {10, 0, 38}, 
        {24, 19, 38}, 
        {128, 0, 255}, 
        {192, 128, 255}, 
        {83, 0, 166}, 
        {125, 83, 166}, 
        {64, 0, 128}, 
        {96, 64, 128}, 
        {38, 0, 77}, 
        {58, 38, 77}, 
        {19, 0, 38}, 
        {29, 19, 38}, 
        {192, 0, 255}, 
        {224, 128, 255}, 
        {125, 0, 166}, 
        {146, 83, 166}, 
        {96, 0, 128}, 
        {112, 64, 128}, 
        {58, 0, 77}, 
        {67, 38, 77}, 
        {29, 0, 38}, 
        {34, 19, 38}, 
        {255, 0, 255}, 
        {255, 128, 255}, 
        {166, 0, 166}, 
        {166, 83, 166}, 
        {128, 0, 128}, 
        {128, 64, 128}, 
        {77, 0, 77}, 
        {77, 38, 77}, 
        {38, 0, 38}, 
        {38, 19, 38}, 
        {255, 0, 192}, 
        {255, 128, 224}, 
        {166, 0, 125}, 
        {166, 83, 146}, 
        {128, 0, 96}, 
        {128, 64, 112}, 
        {77, 0, 58}, 
        {77, 38, 67}, 
        {38, 0, 29}, 
        {38, 19, 34}, 
        {255, 0, 128}, 
        {255, 128, 192}, 
        {166, 0, 83}, 
        {166, 83, 125}, 
        {128, 0, 64}, 
        {128, 64, 96}, 
        {77, 0, 38}, 
        {77, 38, 58}, 
        {38, 0, 19}, 
        {38, 19, 29}, 
        {255, 0, 64}, 
        {255, 128, 160}, 
        {166, 0, 42}, 
        {166, 83, 104}, 
        {128, 0, 32}, 
        {128, 64, 80}, 
        {77, 0, 19}, 
        {77, 38, 48}, 
        {38, 0, 10}, 
        {38, 19, 24}, 
        {84, 84, 84}, 
        {119, 119, 119}, 
        {153, 153, 153}, 
        {187, 187, 187}, 
        {222, 222, 222}, 
        {255, 255, 255}};
#line 352 "output-dxf.c"
void xypnt_next_pnt(xypnt_head_rec *head_xypnt , xypnt *coord_point , char *finished ) 
{ 


  {
#line 356
  if (head_xypnt) {
#line 356
    if (head_xypnt->current_point) {
#line 358
      head_xypnt->current_point = (head_xypnt->current_point)->next_point;
#line 359
      if ((unsigned long )head_xypnt->current_point == (unsigned long )((void *)0)) {
#line 360
        *finished = (char)1;
      } else {
#line 363
        *coord_point = (head_xypnt->current_point)->point;
#line 364
        *finished = (char)0;
      }
    } else {
#line 368
      *finished = (char)1;
    }
  } else {
#line 368
    *finished = (char)1;
  }
#line 369
  return;
}
}
#line 375 "output-dxf.c"
void xypnt_first_pnt(xypnt_head_rec *head_xypnt , xypnt *coord_point , char *finished ) 
{ 


  {
#line 379
  if (head_xypnt) {
#line 381
    head_xypnt->current_point = head_xypnt->first_point;
#line 382
    if ((unsigned long )head_xypnt->current_point == (unsigned long )((void *)0)) {
#line 383
      *finished = (char)1;
    } else {
#line 386
      *coord_point = (head_xypnt->current_point)->point;
#line 387
      *finished = (char)0;
    }
  } else {
#line 391
    *finished = (char)1;
  }
#line 392
  return;
}
}
#line 399 "output-dxf.c"
void xypnt_add_pnt(xypnt_head_rec *head_xypnt , xypnt coord_point ) 
{ 
  xypnt_point_rec *temp_point ;
  void *tmp ;

  {
#line 404
  if (! head_xypnt) {
#line 405
    return;
  }
  {
#line 406
  tmp = calloc((size_t )1, sizeof(struct xypnt_point_t ));
#line 406
  temp_point = (struct xypnt_point_t *)tmp;
#line 407
  temp_point->point = coord_point;
#line 408
  temp_point->next_point = (struct xypnt_point_t *)((void *)0);
  }
#line 409
  if ((unsigned long )head_xypnt->first_point == (unsigned long )((void *)0)) {
#line 410
    head_xypnt->first_point = temp_point;
  } else {
#line 412
    (head_xypnt->last_point)->next_point = temp_point;
  }
#line 413
  head_xypnt->last_point = temp_point;
#line 414
  return;
}
}
#line 421 "output-dxf.c"
void xypnt_dispose_list(xypnt_head_rec **head_xypnt ) 
{ 
  xypnt_point_rec *p ;
  xypnt_point_rec *old ;

  {
#line 424
  if (head_xypnt) {
#line 424
    if (*head_xypnt) {
#line 426
      if ((*head_xypnt)->last_point) {
#line 426
        if ((*head_xypnt)->first_point) {
#line 428
          p = (*head_xypnt)->first_point;
          {
#line 429
          while (1) {
            while_continue: /* CIL Label */ ;
#line 429
            if (! p) {
#line 429
              goto while_break;
            }
            {
#line 431
            old = p;
#line 432
            p = p->next_point;
#line 433
            free((void *)old);
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 437
  return;
}
}
#line 445 "output-dxf.c"
int GetIndexByRGBValue(int red , int green , int blue ) 
{ 
  int savdis ;
  int i ;
  double psav ;
  double pnew ;
  double px ;
  double py ;
  double pz ;
  int nred ;
  int ngreen ;
  int nblue ;

  {
#line 449
  savdis = 1;
#line 450
  psav = (double )10000000;
#line 453
  i = 0;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! (i < 255)) {
#line 453
      goto while_break;
    }
    {
#line 455
    nred = dxftable[i].red;
#line 456
    ngreen = dxftable[i].green;
#line 457
    nblue = dxftable[i].blue;
#line 459
    px = (double )((red * red - (2 * nred) * red) + nred * nred);
#line 460
    py = (double )((green * green - (2 * ngreen) * green) + ngreen * ngreen);
#line 461
    pz = (double )((blue * blue - (2 * nblue) * blue) + nblue * nblue);
#line 462
    pnew = sqrt((px + py) + pz);
    }
#line 463
    if (pnew < psav) {
#line 465
      psav = pnew;
#line 466
      savdis = i;
    }
#line 453
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 469
  return (savdis + 1);
}
}
#line 477 "output-dxf.c"
void xypnt_last_pnt(xypnt_head_rec *head_xypnt , xypnt *coord_point , char *finished ) 
{ 


  {
#line 481
  if (head_xypnt) {
#line 483
    head_xypnt->current_point = head_xypnt->last_point;
#line 484
    if ((unsigned long )head_xypnt->current_point == (unsigned long )((void *)0)) {
#line 485
      *finished = (char)1;
    } else {
#line 488
      *coord_point = (head_xypnt->current_point)->point;
#line 489
      *finished = (char)0;
    }
  } else {
#line 493
    *finished = (char)1;
  }
#line 494
  return;
}
}
#line 504 "output-dxf.c"
double distpt2pt(xypnt p1 , xypnt p2 ) 
{ 
  double dx ;
  double dy ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 509
  dx = (double )(p2.xp - p1.xp);
#line 510
  dy = (double )(p2.yp - p1.yp);
#line 511
  if (p1.xp == p2.xp) {
    {
#line 512
    tmp = fabs(dy);
    }
#line 512
    return (tmp);
  } else
#line 513
  if (p1.yp == p2.yp) {
    {
#line 514
    tmp___0 = fabs(dx);
    }
#line 514
    return (tmp___0);
  } else {
    {
#line 516
    tmp___1 = sqrt(dx * dx + dy * dy);
    }
#line 516
    return (tmp___1);
  }
}
}
#line 523 "output-dxf.c"
static double get_total_length(xypnt_head_rec *vtx_list ) 
{ 
  double total_length ;
  xypnt curr_pnt ;
  xypnt next_pnt ;
  char end_of_list ;
  double tmp ;

  {
  {
#line 529
  total_length = 0.0;
#line 530
  xypnt_first_pnt(vtx_list, & curr_pnt, & end_of_list);
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! (! end_of_list)) {
#line 531
      goto while_break;
    }
    {
#line 533
    xypnt_next_pnt(vtx_list, & next_pnt, & end_of_list);
#line 534
    tmp = distpt2pt(curr_pnt, next_pnt);
#line 534
    total_length += tmp;
#line 535
    curr_pnt = next_pnt;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  return (total_length);
}
}
#line 546 "output-dxf.c"
int bspline_to_lines(xypnt_head_rec *vtx_list , xypnt_head_rec **new_vtx_list , int vtx_count ,
                     int spline_order , int spline_resolution ) 
{ 
  int i ;
  int j ;
  int knot_index ;
  int number_of_segments ;
  int knot[10001] ;
  int n ;
  int m ;
  double spline_step ;
  double total_length ;
  double t ;
  double spline_pnt_x ;
  double spline_pnt_y ;
  double r ;
  double *weight ;
  xypnt curr_pnt ;
  xypnt spline_pnt ;
  char end_of_list ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 558
  tmp = calloc((size_t )1, sizeof(struct xypnt_head_t ));
#line 558
  *new_vtx_list = (struct xypnt_head_t *)tmp;
  }
#line 559
  if (vtx_list) {
    {
#line 561
    n = (vtx_count + spline_order) + 1;
#line 562
    m = spline_order + 1;
#line 563
    tmp___0 = malloc((unsigned long )(n * m) * sizeof(double ));
#line 563
    weight = (double *)tmp___0;
#line 565
    i = 0;
    }
    {
#line 565
    while (1) {
      while_continue: /* CIL Label */ ;
#line 565
      if (! (i < vtx_count + spline_order)) {
#line 565
        goto while_break;
      }
#line 566
      if (i < spline_order) {
#line 566
        knot[i] = 0;
      } else {
#line 566
        if (i > vtx_count) {
#line 566
          tmp___1 = knot[i - 1];
        } else {
#line 566
          tmp___1 = knot[i - 1] + 1;
        }
#line 566
        knot[i] = tmp___1;
      }
#line 565
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 568
    total_length = get_total_length(vtx_list);
    }
#line 569
    if (spline_resolution == 0) {
      {
#line 569
      tmp___2 = sqrt(total_length);
#line 569
      r = tmp___2;
      }
    } else {
#line 569
      r = total_length / (double )spline_resolution;
    }
#line 571
    if (r > (double )0) {
#line 571
      tmp___4 = 1;
    } else {
#line 571
      if (r < (double )0) {
#line 571
        tmp___3 = -1;
      } else {
#line 571
        tmp___3 = 0;
      }
#line 571
      tmp___4 = tmp___3;
    }
#line 571
    number_of_segments = (int )((double )((int )r) + .5 * (double )tmp___4);
#line 572
    spline_step = (double )knot[(vtx_count + spline_order) - 1] / (double )number_of_segments;
#line 574
    knot_index = spline_order - 1;
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 574
      if (! (knot_index < vtx_count)) {
#line 574
        goto while_break___0;
      }
#line 576
      i = 0;
      {
#line 576
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 576
        if (! (i <= (vtx_count + spline_order) - 2)) {
#line 576
          goto while_break___1;
        }
#line 577
        if (i == knot_index) {
#line 577
          if (knot[i] != knot[i + 1]) {
#line 577
            tmp___5 = 1;
          } else {
#line 577
            tmp___5 = 0;
          }
        } else {
#line 577
          tmp___5 = 0;
        }
#line 577
        *(weight + i) = (double )tmp___5;
#line 576
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 578
      t = (double )knot[knot_index];
      {
#line 579
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 579
        if (! (t < (double )knot[knot_index + 1] - spline_step / 2.0)) {
#line 579
          goto while_break___2;
        }
#line 581
        spline_pnt_x = 0.0;
#line 582
        spline_pnt_y = 0.0;
#line 583
        j = 2;
        {
#line 583
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 583
          if (! (j <= spline_order)) {
#line 583
            goto while_break___3;
          }
          {
#line 585
          i = 0;
#line 586
          xypnt_first_pnt(vtx_list, & curr_pnt, & end_of_list);
          }
          {
#line 587
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 587
            if (! (! end_of_list)) {
#line 587
              goto while_break___4;
            }
#line 589
            *(weight + ((j - 1) * n + i)) = (double )0;
#line 590
            if (*(weight + ((j - 2) * n + i))) {
#line 591
              *(weight + ((j - 1) * n + i)) += ((t - (double )knot[i]) * *(weight + ((j - 2) * n + i))) / (double )(knot[(i + j) - 1] - knot[i]);
            }
#line 593
            if (*(weight + (((j - 2) * n + i) + 1))) {
#line 594
              *(weight + ((j - 1) * n + i)) += (((double )knot[i + j] - t) * *(weight + (((j - 2) * n + i) + 1))) / (double )(knot[i + j] - knot[i + 1]);
            }
#line 596
            if (j == spline_order) {
#line 598
              spline_pnt_x += (double )curr_pnt.xp * *(weight + ((j - 1) * n + i));
#line 599
              spline_pnt_y += (double )curr_pnt.yp * *(weight + ((j - 1) * n + i));
            }
            {
#line 601
            i ++;
#line 602
            xypnt_next_pnt(vtx_list, & curr_pnt, & end_of_list);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 604
          *(weight + ((j - 1) * n + i)) = (double )0;
#line 583
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 606
        if (spline_pnt_x > (double )0) {
#line 606
          tmp___7 = 1;
        } else {
#line 606
          if (spline_pnt_x < (double )0) {
#line 606
            tmp___6 = -1;
          } else {
#line 606
            tmp___6 = 0;
          }
#line 606
          tmp___7 = tmp___6;
        }
#line 606
        spline_pnt.xp = (int )((double )((int )spline_pnt_x) + .5 * (double )tmp___7);
#line 607
        if (spline_pnt_y > (double )0) {
#line 607
          tmp___9 = 1;
        } else {
#line 607
          if (spline_pnt_y < (double )0) {
#line 607
            tmp___8 = -1;
          } else {
#line 607
            tmp___8 = 0;
          }
#line 607
          tmp___9 = tmp___8;
        }
        {
#line 607
        spline_pnt.yp = (int )((double )((int )spline_pnt_y) + .5 * (double )tmp___9);
#line 608
        xypnt_add_pnt(*new_vtx_list, spline_pnt);
#line 609
        t += spline_step;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 574
      knot_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 612
    xypnt_last_pnt(vtx_list, & spline_pnt, & end_of_list);
#line 613
    xypnt_add_pnt(*new_vtx_list, spline_pnt);
#line 615
    free((void *)weight);
    }
  }
#line 618
  return (0);
}
}
#line 625 "output-dxf.c"
static void out_splines___6(FILE *dxf_file , at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  double startx ;
  double starty ;
  xypnt_head_rec *vec ;
  xypnt_head_rec *res ;
  xypnt pnt ;
  xypnt pnt1 ;
  xypnt pnt_old ;
  char fin ;
  char new_layer ;
  char layerstr[10] ;
  int i ;
  int first_seg ;
  int idx ;
  unsigned int this_spline ;
  color_type last_color ;
  spline_list_type list ;
  spline_type first ;
  color_type curr_color ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  spline_type s ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
  {
#line 630
  pnt_old.xp = 0;
#line 630
  pnt_old.yp = 0;
#line 631
  new_layer = (char)0;
#line 632
  first_seg = 1;
#line 634
  strcpy((char */* __restrict  */)(layerstr), (char const   */* __restrict  */)"C1");
#line 635
  this_list = 0U;
  }
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (this_list < shape.length)) {
#line 635
      goto while_break;
    }
#line 639
    last_color.r = (unsigned char)0;
#line 639
    last_color.g = (unsigned char)0;
#line 639
    last_color.b = (unsigned char)0;
#line 641
    list = *(shape.data + this_list);
#line 642
    first = *(list.data + 0);
#line 643
    if (list.clockwise) {
#line 643
      if ((unsigned long )shape.background_color != (unsigned long )((void *)0)) {
#line 643
        curr_color = *(shape.background_color);
      } else {
#line 643
        curr_color = list.color;
      }
    } else {
#line 643
      curr_color = list.color;
    }
#line 643
    curr_color = curr_color;
#line 645
    if (this_list == 0U) {
#line 645
      goto _L___1;
    } else
#line 645
    if ((int )curr_color.r == (int )last_color.r) {
#line 645
      if ((int )curr_color.g == (int )last_color.g) {
#line 645
        if (! ((int )curr_color.b == (int )last_color.b)) {
#line 645
          goto _L___1;
        }
      } else {
#line 645
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 647
    if ((int )curr_color.r == 0) {
#line 647
      if ((int )curr_color.g == 0) {
#line 647
        if ((int )curr_color.b == 0) {
          {
#line 649
          idx = GetIndexByRGBValue((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 650
          sprintf((char */* __restrict  */)(layerstr), (char const   */* __restrict  */)"C%d",
                  idx);
#line 651
          new_layer = (char)1;
#line 652
          last_color = curr_color;
          }
        } else {
          {
#line 649
          idx = GetIndexByRGBValue((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 650
          sprintf((char */* __restrict  */)(layerstr), (char const   */* __restrict  */)"C%d",
                  idx);
#line 651
          new_layer = (char)1;
#line 652
          last_color = curr_color;
          }
        }
      } else {
        {
#line 649
        idx = GetIndexByRGBValue((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 650
        sprintf((char */* __restrict  */)(layerstr), (char const   */* __restrict  */)"C%d",
                idx);
#line 651
        new_layer = (char)1;
#line 652
        last_color = curr_color;
        }
      }
    } else {
      {
#line 649
      idx = GetIndexByRGBValue((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 650
      sprintf((char */* __restrict  */)(layerstr), (char const   */* __restrict  */)"C%d",
              idx);
#line 651
      new_layer = (char)1;
#line 652
      last_color = curr_color;
      }
    }
#line 655
    startx = (double )first.v[0].x;
#line 656
    starty = (double )first.v[0].y;
#line 657
    if (! first_seg) {
#line 659
      if (startx * (double )10000 > (double )0) {
#line 659
        tmp___4 = 1;
      } else {
#line 659
        if (startx * (double )10000 < (double )0) {
#line 659
          tmp___3 = -1;
        } else {
#line 659
          tmp___3 = 0;
        }
#line 659
        tmp___4 = tmp___3;
      }
#line 659
      if ((int )((double )((int )(startx * (double )10000)) + .5 * (double )tmp___4) != pnt_old.xp) {
#line 659
        goto _L___2;
      } else {
#line 659
        if (starty * (double )10000 > (double )0) {
#line 659
          tmp___6 = 1;
        } else {
#line 659
          if (starty * (double )10000 < (double )0) {
#line 659
            tmp___5 = -1;
          } else {
#line 659
            tmp___5 = 0;
          }
#line 659
          tmp___6 = tmp___5;
        }
#line 659
        if ((int )((double )((int )(starty * (double )10000)) + .5 * (double )tmp___6) != pnt_old.yp) {
#line 659
          goto _L___2;
        } else
#line 659
        if (new_layer) {
          _L___2: /* CIL Label */ 
          {
#line 662
          new_layer = (char)0;
#line 663
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nSEQEND\n  8\n%s\n",
                  layerstr);
#line 664
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  layerstr, startx, starty);
#line 666
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n",
                  layerstr, startx, starty);
          }
#line 668
          if (startx * (double )10000 > (double )0) {
#line 668
            tmp___0 = 1;
          } else {
#line 668
            if (startx * (double )10000 < (double )0) {
#line 668
              tmp = -1;
            } else {
#line 668
              tmp = 0;
            }
#line 668
            tmp___0 = tmp;
          }
#line 668
          pnt_old.xp = (int )((double )((int )(startx * (double )10000)) + .5 * (double )tmp___0);
#line 669
          if (starty * (double )10000 > (double )0) {
#line 669
            tmp___2 = 1;
          } else {
#line 669
            if (starty * (double )10000 < (double )0) {
#line 669
              tmp___1 = -1;
            } else {
#line 669
              tmp___1 = 0;
            }
#line 669
            tmp___2 = tmp___1;
          }
#line 669
          pnt_old.yp = (int )((double )((int )(starty * (double )10000)) + .5 * (double )tmp___2);
        }
      }
    } else {
      {
#line 674
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
              layerstr, startx, starty);
#line 676
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n",
              layerstr, startx, starty);
      }
#line 678
      if (startx * (double )10000 > (double )0) {
#line 678
        tmp___8 = 1;
      } else {
#line 678
        if (startx * (double )10000 < (double )0) {
#line 678
          tmp___7 = -1;
        } else {
#line 678
          tmp___7 = 0;
        }
#line 678
        tmp___8 = tmp___7;
      }
#line 678
      pnt_old.xp = (int )((double )((int )(startx * (double )10000)) + .5 * (double )tmp___8);
#line 679
      if (starty * (double )10000 > (double )0) {
#line 679
        tmp___10 = 1;
      } else {
#line 679
        if (starty * (double )10000 < (double )0) {
#line 679
          tmp___9 = -1;
        } else {
#line 679
          tmp___9 = 0;
        }
#line 679
        tmp___10 = tmp___9;
      }
#line 679
      pnt_old.yp = (int )((double )((int )(starty * (double )10000)) + .5 * (double )tmp___10);
    }
#line 681
    this_spline = 0U;
    {
#line 681
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 681
      if (! (this_spline < list.length)) {
#line 681
        goto while_break___0;
      }
#line 684
      s = *(list.data + this_spline);
#line 686
      if ((unsigned int )s.degree == 1U) {
#line 689
        if (startx * (double )10000 > (double )0) {
#line 689
          tmp___12 = 1;
        } else {
#line 689
          if (startx * (double )10000 < (double )0) {
#line 689
            tmp___11 = -1;
          } else {
#line 689
            tmp___11 = 0;
          }
#line 689
          tmp___12 = tmp___11;
        }
#line 689
        if ((int )((double )((int )(startx * (double )10000)) + .5 * (double )tmp___12) != pnt_old.xp) {
          {
#line 692
          new_layer = (char)0;
#line 693
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nSEQEND\n  8\n%s\n",
                  layerstr);
#line 694
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  layerstr, startx, starty);
#line 696
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n",
                  layerstr, startx, starty);
          }
        } else {
#line 689
          if (starty * (double )10000 > (double )0) {
#line 689
            tmp___14 = 1;
          } else {
#line 689
            if (starty * (double )10000 < (double )0) {
#line 689
              tmp___13 = -1;
            } else {
#line 689
              tmp___13 = 0;
            }
#line 689
            tmp___14 = tmp___13;
          }
#line 689
          if ((int )((double )((int )(starty * (double )10000)) + .5 * (double )tmp___14) != pnt_old.yp) {
            {
#line 692
            new_layer = (char)0;
#line 693
            fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nSEQEND\n  8\n%s\n",
                    layerstr);
#line 694
            fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                    layerstr, startx, starty);
#line 696
            fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n",
                    layerstr, startx, starty);
            }
          } else
#line 689
          if (new_layer) {
            {
#line 692
            new_layer = (char)0;
#line 693
            fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nSEQEND\n  8\n%s\n",
                    layerstr);
#line 694
            fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                    layerstr, startx, starty);
#line 696
            fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n",
                    layerstr, startx, starty);
            }
          }
        }
        {
#line 699
        fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n",
                layerstr, (double )s.v[3].x, (double )s.v[3].y);
#line 702
        startx = (double )s.v[3].x;
#line 703
        starty = (double )s.v[3].y;
        }
#line 704
        if (startx * (double )10000 > (double )0) {
#line 704
          tmp___16 = 1;
        } else {
#line 704
          if (startx * (double )10000 < (double )0) {
#line 704
            tmp___15 = -1;
          } else {
#line 704
            tmp___15 = 0;
          }
#line 704
          tmp___16 = tmp___15;
        }
#line 704
        pnt_old.xp = (int )((double )((int )(startx * (double )10000)) + .5 * (double )tmp___16);
#line 705
        if (starty * (double )10000 > (double )0) {
#line 705
          tmp___18 = 1;
        } else {
#line 705
          if (starty * (double )10000 < (double )0) {
#line 705
            tmp___17 = -1;
          } else {
#line 705
            tmp___17 = 0;
          }
#line 705
          tmp___18 = tmp___17;
        }
#line 705
        pnt_old.yp = (int )((double )((int )(starty * (double )10000)) + .5 * (double )tmp___18);
      } else {
        {
#line 709
        tmp___19 = calloc((size_t )1, sizeof(struct xypnt_head_t ));
#line 709
        vec = (struct xypnt_head_t *)tmp___19;
        }
#line 711
        if (startx * (double )10000 > (double )0) {
#line 711
          tmp___21 = 1;
        } else {
#line 711
          if (startx * (double )10000 < (double )0) {
#line 711
            tmp___20 = -1;
          } else {
#line 711
            tmp___20 = 0;
          }
#line 711
          tmp___21 = tmp___20;
        }
#line 711
        pnt.xp = (int )((double )((int )(startx * (double )10000)) + .5 * (double )tmp___21);
#line 711
        if (starty * (double )10000 > (double )0) {
#line 711
          tmp___23 = 1;
        } else {
#line 711
          if (starty * (double )10000 < (double )0) {
#line 711
            tmp___22 = -1;
          } else {
#line 711
            tmp___22 = 0;
          }
#line 711
          tmp___23 = tmp___22;
        }
        {
#line 711
        pnt.yp = (int )((double )((int )(starty * (double )10000)) + .5 * (double )tmp___23);
#line 712
        xypnt_add_pnt(vec, pnt);
        }
#line 713
        if (s.v[1].x * (at_real )10000 > (at_real )0) {
#line 713
          tmp___25 = 1;
        } else {
#line 713
          if (s.v[1].x * (at_real )10000 < (at_real )0) {
#line 713
            tmp___24 = -1;
          } else {
#line 713
            tmp___24 = 0;
          }
#line 713
          tmp___25 = tmp___24;
        }
#line 713
        pnt.xp = (int )((double )((int )(s.v[1].x * (at_real )10000)) + .5 * (double )tmp___25);
#line 713
        if (s.v[1].y * (at_real )10000 > (at_real )0) {
#line 713
          tmp___27 = 1;
        } else {
#line 713
          if (s.v[1].y * (at_real )10000 < (at_real )0) {
#line 713
            tmp___26 = -1;
          } else {
#line 713
            tmp___26 = 0;
          }
#line 713
          tmp___27 = tmp___26;
        }
        {
#line 713
        pnt.yp = (int )((double )((int )(s.v[1].y * (at_real )10000)) + .5 * (double )tmp___27);
#line 714
        xypnt_add_pnt(vec, pnt);
        }
#line 715
        if (s.v[2].x * (at_real )10000 > (at_real )0) {
#line 715
          tmp___29 = 1;
        } else {
#line 715
          if (s.v[2].x * (at_real )10000 < (at_real )0) {
#line 715
            tmp___28 = -1;
          } else {
#line 715
            tmp___28 = 0;
          }
#line 715
          tmp___29 = tmp___28;
        }
#line 715
        pnt.xp = (int )((double )((int )(s.v[2].x * (at_real )10000)) + .5 * (double )tmp___29);
#line 715
        if (s.v[2].y * (at_real )10000 > (at_real )0) {
#line 715
          tmp___31 = 1;
        } else {
#line 715
          if (s.v[2].y * (at_real )10000 < (at_real )0) {
#line 715
            tmp___30 = -1;
          } else {
#line 715
            tmp___30 = 0;
          }
#line 715
          tmp___31 = tmp___30;
        }
        {
#line 715
        pnt.yp = (int )((double )((int )(s.v[2].y * (at_real )10000)) + .5 * (double )tmp___31);
#line 716
        xypnt_add_pnt(vec, pnt);
        }
#line 717
        if (s.v[3].x * (at_real )10000 > (at_real )0) {
#line 717
          tmp___33 = 1;
        } else {
#line 717
          if (s.v[3].x * (at_real )10000 < (at_real )0) {
#line 717
            tmp___32 = -1;
          } else {
#line 717
            tmp___32 = 0;
          }
#line 717
          tmp___33 = tmp___32;
        }
#line 717
        pnt.xp = (int )((double )((int )(s.v[3].x * (at_real )10000)) + .5 * (double )tmp___33);
#line 717
        if (s.v[3].y * (at_real )10000 > (at_real )0) {
#line 717
          tmp___35 = 1;
        } else {
#line 717
          if (s.v[3].y * (at_real )10000 < (at_real )0) {
#line 717
            tmp___34 = -1;
          } else {
#line 717
            tmp___34 = 0;
          }
#line 717
          tmp___35 = tmp___34;
        }
        {
#line 717
        pnt.yp = (int )((double )((int )(s.v[3].y * (at_real )10000)) + .5 * (double )tmp___35);
#line 718
        xypnt_add_pnt(vec, pnt);
#line 720
        res = (xypnt_head_rec *)((void *)0);
#line 723
        bspline_to_lines(vec, & res, 4, 4, 10000);
#line 726
        xypnt_first_pnt(res, & pnt, & fin);
        }
#line 728
        if (pnt.xp != pnt_old.xp) {
          {
#line 731
          new_layer = (char)0;
#line 732
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nSEQEND\n  8\n%s\n",
                  layerstr);
#line 733
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
#line 735
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n",
                  layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
          }
        } else
#line 728
        if (pnt.yp != pnt_old.yp) {
          {
#line 731
          new_layer = (char)0;
#line 732
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nSEQEND\n  8\n%s\n",
                  layerstr);
#line 733
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
#line 735
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n",
                  layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
          }
        } else
#line 728
        if (new_layer) {
          {
#line 731
          new_layer = (char)0;
#line 732
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nSEQEND\n  8\n%s\n",
                  layerstr);
#line 733
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nPOLYLINE\n  8\n%s\n  66\n1\n  10\n%f\n  20\n%f\n",
                  layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
#line 735
          fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n",
                  layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
          }
        }
#line 738
        i = 0;
        {
#line 739
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 739
          if (! (! fin)) {
#line 739
            goto while_break___1;
          }
#line 741
          if (i) {
            {
#line 743
            fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nVERTEX\n  8\n%s\n  10\n%f\n  20\n%f\n",
                    layerstr, (double )pnt.xp / (double )10000, (double )pnt.yp / (double )10000);
            }
          }
          {
#line 746
          pnt1 = pnt;
#line 747
          xypnt_next_pnt(res, & pnt, & fin);
#line 748
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 751
        pnt_old = pnt;
#line 753
        xypnt_dispose_list(& vec);
#line 754
        xypnt_dispose_list(& res);
#line 756
        startx = (double )s.v[3].x;
#line 757
        starty = (double )s.v[3].y;
#line 759
        free((void *)res);
#line 760
        free((void *)vec);
        }
      }
#line 681
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 763
    first_seg = 0;
#line 764
    last_color = curr_color;
#line 635
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 767
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"  0\nSEQEND\n  8\n0\n");
  }
#line 769
  return;
}
}
#line 775 "output-dxf.c"
void output_layer(FILE *dxf_file , at_spline_list_array_type shape ) 
{ 
  int i ;
  int idx ;
  char layerlist[256] ;
  unsigned int this_list ;
  color_type last_color ;
  spline_list_type list ;
  color_type curr_color ;
  at_color_type tmp ;

  {
  {
#line 781
  last_color.r = (unsigned char)0;
#line 781
  last_color.g = (unsigned char)0;
#line 781
  last_color.b = (unsigned char)0;
#line 783
  memset((void *)(layerlist), 0, sizeof(layerlist));
#line 784
  this_list = 0U;
  }
  {
#line 784
  while (1) {
    while_continue: /* CIL Label */ ;
#line 784
    if (! (this_list < shape.length)) {
#line 784
      goto while_break;
    }
#line 787
    list = *(shape.data + this_list);
#line 788
    if (list.clockwise) {
#line 788
      if ((unsigned long )shape.background_color != (unsigned long )((void *)0)) {
#line 788
        tmp = *(shape.background_color);
      } else {
#line 788
        tmp = list.color;
      }
    } else {
#line 788
      tmp = list.color;
    }
#line 788
    curr_color = tmp;
#line 790
    if (this_list == 0U) {
#line 790
      goto _L___1;
    } else
#line 790
    if ((int )curr_color.r == (int )last_color.r) {
#line 790
      if ((int )curr_color.g == (int )last_color.g) {
#line 790
        if (! ((int )curr_color.b == (int )last_color.b)) {
#line 790
          goto _L___1;
        }
      } else {
#line 790
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 792
    if ((int )curr_color.r == 0) {
#line 792
      if ((int )curr_color.g == 0) {
#line 792
        if ((int )curr_color.b == 0) {
          {
#line 794
          idx = GetIndexByRGBValue((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 795
          layerlist[idx - 1] = (char)1;
#line 796
          last_color = curr_color;
          }
        } else {
          {
#line 794
          idx = GetIndexByRGBValue((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 795
          layerlist[idx - 1] = (char)1;
#line 796
          last_color = curr_color;
          }
        }
      } else {
        {
#line 794
        idx = GetIndexByRGBValue((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 795
        layerlist[idx - 1] = (char)1;
#line 796
        last_color = curr_color;
        }
      }
    } else {
      {
#line 794
      idx = GetIndexByRGBValue((int )curr_color.r, (int )curr_color.g, (int )curr_color.b);
#line 795
      layerlist[idx - 1] = (char)1;
#line 796
      last_color = curr_color;
      }
    }
#line 784
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 801
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  0");
#line 802
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "SECTION");
#line 803
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  2");
#line 804
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "TABLES");
#line 805
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  0");
#line 806
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "TABLE");
#line 807
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  2");
#line 808
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "LAYER");
#line 809
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  70");
#line 810
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "     2048");
#line 812
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  0");
#line 813
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "LAYER");
#line 814
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  2");
#line 815
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "0");
#line 816
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  70");
#line 817
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "    0");
#line 818
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  62");
#line 819
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "     7");
#line 820
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  6");
#line 821
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "CONTINUOUS");
#line 823
  i = 1;
  }
  {
#line 823
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 823
    if (! (i < 256)) {
#line 823
      goto while_break___0;
    }
#line 825
    if (layerlist[i - 1]) {
      {
#line 827
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
              "  0");
#line 828
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
              "LAYER");
#line 829
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
              "   2");
#line 830
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"C%d\n",
              i);
#line 831
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
              "  70");
#line 832
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
              "     64");
#line 833
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
              "  62");
#line 834
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%d\n",
              i);
#line 835
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
              "  6");
#line 836
      fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
              "CONTINUOUS");
      }
    }
#line 823
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 840
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  0");
#line 841
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "ENDTAB");
#line 842
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  0");
#line 843
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "ENDSEC");
  }
#line 845
  return;
}
}
#line 851 "output-dxf.c"
int output_dxf12_writer(FILE *dxf_file , at_string name , int llx , int lly , int urx ,
                        int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                        void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                        at_address msg_data ) 
{ 


  {
  {
#line 858
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  0");
#line 859
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "SECTION");
#line 860
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  2");
#line 861
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "HEADER");
#line 862
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  9");
#line 863
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "$ACADVER");
#line 864
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  1");
#line 865
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "AC1009");
#line 866
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  9");
#line 867
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "$EXTMIN");
#line 868
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  10");
#line 869
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)" %f\n",
          (double )llx);
#line 870
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  20");
#line 871
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)" %f\n",
          (double )lly);
#line 872
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  30");
#line 873
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          " 0.000000");
#line 874
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  9");
#line 875
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "$EXTMAX");
#line 876
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  10");
#line 877
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)" %f\n",
          (double )urx);
#line 878
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  20");
#line 879
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)" %f\n",
          (double )ury);
#line 880
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  30");
#line 881
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          " 0.000000");
#line 882
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  0");
#line 883
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "ENDSEC");
#line 885
  output_layer(dxf_file, shape);
#line 887
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  0");
#line 888
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "SECTION");
#line 889
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  2");
#line 890
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "ENTITIES");
#line 892
  out_splines___6(dxf_file, shape);
#line 894
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  0");
#line 895
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "ENDSEC");
#line 896
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "  0");
#line 897
  fprintf((FILE */* __restrict  */)dxf_file, (char const   */* __restrict  */)"%s\n",
          "EOF");
  }
#line 898
  return (0);
}
}
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 25 "output-dr2d.h"
int output_dr2d_writer(FILE *file , at_string name , int llx , int lly , int urx ,
                       int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                       void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                       at_address msg_data ) ;
#line 33 "output-dr2d.c"
float XFactor  ;
#line 34 "output-dr2d.c"
float YFactor  ;
#line 35 "output-dr2d.c"
float LineThickness  ;
#line 60
static struct Chunk *BuildDRHD(int x1 , int y1 , int x2 , int y2 ) ;
#line 61
static struct Chunk *BuildPPRF(char *Units , int Portrait , char *PageType , float GridSize ) ;
#line 62
static struct Chunk *BuildCMAP(at_spline_list_array_type shape ) ;
#line 63
static struct Chunk *BuildLAYR(void) ;
#line 64
static struct Chunk *BuildDASH(void) ;
#line 65
static struct Chunk *BuildBBOX(spline_list_type list , int height ) ;
#line 66
static struct Chunk *BuildATTR(at_color_type colour , int StrokeOrFill , struct Chunk *CMAPChunk ) ;
#line 67
static int GetCMAPEntry(at_color_type colour , struct Chunk *CMAPChunk ) ;
#line 68
static int CountSplines(spline_list_type list ) ;
#line 69
static int SizeFloat(float f , char *Format ) ;
#line 70
static void ShortAsBytes(int value , unsigned char *bytes ) ;
#line 71
static void IntAsBytes(int value , unsigned char *bytes ) ;
#line 72
static void FloatAsIEEEBytes(float value , unsigned char *bytes ) ;
#line 74
static void flt2ieee(float *flt , unsigned char *bytes ) ;
#line 75
static void FreeChunk(struct Chunk *ThisChunk ) ;
#line 76
static void FreeChunks(struct Chunk **ChunkList , int NumChunks ) ;
#line 77
static int TotalSizeChunks(struct Chunk **ChunkList , int NumChunks ) ;
#line 78
static int SizeChunk(struct Chunk *ThisChunk ) ;
#line 79
static void PushPolyPoint(unsigned char *PolyData , int *PolyPoint , float x , float y ) ;
#line 80
static void PushPolyIndicator(unsigned char *PolyData , int *PolyPoint , unsigned int flags ) ;
#line 81
static struct Chunk **GeneratexPLY(struct Chunk *CMAP , at_spline_list_array_type shape ,
                                   int height ) ;
#line 83 "output-dr2d.c"
static struct Chunk *BuildCMAP(at_spline_list_array_type shape ) 
{ 
  unsigned int this_list ;
  unsigned int this_list_length ;
  int ListSize ;
  int MaxListSize ;
  int WalkCol ;
  int FoundCol ;
  unsigned char Red ;
  unsigned char Green ;
  unsigned char Blue ;
  unsigned char *CMAP ;
  unsigned char *IndexCol ;
  struct Chunk *CMAPChunk ;
  void *tmp ;
  void *tmp___0 ;
  spline_list_type list ;
  color_type curr_color ;

  {
  {
#line 93
  MaxListSize = (int )shape.length;
#line 95
  tmp = malloc(sizeof(struct Chunk ));
#line 95
  CMAPChunk = (struct Chunk *)tmp;
  }
#line 95
  if ((unsigned long )CMAPChunk == (unsigned long )((void *)0)) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate CMAP chunk\n");
    }
#line 97
    return ((struct Chunk *)((void *)0));
  }
  {
#line 100
  tmp___0 = malloc((size_t )(MaxListSize * 3));
#line 100
  CMAP = (unsigned char *)tmp___0;
  }
#line 100
  if ((unsigned long )CMAP == (unsigned long )((void *)0)) {
    {
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate colour map (size %d)\n",
            MaxListSize);
#line 102
    free((void *)CMAPChunk);
    }
#line 103
    return ((struct Chunk *)((void *)0));
  }
#line 106
  ListSize = 0;
#line 107
  this_list_length = shape.length;
#line 108
  this_list = 0U;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (this_list < this_list_length)) {
#line 108
      goto while_break;
    }
#line 109
    list = *(shape.data + this_list);
#line 110
    if (list.clockwise) {
#line 110
      if ((unsigned long )shape.background_color != (unsigned long )((void *)0)) {
#line 110
        curr_color = *(shape.background_color);
      } else {
#line 110
        curr_color = list.color;
      }
    } else {
#line 110
      curr_color = list.color;
    }
#line 110
    curr_color = curr_color;
#line 112
    Red = curr_color.r;
#line 113
    Green = curr_color.g;
#line 114
    Blue = curr_color.b;
#line 116
    FoundCol = 0;
#line 117
    WalkCol = 0;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (WalkCol < ListSize)) {
#line 117
        goto while_break___0;
      }
#line 118
      IndexCol = CMAP + WalkCol * 3;
#line 119
      if ((int )*IndexCol == (int )Red) {
#line 119
        if ((int )*(IndexCol + 1) == (int )Green) {
#line 119
          if ((int )*(IndexCol + 2) == (int )Blue) {
#line 120
            FoundCol = 1;
#line 121
            goto while_break___0;
          }
        }
      }
#line 117
      WalkCol ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 125
    if (FoundCol == 0) {
#line 126
      IndexCol = CMAP + ListSize * 3;
#line 127
      *IndexCol = Red;
#line 128
      *(IndexCol + 1) = Green;
#line 129
      *(IndexCol + 2) = Blue;
#line 130
      ListSize ++;
    }
#line 108
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 134
  strncpy((char */* __restrict  */)(CMAPChunk->ID), (char const   */* __restrict  */)"CMAP",
          (size_t )4);
#line 135
  CMAPChunk->Size = (unsigned int )(ListSize * 3);
#line 136
  CMAPChunk->Data = CMAP;
  }
#line 138
  return (CMAPChunk);
}
}
#line 141 "output-dr2d.c"
static int GetCMAPEntry(at_color_type colour , struct Chunk *CMAPChunk ) 
{ 
  int WalkCol ;
  int ListSize ;
  unsigned char Red ;
  unsigned char Green ;
  unsigned char Blue ;
  unsigned char *IndexCol ;
  unsigned char *CMAPTable ;

  {
#line 147
  ListSize = (int )(CMAPChunk->Size / 3U);
#line 148
  CMAPTable = CMAPChunk->Data;
#line 150
  Red = colour.r;
#line 151
  Green = colour.g;
#line 152
  Blue = colour.b;
#line 154
  WalkCol = 0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (WalkCol < ListSize)) {
#line 154
      goto while_break;
    }
#line 155
    IndexCol = CMAPTable + WalkCol * 3;
#line 156
    if ((int )*IndexCol == (int )Red) {
#line 156
      if ((int )*(IndexCol + 1) == (int )Green) {
#line 156
        if ((int )*(IndexCol + 2) == (int )Blue) {
#line 157
          return (WalkCol);
        }
      }
    }
#line 154
    WalkCol ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (-1);
}
}
#line 164 "output-dr2d.c"
static struct Chunk *BuildBBOX(spline_list_type list , int height ) 
{ 
  unsigned int this_spline ;
  unsigned int this_spline_length ;
  float x1 ;
  float y1 ;
  float x2 ;
  float y2 ;
  float ex ;
  float ey ;
  struct Chunk *BBOXChunk ;
  unsigned char *BBOXData ;
  spline_type s ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 173
  tmp = malloc(sizeof(struct Chunk ));
#line 173
  BBOXChunk = (struct Chunk *)tmp;
  }
#line 173
  if ((unsigned long )BBOXChunk == (unsigned long )((void *)0)) {
    {
#line 174
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate BBOX chunk\n");
    }
#line 175
    return ((struct Chunk *)((void *)0));
  }
  {
#line 178
  tmp___0 = malloc((size_t )16);
#line 178
  BBOXData = (unsigned char *)tmp___0;
  }
#line 178
  if ((unsigned long )BBOXData == (unsigned long )((void *)0)) {
    {
#line 179
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate BBOX data\n");
#line 180
    free((void *)BBOXChunk);
    }
#line 181
    return ((struct Chunk *)((void *)0));
  }
#line 184
  s = *(list.data + 0);
#line 186
  x1 = s.v[0].x;
#line 187
  y1 = s.v[0].y;
#line 188
  x2 = s.v[0].x;
#line 189
  y2 = s.v[0].y;
#line 191
  this_spline_length = list.length;
#line 192
  this_spline = 0U;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (this_spline < this_spline_length)) {
#line 192
      goto while_break;
    }
#line 193
    s = *(list.data + this_spline);
#line 194
    ex = s.v[3].x;
#line 195
    ey = (at_real )height - s.v[3].y;
#line 197
    if (x1 > ex) {
#line 198
      x1 = ex;
    }
#line 201
    if (y1 > ey) {
#line 202
      y1 = ey;
    }
#line 205
    if (x2 < ex) {
#line 206
      x2 = ex;
    }
#line 209
    if (y2 < ey) {
#line 210
      y2 = ey;
    }
#line 192
    this_spline ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 214
  FloatAsIEEEBytes(x1 * XFactor, BBOXData);
#line 215
  FloatAsIEEEBytes(y1 * YFactor, BBOXData + 4);
#line 216
  FloatAsIEEEBytes(x2 * XFactor, BBOXData + 8);
#line 217
  FloatAsIEEEBytes(y2 * YFactor, BBOXData + 12);
#line 219
  strncpy((char */* __restrict  */)(BBOXChunk->ID), (char const   */* __restrict  */)"BBOX",
          (size_t )4);
#line 220
  BBOXChunk->Size = 16U;
#line 221
  BBOXChunk->Data = BBOXData;
  }
#line 223
  return (BBOXChunk);
}
}
#line 226 "output-dr2d.c"
static struct Chunk *BuildATTR(at_color_type colour , int StrokeOrFill , struct Chunk *CMAPChunk ) 
{ 
  struct Chunk *ATTRChunk ;
  unsigned char *ATTRData ;
  int ColourIndex ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 231
  tmp = malloc(sizeof(struct Chunk ));
#line 231
  ATTRChunk = (struct Chunk *)tmp;
  }
#line 231
  if ((unsigned long )ATTRChunk == (unsigned long )((void *)0)) {
    {
#line 232
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate ATTR chunk\n");
    }
#line 233
    return ((struct Chunk *)((void *)0));
  }
  {
#line 236
  tmp___0 = malloc((size_t )14);
#line 236
  ATTRData = (unsigned char *)tmp___0;
  }
#line 236
  if ((unsigned long )ATTRData == (unsigned long )((void *)0)) {
    {
#line 237
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate ATTR data\n");
#line 238
    free((void *)ATTRChunk);
    }
#line 239
    return ((struct Chunk *)((void *)0));
  }
  {
#line 242
  ColourIndex = GetCMAPEntry(colour, CMAPChunk);
  }
#line 244
  if (StrokeOrFill) {
#line 244
    *(ATTRData + 0) = (unsigned char)0;
  } else {
#line 244
    *(ATTRData + 0) = (unsigned char)1;
  }
  {
#line 245
  *(ATTRData + 1) = (unsigned char)3;
#line 246
  *(ATTRData + 2) = (unsigned char)1;
#line 247
  *(ATTRData + 3) = (unsigned char)0;
#line 248
  ShortAsBytes(ColourIndex, ATTRData + 4);
#line 249
  ShortAsBytes(ColourIndex, ATTRData + 6);
#line 250
  ShortAsBytes(0, ATTRData + 8);
#line 251
  FloatAsIEEEBytes(LineThickness, ATTRData + 10);
#line 253
  strncpy((char */* __restrict  */)(ATTRChunk->ID), (char const   */* __restrict  */)"ATTR",
          (size_t )4);
#line 254
  ATTRChunk->Size = 14U;
#line 255
  ATTRChunk->Data = ATTRData;
  }
#line 257
  return (ATTRChunk);
}
}
#line 260 "output-dr2d.c"
static struct Chunk *BuildDRHD(int x1 , int y1 , int x2 , int y2 ) 
{ 
  struct Chunk *DRHDChunk ;
  unsigned char *DRHDData ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 264
  tmp = malloc(sizeof(struct Chunk ));
#line 264
  DRHDChunk = (struct Chunk *)tmp;
  }
#line 264
  if ((unsigned long )DRHDChunk == (unsigned long )((void *)0)) {
    {
#line 265
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate DRHD chunk\n");
    }
#line 266
    return ((struct Chunk *)((void *)0));
  }
  {
#line 269
  tmp___0 = malloc((size_t )16);
#line 269
  DRHDData = (unsigned char *)tmp___0;
  }
#line 269
  if ((unsigned long )DRHDData == (unsigned long )((void *)0)) {
    {
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate DRHD data\n");
#line 271
    free((void *)DRHDChunk);
    }
#line 272
    return ((struct Chunk *)((void *)0));
  }
  {
#line 275
  FloatAsIEEEBytes((float )x1 * XFactor, DRHDData);
#line 276
  FloatAsIEEEBytes((float )y1 * YFactor, DRHDData + 4);
#line 277
  FloatAsIEEEBytes((float )x2 * XFactor, DRHDData + 8);
#line 278
  FloatAsIEEEBytes((float )y2 * YFactor, DRHDData + 12);
#line 280
  strncpy((char */* __restrict  */)(DRHDChunk->ID), (char const   */* __restrict  */)"DRHD",
          (size_t )4);
#line 281
  DRHDChunk->Size = 16U;
#line 282
  DRHDChunk->Data = DRHDData;
  }
#line 284
  return (DRHDChunk);
}
}
#line 287 "output-dr2d.c"
static struct Chunk *BuildPPRF(char *Units , int Portrait , char *PageType , float GridSize ) 
{ 
  struct Chunk *PPRFChunk ;
  char *PPRFData ;
  char *PPRFPos ;
  int ChunkSize ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  char const   *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 293
  tmp = malloc(sizeof(struct Chunk ));
#line 293
  PPRFChunk = (struct Chunk *)tmp;
  }
#line 293
  if ((unsigned long )PPRFChunk == (unsigned long )((void *)0)) {
    {
#line 294
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate PPRF chunk\n");
    }
#line 295
    return ((struct Chunk *)((void *)0));
  }
  {
#line 298
  tmp___0 = strlen("Units=");
#line 298
  tmp___1 = strlen((char const   *)Units);
#line 298
  ChunkSize = (int )((tmp___0 + tmp___1) + 1UL);
#line 299
  tmp___2 = strlen("Portrait=");
  }
#line 299
  if (Portrait) {
#line 299
    tmp___3 = 4;
  } else {
#line 299
    tmp___3 = 5;
  }
  {
#line 299
  ChunkSize = (int )((size_t )ChunkSize + ((tmp___2 + (size_t )tmp___3) + 1UL));
#line 300
  tmp___4 = strlen("PageType=");
#line 300
  tmp___5 = strlen((char const   *)PageType);
#line 300
  ChunkSize = (int )((size_t )ChunkSize + ((tmp___4 + tmp___5) + 1UL));
#line 301
  tmp___6 = strlen("GridSize=");
#line 301
  tmp___7 = SizeFloat(GridSize, (char *)"%f");
#line 301
  ChunkSize = (int )((size_t )ChunkSize + ((tmp___6 + (size_t )tmp___7) + 1UL));
#line 303
  tmp___8 = malloc((size_t )ChunkSize);
#line 303
  PPRFData = (char *)tmp___8;
  }
#line 303
  if ((unsigned long )PPRFData == (unsigned long )((void *)0)) {
    {
#line 304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate PPRF data\n");
#line 305
    free((void *)PPRFChunk);
    }
#line 306
    return ((struct Chunk *)((void *)0));
  }
  {
#line 309
  PPRFPos = PPRFData;
#line 310
  sprintf((char */* __restrict  */)PPRFPos, (char const   */* __restrict  */)"Units=%s",
          Units);
#line 311
  tmp___9 = strlen((char const   *)PPRFPos);
#line 311
  PPRFPos += tmp___9 + 1UL;
  }
#line 312
  if (Portrait) {
#line 312
    tmp___10 = "True";
  } else {
#line 312
    tmp___10 = "False";
  }
  {
#line 312
  sprintf((char */* __restrict  */)PPRFPos, (char const   */* __restrict  */)"Portrait=%s",
          tmp___10);
#line 313
  tmp___11 = strlen((char const   *)PPRFPos);
#line 313
  PPRFPos += tmp___11 + 1UL;
#line 314
  sprintf((char */* __restrict  */)PPRFPos, (char const   */* __restrict  */)"PageType=%s",
          PageType);
#line 315
  tmp___12 = strlen((char const   *)PPRFPos);
#line 315
  PPRFPos += tmp___12 + 1UL;
#line 316
  sprintf((char */* __restrict  */)PPRFPos, (char const   */* __restrict  */)"GridSize=%f",
          (double )GridSize);
#line 318
  strncpy((char */* __restrict  */)(PPRFChunk->ID), (char const   */* __restrict  */)"PPRF",
          (size_t )4);
#line 319
  PPRFChunk->Size = (unsigned int )ChunkSize;
#line 320
  PPRFChunk->Data = (unsigned char *)PPRFData;
  }
#line 322
  return (PPRFChunk);
}
}
#line 325 "output-dr2d.c"
static struct Chunk *BuildLAYR(void) 
{ 
  struct Chunk *LAYRChunk ;
  unsigned char *LAYRData ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 329
  tmp = malloc(sizeof(struct Chunk ));
#line 329
  LAYRChunk = (struct Chunk *)tmp;
  }
#line 329
  if ((unsigned long )LAYRChunk == (unsigned long )((void *)0)) {
    {
#line 330
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate LAYR chunk\n");
    }
#line 331
    return ((struct Chunk *)((void *)0));
  }
  {
#line 334
  tmp___0 = malloc((size_t )20);
#line 334
  LAYRData = (unsigned char *)tmp___0;
  }
#line 334
  if ((unsigned long )LAYRData == (unsigned long )((void *)0)) {
    {
#line 335
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate LAYR data\n");
#line 336
    free((void *)LAYRChunk);
    }
#line 337
    return ((struct Chunk *)((void *)0));
  }
  {
#line 340
  ShortAsBytes(0, LAYRData);
#line 341
  memset((void *)(LAYRData + 2), (int )((char )((void *)0)), (size_t )16);
#line 342
  strcpy((char */* __restrict  */)(LAYRData + 2), (char const   */* __restrict  */)"Default layer");
#line 343
  *(LAYRData + 18) = (unsigned char)3;
#line 344
  *(LAYRData + 19) = (unsigned char)0;
#line 346
  strncpy((char */* __restrict  */)(LAYRChunk->ID), (char const   */* __restrict  */)"LAYR",
          (size_t )4);
#line 347
  LAYRChunk->Size = 20U;
#line 348
  LAYRChunk->Data = LAYRData;
  }
#line 350
  return (LAYRChunk);
}
}
#line 353 "output-dr2d.c"
static struct Chunk *BuildDASH(void) 
{ 
  struct Chunk *DASHChunk ;
  unsigned char *DASHData ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 357
  tmp = malloc(sizeof(struct Chunk ));
#line 357
  DASHChunk = (struct Chunk *)tmp;
  }
#line 357
  if ((unsigned long )DASHChunk == (unsigned long )((void *)0)) {
    {
#line 358
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate DASH chunk\n");
    }
#line 359
    return ((struct Chunk *)((void *)0));
  }
  {
#line 362
  tmp___0 = malloc((size_t )4);
#line 362
  DASHData = (unsigned char *)tmp___0;
  }
#line 362
  if ((unsigned long )DASHData == (unsigned long )((void *)0)) {
    {
#line 363
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate DASH data\n");
#line 364
    free((void *)DASHChunk);
    }
#line 365
    return ((struct Chunk *)((void *)0));
  }
  {
#line 368
  ShortAsBytes(1, DASHData);
#line 369
  ShortAsBytes(0, DASHData + 2);
#line 371
  strncpy((char */* __restrict  */)(DASHChunk->ID), (char const   */* __restrict  */)"DASH",
          (size_t )4);
#line 372
  DASHChunk->Size = 4U;
#line 373
  DASHChunk->Data = DASHData;
  }
#line 375
  return (DASHChunk);
}
}
#line 378 "output-dr2d.c"
static struct Chunk **GeneratexPLY(struct Chunk *CMAP , at_spline_list_array_type shape ,
                                   int height ) 
{ 
  unsigned int this_list ;
  unsigned int this_list_length ;
  unsigned int this_spline ;
  unsigned int this_spline_length ;
  spline_type s ;
  struct Chunk **ChunkList ;
  struct Chunk *PolyChunk ;
  int ListPoint ;
  int PolySize ;
  int PolyPoint ;
  int NumPoints ;
  int StrokeOrFill ;
  unsigned char *PolyData ;
  void *tmp ;
  spline_list_type list ;
  spline_type first ;
  color_type curr_color ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 390
  this_list_length = shape.length;
#line 393
  tmp = malloc(sizeof(struct Chunk ) * (unsigned long )(this_list_length * 3U));
#line 393
  ChunkList = (struct Chunk **)tmp;
  }
#line 393
  if ((unsigned long )ChunkList == (unsigned long )((void *)0)) {
    {
#line 394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate chunk list\n");
    }
#line 395
    return ((struct Chunk **)((void *)0));
  }
#line 398
  ListPoint = 0;
#line 399
  this_list = 0U;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! (this_list < this_list_length)) {
#line 399
      goto while_break;
    }
#line 400
    list = *(shape.data + this_list);
#line 401
    first = *(list.data + 0);
#line 402
    if (list.clockwise) {
#line 402
      if ((unsigned long )shape.background_color != (unsigned long )((void *)0)) {
#line 402
        curr_color = *(shape.background_color);
      } else {
#line 402
        curr_color = list.color;
      }
    } else {
#line 402
      curr_color = list.color;
    }
#line 402
    curr_color = curr_color;
#line 404
    if (shape.centerline) {
#line 404
      tmp___0 = 1;
    } else
#line 404
    if (list.open) {
#line 404
      tmp___0 = 1;
    } else {
#line 404
      tmp___0 = 0;
    }
    {
#line 404
    StrokeOrFill = tmp___0;
#line 405
    this_spline_length = list.length;
#line 407
    tmp___1 = ListPoint;
#line 407
    ListPoint ++;
#line 407
    *(ChunkList + tmp___1) = BuildBBOX(list, height);
#line 408
    tmp___2 = ListPoint;
#line 408
    ListPoint ++;
#line 408
    *(ChunkList + tmp___2) = BuildATTR(curr_color, StrokeOrFill, CMAP);
#line 410
    tmp___3 = malloc(sizeof(struct Chunk ));
#line 410
    PolyChunk = (struct Chunk *)tmp___3;
    }
#line 410
    if ((unsigned long )PolyChunk == (unsigned long )((void *)0)) {
      {
#line 411
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate xPLY chunk\n");
#line 412
      FreeChunks(ChunkList, ListPoint);
      }
#line 413
      return ((struct Chunk **)((void *)0));
    }
    {
#line 416
    NumPoints = CountSplines(list);
#line 419
    PolySize = (NumPoints << 3) + 2;
#line 420
    tmp___4 = malloc((size_t )PolySize);
#line 420
    PolyData = (unsigned char *)tmp___4;
    }
#line 420
    if ((unsigned long )PolyData == (unsigned long )((void *)0)) {
      {
#line 421
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Insufficient memory to allocate xPLY data\n");
#line 422
      free((void *)PolyChunk);
#line 423
      free((void *)PolyData);
#line 424
      FreeChunks(ChunkList, ListPoint);
      }
#line 425
      return ((struct Chunk **)((void *)0));
    }
#line 428
    tmp___5 = ListPoint;
#line 428
    ListPoint ++;
#line 428
    *(ChunkList + tmp___5) = PolyChunk;
#line 429
    if (StrokeOrFill) {
#line 429
      tmp___6 = "OPLY";
    } else {
#line 429
      tmp___6 = "CPLY";
    }
    {
#line 429
    strncpy((char */* __restrict  */)(PolyChunk->ID), (char const   */* __restrict  */)tmp___6,
            (size_t )4);
#line 430
    PolyChunk->Size = (unsigned int )PolySize;
#line 431
    PolyChunk->Data = PolyData;
#line 433
    ShortAsBytes(NumPoints, PolyData);
#line 434
    PolyPoint = 2;
    }
#line 436
    if ((unsigned int )first.degree == 1U) {
      {
#line 437
      PushPolyPoint(PolyData, & PolyPoint, first.v[0].x, (at_real )height - first.v[0].y);
      }
    }
#line 440
    this_spline = 0U;
    {
#line 440
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 440
      if (! (this_spline < this_spline_length)) {
#line 440
        goto while_break___0;
      }
#line 441
      s = *(list.data + this_spline);
#line 443
      if ((unsigned int )s.degree == 1U) {
        {
#line 444
        PushPolyPoint(PolyData, & PolyPoint, s.v[3].x, (at_real )height - s.v[3].y);
        }
      } else {
        {
#line 446
        PushPolyIndicator(PolyData, & PolyPoint, 1U);
#line 447
        PushPolyPoint(PolyData, & PolyPoint, s.v[0].x, (at_real )height - s.v[0].y);
#line 448
        PushPolyPoint(PolyData, & PolyPoint, s.v[1].x, (at_real )height - s.v[1].y);
#line 449
        PushPolyPoint(PolyData, & PolyPoint, s.v[2].x, (at_real )height - s.v[2].y);
#line 450
        PushPolyPoint(PolyData, & PolyPoint, s.v[3].x, (at_real )height - s.v[3].y);
        }
      }
#line 440
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 399
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (ChunkList);
}
}
#line 458 "output-dr2d.c"
static int CountSplines(spline_list_type list ) 
{ 
  unsigned int this_spline ;
  unsigned int this_spline_length ;
  int Total ;

  {
#line 463
  Total = 0;
#line 465
  if ((unsigned int )(list.data + 0)->degree == 1U) {
#line 466
    Total ++;
  }
#line 469
  this_spline_length = list.length;
#line 470
  this_spline = 0U;
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! (this_spline < this_spline_length)) {
#line 470
      goto while_break;
    }
#line 471
    if ((unsigned int )(list.data + this_spline)->degree == 1U) {
#line 472
      Total ++;
    } else {
#line 474
      Total += 5;
    }
#line 470
    this_spline ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  return (Total);
}
}
#line 481 "output-dr2d.c"
static void PushPolyPoint(unsigned char *PolyData , int *PolyPoint , float x , float y ) 
{ 
  int PolyLocal ;

  {
  {
#line 484
  PolyLocal = *PolyPoint;
#line 486
  FloatAsIEEEBytes(x * XFactor, PolyData + PolyLocal);
#line 487
  PolyLocal += 4;
#line 488
  FloatAsIEEEBytes(y * YFactor, PolyData + PolyLocal);
#line 490
  *PolyPoint = PolyLocal + 4;
  }
#line 491
  return;
}
}
#line 493 "output-dr2d.c"
static void PushPolyIndicator(unsigned char *PolyData , int *PolyPoint , unsigned int flags ) 
{ 
  int PolyLocal ;

  {
  {
#line 496
  PolyLocal = *PolyPoint;
#line 498
  IntAsBytes(-1, PolyData + PolyLocal);
#line 499
  PolyLocal += 4;
#line 500
  IntAsBytes((int )flags, PolyData + PolyLocal);
#line 502
  *PolyPoint = PolyLocal + 4;
  }
#line 503
  return;
}
}
#line 505 "output-dr2d.c"
static void WriteChunk(FILE *file , struct Chunk *Chunk ) 
{ 
  unsigned char SizeBytes[4] ;
  int Size ;

  {
  {
#line 509
  Size = (int )Chunk->Size;
#line 510
  IntAsBytes(Size, SizeBytes);
#line 512
  fwrite((void const   */* __restrict  */)(Chunk->ID), (size_t )4, (size_t )1, (FILE */* __restrict  */)file);
#line 513
  fwrite((void const   */* __restrict  */)(SizeBytes), (size_t )4, (size_t )1, (FILE */* __restrict  */)file);
#line 514
  fwrite((void const   */* __restrict  */)Chunk->Data, (size_t )Size, (size_t )1,
         (FILE */* __restrict  */)file);
  }
#line 515
  if (Size & 1) {
    {
#line 516
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%c",
            (int )((char )((void *)0)));
    }
  }
#line 518
  return;
}
}
#line 520 "output-dr2d.c"
static void WriteChunks(FILE *file , struct Chunk **ChunkList , int NumChunks ) 
{ 
  int WalkChunks ;

  {
#line 523
  WalkChunks = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! (WalkChunks < NumChunks)) {
#line 523
      goto while_break;
    }
    {
#line 524
    WriteChunk(file, *(ChunkList + WalkChunks));
#line 523
    WalkChunks ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return;
}
}
#line 528 "output-dr2d.c"
static int TotalSizeChunks(struct Chunk **ChunkList , int NumChunks ) 
{ 
  int WalkChunks ;
  int Size ;
  int Total ;

  {
#line 533
  Total = 0;
#line 534
  WalkChunks = 0;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (WalkChunks < NumChunks)) {
#line 534
      goto while_break;
    }
#line 536
    Size = (int )(*(ChunkList + WalkChunks))->Size;
#line 537
    Size += Size & 1;
#line 538
    Total += Size + 8;
#line 534
    WalkChunks ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  return (Total);
}
}
#line 544 "output-dr2d.c"
static int SizeChunk(struct Chunk *ThisChunk ) 
{ 
  int Size ;

  {
#line 547
  Size = (int )ThisChunk->Size;
#line 548
  Size += Size & 1;
#line 550
  return (Size);
}
}
#line 553 "output-dr2d.c"
static void FreeChunk(struct Chunk *ThisChunk ) 
{ 


  {
  {
#line 554
  free((void *)ThisChunk->Data);
#line 555
  free((void *)ThisChunk);
  }
#line 556
  return;
}
}
#line 558 "output-dr2d.c"
static void FreeChunks(struct Chunk **ChunkList , int NumChunks ) 
{ 
  int WalkChunks ;

  {
#line 561
  WalkChunks = 0;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! (WalkChunks < NumChunks)) {
#line 561
      goto while_break;
    }
    {
#line 562
    FreeChunk(*(ChunkList + WalkChunks));
#line 561
    WalkChunks ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  return;
}
}
#line 566 "output-dr2d.c"
int output_dr2d_writer(FILE *file , at_string name , int llx , int lly , int urx ,
                       int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                       void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                       at_address msg_data ) 
{ 
  int width ;
  int height ;
  int NumSplines ;
  int FORMSize ;
  int Portrait ;
  struct Chunk *DRHDChunk ;
  struct Chunk *PPRFChunk ;
  struct Chunk *LAYRChunk ;
  struct Chunk *DASHChunk ;
  struct Chunk *CMAPChunk ;
  struct Chunk **ChunkList ;
  unsigned char SizeBytes[4] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 570
  width = urx - llx;
#line 571
  height = ury - lly;
#line 582
  Portrait = width < height;
#line 584
  if (Portrait) {
#line 585
    XFactor = ((float )11.6930 / (float )width) * (float )(1 << 10);
#line 586
    YFactor = XFactor;
  } else {
#line 588
    YFactor = ((float )8.2681 / (float )height) * (float )(1 << 10);
#line 589
    XFactor = YFactor;
  }
  {
#line 592
  LineThickness = (float )1.0 / (float )opts->dpi;
#line 594
  DRHDChunk = BuildDRHD(llx, lly, urx, ury);
#line 595
  PPRFChunk = BuildPPRF((char *)"Inch", Portrait, (char *)"A4", (float )1.0);
#line 596
  LAYRChunk = BuildLAYR();
#line 597
  DASHChunk = BuildDASH();
#line 598
  CMAPChunk = BuildCMAP(shape);
#line 600
  ChunkList = GeneratexPLY(CMAPChunk, shape, height);
#line 602
  NumSplines = (int )(shape.length * 3U);
#line 603
  tmp = SizeChunk(DRHDChunk);
#line 603
  tmp___0 = SizeChunk(PPRFChunk);
#line 603
  tmp___1 = SizeChunk(LAYRChunk);
#line 603
  tmp___2 = SizeChunk(DASHChunk);
#line 603
  tmp___3 = SizeChunk(CMAPChunk);
#line 603
  tmp___4 = TotalSizeChunks(ChunkList, NumSplines);
#line 603
  FORMSize = (((((4 + (tmp + 8)) + (tmp___0 + 8)) + (tmp___1 + 8)) + (tmp___2 + 8)) + (tmp___3 + 8)) + tmp___4;
#line 605
  IntAsBytes(FORMSize, SizeBytes);
#line 606
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"FORM");
#line 607
  fwrite((void const   */* __restrict  */)(SizeBytes), (size_t )4, (size_t )1, (FILE */* __restrict  */)file);
#line 608
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"DR2D");
#line 610
  WriteChunk(file, DRHDChunk);
#line 611
  FreeChunk(DRHDChunk);
#line 612
  WriteChunk(file, PPRFChunk);
#line 613
  FreeChunk(PPRFChunk);
#line 614
  WriteChunk(file, LAYRChunk);
#line 615
  FreeChunk(LAYRChunk);
#line 616
  WriteChunk(file, DASHChunk);
#line 617
  FreeChunk(DASHChunk);
#line 618
  WriteChunk(file, CMAPChunk);
#line 619
  FreeChunk(CMAPChunk);
#line 620
  WriteChunks(file, ChunkList, NumSplines);
#line 621
  FreeChunks(ChunkList, NumSplines);
  }
#line 623
  return (0);
}
}
#line 626 "output-dr2d.c"
static int SizeFloat(float f , char *Format ) 
{ 
  char FloatString[100] ;
  int tmp ;

  {
  {
#line 629
  tmp = sprintf((char */* __restrict  */)(FloatString), (char const   */* __restrict  */)Format,
                (double )f);
  }
#line 629
  return (tmp);
}
}
#line 632 "output-dr2d.c"
static void IntAsBytes(int value , unsigned char *bytes ) 
{ 


  {
#line 633
  *bytes = (unsigned char )((value >> 24) & 255);
#line 634
  *(bytes + 1) = (unsigned char )((value >> 16) & 255);
#line 635
  *(bytes + 2) = (unsigned char )((value >> 8) & 255);
#line 636
  *(bytes + 3) = (unsigned char )(value & 255);
#line 637
  return;
}
}
#line 639 "output-dr2d.c"
static void ShortAsBytes(int value , unsigned char *bytes ) 
{ 


  {
#line 640
  *(bytes + 0) = (unsigned char )((value >> 8) & 255);
#line 641
  *(bytes + 1) = (unsigned char )(value & 255);
#line 642
  return;
}
}
#line 644 "output-dr2d.c"
static void FloatAsIEEEBytes(float value , unsigned char *bytes ) 
{ 


  {
  {
#line 645
  flt2ieee(& value, bytes);
  }
#line 646
  return;
}
}
#line 648 "output-dr2d.c"
static void flt2ieee(float *flt , unsigned char *bytes ) 
{ 
  long RealMant ;
  long RealMask ;
  long RealExp ;
  long MoveExp ;

  {
#line 652
  RealMant = (long )*flt;
#line 654
  *bytes = (unsigned char)0;
#line 655
  *(bytes + 1) = (unsigned char)0;
#line 656
  *(bytes + 2) = (unsigned char)0;
#line 657
  *(bytes + 3) = (unsigned char)0;
#line 659
  if (RealMant) {
#line 660
    if (RealMant < 0L) {
#line 661
      *bytes = (unsigned char )((int )*bytes | 128);
#line 662
      RealMant = - RealMant;
    }
#line 665
    RealMask = 1073741824L;
#line 665
    RealExp = 31L;
    {
#line 665
    while (1) {
      while_continue: /* CIL Label */ ;
#line 665
      if (! RealMask) {
#line 665
        goto while_break;
      }
#line 666
      if (RealMant & RealMask) {
#line 667
        goto while_break;
      }
#line 665
      RealMask >>= 1;
#line 665
      RealExp --;
    }
    while_break: /* CIL Label */ ;
    }
#line 671
    if (RealExp > 24L) {
#line 672
      RealMant >>= RealExp - 24L;
    } else {
#line 674
      RealMant <<= 24L - RealExp;
    }
#line 676
    RealExp -= 10L;
#line 677
    RealExp += 126L;
#line 679
    MoveExp = RealExp << 23;
#line 680
    *bytes = (unsigned char )((long )*bytes | ((MoveExp >> 24) & 127L));
#line 681
    *(bytes + 1) = (unsigned char )((long )*(bytes + 1) | (((MoveExp >> 16) & 128L) | ((RealMant >> 16) & 127L)));
#line 682
    *(bytes + 2) = (unsigned char )((long )*(bytes + 2) | ((RealMant >> 8) & 255L));
#line 683
    *(bytes + 3) = (unsigned char )((long )*(bytes + 3) | (RealMant & 255L));
  }
#line 685
  return;
}
}
#line 419 "autotrace.h"
at_output_write_func at_output_get_handler(at_string filename___0 ) ;
#line 420
at_output_write_func at_output_get_handler_by_suffix(at_string suffix ) ;
#line 421
char **at_output_list_new(void) ;
#line 422
void at_output_list_free(char **list ) ;
#line 426
char *at_output_shortlist(void) ;
#line 81 "output.h"
void at_spline_list_foreach(at_spline_list_type *list , void (*func)(at_spline_list_type *spline_list ,
                                                                     at_spline_type *spline ,
                                                                     int index , at_address user_data ) ,
                            at_address user_data ) ;
#line 84
void at_spline_list_array_foreach(at_spline_list_array_type *list_array , void (*func)(at_spline_list_array_type *spline_list_array ,
                                                                                       at_spline_list_type *spline_list ,
                                                                                       int index ,
                                                                                       at_address user_data ) ,
                                  at_address user_data ) ;
#line 88
int at_output_add_handler(at_string suffix , at_string description , int (*func)(FILE * ,
                                                                                 at_string name ,
                                                                                 int llx ,
                                                                                 int lly ,
                                                                                 int urx ,
                                                                                 int ury ,
                                                                                 at_output_opts_type *opts ,
                                                                                 at_spline_list_array_type shape ,
                                                                                 void (*msg_func)(at_string msg ,
                                                                                                  at_msg_type msg_type ,
                                                                                                  at_address client_data ) ,
                                                                                 at_address msg_data ) ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 28 "filename.h"
at_string find_suffix(at_string name ) ;
#line 25 "output-cgm.h"
int output_cgm_writer(FILE *cgm_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) ;
#line 57 "output.c"
static struct output_format_entry output_formats[15]  = 
#line 57 "output.c"
  {      {"eps", "Encapsulated PostScript", & output_eps_writer}, 
        {"ai", "Adobe Illustrator", & output_eps_writer}, 
        {"p2e", "pstoedit frontend format", & output_p2e_writer}, 
        {"sk", "Sketch", & output_sk_writer}, 
        {"svg", "Scalable Vector Graphics", & output_svg_writer}, 
        {"fig", "XFIG 3.2", & output_fig_writer}, 
        {"emf", "Enhanced Metafile format", (int (*)(FILE * , at_string name , int llx ,
                                                  int lly , int urx , int ury , at_output_opts_type *opts ,
                                                  at_spline_list_array_type shape ,
                                                  void (*msg_func)(at_string msg ,
                                                                   at_msg_type msg_type ,
                                                                   at_address client_data ) ,
                                                  at_address msg_data ))(& output_emf_writer)}, 
        {"mif",
      "FrameMaker MIF format", & output_mif_writer}, 
        {"er", "Elastic Reality Shape file", & output_er_writer}, 
        {"dxf", "DXF format (without splines)", & output_dxf12_writer}, 
        {"epd", "EPD format", & output_epd_writer}, 
        {"pdf", "PDF format", & output_pdf_writer}, 
        {"cgm", "Computer Graphics Metafile", & output_cgm_writer}, 
        {"dr2d", "IFF DR2D format", & output_dr2d_writer}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (int (*)(FILE * ,
                                                                         at_string name ,
                                                                         int llx ,
                                                                         int lly ,
                                                                         int urx ,
                                                                         int ury ,
                                                                         at_output_opts_type *opts ,
                                                                         at_spline_list_array_type shape ,
                                                                         void (*msg_func)(at_string msg ,
                                                                                          at_msg_type msg_type ,
                                                                                          at_address client_data ) ,
                                                                         at_address msg_data ))((void *)0)}};
#line 85 "output.c"
at_output_write_func at_output_get_handler(at_string filename___0 ) 
{ 
  char *ext ;
  at_string tmp ;
  at_output_write_func tmp___0 ;

  {
  {
#line 88
  tmp = find_suffix(filename___0);
#line 88
  ext = tmp;
  }
#line 89
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 90
    ext = (char *)"";
  }
  {
#line 92
  tmp___0 = at_output_get_handler_by_suffix(ext);
  }
#line 92
  return (tmp___0);
}
}
#line 95 "output.c"
at_output_write_func at_output_get_handler_by_suffix(at_string suffix ) 
{ 
  struct output_format_entry *format ;
  at_bool tmp ;

  {
#line 100
  if (! suffix) {
#line 101
    return ((at_output_write_func )((void *)0));
  } else
#line 100
  if ((int )*(suffix + 0) == 0) {
#line 101
    return ((at_output_write_func )((void *)0));
  }
#line 103
  format = output_formats;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! format->name) {
#line 103
      goto while_break;
    }
    {
#line 105
    tmp = strgicmp((char const   *)suffix, format->name);
    }
#line 105
    if (tmp) {
#line 107
      return (format->writer);
    }
#line 103
    format ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return ((at_output_write_func )((void *)0));
}
}
#line 117 "output.c"
char **at_output_list_new(void) 
{ 
  char **list ;
  int count_out ;
  int count ;
  int i ;
  struct output_format_entry *entry ;
  void *tmp ;

  {
#line 121
  count_out = 0;
#line 129
  entry = output_formats;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! entry->name) {
#line 129
      goto while_break;
    }
#line 130
    count_out ++;
#line 129
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  count = count_out;
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 158
    tmp = malloc(sizeof(char *) * (unsigned long )(2 * count + 1));
#line 158
    list = (char **)tmp;
    }
#line 158
    if (! list) {
      {
#line 158
      __assert_fail("list", "output.c", 158U, "at_output_list_new");
      }
    }
#line 158
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 160
  entry = output_formats;
#line 161
  i = 0;
  {
#line 161
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 161
    if (! (i < count_out)) {
#line 161
      goto while_break___1;
    }
#line 163
    *(list + 2 * i) = (char *)(entry + i)->name;
#line 164
    *(list + (2 * i + 1)) = (char *)(entry + i)->descr;
#line 161
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 187
  *(list + 2 * i) = (char *)((void *)0);
#line 188
  return (list);
}
}
#line 191 "output.c"
void at_output_list_free(char **list ) 
{ 


  {
  {
#line 194
  free((void *)list);
  }
#line 195
  return;
}
}
#line 197 "output.c"
char *at_output_shortlist(void) 
{ 
  char *list ;
  int count ;
  size_t length ;
  int i ;
  struct output_format_entry *entry ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 201
  count = 0;
#line 202
  length = (size_t )0;
#line 211
  entry = output_formats;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! entry->name) {
#line 211
      goto while_break;
    }
    {
#line 213
    count ++;
#line 214
    tmp = strlen(entry->name);
#line 214
    length += tmp + 2UL;
#line 211
    entry ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 240
    tmp___0 = malloc(sizeof(char ) * ((length + 1UL) + 2UL));
#line 240
    list = (char *)tmp___0;
    }
#line 240
    if (! list) {
      {
#line 240
      __assert_fail("list", "output.c", 240U, "at_output_shortlist");
      }
    }
#line 240
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 242
  entry = output_formats;
#line 243
  strcpy((char */* __restrict  */)list, (char const   */* __restrict  */)((char *)(entry + 0)->name));
#line 244
  i = 1;
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (! (i < count - 1)) {
#line 244
      goto while_break___1;
    }
    {
#line 246
    strcat((char */* __restrict  */)list, (char const   */* __restrict  */)", ");
#line 247
    strcat((char */* __restrict  */)list, (char const   */* __restrict  */)((char *)(entry + i)->name));
#line 244
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 271
  strcat((char */* __restrict  */)list, (char const   */* __restrict  */)" or ");
#line 272
  strcat((char */* __restrict  */)list, (char const   */* __restrict  */)((char *)(entry + i)->name));
  }
#line 273
  return (list);
}
}
#line 276 "output.c"
int at_output_add_handler(at_string suffix , at_string description , int (*func)(FILE * ,
                                                                                 at_string name ,
                                                                                 int llx ,
                                                                                 int lly ,
                                                                                 int urx ,
                                                                                 int ury ,
                                                                                 at_output_opts_type *opts ,
                                                                                 at_spline_list_array_type shape ,
                                                                                 void (*msg_func)(at_string msg ,
                                                                                                  at_msg_type msg_type ,
                                                                                                  at_address client_data ) ,
                                                                                 at_address msg_data ) ) 
{ 


  {
#line 281
  return (0);
}
}
#line 284 "output.c"
void at_spline_list_foreach(at_spline_list_type *list , void (*func)(at_spline_list_type *spline_list ,
                                                                     at_spline_type *spline ,
                                                                     int index , at_address user_data ) ,
                            at_address user_data ) 
{ 
  unsigned int i ;

  {
#line 290
  i = 0U;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i < list->length)) {
#line 290
      goto while_break;
    }
    {
#line 292
    (*func)(list, list->data + i, (int )i, user_data);
#line 290
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return;
}
}
#line 297 "output.c"
void at_spline_list_array_foreach(at_spline_list_array_type *list_array , void (*func)(at_spline_list_array_type *spline_list_array ,
                                                                                       at_spline_list_type *spline_list ,
                                                                                       int index ,
                                                                                       at_address user_data ) ,
                                  at_address user_data ) 
{ 
  unsigned int i ;

  {
#line 303
  i = 0U;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (i < list_array->length)) {
#line 303
      goto while_break;
    }
    {
#line 305
    (*func)(list_array, list_array->data + i, (int )i, user_data);
#line 303
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  return;
}
}
#line 42 "output-cgm.c"
static at_bool write16___0(FILE *fdes , UI16 data ) 
{ 
  size_t count ;
  UI8 outch ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 44
  count = (size_t )0;
#line 47
  outch = (UI8 )(((int )data >> 8) & 255);
#line 48
  tmp = fwrite((void const   */* __restrict  */)(& outch), (size_t )1, (size_t )1,
               (FILE */* __restrict  */)fdes);
#line 48
  count += tmp;
#line 50
  outch = (UI8 )((int )data & 255);
#line 51
  tmp___0 = fwrite((void const   */* __restrict  */)(& outch), (size_t )1, (size_t )1,
                   (FILE */* __restrict  */)fdes);
#line 51
  count += tmp___0;
  }
#line 53
  if (count == sizeof(UI16 )) {
#line 53
    tmp___1 = 1;
  } else {
#line 53
    tmp___1 = 0;
  }
#line 53
  return ((at_bool )tmp___1);
}
}
#line 56 "output-cgm.c"
static at_bool write8(FILE *fdes , UI8 data ) 
{ 
  size_t count ;
  int tmp ;

  {
  {
#line 58
  count = (size_t )0;
#line 60
  count = fwrite((void const   */* __restrict  */)(& data), (size_t )1, (size_t )1,
                 (FILE */* __restrict  */)fdes);
  }
#line 62
  if (count == sizeof(UI8 )) {
#line 62
    tmp = 1;
  } else {
#line 62
    tmp = 0;
  }
#line 62
  return ((at_bool )tmp);
}
}
#line 66 "output-cgm.c"
static at_bool output_beginmetafilename(FILE *fdes , char const   *string ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 68
  tmp = strlen(string);
#line 68
  len = (int )tmp;
  }
#line 70
  if (len + 1 < 31) {
    {
#line 71
    write16___0(fdes, (UI16 )((32 + len) + 1));
    }
  } else {
    {
#line 74
    write16___0(fdes, (UI16 )63);
#line 75
    write16___0(fdes, (UI16 )(len + 1));
    }
  }
  {
#line 78
  write8(fdes, (UI8 )len);
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! ((int const   )*string != 0)) {
#line 80
      goto while_break;
    }
    {
#line 82
    write8(fdes, (UI8 )*string);
#line 83
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  if (len % 2 == 0) {
    {
#line 87
    write8(fdes, (UI8 )0);
    }
  }
#line 90
  return ((at_bool )1);
}
}
#line 93 "output-cgm.c"
static at_bool output_beginpicture(FILE *fdes , char const   *string ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 95
  tmp = strlen(string);
#line 95
  len = (int )tmp;
  }
#line 97
  if (len + 1 < 31) {
    {
#line 98
    write16___0(fdes, (UI16 )((96 + len) + 1));
    }
  } else {
    {
#line 101
    write16___0(fdes, (UI16 )127);
#line 102
    write16___0(fdes, (UI16 )(len + 1));
    }
  }
  {
#line 105
  write8(fdes, (UI8 )len);
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! ((int const   )*string != 0)) {
#line 107
      goto while_break;
    }
    {
#line 109
    write8(fdes, (UI8 )*string);
#line 110
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  if (len % 2 == 0) {
    {
#line 114
    write8(fdes, (UI8 )0);
    }
  }
#line 117
  return ((at_bool )1);
}
}
#line 120 "output-cgm.c"
static at_bool output_metafiledescription(FILE *fdes , char const   *string ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 122
  tmp = strlen(string);
#line 122
  len = (int )tmp;
  }
#line 124
  if (len + 1 < 31) {
    {
#line 125
    write16___0(fdes, (UI16 )((4160 + len) + 1));
    }
  } else {
    {
#line 128
    write16___0(fdes, (UI16 )4191);
#line 129
    write16___0(fdes, (UI16 )(len + 1));
    }
  }
  {
#line 132
  write8(fdes, (UI8 )len);
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((int const   )*string != 0)) {
#line 134
      goto while_break;
    }
    {
#line 136
    write8(fdes, (UI8 )*string);
#line 137
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (len % 2 == 0) {
    {
#line 141
    write8(fdes, (UI8 )0);
    }
  }
#line 144
  return ((at_bool )1);
}
}
#line 147 "output-cgm.c"
int output_cgm_writer(FILE *cgm_file , at_string name , int llx , int lly , int urx ,
                      int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) 
{ 
  unsigned int this_list ;
  char *des ;
  char const   *version_string ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  unsigned int this_spline ;
  spline_list_type list ;
  spline_type s ;

  {
  {
#line 156
  tmp = at_version((at_bool )1);
#line 156
  version_string = tmp;
#line 158
  output_beginmetafilename(cgm_file, (char const   *)name);
#line 160
  write16___0(cgm_file, (UI16 )4130);
#line 161
  write16___0(cgm_file, (UI16 )2);
#line 163
  tmp___0 = strlen("created by ");
#line 163
  tmp___1 = strlen(version_string);
#line 163
  tmp___2 = malloc((tmp___0 + tmp___1) + 1UL);
#line 163
  des = (char *)tmp___2;
#line 164
  strcpy((char */* __restrict  */)des, (char const   */* __restrict  */)"created by ");
#line 165
  strcat((char */* __restrict  */)des, (char const   */* __restrict  */)version_string);
#line 166
  output_metafiledescription(cgm_file, (char const   *)des);
#line 167
  free((void *)des);
#line 169
  write16___0(cgm_file, (UI16 )4454);
#line 170
  write16___0(cgm_file, (UI16 )1);
#line 171
  write16___0(cgm_file, (UI16 )65535);
#line 172
  write16___0(cgm_file, (UI16 )1);
#line 174
  output_beginpicture(cgm_file, "pic1");
#line 176
  write16___0(cgm_file, (UI16 )8258);
#line 177
  write16___0(cgm_file, (UI16 )1);
#line 179
  write16___0(cgm_file, (UI16 )8392);
#line 180
  write16___0(cgm_file, (UI16 )llx);
#line 181
  write16___0(cgm_file, (UI16 )urx);
#line 182
  write16___0(cgm_file, (UI16 )ury);
#line 183
  write16___0(cgm_file, (UI16 )lly);
#line 185
  write16___0(cgm_file, (UI16 )128);
#line 188
  this_list = 0U;
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (this_list < shape.length)) {
#line 188
      goto while_break;
    }
#line 193
    list = *(shape.data + this_list);
#line 195
    if (this_list > 0U) {
#line 197
      if (shape.centerline) {
        {
#line 198
        write16___0(cgm_file, (UI16 )512);
        }
      } else {
        {
#line 200
        write16___0(cgm_file, (UI16 )288);
        }
      }
    }
#line 203
    if (shape.centerline) {
      {
#line 204
      write16___0(cgm_file, (UI16 )20611);
      }
    } else {
      {
#line 206
      write16___0(cgm_file, (UI16 )21219);
      }
    }
#line 209
    if (list.clockwise) {
#line 209
      if ((unsigned long )shape.background_color != (unsigned long )((void *)0)) {
        {
#line 211
        write8(cgm_file, (shape.background_color)->r);
#line 212
        write8(cgm_file, (shape.background_color)->g);
#line 213
        write8(cgm_file, (shape.background_color)->b);
        }
      } else {
        {
#line 217
        write8(cgm_file, list.color.r);
#line 218
        write8(cgm_file, list.color.g);
#line 219
        write8(cgm_file, list.color.b);
        }
      }
    } else {
      {
#line 217
      write8(cgm_file, list.color.r);
#line 218
      write8(cgm_file, list.color.g);
#line 219
      write8(cgm_file, list.color.b);
      }
    }
    {
#line 221
    write8(cgm_file, (UI8 )0);
    }
#line 223
    if (shape.centerline) {
      {
#line 225
      write16___0(cgm_file, (UI16 )21442);
#line 226
      write16___0(cgm_file, (UI16 )1);
      }
    } else {
      {
#line 230
      write16___0(cgm_file, (UI16 )21186);
#line 231
      write16___0(cgm_file, (UI16 )1);
      }
    }
#line 234
    if (shape.centerline) {
      {
#line 235
      write16___0(cgm_file, (UI16 )480);
      }
    } else {
      {
#line 237
      write16___0(cgm_file, (UI16 )256);
      }
    }
#line 239
    this_spline = 0U;
    {
#line 239
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 239
      if (! (this_spline < list.length)) {
#line 239
        goto while_break___0;
      }
#line 242
      s = *(list.data + this_spline);
#line 244
      if ((unsigned int )s.degree == 1U) {
        {
#line 246
        write16___0(cgm_file, (UI16 )16424);
#line 247
        write16___0(cgm_file, (UI16 )s.v[0].x);
#line 248
        write16___0(cgm_file, (UI16 )(ury - (int )((UI16 )s.v[0].y)));
#line 249
        write16___0(cgm_file, (UI16 )s.v[3].x);
#line 250
        write16___0(cgm_file, (UI16 )(ury - (int )((UI16 )s.v[3].y)));
        }
      } else {
        {
#line 254
        write16___0(cgm_file, (UI16 )17234);
#line 255
        write16___0(cgm_file, (UI16 )2);
#line 256
        write16___0(cgm_file, (UI16 )s.v[0].x);
#line 257
        write16___0(cgm_file, (UI16 )(ury - (int )((UI16 )s.v[0].y)));
#line 258
        write16___0(cgm_file, (UI16 )s.v[1].x);
#line 259
        write16___0(cgm_file, (UI16 )(ury - (int )((UI16 )s.v[1].y)));
#line 260
        write16___0(cgm_file, (UI16 )s.v[2].x);
#line 261
        write16___0(cgm_file, (UI16 )(ury - (int )((UI16 )s.v[2].y)));
#line 262
        write16___0(cgm_file, (UI16 )s.v[3].x);
#line 263
        write16___0(cgm_file, (UI16 )(ury - (int )((UI16 )s.v[3].y)));
        }
      }
#line 239
      this_spline ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 188
    this_list ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  if (shape.length > 0U) {
#line 270
    if (shape.centerline) {
      {
#line 271
      write16___0(cgm_file, (UI16 )512);
      }
    } else {
      {
#line 273
      write16___0(cgm_file, (UI16 )288);
      }
    }
  }
  {
#line 276
  write16___0(cgm_file, (UI16 )160);
#line 278
  write16___0(cgm_file, (UI16 )64);
  }
#line 280
  return (0);
}
}
#line 49 "quantize.h"
void quantize(bitmap_type *image , long ncolors , color_type const   *bgColor , QuantizeObj **iQuant ,
              at_exception_type *exp ) ;
#line 52
void quantize_object_free(QuantizeObj *quantobj ) ;
#line 63 "median.c"
static void zero_histogram_rgb(Histogram histogram ) 
{ 
  int r ;
  int g ;
  int b ;

  {
#line 66
  r = 0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (r < 1 << 7)) {
#line 66
      goto while_break;
    }
#line 67
    g = 0;
    {
#line 67
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 67
      if (! (g < 1 << 7)) {
#line 67
        goto while_break___0;
      }
#line 68
      b = 0;
      {
#line 68
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 68
        if (! (b < 1 << 7)) {
#line 68
          goto while_break___1;
        }
#line 69
        *(histogram + (((r * (1 << 7)) * (1 << 7) + g * (1 << 7)) + b)) = (ColorFreq )0;
#line 68
        b ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 67
      g ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 66
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72 "median.c"
static void generate_histogram_rgb(Histogram histogram , bitmap_type *image , color_type const   *ignoreColor ) 
{ 
  unsigned char *src ;
  int num_elems ;
  ColorFreq *col ;
  int tmp ;

  {
  {
#line 75
  src = image->bitmap;
#line 79
  num_elems = (int )image->width * (int )image->height;
#line 81
  zero_histogram_rgb(histogram);
  }
  {
#line 85
  if (image->np == 3U) {
#line 85
    goto case_3;
  }
#line 107
  if (image->np == 1U) {
#line 107
    goto case_1;
  }
#line 117
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    tmp = num_elems;
#line 86
    num_elems --;
#line 86
    if (! tmp) {
#line 86
      goto while_break;
    }
#line 89
    if (ignoreColor) {
#line 91
      if ((int )*(src + 0) == (int )ignoreColor->r) {
#line 91
        if ((int )*(src + 1) == (int )ignoreColor->g) {
#line 91
          if ((int )*(src + 2) == (int )ignoreColor->b) {
#line 95
            src += 3;
#line 96
            goto while_continue;
          }
        }
      }
    }
#line 99
    col = histogram + (((((int )*(src + 0) >> 1) * (1 << 7)) * (1 << 7) + ((int )*(src + 1) >> 1) * (1 << 7)) + ((int )*(src + 2) >> 1));
#line 102
    (*col) ++;
#line 103
    src += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 108
    num_elems --;
#line 108
    if (! (num_elems >= 0)) {
#line 108
      goto while_break___0;
    }
#line 110
    if (ignoreColor) {
#line 110
      if ((int )*(src + num_elems) == (int )ignoreColor->r) {
#line 110
        goto while_continue___0;
      }
    }
#line 111
    col = histogram + (((((int )*(src + num_elems) >> 1) * (1 << 7)) * (1 << 7) + ((int )*(src + num_elems) >> 1) * (1 << 7)) + ((int )*(src + num_elems) >> 1));
#line 114
    (*col) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 116
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 123 "median.c"
static boxptr find_biggest_volume(boxptr boxlist , int numboxes ) 
{ 
  boxptr boxp ;
  int i ;
  int maxv ;
  boxptr which ;

  {
#line 129
  maxv = 0;
#line 130
  which = (boxptr )0;
#line 132
  i = 0;
#line 132
  boxp = boxlist;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i < numboxes)) {
#line 132
      goto while_break;
    }
#line 133
    if (boxp->volume > maxv) {
#line 134
      which = boxp;
#line 135
      maxv = boxp->volume;
    }
#line 132
    i ++;
#line 132
    boxp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return (which);
}
}
#line 143 "median.c"
static void update_box_rgb(Histogram histogram , boxptr boxp ) 
{ 
  ColorFreq *histp ;
  int R ;
  int G ;
  int B ;
  int Rmin ;
  int Rmax ;
  int Gmin ;
  int Gmax ;
  int Bmin ;
  int Bmax ;
  int dist0 ;
  int dist1 ;
  int dist2 ;
  long ccount ;
  ColorFreq *tmp ;
  ColorFreq *tmp___0 ;
  ColorFreq *tmp___1 ;
  ColorFreq *tmp___2 ;

  {
#line 153
  Rmin = boxp->Rmin;
#line 154
  Rmax = boxp->Rmax;
#line 155
  Gmin = boxp->Gmin;
#line 156
  Gmax = boxp->Gmax;
#line 157
  Bmin = boxp->Bmin;
#line 158
  Bmax = boxp->Bmax;
#line 160
  if (Rmax > Rmin) {
#line 161
    R = Rmin;
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if (! (R <= Rmax)) {
#line 161
        goto while_break;
      }
#line 162
      G = Gmin;
      {
#line 162
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 162
        if (! (G <= Gmax)) {
#line 162
          goto while_break___0;
        }
#line 163
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 164
        B = Bmin;
        {
#line 164
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 164
          if (! (B <= Bmax)) {
#line 164
            goto while_break___1;
          }
#line 165
          tmp = histp;
#line 165
          histp ++;
#line 165
          if (*tmp != 0UL) {
#line 166
            Rmin = R;
#line 166
            boxp->Rmin = Rmin;
#line 167
            goto have_Rmin;
          }
#line 164
          B ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 162
        G ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 161
      R ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  have_Rmin: 
#line 171
  if (Rmax > Rmin) {
#line 172
    R = Rmax;
    {
#line 172
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 172
      if (! (R >= Rmin)) {
#line 172
        goto while_break___2;
      }
#line 173
      G = Gmin;
      {
#line 173
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 173
        if (! (G <= Gmax)) {
#line 173
          goto while_break___3;
        }
#line 174
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 175
        B = Bmin;
        {
#line 175
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 175
          if (! (B <= Bmax)) {
#line 175
            goto while_break___4;
          }
#line 176
          tmp___0 = histp;
#line 176
          histp ++;
#line 176
          if (*tmp___0 != 0UL) {
#line 177
            Rmax = R;
#line 177
            boxp->Rmax = Rmax;
#line 178
            goto have_Rmax;
          }
#line 175
          B ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 173
        G ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 172
      R --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  have_Rmax: 
#line 182
  if (Gmax > Gmin) {
#line 183
    G = Gmin;
    {
#line 183
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 183
      if (! (G <= Gmax)) {
#line 183
        goto while_break___5;
      }
#line 184
      R = Rmin;
      {
#line 184
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 184
        if (! (R <= Rmax)) {
#line 184
          goto while_break___6;
        }
#line 185
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 186
        B = Bmin;
        {
#line 186
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 186
          if (! (B <= Bmax)) {
#line 186
            goto while_break___7;
          }
#line 187
          tmp___1 = histp;
#line 187
          histp ++;
#line 187
          if (*tmp___1 != 0UL) {
#line 188
            Gmin = G;
#line 188
            boxp->Gmin = Gmin;
#line 189
            goto have_Gmin;
          }
#line 186
          B ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 184
        R ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 183
      G ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  have_Gmin: 
#line 193
  if (Gmax > Gmin) {
#line 194
    G = Gmax;
    {
#line 194
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 194
      if (! (G >= Gmin)) {
#line 194
        goto while_break___8;
      }
#line 195
      R = Rmin;
      {
#line 195
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 195
        if (! (R <= Rmax)) {
#line 195
          goto while_break___9;
        }
#line 196
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 197
        B = Bmin;
        {
#line 197
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 197
          if (! (B <= Bmax)) {
#line 197
            goto while_break___10;
          }
#line 198
          tmp___2 = histp;
#line 198
          histp ++;
#line 198
          if (*tmp___2 != 0UL) {
#line 199
            Gmax = G;
#line 199
            boxp->Gmax = Gmax;
#line 200
            goto have_Gmax;
          }
#line 197
          B ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 195
        R ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 194
      G --;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  have_Gmax: 
#line 204
  if (Bmax > Bmin) {
#line 205
    B = Bmin;
    {
#line 205
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 205
      if (! (B <= Bmax)) {
#line 205
        goto while_break___11;
      }
#line 206
      R = Rmin;
      {
#line 206
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 206
        if (! (R <= Rmax)) {
#line 206
          goto while_break___12;
        }
#line 207
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + Gmin * (1 << 7)) + B;
#line 208
        G = Gmin;
        {
#line 208
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 208
          if (! (G <= Gmax)) {
#line 208
            goto while_break___13;
          }
#line 209
          if (*histp != 0UL) {
#line 210
            Bmin = B;
#line 210
            boxp->Bmin = Bmin;
#line 211
            goto have_Bmin;
          }
#line 208
          G ++;
#line 208
          histp += 1 << 7;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 206
        R ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 205
      B ++;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  have_Bmin: 
#line 215
  if (Bmax > Bmin) {
#line 216
    B = Bmax;
    {
#line 216
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 216
      if (! (B >= Bmin)) {
#line 216
        goto while_break___14;
      }
#line 217
      R = Rmin;
      {
#line 217
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 217
        if (! (R <= Rmax)) {
#line 217
          goto while_break___15;
        }
#line 218
        histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + Gmin * (1 << 7)) + B;
#line 219
        G = Gmin;
        {
#line 219
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 219
          if (! (G <= Gmax)) {
#line 219
            goto while_break___16;
          }
#line 220
          if (*histp != 0UL) {
#line 221
            Bmax = B;
#line 221
            boxp->Bmax = Bmax;
#line 222
            goto have_Bmax;
          }
#line 219
          G ++;
#line 219
          histp += 1 << 7;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 217
        R ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 216
      B --;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
  have_Bmax: 
#line 235
  dist0 = Rmax - Rmin;
#line 236
  dist1 = Gmax - Gmin;
#line 237
  dist2 = Bmax - Bmin;
#line 238
  boxp->volume = (dist0 * dist0 + dist1 * dist1) + dist2 * dist2;
#line 241
  ccount = 0L;
#line 242
  R = Rmin;
  {
#line 242
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 242
    if (! (R <= Rmax)) {
#line 242
      goto while_break___17;
    }
#line 243
    G = Gmin;
    {
#line 243
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 243
      if (! (G <= Gmax)) {
#line 243
        goto while_break___18;
      }
#line 244
      histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 245
      B = Bmin;
      {
#line 245
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 245
        if (! (B <= Bmax)) {
#line 245
          goto while_break___19;
        }
#line 246
        if (*histp != 0UL) {
#line 247
          ccount ++;
        }
#line 245
        B ++;
#line 245
        histp ++;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 243
      G ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 242
    R ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 251
  boxp->colorcount = ccount;
#line 252
  return;
}
}
#line 255 "median.c"
static int median_cut_rgb(Histogram histogram , boxptr boxlist , int numboxes , int desired_colors ) 
{ 
  int n ;
  int lb ;
  int R ;
  int G ;
  int B ;
  int cmax ;
  boxptr b1 ;
  boxptr b2 ;

  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (numboxes < desired_colors)) {
#line 263
      goto while_break;
    }
    {
#line 267
    b1 = find_biggest_volume(boxlist, numboxes);
    }
#line 269
    if ((unsigned long )b1 == (unsigned long )((boxptr )0)) {
#line 270
      goto while_break;
    }
#line 271
    b2 = boxlist + numboxes;
#line 273
    b2->Rmax = b1->Rmax;
#line 274
    b2->Gmax = b1->Gmax;
#line 275
    b2->Bmax = b1->Bmax;
#line 276
    b2->Rmin = b1->Rmin;
#line 277
    b2->Gmin = b1->Gmin;
#line 278
    b2->Bmin = b1->Bmin;
#line 283
    R = b1->Rmax - b1->Rmin;
#line 284
    G = b1->Gmax - b1->Gmin;
#line 285
    B = b1->Bmax - b1->Bmin;
#line 288
    cmax = G;
#line 289
    n = 1;
#line 290
    if (R > cmax) {
#line 291
      cmax = R;
#line 292
      n = 0;
    }
#line 294
    if (B > cmax) {
#line 295
      n = 2;
    }
    {
#line 304
    if (n == 0) {
#line 304
      goto case_0;
    }
#line 309
    if (n == 1) {
#line 309
      goto case_1;
    }
#line 314
    if (n == 2) {
#line 314
      goto case_2;
    }
#line 303
    goto switch_break;
    case_0: /* CIL Label */ 
#line 305
    lb = (b1->Rmax + b1->Rmin) / 2;
#line 306
    b1->Rmax = lb;
#line 307
    b2->Rmin = lb + 1;
#line 308
    goto switch_break;
    case_1: /* CIL Label */ 
#line 310
    lb = (b1->Gmax + b1->Gmin) / 2;
#line 311
    b1->Gmax = lb;
#line 312
    b2->Gmin = lb + 1;
#line 313
    goto switch_break;
    case_2: /* CIL Label */ 
#line 315
    lb = (b1->Bmax + b1->Bmin) / 2;
#line 316
    b1->Bmax = lb;
#line 317
    b2->Bmin = lb + 1;
#line 318
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 321
    update_box_rgb(histogram, b1);
#line 322
    update_box_rgb(histogram, b2);
#line 323
    numboxes ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  return (numboxes);
}
}
#line 329 "median.c"
static void compute_color_rgb(QuantizeObj *quantobj , Histogram histogram , boxptr boxp ,
                              int icolor ) 
{ 
  ColorFreq *histp ;
  int R ;
  int G ;
  int B ;
  int Rmin ;
  int Rmax ;
  int Gmin ;
  int Gmax ;
  int Bmin ;
  int Bmax ;
  unsigned long count ;
  unsigned long total ;
  unsigned long Rtotal ;
  unsigned long Gtotal ;
  unsigned long Btotal ;
  ColorFreq *tmp ;

  {
#line 341
  total = 0UL;
#line 342
  Rtotal = 0UL;
#line 343
  Gtotal = 0UL;
#line 344
  Btotal = 0UL;
#line 346
  Rmin = boxp->Rmin;
#line 347
  Rmax = boxp->Rmax;
#line 348
  Gmin = boxp->Gmin;
#line 349
  Gmax = boxp->Gmax;
#line 350
  Bmin = boxp->Bmin;
#line 351
  Bmax = boxp->Bmax;
#line 353
  R = Rmin;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! (R <= Rmax)) {
#line 353
      goto while_break;
    }
#line 354
    G = Gmin;
    {
#line 354
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 354
      if (! (G <= Gmax)) {
#line 354
        goto while_break___0;
      }
#line 355
      histp = ((histogram + (R * (1 << 7)) * (1 << 7)) + G * (1 << 7)) + Bmin;
#line 356
      B = Bmin;
      {
#line 356
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 356
        if (! (B <= Bmax)) {
#line 356
          goto while_break___1;
        }
#line 357
        tmp = histp;
#line 357
        histp ++;
#line 357
        count = *tmp;
#line 357
        if (count != 0UL) {
#line 358
          total += count;
#line 359
          Rtotal += (unsigned long )((R << 1) + ((1 << 1) >> 1)) * count;
#line 360
          Gtotal += (unsigned long )((G << 1) + ((1 << 1) >> 1)) * count;
#line 361
          Btotal += (unsigned long )((B << 1) + ((1 << 1) >> 1)) * count;
        }
#line 356
        B ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 354
      G ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 353
    R ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  quantobj->cmap[icolor].r = (unsigned char )((Rtotal + (total >> 1)) / total);
#line 367
  quantobj->cmap[icolor].g = (unsigned char )((Gtotal + (total >> 1)) / total);
#line 368
  quantobj->cmap[icolor].b = (unsigned char )((Btotal + (total >> 1)) / total);
#line 369
  quantobj->freq[icolor] = total;
#line 370
  return;
}
}
#line 373 "median.c"
static void select_colors_rgb(QuantizeObj *quantobj , Histogram histogram ) 
{ 
  boxptr boxlist ;
  int numboxes ;
  int desired ;
  int i ;
  void *tmp ;

  {
#line 378
  desired = quantobj->desired_number_of_colors;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 382
    tmp = malloc((unsigned long )desired * sizeof(box ));
#line 382
    boxlist = (boxptr )tmp;
    }
#line 382
    if (! boxlist) {
      {
#line 382
      __assert_fail("boxlist", "median.c", 382U, "select_colors_rgb");
      }
    }
#line 382
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  numboxes = 1;
#line 386
  (boxlist + 0)->Rmin = 0;
#line 387
  (boxlist + 0)->Rmax = (1 << 7) - 1;
#line 388
  (boxlist + 0)->Gmin = 0;
#line 389
  (boxlist + 0)->Gmax = (1 << 7) - 1;
#line 390
  (boxlist + 0)->Bmin = 0;
#line 391
  (boxlist + 0)->Bmax = (1 << 7) - 1;
#line 393
  update_box_rgb(histogram, boxlist);
#line 395
  numboxes = median_cut_rgb(histogram, boxlist, numboxes, desired);
#line 396
  quantobj->actual_number_of_colors = numboxes;
#line 398
  i = 0;
  }
  {
#line 398
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 398
    if (! (i < numboxes)) {
#line 398
      goto while_break___0;
    }
    {
#line 399
    compute_color_rgb(quantobj, histogram, boxlist + i, i);
#line 398
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 400
  free((void *)boxlist);
  }
#line 401
  return;
}
}
#line 480 "median.c"
static int find_nearby_colors(QuantizeObj *quantobj , int minR , int minG , int minB ,
                              int *colorlist ) 
{ 
  int numcolors ;
  int maxR ;
  int maxG ;
  int maxB ;
  int centerR ;
  int centerG ;
  int centerB ;
  int i ;
  int x ;
  int ncolors ;
  int minmaxdist ;
  int min_dist ;
  int max_dist ;
  int tdist ;
  int mindist[256] ;
  int tmp ;

  {
#line 491
  numcolors = quantobj->actual_number_of_colors;
#line 495
  min_dist = 0;
#line 504
  maxR = minR + ((1 << 5) - (1 << 1));
#line 505
  centerR = (minR + maxR) >> 1;
#line 506
  maxG = minG + ((1 << 5) - (1 << 1));
#line 507
  centerG = (minG + maxG) >> 1;
#line 508
  maxB = minB + ((1 << 5) - (1 << 1));
#line 509
  centerB = (minB + maxB) >> 1;
#line 519
  minmaxdist = 2147483647;
#line 521
  i = 0;
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
#line 521
    if (! (i < numcolors)) {
#line 521
      goto while_break;
    }
#line 523
    x = (int )quantobj->cmap[i].r;
#line 524
    if (x < minR) {
#line 525
      tdist = (x - minR) << 1;
#line 526
      min_dist = tdist * tdist;
#line 527
      tdist = (x - maxR) << 1;
#line 528
      max_dist = tdist * tdist;
    } else
#line 529
    if (x > maxR) {
#line 530
      tdist = (x - maxR) << 1;
#line 531
      min_dist = tdist * tdist;
#line 532
      tdist = (x - minR) << 1;
#line 533
      max_dist = tdist * tdist;
    } else {
#line 536
      min_dist = 0;
#line 537
      if (x <= centerR) {
#line 538
        tdist = (x - maxR) << 1;
#line 539
        max_dist = tdist * tdist;
      } else {
#line 541
        tdist = (x - minR) << 1;
#line 542
        max_dist = tdist * tdist;
      }
    }
#line 546
    x = (int )quantobj->cmap[i].g;
#line 547
    if (x < minG) {
#line 548
      tdist = (x - minG) * 3;
#line 549
      min_dist += tdist * tdist;
#line 550
      tdist = (x - maxG) * 3;
#line 551
      max_dist += tdist * tdist;
    } else
#line 552
    if (x > maxG) {
#line 553
      tdist = (x - maxG) * 3;
#line 554
      min_dist += tdist * tdist;
#line 555
      tdist = (x - minG) * 3;
#line 556
      max_dist += tdist * tdist;
    } else
#line 559
    if (x <= centerG) {
#line 560
      tdist = (x - maxG) * 3;
#line 561
      max_dist += tdist * tdist;
    } else {
#line 563
      tdist = (x - minG) * 3;
#line 564
      max_dist += tdist * tdist;
    }
#line 568
    x = (int )quantobj->cmap[i].b;
#line 569
    if (x < minB) {
#line 570
      tdist = x - minB;
#line 571
      min_dist += tdist * tdist;
#line 572
      tdist = x - maxB;
#line 573
      max_dist += tdist * tdist;
    } else
#line 574
    if (x > maxB) {
#line 575
      tdist = x - maxB;
#line 576
      min_dist += tdist * tdist;
#line 577
      tdist = x - minB;
#line 578
      max_dist += tdist * tdist;
    } else
#line 581
    if (x <= centerB) {
#line 582
      tdist = x - maxB;
#line 583
      max_dist += tdist * tdist;
    } else {
#line 585
      tdist = x - minB;
#line 586
      max_dist += tdist * tdist;
    }
#line 590
    mindist[i] = min_dist;
#line 591
    if (max_dist < minmaxdist) {
#line 592
      minmaxdist = max_dist;
    }
#line 521
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 599
  ncolors = 0;
#line 600
  i = 0;
  {
#line 600
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 600
    if (! (i < numcolors)) {
#line 600
      goto while_break___0;
    }
#line 601
    if (mindist[i] <= minmaxdist) {
#line 602
      tmp = ncolors;
#line 602
      ncolors ++;
#line 602
      *(colorlist + tmp) = i;
    }
#line 600
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 604
  return (ncolors);
}
}
#line 608 "median.c"
static void find_best_colors(QuantizeObj *quantobj , int minR , int minG , int minB ,
                             int numcolors , int *colorlist , int *bestcolor ) 
{ 
  int iR ;
  int iG ;
  int iB ;
  int i ;
  int icolor ;
  int *bptr ;
  int *cptr ;
  int dist0 ;
  int dist1 ;
  int dist2 ;
  int xx0 ;
  int xx1 ;
  int xx2 ;
  int inR ;
  int inG ;
  int inB ;
  int bestdist[((1 << 4) * (1 << 4)) * (1 << 4)] ;
  int *tmp ;

  {
#line 631
  bptr = bestdist;
#line 632
  i = ((1 << 4) * (1 << 4)) * (1 << 4) - 1;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (! (i >= 0)) {
#line 632
      goto while_break;
    }
#line 633
    tmp = bptr;
#line 633
    bptr ++;
#line 633
    *tmp = 2147483647;
#line 632
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 645
  i = 0;
  {
#line 645
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 645
    if (! (i < numcolors)) {
#line 645
      goto while_break___0;
    }
#line 646
    icolor = *(colorlist + i);
#line 648
    inR = (minR - (int )quantobj->cmap[icolor].r) << 1;
#line 649
    dist0 = inR * inR;
#line 650
    inG = (minG - (int )quantobj->cmap[icolor].g) * 3;
#line 651
    dist0 += inG * inG;
#line 652
    inB = minB - (int )quantobj->cmap[icolor].b;
#line 653
    dist0 += inB * inB;
#line 655
    inR = inR * (2 * ((1 << 1) << 1)) + ((1 << 1) << 1) * ((1 << 1) << 1);
#line 656
    inG = inG * (2 * ((1 << 1) * 3)) + ((1 << 1) * 3) * ((1 << 1) * 3);
#line 657
    inB = inB * (2 * (1 << 1)) + (1 << 1) * (1 << 1);
#line 659
    bptr = bestdist;
#line 660
    cptr = bestcolor;
#line 661
    xx0 = inR;
#line 662
    iR = (1 << 4) - 1;
    {
#line 662
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 662
      if (! (iR >= 0)) {
#line 662
        goto while_break___1;
      }
#line 663
      dist1 = dist0;
#line 664
      xx1 = inG;
#line 665
      iG = (1 << 4) - 1;
      {
#line 665
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 665
        if (! (iG >= 0)) {
#line 665
          goto while_break___2;
        }
#line 666
        dist2 = dist1;
#line 667
        xx2 = inB;
#line 668
        iB = (1 << 4) - 1;
        {
#line 668
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 668
          if (! (iB >= 0)) {
#line 668
            goto while_break___3;
          }
#line 669
          if (dist2 < *bptr) {
#line 670
            *bptr = dist2;
#line 671
            *cptr = icolor;
          }
#line 673
          dist2 += xx2;
#line 674
          xx2 += (2 * (1 << 1)) * (1 << 1);
#line 675
          bptr ++;
#line 676
          cptr ++;
#line 668
          iB --;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 678
        dist1 += xx1;
#line 679
        xx1 += (2 * ((1 << 1) * 3)) * ((1 << 1) * 3);
#line 665
        iG --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 681
      dist0 += xx0;
#line 682
      xx0 += (2 * ((1 << 1) << 1)) * ((1 << 1) << 1);
#line 662
      iR --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 645
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 685
  return;
}
}
#line 687 "median.c"
static void fill_inverse_cmap_rgb(QuantizeObj *quantobj , Histogram histogram , int R ,
                                  int G , int B ) 
{ 
  int minR ;
  int minG ;
  int minB ;
  int iR ;
  int iG ;
  int iB ;
  int *cptr ;
  ColorFreq *cachep ;
  int colorlist[256] ;
  int numcolors ;
  int bestcolor[((1 << 4) * (1 << 4)) * (1 << 4)] ;
  ColorFreq *tmp ;
  int *tmp___0 ;

  {
  {
#line 704
  R >>= 4;
#line 705
  G >>= 4;
#line 706
  B >>= 4;
#line 712
  minR = (R << 5) + ((1 << 1) >> 1);
#line 713
  minG = (G << 5) + ((1 << 1) >> 1);
#line 714
  minB = (B << 5) + ((1 << 1) >> 1);
#line 719
  numcolors = find_nearby_colors(quantobj, minR, minG, minB, colorlist);
#line 722
  find_best_colors(quantobj, minR, minG, minB, numcolors, colorlist, bestcolor);
#line 726
  R <<= 4;
#line 727
  G <<= 4;
#line 728
  B <<= 4;
#line 729
  cptr = bestcolor;
#line 730
  iR = 0;
  }
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 730
    if (! (iR < 1 << 4)) {
#line 730
      goto while_break;
    }
#line 731
    iG = 0;
    {
#line 731
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 731
      if (! (iG < 1 << 4)) {
#line 731
        goto while_break___0;
      }
#line 732
      cachep = histogram + ((((R + iR) * (1 << 7)) * (1 << 7) + (G + iG) * (1 << 7)) + B);
#line 733
      iB = 0;
      {
#line 733
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 733
        if (! (iB < 1 << 4)) {
#line 733
          goto while_break___1;
        }
#line 734
        tmp = cachep;
#line 734
        cachep ++;
#line 734
        tmp___0 = cptr;
#line 734
        cptr ++;
#line 734
        *tmp = (ColorFreq )(*tmp___0 + 1);
#line 733
        iB ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 731
      iG ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 730
    iR ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  return;
}
}
#line 741 "median.c"
static void median_cut_pass1_rgb(QuantizeObj *quantobj , bitmap_type *image , color_type const   *ignoreColor ) 
{ 


  {
  {
#line 744
  generate_histogram_rgb(quantobj->histogram, image, ignoreColor);
#line 745
  select_colors_rgb(quantobj, quantobj->histogram);
  }
#line 746
  return;
}
}
#line 750 "median.c"
static void median_cut_pass2_rgb(QuantizeObj *quantobj , bitmap_type *image , color_type const   *bgColor ) 
{ 
  Histogram histogram ;
  ColorFreq *cachep ;
  int R ;
  int G ;
  int B ;
  int origR ;
  int origG ;
  int origB ;
  int row ;
  int col ;
  int spp ;
  int width ;
  int height ;
  unsigned char *src ;
  unsigned char *dest ;
  color_type bg_color ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  long idx ;

  {
  {
#line 754
  histogram = quantobj->histogram;
#line 759
  spp = (int )image->np;
#line 760
  width = (int )image->width;
#line 761
  height = (int )image->height;
#line 763
  bg_color.r = (unsigned char)255;
#line 763
  bg_color.g = (unsigned char)255;
#line 763
  bg_color.b = (unsigned char)255;
#line 765
  zero_histogram_rgb(histogram);
  }
#line 767
  if (bgColor) {
#line 770
    R = (int )((int const   )bgColor->r >> 1);
#line 771
    G = (int )((int const   )bgColor->g >> 1);
#line 772
    B = (int )((int const   )bgColor->b >> 1);
#line 773
    cachep = histogram + (((R * (1 << 7)) * (1 << 7) + G * (1 << 7)) + B);
#line 774
    if (*cachep == 0UL) {
      {
#line 775
      fill_inverse_cmap_rgb(quantobj, histogram, R, G, B);
      }
    }
#line 776
    bg_color = quantobj->cmap[*cachep - 1UL];
  }
#line 779
  dest = image->bitmap;
#line 779
  src = dest;
#line 780
  if (spp == 3) {
#line 782
    row = 0;
    {
#line 782
    while (1) {
      while_continue: /* CIL Label */ ;
#line 782
      if (! (row < height)) {
#line 782
        goto while_break;
      }
#line 783
      col = 0;
      {
#line 783
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 783
        if (! (col < width)) {
#line 783
          goto while_break___0;
        }
#line 785
        tmp = src;
#line 785
        src ++;
#line 785
        origR = (int )*tmp;
#line 785
        tmp___0 = src;
#line 785
        src ++;
#line 785
        origG = (int )*tmp___0;
#line 785
        tmp___1 = src;
#line 785
        src ++;
#line 785
        origB = (int )*tmp___1;
#line 796
        R = origR >> 1;
#line 797
        G = origG >> 1;
#line 798
        B = origB >> 1;
#line 799
        cachep = histogram + (((R * (1 << 7)) * (1 << 7) + G * (1 << 7)) + B);
#line 802
        if (*cachep == 0UL) {
          {
#line 803
          fill_inverse_cmap_rgb(quantobj, histogram, R, G, B);
          }
        }
#line 806
        *(dest + 0) = quantobj->cmap[*cachep - 1UL].r;
#line 807
        *(dest + 1) = quantobj->cmap[*cachep - 1UL].g;
#line 808
        *(dest + 2) = quantobj->cmap[*cachep - 1UL].b;
#line 813
        if (bgColor) {
#line 813
          if ((int )*(dest + 0) == (int )bg_color.r) {
#line 813
            if ((int )*(dest + 1) == (int )bg_color.g) {
#line 813
              if ((int )*(dest + 2) == (int )bg_color.b) {
#line 816
                *(dest + 0) = (unsigned char )bgColor->r;
#line 817
                *(dest + 1) = (unsigned char )bgColor->g;
#line 818
                *(dest + 2) = (unsigned char )bgColor->b;
              }
            }
          }
        }
#line 820
        dest += 3;
#line 783
        col ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 782
      row ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 824
  if (spp == 1) {
#line 826
    idx = (long )(width * height);
    {
#line 827
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 827
      idx --;
#line 827
      if (! (idx >= 0L)) {
#line 827
        goto while_break___1;
      }
#line 829
      origR = (int )*(src + idx);
#line 830
      R = origR >> 1;
#line 830
      G = origR >> 1;
#line 830
      B = origR >> 1;
#line 831
      cachep = histogram + (((R * (1 << 7)) * (1 << 7) + G * (1 << 7)) + B);
#line 832
      if (*cachep == 0UL) {
        {
#line 833
        fill_inverse_cmap_rgb(quantobj, histogram, R, G, B);
        }
      }
#line 835
      *(dest + idx) = quantobj->cmap[*cachep - 1UL].r;
#line 840
      if (bgColor) {
#line 840
        if ((int )*(dest + idx) == (int )bg_color.r) {
#line 841
          *(dest + idx) = (unsigned char )bgColor->r;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 844
  return;
}
}
#line 847 "median.c"
static QuantizeObj *initialize_median_cut(int num_colors ) 
{ 
  QuantizeObj *quantobj ;
  void *tmp ;
  void *tmp___1 ;

  {
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 852
    tmp = malloc(sizeof(QuantizeObj ));
#line 852
    quantobj = (QuantizeObj *)tmp;
    }
#line 852
    if (! quantobj) {
      {
#line 852
      __assert_fail("quantobj", "median.c", 852U, "initialize_median_cut");
      }
    }
#line 852
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 854
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 854
    tmp___1 = malloc(((sizeof(ColorFreq ) * (unsigned long )(1 << 7)) * (unsigned long )(1 << 7)) * (unsigned long )(1 << 7));
#line 854
    quantobj->histogram = (Histogram )tmp___1;
    }
#line 854
    if (! quantobj->histogram) {
      {
#line 854
      __assert_fail("quantobj->histogram", "median.c", 857U, "initialize_median_cut");
      }
    }
#line 854
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 858
  quantobj->desired_number_of_colors = num_colors;
#line 860
  return (quantobj);
}
}
#line 864 "median.c"
void quantize(bitmap_type *image , long ncolors , color_type const   *bgColor , QuantizeObj **iQuant ,
              at_exception_type *exp ) 
{ 
  QuantizeObj *quantobj ;
  unsigned int spp ;

  {
#line 868
  spp = image->np;
#line 870
  if (spp != 3U) {
#line 870
    if (spp != 1U) {
      {
#line 872
      while (1) {
        while_continue: /* CIL Label */ ;
#line 872
        if (at_log_file) {
          {
#line 872
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"quantize: %u-plane images are not supported",
                  spp);
          }
        }
#line 872
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 873
      at_exception_fatal(exp, (at_string const   )"quantize: wrong plane images are passed");
      }
#line 874
      return;
    }
  }
#line 878
  if (iQuant) {
#line 880
    if ((unsigned long )*iQuant == (unsigned long )((void *)0)) {
      {
#line 882
      quantobj = initialize_median_cut((int )ncolors);
#line 883
      median_cut_pass1_rgb(quantobj, image, bgColor);
#line 884
      *iQuant = quantobj;
      }
    } else {
#line 887
      quantobj = *iQuant;
    }
  } else {
    {
#line 891
    quantobj = initialize_median_cut((int )ncolors);
#line 892
    median_cut_pass1_rgb(quantobj, image, (color_type const   *)((void *)0));
    }
  }
  {
#line 896
  median_cut_pass2_rgb(quantobj, image, bgColor);
  }
#line 898
  if ((unsigned long )iQuant == (unsigned long )((void *)0)) {
    {
#line 899
    quantize_object_free(quantobj);
    }
  }
#line 900
  return;
}
}
#line 902 "median.c"
void quantize_object_free(QuantizeObj *quantobj ) 
{ 


  {
  {
#line 905
  free((void *)quantobj->histogram);
#line 906
  free((void *)quantobj);
  }
#line 907
  return;
}
}
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 273 "autotrace.h"
at_fitting_opts_type *at_fitting_opts_new(void) ;
#line 275
void at_fitting_opts_free(at_fitting_opts_type *opts ) ;
#line 285
at_input_opts_type *at_input_opts_new(void) ;
#line 287
void at_input_opts_free(at_input_opts_type *opts ) ;
#line 294
at_output_opts_type *at_output_opts_new(void) ;
#line 296
void at_output_opts_free(at_output_opts_type *opts ) ;
#line 314
at_bitmap_type *at_bitmap_read(at_bitmap_type (*input_reader___0)(at_string name ,
                                                                  at_input_opts_type *opts ,
                                                                  void (*msg_func)(at_string msg ,
                                                                                   at_msg_type msg_type ,
                                                                                   at_address client_data ) ,
                                                                  at_address msg_data ) ,
                               at_string filename___0 , at_input_opts_type *opts ,
                               void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                at_address client_data ) , at_address msg_data ) ;
#line 326
unsigned short at_bitmap_get_width(at_bitmap_type *bitmap ) ;
#line 327
unsigned short at_bitmap_get_height(at_bitmap_type *bitmap ) ;
#line 328
unsigned short at_bitmap_get_planes(at_bitmap_type *bitmap ) ;
#line 329
void at_bitmap_free(at_bitmap_type *bitmap ) ;
#line 375
at_spline_list_array_type *at_splines_new_full(at_bitmap_type *bitmap , at_fitting_opts_type *opts ,
                                               void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                                at_address client_data ) ,
                                               at_address msg_data , void (*notify_progress)(at_real percentage ,
                                                                                             at_address client_data ) ,
                                               at_address progress_data , at_bool (*test_cancel)(at_address client_data ) ,
                                               at_address testcancel_data ) ;
#line 384
void at_splines_write(int (*output_writer___0)(FILE * , at_string name , int llx ,
                                               int lly , int urx , int ury , at_output_opts_type *opts ,
                                               at_spline_list_array_type shape , void (*msg_func)(at_string msg ,
                                                                                                  at_msg_type msg_type ,
                                                                                                  at_address client_data ) ,
                                               at_address msg_data ) , FILE *writeto ,
                      at_string file_name , at_output_opts_type *opts , at_spline_list_array_type *splines ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) ;
#line 391
void at_splines_free(at_spline_list_array_type *splines ) ;
#line 396
at_color_type *at_color_new(unsigned char r , unsigned char g , unsigned char b ) ;
#line 399
at_color_type *at_color_copy(at_color_type *original ) ;
#line 406
at_input_read_func at_input_get_handler(at_string filename___0 ) ;
#line 407
at_input_read_func at_input_get_handler_by_suffix(at_string suffix ) ;
#line 409
char **at_input_list_new(void) ;
#line 410
void at_input_list_free(char **list ) ;
#line 414
char *at_input_shortlist(void) ;
#line 444
char const   *at_home_site(void) ;
#line 101 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 31 "getopt.h"
char *optarg ;
#line 45
int optind ;
#line 92
int getopt_long_only(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                     int *opt_index ) ;
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 32 "filename.h"
at_string extend_filename(at_string name , at_string default_suffix ) ;
#line 40
at_string remove_suffix(at_string s ) ;
#line 7 "atou.h"
unsigned int atou(at_string s ) ;
#line 23 "main.c"
static at_bitmap_type (*input_reader)(at_string name , at_input_opts_type *opts ,
                                      void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                       at_address client_data ) ,
                                      at_address msg_data )  =    (at_bitmap_type (*)(at_string name , at_input_opts_type *opts , void (*msg_func)(at_string msg ,
                                                                                    at_msg_type msg_type ,
                                                                                    at_address client_data ) ,
                       at_address msg_data ))((void *)0);
#line 28
static char *get_basename(char *name ) ;
#line 31 "main.c"
static char *output_name  =    (char *)"";
#line 34 "main.c"
static int (*output_writer)(FILE * , at_string name , int llx , int lly , int urx ,
                            int ury , at_output_opts_type *opts , at_spline_list_array_type shape ,
                            void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                             at_address client_data ) , at_address msg_data )  =    (int (*)(FILE * ,
            at_string name , int llx , int lly , int urx , int ury , at_output_opts_type *opts ,
            at_spline_list_array_type shape , void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                               at_address client_data ) ,
            at_address msg_data ))((void *)0);
#line 37 "main.c"
static at_bool printed_version  ;
#line 40 "main.c"
static at_bool logging  =    (at_bool )0;
#line 43 "main.c"
static at_bool dumping_bitmap  =    (at_bool )0;
#line 46 "main.c"
static at_bool report_progress  =    (at_bool )0;
#line 49
static void dot_printer(at_real percentage , at_address client_data ) ;
#line 51
static char *read_command_line(int argc , char **argv , at_fitting_opts_type *fitting_opts ,
                               at_output_opts_type *output_opts ) ;
#line 55
static unsigned int hctoi(char c ) ;
#line 57
static void dump(at_bitmap_type *bitmap , FILE *fp ) ;
#line 59
static void input_list_formats(FILE *file ) ;
#line 60
static void output_list_formats(FILE *file ) ;
#line 62
static void exception_handler(at_string msg , at_msg_type type , at_address data ) ;
#line 66 "main.c"
int main(int argc , char **argv ) 
{ 
  at_fitting_opts_type *fitting_opts ;
  at_input_opts_type *input_opts ;
  at_output_opts_type *output_opts ;
  char *input_name ;
  char *input_rootname ;
  char *logfile_name ;
  char *dumpfile_name ;
  at_spline_list_array_type *splines ;
  at_bitmap_type *bitmap ;
  FILE *output_file ;
  FILE *dump_file ;
  void (*progress_reporter)(at_real percentage , at_address client_data ) ;
  int progress_stat ;
  at_bool tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 73
  logfile_name = (char *)((void *)0);
#line 73
  dumpfile_name = (char *)((void *)0);
#line 79
  progress_reporter = (void (*)(at_real percentage , at_address client_data ))((void *)0);
#line 80
  progress_stat = 0;
#line 82
  fitting_opts = at_fitting_opts_new();
#line 83
  output_opts = at_output_opts_new();
#line 84
  input_name = read_command_line(argc, argv, fitting_opts, output_opts);
#line 86
  tmp = strgicmp((char const   *)output_name, (char const   *)input_name);
  }
#line 86
  if (tmp) {
    {
#line 87
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 87
      fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)stderr);
      }
      {
#line 87
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 87
        if (at_log_file) {
          {
#line 87
          fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 87
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 87
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              "Input and output file may not be the same\n");
      }
      {
#line 87
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 87
        if (at_log_file) {
          {
#line 87
          fputs((char const   */* __restrict  */)"Input and output file may not be the same\n",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 87
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 87
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stderr);
#line 87
      exit(1);
      }
#line 87
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 89
  tmp___0 = get_basename(input_name);
#line 89
  input_rootname = remove_suffix(tmp___0);
  }
#line 89
  if ((unsigned long )input_rootname == (unsigned long )((void *)0)) {
    {
#line 90
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 90
      fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)stderr);
      }
      {
#line 90
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 90
        if (at_log_file) {
          {
#line 90
          fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 90
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 90
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not a valid inputname %s",
              input_name);
      }
      {
#line 90
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 90
        if (at_log_file) {
          {
#line 90
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Not a valid inputname %s",
                  input_name);
          }
        }
#line 90
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 90
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stderr);
#line 90
      exit(1);
      }
#line 90
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 92
  if (logging) {
    {
#line 93
    logfile_name = extend_filename(input_rootname, (at_string )"log");
#line 93
    at_log_file = xfopen(logfile_name, (at_string )"w");
    }
  }
#line 101
  if (logging) {
    {
#line 102
    free((void *)logfile_name);
    }
  }
#line 105
  if (! input_reader) {
    {
#line 106
    input_reader = at_input_get_handler(input_name);
    }
  }
#line 111
  if (! output_writer) {
    {
#line 112
    output_writer = at_output_get_handler(output_name);
    }
  }
#line 113
  if (! output_writer) {
    {
#line 115
    output_writer = at_output_get_handler_by_suffix((at_string )"eps");
    }
#line 116
    if ((unsigned long )output_writer == (unsigned long )((void *)0)) {
      {
#line 117
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 117
        fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)stderr);
        }
        {
#line 117
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 117
          if (at_log_file) {
            {
#line 117
            fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)at_log_file);
            }
          }
#line 117
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 117
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Default format %s not supported",
                "eps");
        }
        {
#line 117
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 117
          if (at_log_file) {
            {
#line 117
            fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Default format %s not supported",
                    "eps");
            }
          }
#line 117
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 117
        fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stderr);
#line 117
        exit(1);
        }
#line 117
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
  {
#line 121
  tmp___1 = strcmp((char const   *)output_name, "");
  }
#line 121
  if (tmp___1) {
    {
#line 124
    output_file = xfopen(output_name, (at_string )"wb");
    }
  } else {
#line 122
    output_file = stdout;
  }
#line 127
  if ((unsigned long )input_reader != (unsigned long )((void *)0)) {
    {
#line 129
    input_opts = at_input_opts_new();
    }
#line 130
    if (fitting_opts->background_color) {
      {
#line 131
      input_opts->background_color = at_color_copy(fitting_opts->background_color);
      }
    }
    {
#line 133
    bitmap = at_bitmap_read(input_reader, input_name, input_opts, & exception_handler,
                            (void *)0);
#line 136
    at_input_opts_free(input_opts);
    }
  } else {
    {
#line 139
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 139
      fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)stderr);
      }
      {
#line 139
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 139
        if (at_log_file) {
          {
#line 139
          fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 139
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 139
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              "Unsupported input format");
      }
      {
#line 139
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 139
        if (at_log_file) {
          {
#line 139
          fputs((char const   */* __restrict  */)"Unsupported input format", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 139
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 139
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stderr);
#line 139
      exit(1);
      }
#line 139
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 141
  if (report_progress) {
    {
#line 143
    progress_reporter = & dot_printer;
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-15s",
            input_name);
    }
  }
  {
#line 147
  splines = at_splines_new_full(bitmap, fitting_opts, & exception_handler, (void *)0,
                                progress_reporter, (at_address )(& progress_stat),
                                (at_bool (*)(at_address client_data ))((void *)0),
                                (void *)0);
  }
#line 153
  if (dumping_bitmap) {
    {
#line 155
    dumpfile_name = extend_filename(input_rootname, (at_string )"bitmap");
#line 156
    dump_file = xfopen(dumpfile_name, (at_string )"wb");
#line 157
    dump(bitmap, dump_file);
#line 158
    fclose(dump_file);
    }
  }
  {
#line 161
  at_splines_write(output_writer, output_file, output_name, output_opts, splines,
                   & exception_handler, (void *)0);
#line 167
  at_output_opts_free(output_opts);
  }
#line 169
  if ((unsigned long )output_file != (unsigned long )stdout) {
    {
#line 170
    fclose(output_file);
    }
  }
  {
#line 172
  at_splines_free(splines);
#line 173
  at_bitmap_free(bitmap);
#line 174
  at_fitting_opts_free(fitting_opts);
  }
#line 176
  if (report_progress) {
    {
#line 177
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stderr);
    }
  }
#line 179
  return (0);
}
}
#line 239 "main.c"
static char *read_command_line(int argc , char **argv , at_fitting_opts_type *fitting_opts ,
                               at_output_opts_type *output_opts ) 
{ 
  int g ;
  int option_index ;
  struct option long_options[31] ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int endian ;
  char *str ;
  double tmp___9 ;
  unsigned int tmp___10 ;
  double tmp___11 ;
  char *ishortlist ;
  char *oshortlist ;
  char const   *tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  char const   *tmp___15 ;
  double tmp___16 ;
  at_bool tmp___17 ;
  at_bool tmp___18 ;
  at_bool tmp___19 ;
  at_bool tmp___20 ;
  at_bool tmp___21 ;
  at_bool tmp___22 ;
  at_bool tmp___23 ;
  at_bool tmp___24 ;
  at_bool tmp___25 ;
  at_bool tmp___26 ;
  at_bool tmp___27 ;
  at_bool tmp___28 ;
  at_bool tmp___29 ;
  at_bool tmp___30 ;
  at_bool tmp___31 ;
  at_bool tmp___32 ;
  at_bool tmp___33 ;
  at_bool tmp___34 ;
  at_bool tmp___35 ;
  at_bool tmp___36 ;
  at_bool tmp___37 ;
  at_bool tmp___38 ;
  at_bool tmp___39 ;
  at_bool tmp___40 ;
  at_bool tmp___41 ;
  char const   *tmp___42 ;

  {
#line 246
  long_options[0].name = "align-threshold";
#line 246
  long_options[0].has_arg = 1;
#line 246
  long_options[0].flag = (int *)0;
#line 246
  long_options[0].val = 0;
#line 246
  long_options[1].name = "background-color";
#line 246
  long_options[1].has_arg = 1;
#line 246
  long_options[1].flag = (int *)0;
#line 246
  long_options[1].val = 0;
#line 246
  long_options[2].name = "debug-arch";
#line 246
  long_options[2].has_arg = 0;
#line 246
  long_options[2].flag = (int *)0;
#line 246
  long_options[2].val = 0;
#line 246
  long_options[3].name = "debug-bitmap";
#line 246
  long_options[3].has_arg = 0;
#line 246
  long_options[3].flag = (int *)(& dumping_bitmap);
#line 246
  long_options[3].val = 1;
#line 246
  long_options[4].name = "centerline";
#line 246
  long_options[4].has_arg = 0;
#line 246
  long_options[4].flag = (int *)0;
#line 246
  long_options[4].val = 0;
#line 246
  long_options[5].name = "color-count";
#line 246
  long_options[5].has_arg = 1;
#line 246
  long_options[5].flag = (int *)0;
#line 246
  long_options[5].val = 0;
#line 246
  long_options[6].name = "corner-always-threshold";
#line 246
  long_options[6].has_arg = 1;
#line 246
  long_options[6].flag = (int *)0;
#line 246
  long_options[6].val = 0;
#line 246
  long_options[7].name = "corner-surround";
#line 246
  long_options[7].has_arg = 1;
#line 246
  long_options[7].flag = (int *)0;
#line 246
  long_options[7].val = 0;
#line 246
  long_options[8].name = "corner-threshold";
#line 246
  long_options[8].has_arg = 1;
#line 246
  long_options[8].flag = (int *)0;
#line 246
  long_options[8].val = 0;
#line 246
  long_options[9].name = "despeckle-level";
#line 246
  long_options[9].has_arg = 1;
#line 246
  long_options[9].flag = (int *)0;
#line 246
  long_options[9].val = 0;
#line 246
  long_options[10].name = "despeckle-tightness";
#line 246
  long_options[10].has_arg = 1;
#line 246
  long_options[10].flag = (int *)0;
#line 246
  long_options[10].val = 0;
#line 246
  long_options[11].name = "dpi";
#line 246
  long_options[11].has_arg = 1;
#line 246
  long_options[11].flag = (int *)0;
#line 246
  long_options[11].val = 0;
#line 246
  long_options[12].name = "error-threshold";
#line 246
  long_options[12].has_arg = 1;
#line 246
  long_options[12].flag = (int *)0;
#line 246
  long_options[12].val = 0;
#line 246
  long_options[13].name = "filter-iterations";
#line 246
  long_options[13].has_arg = 1;
#line 246
  long_options[13].flag = (int *)0;
#line 246
  long_options[13].val = 0;
#line 246
  long_options[14].name = "help";
#line 246
  long_options[14].has_arg = 0;
#line 246
  long_options[14].flag = (int *)0;
#line 246
  long_options[14].val = 0;
#line 246
  long_options[15].name = "input-format";
#line 246
  long_options[15].has_arg = 1;
#line 246
  long_options[15].flag = (int *)0;
#line 246
  long_options[15].val = 0;
#line 246
  long_options[16].name = "line-reversion-threshold";
#line 246
  long_options[16].has_arg = 1;
#line 246
  long_options[16].flag = (int *)0;
#line 246
  long_options[16].val = 0;
#line 246
  long_options[17].name = "line-threshold";
#line 246
  long_options[17].has_arg = 1;
#line 246
  long_options[17].flag = (int *)0;
#line 246
  long_options[17].val = 0;
#line 246
  long_options[18].name = "list-output-formats";
#line 246
  long_options[18].has_arg = 0;
#line 246
  long_options[18].flag = (int *)0;
#line 246
  long_options[18].val = 0;
#line 246
  long_options[19].name = "list-input-formats";
#line 246
  long_options[19].has_arg = 0;
#line 246
  long_options[19].flag = (int *)0;
#line 246
  long_options[19].val = 0;
#line 246
  long_options[20].name = "log";
#line 246
  long_options[20].has_arg = 0;
#line 246
  long_options[20].flag = (int *)(& logging);
#line 246
  long_options[20].val = 1;
#line 246
  long_options[21].name = "output-file";
#line 246
  long_options[21].has_arg = 1;
#line 246
  long_options[21].flag = (int *)0;
#line 246
  long_options[21].val = 0;
#line 246
  long_options[22].name = "output-format";
#line 246
  long_options[22].has_arg = 1;
#line 246
  long_options[22].flag = (int *)0;
#line 246
  long_options[22].val = 0;
#line 246
  long_options[23].name = "preserve-width";
#line 246
  long_options[23].has_arg = 0;
#line 246
  long_options[23].flag = (int *)0;
#line 246
  long_options[23].val = 0;
#line 246
  long_options[24].name = "range";
#line 246
  long_options[24].has_arg = 1;
#line 246
  long_options[24].flag = (int *)0;
#line 246
  long_options[24].val = 0;
#line 246
  long_options[25].name = "remove-adjacent-corners";
#line 246
  long_options[25].has_arg = 0;
#line 246
  long_options[25].flag = (int *)0;
#line 246
  long_options[25].val = 0;
#line 246
  long_options[26].name = "tangent-surround";
#line 246
  long_options[26].has_arg = 1;
#line 246
  long_options[26].flag = (int *)0;
#line 246
  long_options[26].val = 0;
#line 246
  long_options[27].name = "report-progress";
#line 246
  long_options[27].has_arg = 0;
#line 246
  long_options[27].flag = (int *)(& report_progress);
#line 246
  long_options[27].val = 1;
#line 246
  long_options[28].name = "version";
#line 246
  long_options[28].has_arg = 0;
#line 246
  long_options[28].flag = (int *)(& printed_version);
#line 246
  long_options[28].val = 1;
#line 246
  long_options[29].name = "width-weight-factor";
#line 246
  long_options[29].has_arg = 1;
#line 246
  long_options[29].flag = (int *)0;
#line 246
  long_options[29].val = 0;
#line 246
  long_options[30].name = (char const   *)0;
#line 246
  long_options[30].has_arg = 0;
#line 246
  long_options[30].flag = (int *)0;
#line 246
  long_options[30].val = 0;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 282
    g = getopt_long_only(argc, (char * const  *)argv, "", (struct option  const  *)(long_options),
                         & option_index);
    }
#line 284
    if (g == -1) {
#line 285
      goto while_break;
    }
#line 287
    if (g == 63) {
      {
#line 288
      exit(1);
      }
    }
#line 290
    if (! (g == 0)) {
      {
#line 290
      __assert_fail("g == 0", "main.c", 290U, "read_command_line");
      }
    }
    {
#line 292
    tmp___41 = strgicmp(long_options[option_index].name, "background-color");
    }
#line 292
    if (tmp___41) {
      {
#line 294
      tmp___0 = strlen((char const   *)optarg);
      }
#line 294
      if (tmp___0 != 6UL) {
        {
#line 295
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 295
          fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)stderr);
          }
          {
#line 295
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 295
            if (at_log_file) {
              {
#line 295
              fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)at_log_file);
              }
            }
#line 295
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 295
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                  "background-color be six chars long");
          }
          {
#line 295
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 295
            if (at_log_file) {
              {
#line 295
              fputs((char const   */* __restrict  */)"background-color be six chars long",
                    (FILE */* __restrict  */)at_log_file);
              }
            }
#line 295
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 295
          fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stderr);
#line 295
          exit(1);
          }
#line 295
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 296
      tmp___1 = hctoi(*(optarg + 4));
#line 296
      tmp___2 = hctoi(*(optarg + 5));
#line 296
      tmp___3 = hctoi(*(optarg + 2));
#line 296
      tmp___4 = hctoi(*(optarg + 3));
#line 296
      tmp___5 = hctoi(*(optarg + 0));
#line 296
      tmp___6 = hctoi(*(optarg + 1));
#line 296
      fitting_opts->background_color = at_color_new((unsigned char )(tmp___5 * 16U + tmp___6),
                                                    (unsigned char )(tmp___3 * 16U + tmp___4),
                                                    (unsigned char )(tmp___1 * 16U + tmp___2));
      }
    } else {
      {
#line 300
      tmp___40 = strgicmp(long_options[option_index].name, "centerline");
      }
#line 300
      if (tmp___40) {
#line 301
        fitting_opts->centerline = (at_bool )1;
      } else {
        {
#line 303
        tmp___39 = strgicmp(long_options[option_index].name, "color-count");
        }
#line 303
        if (tmp___39) {
          {
#line 304
          fitting_opts->color_count = atou(optarg);
          }
        } else {
          {
#line 306
          tmp___38 = strgicmp(long_options[option_index].name, "corner-always-threshold");
          }
#line 306
          if (tmp___38) {
            {
#line 307
            tmp___7 = atof((char const   *)optarg);
#line 307
            fitting_opts->corner_always_threshold = (at_real )tmp___7;
            }
          } else {
            {
#line 309
            tmp___37 = strgicmp(long_options[option_index].name, "corner-surround");
            }
#line 309
            if (tmp___37) {
              {
#line 310
              fitting_opts->corner_surround = atou(optarg);
              }
            } else {
              {
#line 312
              tmp___36 = strgicmp(long_options[option_index].name, "corner-threshold");
              }
#line 312
              if (tmp___36) {
                {
#line 313
                tmp___8 = atof((char const   *)optarg);
#line 313
                fitting_opts->corner_threshold = (at_real )tmp___8;
                }
              } else {
                {
#line 315
                tmp___35 = strgicmp(long_options[option_index].name, "debug-arch");
                }
#line 315
                if (tmp___35) {
#line 317
                  endian = 1;
#line 319
                  if (*((char *)(& endian))) {
#line 320
                    str = (char *)"little";
                  } else {
#line 322
                    str = (char *)"big";
                  }
                  {
#line 324
                  printf((char const   */* __restrict  */)"%d bit, %s endian\n", sizeof(void *) * 8UL,
                         str);
#line 327
                  exit(0);
                  }
                } else {
                  {
#line 330
                  tmp___34 = strgicmp(long_options[option_index].name, "despeckle-level");
                  }
#line 330
                  if (tmp___34) {
                    {
#line 331
                    fitting_opts->despeckle_level = atou(optarg);
                    }
                  } else {
                    {
#line 333
                    tmp___33 = strgicmp(long_options[option_index].name, "despeckle-tightness");
                    }
#line 333
                    if (tmp___33) {
                      {
#line 334
                      tmp___9 = atof((char const   *)optarg);
#line 334
                      fitting_opts->despeckle_tightness = (at_real )tmp___9;
                      }
                    } else {
                      {
#line 336
                      tmp___32 = strgicmp(long_options[option_index].name, "dpi");
                      }
#line 336
                      if (tmp___32) {
                        {
#line 337
                        tmp___10 = atou(optarg);
#line 337
                        output_opts->dpi = (int )tmp___10;
                        }
                      } else {
                        {
#line 339
                        tmp___31 = strgicmp(long_options[option_index].name, "error-threshold");
                        }
#line 339
                        if (tmp___31) {
                          {
#line 340
                          tmp___11 = atof((char const   *)optarg);
#line 340
                          fitting_opts->error_threshold = (at_real )tmp___11;
                          }
                        } else {
                          {
#line 342
                          tmp___30 = strgicmp(long_options[option_index].name, "filter-iterations");
                          }
#line 342
                          if (tmp___30) {
                            {
#line 343
                            fitting_opts->filter_iterations = atou(optarg);
                            }
                          } else {
                            {
#line 345
                            tmp___29 = strgicmp(long_options[option_index].name, "help");
                            }
#line 345
                            if (tmp___29) {
                              {
#line 348
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [options] <input_name>.\n",
                                      *(argv + 0));
#line 349
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:<input_name> should be a supported image.\n  You can use `--\' or `-\' to start an option.\n  You can use any unambiguous abbreviation for an option name.\n  You can separate option names and values with `=\' or ` \'.\nbackground-color <hexadezimal>: the color of the background that\n  should be ignored, for example FFFFFF;\n  default is no background color.\ncenterline: trace a character\'s centerline, rather than its outline.\ncolor-count <unsigned>: number of colors a color bitmap is reduced to,\n  it does not work on grayscale, allowed are 1..256;\n  default is 0, that means not color reduction is done.\ncorner-always-threshold <angle-in-degrees>: if the angle at a pixel is\n  less than this, it is considered a corner, even if it is within\n  `corner-surround\' pixels of another corner; default is 60.\ncorner-surround <unsigned>: number of pixels on either side of a\n  point to consider when determining if that point is a corner;\n  default is 4.\ncorner-threshold <angle-in-degrees>: if a pixel, its predecessor(s),\n  and its successor(s) meet at an angle smaller than this, it\'s a\n  corner; default is 100.\ndespeckle-level <unsigned>: 0..20; default is no despeckling.\ndespeckle-tightness <real>: 0.0..8.0; default is 2.0.\ndpi <unsigned>: The dots per inch value in the input image, affects scaling\n  of mif output image\n");
#line 350
                              oshortlist = at_output_shortlist();
#line 350
                              ishortlist = at_input_shortlist();
#line 350
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error-threshold <real>: subdivide fitted curves that are off by\n  more pixels than this; default is 2.0.\nfilter-iterations <unsigned>: smooth the curve this many times\n  before fitting; default is 4.\ninput-format:  %s. \nhelp: print this message.\nline-reversion-threshold <real>: if a spline is closer to a straight\n  line than this, weighted by the square of the curve length, keep it a\n  straight line even if it is a list with curves; default is .01.\nline-threshold <real>: if the spline is not more than this far away\n  from the straight line defined by its endpoints,\n  then output a straight line; default is 1.\nlist-output-formats: print a list of support output formats to stderr.\nlist-input-formats:  print a list of support input formats to stderr.\nlog: write detailed progress reports to <input_name>.log.\noutput-file <filename>: write to <filename>\noutput-format <format>: use format <format> for the output file\n  %s can be used.\npreserve-width: whether to preserve line width prior to thinning.\nremove-adjacent-corners: remove corners that are adjacent.\ntangent-surround <unsigned>: number of points on either side of a\n  point to consider when computing the tangent at that point; default is 3.\nreport-progress: report tracing status in real time.\ndebug-arch: print the type of cpu.\ndebug-bitmap: dump loaded bitmap to <input_name>.bitmap.\nversion: print the version number of this program.\nwidth-weight-factor <real>: weight factor for fitting the linewidth.\n",
                                      ishortlist, oshortlist);
#line 352
                              free((void *)ishortlist);
#line 353
                              free((void *)oshortlist);
#line 354
                              tmp___12 = at_home_site();
#line 354
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nYou can get the source code of autotrace from \n%s\n",
                                      tmp___12);
#line 357
                              exit(0);
                              }
                            } else {
                              {
#line 360
                              tmp___28 = strgicmp(long_options[option_index].name,
                                                  "input-format");
                              }
#line 360
                              if (tmp___28) {
                                {
#line 362
                                input_reader = at_input_get_handler_by_suffix(optarg);
                                }
#line 363
                                if (! input_reader) {
                                  {
#line 364
                                  while (1) {
                                    while_continue___3: /* CIL Label */ ;
                                    {
#line 364
                                    fputs((char const   */* __restrict  */)"fatal: ",
                                          (FILE */* __restrict  */)stderr);
                                    }
                                    {
#line 364
                                    while (1) {
                                      while_continue___4: /* CIL Label */ ;
#line 364
                                      if (at_log_file) {
                                        {
#line 364
                                        fputs((char const   */* __restrict  */)"fatal: ",
                                              (FILE */* __restrict  */)at_log_file);
                                        }
                                      }
#line 364
                                      goto while_break___4;
                                    }
                                    while_break___4: /* CIL Label */ ;
                                    }
                                    {
#line 364
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Input format %s not supported\n",
                                            optarg);
                                    }
                                    {
#line 364
                                    while (1) {
                                      while_continue___5: /* CIL Label */ ;
#line 364
                                      if (at_log_file) {
                                        {
#line 364
                                        fprintf((FILE */* __restrict  */)at_log_file,
                                                (char const   */* __restrict  */)"Input format %s not supported\n",
                                                optarg);
                                        }
                                      }
#line 364
                                      goto while_break___5;
                                    }
                                    while_break___5: /* CIL Label */ ;
                                    }
                                    {
#line 364
                                    fputs((char const   */* __restrict  */)".\n",
                                          (FILE */* __restrict  */)stderr);
#line 364
                                    exit(1);
                                    }
#line 364
                                    goto while_break___3;
                                  }
                                  while_break___3: /* CIL Label */ ;
                                  }
                                }
                              } else {
                                {
#line 367
                                tmp___27 = strgicmp(long_options[option_index].name,
                                                    "line-threshold");
                                }
#line 367
                                if (tmp___27) {
                                  {
#line 368
                                  tmp___13 = atof((char const   *)optarg);
#line 368
                                  fitting_opts->line_threshold = (at_real )tmp___13;
                                  }
                                } else {
                                  {
#line 370
                                  tmp___26 = strgicmp(long_options[option_index].name,
                                                      "line-reversion-threshold");
                                  }
#line 370
                                  if (tmp___26) {
                                    {
#line 371
                                    tmp___14 = atof((char const   *)optarg);
#line 371
                                    fitting_opts->line_reversion_threshold = (at_real )tmp___14;
                                    }
                                  } else {
                                    {
#line 373
                                    tmp___25 = strgicmp(long_options[option_index].name,
                                                        "list-output-formats");
                                    }
#line 373
                                    if (tmp___25) {
                                      {
#line 375
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Supported output formats:\n");
#line 376
                                      output_list_formats(stderr);
#line 377
                                      exit(0);
                                      }
                                    } else {
                                      {
#line 379
                                      tmp___24 = strgicmp(long_options[option_index].name,
                                                          "list-input-formats");
                                      }
#line 379
                                      if (tmp___24) {
                                        {
#line 381
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Supported input formats:\n");
#line 382
                                        input_list_formats(stderr);
#line 383
                                        exit(0);
                                        }
                                      } else {
                                        {
#line 386
                                        tmp___23 = strgicmp(long_options[option_index].name,
                                                            "output-file");
                                        }
#line 386
                                        if (tmp___23) {
#line 387
                                          output_name = optarg;
                                        } else {
                                          {
#line 389
                                          tmp___22 = strgicmp(long_options[option_index].name,
                                                              "output-format");
                                          }
#line 389
                                          if (tmp___22) {
                                            {
#line 391
                                            output_writer = at_output_get_handler_by_suffix(optarg);
                                            }
#line 392
                                            if ((unsigned long )output_writer == (unsigned long )((void *)0)) {
                                              {
#line 393
                                              while (1) {
                                                while_continue___6: /* CIL Label */ ;
                                                {
#line 393
                                                fputs((char const   */* __restrict  */)"fatal: ",
                                                      (FILE */* __restrict  */)stderr);
                                                }
                                                {
#line 393
                                                while (1) {
                                                  while_continue___7: /* CIL Label */ ;
#line 393
                                                  if (at_log_file) {
                                                    {
#line 393
                                                    fputs((char const   */* __restrict  */)"fatal: ",
                                                          (FILE */* __restrict  */)at_log_file);
                                                    }
                                                  }
#line 393
                                                  goto while_break___7;
                                                }
                                                while_break___7: /* CIL Label */ ;
                                                }
                                                {
#line 393
                                                fprintf((FILE */* __restrict  */)stderr,
                                                        (char const   */* __restrict  */)"Output format %s not supported",
                                                        optarg);
                                                }
                                                {
#line 393
                                                while (1) {
                                                  while_continue___8: /* CIL Label */ ;
#line 393
                                                  if (at_log_file) {
                                                    {
#line 393
                                                    fprintf((FILE */* __restrict  */)at_log_file,
                                                            (char const   */* __restrict  */)"Output format %s not supported",
                                                            optarg);
                                                    }
                                                  }
#line 393
                                                  goto while_break___8;
                                                }
                                                while_break___8: /* CIL Label */ ;
                                                }
                                                {
#line 393
                                                fputs((char const   */* __restrict  */)".\n",
                                                      (FILE */* __restrict  */)stderr);
#line 393
                                                exit(1);
                                                }
#line 393
                                                goto while_break___6;
                                              }
                                              while_break___6: /* CIL Label */ ;
                                              }
                                            }
                                          } else {
                                            {
#line 395
                                            tmp___21 = strgicmp(long_options[option_index].name,
                                                                "preserve_width");
                                            }
#line 395
                                            if (tmp___21) {
#line 396
                                              fitting_opts->preserve_width = (at_bool )1;
                                            } else {
                                              {
#line 398
                                              tmp___20 = strgicmp(long_options[option_index].name,
                                                                  "remove-adjacent-corners");
                                              }
#line 398
                                              if (tmp___20) {
#line 399
                                                fitting_opts->remove_adjacent_corners = (at_bool )1;
                                              } else {
                                                {
#line 401
                                                tmp___19 = strgicmp(long_options[option_index].name,
                                                                    "tangent-surround");
                                                }
#line 401
                                                if (tmp___19) {
                                                  {
#line 402
                                                  fitting_opts->tangent_surround = atou(optarg);
                                                  }
                                                } else {
                                                  {
#line 404
                                                  tmp___18 = strgicmp(long_options[option_index].name,
                                                                      "version");
                                                  }
#line 404
                                                  if (tmp___18) {
                                                    {
#line 405
                                                    tmp___15 = at_version((at_bool )0);
#line 405
                                                    printf((char const   */* __restrict  */)"AutoTrace version %s.\n",
                                                           tmp___15);
                                                    }
                                                  } else {
                                                    {
#line 407
                                                    tmp___17 = strgicmp(long_options[option_index].name,
                                                                        "width-weight-factor");
                                                    }
#line 407
                                                    if (tmp___17) {
                                                      {
#line 408
                                                      tmp___16 = atof((char const   *)optarg);
#line 408
                                                      fitting_opts->width_weight_factor = (at_real )tmp___16;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 412
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 412
    if (printed_version) {
#line 412
      if (optind == argc) {
        {
#line 412
        exit(0);
        }
      }
    }
#line 412
    if (optind + 1 == argc) {
#line 412
      if ((int )*(*(argv + optind)) != 0) {
#line 412
        return (*(argv + optind));
      } else {
#line 412
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 412
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [options] <image_name>.\n",
              *(argv + 0));
      }
#line 412
      if (optind == argc) {
#line 412
        tmp___42 = "Missing <image_name>";
      } else {
#line 412
        tmp___42 = "Too many <image_name>s";
      }
      {
#line 412
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(%s.)\n",
              tmp___42);
#line 412
      fputs((char const   */* __restrict  */)"For more information, use ``-help\'\'.\n",
            (FILE */* __restrict  */)stderr);
#line 412
      exit(1);
      }
    }
#line 412
    return ((char *)((void *)0));
#line 412
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 413
  return ((char *)0);
}
}
#line 419 "main.c"
static char *get_basename(char *name ) 
{ 
  char *base ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 425
  tmp = strrchr((char const   *)name, '/');
#line 425
  base = tmp;
  }
#line 427
  if (base) {
#line 427
    tmp___0 = base + 1;
  } else {
#line 427
    tmp___0 = name;
  }
#line 427
  return (tmp___0);
}
}
#line 433 "main.c"
static unsigned int hctoi(char c ) 
{ 


  {
#line 435
  if ((int )c == 48) {
#line 436
    return (0U);
  } else
#line 437
  if ((int )c == 49) {
#line 438
    return (1U);
  } else
#line 439
  if ((int )c == 50) {
#line 440
    return (2U);
  } else
#line 441
  if ((int )c == 51) {
#line 442
    return (3U);
  } else
#line 443
  if ((int )c == 52) {
#line 444
    return (4U);
  } else
#line 445
  if ((int )c == 53) {
#line 446
    return (5U);
  } else
#line 447
  if ((int )c == 54) {
#line 448
    return (6U);
  } else
#line 449
  if ((int )c == 55) {
#line 450
    return (7U);
  } else
#line 451
  if ((int )c == 56) {
#line 452
    return (8U);
  } else
#line 453
  if ((int )c == 57) {
#line 454
    return (9U);
  } else
#line 455
  if ((int )c == 97) {
#line 456
    return (10U);
  } else
#line 457
  if ((int )c == 65) {
#line 458
    return (10U);
  } else
#line 459
  if ((int )c == 98) {
#line 460
    return (11U);
  } else
#line 461
  if ((int )c == 66) {
#line 462
    return (11U);
  } else
#line 463
  if ((int )c == 99) {
#line 464
    return (12U);
  } else
#line 465
  if ((int )c == 67) {
#line 466
    return (12U);
  } else
#line 467
  if ((int )c == 100) {
#line 468
    return (13U);
  } else
#line 469
  if ((int )c == 68) {
#line 470
    return (13U);
  } else
#line 471
  if ((int )c == 101) {
#line 472
    return (14U);
  } else
#line 473
  if ((int )c == 69) {
#line 474
    return (14U);
  } else
#line 475
  if ((int )c == 102) {
#line 476
    return (15U);
  } else
#line 477
  if ((int )c == 70) {
#line 478
    return (15U);
  } else {
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 480
      fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)stderr);
      }
      {
#line 480
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 480
        if (at_log_file) {
          {
#line 480
          fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 480
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 480
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              "No hex values");
      }
      {
#line 480
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 480
        if (at_log_file) {
          {
#line 480
          fputs((char const   */* __restrict  */)"No hex values", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 480
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 480
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stderr);
#line 480
      exit(1);
      }
#line 480
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 481
  return (0U);
}
}
#line 483 "main.c"
static void input_list_formats(FILE *file ) 
{ 
  char **list ;
  char **tmp ;
  char **tmp___0 ;
  char *suffix ;
  char *descr ;
  char **tmp___1 ;
  char **tmp___2 ;

  {
  {
#line 486
  tmp = at_input_list_new();
#line 486
  list = tmp;
#line 491
  tmp___0 = list;
  }
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! *list) {
#line 492
      goto while_break;
    }
    {
#line 494
    tmp___1 = list;
#line 494
    list ++;
#line 494
    suffix = *tmp___1;
#line 495
    tmp___2 = list;
#line 495
    list ++;
#line 495
    descr = *tmp___2;
#line 496
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%5s %s\n",
            suffix, descr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 499
  at_input_list_free(tmp___0);
  }
#line 500
  return;
}
}
#line 503 "main.c"
static void output_list_formats(FILE *file ) 
{ 
  char **list ;
  char **tmp ;
  char **tmp___0 ;
  char *suffix ;
  char *descr ;
  char **tmp___1 ;
  char **tmp___2 ;

  {
  {
#line 506
  tmp = at_output_list_new();
#line 506
  list = tmp;
#line 511
  tmp___0 = list;
  }
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! *list) {
#line 512
      goto while_break;
    }
    {
#line 514
    tmp___1 = list;
#line 514
    list ++;
#line 514
    suffix = *tmp___1;
#line 515
    tmp___2 = list;
#line 515
    list ++;
#line 515
    descr = *tmp___2;
#line 516
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%10s %s\n",
            suffix, descr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 519
  at_output_list_free(tmp___0);
  }
#line 520
  return;
}
}
#line 522 "main.c"
static void dot_printer(at_real percentage , at_address client_data ) 
{ 
  int *current ;
  float unit ;
  int maximum ;

  {
#line 525
  current = (int *)client_data;
#line 526
  unit = (float )1.0 / (float )50;
#line 527
  maximum = (int )(percentage / unit);
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! (*current < maximum)) {
#line 529
      goto while_break;
    }
    {
#line 531
    fputc('|', stderr);
#line 532
    (*current) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  return;
}
}
#line 536 "main.c"
static void dump(at_bitmap_type *bitmap , FILE *fp ) 
{ 
  unsigned short width ;
  unsigned short height ;
  unsigned int np ;
  unsigned short tmp ;

  {
  {
#line 542
  width = at_bitmap_get_width(bitmap);
#line 543
  height = at_bitmap_get_height(bitmap);
#line 544
  tmp = at_bitmap_get_planes(bitmap);
#line 544
  np = (unsigned int )tmp;
#line 545
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"w=%u, h=%u, np=%u\n",
          (int )width, (int )height, np);
#line 547
  fwrite((void const   */* __restrict  */)bitmap->bitmap, sizeof(unsigned char ),
         (size_t )((unsigned int )((int )width * (int )height) * np), (FILE */* __restrict  */)fp);
  }
#line 551
  return;
}
}
#line 553 "main.c"
static void exception_handler(at_string msg , at_msg_type type , at_address data ) 
{ 


  {
#line 556
  if ((unsigned int )type == 1U) {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            msg);
#line 559
    exit(1);
    }
  } else
#line 561
  if ((unsigned int )type == 2U) {
    {
#line 562
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            msg);
    }
  } else {
    {
#line 564
    exception_handler((at_string )"Wrong type of msg", (at_msg_type )1, (void *)0);
    }
  }
#line 565
  return;
}
}
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 18 "logreport.c"
FILE *at_log_file  =    (FILE *)((void *)0);
#line 22 "logreport.c"
void flush_log_output(void) 
{ 


  {
#line 25
  if (at_log_file) {
    {
#line 26
    fflush(at_log_file);
    }
  }
#line 27
  return;
}
}
#line 646 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 30 "exception.h"
void at_exception_warning(at_exception_type *exception , at_string const   message ) ;
#line 59 "input.h"
at_bitmap_type at_bitmap_init(unsigned char *area , unsigned short width , unsigned short height ,
                              unsigned int planes ) ;
#line 97 "input-tga.c"
static struct __anonstruct_tga_footer_517022796 tga_footer  ;
#line 108
static at_bitmap_type ReadImage(FILE *fp , struct tga_header *hdr , at_exception_type *exp ) ;
#line 111 "input-tga.c"
at_bitmap_type input_tga_reader(at_string filename___0 , at_input_opts_type *opts ,
                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                 at_address client_data ) , at_address msg_data ) 
{ 
  FILE *fp ;
  struct tga_header hdr ;
  at_bitmap_type image ;
  at_bitmap_type tmp ;
  at_exception_type exp ;
  at_exception_type tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  {
#line 120
  tmp = at_bitmap_init((unsigned char *)0, (unsigned short)0, (unsigned short)0, 1U);
#line 120
  image = tmp;
#line 121
  tmp___0 = at_exception_new(msg_func, msg_data);
#line 121
  exp = tmp___0;
#line 123
  fp = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"rb");
  }
#line 124
  if (! fp) {
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 126
      if (at_log_file) {
        {
#line 126
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: can\'t open \"%s\"\n",
                filename___0);
        }
      }
#line 126
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 127
    at_exception_fatal(& exp, (at_string const   )"Cannot open input tga file");
    }
  }
  {
#line 131
  tmp___1 = fseek(fp, (long )(0UL - sizeof(tga_footer)), 2);
  }
#line 131
  if (tmp___1) {
#line 131
    goto _L;
  } else {
    {
#line 131
    tmp___2 = fread((void */* __restrict  */)(& tga_footer), sizeof(tga_footer), (size_t )1,
                    (FILE */* __restrict  */)fp);
    }
#line 131
    if (tmp___2 != 1UL) {
      _L: /* CIL Label */ 
      {
#line 134
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 134
        if (at_log_file) {
          {
#line 134
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: Cannot read footer from \"%s\"\n",
                  filename___0);
          }
        }
#line 134
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 135
      at_exception_fatal(& exp, (at_string const   )"TGA: Cannot read footer");
      }
#line 136
      goto cleanup;
    }
  }
  {
#line 141
  tmp___3 = fseek(fp, 0L, 0);
  }
#line 141
  if (tmp___3) {
#line 141
    goto _L___0;
  } else {
    {
#line 141
    tmp___4 = fread((void */* __restrict  */)(& hdr), sizeof(hdr), (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 141
    if (tmp___4 != 1UL) {
      _L___0: /* CIL Label */ 
      {
#line 144
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 144
        if (at_log_file) {
          {
#line 144
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: Cannot read header from \"%s\"\n",
                  filename___0);
          }
        }
#line 144
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 145
      at_exception_fatal(& exp, (at_string const   )"TGA: Cannot read header");
      }
#line 146
      goto cleanup;
    }
  }
#line 150
  if (hdr.idLength) {
    {
#line 150
    tmp___5 = fseek(fp, (long )hdr.idLength, 1);
    }
#line 150
    if (tmp___5) {
      {
#line 152
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 152
        if (at_log_file) {
          {
#line 152
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: Cannot skip ID field in \"%s\"\n",
                  filename___0);
          }
        }
#line 152
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 153
      at_exception_fatal(& exp, (at_string const   )"TGA: Cannot skip ID field");
      }
#line 154
      goto cleanup;
    }
  }
  {
#line 157
  image = ReadImage(fp, & hdr, & exp);
  }
  cleanup: 
  {
#line 159
  fclose(fp);
  }
#line 160
  return (image);
}
}
#line 164 "input-tga.c"
static int std_fread(unsigned char *buf , int datasize , int nelems , FILE *fp ) 
{ 
  size_t tmp ;

  {
  {
#line 171
  tmp = fread((void */* __restrict  */)buf, (size_t )datasize, (size_t )nelems, (FILE */* __restrict  */)fp);
  }
#line 171
  return ((int )tmp);
}
}
#line 183
static int rle_fread(unsigned char *buf , int datasize , int nelems , FILE *fp ) ;
#line 183 "input-tga.c"
static unsigned char *statebuf  =    (unsigned char *)0;
#line 184 "input-tga.c"
static int statelen  =    0;
#line 185 "input-tga.c"
static int laststate  =    0;
#line 177 "input-tga.c"
static int rle_fread(unsigned char *buf , int datasize , int nelems , FILE *fp ) 
{ 
  int j ;
  int k ;
  int buflen ;
  int count ;
  int bytes ;
  unsigned char *p ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 192
  buflen = nelems * datasize;
#line 194
  j = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (j < buflen)) {
#line 195
      goto while_break;
    }
#line 197
    if (laststate < statelen) {
#line 200
      if (buflen - j < statelen - laststate) {
#line 200
        bytes = buflen - j;
      } else {
#line 200
        bytes = statelen - laststate;
      }
      {
#line 201
      memcpy((void */* __restrict  */)(buf + j), (void const   */* __restrict  */)(statebuf + laststate),
             (size_t )bytes);
#line 202
      j += bytes;
#line 203
      laststate += bytes;
      }
#line 206
      if (laststate >= statelen) {
#line 208
        laststate = 0;
#line 209
        statelen = 0;
      }
#line 213
      if (j >= buflen) {
#line 214
        goto while_break;
      }
    }
    {
#line 218
    count = fgetc(fp);
    }
#line 219
    if (count == -1) {
#line 221
      return (j / datasize);
    }
#line 225
    bytes = ((count & -129) + 1) * datasize;
#line 227
    if (j + bytes <= buflen) {
#line 230
      p = buf + j;
    } else {
#line 234
      if (! statebuf) {
        {
#line 235
        tmp = malloc((size_t )(128 * datasize));
#line 235
        statebuf = (unsigned char *)tmp;
        }
      }
#line 236
      p = statebuf;
    }
#line 239
    if (count & 128) {
      {
#line 242
      tmp___0 = fread((void */* __restrict  */)p, (size_t )datasize, (size_t )1, (FILE */* __restrict  */)fp);
      }
#line 242
      if (tmp___0 != 1UL) {
#line 244
        return (j / datasize);
      }
#line 248
      if (datasize == 1) {
        {
#line 249
        memset((void *)(p + 1), (int )*p, (size_t )(bytes - 1));
        }
      } else {
#line 251
        k = datasize;
        {
#line 251
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 251
          if (! (k < bytes)) {
#line 251
            goto while_break___0;
          }
          {
#line 252
          memcpy((void */* __restrict  */)(p + k), (void const   */* __restrict  */)p,
                 (size_t )datasize);
#line 251
          k += datasize;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 257
      tmp___1 = fread((void */* __restrict  */)p, (size_t )bytes, (size_t )1, (FILE */* __restrict  */)fp);
      }
#line 257
      if (tmp___1 != 1UL) {
#line 259
        return (j / datasize);
      }
    }
#line 264
    if ((unsigned long )p == (unsigned long )statebuf) {
#line 265
      statelen = bytes;
    } else {
#line 267
      j += bytes;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  return (nelems);
}
}
#line 273 "input-tga.c"
static at_bitmap_type ReadImage(FILE *fp , struct tga_header *hdr , at_exception_type *exp ) 
{ 
  at_bitmap_type image ;
  at_bitmap_type tmp ;
  unsigned char *buffer___0 ;
  unsigned char *alphas ;
  int width ;
  int height ;
  int bpp ;
  int abpp ;
  int pbpp ;
  int nalphas ;
  int j ;
  int k ;
  int pelbytes ;
  int wbytes ;
  int bsize ;
  int npels ;
  int pels ;
  int rle ;
  int badread ;
  int itype ;
  int dtype ;
  unsigned char *cmap ;
  int (*myfread)(unsigned char * , int  , int  , FILE * ) ;
  char horzrev ;
  char vertrev ;
  int tmp___0 ;
  int tmp___1 ;
  int index___0 ;
  int colors ;
  unsigned int length ;
  void *tmp___2 ;
  long tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  unsigned char tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  unsigned char tmp___14 ;
  unsigned char *tmp___15 ;
  int tmp___16 ;
  unsigned char *temp ;
  unsigned char *temp2 ;
  unsigned char *temp3 ;
  unsigned char index___1 ;
  int xpos ;
  int ypos ;
  void *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;

  {
  {
#line 278
  tmp = at_bitmap_init((unsigned char *)0, (unsigned short)0, (unsigned short)0, 1U);
#line 278
  image = tmp;
#line 287
  cmap = (unsigned char *)((void *)0);
#line 291
  horzrev = (char )((int )hdr->descriptor & 16);
#line 292
  vertrev = (char )(! ((int )hdr->descriptor & 32));
#line 294
  image.bitmap = (unsigned char *)((void *)0);
#line 298
  width = ((int )hdr->widthHi << 8) | (int )hdr->widthLo;
#line 299
  height = ((int )hdr->heightHi << 8) | (int )hdr->heightLo;
#line 301
  bpp = (int )hdr->bpp;
#line 302
  abpp = (int )hdr->descriptor & 15;
  }
#line 304
  if ((int )hdr->imageType == 2) {
#line 304
    goto _L;
  } else
#line 304
  if ((int )hdr->imageType == 10) {
    _L: /* CIL Label */ 
#line 306
    if (bpp / 3 < 8) {
#line 306
      tmp___0 = bpp / 3;
    } else {
#line 306
      tmp___0 = 8;
    }
#line 306
    pbpp = tmp___0 * 3;
  } else
#line 307
  if (abpp < bpp) {
#line 308
    pbpp = bpp - abpp;
  } else {
#line 310
    pbpp = bpp;
  }
#line 312
  if (abpp + pbpp > bpp) {
    {
#line 314
    while (1) {
      while_continue: /* CIL Label */ ;
#line 314
      if (at_log_file) {
        {
#line 314
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: %d bit image, %d bit alpha is greater than %d total bits per pixel\n",
                pbpp, abpp, bpp);
        }
      }
#line 314
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 316
    at_exception_warning(exp, (at_string const   )"TGA: alpha bit is too great");
#line 319
    abpp = bpp - pbpp;
    }
    {
#line 320
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 320
      if (at_log_file) {
        {
#line 320
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: reducing to %d bit alpha\n",
                abpp);
        }
      }
#line 320
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 321
    at_exception_warning(exp, (at_string const   )"TGA: alpha bit is reduced");
    }
  } else
#line 323
  if (abpp + pbpp < bpp) {
    {
#line 325
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 325
      if (at_log_file) {
        {
#line 325
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: %d bit image, %d bit alpha is less than %d total bits per pixel\n",
                pbpp, abpp, bpp);
        }
      }
#line 325
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 327
    at_exception_warning(exp, (at_string const   )"TGA: alpha bit is too little");
#line 330
    abpp = bpp - pbpp;
    }
    {
#line 331
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 331
      if (at_log_file) {
        {
#line 331
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: increasing to %d bit alpha\n",
                abpp);
        }
      }
#line 331
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 332
    at_exception_warning(exp, (at_string const   )"TGA: alpha bit is increased");
    }
  }
#line 335
  rle = 0;
  {
#line 338
  if ((int )hdr->imageType == 9) {
#line 338
    goto case_9;
  }
#line 340
  if ((int )hdr->imageType == 1) {
#line 340
    goto case_1;
  }
#line 364
  if ((int )hdr->imageType == 11) {
#line 364
    goto case_11;
  }
#line 366
  if ((int )hdr->imageType == 3) {
#line 366
    goto case_3;
  }
#line 375
  if ((int )hdr->imageType == 10) {
#line 375
    goto case_10;
  }
#line 377
  if ((int )hdr->imageType == 2) {
#line 377
    goto case_2;
  }
#line 386
  goto switch_default;
  case_9: /* CIL Label */ 
#line 339
  rle = 1;
  case_1: /* CIL Label */ 
#line 341
  itype = 1;
#line 344
  if ((int )hdr->colorMapSize / 3 < 8) {
#line 344
    tmp___1 = (int )hdr->colorMapSize / 3;
  } else {
#line 344
    tmp___1 = 8;
  }
#line 344
  pbpp = tmp___1 * 3;
#line 345
  if (pbpp < (int )hdr->colorMapSize) {
#line 346
    abpp = (int )hdr->colorMapSize - pbpp;
  } else {
#line 348
    abpp = 0;
  }
#line 351
  if (bpp != 8) {
    {
#line 353
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 353
      if (at_log_file) {
        {
#line 353
        fputs((char const   */* __restrict  */)"TGA: index sizes other than 8 bits are unimplemented\n",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 353
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 354
    at_exception_fatal(exp, (at_string const   )"TGA: index sizes other than 8 bits are unimplemented");
    }
#line 355
    return (image);
  }
#line 358
  if (abpp) {
#line 359
    dtype = 2;
  } else {
#line 361
    dtype = 1;
  }
#line 362
  goto switch_break;
  case_11: /* CIL Label */ 
#line 365
  rle = 1;
  case_3: /* CIL Label */ 
#line 367
  itype = 3;
#line 369
  if (abpp) {
#line 370
    dtype = 4;
  } else {
#line 372
    dtype = 3;
  }
#line 373
  goto switch_break;
  case_10: /* CIL Label */ 
#line 376
  rle = 1;
  case_2: /* CIL Label */ 
#line 378
  itype = 5;
#line 380
  if (abpp) {
#line 381
    dtype = 6;
  } else {
#line 383
    dtype = 5;
  }
#line 384
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 388
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 388
    if (at_log_file) {
      {
#line 388
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: unrecognized image type %d\n",
              (int )hdr->imageType);
      }
    }
#line 388
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 389
  at_exception_fatal(exp, (at_string const   )"TGA: unrecognized image type");
  }
#line 390
  return (image);
  switch_break: /* CIL Label */ ;
  }
#line 394
  if (abpp) {
#line 394
    if (abpp != 8) {
#line 394
      goto _L___0;
    } else {
#line 394
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 394
  if (itype == 5) {
#line 394
    goto _L___2;
  } else
#line 394
  if (itype == 1) {
    _L___2: /* CIL Label */ 
#line 394
    if (pbpp != 24) {
#line 394
      goto _L___0;
    } else {
#line 394
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 394
  if (itype == 3) {
#line 394
    if (pbpp != 8) {
      _L___0: /* CIL Label */ 
      {
#line 399
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 399
        if (at_log_file) {
          {
#line 399
          fputs((char const   */* __restrict  */)"TGA: channel sizes other than 8 bits are unimplemented\n",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 399
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 400
      at_exception_fatal(exp, (at_string const   )"TGA: channel sizes other than 8 bits are unimplemented");
      }
#line 402
      return (image);
    }
  }
#line 406
  if (itype == 1) {
#line 408
    if ((int )hdr->colorMapType != 1) {
      {
#line 410
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 410
        if (at_log_file) {
          {
#line 410
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: indexed image has invalid color map type %d\n",
                  (int )hdr->colorMapType);
          }
        }
#line 410
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 412
      at_exception_fatal(exp, (at_string const   )"TGA: indexed image has invalid color map type");
      }
#line 414
      return (image);
    }
  } else
#line 417
  if ((int )hdr->colorMapType != 0) {
    {
#line 419
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 419
      if (at_log_file) {
        {
#line 419
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: non-indexed image has invalid color map type %d\n",
                (int )hdr->colorMapType);
        }
      }
#line 419
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 421
    at_exception_fatal(exp, (at_string const   )"TGA: non-indexed image has invalid color map type");
    }
#line 422
    return (image);
  }
#line 425
  alphas = (unsigned char *)0;
#line 426
  nalphas = 0;
#line 427
  if ((int )hdr->colorMapType == 1) {
#line 433
    index___0 = ((int )hdr->colorMapIndexHi << 8) | (int )hdr->colorMapIndexLo;
#line 434
    length = (unsigned int )(((int )hdr->colorMapLengthHi << 8) | (int )hdr->colorMapLengthLo);
#line 436
    if (length == 0U) {
      {
#line 438
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 438
        if (at_log_file) {
          {
#line 438
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: invalid color map length %d\n",
                  length);
          }
        }
#line 438
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 439
      at_exception_fatal(exp, (at_string const   )"TGA: invalid color map length");
      }
#line 440
      return (image);
    }
    {
#line 443
    pelbytes = ((int )hdr->colorMapSize + 7) / 8;
#line 444
    colors = (int )(length + (unsigned int )index___0);
#line 445
    tmp___2 = malloc((size_t )(colors * pelbytes));
#line 445
    cmap = (unsigned char *)tmp___2;
#line 448
    memset((void *)cmap, 0, (size_t )(index___0 * pelbytes));
#line 451
    tmp___4 = fread((void */* __restrict  */)(cmap + index___0 * pelbytes), (size_t )pelbytes,
                    (size_t )length, (FILE */* __restrict  */)fp);
    }
#line 451
    if (tmp___4 != (size_t )length) {
      {
#line 453
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 453
        if (at_log_file) {
          {
#line 453
          tmp___3 = ftell(fp);
#line 453
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: error reading colormap (ftell == %ld)\n",
                  tmp___3);
          }
        }
#line 453
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 454
      at_exception_fatal(exp, (at_string const   )"TGA: error reading colormap");
      }
#line 455
      return (image);
    }
#line 460
    if (pelbytes > 3) {
      {
#line 461
      tmp___5 = malloc((size_t )colors);
#line 461
      alphas = (unsigned char *)tmp___5;
      }
    }
#line 463
    k = 0;
#line 464
    j = 0;
    {
#line 464
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 464
      if (! (j < colors * pelbytes)) {
#line 464
        goto while_break___10;
      }
#line 467
      tmp___6 = *(cmap + j);
#line 468
      tmp___7 = k;
#line 468
      k ++;
#line 468
      *(cmap + tmp___7) = *(cmap + (j + 2));
#line 469
      tmp___8 = k;
#line 469
      k ++;
#line 469
      *(cmap + tmp___8) = *(cmap + (j + 1));
#line 470
      tmp___9 = k;
#line 470
      k ++;
#line 470
      *(cmap + tmp___9) = tmp___6;
#line 473
      if (alphas) {
#line 474
        tmp___10 = nalphas;
#line 474
        nalphas ++;
#line 474
        *(alphas + tmp___10) = *(cmap + (j + 3));
      }
#line 464
      j += pelbytes;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 479
    if (nalphas) {
#line 479
      if ((int )*(alphas + (nalphas - 1)) == 0) {
#line 480
        colors --;
      }
    }
#line 483
    abpp = 0;
#line 484
    pbpp = 8;
#line 485
    pelbytes = 1;
  } else {
#line 488
    pelbytes = 3;
  }
  {
#line 490
  image = at_bitmap_init((unsigned char *)((void *)0), (unsigned short )width, (unsigned short )height,
                         3U);
#line 493
  bpp = ((pbpp + abpp) + 7) / 8;
#line 496
  buffer___0 = (unsigned char *)((void *)0);
  }
#line 497
  if (horzrev) {
    {
#line 498
    tmp___11 = malloc((unsigned long )((width * height) * pelbytes) * sizeof(unsigned char ));
#line 498
    buffer___0 = (unsigned char *)tmp___11;
    }
  } else
#line 497
  if (vertrev) {
    {
#line 498
    tmp___11 = malloc((unsigned long )((width * height) * pelbytes) * sizeof(unsigned char ));
#line 498
    buffer___0 = (unsigned char *)tmp___11;
    }
  }
#line 499
  if (rle) {
#line 500
    myfread = & rle_fread;
  } else {
#line 502
    myfread = & std_fread;
  }
#line 504
  wbytes = width * pelbytes;
#line 505
  badread = 0;
#line 507
  npels = width * height;
#line 508
  bsize = wbytes * height;
#line 511
  if (badread) {
#line 512
    pels = 0;
  } else {
    {
#line 514
    pels = (*myfread)(image.bitmap, bpp, npels, fp);
    }
  }
#line 516
  if (pels != npels) {
#line 518
    if (! badread) {
      {
#line 521
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 521
        if (at_log_file) {
          {
#line 521
          tmp___12 = ftell(fp);
#line 521
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"TGA: error reading (ftell == %ld)\n",
                  tmp___12);
          }
        }
#line 521
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 522
      at_exception_warning(exp, (at_string const   )"TGA: eroor reading file");
#line 523
      badread = 1;
      }
    }
    {
#line 528
    memset((void *)(image.bitmap + pels * bpp), 0, (size_t )((npels - pels) * bpp));
    }
  }
#line 531
  if (nalphas) {
#line 534
    k = (npels - 1) * bpp;
#line 535
    j = bsize - pelbytes;
    {
#line 535
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 535
      if (! (j >= 0)) {
#line 535
        goto while_break___12;
      }
#line 538
      *(image.bitmap + (j + 1)) = *(alphas + *(image.bitmap + k));
#line 539
      tmp___13 = k;
#line 539
      k --;
#line 539
      *(image.bitmap + j) = *(image.bitmap + tmp___13);
#line 535
      j -= pelbytes;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 543
  if (itype == 3) {
#line 544
    j = bsize / 3 - 1;
    {
#line 544
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 544
      if (! (j >= 0)) {
#line 544
        goto while_break___13;
      }
#line 547
      *(image.bitmap + 3 * j) = *(image.bitmap + j);
#line 548
      *(image.bitmap + (3 * j + 1)) = *(image.bitmap + j);
#line 549
      *(image.bitmap + (3 * j + 2)) = *(image.bitmap + j);
#line 544
      j --;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
#line 553
  if (pelbytes >= 3) {
#line 556
    j = 0;
    {
#line 556
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 556
      if (! (j < bsize)) {
#line 556
        goto while_break___14;
      }
#line 558
      tmp___14 = *(image.bitmap + j);
#line 559
      *(image.bitmap + j) = *(image.bitmap + (j + 2));
#line 560
      *(image.bitmap + (j + 2)) = tmp___14;
#line 556
      j += pelbytes;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
#line 566
  if (horzrev) {
#line 566
    goto _L___4;
  } else
#line 566
  if (vertrev) {
    _L___4: /* CIL Label */ 
#line 569
    if (vertrev) {
#line 572
      j = 0;
      {
#line 572
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 572
        if (! (j < bsize)) {
#line 572
          goto while_break___15;
        }
        {
#line 573
        memcpy((void */* __restrict  */)(buffer___0 + j), (void const   */* __restrict  */)((image.bitmap + bsize) - (j + wbytes)),
               (size_t )wbytes);
#line 572
        j += wbytes;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
    } else
#line 576
    if (horzrev) {
#line 579
      j = 0;
      {
#line 579
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 579
        if (! (j < bsize)) {
#line 579
          goto while_break___16;
        }
#line 580
        k = 0;
        {
#line 580
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 580
          if (! (k < wbytes)) {
#line 580
            goto while_break___17;
          }
          {
#line 581
          memcpy((void */* __restrict  */)((buffer___0 + k) + j), (void const   */* __restrict  */)((image.bitmap + (j + wbytes)) - (k + pelbytes)),
                 (size_t )pelbytes);
#line 580
          k += pelbytes;
          }
        }
        while_break___17: /* CIL Label */ ;
        }
#line 579
        j += wbytes;
      }
      while_break___16: /* CIL Label */ ;
      }
    } else {
#line 587
      j = 0;
      {
#line 587
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 587
        if (! (j < bsize)) {
#line 587
          goto while_break___18;
        }
        {
#line 588
        memcpy((void */* __restrict  */)(buffer___0 + j), (void const   */* __restrict  */)((image.bitmap + bsize) - (j + pelbytes)),
               (size_t )pelbytes);
#line 587
        j += pelbytes;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 593
    tmp___15 = buffer___0;
#line 594
    buffer___0 = image.bitmap;
#line 595
    image.bitmap = tmp___15;
  }
  {
#line 598
  tmp___16 = fgetc(fp);
  }
#line 598
  if (tmp___16 != -1) {
    {
#line 600
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 600
      if (at_log_file) {
        {
#line 600
        fputs((char const   */* __restrict  */)"TGA: too much input data, ignoring extra...\n",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 600
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 601
    at_exception_warning(exp, (at_string const   )"TGA: too much input data, ignoring extra datum");
    }
  }
  {
#line 604
  free((void *)buffer___0);
  }
#line 606
  if ((int )hdr->colorMapType == 1) {
    {
#line 612
    temp = image.bitmap;
#line 612
    temp2 = temp;
#line 613
    tmp___17 = malloc((unsigned long )((width * height) * 3) * sizeof(unsigned char ));
#line 613
    temp3 = (unsigned char *)tmp___17;
#line 613
    image.bitmap = temp3;
#line 615
    ypos = 0;
    }
    {
#line 615
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 615
      if (! (ypos < height)) {
#line 615
        goto while_break___20;
      }
#line 617
      xpos = 0;
      {
#line 617
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 617
        if (! (xpos < width)) {
#line 617
          goto while_break___21;
        }
#line 619
        tmp___18 = temp2;
#line 619
        temp2 ++;
#line 619
        index___1 = *tmp___18;
#line 620
        tmp___19 = temp3;
#line 620
        temp3 ++;
#line 620
        *tmp___19 = *(cmap + 3 * (int )index___1);
#line 621
        tmp___20 = temp3;
#line 621
        temp3 ++;
#line 621
        *tmp___20 = *(cmap + (3 * (int )index___1 + 1));
#line 622
        tmp___21 = temp3;
#line 622
        temp3 ++;
#line 622
        *tmp___21 = *(cmap + (3 * (int )index___1 + 2));
#line 617
        xpos ++;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 615
      ypos ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 625
    free((void *)temp);
#line 626
    free((void *)cmap);
    }
  }
#line 629
  if (alphas) {
    {
#line 630
    free((void *)alphas);
    }
  }
#line 632
  return (image);
}
}
#line 25 "input-pnm.h"
at_bitmap_type input_pnm_reader(at_string filename___0 , at_input_opts_type *opts ,
                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                 at_address client_data ) , at_address msg_data ) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 159 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 76 "input-pnm.c"
static void pnm_load_ascii(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                           at_exception_type *excep ) ;
#line 80
static void pnm_load_raw(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                         at_exception_type *excep ) ;
#line 84
static void pnm_load_rawpbm(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                            at_exception_type *excep ) ;
#line 89
static void pnmscanner_destroy(PNMScanner *s ) ;
#line 90
static void pnmscanner_createbuffer(PNMScanner *s , unsigned int bufsize ) ;
#line 92
static void pnmscanner_getchar(PNMScanner *s ) ;
#line 93
static void pnmscanner_eatwhitespace(PNMScanner *s ) ;
#line 94
static void pnmscanner_gettoken(PNMScanner *s , unsigned char *buf , unsigned int bufsize ) ;
#line 97
static void pnmscanner_getsmalltoken(PNMScanner *s , unsigned char *buf ) ;
#line 100
static PNMScanner *pnmscanner_create(FILE *fd ) ;
#line 106 "input-pnm.c"
static struct struct_pnm_types pnm_types[7]  = {      {(char )'1', 0, 1, 1, & pnm_load_ascii}, 
        {(char )'2', 1, 1, 255, & pnm_load_ascii}, 
        {(char )'3', 3, 1, 255, & pnm_load_ascii}, 
        {(char )'4', 0, 0, 1, & pnm_load_rawpbm}, 
        {(char )'5', 1, 0, 255, & pnm_load_raw}, 
        {(char )'6', 3, 0, 255, & pnm_load_raw}, 
        {(char)0, 0, 0, 0, (void (*)(PNMScanner * , struct _PNMInfo * , unsigned char *pixel_rgn ,
                                  at_exception_type *excep ))((void *)0)}};
#line 125 "input-pnm.c"
at_bitmap_type input_pnm_reader(at_string filename___0 , at_input_opts_type *opts ,
                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                 at_address client_data ) , at_address msg_data ) 
{ 
  char buf[512] ;
  PNMInfo *pnminfo ;
  PNMScanner * volatile  scan ;
  int ctr ;
  FILE *fd ;
  at_bitmap_type bitmap ;
  at_bitmap_type tmp ;
  at_exception_type excep ;
  at_exception_type tmp___0 ;
  void *tmp___1 ;
  PNMScanner *tmp___2 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  int tmp___12 ;

  {
  {
#line 135
  tmp = at_bitmap_init((unsigned char *)((void *)0), (unsigned short)0, (unsigned short)0,
                       0U);
#line 135
  bitmap = tmp;
#line 136
  tmp___0 = at_exception_new(msg_func, msg_data);
#line 136
  excep = tmp___0;
#line 139
  fd = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"rb");
  }
#line 141
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    {
#line 143
    while (1) {
      while_continue: /* CIL Label */ ;
#line 143
      if (at_log_file) {
        {
#line 143
        fputs((char const   */* __restrict  */)"pnm filter: can\'t open file\n", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 143
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 144
    at_exception_fatal(& excep, (at_string const   )"pnm filter: can\'t open file");
    }
#line 145
    return (bitmap);
  }
  {
#line 149
  tmp___1 = malloc(sizeof(PNMInfo ));
#line 149
  pnminfo = (PNMInfo *)tmp___1;
#line 151
  scan = (PNMScanner */* volatile  */)((void *)0);
#line 154
  tmp___2 = pnmscanner_create(fd);
#line 154
  scan = (PNMScanner */* volatile  */)tmp___2;
#line 157
  pnmscanner_gettoken((PNMScanner *)scan, (unsigned char *)(buf), 512U);
  }
#line 158
  if (scan->eof) {
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 160
      if (at_log_file) {
        {
#line 160
        fputs((char const   */* __restrict  */)"pnm filter: premature end of file\n",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 160
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 161
    at_exception_fatal(& excep, (at_string const   )"pnm filter: premature end of file");
    }
#line 162
    goto cleanup;
  }
#line 164
  if ((int )buf[0] != 80) {
#line 164
    goto _L;
  } else
#line 164
  if (buf[2]) {
    _L: /* CIL Label */ 
    {
#line 166
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 166
      if (at_log_file) {
        {
#line 166
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"pnm filter: %s is not a valid file\n",
                filename___0);
        }
      }
#line 166
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 167
    at_exception_fatal(& excep, (at_string const   )"pnm filter: invalid file");
    }
#line 168
    goto cleanup;
  }
#line 172
  ctr = 0;
  {
#line 172
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 172
    if (! pnm_types[ctr].name) {
#line 172
      goto while_break___2;
    }
#line 173
    if ((int )buf[1] == (int )pnm_types[ctr].name) {
#line 175
      pnminfo->np = pnm_types[ctr].np;
#line 176
      pnminfo->asciibody = pnm_types[ctr].asciibody;
#line 177
      pnminfo->maxval = pnm_types[ctr].maxval;
#line 178
      pnminfo->loader = pnm_types[ctr].loader;
    }
#line 172
    ctr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 180
  if (! pnminfo->loader) {
    {
#line 182
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 182
      if (at_log_file) {
        {
#line 182
        fputs((char const   */* __restrict  */)"pnm filter: file not in a supported format\n",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 182
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 183
    at_exception_fatal(& excep, (at_string const   )"pnm filter: file not in a supported format");
    }
#line 184
    goto cleanup;
  }
  {
#line 188
  pnmscanner_gettoken((PNMScanner *)scan, (unsigned char *)(buf), 512U);
  }
#line 189
  if (scan->eof) {
    {
#line 191
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 191
      if (at_log_file) {
        {
#line 191
        fputs((char const   */* __restrict  */)"pnm filter: premature end of file\n",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 191
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 192
    at_exception_fatal(& excep, (at_string const   )"pnm filter: premature end of file");
    }
#line 193
    goto cleanup;
  }
  {
#line 195
  tmp___5 = __ctype_b_loc();
  }
#line 195
  if ((int const   )*(*tmp___5 + (int )buf[0]) & 2048) {
    {
#line 195
    tmp___4 = atoi((char const   *)(buf));
#line 195
    pnminfo->xres = (unsigned int )tmp___4;
    }
  } else {
#line 195
    pnminfo->xres = 0U;
  }
#line 196
  if (pnminfo->xres <= 0U) {
    {
#line 198
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 198
      if (at_log_file) {
        {
#line 198
        fputs((char const   */* __restrict  */)"pnm filter: invalid xres while loading\n",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 198
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 199
    at_exception_fatal(& excep, (at_string const   )"pnm filter: premature end of file");
    }
#line 200
    goto cleanup;
  }
  {
#line 203
  pnmscanner_gettoken((PNMScanner *)scan, (unsigned char *)(buf), 512U);
  }
#line 204
  if (scan->eof) {
    {
#line 206
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 206
      if (at_log_file) {
        {
#line 206
        fputs((char const   */* __restrict  */)"pnm filter: premature end of file\n",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 206
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 207
    at_exception_fatal(& excep, (at_string const   )"pnm filter: premature end of file");
    }
#line 208
    goto cleanup;
  }
  {
#line 210
  tmp___8 = __ctype_b_loc();
  }
#line 210
  if ((int const   )*(*tmp___8 + (int )buf[0]) & 2048) {
    {
#line 210
    tmp___7 = atoi((char const   *)(buf));
#line 210
    pnminfo->yres = (unsigned int )tmp___7;
    }
  } else {
#line 210
    pnminfo->yres = 0U;
  }
#line 211
  if (pnminfo->yres <= 0U) {
    {
#line 213
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 213
      if (at_log_file) {
        {
#line 213
        fputs((char const   */* __restrict  */)"pnm filter: invalid yres while loading\n",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 213
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 214
    at_exception_fatal(& excep, (at_string const   )"pnm filter: invalid yres while loading");
    }
#line 215
    goto cleanup;
  }
#line 219
  if (pnminfo->np != 0) {
    {
#line 221
    pnmscanner_gettoken((PNMScanner *)scan, (unsigned char *)(buf), 512U);
    }
#line 222
    if (scan->eof) {
      {
#line 224
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 224
        if (at_log_file) {
          {
#line 224
          fputs((char const   */* __restrict  */)"pnm filter: premature end of file\n",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 224
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 225
      at_exception_fatal(& excep, (at_string const   )"pnm filter: invalid yres while loading");
      }
#line 226
      goto cleanup;
    }
    {
#line 229
    tmp___11 = __ctype_b_loc();
    }
#line 229
    if ((int const   )*(*tmp___11 + (int )buf[0]) & 2048) {
      {
#line 229
      tmp___10 = atoi((char const   *)(buf));
#line 229
      pnminfo->maxval = tmp___10;
      }
    } else {
#line 229
      pnminfo->maxval = 0;
    }
#line 230
    if (pnminfo->maxval <= 0) {
#line 230
      goto _L___0;
    } else
#line 230
    if (pnminfo->maxval > 255) {
#line 230
      if (! pnminfo->asciibody) {
        _L___0: /* CIL Label */ 
        {
#line 233
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 233
          if (at_log_file) {
            {
#line 233
            fputs((char const   */* __restrict  */)"pnm filter: invalid maxval while loading\n",
                  (FILE */* __restrict  */)at_log_file);
            }
          }
#line 233
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 234
        at_exception_fatal(& excep, (at_string const   )"pnm filter: invalid maxval while loading");
        }
#line 235
        goto cleanup;
      }
    }
  }
#line 239
  if (pnminfo->np) {
#line 239
    tmp___12 = pnminfo->np;
  } else {
#line 239
    tmp___12 = 1;
  }
  {
#line 239
  bitmap = at_bitmap_init((unsigned char *)((void *)0), (unsigned short )pnminfo->xres,
                          (unsigned short )pnminfo->yres, (unsigned int )tmp___12);
#line 243
  (*(pnminfo->loader))((PNMScanner *)scan, pnminfo, bitmap.bitmap, & excep);
  }
  cleanup: 
  {
#line 247
  pnmscanner_destroy((PNMScanner *)scan);
#line 250
  free((void *)pnminfo);
#line 253
  fclose(fd);
  }
#line 255
  return (bitmap);
}
}
#line 258 "input-pnm.c"
static void pnm_load_ascii(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                           at_exception_type *excep ) 
{ 
  unsigned char *d ;
  unsigned int x ;
  int i ;
  int b ;
  int start ;
  int end ;
  int scanlines ;
  int np ;
  char buf[512] ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 271
  if (info->np) {
#line 271
    np = info->np;
  } else {
#line 271
    np = 1;
  }
  {
#line 274
  pnmscanner_createbuffer(scan, 4096U);
#line 276
  start = 0;
#line 277
  end = (int )info->yres;
#line 278
  scanlines = end - start;
#line 279
  d = data;
#line 281
  i = 0;
  }
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (i < scanlines)) {
#line 281
      goto while_break;
    }
#line 282
    x = 0U;
    {
#line 282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 282
      if (! (x < info->xres)) {
#line 282
        goto while_break___0;
      }
#line 284
      b = 0;
      {
#line 284
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 284
        if (! (b < np)) {
#line 284
          goto while_break___1;
        }
#line 287
        if (scan->eof) {
          {
#line 289
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 289
            if (at_log_file) {
              {
#line 289
              fputs((char const   */* __restrict  */)"pnm filter: premature end of file\n",
                    (FILE */* __restrict  */)at_log_file);
              }
            }
#line 289
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 290
          at_exception_fatal(excep, (at_string const   )"pnm filter: premature end of file");
          }
#line 291
          return;
        }
#line 293
        if (info->np) {
          {
#line 294
          pnmscanner_gettoken(scan, (unsigned char *)(buf), 512U);
          }
        } else {
          {
#line 296
          pnmscanner_getsmalltoken(scan, (unsigned char *)(buf));
          }
        }
        {
#line 299
        if (info->maxval == 255) {
#line 299
          goto case_255;
        }
#line 302
        if (info->maxval == 1) {
#line 302
          goto case_1;
        }
#line 305
        goto switch_default;
        case_255: /* CIL Label */ 
        {
#line 300
        tmp___2 = __ctype_b_loc();
        }
#line 300
        if ((int const   )*(*tmp___2 + (int )buf[0]) & 2048) {
          {
#line 300
          tmp___0 = atoi((char const   *)(buf));
#line 300
          tmp___1 = tmp___0;
          }
        } else {
#line 300
          tmp___1 = 0;
        }
#line 300
        *(d + b) = (unsigned char )tmp___1;
#line 301
        goto switch_break;
        case_1: /* CIL Label */ 
#line 303
        if ((int )buf[0] == 48) {
#line 303
          *(d + b) = (unsigned char)255;
        } else {
#line 303
          *(d + b) = (unsigned char)0;
        }
#line 304
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 306
        tmp___6 = __ctype_b_loc();
        }
#line 306
        if ((int const   )*(*tmp___6 + (int )buf[0]) & 2048) {
          {
#line 306
          tmp___4 = atoi((char const   *)(buf));
#line 306
          tmp___5 = tmp___4;
          }
        } else {
#line 306
          tmp___5 = 0;
        }
#line 306
        *(d + b) = (unsigned char )(255.0 * ((double )tmp___5 / (double )info->maxval));
        switch_break: /* CIL Label */ ;
        }
#line 284
        b ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 311
      d += np;
#line 282
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 281
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  return;
}
}
#line 315 "input-pnm.c"
static void pnm_load_raw(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                         at_exception_type *excep ) 
{ 
  unsigned char *d ;
  unsigned int x ;
  unsigned int i ;
  unsigned int start ;
  unsigned int end ;
  unsigned int scanlines ;
  FILE *fd ;
  size_t tmp ;

  {
#line 326
  fd = scan->fd;
#line 328
  start = 0U;
#line 329
  end = info->yres;
#line 330
  scanlines = end - start;
#line 331
  d = data;
#line 333
  i = 0U;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (i < scanlines)) {
#line 333
      goto while_break;
    }
    {
#line 335
    tmp = fread((void */* __restrict  */)d, (size_t )1, (size_t )(info->xres * (unsigned int )info->np),
                (FILE */* __restrict  */)fd);
    }
#line 335
    if ((size_t )(info->xres * (unsigned int )info->np) != tmp) {
      {
#line 338
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 338
        if (at_log_file) {
          {
#line 338
          fputs((char const   */* __restrict  */)"pnm filter: premature end of file\n",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 338
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 339
      at_exception_fatal(excep, (at_string const   )"pnm filter: premature end of file\n");
      }
#line 340
      return;
    }
#line 343
    if (info->maxval != 255) {
#line 345
      x = 0U;
      {
#line 345
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 345
        if (! (x < info->xres * (unsigned int )info->np)) {
#line 345
          goto while_break___1;
        }
#line 346
        *(d + x) = (unsigned char )((255.0 * (double )*(d + x)) / (double )info->maxval);
#line 345
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 349
    d += info->xres * (unsigned int )info->np;
#line 333
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  return;
}
}
#line 353 "input-pnm.c"
static void pnm_load_rawpbm(PNMScanner *scan , PNMInfo *info , unsigned char *data ,
                            at_exception_type *excep ) 
{ 
  unsigned char *buf ;
  unsigned char curbyte ;
  unsigned char *d ;
  unsigned int x ;
  unsigned int i ;
  unsigned int start ;
  unsigned int end ;
  unsigned int scanlines ;
  FILE *fd ;
  unsigned int rowlen ;
  unsigned int bufpos ;
  double tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 367
  fd = scan->fd;
#line 368
  tmp = ceil((double )info->xres / 8.0);
#line 368
  rowlen = (unsigned int )tmp;
#line 369
  tmp___0 = malloc((unsigned long )rowlen * sizeof(unsigned char ));
#line 369
  buf = (unsigned char *)tmp___0;
#line 371
  start = 0U;
#line 372
  end = info->yres;
#line 373
  scanlines = end - start;
#line 374
  d = data;
#line 376
  i = 0U;
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < scanlines)) {
#line 376
      goto while_break;
    }
    {
#line 378
    tmp___1 = fread((void */* __restrict  */)buf, (size_t )1, (size_t )rowlen, (FILE */* __restrict  */)fd);
    }
#line 378
    if ((size_t )rowlen != tmp___1) {
      {
#line 380
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 380
        if (at_log_file) {
          {
#line 380
          fputs((char const   */* __restrict  */)"pnm filter: error reading file\n",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 380
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 381
      at_exception_fatal(excep, (at_string const   )"pnm filter: error reading file");
      }
#line 382
      goto cleanup;
    }
#line 384
    bufpos = 0U;
#line 385
    curbyte = *(buf + 0);
#line 387
    x = 0U;
    {
#line 387
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 387
      if (! (x < info->xres)) {
#line 387
        goto while_break___1;
      }
#line 389
      if (x % 8U == 0U) {
#line 390
        tmp___2 = bufpos;
#line 390
        bufpos ++;
#line 390
        curbyte = *(buf + tmp___2);
      }
#line 391
      if ((int )curbyte & 128) {
#line 391
        *(d + x) = (unsigned char)0;
      } else {
#line 391
        *(d + x) = (unsigned char)255;
      }
#line 392
      curbyte = (unsigned char )((int )curbyte << 1);
#line 387
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 395
    d += info->xres;
#line 376
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 398
  free((void *)buf);
  }
#line 399
  return;
}
}
#line 407 "input-pnm.c"
static PNMScanner *pnmscanner_create(FILE *fd ) 
{ 
  PNMScanner *s ;
  void *tmp ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 412
    tmp = malloc(sizeof(PNMScanner ));
#line 412
    s = (PNMScanner *)tmp;
    }
#line 412
    if (! s) {
      {
#line 412
      __assert_fail("s", "input-pnm.c", 412U, "pnmscanner_create");
      }
    }
#line 412
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  s->fd = fd;
#line 414
  s->inbuf = (char *)0;
#line 415
  tmp___1 = fread((void */* __restrict  */)(& s->cur), (size_t )1, (size_t )1, (FILE */* __restrict  */)s->fd);
  }
#line 415
  if (tmp___1) {
#line 415
    tmp___2 = 0;
  } else {
#line 415
    tmp___2 = 1;
  }
#line 415
  s->eof = tmp___2;
#line 416
  return (s);
}
}
#line 422 "input-pnm.c"
static void pnmscanner_destroy(PNMScanner *s ) 
{ 


  {
#line 425
  if (s->inbuf) {
    {
#line 425
    free((void *)s->inbuf);
    }
  }
  {
#line 426
  free((void *)s);
  }
#line 427
  return;
}
}
#line 432 "input-pnm.c"
static void pnmscanner_createbuffer(PNMScanner *s , unsigned int bufsize ) 
{ 
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 436
  tmp = malloc(sizeof(char ) * (unsigned long )bufsize);
#line 436
  s->inbuf = (char *)tmp;
#line 437
  s->inbufsize = (int )bufsize;
#line 438
  s->inbufpos = 0;
#line 439
  tmp___0 = fread((void */* __restrict  */)s->inbuf, (size_t )1, (size_t )bufsize,
                  (FILE */* __restrict  */)s->fd);
#line 439
  s->inbufvalidsize = (int )tmp___0;
  }
#line 440
  return;
}
}
#line 445 "input-pnm.c"
static void pnmscanner_gettoken(PNMScanner *s , unsigned char *buf , unsigned int bufsize ) 
{ 
  unsigned int ctr ;
  unsigned int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 450
  ctr = 0U;
#line 452
  pnmscanner_eatwhitespace(s);
  }
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! s->eof) {
      {
#line 453
      tmp___0 = __ctype_b_loc();
      }
#line 453
      if ((int const   )*(*tmp___0 + (int )s->cur) & 8192) {
#line 453
        goto while_break;
      } else
#line 453
      if ((int )s->cur != 35) {
#line 453
        if (! (ctr < bufsize)) {
#line 453
          goto while_break;
        }
      } else {
#line 453
        goto while_break;
      }
    } else {
#line 453
      goto while_break;
    }
    {
#line 455
    tmp = ctr;
#line 455
    ctr ++;
#line 455
    *(buf + tmp) = (unsigned char )s->cur;
#line 456
    pnmscanner_getchar(s);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  *(buf + ctr) = (unsigned char )'\000';
#line 459
  return;
}
}
#line 464 "input-pnm.c"
static void pnmscanner_getsmalltoken(PNMScanner *s , unsigned char *buf ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 468
  pnmscanner_eatwhitespace(s);
  }
#line 469
  if (! s->eof) {
    {
#line 469
    tmp = __ctype_b_loc();
    }
#line 469
    if (! ((int const   )*(*tmp + (int )s->cur) & 8192)) {
#line 469
      if ((int )s->cur != 35) {
        {
#line 471
        *buf = (unsigned char )s->cur;
#line 472
        pnmscanner_getchar(s);
        }
      }
    }
  }
#line 474
  return;
}
}
#line 479 "input-pnm.c"
static void pnmscanner_getchar(PNMScanner *s ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 482
  if (s->inbuf) {
#line 484
    tmp = s->inbufpos;
#line 484
    (s->inbufpos) ++;
#line 484
    s->cur = *(s->inbuf + tmp);
#line 485
    if (s->inbufpos >= s->inbufvalidsize) {
#line 487
      if (s->inbufsize > s->inbufvalidsize) {
#line 488
        s->eof = 1;
      } else {
        {
#line 490
        tmp___0 = fread((void */* __restrict  */)s->inbuf, (size_t )1, (size_t )s->inbufsize,
                        (FILE */* __restrict  */)s->fd);
#line 490
        s->inbufvalidsize = (int )tmp___0;
        }
      }
#line 491
      s->inbufpos = 0;
    }
  } else {
    {
#line 495
    tmp___1 = fread((void */* __restrict  */)(& s->cur), (size_t )1, (size_t )1, (FILE */* __restrict  */)s->fd);
    }
#line 495
    if (tmp___1) {
#line 495
      tmp___2 = 0;
    } else {
#line 495
      tmp___2 = 1;
    }
#line 495
    s->eof = tmp___2;
  }
#line 496
  return;
}
}
#line 502 "input-pnm.c"
static void pnmscanner_eatwhitespace(PNMScanner *s ) 
{ 
  int state ;
  unsigned short const   **tmp ;

  {
#line 505
  state = 0;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! s->eof) {
#line 507
      if (! (state != -1)) {
#line 507
        goto while_break;
      }
    } else {
#line 507
      goto while_break;
    }
    {
#line 511
    if (state == 0) {
#line 511
      goto case_0;
    }
#line 523
    if (state == 1) {
#line 523
      goto case_1;
    }
#line 509
    goto switch_break;
    case_0: /* CIL Label */ 
#line 512
    if ((int )s->cur == 35) {
      {
#line 514
      state = 1;
#line 515
      pnmscanner_getchar(s);
      }
    } else {
      {
#line 517
      tmp = __ctype_b_loc();
      }
#line 517
      if ((int const   )*(*tmp + (int )s->cur) & 8192) {
        {
#line 520
        pnmscanner_getchar(s);
        }
      } else {
#line 518
        state = -1;
      }
    }
#line 521
    goto switch_break;
    case_1: /* CIL Label */ 
#line 524
    if ((int )s->cur == 10) {
#line 525
      state = 0;
    }
    {
#line 526
    pnmscanner_getchar(s);
    }
#line 527
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  return;
}
}
#line 1414 "/usr/local/include/png.h"
extern png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                          void (*error_fn)(png_structp  , png_const_charp  ) ,
                                          void (*warn_fn)(png_structp  , png_const_charp  ) )  __attribute__((__malloc__)) ;
#line 1486
extern png_infop png_create_info_struct(png_structp png_ptr )  __attribute__((__malloc__)) ;
#line 1500
extern void png_read_info(png_structp png_ptr , png_infop info_ptr ) ;
#line 1521
extern void png_set_expand(png_structp png_ptr ) ;
#line 1554
extern void png_set_strip_alpha(png_structp png_ptr ) ;
#line 1586
extern void png_set_packing(png_structp png_ptr ) ;
#line 1615
extern void png_set_background(png_structp png_ptr , png_color_16p background_color ,
                               int background_gamma_code , int need_expand , double background_gamma ) ;
#line 1627
extern void png_set_strip_16(png_structp png_ptr ) ;
#line 1661
extern void png_read_update_info(png_structp png_ptr , png_infop info_ptr ) ;
#line 1679
extern void png_read_image(png_structp png_ptr , png_bytepp image ) ;
#line 1701
extern void png_read_end(png_structp png_ptr , png_infop info_ptr ) ;
#line 1710
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 1822
extern void png_init_io(png_structp png_ptr , png_FILE_p fp ) ;
#line 1925
extern png_voidp png_malloc(png_structp png_ptr , png_alloc_size_t size )  __attribute__((__malloc__)) ;
#line 2020
extern png_uint_32 png_get_valid(png_const_structp png_ptr , png_const_infop info_ptr ,
                                 png_uint_32 flag ) ;
#line 2024
extern png_size_t png_get_rowbytes(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 2031
extern png_bytepp png_get_rows(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 2046
extern png_uint_32 png_get_image_width(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 2050
extern png_uint_32 png_get_image_height(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 2058
extern png_byte png_get_color_type(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 2104
extern png_uint_32 png_get_bKGD(png_const_structp png_ptr , png_infop info_ptr , png_color_16p *background ) ;
#line 27 "input-png.h"
at_bitmap_type input_png_reader(at_string filename___0 , at_input_opts_type *opts ,
                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                 at_address client_data ) , at_address msg_data ) ;
#line 36 "input-png.c"
static png_bytep *read_png(png_structp png_ptr , png_infop info_ptr , at_input_opts_type *opts ) ;
#line 43 "input-png.c"
static void handle_warning(png_structp png , at_string const   message ) 
{ 


  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (at_log_file) {
      {
#line 44
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"PNG warning: %s",
              message);
      }
    }
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  at_exception_warning((at_exception_type *)png->error_ptr, message);
  }
#line 49
  return;
}
}
#line 51 "input-png.c"
static void handle_error(png_structp png , at_string const   message ) 
{ 


  {
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (at_log_file) {
      {
#line 52
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"PNG error: %s",
              message);
      }
    }
#line 52
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  at_exception_fatal((at_exception_type *)png->error_ptr, message);
  }
#line 58
  return;
}
}
#line 60 "input-png.c"
static void finalize_structs(png_structp png , png_infop info , png_infop end_info ) 
{ 
  png_infop *tmp ;
  png_infop *tmp___0 ;
  png_structp *tmp___1 ;

  {
#line 63
  if (end_info) {
#line 63
    tmp = & end_info;
  } else {
#line 63
    tmp = (png_infop *)((void *)0);
  }
#line 63
  if (info) {
#line 63
    tmp___0 = & info;
  } else {
#line 63
    tmp___0 = (png_infop *)((void *)0);
  }
#line 63
  if (png) {
#line 63
    tmp___1 = & png;
  } else {
#line 63
    tmp___1 = (png_structp *)((void *)0);
  }
  {
#line 63
  png_destroy_read_struct(tmp___1, tmp___0, tmp);
  }
#line 66
  return;
}
}
#line 68 "input-png.c"
static int init_structs(png_structp *png , png_infop *info , png_infop *end_info ,
                        at_exception_type *exp ) 
{ 
  png_infop tmp ;

  {
  {
#line 71
  *png = (png_structp )((void *)0);
#line 72
  tmp = (png_infop )((void *)0);
#line 72
  *end_info = tmp;
#line 72
  *info = tmp;
#line 74
  *png = png_create_read_struct("1.4.22", (png_voidp )exp, (void (*)(png_structp  ,
                                                                     png_const_charp  ))(& handle_error),
                                (void (*)(png_structp  , png_const_charp  ))(& handle_warning));
  }
#line 77
  if (*png) {
    {
#line 78
    *info = png_create_info_struct(*png);
    }
#line 79
    if (*info) {
      {
#line 80
      *end_info = png_create_info_struct(*png);
      }
#line 81
      if (*end_info) {
#line 81
        return (1);
      }
    }
    {
#line 83
    finalize_structs(*png, *info, *end_info);
    }
  }
#line 85
  return (0);
}
}
#line 94 "input-png.c"
static int load_image(at_bitmap_type *image , FILE *stream , at_input_opts_type *opts ,
                      at_exception_type *exp ) 
{ 
  png_structp png ;
  png_infop info ;
  png_infop end_info ;
  png_bytep *rows ;
  unsigned short width ;
  unsigned short height ;
  unsigned short row ;
  int pixel_size ;
  int result ;
  int tmp ;
  at_bool tmp___0 ;
  png_uint_32 tmp___1 ;
  png_uint_32 tmp___2 ;
  png_byte tmp___3 ;

  {
  {
#line 101
  result = 1;
#line 103
  tmp = init_structs(& png, & info, & end_info, exp);
  }
#line 103
  if (! tmp) {
#line 104
    return (0);
  }
  {
#line 106
  png_init_io(png, stream);
  }
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    tmp___0 = at_exception_got_fatal(exp);
    }
#line 107
    if (tmp___0) {
#line 107
      result = 0;
#line 107
      goto cleanup;
    }
#line 107
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  rows = read_png(png, info, opts);
#line 111
  tmp___1 = png_get_image_width((png_const_structp )png, (png_const_infop )info);
#line 111
  width = (unsigned short )tmp___1;
#line 112
  tmp___2 = png_get_image_height((png_const_structp )png, (png_const_infop )info);
#line 112
  height = (unsigned short )tmp___2;
#line 113
  tmp___3 = png_get_color_type((png_const_structp )png, (png_const_infop )info);
  }
#line 113
  if ((int )tmp___3 == 0) {
#line 114
    pixel_size = 1;
  } else {
#line 116
    pixel_size = 3;
  }
  {
#line 119
  *image = at_bitmap_init((unsigned char *)((void *)0), width, height, (unsigned int )pixel_size);
#line 120
  row = (unsigned short)0;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! ((int )row < (int )height)) {
#line 120
      goto while_break___0;
    }
    {
#line 121
    memcpy((void */* __restrict  */)((image->bitmap + ((unsigned int )row * image->np) * (unsigned int )image->width) + 0U),
           (void const   */* __restrict  */)*rows, (unsigned long )((int )width * pixel_size) * sizeof(unsigned char ));
#line 120
    row = (unsigned short )((int )row + 1);
#line 120
    rows ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 125
  finalize_structs(png, info, end_info);
  }
#line 126
  return (result);
}
}
#line 129 "input-png.c"
at_bitmap_type input_png_reader(at_string filename___0 , at_input_opts_type *opts ,
                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                 at_address client_data ) , at_address msg_data ) 
{ 
  FILE *stream ;
  at_bitmap_type image ;
  at_bitmap_type tmp ;
  at_exception_type exp ;
  at_exception_type tmp___0 ;

  {
  {
#line 132
  tmp = at_bitmap_init((unsigned char *)0, (unsigned short)0, (unsigned short)0, 1U);
#line 132
  image = tmp;
#line 133
  tmp___0 = at_exception_new(msg_func, msg_data);
#line 133
  exp = tmp___0;
#line 135
  stream = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"rb");
  }
#line 136
  if (! stream) {
    {
#line 138
    while (1) {
      while_continue: /* CIL Label */ ;
#line 138
      if (at_log_file) {
        {
#line 138
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Can\'t open \"%s\"\n",
                filename___0);
        }
      }
#line 138
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 139
    at_exception_fatal(& exp, (at_string const   )"Cannot open input png file");
    }
#line 140
    return (image);
  }
  {
#line 143
  load_image(& image, stream, opts, & exp);
#line 144
  fclose(stream);
  }
#line 146
  return (image);
}
}
#line 149 "input-png.c"
static png_bytep *read_png(png_structp png_ptr , png_infop info_ptr , at_input_opts_type *opts ) 
{ 
  int row ;
  png_color_16p original_bg ;
  png_color_16 my_bg ;
  png_uint_32 tmp ;
  png_uint_32 tmp___0 ;
  png_voidp tmp___1 ;
  png_size_t tmp___2 ;
  png_voidp tmp___3 ;
  png_bytepp tmp___4 ;

  {
  {
#line 156
  png_read_info(png_ptr, info_ptr);
#line 158
  png_set_strip_16(png_ptr);
#line 159
  png_set_packing(png_ptr);
  }
#line 160
  if ((int )png_ptr->bit_depth < 8) {
    {
#line 163
    png_set_expand(png_ptr);
    }
  } else
#line 160
  if ((int )png_ptr->color_type == 3) {
    {
#line 163
    png_set_expand(png_ptr);
    }
  } else {
    {
#line 160
    tmp = png_get_valid((png_const_structp )png_ptr, (png_const_infop )info_ptr, (png_uint_32 )16);
    }
#line 160
    if (tmp) {
      {
#line 163
      png_set_expand(png_ptr);
      }
    }
  }
  {
#line 165
  tmp___0 = png_get_bKGD((png_const_structp )png_ptr, info_ptr, & original_bg);
  }
#line 165
  if (tmp___0) {
#line 167
    my_bg.index = (png_byte )0;
#line 169
    if (opts) {
#line 169
      if (opts->background_color) {
#line 170
        my_bg.red = (png_uint_16 )(256 * (int )(opts->background_color)->r);
#line 171
        my_bg.green = (png_uint_16 )(256 * (int )(opts->background_color)->g);
#line 172
        my_bg.blue = (png_uint_16 )(256 * (int )(opts->background_color)->b);
#line 173
        my_bg.gray = (png_uint_16 )(256 * ((((int )(opts->background_color)->r + (int )(opts->background_color)->g) + (int )(opts->background_color)->b) / 3));
      } else {
#line 178
        my_bg.gray = (png_uint_16 )65535;
#line 178
        my_bg.blue = my_bg.gray;
#line 178
        my_bg.green = my_bg.blue;
#line 178
        my_bg.red = my_bg.green;
      }
    } else {
#line 178
      my_bg.gray = (png_uint_16 )65535;
#line 178
      my_bg.blue = my_bg.gray;
#line 178
      my_bg.green = my_bg.blue;
#line 178
      my_bg.red = my_bg.green;
    }
    {
#line 180
    png_set_background(png_ptr, & my_bg, 2, 1, 1.0);
    }
  } else {
    {
#line 183
    png_set_strip_alpha(png_ptr);
    }
  }
  {
#line 184
  png_read_update_info(png_ptr, info_ptr);
#line 187
  tmp___1 = png_malloc(png_ptr, (unsigned long )info_ptr->height * sizeof(png_bytep ));
#line 187
  info_ptr->row_pointers = (png_bytepp )tmp___1;
#line 192
  row = 0;
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (row < (int )info_ptr->height)) {
#line 192
      goto while_break;
    }
    {
#line 193
    tmp___2 = png_get_rowbytes((png_const_structp )png_ptr, (png_const_infop )info_ptr);
#line 193
    tmp___3 = png_malloc(png_ptr, tmp___2);
#line 193
    *(info_ptr->row_pointers + row) = (png_bytep )tmp___3;
#line 192
    row ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  png_read_image(png_ptr, info_ptr->row_pointers);
#line 197
  info_ptr->valid = (png_uint_32 )((long )info_ptr->valid | 32768L);
#line 198
  png_read_end(png_ptr, info_ptr);
#line 199
  tmp___4 = png_get_rows((png_const_structp )png_ptr, (png_const_infop )info_ptr);
  }
#line 199
  return (tmp___4);
}
}
#line 35 "input.h"
int at_input_add_handler(at_string suffix , at_string description , at_bitmap_type (*func)(at_string name ,
                                                                                           at_input_opts_type *opts ,
                                                                                           void (*msg_func)(at_string msg ,
                                                                                                            at_msg_type msg_type ,
                                                                                                            at_address client_data ) ,
                                                                                           at_address msg_data ) ) ;
#line 26 "input-bmp.h"
at_bitmap_type input_bmp_reader(at_string filename___0 , at_input_opts_type *opts ,
                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                 at_address client_data ) , at_address msg_data ) ;
#line 50 "input.c"
static struct input_format_entry input_formats[7]  = {      {"TGA", "Truevision Targa image", & input_tga_reader}, 
        {"PBM", "Portable bitmap format", & input_pnm_reader}, 
        {"PNM", "Portable anymap format", & input_pnm_reader}, 
        {"PGM", "Portable graymap format", & input_pnm_reader}, 
        {"PPM", "Portable pixmap format", & input_pnm_reader}, 
        {"BMP", "Microsoft Windows bitmap image", & input_bmp_reader}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (at_bitmap_type (*)(at_string name ,
                                                                                    at_input_opts_type *opts ,
                                                                                    void (*msg_func)(at_string msg ,
                                                                                                     at_msg_type msg_type ,
                                                                                                     at_address client_data ) ,
                                                                                    at_address msg_data ))((void *)0)}};
#line 63 "input.c"
at_input_read_func at_input_get_handler(at_string filename___0 ) 
{ 
  char *ext ;
  at_string tmp ;
  at_input_read_func tmp___0 ;

  {
  {
#line 66
  tmp = find_suffix(filename___0);
#line 66
  ext = tmp;
  }
#line 67
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 68
    ext = (char *)"";
  }
  {
#line 70
  tmp___0 = at_input_get_handler_by_suffix(ext);
  }
#line 70
  return (tmp___0);
}
}
#line 73 "input.c"
at_input_read_func at_input_get_handler_by_suffix(at_string suffix ) 
{ 
  struct input_format_entry *format ;
  at_bool tmp ;

  {
#line 78
  if (! suffix) {
#line 79
    return ((at_input_read_func )((void *)0));
  } else
#line 78
  if ((int )*(suffix + 0) == 0) {
#line 79
    return ((at_input_read_func )((void *)0));
  }
#line 81
  format = input_formats;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! format->name) {
#line 81
      goto while_break;
    }
    {
#line 83
    tmp = strgicmp((char const   *)suffix, format->name);
    }
#line 83
    if (tmp) {
#line 85
      return (format->reader);
    }
#line 81
    format ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return ((at_input_read_func )((void *)0));
}
}
#line 95 "input.c"
char **at_input_list_new(void) 
{ 
  char **list ;
  int count ;
  int count_int ;
  int i ;
  struct input_format_entry *entry ;
  void *tmp ;

  {
#line 99
  count_int = 0;
#line 111
  entry = input_formats;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! entry->name) {
#line 111
      goto while_break;
    }
#line 112
    count_int ++;
#line 111
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  count = count_int;
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 143
    tmp = malloc(sizeof(char *) * (unsigned long )(2 * count + 1));
#line 143
    list = (char **)tmp;
    }
#line 143
    if (! list) {
      {
#line 143
      __assert_fail("list", "input.c", 143U, "at_input_list_new");
      }
    }
#line 143
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 145
  entry = input_formats;
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 146
    if (! (i < count_int)) {
#line 146
      goto while_break___1;
    }
#line 148
    *(list + 2 * i) = (char *)(entry + i)->name;
#line 149
    *(list + (2 * i + 1)) = (char *)(entry + i)->descr;
#line 146
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 174
  *(list + 2 * i) = (char *)((void *)0);
#line 175
  return (list);
}
}
#line 178 "input.c"
void at_input_list_free(char **list ) 
{ 


  {
  {
#line 181
  free((void *)list);
  }
#line 182
  return;
}
}
#line 184 "input.c"
char *at_input_shortlist(void) 
{ 
  char *list ;
  int count_int ;
  size_t length ;
  int i ;
  struct input_format_entry *entry ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 188
  count_int = 0;
#line 189
  length = (size_t )0;
#line 201
  entry = input_formats;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! entry->name) {
#line 201
      goto while_break;
    }
    {
#line 203
    count_int ++;
#line 204
    tmp = strlen(entry->name);
#line 204
    length += tmp + 2UL;
#line 201
    entry ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 239
    tmp___0 = malloc(sizeof(char ) * ((length + 1UL) + 2UL));
#line 239
    list = (char *)tmp___0;
    }
#line 239
    if (! list) {
      {
#line 239
      __assert_fail("list", "input.c", 239U, "at_input_shortlist");
      }
    }
#line 239
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 241
  entry = input_formats;
#line 242
  strcpy((char */* __restrict  */)list, (char const   */* __restrict  */)((char *)(entry + 0)->name));
#line 243
  i = 1;
  }
  {
#line 243
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 243
    if (! (i < count_int - 1)) {
#line 243
      goto while_break___1;
    }
    {
#line 245
    strcat((char */* __restrict  */)list, (char const   */* __restrict  */)", ");
#line 246
    strcat((char */* __restrict  */)list, (char const   */* __restrict  */)((char *)(entry + i)->name));
#line 243
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 268
  strcat((char */* __restrict  */)list, (char const   */* __restrict  */)" or ");
#line 269
  strcat((char */* __restrict  */)list, (char const   */* __restrict  */)((char *)(entry + i)->name));
  }
#line 270
  return (list);
}
}
#line 273 "input.c"
int at_input_add_handler(at_string suffix , at_string description , at_bitmap_type (*func)(at_string name ,
                                                                                           at_input_opts_type *opts ,
                                                                                           void (*msg_func)(at_string msg ,
                                                                                                            at_msg_type msg_type ,
                                                                                                            at_address client_data ) ,
                                                                                           at_address msg_data ) ) 
{ 


  {
#line 278
  return (0);
}
}
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 42 "input-bmp.c"
struct Bitmap_File_Head_Struct Bitmap_File_Head  ;
#line 52 "input-bmp.c"
struct Bitmap_Head_Struct Bitmap_Head  ;
#line 67
static long ToL(unsigned char *puffer ) ;
#line 68
static short ToS(unsigned char *puffer ) ;
#line 69
static int ReadColorMap(FILE *fd , unsigned char (*buffer___0)[3] , int number , int size ,
                        int *grey , at_exception_type *exp ) ;
#line 75
static unsigned char *ReadImage___0(FILE *fd , int width , int height , unsigned char (*cmap)[3] ,
                                    int bpp , int compression , int rowbytes , int grey ) ;
#line 84 "input-bmp.c"
at_bitmap_type input_bmp_reader(at_string filename___0 , at_input_opts_type *opts ,
                                void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                 at_address client_data ) , at_address msg_data ) 
{ 
  FILE *fd ;
  unsigned char buffer___0[64] ;
  int ColormapSize ;
  int rowbytes ;
  int Maps ;
  int Grey ;
  unsigned char ColorMap[256][3] ;
  at_bitmap_type image ;
  at_bitmap_type tmp ;
  unsigned char *image_storage ;
  at_exception_type exp ;
  at_exception_type tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  short tmp___4 ;
  short tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  size_t tmp___8 ;
  short tmp___9 ;
  short tmp___10 ;
  short tmp___11 ;
  short tmp___12 ;
  size_t tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  short tmp___16 ;
  short tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  size_t tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  short tmp___27 ;
  short tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  long tmp___31 ;
  long tmp___32 ;
  long tmp___33 ;
  long tmp___34 ;
  at_bool tmp___35 ;
  int tmp___36 ;

  {
  {
#line 94
  tmp = at_bitmap_init((unsigned char *)0, (unsigned short)0, (unsigned short)0, 1U);
#line 94
  image = tmp;
#line 96
  tmp___0 = at_exception_new(msg_func, msg_data);
#line 96
  exp = tmp___0;
#line 98
  fd = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"rb");
  }
#line 100
  if (! fd) {
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 102
      if (at_log_file) {
        {
#line 102
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Can\'t open \"%s\"\n",
                filename___0);
        }
      }
#line 102
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 103
    at_exception_fatal(& exp, (at_string const   )"bmp: cannot open input file");
    }
#line 104
    return (image);
  }
  {
#line 110
  tmp___1 = fread((void */* __restrict  */)(buffer___0), (size_t )18, (size_t )1,
                  (FILE */* __restrict  */)fd);
  }
#line 110
  if (tmp___1 != 0UL) {
    {
#line 110
    tmp___2 = strncmp((char const   *)(buffer___0), "BM", (size_t )2);
    }
#line 110
    if (tmp___2) {
      _L: /* CIL Label */ 
      {
#line 112
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 112
        if (at_log_file) {
          {
#line 112
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Not a valid BMP file %s\n",
                  filename___0);
          }
        }
#line 112
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 113
      at_exception_fatal(& exp, (at_string const   )"bmp: invalid input file");
      }
#line 114
      goto cleanup;
    }
  } else {
#line 110
    goto _L;
  }
  {
#line 119
  tmp___3 = ToL(& buffer___0[2]);
#line 119
  Bitmap_File_Head.bfSize = (unsigned long )tmp___3;
#line 120
  tmp___4 = ToS(& buffer___0[6]);
#line 120
  Bitmap_File_Head.zzHotX = (unsigned short )tmp___4;
#line 121
  tmp___5 = ToS(& buffer___0[8]);
#line 121
  Bitmap_File_Head.zzHotY = (unsigned short )tmp___5;
#line 122
  tmp___6 = ToL(& buffer___0[10]);
#line 122
  Bitmap_File_Head.bfOffs = (unsigned long )tmp___6;
#line 123
  tmp___7 = ToL(& buffer___0[14]);
#line 123
  Bitmap_File_Head.biSize = (unsigned long )tmp___7;
  }
#line 127
  if (Bitmap_File_Head.biSize == 12UL) {
    {
#line 129
    tmp___8 = fread((void */* __restrict  */)(buffer___0), (size_t )8, (size_t )1,
                    (FILE */* __restrict  */)fd);
    }
#line 129
    if (! (tmp___8 != 0UL)) {
      {
#line 131
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 131
        if (at_log_file) {
          {
#line 131
          fputs((char const   */* __restrict  */)"Error reading BMP file header\n",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 131
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 132
      at_exception_fatal(& exp, (at_string const   )"Error reading BMP file header");
      }
#line 133
      goto cleanup;
    }
    {
#line 136
    tmp___9 = ToS(& buffer___0[0]);
#line 136
    Bitmap_Head.biWidth = (unsigned long )tmp___9;
#line 137
    tmp___10 = ToS(& buffer___0[2]);
#line 137
    Bitmap_Head.biHeight = (unsigned long )tmp___10;
#line 138
    tmp___11 = ToS(& buffer___0[4]);
#line 138
    Bitmap_Head.biPlanes = (unsigned short )tmp___11;
#line 139
    tmp___12 = ToS(& buffer___0[6]);
#line 139
    Bitmap_Head.biBitCnt = (unsigned short )tmp___12;
#line 140
    Bitmap_Head.biCompr = 0UL;
#line 141
    Bitmap_Head.biSizeIm = 0UL;
#line 142
    Bitmap_Head.biYPels = 0UL;
#line 142
    Bitmap_Head.biXPels = Bitmap_Head.biYPels;
#line 143
    Bitmap_Head.biClrUsed = 0UL;
#line 144
    Maps = 3;
    }
  } else
#line 146
  if (Bitmap_File_Head.biSize == 40UL) {
    {
#line 148
    tmp___13 = fread((void */* __restrict  */)(buffer___0), Bitmap_File_Head.biSize - 4UL,
                     (size_t )1, (FILE */* __restrict  */)fd);
    }
#line 148
    if (! (tmp___13 != 0UL)) {
      {
#line 150
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 150
        if (at_log_file) {
          {
#line 150
          fputs((char const   */* __restrict  */)"Error reading BMP file header\n",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 150
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 151
      at_exception_fatal(& exp, (at_string const   )"Error reading BMP file header");
      }
#line 152
      goto cleanup;
    }
    {
#line 156
    tmp___14 = ToL(& buffer___0[0]);
#line 156
    Bitmap_Head.biWidth = (unsigned long )tmp___14;
#line 157
    tmp___15 = ToL(& buffer___0[4]);
#line 157
    Bitmap_Head.biHeight = (unsigned long )tmp___15;
#line 158
    tmp___16 = ToS(& buffer___0[8]);
#line 158
    Bitmap_Head.biPlanes = (unsigned short )tmp___16;
#line 159
    tmp___17 = ToS(& buffer___0[10]);
#line 159
    Bitmap_Head.biBitCnt = (unsigned short )tmp___17;
#line 160
    tmp___18 = ToL(& buffer___0[12]);
#line 160
    Bitmap_Head.biCompr = (unsigned long )tmp___18;
#line 161
    tmp___19 = ToL(& buffer___0[16]);
#line 161
    Bitmap_Head.biSizeIm = (unsigned long )tmp___19;
#line 162
    tmp___20 = ToL(& buffer___0[20]);
#line 162
    Bitmap_Head.biXPels = (unsigned long )tmp___20;
#line 163
    tmp___21 = ToL(& buffer___0[24]);
#line 163
    Bitmap_Head.biYPels = (unsigned long )tmp___21;
#line 164
    tmp___22 = ToL(& buffer___0[28]);
#line 164
    Bitmap_Head.biClrUsed = (unsigned long )tmp___22;
#line 165
    tmp___23 = ToL(& buffer___0[32]);
#line 165
    Bitmap_Head.biClrImp = (unsigned long )tmp___23;
#line 167
    Maps = 4;
    }
  } else
#line 169
  if (Bitmap_File_Head.biSize <= 64UL) {
    {
#line 171
    tmp___24 = fread((void */* __restrict  */)(buffer___0), Bitmap_File_Head.biSize - 4UL,
                     (size_t )1, (FILE */* __restrict  */)fd);
    }
#line 171
    if (! (tmp___24 != 0UL)) {
      {
#line 173
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 173
        if (at_log_file) {
          {
#line 173
          fputs((char const   */* __restrict  */)"Error reading BMP file header\n",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 173
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 174
      at_exception_fatal(& exp, (at_string const   )"Error reading BMP file header");
      }
#line 175
      goto cleanup;
    }
    {
#line 178
    tmp___25 = ToL(& buffer___0[0]);
#line 178
    Bitmap_Head.biWidth = (unsigned long )tmp___25;
#line 179
    tmp___26 = ToL(& buffer___0[4]);
#line 179
    Bitmap_Head.biHeight = (unsigned long )tmp___26;
#line 180
    tmp___27 = ToS(& buffer___0[8]);
#line 180
    Bitmap_Head.biPlanes = (unsigned short )tmp___27;
#line 181
    tmp___28 = ToS(& buffer___0[10]);
#line 181
    Bitmap_Head.biBitCnt = (unsigned short )tmp___28;
#line 182
    tmp___29 = ToL(& buffer___0[12]);
#line 182
    Bitmap_Head.biCompr = (unsigned long )tmp___29;
#line 183
    tmp___30 = ToL(& buffer___0[16]);
#line 183
    Bitmap_Head.biSizeIm = (unsigned long )tmp___30;
#line 184
    tmp___31 = ToL(& buffer___0[20]);
#line 184
    Bitmap_Head.biXPels = (unsigned long )tmp___31;
#line 185
    tmp___32 = ToL(& buffer___0[24]);
#line 185
    Bitmap_Head.biYPels = (unsigned long )tmp___32;
#line 186
    tmp___33 = ToL(& buffer___0[28]);
#line 186
    Bitmap_Head.biClrUsed = (unsigned long )tmp___33;
#line 187
    tmp___34 = ToL(& buffer___0[32]);
#line 187
    Bitmap_Head.biClrImp = (unsigned long )tmp___34;
#line 189
    Maps = 3;
    }
  } else {
    {
#line 193
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 193
      if (at_log_file) {
        {
#line 193
        fputs((char const   */* __restrict  */)"Error reading BMP file header\n",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 193
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 194
    at_exception_fatal(& exp, (at_string const   )"Error reading BMP file header");
    }
#line 195
    goto cleanup;
  }
#line 203
  ColormapSize = (int )(((Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize) - 14UL) / (unsigned long )Maps);
#line 205
  if (Bitmap_Head.biClrUsed == 0UL) {
#line 205
    if ((int )Bitmap_Head.biBitCnt <= 8) {
#line 206
      Bitmap_Head.biClrUsed = (unsigned long )ColormapSize;
    }
  }
#line 210
  if (Bitmap_Head.biHeight == 0UL) {
#line 210
    goto _L___1;
  } else
#line 210
  if (Bitmap_Head.biWidth == 0UL) {
#line 210
    goto _L___1;
  } else
#line 210
  if ((int )Bitmap_Head.biPlanes != 1) {
#line 210
    goto _L___1;
  } else
#line 210
  if (ColormapSize > 256) {
#line 210
    goto _L___1;
  } else
#line 210
  if (Bitmap_Head.biClrUsed > 256UL) {
    _L___1: /* CIL Label */ 
    {
#line 214
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 214
      if (at_log_file) {
        {
#line 214
        fputs((char const   */* __restrict  */)"Error reading BMP file header\n",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 214
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 215
    at_exception_fatal(& exp, (at_string const   )"Error reading BMP file header");
    }
#line 216
    goto cleanup;
  }
  {
#line 223
  rowbytes = (int )(((Bitmap_Head.biWidth * (unsigned long )Bitmap_Head.biBitCnt - 1UL) / 32UL) * 4UL + 4UL);
#line 232
  ReadColorMap(fd, (unsigned char (*)[3])(ColorMap), ColormapSize, Maps, & Grey, & exp);
#line 233
  tmp___35 = at_exception_got_fatal(& exp);
  }
#line 233
  if (tmp___35) {
#line 234
    goto cleanup;
  }
  {
#line 241
  image_storage = ReadImage___0(fd, (int )Bitmap_Head.biWidth, (int )Bitmap_Head.biHeight,
                                (unsigned char (*)[3])(ColorMap), (int )Bitmap_Head.biBitCnt,
                                (int )Bitmap_Head.biCompr, rowbytes, Grey);
  }
#line 248
  if (Grey) {
#line 248
    tmp___36 = 1;
  } else {
#line 248
    tmp___36 = 3;
  }
  {
#line 248
  image = at_bitmap_init(image_storage, (unsigned short )Bitmap_Head.biWidth, (unsigned short )Bitmap_Head.biHeight,
                         (unsigned int )tmp___36);
  }
  cleanup: 
  {
#line 253
  fclose(fd);
  }
#line 254
  return (image);
}
}
#line 257 "input-bmp.c"
static int ReadColorMap(FILE *fd , unsigned char (*buffer___0)[3] , int number , int size ,
                        int *grey , at_exception_type *exp ) 
{ 
  int i ;
  unsigned char rgb[4] ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 268
  *grey = number > 2;
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (i < number)) {
#line 269
      goto while_break;
    }
    {
#line 271
    tmp = fread((void */* __restrict  */)(rgb), (size_t )size, (size_t )1, (FILE */* __restrict  */)fd);
    }
#line 271
    if (! (tmp != 0UL)) {
      {
#line 273
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 273
        if (at_log_file) {
          {
#line 273
          fputs((char const   */* __restrict  */)"Bad colormap\n", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 273
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 274
      at_exception_fatal(exp, (at_string const   )"Bad colormap");
      }
#line 275
      goto cleanup;
    }
#line 280
    (*(buffer___0 + i))[0] = rgb[2];
#line 281
    (*(buffer___0 + i))[1] = rgb[1];
#line 282
    (*(buffer___0 + i))[2] = rgb[0];
#line 283
    if (*grey) {
#line 283
      if ((int )rgb[0] == (int )rgb[1]) {
#line 283
        if ((int )rgb[1] == (int )rgb[2]) {
#line 283
          tmp___0 = 1;
        } else {
#line 283
          tmp___0 = 0;
        }
      } else {
#line 283
        tmp___0 = 0;
      }
    } else {
#line 283
      tmp___0 = 0;
    }
#line 283
    *grey = tmp___0;
#line 269
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 286
  return (0);
}
}
#line 289 "input-bmp.c"
static unsigned char *ReadImage___0(FILE *fd , int width , int height , unsigned char (*cmap)[3] ,
                                    int bpp , int compression , int rowbytes , int grey ) 
{ 
  unsigned char v ;
  unsigned char howmuch ;
  int xpos ;
  int ypos ;
  unsigned char *image ;
  unsigned char *temp ;
  unsigned char *buffer___0 ;
  long rowstride ;
  long channels ;
  unsigned short rgb ;
  int i ;
  int j ;
  int notused ;
  void *tmp ;
  void *tmp___1 ;
  void *tmp___3 ;
  void *tmp___5 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  size_t tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  size_t tmp___14 ;
  short tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  unsigned char *temp2 ;
  unsigned char *temp3 ;
  unsigned char index___0 ;
  void *tmp___26 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;

  {
#line 300
  xpos = 0;
#line 300
  ypos = 0;
#line 307
  if (bpp >= 16) {
    {
#line 309
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 309
      tmp = malloc((unsigned long )((width * height) * 3) * sizeof(unsigned char ));
#line 309
      image = (unsigned char *)tmp;
      }
#line 309
      if (! image) {
        {
#line 309
        __assert_fail("image", "input-bmp.c", 309U, "ReadImage");
        }
      }
#line 309
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 310
    channels = 3L;
  } else
#line 312
  if (grey) {
    {
#line 314
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 314
      tmp___1 = malloc((unsigned long )(width * height) * sizeof(unsigned char ));
#line 314
      image = (unsigned char *)tmp___1;
      }
#line 314
      if (! image) {
        {
#line 314
        __assert_fail("image", "input-bmp.c", 314U, "ReadImage");
        }
      }
#line 314
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 315
    channels = 1L;
  } else {
    {
#line 319
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 319
      tmp___3 = malloc((unsigned long )(width * height) * sizeof(unsigned char ));
#line 319
      image = (unsigned char *)tmp___3;
      }
#line 319
      if (! image) {
        {
#line 319
        __assert_fail("image", "input-bmp.c", 319U, "ReadImage");
        }
      }
#line 319
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 320
    channels = 1L;
  }
  {
#line 323
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 323
    tmp___5 = malloc((size_t )rowbytes);
#line 323
    buffer___0 = (unsigned char *)tmp___5;
    }
#line 323
    if (! buffer___0) {
      {
#line 323
      __assert_fail("buffer", "input-bmp.c", 323U, "ReadImage");
      }
    }
#line 323
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 324
  rowstride = (long )width * channels;
#line 326
  ypos = height - 1;
  {
#line 330
  if (bpp == 32) {
#line 330
    goto case_32;
  }
#line 346
  if (bpp == 24) {
#line 346
    goto case_24;
  }
#line 362
  if (bpp == 16) {
#line 362
    goto case_16;
  }
#line 381
  if (bpp == 1) {
#line 381
    goto case_1;
  }
#line 381
  if (bpp == 4) {
#line 381
    goto case_1;
  }
#line 381
  if (bpp == 8) {
#line 381
    goto case_1;
  }
#line 476
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 332
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 332
    tmp___10 = fread((void */* __restrict  */)buffer___0, (size_t )rowbytes, (size_t )1,
                     (FILE */* __restrict  */)fd);
    }
#line 332
    if (! (tmp___10 != 0UL)) {
#line 332
      goto while_break___3;
    }
#line 334
    temp = image + (long )ypos * rowstride;
#line 335
    xpos = 0;
    {
#line 335
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 335
      if (! (xpos < width)) {
#line 335
        goto while_break___4;
      }
#line 337
      tmp___7 = temp;
#line 337
      temp ++;
#line 337
      *tmp___7 = *(buffer___0 + (xpos * 4 + 2));
#line 338
      tmp___8 = temp;
#line 338
      temp ++;
#line 338
      *tmp___8 = *(buffer___0 + (xpos * 4 + 1));
#line 339
      tmp___9 = temp;
#line 339
      temp ++;
#line 339
      *tmp___9 = *(buffer___0 + xpos * 4);
#line 335
      xpos ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 341
    ypos --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 344
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 348
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 348
    tmp___14 = fread((void */* __restrict  */)buffer___0, (size_t )rowbytes, (size_t )1,
                     (FILE */* __restrict  */)fd);
    }
#line 348
    if (! (tmp___14 != 0UL)) {
#line 348
      goto while_break___5;
    }
#line 350
    temp = image + (long )ypos * rowstride;
#line 351
    xpos = 0;
    {
#line 351
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 351
      if (! (xpos < width)) {
#line 351
        goto while_break___6;
      }
#line 353
      tmp___11 = temp;
#line 353
      temp ++;
#line 353
      *tmp___11 = *(buffer___0 + (xpos * 3 + 2));
#line 354
      tmp___12 = temp;
#line 354
      temp ++;
#line 354
      *tmp___12 = *(buffer___0 + (xpos * 3 + 1));
#line 355
      tmp___13 = temp;
#line 355
      temp ++;
#line 355
      *tmp___13 = *(buffer___0 + xpos * 3);
#line 351
      xpos ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 357
    ypos --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 360
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 364
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 364
    tmp___19 = fread((void */* __restrict  */)buffer___0, (size_t )rowbytes, (size_t )1,
                     (FILE */* __restrict  */)fd);
    }
#line 364
    if (! (tmp___19 != 0UL)) {
#line 364
      goto while_break___7;
    }
#line 366
    temp = image + (long )ypos * rowstride;
#line 367
    xpos = 0;
    {
#line 367
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 367
      if (! (xpos < width)) {
#line 367
        goto while_break___8;
      }
      {
#line 369
      tmp___15 = ToS(buffer___0 + xpos * 2);
#line 369
      rgb = (unsigned short )tmp___15;
#line 370
      tmp___16 = temp;
#line 370
      temp ++;
#line 370
      *tmp___16 = (unsigned char )((((int )rgb >> 10) & 31) * 8);
#line 371
      tmp___17 = temp;
#line 371
      temp ++;
#line 371
      *tmp___17 = (unsigned char )((((int )rgb >> 5) & 31) * 8);
#line 372
      tmp___18 = temp;
#line 372
      temp ++;
#line 372
      *tmp___18 = (unsigned char )(((int )rgb & 31) * 8);
#line 367
      xpos ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 374
    ypos --;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 377
  goto switch_break;
  case_1: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 383
  if (compression == 0) {
    {
#line 385
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 385
      tmp___21 = fread((void */* __restrict  */)(& v), (size_t )1, (size_t )1, (FILE */* __restrict  */)fd);
      }
#line 385
      if (! (tmp___21 != 0UL)) {
#line 385
        goto while_break___9;
      }
#line 387
      i = 1;
      {
#line 387
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 387
        if (i <= 8 / bpp) {
#line 387
          if (! (xpos < width)) {
#line 387
            goto while_break___10;
          }
        } else {
#line 387
          goto while_break___10;
        }
#line 389
        temp = (image + (long )ypos * rowstride) + (long )xpos * channels;
#line 390
        *temp = (unsigned char )(((int )v & (((1 << bpp) - 1) << (8 - i * bpp))) >> (8 - i * bpp));
#line 387
        i ++;
#line 387
        xpos ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 392
      if (xpos == width) {
        {
#line 394
        tmp___20 = fread((void */* __restrict  */)buffer___0, (size_t )((rowbytes - 1) - (width * bpp - 1) / 8),
                         (size_t )1, (FILE */* __restrict  */)fd);
#line 394
        notused = tmp___20 != 0UL;
#line 396
        ypos --;
#line 397
        xpos = 0;
        }
      }
#line 400
      if (ypos < 0) {
#line 401
        goto while_break___9;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 403
    goto switch_break;
  } else {
    {
#line 407
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 407
      if (ypos >= 0) {
#line 407
        if (! (xpos <= width)) {
#line 407
          goto while_break___11;
        }
      } else {
#line 407
        goto while_break___11;
      }
      {
#line 409
      tmp___22 = fread((void */* __restrict  */)buffer___0, (size_t )2, (size_t )1,
                       (FILE */* __restrict  */)fd);
#line 409
      notused = tmp___22 != 0UL;
      }
#line 410
      if ((int )*(buffer___0 + 0) != 0) {
#line 413
        j = 0;
        {
#line 413
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 413
          if ((int )((unsigned char )j) < (int )*(buffer___0 + 0)) {
#line 413
            if (! (xpos < width)) {
#line 413
              goto while_break___12;
            }
          } else {
#line 413
            goto while_break___12;
          }
#line 418
          i = 1;
          {
#line 418
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 418
            if (i <= 8 / bpp) {
#line 418
              if (xpos < width) {
#line 418
                if (! ((int )((unsigned char )j) < (int )*(buffer___0 + 0))) {
#line 418
                  goto while_break___13;
                }
              } else {
#line 418
                goto while_break___13;
              }
            } else {
#line 418
              goto while_break___13;
            }
#line 424
            temp = (image + (long )ypos * rowstride) + (long )xpos * channels;
#line 425
            *temp = (unsigned char )(((int )*(buffer___0 + 1) & (((1 << bpp) - 1) << (8 - i * bpp))) >> (8 - i * bpp));
#line 418
            i ++;
#line 418
            xpos ++;
#line 418
            j ++;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
      }
#line 429
      if ((int )*(buffer___0 + 0) == 0) {
#line 429
        if ((int )*(buffer___0 + 1) > 2) {
#line 432
          howmuch = *(buffer___0 + 1);
#line 433
          j = 0;
          {
#line 433
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 433
            if (! (j < (int )howmuch)) {
#line 433
              goto while_break___14;
            }
            {
#line 435
            tmp___23 = fread((void */* __restrict  */)(& v), (size_t )1, (size_t )1,
                             (FILE */* __restrict  */)fd);
#line 435
            notused = tmp___23 != 0UL;
#line 436
            i = 1;
            }
            {
#line 437
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 437
              if (i <= 8 / bpp) {
#line 437
                if (! (xpos < width)) {
#line 437
                  goto while_break___15;
                }
              } else {
#line 437
                goto while_break___15;
              }
#line 439
              temp = (image + (long )ypos * rowstride) + (long )xpos * channels;
#line 440
              *temp = (unsigned char )(((int )v & (((1 << bpp) - 1) << (8 - i * bpp))) >> (8 - i * bpp));
#line 441
              i ++;
#line 442
              xpos ++;
            }
            while_break___15: /* CIL Label */ ;
            }
#line 433
            j += 8 / bpp;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 446
          if ((int )howmuch % 2) {
#line 446
            if (bpp == 4) {
#line 447
              howmuch = (unsigned char )((int )howmuch + 1);
            }
          }
#line 449
          if (((int )howmuch / (8 / bpp)) % 2) {
            {
#line 450
            tmp___24 = fread((void */* __restrict  */)(& v), (size_t )1, (size_t )1,
                             (FILE */* __restrict  */)fd);
#line 450
            notused = tmp___24 != 0UL;
            }
          }
        }
      }
#line 453
      if ((int )*(buffer___0 + 0) == 0) {
#line 453
        if ((int )*(buffer___0 + 1) == 0) {
#line 456
          ypos --;
#line 457
          xpos = 0;
        }
      }
#line 459
      if ((int )*(buffer___0 + 0) == 0) {
#line 459
        if ((int )*(buffer___0 + 1) == 1) {
#line 462
          goto while_break___11;
        }
      }
#line 464
      if ((int )*(buffer___0 + 0) == 0) {
#line 464
        if ((int )*(buffer___0 + 1) == 2) {
          {
#line 467
          tmp___25 = fread((void */* __restrict  */)buffer___0, (size_t )2, (size_t )1,
                           (FILE */* __restrict  */)fd);
#line 467
          notused = tmp___25 != 0UL;
#line 468
          xpos += (int )*(buffer___0 + 0);
#line 469
          ypos -= (int )*(buffer___0 + 1);
          }
        }
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 472
    goto switch_break;
  }
#line 475
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 481
  if (bpp <= 8) {
#line 485
    temp = image;
#line 485
    temp2 = temp;
    {
#line 486
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 486
      tmp___26 = malloc((unsigned long )((width * height) * 3) * sizeof(unsigned char ));
#line 486
      image = (unsigned char *)tmp___26;
      }
#line 486
      if (! image) {
        {
#line 486
        __assert_fail("image", "input-bmp.c", 486U, "ReadImage");
        }
      }
#line 486
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 487
    temp3 = image;
#line 488
    ypos = 0;
    {
#line 488
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 488
      if (! (ypos < height)) {
#line 488
        goto while_break___17;
      }
#line 490
      xpos = 0;
      {
#line 490
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 490
        if (! (xpos < width)) {
#line 490
          goto while_break___18;
        }
#line 492
        tmp___28 = temp2;
#line 492
        temp2 ++;
#line 492
        index___0 = *tmp___28;
#line 493
        tmp___29 = temp3;
#line 493
        temp3 ++;
#line 493
        *tmp___29 = (*(cmap + index___0))[0];
#line 494
        if (! grey) {
#line 496
          tmp___30 = temp3;
#line 496
          temp3 ++;
#line 496
          *tmp___30 = (*(cmap + index___0))[1];
#line 497
          tmp___31 = temp3;
#line 497
          temp3 ++;
#line 497
          *tmp___31 = (*(cmap + index___0))[2];
        }
#line 490
        xpos ++;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 488
      ypos ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 501
    free((void *)temp);
    }
  }
  {
#line 504
  free((void *)buffer___0);
  }
#line 505
  return (image);
}
}
#line 508 "input-bmp.c"
FILE *errorfile  ;
#line 509 "input-bmp.c"
char *prog_name  =    (char *)"bmp";
#line 510 "input-bmp.c"
char *filename  ;
#line 511 "input-bmp.c"
int interactive_bmp  ;
#line 513 "input-bmp.c"
static long ToL(unsigned char *puffer ) 
{ 


  {
#line 516
  return ((long )((((int )*(puffer + 0) | ((int )*(puffer + 1) << 8)) | ((int )*(puffer + 2) << 16)) | ((int )*(puffer + 3) << 24)));
}
}
#line 519 "input-bmp.c"
static short ToS(unsigned char *puffer ) 
{ 


  {
#line 522
  return ((short )((int )*(puffer + 0) | ((int )*(puffer + 1) << 8)));
}
}
#line 26 "image-proc.h"
distance_map_type new_distance_map(bitmap_type bitmap , unsigned char target_value ,
                                   at_bool padded , at_exception_type *exp___0 ) ;
#line 31
void free_distance_map(distance_map_type *dist ) ;
#line 39
void binarize(bitmap_type *bitmap ) ;
#line 33 "image-proc.c"
distance_map_type new_distance_map(bitmap_type bitmap , unsigned char target_value ,
                                   at_bool padded , at_exception_type *exp___0 ) 
{ 
  int x ;
  int y ;
  float d ;
  float min ;
  distance_map_type dist ;
  unsigned char *b ;
  unsigned int w ;
  unsigned int h ;
  unsigned int spp ;
  void *tmp ;
  void *tmp___1 ;
  void *tmp___3 ;
  void *tmp___5 ;
  int gray ;
  float fgray ;
  int gray___0 ;
  float fgray___0 ;
  float tmp___7 ;
  float tmp___8 ;
  float tmp___9 ;
  float tmp___10 ;
  float tmp___11 ;
  float tmp___12 ;
  float tmp___13 ;
  float tmp___14 ;

  {
#line 39
  b = bitmap.bitmap;
#line 40
  w = (unsigned int )bitmap.width;
#line 41
  h = (unsigned int )bitmap.height;
#line 42
  spp = bitmap.np;
#line 44
  dist.height = h;
#line 44
  dist.width = w;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 45
    tmp = malloc((unsigned long )h * sizeof(float *));
#line 45
    dist.d = (float **)tmp;
    }
#line 45
    if (! dist.d) {
      {
#line 45
      __assert_fail("dist.d", "image-proc.c", 45U, "new_distance_map");
      }
    }
#line 45
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 46
    tmp___1 = malloc((unsigned long )h * sizeof(float *));
#line 46
    dist.weight = (float **)tmp___1;
    }
#line 46
    if (! dist.weight) {
      {
#line 46
      __assert_fail("dist.weight", "image-proc.c", 46U, "new_distance_map");
      }
    }
#line 46
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 47
  y = 0;
  {
#line 47
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 47
    if (! (y < (int )h)) {
#line 47
      goto while_break___1;
    }
    {
#line 49
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 49
      tmp___3 = calloc((unsigned long )w * sizeof(float ), (size_t )1);
#line 49
      *(dist.d + y) = (float *)tmp___3;
      }
#line 49
      if (! *(dist.d + y)) {
        {
#line 49
        __assert_fail("dist.d[y]", "image-proc.c", 49U, "new_distance_map");
        }
      }
#line 49
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 50
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 50
      tmp___5 = malloc((unsigned long )w * sizeof(float ));
#line 50
      *(dist.weight + y) = (float *)tmp___5;
      }
#line 50
      if (! *(dist.weight + y)) {
        {
#line 50
        __assert_fail("dist.weight[y]", "image-proc.c", 50U, "new_distance_map");
        }
      }
#line 50
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 47
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 53
  if (spp == 3U) {
#line 55
    y = 0;
    {
#line 55
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 55
      if (! (y < (int )h)) {
#line 55
        goto while_break___4;
      }
#line 57
      x = 0;
      {
#line 57
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 57
        if (! (x < (int )w)) {
#line 57
          goto while_break___5;
        }
#line 60
        gray = (int )((((double )*(b + 0) * 0.30 + (double )*(b + 1) * 0.59) + (double )*(b + 2) * 0.11) + 0.5);
#line 61
        if (gray == (int )target_value) {
#line 61
          *(*(dist.d + y) + x) = 0.0F;
        } else {
#line 61
          *(*(dist.d + y) + x) = 1.0e10F;
        }
#line 62
        fgray = (float )gray * 0.0039215686F;
#line 63
        *(*(dist.weight + y) + x) = 1.0F - fgray;
#line 57
        x ++;
#line 57
        b += spp;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 55
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
#line 71
    y = 0;
    {
#line 71
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 71
      if (! (y < (int )h)) {
#line 71
        goto while_break___6;
      }
#line 73
      x = 0;
      {
#line 73
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 73
        if (! (x < (int )w)) {
#line 73
          goto while_break___7;
        }
#line 76
        gray___0 = (int )*(b + 0);
#line 77
        if (gray___0 == (int )target_value) {
#line 77
          *(*(dist.d + y) + x) = 0.0F;
        } else {
#line 77
          *(*(dist.d + y) + x) = 1.0e10F;
        }
#line 78
        fgray___0 = (float )gray___0 * 0.0039215686F;
#line 79
        *(*(dist.weight + y) + x) = 1.0F - fgray___0;
#line 73
        x ++;
#line 73
        b += spp;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 71
      y ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 88
  if (padded) {
#line 90
    y = 0;
    {
#line 90
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 90
      if (! (y < (int )h)) {
#line 90
        goto while_break___8;
      }
#line 92
      if (*(*(dist.d + y) + 0) > *(*(dist.weight + y) + 0)) {
#line 93
        *(*(dist.d + y) + 0) = *(*(dist.weight + y) + 0);
      }
#line 94
      if (*(*(dist.d + y) + (w - 1U)) > *(*(dist.weight + y) + (w - 1U))) {
#line 95
        *(*(dist.d + y) + (w - 1U)) = *(*(dist.weight + y) + (w - 1U));
      }
#line 90
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 97
    x = 0;
    {
#line 97
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 97
      if (! (x < (int )w)) {
#line 97
        goto while_break___9;
      }
#line 99
      if (*(*(dist.d + 0) + x) > *(*(dist.weight + 0) + x)) {
#line 100
        *(*(dist.d + 0) + x) = *(*(dist.weight + 0) + x);
      }
#line 101
      if (*(*(dist.d + (h - 1U)) + x) > *(*(dist.weight + (h - 1U)) + x)) {
#line 102
        *(*(dist.d + (h - 1U)) + x) = *(*(dist.weight + (h - 1U)) + x);
      }
#line 97
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 114
  y = 1;
  {
#line 114
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 114
    if (! (y < (int )h)) {
#line 114
      goto while_break___10;
    }
#line 116
    x = 1;
    {
#line 116
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 116
      if (! (x < (int )w)) {
#line 116
        goto while_break___11;
      }
#line 118
      if (*(*(dist.d + y) + x) == 0.0F) {
#line 118
        goto __Cont;
      }
#line 120
      min = *(*(dist.d + y) + x);
#line 123
      d = *(*(dist.d + (y - 1)) + (x - 1)) + (float )1.41421356237309504880 * *(*(dist.weight + y) + x);
#line 124
      if (d < min) {
#line 124
        tmp___7 = d;
#line 124
        *(*(dist.d + y) + x) = tmp___7;
#line 124
        min = tmp___7;
      }
#line 127
      d = *(*(dist.d + (y - 1)) + x) + *(*(dist.weight + y) + x);
#line 128
      if (d < min) {
#line 128
        tmp___8 = d;
#line 128
        *(*(dist.d + y) + x) = tmp___8;
#line 128
        min = tmp___8;
      }
#line 131
      d = *(*(dist.d + y) + (x - 1)) + *(*(dist.weight + y) + x);
#line 132
      if (d < min) {
#line 132
        tmp___9 = d;
#line 132
        *(*(dist.d + y) + x) = tmp___9;
#line 132
        min = tmp___9;
      }
#line 135
      if (x + 1 < (int )w) {
#line 137
        d = *(*(dist.d + (y - 1)) + (x + 1)) + (float )1.41421356237309504880 * *(*(dist.weight + y) + x);
#line 138
        if (d < min) {
#line 138
          tmp___10 = d;
#line 138
          *(*(dist.d + y) + x) = tmp___10;
#line 138
          min = tmp___10;
        }
      }
      __Cont: /* CIL Label */ 
#line 116
      x ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 114
    y ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 144
  y = (int )(h - 2U);
  {
#line 144
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 144
    if (! (y >= 0)) {
#line 144
      goto while_break___12;
    }
#line 146
    x = (int )(w - 2U);
    {
#line 146
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 146
      if (! (x >= 0)) {
#line 146
        goto while_break___13;
      }
#line 148
      min = *(*(dist.d + y) + x);
#line 151
      d = *(*(dist.d + (y + 1)) + (x + 1)) + (float )1.41421356237309504880 * *(*(dist.weight + y) + x);
#line 152
      if (d < min) {
#line 152
        tmp___11 = d;
#line 152
        *(*(dist.d + y) + x) = tmp___11;
#line 152
        min = tmp___11;
      }
#line 155
      d = *(*(dist.d + (y + 1)) + x) + *(*(dist.weight + y) + x);
#line 156
      if (d < min) {
#line 156
        tmp___12 = d;
#line 156
        *(*(dist.d + y) + x) = tmp___12;
#line 156
        min = tmp___12;
      }
#line 159
      d = *(*(dist.d + y) + (x + 1)) + *(*(dist.weight + y) + x);
#line 160
      if (d < min) {
#line 160
        tmp___13 = d;
#line 160
        *(*(dist.d + y) + x) = tmp___13;
#line 160
        min = tmp___13;
      }
#line 163
      if (x - 1 >= 0) {
#line 165
        d = *(*(dist.d + (y + 1)) + (x - 1)) + (float )1.41421356237309504880 * *(*(dist.weight + y) + x);
#line 166
        if (d < min) {
#line 166
          tmp___14 = d;
#line 166
          *(*(dist.d + y) + x) = tmp___14;
#line 166
          min = tmp___14;
        }
      }
#line 146
      x --;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 144
    y --;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 170
  return (dist);
}
}
#line 176 "image-proc.c"
void free_distance_map(distance_map_type *dist ) 
{ 
  unsigned int y ;
  unsigned int h ;

  {
#line 181
  if (! dist) {
#line 181
    return;
  }
#line 183
  h = dist->height;
#line 185
  if ((unsigned long )dist->d != (unsigned long )((void *)0)) {
#line 187
    y = 0U;
    {
#line 187
    while (1) {
      while_continue: /* CIL Label */ ;
#line 187
      if (! (y < h)) {
#line 187
        goto while_break;
      }
      {
#line 188
      free((void *)((at_address *)*(dist->d + y)));
#line 187
      y ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 189
    free((void *)((at_address *)dist->d));
    }
  }
#line 191
  if ((unsigned long )dist->weight != (unsigned long )((void *)0)) {
#line 193
    y = 0U;
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! (y < h)) {
#line 193
        goto while_break___0;
      }
      {
#line 194
      free((void *)((at_address *)*(dist->weight + y)));
#line 193
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 195
    free((void *)((at_address *)dist->weight));
    }
  }
#line 197
  return;
}
}
#line 291 "image-proc.c"
void binarize(bitmap_type *bitmap ) 
{ 
  unsigned int i ;
  unsigned int npixels ;
  unsigned int spp ;
  unsigned char *b ;
  unsigned char *rgb ;
  at_address new_mem ;
  void *tmp___1 ;
  void *tmp___3 ;

  {
#line 297
  if (! ((unsigned long )bitmap != (unsigned long )((void *)0))) {
    {
#line 297
    __assert_fail("bitmap != NULL", "image-proc.c", 297U, "binarize");
    }
  }
#line 298
  if (! ((unsigned long )bitmap->bitmap != (unsigned long )((void *)0))) {
    {
#line 298
    __assert_fail("BITMAP_BITS(*bitmap) != NULL", "image-proc.c", 298U, "binarize");
    }
  }
#line 300
  b = bitmap->bitmap;
#line 301
  spp = bitmap->np;
#line 302
  npixels = (unsigned int )((int )bitmap->width * (int )bitmap->height);
#line 304
  if (spp == 1U) {
#line 306
    i = 0U;
    {
#line 306
    while (1) {
      while_continue: /* CIL Label */ ;
#line 306
      if (! (i < npixels)) {
#line 306
        goto while_break;
      }
#line 307
      if ((int )*(b + i) > 225) {
#line 307
        *(b + i) = (unsigned char)255;
      } else {
#line 307
        *(b + i) = (unsigned char)0;
      }
#line 306
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 309
  if (spp == 3U) {
#line 311
    rgb = b;
#line 312
    i = 0U;
    {
#line 312
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 312
      if (! (i < npixels)) {
#line 312
        goto while_break___0;
      }
#line 314
      if ((((double )*(rgb + 0) * 0.30 + (double )*(rgb + 1) * 0.59) + (double )*(rgb + 2) * 0.11) + 0.5 > (double )225) {
#line 314
        *(b + i) = (unsigned char)255;
      } else {
#line 314
        *(b + i) = (unsigned char)0;
      }
#line 312
      i ++;
#line 312
      rgb += 3;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 317
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 317
      if ((unsigned long )bitmap->bitmap == (unsigned long )((void *)0)) {
        {
#line 317
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 317
          tmp___1 = malloc((size_t )npixels);
#line 317
          new_mem = tmp___1;
          }
#line 317
          if (! new_mem) {
            {
#line 317
            __assert_fail("new_mem", "image-proc.c", 317U, "binarize");
            }
          }
#line 317
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 317
        tmp___3 = realloc((void *)bitmap->bitmap, (size_t )npixels);
#line 317
        new_mem = tmp___3;
        }
#line 317
        if (! new_mem) {
          {
#line 317
          __assert_fail("new_mem", "image-proc.c", 317U, "binarize");
          }
        }
      }
#line 317
      bitmap->bitmap = (unsigned char *)new_mem;
#line 317
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 318
    bitmap->np = 1U;
  } else {
    {
#line 322
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 322
      fputs((char const   */* __restrict  */)"warning: ", (FILE */* __restrict  */)stderr);
      }
      {
#line 322
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 322
        if (at_log_file) {
          {
#line 322
          fputs((char const   */* __restrict  */)"warning: ", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 322
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 322
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"binarize: %u-plane images are not supported",
              spp);
      }
      {
#line 322
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 322
        if (at_log_file) {
          {
#line 322
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"binarize: %u-plane images are not supported",
                  spp);
          }
        }
#line 322
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 322
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stderr);
      }
#line 322
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 324
  return;
}
}
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 50 "getopt.h"
int opterr ;
#line 89
int getopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 97
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) ;
#line 58 "getopt.c"
char *optarg  =    (char *)0;
#line 72 "getopt.c"
int optind  =    0;
#line 81 "getopt.c"
static char *nextchar  ;
#line 86 "getopt.c"
int opterr  =    1;
#line 117 "getopt.c"
static enum __anonenum_ordering_681854793 ordering  ;
#line 130 "getopt.c"
static int first_nonopt  ;
#line 131 "getopt.c"
static int last_nonopt  ;
#line 142 "getopt.c"
static void exchange(char **argv ) 
{ 
  int nonopts_size ;
  char **temp ;
  void *tmp ;

  {
#line 145
  nonopts_size = (int )((unsigned long )(last_nonopt - first_nonopt) * sizeof(char *));
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 148
    tmp = malloc((size_t )nonopts_size);
#line 148
    temp = (char **)tmp;
    }
#line 148
    if (! temp) {
      {
#line 148
      __assert_fail("temp", "getopt.c", 148U, "exchange");
      }
    }
#line 148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  memcpy((void */* __restrict  */)((char *)temp), (void const   */* __restrict  */)((char *)(argv + first_nonopt)),
         (size_t )nonopts_size);
#line 153
  memcpy((void */* __restrict  */)((char *)(argv + first_nonopt)), (void const   */* __restrict  */)((char *)(argv + last_nonopt)),
         (unsigned long )(optind - last_nonopt) * sizeof(char *));
#line 155
  memcpy((void */* __restrict  */)((char *)(argv + ((first_nonopt + optind) - last_nonopt))),
         (void const   */* __restrict  */)((char *)temp), (size_t )nonopts_size);
#line 160
  first_nonopt += optind - last_nonopt;
#line 161
  last_nonopt = optind;
#line 162
  free((void *)temp);
  }
#line 163
  return;
}
}
#line 222 "getopt.c"
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) 
{ 
  int option_index ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct option  const  *p ;
  char *s ;
  int exact ;
  int ambig ;
  struct option  const  *pfound ;
  int indfound ;
  size_t tmp___3 ;
  at_bool tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char c ;
  char *tmp___11 ;
  char *temp ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 228
  optarg = (char *)0;
#line 235
  if (optind == 0) {
#line 237
    optind = 1;
#line 237
    last_nonopt = optind;
#line 237
    first_nonopt = last_nonopt;
#line 239
    nextchar = (char *)((void *)0);
#line 243
    if ((int const   )*(optstring + 0) == 45) {
#line 245
      ordering = (enum __anonenum_ordering_681854793 )2;
#line 246
      optstring ++;
    } else
#line 248
    if ((int const   )*(optstring + 0) == 43) {
#line 250
      ordering = (enum __anonenum_ordering_681854793 )0;
#line 251
      optstring ++;
    } else {
      {
#line 253
      tmp = getenv("POSIXLY_CORRECT");
      }
#line 253
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 254
        ordering = (enum __anonenum_ordering_681854793 )0;
      } else {
#line 256
        ordering = (enum __anonenum_ordering_681854793 )1;
      }
    }
  }
#line 259
  if ((unsigned long )nextchar == (unsigned long )((void *)0)) {
#line 259
    goto _L___4;
  } else
#line 259
  if ((int )*nextchar == 0) {
    _L___4: /* CIL Label */ 
#line 261
    if ((unsigned int )ordering == 1U) {
#line 266
      if (first_nonopt != last_nonopt) {
#line 266
        if (last_nonopt != optind) {
          {
#line 267
          exchange((char **)argv);
          }
        } else {
#line 266
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 268
      if (last_nonopt != optind) {
#line 269
        first_nonopt = optind;
      }
      {
#line 274
      while (1) {
        while_continue: /* CIL Label */ ;
#line 274
        if (optind < argc) {
#line 274
          if ((int )*(*(argv + optind) + 0) != 45) {
#line 274
            goto _L___0;
          } else
#line 274
          if ((int )*(*(argv + optind) + 1) == 0) {
            _L___0: /* CIL Label */ 
#line 274
            if (! ((unsigned long )longopts == (unsigned long )((void *)0))) {
#line 274
              if (! ((int )*(*(argv + optind) + 0) != 43)) {
#line 274
                if (! ((int )*(*(argv + optind) + 1) == 0)) {
#line 274
                  goto while_break;
                }
              }
            }
          } else {
#line 274
            goto while_break;
          }
        } else {
#line 274
          goto while_break;
        }
#line 281
        optind ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 282
      last_nonopt = optind;
    }
#line 290
    if (optind != argc) {
      {
#line 290
      tmp___0 = strcmp((char const   *)*(argv + optind), "--");
      }
#line 290
      if (! tmp___0) {
#line 292
        optind ++;
#line 294
        if (first_nonopt != last_nonopt) {
#line 294
          if (last_nonopt != optind) {
            {
#line 295
            exchange((char **)argv);
            }
          } else {
#line 294
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 296
        if (first_nonopt == last_nonopt) {
#line 297
          first_nonopt = optind;
        }
#line 298
        last_nonopt = argc;
#line 300
        optind = argc;
      }
    }
#line 306
    if (optind == argc) {
#line 310
      if (first_nonopt != last_nonopt) {
#line 311
        optind = first_nonopt;
      }
#line 312
      return (-1);
    }
#line 318
    if ((int )*(*(argv + optind) + 0) != 45) {
#line 318
      goto _L___3;
    } else
#line 318
    if ((int )*(*(argv + optind) + 1) == 0) {
      _L___3: /* CIL Label */ 
#line 318
      if ((unsigned long )longopts == (unsigned long )((void *)0)) {
#line 318
        goto _L___2;
      } else
#line 318
      if ((int )*(*(argv + optind) + 0) != 43) {
#line 318
        goto _L___2;
      } else
#line 318
      if ((int )*(*(argv + optind) + 1) == 0) {
        _L___2: /* CIL Label */ 
#line 325
        if ((unsigned int )ordering == 0U) {
#line 326
          return (-1);
        }
#line 327
        tmp___1 = optind;
#line 327
        optind ++;
#line 327
        optarg = (char *)*(argv + tmp___1);
#line 328
        return (1);
      }
    }
#line 334
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 334
      if ((int )*(*(argv + optind) + 1) == 45) {
#line 334
        tmp___2 = 1;
      } else {
#line 334
        tmp___2 = 0;
      }
    } else {
#line 334
      tmp___2 = 0;
    }
#line 334
    nextchar = (char *)((*(argv + optind) + 1) + tmp___2);
  }
#line 338
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 338
    if ((int )*(*(argv + optind) + 0) == 45) {
#line 338
      if ((int )*(*(argv + optind) + 1) == 45) {
#line 338
        goto _L___6;
      } else
#line 338
      if (long_only) {
#line 338
        goto _L___6;
      } else {
#line 338
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 338
    if ((int )*(*(argv + optind) + 0) == 43) {
      _L___6: /* CIL Label */ 
#line 347
      s = nextchar;
#line 348
      exact = 0;
#line 349
      ambig = 0;
#line 350
      pfound = (struct option  const  *)((void *)0);
#line 351
      indfound = 0;
      {
#line 353
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 353
        if (*s) {
#line 353
          if (! ((int )*s != 61)) {
#line 353
            goto while_break___0;
          }
        } else {
#line 353
          goto while_break___0;
        }
#line 354
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 357
      p = longopts;
#line 357
      option_index = 0;
      {
#line 357
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 357
        if (! p->name) {
#line 357
          goto while_break___1;
        }
        {
#line 359
        tmp___4 = strgnicmp((char const   *)p->name, (char const   *)nextchar, (size_t )(s - nextchar));
        }
#line 359
        if (tmp___4) {
          {
#line 361
          tmp___3 = strlen((char const   *)p->name);
          }
#line 361
          if ((size_t )((unsigned int )(s - nextchar)) == tmp___3) {
#line 364
            pfound = p;
#line 365
            indfound = option_index;
#line 366
            exact = 1;
#line 367
            goto while_break___1;
          } else
#line 369
          if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 372
            pfound = p;
#line 373
            indfound = option_index;
          } else {
#line 377
            ambig = 1;
          }
        }
#line 357
        p ++;
#line 357
        option_index ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 380
      if (ambig) {
#line 380
        if (! exact) {
#line 382
          if (opterr) {
            {
#line 383
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' is ambiguous\n",
                    *(argv + 0), *(argv + optind));
            }
          }
          {
#line 385
          tmp___5 = strlen((char const   *)nextchar);
#line 385
          nextchar += tmp___5;
#line 386
          optind ++;
          }
#line 387
          return ('?');
        }
      }
#line 390
      if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 392
        option_index = indfound;
#line 393
        optind ++;
#line 394
        if (*s) {
#line 398
          if (pfound->has_arg) {
#line 399
            optarg = s + 1;
          } else {
#line 402
            if (opterr) {
#line 404
              if ((int )*(*(argv + (optind - 1)) + 1) == 45) {
                {
#line 406
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `--%s\' doesn\'t allow an argument\n",
                        *(argv + 0), pfound->name);
                }
              } else {
                {
#line 411
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%c%s\' doesn\'t allow an argument\n",
                        *(argv + 0), (int )*(*(argv + (optind - 1)) + 0), pfound->name);
                }
              }
            }
            {
#line 415
            tmp___6 = strlen((char const   *)nextchar);
#line 415
            nextchar += tmp___6;
            }
#line 416
            return ('?');
          }
        } else
#line 419
        if (pfound->has_arg == 1) {
#line 421
          if (optind < argc) {
#line 422
            tmp___7 = optind;
#line 422
            optind ++;
#line 422
            optarg = (char *)*(argv + tmp___7);
          } else {
#line 425
            if (opterr) {
              {
#line 426
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' requires an argument\n",
                      *(argv + 0), *(argv + (optind - 1)));
              }
            }
            {
#line 428
            tmp___8 = strlen((char const   *)nextchar);
#line 428
            nextchar += tmp___8;
            }
#line 429
            return ('?');
          }
        }
        {
#line 432
        tmp___9 = strlen((char const   *)nextchar);
#line 432
        nextchar += tmp___9;
        }
#line 433
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 434
          *longind = option_index;
        }
#line 435
        if (pfound->flag) {
#line 437
          *(pfound->flag) = (int )pfound->val;
#line 438
          return (0);
        }
#line 440
        return ((int )pfound->val);
      }
#line 446
      if (! long_only) {
#line 446
        goto _L___5;
      } else
#line 446
      if ((int )*(*(argv + optind) + 1) == 45) {
#line 446
        goto _L___5;
      } else
#line 446
      if ((int )*(*(argv + optind) + 0) == 43) {
#line 446
        goto _L___5;
      } else {
        {
#line 446
        tmp___10 = strchr(optstring, (int )*nextchar);
        }
#line 446
        if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
          _L___5: /* CIL Label */ 
#line 452
          if (opterr) {
#line 454
            if ((int )*(*(argv + optind) + 1) == 45) {
              {
#line 456
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option `--%s\'\n",
                      *(argv + 0), nextchar);
              }
            } else {
              {
#line 460
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option `%c%s\'\n",
                      *(argv + 0), (int )*(*(argv + optind) + 0), nextchar);
              }
            }
          }
#line 463
          nextchar = (char *)"";
#line 464
          optind ++;
#line 465
          return ('?');
        }
      }
    }
  }
  {
#line 472
  tmp___11 = nextchar;
#line 472
  nextchar ++;
#line 472
  c = *tmp___11;
#line 473
  tmp___12 = strchr(optstring, (int )c);
#line 473
  temp = tmp___12;
  }
#line 476
  if ((int )*nextchar == 0) {
#line 477
    optind ++;
  }
#line 479
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 479
    goto _L___8;
  } else
#line 479
  if ((int )c == 58) {
    _L___8: /* CIL Label */ 
#line 481
    if (opterr) {
#line 483
      if ((int )c < 32) {
        {
#line 484
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option, character code 0%o\n",
                *(argv + 0), (int )c);
        }
      } else
#line 483
      if ((int )c >= 127) {
        {
#line 484
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option, character code 0%o\n",
                *(argv + 0), (int )c);
        }
      } else {
        {
#line 487
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option `-%c\'\n",
                *(argv + 0), (int )c);
        }
      }
    }
#line 489
    return ('?');
  }
#line 491
  if ((int )*(temp + 1) == 58) {
#line 493
    if ((int )*(temp + 2) == 58) {
#line 496
      if ((int )*nextchar != 0) {
#line 498
        optarg = nextchar;
#line 499
        optind ++;
      } else {
#line 502
        optarg = (char *)0;
      }
#line 503
      nextchar = (char *)((void *)0);
    } else {
#line 508
      if ((int )*nextchar != 0) {
#line 510
        optarg = nextchar;
#line 513
        optind ++;
      } else
#line 515
      if (optind == argc) {
#line 517
        if (opterr) {
          {
#line 518
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `-%c\' requires an argument\n",
                  *(argv + 0), (int )c);
          }
        }
#line 520
        c = (char )'?';
      } else {
#line 525
        tmp___13 = optind;
#line 525
        optind ++;
#line 525
        optarg = (char *)*(argv + tmp___13);
      }
#line 526
      nextchar = (char *)((void *)0);
    }
  }
#line 529
  return ((int )c);
}
}
#line 533 "getopt.c"
int getopt(int argc , char * const  *argv , char const   *optstring ) 
{ 
  int tmp ;

  {
  {
#line 536
  tmp = _getopt_internal(argc, argv, optstring, (struct option  const  *)0, (int *)0,
                         0);
  }
#line 536
  return (tmp);
}
}
#line 90 "getopt.h"
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                int *opt_index ) ;
#line 24 "getopt1.c"
int getopt_long(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 28
  tmp = _getopt_internal(argc, argv, options, long_options, opt_index, 0);
  }
#line 28
  return (tmp);
}
}
#line 36 "getopt1.c"
int getopt_long_only(int argc , char * const  *argv , char const   *options , struct option  const  *long_options ,
                     int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 40
  tmp = _getopt_internal(argc, argv, options, long_options, opt_index, 1);
  }
#line 40
  return (tmp);
}
}
#line 401 "autotrace.h"
void at_color_free(at_color_type *color ) ;
#line 17 "fit.h"
at_spline_list_array_type fitted_splines(pixel_outline_list_type pixel_outline_list ,
                                         fitting_opts_type *fitting_opts , distance_map_type *dist ,
                                         unsigned short width , unsigned short height ,
                                         at_exception_type *exception , void (*notify_progress)(at_real percentage ,
                                                                                                at_address client_data ) ,
                                         at_address progress_data , at_bool (*test_cancel)(at_address client_data ) ,
                                         at_address testcancel_data ) ;
#line 26
fitting_opts_type new_fitting_opts(void) ;
#line 73 "curve.h"
curve_type new_curve(void) ;
#line 76
curve_type copy_most_of_curve(curve_type old_curve ) ;
#line 79
void free_curve(curve_type curve ) ;
#line 82
void append_pixel(curve_type curve , at_coord coord ) ;
#line 85
void append_point(curve_type curve , at_real_coord coord ) ;
#line 89
void log_curve(curve_type curve , at_bool print_t ) ;
#line 90
void log_entire_curve(curve_type curve ) ;
#line 116
curve_list_type new_curve_list(void) ;
#line 118
void append_curve(curve_list_type *curve_list , curve_type curve ) ;
#line 135
curve_list_array_type new_curve_list_array(void) ;
#line 136
void free_curve_list_array(curve_list_array_type *curve_list_array , void (*notify_progress)(at_real percentage ,
                                                                                             at_address client_data ) ,
                           at_address client_data ) ;
#line 139
void append_curve_list(curve_list_array_type *curve_list_array , curve_list_type curve_list ) ;
#line 67 "fit.c"
static void append_index(index_list_type *list , unsigned int new_index ) ;
#line 68
static void free_index_list(index_list_type *index_list ) ;
#line 69
static index_list_type new_index_list(void) ;
#line 70
static void remove_adjacent_corners(index_list_type *list , unsigned int last_index ,
                                    at_bool remove_adj_corners , at_exception_type *exception ) ;
#line 72
static void change_bad_lines(spline_list_type *spline_list , fitting_opts_type *fitting_opts ) ;
#line 74
static void filter(curve_type curve , fitting_opts_type *fitting_opts ) ;
#line 75
static void find_vectors(unsigned int test_index , pixel_outline_type outline , vector_type *in ,
                         vector_type *out , unsigned int corner_surround ) ;
#line 77
static index_list_type find_corners(pixel_outline_type pixel_outline , fitting_opts_type *fitting_opts ,
                                    at_exception_type *exception ) ;
#line 80
static at_real find_error(curve_type curve , spline_type spline , unsigned int *worst_point ,
                          at_exception_type *exception ) ;
#line 82
static vector_type find_half_tangent(curve_type c , at_bool to_start_point , unsigned int *n_points ,
                                     unsigned int tangent_surround ) ;
#line 83
static void find_tangent(curve_type curve , at_bool to_start_point , at_bool cross_curve ,
                         unsigned int tangent_surround ) ;
#line 84
static spline_type fit_one_spline(curve_type curve , at_exception_type *exception ) ;
#line 86
static spline_list_type *fit_curve(curve_type curve , fitting_opts_type *fitting_opts ,
                                   at_exception_type *exception ) ;
#line 89
static spline_list_type fit_curve_list(curve_list_type curve_list , fitting_opts_type *fitting_opts ,
                                       distance_map_type *dist , at_exception_type *exception ) ;
#line 92
static spline_list_type *fit_with_least_squares(curve_type curve , fitting_opts_type *fitting_opts ,
                                                at_exception_type *exception ) ;
#line 95
static spline_list_type *fit_with_line(curve_type curve ) ;
#line 96
static void remove_knee_points(curve_type curve , at_bool clockwise ) ;
#line 97
static void set_initial_parameter_values(curve_type curve ) ;
#line 98
static at_bool spline_linear_enough(spline_type *spline , curve_type curve , fitting_opts_type *fitting_opts ) ;
#line 100
static curve_list_array_type split_at_corners(pixel_outline_list_type pixel_list ,
                                              fitting_opts_type *fitting_opts , at_exception_type *exception ) ;
#line 103
static at_coord real_to_int_coord(at_real_coord real_coord ) ;
#line 104
static at_real distance(at_real_coord p1 , at_real_coord p2 ) ;
#line 107 "fit.c"
fitting_opts_type new_fitting_opts(void) 
{ 
  fitting_opts_type fitting_opts ;

  {
#line 112
  fitting_opts.background_color = (at_color_type *)((void *)0);
#line 113
  fitting_opts.color_count = 0U;
#line 114
  fitting_opts.corner_always_threshold = (at_real )60.0;
#line 115
  fitting_opts.corner_surround = 4U;
#line 116
  fitting_opts.corner_threshold = (at_real )100.0;
#line 117
  fitting_opts.error_threshold = (at_real )2.0;
#line 118
  fitting_opts.filter_iterations = 4U;
#line 119
  fitting_opts.line_reversion_threshold = (at_real ).01;
#line 120
  fitting_opts.line_threshold = (at_real )1.0;
#line 121
  fitting_opts.remove_adjacent_corners = (at_bool )0;
#line 122
  fitting_opts.tangent_surround = 3U;
#line 123
  fitting_opts.despeckle_level = 0U;
#line 124
  fitting_opts.despeckle_tightness = (at_real )2.0;
#line 125
  fitting_opts.centerline = (at_bool )0;
#line 126
  fitting_opts.preserve_width = (at_bool )0;
#line 127
  fitting_opts.width_weight_factor = (at_real )6.0;
#line 129
  return (fitting_opts);
}
}
#line 136 "fit.c"
at_spline_list_array_type fitted_splines(pixel_outline_list_type pixel_outline_list ,
                                         fitting_opts_type *fitting_opts , distance_map_type *dist ,
                                         unsigned short width , unsigned short height ,
                                         at_exception_type *exception , void (*notify_progress)(at_real percentage ,
                                                                                                at_address client_data ) ,
                                         at_address progress_data , at_bool (*test_cancel)(at_address client_data ) ,
                                         at_address testcancel_data ) 
{ 
  unsigned int this_list ;
  at_spline_list_array_type char_splines ;
  at_spline_list_array_type tmp ;
  curve_list_array_type curve_array ;
  curve_list_array_type tmp___0 ;
  spline_list_type curve_list_splines ;
  curve_list_type curves ;
  at_bool tmp___1 ;
  at_bool tmp___2 ;

  {
  {
#line 148
  tmp = new_spline_list_array();
#line 148
  char_splines = tmp;
#line 149
  tmp___0 = split_at_corners(pixel_outline_list, fitting_opts, exception);
#line 149
  curve_array = tmp___0;
#line 153
  char_splines.centerline = fitting_opts->centerline;
#line 154
  char_splines.preserve_width = fitting_opts->preserve_width;
#line 155
  char_splines.width_weight_factor = fitting_opts->width_weight_factor;
  }
#line 157
  if (fitting_opts->background_color) {
    {
#line 158
    char_splines.background_color = at_color_copy(fitting_opts->background_color);
    }
  } else {
#line 160
    char_splines.background_color = (at_color_type *)((void *)0);
  }
#line 162
  char_splines.width = width;
#line 163
  char_splines.height = height;
#line 165
  this_list = 0U;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (this_list < curve_array.length)) {
#line 165
      goto while_break;
    }
#line 169
    curves = *(curve_array.data + this_list);
#line 171
    if (notify_progress) {
      {
#line 172
      (*notify_progress)((at_real )this_list / ((at_real )curve_array.length * (at_real )3.0) + (at_real )0.333,
                         progress_data);
      }
    }
#line 174
    if (test_cancel) {
      {
#line 174
      tmp___1 = (*test_cancel)(testcancel_data);
      }
#line 174
      if (tmp___1) {
#line 175
        goto cleanup;
      }
    }
    {
#line 177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 177
      if (at_log_file) {
        {
#line 177
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"\nFitting curve list #%u:\n",
                this_list);
        }
      }
#line 177
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 179
    curve_list_splines = fit_curve_list(curves, fitting_opts, dist, exception);
#line 181
    tmp___2 = at_exception_got_fatal(exception);
    }
#line 181
    if (tmp___2) {
#line 183
      if (char_splines.background_color) {
        {
#line 184
        at_color_free(char_splines.background_color);
        }
      }
#line 185
      goto cleanup;
    }
    {
#line 187
    curve_list_splines.clockwise = curves.clockwise;
#line 189
    memcpy((void */* __restrict  */)(& curve_list_splines.color), (void const   */* __restrict  */)(& (pixel_outline_list.data + this_list)->color),
           sizeof(color_type ));
#line 192
    append_spline_list(& char_splines, curve_list_splines);
#line 165
    this_list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
  {
#line 195
  free_curve_list_array(& curve_array, notify_progress, progress_data);
#line 197
  flush_log_output();
  }
#line 199
  return (char_splines);
}
}
#line 206 "fit.c"
static spline_list_type fit_curve_list(curve_list_type curve_list , fitting_opts_type *fitting_opts ,
                                       distance_map_type *dist , at_exception_type *exception ) 
{ 
  curve_type curve ;
  unsigned int this_curve ;
  unsigned int this_spline ;
  unsigned int curve_list_length ;
  spline_list_type curve_list_splines ;
  spline_list_type tmp ;
  unsigned int this_point ;
  unsigned int height ;
  unsigned int x ;
  unsigned int y ;
  float width ;
  float w ;
  at_real_coord *coord ;
  spline_list_type *curve_splines ;
  curve_type current_curve ;
  at_bool tmp___0 ;

  {
  {
#line 213
  curve_list_length = curve_list.length;
#line 214
  tmp = empty_spline_list();
#line 214
  curve_list_splines = tmp;
#line 216
  curve_list_splines.open = curve_list.open;
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (at_log_file) {
      {
#line 222
      fputs((char const   */* __restrict  */)"\nRemoving knees:\n", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 222
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  this_curve = 0U;
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if (! (this_curve < curve_list_length)) {
#line 223
      goto while_break___0;
    }
    {
#line 225
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 225
      if (at_log_file) {
        {
#line 225
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"#%u:",
                this_curve);
        }
      }
#line 225
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 226
    remove_knee_points(*(curve_list.data + this_curve), curve_list.clockwise);
#line 223
    this_curve ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 230
  if ((unsigned long )dist != (unsigned long )((void *)0)) {
#line 233
    height = dist->height;
#line 234
    this_curve = 0U;
    {
#line 234
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 234
      if (! (this_curve < curve_list_length)) {
#line 234
        goto while_break___2;
      }
#line 236
      curve = *(curve_list.data + this_curve);
#line 237
      this_point = 0U;
      {
#line 237
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 237
        if (! (this_point < curve->length)) {
#line 237
          goto while_break___3;
        }
#line 241
        coord = & (curve->point_list + this_point)->coord;
#line 242
        x = (unsigned int )coord->x;
#line 243
        y = (height - (unsigned int )coord->y) - 1U;
#line 249
        width = *(*(dist->d + y) + x);
#line 250
        if (y - 1U >= 0U) {
#line 252
          w = *(*(dist->d + (y - 1U)) + x);
#line 252
          if (w > width) {
#line 252
            width = w;
          }
#line 253
          if (x - 1U >= 0U) {
#line 255
            w = *(*(dist->d + y) + (x - 1U));
#line 255
            if (w > width) {
#line 255
              width = w;
            }
#line 256
            w = *(*(dist->d + (y - 1U)) + (x - 1U));
#line 256
            if (w > width) {
#line 256
              width = w;
            }
          }
#line 258
          if (x + 1U < dist->width) {
#line 260
            w = *(*(dist->d + y) + (x + 1U));
#line 260
            if (w > width) {
#line 260
              width = w;
            }
#line 261
            w = *(*(dist->d + (y - 1U)) + (x + 1U));
#line 261
            if (w > width) {
#line 261
              width = w;
            }
          }
        }
#line 264
        if (y + 1U < height) {
#line 266
          w = *(*(dist->d + (y + 1U)) + x);
#line 266
          if (w > width) {
#line 266
            width = w;
          }
#line 267
          if (x - 1U >= 0U) {
#line 267
            w = *(*(dist->d + (y + 1U)) + (x - 1U));
#line 267
            if (w > width) {
#line 268
              width = w;
            }
          }
#line 269
          if (x + 1U < dist->width) {
#line 269
            w = *(*(dist->d + (y + 1U)) + (x + 1U));
#line 269
            if (w > width) {
#line 270
              width = w;
            }
          }
        }
#line 272
        coord->z = width * fitting_opts->width_weight_factor;
#line 237
        this_point ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 234
      this_curve ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 280
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 280
    if (at_log_file) {
      {
#line 280
      fputs((char const   */* __restrict  */)"\nFiltering curves:\n", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 280
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 281
  this_curve = 0U;
  {
#line 281
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 281
    if (! (this_curve < curve_list.length)) {
#line 281
      goto while_break___5;
    }
    {
#line 283
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 283
      if (at_log_file) {
        {
#line 283
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"#%u: ",
                this_curve);
        }
      }
#line 283
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 284
    filter(*(curve_list.data + this_curve), fitting_opts);
#line 281
    this_curve ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 298
  curve = *(curve_list.data + 0);
#line 299
  if ((unsigned int )curve->cyclic == 1U) {
    {
#line 300
    append_point(curve, (curve->point_list + 0)->coord);
    }
  }
#line 303
  this_curve = 0U;
  {
#line 303
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 303
    if (! (this_curve < curve_list_length)) {
#line 303
      goto while_break___7;
    }
#line 306
    current_curve = *(curve_list.data + this_curve);
    {
#line 308
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 308
      if (at_log_file) {
        {
#line 308
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"\nFitting curve #%u:\n",
                this_curve);
        }
      }
#line 308
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 310
    curve_splines = fit_curve(current_curve, fitting_opts, exception);
#line 311
    tmp___0 = at_exception_got_fatal(exception);
    }
#line 311
    if (tmp___0) {
#line 312
      goto cleanup;
    } else
#line 313
    if ((unsigned long )curve_splines == (unsigned long )((void *)0)) {
      {
#line 315
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 315
        if (at_log_file) {
          {
#line 315
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Could not fit curve #%u",
                  this_curve);
          }
        }
#line 315
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 316
      at_exception_warning(exception, (at_string const   )"Could not fit curve");
      }
    } else {
      {
#line 320
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 320
        if (at_log_file) {
          {
#line 320
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Fitted splines for curve #%u:\n",
                  this_curve);
          }
        }
#line 320
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 321
      this_spline = 0U;
      {
#line 321
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 321
        if (! (this_spline < curve_splines->length)) {
#line 321
          goto while_break___11;
        }
        {
#line 325
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 325
          if (at_log_file) {
            {
#line 325
            fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  %u: ",
                    this_spline);
            }
          }
#line 325
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 326
        if (at_log_file) {
          {
#line 327
          print_spline(at_log_file, *(curve_splines->data + this_spline));
          }
        }
#line 321
        this_spline ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 334
      change_bad_lines(curve_splines, fitting_opts);
#line 336
      concat_spline_lists(& curve_list_splines, *curve_splines);
#line 337
      free_spline_list(*curve_splines);
#line 338
      free((void *)curve_splines);
      }
    }
#line 303
    this_curve ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 342
  if (at_log_file) {
    {
#line 344
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 344
      if (at_log_file) {
        {
#line 344
        fputs((char const   */* __restrict  */)"\nFitted splines are:\n", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 344
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 345
    this_spline = 0U;
    {
#line 345
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 345
      if (! (this_spline < curve_list_splines.length)) {
#line 345
        goto while_break___14;
      }
      {
#line 348
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 348
        if (at_log_file) {
          {
#line 348
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  %u: ",
                  this_spline);
          }
        }
#line 348
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 349
      print_spline(at_log_file, *(curve_list_splines.data + this_spline));
#line 345
      this_spline ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
  }
  cleanup: 
#line 354
  return (curve_list_splines);
}
}
#line 361 "fit.c"
static spline_list_type *fit_curve(curve_type curve , fitting_opts_type *fitting_opts ,
                                   at_exception_type *exception ) 
{ 
  spline_list_type *fittedsplines ;
  spline_list_type *tmp ;
  spline_list_type *tmp___0 ;

  {
#line 367
  if (curve->length < 2U) {
    {
#line 369
    while (1) {
      while_continue: /* CIL Label */ ;
#line 369
      if (at_log_file) {
        {
#line 369
        fputs((char const   */* __restrict  */)"Tried to fit curve with less than two points",
              (FILE */* __restrict  */)at_log_file);
        }
      }
#line 369
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 370
    at_exception_warning(exception, (at_string const   )"Tried to fit curve with less than two points");
    }
#line 372
    return ((spline_list_type *)((void *)0));
  }
#line 376
  if (curve->length < 4U) {
    {
#line 376
    tmp = fit_with_line(curve);
#line 376
    fittedsplines = tmp;
    }
  } else {
    {
#line 376
    tmp___0 = fit_with_least_squares(curve, fitting_opts, exception);
#line 376
    fittedsplines = tmp___0;
    }
  }
#line 380
  return (fittedsplines);
}
}
#line 408 "fit.c"
static curve_list_array_type split_at_corners(pixel_outline_list_type pixel_list ,
                                              fitting_opts_type *fitting_opts , at_exception_type *exception ) 
{ 
  unsigned int this_pixel_o ;
  curve_list_array_type curve_array ;
  curve_list_array_type tmp ;
  curve_type curve ;
  curve_type first_curve ;
  index_list_type corner_list ;
  unsigned int p ;
  unsigned int this_corner ;
  curve_list_type curve_list ;
  curve_list_type tmp___0 ;
  pixel_outline_type pixel_o ;
  int surround ;
  unsigned int save_corner_surround ;
  curve_type previous_curve ;
  unsigned int corner ;
  unsigned int next_corner ;
  curve_type last_curve ;

  {
  {
#line 413
  tmp = new_curve_list_array();
#line 413
  curve_array = tmp;
  }
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (at_log_file) {
      {
#line 415
      fputs((char const   */* __restrict  */)"\nFinding corners:\n", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 415
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  this_pixel_o = 0U;
  {
#line 417
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 417
    if (! (this_pixel_o < pixel_list.length)) {
#line 417
      goto while_break___0;
    }
    {
#line 423
    tmp___0 = new_curve_list();
#line 423
    curve_list = tmp___0;
#line 424
    pixel_o = *(pixel_list.data + this_pixel_o);
#line 426
    curve_list.clockwise = pixel_o.clockwise;
#line 427
    curve_list.open = pixel_o.open;
    }
    {
#line 429
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 429
      if (at_log_file) {
        {
#line 429
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"#%u:",
                this_pixel_o);
        }
      }
#line 429
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 436
    if (pixel_o.length > fitting_opts->corner_surround * 2U + 2U) {
      {
#line 437
      corner_list = find_corners(pixel_o, fitting_opts, exception);
      }
    } else {
#line 442
      surround = (int )(pixel_o.length - 3U) / 2;
#line 442
      if (surround >= 2) {
        {
#line 444
        save_corner_surround = fitting_opts->corner_surround;
#line 445
        fitting_opts->corner_surround = (unsigned int )surround;
#line 446
        corner_list = find_corners(pixel_o, fitting_opts, exception);
#line 448
        fitting_opts->corner_surround = save_corner_surround;
        }
      } else {
#line 452
        corner_list.length = 0U;
#line 453
        corner_list.data = (unsigned int *)((void *)0);
      }
    }
    {
#line 459
    first_curve = new_curve();
#line 461
    curve = first_curve;
    }
#line 463
    if (corner_list.length == 0U) {
#line 465
      p = 0U;
      {
#line 465
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 465
        if (! (p < pixel_o.length)) {
#line 465
          goto while_break___2;
        }
        {
#line 466
        append_pixel(curve, *(pixel_o.data + p));
#line 465
        p ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 468
      if ((unsigned int )curve_list.open == 1U) {
#line 469
        curve->cyclic = (at_bool )0;
      } else {
#line 471
        curve->cyclic = (at_bool )1;
      }
    } else {
#line 476
      this_corner = 0U;
      {
#line 476
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 476
        if (! (this_corner < corner_list.length - 1U)) {
#line 476
          goto while_break___3;
        }
#line 479
        previous_curve = curve;
#line 480
        corner = *(corner_list.data + this_corner);
#line 481
        next_corner = *(corner_list.data + (this_corner + 1U));
#line 483
        p = corner;
        {
#line 483
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 483
          if (! (p <= next_corner)) {
#line 483
            goto while_break___4;
          }
          {
#line 484
          append_pixel(curve, *(pixel_o.data + p));
#line 483
          p ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 486
        append_curve(& curve_list, curve);
#line 487
        curve = new_curve();
#line 488
        previous_curve->next = curve;
#line 489
        curve->previous = previous_curve;
#line 476
        this_corner ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 495
      p = *(corner_list.data + (corner_list.length - 1U));
      {
#line 495
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 495
        if (! (p < pixel_o.length)) {
#line 495
          goto while_break___5;
        }
        {
#line 497
        append_pixel(curve, *(pixel_o.data + p));
#line 495
        p ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 499
      if (! pixel_o.open) {
#line 501
        p = 0U;
        {
#line 501
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 501
          if (! (p <= *(corner_list.data + 0))) {
#line 501
            goto while_break___6;
          }
          {
#line 502
          append_pixel(curve, *(pixel_o.data + p));
#line 501
          p ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
#line 506
        last_curve = curve->previous;
#line 507
        first_curve->previous = (struct curve *)((void *)0);
#line 508
        if (last_curve) {
#line 508
          last_curve->next = (struct curve *)((void *)0);
        }
      }
    }
    {
#line 512
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 512
      if (at_log_file) {
        {
#line 512
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" [%u].\n",
                corner_list.length);
        }
      }
#line 512
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 513
    free_index_list(& corner_list);
#line 517
    append_curve(& curve_list, curve);
#line 518
    curve->next = first_curve;
#line 519
    first_curve->previous = curve;
#line 522
    append_curve_list(& curve_array, curve_list);
#line 417
    this_pixel_o ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 525
  return (curve_array);
}
}
#line 550 "fit.c"
static index_list_type find_corners(pixel_outline_type pixel_outline , fitting_opts_type *fitting_opts ,
                                    at_exception_type *exception ) 
{ 
  unsigned int p ;
  unsigned int start_p ;
  unsigned int end_p ;
  index_list_type corner_list ;
  index_list_type tmp ;
  at_real corner_angle ;
  vector_type in_vector ;
  vector_type out_vector ;
  at_bool tmp___0 ;
  at_real best_corner_angle ;
  unsigned int best_corner_index ;
  index_list_type equally_good_list ;
  index_list_type tmp___1 ;
  unsigned int q ;
  unsigned int i ;
  at_bool tmp___2 ;
  at_bool tmp___3 ;
  unsigned int j ;
  double tmp___4 ;
  int tmp___5 ;

  {
  {
#line 556
  tmp = new_index_list();
#line 556
  corner_list = tmp;
#line 558
  start_p = 0U;
#line 559
  end_p = pixel_outline.length - 1U;
  }
#line 560
  if (pixel_outline.open) {
#line 562
    if (end_p <= fitting_opts->corner_surround * 2U) {
#line 563
      return (corner_list);
    }
    {
#line 564
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 564
      append_index(& corner_list, 0U);
      }
      {
#line 564
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 564
        if (at_log_file) {
          {
#line 564
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" (%d,%d)%c%.3f",
                  (int )(pixel_outline.data + 0)->x, (int )(pixel_outline.data + 0)->y,
                  '@', 0.0);
          }
        }
#line 564
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 564
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 565
    start_p += fitting_opts->corner_surround;
#line 566
    end_p -= fitting_opts->corner_surround;
  }
#line 570
  p = start_p;
  {
#line 570
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 570
    if (! (p <= end_p)) {
#line 570
      goto while_break___1;
    }
    {
#line 576
    find_vectors(p, pixel_outline, & in_vector, & out_vector, fitting_opts->corner_surround);
#line 578
    corner_angle = Vangle((vector_type const   )in_vector, (vector_type const   )out_vector,
                          exception);
#line 579
    tmp___0 = at_exception_got_fatal(exception);
    }
#line 579
    if (tmp___0) {
#line 580
      goto cleanup;
    }
    {
#line 582
    tmp___4 = fabs((double )corner_angle);
    }
#line 582
    if (tmp___4 <= (double )fitting_opts->corner_threshold) {
      {
#line 588
      best_corner_angle = corner_angle;
#line 589
      best_corner_index = p;
#line 590
      tmp___1 = new_index_list();
#line 590
      equally_good_list = tmp___1;
#line 595
      q = p;
#line 596
      i = p + 1U;
      }
      {
#line 598
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 608
        if (corner_angle <= fitting_opts->corner_always_threshold) {
#line 608
          if (q >= p) {
            {
#line 609
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 609
              append_index(& corner_list, q);
              }
              {
#line 609
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 609
                if (at_log_file) {
                  {
#line 609
                  fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" (%d,%d)%c%.3f",
                          (int )(pixel_outline.data + q)->x, (int )(pixel_outline.data + q)->y,
                          '\\', (double )corner_angle);
                  }
                }
#line 609
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 609
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
#line 614
        if (i >= best_corner_index + fitting_opts->corner_surround) {
#line 616
          goto while_break___2;
        } else
#line 614
        if (i >= pixel_outline.length) {
#line 616
          goto while_break___2;
        }
        {
#line 619
        q = i % pixel_outline.length;
#line 620
        find_vectors(q, pixel_outline, & in_vector, & out_vector, fitting_opts->corner_surround);
#line 622
        corner_angle = Vangle((vector_type const   )in_vector, (vector_type const   )out_vector,
                              exception);
#line 623
        tmp___2 = at_exception_got_fatal(exception);
        }
#line 623
        if (tmp___2) {
#line 624
          goto cleanup;
        }
        {
#line 630
        tmp___3 = epsilon_equal(corner_angle, best_corner_angle);
        }
#line 630
        if (tmp___3) {
          {
#line 631
          append_index(& equally_good_list, q);
          }
        } else
#line 633
        if (corner_angle < best_corner_angle) {
          {
#line 635
          best_corner_angle = corner_angle;
#line 638
          best_corner_index = q;
#line 638
          i = best_corner_index;
#line 639
          free_index_list(& equally_good_list);
#line 640
          equally_good_list = new_index_list();
          }
        }
#line 643
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 651
      if (best_corner_angle > fitting_opts->corner_always_threshold) {
#line 651
        if (best_corner_index >= p) {
          {
#line 656
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 656
            append_index(& corner_list, best_corner_index);
            }
            {
#line 656
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 656
              if (at_log_file) {
                {
#line 656
                fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" (%d,%d)%c%.3f",
                        (int )(pixel_outline.data + best_corner_index)->x, (int )(pixel_outline.data + best_corner_index)->y,
                        '/', (double )best_corner_angle);
                }
              }
#line 656
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 656
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 658
          j = 0U;
          {
#line 658
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 658
            if (! (j < equally_good_list.length)) {
#line 658
              goto while_break___7;
            }
            {
#line 659
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 659
              append_index(& corner_list, *(equally_good_list.data + j));
              }
              {
#line 659
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 659
                if (at_log_file) {
                  {
#line 659
                  fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" (%d,%d)%c%.3f",
                          (int )(pixel_outline.data + *(equally_good_list.data + j))->x,
                          (int )(pixel_outline.data + *(equally_good_list.data + j))->y,
                          '@', (double )best_corner_angle);
                  }
                }
#line 659
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 659
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 658
            j ++;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
      }
      {
#line 662
      free_index_list(& equally_good_list);
      }
#line 667
      if (q < p) {
#line 667
        p = pixel_outline.length;
      } else {
#line 667
        p = q;
      }
    }
#line 570
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 671
  if (corner_list.length > 0U) {
#line 675
    if (pixel_outline.open) {
#line 675
      tmp___5 = 2;
    } else {
#line 675
      tmp___5 = 1;
    }
    {
#line 675
    remove_adjacent_corners(& corner_list, pixel_outline.length - (unsigned int )tmp___5,
                            fitting_opts->remove_adjacent_corners, exception);
    }
  }
  cleanup: 
#line 680
  return (corner_list);
}
}
#line 691 "fit.c"
static void find_vectors(unsigned int test_index , pixel_outline_type outline , vector_type *in ,
                         vector_type *out , unsigned int corner_surround ) 
{ 
  int i ;
  unsigned int n_done ;
  at_coord candidate ;
  at_real tmp ;
  at_real tmp___0 ;
  at_real tmp___1 ;
  at_real tmp___2 ;
  vector_type tmp___3 ;
  vector_type tmp___4 ;

  {
#line 698
  candidate = *(outline.data + test_index);
#line 700
  tmp___0 = (at_real )0.0;
#line 700
  in->dz = tmp___0;
#line 700
  tmp = tmp___0;
#line 700
  in->dy = tmp;
#line 700
  in->dx = tmp;
#line 701
  tmp___2 = (at_real )0.0;
#line 701
  out->dz = tmp___2;
#line 701
  tmp___1 = tmp___2;
#line 701
  out->dy = tmp___1;
#line 701
  out->dx = tmp___1;
#line 705
  if (test_index == 0U) {
#line 705
    i = (int )(outline.length - 1U);
  } else {
#line 705
    i = (int )(test_index - 1U);
  }
#line 705
  n_done = 0U;
  {
#line 705
  while (1) {
    while_continue: /* CIL Label */ ;
#line 705
    if (! (n_done < corner_surround)) {
#line 705
      goto while_break;
    }
    {
#line 708
    tmp___3 = IPsubtract((at_coord const   )*(outline.data + i), (at_coord const   )candidate);
#line 708
    *in = Vadd((vector_type const   )*in, (vector_type const   )tmp___3);
    }
#line 705
    if (i == 0) {
#line 705
      i = (int )(outline.length - 1U);
    } else {
#line 705
      i --;
    }
#line 705
    n_done ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 711
  i = (int )((test_index + 1U) % outline.length);
#line 711
  n_done = 0U;
  {
#line 711
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 711
    if (! (n_done < corner_surround)) {
#line 711
      goto while_break___0;
    }
    {
#line 713
    tmp___4 = IPsubtract((at_coord const   )*(outline.data + i), (at_coord const   )candidate);
#line 713
    *out = Vadd((vector_type const   )*out, (vector_type const   )tmp___4);
#line 711
    i = (int )((unsigned int )(i + 1) % outline.length);
#line 711
    n_done ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 714
  return;
}
}
#line 726 "fit.c"
static void remove_adjacent_corners(index_list_type *list , unsigned int last_index ,
                                    at_bool remove_adj_corners , at_exception_type *exception ) 
{ 
  unsigned int j ;
  unsigned int last ;
  index_list_type new_list ;
  index_list_type tmp ;
  unsigned int search ;
  unsigned int temp ;
  unsigned int max_index ;
  unsigned int current ;
  unsigned int next ;

  {
  {
#line 734
  tmp = new_index_list();
#line 734
  new_list = tmp;
#line 736
  j = list->length - 1U;
  }
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (j > 0U)) {
#line 736
      goto while_break;
    }
#line 741
    max_index = j;
#line 743
    search = 0U;
    {
#line 743
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 743
      if (! (search < j)) {
#line 743
        goto while_break___0;
      }
#line 744
      if (*(list->data + search) > *(list->data + max_index)) {
#line 745
        max_index = search;
      }
#line 743
      search ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 747
    if (max_index != j) {
#line 749
      temp = *(list->data + j);
#line 750
      *(list->data + j) = *(list->data + max_index);
#line 751
      *(list->data + max_index) = temp;
      {
#line 754
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 754
        if (at_log_file) {
          {
#line 754
          fputs((char const   */* __restrict  */)"needed exchange", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 754
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 755
      at_exception_warning(exception, (at_string const   )"needed exchange");
      }
    }
#line 736
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  j = 0U;
  {
#line 762
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 762
    if (! (j < list->length - 1U)) {
#line 762
      goto while_break___2;
    }
#line 764
    current = *(list->data + j);
#line 765
    next = *(list->data + (j + 1U));
#line 770
    if (remove_adj_corners) {
#line 770
      if (next == current + 1U) {
#line 771
        j ++;
      } else
#line 770
      if (next == current) {
#line 771
        j ++;
      }
    }
    {
#line 773
    append_index(& new_list, current);
#line 762
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 778
  last = *(list->data + (list->length - 1U));
#line 779
  if (new_list.length == 0U) {
    {
#line 782
    append_index(& new_list, last);
    }
  } else
#line 779
  if (! (last == *(new_list.data + (new_list.length - 1U)) + 1U)) {
#line 779
    if (last == last_index) {
#line 779
      if (! (*(list->data + 0) == 0U)) {
        {
#line 782
        append_index(& new_list, last);
        }
      }
    } else {
      {
#line 782
      append_index(& new_list, last);
      }
    }
  }
  {
#line 784
  free_index_list(list);
#line 785
  *list = new_list;
  }
#line 786
  return;
}
}
#line 824 "fit.c"
static void remove_knee_points(curve_type curve , at_bool clockwise ) 
{ 
  unsigned int i ;
  unsigned int offset ;
  int tmp ;
  at_coord previous ;
  int tmp___0 ;
  int tmp___1 ;
  at_coord tmp___2 ;
  curve_type trimmed_curve ;
  curve_type tmp___3 ;
  at_coord tmp___4 ;
  at_coord current ;
  at_coord tmp___5 ;
  at_coord next ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  at_coord tmp___8 ;
  vector_type prev_delta ;
  vector_type tmp___9 ;
  vector_type next_delta ;
  vector_type tmp___10 ;
  at_coord tmp___11 ;

  {
#line 828
  if ((unsigned int )curve->cyclic == 1U) {
#line 828
    tmp = 0;
  } else {
#line 828
    tmp = 1;
  }
#line 828
  offset = (unsigned int )tmp;
#line 829
  if ((int )offset - 1 < 0) {
#line 829
    if (curve->cyclic) {
#line 829
      tmp___0 = ((int )curve->length + (int )offset) - 1;
    } else {
#line 829
      tmp___0 = -1;
    }
#line 829
    tmp___1 = tmp___0;
  } else {
#line 829
    tmp___1 = (int )offset - 1;
  }
  {
#line 829
  tmp___2 = real_to_int_coord((curve->point_list + tmp___1)->coord);
#line 829
  previous = tmp___2;
#line 831
  tmp___3 = copy_most_of_curve(curve);
#line 831
  trimmed_curve = tmp___3;
  }
#line 833
  if ((unsigned int )curve->cyclic == 0U) {
    {
#line 834
    tmp___4 = real_to_int_coord((curve->point_list + 0)->coord);
#line 834
    append_pixel(trimmed_curve, tmp___4);
    }
  }
#line 836
  i = offset;
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! (i < curve->length - offset)) {
#line 836
      goto while_break;
    }
    {
#line 838
    tmp___5 = real_to_int_coord((curve->point_list + i)->coord);
#line 838
    current = tmp___5;
    }
#line 840
    if (i + 1U >= curve->length) {
#line 840
      if (curve->cyclic) {
#line 840
        tmp___6 = (i + 1U) % curve->length;
      } else {
#line 840
        tmp___6 = curve->length;
      }
#line 840
      tmp___7 = tmp___6;
    } else {
#line 840
      tmp___7 = i + 1U;
    }
    {
#line 840
    tmp___8 = real_to_int_coord((curve->point_list + tmp___7)->coord);
#line 840
    next = tmp___8;
#line 842
    tmp___9 = IPsubtract((at_coord const   )previous, (at_coord const   )current);
#line 842
    prev_delta = tmp___9;
#line 843
    tmp___10 = IPsubtract((at_coord const   )next, (at_coord const   )current);
#line 843
    next_delta = tmp___10;
    }
#line 845
    if ((double )prev_delta.dx == 0.0) {
#line 845
      if ((double )prev_delta.dy != 0.0) {
#line 845
        goto _L___10;
      } else {
#line 845
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 845
    if ((double )prev_delta.dy == 0.0) {
#line 845
      if ((double )prev_delta.dx != 0.0) {
        _L___10: /* CIL Label */ 
#line 845
        if ((double )next_delta.dx == 0.0) {
#line 845
          if ((double )next_delta.dy != 0.0) {
#line 845
            goto _L___8;
          } else {
#line 845
            goto _L___9;
          }
        } else
        _L___9: /* CIL Label */ 
#line 845
        if ((double )next_delta.dy == 0.0) {
#line 845
          if ((double )next_delta.dx != 0.0) {
            _L___8: /* CIL Label */ 
#line 845
            if (clockwise) {
#line 845
              if ((double )prev_delta.dx == - 1.0) {
#line 845
                if ((double )next_delta.dy == 1.0) {
#line 845
                  goto _L___0;
                } else {
#line 845
                  goto _L___7;
                }
              } else
              _L___7: /* CIL Label */ 
#line 845
              if ((double )prev_delta.dy == 1.0) {
#line 845
                if ((double )next_delta.dx == 1.0) {
#line 845
                  goto _L___0;
                } else {
#line 845
                  goto _L___6;
                }
              } else
              _L___6: /* CIL Label */ 
#line 845
              if ((double )prev_delta.dx == 1.0) {
#line 845
                if ((double )next_delta.dy == - 1.0) {
#line 845
                  goto _L___0;
                } else {
#line 845
                  goto _L___5;
                }
              } else
              _L___5: /* CIL Label */ 
#line 845
              if ((double )prev_delta.dy == - 1.0) {
#line 845
                if ((double )next_delta.dx == - 1.0) {
#line 845
                  goto _L___0;
                } else {
#line 845
                  goto _L___4;
                }
              } else {
#line 845
                goto _L___4;
              }
            } else
            _L___4: /* CIL Label */ 
#line 845
            if (! clockwise) {
#line 845
              if ((double )prev_delta.dy == 1.0) {
#line 845
                if ((double )next_delta.dx == - 1.0) {
#line 845
                  goto _L___0;
                } else {
#line 845
                  goto _L___3;
                }
              } else
              _L___3: /* CIL Label */ 
#line 845
              if ((double )prev_delta.dx == 1.0) {
#line 845
                if ((double )next_delta.dy == 1.0) {
#line 845
                  goto _L___0;
                } else {
#line 845
                  goto _L___2;
                }
              } else
              _L___2: /* CIL Label */ 
#line 845
              if ((double )prev_delta.dy == - 1.0) {
#line 845
                if ((double )next_delta.dx == 1.0) {
#line 845
                  goto _L___0;
                } else {
#line 845
                  goto _L___1;
                }
              } else
              _L___1: /* CIL Label */ 
#line 845
              if ((double )prev_delta.dx == - 1.0) {
#line 845
                if ((double )next_delta.dy == - 1.0) {
                  _L___0: /* CIL Label */ 
                  {
#line 849
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 849
                    if (at_log_file) {
                      {
#line 849
                      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)" (%d,%d)",
                              (int )current.x, (int )current.y);
                      }
                    }
#line 849
                    goto while_break___0;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                } else {
                  {
#line 852
                  previous = current;
#line 853
                  append_pixel(trimmed_curve, current);
                  }
                }
              } else {
                {
#line 852
                previous = current;
#line 853
                append_pixel(trimmed_curve, current);
                }
              }
            } else {
              {
#line 852
              previous = current;
#line 853
              append_pixel(trimmed_curve, current);
              }
            }
          } else {
            {
#line 852
            previous = current;
#line 853
            append_pixel(trimmed_curve, current);
            }
          }
        } else {
          {
#line 852
          previous = current;
#line 853
          append_pixel(trimmed_curve, current);
          }
        }
      } else {
        {
#line 852
        previous = current;
#line 853
        append_pixel(trimmed_curve, current);
        }
      }
    } else {
      {
#line 852
      previous = current;
#line 853
      append_pixel(trimmed_curve, current);
      }
    }
#line 836
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  if ((unsigned int )curve->cyclic == 0U) {
    {
#line 858
    tmp___11 = real_to_int_coord((curve->point_list + (curve->length - 1U))->coord);
#line 858
    append_pixel(trimmed_curve, tmp___11);
    }
  }
#line 860
  if (trimmed_curve->length == curve->length) {
    {
#line 861
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 861
      if (at_log_file) {
        {
#line 861
        fputs((char const   */* __restrict  */)" (none)", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 861
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 863
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 863
    if (at_log_file) {
      {
#line 863
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 863
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 865
  free_curve(curve);
#line 866
  *curve = *trimmed_curve;
#line 867
  free((void *)trimmed_curve);
  }
#line 868
  return;
}
}
#line 873 "fit.c"
static void filter(curve_type curve , fitting_opts_type *fitting_opts ) 
{ 
  unsigned int iteration ;
  unsigned int this_point ;
  unsigned int offset ;
  int tmp ;
  at_real_coord prev_new_point ;
  curve_type newcurve ;
  curve_type tmp___0 ;
  at_bool collapsed ;
  vector_type in ;
  vector_type out ;
  vector_type sum ;
  at_real_coord new_point ;
  int prev ;
  int prevprev ;
  unsigned int next ;
  unsigned int nextnext ;
  at_real_coord candidate ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  vector_type tmp___5 ;
  vector_type tmp___6 ;
  vector_type tmp___7 ;
  vector_type tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;

  {
#line 877
  if ((unsigned int )curve->cyclic == 1U) {
#line 877
    tmp = 0;
  } else {
#line 877
    tmp = 1;
  }
#line 877
  offset = (unsigned int )tmp;
#line 884
  if (curve->length < 5U) {
    {
#line 886
    while (1) {
      while_continue: /* CIL Label */ ;
#line 886
      if (at_log_file) {
        {
#line 886
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Length is %u, not enough to filter.\n",
                curve->length);
        }
      }
#line 886
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 887
    return;
  }
#line 890
  prev_new_point.x = 3.40282346638528859812e+38F;
#line 891
  prev_new_point.y = 3.40282346638528859812e+38F;
#line 892
  prev_new_point.z = 3.40282346638528859812e+38F;
#line 894
  iteration = 0U;
  {
#line 894
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 894
    if (! (iteration < fitting_opts->filter_iterations)) {
#line 894
      goto while_break___0;
    }
    {
#line 897
    tmp___0 = copy_most_of_curve(curve);
#line 897
    newcurve = tmp___0;
#line 898
    collapsed = (at_bool )0;
    }
#line 901
    if (offset) {
      {
#line 902
      append_point(newcurve, (curve->point_list + 0)->coord);
      }
    }
#line 904
    this_point = offset;
    {
#line 904
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 904
      if (! (this_point < curve->length - offset)) {
#line 904
        goto while_break___1;
      }
#line 916
      candidate = (curve->point_list + this_point)->coord;
#line 918
      if ((int )this_point - 1 < 0) {
#line 918
        if (curve->cyclic) {
#line 918
          tmp___1 = ((int )curve->length + (int )this_point) - 1;
        } else {
#line 918
          tmp___1 = -1;
        }
#line 918
        prev = tmp___1;
      } else {
#line 918
        prev = (int )this_point - 1;
      }
#line 919
      if (prev - 1 < 0) {
#line 919
        if (curve->cyclic) {
#line 919
          tmp___2 = ((int )curve->length + prev) - 1;
        } else {
#line 919
          tmp___2 = -1;
        }
#line 919
        prevprev = tmp___2;
      } else {
#line 919
        prevprev = prev - 1;
      }
#line 920
      if (this_point + 1U >= curve->length) {
#line 920
        if (curve->cyclic) {
#line 920
          tmp___3 = (this_point + 1U) % curve->length;
        } else {
#line 920
          tmp___3 = curve->length;
        }
#line 920
        next = tmp___3;
      } else {
#line 920
        next = this_point + 1U;
      }
#line 921
      if (next + 1U >= curve->length) {
#line 921
        if (curve->cyclic) {
#line 921
          tmp___4 = (next + 1U) % curve->length;
        } else {
#line 921
          tmp___4 = curve->length;
        }
#line 921
        nextnext = tmp___4;
      } else {
#line 921
        nextnext = next + 1U;
      }
      {
#line 925
      in.dz = (at_real )0.0;
#line 925
      in.dy = in.dz;
#line 925
      in.dx = in.dy;
#line 927
      tmp___5 = Psubtract((at_real_coord const   )(curve->point_list + prev)->coord,
                          (at_real_coord const   )candidate);
#line 927
      in = Vadd((vector_type const   )in, (vector_type const   )tmp___5);
      }
#line 928
      if (prevprev >= 0) {
        {
#line 929
        tmp___6 = Psubtract((at_real_coord const   )(curve->point_list + prevprev)->coord,
                            (at_real_coord const   )candidate);
#line 929
        in = Vadd((vector_type const   )in, (vector_type const   )tmp___6);
        }
      }
      {
#line 933
      out.dz = (at_real )0.0;
#line 933
      out.dy = out.dz;
#line 933
      out.dx = out.dy;
#line 935
      tmp___7 = Psubtract((at_real_coord const   )(curve->point_list + next)->coord,
                          (at_real_coord const   )candidate);
#line 935
      out = Vadd((vector_type const   )out, (vector_type const   )tmp___7);
      }
#line 936
      if (nextnext < curve->length) {
        {
#line 937
        tmp___8 = Psubtract((at_real_coord const   )(curve->point_list + nextnext)->coord,
                            (at_real_coord const   )candidate);
#line 937
        out = Vadd((vector_type const   )out, (vector_type const   )tmp___8);
        }
      }
      {
#line 940
      new_point = candidate;
#line 941
      sum = Vadd((vector_type const   )in, (vector_type const   )out);
#line 943
      new_point.x += sum.dx / (at_real )6;
#line 944
      new_point.y += sum.dy / (at_real )6;
#line 945
      new_point.z += sum.dz / (at_real )6;
#line 946
      tmp___9 = fabs((double )(prev_new_point.x - new_point.x));
      }
#line 946
      if (tmp___9 < 0.3) {
        {
#line 946
        tmp___10 = fabs((double )(prev_new_point.y - new_point.y));
        }
#line 946
        if (tmp___10 < 0.3) {
          {
#line 946
          tmp___11 = fabs((double )(prev_new_point.z - new_point.z));
          }
#line 946
          if (tmp___11 < 0.3) {
#line 950
            collapsed = (at_bool )1;
#line 951
            goto while_break___1;
          }
        }
      }
      {
#line 957
      prev_new_point = new_point;
#line 957
      append_point(newcurve, prev_new_point);
#line 904
      this_point ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 960
    if (collapsed) {
      {
#line 961
      free_curve(newcurve);
      }
    } else {
#line 965
      if (offset) {
        {
#line 966
        append_point(newcurve, (curve->point_list + (curve->length - 1U))->coord);
        }
      }
      {
#line 969
      free_curve(curve);
#line 970
      *curve = *newcurve;
      }
    }
    {
#line 972
    free((void *)newcurve);
#line 894
    iteration ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 975
  log_curve(curve, (at_bool )0);
  }
#line 976
  return;
}
}
#line 984 "fit.c"
static spline_list_type *fit_with_line(curve_type curve ) 
{ 
  spline_type line ;
  spline_list_type *tmp ;

  {
  {
#line 989
  while (1) {
    while_continue: /* CIL Label */ ;
#line 989
    if (at_log_file) {
      {
#line 989
      fputs((char const   */* __restrict  */)"Fitting with straight line:\n", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 989
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 991
  line.degree = (at_polynomial_degree )1;
#line 992
  line.v[1] = (curve->point_list + 0)->coord;
#line 992
  line.v[0] = line.v[1];
#line 993
  line.v[2] = (curve->point_list + (curve->length - 1U))->coord;
#line 993
  line.v[3] = line.v[2];
#line 996
  line.linearity = (at_real )0;
#line 998
  if (at_log_file) {
    {
#line 1000
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1000
      if (at_log_file) {
        {
#line 1000
        fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 1000
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1001
    print_spline(at_log_file, line);
    }
  }
  {
#line 1004
  tmp = new_spline_list_with_spline(line);
  }
#line 1004
  return (tmp);
}
}
#line 1011 "fit.c"
static spline_list_type *fit_with_least_squares(curve_type curve , fitting_opts_type *fitting_opts ,
                                                at_exception_type *exception ) 
{ 
  at_real error ;
  at_real best_error ;
  spline_type spline ;
  spline_type best_spline ;
  spline_list_type *spline_list ;
  unsigned int worst_point ;
  at_real previous_error ;
  at_bool tmp ;
  at_bool tmp___0 ;
  unsigned int subdivision_index ;
  spline_list_type *left_spline_list ;
  spline_list_type *right_spline_list ;
  curve_type left_curve ;
  curve_type tmp___1 ;
  curve_type right_curve ;
  curve_type tmp___2 ;
  at_bool tmp___3 ;
  at_bool tmp___4 ;

  {
#line 1016
  error = (at_real )0;
#line 1016
  best_error = 3.40282346638528859812e+38F;
#line 1018
  spline_list = (spline_list_type *)((void *)0);
#line 1019
  worst_point = 0U;
#line 1020
  previous_error = 3.40282346638528859812e+38F;
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1022
    if (at_log_file) {
      {
#line 1022
      fputs((char const   */* __restrict  */)"\nFitting with least squares:\n", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 1022
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1032
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1032
    if (at_log_file) {
      {
#line 1032
      fputs((char const   */* __restrict  */)"Finding tangents:\n", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 1032
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1033
  find_tangent(curve, (at_bool )1, (at_bool )0, fitting_opts->tangent_surround);
#line 1035
  find_tangent(curve, (at_bool )0, (at_bool )0, fitting_opts->tangent_surround);
#line 1038
  set_initial_parameter_values(curve);
  }
  {
#line 1042
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1044
    best_spline = fit_one_spline(curve, exception);
#line 1044
    spline = best_spline;
#line 1045
    tmp = at_exception_got_fatal(exception);
    }
#line 1045
    if (tmp) {
#line 1046
      goto cleanup;
    }
#line 1048
    if ((unsigned int )spline.degree == 1U) {
      {
#line 1049
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1049
        if (at_log_file) {
          {
#line 1049
          fputs((char const   */* __restrict  */)"  fitted to line:\n", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 1049
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 1051
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1051
        if (at_log_file) {
          {
#line 1051
          fputs((char const   */* __restrict  */)"  fitted to spline:\n", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 1051
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1053
    if (at_log_file) {
      {
#line 1055
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1055
        if (at_log_file) {
          {
#line 1055
          fputs((char const   */* __restrict  */)"    ", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 1055
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1056
      print_spline(at_log_file, spline);
      }
    }
#line 1059
    if ((unsigned int )spline.degree == 1U) {
#line 1060
      goto while_break___1;
    }
    {
#line 1062
    error = find_error(curve, spline, & worst_point, exception);
    }
#line 1063
    if (error <= previous_error) {
#line 1065
      best_error = error;
#line 1066
      best_spline = spline;
    }
#line 1068
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1071
  if ((unsigned int )spline.degree == 1U) {
    {
#line 1073
    spline_list = new_spline_list_with_spline(spline);
    }
    {
#line 1074
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1074
      if (at_log_file) {
        {
#line 1074
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Accepted error of %.3f.\n",
                (double )error);
        }
      }
#line 1074
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1075
    return (spline_list);
  }
#line 1079
  spline = best_spline;
#line 1080
  error = best_error;
#line 1082
  if (error < fitting_opts->error_threshold) {
#line 1082
    if ((unsigned int )curve->cyclic == 0U) {
      {
#line 1088
      tmp___0 = spline_linear_enough(& spline, curve, fitting_opts);
      }
#line 1088
      if (tmp___0) {
#line 1090
        spline.degree = (at_polynomial_degree )1;
        {
#line 1091
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1091
          if (at_log_file) {
            {
#line 1091
            fputs((char const   */* __restrict  */)"Changed to line.\n", (FILE */* __restrict  */)at_log_file);
            }
          }
#line 1091
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
#line 1093
      spline_list = new_spline_list_with_spline(spline);
      }
      {
#line 1094
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1094
        if (at_log_file) {
          {
#line 1094
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Accepted error of %.3f.\n",
                  (double )error);
          }
        }
#line 1094
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    } else {
#line 1082
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1102
    tmp___1 = new_curve();
#line 1102
    left_curve = tmp___1;
#line 1103
    tmp___2 = new_curve();
#line 1103
    right_curve = tmp___2;
#line 1106
    right_curve->next = curve->next;
#line 1107
    right_curve->previous = left_curve;
#line 1108
    left_curve->next = right_curve;
#line 1109
    left_curve->previous = curve;
#line 1110
    curve->next = left_curve;
    }
    {
#line 1112
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1112
      if (at_log_file) {
        {
#line 1112
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"\nSubdividing (error %.3f):\n",
                (double )error);
        }
      }
#line 1112
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1113
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1113
      if (at_log_file) {
        {
#line 1113
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  Original point: (%.3f,%.3f), #%u.\n",
                (double )(curve->point_list + worst_point)->coord.x, (double )(curve->point_list + worst_point)->coord.y,
                worst_point);
        }
      }
#line 1113
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1116
    subdivision_index = worst_point;
    {
#line 1117
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1117
      if (at_log_file) {
        {
#line 1117
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  Final point: (%.3f,%.3f), #%u.\n",
                (double )(curve->point_list + subdivision_index)->coord.x, (double )(curve->point_list + subdivision_index)->coord.y,
                subdivision_index);
        }
      }
#line 1117
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 1123
    left_curve->length = subdivision_index + 1U;
#line 1124
    right_curve->length = curve->length - subdivision_index;
#line 1125
    left_curve->point_list = curve->point_list;
#line 1126
    right_curve->point_list = curve->point_list + subdivision_index;
#line 1131
    left_curve->start_tangent = curve->start_tangent;
#line 1132
    right_curve->end_tangent = curve->end_tangent;
#line 1139
    find_tangent(left_curve, (at_bool )0, (at_bool )1, fitting_opts->tangent_surround);
#line 1141
    right_curve->start_tangent = left_curve->end_tangent;
#line 1144
    left_spline_list = fit_curve(left_curve, fitting_opts, exception);
#line 1146
    tmp___3 = at_exception_got_fatal(exception);
    }
#line 1146
    if (tmp___3) {
#line 1149
      goto cleanup;
    }
    {
#line 1151
    right_spline_list = fit_curve(right_curve, fitting_opts, exception);
#line 1155
    tmp___4 = at_exception_got_fatal(exception);
    }
#line 1155
    if (tmp___4) {
#line 1156
      goto cleanup;
    }
#line 1159
    if ((unsigned long )left_spline_list == (unsigned long )((void *)0)) {
#line 1159
      if ((unsigned long )right_spline_list == (unsigned long )((void *)0)) {
#line 1160
        return ((spline_list_type *)((void *)0));
      }
    }
    {
#line 1163
    spline_list = new_spline_list();
    }
#line 1165
    if ((unsigned long )left_spline_list == (unsigned long )((void *)0)) {
      {
#line 1167
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1167
        if (at_log_file) {
          {
#line 1167
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Could not fit spline to left curve (%lx).\n",
                  (unsigned long )left_curve);
          }
        }
#line 1167
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 1169
      at_exception_warning(exception, (at_string const   )"Could not fit left spline list");
      }
    } else {
      {
#line 1173
      concat_spline_lists(spline_list, *left_spline_list);
#line 1174
      free_spline_list(*left_spline_list);
#line 1175
      free((void *)left_spline_list);
      }
    }
#line 1178
    if ((unsigned long )right_spline_list == (unsigned long )((void *)0)) {
      {
#line 1180
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1180
        if (at_log_file) {
          {
#line 1180
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"Could not fit spline to right curve (%lx).\n",
                  (unsigned long )right_curve);
          }
        }
#line 1180
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 1182
      at_exception_warning(exception, (at_string const   )"Could not fit right spline list");
      }
    } else {
      {
#line 1186
      concat_spline_lists(spline_list, *right_spline_list);
#line 1187
      free_spline_list(*right_spline_list);
#line 1188
      free((void *)right_spline_list);
      }
    }
#line 1190
    if (left_curve->end_tangent) {
      {
#line 1191
      free((void *)left_curve->end_tangent);
      }
    }
    {
#line 1192
    free((void *)left_curve);
#line 1193
    free((void *)right_curve);
    }
  }
  cleanup: 
#line 1196
  return (spline_list);
}
}
#line 1219 "fit.c"
static spline_type fit_one_spline(curve_type curve , at_exception_type *exception ) 
{ 
  at_real X_C1_det ;
  at_real C0_X_det ;
  at_real C0_C1_det ;
  at_real alpha1 ;
  at_real alpha2 ;
  spline_type spline ;
  vector_type start_vector ;
  vector_type end_vector ;
  unsigned int i ;
  vector_type *A ;
  vector_type t1_hat ;
  vector_type t2_hat ;
  at_real C[2][2] ;
  at_real X[2] ;
  void *tmp ;
  vector_type temp ;
  vector_type temp0 ;
  vector_type temp1 ;
  vector_type temp2 ;
  vector_type temp3 ;
  vector_type *Ai ;
  at_real tmp___1 ;
  at_real tmp___2 ;
  at_real tmp___3 ;
  vector_type tmp___4 ;
  vector_type tmp___5 ;
  vector_type tmp___6 ;
  at_real_coord tmp___7 ;
  at_real tmp___8 ;
  at_real tmp___9 ;
  vector_type tmp___10 ;
  vector_type tmp___11 ;

  {
#line 1231
  t1_hat = *(curve->start_tangent);
#line 1232
  t2_hat = *(curve->end_tangent);
#line 1233
  C[0][0] = (at_real )0.0;
#line 1233
  C[0][1] = (at_real )0.0;
#line 1233
  C[1][0] = (at_real )0.0;
#line 1233
  C[1][1] = (at_real )0.0;
#line 1234
  X[0] = (at_real )0.0;
#line 1234
  X[1] = (at_real )0.0;
  {
#line 1236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1236
    tmp = malloc((unsigned long )(curve->length * 2U) * sizeof(vector_type ));
#line 1236
    A = (vector_type *)tmp;
    }
#line 1236
    if (! A) {
      {
#line 1236
      __assert_fail("A", "fit.c", 1237U, "fit_one_spline");
      }
    }
#line 1236
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1239
  spline.v[0] = (curve->point_list + 0)->coord;
#line 1240
  spline.v[3] = (curve->point_list + (curve->length - 1U))->coord;
#line 1241
  start_vector = make_vector((at_real_coord const   )spline.v[0]);
#line 1242
  end_vector = make_vector((at_real_coord const   )spline.v[3]);
#line 1244
  i = 0U;
  }
  {
#line 1244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1244
    if (! (i < curve->length)) {
#line 1244
      goto while_break___0;
    }
    {
#line 1246
    *(A + (i << 1)) = Vmult_scalar((vector_type const   )t1_hat, (at_real const   )(((at_real )3.0 * (curve->point_list + i)->t) * (((at_real )1.0 - (curve->point_list + i)->t) * ((at_real )1.0 - (curve->point_list + i)->t))));
#line 1247
    *(A + ((i << 1) + 1U)) = Vmult_scalar((vector_type const   )t2_hat, (at_real const   )(((at_real )3.0 * ((curve->point_list + i)->t * (curve->point_list + i)->t)) * ((at_real )1.0 - (curve->point_list + i)->t)));
#line 1244
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1250
  i = 0U;
  {
#line 1250
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1250
    if (! (i < curve->length)) {
#line 1250
      goto while_break___1;
    }
    {
#line 1253
    Ai = A + (i << 1);
#line 1255
    tmp___1 = Vdot((vector_type const   )*(Ai + 0), (vector_type const   )*(Ai + 0));
#line 1255
    C[0][0] += tmp___1;
#line 1256
    tmp___2 = Vdot((vector_type const   )*(Ai + 0), (vector_type const   )*(Ai + 1));
#line 1256
    C[0][1] += tmp___2;
#line 1258
    tmp___3 = Vdot((vector_type const   )*(Ai + 1), (vector_type const   )*(Ai + 1));
#line 1258
    C[1][1] += tmp___3;
#line 1262
    temp0 = Vmult_scalar((vector_type const   )start_vector, (at_real const   )((((at_real )1.0 - (curve->point_list + i)->t) * ((at_real )1.0 - (curve->point_list + i)->t)) * ((at_real )1.0 - (curve->point_list + i)->t)));
#line 1263
    temp1 = Vmult_scalar((vector_type const   )start_vector, (at_real const   )(((at_real )3.0 * (curve->point_list + i)->t) * (((at_real )1.0 - (curve->point_list + i)->t) * ((at_real )1.0 - (curve->point_list + i)->t))));
#line 1264
    temp2 = Vmult_scalar((vector_type const   )end_vector, (at_real const   )(((at_real )3.0 * ((curve->point_list + i)->t * (curve->point_list + i)->t)) * ((at_real )1.0 - (curve->point_list + i)->t)));
#line 1265
    temp3 = Vmult_scalar((vector_type const   )end_vector, (at_real const   )(((curve->point_list + i)->t * (curve->point_list + i)->t) * (curve->point_list + i)->t));
#line 1267
    tmp___4 = Vadd((vector_type const   )temp2, (vector_type const   )temp3);
#line 1267
    tmp___5 = Vadd((vector_type const   )temp1, (vector_type const   )tmp___4);
#line 1267
    tmp___6 = Vadd((vector_type const   )temp0, (vector_type const   )tmp___5);
#line 1267
    tmp___7 = Vsubtract_point((at_real_coord const   )(curve->point_list + i)->coord,
                              (vector_type const   )tmp___6);
#line 1267
    temp = make_vector((at_real_coord const   )tmp___7);
#line 1270
    tmp___8 = Vdot((vector_type const   )temp, (vector_type const   )*(Ai + 0));
#line 1270
    X[0] += tmp___8;
#line 1271
    tmp___9 = Vdot((vector_type const   )temp, (vector_type const   )*(Ai + 1));
#line 1271
    X[1] += tmp___9;
#line 1250
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1273
  free((void *)A);
#line 1275
  C[1][0] = C[0][1];
#line 1277
  X_C1_det = X[0] * C[1][1] - X[1] * C[0][1];
#line 1278
  C0_X_det = C[0][0] * X[1] - C[0][1] * X[0];
#line 1279
  C0_C1_det = C[0][0] * C[1][1] - C[1][0] * C[0][1];
  }
#line 1280
  if ((double )C0_C1_det == 0.0) {
    {
#line 1282
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1282
      if (at_log_file) {
        {
#line 1282
        fputs((char const   */* __restrict  */)"zero determinant of C0*C1", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 1282
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1283
    at_exception_fatal(exception, (at_string const   )"zero determinant of C0*C1");
    }
#line 1284
    goto cleanup;
  }
  {
#line 1287
  alpha1 = X_C1_det / C0_C1_det;
#line 1288
  alpha2 = C0_X_det / C0_C1_det;
#line 1290
  tmp___10 = Vmult_scalar((vector_type const   )t1_hat, (at_real const   )alpha1);
#line 1290
  spline.v[1] = Vadd_point((at_real_coord const   )spline.v[0], (vector_type const   )tmp___10);
#line 1292
  tmp___11 = Vmult_scalar((vector_type const   )t2_hat, (at_real const   )alpha2);
#line 1292
  spline.v[2] = Vadd_point((at_real_coord const   )spline.v[3], (vector_type const   )tmp___11);
#line 1294
  spline.degree = (at_polynomial_degree )3;
  }
  cleanup: 
#line 1297
  return (spline);
}
}
#line 1306 "fit.c"
static void set_initial_parameter_values(curve_type curve ) 
{ 
  unsigned int p ;
  at_real_coord point ;
  at_real_coord previous_p ;
  at_real d ;
  at_real tmp ;

  {
  {
#line 1311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1311
    if (at_log_file) {
      {
#line 1311
      fputs((char const   */* __restrict  */)"\nAssigning initial t values:\n  ",
            (FILE */* __restrict  */)at_log_file);
      }
    }
#line 1311
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1313
  (curve->point_list + 0)->t = (at_real )0.0;
#line 1315
  p = 1U;
  {
#line 1315
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1315
    if (! (p < curve->length)) {
#line 1315
      goto while_break___0;
    }
    {
#line 1317
    point = (curve->point_list + p)->coord;
#line 1317
    previous_p = (curve->point_list + (p - 1U))->coord;
#line 1319
    tmp = distance(point, previous_p);
#line 1319
    d = tmp;
#line 1320
    (curve->point_list + p)->t = (curve->point_list + (p - 1U))->t + d;
#line 1315
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1323
  if (! ((double )(curve->point_list + (curve->length - 1U))->t != 0.0)) {
    {
#line 1323
    __assert_fail("LAST_CURVE_T (curve) != 0.0", "fit.c", 1323U, "set_initial_parameter_values");
    }
  }
#line 1325
  p = 1U;
  {
#line 1325
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1325
    if (! (p < curve->length)) {
#line 1325
      goto while_break___1;
    }
#line 1326
    (curve->point_list + p)->t /= (curve->point_list + (curve->length - 1U))->t;
#line 1325
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1328
  log_entire_curve(curve);
  }
#line 1329
  return;
}
}
#line 1340 "fit.c"
static void find_tangent(curve_type curve , at_bool to_start_point , at_bool cross_curve ,
                         unsigned int tangent_surround ) 
{ 
  vector_type tangent ;
  vector_type **curve_tangent ;
  vector_type **tmp ;
  unsigned int n_points ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  curve_type adjacent_curve ;
  struct curve *tmp___3 ;
  vector_type tangent2 ;
  vector_type tmp___4 ;
  vector_type tmp___5 ;
  vector_type tmp___6 ;

  {
#line 1345
  if ((unsigned int )to_start_point == 1U) {
#line 1345
    tmp = & curve->start_tangent;
  } else {
#line 1345
    tmp = & curve->end_tangent;
  }
#line 1345
  curve_tangent = tmp;
#line 1347
  n_points = 0U;
  {
#line 1349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1349
    if (at_log_file) {
#line 1349
      if ((unsigned int )to_start_point == 1U) {
#line 1349
        tmp___0 = "start";
      } else {
#line 1349
        tmp___0 = "end";
      }
      {
#line 1349
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  tangent to %s: ",
              tmp___0);
      }
    }
#line 1349
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1351
  if ((unsigned long )*curve_tangent == (unsigned long )((void *)0)) {
    {
#line 1353
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1353
      tmp___1 = malloc(sizeof(vector_type ));
#line 1353
      *curve_tangent = (vector_type *)tmp___1;
      }
#line 1353
      if (! *curve_tangent) {
        {
#line 1353
        __assert_fail("*curve_tangent", "fit.c", 1353U, "find_tangent");
        }
      }
#line 1353
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1354
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1356
      tangent = find_half_tangent(curve, to_start_point, & n_points, tangent_surround);
      }
#line 1359
      if ((unsigned int )cross_curve == 1U) {
#line 1359
        goto _L;
      } else
#line 1359
      if ((unsigned int )curve->cyclic == 1U) {
        _L: /* CIL Label */ 
#line 1361
        if ((unsigned int )to_start_point == 1U) {
#line 1361
          tmp___3 = curve->previous;
        } else {
#line 1361
          tmp___3 = curve->next;
        }
#line 1361
        adjacent_curve = tmp___3;
#line 1363
        if ((unsigned int )to_start_point == 0U) {
          {
#line 1363
          tmp___4 = find_half_tangent(adjacent_curve, (at_bool )1, & n_points, tangent_surround);
#line 1363
          tmp___6 = tmp___4;
          }
        } else {
          {
#line 1363
          tmp___5 = find_half_tangent(adjacent_curve, (at_bool )1, & n_points, tangent_surround);
#line 1363
          tmp___6 = tmp___5;
          }
        }
#line 1363
        tangent2 = tmp___6;
        {
#line 1368
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1368
          if (at_log_file) {
            {
#line 1368
            fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"(adjacent curve half tangent (%.3f,%.3f,%.3f)) ",
                    (double )tangent2.dx, (double )tangent2.dy, (double )tangent2.dz);
            }
          }
#line 1368
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1370
        tangent = Vadd((vector_type const   )tangent, (vector_type const   )tangent2);
        }
      }
#line 1372
      tangent_surround --;
#line 1354
      if ((double )tangent.dx == 0.0) {
#line 1354
        if (! ((double )tangent.dy == 0.0)) {
#line 1354
          goto while_break___1;
        }
      } else {
#line 1354
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1377
    if (! (n_points > 0U)) {
      {
#line 1377
      __assert_fail("n_points > 0", "fit.c", 1377U, "find_tangent");
      }
    }
    {
#line 1378
    *(*curve_tangent) = Vmult_scalar((vector_type const   )tangent, (at_real const   )((at_real )(1.0 / (double )n_points)));
    }
#line 1379
    if ((unsigned int )curve->cyclic == 1U) {
#line 1379
      if (curve->start_tangent) {
#line 1380
        *(curve->start_tangent) = *(*curve_tangent);
      }
    }
#line 1381
    if ((unsigned int )curve->cyclic == 1U) {
#line 1381
      if (curve->end_tangent) {
#line 1382
        *(curve->end_tangent) = *(*curve_tangent);
      }
    }
  } else {
    {
#line 1385
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1385
      if (at_log_file) {
        {
#line 1385
        fputs((char const   */* __restrict  */)"(already computed) ", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 1385
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 1387
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1387
    if (at_log_file) {
      {
#line 1387
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"(%.3f,%.3f,%.3f).\n",
              (double )(*curve_tangent)->dx, (double )(*curve_tangent)->dy, (double )(*curve_tangent)->dz);
      }
    }
#line 1387
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1388
  return;
}
}
#line 1394 "fit.c"
static vector_type find_half_tangent(curve_type c , at_bool to_start_point , unsigned int *n_points ,
                                     unsigned int tangent_surround ) 
{ 
  unsigned int p ;
  int factor ;
  int tmp ;
  unsigned int tangent_index ;
  unsigned int tmp___0 ;
  at_real_coord tangent_point ;
  vector_type tangent ;
  unsigned int surround ;
  int this_index ;
  at_real_coord this_point ;
  vector_type tmp___1 ;
  vector_type tmp___2 ;

  {
#line 1399
  if (to_start_point) {
#line 1399
    tmp = 1;
  } else {
#line 1399
    tmp = -1;
  }
#line 1399
  factor = tmp;
#line 1400
  if (to_start_point) {
#line 1400
    tmp___0 = 0U;
  } else {
#line 1400
    tmp___0 = c->length - 1U;
  }
#line 1400
  tangent_index = tmp___0;
#line 1401
  tangent_point = (c->point_list + tangent_index)->coord;
#line 1402
  tangent.dx = (at_real )0.0;
#line 1402
  tangent.dy = (at_real )0.0;
#line 1402
  tangent.dz = 0.f;
#line 1405
  surround = c->length / 2U;
#line 1405
  if (surround > tangent_surround) {
#line 1406
    surround = tangent_surround;
  }
#line 1408
  p = 1U;
  {
#line 1408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1408
    if (! (p <= surround)) {
#line 1408
      goto while_break;
    }
#line 1410
    this_index = (int )(p * (unsigned int )factor + tangent_index);
#line 1413
    if (this_index < 0) {
#line 1414
      goto while_break;
    } else
#line 1413
    if (this_index >= (int )c->length) {
#line 1414
      goto while_break;
    }
    {
#line 1416
    this_point = (c->point_list + (p * (unsigned int )factor + tangent_index))->coord;
#line 1420
    tmp___1 = Psubtract((at_real_coord const   )this_point, (at_real_coord const   )tangent_point);
#line 1420
    tmp___2 = Vmult_scalar((vector_type const   )tmp___1, (at_real const   )((at_real )factor));
#line 1420
    tangent = Vadd((vector_type const   )tangent, (vector_type const   )tmp___2);
#line 1423
    (*n_points) ++;
#line 1408
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1426
  return (tangent);
}
}
#line 1437 "fit.c"
static at_real find_error(curve_type curve , spline_type spline , unsigned int *worst_point ,
                          at_exception_type *exception ) 
{ 
  unsigned int this_point ;
  at_real total_error ;
  at_real worst_error ;
  at_real_coord curve_point ;
  at_real t ;
  at_real_coord spline_point ;
  at_real_coord tmp ;
  at_real this_error ;
  at_real tmp___0 ;
  at_bool tmp___1 ;
  at_bool tmp___2 ;

  {
#line 1442
  total_error = (at_real )0.0;
#line 1443
  worst_error = 1.17549435082228750797e-38F;
#line 1445
  *worst_point = curve->length + 1U;
#line 1447
  this_point = 0U;
  {
#line 1447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1447
    if (! (this_point < curve->length)) {
#line 1447
      goto while_break;
    }
    {
#line 1449
    curve_point = (curve->point_list + this_point)->coord;
#line 1450
    t = (curve->point_list + this_point)->t;
#line 1451
    tmp = evaluate_spline(spline, t);
#line 1451
    spline_point = tmp;
#line 1452
    tmp___0 = distance(curve_point, spline_point);
#line 1452
    this_error = tmp___0;
    }
#line 1453
    if (this_error >= worst_error) {
#line 1455
      *worst_point = this_point;
#line 1456
      worst_error = this_error;
    }
#line 1458
    total_error += this_error;
#line 1447
    this_point ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1461
  if (*worst_point == curve->length + 1U) {
    {
#line 1463
    tmp___1 = epsilon_equal(total_error, (at_real )0.0);
    }
#line 1463
    if (tmp___1) {
      {
#line 1464
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1464
        if (at_log_file) {
          {
#line 1464
          fputs((char const   */* __restrict  */)"  Every point fit perfectly.\n",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 1464
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 1467
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1467
        if (at_log_file) {
          {
#line 1467
          fputs((char const   */* __restrict  */)"No worst point found; something is wrong",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 1467
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1468
      at_exception_warning(exception, (at_string const   )"No worst point found; something is wrong");
      }
    }
  } else {
    {
#line 1473
    tmp___2 = epsilon_equal(total_error, (at_real )0.0);
    }
#line 1473
    if (tmp___2) {
      {
#line 1474
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1474
        if (at_log_file) {
          {
#line 1474
          fputs((char const   */* __restrict  */)"  Every point fit perfectly.\n",
                (FILE */* __restrict  */)at_log_file);
          }
        }
#line 1474
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 1477
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1477
        if (at_log_file) {
          {
#line 1477
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  Worst error (at (%.3f,%.3f,%.3f), point #%u) was %.3f.\n",
                  (double )(curve->point_list + *worst_point)->coord.x, (double )(curve->point_list + *worst_point)->coord.y,
                  (double )(curve->point_list + *worst_point)->coord.z, *worst_point,
                  (double )worst_error);
          }
        }
#line 1477
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1481
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1481
        if (at_log_file) {
          {
#line 1481
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  Total error was %.3f.\n",
                  (double )total_error);
          }
        }
#line 1481
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1482
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1482
        if (at_log_file) {
          {
#line 1482
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  Average error (over %u points) was %.3f.\n",
                  curve->length, (double )(total_error / (at_real )curve->length));
          }
        }
#line 1482
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 1487
  return (worst_error);
}
}
#line 1493 "fit.c"
static at_bool spline_linear_enough(spline_type *spline , curve_type curve , fitting_opts_type *fitting_opts ) 
{ 
  at_real A ;
  at_real B ;
  at_real C ;
  unsigned int this_point ;
  at_real dist ;
  at_real start_end_dist ;
  at_real threshold ;
  double tmp ;
  at_real a ;
  at_real b ;
  at_real c ;
  at_real w ;
  at_real t ;
  at_real_coord spline_point ;
  at_real_coord tmp___0 ;
  double tmp___1 ;

  {
#line 1499
  dist = (at_real )0.0;
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1501
    if (at_log_file) {
      {
#line 1501
      fputs((char const   */* __restrict  */)"Checking linearity:\n", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 1501
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1503
  A = spline->v[3].x - spline->v[0].x;
#line 1504
  B = spline->v[3].y - spline->v[0].y;
#line 1505
  C = spline->v[3].z - spline->v[0].z;
#line 1507
  start_end_dist = (A * A + B * B) + C * C;
  {
#line 1508
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1508
    if (at_log_file) {
      {
#line 1508
      tmp = sqrt((double )start_end_dist);
#line 1508
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"start_end_distance is %.3f.\n",
              tmp);
      }
    }
#line 1508
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1510
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1510
    if (at_log_file) {
      {
#line 1510
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  Line endpoints are (%.3f, %.3f, %.3f) and ",
              (double )spline->v[0].x, (double )spline->v[0].y, (double )spline->v[0].z);
      }
    }
#line 1510
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1511
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1511
    if (at_log_file) {
      {
#line 1511
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"(%.3f, %.3f, %.3f)\n",
              (double )spline->v[3].x, (double )spline->v[3].y, (double )spline->v[3].z);
      }
    }
#line 1511
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1515
  this_point = 0U;
  {
#line 1515
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1515
    if (! (this_point < curve->length)) {
#line 1515
      goto while_break___3;
    }
    {
#line 1518
    t = (curve->point_list + this_point)->t;
#line 1519
    tmp___0 = evaluate_spline(*spline, t);
#line 1519
    spline_point = tmp___0;
#line 1521
    a = spline_point.x - spline->v[0].x;
#line 1522
    b = spline_point.y - spline->v[0].y;
#line 1523
    c = spline_point.z - spline->v[0].z;
#line 1524
    w = ((A * a + B * b) + C * c) / start_end_dist;
#line 1526
    tmp___1 = sqrt((double )(((a - A * w) * (a - A * w) + (b - B * w) * (b - B * w)) + (c - C * w) * (c - C * w)));
#line 1526
    dist += (at_real )tmp___1;
#line 1515
    this_point ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1528
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1528
    if (at_log_file) {
      {
#line 1528
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  Total distance is %.3f, ",
              (double )dist);
      }
    }
#line 1528
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1530
  dist /= (at_real )(curve->length - 1U);
  {
#line 1531
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1531
    if (at_log_file) {
      {
#line 1531
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"which is %.3f normalized.\n",
              (double )dist);
      }
    }
#line 1531
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1536
  spline->linearity = dist;
  {
#line 1537
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1537
    if (at_log_file) {
      {
#line 1537
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  Final linearity: %.3f.\n",
              (double )spline->linearity);
      }
    }
#line 1537
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1538
  if (start_end_dist * (at_real )0.5 > fitting_opts->line_threshold) {
#line 1539
    threshold = fitting_opts->line_threshold;
  } else {
#line 1541
    threshold = start_end_dist * (at_real )0.5;
  }
  {
#line 1542
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1542
    if (at_log_file) {
      {
#line 1542
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"threshold is %.3f .\n",
              (double )threshold);
      }
    }
#line 1542
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1543
  if (dist < threshold) {
#line 1544
    return ((at_bool )1);
  } else {
#line 1546
    return ((at_bool )0);
  }
}
}
#line 1557 "fit.c"
static void change_bad_lines(spline_list_type *spline_list , fitting_opts_type *fitting_opts ) 
{ 
  unsigned int this_spline ;
  at_bool found_cubic ;
  unsigned int length ;
  spline_type s ;

  {
#line 1562
  found_cubic = (at_bool )0;
#line 1563
  length = spline_list->length;
  {
#line 1565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1565
    if (at_log_file) {
      {
#line 1565
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"\nChecking for bad lines (length %u):\n",
              length);
      }
    }
#line 1565
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1568
  this_spline = 0U;
  {
#line 1568
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1568
    if (! (this_spline < length)) {
#line 1568
      goto while_break___0;
    }
#line 1570
    if ((unsigned int )(spline_list->data + this_spline)->degree == 3U) {
#line 1573
      found_cubic = (at_bool )1;
#line 1574
      goto while_break___0;
    }
#line 1568
    this_spline ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1581
  if (found_cubic) {
#line 1582
    this_spline = 0U;
    {
#line 1582
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1582
      if (! (this_spline < length)) {
#line 1582
        goto while_break___1;
      }
#line 1584
      s = *(spline_list->data + this_spline);
#line 1586
      if ((unsigned int )s.degree == 1U) {
        {
#line 1588
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1588
          if (at_log_file) {
            {
#line 1588
            fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  #%u: ",
                    this_spline);
            }
          }
#line 1588
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1589
        if (s.linearity > fitting_opts->line_reversion_threshold) {
          {
#line 1591
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1591
            if (at_log_file) {
              {
#line 1591
              fputs((char const   */* __restrict  */)"reverted, ", (FILE */* __restrict  */)at_log_file);
              }
            }
#line 1591
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1592
          (spline_list->data + this_spline)->degree = (at_polynomial_degree )3;
        }
        {
#line 1595
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1595
          if (at_log_file) {
            {
#line 1595
            fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"linearity %.3f.\n",
                    (double )s.linearity);
            }
          }
#line 1595
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 1582
      this_spline ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1599
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1599
      if (at_log_file) {
        {
#line 1599
        fputs((char const   */* __restrict  */)"  No lines.\n", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 1599
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1600
  return;
}
}
#line 1604 "fit.c"
static index_list_type new_index_list(void) 
{ 
  index_list_type index_list ;

  {
#line 1609
  index_list.data = (unsigned int *)((void *)0);
#line 1610
  index_list.length = 0U;
#line 1612
  return (index_list);
}
}
#line 1615 "fit.c"
static void free_index_list(index_list_type *index_list ) 
{ 


  {
#line 1618
  if (index_list->length > 0U) {
    {
#line 1620
    free((void *)index_list->data);
#line 1621
    index_list->data = (unsigned int *)((void *)0);
#line 1622
    index_list->length = 0U;
    }
  }
#line 1624
  return;
}
}
#line 1626 "fit.c"
static void append_index(index_list_type *list , unsigned int new_index ) 
{ 
  at_address new_mem ;
  void *tmp ;
  void *tmp___1 ;

  {
#line 1629
  (list->length) ++;
  {
#line 1630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1630
    if ((unsigned long )list->data == (unsigned long )((void *)0)) {
      {
#line 1630
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1630
        tmp = malloc((unsigned long )list->length * sizeof(unsigned int ));
#line 1630
        new_mem = tmp;
        }
#line 1630
        if (! new_mem) {
          {
#line 1630
          __assert_fail("new_mem", "fit.c", 1630U, "append_index");
          }
        }
#line 1630
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 1630
      tmp___1 = realloc((void *)list->data, (unsigned long )list->length * sizeof(unsigned int ));
#line 1630
      new_mem = tmp___1;
      }
#line 1630
      if (! new_mem) {
        {
#line 1630
        __assert_fail("new_mem", "fit.c", 1630U, "append_index");
        }
      }
    }
#line 1630
    list->data = (unsigned int *)new_mem;
#line 1630
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1631
  *(list->data + (list->length - 1U)) = new_index;
#line 1632
  return;
}
}
#line 1636 "fit.c"
static at_coord real_to_int_coord(at_real_coord real_coord ) 
{ 
  at_coord int_coord ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1641
  if (real_coord.x > (at_real )0) {
#line 1641
    tmp___0 = 1;
  } else {
#line 1641
    if (real_coord.x < (at_real )0) {
#line 1641
      tmp = -1;
    } else {
#line 1641
      tmp = 0;
    }
#line 1641
    tmp___0 = tmp;
  }
#line 1641
  int_coord.x = (unsigned short )((double )((unsigned short )real_coord.x) + .5 * (double )tmp___0);
#line 1642
  if (real_coord.y > (at_real )0) {
#line 1642
    tmp___2 = 1;
  } else {
#line 1642
    if (real_coord.y < (at_real )0) {
#line 1642
      tmp___1 = -1;
    } else {
#line 1642
      tmp___1 = 0;
    }
#line 1642
    tmp___2 = tmp___1;
  }
#line 1642
  int_coord.y = (unsigned short )((double )((unsigned short )real_coord.y) + .5 * (double )tmp___2);
#line 1644
  return (int_coord);
}
}
#line 1649 "fit.c"
static at_real distance(at_real_coord p1 , at_real_coord p2 ) 
{ 
  at_real x ;
  at_real y ;
  at_real z ;
  double tmp ;

  {
  {
#line 1652
  x = p1.x - p2.x;
#line 1652
  y = p1.y - p2.y;
#line 1652
  z = p1.z - p2.z;
#line 1653
  tmp = sqrt((double )((x * x + y * y) + z * z));
  }
#line 1653
  return ((at_real )tmp);
}
}
#line 37 "filename.h"
at_string make_suffix(at_string s , at_string new_suffix ) ;
#line 33 "filename.c"
static at_string substring(at_string source , unsigned int const   start , unsigned int const   limit ) ;
#line 36
static at_string concat3(at_string s1 , at_string s2 , at_string s3 ) ;
#line 38 "filename.c"
at_string find_suffix(at_string name ) 
{ 
  at_string dot_pos ;
  char *tmp ;
  at_string slash_pos ;
  char *tmp___0 ;
  at_string tmp___1 ;

  {
  {
#line 41
  tmp = strrchr((char const   *)name, '.');
#line 41
  dot_pos = tmp;
#line 45
  tmp___0 = strrchr((char const   *)name, '/');
#line 45
  slash_pos = tmp___0;
  }
#line 49
  if ((unsigned long )dot_pos == (unsigned long )((void *)0)) {
#line 49
    tmp___1 = (at_string )((void *)0);
  } else
#line 49
  if ((unsigned long )dot_pos < (unsigned long )slash_pos) {
#line 49
    tmp___1 = (at_string )((void *)0);
  } else {
#line 49
    tmp___1 = dot_pos + 1;
  }
#line 49
  return (tmp___1);
}
}
#line 55 "filename.c"
at_string extend_filename(at_string name , at_string default_suffix ) 
{ 
  at_string new_s ;
  at_string suffix ;
  at_string tmp ;
  at_string tmp___0 ;

  {
  {
#line 59
  tmp = find_suffix(name);
#line 59
  suffix = tmp;
  }
#line 61
  if ((unsigned long )suffix == (unsigned long )((void *)0)) {
    {
#line 61
    tmp___0 = concat3(name, (at_string )".", default_suffix);
#line 61
    new_s = tmp___0;
    }
  } else {
#line 61
    new_s = name;
  }
#line 63
  return (new_s);
}
}
#line 66 "filename.c"
at_string make_suffix(at_string s , at_string new_suffix ) 
{ 
  at_string new_s ;
  at_string old_suffix ;
  at_string tmp ;
  size_t length_through_dot ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 70
  tmp = find_suffix(s);
#line 70
  old_suffix = tmp;
  }
#line 72
  if ((unsigned long )old_suffix == (unsigned long )((void *)0)) {
    {
#line 73
    new_s = concat3(s, (at_string )".", new_suffix);
    }
  } else {
#line 76
    length_through_dot = (size_t )(old_suffix - s);
    {
#line 78
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 78
      tmp___0 = strlen((char const   *)new_suffix);
#line 78
      tmp___1 = malloc((length_through_dot + tmp___0) + 1UL);
#line 78
      new_s = (at_string )tmp___1;
      }
#line 78
      if (! new_s) {
        {
#line 78
        __assert_fail("new_s", "filename.c", 78U, "make_suffix");
        }
      }
#line 78
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 79
    strncpy((char */* __restrict  */)new_s, (char const   */* __restrict  */)s, length_through_dot);
#line 80
    strcpy((char */* __restrict  */)(new_s + length_through_dot), (char const   */* __restrict  */)new_suffix);
    }
  }
#line 83
  return (new_s);
}
}
#line 86 "filename.c"
at_string remove_suffix(at_string s ) 
{ 
  at_string suffix ;
  at_string tmp ;
  at_string tmp___0 ;
  at_string tmp___1 ;
  at_string tmp___2 ;

  {
  {
#line 89
  tmp = find_suffix(s);
#line 89
  suffix = tmp;
  }
#line 91
  if ((unsigned long )suffix == (unsigned long )((void *)0)) {
#line 91
    tmp___2 = s;
  } else {
#line 91
    if ((suffix - 2) - s < 0L) {
#line 91
      tmp___1 = (at_string )((void *)0);
    } else {
      {
#line 91
      tmp___0 = substring(s, (unsigned int const   )0, (unsigned int const   )((unsigned int )((suffix - 2) - s)));
#line 91
      tmp___1 = tmp___0;
      }
    }
#line 91
    tmp___2 = tmp___1;
  }
#line 91
  return (tmp___2);
}
}
#line 95 "filename.c"
static at_string substring(at_string source , unsigned int const   start , unsigned int const   limit ) 
{ 
  at_string result ;
  unsigned int this_char ;
  size_t length ;
  size_t tmp ;
  size_t lim ;
  void *tmp___0 ;

  {
  {
#line 100
  tmp = strlen((char const   *)source);
#line 100
  length = tmp;
#line 101
  lim = (size_t )limit;
  }
#line 104
  if (lim >= length) {
#line 105
    lim = length - 1UL;
  }
#line 108
  if ((size_t )start > lim) {
#line 109
    return ((at_string )"");
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 112
    tmp___0 = malloc((lim - (size_t )start) + 2UL);
#line 112
    result = (at_string )tmp___0;
    }
#line 112
    if (! result) {
      {
#line 112
      __assert_fail("result", "filename.c", 112U, "substring");
      }
    }
#line 112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  this_char = (unsigned int )start;
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 114
    if (! ((size_t )this_char <= lim)) {
#line 114
      goto while_break___0;
    }
#line 115
    *(result + (this_char - (unsigned int )start)) = *(source + this_char);
#line 114
    this_char ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 117
  *(result + (this_char - (unsigned int )start)) = (char)0;
#line 119
  return (result);
}
}
#line 122 "filename.c"
static at_string concat3(at_string s1 , at_string s2 , at_string s3 ) 
{ 
  at_string answer ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 126
    tmp = strlen((char const   *)s1);
#line 126
    tmp___0 = strlen((char const   *)s2);
#line 126
    tmp___1 = strlen((char const   *)s3);
#line 126
    tmp___2 = malloc(((tmp + tmp___0) + tmp___1) + 1UL);
#line 126
    answer = (at_string )tmp___2;
    }
#line 126
    if (! answer) {
      {
#line 126
      __assert_fail("answer", "filename.c", 126U, "concat3");
      }
    }
#line 126
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  strcpy((char */* __restrict  */)answer, (char const   */* __restrict  */)s1);
#line 128
  strcat((char */* __restrict  */)answer, (char const   */* __restrict  */)s2);
#line 129
  strcat((char */* __restrict  */)answer, (char const   */* __restrict  */)s3);
  }
#line 131
  return (answer);
}
}
#line 7 "exception.c"
at_exception_type at_exception_new(void (*client_func)(at_string msg , at_msg_type msg_type ,
                                                       at_address client_data ) ,
                                   at_address client_data ) 
{ 
  at_exception_type e ;

  {
#line 11
  e.msg_type = (at_msg_type )0;
#line 11
  e.client_func = client_func;
#line 11
  e.client_data = (at_address *)client_data;
#line 12
  return (e);
}
}
#line 15 "exception.c"
at_bool at_exception_got_fatal(at_exception_type *exception ) 
{ 


  {
#line 18
  return ((at_bool )((unsigned int )exception->msg_type == 1U));
}
}
#line 21 "exception.c"
void at_exception_fatal(at_exception_type *exception , at_string const   message ) 
{ 


  {
#line 25
  if (! exception) {
#line 26
    return;
  }
#line 27
  exception->msg_type = (at_msg_type )1;
#line 28
  if (exception->client_func) {
    {
#line 30
    (*(exception->client_func))((at_string )message, (at_msg_type )1, (at_address )exception->client_data);
    }
  }
#line 34
  return;
}
}
#line 36 "exception.c"
void at_exception_warning(at_exception_type *exception , at_string const   message ) 
{ 


  {
#line 40
  if (! exception) {
#line 41
    return;
  }
#line 42
  exception->msg_type = (at_msg_type )2;
#line 43
  if (exception->client_func) {
    {
#line 45
    (*(exception->client_func))((at_string )message, (at_msg_type )2, (at_address )exception->client_data);
    }
  }
#line 49
  return;
}
}
#line 15 "epsilon-equal.c"
at_bool epsilon_equal(at_real v1 , at_real v2 ) 
{ 
  double tmp ;

  {
#line 18
  if (v1 == v2) {
#line 20
    return ((at_bool )1);
  } else {
    {
#line 18
    tmp = fabs((double )(v1 - v2));
    }
#line 18
    if (tmp <= 0.00001) {
#line 20
      return ((at_bool )1);
    } else {
#line 22
      return ((at_bool )0);
    }
  }
}
}
#line 45 "despeckle.h"
void despeckle(bitmap_type *bitmap , int level , at_real tightness , at_exception_type *excep ) ;
#line 42 "despeckle.c"
static int calc_error(unsigned char *color1 , unsigned char *color2 ) 
{ 
  int the_error ;
  int temp ;

  {
#line 49
  temp = (int )*(color1 + 0) - (int )*(color2 + 0);
#line 50
  the_error = temp * temp;
#line 51
  temp = (int )*(color1 + 1) - (int )*(color2 + 1);
#line 52
  the_error += temp * temp;
#line 53
  temp = (int )*(color1 + 2) - (int )*(color2 + 2);
#line 54
  the_error += temp * temp;
#line 56
  return (the_error);
}
}
#line 69 "despeckle.c"
static int calc_error_8(unsigned char *color1 , unsigned char *color2 ) 
{ 
  int the_error ;
  int temp ;

  {
#line 76
  temp = (int )*(color1 + 0) - (int )*(color2 + 0);
#line 77
  the_error = temp * temp;
#line 79
  return (the_error);
}
}
#line 96 "despeckle.c"
static int find_size(unsigned char *index___0 , int x , int y , int width , int height ,
                     unsigned char *bitmap , unsigned char *mask ) 
{ 
  int count ;
  int x1 ;
  int x2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 108
  if (y < 0) {
#line 113
    return (0);
  } else
#line 108
  if (y >= height) {
#line 113
    return (0);
  } else
#line 108
  if ((int )*(mask + (y * width + x)) == 1) {
#line 113
    return (0);
  } else
#line 108
  if ((int )*(bitmap + 3 * (y * width + x)) != (int )*(index___0 + 0)) {
#line 113
    return (0);
  } else
#line 108
  if ((int )*(bitmap + (3 * (y * width + x) + 1)) != (int )*(index___0 + 1)) {
#line 113
    return (0);
  } else
#line 108
  if ((int )*(bitmap + (3 * (y * width + x) + 2)) != (int )*(index___0 + 2)) {
#line 113
    return (0);
  }
#line 115
  x1 = x;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (x1 >= 0) {
#line 115
      if ((int )*(bitmap + 3 * (y * width + x1)) == (int )*(index___0 + 0)) {
#line 115
        if ((int )*(bitmap + (3 * (y * width + x1) + 1)) == (int )*(index___0 + 1)) {
#line 115
          if ((int )*(bitmap + (3 * (y * width + x1) + 2)) == (int )*(index___0 + 2)) {
#line 115
            if (! ((int )*(mask + (y * width + x)) != 1)) {
#line 115
              goto while_break;
            }
          } else {
#line 115
            goto while_break;
          }
        } else {
#line 115
          goto while_break;
        }
      } else {
#line 115
        goto while_break;
      }
    } else {
#line 115
      goto while_break;
    }
#line 115
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  x1 ++;
#line 122
  x2 = x;
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    if (x2 < width) {
#line 122
      if ((int )*(bitmap + 3 * (y * width + x2)) == (int )*(index___0 + 0)) {
#line 122
        if ((int )*(bitmap + (3 * (y * width + x2) + 1)) == (int )*(index___0 + 1)) {
#line 122
          if ((int )*(bitmap + (3 * (y * width + x2) + 2)) == (int )*(index___0 + 2)) {
#line 122
            if (! ((int )*(mask + (y * width + x)) != 1)) {
#line 122
              goto while_break___0;
            }
          } else {
#line 122
            goto while_break___0;
          }
        } else {
#line 122
          goto while_break___0;
        }
      } else {
#line 122
        goto while_break___0;
      }
    } else {
#line 122
      goto while_break___0;
    }
#line 122
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 127
  x2 --;
#line 129
  count = (x2 - x1) + 1;
#line 130
  x = x1;
  {
#line 130
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 130
    if (! (x <= x2)) {
#line 130
      goto while_break___1;
    }
#line 131
    *(mask + (y * width + x)) = (unsigned char)1;
#line 130
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 133
  x = x1;
  {
#line 133
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 133
    if (! (x <= x2)) {
#line 133
      goto while_break___2;
    }
    {
#line 135
    tmp = find_size(index___0, x, y - 1, width, height, bitmap, mask);
#line 135
    count += tmp;
#line 136
    tmp___0 = find_size(index___0, x, y + 1, width, height, bitmap, mask);
#line 136
    count += tmp___0;
#line 133
    x ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 139
  return (count);
}
}
#line 156 "despeckle.c"
static int find_size_8(unsigned char *index___0 , int x , int y , int width , int height ,
                       unsigned char *bitmap , unsigned char *mask ) 
{ 
  int count ;
  int x1 ;
  int x2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 168
  if (y < 0) {
#line 171
    return (0);
  } else
#line 168
  if (y >= height) {
#line 171
    return (0);
  } else
#line 168
  if ((int )*(mask + (y * width + x)) == 1) {
#line 171
    return (0);
  } else
#line 168
  if ((int )*(bitmap + (y * width + x)) != (int )*(index___0 + 0)) {
#line 171
    return (0);
  }
#line 173
  x1 = x;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (x1 >= 0) {
#line 173
      if ((int )*(bitmap + (y * width + x1)) == (int )*(index___0 + 0)) {
#line 173
        if (! ((int )*(mask + (y * width + x)) != 1)) {
#line 173
          goto while_break;
        }
      } else {
#line 173
        goto while_break;
      }
    } else {
#line 173
      goto while_break;
    }
#line 173
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  x1 ++;
#line 178
  x2 = x;
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (x2 < width) {
#line 178
      if ((int )*(bitmap + (y * width + x2)) == (int )*(index___0 + 0)) {
#line 178
        if (! ((int )*(mask + (y * width + x)) != 1)) {
#line 178
          goto while_break___0;
        }
      } else {
#line 178
        goto while_break___0;
      }
    } else {
#line 178
      goto while_break___0;
    }
#line 178
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 181
  x2 --;
#line 183
  count = (x2 - x1) + 1;
#line 184
  x = x1;
  {
#line 184
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 184
    if (! (x <= x2)) {
#line 184
      goto while_break___1;
    }
#line 185
    *(mask + (y * width + x)) = (unsigned char)1;
#line 184
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 187
  x = x1;
  {
#line 187
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 187
    if (! (x <= x2)) {
#line 187
      goto while_break___2;
    }
    {
#line 189
    tmp = find_size_8(index___0, x, y - 1, width, height, bitmap, mask);
#line 189
    count += tmp;
#line 190
    tmp___0 = find_size_8(index___0, x, y + 1, width, height, bitmap, mask);
#line 190
    count += tmp___0;
#line 187
    x ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 193
  return (count);
}
}
#line 213 "despeckle.c"
static void find_most_similar_neighbor(unsigned char *index___0 , unsigned char **closest_index ,
                                       int *error_amt , int x , int y , int width ,
                                       int height , unsigned char *bitmap , unsigned char *mask ) 
{ 
  int x1 ;
  int x2 ;
  int temp_error ;
  unsigned char *value ;
  unsigned char *temp ;

  {
#line 228
  if (y < 0) {
#line 229
    return;
  } else
#line 228
  if (y >= height) {
#line 229
    return;
  } else
#line 228
  if ((int )*(mask + (y * width + x)) == 2) {
#line 229
    return;
  }
#line 231
  temp = bitmap + 3 * (y * width + x);
#line 233
  if (! ((unsigned long )closest_index != (unsigned long )((void *)0))) {
    {
#line 233
    __assert_fail("closest_index != NULL", "despeckle.c", 233U, "find_most_similar_neighbor");
    }
  }
#line 235
  if ((int )*(temp + 0) != (int )*(index___0 + 0)) {
#line 235
    goto _L;
  } else
#line 235
  if ((int )*(temp + 1) != (int )*(index___0 + 1)) {
#line 235
    goto _L;
  } else
#line 235
  if ((int )*(temp + 2) != (int )*(index___0 + 2)) {
    _L: /* CIL Label */ 
    {
#line 237
    value = temp;
#line 239
    temp_error = calc_error(index___0, value);
    }
#line 241
    if ((unsigned long )*closest_index == (unsigned long )((void *)0)) {
#line 242
      *closest_index = value;
#line 242
      *error_amt = temp_error;
    } else
#line 241
    if (temp_error < *error_amt) {
#line 242
      *closest_index = value;
#line 242
      *error_amt = temp_error;
    }
#line 244
    return;
  }
#line 247
  x1 = x;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (x1 >= 0) {
#line 247
      if ((int )*(bitmap + 3 * (y * width + x1)) == (int )*(index___0 + 0)) {
#line 247
        if ((int )*(bitmap + (3 * (y * width + x1) + 1)) == (int )*(index___0 + 1)) {
#line 247
          if (! ((int )*(bitmap + (3 * (y * width + x1) + 2)) == (int )*(index___0 + 2))) {
#line 247
            goto while_break;
          }
        } else {
#line 247
          goto while_break;
        }
      } else {
#line 247
        goto while_break;
      }
    } else {
#line 247
      goto while_break;
    }
#line 247
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  x1 ++;
#line 253
  x2 = x;
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 253
    if (x2 < width) {
#line 253
      if ((int )*(bitmap + 3 * (y * width + x2)) == (int )*(index___0 + 0)) {
#line 253
        if ((int )*(bitmap + (3 * (y * width + x2) + 1)) == (int )*(index___0 + 1)) {
#line 253
          if (! ((int )*(bitmap + (3 * (y * width + x2) + 2)) == (int )*(index___0 + 2))) {
#line 253
            goto while_break___0;
          }
        } else {
#line 253
          goto while_break___0;
        }
      } else {
#line 253
        goto while_break___0;
      }
    } else {
#line 253
      goto while_break___0;
    }
#line 253
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 257
  x2 --;
#line 259
  if (x1 > 0) {
    {
#line 261
    value = bitmap + 3 * ((y * width + x1) - 1);
#line 263
    temp_error = calc_error(index___0, value);
    }
#line 265
    if ((unsigned long )*closest_index == (unsigned long )((void *)0)) {
#line 266
      *closest_index = value;
#line 266
      *error_amt = temp_error;
    } else
#line 265
    if (temp_error < *error_amt) {
#line 266
      *closest_index = value;
#line 266
      *error_amt = temp_error;
    }
  }
#line 269
  if (x2 < width - 1) {
    {
#line 271
    value = bitmap + 3 * ((y * width + x2) + 1);
#line 273
    temp_error = calc_error(index___0, value);
    }
#line 275
    if ((unsigned long )*closest_index == (unsigned long )((void *)0)) {
#line 276
      *closest_index = value;
#line 276
      *error_amt = temp_error;
    } else
#line 275
    if (temp_error < *error_amt) {
#line 276
      *closest_index = value;
#line 276
      *error_amt = temp_error;
    }
  }
#line 279
  x = x1;
  {
#line 279
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 279
    if (! (x <= x2)) {
#line 279
      goto while_break___1;
    }
#line 280
    *(mask + (y * width + x)) = (unsigned char)2;
#line 279
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 282
  x = x1;
  {
#line 282
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 282
    if (! (x <= x2)) {
#line 282
      goto while_break___2;
    }
    {
#line 284
    find_most_similar_neighbor(index___0, closest_index, error_amt, x, y - 1, width,
                               height, bitmap, mask);
#line 286
    find_most_similar_neighbor(index___0, closest_index, error_amt, x, y + 1, width,
                               height, bitmap, mask);
#line 282
    x ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 289
  return;
}
}
#line 308 "despeckle.c"
static void find_most_similar_neighbor_8(unsigned char *index___0 , unsigned char **closest_index ,
                                         int *error_amt , int x , int y , int width ,
                                         int height , unsigned char *bitmap , unsigned char *mask ) 
{ 
  int x1 ;
  int x2 ;
  int temp_error ;
  unsigned char *value ;
  unsigned char *temp ;

  {
#line 323
  if (y < 0) {
#line 324
    return;
  } else
#line 323
  if (y >= height) {
#line 324
    return;
  } else
#line 323
  if ((int )*(mask + (y * width + x)) == 2) {
#line 324
    return;
  }
#line 326
  temp = bitmap + (y * width + x);
#line 328
  if (! ((unsigned long )closest_index != (unsigned long )((void *)0))) {
    {
#line 328
    __assert_fail("closest_index != NULL", "despeckle.c", 328U, "find_most_similar_neighbor_8");
    }
  }
#line 330
  if ((int )*(temp + 0) != (int )*(index___0 + 0)) {
    {
#line 332
    value = temp;
#line 334
    temp_error = calc_error_8(index___0, value);
    }
#line 336
    if ((unsigned long )*closest_index == (unsigned long )((void *)0)) {
#line 337
      *closest_index = value;
#line 337
      *error_amt = temp_error;
    } else
#line 336
    if (temp_error < *error_amt) {
#line 337
      *closest_index = value;
#line 337
      *error_amt = temp_error;
    }
#line 339
    return;
  }
#line 342
  x1 = x;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (x1 >= 0) {
#line 342
      if (! ((int )*(bitmap + (y * width + x1)) == (int )*(index___0 + 0))) {
#line 342
        goto while_break;
      }
    } else {
#line 342
      goto while_break;
    }
#line 342
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  x1 ++;
#line 346
  x2 = x;
  {
#line 346
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 346
    if (x2 < width) {
#line 346
      if (! ((int )*(bitmap + (y * width + x2)) == (int )*(index___0 + 0))) {
#line 346
        goto while_break___0;
      }
    } else {
#line 346
      goto while_break___0;
    }
#line 346
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 348
  x2 --;
#line 350
  if (x1 > 0) {
    {
#line 352
    value = bitmap + ((y * width + x1) - 1);
#line 354
    temp_error = calc_error_8(index___0, value);
    }
#line 356
    if ((unsigned long )*closest_index == (unsigned long )((void *)0)) {
#line 357
      *closest_index = value;
#line 357
      *error_amt = temp_error;
    } else
#line 356
    if (temp_error < *error_amt) {
#line 357
      *closest_index = value;
#line 357
      *error_amt = temp_error;
    }
  }
#line 360
  if (x2 < width - 1) {
    {
#line 362
    value = bitmap + ((y * width + x2) + 1);
#line 364
    temp_error = calc_error_8(index___0, value);
    }
#line 366
    if ((unsigned long )*closest_index == (unsigned long )((void *)0)) {
#line 367
      *closest_index = value;
#line 367
      *error_amt = temp_error;
    } else
#line 366
    if (temp_error < *error_amt) {
#line 367
      *closest_index = value;
#line 367
      *error_amt = temp_error;
    }
  }
#line 370
  x = x1;
  {
#line 370
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 370
    if (! (x <= x2)) {
#line 370
      goto while_break___1;
    }
#line 371
    *(mask + (y * width + x)) = (unsigned char)2;
#line 370
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 373
  x = x1;
  {
#line 373
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 373
    if (! (x <= x2)) {
#line 373
      goto while_break___2;
    }
    {
#line 375
    find_most_similar_neighbor_8(index___0, closest_index, error_amt, x, y - 1, width,
                                 height, bitmap, mask);
#line 377
    find_most_similar_neighbor_8(index___0, closest_index, error_amt, x, y + 1, width,
                                 height, bitmap, mask);
#line 373
    x ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 392 "despeckle.c"
static void fill(unsigned char *to_index , int x , int y , int width , int height ,
                 unsigned char *bitmap , unsigned char *mask ) 
{ 
  int x1 ;
  int x2 ;

  {
#line 403
  if (y < 0) {
#line 404
    return;
  } else
#line 403
  if (y >= height) {
#line 404
    return;
  } else
#line 403
  if ((int )*(mask + (y * width + x)) != 2) {
#line 404
    return;
  }
#line 406
  x1 = x;
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (x1 >= 0) {
#line 406
      if (! ((int )*(mask + (y * width + x1)) == 2)) {
#line 406
        goto while_break;
      }
    } else {
#line 406
      goto while_break;
    }
#line 406
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  x1 ++;
#line 408
  x2 = x;
  {
#line 408
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 408
    if (x2 < width) {
#line 408
      if (! ((int )*(mask + (y * width + x2)) == 2)) {
#line 408
        goto while_break___0;
      }
    } else {
#line 408
      goto while_break___0;
    }
#line 408
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 409
  x2 --;
#line 411
  if (x1 >= 0) {
#line 411
    if (! (x2 < width)) {
      {
#line 411
      __assert_fail("x1 >= 0 && x2 < width", "despeckle.c", 411U, "fill");
      }
    }
  } else {
    {
#line 411
    __assert_fail("x1 >= 0 && x2 < width", "despeckle.c", 411U, "fill");
    }
  }
#line 413
  x = x1;
  {
#line 413
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 413
    if (! (x <= x2)) {
#line 413
      goto while_break___1;
    }
#line 415
    *(bitmap + 3 * (y * width + x)) = *(to_index + 0);
#line 416
    *(bitmap + (3 * (y * width + x) + 1)) = *(to_index + 1);
#line 417
    *(bitmap + (3 * (y * width + x) + 2)) = *(to_index + 2);
#line 418
    *(mask + (y * width + x)) = (unsigned char)3;
#line 413
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 421
  x = x1;
  {
#line 421
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 421
    if (! (x <= x2)) {
#line 421
      goto while_break___2;
    }
    {
#line 423
    fill(to_index, x, y - 1, width, height, bitmap, mask);
#line 424
    fill(to_index, x, y + 1, width, height, bitmap, mask);
#line 421
    x ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 426
  return;
}
}
#line 438 "despeckle.c"
static void fill_8(unsigned char *to_index , int x , int y , int width , int height ,
                   unsigned char *bitmap , unsigned char *mask ) 
{ 
  int x1 ;
  int x2 ;

  {
#line 449
  if (y < 0) {
#line 450
    return;
  } else
#line 449
  if (y >= height) {
#line 450
    return;
  } else
#line 449
  if ((int )*(mask + (y * width + x)) != 2) {
#line 450
    return;
  }
#line 452
  x1 = x;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (x1 >= 0) {
#line 452
      if (! ((int )*(mask + (y * width + x1)) == 2)) {
#line 452
        goto while_break;
      }
    } else {
#line 452
      goto while_break;
    }
#line 452
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  x1 ++;
#line 454
  x2 = x;
  {
#line 454
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 454
    if (x2 < width) {
#line 454
      if (! ((int )*(mask + (y * width + x2)) == 2)) {
#line 454
        goto while_break___0;
      }
    } else {
#line 454
      goto while_break___0;
    }
#line 454
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 455
  x2 --;
#line 457
  if (x1 >= 0) {
#line 457
    if (! (x2 < width)) {
      {
#line 457
      __assert_fail("x1 >= 0 && x2 < width", "despeckle.c", 457U, "fill_8");
      }
    }
  } else {
    {
#line 457
    __assert_fail("x1 >= 0 && x2 < width", "despeckle.c", 457U, "fill_8");
    }
  }
#line 459
  x = x1;
  {
#line 459
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 459
    if (! (x <= x2)) {
#line 459
      goto while_break___1;
    }
#line 461
    *(bitmap + (y * width + x)) = *(to_index + 0);
#line 462
    *(mask + (y * width + x)) = (unsigned char)3;
#line 459
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 465
  x = x1;
  {
#line 465
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 465
    if (! (x <= x2)) {
#line 465
      goto while_break___2;
    }
    {
#line 467
    fill_8(to_index, x, y - 1, width, height, bitmap, mask);
#line 468
    fill_8(to_index, x, y + 1, width, height, bitmap, mask);
#line 465
    x ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 470
  return;
}
}
#line 479 "despeckle.c"
static void ignore(int x , int y , int width , int height , unsigned char *mask ) 
{ 
  int x1 ;
  int x2 ;

  {
#line 488
  if (y < 0) {
#line 489
    return;
  } else
#line 488
  if (y >= height) {
#line 489
    return;
  } else
#line 488
  if ((int )*(mask + (y * width + x)) != 1) {
#line 489
    return;
  }
#line 491
  x1 = x;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 491
    if (x1 >= 0) {
#line 491
      if (! ((int )*(mask + (y * width + x1)) == 1)) {
#line 491
        goto while_break;
      }
    } else {
#line 491
      goto while_break;
    }
#line 491
    x1 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  x1 ++;
#line 493
  x2 = x;
  {
#line 493
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 493
    if (x2 < width) {
#line 493
      if (! ((int )*(mask + (y * width + x2)) == 1)) {
#line 493
        goto while_break___0;
      }
    } else {
#line 493
      goto while_break___0;
    }
#line 493
    x2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 494
  x2 --;
#line 496
  if (x1 >= 0) {
#line 496
    if (! (x2 < width)) {
      {
#line 496
      __assert_fail("x1 >= 0 && x2 < width", "despeckle.c", 496U, "ignore");
      }
    }
  } else {
    {
#line 496
    __assert_fail("x1 >= 0 && x2 < width", "despeckle.c", 496U, "ignore");
    }
  }
#line 498
  x = x1;
  {
#line 498
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 498
    if (! (x <= x2)) {
#line 498
      goto while_break___1;
    }
#line 499
    *(mask + (y * width + x)) = (unsigned char)3;
#line 498
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 501
  x = x1;
  {
#line 501
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 501
    if (! (x <= x2)) {
#line 501
      goto while_break___2;
    }
    {
#line 503
    ignore(x, y - 1, width, height, mask);
#line 504
    ignore(x, y + 1, width, height, mask);
#line 501
    x ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 506
  return;
}
}
#line 527 "despeckle.c"
static at_bool recolor(double adaptive_tightness , int x , int y , int width , int height ,
                       unsigned char *bitmap , unsigned char *mask ) 
{ 
  unsigned char *index___0 ;
  unsigned char *to_index ;
  int error_amt ;
  double temp_error ;
  int tmp ;

  {
  {
#line 539
  index___0 = bitmap + 3 * (y * width + x);
#line 540
  to_index = (unsigned char *)((void *)0);
#line 541
  error_amt = 0;
#line 543
  find_most_similar_neighbor(index___0, & to_index, & error_amt, x, y, width, height,
                             bitmap, mask);
  }
#line 547
  if ((unsigned long )to_index != (unsigned long )((void *)0)) {
    {
#line 552
    tmp = calc_error(index___0, to_index);
#line 552
    temp_error = (double )tmp;
#line 554
    temp_error = sqrt(temp_error / 3.0);
    }
#line 562
    if (temp_error > adaptive_tightness) {
      {
#line 563
      fill(index___0, x, y, width, height, bitmap, mask);
      }
    } else {
      {
#line 566
      fill(to_index, x, y, width, height, bitmap, mask);
      }
#line 568
      return ((at_bool )1);
    }
  }
#line 572
  return ((at_bool )0);
}
}
#line 594 "despeckle.c"
static at_bool recolor_8(double adaptive_tightness , int x , int y , int width , int height ,
                         unsigned char *bitmap , unsigned char *mask ) 
{ 
  unsigned char *index___0 ;
  unsigned char *to_index ;
  int error_amt ;
  double temp_error ;
  int tmp ;

  {
  {
#line 606
  index___0 = bitmap + (y * width + x);
#line 607
  to_index = (unsigned char *)((void *)0);
#line 608
  error_amt = 0;
#line 610
  find_most_similar_neighbor_8(index___0, & to_index, & error_amt, x, y, width, height,
                               bitmap, mask);
  }
#line 614
  if ((unsigned long )to_index != (unsigned long )((void *)0)) {
    {
#line 619
    tmp = calc_error_8(index___0, to_index);
#line 619
    temp_error = (double )tmp;
#line 621
    temp_error = sqrt(temp_error / 3.0);
    }
#line 629
    if (temp_error > adaptive_tightness) {
      {
#line 630
      fill_8(index___0, x, y, width, height, bitmap, mask);
      }
    } else {
      {
#line 633
      fill_8(to_index, x, y, width, height, bitmap, mask);
      }
#line 635
      return ((at_bool )1);
    }
  }
#line 639
  return ((at_bool )0);
}
}
#line 654 "despeckle.c"
static void despeckle_iteration(int level , double adaptive_tightness , int width ,
                                int height , unsigned char *bitmap ) 
{ 
  unsigned char *mask ;
  int x ;
  int y ;
  int i ;
  int current_size ;
  int tightness ;
  void *tmp ;
  int size ;
  at_bool tmp___1 ;

  {
#line 667
  i = 0;
#line 667
  current_size = 1;
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 667
    if (! (i < level)) {
#line 667
      goto while_break;
    }
#line 668
    tightness = (int )((double )256 / (1.0 + adaptive_tightness * (double )level));
#line 667
    i ++;
#line 667
    current_size *= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 670
  tmp = calloc((size_t )(width * height), sizeof(unsigned char ));
#line 670
  mask = (unsigned char *)tmp;
#line 671
  y = 0;
  }
  {
#line 671
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 671
    if (! (y < height)) {
#line 671
      goto while_break___0;
    }
#line 673
    x = 0;
    {
#line 673
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 673
      if (! (x < width)) {
#line 673
        goto while_break___1;
      }
#line 675
      if ((int )*(mask + (y * width + x)) == 0) {
        {
#line 679
        size = find_size(bitmap + 3 * (y * width + x), x, y, width, height, bitmap,
                         mask);
        }
#line 682
        if (! (size > 0)) {
          {
#line 682
          __assert_fail("size > 0", "despeckle.c", 682U, "despeckle_iteration");
          }
        }
#line 684
        if (size < current_size) {
          {
#line 686
          tmp___1 = recolor((double )tightness, x, y, width, height, bitmap, mask);
          }
#line 686
          if (tmp___1) {
#line 689
            x --;
          }
        } else {
          {
#line 692
          ignore(x, y, width, height, mask);
          }
        }
      }
#line 673
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 671
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 697
  free((void *)mask);
  }
#line 698
  return;
}
}
#line 712 "despeckle.c"
static void despeckle_iteration_8(int level , double adaptive_tightness , int width ,
                                  int height , unsigned char *bitmap ) 
{ 
  unsigned char *mask ;
  int x ;
  int y ;
  int i ;
  int current_size ;
  int tightness ;
  void *tmp ;
  int size ;
  at_bool tmp___1 ;

  {
#line 725
  i = 0;
#line 725
  current_size = 1;
  {
#line 725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    if (! (i < level)) {
#line 725
      goto while_break;
    }
#line 726
    tightness = (int )((double )256 / (1.0 + adaptive_tightness * (double )level));
#line 725
    i ++;
#line 725
    current_size *= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 728
  tmp = calloc((size_t )(width * height), sizeof(unsigned char ));
#line 728
  mask = (unsigned char *)tmp;
#line 729
  y = 0;
  }
  {
#line 729
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 729
    if (! (y < height)) {
#line 729
      goto while_break___0;
    }
#line 731
    x = 0;
    {
#line 731
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 731
      if (! (x < width)) {
#line 731
        goto while_break___1;
      }
#line 733
      if ((int )*(mask + (y * width + x)) == 0) {
        {
#line 737
        size = find_size_8(bitmap + (y * width + x), x, y, width, height, bitmap,
                           mask);
        }
#line 740
        if (! (size > 0)) {
          {
#line 740
          __assert_fail("size > 0", "despeckle.c", 740U, "despeckle_iteration_8");
          }
        }
#line 742
        if (size < current_size) {
          {
#line 744
          tmp___1 = recolor_8((double )tightness, x, y, width, height, bitmap, mask);
          }
#line 744
          if (tmp___1) {
#line 747
            x --;
          }
        } else {
          {
#line 750
          ignore(x, y, width, height, mask);
          }
        }
      }
#line 731
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 729
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 755
  free((void *)mask);
  }
#line 756
  return;
}
}
#line 777 "despeckle.c"
void despeckle(bitmap_type *bitmap , int level , at_real tightness , at_exception_type *excep ) 
{ 
  int i ;
  int planes ;

  {
#line 786
  planes = (int )bitmap->np;
#line 788
  if ((double )tightness >= 0.0) {
#line 788
    if (! ((double )tightness <= 8.0)) {
      {
#line 788
      __assert_fail("tightness >= 0.0 && tightness <= 8.0", "despeckle.c", 788U, "despeckle");
      }
    }
  } else {
    {
#line 788
    __assert_fail("tightness >= 0.0 && tightness <= 8.0", "despeckle.c", 788U, "despeckle");
    }
  }
#line 789
  if (level >= 0) {
#line 789
    if (! (level <= 20)) {
      {
#line 789
      __assert_fail("level >= 0 && level <= 20", "despeckle.c", 789U, "despeckle");
      }
    }
  } else {
    {
#line 789
    __assert_fail("level >= 0 && level <= 20", "despeckle.c", 789U, "despeckle");
    }
  }
#line 791
  if (planes == 3) {
#line 792
    i = 0;
    {
#line 792
    while (1) {
      while_continue: /* CIL Label */ ;
#line 792
      if (! (i < level)) {
#line 792
        goto while_break;
      }
      {
#line 793
      despeckle_iteration(i, (double )tightness, (int )bitmap->width, (int )bitmap->height,
                          bitmap->bitmap);
#line 792
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 796
  if (planes == 1) {
#line 797
    i = 0;
    {
#line 797
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 797
      if (! (i < level)) {
#line 797
        goto while_break___0;
      }
      {
#line 798
      despeckle_iteration_8(i, (double )tightness, (int )bitmap->width, (int )bitmap->height,
                            bitmap->bitmap);
#line 797
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 803
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 803
      if (at_log_file) {
        {
#line 803
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"despeckle: %u-plane images are not supported",
                planes);
        }
      }
#line 803
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 804
    at_exception_fatal(excep, (at_string const   )"despeckle: wrong plane images are passed");
    }
#line 805
    return;
  }
#line 808
  return;
}
}
#line 117 "curve.h"
void free_curve_list(curve_list_type *curve_list ) ;
#line 29 "curve.c"
static at_real_coord int_to_real_coord(at_coord int_coord ) ;
#line 33 "curve.c"
curve_type new_curve(void) 
{ 
  curve_type curve ;
  void *tmp ;
  vector_type *tmp___1 ;
  struct curve *tmp___2 ;

  {
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 37
    tmp = malloc(sizeof(struct curve ));
#line 37
    curve = (curve_type )tmp;
    }
#line 37
    if (! curve) {
      {
#line 37
      __assert_fail("curve", "curve.c", 37U, "new_curve");
      }
    }
#line 37
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  curve->point_list = (point_type *)((void *)0);
#line 39
  curve->length = 0U;
#line 40
  curve->cyclic = (at_bool )0;
#line 41
  tmp___1 = (vector_type *)((void *)0);
#line 41
  curve->end_tangent = tmp___1;
#line 41
  curve->start_tangent = tmp___1;
#line 42
  tmp___2 = (struct curve *)((void *)0);
#line 42
  curve->next = tmp___2;
#line 42
  curve->previous = tmp___2;
#line 44
  return (curve);
}
}
#line 50 "curve.c"
curve_type copy_most_of_curve(curve_type old_curve ) 
{ 
  curve_type curve ;
  curve_type tmp ;

  {
  {
#line 53
  tmp = new_curve();
#line 53
  curve = tmp;
#line 55
  curve->cyclic = old_curve->cyclic;
#line 56
  curve->previous = old_curve->previous;
#line 57
  curve->next = old_curve->next;
  }
#line 59
  return (curve);
}
}
#line 67 "curve.c"
void free_curve(curve_type curve ) 
{ 


  {
#line 70
  if (curve->length > 0U) {
    {
#line 71
    free((void *)curve->point_list);
    }
  }
#line 72
  if (curve->start_tangent) {
    {
#line 73
    free((void *)curve->start_tangent);
    }
  }
#line 74
  if (curve->end_tangent) {
    {
#line 75
    free((void *)curve->end_tangent);
    }
  }
#line 76
  return;
}
}
#line 79 "curve.c"
void append_pixel(curve_type curve , at_coord coord ) 
{ 
  at_real_coord tmp ;

  {
  {
#line 82
  tmp = int_to_real_coord(coord);
#line 82
  append_point(curve, tmp);
  }
#line 83
  return;
}
}
#line 86 "curve.c"
void append_point(curve_type curve , at_real_coord coord ) 
{ 
  at_address new_mem ;
  void *tmp ;
  void *tmp___1 ;

  {
#line 89
  (curve->length) ++;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if ((unsigned long )curve->point_list == (unsigned long )((void *)0)) {
      {
#line 90
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 90
        tmp = malloc((unsigned long )curve->length * sizeof(point_type ));
#line 90
        new_mem = tmp;
        }
#line 90
        if (! new_mem) {
          {
#line 90
          __assert_fail("new_mem", "curve.c", 90U, "append_point");
          }
        }
#line 90
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 90
      tmp___1 = realloc((void *)curve->point_list, (unsigned long )curve->length * sizeof(point_type ));
#line 90
      new_mem = tmp___1;
      }
#line 90
      if (! new_mem) {
        {
#line 90
        __assert_fail("new_mem", "curve.c", 90U, "append_point");
        }
      }
    }
#line 90
    curve->point_list = (point_type *)new_mem;
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  (curve->point_list + (curve->length - 1U))->coord = coord;
#line 93
  return;
}
}
#line 112 "curve.c"
void log_curve(curve_type curve , at_bool print_t ) 
{ 
  unsigned int this_point ;

  {
#line 117
  if (! at_log_file) {
#line 117
    return;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (at_log_file) {
      {
#line 119
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"curve id = %x:\n",
              (unsigned long )curve);
      }
    }
#line 119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (at_log_file) {
      {
#line 120
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  length = %u.\n",
              curve->length);
      }
    }
#line 120
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 121
  if (curve->cyclic) {
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 122
      if (at_log_file) {
        {
#line 122
        fputs((char const   */* __restrict  */)"  cyclic.\n", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 122
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 126
  if ((unsigned long )curve->start_tangent != (unsigned long )((void *)0)) {
    {
#line 127
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 127
      if (at_log_file) {
        {
#line 127
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  tangents = (%.3f,%.3f) & (%.3f,%.3f).\n",
                (double )(curve->start_tangent)->dx, (double )(curve->start_tangent)->dy,
                (double )(curve->end_tangent)->dx, (double )(curve->end_tangent)->dy);
        }
      }
#line 127
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 131
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 131
    if (at_log_file) {
      {
#line 131
      fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 131
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 134
  if (curve->length <= 6U) {
#line 136
    this_point = 0U;
    {
#line 136
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 136
      if (! (this_point < curve->length)) {
#line 136
        goto while_break___4;
      }
      {
#line 138
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 138
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 138
          if (at_log_file) {
            {
#line 138
            fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"(%.3f,%.3f)",
                    (double )(curve->point_list + this_point)->coord.x, (double )(curve->point_list + this_point)->coord.y);
            }
          }
#line 138
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 138
        if (print_t) {
          {
#line 138
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 138
            if (at_log_file) {
              {
#line 138
              fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"/%.2f",
                      (double )(curve->point_list + this_point)->t);
              }
            }
#line 138
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 138
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 139
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 139
        if (at_log_file) {
          {
#line 139
          fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 139
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 141
      if (this_point != curve->length - 1U) {
#line 141
        if ((this_point + 1U) % 3U == 0U) {
          {
#line 143
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 143
            if (at_log_file) {
              {
#line 143
              fputs((char const   */* __restrict  */)"\n  ", (FILE */* __restrict  */)at_log_file);
              }
            }
#line 143
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
#line 136
      this_point ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
#line 148
    this_point = 0U;
    {
#line 148
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 148
      if (this_point < 3U) {
#line 148
        if (! (this_point < curve->length)) {
#line 148
          goto while_break___10;
        }
      } else {
#line 148
        goto while_break___10;
      }
      {
#line 152
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 152
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 152
          if (at_log_file) {
            {
#line 152
            fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"(%.3f,%.3f)",
                    (double )(curve->point_list + this_point)->coord.x, (double )(curve->point_list + this_point)->coord.y);
            }
          }
#line 152
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 152
        if (print_t) {
          {
#line 152
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 152
            if (at_log_file) {
              {
#line 152
              fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"/%.2f",
                      (double )(curve->point_list + this_point)->t);
              }
            }
#line 152
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
        }
#line 152
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 153
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 153
        if (at_log_file) {
          {
#line 153
          fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 153
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 148
      this_point ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 156
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 156
      if (at_log_file) {
        {
#line 156
        fputs((char const   */* __restrict  */)"...\n   ...", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 156
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 158
    this_point = curve->length - 3U;
    {
#line 158
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 158
      if (! (this_point < curve->length)) {
#line 158
        goto while_break___16;
      }
      {
#line 162
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 162
        if (at_log_file) {
          {
#line 162
          fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 162
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 163
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 163
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 163
          if (at_log_file) {
            {
#line 163
            fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"(%.3f,%.3f)",
                    (double )(curve->point_list + this_point)->coord.x, (double )(curve->point_list + this_point)->coord.y);
            }
          }
#line 163
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 163
        if (print_t) {
          {
#line 163
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 163
            if (at_log_file) {
              {
#line 163
              fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"/%.2f",
                      (double )(curve->point_list + this_point)->t);
              }
            }
#line 163
            goto while_break___20;
          }
          while_break___20: /* CIL Label */ ;
          }
        }
#line 163
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 158
      this_point ++;
    }
    while_break___16: /* CIL Label */ ;
    }
  }
  {
#line 167
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 167
    if (at_log_file) {
      {
#line 167
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 167
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 168
  return;
}
}
#line 173 "curve.c"
void log_entire_curve(curve_type curve ) 
{ 
  unsigned int this_point ;

  {
#line 178
  if (! at_log_file) {
#line 178
    return;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (at_log_file) {
      {
#line 180
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"curve id = %x:\n",
              (unsigned long )curve);
      }
    }
#line 180
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (at_log_file) {
      {
#line 181
      fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  length = %u.\n",
              curve->length);
      }
    }
#line 181
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 182
  if (curve->cyclic) {
    {
#line 183
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 183
      if (at_log_file) {
        {
#line 183
        fputs((char const   */* __restrict  */)"  cyclic.\n", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 183
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 187
  if ((unsigned long )curve->start_tangent != (unsigned long )((void *)0)) {
    {
#line 188
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 188
      if (at_log_file) {
        {
#line 188
        fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"  tangents = (%.3f,%.3f) & (%.3f,%.3f).\n",
                (double )(curve->start_tangent)->dx, (double )(curve->start_tangent)->dy,
                (double )(curve->end_tangent)->dx, (double )(curve->end_tangent)->dy);
        }
      }
#line 188
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 192
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 192
    if (at_log_file) {
      {
#line 192
      fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 192
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 194
  this_point = 0U;
  {
#line 194
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 194
    if (! (this_point < curve->length)) {
#line 194
      goto while_break___4;
    }
    {
#line 196
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 196
      if (at_log_file) {
        {
#line 196
        fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)at_log_file);
        }
      }
#line 196
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 197
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 197
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 197
        if (at_log_file) {
          {
#line 197
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"(%.3f,%.3f)",
                  (double )(curve->point_list + this_point)->coord.x, (double )(curve->point_list + this_point)->coord.y);
          }
        }
#line 197
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 197
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 197
        if (at_log_file) {
          {
#line 197
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"/%.2f",
                  (double )(curve->point_list + this_point)->t);
          }
        }
#line 197
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 197
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 194
    this_point ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 201
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 201
    if (at_log_file) {
      {
#line 201
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)at_log_file);
      }
    }
#line 201
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 207 "curve.c"
curve_list_type new_curve_list(void) 
{ 
  curve_list_type curve_list ;

  {
#line 212
  curve_list.length = 0U;
#line 213
  curve_list.data = (curve_type *)((void *)0);
#line 215
  return (curve_list);
}
}
#line 221 "curve.c"
void free_curve_list(curve_list_type *curve_list ) 
{ 
  unsigned int this_curve ;

  {
#line 226
  this_curve = 0U;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (this_curve < curve_list->length)) {
#line 226
      goto while_break;
    }
    {
#line 228
    free_curve(*(curve_list->data + this_curve));
#line 229
    free((void *)*(curve_list->data + this_curve));
#line 226
    this_curve ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  if ((unsigned long )curve_list->data != (unsigned long )((void *)0)) {
    {
#line 234
    free((void *)curve_list->data);
    }
  }
#line 235
  return;
}
}
#line 240 "curve.c"
void append_curve(curve_list_type *curve_list , curve_type curve ) 
{ 
  at_address new_mem ;
  void *tmp ;
  void *tmp___1 ;

  {
#line 243
  (curve_list->length) ++;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if ((unsigned long )curve_list->data == (unsigned long )((void *)0)) {
      {
#line 244
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 244
        tmp = malloc((unsigned long )curve_list->length * sizeof(curve_type ));
#line 244
        new_mem = tmp;
        }
#line 244
        if (! new_mem) {
          {
#line 244
          __assert_fail("new_mem", "curve.c", 244U, "append_curve");
          }
        }
#line 244
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 244
      tmp___1 = realloc((void *)curve_list->data, (unsigned long )curve_list->length * sizeof(curve_type ));
#line 244
      new_mem = tmp___1;
      }
#line 244
      if (! new_mem) {
        {
#line 244
        __assert_fail("new_mem", "curve.c", 244U, "append_curve");
        }
      }
    }
#line 244
    curve_list->data = (curve_type *)new_mem;
#line 244
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  *(curve_list->data + (curve_list->length - 1U)) = curve;
#line 245
  return;
}
}
#line 250 "curve.c"
curve_list_array_type new_curve_list_array(void) 
{ 
  curve_list_array_type curve_list_array ;

  {
#line 255
  curve_list_array.length = 0U;
#line 256
  curve_list_array.data = (curve_list_type *)((void *)0);
#line 258
  return (curve_list_array);
}
}
#line 264 "curve.c"
void free_curve_list_array(curve_list_array_type *curve_list_array , void (*notify_progress)(at_real percentage ,
                                                                                             at_address client_data ) ,
                           at_address client_data ) 
{ 
  unsigned int this_list ;

  {
#line 271
  this_list = 0U;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (this_list < curve_list_array->length)) {
#line 271
      goto while_break;
    }
#line 273
    if (notify_progress) {
      {
#line 274
      (*notify_progress)((at_real )this_list / ((at_real )curve_list_array->length * (at_real )3.0) + (at_real )0.666,
                         client_data);
      }
    }
    {
#line 276
    free_curve_list(curve_list_array->data + this_list);
#line 271
    this_list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if ((unsigned long )curve_list_array->data != (unsigned long )((void *)0)) {
    {
#line 281
    free((void *)curve_list_array->data);
    }
  }
#line 282
  return;
}
}
#line 287 "curve.c"
void append_curve_list(curve_list_array_type *curve_list_array , curve_list_type curve_list ) 
{ 
  at_address new_mem ;
  void *tmp ;
  void *tmp___1 ;

  {
#line 290
  (curve_list_array->length) ++;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if ((unsigned long )curve_list_array->data == (unsigned long )((void *)0)) {
      {
#line 291
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 291
        tmp = malloc((unsigned long )curve_list_array->length * sizeof(curve_list_type ));
#line 291
        new_mem = tmp;
        }
#line 291
        if (! new_mem) {
          {
#line 291
          __assert_fail("new_mem", "curve.c", 291U, "append_curve_list");
          }
        }
#line 291
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 291
      tmp___1 = realloc((void *)curve_list_array->data, (unsigned long )curve_list_array->length * sizeof(curve_list_type ));
#line 291
      new_mem = tmp___1;
      }
#line 291
      if (! new_mem) {
        {
#line 291
        __assert_fail("new_mem", "curve.c", 291U, "append_curve_list");
        }
      }
    }
#line 291
    curve_list_array->data = (curve_list_type *)new_mem;
#line 291
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  *(curve_list_array->data + (curve_list_array->length - 1U)) = curve_list;
#line 293
  return;
}
}
#line 298 "curve.c"
static at_real_coord int_to_real_coord(at_coord int_coord ) 
{ 
  at_real_coord real_coord ;

  {
#line 303
  real_coord.x = (at_real )int_coord.x;
#line 304
  real_coord.y = (at_real )int_coord.y;
#line 305
  real_coord.z = (at_real )0.0;
#line 307
  return (real_coord);
}
}
#line 9 "color.c"
color_type GET_COLOR(at_bitmap_type bitmap , unsigned int row , unsigned int col ) 
{ 
  color_type c ;
  unsigned char *p ;

  {
#line 12
  p = (bitmap.bitmap + (row * bitmap.np) * (unsigned int )bitmap.width) + col * bitmap.np;
#line 14
  if (bitmap.np >= 3U) {
#line 16
    c.r = *(p + 0);
#line 17
    c.g = *(p + 1);
#line 18
    c.b = *(p + 2);
  } else {
#line 21
    c.r = *(p + 0);
#line 21
    c.b = c.r;
#line 21
    c.g = c.b;
  }
#line 22
  return (c);
}
}
#line 10 "bitmap.c"
bitmap_type new_bitmap(unsigned short width , unsigned short height ) 
{ 
  at_bitmap_type tmp ;

  {
  {
#line 13
  tmp = at_bitmap_init((unsigned char *)((void *)0), width, height, 1U);
  }
#line 13
  return (tmp);
}
}
#line 20 "bitmap.c"
void free_bitmap(bitmap_type *b ) 
{ 


  {
#line 23
  if ((unsigned long )b->bitmap != (unsigned long )((void *)0)) {
    {
#line 24
    free((void *)b->bitmap);
    }
  }
#line 25
  return;
}
}
#line 274 "autotrace.h"
at_fitting_opts_type *at_fitting_opts_copy(at_fitting_opts_type *original ) ;
#line 286
at_input_opts_type *at_input_opts_copy(at_input_opts_type *original ) ;
#line 295
at_output_opts_type *at_output_opts_copy(at_output_opts_type *original ) ;
#line 318
at_bitmap_type *at_bitmap_new(unsigned short width , unsigned short height , unsigned int planes ) ;
#line 321
at_bitmap_type *at_bitmap_copy(at_bitmap_type *src ) ;
#line 348
at_spline_list_array_type *at_splines_new(at_bitmap_type *bitmap , at_fitting_opts_type *opts ,
                                          void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                           at_address client_data ) ,
                                          at_address msg_data ) ;
#line 400
at_bool at_color_equal(at_color_type *c1 , at_color_type *c2 ) ;
#line 47 "autotrace.c"
at_fitting_opts_type *at_fitting_opts_new(void) 
{ 
  at_fitting_opts_type *opts ;
  void *tmp ;

  {
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    tmp = malloc(sizeof(at_fitting_opts_type ));
#line 51
    opts = (at_fitting_opts_type *)tmp;
    }
#line 51
    if (! opts) {
      {
#line 51
      __assert_fail("opts", "autotrace.c", 51U, "at_fitting_opts_new");
      }
    }
#line 51
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 52
  *opts = new_fitting_opts();
  }
#line 53
  return (opts);
}
}
#line 56 "autotrace.c"
at_fitting_opts_type *at_fitting_opts_copy(at_fitting_opts_type *original ) 
{ 
  at_fitting_opts_type *new_opts ;

  {
#line 60
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 61
    return ((at_fitting_opts_type *)((void *)0));
  }
  {
#line 63
  new_opts = at_fitting_opts_new();
#line 64
  *new_opts = *original;
  }
#line 65
  if (original->background_color) {
    {
#line 66
    new_opts->background_color = at_color_copy(original->background_color);
    }
  }
#line 67
  return (new_opts);
}
}
#line 70 "autotrace.c"
void at_fitting_opts_free(at_fitting_opts_type *opts ) 
{ 


  {
#line 73
  if ((unsigned long )opts->background_color != (unsigned long )((void *)0)) {
    {
#line 74
    free((void *)opts->background_color);
    }
  }
  {
#line 75
  free((void *)opts);
  }
#line 76
  return;
}
}
#line 78 "autotrace.c"
at_input_opts_type *at_input_opts_new(void) 
{ 
  at_input_opts_type *opts ;
  void *tmp ;

  {
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 82
    tmp = malloc(sizeof(at_input_opts_type ));
#line 82
    opts = (at_input_opts_type *)tmp;
    }
#line 82
    if (! opts) {
      {
#line 82
      __assert_fail("opts", "autotrace.c", 82U, "at_input_opts_new");
      }
    }
#line 82
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  opts->background_color = (at_color_type *)((void *)0);
#line 84
  return (opts);
}
}
#line 87 "autotrace.c"
at_input_opts_type *at_input_opts_copy(at_input_opts_type *original ) 
{ 
  at_input_opts_type *opts ;

  {
  {
#line 91
  opts = at_input_opts_new();
  }
#line 92
  if (original->background_color) {
    {
#line 93
    opts->background_color = at_color_copy(original->background_color);
    }
  }
#line 94
  return (opts);
}
}
#line 97 "autotrace.c"
void at_input_opts_free(at_input_opts_type *opts ) 
{ 


  {
#line 100
  if ((unsigned long )opts->background_color != (unsigned long )((void *)0)) {
    {
#line 101
    free((void *)opts->background_color);
    }
  }
  {
#line 102
  free((void *)opts);
  }
#line 103
  return;
}
}
#line 105 "autotrace.c"
at_output_opts_type *at_output_opts_new(void) 
{ 
  at_output_opts_type *opts ;
  void *tmp ;

  {
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 109
    tmp = malloc(sizeof(at_output_opts_type ));
#line 109
    opts = (at_output_opts_type *)tmp;
    }
#line 109
    if (! opts) {
      {
#line 109
      __assert_fail("opts", "autotrace.c", 109U, "at_output_opts_new");
      }
    }
#line 109
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  opts->dpi = 72;
#line 111
  return (opts);
}
}
#line 114 "autotrace.c"
at_output_opts_type *at_output_opts_copy(at_output_opts_type *original ) 
{ 
  at_output_opts_type *opts ;
  at_output_opts_type *tmp ;

  {
  {
#line 117
  tmp = at_output_opts_new();
#line 117
  opts = tmp;
#line 118
  *opts = *original;
  }
#line 119
  return (opts);
}
}
#line 122 "autotrace.c"
void at_output_opts_free(at_output_opts_type *opts ) 
{ 


  {
  {
#line 125
  free((void *)opts);
  }
#line 126
  return;
}
}
#line 128 "autotrace.c"
at_bitmap_type *at_bitmap_read(at_bitmap_type (*input_reader___0)(at_string name ,
                                                                  at_input_opts_type *opts ,
                                                                  void (*msg_func)(at_string msg ,
                                                                                   at_msg_type msg_type ,
                                                                                   at_address client_data ) ,
                                                                  at_address msg_data ) ,
                               at_string filename___0 , at_input_opts_type *opts ,
                               void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                at_address client_data ) , at_address msg_data ) 
{ 
  at_bool new_opts ;
  at_bitmap_type *bitmap ;
  void *tmp ;

  {
#line 134
  new_opts = (at_bool )0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 136
    tmp = malloc(sizeof(at_bitmap_type ));
#line 136
    bitmap = (at_bitmap_type *)tmp;
    }
#line 136
    if (! bitmap) {
      {
#line 136
      __assert_fail("bitmap", "autotrace.c", 136U, "at_bitmap_read");
      }
    }
#line 136
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if ((unsigned long )opts == (unsigned long )((void *)0)) {
    {
#line 139
    opts = at_input_opts_new();
#line 140
    new_opts = (at_bool )1;
    }
  }
  {
#line 142
  *bitmap = (*input_reader___0)(filename___0, opts, msg_func, msg_data);
  }
#line 143
  if (new_opts) {
    {
#line 144
    at_input_opts_free(opts);
    }
  }
#line 145
  return (bitmap);
}
}
#line 148 "autotrace.c"
at_bitmap_type *at_bitmap_new(unsigned short width , unsigned short height , unsigned int planes ) 
{ 
  at_bitmap_type *bitmap ;
  void *tmp ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    tmp = malloc(sizeof(at_bitmap_type ));
#line 154
    bitmap = (at_bitmap_type *)tmp;
    }
#line 154
    if (! bitmap) {
      {
#line 154
      __assert_fail("bitmap", "autotrace.c", 154U, "at_bitmap_new");
      }
    }
#line 154
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  *bitmap = at_bitmap_init((unsigned char *)((void *)0), width, height, planes);
  }
#line 156
  return (bitmap);
}
}
#line 159 "autotrace.c"
at_bitmap_type *at_bitmap_copy(at_bitmap_type *src ) 
{ 
  at_bitmap_type *dist ;
  unsigned short width ;
  unsigned short height ;
  unsigned short planes ;

  {
  {
#line 165
  width = at_bitmap_get_width(src);
#line 166
  height = at_bitmap_get_height(src);
#line 167
  planes = at_bitmap_get_planes(src);
#line 169
  dist = at_bitmap_new(width, height, (unsigned int )planes);
#line 170
  memcpy((void */* __restrict  */)dist->bitmap, (void const   */* __restrict  */)src->bitmap,
         (unsigned long )(((int )width * (int )height) * (int )planes) * sizeof(unsigned char ));
  }
#line 173
  return (dist);
}
}
#line 176 "autotrace.c"
at_bitmap_type at_bitmap_init(unsigned char *area , unsigned short width , unsigned short height ,
                              unsigned int planes ) 
{ 
  at_bitmap_type bitmap ;
  void *tmp ;

  {
#line 184
  if (area) {
#line 185
    bitmap.bitmap = area;
  } else
#line 188
  if (0 == (int )width * (int )height) {
#line 189
    bitmap.bitmap = (unsigned char *)((void *)0);
  } else {
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 191
      tmp = calloc((unsigned long )((unsigned int )((int )width * (int )height) * planes) * sizeof(unsigned char ),
                   (size_t )1);
#line 191
      bitmap.bitmap = (unsigned char *)tmp;
      }
#line 191
      if (! bitmap.bitmap) {
        {
#line 191
        __assert_fail("bitmap.bitmap", "autotrace.c", 191U, "at_bitmap_init");
        }
      }
#line 191
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 194
  bitmap.width = width;
#line 195
  bitmap.height = height;
#line 196
  bitmap.np = planes;
#line 197
  return (bitmap);
}
}
#line 200 "autotrace.c"
void at_bitmap_free(at_bitmap_type *bitmap ) 
{ 


  {
  {
#line 203
  free_bitmap(bitmap);
#line 204
  free((void *)bitmap);
  }
#line 205
  return;
}
}
#line 207 "autotrace.c"
unsigned short at_bitmap_get_width(at_bitmap_type *bitmap ) 
{ 


  {
#line 210
  return (bitmap->width);
}
}
#line 213 "autotrace.c"
unsigned short at_bitmap_get_height(at_bitmap_type *bitmap ) 
{ 


  {
#line 216
  return (bitmap->height);
}
}
#line 219 "autotrace.c"
unsigned short at_bitmap_get_planes(at_bitmap_type *bitmap ) 
{ 


  {
#line 222
  return ((unsigned short )bitmap->np);
}
}
#line 225 "autotrace.c"
at_spline_list_array_type *at_splines_new(at_bitmap_type *bitmap , at_fitting_opts_type *opts ,
                                          void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                           at_address client_data ) ,
                                          at_address msg_data ) 
{ 
  at_spline_list_array_type *tmp ;

  {
  {
#line 230
  tmp = at_splines_new_full(bitmap, opts, msg_func, msg_data, (void (*)(at_real percentage ,
                                                                        at_address client_data ))((void *)0),
                            (void *)0, (at_bool (*)(at_address client_data ))((void *)0),
                            (void *)0);
  }
#line 230
  return (tmp);
}
}
#line 237 "autotrace.c"
at_spline_list_array_type *at_splines_new_full(at_bitmap_type *bitmap , at_fitting_opts_type *opts ,
                                               void (*msg_func)(at_string msg , at_msg_type msg_type ,
                                                                at_address client_data ) ,
                                               at_address msg_data , void (*notify_progress)(at_real percentage ,
                                                                                             at_address client_data ) ,
                                               at_address progress_data , at_bool (*test_cancel)(at_address client_data ) ,
                                               at_address testcancel_data ) 
{ 
  image_header_type image_header ;
  at_spline_list_array_type *splines ;
  pixel_outline_list_type pixels ;
  QuantizeObj *myQuant ;
  at_exception_type exp ;
  at_exception_type tmp ;
  distance_map_type dist_map ;
  distance_map_type *dist ;
  at_bool tmp___0 ;
  at_bool tmp___1 ;
  at_bool tmp___2 ;
  at_bool tmp___3 ;
  color_type background_color ;
  at_bool tmp___4 ;
  at_bool tmp___5 ;
  void *tmp___6 ;
  at_bool tmp___8 ;
  at_bool tmp___9 ;

  {
  {
#line 248
  splines = (at_spline_list_array_type *)((void *)0);
#line 250
  myQuant = (QuantizeObj *)((void *)0);
#line 251
  tmp = at_exception_new(msg_func, msg_data);
#line 251
  exp = tmp;
#line 252
  dist = (distance_map_type *)((void *)0);
  }
#line 265
  if (opts->despeckle_level > 0U) {
    {
#line 267
    despeckle(bitmap, (int )opts->despeckle_level, opts->despeckle_tightness, & exp);
#line 271
    tmp___0 = at_exception_got_fatal(& exp);
    }
#line 271
    if (tmp___0) {
#line 271
      return (splines);
    }
  }
  {
#line 274
  image_header.width = at_bitmap_get_width(bitmap);
#line 275
  image_header.height = at_bitmap_get_height(bitmap);
  }
#line 277
  if (opts->color_count > 0U) {
    {
#line 279
    quantize(bitmap, (long )opts->color_count, (color_type const   *)opts->background_color,
             & myQuant, & exp);
    }
#line 280
    if (myQuant) {
      {
#line 281
      quantize_object_free(myQuant);
      }
    }
    {
#line 282
    tmp___1 = at_exception_got_fatal(& exp);
    }
#line 282
    if (tmp___1) {
#line 282
      return (splines);
    }
  }
#line 285
  if (opts->centerline) {
#line 287
    if (opts->preserve_width) {
      {
#line 290
      dist_map = new_distance_map(*bitmap, (unsigned char)255, (at_bool )1, & exp);
#line 291
      dist = & dist_map;
#line 292
      tmp___2 = at_exception_got_fatal(& exp);
      }
#line 292
      if (tmp___2) {
#line 292
        return (splines);
      }
    }
    {
#line 297
    thin_image(bitmap, (color_type const   *)opts->background_color, & exp);
#line 298
    tmp___3 = at_exception_got_fatal(& exp);
    }
#line 298
    if (tmp___3) {
#line 298
      goto cleanup_dist;
    }
  }
#line 303
  if (opts->centerline) {
#line 305
    background_color.r = (unsigned char)255;
#line 305
    background_color.g = (unsigned char)255;
#line 305
    background_color.b = (unsigned char)255;
#line 306
    if (opts->background_color) {
#line 307
      background_color = *(opts->background_color);
    }
    {
#line 309
    pixels = find_centerline_pixels(*bitmap, background_color, notify_progress, progress_data,
                                    test_cancel, testcancel_data, & exp);
    }
  } else {
    {
#line 314
    pixels = find_outline_pixels(*bitmap, opts->background_color, notify_progress,
                                 progress_data, test_cancel, testcancel_data, & exp);
    }
  }
  {
#line 317
  tmp___4 = at_exception_got_fatal(& exp);
  }
#line 317
  if (tmp___4) {
#line 317
    goto cleanup_dist;
  }
#line 318
  if (test_cancel) {
    {
#line 318
    tmp___5 = (*test_cancel)(testcancel_data);
    }
#line 318
    if (tmp___5) {
#line 318
      goto cleanup_dist;
    }
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 320
    tmp___6 = malloc(sizeof(at_spline_list_array_type ));
#line 320
    splines = (at_spline_list_array_type *)tmp___6;
    }
#line 320
    if (! splines) {
      {
#line 320
      __assert_fail("splines", "autotrace.c", 320U, "at_splines_new_full");
      }
    }
#line 320
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  *splines = fitted_splines(pixels, opts, dist, image_header.width, image_header.height,
                            & exp, notify_progress, progress_data, test_cancel, testcancel_data);
#line 327
  tmp___8 = at_exception_got_fatal(& exp);
  }
#line 327
  if (tmp___8) {
    {
#line 327
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 327
      if (splines) {
        {
#line 327
        at_splines_free(splines);
#line 327
        splines = (at_spline_list_array_type *)((void *)0);
        }
      }
#line 327
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 327
    goto cleanup_pixels;
  }
#line 328
  if (test_cancel) {
    {
#line 328
    tmp___9 = (*test_cancel)(testcancel_data);
    }
#line 328
    if (tmp___9) {
      {
#line 328
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 328
        if (splines) {
          {
#line 328
          at_splines_free(splines);
#line 328
          splines = (at_spline_list_array_type *)((void *)0);
          }
        }
#line 328
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 328
      goto cleanup_pixels;
    }
  }
#line 330
  if (notify_progress) {
    {
#line 331
    (*notify_progress)((at_real )1.0, progress_data);
    }
  }
  cleanup_pixels: 
  {
#line 334
  free_pixel_outline_list(& pixels);
  }
  cleanup_dist: 
#line 336
  if (dist) {
    {
#line 337
    free_distance_map(dist);
    }
  }
#line 338
  return (splines);
}
}
#line 351 "autotrace.c"
void at_splines_write(int (*output_writer___0)(FILE * , at_string name , int llx ,
                                               int lly , int urx , int ury , at_output_opts_type *opts ,
                                               at_spline_list_array_type shape , void (*msg_func)(at_string msg ,
                                                                                                  at_msg_type msg_type ,
                                                                                                  at_address client_data ) ,
                                               at_address msg_data ) , FILE *writeto ,
                      at_string file_name , at_output_opts_type *opts , at_spline_list_array_type *splines ,
                      void (*msg_func)(at_string msg , at_msg_type msg_type , at_address client_data ) ,
                      at_address msg_data ) 
{ 
  at_bool new_opts ;
  int llx ;
  int lly ;
  int urx ;
  int ury ;

  {
#line 359
  new_opts = (at_bool )0;
#line 361
  llx = 0;
#line 362
  lly = 0;
#line 363
  urx = (int )splines->width;
#line 364
  ury = (int )splines->height;
#line 366
  if (! file_name) {
#line 367
    file_name = (at_string )"";
  }
#line 369
  if ((unsigned long )opts == (unsigned long )((void *)0)) {
    {
#line 371
    new_opts = (at_bool )1;
#line 372
    opts = at_output_opts_new();
    }
  }
  {
#line 386
  (*output_writer___0)(writeto, file_name, llx, lly, urx, ury, opts, *splines, msg_func,
                       msg_data);
  }
#line 389
  if (new_opts) {
    {
#line 390
    at_output_opts_free(opts);
    }
  }
#line 391
  return;
}
}
#line 393 "autotrace.c"
void at_splines_free(at_spline_list_array_type *splines ) 
{ 


  {
  {
#line 396
  free_spline_list_array(splines);
  }
#line 397
  if (splines->background_color) {
    {
#line 398
    at_color_free(splines->background_color);
    }
  }
  {
#line 399
  free((void *)splines);
  }
#line 400
  return;
}
}
#line 402 "autotrace.c"
at_color_type *at_color_new(unsigned char r , unsigned char g , unsigned char b ) 
{ 
  at_color_type *color ;
  void *tmp ;

  {
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 408
    tmp = malloc(sizeof(at_color_type ));
#line 408
    color = (at_color_type *)tmp;
    }
#line 408
    if (! color) {
      {
#line 408
      __assert_fail("color", "autotrace.c", 408U, "at_color_new");
      }
    }
#line 408
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  color->r = r;
#line 410
  color->g = g;
#line 411
  color->b = b;
#line 412
  return (color);
}
}
#line 415 "autotrace.c"
at_color_type *at_color_copy(at_color_type *original ) 
{ 
  at_color_type *tmp ;

  {
#line 418
  if ((unsigned long )original == (unsigned long )((void *)0)) {
#line 419
    return ((at_color_type *)((void *)0));
  }
  {
#line 420
  tmp = at_color_new(original->r, original->g, original->b);
  }
#line 420
  return (tmp);
}
}
#line 425 "autotrace.c"
at_bool at_color_equal(at_color_type *c1 , at_color_type *c2 ) 
{ 
  int tmp ;

  {
#line 428
  if ((unsigned long )c1 == (unsigned long )c2) {
#line 429
    return ((at_bool )1);
  } else {
#line 431
    if ((int )c1->r == (int )c2->r) {
#line 431
      if ((int )c1->g == (int )c2->g) {
#line 431
        if ((int )c1->b == (int )c2->b) {
#line 431
          tmp = 1;
        } else {
#line 431
          tmp = 0;
        }
      } else {
#line 431
        tmp = 0;
      }
    } else {
#line 431
      tmp = 0;
    }
#line 431
    return ((at_bool )tmp);
  }
}
}
#line 434 "autotrace.c"
void at_color_free(at_color_type *color ) 
{ 


  {
  {
#line 437
  free((void *)color);
  }
#line 438
  return;
}
}
#line 440 "autotrace.c"
char const   *at_version(at_bool long_format ) 
{ 


  {
#line 443
  if (long_format) {
#line 444
    return ("AutoTrace version ");
  } else {
#line 446
    return ("");
  }
}
}
#line 449 "autotrace.c"
char const   *at_home_site(void) 
{ 


  {
#line 452
  return ("");
}
}
#line 10 "atou.c"
unsigned int atou(at_string s ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 13
  tmp = atoi((char const   *)s);
#line 13
  i = tmp;
  }
#line 15
  if (i < 0) {
    {
#line 16
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 16
      fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)stderr);
      }
      {
#line 16
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 16
        if (at_log_file) {
          {
#line 16
          fputs((char const   */* __restrict  */)"fatal: ", (FILE */* __restrict  */)at_log_file);
          }
        }
#line 16
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 16
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"I expected a positive number, not %d",
              i);
      }
      {
#line 16
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 16
        if (at_log_file) {
          {
#line 16
          fprintf((FILE */* __restrict  */)at_log_file, (char const   */* __restrict  */)"I expected a positive number, not %d",
                  i);
          }
        }
#line 16
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 16
      fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stderr);
#line 16
      exit(1);
      }
#line 16
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 18
  return ((unsigned int )i);
}
}

/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 46 "/usr/lib/llvm-10/lib/clang/10.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 32 "/usr/lib/llvm-10/lib/clang/10.0.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 14 "/home/kihong/gzip-1.2.4a/gzip.h"
typedef void *voidp;
#line 44 "/home/kihong/gzip-1.2.4a/gzip.h"
typedef unsigned char uch;
#line 45 "/home/kihong/gzip-1.2.4a/gzip.h"
typedef unsigned short ush;
#line 46 "/home/kihong/gzip-1.2.4a/gzip.h"
typedef unsigned long ulg;
#line 193 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 108 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 28 "/home/kihong/gzip-1.2.4a/unlzw.c"
typedef unsigned char char_type;
#line 29 "/home/kihong/gzip-1.2.4a/unlzw.c"
typedef long code_int;
#line 32 "/home/kihong/gzip-1.2.4a/unlzw.c"
typedef unsigned long cmp_code_int;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 121 "/home/kihong/gzip-1.2.4a/inflate.c"
union __anonunion_v_597249420 {
   ush n ;
   struct huft *t ;
};
#line 121 "/home/kihong/gzip-1.2.4a/inflate.c"
struct huft {
   uch e ;
   uch b ;
   union __anonunion_v_597249420 v ;
};
#line 151 "/home/kihong/gzip-1.2.4a/gzip.h"
typedef int file_t;
#line 160 "/home/kihong/gzip-1.2.4a/trees.c"
union __anonunion_fc_152553610 {
   ush freq ;
   ush code ;
};
#line 160 "/home/kihong/gzip-1.2.4a/trees.c"
union __anonunion_dl_152553611 {
   ush dad ;
   ush len ;
};
#line 160 "/home/kihong/gzip-1.2.4a/trees.c"
struct ct_data {
   union __anonunion_fc_152553610 fc ;
   union __anonunion_dl_152553611 dl ;
};
#line 160 "/home/kihong/gzip-1.2.4a/trees.c"
typedef struct ct_data ct_data;
#line 197 "/home/kihong/gzip-1.2.4a/trees.c"
struct tree_desc {
   ct_data *dyn_tree ;
   ct_data *static_tree ;
   int *extra_bits ;
   int extra_base ;
   int elems ;
   int max_length ;
   int max_code ;
};
#line 197 "/home/kihong/gzip-1.2.4a/trees.c"
typedef struct tree_desc tree_desc;
#line 128 "/home/kihong/gzip-1.2.4a/deflate.c"
typedef ush Pos;
#line 129 "/home/kihong/gzip-1.2.4a/deflate.c"
typedef unsigned int IPos;
#line 212 "/home/kihong/gzip-1.2.4a/deflate.c"
struct config {
   ush good_length ;
   ush max_lazy ;
   ush nice_length ;
   ush max_chain ;
};
#line 212 "/home/kihong/gzip-1.2.4a/deflate.c"
typedef struct config config;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 85 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 77 "/home/kihong/gzip-1.2.4a/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 87 "/home/kihong/gzip-1.2.4a/gzip.c"
typedef struct dirent dir_type;
#line 36 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 137 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 138
extern FILE *stdout ;
#line 341
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 347
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
#line 486
extern int getc(FILE *__stream ) ;
#line 492
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 499
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 500
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 510
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 522
extern int putc(int __c , FILE *__stream ) ;
#line 528
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 545
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 858
extern int __uflow(FILE * ) ;
#line 859
extern int __overflow(FILE * , int  ) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
#line 41
  return (tmp);
}
}
#line 46 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  {
#line 49
  tmp = getc(stdin);
  }
#line 49
  return (tmp);
}
}
#line 55 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 58
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 58
  if (tmp___3) {
    {
#line 58
    tmp___0 = __uflow(__fp);
#line 58
    tmp___2 = tmp___0;
    }
  } else {
#line 58
    tmp___1 = __fp->_IO_read_ptr;
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 58
  return (tmp___2);
}
}
#line 72 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 75
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  }
#line 75
  if (tmp___3) {
    {
#line 75
    tmp___0 = __uflow(stdin);
#line 75
    tmp___2 = tmp___0;
    }
  } else {
#line 75
    tmp___1 = stdin->_IO_read_ptr;
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 75
  return (tmp___2);
}
}
#line 81 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  {
#line 84
  tmp = putc(__c, stdout);
  }
#line 84
  return (tmp);
}
}
#line 90 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 93
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  }
#line 93
  if (tmp___4) {
    {
#line 93
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp___3 = tmp___0;
    }
  } else {
#line 93
    tmp___1 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    tmp___2 = (char )__c;
#line 93
    *tmp___1 = tmp___2;
#line 93
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 93
  return (tmp___3);
}
}
#line 107 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 110
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  }
#line 110
  if (tmp___4) {
    {
#line 110
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp___3 = tmp___0;
    }
  } else {
#line 110
    tmp___1 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    tmp___2 = (char )__c;
#line 110
    *tmp___1 = tmp___2;
#line 110
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 110
  return (tmp___3);
}
}
#line 127
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 127 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 134
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 134 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 115 "/home/kihong/gzip-1.2.4a/gzip.h"
uch inbuf[32832] ;
#line 116
uch outbuf[18432] ;
#line 117
ush d_buf[32768] ;
#line 118
uch window[65536L] ;
#line 123
ush prev[1L << 16] ;
#line 131
unsigned int insize ;
#line 132
unsigned int inptr ;
#line 142
int ifd ;
#line 143
int ofd ;
#line 198
int test ;
#line 273
int unlzh(int in , int out ) ;
#line 299
int fill_inbuf(int eof_ok ) ;
#line 302
void write_buf(int fd , voidp buf , unsigned int cnt ) ;
#line 307
void error(char *m ) ;
#line 18 "/home/kihong/gzip-1.2.4a/unlzh.c"
static unsigned int decode(unsigned int count , uch *buffer ) ;
#line 19
static void decode_start(void) ;
#line 22
static void huf_decode_start(void) ;
#line 23
static unsigned int decode_c(void) ;
#line 24
static unsigned int decode_p(void) ;
#line 25
static void read_pt_len(int nn , int nbit , int i_special ) ;
#line 26
static void read_c_len(void) ;
#line 29
static void fillbuf(int n ) ;
#line 30
static unsigned int getbits(int n ) ;
#line 31
static void init_getbits(void) ;
#line 35
static void make_table(int nchar , uch *bitlen , int tablebits , ush *table ) ;
#line 91 "/home/kihong/gzip-1.2.4a/unlzh.c"
static uch pt_len[19]  ;
#line 92 "/home/kihong/gzip-1.2.4a/unlzh.c"
static unsigned int blocksize  ;
#line 93 "/home/kihong/gzip-1.2.4a/unlzh.c"
static ush pt_table[256]  ;
#line 105 "/home/kihong/gzip-1.2.4a/unlzh.c"
static ush bitbuf  ;
#line 106 "/home/kihong/gzip-1.2.4a/unlzh.c"
static unsigned int subbitbuf  ;
#line 107 "/home/kihong/gzip-1.2.4a/unlzh.c"
static int bitcount  ;
#line 109 "/home/kihong/gzip-1.2.4a/unlzh.c"
static void fillbuf(int n ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 112
  bitbuf = (ush )((int )bitbuf << n);
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (n > bitcount)) {
#line 113
      goto while_break;
    }
#line 114
    n -= bitcount;
#line 114
    bitbuf = (ush )((unsigned int )bitbuf | (subbitbuf << n));
#line 115
    if (inptr < insize) {
#line 115
      tmp = inptr;
#line 115
      inptr ++;
#line 115
      tmp___1 = (int )inbuf[tmp];
    } else {
      {
#line 115
      tmp___0 = fill_inbuf(1);
#line 115
      tmp___1 = tmp___0;
      }
    }
#line 115
    subbitbuf = (unsigned int )tmp___1;
#line 116
    if ((int )subbitbuf == -1) {
#line 116
      subbitbuf = 0U;
    }
#line 117
    bitcount = 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  bitcount -= n;
#line 119
  bitbuf = (ush )((unsigned int )bitbuf | (subbitbuf >> bitcount));
#line 120
  return;
}
}
#line 122 "/home/kihong/gzip-1.2.4a/unlzh.c"
static unsigned int getbits(int n ) 
{ 
  unsigned int x ;

  {
  {
#line 127
  x = (unsigned int )((int )bitbuf >> (16UL * sizeof(char ) - (unsigned long )n));
#line 127
  fillbuf(n);
  }
#line 128
  return (x);
}
}
#line 131 "/home/kihong/gzip-1.2.4a/unlzh.c"
static void init_getbits(void) 
{ 


  {
  {
#line 133
  bitbuf = (ush )0;
#line 133
  subbitbuf = 0U;
#line 133
  bitcount = 0;
#line 134
  fillbuf((int )(16UL * sizeof(char )));
  }
#line 135
  return;
}
}
#line 141 "/home/kihong/gzip-1.2.4a/unlzh.c"
static void make_table(int nchar , uch *bitlen , int tablebits , ush *table ) 
{ 
  ush count[17] ;
  ush weight[17] ;
  ush start[18] ;
  ush *p ;
  unsigned int i___0 ;
  unsigned int k ;
  unsigned int len ;
  unsigned int ch ;
  unsigned int jutbits ;
  unsigned int avail ;
  unsigned int nextcode ;
  unsigned int mask ;
  unsigned int tmp ;
  ush tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 150
  i___0 = 1U;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i___0 <= 16U)) {
#line 150
      goto while_break;
    }
#line 150
    count[i___0] = (ush )0;
#line 150
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  i___0 = 0U;
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! (i___0 < (unsigned int )nchar)) {
#line 151
      goto while_break___0;
    }
#line 151
    count[*(bitlen + i___0)] = (ush )((int )count[*(bitlen + i___0)] + 1);
#line 151
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  start[1] = (ush )0;
#line 154
  i___0 = 1U;
  {
#line 154
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 154
    if (! (i___0 <= 16U)) {
#line 154
      goto while_break___1;
    }
#line 155
    start[i___0 + 1U] = (ush )((int )start[i___0] + ((int )count[i___0] << (16U - i___0)));
#line 154
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 156
  if (((int )start[17] & 65535) != 0) {
    {
#line 157
    error((char *)"Bad table\n");
    }
  }
#line 159
  jutbits = (unsigned int )(16 - tablebits);
#line 160
  i___0 = 1U;
  {
#line 160
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 160
    if (! (i___0 <= (unsigned int )tablebits)) {
#line 160
      goto while_break___2;
    }
#line 161
    start[i___0] = (ush )((int )start[i___0] >> jutbits);
#line 162
    weight[i___0] = (ush )(1U << ((unsigned int )tablebits - i___0));
#line 160
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 164
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 164
    if (! (i___0 <= 16U)) {
#line 164
      goto while_break___3;
    }
#line 165
    weight[i___0] = (ush )(1U << (16U - i___0));
#line 166
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 169
  i___0 = (unsigned int )((int )start[tablebits + 1] >> jutbits);
#line 170
  if (i___0 != 0U) {
#line 171
    k = (unsigned int )(1 << tablebits);
    {
#line 172
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 172
      if (! (i___0 != k)) {
#line 172
        goto while_break___4;
      }
#line 172
      tmp = i___0;
#line 172
      i___0 ++;
#line 172
      *(table + tmp) = (ush )0;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 175
  avail = (unsigned int )nchar;
#line 176
  mask = 1U << (15 - tablebits);
#line 177
  ch = 0U;
  {
#line 177
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 177
    if (! (ch < (unsigned int )nchar)) {
#line 177
      goto while_break___5;
    }
#line 178
    len = (unsigned int )*(bitlen + ch);
#line 178
    if (len == 0U) {
#line 178
      goto __Cont;
    }
#line 179
    nextcode = (unsigned int )((int )start[len] + (int )weight[len]);
#line 180
    if (len <= (unsigned int )tablebits) {
#line 181
      i___0 = (unsigned int )start[len];
      {
#line 181
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 181
        if (! (i___0 < nextcode)) {
#line 181
          goto while_break___6;
        }
#line 181
        *(table + i___0) = (ush )ch;
#line 181
        i___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
#line 183
      k = (unsigned int )start[len];
#line 184
      p = table + (k >> jutbits);
#line 185
      i___0 = len - (unsigned int )tablebits;
      {
#line 186
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 186
        if (! (i___0 != 0U)) {
#line 186
          goto while_break___7;
        }
#line 187
        if ((int )*p == 0) {
#line 188
          tmp___0 = (ush )0;
#line 188
          prev[avail] = tmp___0;
#line 188
          *((prev + 32768) + avail) = tmp___0;
#line 189
          tmp___1 = avail;
#line 189
          avail ++;
#line 189
          *p = (ush )tmp___1;
        }
#line 191
        if (k & mask) {
#line 191
          p = (prev + 32768) + *p;
        } else {
#line 192
          p = & prev[*p];
        }
#line 193
        k <<= 1;
#line 193
        i___0 --;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 195
      *p = (ush )ch;
    }
#line 197
    start[len] = (ush )nextcode;
    __Cont: /* CIL Label */ 
#line 177
    ch ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 199
  return;
}
}
#line 205 "/home/kihong/gzip-1.2.4a/unlzh.c"
static void read_pt_len(int nn , int nbit , int i_special ) 
{ 
  int i___0 ;
  int c ;
  int n ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 213
  tmp = getbits(nbit);
#line 213
  n = (int )tmp;
  }
#line 214
  if (n == 0) {
    {
#line 215
    tmp___0 = getbits(nbit);
#line 215
    c = (int )tmp___0;
#line 216
    i___0 = 0;
    }
    {
#line 216
    while (1) {
      while_continue: /* CIL Label */ ;
#line 216
      if (! (i___0 < nn)) {
#line 216
        goto while_break;
      }
#line 216
      pt_len[i___0] = (uch )0;
#line 216
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 217
    i___0 = 0;
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 217
      if (! (i___0 < 256)) {
#line 217
        goto while_break___0;
      }
#line 217
      pt_table[i___0] = (ush )c;
#line 217
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 219
    i___0 = 0;
    {
#line 220
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 220
      if (! (i___0 < n)) {
#line 220
        goto while_break___1;
      }
#line 221
      c = (int )bitbuf >> (16UL * sizeof(char ) - 3UL);
#line 222
      if (c == 7) {
#line 223
        mask = 1U << ((16UL * sizeof(char ) - 1UL) - 3UL);
        {
#line 224
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 224
          if (! (mask & (unsigned int )bitbuf)) {
#line 224
            goto while_break___2;
          }
#line 224
          mask >>= 1;
#line 224
          c ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 226
      if (c < 7) {
#line 226
        tmp___1 = 3;
      } else {
#line 226
        tmp___1 = c - 3;
      }
      {
#line 226
      fillbuf(tmp___1);
#line 227
      tmp___2 = i___0;
#line 227
      i___0 ++;
#line 227
      pt_len[tmp___2] = (uch )c;
      }
#line 228
      if (i___0 == i_special) {
        {
#line 229
        tmp___3 = getbits(2);
#line 229
        c = (int )tmp___3;
        }
        {
#line 230
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 230
          c --;
#line 230
          if (! (c >= 0)) {
#line 230
            goto while_break___3;
          }
#line 230
          tmp___4 = i___0;
#line 230
          i___0 ++;
#line 230
          pt_len[tmp___4] = (uch )0;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 233
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 233
      if (! (i___0 < nn)) {
#line 233
        goto while_break___4;
      }
#line 233
      tmp___5 = i___0;
#line 233
      i___0 ++;
#line 233
      pt_len[tmp___5] = (uch )0;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 234
    make_table(nn, pt_len, 8, pt_table);
    }
  }
#line 236
  return;
}
}
#line 238 "/home/kihong/gzip-1.2.4a/unlzh.c"
static void read_c_len(void) 
{ 
  int i___0 ;
  int c ;
  int n ;
  unsigned int mask ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 243
  tmp = getbits(9);
#line 243
  n = (int )tmp;
  }
#line 244
  if (n == 0) {
    {
#line 245
    tmp___0 = getbits(9);
#line 245
    c = (int )tmp___0;
#line 246
    i___0 = 0;
    }
    {
#line 246
    while (1) {
      while_continue: /* CIL Label */ ;
#line 246
      if (! (i___0 < 510)) {
#line 246
        goto while_break;
      }
#line 246
      outbuf[i___0] = (uch )0;
#line 246
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 247
    i___0 = 0;
    {
#line 247
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 247
      if (! (i___0 < 4096)) {
#line 247
        goto while_break___0;
      }
#line 247
      d_buf[i___0] = (ush )c;
#line 247
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 249
    i___0 = 0;
    {
#line 250
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 250
      if (! (i___0 < n)) {
#line 250
        goto while_break___1;
      }
#line 251
      c = (int )pt_table[(int )bitbuf >> (16UL * sizeof(char ) - 8UL)];
#line 252
      if (c >= 19) {
#line 253
        mask = 1U << ((16UL * sizeof(char ) - 1UL) - 8UL);
        {
#line 254
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 255
          if ((unsigned int )bitbuf & mask) {
#line 255
            c = (int )*((prev + 32768) + c);
          } else {
#line 256
            c = (int )prev[c];
          }
#line 257
          mask >>= 1;
#line 254
          if (! (c >= 19)) {
#line 254
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 260
      fillbuf((int )pt_len[c]);
      }
#line 261
      if (c <= 2) {
#line 262
        if (c == 0) {
#line 262
          c = 1;
        } else
#line 263
        if (c == 1) {
          {
#line 263
          tmp___1 = getbits(4);
#line 263
          c = (int )(tmp___1 + 3U);
          }
        } else {
          {
#line 264
          tmp___2 = getbits(9);
#line 264
          c = (int )(tmp___2 + 20U);
          }
        }
        {
#line 265
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 265
          c --;
#line 265
          if (! (c >= 0)) {
#line 265
            goto while_break___3;
          }
#line 265
          tmp___3 = i___0;
#line 265
          i___0 ++;
#line 265
          outbuf[tmp___3] = (uch )0;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 266
        tmp___4 = i___0;
#line 266
        i___0 ++;
#line 266
        outbuf[tmp___4] = (uch )(c - 2);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 268
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 268
      if (! (i___0 < 510)) {
#line 268
        goto while_break___4;
      }
#line 268
      tmp___5 = i___0;
#line 268
      i___0 ++;
#line 268
      outbuf[tmp___5] = (uch )0;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 269
    make_table(510, outbuf, 12, d_buf);
    }
  }
#line 271
  return;
}
}
#line 273 "/home/kihong/gzip-1.2.4a/unlzh.c"
static unsigned int decode_c(void) 
{ 
  unsigned int j___0 ;
  unsigned int mask ;

  {
#line 277
  if (blocksize == 0U) {
    {
#line 278
    blocksize = getbits(16);
    }
#line 279
    if (blocksize == 0U) {
#line 280
      return (510U);
    }
    {
#line 282
    read_pt_len(19, 5, 3);
#line 283
    read_c_len();
#line 284
    read_pt_len(14, 4, -1);
    }
  }
#line 286
  blocksize --;
#line 287
  j___0 = (unsigned int )d_buf[(int )bitbuf >> (16UL * sizeof(char ) - 12UL)];
#line 288
  if (j___0 >= 510U) {
#line 289
    mask = 1U << ((16UL * sizeof(char ) - 1UL) - 12UL);
    {
#line 290
    while (1) {
      while_continue: /* CIL Label */ ;
#line 291
      if ((unsigned int )bitbuf & mask) {
#line 291
        j___0 = (unsigned int )*((prev + 32768) + j___0);
      } else {
#line 292
        j___0 = (unsigned int )prev[j___0];
      }
#line 293
      mask >>= 1;
#line 290
      if (! (j___0 >= 510U)) {
#line 290
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 296
  fillbuf((int )outbuf[j___0]);
  }
#line 297
  return (j___0);
}
}
#line 300 "/home/kihong/gzip-1.2.4a/unlzh.c"
static unsigned int decode_p(void) 
{ 
  unsigned int j___0 ;
  unsigned int mask ;
  unsigned int tmp ;

  {
#line 304
  j___0 = (unsigned int )pt_table[(int )bitbuf >> (16UL * sizeof(char ) - 8UL)];
#line 305
  if (j___0 >= 14U) {
#line 306
    mask = 1U << ((16UL * sizeof(char ) - 1UL) - 8UL);
    {
#line 307
    while (1) {
      while_continue: /* CIL Label */ ;
#line 308
      if ((unsigned int )bitbuf & mask) {
#line 308
        j___0 = (unsigned int )*((prev + 32768) + j___0);
      } else {
#line 309
        j___0 = (unsigned int )prev[j___0];
      }
#line 310
      mask >>= 1;
#line 307
      if (! (j___0 >= 14U)) {
#line 307
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 313
  fillbuf((int )pt_len[j___0]);
  }
#line 314
  if (j___0 != 0U) {
    {
#line 314
    tmp = getbits((int )(j___0 - 1U));
#line 314
    j___0 = (1U << (j___0 - 1U)) + tmp;
    }
  }
#line 315
  return (j___0);
}
}
#line 318 "/home/kihong/gzip-1.2.4a/unlzh.c"
static void huf_decode_start(void) 
{ 


  {
  {
#line 320
  init_getbits();
#line 320
  blocksize = 0U;
  }
#line 321
  return;
}
}
#line 327 "/home/kihong/gzip-1.2.4a/unlzh.c"
static int j  ;
#line 328 "/home/kihong/gzip-1.2.4a/unlzh.c"
static int done  ;
#line 330 "/home/kihong/gzip-1.2.4a/unlzh.c"
static void decode_start(void) 
{ 


  {
  {
#line 332
  huf_decode_start();
#line 333
  j = 0;
#line 334
  done = 0;
  }
#line 335
  return;
}
}
#line 351 "/home/kihong/gzip-1.2.4a/unlzh.c"
static unsigned int i  ;
#line 339 "/home/kihong/gzip-1.2.4a/unlzh.c"
static unsigned int decode(unsigned int count , uch *buffer ) 
{ 
  unsigned int r ;
  unsigned int c ;
  unsigned int tmp ;

  {
#line 354
  r = 0U;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    j --;
#line 355
    if (! (j >= 0)) {
#line 355
      goto while_break;
    }
#line 356
    *(buffer + r) = *(buffer + i);
#line 357
    i = (i + 1U) & ((1U << 13) - 1U);
#line 358
    r ++;
#line 358
    if (r == count) {
#line 358
      return (r);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 361
    c = decode_c();
    }
#line 362
    if (c == 510U) {
#line 363
      done = 1;
#line 364
      return (r);
    }
#line 366
    if (c <= 255U) {
#line 367
      *(buffer + r) = (uch )c;
#line 368
      r ++;
#line 368
      if (r == count) {
#line 368
        return (r);
      }
    } else {
      {
#line 370
      j = (int )(c - 253U);
#line 371
      tmp = decode_p();
#line 371
      i = ((r - tmp) - 1U) & ((1U << 13) - 1U);
      }
      {
#line 372
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 372
        j --;
#line 372
        if (! (j >= 0)) {
#line 372
          goto while_break___1;
        }
#line 373
        *(buffer + r) = *(buffer + i);
#line 374
        i = (i + 1U) & ((1U << 13) - 1U);
#line 375
        r ++;
#line 375
        if (r == count) {
#line 375
          return (r);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 385 "/home/kihong/gzip-1.2.4a/unlzh.c"
int unlzh(int in , int out ) 
{ 
  unsigned int n ;

  {
  {
#line 390
  ifd = in;
#line 391
  ofd = out;
#line 393
  decode_start();
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (! done)) {
#line 394
      goto while_break;
    }
    {
#line 395
    n = decode(1U << 13, window);
    }
#line 396
    if (! test) {
#line 396
      if (n > 0U) {
        {
#line 397
        write_buf(out, (voidp )((char *)(window)), n);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return (0);
}
}
#line 133 "/home/kihong/gzip-1.2.4a/gzip.h"
unsigned int outcnt ;
#line 136
long bytes_out ;
#line 270
int unpack(int in , int out ) ;
#line 301
void flush_window(void) ;
#line 32 "/home/kihong/gzip-1.2.4a/unpack.c"
static ulg orig_len  ;
#line 33 "/home/kihong/gzip-1.2.4a/unpack.c"
static int max_len  ;
#line 35 "/home/kihong/gzip-1.2.4a/unpack.c"
static uch literal[256]  ;
#line 40 "/home/kihong/gzip-1.2.4a/unpack.c"
static int lit_base[26]  ;
#line 46 "/home/kihong/gzip-1.2.4a/unpack.c"
static int leaves[26]  ;
#line 47 "/home/kihong/gzip-1.2.4a/unpack.c"
static int parents[26]  ;
#line 49 "/home/kihong/gzip-1.2.4a/unpack.c"
static int peek_bits  ;
#line 64 "/home/kihong/gzip-1.2.4a/unpack.c"
static ulg bitbuf___0  ;
#line 67 "/home/kihong/gzip-1.2.4a/unpack.c"
static int valid  ;
#line 88
static void read_tree(void) ;
#line 89
static void build_tree(void) ;
#line 94 "/home/kihong/gzip-1.2.4a/unpack.c"
static void read_tree(void) 
{ 
  int len ;
  int base ;
  int n ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 101
  orig_len = (ulg )0;
#line 102
  n = 1;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (n <= 4)) {
#line 102
      goto while_break;
    }
#line 102
    if (inptr < insize) {
#line 102
      tmp = inptr;
#line 102
      inptr ++;
#line 102
      tmp___1 = (int )inbuf[tmp];
    } else {
      {
#line 102
      tmp___0 = fill_inbuf(0);
#line 102
      tmp___1 = tmp___0;
      }
    }
#line 102
    orig_len = (orig_len << 8) | (ulg )tmp___1;
#line 102
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (inptr < insize) {
#line 104
    tmp___2 = inptr;
#line 104
    inptr ++;
#line 104
    tmp___4 = (int )inbuf[tmp___2];
  } else {
    {
#line 104
    tmp___3 = fill_inbuf(0);
#line 104
    tmp___4 = tmp___3;
    }
  }
#line 104
  max_len = tmp___4;
#line 105
  if (max_len > 25) {
    {
#line 106
    error((char *)"invalid compressed data -- Huffman code > 32 bits");
    }
  }
#line 110
  n = 0;
#line 111
  len = 1;
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (len <= max_len)) {
#line 111
      goto while_break___0;
    }
#line 112
    if (inptr < insize) {
#line 112
      tmp___5 = inptr;
#line 112
      inptr ++;
#line 112
      tmp___7 = (int )inbuf[tmp___5];
    } else {
      {
#line 112
      tmp___6 = fill_inbuf(0);
#line 112
      tmp___7 = tmp___6;
      }
    }
#line 112
    leaves[len] = tmp___7;
#line 113
    n += leaves[len];
#line 111
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 115
  if (n > 256) {
    {
#line 116
    error((char *)"too many leaves in Huffman tree");
    }
  }
#line 127
  (leaves[max_len]) ++;
#line 130
  base = 0;
#line 131
  len = 1;
  {
#line 131
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 131
    if (! (len <= max_len)) {
#line 131
      goto while_break___1;
    }
#line 133
    lit_base[len] = base;
#line 135
    n = leaves[len];
    {
#line 135
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 135
      if (! (n > 0)) {
#line 135
        goto while_break___2;
      }
#line 136
      tmp___8 = base;
#line 136
      base ++;
#line 136
      if (inptr < insize) {
#line 136
        tmp___9 = inptr;
#line 136
        inptr ++;
#line 136
        tmp___11 = (int )inbuf[tmp___9];
      } else {
        {
#line 136
        tmp___10 = fill_inbuf(0);
#line 136
        tmp___11 = tmp___10;
        }
      }
#line 136
      literal[tmp___8] = (uch )tmp___11;
#line 135
      n --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 131
    len ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 139
  (leaves[max_len]) ++;
#line 140
  return;
}
}
#line 145 "/home/kihong/gzip-1.2.4a/unpack.c"
static void build_tree(void) 
{ 
  int nodes ;
  int len ;
  uch *prefixp ;
  int prefixes ;
  int tmp ;

  {
#line 147
  nodes = 0;
#line 151
  len = max_len;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (len >= 1)) {
#line 151
      goto while_break;
    }
#line 155
    nodes >>= 1;
#line 156
    parents[len] = nodes;
#line 160
    lit_base[len] -= nodes;
#line 162
    nodes += leaves[len];
#line 151
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  if (max_len <= 12) {
#line 167
    peek_bits = max_len;
  } else {
#line 167
    peek_bits = 12;
  }
#line 168
  prefixp = & outbuf[1 << peek_bits];
#line 169
  len = 1;
  {
#line 169
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 169
    if (! (len <= peek_bits)) {
#line 169
      goto while_break___0;
    }
#line 170
    prefixes = leaves[len] << (peek_bits - len);
    {
#line 171
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 171
      tmp = prefixes;
#line 171
      prefixes --;
#line 171
      if (! tmp) {
#line 171
        goto while_break___1;
      }
#line 171
      prefixp --;
#line 171
      *prefixp = (uch )len;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 169
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 174
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 174
    if (! ((unsigned long )prefixp > (unsigned long )(outbuf))) {
#line 174
      goto while_break___2;
    }
#line 174
    prefixp --;
#line 174
    *prefixp = (uch )0;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 185 "/home/kihong/gzip-1.2.4a/unpack.c"
int unpack(int in , int out ) 
{ 
  int len ;
  unsigned int eob ;
  register unsigned int peek ;
  unsigned int peek_mask ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ulg mask ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;

  {
  {
#line 193
  ifd = in;
#line 194
  ofd = out;
#line 196
  read_tree();
#line 197
  build_tree();
#line 198
  valid = 0;
#line 198
  bitbuf___0 = (ulg )0;
#line 199
  peek_mask = (unsigned int )((1 << peek_bits) - 1);
#line 202
  eob = (unsigned int )(leaves[max_len] - 1);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 211
      if (! (valid < peek_bits)) {
#line 211
        goto while_break___0;
      }
#line 211
      if (inptr < insize) {
#line 211
        tmp = inptr;
#line 211
        inptr ++;
#line 211
        tmp___1 = (int )inbuf[tmp];
      } else {
        {
#line 211
        tmp___0 = fill_inbuf(0);
#line 211
        tmp___1 = tmp___0;
        }
      }
#line 211
      bitbuf___0 = (bitbuf___0 << 8) | (ulg )tmp___1;
#line 211
      valid += 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 211
    peek = (unsigned int )((bitbuf___0 >> (valid - peek_bits)) & (unsigned long )peek_mask);
#line 212
    len = (int )outbuf[peek];
#line 213
    if (len > 0) {
#line 214
      peek >>= peek_bits - len;
    } else {
#line 217
      mask = (ulg )peek_mask;
#line 218
      len = peek_bits;
      {
#line 219
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 220
        len ++;
#line 220
        mask = (mask << 1) + 1UL;
        {
#line 221
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 221
          if (! (valid < len)) {
#line 221
            goto while_break___2;
          }
#line 221
          if (inptr < insize) {
#line 221
            tmp___2 = inptr;
#line 221
            inptr ++;
#line 221
            tmp___4 = (int )inbuf[tmp___2];
          } else {
            {
#line 221
            tmp___3 = fill_inbuf(0);
#line 221
            tmp___4 = tmp___3;
            }
          }
#line 221
          bitbuf___0 = (bitbuf___0 << 8) | (ulg )tmp___4;
#line 221
          valid += 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 221
        peek = (unsigned int )((bitbuf___0 >> (valid - len)) & mask);
#line 219
        if (! (peek < (unsigned int )parents[len])) {
#line 219
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 226
    if (peek == eob) {
#line 226
      if (len == max_len) {
#line 226
        goto while_break;
      }
    }
#line 227
    tmp___5 = outcnt;
#line 227
    outcnt ++;
#line 227
    window[tmp___5] = literal[peek + (unsigned int )lit_base[len]];
#line 227
    if (outcnt == 32768U) {
      {
#line 227
      flush_window();
      }
    }
#line 230
    valid -= len;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  flush_window();
  }
#line 235
  if (orig_len != (ulg )bytes_out) {
    {
#line 236
    error((char *)"invalid compressed data--length error");
    }
  }
#line 238
  return (0);
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 139 "/usr/include/stdio.h"
extern FILE *stderr ;
#line 326
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 61
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 135 "/home/kihong/gzip-1.2.4a/gzip.h"
long bytes_in ;
#line 144
char ifname[1024] ;
#line 146
char *progname ;
#line 194
int exit_code ;
#line 196
int quiet ;
#line 199
int to_stdout ;
#line 309
void read_error(void) ;
#line 38 "/home/kihong/gzip-1.2.4a/lzw.h"
int maxbits ;
#line 39
int block_mode ;
#line 42
int unlzw(int in , int out ) ;
#line 181 "/home/kihong/gzip-1.2.4a/unlzw.c"
int block_mode  =    128;
#line 192 "/home/kihong/gzip-1.2.4a/unlzw.c"
int unlzw(int in , int out ) 
{ 
  register char_type *stackp ;
  code_int code ;
  int finchar ;
  code_int oldcode ;
  code_int incode ;
  long inbits ;
  long posbits ;
  int outpos ;
  unsigned int bitmask ;
  code_int free_ent ;
  code_int maxcode ;
  code_int maxmaxcode ;
  int n_bits ;
  int rsize ;
  unsigned int tmp ;
  int tmp___0 ;
  register int i___0 ;
  int e ;
  int o ;
  ssize_t tmp___1 ;
  register char_type *p ;
  int tmp___2 ;
  char const   *tmp___3 ;
  register int i___1 ;

  {
#line 215
  if (inptr < insize) {
#line 215
    tmp = inptr;
#line 215
    inptr ++;
#line 215
    maxbits = (int )inbuf[tmp];
  } else {
    {
#line 215
    tmp___0 = fill_inbuf(0);
#line 215
    maxbits = tmp___0;
    }
  }
#line 216
  block_mode = maxbits & 128;
#line 217
  if ((maxbits & 96) != 0) {
#line 218
    if (! quiet) {
      {
#line 218
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: warning, unknown flags 0x%x\n",
              progname, ifname, maxbits & 96);
      }
    }
#line 218
    if (exit_code == 0) {
#line 218
      exit_code = 2;
    }
  }
#line 221
  maxbits &= 31;
#line 222
  maxmaxcode = 1L << maxbits;
#line 224
  if (maxbits > 16) {
    {
#line 225
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: compressed with %d bits, can only handle %d bits\n",
            progname, ifname, maxbits, 16);
#line 228
    exit_code = 1;
    }
#line 229
    return (1);
  }
#line 231
  rsize = (int )insize;
#line 232
  n_bits = 9;
#line 232
  maxcode = (1L << n_bits) - 1L;
#line 233
  bitmask = (unsigned int )((1 << n_bits) - 1);
#line 234
  oldcode = (code_int )-1;
#line 235
  finchar = 0;
#line 236
  outpos = 0;
#line 237
  posbits = (long )(inptr << 3);
#line 239
  if (block_mode) {
#line 239
    free_ent = (code_int )257;
  } else {
#line 239
    free_ent = (code_int )256;
  }
  {
#line 241
  memset((voidp )(prev), 0, (size_t )256);
#line 243
  code = (code_int )255;
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (code >= 0L)) {
#line 243
      goto while_break;
    }
#line 244
    window[code] = (char_type )code;
#line 243
    code --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
    resetbuf: 
#line 252
    o = (int )(posbits >> 3);
#line 252
    e = (int )(insize - (unsigned int )o);
#line 254
    i___0 = 0;
    {
#line 254
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 254
      if (! (i___0 < e)) {
#line 254
        goto while_break___1;
      }
#line 255
      inbuf[i___0] = inbuf[i___0 + o];
#line 254
      i___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 257
    insize = (unsigned int )e;
#line 258
    posbits = 0L;
#line 260
    if (insize < 64U) {
      {
#line 261
      tmp___1 = read(in, (void *)((char *)(inbuf) + insize), (size_t )32768);
#line 261
      rsize = (int )tmp___1;
      }
#line 261
      if (rsize == -1) {
        {
#line 262
        read_error();
        }
      }
#line 264
      insize += (unsigned int )rsize;
#line 265
      bytes_in = (long )((ulg )bytes_in + (ulg )rsize);
    }
#line 267
    if (rsize != 0) {
#line 267
      inbits = ((long )insize - (long )(insize % (unsigned int )n_bits)) << 3;
    } else {
#line 267
      inbits = ((long )insize << 3) - (long )(n_bits - 1);
    }
    {
#line 270
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 270
      if (! (inbits > posbits)) {
#line 270
        goto while_break___2;
      }
#line 271
      if (free_ent > maxcode) {
#line 272
        posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
#line 274
        n_bits ++;
#line 275
        if (n_bits == maxbits) {
#line 276
          maxcode = maxmaxcode;
        } else {
#line 278
          maxcode = (1L << n_bits) - 1L;
        }
#line 280
        bitmask = (unsigned int )((1 << n_bits) - 1);
#line 281
        goto resetbuf;
      }
#line 283
      p = & inbuf[posbits >> 3];
#line 283
      code = ((((long )*(p + 0) | ((long )*(p + 1) << 8)) | ((long )*(p + 2) << 16)) >> (posbits & 7L)) & (long )bitmask;
#line 283
      posbits += (long )n_bits;
#line 286
      if (oldcode == -1L) {
#line 287
        if (code >= 256L) {
          {
#line 287
          error((char *)"corrupt input.");
          }
        }
#line 288
        tmp___2 = outpos;
#line 288
        outpos ++;
#line 288
        oldcode = code;
#line 288
        finchar = (int )oldcode;
#line 288
        outbuf[tmp___2] = (char_type )finchar;
#line 289
        goto while_continue___2;
      }
#line 291
      if (code == 256L) {
#line 291
        if (block_mode) {
          {
#line 292
          memset((voidp )(prev), 0, (size_t )256);
#line 293
          free_ent = (code_int )256;
#line 294
          posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
#line 296
          n_bits = 9;
#line 296
          maxcode = (1L << n_bits) - 1L;
#line 297
          bitmask = (unsigned int )((1 << n_bits) - 1);
          }
#line 298
          goto resetbuf;
        }
      }
#line 300
      incode = code;
#line 301
      stackp = (char_type *)(& d_buf[32767]);
#line 303
      if (code >= free_ent) {
#line 304
        if (code > free_ent) {
#line 317
          if (! test) {
#line 317
            if (outpos > 0) {
              {
#line 318
              write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
#line 319
              bytes_out = (long )((ulg )bytes_out + (ulg )outpos);
              }
            }
          }
#line 321
          if (to_stdout) {
#line 321
            tmp___3 = "corrupt input.";
          } else {
#line 321
            tmp___3 = "corrupt input. Use zcat to recover some data.";
          }
          {
#line 321
          error((char *)tmp___3);
          }
        }
#line 324
        stackp --;
#line 324
        *stackp = (char_type )finchar;
#line 325
        code = oldcode;
      }
      {
#line 328
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 328
        if (! ((cmp_code_int )code >= 256UL)) {
#line 328
          goto while_break___3;
        }
#line 330
        stackp --;
#line 330
        *stackp = window[code];
#line 331
        code = (code_int )prev[code];
      }
      while_break___3: /* CIL Label */ ;
      }
#line 333
      stackp --;
#line 333
      finchar = (int )window[code];
#line 333
      *stackp = (char_type )finchar;
#line 339
      i___1 = (int )((char_type *)(& d_buf[32767]) - stackp);
#line 339
      if (outpos + i___1 >= 16384) {
        {
#line 340
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 341
          if (i___1 > 16384 - outpos) {
#line 341
            i___1 = 16384 - outpos;
          }
#line 343
          if (i___1 > 0) {
            {
#line 344
            memcpy((void */* __restrict  */)(outbuf + outpos), (void const   */* __restrict  */)stackp,
                   (size_t )i___1);
#line 345
            outpos += i___1;
            }
          }
#line 347
          if (outpos >= 16384) {
#line 348
            if (! test) {
              {
#line 349
              write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
#line 350
              bytes_out = (long )((ulg )bytes_out + (ulg )outpos);
              }
            }
#line 352
            outpos = 0;
          }
#line 354
          stackp += i___1;
#line 340
          i___1 = (int )((char_type *)(& d_buf[32767]) - stackp);
#line 340
          if (! (i___1 > 0)) {
#line 340
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
        {
#line 357
        memcpy((void */* __restrict  */)(outbuf + outpos), (void const   */* __restrict  */)stackp,
               (size_t )i___1);
#line 358
        outpos += i___1;
        }
      }
#line 362
      code = free_ent;
#line 362
      if (code < maxmaxcode) {
#line 364
        prev[code] = (unsigned short )oldcode;
#line 365
        window[code] = (char_type )finchar;
#line 366
        free_ent = code + 1L;
      }
#line 368
      oldcode = incode;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 246
    if (! (rsize != 0)) {
#line 246
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  if (! test) {
#line 372
    if (outpos > 0) {
      {
#line 373
      write_buf(out, (voidp )((char *)(outbuf)), (unsigned int )outpos);
#line 374
      bytes_out = (long )((ulg )bytes_out + (ulg )outpos);
      }
    }
  }
#line 376
  return (0);
}
}
#line 41 "/home/kihong/gzip-1.2.4a/lzw.h"
int lzw(int in , int out ) ;
#line 13 "/home/kihong/gzip-1.2.4a/lzw.c"
static int msg_done  =    0;
#line 16 "/home/kihong/gzip-1.2.4a/lzw.c"
int lzw(int in , int out ) 
{ 


  {
#line 19
  if (msg_done) {
#line 19
    return (1);
  }
  {
#line 20
  msg_done = 1;
#line 21
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output in compress .Z format not supported\n");
  }
#line 22
  if (in != out) {
#line 23
    exit_code = 1;
  }
#line 25
  return (1);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 206
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 206 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 209
  if (__c >= -128) {
#line 209
    if (__c < 256) {
      {
#line 209
      tmp = __ctype_tolower_loc();
#line 209
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 209
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 209
    tmp___0 = (__int32_t const   )__c;
  }
#line 209
  return ((int )tmp___0);
}
}
#line 212
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 212 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 215
  if (__c >= -128) {
#line 215
    if (__c < 256) {
      {
#line 215
      tmp = __ctype_toupper_loc();
#line 215
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 215
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 215
    tmp___0 = (__int32_t const   )__c;
  }
#line 215
  return ((int )tmp___0);
}
}
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 117
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
#line 360
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 360 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
#line 363
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 363
  return ((int )tmp);
}
}
#line 365
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 365 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
#line 368
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 368
  return (tmp);
}
}
#line 372
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 372 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  {
#line 375
  tmp = strtoll((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
                10);
  }
#line 375
  return (tmp);
}
}
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 542
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 565
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 634
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 820
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
#line 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  {
#line 27
  tmp = strtod((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)));
  }
#line 27
  return (tmp);
}
}
#line 775 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 122 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 253
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 273
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 277
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 385
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 145 "/home/kihong/gzip-1.2.4a/gzip.h"
char ofname[1024] ;
#line 276
void abort_gzip(void) ;
#line 296
int copy(int in , int out ) ;
#line 297
ulg updcrc(uch *s , unsigned int n ) ;
#line 298
void clear_bufs(void) ;
#line 300
void flush_outbuf(void) ;
#line 303
char *strlwr(char *s ) ;
#line 304
char *basename(char *fname ) ;
#line 305
void make_simple_name(char *name ) ;
#line 306
char *add_envopt(int *argcp , char ***argvp , char *env___0 ) ;
#line 308
void warn(char *a , char *b ) ;
#line 310
void write_error(void) ;
#line 311
void display_ratio(long num , long den , FILE *file ) ;
#line 312
voidp xmalloc(unsigned int size ) ;
#line 33 "/home/kihong/gzip-1.2.4a/util.c"
ulg crc_32_tab[256] ;
#line 39 "/home/kihong/gzip-1.2.4a/util.c"
int copy(int in , int out ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 42
  tmp = __errno_location();
#line 42
  *tmp = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (insize != 0U) {
#line 43
      if (! ((int )insize != -1)) {
#line 43
        goto while_break;
      }
    } else {
#line 43
      goto while_break;
    }
    {
#line 44
    write_buf(out, (voidp )((char *)(inbuf)), insize);
#line 45
    bytes_out += (long )insize;
#line 46
    tmp___0 = read(in, (void *)((char *)(inbuf)), (size_t )32768);
#line 46
    insize = (unsigned int )tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  if ((int )insize == -1) {
    {
#line 48
    tmp___1 = __errno_location();
    }
#line 48
    if (*tmp___1 != 0) {
      {
#line 49
      read_error();
      }
    }
  }
#line 51
  bytes_in = bytes_out;
#line 52
  return (0);
}
}
#line 66 "/home/kihong/gzip-1.2.4a/util.c"
static ulg crc  =    (ulg )4294967295L;
#line 60 "/home/kihong/gzip-1.2.4a/util.c"
ulg updcrc(uch *s , unsigned int n ) 
{ 
  register ulg c ;
  uch *tmp ;

  {
#line 68
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 69
    c = (ulg )4294967295L;
  } else {
#line 71
    c = crc;
#line 72
    if (n) {
      {
#line 72
      while (1) {
        while_continue: /* CIL Label */ ;
#line 73
        tmp = s;
#line 73
        s ++;
#line 73
        c = crc_32_tab[((int )c ^ (int )*tmp) & 255] ^ (c >> 8);
#line 72
        n --;
#line 72
        if (! n) {
#line 72
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 76
  crc = c;
#line 77
  return (c ^ 4294967295UL);
}
}
#line 83 "/home/kihong/gzip-1.2.4a/util.c"
void clear_bufs(void) 
{ 


  {
#line 85
  outcnt = 0U;
#line 86
  inptr = 0U;
#line 86
  insize = inptr;
#line 87
  bytes_out = 0L;
#line 87
  bytes_in = bytes_out;
#line 88
  return;
}
}
#line 93 "/home/kihong/gzip-1.2.4a/util.c"
int fill_inbuf(int eof_ok ) 
{ 
  int len ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 99
  insize = 0U;
#line 100
  tmp = __errno_location();
#line 100
  *tmp = 0;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    tmp___0 = read(ifd, (void *)((char *)(inbuf) + insize), (size_t )(32768U - insize));
#line 102
    len = (int )tmp___0;
    }
#line 103
    if (len == 0) {
#line 103
      goto while_break;
    } else
#line 103
    if (len == -1) {
#line 103
      goto while_break;
    }
#line 104
    insize += (unsigned int )len;
#line 101
    if (! (insize < 32768U)) {
#line 101
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if (insize == 0U) {
#line 108
    if (eof_ok) {
#line 108
      return (-1);
    }
    {
#line 109
    read_error();
    }
  }
#line 111
  bytes_in = (long )((ulg )bytes_in + (ulg )insize);
#line 112
  inptr = 1U;
#line 113
  return ((int )inbuf[0]);
}
}
#line 120 "/home/kihong/gzip-1.2.4a/util.c"
void flush_outbuf(void) 
{ 


  {
#line 122
  if (outcnt == 0U) {
#line 122
    return;
  }
  {
#line 124
  write_buf(ofd, (voidp )((char *)(outbuf)), outcnt);
#line 125
  bytes_out = (long )((ulg )bytes_out + (ulg )outcnt);
#line 126
  outcnt = 0U;
  }
#line 127
  return;
}
}
#line 133 "/home/kihong/gzip-1.2.4a/util.c"
void flush_window(void) 
{ 


  {
#line 135
  if (outcnt == 0U) {
#line 135
    return;
  }
  {
#line 136
  updcrc(window, outcnt);
  }
#line 138
  if (! test) {
    {
#line 139
    write_buf(ofd, (voidp )((char *)(window)), outcnt);
    }
  }
#line 141
  bytes_out = (long )((ulg )bytes_out + (ulg )outcnt);
#line 142
  outcnt = 0U;
#line 143
  return;
}
}
#line 149 "/home/kihong/gzip-1.2.4a/util.c"
void write_buf(int fd , voidp buf , unsigned int cnt ) 
{ 
  unsigned int n ;
  ssize_t tmp ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp = write(fd, (void const   *)buf, (size_t )cnt);
#line 156
    n = (unsigned int )tmp;
    }
#line 156
    if (! (n != cnt)) {
#line 156
      goto while_break;
    }
#line 157
    if (n == 4294967295U) {
      {
#line 158
      write_error();
      }
    }
#line 160
    cnt -= n;
#line 161
    buf = (voidp )((char *)buf + n);
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 168 "/home/kihong/gzip-1.2.4a/util.c"
char *strlwr(char *s ) 
{ 
  char *t ;
  unsigned short const   **tmp___0 ;

  {
#line 172
  t = s;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! *t) {
#line 172
      goto while_break;
    }
    {
#line 172
    tmp___0 = __ctype_b_loc();
    }
#line 172
    if ((int const   )*(*tmp___0 + (int )*t) & 256) {
#line 172
      *t = (char )(((int )*t - 65) + 97);
    } else {
#line 172
      *t = *t;
    }
#line 172
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (s);
}
}
#line 181 "/home/kihong/gzip-1.2.4a/util.c"
char *basename(char *fname ) 
{ 
  char *p ;

  {
  {
#line 186
  p = strrchr((char const   *)fname, '/');
  }
#line 186
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 186
    fname = p + 1;
  }
#line 197
  return (fname);
}
}
#line 208 "/home/kihong/gzip-1.2.4a/util.c"
void make_simple_name(char *name ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
#line 211
  tmp = strrchr((char const   *)name, '.');
#line 211
  p = tmp;
  }
#line 212
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 212
    return;
  }
#line 213
  if ((unsigned long )p == (unsigned long )name) {
#line 213
    p ++;
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    p --;
#line 215
    if ((int )*p == 46) {
#line 215
      *p = (char )'_';
    }
#line 214
    if (! ((unsigned long )p != (unsigned long )name)) {
#line 214
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 279 "/home/kihong/gzip-1.2.4a/util.c"
char *add_envopt(int *argcp , char ***argvp , char *env___0 ) 
{ 
  char *p ;
  char **oargv ;
  char **nargv ;
  int oargc ;
  int nargc ;
  char *tmp ;
  size_t tmp___0 ;
  voidp tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  char **tmp___8 ;
  size_t tmp___9 ;
  char **tmp___10 ;
  char *tmp___11 ;
  char **tmp___12 ;
  char **tmp___13 ;
  int tmp___14 ;

  {
  {
#line 287
  oargc = *argcp;
#line 288
  nargc = 0;
#line 290
  tmp = getenv((char const   *)env___0);
#line 290
  env___0 = tmp;
  }
#line 291
  if ((unsigned long )env___0 == (unsigned long )((void *)0)) {
#line 291
    return ((char *)((void *)0));
  }
  {
#line 293
  tmp___0 = strlen((char const   *)env___0);
#line 293
  tmp___1 = xmalloc((unsigned int )(tmp___0 + 1UL));
#line 293
  p = (char *)tmp___1;
#line 294
  env___0 = strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)env___0);
#line 296
  p = env___0;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! *p) {
#line 296
      goto while_break;
    }
    {
#line 297
    tmp___2 = strspn((char const   *)p, " \t");
#line 297
    p += tmp___2;
    }
#line 298
    if ((int )*p == 0) {
#line 298
      goto while_break;
    }
    {
#line 300
    tmp___3 = strcspn((char const   *)p, " \t");
#line 300
    p += tmp___3;
    }
#line 301
    if (*p) {
#line 301
      tmp___4 = p;
#line 301
      p ++;
#line 301
      *tmp___4 = (char )'\000';
    }
#line 296
    nargc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  if (nargc == 0) {
    {
#line 304
    free((void *)env___0);
    }
#line 305
    return ((char *)((void *)0));
  }
  {
#line 307
  *argcp += nargc;
#line 311
  tmp___5 = calloc((size_t )(*argcp + 1), sizeof(char *));
#line 311
  nargv = (char **)tmp___5;
  }
#line 312
  if ((unsigned long )nargv == (unsigned long )((void *)0)) {
    {
#line 312
    error((char *)"out of memory");
    }
  }
#line 313
  oargv = *argvp;
#line 314
  *argvp = nargv;
#line 317
  tmp___6 = oargc;
#line 317
  oargc --;
#line 317
  if (tmp___6 < 0) {
    {
#line 317
    error((char *)"argc<=0");
    }
  }
#line 318
  tmp___7 = nargv;
#line 318
  nargv ++;
#line 318
  tmp___8 = oargv;
#line 318
  oargv ++;
#line 318
  *tmp___7 = *tmp___8;
#line 321
  p = env___0;
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 321
    if (! (nargc > 0)) {
#line 321
      goto while_break___0;
    }
    {
#line 322
    tmp___9 = strspn((char const   *)p, " \t");
#line 322
    p += tmp___9;
#line 323
    tmp___10 = nargv;
#line 323
    nargv ++;
#line 323
    *tmp___10 = p;
    }
    {
#line 324
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 324
      tmp___11 = p;
#line 324
      p ++;
#line 324
      if (! *tmp___11) {
#line 324
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 321
    nargc --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 328
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 328
    tmp___14 = oargc;
#line 328
    oargc --;
#line 328
    if (! tmp___14) {
#line 328
      goto while_break___2;
    }
#line 328
    tmp___12 = nargv;
#line 328
    nargv ++;
#line 328
    tmp___13 = oargv;
#line 328
    oargv ++;
#line 328
    *tmp___12 = *tmp___13;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 329
  *nargv = (char *)((void *)0);
#line 330
  return (env___0);
}
}
#line 336 "/home/kihong/gzip-1.2.4a/util.c"
void error(char *m ) 
{ 


  {
  {
#line 339
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: %s\n",
          progname, ifname, m);
#line 340
  abort_gzip();
  }
#line 341
  return;
}
}
#line 343 "/home/kihong/gzip-1.2.4a/util.c"
void warn(char *a , char *b ) 
{ 


  {
#line 346
  if (! quiet) {
    {
#line 346
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: warning: %s%s\n",
            progname, ifname, a, b);
    }
  }
#line 346
  if (exit_code == 0) {
#line 346
    exit_code = 2;
  }
#line 347
  return;
}
}
#line 349 "/home/kihong/gzip-1.2.4a/util.c"
void read_error(void) 
{ 
  int *tmp ;

  {
  {
#line 351
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: ",
          progname);
#line 352
  tmp = __errno_location();
  }
#line 352
  if (*tmp != 0) {
    {
#line 353
    perror((char const   *)(ifname));
    }
  } else {
    {
#line 355
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unexpected end of file\n",
            ifname);
    }
  }
  {
#line 357
  abort_gzip();
  }
#line 358
  return;
}
}
#line 360 "/home/kihong/gzip-1.2.4a/util.c"
void write_error(void) 
{ 


  {
  {
#line 362
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: ",
          progname);
#line 363
  perror((char const   *)(ofname));
#line 364
  abort_gzip();
  }
#line 365
  return;
}
}
#line 370 "/home/kihong/gzip-1.2.4a/util.c"
void display_ratio(long num , long den , FILE *file ) 
{ 
  long ratio ;

  {
#line 377
  if (den == 0L) {
#line 378
    ratio = 0L;
  } else
#line 379
  if (den < 2147483L) {
#line 380
    ratio = (1000L * num) / den;
  } else {
#line 382
    ratio = num / (den / 1000L);
  }
#line 384
  if (ratio < 0L) {
    {
#line 385
    putc('-', file);
#line 386
    ratio = - ratio;
    }
  } else {
    {
#line 388
    putc(' ', file);
    }
  }
  {
#line 390
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%2ld.%1ld%%",
          ratio / 10L, ratio % 10L);
  }
#line 391
  return;
}
}
#line 397 "/home/kihong/gzip-1.2.4a/util.c"
voidp xmalloc(unsigned int size ) 
{ 
  voidp cp ;
  void *tmp ;

  {
  {
#line 400
  tmp = malloc((size_t )size);
#line 400
  cp = tmp;
  }
#line 402
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 402
    error((char *)"out of memory");
    }
  }
#line 403
  return (cp);
}
}
#line 409 "/home/kihong/gzip-1.2.4a/util.c"
ulg crc_32_tab[256]  = 
#line 409
  {      (ulg )0L,      (ulg )1996959894L,      (ulg )3993919788L,      (ulg )2567524794L, 
        (ulg )124634137L,      (ulg )1886057615L,      (ulg )3915621685L,      (ulg )2657392035L, 
        (ulg )249268274L,      (ulg )2044508324L,      (ulg )3772115230L,      (ulg )2547177864L, 
        (ulg )162941995L,      (ulg )2125561021L,      (ulg )3887607047L,      (ulg )2428444049L, 
        (ulg )498536548L,      (ulg )1789927666L,      (ulg )4089016648L,      (ulg )2227061214L, 
        (ulg )450548861L,      (ulg )1843258603L,      (ulg )4107580753L,      (ulg )2211677639L, 
        (ulg )325883990L,      (ulg )1684777152L,      (ulg )4251122042L,      (ulg )2321926636L, 
        (ulg )335633487L,      (ulg )1661365465L,      (ulg )4195302755L,      (ulg )2366115317L, 
        (ulg )997073096L,      (ulg )1281953886L,      (ulg )3579855332L,      (ulg )2724688242L, 
        (ulg )1006888145L,      (ulg )1258607687L,      (ulg )3524101629L,      (ulg )2768942443L, 
        (ulg )901097722L,      (ulg )1119000684L,      (ulg )3686517206L,      (ulg )2898065728L, 
        (ulg )853044451L,      (ulg )1172266101L,      (ulg )3705015759L,      (ulg )2882616665L, 
        (ulg )651767980L,      (ulg )1373503546L,      (ulg )3369554304L,      (ulg )3218104598L, 
        (ulg )565507253L,      (ulg )1454621731L,      (ulg )3485111705L,      (ulg )3099436303L, 
        (ulg )671266974L,      (ulg )1594198024L,      (ulg )3322730930L,      (ulg )2970347812L, 
        (ulg )795835527L,      (ulg )1483230225L,      (ulg )3244367275L,      (ulg )3060149565L, 
        (ulg )1994146192L,      (ulg )31158534L,      (ulg )2563907772L,      (ulg )4023717930L, 
        (ulg )1907459465L,      (ulg )112637215L,      (ulg )2680153253L,      (ulg )3904427059L, 
        (ulg )2013776290L,      (ulg )251722036L,      (ulg )2517215374L,      (ulg )3775830040L, 
        (ulg )2137656763L,      (ulg )141376813L,      (ulg )2439277719L,      (ulg )3865271297L, 
        (ulg )1802195444L,      (ulg )476864866L,      (ulg )2238001368L,      (ulg )4066508878L, 
        (ulg )1812370925L,      (ulg )453092731L,      (ulg )2181625025L,      (ulg )4111451223L, 
        (ulg )1706088902L,      (ulg )314042704L,      (ulg )2344532202L,      (ulg )4240017532L, 
        (ulg )1658658271L,      (ulg )366619977L,      (ulg )2362670323L,      (ulg )4224994405L, 
        (ulg )1303535960L,      (ulg )984961486L,      (ulg )2747007092L,      (ulg )3569037538L, 
        (ulg )1256170817L,      (ulg )1037604311L,      (ulg )2765210733L,      (ulg )3554079995L, 
        (ulg )1131014506L,      (ulg )879679996L,      (ulg )2909243462L,      (ulg )3663771856L, 
        (ulg )1141124467L,      (ulg )855842277L,      (ulg )2852801631L,      (ulg )3708648649L, 
        (ulg )1342533948L,      (ulg )654459306L,      (ulg )3188396048L,      (ulg )3373015174L, 
        (ulg )1466479909L,      (ulg )544179635L,      (ulg )3110523913L,      (ulg )3462522015L, 
        (ulg )1591671054L,      (ulg )702138776L,      (ulg )2966460450L,      (ulg )3352799412L, 
        (ulg )1504918807L,      (ulg )783551873L,      (ulg )3082640443L,      (ulg )3233442989L, 
        (ulg )3988292384L,      (ulg )2596254646L,      (ulg )62317068L,      (ulg )1957810842L, 
        (ulg )3939845945L,      (ulg )2647816111L,      (ulg )81470997L,      (ulg )1943803523L, 
        (ulg )3814918930L,      (ulg )2489596804L,      (ulg )225274430L,      (ulg )2053790376L, 
        (ulg )3826175755L,      (ulg )2466906013L,      (ulg )167816743L,      (ulg )2097651377L, 
        (ulg )4027552580L,      (ulg )2265490386L,      (ulg )503444072L,      (ulg )1762050814L, 
        (ulg )4150417245L,      (ulg )2154129355L,      (ulg )426522225L,      (ulg )1852507879L, 
        (ulg )4275313526L,      (ulg )2312317920L,      (ulg )282753626L,      (ulg )1742555852L, 
        (ulg )4189708143L,      (ulg )2394877945L,      (ulg )397917763L,      (ulg )1622183637L, 
        (ulg )3604390888L,      (ulg )2714866558L,      (ulg )953729732L,      (ulg )1340076626L, 
        (ulg )3518719985L,      (ulg )2797360999L,      (ulg )1068828381L,      (ulg )1219638859L, 
        (ulg )3624741850L,      (ulg )2936675148L,      (ulg )906185462L,      (ulg )1090812512L, 
        (ulg )3747672003L,      (ulg )2825379669L,      (ulg )829329135L,      (ulg )1181335161L, 
        (ulg )3412177804L,      (ulg )3160834842L,      (ulg )628085408L,      (ulg )1382605366L, 
        (ulg )3423369109L,      (ulg )3138078467L,      (ulg )570562233L,      (ulg )1426400815L, 
        (ulg )3317316542L,      (ulg )2998733608L,      (ulg )733239954L,      (ulg )1555261956L, 
        (ulg )3268935591L,      (ulg )3050360625L,      (ulg )752459403L,      (ulg )1541320221L, 
        (ulg )2607071920L,      (ulg )3965973030L,      (ulg )1969922972L,      (ulg )40735498L, 
        (ulg )2617837225L,      (ulg )3943577151L,      (ulg )1913087877L,      (ulg )83908371L, 
        (ulg )2512341634L,      (ulg )3803740692L,      (ulg )2075208622L,      (ulg )213261112L, 
        (ulg )2463272603L,      (ulg )3855990285L,      (ulg )2094854071L,      (ulg )198958881L, 
        (ulg )2262029012L,      (ulg )4057260610L,      (ulg )1759359992L,      (ulg )534414190L, 
        (ulg )2176718541L,      (ulg )4139329115L,      (ulg )1873836001L,      (ulg )414664567L, 
        (ulg )2282248934L,      (ulg )4279200368L,      (ulg )1711684554L,      (ulg )285281116L, 
        (ulg )2405801727L,      (ulg )4167216745L,      (ulg )1634467795L,      (ulg )376229701L, 
        (ulg )2685067896L,      (ulg )3608007406L,      (ulg )1308918612L,      (ulg )956543938L, 
        (ulg )2808555105L,      (ulg )3495958263L,      (ulg )1231636301L,      (ulg )1047427035L, 
        (ulg )2932959818L,      (ulg )3654703836L,      (ulg )1088359270L,      (ulg )936918000L, 
        (ulg )2847714899L,      (ulg )3736837829L,      (ulg )1202900863L,      (ulg )817233897L, 
        (ulg )3183342108L,      (ulg )3401237130L,      (ulg )1404277552L,      (ulg )615818150L, 
        (ulg )3134207493L,      (ulg )3453421203L,      (ulg )1423857449L,      (ulg )601450431L, 
        (ulg )3009837614L,      (ulg )3294710456L,      (ulg )1567103746L,      (ulg )711928724L, 
        (ulg )3020668471L,      (ulg )3272380065L,      (ulg )1510334235L,      (ulg )755167117L};
#line 315 "/home/kihong/gzip-1.2.4a/gzip.h"
int inflate(void) ;
#line 132 "/home/kihong/gzip-1.2.4a/inflate.c"
int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush *d , ush *e ,
               struct huft **t , int *m ) ;
#line 134
int huft_free(struct huft *t ) ;
#line 135
int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) ;
#line 136
int inflate_stored(void) ;
#line 137
int inflate_fixed(void) ;
#line 138
int inflate_dynamic(void) ;
#line 139
int inflate_block(int *e ) ;
#line 156 "/home/kihong/gzip-1.2.4a/inflate.c"
static unsigned int border[19]  = 
#line 156
  {      16U,      17U,      18U,      0U, 
        8U,      7U,      9U,      6U, 
        10U,      5U,      11U,      4U, 
        12U,      3U,      13U,      2U, 
        14U,      1U,      15U};
#line 158 "/home/kihong/gzip-1.2.4a/inflate.c"
static ush cplens[31]  = 
#line 158
  {      (ush )3,      (ush )4,      (ush )5,      (ush )6, 
        (ush )7,      (ush )8,      (ush )9,      (ush )10, 
        (ush )11,      (ush )13,      (ush )15,      (ush )17, 
        (ush )19,      (ush )23,      (ush )27,      (ush )31, 
        (ush )35,      (ush )43,      (ush )51,      (ush )59, 
        (ush )67,      (ush )83,      (ush )99,      (ush )115, 
        (ush )131,      (ush )163,      (ush )195,      (ush )227, 
        (ush )258,      (ush )0,      (ush )0};
#line 162 "/home/kihong/gzip-1.2.4a/inflate.c"
static ush cplext[31]  = 
#line 162
  {      (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )1,      (ush )1,      (ush )1,      (ush )1, 
        (ush )2,      (ush )2,      (ush )2,      (ush )2, 
        (ush )3,      (ush )3,      (ush )3,      (ush )3, 
        (ush )4,      (ush )4,      (ush )4,      (ush )4, 
        (ush )5,      (ush )5,      (ush )5,      (ush )5, 
        (ush )0,      (ush )99,      (ush )99};
#line 165 "/home/kihong/gzip-1.2.4a/inflate.c"
static ush cpdist[30]  = 
#line 165
  {      (ush )1,      (ush )2,      (ush )3,      (ush )4, 
        (ush )5,      (ush )7,      (ush )9,      (ush )13, 
        (ush )17,      (ush )25,      (ush )33,      (ush )49, 
        (ush )65,      (ush )97,      (ush )129,      (ush )193, 
        (ush )257,      (ush )385,      (ush )513,      (ush )769, 
        (ush )1025,      (ush )1537,      (ush )2049,      (ush )3073, 
        (ush )4097,      (ush )6145,      (ush )8193,      (ush )12289, 
        (ush )16385,      (ush )24577};
#line 169 "/home/kihong/gzip-1.2.4a/inflate.c"
static ush cpdext[30]  = 
#line 169
  {      (ush )0,      (ush )0,      (ush )0,      (ush )0, 
        (ush )1,      (ush )1,      (ush )2,      (ush )2, 
        (ush )3,      (ush )3,      (ush )4,      (ush )4, 
        (ush )5,      (ush )5,      (ush )6,      (ush )6, 
        (ush )7,      (ush )7,      (ush )8,      (ush )8, 
        (ush )9,      (ush )9,      (ush )10,      (ush )10, 
        (ush )11,      (ush )11,      (ush )12,      (ush )12, 
        (ush )13,      (ush )13};
#line 206 "/home/kihong/gzip-1.2.4a/inflate.c"
ulg bb  ;
#line 207 "/home/kihong/gzip-1.2.4a/inflate.c"
unsigned int bk  ;
#line 209 "/home/kihong/gzip-1.2.4a/inflate.c"
ush mask_bits[17]  = 
#line 209
  {      (ush )0,      (ush )1,      (ush )3,      (ush )7, 
        (ush )15,      (ush )31,      (ush )63,      (ush )127, 
        (ush )255,      (ush )511,      (ush )1023,      (ush )2047, 
        (ush )4095,      (ush )8191,      (ush )16383,      (ush )32767, 
        (ush )65535};
#line 259 "/home/kihong/gzip-1.2.4a/inflate.c"
int lbits  =    9;
#line 260 "/home/kihong/gzip-1.2.4a/inflate.c"
int dbits  =    6;
#line 268 "/home/kihong/gzip-1.2.4a/inflate.c"
unsigned int hufts  ;
#line 271 "/home/kihong/gzip-1.2.4a/inflate.c"
int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush *d , ush *e ,
               struct huft **t , int *m ) 
{ 
  unsigned int a ;
  unsigned int c[17] ;
  unsigned int f ;
  int g ;
  int h ;
  register unsigned int i___0 ;
  register unsigned int j___0 ;
  register int k ;
  int l ;
  register unsigned int *p ;
  register struct huft *q ;
  struct huft r ;
  struct huft *u[16] ;
  unsigned int v[288] ;
  register int w ;
  unsigned int x[17] ;
  unsigned int *xp ;
  int y ;
  unsigned int z ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned int *tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 307
  memset((voidp )(c), 0, sizeof(c));
#line 308
  p = b;
#line 308
  i___0 = n;
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    (c[*p]) ++;
#line 313
    p ++;
#line 309
    i___0 --;
#line 309
    if (! i___0) {
#line 309
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  if (c[0] == n) {
#line 317
    *t = (struct huft *)((void *)0);
#line 318
    *m = 0;
#line 319
    return (0);
  }
#line 324
  l = *m;
#line 325
  j___0 = 1U;
  {
#line 325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 325
    if (! (j___0 <= 16U)) {
#line 325
      goto while_break___0;
    }
#line 326
    if (c[j___0]) {
#line 327
      goto while_break___0;
    }
#line 325
    j___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  k = (int )j___0;
#line 329
  if ((unsigned int )l < j___0) {
#line 330
    l = (int )j___0;
  }
#line 331
  i___0 = 16U;
  {
#line 331
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 331
    if (! i___0) {
#line 331
      goto while_break___1;
    }
#line 332
    if (c[i___0]) {
#line 333
      goto while_break___1;
    }
#line 331
    i___0 --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  g = (int )i___0;
#line 335
  if ((unsigned int )l > i___0) {
#line 336
    l = (int )i___0;
  }
#line 337
  *m = l;
#line 341
  y = 1 << j___0;
  {
#line 341
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 341
    if (! (j___0 < i___0)) {
#line 341
      goto while_break___2;
    }
#line 342
    y = (int )((unsigned int )y - c[j___0]);
#line 342
    if (y < 0) {
#line 343
      return (2);
    }
#line 341
    j___0 ++;
#line 341
    y <<= 1;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 344
  y = (int )((unsigned int )y - c[i___0]);
#line 344
  if (y < 0) {
#line 345
    return (2);
  }
#line 346
  c[i___0] += (unsigned int )y;
#line 350
  j___0 = 0U;
#line 350
  x[1] = j___0;
#line 351
  p = c + 1;
#line 351
  xp = x + 2;
  {
#line 352
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 352
    i___0 --;
#line 352
    if (! i___0) {
#line 352
      goto while_break___3;
    }
#line 353
    tmp = xp;
#line 353
    xp ++;
#line 353
    tmp___0 = p;
#line 353
    p ++;
#line 353
    j___0 += *tmp___0;
#line 353
    *tmp = j___0;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 358
  p = b;
#line 358
  i___0 = 0U;
  {
#line 359
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 360
    tmp___2 = p;
#line 360
    p ++;
#line 360
    j___0 = *tmp___2;
#line 360
    if (j___0 != 0U) {
#line 361
      tmp___1 = x[j___0];
#line 361
      (x[j___0]) ++;
#line 361
      v[tmp___1] = i___0;
    }
#line 359
    i___0 ++;
#line 359
    if (! (i___0 < n)) {
#line 359
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 366
  i___0 = 0U;
#line 366
  x[0] = i___0;
#line 367
  p = v;
#line 368
  h = -1;
#line 369
  w = - l;
#line 370
  u[0] = (struct huft *)((void *)0);
#line 371
  q = (struct huft *)((void *)0);
#line 372
  z = 0U;
  {
#line 375
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 375
    if (! (k <= g)) {
#line 375
      goto while_break___5;
    }
#line 377
    a = c[k];
    {
#line 378
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 378
      tmp___6 = a;
#line 378
      a --;
#line 378
      if (! tmp___6) {
#line 378
        goto while_break___6;
      }
      {
#line 382
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 382
        if (! (k > w + l)) {
#line 382
          goto while_break___7;
        }
#line 384
        h ++;
#line 385
        w += l;
#line 388
        z = (unsigned int )(g - w);
#line 388
        if (z > (unsigned int )l) {
#line 388
          z = (unsigned int )l;
        } else {
#line 388
          z = z;
        }
#line 389
        j___0 = (unsigned int )(k - w);
#line 389
        f = (unsigned int )(1 << j___0);
#line 389
        if (f > a + 1U) {
#line 391
          f -= a + 1U;
#line 392
          xp = c + k;
          {
#line 393
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 393
            j___0 ++;
#line 393
            if (! (j___0 < z)) {
#line 393
              goto while_break___8;
            }
#line 395
            f <<= 1;
#line 395
            xp ++;
#line 395
            if (f <= *xp) {
#line 396
              goto while_break___8;
            }
#line 397
            f -= *xp;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
        {
#line 400
        z = (unsigned int )(1 << j___0);
#line 403
        tmp___3 = malloc((unsigned long )(z + 1U) * sizeof(struct huft ));
#line 403
        q = (struct huft *)tmp___3;
        }
#line 403
        if ((unsigned long )q == (unsigned long )((struct huft *)((void *)0))) {
#line 406
          if (h) {
            {
#line 407
            huft_free(u[0]);
            }
          }
#line 408
          return (3);
        }
#line 410
        hufts += z + 1U;
#line 411
        *t = q + 1;
#line 412
        t = & q->v.t;
#line 412
        *t = (struct huft *)((void *)0);
#line 413
        q ++;
#line 413
        u[h] = q;
#line 416
        if (h) {
#line 418
          x[h] = i___0;
#line 419
          r.b = (uch )l;
#line 420
          r.e = (uch )(16U + j___0);
#line 421
          r.v.t = q;
#line 422
          j___0 = i___0 >> (w - l);
#line 423
          *(u[h - 1] + j___0) = r;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 428
      r.b = (uch )(k - w);
#line 429
      if ((unsigned long )p >= (unsigned long )(v + n)) {
#line 430
        r.e = (uch )99;
      } else
#line 431
      if (*p < s) {
#line 433
        if (*p < 256U) {
#line 433
          tmp___4 = 16;
        } else {
#line 433
          tmp___4 = 15;
        }
#line 433
        r.e = (uch )tmp___4;
#line 434
        r.v.n = (ush )*p;
#line 435
        p ++;
      } else {
#line 439
        r.e = (uch )*(e + (*p - s));
#line 440
        tmp___5 = p;
#line 440
        p ++;
#line 440
        r.v.n = *(d + (*tmp___5 - s));
      }
#line 444
      f = (unsigned int )(1 << (k - w));
#line 445
      j___0 = i___0 >> w;
      {
#line 445
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 445
        if (! (j___0 < z)) {
#line 445
          goto while_break___9;
        }
#line 446
        *(q + j___0) = r;
#line 445
        j___0 += f;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 449
      j___0 = (unsigned int )(1 << (k - 1));
      {
#line 449
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 449
        if (! (i___0 & j___0)) {
#line 449
          goto while_break___10;
        }
#line 450
        i___0 ^= j___0;
#line 449
        j___0 >>= 1;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 451
      i___0 ^= j___0;
      {
#line 454
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 454
        if (! ((i___0 & (unsigned int )((1 << w) - 1)) != x[h])) {
#line 454
          goto while_break___11;
        }
#line 456
        h --;
#line 457
        w -= l;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 375
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 464
  if (y != 0) {
#line 464
    if (g != 1) {
#line 464
      tmp___7 = 1;
    } else {
#line 464
      tmp___7 = 0;
    }
  } else {
#line 464
    tmp___7 = 0;
  }
#line 464
  return (tmp___7);
}
}
#line 469 "/home/kihong/gzip-1.2.4a/inflate.c"
int huft_free(struct huft *t ) 
{ 
  register struct huft *p ;
  register struct huft *q ;

  {
#line 479
  p = t;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! ((unsigned long )p != (unsigned long )((struct huft *)((void *)0)))) {
#line 480
      goto while_break;
    }
    {
#line 482
    p --;
#line 482
    q = p->v.t;
#line 483
    free((void *)((char *)p));
#line 484
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return (0);
}
}
#line 490 "/home/kihong/gzip-1.2.4a/inflate.c"
int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) 
{ 
  register unsigned int e ;
  unsigned int n ;
  unsigned int d ;
  unsigned int w ;
  struct huft *t ;
  unsigned int ml ;
  unsigned int md ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;

  {
#line 506
  b = bb;
#line 507
  k = bk;
#line 508
  w = outcnt;
#line 511
  ml = (unsigned int )mask_bits[bl];
#line 512
  md = (unsigned int )mask_bits[bd];
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 515
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 515
      if (! (k < (unsigned int )bl)) {
#line 515
        goto while_break___0;
      }
#line 515
      if (inptr < insize) {
#line 515
        tmp = inptr;
#line 515
        inptr ++;
#line 515
        tmp___1 = (int )inbuf[tmp];
      } else {
        {
#line 515
        tmp___0 = fill_inbuf(0);
#line 515
        tmp___1 = tmp___0;
        }
      }
#line 515
      b |= (ulg )((uch )tmp___1) << k;
#line 515
      k += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 516
    t = tl + ((unsigned int )b & ml);
#line 516
    e = (unsigned int )t->e;
#line 516
    if (e > 16U) {
      {
#line 517
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 518
        if (e == 99U) {
#line 519
          return (1);
        }
#line 520
        b >>= (int )t->b;
#line 520
        k -= (unsigned int )t->b;
#line 521
        e -= 16U;
        {
#line 522
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 522
          if (! (k < e)) {
#line 522
            goto while_break___2;
          }
#line 522
          if (inptr < insize) {
#line 522
            tmp___2 = inptr;
#line 522
            inptr ++;
#line 522
            tmp___4 = (int )inbuf[tmp___2];
          } else {
            {
#line 522
            tmp___3 = fill_inbuf(0);
#line 522
            tmp___4 = tmp___3;
            }
          }
#line 522
          b |= (ulg )((uch )tmp___4) << k;
#line 522
          k += 8U;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 517
        t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 517
        e = (unsigned int )t->e;
#line 517
        if (! (e > 16U)) {
#line 517
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 524
    b >>= (int )t->b;
#line 524
    k -= (unsigned int )t->b;
#line 525
    if (e == 16U) {
#line 527
      tmp___5 = w;
#line 527
      w ++;
#line 527
      window[tmp___5] = (uch )t->v.n;
#line 529
      if (w == 32768U) {
        {
#line 531
        outcnt = w;
#line 531
        flush_window();
#line 532
        w = 0U;
        }
      }
    } else {
#line 538
      if (e == 15U) {
#line 539
        goto while_break;
      }
      {
#line 542
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 542
        if (! (k < e)) {
#line 542
          goto while_break___3;
        }
#line 542
        if (inptr < insize) {
#line 542
          tmp___6 = inptr;
#line 542
          inptr ++;
#line 542
          tmp___8 = (int )inbuf[tmp___6];
        } else {
          {
#line 542
          tmp___7 = fill_inbuf(0);
#line 542
          tmp___8 = tmp___7;
          }
        }
#line 542
        b |= (ulg )((uch )tmp___8) << k;
#line 542
        k += 8U;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 543
      n = (unsigned int )t->v.n + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 544
      b >>= e;
#line 544
      k -= e;
      {
#line 547
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 547
        if (! (k < (unsigned int )bd)) {
#line 547
          goto while_break___4;
        }
#line 547
        if (inptr < insize) {
#line 547
          tmp___9 = inptr;
#line 547
          inptr ++;
#line 547
          tmp___11 = (int )inbuf[tmp___9];
        } else {
          {
#line 547
          tmp___10 = fill_inbuf(0);
#line 547
          tmp___11 = tmp___10;
          }
        }
#line 547
        b |= (ulg )((uch )tmp___11) << k;
#line 547
        k += 8U;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 548
      t = td + ((unsigned int )b & md);
#line 548
      e = (unsigned int )t->e;
#line 548
      if (e > 16U) {
        {
#line 549
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 550
          if (e == 99U) {
#line 551
            return (1);
          }
#line 552
          b >>= (int )t->b;
#line 552
          k -= (unsigned int )t->b;
#line 553
          e -= 16U;
          {
#line 554
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 554
            if (! (k < e)) {
#line 554
              goto while_break___6;
            }
#line 554
            if (inptr < insize) {
#line 554
              tmp___12 = inptr;
#line 554
              inptr ++;
#line 554
              tmp___14 = (int )inbuf[tmp___12];
            } else {
              {
#line 554
              tmp___13 = fill_inbuf(0);
#line 554
              tmp___14 = tmp___13;
              }
            }
#line 554
            b |= (ulg )((uch )tmp___14) << k;
#line 554
            k += 8U;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 549
          t = t->v.t + ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 549
          e = (unsigned int )t->e;
#line 549
          if (! (e > 16U)) {
#line 549
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 556
      b >>= (int )t->b;
#line 556
      k -= (unsigned int )t->b;
      {
#line 557
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 557
        if (! (k < e)) {
#line 557
          goto while_break___7;
        }
#line 557
        if (inptr < insize) {
#line 557
          tmp___15 = inptr;
#line 557
          inptr ++;
#line 557
          tmp___17 = (int )inbuf[tmp___15];
        } else {
          {
#line 557
          tmp___16 = fill_inbuf(0);
#line 557
          tmp___17 = tmp___16;
          }
        }
#line 557
        b |= (ulg )((uch )tmp___17) << k;
#line 557
        k += 8U;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 558
      d = (w - (unsigned int )t->v.n) - ((unsigned int )b & (unsigned int )mask_bits[e]);
#line 559
      b >>= e;
#line 559
      k -= e;
      {
#line 563
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 564
        d &= 32767U;
#line 564
        if (d > w) {
#line 564
          tmp___19 = d;
        } else {
#line 564
          tmp___19 = w;
        }
#line 564
        e = 32768U - tmp___19;
#line 564
        if (e > n) {
#line 564
          e = n;
        } else {
#line 564
          e = e;
        }
#line 564
        n -= e;
#line 566
        if (w - d >= e) {
          {
#line 568
          memcpy((void */* __restrict  */)(window + w), (void const   */* __restrict  */)(window + d),
                 (size_t )e);
#line 569
          w += e;
#line 570
          d += e;
          }
        } else {
          {
#line 574
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 575
            tmp___20 = w;
#line 575
            w ++;
#line 575
            tmp___21 = d;
#line 575
            d ++;
#line 575
            window[tmp___20] = window[tmp___21];
#line 574
            e --;
#line 574
            if (! e) {
#line 574
              goto while_break___9;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
        }
#line 578
        if (w == 32768U) {
          {
#line 580
          outcnt = w;
#line 580
          flush_window();
#line 581
          w = 0U;
          }
        }
#line 563
        if (! n) {
#line 563
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  outcnt = w;
#line 590
  bb = b;
#line 591
  bk = k;
#line 594
  return (0);
}
}
#line 599 "/home/kihong/gzip-1.2.4a/inflate.c"
int inflate_stored(void) 
{ 
  unsigned int n ;
  unsigned int w ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 609
  b = bb;
#line 610
  k = bk;
#line 611
  w = outcnt;
#line 615
  n = k & 7U;
#line 616
  b >>= n;
#line 616
  k -= n;
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! (k < 16U)) {
#line 620
      goto while_break;
    }
#line 620
    if (inptr < insize) {
#line 620
      tmp = inptr;
#line 620
      inptr ++;
#line 620
      tmp___1 = (int )inbuf[tmp];
    } else {
      {
#line 620
      tmp___0 = fill_inbuf(0);
#line 620
      tmp___1 = tmp___0;
      }
    }
#line 620
    b |= (ulg )((uch )tmp___1) << k;
#line 620
    k += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  n = (unsigned int )b & 65535U;
#line 622
  b >>= 16;
#line 622
  k -= 16U;
  {
#line 623
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 623
    if (! (k < 16U)) {
#line 623
      goto while_break___0;
    }
#line 623
    if (inptr < insize) {
#line 623
      tmp___2 = inptr;
#line 623
      inptr ++;
#line 623
      tmp___4 = (int )inbuf[tmp___2];
    } else {
      {
#line 623
      tmp___3 = fill_inbuf(0);
#line 623
      tmp___4 = tmp___3;
      }
    }
#line 623
    b |= (ulg )((uch )tmp___4) << k;
#line 623
    k += 8U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 624
  if (n != (unsigned int )(~ b & 65535UL)) {
#line 625
    return (1);
  }
#line 626
  b >>= 16;
#line 626
  k -= 16U;
  {
#line 630
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 630
    tmp___9 = n;
#line 630
    n --;
#line 630
    if (! tmp___9) {
#line 630
      goto while_break___1;
    }
    {
#line 632
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 632
      if (! (k < 8U)) {
#line 632
        goto while_break___2;
      }
#line 632
      if (inptr < insize) {
#line 632
        tmp___5 = inptr;
#line 632
        inptr ++;
#line 632
        tmp___7 = (int )inbuf[tmp___5];
      } else {
        {
#line 632
        tmp___6 = fill_inbuf(0);
#line 632
        tmp___7 = tmp___6;
        }
      }
#line 632
      b |= (ulg )((uch )tmp___7) << k;
#line 632
      k += 8U;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 633
    tmp___8 = w;
#line 633
    w ++;
#line 633
    window[tmp___8] = (uch )b;
#line 634
    if (w == 32768U) {
      {
#line 636
      outcnt = w;
#line 636
      flush_window();
#line 637
      w = 0U;
      }
    }
#line 639
    b >>= 8;
#line 639
    k -= 8U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 644
  outcnt = w;
#line 645
  bb = b;
#line 646
  bk = k;
#line 647
  return (0);
}
}
#line 652 "/home/kihong/gzip-1.2.4a/inflate.c"
int inflate_fixed(void) 
{ 
  int i___0 ;
  struct huft *tl ;
  struct huft *td ;
  int bl ;
  int bd ;
  unsigned int l[288] ;
  int tmp ;

  {
#line 666
  i___0 = 0;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    if (! (i___0 < 144)) {
#line 666
      goto while_break;
    }
#line 667
    l[i___0] = 8U;
#line 666
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 668
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 668
    if (! (i___0 < 256)) {
#line 668
      goto while_break___0;
    }
#line 669
    l[i___0] = 9U;
#line 668
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 670
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 670
    if (! (i___0 < 280)) {
#line 670
      goto while_break___1;
    }
#line 671
    l[i___0] = 7U;
#line 670
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 672
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 672
    if (! (i___0 < 288)) {
#line 672
      goto while_break___2;
    }
#line 673
    l[i___0] = 8U;
#line 672
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 674
  bl = 7;
#line 675
  i___0 = huft_build(l, 288U, 257U, cplens, cplext, & tl, & bl);
  }
#line 675
  if (i___0 != 0) {
#line 676
    return (i___0);
  }
#line 680
  i___0 = 0;
  {
#line 680
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 680
    if (! (i___0 < 30)) {
#line 680
      goto while_break___3;
    }
#line 681
    l[i___0] = 5U;
#line 680
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 682
  bd = 5;
#line 683
  i___0 = huft_build(l, 30U, 0U, cpdist, cpdext, & td, & bd);
  }
#line 683
  if (i___0 > 1) {
    {
#line 685
    huft_free(tl);
    }
#line 686
    return (i___0);
  }
  {
#line 691
  tmp = inflate_codes(tl, td, bl, bd);
  }
#line 691
  if (tmp) {
#line 692
    return (1);
  }
  {
#line 696
  huft_free(tl);
#line 697
  huft_free(td);
  }
#line 698
  return (0);
}
}
#line 703 "/home/kihong/gzip-1.2.4a/inflate.c"
int inflate_dynamic(void) 
{ 
  int i___0 ;
  unsigned int j___0 ;
  unsigned int l ;
  unsigned int m ;
  unsigned int n ;
  struct huft *tl ;
  struct huft *td ;
  int bl ;
  int bd ;
  unsigned int nb ;
  unsigned int nl ;
  unsigned int nd ;
  unsigned int ll[316] ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  unsigned int tmp___29 ;
  int tmp___30 ;

  {
#line 728
  b = bb;
#line 729
  k = bk;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! (k < 5U)) {
#line 733
      goto while_break;
    }
#line 733
    if (inptr < insize) {
#line 733
      tmp = inptr;
#line 733
      inptr ++;
#line 733
      tmp___1 = (int )inbuf[tmp];
    } else {
      {
#line 733
      tmp___0 = fill_inbuf(0);
#line 733
      tmp___1 = tmp___0;
      }
    }
#line 733
    b |= (ulg )((uch )tmp___1) << k;
#line 733
    k += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  nl = 257U + ((unsigned int )b & 31U);
#line 735
  b >>= 5;
#line 735
  k -= 5U;
  {
#line 736
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 736
    if (! (k < 5U)) {
#line 736
      goto while_break___0;
    }
#line 736
    if (inptr < insize) {
#line 736
      tmp___2 = inptr;
#line 736
      inptr ++;
#line 736
      tmp___4 = (int )inbuf[tmp___2];
    } else {
      {
#line 736
      tmp___3 = fill_inbuf(0);
#line 736
      tmp___4 = tmp___3;
      }
    }
#line 736
    b |= (ulg )((uch )tmp___4) << k;
#line 736
    k += 8U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 737
  nd = 1U + ((unsigned int )b & 31U);
#line 738
  b >>= 5;
#line 738
  k -= 5U;
  {
#line 739
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 739
    if (! (k < 4U)) {
#line 739
      goto while_break___1;
    }
#line 739
    if (inptr < insize) {
#line 739
      tmp___5 = inptr;
#line 739
      inptr ++;
#line 739
      tmp___7 = (int )inbuf[tmp___5];
    } else {
      {
#line 739
      tmp___6 = fill_inbuf(0);
#line 739
      tmp___7 = tmp___6;
      }
    }
#line 739
    b |= (ulg )((uch )tmp___7) << k;
#line 739
    k += 8U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 740
  nb = 4U + ((unsigned int )b & 15U);
#line 741
  b >>= 4;
#line 741
  k -= 4U;
#line 745
  if (nl > 286U) {
#line 747
    return (1);
  } else
#line 745
  if (nd > 30U) {
#line 747
    return (1);
  }
#line 751
  j___0 = 0U;
  {
#line 751
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 751
    if (! (j___0 < nb)) {
#line 751
      goto while_break___2;
    }
    {
#line 753
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 753
      if (! (k < 3U)) {
#line 753
        goto while_break___3;
      }
#line 753
      if (inptr < insize) {
#line 753
        tmp___8 = inptr;
#line 753
        inptr ++;
#line 753
        tmp___10 = (int )inbuf[tmp___8];
      } else {
        {
#line 753
        tmp___9 = fill_inbuf(0);
#line 753
        tmp___10 = tmp___9;
        }
      }
#line 753
      b |= (ulg )((uch )tmp___10) << k;
#line 753
      k += 8U;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 754
    ll[border[j___0]] = (unsigned int )b & 7U;
#line 755
    b >>= 3;
#line 755
    k -= 3U;
#line 751
    j___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 757
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 757
    if (! (j___0 < 19U)) {
#line 757
      goto while_break___4;
    }
#line 758
    ll[border[j___0]] = 0U;
#line 757
    j___0 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 762
  bl = 7;
#line 763
  i___0 = huft_build(ll, 19U, 19U, (ush *)((void *)0), (ush *)((void *)0), & tl, & bl);
  }
#line 763
  if (i___0 != 0) {
#line 765
    if (i___0 == 1) {
      {
#line 766
      huft_free(tl);
      }
    }
#line 767
    return (i___0);
  }
#line 772
  n = nl + nd;
#line 773
  m = (unsigned int )mask_bits[bl];
#line 774
  l = 0U;
#line 774
  i___0 = (int )l;
  {
#line 775
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 775
    if (! ((unsigned int )i___0 < n)) {
#line 775
      goto while_break___5;
    }
    {
#line 777
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 777
      if (! (k < (unsigned int )bl)) {
#line 777
        goto while_break___6;
      }
#line 777
      if (inptr < insize) {
#line 777
        tmp___11 = inptr;
#line 777
        inptr ++;
#line 777
        tmp___13 = (int )inbuf[tmp___11];
      } else {
        {
#line 777
        tmp___12 = fill_inbuf(0);
#line 777
        tmp___13 = tmp___12;
        }
      }
#line 777
      b |= (ulg )((uch )tmp___13) << k;
#line 777
      k += 8U;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 778
    td = tl + ((unsigned int )b & m);
#line 778
    j___0 = (unsigned int )td->b;
#line 779
    b >>= j___0;
#line 779
    k -= j___0;
#line 780
    j___0 = (unsigned int )td->v.n;
#line 781
    if (j___0 < 16U) {
#line 782
      tmp___14 = i___0;
#line 782
      i___0 ++;
#line 782
      l = j___0;
#line 782
      ll[tmp___14] = l;
    } else
#line 783
    if (j___0 == 16U) {
      {
#line 785
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 785
        if (! (k < 2U)) {
#line 785
          goto while_break___7;
        }
#line 785
        if (inptr < insize) {
#line 785
          tmp___15 = inptr;
#line 785
          inptr ++;
#line 785
          tmp___17 = (int )inbuf[tmp___15];
        } else {
          {
#line 785
          tmp___16 = fill_inbuf(0);
#line 785
          tmp___17 = tmp___16;
          }
        }
#line 785
        b |= (ulg )((uch )tmp___17) << k;
#line 785
        k += 8U;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 786
      j___0 = 3U + ((unsigned int )b & 3U);
#line 787
      b >>= 2;
#line 787
      k -= 2U;
#line 788
      if ((unsigned int )i___0 + j___0 > n) {
#line 789
        return (1);
      }
      {
#line 790
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 790
        tmp___19 = j___0;
#line 790
        j___0 --;
#line 790
        if (! tmp___19) {
#line 790
          goto while_break___8;
        }
#line 791
        tmp___18 = i___0;
#line 791
        i___0 ++;
#line 791
        ll[tmp___18] = l;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 793
    if (j___0 == 17U) {
      {
#line 795
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 795
        if (! (k < 3U)) {
#line 795
          goto while_break___9;
        }
#line 795
        if (inptr < insize) {
#line 795
          tmp___20 = inptr;
#line 795
          inptr ++;
#line 795
          tmp___22 = (int )inbuf[tmp___20];
        } else {
          {
#line 795
          tmp___21 = fill_inbuf(0);
#line 795
          tmp___22 = tmp___21;
          }
        }
#line 795
        b |= (ulg )((uch )tmp___22) << k;
#line 795
        k += 8U;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 796
      j___0 = 3U + ((unsigned int )b & 7U);
#line 797
      b >>= 3;
#line 797
      k -= 3U;
#line 798
      if ((unsigned int )i___0 + j___0 > n) {
#line 799
        return (1);
      }
      {
#line 800
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 800
        tmp___24 = j___0;
#line 800
        j___0 --;
#line 800
        if (! tmp___24) {
#line 800
          goto while_break___10;
        }
#line 801
        tmp___23 = i___0;
#line 801
        i___0 ++;
#line 801
        ll[tmp___23] = 0U;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 802
      l = 0U;
    } else {
      {
#line 806
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 806
        if (! (k < 7U)) {
#line 806
          goto while_break___11;
        }
#line 806
        if (inptr < insize) {
#line 806
          tmp___25 = inptr;
#line 806
          inptr ++;
#line 806
          tmp___27 = (int )inbuf[tmp___25];
        } else {
          {
#line 806
          tmp___26 = fill_inbuf(0);
#line 806
          tmp___27 = tmp___26;
          }
        }
#line 806
        b |= (ulg )((uch )tmp___27) << k;
#line 806
        k += 8U;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 807
      j___0 = 11U + ((unsigned int )b & 127U);
#line 808
      b >>= 7;
#line 808
      k -= 7U;
#line 809
      if ((unsigned int )i___0 + j___0 > n) {
#line 810
        return (1);
      }
      {
#line 811
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 811
        tmp___29 = j___0;
#line 811
        j___0 --;
#line 811
        if (! tmp___29) {
#line 811
          goto while_break___12;
        }
#line 812
        tmp___28 = i___0;
#line 812
        i___0 ++;
#line 812
        ll[tmp___28] = 0U;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 813
      l = 0U;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 819
  huft_free(tl);
#line 823
  bb = b;
#line 824
  bk = k;
#line 828
  bl = lbits;
#line 829
  i___0 = huft_build(ll, nl, 257U, cplens, cplext, & tl, & bl);
  }
#line 829
  if (i___0 != 0) {
#line 831
    if (i___0 == 1) {
      {
#line 832
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" incomplete literal tree\n");
#line 833
      huft_free(tl);
      }
    }
#line 835
    return (i___0);
  }
  {
#line 837
  bd = dbits;
#line 838
  i___0 = huft_build(ll + nl, nd, 0U, cpdist, cpdext, & td, & bd);
  }
#line 838
  if (i___0 != 0) {
#line 840
    if (i___0 == 1) {
      {
#line 841
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" incomplete distance tree\n");
#line 846
      huft_free(td);
      }
    }
    {
#line 848
    huft_free(tl);
    }
#line 849
    return (i___0);
  }
  {
#line 855
  tmp___30 = inflate_codes(tl, td, bl, bd);
  }
#line 855
  if (tmp___30) {
#line 856
    return (1);
  }
  {
#line 860
  huft_free(tl);
#line 861
  huft_free(td);
  }
#line 862
  return (0);
}
}
#line 867 "/home/kihong/gzip-1.2.4a/inflate.c"
int inflate_block(int *e ) 
{ 
  unsigned int t ;
  register ulg b ;
  register unsigned int k ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 877
  b = bb;
#line 878
  k = bk;
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (! (k < 1U)) {
#line 882
      goto while_break;
    }
#line 882
    if (inptr < insize) {
#line 882
      tmp = inptr;
#line 882
      inptr ++;
#line 882
      tmp___1 = (int )inbuf[tmp];
    } else {
      {
#line 882
      tmp___0 = fill_inbuf(0);
#line 882
      tmp___1 = tmp___0;
      }
    }
#line 882
    b |= (ulg )((uch )tmp___1) << k;
#line 882
    k += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  *e = (int )b & 1;
#line 884
  b >>= 1;
#line 884
  k --;
  {
#line 888
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 888
    if (! (k < 2U)) {
#line 888
      goto while_break___0;
    }
#line 888
    if (inptr < insize) {
#line 888
      tmp___2 = inptr;
#line 888
      inptr ++;
#line 888
      tmp___4 = (int )inbuf[tmp___2];
    } else {
      {
#line 888
      tmp___3 = fill_inbuf(0);
#line 888
      tmp___4 = tmp___3;
      }
    }
#line 888
    b |= (ulg )((uch )tmp___4) << k;
#line 888
    k += 8U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 889
  t = (unsigned int )b & 3U;
#line 890
  b >>= 2;
#line 890
  k -= 2U;
#line 894
  bb = b;
#line 895
  bk = k;
#line 899
  if (t == 2U) {
    {
#line 900
    tmp___5 = inflate_dynamic();
    }
#line 900
    return (tmp___5);
  }
#line 901
  if (t == 0U) {
    {
#line 902
    tmp___6 = inflate_stored();
    }
#line 902
    return (tmp___6);
  }
#line 903
  if (t == 1U) {
    {
#line 904
    tmp___7 = inflate_fixed();
    }
#line 904
    return (tmp___7);
  }
#line 908
  return (2);
}
}
#line 913 "/home/kihong/gzip-1.2.4a/inflate.c"
int inflate(void) 
{ 
  int e ;
  int r ;
  unsigned int h ;

  {
#line 922
  outcnt = 0U;
#line 923
  bk = 0U;
#line 924
  bb = (ulg )0;
#line 928
  h = 0U;
  {
#line 929
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 930
    hufts = 0U;
#line 931
    r = inflate_block(& e);
    }
#line 931
    if (r != 0) {
#line 932
      return (r);
    }
#line 933
    if (hufts > h) {
#line 934
      h = hufts;
    }
#line 929
    if (! (! e)) {
#line 929
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 940
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 940
    if (! (bk >= 8U)) {
#line 940
      goto while_break___0;
    }
#line 941
    bk -= 8U;
#line 942
    inptr --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 946
  outcnt = outcnt;
#line 946
  flush_window();
  }
#line 953
  return (0);
}
}
#line 61 "/home/kihong/gzip-1.2.4a/gzip.h"
int method ;
#line 193 "/home/kihong/gzip-1.2.4a/gzip.h"
int decrypt  ;
#line 266
int unzip(int in , int out ) ;
#line 267
int check_zipfile(int in ) ;
#line 43 "/home/kihong/gzip-1.2.4a/unzip.c"
char *key  ;
#line 44 "/home/kihong/gzip-1.2.4a/unzip.c"
int pkzip  =    0;
#line 45 "/home/kihong/gzip-1.2.4a/unzip.c"
int ext_header  =    0;
#line 51 "/home/kihong/gzip-1.2.4a/unzip.c"
int check_zipfile(int in ) 
{ 
  uch *h ;

  {
#line 54
  h = inbuf + inptr;
#line 56
  ifd = in;
#line 59
  inptr += (unsigned int )((30 + ((int )((ush )*((h + 26) + 0)) | ((int )((ush )*((h + 26) + 1)) << 8))) + ((int )((ush )*((h + 28) + 0)) | ((int )((ush )*((h + 28) + 1)) << 8)));
#line 61
  if (inptr > insize) {
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: not a valid zip file\n",
            progname, ifname);
#line 64
    exit_code = 1;
    }
#line 65
    return (1);
  } else
#line 61
  if (((ulg )((int )((ush )*(h + 0)) | ((int )((ush )*(h + 1)) << 8)) | ((ulg )((int )((ush )*((h + 2) + 0)) | ((int )((ush )*((h + 2) + 1)) << 8)) << 16)) != 67324752UL) {
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: not a valid zip file\n",
            progname, ifname);
#line 64
    exit_code = 1;
    }
#line 65
    return (1);
  }
#line 67
  method = (int )*(h + 8);
#line 68
  if (method != 0) {
#line 68
    if (method != 8) {
      {
#line 69
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: first entry not deflated or stored -- use unzip\n",
              progname, ifname);
#line 72
      exit_code = 1;
      }
#line 73
      return (1);
    }
  }
#line 77
  decrypt = (int )*(h + 6) & 1;
#line 77
  if (decrypt != 0) {
    {
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: encrypted file -- use unzip\n",
            progname, ifname);
#line 80
    exit_code = 1;
    }
#line 81
    return (1);
  }
#line 85
  ext_header = ((int )*(h + 6) & 8) != 0;
#line 86
  pkzip = 1;
#line 89
  return (0);
}
}
#line 99 "/home/kihong/gzip-1.2.4a/unzip.c"
int unzip(int in , int out ) 
{ 
  ulg orig_crc ;
  ulg orig_len___0 ;
  int n ;
  uch buf[16] ;
  int res ;
  int tmp ;
  register ulg n___0 ;
  int tmp___0 ;
  uch c ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  ulg tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  ulg tmp___12 ;

  {
  {
#line 102
  orig_crc = (ulg )0;
#line 103
  orig_len___0 = (ulg )0;
#line 107
  ifd = in;
#line 108
  ofd = out;
#line 110
  updcrc((uch *)((void *)0), 0U);
  }
#line 112
  if (pkzip) {
#line 112
    if (! ext_header) {
#line 113
      orig_crc = (ulg )((int )((ush )*((inbuf + 14) + 0)) | ((int )((ush )*((inbuf + 14) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 14) + 2) + 0)) | ((int )((ush )*(((inbuf + 14) + 2) + 1)) << 8)) << 16);
#line 114
      orig_len___0 = (ulg )((int )((ush )*((inbuf + 22) + 0)) | ((int )((ush )*((inbuf + 22) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 22) + 2) + 0)) | ((int )((ush )*(((inbuf + 22) + 2) + 1)) << 8)) << 16);
    }
  }
#line 118
  if (method == 8) {
    {
#line 120
    tmp = inflate();
#line 120
    res = tmp;
    }
#line 122
    if (res == 3) {
      {
#line 123
      error((char *)"out of memory");
      }
    } else
#line 124
    if (res != 0) {
      {
#line 125
      error((char *)"invalid compressed data--format violated");
      }
    }
  } else
#line 128
  if (pkzip) {
#line 128
    if (method == 0) {
#line 130
      n___0 = (ulg )((int )((ush )*((inbuf + 22) + 0)) | ((int )((ush )*((inbuf + 22) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 22) + 2) + 0)) | ((int )((ush )*(((inbuf + 22) + 2) + 1)) << 8)) << 16);
#line 132
      if (decrypt) {
#line 132
        tmp___0 = 12;
      } else {
#line 132
        tmp___0 = 0;
      }
#line 132
      if (n___0 != ((ulg )((int )((ush )*((inbuf + 18) + 0)) | ((int )((ush )*((inbuf + 18) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 18) + 2) + 0)) | ((int )((ush )*(((inbuf + 18) + 2) + 1)) << 8)) << 16)) - (unsigned long )tmp___0) {
        {
#line 134
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"len %ld, siz %ld\n",
                n___0, (ulg )((int )((ush )*((inbuf + 18) + 0)) | ((int )((ush )*((inbuf + 18) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + 18) + 2) + 0)) | ((int )((ush )*(((inbuf + 18) + 2) + 1)) << 8)) << 16));
#line 135
        error((char *)"invalid compressed data--length mismatch");
        }
      }
      {
#line 137
      while (1) {
        while_continue: /* CIL Label */ ;
#line 137
        tmp___5 = n___0;
#line 137
        n___0 --;
#line 137
        if (! tmp___5) {
#line 137
          goto while_break;
        }
#line 138
        if (inptr < insize) {
#line 138
          tmp___1 = inptr;
#line 138
          inptr ++;
#line 138
          tmp___3 = (int )inbuf[tmp___1];
        } else {
          {
#line 138
          tmp___2 = fill_inbuf(0);
#line 138
          tmp___3 = tmp___2;
          }
        }
#line 138
        c = (uch )tmp___3;
#line 142
        tmp___4 = outcnt;
#line 142
        outcnt ++;
#line 142
        window[tmp___4] = c;
#line 142
        if (outcnt == 32768U) {
          {
#line 142
          flush_window();
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 144
      flush_window();
      }
    } else {
      {
#line 146
      error((char *)"internal error, invalid method");
      }
    }
  } else {
    {
#line 146
    error((char *)"internal error, invalid method");
    }
  }
#line 150
  if (! pkzip) {
#line 154
    n = 0;
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 154
      if (! (n < 8)) {
#line 154
        goto while_break___0;
      }
#line 155
      if (inptr < insize) {
#line 155
        tmp___6 = inptr;
#line 155
        inptr ++;
#line 155
        tmp___8 = (int )inbuf[tmp___6];
      } else {
        {
#line 155
        tmp___7 = fill_inbuf(0);
#line 155
        tmp___8 = tmp___7;
        }
      }
#line 155
      buf[n] = (uch )tmp___8;
#line 154
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 157
    orig_crc = (ulg )((int )((ush )buf[0]) | ((int )((ush )buf[1]) << 8)) | ((ulg )((int )((ush )*((buf + 2) + 0)) | ((int )((ush )*((buf + 2) + 1)) << 8)) << 16);
#line 158
    orig_len___0 = (ulg )((int )((ush )*((buf + 4) + 0)) | ((int )((ush )*((buf + 4) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 4) + 2) + 0)) | ((int )((ush )*(((buf + 4) + 2) + 1)) << 8)) << 16);
  } else
#line 160
  if (ext_header) {
#line 166
    n = 0;
    {
#line 166
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 166
      if (! (n < 16)) {
#line 166
        goto while_break___1;
      }
#line 167
      if (inptr < insize) {
#line 167
        tmp___9 = inptr;
#line 167
        inptr ++;
#line 167
        tmp___11 = (int )inbuf[tmp___9];
      } else {
        {
#line 167
        tmp___10 = fill_inbuf(0);
#line 167
        tmp___11 = tmp___10;
        }
      }
#line 167
      buf[n] = (uch )tmp___11;
#line 166
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 169
    orig_crc = (ulg )((int )((ush )*((buf + 4) + 0)) | ((int )((ush )*((buf + 4) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 4) + 2) + 0)) | ((int )((ush )*(((buf + 4) + 2) + 1)) << 8)) << 16);
#line 170
    orig_len___0 = (ulg )((int )((ush )*((buf + 12) + 0)) | ((int )((ush )*((buf + 12) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 12) + 2) + 0)) | ((int )((ush )*(((buf + 12) + 2) + 1)) << 8)) << 16);
  }
  {
#line 174
  tmp___12 = updcrc(outbuf, 0U);
  }
#line 174
  if (orig_crc != tmp___12) {
    {
#line 175
    error((char *)"invalid compressed data--crc error");
    }
  }
#line 177
  if (orig_len___0 != (ulg )bytes_out) {
    {
#line 178
    error((char *)"invalid compressed data--length error");
    }
  }
#line 182
  if (pkzip) {
#line 182
    if (inptr + 4U < insize) {
#line 182
      if (((ulg )((int )((ush )*((inbuf + inptr) + 0)) | ((int )((ush )*((inbuf + inptr) + 1)) << 8)) | ((ulg )((int )((ush )*(((inbuf + inptr) + 2) + 0)) | ((int )((ush )*(((inbuf + inptr) + 2) + 1)) << 8)) << 16)) == 67324752UL) {
#line 183
        if (to_stdout) {
#line 184
          if (! quiet) {
            {
#line 184
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has more than one entry--rest ignored\n",
                    progname, ifname);
            }
          }
#line 184
          if (exit_code == 0) {
#line 184
            exit_code = 2;
          }
        } else {
          {
#line 189
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has more than one entry -- unchanged\n",
                  progname, ifname);
#line 192
          exit_code = 1;
#line 193
          pkzip = 0;
#line 193
          ext_header = pkzip;
          }
#line 194
          return (1);
        }
      }
    }
  }
#line 197
  pkzip = 0;
#line 197
  ext_header = pkzip;
#line 198
  return (0);
}
}
#line 263 "/home/kihong/gzip-1.2.4a/gzip.h"
int file_read(char *buf , unsigned int size ) ;
#line 288
void bi_init(file_t zipfile ) ;
#line 289
void send_bits(int value , int length ) ;
#line 290
unsigned int bi_reverse(unsigned int code , int len ) ;
#line 291
void bi_windup(void) ;
#line 292
void copy_block(char *buf , unsigned int len , int header ) ;
#line 293 "/home/kihong/gzip-1.2.4a/gzip.h"
int (*read_buf)(char *buf , unsigned int size )  ;
#line 70 "/home/kihong/gzip-1.2.4a/bits.c"
static file_t zfile  ;
#line 72 "/home/kihong/gzip-1.2.4a/bits.c"
static unsigned short bi_buf  ;
#line 82 "/home/kihong/gzip-1.2.4a/bits.c"
static int bi_valid  ;
#line 97 "/home/kihong/gzip-1.2.4a/bits.c"
void bi_init(file_t zipfile ) 
{ 


  {
#line 100
  zfile = zipfile;
#line 101
  bi_buf = (unsigned short)0;
#line 102
  bi_valid = 0;
#line 110
  if (zfile != -1) {
#line 111
    read_buf = & file_read;
  }
#line 113
  return;
}
}
#line 119 "/home/kihong/gzip-1.2.4a/bits.c"
void send_bits(int value , int length ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 132
  if (bi_valid > (int )(16UL * sizeof(char )) - length) {
#line 133
    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
#line 134
    if (outcnt < 16382U) {
#line 134
      tmp = outcnt;
#line 134
      outcnt ++;
#line 134
      outbuf[tmp] = (uch )((int )bi_buf & 255);
#line 134
      tmp___0 = outcnt;
#line 134
      outcnt ++;
#line 134
      outbuf[tmp___0] = (uch )((int )bi_buf >> 8);
    } else {
#line 134
      tmp___1 = outcnt;
#line 134
      outcnt ++;
#line 134
      outbuf[tmp___1] = (uch )((int )bi_buf & 255);
#line 134
      if (outcnt == 16384U) {
        {
#line 134
        flush_outbuf();
        }
      }
#line 134
      tmp___2 = outcnt;
#line 134
      outcnt ++;
#line 134
      outbuf[tmp___2] = (uch )((int )bi_buf >> 8);
#line 134
      if (outcnt == 16384U) {
        {
#line 134
        flush_outbuf();
        }
      }
    }
#line 135
    bi_buf = (unsigned short )((int )((ush )value) >> (16UL * sizeof(char ) - (unsigned long )bi_valid));
#line 136
    bi_valid = (int )((unsigned long )bi_valid + ((unsigned long )length - 16UL * sizeof(char )));
  } else {
#line 138
    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
#line 139
    bi_valid += length;
  }
#line 141
  return;
}
}
#line 148 "/home/kihong/gzip-1.2.4a/bits.c"
unsigned int bi_reverse(unsigned int code , int len ) 
{ 
  register unsigned int res ;

  {
#line 152
  res = 0U;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    res |= code & 1U;
#line 155
    code >>= 1;
#line 155
    res <<= 1;
#line 153
    len --;
#line 153
    if (! (len > 0)) {
#line 153
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return (res >> 1);
}
}
#line 163 "/home/kihong/gzip-1.2.4a/bits.c"
void bi_windup(void) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 165
  if (bi_valid > 8) {
#line 166
    if (outcnt < 16382U) {
#line 166
      tmp = outcnt;
#line 166
      outcnt ++;
#line 166
      outbuf[tmp] = (uch )((int )bi_buf & 255);
#line 166
      tmp___0 = outcnt;
#line 166
      outcnt ++;
#line 166
      outbuf[tmp___0] = (uch )((int )bi_buf >> 8);
    } else {
#line 166
      tmp___1 = outcnt;
#line 166
      outcnt ++;
#line 166
      outbuf[tmp___1] = (uch )((int )bi_buf & 255);
#line 166
      if (outcnt == 16384U) {
        {
#line 166
        flush_outbuf();
        }
      }
#line 166
      tmp___2 = outcnt;
#line 166
      outcnt ++;
#line 166
      outbuf[tmp___2] = (uch )((int )bi_buf >> 8);
#line 166
      if (outcnt == 16384U) {
        {
#line 166
        flush_outbuf();
        }
      }
    }
  } else
#line 167
  if (bi_valid > 0) {
#line 168
    tmp___3 = outcnt;
#line 168
    outcnt ++;
#line 168
    outbuf[tmp___3] = (uch )bi_buf;
#line 168
    if (outcnt == 16384U) {
      {
#line 168
      flush_outbuf();
      }
    }
  }
#line 170
  bi_buf = (unsigned short)0;
#line 171
  bi_valid = 0;
#line 175
  return;
}
}
#line 181 "/home/kihong/gzip-1.2.4a/bits.c"
void copy_block(char *buf , unsigned int len , int header ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;

  {
  {
#line 186
  bi_windup();
  }
#line 188
  if (header) {
#line 189
    if (outcnt < 16382U) {
#line 189
      tmp = outcnt;
#line 189
      outcnt ++;
#line 189
      outbuf[tmp] = (uch )((int )((ush )len) & 255);
#line 189
      tmp___0 = outcnt;
#line 189
      outcnt ++;
#line 189
      outbuf[tmp___0] = (uch )((int )((ush )len) >> 8);
    } else {
#line 189
      tmp___1 = outcnt;
#line 189
      outcnt ++;
#line 189
      outbuf[tmp___1] = (uch )((int )((ush )len) & 255);
#line 189
      if (outcnt == 16384U) {
        {
#line 189
        flush_outbuf();
        }
      }
#line 189
      tmp___2 = outcnt;
#line 189
      outcnt ++;
#line 189
      outbuf[tmp___2] = (uch )((int )((ush )len) >> 8);
#line 189
      if (outcnt == 16384U) {
        {
#line 189
        flush_outbuf();
        }
      }
    }
#line 190
    if (outcnt < 16382U) {
#line 190
      tmp___3 = outcnt;
#line 190
      outcnt ++;
#line 190
      outbuf[tmp___3] = (uch )((int )((ush )(~ len)) & 255);
#line 190
      tmp___4 = outcnt;
#line 190
      outcnt ++;
#line 190
      outbuf[tmp___4] = (uch )((int )((ush )(~ len)) >> 8);
    } else {
#line 190
      tmp___5 = outcnt;
#line 190
      outcnt ++;
#line 190
      outbuf[tmp___5] = (uch )((int )((ush )(~ len)) & 255);
#line 190
      if (outcnt == 16384U) {
        {
#line 190
        flush_outbuf();
        }
      }
#line 190
      tmp___6 = outcnt;
#line 190
      outcnt ++;
#line 190
      outbuf[tmp___6] = (uch )((int )((ush )(~ len)) >> 8);
#line 190
      if (outcnt == 16384U) {
        {
#line 190
        flush_outbuf();
        }
      }
    }
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    tmp___9 = len;
#line 198
    len --;
#line 198
    if (! tmp___9) {
#line 198
      goto while_break;
    }
#line 203
    tmp___7 = outcnt;
#line 203
    outcnt ++;
#line 203
    tmp___8 = buf;
#line 203
    buf ++;
#line 203
    outbuf[tmp___7] = (uch )*tmp___8;
#line 203
    if (outcnt == 16384U) {
      {
#line 203
      flush_outbuf();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 197 "/home/kihong/gzip-1.2.4a/gzip.h"
int level ;
#line 283
void ct_init(ush *attr , int *methodp ) ;
#line 284
int ct_tally(int dist , int lc ) ;
#line 285
ulg flush_block(char *buf , ulg stored_len , int eof ) ;
#line 94 "/home/kihong/gzip-1.2.4a/trees.c"
static int extra_lbits[29]  = 
#line 94 "/home/kihong/gzip-1.2.4a/trees.c"
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        1,      1,      1,      1, 
        2,      2,      2,      2, 
        3,      3,      3,      3, 
        4,      4,      4,      4, 
        5,      5,      5,      5, 
        0};
#line 97 "/home/kihong/gzip-1.2.4a/trees.c"
static int extra_dbits[30]  = 
#line 97
  {      0,      0,      0,      0, 
        1,      1,      2,      2, 
        3,      3,      4,      4, 
        5,      5,      6,      6, 
        7,      7,      8,      8, 
        9,      9,      10,      10, 
        11,      11,      12,      12, 
        13,      13};
#line 100 "/home/kihong/gzip-1.2.4a/trees.c"
static int extra_blbits[19]  = 
#line 100
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        2,      3,      7};
#line 179 "/home/kihong/gzip-1.2.4a/trees.c"
static ct_data dyn_ltree[573]  ;
#line 180 "/home/kihong/gzip-1.2.4a/trees.c"
static ct_data dyn_dtree[61]  ;
#line 182 "/home/kihong/gzip-1.2.4a/trees.c"
static ct_data static_ltree[288]  ;
#line 189 "/home/kihong/gzip-1.2.4a/trees.c"
static ct_data static_dtree[30]  ;
#line 194 "/home/kihong/gzip-1.2.4a/trees.c"
static ct_data bl_tree[39]  ;
#line 207 "/home/kihong/gzip-1.2.4a/trees.c"
static tree_desc l_desc  =    {dyn_ltree, static_ltree, extra_lbits, 257, 286, 15, 0};
#line 210 "/home/kihong/gzip-1.2.4a/trees.c"
static tree_desc d_desc  =    {dyn_dtree, static_dtree, extra_dbits, 0, 30, 15, 0};
#line 213 "/home/kihong/gzip-1.2.4a/trees.c"
static tree_desc bl_desc  =    {bl_tree, (ct_data *)0, extra_blbits, 0, 19, 7, 0};
#line 217 "/home/kihong/gzip-1.2.4a/trees.c"
static ush bl_count[16]  ;
#line 220 "/home/kihong/gzip-1.2.4a/trees.c"
static uch bl_order[19]  = 
#line 220
  {      (uch )16,      (uch )17,      (uch )18,      (uch )0, 
        (uch )8,      (uch )7,      (uch )9,      (uch )6, 
        (uch )10,      (uch )5,      (uch )11,      (uch )4, 
        (uch )12,      (uch )3,      (uch )13,      (uch )2, 
        (uch )14,      (uch )1,      (uch )15};
#line 226 "/home/kihong/gzip-1.2.4a/trees.c"
static int heap[573]  ;
#line 227 "/home/kihong/gzip-1.2.4a/trees.c"
static int heap_len  ;
#line 228 "/home/kihong/gzip-1.2.4a/trees.c"
static int heap_max  ;
#line 233 "/home/kihong/gzip-1.2.4a/trees.c"
static uch depth[573]  ;
#line 236 "/home/kihong/gzip-1.2.4a/trees.c"
static uch length_code[256]  ;
#line 239 "/home/kihong/gzip-1.2.4a/trees.c"
static uch dist_code[512]  ;
#line 245 "/home/kihong/gzip-1.2.4a/trees.c"
static int base_length[29]  ;
#line 248 "/home/kihong/gzip-1.2.4a/trees.c"
static int base_dist[30]  ;
#line 256 "/home/kihong/gzip-1.2.4a/trees.c"
static uch flag_buf[4096]  ;
#line 261 "/home/kihong/gzip-1.2.4a/trees.c"
static unsigned int last_lit  ;
#line 262 "/home/kihong/gzip-1.2.4a/trees.c"
static unsigned int last_dist  ;
#line 263 "/home/kihong/gzip-1.2.4a/trees.c"
static unsigned int last_flags  ;
#line 264 "/home/kihong/gzip-1.2.4a/trees.c"
static uch flags  ;
#line 265 "/home/kihong/gzip-1.2.4a/trees.c"
static uch flag_bit  ;
#line 271 "/home/kihong/gzip-1.2.4a/trees.c"
static ulg opt_len  ;
#line 272 "/home/kihong/gzip-1.2.4a/trees.c"
static ulg static_len  ;
#line 274 "/home/kihong/gzip-1.2.4a/trees.c"
static ulg compressed_len  ;
#line 276 "/home/kihong/gzip-1.2.4a/trees.c"
static ulg input_len  ;
#line 279 "/home/kihong/gzip-1.2.4a/trees.c"
ush *file_type  ;
#line 280 "/home/kihong/gzip-1.2.4a/trees.c"
int *file_method  ;
#line 287
long block_start ;
#line 288
unsigned int strstart ;
#line 294
static void init_block(void) ;
#line 295
static void pqdownheap(ct_data *tree , int k ) ;
#line 296
static void gen_bitlen(tree_desc *desc ) ;
#line 297
static void gen_codes(ct_data *tree , int max_code ) ;
#line 298
static void build_tree___0(tree_desc *desc ) ;
#line 299
static void scan_tree(ct_data *tree , int max_code ) ;
#line 300
static void send_tree(ct_data *tree , int max_code ) ;
#line 301
static int build_bl_tree(void) ;
#line 302
static void send_all_trees(int lcodes , int dcodes , int blcodes ) ;
#line 303
static void compress_block(ct_data *ltree , ct_data *dtree ) ;
#line 304
static void set_file_type(void) ;
#line 332 "/home/kihong/gzip-1.2.4a/trees.c"
void ct_init(ush *attr , int *methodp ) 
{ 
  int n ;
  int bits ;
  int length ;
  int code ;
  int dist ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 342
  file_type = attr;
#line 343
  file_method = methodp;
#line 344
  input_len = (ulg )0L;
#line 344
  compressed_len = input_len;
#line 346
  if ((int )static_dtree[0].dl.len != 0) {
#line 346
    return;
  }
#line 349
  length = 0;
#line 350
  code = 0;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (code < 28)) {
#line 350
      goto while_break;
    }
#line 351
    base_length[code] = length;
#line 352
    n = 0;
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (! (n < 1 << extra_lbits[code])) {
#line 352
        goto while_break___0;
      }
#line 353
      tmp = length;
#line 353
      length ++;
#line 353
      length_code[tmp] = (uch )code;
#line 352
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 350
    code ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  length_code[length - 1] = (uch )code;
#line 364
  dist = 0;
#line 365
  code = 0;
  {
#line 365
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 365
    if (! (code < 16)) {
#line 365
      goto while_break___1;
    }
#line 366
    base_dist[code] = dist;
#line 367
    n = 0;
    {
#line 367
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 367
      if (! (n < 1 << extra_dbits[code])) {
#line 367
        goto while_break___2;
      }
#line 368
      tmp___0 = dist;
#line 368
      dist ++;
#line 368
      dist_code[tmp___0] = (uch )code;
#line 367
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 365
    code ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 372
  dist >>= 7;
  {
#line 373
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 373
    if (! (code < 30)) {
#line 373
      goto while_break___3;
    }
#line 374
    base_dist[code] = dist << 7;
#line 375
    n = 0;
    {
#line 375
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 375
      if (! (n < 1 << (extra_dbits[code] - 7))) {
#line 375
        goto while_break___4;
      }
#line 376
      tmp___1 = dist;
#line 376
      dist ++;
#line 376
      dist_code[256 + tmp___1] = (uch )code;
#line 375
      n ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 373
    code ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 382
  bits = 0;
  {
#line 382
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 382
    if (! (bits <= 15)) {
#line 382
      goto while_break___5;
    }
#line 382
    bl_count[bits] = (ush )0;
#line 382
    bits ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 383
  n = 0;
  {
#line 384
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 384
    if (! (n <= 143)) {
#line 384
      goto while_break___6;
    }
#line 384
    tmp___2 = n;
#line 384
    n ++;
#line 384
    static_ltree[tmp___2].dl.len = (ush )8;
#line 384
    bl_count[8] = (ush )((int )bl_count[8] + 1);
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 385
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 385
    if (! (n <= 255)) {
#line 385
      goto while_break___7;
    }
#line 385
    tmp___3 = n;
#line 385
    n ++;
#line 385
    static_ltree[tmp___3].dl.len = (ush )9;
#line 385
    bl_count[9] = (ush )((int )bl_count[9] + 1);
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 386
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 386
    if (! (n <= 279)) {
#line 386
      goto while_break___8;
    }
#line 386
    tmp___4 = n;
#line 386
    n ++;
#line 386
    static_ltree[tmp___4].dl.len = (ush )7;
#line 386
    bl_count[7] = (ush )((int )bl_count[7] + 1);
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 387
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 387
    if (! (n <= 287)) {
#line 387
      goto while_break___9;
    }
#line 387
    tmp___5 = n;
#line 387
    n ++;
#line 387
    static_ltree[tmp___5].dl.len = (ush )8;
#line 387
    bl_count[8] = (ush )((int )bl_count[8] + 1);
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 392
  gen_codes(static_ltree, 287);
#line 395
  n = 0;
  }
  {
#line 395
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 395
    if (! (n < 30)) {
#line 395
      goto while_break___10;
    }
    {
#line 396
    static_dtree[n].dl.len = (ush )5;
#line 397
    tmp___6 = bi_reverse((unsigned int )n, 5);
#line 397
    static_dtree[n].fc.code = (ush )tmp___6;
#line 395
    n ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 401
  init_block();
  }
#line 402
  return;
}
}
#line 407 "/home/kihong/gzip-1.2.4a/trees.c"
static void init_block(void) 
{ 
  int n ;

  {
#line 412
  n = 0;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! (n < 286)) {
#line 412
      goto while_break;
    }
#line 412
    dyn_ltree[n].fc.freq = (ush )0;
#line 412
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  n = 0;
  {
#line 413
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 413
    if (! (n < 30)) {
#line 413
      goto while_break___0;
    }
#line 413
    dyn_dtree[n].fc.freq = (ush )0;
#line 413
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 414
  n = 0;
  {
#line 414
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 414
    if (! (n < 19)) {
#line 414
      goto while_break___1;
    }
#line 414
    bl_tree[n].fc.freq = (ush )0;
#line 414
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 416
  dyn_ltree[256].fc.freq = (ush )1;
#line 417
  static_len = (ulg )0L;
#line 417
  opt_len = static_len;
#line 418
  last_flags = 0U;
#line 418
  last_dist = last_flags;
#line 418
  last_lit = last_dist;
#line 419
  flags = (uch )0;
#line 419
  flag_bit = (uch )1;
#line 420
  return;
}
}
#line 451 "/home/kihong/gzip-1.2.4a/trees.c"
static void pqdownheap(ct_data *tree , int k ) 
{ 
  int v ;
  int j___0 ;

  {
#line 455
  v = heap[k];
#line 456
  j___0 = k << 1;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! (j___0 <= heap_len)) {
#line 457
      goto while_break;
    }
#line 459
    if (j___0 < heap_len) {
#line 459
      if ((int )(tree + heap[j___0 + 1])->fc.freq < (int )(tree + heap[j___0])->fc.freq) {
#line 459
        j___0 ++;
      } else
#line 459
      if ((int )(tree + heap[j___0 + 1])->fc.freq == (int )(tree + heap[j___0])->fc.freq) {
#line 459
        if ((int )depth[heap[j___0 + 1]] <= (int )depth[heap[j___0]]) {
#line 459
          j___0 ++;
        }
      }
    }
#line 462
    if ((int )(tree + v)->fc.freq < (int )(tree + heap[j___0])->fc.freq) {
#line 462
      goto while_break;
    } else
#line 462
    if ((int )(tree + v)->fc.freq == (int )(tree + heap[j___0])->fc.freq) {
#line 462
      if ((int )depth[v] <= (int )depth[heap[j___0]]) {
#line 462
        goto while_break;
      }
    }
#line 465
    heap[k] = heap[j___0];
#line 465
    k = j___0;
#line 468
    j___0 <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  heap[k] = v;
#line 471
  return;
}
}
#line 483 "/home/kihong/gzip-1.2.4a/trees.c"
static void gen_bitlen(tree_desc *desc ) 
{ 
  ct_data *tree ;
  int *extra ;
  int base ;
  int max_code ;
  int max_length ;
  ct_data *stree ;
  int h ;
  int n ;
  int m ;
  int bits ;
  int xbits ;
  ush f ;
  int overflow ;

  {
#line 486
  tree = desc->dyn_tree;
#line 487
  extra = desc->extra_bits;
#line 488
  base = desc->extra_base;
#line 489
  max_code = desc->max_code;
#line 490
  max_length = desc->max_length;
#line 491
  stree = desc->static_tree;
#line 497
  overflow = 0;
#line 499
  bits = 0;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (bits <= 15)) {
#line 499
      goto while_break;
    }
#line 499
    bl_count[bits] = (ush )0;
#line 499
    bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  (tree + heap[heap_max])->dl.len = (ush )0;
#line 506
  h = heap_max + 1;
  {
#line 506
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 506
    if (! (h < 573)) {
#line 506
      goto while_break___0;
    }
#line 507
    n = heap[h];
#line 508
    bits = (int )(tree + (tree + n)->dl.dad)->dl.len + 1;
#line 509
    if (bits > max_length) {
#line 509
      bits = max_length;
#line 509
      overflow ++;
    }
#line 510
    (tree + n)->dl.len = (ush )bits;
#line 513
    if (n > max_code) {
#line 513
      goto __Cont;
    }
#line 515
    bl_count[bits] = (ush )((int )bl_count[bits] + 1);
#line 516
    xbits = 0;
#line 517
    if (n >= base) {
#line 517
      xbits = *(extra + (n - base));
    }
#line 518
    f = (tree + n)->fc.freq;
#line 519
    opt_len += (ulg )f * (ulg )(bits + xbits);
#line 520
    if (stree) {
#line 520
      static_len += (ulg )f * (ulg )((int )(stree + n)->dl.len + xbits);
    }
    __Cont: /* CIL Label */ 
#line 506
    h ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 522
  if (overflow == 0) {
#line 522
    return;
  }
  {
#line 528
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 529
    bits = max_length - 1;
    {
#line 530
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 530
      if (! ((int )bl_count[bits] == 0)) {
#line 530
        goto while_break___2;
      }
#line 530
      bits --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 531
    bl_count[bits] = (ush )((int )bl_count[bits] - 1);
#line 532
    bl_count[bits + 1] = (ush )((int )bl_count[bits + 1] + 2);
#line 533
    bl_count[max_length] = (ush )((int )bl_count[max_length] - 1);
#line 537
    overflow -= 2;
#line 528
    if (! (overflow > 0)) {
#line 528
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 545
  bits = max_length;
  {
#line 545
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 545
    if (! (bits != 0)) {
#line 545
      goto while_break___3;
    }
#line 546
    n = (int )bl_count[bits];
    {
#line 547
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 547
      if (! (n != 0)) {
#line 547
        goto while_break___4;
      }
#line 548
      h --;
#line 548
      m = heap[h];
#line 549
      if (m > max_code) {
#line 549
        goto while_continue___4;
      }
#line 550
      if ((unsigned int )(tree + m)->dl.len != (unsigned int )bits) {
#line 552
        opt_len += (ulg )(((long )bits - (long )(tree + m)->dl.len) * (long )(tree + m)->fc.freq);
#line 553
        (tree + m)->dl.len = (ush )bits;
      }
#line 555
      n --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 545
    bits --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 558
  return;
}
}
#line 568 "/home/kihong/gzip-1.2.4a/trees.c"
static void gen_codes(ct_data *tree , int max_code ) 
{ 
  ush next_code[16] ;
  ush code ;
  int bits ;
  int n ;
  int len ;
  ush tmp ;
  unsigned int tmp___0 ;

  {
#line 573
  code = (ush )0;
#line 580
  bits = 1;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (bits <= 15)) {
#line 580
      goto while_break;
    }
#line 581
    code = (ush )(((int )code + (int )bl_count[bits - 1]) << 1);
#line 581
    next_code[bits] = code;
#line 580
    bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  n = 0;
  {
#line 590
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 590
    if (! (n <= max_code)) {
#line 590
      goto while_break___0;
    }
#line 591
    len = (int )(tree + n)->dl.len;
#line 592
    if (len == 0) {
#line 592
      goto __Cont;
    }
    {
#line 594
    tmp = next_code[len];
#line 594
    next_code[len] = (ush )((int )next_code[len] + 1);
#line 594
    tmp___0 = bi_reverse((unsigned int )tmp, len);
#line 594
    (tree + n)->fc.code = (ush )tmp___0;
    }
    __Cont: /* CIL Label */ 
#line 590
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 599
  return;
}
}
#line 609 "/home/kihong/gzip-1.2.4a/trees.c"
static void build_tree___0(tree_desc *desc ) 
{ 
  ct_data *tree ;
  ct_data *stree ;
  int elems ;
  int n ;
  int m ;
  int max_code ;
  int node ;
  int new ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ush tmp___2 ;
  int tmp___3 ;

  {
#line 612
  tree = desc->dyn_tree;
#line 613
  stree = desc->static_tree;
#line 614
  elems = desc->elems;
#line 616
  max_code = -1;
#line 617
  node = elems;
#line 623
  heap_len = 0;
#line 623
  heap_max = 573;
#line 625
  n = 0;
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 625
    if (! (n < elems)) {
#line 625
      goto while_break;
    }
#line 626
    if ((int )(tree + n)->fc.freq != 0) {
#line 627
      heap_len ++;
#line 627
      max_code = n;
#line 627
      heap[heap_len] = max_code;
#line 628
      depth[n] = (uch )0;
    } else {
#line 630
      (tree + n)->dl.len = (ush )0;
    }
#line 625
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 639
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 639
    if (! (heap_len < 2)) {
#line 639
      goto while_break___0;
    }
#line 640
    heap_len ++;
#line 640
    if (max_code < 2) {
#line 640
      max_code ++;
#line 640
      tmp = max_code;
    } else {
#line 640
      tmp = 0;
    }
#line 640
    heap[heap_len] = tmp;
#line 640
    new = tmp;
#line 641
    (tree + new)->fc.freq = (ush )1;
#line 642
    depth[new] = (uch )0;
#line 643
    opt_len --;
#line 643
    if (stree) {
#line 643
      static_len -= (ulg )(stree + new)->dl.len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 646
  desc->max_code = max_code;
#line 651
  n = heap_len / 2;
  {
#line 651
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 651
    if (! (n >= 1)) {
#line 651
      goto while_break___1;
    }
    {
#line 651
    pqdownheap(tree, n);
#line 651
    n --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 656
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 657
    n = heap[1];
#line 657
    tmp___0 = heap_len;
#line 657
    heap_len --;
#line 657
    heap[1] = heap[tmp___0];
#line 657
    pqdownheap(tree, 1);
#line 658
    m = heap[1];
#line 660
    heap_max --;
#line 660
    heap[heap_max] = n;
#line 661
    heap_max --;
#line 661
    heap[heap_max] = m;
#line 664
    (tree + node)->fc.freq = (ush )((int )(tree + n)->fc.freq + (int )(tree + m)->fc.freq);
    }
#line 665
    if ((int )depth[n] >= (int )depth[m]) {
#line 665
      tmp___1 = (int )depth[n];
    } else {
#line 665
      tmp___1 = (int )depth[m];
    }
    {
#line 665
    depth[node] = (uch )(tmp___1 + 1);
#line 666
    tmp___2 = (ush )node;
#line 666
    (tree + m)->dl.dad = tmp___2;
#line 666
    (tree + n)->dl.dad = tmp___2;
#line 674
    tmp___3 = node;
#line 674
    node ++;
#line 674
    heap[1] = tmp___3;
#line 675
    pqdownheap(tree, 1);
    }
#line 656
    if (! (heap_len >= 2)) {
#line 656
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 679
  heap_max --;
#line 679
  heap[heap_max] = heap[1];
#line 684
  gen_bitlen(desc);
#line 687
  gen_codes(tree, max_code);
  }
#line 688
  return;
}
}
#line 696 "/home/kihong/gzip-1.2.4a/trees.c"
static void scan_tree(ct_data *tree , int max_code ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;

  {
#line 701
  prevlen = -1;
#line 703
  nextlen = (int )(tree + 0)->dl.len;
#line 704
  count = 0;
#line 705
  max_count = 7;
#line 706
  min_count = 4;
#line 708
  if (nextlen == 0) {
#line 708
    max_count = 138;
#line 708
    min_count = 3;
  }
#line 709
  (tree + (max_code + 1))->dl.len = (ush )65535;
#line 711
  n = 0;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (! (n <= max_code)) {
#line 711
      goto while_break;
    }
#line 712
    curlen = nextlen;
#line 712
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 713
    count ++;
#line 713
    if (count < max_count) {
#line 713
      if (curlen == nextlen) {
#line 714
        goto __Cont;
      } else {
#line 713
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 715
    if (count < min_count) {
#line 716
      bl_tree[curlen].fc.freq = (ush )((int )bl_tree[curlen].fc.freq + count);
    } else
#line 717
    if (curlen != 0) {
#line 718
      if (curlen != prevlen) {
#line 718
        bl_tree[curlen].fc.freq = (ush )((int )bl_tree[curlen].fc.freq + 1);
      }
#line 719
      bl_tree[16].fc.freq = (ush )((int )bl_tree[16].fc.freq + 1);
    } else
#line 720
    if (count <= 10) {
#line 721
      bl_tree[17].fc.freq = (ush )((int )bl_tree[17].fc.freq + 1);
    } else {
#line 723
      bl_tree[18].fc.freq = (ush )((int )bl_tree[18].fc.freq + 1);
    }
#line 725
    count = 0;
#line 725
    prevlen = curlen;
#line 726
    if (nextlen == 0) {
#line 727
      max_count = 138;
#line 727
      min_count = 3;
    } else
#line 728
    if (curlen == nextlen) {
#line 729
      max_count = 6;
#line 729
      min_count = 3;
    } else {
#line 731
      max_count = 7;
#line 731
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 711
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  return;
}
}
#line 740 "/home/kihong/gzip-1.2.4a/trees.c"
static void send_tree(ct_data *tree , int max_code ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;

  {
#line 745
  prevlen = -1;
#line 747
  nextlen = (int )(tree + 0)->dl.len;
#line 748
  count = 0;
#line 749
  max_count = 7;
#line 750
  min_count = 4;
#line 753
  if (nextlen == 0) {
#line 753
    max_count = 138;
#line 753
    min_count = 3;
  }
#line 755
  n = 0;
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    if (! (n <= max_code)) {
#line 755
      goto while_break;
    }
#line 756
    curlen = nextlen;
#line 756
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 757
    count ++;
#line 757
    if (count < max_count) {
#line 757
      if (curlen == nextlen) {
#line 758
        goto __Cont;
      } else {
#line 757
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 759
    if (count < min_count) {
      {
#line 760
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 760
        send_bits((int )bl_tree[curlen].fc.code, (int )bl_tree[curlen].dl.len);
#line 760
        count --;
        }
#line 760
        if (! (count != 0)) {
#line 760
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 762
    if (curlen != 0) {
#line 763
      if (curlen != prevlen) {
        {
#line 764
        send_bits((int )bl_tree[curlen].fc.code, (int )bl_tree[curlen].dl.len);
#line 764
        count --;
        }
      }
      {
#line 767
      send_bits((int )bl_tree[16].fc.code, (int )bl_tree[16].dl.len);
#line 767
      send_bits(count - 3, 2);
      }
    } else
#line 769
    if (count <= 10) {
      {
#line 770
      send_bits((int )bl_tree[17].fc.code, (int )bl_tree[17].dl.len);
#line 770
      send_bits(count - 3, 3);
      }
    } else {
      {
#line 773
      send_bits((int )bl_tree[18].fc.code, (int )bl_tree[18].dl.len);
#line 773
      send_bits(count - 11, 7);
      }
    }
#line 775
    count = 0;
#line 775
    prevlen = curlen;
#line 776
    if (nextlen == 0) {
#line 777
      max_count = 138;
#line 777
      min_count = 3;
    } else
#line 778
    if (curlen == nextlen) {
#line 779
      max_count = 6;
#line 779
      min_count = 3;
    } else {
#line 781
      max_count = 7;
#line 781
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 755
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 784
  return;
}
}
#line 790 "/home/kihong/gzip-1.2.4a/trees.c"
static int build_bl_tree(void) 
{ 
  int max_blindex ;

  {
  {
#line 795
  scan_tree(dyn_ltree, l_desc.max_code);
#line 796
  scan_tree(dyn_dtree, d_desc.max_code);
#line 799
  build_tree___0(& bl_desc);
#line 808
  max_blindex = 18;
  }
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! (max_blindex >= 3)) {
#line 808
      goto while_break;
    }
#line 809
    if ((int )bl_tree[bl_order[max_blindex]].dl.len != 0) {
#line 809
      goto while_break;
    }
#line 808
    max_blindex --;
  }
  while_break: /* CIL Label */ ;
  }
#line 812
  opt_len += (ulg )(((3 * (max_blindex + 1) + 5) + 5) + 4);
#line 815
  return (max_blindex);
}
}
#line 823 "/home/kihong/gzip-1.2.4a/trees.c"
static void send_all_trees(int lcodes , int dcodes , int blcodes ) 
{ 
  int rank ;

  {
  {
#line 832
  send_bits(lcodes - 257, 5);
#line 833
  send_bits(dcodes - 1, 5);
#line 834
  send_bits(blcodes - 4, 4);
#line 835
  rank = 0;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! (rank < blcodes)) {
#line 835
      goto while_break;
    }
    {
#line 837
    send_bits((int )bl_tree[bl_order[rank]].dl.len, 3);
#line 835
    rank ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 841
  send_tree(dyn_ltree, lcodes - 1);
#line 844
  send_tree(dyn_dtree, dcodes - 1);
  }
#line 846
  return;
}
}
#line 853 "/home/kihong/gzip-1.2.4a/trees.c"
ulg flush_block(char *buf , ulg stored_len , int eof ) 
{ 
  ulg opt_lenb ;
  ulg static_lenb ;
  int max_blindex ;

  {
#line 861
  flag_buf[last_flags] = flags;
#line 864
  if ((int )*file_type == 65535) {
    {
#line 864
    set_file_type();
    }
  }
  {
#line 867
  build_tree___0(& l_desc);
#line 870
  build_tree___0(& d_desc);
#line 879
  max_blindex = build_bl_tree();
#line 882
  opt_lenb = ((opt_len + 3UL) + 7UL) >> 3;
#line 883
  static_lenb = ((static_len + 3UL) + 7UL) >> 3;
#line 884
  input_len += stored_len;
  }
#line 890
  if (static_lenb <= opt_lenb) {
#line 890
    opt_lenb = static_lenb;
  }
#line 899
  if (stored_len <= opt_lenb) {
#line 899
    if (eof) {
#line 899
      if (compressed_len == 0UL) {
#line 899
        goto _L___2;
      } else {
#line 899
        goto _L___2;
      }
    } else {
#line 899
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 911
  if (stored_len + 4UL <= opt_lenb) {
#line 911
    if ((unsigned long )buf != (unsigned long )((char *)0)) {
      {
#line 920
      send_bits(eof, 3);
#line 921
      compressed_len = ((compressed_len + 3UL) + 7UL) & 0xfffffffffffffff8UL;
#line 922
      compressed_len += (stored_len + 4UL) << 3;
#line 924
      copy_block(buf, (unsigned int )stored_len, 1);
      }
    } else {
#line 911
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 929
  if (static_lenb == opt_lenb) {
    {
#line 931
    send_bits((1 << 1) + eof, 3);
#line 932
    compress_block(static_ltree, static_dtree);
#line 933
    compressed_len += 3UL + static_len;
    }
  } else {
    {
#line 935
    send_bits((2 << 1) + eof, 3);
#line 936
    send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
#line 937
    compress_block(dyn_ltree, dyn_dtree);
#line 938
    compressed_len += 3UL + opt_len;
    }
  }
  {
#line 941
  init_block();
  }
#line 943
  if (eof) {
    {
#line 945
    bi_windup();
#line 946
    compressed_len += 7UL;
    }
  }
#line 951
  return (compressed_len >> 3);
}
}
#line 958 "/home/kihong/gzip-1.2.4a/trees.c"
int ct_tally(int dist , int lc ) 
{ 
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  ulg out_length ;
  ulg in_length ;
  int dcode ;
  int tmp___3 ;

  {
#line 962
  tmp = last_lit;
#line 962
  last_lit ++;
#line 962
  inbuf[tmp] = (uch )lc;
#line 963
  if (dist == 0) {
#line 965
    dyn_ltree[lc].fc.freq = (ush )((int )dyn_ltree[lc].fc.freq + 1);
  } else {
#line 968
    dist --;
#line 973
    dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq = (ush )((int )dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq + 1);
#line 974
    if (dist < 256) {
#line 974
      tmp___0 = (int )dist_code[dist];
    } else {
#line 974
      tmp___0 = (int )dist_code[256 + (dist >> 7)];
    }
#line 974
    dyn_dtree[tmp___0].fc.freq = (ush )((int )dyn_dtree[tmp___0].fc.freq + 1);
#line 976
    tmp___1 = last_dist;
#line 976
    last_dist ++;
#line 976
    d_buf[tmp___1] = (ush )dist;
#line 977
    flags = (uch )((int )flags | (int )flag_bit);
  }
#line 979
  flag_bit = (uch )((int )flag_bit << 1);
#line 982
  if ((last_lit & 7U) == 0U) {
#line 983
    tmp___2 = last_flags;
#line 983
    last_flags ++;
#line 983
    flag_buf[tmp___2] = flags;
#line 984
    flags = (uch )0;
#line 984
    flag_bit = (uch )1;
  }
#line 987
  if (level > 2) {
#line 987
    if ((last_lit & 4095U) == 0U) {
#line 989
      out_length = (ulg )last_lit * 8UL;
#line 990
      in_length = (ulg )strstart - (ulg )block_start;
#line 992
      dcode = 0;
      {
#line 992
      while (1) {
        while_continue: /* CIL Label */ ;
#line 992
        if (! (dcode < 30)) {
#line 992
          goto while_break;
        }
#line 993
        out_length += (ulg )dyn_dtree[dcode].fc.freq * (ulg )(5L + (long )extra_dbits[dcode]);
#line 992
        dcode ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 995
      out_length >>= 3;
#line 999
      if (last_dist < last_lit / 2U) {
#line 999
        if (out_length < in_length / 2UL) {
#line 999
          return (1);
        }
      }
    }
  }
#line 1001
  if (last_lit == 32767U) {
#line 1001
    tmp___3 = 1;
  } else
#line 1001
  if (last_dist == 32768U) {
#line 1001
    tmp___3 = 1;
  } else {
#line 1001
    tmp___3 = 0;
  }
#line 1001
  return (tmp___3);
}
}
#line 1011 "/home/kihong/gzip-1.2.4a/trees.c"
static void compress_block(ct_data *ltree , ct_data *dtree ) 
{ 
  unsigned int dist ;
  int lc ;
  unsigned int lx ;
  unsigned int dx ;
  unsigned int fx ;
  uch flag ;
  unsigned int code ;
  int extra ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1017
  lx = 0U;
#line 1018
  dx = 0U;
#line 1019
  fx = 0U;
#line 1020
  flag = (uch )0;
#line 1024
  if (last_lit != 0U) {
    {
#line 1024
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1025
      if ((lx & 7U) == 0U) {
#line 1025
        tmp = fx;
#line 1025
        fx ++;
#line 1025
        flag = flag_buf[tmp];
      }
#line 1026
      tmp___0 = lx;
#line 1026
      lx ++;
#line 1026
      lc = (int )inbuf[tmp___0];
#line 1027
      if (((int )flag & 1) == 0) {
        {
#line 1028
        send_bits((int )(ltree + lc)->fc.code, (int )(ltree + lc)->dl.len);
        }
      } else {
        {
#line 1032
        code = (unsigned int )length_code[lc];
#line 1033
        send_bits((int )(ltree + ((code + 256U) + 1U))->fc.code, (int )(ltree + ((code + 256U) + 1U))->dl.len);
#line 1034
        extra = extra_lbits[code];
        }
#line 1035
        if (extra != 0) {
          {
#line 1036
          lc -= base_length[code];
#line 1037
          send_bits(lc, extra);
          }
        }
#line 1039
        tmp___1 = dx;
#line 1039
        dx ++;
#line 1039
        dist = (unsigned int )d_buf[tmp___1];
#line 1041
        if (dist < 256U) {
#line 1041
          code = (unsigned int )dist_code[dist];
        } else {
#line 1041
          code = (unsigned int )dist_code[256U + (dist >> 7)];
        }
        {
#line 1044
        send_bits((int )(dtree + code)->fc.code, (int )(dtree + code)->dl.len);
#line 1045
        extra = extra_dbits[code];
        }
#line 1046
        if (extra != 0) {
          {
#line 1047
          dist -= (unsigned int )base_dist[code];
#line 1048
          send_bits((int )dist, extra);
          }
        }
      }
#line 1051
      flag = (uch )((int )flag >> 1);
#line 1024
      if (! (lx < last_lit)) {
#line 1024
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1054
  send_bits((int )(ltree + 256)->fc.code, (int )(ltree + 256)->dl.len);
  }
#line 1055
  return;
}
}
#line 1063 "/home/kihong/gzip-1.2.4a/trees.c"
static void set_file_type(void) 
{ 
  int n ;
  unsigned int ascii_freq ;
  unsigned int bin_freq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1065
  n = 0;
#line 1066
  ascii_freq = 0U;
#line 1067
  bin_freq = 0U;
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1068
    if (! (n < 7)) {
#line 1068
      goto while_break;
    }
#line 1068
    tmp = n;
#line 1068
    n ++;
#line 1068
    bin_freq += (unsigned int )dyn_ltree[tmp].fc.freq;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1069
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1069
    if (! (n < 128)) {
#line 1069
      goto while_break___0;
    }
#line 1069
    tmp___0 = n;
#line 1069
    n ++;
#line 1069
    ascii_freq += (unsigned int )dyn_ltree[tmp___0].fc.freq;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1070
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1070
    if (! (n < 256)) {
#line 1070
      goto while_break___1;
    }
#line 1070
    tmp___1 = n;
#line 1070
    n ++;
#line 1070
    bin_freq += (unsigned int )dyn_ltree[tmp___1].fc.freq;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1071
  if (bin_freq > ascii_freq >> 2) {
#line 1071
    *file_type = (ush )0;
  } else {
#line 1071
    *file_type = (ush )1;
  }
#line 1072
  if ((int )*file_type == 0) {

  }
#line 1075
  return;
}
}
#line 279 "/home/kihong/gzip-1.2.4a/gzip.h"
void lm_init(int pack_level , ush *flags___0 ) ;
#line 280
ulg deflate(void) ;
#line 154 "/home/kihong/gzip-1.2.4a/deflate.c"
ulg window_size  =    65536UL;
#line 159 "/home/kihong/gzip-1.2.4a/deflate.c"
long block_start  ;
#line 164 "/home/kihong/gzip-1.2.4a/deflate.c"
static unsigned int ins_h  ;
#line 173 "/home/kihong/gzip-1.2.4a/deflate.c"
unsigned int prev_length  ;
#line 178 "/home/kihong/gzip-1.2.4a/deflate.c"
unsigned int strstart  ;
#line 179 "/home/kihong/gzip-1.2.4a/deflate.c"
unsigned int match_start  ;
#line 180 "/home/kihong/gzip-1.2.4a/deflate.c"
static int eofile  ;
#line 181 "/home/kihong/gzip-1.2.4a/deflate.c"
static unsigned int lookahead  ;
#line 183 "/home/kihong/gzip-1.2.4a/deflate.c"
unsigned int max_chain_length  ;
#line 188 "/home/kihong/gzip-1.2.4a/deflate.c"
static unsigned int max_lazy_match  ;
#line 199 "/home/kihong/gzip-1.2.4a/deflate.c"
static int compr_level  ;
#line 202 "/home/kihong/gzip-1.2.4a/deflate.c"
unsigned int good_match  ;
#line 222 "/home/kihong/gzip-1.2.4a/deflate.c"
int nice_match  ;
#line 225 "/home/kihong/gzip-1.2.4a/deflate.c"
static config configuration_table[10]  = 
#line 225
  {      {(ush )0, (ush )0, (ush )0, (ush )0}, 
        {(ush )4, (ush )4, (ush )8, (ush )4}, 
        {(ush )4, (ush )5, (ush )16, (ush )8}, 
        {(ush )4, (ush )6, (ush )32, (ush )32}, 
        {(ush )4, (ush )4, (ush )16, (ush )16}, 
        {(ush )8, (ush )16, (ush )32, (ush )32}, 
        {(ush )8, (ush )16, (ush )128, (ush )128}, 
        {(ush )8, (ush )32, (ush )128, (ush )256}, 
        {(ush )32, (ush )128, (ush )258, (ush )1024}, 
        {(ush )32, (ush )258, (ush )258, (ush )4096}};
#line 250
static void fill_window(void) ;
#line 251
static ulg deflate_fast(void) ;
#line 253
int longest_match(IPos cur_match ) ;
#line 286 "/home/kihong/gzip-1.2.4a/deflate.c"
void lm_init(int pack_level , ush *flags___0 ) 
{ 
  register unsigned int j___0 ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 292
  if (pack_level < 1) {
    {
#line 292
    error((char *)"bad pack level");
    }
  } else
#line 292
  if (pack_level > 9) {
    {
#line 292
    error((char *)"bad pack level");
    }
  }
  {
#line 293
  compr_level = pack_level;
#line 299
  memset((voidp )((char *)(prev + 32768)), 0, (unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768)));
#line 305
  max_lazy_match = (unsigned int )configuration_table[pack_level].max_lazy;
#line 306
  good_match = (unsigned int )configuration_table[pack_level].good_length;
#line 308
  nice_match = (int )configuration_table[pack_level].nice_length;
#line 310
  max_chain_length = (unsigned int )configuration_table[pack_level].max_chain;
  }
#line 311
  if (pack_level == 1) {
#line 312
    *flags___0 = (ush )((int )*flags___0 | 4);
  } else
#line 313
  if (pack_level == 9) {
#line 314
    *flags___0 = (ush )((int )*flags___0 | 2);
  }
#line 318
  strstart = 0U;
#line 319
  block_start = 0L;
#line 324
  if (sizeof(int ) <= 2UL) {
#line 324
    tmp = 32768U;
  } else {
#line 324
    tmp = 65536U;
  }
  {
#line 324
  tmp___0 = (*read_buf)((char *)(window), tmp);
#line 324
  lookahead = (unsigned int )tmp___0;
  }
#line 327
  if (lookahead == 0U) {
#line 328
    eofile = 1;
#line 328
    lookahead = 0U;
#line 329
    return;
  } else
#line 327
  if (lookahead == 4294967295U) {
#line 328
    eofile = 1;
#line 328
    lookahead = 0U;
#line 329
    return;
  }
#line 331
  eofile = 0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (lookahead < 262U) {
#line 335
      if (! (! eofile)) {
#line 335
        goto while_break;
      }
    } else {
#line 335
      goto while_break;
    }
    {
#line 335
    fill_window();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  ins_h = 0U;
#line 338
  j___0 = 0U;
  {
#line 338
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 338
    if (! (j___0 < 2U)) {
#line 338
      goto while_break___0;
    }
#line 338
    ins_h = ((ins_h << 5) ^ (unsigned int )window[j___0]) & ((unsigned int )(1 << 15) - 1U);
#line 338
    j___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 342
  return;
}
}
#line 357 "/home/kihong/gzip-1.2.4a/deflate.c"
int longest_match(IPos cur_match ) 
{ 
  unsigned int chain_length ;
  register uch *scan ;
  register uch *match ;
  register int len ;
  int best_len ;
  IPos limit ;
  unsigned int tmp ;
  register uch *strend ;
  register uch scan_end1 ;
  register uch scan_end ;

  {
#line 360
  chain_length = max_chain_length;
#line 361
  scan = window + strstart;
#line 364
  best_len = (int )prev_length;
#line 365
  if (strstart > 32506U) {
#line 365
    tmp = strstart - 32506U;
  } else {
#line 365
    tmp = 0U;
  }
#line 365
  limit = tmp;
#line 385
  strend = (window + strstart) + 258;
#line 386
  scan_end1 = *(scan + (best_len - 1));
#line 387
  scan_end = *(scan + best_len);
#line 391
  if (prev_length >= good_match) {
#line 392
    chain_length >>= 2;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    match = window + cur_match;
#line 437
    if ((int )*(match + best_len) != (int )scan_end) {
#line 440
      goto __Cont;
    } else
#line 437
    if ((int )*(match + (best_len - 1)) != (int )scan_end1) {
#line 440
      goto __Cont;
    } else
#line 437
    if ((int )*match != (int )*scan) {
#line 440
      goto __Cont;
    } else {
#line 437
      match ++;
#line 437
      if ((int )*match != (int )*(scan + 1)) {
#line 440
        goto __Cont;
      }
    }
#line 448
    scan += 2;
#line 448
    match ++;
    {
#line 453
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 453
      scan ++;
#line 453
      match ++;
#line 453
      if ((int )*scan == (int )*match) {
#line 453
        scan ++;
#line 453
        match ++;
#line 453
        if ((int )*scan == (int )*match) {
#line 453
          scan ++;
#line 453
          match ++;
#line 453
          if ((int )*scan == (int )*match) {
#line 453
            scan ++;
#line 453
            match ++;
#line 453
            if ((int )*scan == (int )*match) {
#line 453
              scan ++;
#line 453
              match ++;
#line 453
              if ((int )*scan == (int )*match) {
#line 453
                scan ++;
#line 453
                match ++;
#line 453
                if ((int )*scan == (int )*match) {
#line 453
                  scan ++;
#line 453
                  match ++;
#line 453
                  if ((int )*scan == (int )*match) {
#line 453
                    scan ++;
#line 453
                    match ++;
#line 453
                    if ((int )*scan == (int )*match) {
#line 453
                      if (! ((unsigned long )scan < (unsigned long )strend)) {
#line 453
                        goto while_break___0;
                      }
                    } else {
#line 453
                      goto while_break___0;
                    }
                  } else {
#line 453
                    goto while_break___0;
                  }
                } else {
#line 453
                  goto while_break___0;
                }
              } else {
#line 453
                goto while_break___0;
              }
            } else {
#line 453
              goto while_break___0;
            }
          } else {
#line 453
            goto while_break___0;
          }
        } else {
#line 453
          goto while_break___0;
        }
      } else {
#line 453
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 460
    len = 258 - (int )(strend - scan);
#line 461
    scan = strend - 258;
#line 465
    if (len > best_len) {
#line 466
      match_start = cur_match;
#line 467
      best_len = len;
#line 468
      if (len >= nice_match) {
#line 468
        goto while_break;
      }
#line 472
      scan_end1 = *(scan + (best_len - 1));
#line 473
      scan_end = *(scan + best_len);
    }
    __Cont: /* CIL Label */ 
#line 396
    cur_match = (IPos )prev[cur_match & 32767U];
#line 396
    if (cur_match > limit) {
#line 396
      chain_length --;
#line 396
      if (! (chain_length != 0U)) {
#line 396
        goto while_break;
      }
    } else {
#line 396
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  return (best_len);
}
}
#line 516 "/home/kihong/gzip-1.2.4a/deflate.c"
static void fill_window(void) 
{ 
  register unsigned int n ;
  register unsigned int m ;
  unsigned int more ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 519
  more = (unsigned int )((window_size - (ulg )lookahead) - (ulg )strstart);
#line 525
  if (more == 4294967295U) {
#line 529
    more --;
  } else
#line 530
  if (strstart >= 65274U) {
    {
#line 536
    memcpy((void */* __restrict  */)((char *)(window)), (void const   */* __restrict  */)((char *)(window) + 32768),
           (size_t )32768U);
#line 537
    match_start -= 32768U;
#line 538
    strstart -= 32768U;
#line 540
    block_start -= 32768L;
#line 542
    n = 0U;
    }
    {
#line 542
    while (1) {
      while_continue: /* CIL Label */ ;
#line 542
      if (! (n < (unsigned int )(1 << 15))) {
#line 542
        goto while_break;
      }
#line 543
      m = (unsigned int )*((prev + 32768) + n);
#line 544
      if (m >= 32768U) {
#line 544
        tmp = m - 32768U;
      } else {
#line 544
        tmp = 0U;
      }
#line 544
      *((prev + 32768) + n) = (Pos )tmp;
#line 542
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 546
    n = 0U;
    {
#line 546
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 546
      if (! (n < 32768U)) {
#line 546
        goto while_break___0;
      }
#line 547
      m = (unsigned int )prev[n];
#line 548
      if (m >= 32768U) {
#line 548
        tmp___0 = m - 32768U;
      } else {
#line 548
        tmp___0 = 0U;
      }
#line 548
      prev[n] = (Pos )tmp___0;
#line 546
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 553
    more += 32768U;
  }
#line 556
  if (! eofile) {
    {
#line 557
    tmp___1 = (*read_buf)(((char *)(window) + strstart) + lookahead, more);
#line 557
    n = (unsigned int )tmp___1;
    }
#line 558
    if (n == 0U) {
#line 559
      eofile = 1;
    } else
#line 558
    if (n == 4294967295U) {
#line 559
      eofile = 1;
    } else {
#line 561
      lookahead += n;
    }
  }
#line 564
  return;
}
}
#line 580 "/home/kihong/gzip-1.2.4a/deflate.c"
static ulg deflate_fast(void) 
{ 
  IPos hash_head ;
  int flush ;
  unsigned int match_length ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  ulg tmp___2 ;

  {
#line 584
  match_length = 0U;
#line 586
  prev_length = 2U;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (! (lookahead != 0U)) {
#line 587
      goto while_break;
    }
#line 591
    ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 591
    hash_head = (IPos )*((prev + 32768) + ins_h);
#line 591
    prev[strstart & 32767U] = (ush )hash_head;
#line 591
    *((prev + 32768) + ins_h) = (ush )strstart;
#line 596
    if (hash_head != 0U) {
#line 596
      if (strstart - hash_head <= 32506U) {
        {
#line 601
        tmp = longest_match(hash_head);
#line 601
        match_length = (unsigned int )tmp;
        }
#line 603
        if (match_length > lookahead) {
#line 603
          match_length = lookahead;
        }
      }
    }
#line 605
    if (match_length >= 3U) {
      {
#line 608
      flush = ct_tally((int )(strstart - match_start), (int )(match_length - 3U));
#line 610
      lookahead -= match_length;
      }
#line 615
      if (match_length <= max_lazy_match) {
#line 616
        match_length --;
        {
#line 617
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 618
          strstart ++;
#line 619
          ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 619
          hash_head = (IPos )*((prev + 32768) + ins_h);
#line 619
          prev[strstart & 32767U] = (ush )hash_head;
#line 619
          *((prev + 32768) + ins_h) = (ush )strstart;
#line 617
          match_length --;
#line 617
          if (! (match_length != 0U)) {
#line 617
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 626
        strstart ++;
      } else {
#line 628
        strstart += match_length;
#line 629
        match_length = 0U;
#line 630
        ins_h = (unsigned int )window[strstart];
#line 631
        ins_h = ((ins_h << 5) ^ (unsigned int )window[strstart + 1U]) & ((unsigned int )(1 << 15) - 1U);
      }
    } else {
      {
#line 639
      flush = ct_tally(0, (int )window[strstart]);
#line 640
      lookahead --;
#line 641
      strstart ++;
      }
    }
#line 643
    if (flush) {
#line 643
      if (block_start >= 0L) {
#line 643
        tmp___0 = (char *)(& window[(unsigned int )block_start]);
      } else {
#line 643
        tmp___0 = (char *)((void *)0);
      }
      {
#line 643
      flush_block(tmp___0, (ulg )((long )strstart - block_start), 0);
#line 643
      block_start = (long )strstart;
      }
    }
    {
#line 650
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 650
      if (lookahead < 262U) {
#line 650
        if (! (! eofile)) {
#line 650
          goto while_break___1;
        }
      } else {
#line 650
        goto while_break___1;
      }
      {
#line 650
      fill_window();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  if (block_start >= 0L) {
#line 653
    tmp___1 = (char *)(& window[(unsigned int )block_start]);
  } else {
#line 653
    tmp___1 = (char *)((void *)0);
  }
  {
#line 653
  tmp___2 = flush_block(tmp___1, (ulg )((long )strstart - block_start), 1);
  }
#line 653
  return (tmp___2);
}
}
#line 661 "/home/kihong/gzip-1.2.4a/deflate.c"
ulg deflate(void) 
{ 
  IPos hash_head ;
  IPos prev_match ;
  int flush ;
  int match_available ;
  register unsigned int match_length ;
  ulg tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  ulg tmp___5 ;

  {
#line 666
  match_available = 0;
#line 667
  match_length = 2U;
#line 672
  if (compr_level <= 3) {
    {
#line 672
    tmp = deflate_fast();
    }
#line 672
    return (tmp);
  }
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (! (lookahead != 0U)) {
#line 675
      goto while_break;
    }
#line 679
    ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 679
    hash_head = (IPos )*((prev + 32768) + ins_h);
#line 679
    prev[strstart & 32767U] = (ush )hash_head;
#line 679
    *((prev + 32768) + ins_h) = (ush )strstart;
#line 683
    prev_length = match_length;
#line 683
    prev_match = match_start;
#line 684
    match_length = 2U;
#line 686
    if (hash_head != 0U) {
#line 686
      if (prev_length < max_lazy_match) {
#line 686
        if (strstart - hash_head <= 32506U) {
          {
#line 692
          tmp___0 = longest_match(hash_head);
#line 692
          match_length = (unsigned int )tmp___0;
          }
#line 694
          if (match_length > lookahead) {
#line 694
            match_length = lookahead;
          }
#line 697
          if (match_length == 3U) {
#line 697
            if (strstart - match_start > 4096U) {
#line 701
              match_length --;
            }
          }
        }
      }
    }
#line 707
    if (prev_length >= 3U) {
#line 707
      if (match_length <= prev_length) {
        {
#line 711
        flush = ct_tally((int )((strstart - 1U) - prev_match), (int )(prev_length - 3U));
#line 716
        lookahead -= prev_length - 1U;
#line 717
        prev_length -= 2U;
        }
        {
#line 718
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 719
          strstart ++;
#line 720
          ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 720
          hash_head = (IPos )*((prev + 32768) + ins_h);
#line 720
          prev[strstart & 32767U] = (ush )hash_head;
#line 720
          *((prev + 32768) + ins_h) = (ush )strstart;
#line 718
          prev_length --;
#line 718
          if (! (prev_length != 0U)) {
#line 718
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 727
        match_available = 0;
#line 728
        match_length = 2U;
#line 729
        strstart ++;
#line 730
        if (flush) {
#line 730
          if (block_start >= 0L) {
#line 730
            tmp___1 = (char *)(& window[(unsigned int )block_start]);
          } else {
#line 730
            tmp___1 = (char *)((void *)0);
          }
          {
#line 730
          flush_block(tmp___1, (ulg )((long )strstart - block_start), 0);
#line 730
          block_start = (long )strstart;
          }
        }
      } else {
#line 707
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 732
    if (match_available) {
      {
#line 738
      tmp___3 = ct_tally(0, (int )window[strstart - 1U]);
      }
#line 738
      if (tmp___3) {
#line 739
        if (block_start >= 0L) {
#line 739
          tmp___2 = (char *)(& window[(unsigned int )block_start]);
        } else {
#line 739
          tmp___2 = (char *)((void *)0);
        }
        {
#line 739
        flush_block(tmp___2, (ulg )((long )strstart - block_start), 0);
#line 739
        block_start = (long )strstart;
        }
      }
#line 741
      strstart ++;
#line 742
      lookahead --;
    } else {
#line 747
      match_available = 1;
#line 748
      strstart ++;
#line 749
      lookahead --;
    }
    {
#line 758
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 758
      if (lookahead < 262U) {
#line 758
        if (! (! eofile)) {
#line 758
          goto while_break___1;
        }
      } else {
#line 758
        goto while_break___1;
      }
      {
#line 758
      fill_window();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  if (match_available) {
    {
#line 760
    ct_tally(0, (int )window[strstart - 1U]);
    }
  }
#line 762
  if (block_start >= 0L) {
#line 762
    tmp___4 = (char *)(& window[(unsigned int )block_start]);
  } else {
#line 762
    tmp___4 = (char *)((void *)0);
  }
  {
#line 762
  tmp___5 = flush_block(tmp___4, (ulg )((long )strstart - block_start), 1);
  }
#line 762
  return (tmp___5);
}
}
#line 137 "/home/kihong/gzip-1.2.4a/gzip.h"
long header_bytes  ;
#line 148
long time_stamp ;
#line 200
int save_orig_name ;
#line 262
int zip(int in , int out ) ;
#line 25 "/home/kihong/gzip-1.2.4a/zip.c"
static ulg crc___0  ;
#line 33 "/home/kihong/gzip-1.2.4a/zip.c"
int zip(int in , int out ) 
{ 
  uch flags___0 ;
  ush attr ;
  ush deflate_flags ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  char *p ;
  char *tmp___13 ;
  unsigned int tmp___14 ;
  char *tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;

  {
#line 36
  flags___0 = (uch )0;
#line 37
  attr = (ush )0;
#line 38
  deflate_flags = (ush )0;
#line 40
  ifd = in;
#line 41
  ofd = out;
#line 42
  outcnt = 0U;
#line 46
  method = 8;
#line 47
  tmp = outcnt;
#line 47
  outcnt ++;
#line 47
  outbuf[tmp] = (uch )*("\037\213" + 0);
#line 47
  if (outcnt == 16384U) {
    {
#line 47
    flush_outbuf();
    }
  }
#line 48
  tmp___0 = outcnt;
#line 48
  outcnt ++;
#line 48
  outbuf[tmp___0] = (uch )*("\037\213" + 1);
#line 48
  if (outcnt == 16384U) {
    {
#line 48
    flush_outbuf();
    }
  }
#line 49
  tmp___1 = outcnt;
#line 49
  outcnt ++;
#line 49
  outbuf[tmp___1] = (uch )8;
#line 49
  if (outcnt == 16384U) {
    {
#line 49
    flush_outbuf();
    }
  }
#line 51
  if (save_orig_name) {
#line 52
    flags___0 = (uch )((int )flags___0 | 8);
  }
#line 54
  tmp___2 = outcnt;
#line 54
  outcnt ++;
#line 54
  outbuf[tmp___2] = flags___0;
#line 54
  if (outcnt == 16384U) {
    {
#line 54
    flush_outbuf();
    }
  }
#line 55
  if (outcnt < 16382U) {
#line 55
    tmp___3 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___3] = (uch )((time_stamp & 65535L) & 255L);
#line 55
    tmp___4 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___4] = (uch )((int )((ush )(time_stamp & 65535L)) >> 8);
  } else {
#line 55
    tmp___5 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___5] = (uch )((time_stamp & 65535L) & 255L);
#line 55
    if (outcnt == 16384U) {
      {
#line 55
      flush_outbuf();
      }
    }
#line 55
    tmp___6 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___6] = (uch )((int )((ush )(time_stamp & 65535L)) >> 8);
#line 55
    if (outcnt == 16384U) {
      {
#line 55
      flush_outbuf();
      }
    }
  }
#line 55
  if (outcnt < 16382U) {
#line 55
    tmp___7 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___7] = (uch )(((ulg )time_stamp >> 16) & 255UL);
#line 55
    tmp___8 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___8] = (uch )((int )((ush )((ulg )time_stamp >> 16)) >> 8);
  } else {
#line 55
    tmp___9 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___9] = (uch )(((ulg )time_stamp >> 16) & 255UL);
#line 55
    if (outcnt == 16384U) {
      {
#line 55
      flush_outbuf();
      }
    }
#line 55
    tmp___10 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___10] = (uch )((int )((ush )((ulg )time_stamp >> 16)) >> 8);
#line 55
    if (outcnt == 16384U) {
      {
#line 55
      flush_outbuf();
      }
    }
  }
  {
#line 58
  crc___0 = updcrc((uch *)0, 0U);
#line 60
  bi_init(out);
#line 61
  ct_init(& attr, & method);
#line 62
  lm_init(level, & deflate_flags);
#line 64
  tmp___11 = outcnt;
#line 64
  outcnt ++;
#line 64
  outbuf[tmp___11] = (uch )deflate_flags;
  }
#line 64
  if (outcnt == 16384U) {
    {
#line 64
    flush_outbuf();
    }
  }
#line 65
  tmp___12 = outcnt;
#line 65
  outcnt ++;
#line 65
  outbuf[tmp___12] = (uch )3;
#line 65
  if (outcnt == 16384U) {
    {
#line 65
    flush_outbuf();
    }
  }
#line 67
  if (save_orig_name) {
    {
#line 68
    tmp___13 = basename(ifname);
#line 68
    p = tmp___13;
    }
    {
#line 69
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      tmp___14 = outcnt;
#line 70
      outcnt ++;
#line 70
      outbuf[tmp___14] = (uch )*p;
#line 70
      if (outcnt == 16384U) {
        {
#line 70
        flush_outbuf();
        }
      }
#line 69
      tmp___15 = p;
#line 69
      p ++;
#line 69
      if (! *tmp___15) {
#line 69
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 73
  header_bytes = (long )outcnt;
#line 75
  deflate();
  }
#line 89
  if (outcnt < 16382U) {
#line 89
    tmp___16 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___16] = (uch )((crc___0 & 65535UL) & 255UL);
#line 89
    tmp___17 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___17] = (uch )((int )((ush )(crc___0 & 65535UL)) >> 8);
  } else {
#line 89
    tmp___18 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___18] = (uch )((crc___0 & 65535UL) & 255UL);
#line 89
    if (outcnt == 16384U) {
      {
#line 89
      flush_outbuf();
      }
    }
#line 89
    tmp___19 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___19] = (uch )((int )((ush )(crc___0 & 65535UL)) >> 8);
#line 89
    if (outcnt == 16384U) {
      {
#line 89
      flush_outbuf();
      }
    }
  }
#line 89
  if (outcnt < 16382U) {
#line 89
    tmp___20 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___20] = (uch )((crc___0 >> 16) & 255UL);
#line 89
    tmp___21 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___21] = (uch )((int )((ush )(crc___0 >> 16)) >> 8);
  } else {
#line 89
    tmp___22 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___22] = (uch )((crc___0 >> 16) & 255UL);
#line 89
    if (outcnt == 16384U) {
      {
#line 89
      flush_outbuf();
      }
    }
#line 89
    tmp___23 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___23] = (uch )((int )((ush )(crc___0 >> 16)) >> 8);
#line 89
    if (outcnt == 16384U) {
      {
#line 89
      flush_outbuf();
      }
    }
  }
#line 90
  if (outcnt < 16382U) {
#line 90
    tmp___24 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___24] = (uch )((bytes_in & 65535L) & 255L);
#line 90
    tmp___25 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___25] = (uch )((int )((ush )(bytes_in & 65535L)) >> 8);
  } else {
#line 90
    tmp___26 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___26] = (uch )((bytes_in & 65535L) & 255L);
#line 90
    if (outcnt == 16384U) {
      {
#line 90
      flush_outbuf();
      }
    }
#line 90
    tmp___27 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___27] = (uch )((int )((ush )(bytes_in & 65535L)) >> 8);
#line 90
    if (outcnt == 16384U) {
      {
#line 90
      flush_outbuf();
      }
    }
  }
#line 90
  if (outcnt < 16382U) {
#line 90
    tmp___28 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___28] = (uch )(((ulg )bytes_in >> 16) & 255UL);
#line 90
    tmp___29 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___29] = (uch )((int )((ush )((ulg )bytes_in >> 16)) >> 8);
  } else {
#line 90
    tmp___30 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___30] = (uch )(((ulg )bytes_in >> 16) & 255UL);
#line 90
    if (outcnt == 16384U) {
      {
#line 90
      flush_outbuf();
      }
    }
#line 90
    tmp___31 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___31] = (uch )((int )((ush )((ulg )bytes_in >> 16)) >> 8);
#line 90
    if (outcnt == 16384U) {
      {
#line 90
      flush_outbuf();
      }
    }
  }
  {
#line 91
  header_bytes = (long )((unsigned long )header_bytes + 2UL * sizeof(long ));
#line 93
  flush_outbuf();
  }
#line 94
  return (0);
}
}
#line 103 "/home/kihong/gzip-1.2.4a/zip.c"
int file_read(char *buf , unsigned int size ) 
{ 
  unsigned int len ;
  ssize_t tmp ;

  {
  {
#line 111
  tmp = read(ifd, (void *)buf, (size_t )size);
#line 111
  len = (unsigned int )tmp;
  }
#line 112
  if (len == 4294967295U) {
#line 112
    return ((int )len);
  } else
#line 112
  if (len == 0U) {
#line 112
    return ((int )len);
  }
  {
#line 114
  crc___0 = updcrc((uch *)buf, len);
#line 115
  bytes_in = (long )((ulg )bytes_in + (ulg )len);
  }
#line 116
  return ((int )len);
}
}
#line 12 "/home/kihong/gzip-1.2.4a/gzip.c"
static char *license_msg[15]  = 
#line 12 "/home/kihong/gzip-1.2.4a/gzip.c"
  {      (char *)"   Copyright (C) 1992-1993 Jean-loup Gailly",      (char *)"   This program is free software; you can redistribute it and/or modify",      (char *)"   it under the terms of the GNU General Public License as published by",      (char *)"   the Free Software Foundation; either version 2, or (at your option)", 
        (char *)"   any later version.",      (char *)"",      (char *)"   This program is distributed in the hope that it will be useful,",      (char *)"   but WITHOUT ANY WARRANTY; without even the implied warranty of", 
        (char *)"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",      (char *)"   GNU General Public License for more details.",      (char *)"",      (char *)"   You should have received a copy of the GNU General Public License", 
        (char *)"   along with this program; if not, write to the Free Software",      (char *)"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",      (char *)0};
#line 88 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 280
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 395
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
#line 452
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 452 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 455
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 455
  return (tmp);
}
}
#line 459
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 459 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 462
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 462
  return (tmp);
}
}
#line 466
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 466 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 469
  tmp = __fxstat(1, __fd, __statbuf);
  }
#line 469
  return (tmp);
}
}
#line 473
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
#line 473 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  {
#line 477
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  }
#line 477
  return (tmp);
}
}
#line 482
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 482 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 485
  tmp = __xmknod(0, __path, __mode, & __dev);
  }
#line 485
  return (tmp);
}
}
#line 490
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 490 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 494
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 494
  return (tmp);
}
}
#line 218 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 332
extern int printf(char const   * __restrict  __format  , ...) ;
#line 564
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 125
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 140
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 115 "/home/kihong/gzip-1.2.4a/gzip.h"
uch inbuf[32832]  ;
#line 116 "/home/kihong/gzip-1.2.4a/gzip.h"
uch outbuf[18432]  ;
#line 117 "/home/kihong/gzip-1.2.4a/gzip.h"
ush d_buf[32768]  ;
#line 118 "/home/kihong/gzip-1.2.4a/gzip.h"
uch window[65536L]  ;
#line 123 "/home/kihong/gzip-1.2.4a/gzip.h"
ush prev[1L << 16]  ;
#line 131 "/home/kihong/gzip-1.2.4a/gzip.h"
unsigned int insize  ;
#line 132 "/home/kihong/gzip-1.2.4a/gzip.h"
unsigned int inptr  ;
#line 133 "/home/kihong/gzip-1.2.4a/gzip.h"
unsigned int outcnt  ;
#line 135 "/home/kihong/gzip-1.2.4a/gzip.h"
long bytes_in  ;
#line 136 "/home/kihong/gzip-1.2.4a/gzip.h"
long bytes_out  ;
#line 142 "/home/kihong/gzip-1.2.4a/gzip.h"
int ifd  ;
#line 143 "/home/kihong/gzip-1.2.4a/gzip.h"
int ofd  ;
#line 144 "/home/kihong/gzip-1.2.4a/gzip.h"
char ifname[1024]  ;
#line 145 "/home/kihong/gzip-1.2.4a/gzip.h"
char ofname[1024]  ;
#line 146 "/home/kihong/gzip-1.2.4a/gzip.h"
char *progname  ;
#line 148 "/home/kihong/gzip-1.2.4a/gzip.h"
long time_stamp  ;
#line 149 "/home/kihong/gzip-1.2.4a/gzip.h"
long ifile_size  ;
#line 195
int verbose ;
#line 200 "/home/kihong/gzip-1.2.4a/gzip.h"
int save_orig_name  ;
#line 31 "/home/kihong/gzip-1.2.4a/getopt.h"
extern char *optarg ;
#line 45
extern int optind ;
#line 104
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 142 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 168 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 473
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 779
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 825
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 617 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 44 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) utime)(char const   *__file ,
                                                                                  struct utimbuf  const  *__file_times ) ;
#line 201 "/home/kihong/gzip-1.2.4a/gzip.c"
int ascii  =    0;
#line 202 "/home/kihong/gzip-1.2.4a/gzip.c"
int to_stdout  =    0;
#line 203 "/home/kihong/gzip-1.2.4a/gzip.c"
int decompress  =    0;
#line 204 "/home/kihong/gzip-1.2.4a/gzip.c"
int force  =    0;
#line 205 "/home/kihong/gzip-1.2.4a/gzip.c"
int no_name  =    -1;
#line 206 "/home/kihong/gzip-1.2.4a/gzip.c"
int no_time  =    -1;
#line 207 "/home/kihong/gzip-1.2.4a/gzip.c"
int recursive  =    0;
#line 208 "/home/kihong/gzip-1.2.4a/gzip.c"
int list  =    0;
#line 209 "/home/kihong/gzip-1.2.4a/gzip.c"
int verbose  =    0;
#line 210 "/home/kihong/gzip-1.2.4a/gzip.c"
int quiet  =    0;
#line 211 "/home/kihong/gzip-1.2.4a/gzip.c"
int do_lzw  =    0;
#line 212 "/home/kihong/gzip-1.2.4a/gzip.c"
int test  =    0;
#line 213 "/home/kihong/gzip-1.2.4a/gzip.c"
int foreground  ;
#line 215 "/home/kihong/gzip-1.2.4a/gzip.c"
int maxbits  =    16;
#line 216 "/home/kihong/gzip-1.2.4a/gzip.c"
int method  =    8;
#line 217 "/home/kihong/gzip-1.2.4a/gzip.c"
int level  =    6;
#line 218 "/home/kihong/gzip-1.2.4a/gzip.c"
int exit_code  =    0;
#line 220 "/home/kihong/gzip-1.2.4a/gzip.c"
int last_member  ;
#line 221 "/home/kihong/gzip-1.2.4a/gzip.c"
int part_nb  ;
#line 224 "/home/kihong/gzip-1.2.4a/gzip.c"
char *env  ;
#line 225 "/home/kihong/gzip-1.2.4a/gzip.c"
char **args  =    (char **)((void *)0);
#line 226 "/home/kihong/gzip-1.2.4a/gzip.c"
char z_suffix[31]  ;
#line 227 "/home/kihong/gzip-1.2.4a/gzip.c"
int z_len  ;
#line 231 "/home/kihong/gzip-1.2.4a/gzip.c"
long total_in  =    0L;
#line 232 "/home/kihong/gzip-1.2.4a/gzip.c"
long total_out  =    0L;
#line 235 "/home/kihong/gzip-1.2.4a/gzip.c"
int remove_ofname  =    0;
#line 236 "/home/kihong/gzip-1.2.4a/gzip.c"
struct stat istat  ;
#line 243 "/home/kihong/gzip-1.2.4a/gzip.c"
struct option longopts[24]  = 
#line 243
  {      {"ascii", 0, (int *)0, 'a'}, 
        {"to-stdout", 0, (int *)0, 'c'}, 
        {"stdout", 0, (int *)0, 'c'}, 
        {"decompress", 0, (int *)0, 'd'}, 
        {"uncompress", 0, (int *)0, 'd'}, 
        {"force", 0, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"list", 0, (int *)0, 'l'}, 
        {"license", 0, (int *)0, 'L'}, 
        {"no-name", 0, (int *)0, 'n'}, 
        {"name", 0, (int *)0, 'N'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"silent", 0, (int *)0, 'q'}, 
        {"recursive", 0, (int *)0, 'r'}, 
        {"suffix", 1, (int *)0, 'S'}, 
        {"test", 0, (int *)0, 't'}, 
        {"no-time", 0, (int *)0, 'T'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"fast", 0, (int *)0, '1'}, 
        {"best", 0, (int *)0, '9'}, 
        {"lzw", 0, (int *)0, 'Z'}, 
        {"bits", 1, (int *)0, 'b'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 276
static void usage(void) ;
#line 277
static void help(void) ;
#line 278
static void license(void) ;
#line 279
static void version(void) ;
#line 280
static void treat_stdin(void) ;
#line 281
static void treat_file(char *iname ) ;
#line 282
static int create_outfile(void) ;
#line 283
static int do_stat(char *name , struct stat *sbuf ) ;
#line 284
static char *get_suffix(char *name ) ;
#line 285
static int get_istat(char *iname , struct stat *sbuf ) ;
#line 286
static int make_ofname(void) ;
#line 287
static int same_file(struct stat *stat1 , struct stat *stat2 ) ;
#line 288
static int name_too_long(char *name , struct stat *statb ) ;
#line 289
static void shorten_name(char *name ) ;
#line 290
static int get_method(int in ) ;
#line 291
static void do_list(int ifd___0 , int method___0 ) ;
#line 292
static int check_ofname(void) ;
#line 293
static void copy_stat(struct stat *ifstat ) ;
#line 294
static void do_exit(int exitcode ) ;
#line 295
int main(int argc , char **argv ) ;
#line 296 "/home/kihong/gzip-1.2.4a/gzip.c"
int (*work)(int infile , int outfile )  =    & zip;
#line 299
static void treat_dir(char *dir ) ;
#line 302
static void reset_times(char *name , struct stat *statb ) ;
#line 308 "/home/kihong/gzip-1.2.4a/gzip.c"
static void usage(void) 
{ 


  {
  {
#line 310
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n",
          progname, "", "r");
  }
#line 323
  return;
}
}
#line 328 "/home/kihong/gzip-1.2.4a/gzip.c"
static char *help_msg[18]  = 
#line 328
  {      (char *)" -c --stdout      write on standard output, keep original files unchanged",      (char *)" -d --decompress  decompress",      (char *)" -f --force       force overwrite of output file and compress links",      (char *)" -h --help        give this help", 
        (char *)" -l --list        list compressed file contents",      (char *)" -L --license     display software license",      (char *)" -n --no-name     do not save or restore the original name and time stamp",      (char *)" -N --name        save or restore the original name and time stamp", 
        (char *)" -q --quiet       suppress all warnings",      (char *)" -r --recursive   operate recursively on directories",      (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",      (char *)" -t --test        test compressed file integrity", 
        (char *)" -v --verbose     verbose mode",      (char *)" -V --version     display version number",      (char *)" -1 --fast        compress faster",      (char *)" -9 --best        compress better", 
        (char *)" file...          files to (de)compress. If none given, use standard input.",      (char *)0};
#line 326 "/home/kihong/gzip-1.2.4a/gzip.c"
static void help(void) 
{ 
  char **p ;
  char **tmp ;

  {
  {
#line 362
  p = help_msg;
#line 364
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s (%s)\n",
          progname, "1.2.4", "18 Aug 93");
#line 365
  usage();
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! *p) {
#line 366
      goto while_break;
    }
    {
#line 366
    tmp = p;
#line 366
    p ++;
#line 366
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            *tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return;
}
}
#line 370 "/home/kihong/gzip-1.2.4a/gzip.c"
static void license(void) 
{ 
  char **p ;
  char **tmp ;

  {
  {
#line 372
  p = license_msg;
#line 374
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s (%s)\n",
          progname, "1.2.4", "18 Aug 93");
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! *p) {
#line 375
      goto while_break;
    }
    {
#line 375
    tmp = p;
#line 375
    p ++;
#line 375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            *tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  return;
}
}
#line 379 "/home/kihong/gzip-1.2.4a/gzip.c"
static void version(void) 
{ 


  {
  {
#line 381
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s (%s)\n",
          progname, "1.2.4", "18 Aug 93");
#line 383
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Compilation options:\n%s %s ",
          "DIRENT", "UTIME");
#line 385
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"STDC_HEADERS ");
#line 388
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"HAVE_UNISTD_H ");
#line 420
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 421
  return;
}
}
#line 424 "/home/kihong/gzip-1.2.4a/gzip.c"
int main(int argc , char **argv ) 
{ 
  int file_count ;
  int proglen ;
  int optc ;
  size_t tmp ;
  int tmp___0 ;
  __sighandler_t tmp___1 ;
  __sighandler_t tmp___2 ;
  __sighandler_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 434
  progname = basename(*(argv + 0));
#line 435
  tmp = strlen((char const   *)progname);
#line 435
  proglen = (int )tmp;
  }
#line 438
  if (proglen > 4) {
    {
#line 438
    tmp___0 = strcmp((char const   *)((progname + proglen) - 4), ".exe");
    }
#line 438
    if (tmp___0 == 0) {
#line 439
      *(progname + (proglen - 4)) = (char )'\000';
    }
  }
  {
#line 443
  env = add_envopt(& argc, & argv, (char *)"GZIP");
  }
#line 444
  if ((unsigned long )env != (unsigned long )((void *)0)) {
#line 444
    args = argv;
  }
  {
#line 446
  tmp___1 = signal(2, (void (*)(int  ))1);
#line 446
  foreground = (unsigned long )tmp___1 != (unsigned long )((void (*)(int  ))1);
  }
#line 447
  if (foreground) {
    {
#line 448
    signal(2, (void (*)(int  ))(& abort_gzip));
    }
  }
  {
#line 451
  tmp___2 = signal(15, (void (*)(int  ))1);
  }
#line 451
  if ((unsigned long )tmp___2 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 452
    signal(15, (void (*)(int  ))(& abort_gzip));
    }
  }
  {
#line 456
  tmp___3 = signal(1, (void (*)(int  ))1);
  }
#line 456
  if ((unsigned long )tmp___3 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 457
    signal(1, (void (*)(int  ))(& abort_gzip));
    }
  }
  {
#line 469
  tmp___6 = strncmp((char const   *)progname, "un", (size_t )2);
  }
#line 469
  if (tmp___6 == 0) {
#line 471
    decompress = 1;
  } else {
    {
#line 469
    tmp___7 = strncmp((char const   *)progname, "gun", (size_t )3);
    }
#line 469
    if (tmp___7 == 0) {
#line 471
      decompress = 1;
    } else {
      {
#line 472
      tmp___4 = strcmp((char const   *)(progname + 1), "cat");
      }
#line 472
      if (tmp___4 == 0) {
#line 474
        to_stdout = 1;
#line 474
        decompress = to_stdout;
      } else {
        {
#line 472
        tmp___5 = strcmp((char const   *)progname, "gzcat");
        }
#line 472
        if (tmp___5 == 0) {
#line 474
          to_stdout = 1;
#line 474
          decompress = to_stdout;
        }
      }
    }
  }
  {
#line 478
  strncpy((char */* __restrict  */)(z_suffix), (char const   */* __restrict  */)".gz",
          sizeof(z_suffix) - 1UL);
#line 479
  tmp___8 = strlen((char const   *)(z_suffix));
#line 479
  z_len = (int )tmp___8;
  }
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 481
    optc = getopt_long(argc, (char * const  *)argv, "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
                       (struct option  const  *)(longopts), (int *)0);
    }
#line 481
    if (! (optc != -1)) {
#line 481
      goto while_break;
    }
    {
#line 484
    if (optc == 97) {
#line 484
      goto case_97;
    }
#line 486
    if (optc == 98) {
#line 486
      goto case_98;
    }
#line 489
    if (optc == 99) {
#line 489
      goto case_99;
    }
#line 491
    if (optc == 100) {
#line 491
      goto case_100;
    }
#line 493
    if (optc == 102) {
#line 493
      goto case_102;
    }
#line 495
    if (optc == 63) {
#line 495
      goto case_63;
    }
#line 495
    if (optc == 72) {
#line 495
      goto case_63;
    }
#line 495
    if (optc == 104) {
#line 495
      goto case_63;
    }
#line 497
    if (optc == 108) {
#line 497
      goto case_108;
    }
#line 499
    if (optc == 76) {
#line 499
      goto case_76;
    }
#line 501
    if (optc == 109) {
#line 501
      goto case_109;
    }
#line 503
    if (optc == 77) {
#line 503
      goto case_77;
    }
#line 505
    if (optc == 110) {
#line 505
      goto case_110;
    }
#line 507
    if (optc == 78) {
#line 507
      goto case_78;
    }
#line 509
    if (optc == 113) {
#line 509
      goto case_113;
    }
#line 511
    if (optc == 114) {
#line 511
      goto case_114;
    }
#line 519
    if (optc == 83) {
#line 519
      goto case_83;
    }
#line 526
    if (optc == 116) {
#line 526
      goto case_116;
    }
#line 529
    if (optc == 118) {
#line 529
      goto case_118;
    }
#line 531
    if (optc == 86) {
#line 531
      goto case_86;
    }
#line 533
    if (optc == 90) {
#line 533
      goto case_90;
    }
#line 543
    if (optc == 57) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 56) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 55) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 54) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 53) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 52) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 51) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 50) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 49) {
#line 543
      goto case_57;
    }
#line 546
    goto switch_default;
    case_97: /* CIL Label */ 
#line 485
    ascii = 1;
#line 485
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 487
    maxbits = atoi((char const   *)optarg);
    }
#line 488
    goto switch_break;
    case_99: /* CIL Label */ 
#line 490
    to_stdout = 1;
#line 490
    goto switch_break;
    case_100: /* CIL Label */ 
#line 492
    decompress = 1;
#line 492
    goto switch_break;
    case_102: /* CIL Label */ 
#line 494
    force ++;
#line 494
    goto switch_break;
    case_63: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
    {
#line 496
    help();
#line 496
    do_exit(0);
    }
#line 496
    goto switch_break;
    case_108: /* CIL Label */ 
#line 498
    to_stdout = 1;
#line 498
    decompress = to_stdout;
#line 498
    list = decompress;
#line 498
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 500
    license();
#line 500
    do_exit(0);
    }
#line 500
    goto switch_break;
    case_109: /* CIL Label */ 
#line 502
    no_time = 1;
#line 502
    goto switch_break;
    case_77: /* CIL Label */ 
#line 504
    no_time = 0;
#line 504
    goto switch_break;
    case_110: /* CIL Label */ 
#line 506
    no_time = 1;
#line 506
    no_name = no_time;
#line 506
    goto switch_break;
    case_78: /* CIL Label */ 
#line 508
    no_time = 0;
#line 508
    no_name = no_time;
#line 508
    goto switch_break;
    case_113: /* CIL Label */ 
#line 510
    quiet = 1;
#line 510
    verbose = 0;
#line 510
    goto switch_break;
    case_114: /* CIL Label */ 
#line 517
    recursive = 1;
#line 517
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 523
    tmp___9 = strlen((char const   *)optarg);
#line 523
    z_len = (int )tmp___9;
#line 524
    strcpy((char */* __restrict  */)(z_suffix), (char const   */* __restrict  */)optarg);
    }
#line 525
    goto switch_break;
    case_116: /* CIL Label */ 
#line 527
    to_stdout = 1;
#line 527
    decompress = to_stdout;
#line 527
    test = decompress;
#line 528
    goto switch_break;
    case_118: /* CIL Label */ 
#line 530
    verbose ++;
#line 530
    quiet = 0;
#line 530
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 532
    version();
#line 532
    do_exit(0);
    }
#line 532
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 537
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -Z not supported in this version\n",
            progname);
#line 539
    usage();
#line 540
    do_exit(1);
    }
#line 540
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 544
    level = optc - 48;
#line 545
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 548
    usage();
#line 549
    do_exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  if (no_time < 0) {
#line 556
    no_time = decompress;
  }
#line 557
  if (no_name < 0) {
#line 557
    no_name = decompress;
  }
#line 559
  file_count = argc - optind;
#line 563
  if (ascii) {
#line 563
    if (! quiet) {
      {
#line 564
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option --ascii ignored on this system\n",
              progname);
      }
    }
  }
#line 568
  if (z_len == 0) {
#line 568
    if (! decompress) {
      {
#line 569
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: incorrect suffix \'%s\'\n",
              progname, optarg);
#line 571
      do_exit(1);
      }
    } else {
#line 568
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 568
  if (z_len > 30) {
    {
#line 569
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: incorrect suffix \'%s\'\n",
            progname, optarg);
#line 571
    do_exit(1);
    }
  }
#line 573
  if (do_lzw) {
#line 573
    if (! decompress) {
#line 573
      work = & lzw;
    }
  }
#line 588
  if (file_count != 0) {
#line 589
    if (to_stdout) {
#line 589
      if (! test) {
#line 589
        if (! list) {
#line 589
          if (! decompress) {
#line 589
            tmp___10 = 1;
          } else
#line 589
          if (! ascii) {
#line 589
            tmp___10 = 1;
          } else {
#line 589
            tmp___10 = 0;
          }
        } else {
#line 589
          tmp___10 = 0;
        }
      } else {
#line 589
        tmp___10 = 0;
      }
    } else {
#line 589
      tmp___10 = 0;
    }
    {
#line 592
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 592
      if (! (optind < argc)) {
#line 592
        goto while_break___0;
      }
      {
#line 593
      tmp___11 = optind;
#line 593
      optind ++;
#line 593
      treat_file(*(argv + tmp___11));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 596
    treat_stdin();
    }
  }
#line 598
  if (list) {
#line 598
    if (! quiet) {
#line 598
      if (file_count > 1) {
        {
#line 599
        do_list(-1, -1);
        }
      }
    }
  }
  {
#line 601
  do_exit(exit_code);
  }
#line 602
  return (exit_code);
}
}
#line 608 "/home/kihong/gzip-1.2.4a/gzip.c"
static void treat_stdin(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  FILE *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 610
  if (! force) {
#line 610
    if (! list) {
#line 610
      if (decompress) {
#line 610
        tmp___1 = stdin;
      } else {
#line 610
        tmp___1 = stdout;
      }
      {
#line 610
      tmp___2 = fileno(tmp___1);
#line 610
      tmp___3 = isatty(tmp___2);
      }
#line 610
      if (tmp___3) {
#line 624
        if (decompress) {
#line 624
          tmp = "de";
        } else {
#line 624
          tmp = "";
        }
#line 624
        if (decompress) {
#line 624
          tmp___0 = "read from";
        } else {
#line 624
          tmp___0 = "written to";
        }
        {
#line 624
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
                progname, tmp___0, tmp);
#line 628
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"For help, type: %s -h\n",
                progname);
#line 629
        do_exit(1);
        }
      }
    }
  }
#line 632
  if (decompress) {
#line 632
    tmp___4 = 1;
  } else
#line 632
  if (! ascii) {
#line 632
    tmp___4 = 1;
  } else {
#line 632
    tmp___4 = 0;
  }
#line 635
  if (! test) {
#line 635
    if (! list) {
#line 635
      if (! decompress) {
#line 635
        tmp___5 = 1;
      } else
#line 635
      if (! ascii) {
#line 635
        tmp___5 = 1;
      } else {
#line 635
        tmp___5 = 0;
      }
    } else {
#line 635
      tmp___5 = 0;
    }
  } else {
#line 635
    tmp___5 = 0;
  }
  {
#line 638
  strcpy((char */* __restrict  */)(ifname), (char const   */* __restrict  */)"stdin");
#line 639
  strcpy((char */* __restrict  */)(ofname), (char const   */* __restrict  */)"stdout");
#line 642
  time_stamp = 0L;
  }
#line 645
  if (list) {
#line 645
    goto _L;
  } else
#line 645
  if (! no_time) {
    _L: /* CIL Label */ 
    {
#line 646
    tmp___6 = fileno(stdin);
#line 646
    tmp___7 = fstat(tmp___6, & istat);
    }
#line 646
    if (tmp___7 != 0) {
      {
#line 647
      error((char *)"fstat(stdin)");
      }
    }
#line 652
    time_stamp = istat.st_mtim.tv_sec;
  }
  {
#line 655
  ifile_size = -1L;
#line 657
  clear_bufs();
#line 658
  to_stdout = 1;
#line 659
  part_nb = 0;
  }
#line 661
  if (decompress) {
    {
#line 662
    method = get_method(ifd);
    }
#line 663
    if (method < 0) {
      {
#line 664
      do_exit(exit_code);
      }
    }
  }
#line 667
  if (list) {
    {
#line 668
    do_list(ifd, method);
    }
#line 669
    return;
  }
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 675
    tmp___8 = fileno(stdout);
#line 675
    tmp___9 = fileno(stdin);
#line 675
    tmp___10 = (*work)(tmp___9, tmp___8);
    }
#line 675
    if (tmp___10 != 0) {
#line 675
      return;
    }
#line 677
    if (! decompress) {
#line 677
      goto while_break;
    } else
#line 677
    if (last_member) {
#line 677
      goto while_break;
    } else
#line 677
    if (inptr == insize) {
#line 677
      goto while_break;
    }
    {
#line 680
    method = get_method(ifd);
    }
#line 681
    if (method < 0) {
#line 681
      return;
    }
#line 682
    bytes_out = 0L;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  if (verbose) {
#line 686
    if (test) {
      {
#line 687
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" OK\n");
      }
    } else
#line 689
    if (! decompress) {
      {
#line 690
      display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
#line 691
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 699
  return;
}
}
#line 704 "/home/kihong/gzip-1.2.4a/gzip.c"
static void treat_file(char *iname ) 
{ 
  int cflag ;
  int tmp ;
  int tmp___0 ;
  struct stat st ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;
  char const   *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 708
  tmp = strcmp((char const   *)iname, "-");
  }
#line 708
  if (tmp == 0) {
    {
#line 709
    cflag = to_stdout;
#line 710
    treat_stdin();
#line 711
    to_stdout = cflag;
    }
#line 712
    return;
  }
  {
#line 716
  tmp___0 = get_istat(iname, & istat);
  }
#line 716
  if (tmp___0 != 0) {
#line 716
    return;
  }
#line 719
  if ((istat.st_mode & 61440U) == 16384U) {
#line 721
    if (recursive) {
      {
#line 723
      st = istat;
#line 724
      treat_dir(iname);
#line 727
      reset_times(iname, & st);
      }
    } else {
#line 731
      if (! quiet) {
        {
#line 731
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is a directory -- ignored\n",
                progname, ifname);
        }
      }
#line 731
      if (exit_code == 0) {
#line 731
        exit_code = 2;
      }
    }
#line 732
    return;
  }
#line 734
  if (! ((istat.st_mode & 61440U) == 32768U)) {
#line 735
    if (! quiet) {
      {
#line 735
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is not a directory or a regular file - ignored\n",
              progname, ifname);
      }
    }
#line 735
    if (exit_code == 0) {
#line 735
      exit_code = 2;
    }
#line 738
    return;
  }
#line 740
  if (istat.st_nlink > 1UL) {
#line 740
    if (! to_stdout) {
#line 740
      if (! force) {
#line 741
        if (! quiet) {
#line 741
          if (istat.st_nlink > 2UL) {
#line 741
            tmp___1 = 's';
          } else {
#line 741
            tmp___1 = ' ';
          }
          {
#line 741
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has %d other link%c -- unchanged\n",
                  progname, ifname, (int )istat.st_nlink - 1, tmp___1);
          }
        }
#line 741
        if (exit_code == 0) {
#line 741
          exit_code = 2;
        }
#line 744
        return;
      }
    }
  }
#line 747
  ifile_size = istat.st_size;
#line 748
  if (no_time) {
#line 748
    if (! list) {
#line 748
      time_stamp = 0L;
    } else {
#line 748
      time_stamp = istat.st_mtim.tv_sec;
    }
  } else {
#line 748
    time_stamp = istat.st_mtim.tv_sec;
  }
#line 753
  if (to_stdout) {
#line 753
    if (! list) {
#line 753
      if (! test) {
        {
#line 754
        strcpy((char */* __restrict  */)(ofname), (char const   */* __restrict  */)"stdout");
        }
      } else {
#line 753
        goto _L___0;
      }
    } else {
#line 753
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 756
    tmp___2 = make_ofname();
    }
#line 756
    if (tmp___2 != 0) {
#line 757
      return;
    }
  }
#line 764
  if (ascii) {
#line 764
    if (! decompress) {
#line 764
      tmp___3 = 0;
    } else {
#line 764
      tmp___3 = 0;
    }
  } else {
#line 764
    tmp___3 = 0;
  }
  {
#line 764
  ifd = open((char const   *)(ifname), tmp___3, 384);
  }
#line 766
  if (ifd == -1) {
    {
#line 767
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
#line 768
    perror((char const   *)(ifname));
#line 769
    exit_code = 1;
    }
#line 770
    return;
  }
  {
#line 772
  clear_bufs();
#line 773
  part_nb = 0;
  }
#line 775
  if (decompress) {
    {
#line 776
    method = get_method(ifd);
    }
#line 777
    if (method < 0) {
      {
#line 778
      close(ifd);
      }
#line 779
      return;
    }
  }
#line 782
  if (list) {
    {
#line 783
    do_list(ifd, method);
#line 784
    close(ifd);
    }
#line 785
    return;
  }
#line 792
  if (to_stdout) {
    {
#line 793
    ofd = fileno(stdout);
    }
  } else {
    {
#line 796
    tmp___4 = create_outfile();
    }
#line 796
    if (tmp___4 != 0) {
#line 796
      return;
    }
#line 798
    if (! decompress) {
#line 798
      if (save_orig_name) {
#line 798
        if (! verbose) {
#line 798
          if (! quiet) {
            {
#line 799
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s compressed to %s\n",
                    progname, ifname, ofname);
            }
          }
        }
      }
    }
  }
#line 804
  if (! save_orig_name) {
#line 804
    save_orig_name = ! no_name;
  }
#line 806
  if (verbose) {
    {
#line 807
    tmp___10 = strlen((char const   *)(ifname));
    }
#line 807
    if ((int )tmp___10 >= 15) {
#line 807
      tmp___9 = "";
    } else {
      {
#line 807
      tmp___8 = strlen((char const   *)(ifname));
      }
#line 807
      if ((int )tmp___8 >= 7) {
#line 807
        tmp___7 = "\t";
      } else {
#line 807
        tmp___7 = "\t\t";
      }
#line 807
      tmp___9 = tmp___7;
    }
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:\t%s",
            ifname, tmp___9);
    }
  }
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 814
    tmp___11 = (*work)(ifd, ofd);
    }
#line 814
    if (tmp___11 != 0) {
#line 815
      method = -1;
#line 816
      goto while_break;
    }
#line 818
    if (! decompress) {
#line 818
      goto while_break;
    } else
#line 818
    if (last_member) {
#line 818
      goto while_break;
    } else
#line 818
    if (inptr == insize) {
#line 818
      goto while_break;
    }
    {
#line 821
    method = get_method(ifd);
    }
#line 822
    if (method < 0) {
#line 822
      goto while_break;
    }
#line 823
    bytes_out = 0L;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 826
  close(ifd);
  }
#line 827
  if (! to_stdout) {
    {
#line 827
    tmp___12 = close(ofd);
    }
#line 827
    if (tmp___12) {
      {
#line 828
      write_error();
      }
    }
  }
#line 830
  if (method == -1) {
#line 831
    if (! to_stdout) {
      {
#line 831
      unlink((char const   *)(ofname));
      }
    }
#line 832
    return;
  }
#line 835
  if (verbose) {
#line 836
    if (test) {
      {
#line 837
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" OK");
      }
    } else
#line 838
    if (decompress) {
      {
#line 839
      display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stderr);
      }
    } else {
      {
#line 841
      display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
      }
    }
#line 843
    if (! test) {
#line 843
      if (! to_stdout) {
        {
#line 844
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -- replaced with %s",
                ofname);
        }
      }
    }
    {
#line 846
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 849
  if (! to_stdout) {
    {
#line 850
    copy_stat(& istat);
    }
  }
#line 852
  return;
}
}
#line 863 "/home/kihong/gzip-1.2.4a/gzip.c"
static int create_outfile(void) 
{ 
  struct stat ostat ;
  int flags___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 866
  flags___0 = 193;
#line 868
  if (ascii) {
#line 868
    if (decompress) {
#line 869
      flags___0 &= -1;
    }
  }
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 873
    tmp = check_ofname();
    }
#line 873
    if (tmp != 0) {
      {
#line 874
      close(ifd);
      }
#line 875
      return (1);
    }
    {
#line 878
    remove_ofname = 1;
#line 879
    ofd = open((char const   *)(ofname), flags___0, 384);
    }
#line 880
    if (ofd == -1) {
      {
#line 881
      perror((char const   *)(ofname));
#line 882
      close(ifd);
#line 883
      exit_code = 1;
      }
#line 884
      return (1);
    }
    {
#line 891
    tmp___0 = fstat(ofd, & ostat);
    }
#line 891
    if (tmp___0 != 0) {
      {
#line 893
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              progname);
#line 894
      perror((char const   *)(ofname));
#line 895
      close(ifd);
#line 895
      close(ofd);
#line 896
      unlink((char const   *)(ofname));
#line 897
      exit_code = 1;
      }
#line 898
      return (1);
    }
    {
#line 900
    tmp___1 = name_too_long(ofname, & ostat);
    }
#line 900
    if (! tmp___1) {
#line 900
      return (0);
    }
#line 902
    if (decompress) {
#line 904
      if (! quiet) {
        {
#line 904
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: warning, name truncated\n",
                progname, ofname);
        }
      }
#line 904
      if (exit_code == 0) {
#line 904
        exit_code = 2;
      }
#line 906
      return (0);
    }
    {
#line 908
    close(ofd);
#line 909
    unlink((char const   *)(ofname));
#line 915
    shorten_name(ofname);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 923 "/home/kihong/gzip-1.2.4a/gzip.c"
static int do_stat(char *name , struct stat *sbuf ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 927
  tmp = __errno_location();
#line 927
  *tmp = 0;
  }
#line 929
  if (! to_stdout) {
#line 929
    if (! force) {
      {
#line 930
      tmp___0 = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)sbuf);
      }
#line 930
      return (tmp___0);
    }
  }
  {
#line 933
  tmp___1 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)sbuf);
  }
#line 933
  return (tmp___1);
}
}
#line 953 "/home/kihong/gzip-1.2.4a/gzip.c"
static char *known_suffixes[9]  = 
#line 953
  {      z_suffix,      (char *)".gz",      (char *)".z",      (char *)".taz", 
        (char *)".tgz",      (char *)"-gz",      (char *)"-z",      (char *)"_z", 
        (char *)((void *)0)};
#line 948 "/home/kihong/gzip-1.2.4a/gzip.c"
static char *get_suffix(char *name ) 
{ 
  int nlen ;
  int slen ;
  char suffix[33] ;
  char **suf ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int s ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 959
  suf = known_suffixes;
#line 961
  tmp = strcmp((char const   *)(z_suffix), "z");
  }
#line 961
  if (tmp == 0) {
#line 961
    suf ++;
  }
  {
#line 970
  tmp___0 = strlen((char const   *)name);
#line 970
  nlen = (int )tmp___0;
  }
#line 971
  if (nlen <= 32) {
    {
#line 972
    strcpy((char */* __restrict  */)(suffix), (char const   */* __restrict  */)name);
    }
  } else {
    {
#line 974
    strcpy((char */* __restrict  */)(suffix), (char const   */* __restrict  */)(((name + nlen) - 30) - 2));
    }
  }
  {
#line 976
  strlwr(suffix);
#line 977
  tmp___1 = strlen((char const   *)(suffix));
#line 977
  slen = (int )tmp___1;
  }
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 979
    tmp___2 = strlen((char const   *)*suf);
#line 979
    s = (int )tmp___2;
    }
#line 980
    if (slen > s) {
#line 980
      if ((int )suffix[(slen - s) - 1] != 47) {
        {
#line 980
        tmp___3 = strcmp((char const   *)((suffix + slen) - s), (char const   *)*suf);
        }
#line 980
        if (tmp___3 == 0) {
#line 982
          return ((name + nlen) - s);
        }
      }
    }
#line 978
    suf ++;
#line 978
    if (! ((unsigned long )*suf != (unsigned long )((void *)0))) {
#line 978
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 986
  return ((char *)((void *)0));
}
}
#line 1002 "/home/kihong/gzip-1.2.4a/gzip.c"
static char *suffixes[6]  = {      z_suffix,      (char *)".gz",      (char *)".z",      (char *)"-z", 
        (char *)".Z",      (char *)((void *)0)};
#line 997 "/home/kihong/gzip-1.2.4a/gzip.c"
static int get_istat(char *iname , struct stat *sbuf ) 
{ 
  int ilen ;
  char **suf ;
  char *s ;
  int tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1003
  suf = suffixes;
#line 1009
  strcpy((char */* __restrict  */)(ifname), (char const   */* __restrict  */)iname);
#line 1012
  tmp = do_stat(ifname, sbuf);
  }
#line 1012
  if (tmp == 0) {
#line 1012
    return (0);
  }
#line 1014
  if (! decompress) {
    {
#line 1015
    perror((char const   *)(ifname));
#line 1016
    exit_code = 1;
    }
#line 1017
    return (1);
  } else {
    {
#line 1014
    tmp___0 = __errno_location();
    }
#line 1014
    if (*tmp___0 != 2) {
      {
#line 1015
      perror((char const   *)(ifname));
#line 1016
      exit_code = 1;
      }
#line 1017
      return (1);
    }
  }
  {
#line 1022
  s = get_suffix(ifname);
  }
#line 1023
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 1024
    perror((char const   *)(ifname));
#line 1025
    exit_code = 1;
    }
#line 1026
    return (1);
  }
  {
#line 1035
  tmp___1 = strlen((char const   *)(ifname));
#line 1035
  ilen = (int )tmp___1;
#line 1036
  tmp___2 = strcmp((char const   *)(z_suffix), ".gz");
  }
#line 1036
  if (tmp___2 == 0) {
#line 1036
    suf ++;
  }
  {
#line 1039
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1040
    s = *suf;
#line 1051
    strcat((char */* __restrict  */)(ifname), (char const   */* __restrict  */)s);
#line 1052
    tmp___3 = do_stat(ifname, sbuf);
    }
#line 1052
    if (tmp___3 == 0) {
#line 1052
      return (0);
    }
#line 1053
    ifname[ilen] = (char )'\000';
#line 1039
    suf ++;
#line 1039
    if (! ((unsigned long )*suf != (unsigned long )((void *)0))) {
#line 1039
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1062
  strcat((char */* __restrict  */)(ifname), (char const   */* __restrict  */)(z_suffix));
#line 1063
  perror((char const   *)(ifname));
#line 1064
  exit_code = 1;
  }
#line 1065
  return (1);
}
}
#line 1072 "/home/kihong/gzip-1.2.4a/gzip.c"
static int make_ofname(void) 
{ 
  char *suff ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1076
  strcpy((char */* __restrict  */)(ofname), (char const   */* __restrict  */)(ifname));
#line 1078
  suff = get_suffix(ofname);
  }
#line 1080
  if (decompress) {
#line 1081
    if ((unsigned long )suff == (unsigned long )((void *)0)) {
#line 1085
      if (! recursive) {
#line 1085
        if (list) {
#line 1085
          return (0);
        } else
#line 1085
        if (test) {
#line 1085
          return (0);
        }
      }
#line 1088
      if (verbose) {
#line 1088
        goto _L;
      } else
#line 1088
      if (! recursive) {
#line 1088
        if (! quiet) {
          _L: /* CIL Label */ 
#line 1089
          if (! quiet) {
            {
#line 1089
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: unknown suffix -- ignored\n",
                    progname, ifname);
            }
          }
#line 1089
          if (exit_code == 0) {
#line 1089
            exit_code = 2;
          }
        }
      }
#line 1092
      return (2);
    }
    {
#line 1095
    strlwr(suff);
#line 1096
    tmp = strcmp((char const   *)suff, ".tgz");
    }
#line 1096
    if (tmp == 0) {
      {
#line 1097
      strcpy((char */* __restrict  */)suff, (char const   */* __restrict  */)".tar");
      }
    } else {
      {
#line 1096
      tmp___0 = strcmp((char const   *)suff, ".taz");
      }
#line 1096
      if (tmp___0 == 0) {
        {
#line 1097
        strcpy((char */* __restrict  */)suff, (char const   */* __restrict  */)".tar");
        }
      } else {
#line 1099
        *suff = (char )'\000';
      }
    }
  } else
#line 1103
  if ((unsigned long )suff != (unsigned long )((void *)0)) {
#line 1105
    if (verbose) {
      {
#line 1106
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already has %s suffix -- unchanged\n",
              progname, ifname, suff);
      }
    } else
#line 1105
    if (! recursive) {
#line 1105
      if (! quiet) {
        {
#line 1106
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already has %s suffix -- unchanged\n",
                progname, ifname, suff);
        }
      }
    }
#line 1109
    if (exit_code == 0) {
#line 1109
      exit_code = 2;
    }
#line 1110
    return (2);
  } else {
    {
#line 1112
    save_orig_name = 0;
#line 1133
    strcat((char */* __restrict  */)(ofname), (char const   */* __restrict  */)(z_suffix));
    }
  }
#line 1136
  return (0);
}
}
#line 1151 "/home/kihong/gzip-1.2.4a/gzip.c"
static int get_method(int in ) 
{ 
  uch flags___0 ;
  char magic[2] ;
  ulg stamp ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  unsigned int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int part ;
  unsigned int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  unsigned int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  unsigned int len ;
  unsigned int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  unsigned int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  char c ;
  unsigned int tmp___45 ;
  int tmp___46 ;
  char *p ;
  char *tmp___47 ;
  char *base ;
  unsigned int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  unsigned int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;

  {
#line 1161
  if (force) {
#line 1161
    if (to_stdout) {
#line 1162
      if (inptr < insize) {
#line 1162
        tmp = inptr;
#line 1162
        inptr ++;
#line 1162
        tmp___1 = (int )inbuf[tmp];
      } else {
        {
#line 1162
        tmp___0 = fill_inbuf(1);
#line 1162
        tmp___1 = tmp___0;
        }
      }
#line 1162
      magic[0] = (char )tmp___1;
#line 1163
      if (inptr < insize) {
#line 1163
        tmp___2 = inptr;
#line 1163
        inptr ++;
#line 1163
        tmp___4 = (int )inbuf[tmp___2];
      } else {
        {
#line 1163
        tmp___3 = fill_inbuf(1);
#line 1163
        tmp___4 = tmp___3;
        }
      }
#line 1163
      magic[1] = (char )tmp___4;
    } else {
#line 1161
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1166
    if (inptr < insize) {
#line 1166
      tmp___5 = inptr;
#line 1166
      inptr ++;
#line 1166
      tmp___7 = (int )inbuf[tmp___5];
    } else {
      {
#line 1166
      tmp___6 = fill_inbuf(0);
#line 1166
      tmp___7 = tmp___6;
      }
    }
#line 1166
    magic[0] = (char )tmp___7;
#line 1167
    if (inptr < insize) {
#line 1167
      tmp___8 = inptr;
#line 1167
      inptr ++;
#line 1167
      tmp___10 = (int )inbuf[tmp___8];
    } else {
      {
#line 1167
      tmp___9 = fill_inbuf(0);
#line 1167
      tmp___10 = tmp___9;
      }
    }
#line 1167
    magic[1] = (char )tmp___10;
  }
  {
#line 1169
  method = -1;
#line 1170
  part_nb ++;
#line 1171
  header_bytes = 0L;
#line 1172
  last_member = 0;
#line 1175
  tmp___61 = memcmp((void const   *)(magic), (void const   *)"\037\213", (size_t )2);
  }
#line 1175
  if (tmp___61 == 0) {
#line 1175
    goto _L___4;
  } else {
    {
#line 1175
    tmp___62 = memcmp((void const   *)(magic), (void const   *)"\037\236", (size_t )2);
    }
#line 1175
    if (tmp___62 == 0) {
      _L___4: /* CIL Label */ 
#line 1178
      if (inptr < insize) {
#line 1178
        tmp___11 = inptr;
#line 1178
        inptr ++;
#line 1178
        tmp___13 = (int )inbuf[tmp___11];
      } else {
        {
#line 1178
        tmp___12 = fill_inbuf(0);
#line 1178
        tmp___13 = tmp___12;
        }
      }
#line 1178
      method = tmp___13;
#line 1179
      if (method != 8) {
        {
#line 1180
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: unknown method %d -- get newer version of gzip\n",
                progname, ifname, method);
#line 1183
        exit_code = 1;
        }
#line 1184
        return (-1);
      }
#line 1186
      work = & unzip;
#line 1187
      if (inptr < insize) {
#line 1187
        tmp___14 = inptr;
#line 1187
        inptr ++;
#line 1187
        tmp___16 = (int )inbuf[tmp___14];
      } else {
        {
#line 1187
        tmp___15 = fill_inbuf(0);
#line 1187
        tmp___16 = tmp___15;
        }
      }
#line 1187
      flags___0 = (uch )tmp___16;
#line 1189
      if (((int )flags___0 & 32) != 0) {
        {
#line 1190
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is encrypted -- get newer version of gzip\n",
                progname, ifname);
#line 1193
        exit_code = 1;
        }
#line 1194
        return (-1);
      }
#line 1196
      if (((int )flags___0 & 2) != 0) {
        {
#line 1197
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
                progname, ifname);
#line 1200
        exit_code = 1;
        }
#line 1201
        if (force <= 1) {
#line 1201
          return (-1);
        }
      }
#line 1203
      if (((int )flags___0 & 192) != 0) {
        {
#line 1204
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has flags 0x%x -- get newer version of gzip\n",
                progname, ifname, (int )flags___0);
#line 1207
        exit_code = 1;
        }
#line 1208
        if (force <= 1) {
#line 1208
          return (-1);
        }
      }
#line 1210
      if (inptr < insize) {
#line 1210
        tmp___17 = inptr;
#line 1210
        inptr ++;
#line 1210
        tmp___19 = (int )inbuf[tmp___17];
      } else {
        {
#line 1210
        tmp___18 = fill_inbuf(0);
#line 1210
        tmp___19 = tmp___18;
        }
      }
#line 1210
      stamp = (ulg )tmp___19;
#line 1211
      if (inptr < insize) {
#line 1211
        tmp___20 = inptr;
#line 1211
        inptr ++;
#line 1211
        tmp___22 = (int )inbuf[tmp___20];
      } else {
        {
#line 1211
        tmp___21 = fill_inbuf(0);
#line 1211
        tmp___22 = tmp___21;
        }
      }
#line 1211
      stamp |= (ulg )tmp___22 << 8;
#line 1212
      if (inptr < insize) {
#line 1212
        tmp___23 = inptr;
#line 1212
        inptr ++;
#line 1212
        tmp___25 = (int )inbuf[tmp___23];
      } else {
        {
#line 1212
        tmp___24 = fill_inbuf(0);
#line 1212
        tmp___25 = tmp___24;
        }
      }
#line 1212
      stamp |= (ulg )tmp___25 << 16;
#line 1213
      if (inptr < insize) {
#line 1213
        tmp___26 = inptr;
#line 1213
        inptr ++;
#line 1213
        tmp___28 = (int )inbuf[tmp___26];
      } else {
        {
#line 1213
        tmp___27 = fill_inbuf(0);
#line 1213
        tmp___28 = tmp___27;
        }
      }
#line 1213
      stamp |= (ulg )tmp___28 << 24;
#line 1214
      if (stamp != 0UL) {
#line 1214
        if (! no_time) {
#line 1214
          time_stamp = (long )stamp;
        }
      }
#line 1216
      if (inptr < insize) {
#line 1216
        tmp___29 = inptr;
#line 1216
        inptr ++;
      } else {
        {
#line 1216
        fill_inbuf(0);
        }
      }
#line 1217
      if (inptr < insize) {
#line 1217
        tmp___30 = inptr;
#line 1217
        inptr ++;
      } else {
        {
#line 1217
        fill_inbuf(0);
        }
      }
#line 1219
      if (((int )flags___0 & 2) != 0) {
#line 1220
        if (inptr < insize) {
#line 1220
          tmp___31 = inptr;
#line 1220
          inptr ++;
#line 1220
          tmp___33 = (int )inbuf[tmp___31];
        } else {
          {
#line 1220
          tmp___32 = fill_inbuf(0);
#line 1220
          tmp___33 = tmp___32;
          }
        }
#line 1220
        part = (unsigned int )tmp___33;
#line 1221
        if (inptr < insize) {
#line 1221
          tmp___34 = inptr;
#line 1221
          inptr ++;
#line 1221
          tmp___36 = (int )inbuf[tmp___34];
        } else {
          {
#line 1221
          tmp___35 = fill_inbuf(0);
#line 1221
          tmp___36 = tmp___35;
          }
        }
#line 1221
        part |= (unsigned int )tmp___36 << 8;
#line 1222
        if (verbose) {
          {
#line 1223
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: part number %u\n",
                  progname, ifname, part);
          }
        }
      }
#line 1227
      if (((int )flags___0 & 4) != 0) {
#line 1228
        if (inptr < insize) {
#line 1228
          tmp___37 = inptr;
#line 1228
          inptr ++;
#line 1228
          tmp___39 = (int )inbuf[tmp___37];
        } else {
          {
#line 1228
          tmp___38 = fill_inbuf(0);
#line 1228
          tmp___39 = tmp___38;
          }
        }
#line 1228
        len = (unsigned int )tmp___39;
#line 1229
        if (inptr < insize) {
#line 1229
          tmp___40 = inptr;
#line 1229
          inptr ++;
#line 1229
          tmp___42 = (int )inbuf[tmp___40];
        } else {
          {
#line 1229
          tmp___41 = fill_inbuf(0);
#line 1229
          tmp___42 = tmp___41;
          }
        }
#line 1229
        len |= (unsigned int )tmp___42 << 8;
#line 1230
        if (verbose) {
          {
#line 1231
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: extra field of %u bytes ignored\n",
                  progname, ifname, len);
          }
        }
        {
#line 1234
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1234
          tmp___44 = len;
#line 1234
          len --;
#line 1234
          if (! tmp___44) {
#line 1234
            goto while_break;
          }
#line 1234
          if (inptr < insize) {
#line 1234
            tmp___43 = inptr;
#line 1234
            inptr ++;
          } else {
            {
#line 1234
            fill_inbuf(0);
            }
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 1238
      if (((int )flags___0 & 8) != 0) {
#line 1239
        if (no_name) {
#line 1239
          goto _L___0;
        } else
#line 1239
        if (to_stdout) {
#line 1239
          if (! list) {
#line 1239
            goto _L___0;
          } else {
#line 1239
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1239
        if (part_nb > 1) {
          _L___0: /* CIL Label */ 
          {
#line 1242
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1242
            if (inptr < insize) {
#line 1242
              tmp___45 = inptr;
#line 1242
              inptr ++;
#line 1242
              c = (char )inbuf[tmp___45];
            } else {
              {
#line 1242
              tmp___46 = fill_inbuf(0);
#line 1242
              c = (char )tmp___46;
              }
            }
#line 1242
            if (! ((int )c != 0)) {
#line 1242
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 1245
          tmp___47 = basename(ofname);
#line 1245
          p = tmp___47;
#line 1246
          base = p;
          }
          {
#line 1247
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1248
            if (inptr < insize) {
#line 1248
              tmp___48 = inptr;
#line 1248
              inptr ++;
#line 1248
              tmp___50 = (int )inbuf[tmp___48];
            } else {
              {
#line 1248
              tmp___49 = fill_inbuf(0);
#line 1248
              tmp___50 = tmp___49;
              }
            }
#line 1248
            *p = (char )tmp___50;
#line 1249
            tmp___51 = p;
#line 1249
            p ++;
#line 1249
            if ((int )*tmp___51 == 0) {
#line 1249
              goto while_break___1;
            }
#line 1250
            if ((unsigned long )p >= (unsigned long )(ofname + sizeof(ofname))) {
              {
#line 1251
              error((char *)"corrupted input -- file name too large");
              }
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1255
          if (! list) {
#line 1257
            if (base) {
#line 1257
              list = 0;
            }
          }
        }
      }
#line 1263
      if (((int )flags___0 & 16) != 0) {
        {
#line 1264
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1264
          if (inptr < insize) {
#line 1264
            tmp___52 = inptr;
#line 1264
            inptr ++;
#line 1264
            tmp___54 = (int )inbuf[tmp___52];
          } else {
            {
#line 1264
            tmp___53 = fill_inbuf(0);
#line 1264
            tmp___54 = tmp___53;
            }
          }
#line 1264
          if (! (tmp___54 != 0)) {
#line 1264
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1266
      if (part_nb == 1) {
#line 1267
        header_bytes = (long )((unsigned long )inptr + 2UL * sizeof(long ));
      }
    } else {
      {
#line 1270
      tmp___59 = memcmp((void const   *)(magic), (void const   *)"PK\003\004", (size_t )2);
      }
#line 1270
      if (tmp___59 == 0) {
#line 1270
        if (inptr == 2U) {
          {
#line 1270
          tmp___60 = memcmp((void const   *)((char *)(inbuf)), (void const   *)"PK\003\004",
                            (size_t )4);
          }
#line 1270
          if (tmp___60 == 0) {
            {
#line 1275
            inptr = 0U;
#line 1276
            work = & unzip;
#line 1277
            tmp___55 = check_zipfile(in);
            }
#line 1277
            if (tmp___55 != 0) {
#line 1277
              return (-1);
            }
#line 1279
            last_member = 1;
          } else {
#line 1270
            goto _L___3;
          }
        } else {
#line 1270
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
        {
#line 1281
        tmp___58 = memcmp((void const   *)(magic), (void const   *)"\037\036", (size_t )2);
        }
#line 1281
        if (tmp___58 == 0) {
#line 1282
          work = & unpack;
#line 1283
          method = 2;
        } else {
          {
#line 1285
          tmp___57 = memcmp((void const   *)(magic), (void const   *)"\037\235", (size_t )2);
          }
#line 1285
          if (tmp___57 == 0) {
#line 1286
            work = & unlzw;
#line 1287
            method = 1;
#line 1288
            last_member = 1;
          } else {
            {
#line 1290
            tmp___56 = memcmp((void const   *)(magic), (void const   *)"\037\240",
                              (size_t )2);
            }
#line 1290
            if (tmp___56 == 0) {
#line 1291
              work = & unlzh;
#line 1292
              method = 3;
#line 1293
              last_member = 1;
            } else
#line 1295
            if (force) {
#line 1295
              if (to_stdout) {
#line 1295
                if (! list) {
#line 1296
                  method = 0;
#line 1297
                  work = & copy;
#line 1298
                  inptr = 0U;
#line 1299
                  last_member = 1;
                }
              }
            }
          }
        }
      }
    }
  }
#line 1301
  if (method >= 0) {
#line 1301
    return (method);
  }
#line 1303
  if (part_nb == 1) {
    {
#line 1304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: not in gzip format\n",
            progname, ifname);
#line 1305
    exit_code = 1;
    }
#line 1306
    return (-1);
  } else {
#line 1308
    if (! quiet) {
      {
#line 1308
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: decompression OK, trailing garbage ignored\n",
              progname, ifname);
      }
    }
#line 1308
    if (exit_code == 0) {
#line 1308
      exit_code = 2;
    }
#line 1310
    return (-2);
  }
}
}
#line 1324 "/home/kihong/gzip-1.2.4a/gzip.c"
static int first_time  =    1;
#line 1325 "/home/kihong/gzip-1.2.4a/gzip.c"
static char *methods[9]  = 
#line 1325
  {      (char *)"store",      (char *)"compr",      (char *)"pack ",      (char *)"lzh  ", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"defla"};
#line 1319 "/home/kihong/gzip-1.2.4a/gzip.c"
static void do_list(int ifd___0 , int method___0 ) 
{ 
  ulg crc___1 ;
  char *date ;
  __off_t tmp ;
  uch buf[8] ;
  ssize_t tmp___0 ;
  char *tmp___1 ;

  {
#line 1334
  if (first_time) {
#line 1334
    if (method___0 >= 0) {
#line 1335
      first_time = 0;
#line 1336
      if (verbose) {
        {
#line 1337
        printf((char const   */* __restrict  */)"method  crc     date  time  ");
        }
      }
#line 1339
      if (! quiet) {
        {
#line 1340
        printf((char const   */* __restrict  */)"compressed  uncompr. ratio uncompressed_name\n");
        }
      }
    } else {
#line 1334
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1342
  if (method___0 < 0) {
#line 1343
    if (total_in <= 0L) {
#line 1343
      return;
    } else
#line 1343
    if (total_out <= 0L) {
#line 1343
      return;
    }
#line 1344
    if (verbose) {
      {
#line 1345
      printf((char const   */* __restrict  */)"                            %9lu %9lu ",
             total_in, total_out);
      }
    } else
#line 1347
    if (! quiet) {
      {
#line 1348
      printf((char const   */* __restrict  */)"%9ld %9ld ", total_in, total_out);
      }
    }
    {
#line 1350
    display_ratio(total_out - (total_in - header_bytes), total_out, stdout);
#line 1354
    printf((char const   */* __restrict  */)" (totals)\n");
    }
#line 1355
    return;
  }
#line 1357
  crc___1 = (ulg )(~ 0);
#line 1358
  bytes_out = -1L;
#line 1359
  bytes_in = ifile_size;
#line 1362
  if (method___0 == 8) {
#line 1362
    if (! last_member) {
      {
#line 1369
      tmp = lseek(ifd___0, (off_t )-8, 2);
#line 1369
      bytes_in = tmp;
      }
#line 1370
      if (bytes_in != -1L) {
        {
#line 1372
        bytes_in += 8L;
#line 1373
        tmp___0 = read(ifd___0, (void *)((char *)(buf)), sizeof(buf));
        }
#line 1373
        if ((unsigned long )tmp___0 != sizeof(buf)) {
          {
#line 1374
          read_error();
          }
        }
#line 1376
        crc___1 = (ulg )((int )((ush )buf[0]) | ((int )((ush )buf[1]) << 8)) | ((ulg )((int )((ush )*((buf + 2) + 0)) | ((int )((ush )*((buf + 2) + 1)) << 8)) << 16);
#line 1377
        bytes_out = (long )((ulg )((int )((ush )*((buf + 4) + 0)) | ((int )((ush )*((buf + 4) + 1)) << 8)) | ((ulg )((int )((ush )*(((buf + 4) + 2) + 0)) | ((int )((ush )*(((buf + 4) + 2) + 1)) << 8)) << 16));
      }
    }
  }
  {
#line 1381
  tmp___1 = ctime((time_t const   *)(& time_stamp));
#line 1381
  date = tmp___1 + 4;
#line 1382
  *(date + 12) = (char )'\000';
  }
#line 1383
  if (verbose) {
    {
#line 1384
    printf((char const   */* __restrict  */)"%5s %08lx %11s ", methods[method___0],
           crc___1, date);
    }
  }
  {
#line 1386
  printf((char const   */* __restrict  */)"%9ld %9ld ", bytes_in, bytes_out);
  }
#line 1387
  if (bytes_in == -1L) {
#line 1388
    total_in = -1L;
#line 1389
    header_bytes = 0L;
#line 1389
    bytes_out = header_bytes;
#line 1389
    bytes_in = bytes_out;
  } else
#line 1390
  if (total_in >= 0L) {
#line 1391
    total_in += bytes_in;
  }
#line 1393
  if (bytes_out == -1L) {
#line 1394
    total_out = -1L;
#line 1395
    header_bytes = 0L;
#line 1395
    bytes_out = header_bytes;
#line 1395
    bytes_in = bytes_out;
  } else
#line 1396
  if (total_out >= 0L) {
#line 1397
    total_out += bytes_out;
  }
  {
#line 1399
  display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stdout);
#line 1400
  printf((char const   */* __restrict  */)" %s\n", ofname);
  }
#line 1401
  return;
}
}
#line 1406 "/home/kihong/gzip-1.2.4a/gzip.c"
static int same_file(struct stat *stat1 , struct stat *stat2 ) 
{ 
  int tmp ;

  {
#line 1410
  if (stat1->st_ino == stat2->st_ino) {
#line 1410
    if (stat1->st_dev == stat2->st_dev) {
#line 1410
      tmp = 1;
    } else {
#line 1410
      tmp = 0;
    }
  } else {
#line 1410
    tmp = 0;
  }
#line 1410
  return (tmp);
}
}
#line 1429 "/home/kihong/gzip-1.2.4a/gzip.c"
static int name_too_long(char *name , struct stat *statb ) 
{ 
  int s ;
  size_t tmp ;
  char c ;
  struct stat tstat ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1433
  tmp = strlen((char const   *)name);
#line 1433
  s = (int )tmp;
#line 1434
  c = *(name + (s - 1));
#line 1438
  tstat = *statb;
#line 1439
  *(name + (s - 1)) = (char )'\000';
#line 1440
  tmp___0 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& tstat));
  }
#line 1440
  if (tmp___0 == 0) {
    {
#line 1440
    tmp___1 = same_file(statb, & tstat);
    }
#line 1440
    if (tmp___1) {
#line 1440
      tmp___2 = 1;
    } else {
#line 1440
      tmp___2 = 0;
    }
  } else {
#line 1440
    tmp___2 = 0;
  }
#line 1440
  res = tmp___2;
#line 1441
  *(name + (s - 1)) = c;
#line 1443
  return (res);
}
}
#line 1455 "/home/kihong/gzip-1.2.4a/gzip.c"
static void shorten_name(char *name ) 
{ 
  int len ;
  char *trunc ;
  int plen ;
  int min_part ;
  char *p ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1459
  trunc = (char *)((void *)0);
#line 1461
  min_part = 3;
#line 1464
  tmp = strlen((char const   *)name);
#line 1464
  len = (int )tmp;
  }
#line 1465
  if (decompress) {
#line 1466
    if (len <= 1) {
      {
#line 1466
      error((char *)"name too short");
      }
    }
#line 1467
    *(name + (len - 1)) = (char )'\000';
#line 1468
    return;
  }
  {
#line 1470
  p = get_suffix(name);
  }
#line 1471
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1471
    error((char *)"can\'t recover suffix\n");
    }
  }
#line 1472
  *p = (char )'\000';
#line 1473
  save_orig_name = 1;
#line 1476
  if (len > 4) {
    {
#line 1476
    tmp___0 = strcmp((char const   *)(p - 4), ".tar");
    }
#line 1476
    if (tmp___0 == 0) {
      {
#line 1477
      strcpy((char */* __restrict  */)(p - 4), (char const   */* __restrict  */)".tgz");
      }
#line 1478
      return;
    }
  }
  {
#line 1483
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1484
    p = strrchr((char const   *)name, '/');
    }
#line 1485
    if (p) {
#line 1485
      p ++;
    } else {
#line 1485
      p = name;
    }
    {
#line 1486
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1486
      if (! *p) {
#line 1486
        goto while_break___0;
      }
      {
#line 1487
      tmp___1 = strcspn((char const   *)p, ".");
#line 1487
      plen = (int )tmp___1;
#line 1488
      p += plen;
      }
#line 1489
      if (plen > min_part) {
#line 1489
        trunc = p - 1;
      }
#line 1490
      if (*p) {
#line 1490
        p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1483
    if ((unsigned long )trunc == (unsigned long )((void *)0)) {
#line 1483
      min_part --;
#line 1483
      if (! (min_part != 0)) {
#line 1483
        goto while_break;
      }
    } else {
#line 1483
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1494
  if ((unsigned long )trunc != (unsigned long )((void *)0)) {
    {
#line 1495
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1496
      *(trunc + 0) = *(trunc + 1);
#line 1495
      tmp___2 = trunc;
#line 1495
      trunc ++;
#line 1495
      if (! *tmp___2) {
#line 1495
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1498
    trunc --;
  } else {
    {
#line 1500
    trunc = strrchr((char const   *)name, (int )*("." + 0));
    }
#line 1501
    if ((unsigned long )trunc == (unsigned long )((void *)0)) {
      {
#line 1501
      error((char *)"internal error in shorten_name");
      }
    }
#line 1502
    if ((int )*(trunc + 1) == 0) {
#line 1502
      trunc --;
    }
  }
  {
#line 1504
  strcpy((char */* __restrict  */)trunc, (char const   */* __restrict  */)(z_suffix));
  }
#line 1505
  return;
}
}
#line 1521 "/home/kihong/gzip-1.2.4a/gzip.c"
static int check_ofname(void) 
{ 
  struct stat ostat ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char response[80] ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  int tmp___12 ;

  {
  {
#line 1529
  tmp = __errno_location();
#line 1529
  *tmp = 0;
  }
  {
#line 1530
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1530
    tmp___1 = stat((char const   */* __restrict  */)(ofname), (struct stat */* __restrict  */)(& ostat));
    }
#line 1530
    if (! (tmp___1 != 0)) {
#line 1530
      goto while_break;
    }
    {
#line 1531
    tmp___0 = __errno_location();
    }
#line 1531
    if (*tmp___0 != 36) {
#line 1531
      return (0);
    }
    {
#line 1532
    shorten_name(ofname);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1541
  if (! decompress) {
    {
#line 1541
    tmp___3 = name_too_long(ofname, & ostat);
    }
#line 1541
    if (tmp___3) {
      {
#line 1542
      shorten_name(ofname);
#line 1543
      tmp___2 = stat((char const   */* __restrict  */)(ofname), (struct stat */* __restrict  */)(& ostat));
      }
#line 1543
      if (tmp___2 != 0) {
#line 1543
        return (0);
      }
    }
  }
  {
#line 1549
  tmp___6 = same_file(& istat, & ostat);
  }
#line 1549
  if (tmp___6) {
    {
#line 1550
    tmp___5 = strcmp((char const   *)(ifname), (char const   *)(ofname));
    }
#line 1550
    if (tmp___5 == 0) {
#line 1551
      if (decompress) {
#line 1551
        tmp___4 = "de";
      } else {
#line 1551
        tmp___4 = "";
      }
      {
#line 1551
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot %scompress onto itself\n",
              progname, ifname, tmp___4);
      }
    } else {
      {
#line 1554
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s and %s are the same file\n",
              progname, ifname, ofname);
      }
    }
#line 1557
    exit_code = 1;
#line 1558
    return (1);
  }
#line 1561
  if (! force) {
    {
#line 1563
    strcpy((char */* __restrict  */)(response), (char const   */* __restrict  */)"n");
#line 1564
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already exists;",
            progname, ofname);
    }
#line 1565
    if (foreground) {
      {
#line 1565
      tmp___7 = fileno(stdin);
#line 1565
      tmp___8 = isatty(tmp___7);
      }
#line 1565
      if (tmp___8) {
        {
#line 1566
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" do you wish to overwrite (y or n)? ");
#line 1567
        fflush(stderr);
#line 1568
        fgets((char */* __restrict  */)(response), (int )(sizeof(response) - 1UL),
              (FILE */* __restrict  */)stdin);
        }
      }
    }
    {
#line 1570
    tmp___11 = __ctype_b_loc();
    }
#line 1570
    if ((int const   )*(*tmp___11 + (int )response[0]) & 256) {
#line 1570
      tmp___10 = ((int )response[0] - 65) + 97;
    } else {
#line 1570
      tmp___10 = (int )response[0];
    }
#line 1570
    if (tmp___10 != 121) {
      {
#line 1571
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tnot overwritten\n");
      }
#line 1572
      if (exit_code == 0) {
#line 1572
        exit_code = 2;
      }
#line 1573
      return (1);
    }
  }
  {
#line 1576
  chmod((char const   *)(ofname), (__mode_t )511);
#line 1577
  tmp___12 = unlink((char const   *)(ofname));
  }
#line 1577
  if (tmp___12) {
    {
#line 1578
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
#line 1579
    perror((char const   *)(ofname));
#line 1580
    exit_code = 1;
    }
#line 1581
    return (1);
  }
#line 1583
  return (0);
}
}
#line 1591 "/home/kihong/gzip-1.2.4a/gzip.c"
static void reset_times(char *name , struct stat *statb ) 
{ 
  struct utimbuf timep ;
  int tmp ;

  {
  {
#line 1598
  timep.actime = statb->st_atim.tv_sec;
#line 1599
  timep.modtime = statb->st_mtim.tv_sec;
#line 1602
  tmp = utime((char const   *)name, (struct utimbuf  const  *)(& timep));
  }
#line 1602
  if (tmp) {
#line 1602
    if (! ((statb->st_mode & 61440U) == 16384U)) {
#line 1603
      if (! quiet) {
        {
#line 1603
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                progname);
        }
      }
#line 1603
      if (exit_code == 0) {
#line 1603
        exit_code = 2;
      }
#line 1604
      if (! quiet) {
        {
#line 1604
        perror((char const   *)(ofname));
        }
      }
    }
  }
#line 1606
  return;
}
}
#line 1614 "/home/kihong/gzip-1.2.4a/gzip.c"
static void copy_stat(struct stat *ifstat ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1618
  if (decompress) {
#line 1618
    if (time_stamp != 0L) {
#line 1618
      if (ifstat->st_mtim.tv_sec != time_stamp) {
#line 1619
        ifstat->st_mtim.tv_sec = time_stamp;
#line 1620
        if (verbose > 1) {
          {
#line 1621
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: time stamp restored\n",
                  ofname);
          }
        }
      }
    }
  }
  {
#line 1624
  reset_times(ofname, ifstat);
#line 1627
  tmp = chmod((char const   *)(ofname), ifstat->st_mode & 4095U);
  }
#line 1627
  if (tmp) {
#line 1628
    if (! quiet) {
      {
#line 1628
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              progname);
      }
    }
#line 1628
    if (exit_code == 0) {
#line 1628
      exit_code = 2;
    }
#line 1629
    if (! quiet) {
      {
#line 1629
      perror((char const   *)(ofname));
      }
    }
  }
  {
#line 1632
  chown((char const   *)(ofname), ifstat->st_uid, ifstat->st_gid);
#line 1634
  remove_ofname = 0;
#line 1636
  chmod((char const   *)(ifname), (__mode_t )511);
#line 1637
  tmp___0 = unlink((char const   *)(ifname));
  }
#line 1637
  if (tmp___0) {
#line 1638
    if (! quiet) {
      {
#line 1638
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              progname);
      }
    }
#line 1638
    if (exit_code == 0) {
#line 1638
      exit_code = 2;
    }
#line 1639
    if (! quiet) {
      {
#line 1639
      perror((char const   *)(ifname));
      }
    }
  }
#line 1641
  return;
}
}
#line 1648 "/home/kihong/gzip-1.2.4a/gzip.c"
static void treat_dir(char *dir ) 
{ 
  dir_type *dp ;
  DIR *dirp ;
  char nbuf[1024] ;
  int len ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 1656
  dirp = opendir((char const   *)dir);
  }
#line 1658
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
    {
#line 1659
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s unreadable\n",
            progname, dir);
#line 1660
    exit_code = 1;
    }
#line 1661
    return;
  }
  {
#line 1679
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1679
    dp = readdir(dirp);
    }
#line 1679
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 1679
      goto while_break;
    }
    {
#line 1681
    tmp = strcmp((char const   *)(dp->d_name), ".");
    }
#line 1681
    if (tmp == 0) {
#line 1682
      goto while_continue;
    } else {
      {
#line 1681
      tmp___0 = strcmp((char const   *)(dp->d_name), "..");
      }
#line 1681
      if (tmp___0 == 0) {
#line 1682
        goto while_continue;
      }
    }
    {
#line 1684
    tmp___1 = strlen((char const   *)dir);
#line 1684
    len = (int )tmp___1;
#line 1685
    tmp___3 = strlen((char const   *)(dp->d_name));
    }
#line 1685
    if ((len + (int )tmp___3) + 1 < 1023) {
      {
#line 1686
      strcpy((char */* __restrict  */)(nbuf), (char const   */* __restrict  */)dir);
      }
#line 1687
      if (len != 0) {
#line 1695
        tmp___2 = len;
#line 1695
        len ++;
#line 1695
        nbuf[tmp___2] = (char )'/';
      }
      {
#line 1697
      strcpy((char */* __restrict  */)(nbuf + len), (char const   */* __restrict  */)(dp->d_name));
#line 1698
      treat_file(nbuf);
      }
    } else {
      {
#line 1700
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s/%s: pathname too long\n",
              progname, dir, dp->d_name);
#line 1702
      exit_code = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1705
  closedir(dirp);
  }
#line 1706
  return;
}
}
#line 1715 "/home/kihong/gzip-1.2.4a/gzip.c"
static int in_exit  =    0;
#line 1712 "/home/kihong/gzip-1.2.4a/gzip.c"
static void do_exit(int exitcode ) 
{ 


  {
#line 1717
  if (in_exit) {
    {
#line 1717
    exit(exitcode);
    }
  }
#line 1718
  in_exit = 1;
#line 1719
  if ((unsigned long )env != (unsigned long )((void *)0)) {
    {
#line 1719
    free((void *)env);
#line 1719
    env = (char *)((void *)0);
    }
  }
#line 1720
  if ((unsigned long )args != (unsigned long )((void *)0)) {
    {
#line 1720
    free((void *)((char *)args));
#line 1720
    args = (char **)((void *)0);
    }
  }
  {
#line 1731
  exit(exitcode);
  }
}
}
#line 1737 "/home/kihong/gzip-1.2.4a/gzip.c"
void abort_gzip(void) 
{ 


  {
#line 1739
  if (remove_ofname) {
    {
#line 1740
    close(ofd);
#line 1741
    unlink((char const   *)(ofname));
    }
  }
  {
#line 1743
  do_exit(1);
  }
#line 1744
  return;
}
}

/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/mman.h"
typedef __mode_t mode_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 29 "/usr/include/x86_64-linux-gnu/sys/mman.h"
typedef __off_t off_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 89 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
typedef double rrd_value_t;
#line 94 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
struct rrd_file_t {
   size_t header_len ;
   size_t file_len ;
   size_t pos ;
   void *pvt ;
};
#line 94 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
typedef struct rrd_file_t rrd_file_t;
#line 112 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
struct rrd_blob_t {
   unsigned long size ;
   unsigned char *ptr ;
};
#line 112 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
typedef struct rrd_blob_t rrd_blob_t;
#line 117
enum rrd_info_type {
    RD_I_VAL = 0,
    RD_I_CNT = 1,
    RD_I_STR = 2,
    RD_I_INT = 3,
    RD_I_BLO = 4
} ;
#line 117 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
typedef enum rrd_info_type rrd_info_type_t;
#line 124 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
union rrd_infoval {
   unsigned long u_cnt ;
   rrd_value_t u_val ;
   char *u_str ;
   int u_int ;
   rrd_blob_t u_blo ;
};
#line 124 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
typedef union rrd_infoval rrd_infoval_t;
#line 132 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
struct rrd_info_t {
   char *key ;
   rrd_info_type_t type ;
   rrd_infoval_t value ;
   struct rrd_info_t *next ;
};
#line 132 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
typedef struct rrd_info_t rrd_info_t;
#line 272
enum __anonenum_rrd_timetype_t_72 {
    ABSOLUTE_TIME = 0,
    RELATIVE_TO_START_TIME = 1,
    RELATIVE_TO_END_TIME = 2,
    RELATIVE_TO_EPOCH = 3
} ;
#line 272 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
typedef enum __anonenum_rrd_timetype_t_72 rrd_timetype_t;
#line 281 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
struct rrd_time_value {
   rrd_timetype_t type ;
   long offset ;
   struct tm tm ;
};
#line 281 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
typedef struct rrd_time_value rrd_time_value_t;
#line 40 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
union unival {
   unsigned long u_cnt ;
   rrd_value_t u_val ;
};
#line 40 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
typedef union unival unival;
#line 113 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
struct stat_head_t {
   char cookie[4] ;
   char version[5] ;
   double float_cookie ;
   unsigned long ds_cnt ;
   unsigned long rra_cnt ;
   unsigned long pdp_step ;
   unival par[10] ;
};
#line 113 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
typedef struct stat_head_t stat_head_t;
#line 137
enum dst_en {
    DST_COUNTER = 0,
    DST_ABSOLUTE = 1,
    DST_GAUGE = 2,
    DST_DERIVE = 3,
    DST_CDEF = 4
} ;
#line 165 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
struct ds_def_t {
   char ds_nam[20] ;
   char dst[20] ;
   unival par[10] ;
};
#line 165 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
typedef struct ds_def_t ds_def_t;
#line 174
enum cf_en {
    CF_AVERAGE = 0,
    CF_MINIMUM = 1,
    CF_MAXIMUM = 2,
    CF_LAST = 3,
    CF_HWPREDICT = 4,
    CF_SEASONAL = 5,
    CF_DEVPREDICT = 6,
    CF_DEVSEASONAL = 7,
    CF_FAILURES = 8,
    CF_MHWPREDICT = 9
} ;
#line 259 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
struct rra_def_t {
   char cf_nam[20] ;
   unsigned long row_cnt ;
   unsigned long pdp_cnt ;
   unival par[10] ;
};
#line 259 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
typedef struct rra_def_t rra_def_t;
#line 281 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
struct live_head_t {
   time_t last_up ;
   long last_up_usec ;
};
#line 281 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
typedef struct live_head_t live_head_t;
#line 300 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
struct pdp_prep_t {
   char last_ds[30] ;
   unival scratch[10] ;
};
#line 300 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
typedef struct pdp_prep_t pdp_prep_t;
#line 373 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
struct cdp_prep_t {
   unival scratch[10] ;
};
#line 373 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
typedef struct cdp_prep_t cdp_prep_t;
#line 384 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
struct rra_ptr_t {
   unsigned long cur_row ;
};
#line 384 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
typedef struct rra_ptr_t rra_ptr_t;
#line 394 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
struct rrd_t {
   stat_head_t *stat_head ;
   ds_def_t *ds_def ;
   rra_def_t *rra_def ;
   live_head_t *live_head ;
   time_t *legacy_last_up ;
   pdp_prep_t *pdp_prep ;
   cdp_prep_t *cdp_prep ;
   rra_ptr_t *rra_ptr ;
   rrd_value_t *rrd_value ;
};
#line 394 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
typedef struct rrd_t rrd_t;
#line 81 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 13 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.h"
enum op_en {
    OP_NUMBER = 0,
    OP_VARIABLE = 1,
    OP_INF = 2,
    OP_PREV = 3,
    OP_NEGINF = 4,
    OP_UNKN = 5,
    OP_NOW = 6,
    OP_TIME = 7,
    OP_ADD = 8,
    OP_MOD = 9,
    OP_SUB = 10,
    OP_MUL = 11,
    OP_DIV = 12,
    OP_SIN = 13,
    OP_DUP = 14,
    OP_EXC = 15,
    OP_POP = 16,
    OP_COS = 17,
    OP_LOG = 18,
    OP_EXP = 19,
    OP_LT = 20,
    OP_LE = 21,
    OP_GT = 22,
    OP_GE = 23,
    OP_EQ = 24,
    OP_IF = 25,
    OP_MIN = 26,
    OP_MAX = 27,
    OP_LIMIT = 28,
    OP_FLOOR = 29,
    OP_CEIL = 30,
    OP_UN = 31,
    OP_END = 32,
    OP_LTIME = 33,
    OP_NE = 34,
    OP_ISINF = 35,
    OP_PREV_OTHER = 36,
    OP_COUNT = 37,
    OP_ATAN = 38,
    OP_SQRT = 39,
    OP_SORT = 40,
    OP_REV = 41,
    OP_TREND = 42,
    OP_TRENDNAN = 43,
    OP_ATAN2 = 44,
    OP_RAD2DEG = 45,
    OP_DEG2RAD = 46,
    OP_PREDICT = 47,
    OP_PREDICTSIGMA = 48,
    OP_AVG = 49,
    OP_ABS = 50,
    OP_ADDNAN = 51
} ;
#line 25 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.h"
struct rpnp_t {
   enum op_en op ;
   double val ;
   long ptr ;
   double *data ;
   long ds_cnt ;
   long step ;
};
#line 25 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.h"
typedef struct rpnp_t rpnp_t;
#line 35 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.h"
struct rpn_cdefds_t {
   char op ;
   short val ;
};
#line 35 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.h"
typedef struct rpn_cdefds_t rpn_cdefds_t;
#line 46 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.h"
struct rpnstack_t {
   double *s ;
   long dc_stacksize ;
   long dc_stackblock ;
};
#line 46 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.h"
typedef struct rpnstack_t rpnstack_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 141 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
struct SpecialToken {
   char *name ;
   int value ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
struct rrd_simple_file_t {
   int fd ;
   char *file_start ;
   int mm_prot ;
   int mm_flags ;
};
#line 102 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
typedef struct rrd_simple_file_t rrd_simple_file_t;
#line 292 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
struct rrd_context {
   char lib_errstr[256] ;
   char rrd_error[4096] ;
};
#line 292 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
typedef struct rrd_context rrd_context_t;
#line 84 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.h"
struct hw_functions_t {
   rrd_value_t (*predict)(rrd_value_t intercept , rrd_value_t slope , int null_count ,
                          rrd_value_t seasonal_coef ) ;
   rrd_value_t (*intercept)(rrd_value_t alpha , rrd_value_t observed , rrd_value_t seasonal_coef ,
                            unival *coefs ) ;
   rrd_value_t (*slope)(rrd_value_t beta , unival *coefs ) ;
   rrd_value_t (*seasonality)(rrd_value_t hw_gamma , rrd_value_t observed , rrd_value_t intercept ,
                              rrd_value_t seasonal_coef ) ;
   rrd_value_t (*init_seasonality)(rrd_value_t seasonal_coef , rrd_value_t intercept ) ;
   rrd_value_t (*seasonal_deviation)(rrd_value_t hw_gamma , rrd_value_t prediction ,
                                     rrd_value_t observed , rrd_value_t last ) ;
   rrd_value_t (*init_seasonal_deviation)(rrd_value_t prediction , rrd_value_t observed ) ;
   rrd_value_t identity ;
};
#line 84 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.h"
typedef struct hw_functions_t hw_functions_t;
#line 49 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.h"
struct FIFOqueue {
   rrd_value_t *queue ;
   int capacity ;
   int head ;
   int tail ;
};
#line 49 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.h"
typedef struct FIFOqueue FIFOqueue;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_4 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_4 pthread_mutex_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 82 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.h"
union __anonunion_value_73 {
   uint64_t counter ;
   double gauge ;
};
#line 82 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.h"
struct rrdc_stats_s {
   char const   *name ;
   uint16_t type ;
   uint16_t flags ;
   union __anonunion_value_73 value ;
   struct rrdc_stats_s *next ;
};
#line 96 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.h"
typedef struct rrdc_stats_s rrdc_stats_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 49 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
struct rrdc_response_s {
   int status ;
   char *message ;
   char **lines ;
   size_t lines_num ;
};
#line 56 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
typedef struct rrdc_response_s rrdc_response_t;
#line 78 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/fnv.h"
typedef unsigned long Fnv32_t;
#line 368 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned char Byte;
#line 370 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned int uInt;
#line 371 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef Byte Bytef;
#line 386 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef void *voidpf;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 83 "/usr/include/zlib.h"
struct internal_state;
#line 85 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 85 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 1742 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 1247 "/usr/include/libpng12/pngconf.h"
typedef unsigned long png_uint_32;
#line 1248 "/usr/include/libpng12/pngconf.h"
typedef long png_int_32;
#line 1249 "/usr/include/libpng12/pngconf.h"
typedef unsigned short png_uint_16;
#line 1251 "/usr/include/libpng12/pngconf.h"
typedef unsigned char png_byte;
#line 1259 "/usr/include/libpng12/pngconf.h"
typedef size_t png_size_t;
#line 1324 "/usr/include/libpng12/pngconf.h"
typedef png_int_32 png_fixed_point;
#line 1327 "/usr/include/libpng12/pngconf.h"
typedef void *png_voidp;
#line 1328 "/usr/include/libpng12/pngconf.h"
typedef png_byte *png_bytep;
#line 1331 "/usr/include/libpng12/pngconf.h"
typedef png_uint_16 *png_uint_16p;
#line 1333 "/usr/include/libpng12/pngconf.h"
typedef char const   *png_const_charp;
#line 1334 "/usr/include/libpng12/pngconf.h"
typedef char *png_charp;
#line 1341 "/usr/include/libpng12/pngconf.h"
typedef FILE *png_FILE_p;
#line 1350 "/usr/include/libpng12/pngconf.h"
typedef png_byte **png_bytepp;
#line 1353 "/usr/include/libpng12/pngconf.h"
typedef png_uint_16 **png_uint_16pp;
#line 1356 "/usr/include/libpng12/pngconf.h"
typedef char **png_charpp;
#line 650 "/usr/include/libpng12/png.h"
struct png_color_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
};
#line 650 "/usr/include/libpng12/png.h"
typedef struct png_color_struct png_color;
#line 656 "/usr/include/libpng12/png.h"
typedef png_color *png_colorp;
#line 659 "/usr/include/libpng12/png.h"
struct png_color_16_struct {
   png_byte index ;
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 gray ;
};
#line 659 "/usr/include/libpng12/png.h"
typedef struct png_color_16_struct png_color_16;
#line 670 "/usr/include/libpng12/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 670 "/usr/include/libpng12/png.h"
typedef struct png_color_8_struct png_color_8;
#line 685 "/usr/include/libpng12/png.h"
struct png_sPLT_entry_struct {
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 alpha ;
   png_uint_16 frequency ;
};
#line 685 "/usr/include/libpng12/png.h"
typedef struct png_sPLT_entry_struct png_sPLT_entry;
#line 693 "/usr/include/libpng12/png.h"
typedef png_sPLT_entry *png_sPLT_entryp;
#line 701 "/usr/include/libpng12/png.h"
struct png_sPLT_struct {
   png_charp name ;
   png_byte depth ;
   png_sPLT_entryp entries ;
   png_int_32 nentries ;
};
#line 701 "/usr/include/libpng12/png.h"
typedef struct png_sPLT_struct png_sPLT_t;
#line 708 "/usr/include/libpng12/png.h"
typedef png_sPLT_t *png_sPLT_tp;
#line 720 "/usr/include/libpng12/png.h"
struct png_text_struct {
   int compression ;
   png_charp key ;
   png_charp text ;
   png_size_t text_length ;
};
#line 720 "/usr/include/libpng12/png.h"
typedef struct png_text_struct png_text;
#line 739 "/usr/include/libpng12/png.h"
typedef png_text *png_textp;
#line 760 "/usr/include/libpng12/png.h"
struct png_time_struct {
   png_uint_16 year ;
   png_byte month ;
   png_byte day ;
   png_byte hour ;
   png_byte minute ;
   png_byte second ;
};
#line 760 "/usr/include/libpng12/png.h"
typedef struct png_time_struct png_time;
#line 780 "/usr/include/libpng12/png.h"
struct png_unknown_chunk_t {
   png_byte name[5] ;
   png_byte *data ;
   png_size_t size ;
   png_byte location ;
};
#line 780 "/usr/include/libpng12/png.h"
typedef struct png_unknown_chunk_t png_unknown_chunk;
#line 790 "/usr/include/libpng12/png.h"
typedef png_unknown_chunk *png_unknown_chunkp;
#line 833 "/usr/include/libpng12/png.h"
struct png_info_struct {
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 valid ;
   png_uint_32 rowbytes ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   png_uint_16 num_trans ;
   png_byte bit_depth ;
   png_byte color_type ;
   png_byte compression_type ;
   png_byte filter_type ;
   png_byte interlace_type ;
   png_byte channels ;
   png_byte pixel_depth ;
   png_byte spare_byte ;
   png_byte signature[8] ;
   float gamma ;
   png_byte srgb_intent ;
   int num_text ;
   int max_text ;
   png_textp text ;
   png_time mod_time ;
   png_color_8 sig_bit ;
   png_bytep trans ;
   png_color_16 trans_values ;
   png_color_16 background ;
   png_int_32 x_offset ;
   png_int_32 y_offset ;
   png_byte offset_unit_type ;
   png_uint_32 x_pixels_per_unit ;
   png_uint_32 y_pixels_per_unit ;
   png_byte phys_unit_type ;
   png_uint_16p hist ;
   float x_white ;
   float y_white ;
   float x_red ;
   float y_red ;
   float x_green ;
   float y_green ;
   float x_blue ;
   float y_blue ;
   png_charp pcal_purpose ;
   png_int_32 pcal_X0 ;
   png_int_32 pcal_X1 ;
   png_charp pcal_units ;
   png_charpp pcal_params ;
   png_byte pcal_type ;
   png_byte pcal_nparams ;
   png_uint_32 free_me ;
   png_unknown_chunkp unknown_chunks ;
   png_size_t unknown_chunks_num ;
   png_charp iccp_name ;
   png_charp iccp_profile ;
   png_uint_32 iccp_proflen ;
   png_byte iccp_compression ;
   png_sPLT_tp splt_palettes ;
   png_uint_32 splt_palettes_num ;
   png_byte scal_unit ;
   double scal_pixel_width ;
   double scal_pixel_height ;
   png_charp scal_s_width ;
   png_charp scal_s_height ;
   png_bytepp row_pointers ;
   png_fixed_point int_gamma ;
   png_fixed_point int_x_white ;
   png_fixed_point int_y_white ;
   png_fixed_point int_x_red ;
   png_fixed_point int_y_red ;
   png_fixed_point int_x_green ;
   png_fixed_point int_y_green ;
   png_fixed_point int_x_blue ;
   png_fixed_point int_y_blue ;
};
#line 833 "/usr/include/libpng12/png.h"
typedef struct png_info_struct png_info;
#line 1072 "/usr/include/libpng12/png.h"
typedef png_info *png_infop;
#line 1073 "/usr/include/libpng12/png.h"
typedef png_info **png_infopp;
#line 1176 "/usr/include/libpng12/png.h"
struct png_row_info_struct {
   png_uint_32 width ;
   png_uint_32 rowbytes ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte channels ;
   png_byte pixel_depth ;
};
#line 1176 "/usr/include/libpng12/png.h"
typedef struct png_row_info_struct png_row_info;
#line 1186 "/usr/include/libpng12/png.h"
typedef png_row_info *png_row_infop;
#line 1195
struct png_struct_def;
#line 1195 "/usr/include/libpng12/png.h"
typedef struct png_struct_def png_struct;
#line 1196 "/usr/include/libpng12/png.h"
typedef png_struct *png_structp;
#line 1262 "/usr/include/libpng12/png.h"
struct png_struct_def {
   jmp_buf jmpbuf ;
   void (*error_fn)(png_structp  , png_const_charp  ) ;
   void (*warning_fn)(png_structp  , png_const_charp  ) ;
   png_voidp error_ptr ;
   void (*write_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
   void (*read_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
   png_voidp io_ptr ;
   void (*read_user_transform_fn)(png_structp  , png_row_infop  , png_bytep  ) ;
   void (*write_user_transform_fn)(png_structp  , png_row_infop  , png_bytep  ) ;
   png_voidp user_transform_ptr ;
   png_byte user_transform_depth ;
   png_byte user_transform_channels ;
   png_uint_32 mode ;
   png_uint_32 flags ;
   png_uint_32 transformations ;
   z_stream zstream ;
   png_bytep zbuf ;
   png_size_t zbuf_size ;
   int zlib_level ;
   int zlib_method ;
   int zlib_window_bits ;
   int zlib_mem_level ;
   int zlib_strategy ;
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 num_rows ;
   png_uint_32 usr_width ;
   png_uint_32 rowbytes ;
   png_uint_32 user_chunk_cache_max ;
   png_uint_32 iwidth ;
   png_uint_32 row_number ;
   png_bytep prev_row ;
   png_bytep row_buf ;
   png_bytep sub_row ;
   png_bytep up_row ;
   png_bytep avg_row ;
   png_bytep paeth_row ;
   png_row_info row_info ;
   png_uint_32 idat_size ;
   png_uint_32 crc ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   png_uint_16 num_trans ;
   png_byte chunk_name[5] ;
   png_byte compression ;
   png_byte filter ;
   png_byte interlaced ;
   png_byte pass ;
   png_byte do_filter ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte usr_bit_depth ;
   png_byte pixel_depth ;
   png_byte channels ;
   png_byte usr_channels ;
   png_byte sig_bytes ;
   png_uint_16 filler ;
   png_byte background_gamma_type ;
   float background_gamma ;
   png_color_16 background ;
   png_color_16 background_1 ;
   void (*output_flush_fn)(png_structp  ) ;
   png_uint_32 flush_dist ;
   png_uint_32 flush_rows ;
   int gamma_shift ;
   float gamma ;
   float screen_gamma ;
   png_bytep gamma_table ;
   png_bytep gamma_from_1 ;
   png_bytep gamma_to_1 ;
   png_uint_16pp gamma_16_table ;
   png_uint_16pp gamma_16_from_1 ;
   png_uint_16pp gamma_16_to_1 ;
   png_color_8 sig_bit ;
   png_color_8 shift ;
   png_bytep trans ;
   png_color_16 trans_values ;
   void (*read_row_fn)(png_structp  , png_uint_32  , int  ) ;
   void (*write_row_fn)(png_structp  , png_uint_32  , int  ) ;
   void (*info_fn)(png_structp  , png_infop  ) ;
   void (*row_fn)(png_structp  , png_bytep  , png_uint_32  , int  ) ;
   void (*end_fn)(png_structp  , png_infop  ) ;
   png_bytep save_buffer_ptr ;
   png_bytep save_buffer ;
   png_bytep current_buffer_ptr ;
   png_bytep current_buffer ;
   png_uint_32 push_length ;
   png_uint_32 skip_length ;
   png_size_t save_buffer_size ;
   png_size_t save_buffer_max ;
   png_size_t buffer_size ;
   png_size_t current_buffer_size ;
   int process_mode ;
   int cur_palette ;
   png_size_t current_text_size ;
   png_size_t current_text_left ;
   png_charp current_text ;
   png_charp current_text_ptr ;
   png_bytep palette_lookup ;
   png_bytep dither_index ;
   png_uint_16p hist ;
   png_byte heuristic_method ;
   png_byte num_prev_filters ;
   png_bytep prev_filters ;
   png_uint_16p filter_weights ;
   png_uint_16p inv_filter_weights ;
   png_uint_16p filter_costs ;
   png_uint_16p inv_filter_costs ;
   png_charp time_buffer ;
   png_uint_32 free_me ;
   png_voidp user_chunk_ptr ;
   int (*read_user_chunk_fn)(png_structp  , png_unknown_chunkp  ) ;
   int num_chunk_list ;
   png_bytep chunk_list ;
   png_byte rgb_to_gray_status ;
   png_uint_16 rgb_to_gray_red_coeff ;
   png_uint_16 rgb_to_gray_green_coeff ;
   png_uint_16 rgb_to_gray_blue_coeff ;
   png_uint_32 mng_features_permitted ;
   png_fixed_point int_gamma ;
   png_byte filter_type ;
   png_byte mmx_bitdepth_threshold ;
   png_uint_32 mmx_rowbytes_threshold ;
   png_uint_32 asm_flags ;
   png_voidp mem_ptr ;
   png_voidp (*malloc_fn)(png_structp  , png_size_t  ) ;
   void (*free_fn)(png_structp  , png_voidp  ) ;
   png_bytep big_row_buf ;
   png_bytep dither_sort ;
   png_bytep index_to_palette ;
   png_bytep palette_to_index ;
   png_byte compression_type ;
   png_uint_32 user_width_max ;
   png_uint_32 user_height_max ;
   png_unknown_chunk unknown_chunk ;
   png_uint_32 old_big_row_buf_size ;
   png_uint_32 old_prev_row_size ;
   png_charp chunkdata ;
};
#line 1578 "/usr/include/libpng12/png.h"
typedef png_struct **png_structpp;
#line 124 "/usr/include/cairo/cairo.h"
struct _cairo;
#line 124 "/usr/include/cairo/cairo.h"
typedef struct _cairo cairo_t;
#line 153
struct _cairo_surface;
#line 153 "/usr/include/cairo/cairo.h"
typedef struct _cairo_surface cairo_surface_t;
#line 701
enum _cairo_antialias {
    CAIRO_ANTIALIAS_DEFAULT = 0,
    CAIRO_ANTIALIAS_NONE = 1,
    CAIRO_ANTIALIAS_GRAY = 2,
    CAIRO_ANTIALIAS_SUBPIXEL = 3,
    CAIRO_ANTIALIAS_FAST = 4,
    CAIRO_ANTIALIAS_GOOD = 5,
    CAIRO_ANTIALIAS_BEST = 6
} ;
#line 701 "/usr/include/cairo/cairo.h"
typedef enum _cairo_antialias cairo_antialias_t;
#line 1366
struct _cairo_font_options;
#line 1366 "/usr/include/cairo/cairo.h"
typedef struct _cairo_font_options cairo_font_options_t;
#line 45 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned int guint32;
#line 65 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gssize;
#line 66 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long gsize;
#line 46 "/usr/include/glib-2.0/glib/gtypes.h"
typedef char gchar;
#line 49 "/usr/include/glib-2.0/glib/gtypes.h"
typedef int gint;
#line 50 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint gboolean;
#line 77 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void *gpointer;
#line 36 "/usr/include/glib-2.0/glib/gquark.h"
typedef guint32 GQuark;
#line 42 "/usr/include/glib-2.0/glib/gerror.h"
struct _GError;
#line 42 "/usr/include/glib-2.0/glib/gerror.h"
typedef struct _GError GError;
#line 44 "/usr/include/glib-2.0/glib/gerror.h"
struct _GError {
   GQuark domain ;
   gint code ;
   gchar *message ;
};
#line 37 "/usr/include/glib-2.0/glib/ghash.h"
struct _GHashTable;
#line 37 "/usr/include/glib-2.0/glib/ghash.h"
typedef struct _GHashTable GHashTable;
#line 38 "/usr/include/pango-1.0/pango/pango-types.h"
struct _PangoRectangle;
#line 38 "/usr/include/pango-1.0/pango/pango-types.h"
typedef struct _PangoRectangle PangoRectangle;
#line 134 "/usr/include/pango-1.0/pango/pango-types.h"
struct _PangoRectangle {
   int x ;
   int y ;
   int width ;
   int height ;
};
#line 40 "/usr/include/pango-1.0/pango/pango-font.h"
struct _PangoFontDescription;
#line 40 "/usr/include/pango-1.0/pango/pango-font.h"
typedef struct _PangoFontDescription PangoFontDescription;
#line 29 "/usr/include/pango-1.0/pango/pango-tabs.h"
struct _PangoTabArray;
#line 29 "/usr/include/pango-1.0/pango/pango-tabs.h"
typedef struct _PangoTabArray PangoTabArray;
#line 37
enum __anonenum_PangoTabAlign_176 {
    PANGO_TAB_LEFT = 0
} ;
#line 37 "/usr/include/pango-1.0/pango/pango-tabs.h"
typedef enum __anonenum_PangoTabAlign_176 PangoTabAlign;
#line 32 "/usr/include/pango-1.0/pango/pango-layout.h"
struct _PangoLayout;
#line 32 "/usr/include/pango-1.0/pango/pango-layout.h"
typedef struct _PangoLayout PangoLayout;
#line 51 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
enum tmt_en {
    TMT_SECOND = 0,
    TMT_MINUTE = 1,
    TMT_HOUR = 2,
    TMT_DAY = 3,
    TMT_WEEK = 4,
    TMT_MONTH = 5,
    TMT_YEAR = 6
} ;
#line 62
enum gf_en {
    GF_PRINT = 0,
    GF_GPRINT = 1,
    GF_COMMENT = 2,
    GF_HRULE = 3,
    GF_VRULE = 4,
    GF_LINE = 5,
    GF_AREA = 6,
    GF_STACK = 7,
    GF_TICK = 8,
    GF_TEXTALIGN = 9,
    GF_DEF = 10,
    GF_CDEF = 11,
    GF_VDEF = 12,
    GF_SHIFT = 13,
    GF_XPORT = 14
} ;
#line 68
enum txa_en {
    TXA_LEFT = 0,
    TXA_RIGHT = 1,
    TXA_CENTER = 2,
    TXA_JUSTIFIED = 3
} ;
#line 70
enum vdef_op_en {
    VDEF_MAXIMUM = 0,
    VDEF_MINIMUM = 1,
    VDEF_AVERAGE = 2,
    VDEF_STDEV = 3,
    VDEF_PERCENT = 4,
    VDEF_TOTAL = 5,
    VDEF_FIRST = 6,
    VDEF_LAST = 7,
    VDEF_LSLSLOPE = 8,
    VDEF_LSLINT = 9,
    VDEF_LSLCORREL = 10,
    VDEF_PERCENTNAN = 11
} ;
#line 94
enum legend_pos {
    NORTH = 0,
    WEST = 1,
    SOUTH = 2,
    EAST = 3
} ;
#line 95
enum legend_direction {
    TOP_DOWN = 0,
    BOTTOM_UP = 1
} ;
#line 97
enum gfx_if_en {
    IF_PNG = 0,
    IF_SVG = 1,
    IF_EPS = 2,
    IF_PDF = 3
} ;
#line 99
enum gfx_h_align_en {
    GFX_H_NULL = 0,
    GFX_H_LEFT = 1,
    GFX_H_RIGHT = 2,
    GFX_H_CENTER = 3
} ;
#line 100
enum gfx_v_align_en {
    GFX_V_NULL = 0,
    GFX_V_TOP = 1,
    GFX_V_BOTTOM = 2,
    GFX_V_CENTER = 3
} ;
#line 103 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
struct gfx_color_t {
   double red ;
   double green ;
   double blue ;
   double alpha ;
};
#line 103 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
typedef struct gfx_color_t gfx_color_t;
#line 111 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
struct text_prop_t {
   double size ;
   char font[1024] ;
   PangoFontDescription *font_desc ;
};
#line 111 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
typedef struct text_prop_t text_prop_t;
#line 118 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
struct vdef_t {
   enum vdef_op_en op ;
   double param ;
   double val ;
   time_t when ;
};
#line 118 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
typedef struct vdef_t vdef_t;
#line 125 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
struct xlab_t {
   long minsec ;
   long length ;
   enum tmt_en gridtm ;
   long gridst ;
   enum tmt_en mgridtm ;
   long mgridst ;
   enum tmt_en labtm ;
   long labst ;
   long precis ;
   char *stst ;
};
#line 125 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
typedef struct xlab_t xlab_t;
#line 138 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
struct ygrid_scale_t {
   double gridstep ;
   int labfact ;
   char labfmt[64] ;
};
#line 138 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
typedef struct ygrid_scale_t ygrid_scale_t;
#line 160 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
struct graph_desc_t {
   enum gf_en gf ;
   int stack ;
   int debug ;
   int skipscale ;
   char vname[256] ;
   long vidx ;
   char rrd[1024] ;
   char ds_nam[20] ;
   long ds ;
   enum cf_en cf ;
   enum cf_en cf_reduce ;
   struct gfx_color_t col ;
   char format[205] ;
   char legend[205] ;
   int strftm ;
   double leg_x ;
   double leg_y ;
   double yrule ;
   time_t xrule ;
   vdef_t vf ;
   rpnp_t *rpnp ;
   int shidx ;
   time_t shval ;
   time_t shift ;
   time_t start ;
   time_t end ;
   time_t start_orig ;
   time_t end_orig ;
   unsigned long step ;
   unsigned long step_orig ;
   unsigned long ds_cnt ;
   long data_first ;
   char **ds_namv ;
   rrd_value_t *data ;
   rrd_value_t *p_data ;
   double linewidth ;
   int dash ;
   double *p_dashes ;
   int ndash ;
   double offset ;
   enum txa_en txtalign ;
};
#line 160 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
typedef struct graph_desc_t graph_desc_t;
#line 209 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
struct image_desc_t {
   char graphfile[4096] ;
   long xsize ;
   long ysize ;
   struct gfx_color_t graph_col[10] ;
   text_prop_t text_prop[6] ;
   char ylegend[210] ;
   char title[210] ;
   char watermark[110] ;
   int draw_x_grid ;
   int draw_y_grid ;
   unsigned int draw_3d_border ;
   unsigned int dynamic_labels ;
   double grid_dash_on ;
   double grid_dash_off ;
   xlab_t xlab_user ;
   char xlab_form[210] ;
   double second_axis_scale ;
   double second_axis_shift ;
   char second_axis_legend[210] ;
   char second_axis_format[210] ;
   double ygridstep ;
   int ylabfact ;
   double tabwidth ;
   time_t start ;
   time_t end ;
   unsigned long step ;
   rrd_value_t minval ;
   rrd_value_t maxval ;
   int rigid ;
   ygrid_scale_t ygrid_scale ;
   int gridfit ;
   char *imginfo ;
   enum gfx_if_en imgformat ;
   char *daemon_addr ;
   int lazy ;
   int slopemode ;
   enum legend_pos legendposition ;
   enum legend_direction legenddirection ;
   int logarithmic ;
   double force_scale_min ;
   double force_scale_max ;
   int with_markup ;
   long xorigin ;
   long yorigin ;
   long xOriginTitle ;
   long yOriginTitle ;
   long xOriginLegendY ;
   long yOriginLegendY ;
   long xOriginLegendY2 ;
   long yOriginLegendY2 ;
   long xOriginLegend ;
   long yOriginLegend ;
   long ximg ;
   long yimg ;
   long legendwidth ;
   long legendheight ;
   size_t rendered_image_size ;
   double zoom ;
   double magfact ;
   long base ;
   char symbol ;
   float viewfactor ;
   int unitsexponent ;
   int unitslength ;
   int forceleftspace ;
   int extra_flags ;
   unsigned char *rendered_image ;
   long prt_c ;
   long gdes_c ;
   graph_desc_t *gdes ;
   cairo_surface_t *surface ;
   cairo_t *cr ;
   cairo_font_options_t *font_options ;
   cairo_antialias_t graph_antialias ;
   PangoLayout *layout ;
   rrd_info_t *grinfo ;
   rrd_info_t *grinfo_current ;
   GHashTable *gdef_map ;
   GHashTable *rrd_map ;
};
#line 209 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
typedef struct image_desc_t image_desc_t;
#line 78 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void const   *gconstpointer;
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 310 "/usr/include/cairo/cairo.h"
enum _cairo_status {
    CAIRO_STATUS_SUCCESS = 0,
    CAIRO_STATUS_NO_MEMORY = 1,
    CAIRO_STATUS_INVALID_RESTORE = 2,
    CAIRO_STATUS_INVALID_POP_GROUP = 3,
    CAIRO_STATUS_NO_CURRENT_POINT = 4,
    CAIRO_STATUS_INVALID_MATRIX = 5,
    CAIRO_STATUS_INVALID_STATUS = 6,
    CAIRO_STATUS_NULL_POINTER = 7,
    CAIRO_STATUS_INVALID_STRING = 8,
    CAIRO_STATUS_INVALID_PATH_DATA = 9,
    CAIRO_STATUS_READ_ERROR = 10,
    CAIRO_STATUS_WRITE_ERROR = 11,
    CAIRO_STATUS_SURFACE_FINISHED = 12,
    CAIRO_STATUS_SURFACE_TYPE_MISMATCH = 13,
    CAIRO_STATUS_PATTERN_TYPE_MISMATCH = 14,
    CAIRO_STATUS_INVALID_CONTENT = 15,
    CAIRO_STATUS_INVALID_FORMAT = 16,
    CAIRO_STATUS_INVALID_VISUAL = 17,
    CAIRO_STATUS_FILE_NOT_FOUND = 18,
    CAIRO_STATUS_INVALID_DASH = 19,
    CAIRO_STATUS_INVALID_DSC_COMMENT = 20,
    CAIRO_STATUS_INVALID_INDEX = 21,
    CAIRO_STATUS_CLIP_NOT_REPRESENTABLE = 22,
    CAIRO_STATUS_TEMP_FILE_ERROR = 23,
    CAIRO_STATUS_INVALID_STRIDE = 24,
    CAIRO_STATUS_FONT_TYPE_MISMATCH = 25,
    CAIRO_STATUS_USER_FONT_IMMUTABLE = 26,
    CAIRO_STATUS_USER_FONT_ERROR = 27,
    CAIRO_STATUS_NEGATIVE_COUNT = 28,
    CAIRO_STATUS_INVALID_CLUSTERS = 29,
    CAIRO_STATUS_INVALID_SLANT = 30,
    CAIRO_STATUS_INVALID_WEIGHT = 31,
    CAIRO_STATUS_INVALID_SIZE = 32,
    CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED = 33,
    CAIRO_STATUS_DEVICE_TYPE_MISMATCH = 34,
    CAIRO_STATUS_DEVICE_ERROR = 35,
    CAIRO_STATUS_INVALID_MESH_CONSTRUCTION = 36,
    CAIRO_STATUS_DEVICE_FINISHED = 37,
    CAIRO_STATUS_JBIG2_GLOBAL_MISSING = 38,
    CAIRO_STATUS_LAST_STATUS = 39
} ;
#line 310 "/usr/include/cairo/cairo.h"
typedef enum _cairo_status cairo_status_t;
#line 408
enum _cairo_format {
    CAIRO_FORMAT_INVALID = -1,
    CAIRO_FORMAT_ARGB32 = 0,
    CAIRO_FORMAT_RGB24 = 1,
    CAIRO_FORMAT_A8 = 2,
    CAIRO_FORMAT_A1 = 3,
    CAIRO_FORMAT_RGB16_565 = 4,
    CAIRO_FORMAT_RGB30 = 5
} ;
#line 408 "/usr/include/cairo/cairo.h"
typedef enum _cairo_format cairo_format_t;
#line 768
enum _cairo_line_cap {
    CAIRO_LINE_CAP_BUTT = 0,
    CAIRO_LINE_CAP_ROUND = 1,
    CAIRO_LINE_CAP_SQUARE = 2
} ;
#line 768 "/usr/include/cairo/cairo.h"
typedef enum _cairo_line_cap cairo_line_cap_t;
#line 792
enum _cairo_line_join {
    CAIRO_LINE_JOIN_MITER = 0,
    CAIRO_LINE_JOIN_ROUND = 1,
    CAIRO_LINE_JOIN_BEVEL = 2
} ;
#line 792 "/usr/include/cairo/cairo.h"
typedef enum _cairo_line_join cairo_line_join_t;
#line 1315
enum _cairo_hint_style {
    CAIRO_HINT_STYLE_DEFAULT = 0,
    CAIRO_HINT_STYLE_NONE = 1,
    CAIRO_HINT_STYLE_SLIGHT = 2,
    CAIRO_HINT_STYLE_MEDIUM = 3,
    CAIRO_HINT_STYLE_FULL = 4
} ;
#line 1315 "/usr/include/cairo/cairo.h"
typedef enum _cairo_hint_style cairo_hint_style_t;
#line 1338
enum _cairo_hint_metrics {
    CAIRO_HINT_METRICS_DEFAULT = 0,
    CAIRO_HINT_METRICS_OFF = 1,
    CAIRO_HINT_METRICS_ON = 2
} ;
#line 1338 "/usr/include/cairo/cairo.h"
typedef enum _cairo_hint_metrics cairo_hint_metrics_t;
#line 51 "/usr/include/cairo/cairo-svg.h"
enum _cairo_svg_version {
    CAIRO_SVG_VERSION_1_1 = 0,
    CAIRO_SVG_VERSION_1_2 = 1
} ;
#line 51 "/usr/include/cairo/cairo-svg.h"
typedef enum _cairo_svg_version cairo_svg_version_t;
#line 48 "/usr/include/glib-2.0/glib/gtypes.h"
typedef long glong;
#line 55 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned int guint;
#line 36 "/usr/include/pango-1.0/pango/pango-types.h"
struct _PangoFontMap;
#line 36 "/usr/include/pango-1.0/pango/pango-types.h"
typedef struct _PangoFontMap PangoFontMap;
#line 51 "/usr/include/pango-1.0/pango/pango-fontmap.h"
struct _PangoContext;
#line 51 "/usr/include/pango-1.0/pango/pango-fontmap.h"
typedef struct _PangoContext PangoContext;
#line 53 "/usr/include/pango-1.0/pango/pangocairo.h"
struct _PangoCairoFontMap;
#line 53 "/usr/include/pango-1.0/pango/pangocairo.h"
typedef struct _PangoCairoFontMap PangoCairoFontMap;
#line 55 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
enum grc_en {
    GRC_CANVAS = 0,
    GRC_BACK = 1,
    GRC_SHADEA = 2,
    GRC_SHADEB = 3,
    GRC_GRID = 4,
    GRC_MGRID = 5,
    GRC_FONT = 6,
    GRC_ARROW = 7,
    GRC_AXIS = 8,
    GRC_FRAME = 9,
    __GRC_END__ = 10
} ;
#line 84
enum text_prop_en {
    TEXT_PROP_DEFAULT = 0,
    TEXT_PROP_TITLE = 1,
    TEXT_PROP_AXIS = 2,
    TEXT_PROP_UNIT = 3,
    TEXT_PROP_LEGEND = 4,
    TEXT_PROP_WATERMARK = 5,
    TEXT_PROP_LAST = 6
} ;
#line 146 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
struct ylab_t {
   double grid ;
   int lfac[4] ;
};
#line 146 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
typedef struct ylab_t ylab_t;
#line 204 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.h"
enum rra_par_en {
    RRA_cdp_xff_val = 0,
    RRA_hw_alpha = 1,
    RRA_hw_beta = 2,
    RRA_dependent_rra_idx = 3,
    RRA_seasonal_gamma = 1,
    RRA_seasonal_smoothing_window = 2,
    RRA_seasonal_smooth_idx = 4,
    RRA_delta_pos = 1,
    RRA_delta_neg = 2,
    RRA_window_len = 4,
    RRA_failure_threshold = 5
} ;
#line 28 "/usr/include/libxml2/libxml/xmlstring.h"
typedef unsigned char xmlChar;
#line 99 "/usr/include/libxml2/libxml/xmlreader.h"
struct _xmlTextReader;
#line 99 "/usr/include/libxml2/libxml/xmlreader.h"
typedef struct _xmlTextReader xmlTextReader;
#line 106 "/usr/include/libxml2/libxml/xmlreader.h"
typedef xmlTextReader *xmlTextReaderPtr;
#line 158 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1,
    RUSAGE_THREAD = 1
} ;
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_42 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_43 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_44 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_45 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_46 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_47 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_48 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_49 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_50 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_51 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_52 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_53 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_54 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_55 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_42 __annonCompField2 ;
   union __anonunion____missing_field_name_43 __annonCompField3 ;
   union __anonunion____missing_field_name_44 __annonCompField4 ;
   union __anonunion____missing_field_name_45 __annonCompField5 ;
   union __anonunion____missing_field_name_46 __annonCompField6 ;
   union __anonunion____missing_field_name_47 __annonCompField7 ;
   union __anonunion____missing_field_name_48 __annonCompField8 ;
   union __anonunion____missing_field_name_49 __annonCompField9 ;
   union __anonunion____missing_field_name_50 __annonCompField10 ;
   union __anonunion____missing_field_name_51 __annonCompField11 ;
   union __anonunion____missing_field_name_52 __annonCompField12 ;
   union __anonunion____missing_field_name_53 __annonCompField13 ;
   union __anonunion____missing_field_name_54 __annonCompField14 ;
   union __anonunion____missing_field_name_55 __annonCompField15 ;
};
#line 39 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rusage_who __rusage_who_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 208 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 320
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 175 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 341 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
long rrd_random(void) ;
#line 343
int rrd_add_ptr(void ***dest , size_t *dest_size , void *src ) ;
#line 344
int rrd_add_strdup(char ***dest , size_t *dest_size , char *src ) ;
#line 345
void rrd_free_ptrs(void ***src , size_t *cnt ) ;
#line 347
int rrd_mkdir_p(char const   *pathname , mode_t mode ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 26 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dirname)(char *__path ) ;
#line 49 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_utils.c"
static int rand_init  =    0;
#line 47 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_utils.c"
long rrd_random(void) 
{ 
  time_t tmp ;
  __pid_t tmp___0 ;
  long tmp___1 ;

  {
#line 50
  if (! rand_init) {
    {
#line 51
    tmp = time((time_t *)((void *)0));
#line 51
    tmp___0 = getpid();
#line 51
    srandom((unsigned int )tmp + (unsigned int )tmp___0);
#line 52
    rand_init ++;
    }
  }
  {
#line 55
  tmp___1 = random();
  }
#line 55
  return (tmp___1);
}
}
#line 62 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_utils.c"
int rrd_add_ptr(void ***dest , size_t *dest_size , void *src ) 
{ 
  void **temp ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 66
  if (! ((unsigned long )dest != (unsigned long )((void *)0))) {
    {
#line 66
    __assert_fail("dest != ((void *)0)", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_utils.c",
                  66U, "rrd_add_ptr");
    }
  }
  {
#line 68
  tmp = realloc((void *)*dest, (*dest_size + 1UL) * sizeof(*dest));
#line 68
  temp = (void **)tmp;
  }
#line 69
  if (! temp) {
#line 70
    return (0);
  }
#line 72
  *dest = temp;
#line 73
  *(temp + *dest_size) = src;
#line 74
  (*dest_size) ++;
#line 76
  return (1);
}
}
#line 80 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_utils.c"
int rrd_add_strdup(char ***dest , size_t *dest_size , char *src ) 
{ 
  char *dup_src ;
  int add_ok ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 85
  if (! ((unsigned long )dest != (unsigned long )((void *)0))) {
    {
#line 85
    __assert_fail("dest != ((void *)0)", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_utils.c",
                  85U, "rrd_add_strdup");
    }
  }
#line 86
  if (! ((unsigned long )src != (unsigned long )((void *)0))) {
    {
#line 86
    __assert_fail("src != ((void *)0)", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_utils.c",
                  86U, "rrd_add_strdup");
    }
  }
  {
#line 88
  dup_src = strdup((char const   *)src);
  }
#line 89
  if (! dup_src) {
#line 90
    return (0);
  }
  {
#line 92
  add_ok = rrd_add_ptr((void ***)dest, dest_size, (void *)dup_src);
  }
#line 93
  if (! add_ok) {
    {
#line 94
    free((void *)dup_src);
    }
  }
#line 96
  return (add_ok);
}
}
#line 99 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_utils.c"
void rrd_free_ptrs(void ***src , size_t *cnt ) 
{ 
  void **sp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 103
  if (! ((unsigned long )src != (unsigned long )((void *)0))) {
    {
#line 103
    __assert_fail("src != ((void *)0)", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_utils.c",
                  103U, "rrd_free_ptrs");
    }
  }
#line 104
  sp = *src;
#line 106
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 107
    return;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (*cnt > 0UL)) {
#line 109
      goto while_break;
    }
    {
#line 110
    (*cnt) --;
#line 111
    free(*(sp + *cnt));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  free((void *)sp);
#line 115
  *src = (void **)((void *)0);
  }
#line 116
  return;
}
}
#line 120 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_utils.c"
int rrd_mkdir_p(char const   *pathname , mode_t mode ) 
{ 
  struct stat sb ;
  char *pathname_copy ;
  char *base_dir ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int orig_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 127
  if ((unsigned long )((void *)0) == (unsigned long )pathname) {
    {
#line 128
    tmp = __errno_location();
#line 128
    *tmp = 22;
    }
#line 129
    return (-1);
  } else
#line 127
  if (0 == (int )*pathname) {
    {
#line 128
    tmp = __errno_location();
#line 128
    *tmp = 22;
    }
#line 129
    return (-1);
  }
  {
#line 132
  tmp___1 = stat((char const   */* __restrict  */)pathname, (struct stat */* __restrict  */)(& sb));
  }
#line 132
  if (0 == tmp___1) {
#line 133
    if (! ((sb.st_mode & 61440U) == 16384U)) {
      {
#line 134
      tmp___0 = __errno_location();
#line 134
      *tmp___0 = 20;
      }
#line 135
      return (-1);
    }
#line 137
    return (0);
  }
  {
#line 141
  tmp___2 = __errno_location();
  }
#line 141
  if (2 != *tmp___2) {
#line 142
    return (-1);
  }
  {
#line 145
  pathname_copy = strdup(pathname);
  }
#line 145
  if ((unsigned long )((void *)0) == (unsigned long )pathname_copy) {
#line 146
    return (-1);
  }
  {
#line 150
  tmp___3 = dirname(pathname_copy);
#line 150
  base_dir = strdup((char const   *)tmp___3);
  }
#line 150
  if ((unsigned long )((void *)0) == (unsigned long )base_dir) {
    {
#line 151
    free((void *)pathname_copy);
    }
#line 152
    return (-1);
  }
  {
#line 158
  tmp___6 = rrd_mkdir_p((char const   *)base_dir, mode);
  }
#line 158
  if (0 != tmp___6) {
    {
#line 159
    tmp___4 = __errno_location();
#line 159
    orig_errno = *tmp___4;
#line 160
    free((void *)pathname_copy);
#line 162
    free((void *)base_dir);
#line 164
    tmp___5 = __errno_location();
#line 164
    *tmp___5 = orig_errno;
    }
#line 165
    return (-1);
  }
  {
#line 168
  free((void *)pathname_copy);
#line 170
  free((void *)base_dir);
#line 178
  tmp___7 = mkdir(pathname, mode);
  }
#line 178
  if (0 != tmp___7) {
#line 179
    return (-1);
  }
#line 181
  return (0);
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 235
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 398
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 230
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnan)(double __value )  __attribute__((__const__)) ;
#line 230
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnanf)(float __value )  __attribute__((__const__)) ;
#line 230
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnanl)(long double __value )  __attribute__((__const__)) ;
#line 82 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
double rrd_set_to_DNAN(void) ;
#line 84
double rrd_set_to_DINF(void) ;
#line 151
rrd_info_t *rrd_info_push(rrd_info_t *info , char *key , rrd_info_type_t type , rrd_infoval_t value ) ;
#line 160
int rrd_update(int argc , char **argv ) ;
#line 163
rrd_info_t *rrd_update_v(int argc , char **argv ) ;
#line 238
int rrd_update_r(char const   *filename , char const   *tmplt , int argc , char const   **argv ) ;
#line 287
char *rrd_parsetime(char const   *tspec , rrd_time_value_t *ptv ) ;
#line 312
void rrd_set_error(char *fmt  , ...) ;
#line 317
int rrd_test_error(void) ;
#line 319
char *rrd_get_error(void) ;
#line 325
char const   *rrd_strerror(int err ) ;
#line 374
void rrd_free(rrd_t *rrd ) ;
#line 377
void rrd_init(rrd_t *rrd ) ;
#line 381
rrd_file_t *rrd_open(char const   * const  file_name , rrd_t *rrd , unsigned int rdwr ) ;
#line 391
int rrd_close(rrd_file_t *rrd_file ) ;
#line 399
ssize_t rrd_write(rrd_file_t *rrd_file , void const   *buf , size_t count ) ;
#line 407
off_t rrd_seek(rrd_file_t *rrd_file , off_t off , int whence ) ;
#line 415
int rrd_lock(rrd_file_t *rrd_file ) ;
#line 418
void rrd_notify_row(rrd_file_t *rrd_file  __attribute__((__unused__)) , int rra_idx  __attribute__((__unused__)) ,
                    unsigned long rra_row  __attribute__((__unused__)) , time_t rra_time  __attribute__((__unused__)) ) ;
#line 113 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_getopt.h"
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 74 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.h"
char *sprintf_alloc(char *fmt  , ...) ;
#line 114
enum cf_en cf_conv(char const   *string ) ;
#line 116
enum dst_en dst_conv(char *string ) ;
#line 118
long ds_match(rrd_t *rrd , char *ds_nam ) ;
#line 123
double rrd_diff(char *a , char *b ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 8 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.h"
int update_aberrant_CF(rrd_t *rrd , rrd_value_t pdp_val , enum cf_en current_cf ,
                       unsigned long cdp_idx , unsigned long rra_idx , unsigned long ds_idx ,
                       unsigned short CDP_scratch_idx , rrd_value_t *seasonal_coef ) ;
#line 21
int lookup_seasonal(rrd_t *rrd , unsigned long rra_idx , unsigned long rra_start ,
                    rrd_file_t *rrd_file , unsigned long offset , rrd_value_t **seasonal_coef ) ;
#line 28
void erase_violations(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx ) ;
#line 32
int apply_smoother(rrd_t *rrd , unsigned long rra_idx , unsigned long rra_start ,
                   rrd_file_t *rrd_file ) ;
#line 52 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.h"
void rpnstack_init(rpnstack_t *rpnstack ) ;
#line 54
void rpnstack_free(rpnstack_t *rpnstack ) ;
#line 69
rpnp_t *rpn_expand(rpn_cdefds_t *rpnc ) ;
#line 80
short rpn_calc(rpnp_t *rpnp , rpnstack_t *rpnstack , long data_idx , rrd_value_t *output ,
               int output_idx ) ;
#line 64 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.h"
int rrdc_connect(char const   *addr ) ;
#line 65
int rrdc_is_connected(char const   *daemon_addr ) ;
#line 68
int rrdc_update(char const   *filename , int values_num , char const   * const  *values ) ;
#line 71 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
int _rrd_update(char const   *filename , char const   *tmplt , int argc , char const   **argv ,
                rrd_info_t *pcdp_summary ) ;
#line 78
static int allocate_data_structures(rrd_t *rrd , char ***updvals , rrd_value_t **pdp_temp ,
                                    char const   *tmplt , long **tmpl_idx , unsigned long *tmpl_cnt ,
                                    unsigned long **rra_step_cnt , unsigned long **skip_update ,
                                    rrd_value_t **pdp_new ) ;
#line 89
static int parse_template(rrd_t *rrd , char const   *tmplt , unsigned long *tmpl_cnt ,
                          long *tmpl_idx ) ;
#line 95
static int process_arg(char *step_start , rrd_t *rrd , rrd_file_t *rrd_file , unsigned long rra_begin ,
                       time_t *current_time , unsigned long *current_time_usec , rrd_value_t *pdp_temp ,
                       rrd_value_t *pdp_new , unsigned long *rra_step_cnt , char **updvals ,
                       long *tmpl_idx , unsigned long tmpl_cnt , rrd_info_t **pcdp_summary ,
                       int version , unsigned long *skip_update , int *schedule_smooth ) ;
#line 113
static int parse_ds(rrd_t *rrd , char **updvals , long *tmpl_idx , char *input , unsigned long tmpl_cnt ,
                    time_t *current_time , unsigned long *current_time_usec , int version ) ;
#line 123
static int get_time_from_reading(rrd_t *rrd , char timesyntax , char **updvals , time_t *current_time ,
                                 unsigned long *current_time_usec , int version ) ;
#line 131
static int update_pdp_prep(rrd_t *rrd , char **updvals , rrd_value_t *pdp_new , double interval ) ;
#line 137
static int calculate_elapsed_steps(rrd_t *rrd , unsigned long current_time , unsigned long current_time_usec ,
                                   double interval , double *pre_int , double *post_int ,
                                   unsigned long *proc_pdp_cnt ) ;
#line 146
static void simple_update(rrd_t *rrd , double interval , rrd_value_t *pdp_new ) ;
#line 151
static int process_all_pdp_st(rrd_t *rrd , double interval , double pre_int , double post_int ,
                              unsigned long elapsed_pdp_st , rrd_value_t *pdp_new ,
                              rrd_value_t *pdp_temp ) ;
#line 160
static int process_pdp_st(rrd_t *rrd , unsigned long ds_idx , double interval , double pre_int ,
                          double post_int , long diff_pdp_st , rrd_value_t *pdp_new ,
                          rrd_value_t *pdp_temp ) ;
#line 170
static int update_all_cdp_prep(rrd_t *rrd , unsigned long *rra_step_cnt , unsigned long rra_begin ,
                               rrd_file_t *rrd_file , unsigned long elapsed_pdp_st ,
                               unsigned long proc_pdp_cnt , rrd_value_t **last_seasonal_coef ,
                               rrd_value_t **seasonal_coef , rrd_value_t *pdp_temp ,
                               unsigned long *skip_update , int *schedule_smooth ) ;
#line 183
static int do_schedule_smooth(rrd_t *rrd , unsigned long rra_idx , unsigned long elapsed_pdp_st ) ;
#line 188
static int update_cdp_prep(rrd_t *rrd , unsigned long elapsed_pdp_st , unsigned long start_pdp_offset ,
                           unsigned long *rra_step_cnt , int rra_idx , rrd_value_t *pdp_temp ,
                           rrd_value_t *last_seasonal_coef , rrd_value_t *seasonal_coef ,
                           int current_cf ) ;
#line 199
static void update_cdp(unival *scratch , int current_cf , rrd_value_t pdp_temp_val ,
                       unsigned long rra_step_cnt , unsigned long elapsed_pdp_st ,
                       unsigned long start_pdp_offset , unsigned long pdp_cnt , rrd_value_t xff ,
                       int i , int ii ) ;
#line 211
static void initialize_cdp_val(unival *scratch , int current_cf , rrd_value_t pdp_temp_val ,
                               unsigned long start_pdp_offset , unsigned long pdp_cnt ) ;
#line 218
static void reset_cdp(rrd_t *rrd , unsigned long elapsed_pdp_st , rrd_value_t *pdp_temp ,
                      rrd_value_t *last_seasonal_coef , rrd_value_t *seasonal_coef ,
                      int rra_idx , int ds_idx , int cdp_idx , enum cf_en current_cf ) ;
#line 229
static rrd_value_t initialize_carry_over(rrd_value_t pdp_temp_val , int current_cf ,
                                         unsigned long elapsed_pdp_st , unsigned long start_pdp_offset ,
                                         unsigned long pdp_cnt ) ;
#line 236
static rrd_value_t calculate_cdp_val(rrd_value_t cdp_val , rrd_value_t pdp_temp_val ,
                                     unsigned long elapsed_pdp_st , int current_cf ,
                                     int i  __attribute__((__unused__)) , int ii  __attribute__((__unused__)) ) ;
#line 244
static int update_aberrant_cdps(rrd_t *rrd , rrd_file_t *rrd_file , unsigned long rra_begin ,
                                unsigned long elapsed_pdp_st , rrd_value_t *pdp_temp ,
                                rrd_value_t **seasonal_coef ) ;
#line 252
static int write_to_rras(rrd_t *rrd , rrd_file_t *rrd_file , unsigned long *rra_step_cnt ,
                         unsigned long rra_begin , time_t current_time , unsigned long *skip_update ,
                         rrd_info_t **pcdp_summary ) ;
#line 261
static int write_RRA_row(rrd_file_t *rrd_file , rrd_t *rrd , unsigned long rra_idx ,
                         unsigned short CDP_scratch_idx , rrd_info_t **pcdp_summary ,
                         time_t rra_time ) ;
#line 269
static int smooth_all_rras(rrd_t *rrd , rrd_file_t *rrd_file , unsigned long rra_begin ) ;
#line 285 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static void normalize_time(struct timeval *t ) 
{ 


  {
#line 288
  if (t->tv_usec < 0L) {
#line 289
    (t->tv_sec) --;
#line 290
    t->tv_usec = (__suseconds_t )((long double )t->tv_usec + 1e6L);
  }
#line 292
  return;
}
}
#line 298 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static void initialize_time(time_t *current_time , unsigned long *current_time_usec ,
                            int version ) 
{ 
  struct timeval tmp_time ;

  {
  {
#line 305
  gettimeofday((struct timeval */* __restrict  */)(& tmp_time), (__timezone_ptr_t )0);
#line 306
  normalize_time(& tmp_time);
#line 307
  *current_time = tmp_time.tv_sec;
  }
#line 308
  if (version >= 3) {
#line 309
    *current_time_usec = (unsigned long )tmp_time.tv_usec;
  } else {
#line 311
    *current_time_usec = 0UL;
  }
#line 313
  return;
}
}
#line 317 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
rrd_info_t *rrd_update_v(int argc , char **argv ) 
{ 
  char *tmplt ;
  rrd_info_t *result ;
  rrd_infoval_t rc ;
  char *opt_daemon ;
  struct option long_options___5[2] ;
  int option_index ;
  int opt ;
  char *tmp ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 321
  tmplt = (char *)((void *)0);
#line 322
  result = (rrd_info_t *)((void *)0);
#line 324
  opt_daemon = (char *)((void *)0);
#line 325
  long_options___5[0].name = "template";
#line 325
  long_options___5[0].has_arg = 1;
#line 325
  long_options___5[0].flag = (int *)0;
#line 325
  long_options___5[0].val = 't';
#line 325
  long_options___5[1].name = (char const   *)0;
#line 325
  long_options___5[1].has_arg = 0;
#line 325
  long_options___5[1].flag = (int *)0;
#line 325
  long_options___5[1].val = 0;
#line 330
  rc.u_int = -1;
#line 331
  optind = 0;
#line 332
  opterr = 0;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 335
    option_index = 0;
#line 338
    opt = getopt_long(argc, (char * const  *)argv, "t:", (struct option  const  *)(long_options___5),
                      & option_index);
    }
#line 340
    if (opt == -1) {
#line 341
      goto while_break;
    }
    {
#line 344
    if (opt == 116) {
#line 344
      goto case_116;
    }
#line 348
    if (opt == 63) {
#line 348
      goto case_63;
    }
#line 343
    goto switch_break;
    case_116: /* CIL Label */ 
#line 345
    tmplt = optarg;
#line 346
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 349
    rrd_set_error((char *)"unknown option \'%s\'", *(argv + (optind - 1)));
    }
#line 350
    goto end_tag;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 354
  opt_daemon = getenv("RRDCACHED_ADDRESS");
  }
#line 355
  if ((unsigned long )opt_daemon != (unsigned long )((void *)0)) {
    {
#line 356
    rrd_set_error((char *)"The \"%s\" environment variable is defined, but \"%s\" cannot work with rrdcached. Either unset the environment variable or use \"update\" instead.",
                  "RRDCACHED_ADDRESS", *(argv + 0));
    }
#line 360
    goto end_tag;
  }
#line 364
  if (argc - optind < 2) {
    {
#line 365
    rrd_set_error((char *)"Not enough arguments");
    }
#line 366
    goto end_tag;
  }
  {
#line 368
  rc.u_int = 0;
#line 369
  tmp = sprintf_alloc((char *)"return_value");
#line 369
  result = rrd_info_push((rrd_info_t *)((void *)0), tmp, (rrd_info_type_t )3, rc);
#line 370
  rc.u_int = _rrd_update((char const   *)*(argv + optind), (char const   *)tmplt,
                         (argc - optind) - 1, (char const   **)((argv + optind) + 1),
                         result);
#line 373
  result->value.u_int = rc.u_int;
  }
  end_tag: 
#line 375
  return (result);
}
}
#line 378 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
int rrd_update(int argc , char **argv ) 
{ 
  struct option long_options___5[3] ;
  int option_index ;
  int opt ;
  char *tmplt ;
  int rc ;
  char *opt_daemon ;
  int status ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 382
  long_options___5[0].name = "template";
#line 382
  long_options___5[0].has_arg = 1;
#line 382
  long_options___5[0].flag = (int *)0;
#line 382
  long_options___5[0].val = 't';
#line 382
  long_options___5[1].name = "daemon";
#line 382
  long_options___5[1].has_arg = 1;
#line 382
  long_options___5[1].flag = (int *)0;
#line 382
  long_options___5[1].val = 'd';
#line 382
  long_options___5[2].name = (char const   *)0;
#line 382
  long_options___5[2].has_arg = 0;
#line 382
  long_options___5[2].flag = (int *)0;
#line 382
  long_options___5[2].val = 0;
#line 387
  option_index = 0;
#line 389
  tmplt = (char *)((void *)0);
#line 390
  rc = -1;
#line 391
  opt_daemon = (char *)((void *)0);
#line 393
  optind = 0;
#line 394
  opterr = 0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 397
    opt = getopt_long(argc, (char * const  *)argv, "t:d:", (struct option  const  *)(long_options___5),
                      & option_index);
    }
#line 399
    if (opt == -1) {
#line 400
      goto while_break;
    }
    {
#line 403
    if (opt == 116) {
#line 403
      goto case_116;
    }
#line 407
    if (opt == 100) {
#line 407
      goto case_100;
    }
#line 418
    if (opt == 63) {
#line 418
      goto case_63;
    }
#line 402
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 404
    tmplt = strdup((char const   *)optarg);
    }
#line 405
    goto switch_break;
    case_100: /* CIL Label */ 
#line 408
    if ((unsigned long )opt_daemon != (unsigned long )((void *)0)) {
      {
#line 409
      free((void *)opt_daemon);
      }
    }
    {
#line 410
    opt_daemon = strdup((char const   *)optarg);
    }
#line 411
    if ((unsigned long )opt_daemon == (unsigned long )((void *)0)) {
      {
#line 413
      rrd_set_error((char *)"strdup failed.");
      }
#line 414
      goto out;
    }
#line 416
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 419
    rrd_set_error((char *)"unknown option \'%s\'", *(argv + (optind - 1)));
    }
#line 420
    goto out;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  if (argc - optind < 2) {
    {
#line 426
    rrd_set_error((char *)"Not enough arguments");
    }
#line 427
    goto out;
  }
  {
#line 431
  tmp = rrdc_connect((char const   *)opt_daemon);
#line 431
  status = tmp;
  }
#line 432
  if (status != 0) {
#line 433
    rc = status;
#line 434
    goto out;
  }
#line 438
  if ((unsigned long )tmplt != (unsigned long )((void *)0)) {
    {
#line 438
    tmp___0 = rrdc_is_connected((char const   *)opt_daemon);
    }
#line 438
    if (tmp___0) {
      {
#line 440
      rrd_set_error((char *)"The caching daemon cannot be used together with templates yet.");
      }
#line 442
      goto out;
    }
  }
  {
#line 445
  tmp___2 = rrdc_is_connected((char const   *)opt_daemon);
  }
#line 445
  if (tmp___2) {
    {
#line 452
    rc = rrdc_update((char const   *)*(argv + optind), (argc - optind) - 1, (char const   * const  *)((argv + optind) + 1));
    }
#line 455
    if (rc > 0) {
      {
#line 456
      tmp___1 = rrd_strerror(rc);
#line 456
      rrd_set_error((char *)"Failed sending the values to rrdcached: %s", tmp___1);
      }
    }
  } else {
    {
#line 447
    rc = rrd_update_r((char const   *)*(argv + optind), (char const   *)tmplt, (argc - optind) - 1,
                      (char const   **)((argv + optind) + 1));
    }
  }
  out: 
#line 461
  if ((unsigned long )tmplt != (unsigned long )((void *)0)) {
    {
#line 463
    free((void *)tmplt);
#line 464
    tmplt = (char *)((void *)0);
    }
  }
#line 466
  if ((unsigned long )opt_daemon != (unsigned long )((void *)0)) {
    {
#line 468
    free((void *)opt_daemon);
#line 469
    opt_daemon = (char *)((void *)0);
    }
  }
#line 471
  return (rc);
}
}
#line 474 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
int rrd_update_r(char const   *filename , char const   *tmplt , int argc , char const   **argv ) 
{ 
  int tmp ;

  {
  {
#line 480
  tmp = _rrd_update(filename, tmplt, argc, argv, (rrd_info_t *)((void *)0));
  }
#line 480
  return (tmp);
}
}
#line 483 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
int _rrd_update(char const   *filename , char const   *tmplt , int argc , char const   **argv ,
                rrd_info_t *pcdp_summary ) 
{ 
  int arg_i ;
  unsigned long rra_begin ;
  rrd_value_t *pdp_new ;
  rrd_value_t *pdp_temp ;
  long *tmpl_idx ;
  unsigned long tmpl_cnt ;
  rrd_t rrd ;
  time_t current_time ;
  unsigned long current_time_usec ;
  char **updvals ;
  int schedule_smooth ;
  unsigned long *rra_step_cnt ;
  int version ;
  rrd_file_t *rrd_file ;
  char *arg_copy ;
  unsigned long *skip_update ;
  int tmp ;
  int tmp___0 ;
  char *save_error ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 491
  arg_i = 2;
#line 503
  tmpl_cnt = 2UL;
#line 505
  current_time = (time_t )0;
#line 506
  current_time_usec = 0UL;
#line 508
  schedule_smooth = 0;
#line 511
  rra_step_cnt = (unsigned long *)((void *)0);
#line 519
  if (argc < 1) {
    {
#line 520
    rrd_set_error((char *)"Not enough arguments");
    }
#line 521
    goto err_out;
  }
  {
#line 524
  rrd_init(& rrd);
#line 525
  rrd_file = rrd_open((char const   */* const  */)filename, & rrd, (unsigned int )(1 << 1));
  }
#line 525
  if ((unsigned long )rrd_file == (unsigned long )((void *)0)) {
#line 526
    goto err_free;
  }
  {
#line 529
  rra_begin = rrd_file->header_len;
#line 531
  version = atoi((char const   *)((rrd.stat_head)->version));
#line 533
  initialize_time(& current_time, & current_time_usec, version);
#line 538
  tmp = rrd_lock(rrd_file);
  }
#line 538
  if (tmp != 0) {
    {
#line 539
    rrd_set_error((char *)"could not lock RRD");
    }
#line 540
    goto err_close;
  }
  {
#line 543
  tmp___0 = allocate_data_structures(& rrd, & updvals, & pdp_temp, tmplt, & tmpl_idx,
                                     & tmpl_cnt, & rra_step_cnt, & skip_update, & pdp_new);
  }
#line 543
  if (tmp___0 == -1) {
#line 547
    goto err_close;
  }
#line 551
  arg_i = 0;
  {
#line 551
  while (1) {
    while_continue: /* CIL Label */ ;
#line 551
    if (! (arg_i < argc)) {
#line 551
      goto while_break;
    }
    {
#line 552
    arg_copy = strdup(*(argv + arg_i));
    }
#line 552
    if ((unsigned long )arg_copy == (unsigned long )((void *)0)) {
      {
#line 553
      rrd_set_error((char *)"failed duplication argv entry");
      }
#line 554
      goto while_break;
    }
    {
#line 556
    tmp___3 = process_arg(arg_copy, & rrd, rrd_file, rra_begin, & current_time, & current_time_usec,
                          pdp_temp, pdp_new, rra_step_cnt, updvals, tmpl_idx, tmpl_cnt,
                          & pcdp_summary, version, skip_update, & schedule_smooth);
    }
#line 556
    if (tmp___3 == -1) {
      {
#line 561
      tmp___2 = rrd_test_error();
      }
#line 561
      if (tmp___2) {
        {
#line 565
        tmp___1 = rrd_get_error();
#line 565
        save_error = strdup((char const   *)tmp___1);
        }
#line 565
        if ((unsigned long )save_error != (unsigned long )((void *)0)) {
          {
#line 566
          rrd_set_error((char *)"%s: %s", filename, save_error);
#line 567
          free((void *)save_error);
          }
        }
      }
      {
#line 570
      free((void *)arg_copy);
      }
#line 571
      goto while_break;
    }
    {
#line 573
    free((void *)arg_copy);
#line 551
    arg_i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 576
  free((void *)rra_step_cnt);
#line 580
  tmp___4 = rrd_test_error();
  }
#line 580
  if (tmp___4) {
#line 581
    goto err_free_structures;
  }
#line 593
  if (schedule_smooth) {
    {
#line 594
    smooth_all_rras(& rrd, rrd_file, rra_begin);
    }
  }
  {
#line 598
  rrd_free(& rrd);
#line 599
  rrd_close(rrd_file);
#line 601
  free((void *)pdp_new);
#line 602
  free((void *)tmpl_idx);
#line 603
  free((void *)pdp_temp);
#line 604
  free((void *)skip_update);
#line 605
  free((void *)updvals);
  }
#line 606
  return (0);
  err_free_structures: 
  {
#line 609
  free((void *)pdp_new);
#line 610
  free((void *)tmpl_idx);
#line 611
  free((void *)pdp_temp);
#line 612
  free((void *)skip_update);
#line 613
  free((void *)updvals);
  }
  err_close: 
  {
#line 615
  rrd_close(rrd_file);
  }
  err_free: 
  {
#line 617
  rrd_free(& rrd);
  }
  err_out: 
#line 619
  return (-1);
}
}
#line 630 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int allocate_data_structures(rrd_t *rrd , char ***updvals , rrd_value_t **pdp_temp ,
                                    char const   *tmplt , long **tmpl_idx , unsigned long *tmpl_cnt ,
                                    unsigned long **rra_step_cnt , unsigned long **skip_update ,
                                    rrd_value_t **pdp_new ) 
{ 
  unsigned int i ;
  unsigned int ii ;
  char **tmp ;
  void *tmp___0 ;
  rrd_value_t *tmp___1 ;
  void *tmp___2 ;
  unsigned long *tmp___3 ;
  void *tmp___4 ;
  long *tmp___5 ;
  void *tmp___6 ;
  unsigned long *tmp___7 ;
  void *tmp___8 ;
  unsigned int tmp___9 ;
  enum dst_en tmp___10 ;
  int tmp___11 ;
  rrd_value_t *tmp___12 ;
  void *tmp___13 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 642
  tmp___0 = malloc(sizeof(char *) * ((rrd->stat_head)->ds_cnt + 1UL));
#line 642
  tmp = (char **)tmp___0;
#line 642
  *updvals = tmp;
  }
#line 642
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 644
    rrd_set_error((char *)"allocating updvals pointer array.");
    }
#line 645
    return (-1);
  }
  {
#line 647
  tmp___2 = malloc(sizeof(rrd_value_t ) * (rrd->stat_head)->ds_cnt);
#line 647
  tmp___1 = (rrd_value_t *)tmp___2;
#line 647
  *pdp_temp = tmp___1;
  }
#line 647
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 650
    rrd_set_error((char *)"allocating pdp_temp.");
    }
#line 651
    goto err_free_updvals;
  }
  {
#line 653
  tmp___4 = malloc(sizeof(unsigned long ) * (rrd->stat_head)->rra_cnt);
#line 653
  tmp___3 = (unsigned long *)tmp___4;
#line 653
  *skip_update = tmp___3;
  }
#line 653
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 657
    rrd_set_error((char *)"allocating skip_update.");
    }
#line 658
    goto err_free_pdp_temp;
  }
  {
#line 660
  tmp___6 = malloc(sizeof(unsigned long ) * ((rrd->stat_head)->ds_cnt + 1UL));
#line 660
  tmp___5 = (long *)tmp___6;
#line 660
  *tmpl_idx = tmp___5;
  }
#line 660
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    {
#line 662
    rrd_set_error((char *)"allocating tmpl_idx.");
    }
#line 663
    goto err_free_skip_update;
  }
  {
#line 665
  tmp___8 = malloc(sizeof(unsigned long ) * (rrd->stat_head)->rra_cnt);
#line 665
  tmp___7 = (unsigned long *)tmp___8;
#line 665
  *rra_step_cnt = tmp___7;
  }
#line 665
  if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
    {
#line 669
    rrd_set_error((char *)"allocating rra_step_cnt.");
    }
#line 670
    goto err_free_tmpl_idx;
  }
#line 679
  *(*tmpl_idx + 0) = 0L;
#line 680
  i = 1U;
#line 680
  ii = 1U;
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    if (! ((unsigned long )i <= (rrd->stat_head)->ds_cnt)) {
#line 680
      goto while_break;
    }
    {
#line 681
    tmp___10 = dst_conv((rrd->ds_def + (i - 1U))->dst);
    }
#line 681
    if ((unsigned int )tmp___10 != 4U) {
#line 682
      tmp___9 = ii;
#line 682
      ii ++;
#line 682
      *(*tmpl_idx + tmp___9) = (long )i;
    }
#line 680
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 684
  *tmpl_cnt = (unsigned long )ii;
#line 686
  if ((unsigned long )tmplt != (unsigned long )((void *)0)) {
    {
#line 687
    tmp___11 = parse_template(rrd, tmplt, tmpl_cnt, *tmpl_idx);
    }
#line 687
    if (tmp___11 == -1) {
#line 688
      goto err_free_rra_step_cnt;
    }
  }
  {
#line 692
  tmp___13 = malloc(sizeof(rrd_value_t ) * (rrd->stat_head)->ds_cnt);
#line 692
  tmp___12 = (rrd_value_t *)tmp___13;
#line 692
  *pdp_new = tmp___12;
  }
#line 692
  if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
    {
#line 694
    rrd_set_error((char *)"allocating pdp_new.");
    }
#line 695
    goto err_free_rra_step_cnt;
  }
#line 698
  return (0);
  err_free_rra_step_cnt: 
  {
#line 701
  free((void *)*rra_step_cnt);
  }
  err_free_tmpl_idx: 
  {
#line 703
  free((void *)*tmpl_idx);
  }
  err_free_skip_update: 
  {
#line 705
  free((void *)*skip_update);
  }
  err_free_pdp_temp: 
  {
#line 707
  free((void *)*pdp_temp);
  }
  err_free_updvals: 
  {
#line 709
  free((void *)*updvals);
  }
#line 710
  return (-1);
}
}
#line 718 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int parse_template(rrd_t *rrd , char const   *tmplt , unsigned long *tmpl_cnt ,
                          long *tmpl_idx ) 
{ 
  char *dsname ;
  char *tmplt_copy ;
  unsigned int tmpl_len ;
  unsigned int i ;
  int ret ;
  size_t tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 726
  ret = 0;
#line 728
  *tmpl_cnt = 1UL;
#line 731
  tmplt_copy = strdup(tmplt);
  }
#line 731
  if ((unsigned long )tmplt_copy == (unsigned long )((void *)0)) {
    {
#line 732
    rrd_set_error((char *)"error copying tmplt \'%s\'", tmplt);
#line 733
    ret = -1;
    }
#line 734
    goto out;
  }
  {
#line 737
  dsname = tmplt_copy;
#line 738
  tmp = strlen((char const   *)tmplt_copy);
#line 738
  tmpl_len = (unsigned int )tmp;
#line 739
  i = 0U;
  }
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 739
    if (! (i <= tmpl_len)) {
#line 739
      goto while_break;
    }
#line 740
    if ((int )*(tmplt_copy + i) == 58) {
#line 740
      goto _L;
    } else
#line 740
    if ((int )*(tmplt_copy + i) == 0) {
      _L: /* CIL Label */ 
#line 741
      *(tmplt_copy + i) = (char )'\000';
#line 742
      if (*tmpl_cnt > (rrd->stat_head)->ds_cnt) {
        {
#line 743
        rrd_set_error((char *)"tmplt contains more DS definitions than RRD");
#line 744
        ret = -1;
        }
#line 745
        goto out_free_tmpl_copy;
      }
      {
#line 747
      tmp___0 = *tmpl_cnt;
#line 747
      (*tmpl_cnt) ++;
#line 747
      tmp___2 = ds_match(rrd, dsname);
#line 747
      tmp___1 = tmp___2 + 1L;
#line 747
      *(tmpl_idx + tmp___0) = tmp___1;
      }
#line 747
      if (tmp___1 == 0L) {
        {
#line 748
        rrd_set_error((char *)"unknown DS name \'%s\'", dsname);
#line 749
        ret = -1;
        }
#line 750
        goto out_free_tmpl_copy;
      }
#line 753
      if (i < tmpl_len) {
#line 754
        dsname = tmplt_copy + (i + 1U);
      }
    }
#line 739
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  out_free_tmpl_copy: 
  {
#line 758
  free((void *)tmplt_copy);
  }
  out: 
#line 760
  return (ret);
}
}
#line 769 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int process_arg(char *step_start , rrd_t *rrd , rrd_file_t *rrd_file , unsigned long rra_begin ,
                       time_t *current_time , unsigned long *current_time_usec , rrd_value_t *pdp_temp ,
                       rrd_value_t *pdp_new , unsigned long *rra_step_cnt , char **updvals ,
                       long *tmpl_idx , unsigned long tmpl_cnt , rrd_info_t **pcdp_summary ,
                       int version , unsigned long *skip_update , int *schedule_smooth ) 
{ 
  rrd_value_t *seasonal_coef ;
  rrd_value_t *last_seasonal_coef ;
  unsigned long elapsed_pdp_st ;
  double interval ;
  double pre_int ;
  double post_int ;
  unsigned long proc_pdp_cnt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 787
  seasonal_coef = (rrd_value_t *)((void *)0);
#line 787
  last_seasonal_coef = (rrd_value_t *)((void *)0);
#line 796
  tmp = parse_ds(rrd, updvals, tmpl_idx, step_start, tmpl_cnt, current_time, current_time_usec,
                 version);
  }
#line 796
  if (tmp == -1) {
#line 798
    return (-1);
  }
  {
#line 801
  interval = (double )(*current_time - (rrd->live_head)->last_up) + (double )((long )*current_time_usec - (rrd->live_head)->last_up_usec) / (double )1e6f;
#line 807
  tmp___0 = update_pdp_prep(rrd, updvals, pdp_new, interval);
  }
#line 807
  if (tmp___0 == -1) {
#line 808
    return (-1);
  }
  {
#line 811
  tmp___1 = calculate_elapsed_steps(rrd, (unsigned long )*current_time, *current_time_usec,
                                    interval, & pre_int, & post_int, & proc_pdp_cnt);
#line 811
  elapsed_pdp_st = (unsigned long )tmp___1;
  }
#line 818
  if (elapsed_pdp_st == 0UL) {
    {
#line 820
    simple_update(rrd, interval, pdp_new);
    }
  } else {
    {
#line 823
    tmp___2 = process_all_pdp_st(rrd, interval, pre_int, post_int, elapsed_pdp_st,
                                 pdp_new, pdp_temp);
    }
#line 823
    if (tmp___2 == -1) {
#line 826
      return (-1);
    }
    {
#line 828
    tmp___3 = update_all_cdp_prep(rrd, rra_step_cnt, rra_begin, rrd_file, elapsed_pdp_st,
                                  proc_pdp_cnt, & last_seasonal_coef, & seasonal_coef,
                                  pdp_temp, skip_update, schedule_smooth);
    }
#line 828
    if (tmp___3 == -1) {
#line 836
      goto err_free_coefficients;
    }
    {
#line 838
    tmp___4 = update_aberrant_cdps(rrd, rrd_file, rra_begin, elapsed_pdp_st, pdp_temp,
                                   & seasonal_coef);
    }
#line 838
    if (tmp___4 == -1) {
#line 841
      goto err_free_coefficients;
    }
    {
#line 843
    tmp___5 = write_to_rras(rrd, rrd_file, rra_step_cnt, rra_begin, *current_time,
                            skip_update, pcdp_summary);
    }
#line 843
    if (tmp___5 == -1) {
#line 846
      goto err_free_coefficients;
    }
  }
#line 849
  (rrd->live_head)->last_up = *current_time;
#line 850
  (rrd->live_head)->last_up_usec = (long )*current_time_usec;
#line 852
  if (version < 3) {
#line 853
    *(rrd->legacy_last_up) = (rrd->live_head)->last_up;
  }
  {
#line 855
  free((void *)seasonal_coef);
#line 856
  free((void *)last_seasonal_coef);
  }
#line 857
  return (0);
  err_free_coefficients: 
  {
#line 860
  free((void *)seasonal_coef);
#line 861
  free((void *)last_seasonal_coef);
  }
#line 862
  return (-1);
}
}
#line 871 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int parse_ds(rrd_t *rrd , char **updvals , long *tmpl_idx , char *input , unsigned long tmpl_cnt ,
                    time_t *current_time , unsigned long *current_time_usec , int version ) 
{ 
  char *p ;
  unsigned long i ;
  char timesyntax ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 885
  *(updvals + 0) = input;
#line 888
  i = 1UL;
  {
#line 888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 888
    if (! (i <= (rrd->stat_head)->ds_cnt)) {
#line 888
      goto while_break;
    }
#line 889
    *(updvals + i) = (char *)"U";
#line 888
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 893
  p = strchr((char const   *)input, '@');
  }
#line 893
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 894
    timesyntax = (char )'@';
  } else {
    {
#line 895
    p = strchr((char const   *)input, ':');
    }
#line 895
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 896
      timesyntax = (char )':';
    } else {
      {
#line 898
      rrd_set_error((char *)"expected timestamp not found in data source from %s",
                    input);
      }
#line 900
      return (-1);
    }
  }
#line 902
  *p = (char )'\000';
#line 903
  i = 1UL;
#line 904
  tmp = i;
#line 904
  i ++;
#line 904
  *(updvals + *(tmpl_idx + tmp)) = p + 1;
  {
#line 905
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 905
    p ++;
#line 905
    if (! *p) {
#line 905
      goto while_break___0;
    }
#line 906
    if ((int )*p == 58) {
#line 907
      *p = (char )'\000';
#line 908
      if (i < tmpl_cnt) {
#line 909
        tmp___0 = i;
#line 909
        i ++;
#line 909
        *(updvals + *(tmpl_idx + tmp___0)) = p + 1;
      } else {
        {
#line 912
        rrd_set_error((char *)"found extra data on update argument: %s", p + 1);
        }
#line 913
        return (-1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 918
  if (i != tmpl_cnt) {
    {
#line 919
    rrd_set_error((char *)"expected %lu data source readings (got %lu) from %s", tmpl_cnt - 1UL,
                  i - 1UL, input);
    }
#line 921
    return (-1);
  }
  {
#line 924
  tmp___1 = get_time_from_reading(rrd, timesyntax, updvals, current_time, current_time_usec,
                                  version);
  }
#line 924
  if (tmp___1 == -1) {
#line 927
    return (-1);
  }
#line 929
  return (0);
}
}
#line 939 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int get_time_from_reading(rrd_t *rrd , char timesyntax , char **updvals , time_t *current_time ,
                                 unsigned long *current_time_usec , int version ) 
{ 
  double tmp ;
  char *parsetime_error ;
  char *old_locale ;
  rrd_time_value_t ds_tv ;
  struct timeval tmp_time ;
  time_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 948
  parsetime_error = (char *)((void *)0);
#line 954
  if ((int )timesyntax == 64) {
    {
#line 955
    parsetime_error = rrd_parsetime((char const   *)*(updvals + 0), & ds_tv);
    }
#line 955
    if (parsetime_error) {
      {
#line 956
      rrd_set_error((char *)"ds time: %s: %s", *(updvals + 0), parsetime_error);
      }
#line 957
      return (-1);
    }
#line 959
    if ((unsigned int )ds_tv.type == 2U) {
      {
#line 961
      rrd_set_error((char *)"specifying time relative to the \'start\' or \'end\' makes no sense here: %s",
                    *(updvals + 0));
      }
#line 963
      return (-1);
    } else
#line 959
    if ((unsigned int )ds_tv.type == 1U) {
      {
#line 961
      rrd_set_error((char *)"specifying time relative to the \'start\' or \'end\' makes no sense here: %s",
                    *(updvals + 0));
      }
#line 963
      return (-1);
    }
    {
#line 965
    tmp___0 = mktime(& ds_tv.tm);
#line 965
    *current_time = tmp___0 + ds_tv.offset;
#line 966
    *current_time_usec = 0UL;
    }
  } else {
    {
#line 967
    tmp___6 = strcmp((char const   *)*(updvals + 0), "N");
    }
#line 967
    if (tmp___6 == 0) {
      {
#line 968
      gettimeofday((struct timeval */* __restrict  */)(& tmp_time), (__timezone_ptr_t )0);
#line 969
      normalize_time(& tmp_time);
#line 970
      *current_time = tmp_time.tv_sec;
#line 971
      *current_time_usec = (unsigned long )tmp_time.tv_usec;
      }
    } else {
      {
#line 973
      old_locale = setlocale(1, (char const   *)((void *)0));
#line 974
      setlocale(1, "C");
#line 975
      tmp___1 = __errno_location();
#line 975
      *tmp___1 = 0;
#line 976
      tmp = strtod((char const   */* __restrict  */)*(updvals + 0), (char **/* __restrict  */)0);
#line 977
      tmp___4 = __errno_location();
      }
#line 977
      if (*tmp___4 > 0) {
        {
#line 978
        tmp___2 = __errno_location();
#line 978
        tmp___3 = rrd_strerror(*tmp___2);
#line 978
        rrd_set_error((char *)"converting \'%s\' to float: %s", *(updvals + 0), tmp___3);
        }
#line 980
        return (-1);
      }
      {
#line 982
      setlocale(1, (char const   *)old_locale);
      }
#line 983
      if (tmp < 0.0) {
        {
#line 984
        gettimeofday((struct timeval */* __restrict  */)(& tmp_time), (__timezone_ptr_t )0);
#line 985
        tmp = ((double )tmp_time.tv_sec + (double )tmp_time.tv_usec * (double )1e-6f) + tmp;
        }
      }
      {
#line 988
      tmp___5 = floor(tmp);
#line 988
      *current_time = (time_t )tmp___5;
#line 989
      *current_time_usec = (unsigned long )((long )((tmp - (double )*current_time) * (double )1e6f));
      }
    }
  }
#line 992
  if (version < 3) {
#line 993
    *current_time_usec = 0UL;
  }
#line 995
  if (*current_time < (rrd->live_head)->last_up) {
    {
#line 998
    rrd_set_error((char *)"illegal attempt to update using time %ld when last update time is %ld (minimum one second step)",
                  *current_time, (rrd->live_head)->last_up);
    }
#line 1001
    return (-1);
  } else
#line 995
  if (*current_time == (rrd->live_head)->last_up) {
#line 995
    if ((long )*current_time_usec <= (rrd->live_head)->last_up_usec) {
      {
#line 998
      rrd_set_error((char *)"illegal attempt to update using time %ld when last update time is %ld (minimum one second step)",
                    *current_time, (rrd->live_head)->last_up);
      }
#line 1001
      return (-1);
    }
  }
#line 1003
  return (0);
}
}
#line 1012 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int update_pdp_prep(rrd_t *rrd , char **updvals , rrd_value_t *pdp_new , double interval ) 
{ 
  unsigned long ds_idx ;
  int ii ;
  char *endptr ;
  double rate ;
  char *old_locale ;
  enum dst_en dst_idx ;
  char const   *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  double tmp___5 ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 1025
  ds_idx = 0UL;
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    if (! (ds_idx < (rrd->stat_head)->ds_cnt)) {
#line 1025
      goto while_break;
    }
    {
#line 1026
    dst_idx = dst_conv((rrd->ds_def + ds_idx)->dst);
    }
#line 1029
    if ((double )(rrd->ds_def + ds_idx)->par[0].u_cnt < interval) {
      {
#line 1030
      strncpy((char */* __restrict  */)((rrd->pdp_prep + ds_idx)->last_ds), (char const   */* __restrict  */)"U",
              (size_t )29);
#line 1031
      (rrd->pdp_prep + ds_idx)->last_ds[29] = (char )'\000';
      }
    }
#line 1039
    if ((int )*(*(updvals + (ds_idx + 1UL)) + 0) != 85) {
#line 1039
      if ((unsigned int )dst_idx != 4U) {
#line 1039
        if ((double )(rrd->ds_def + ds_idx)->par[0].u_cnt >= interval) {
          {
#line 1042
          rate = rrd_set_to_DNAN();
          }
          {
#line 1049
          if ((unsigned int )dst_idx == 3U) {
#line 1049
            goto case_3;
          }
#line 1049
          if ((unsigned int )dst_idx == 0U) {
#line 1049
            goto case_3;
          }
#line 1085
          if ((unsigned int )dst_idx == 1U) {
#line 1085
            goto case_1;
          }
#line 1104
          if ((unsigned int )dst_idx == 2U) {
#line 1104
            goto case_2;
          }
#line 1124
          goto switch_default;
          case_3: /* CIL Label */ 
          case_0: /* CIL Label */ 
#line 1052
          ii = 0;
          {
#line 1052
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1052
            if (! ((int )*(*(updvals + (ds_idx + 1UL)) + ii) != 0)) {
#line 1052
              goto while_break___0;
            }
#line 1053
            if (ii == 0) {
#line 1053
              if ((unsigned int )dst_idx == 3U) {
#line 1053
                if ((int )*(*(updvals + (ds_idx + 1UL)) + ii) == 45) {
#line 1055
                  goto __Cont;
                }
              }
            }
#line 1057
            if ((int )*(*(updvals + (ds_idx + 1UL)) + ii) < 48) {
#line 1057
              goto _L;
            } else
#line 1057
            if ((int )*(*(updvals + (ds_idx + 1UL)) + ii) > 57) {
              _L: /* CIL Label */ 
#line 1059
              if ((unsigned int )dst_idx == 3U) {
#line 1059
                tmp = "signed";
              } else {
#line 1059
                tmp = "unsigned";
              }
              {
#line 1059
              rrd_set_error((char *)"not a simple %s integer: \'%s\'", tmp, *(updvals + (ds_idx + 1UL)));
              }
#line 1062
              return (-1);
            }
            __Cont: /* CIL Label */ 
#line 1052
            ii ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1066
          if ((int )(rrd->pdp_prep + ds_idx)->last_ds[0] != 85) {
            {
#line 1067
            *(pdp_new + ds_idx) = rrd_diff(*(updvals + (ds_idx + 1UL)), (rrd->pdp_prep + ds_idx)->last_ds);
            }
#line 1070
            if ((unsigned int )dst_idx == 0U) {
#line 1075
              if (*(pdp_new + ds_idx) < 0.0) {
#line 1076
                *(pdp_new + ds_idx) += 4294967296.0;
              }
#line 1077
              if (*(pdp_new + ds_idx) < 0.0) {
#line 1078
                *(pdp_new + ds_idx) += 18446744069414584320.0;
              }
            }
#line 1080
            rate = *(pdp_new + ds_idx) / interval;
          } else {
            {
#line 1082
            *(pdp_new + ds_idx) = rrd_set_to_DNAN();
            }
          }
#line 1084
          goto switch_break;
          case_1: /* CIL Label */ 
          {
#line 1086
          old_locale = setlocale(1, (char const   *)((void *)0));
#line 1087
          setlocale(1, "C");
#line 1088
          tmp___0 = __errno_location();
#line 1088
          *tmp___0 = 0;
#line 1089
          *(pdp_new + ds_idx) = strtod((char const   */* __restrict  */)*(updvals + (ds_idx + 1UL)),
                                       (char **/* __restrict  */)(& endptr));
#line 1090
          tmp___3 = __errno_location();
          }
#line 1090
          if (*tmp___3 > 0) {
            {
#line 1091
            tmp___1 = __errno_location();
#line 1091
            tmp___2 = rrd_strerror(*tmp___1);
#line 1091
            rrd_set_error((char *)"converting \'%s\' to float: %s", *(updvals + (ds_idx + 1UL)),
                          tmp___2);
            }
#line 1093
            return (-1);
          }
          {
#line 1095
          setlocale(1, (char const   *)old_locale);
          }
#line 1096
          if ((int )*(endptr + 0) != 0) {
            {
#line 1097
            rrd_set_error((char *)"conversion of \'%s\' to float not complete: tail \'%s\'",
                          *(updvals + (ds_idx + 1UL)), endptr);
            }
#line 1100
            return (-1);
          }
#line 1102
          rate = *(pdp_new + ds_idx) / interval;
#line 1103
          goto switch_break;
          case_2: /* CIL Label */ 
          {
#line 1105
          old_locale = setlocale(1, (char const   *)((void *)0));
#line 1106
          setlocale(1, "C");
#line 1107
          tmp___4 = __errno_location();
#line 1107
          *tmp___4 = 0;
#line 1108
          tmp___5 = strtod((char const   */* __restrict  */)*(updvals + (ds_idx + 1UL)),
                           (char **/* __restrict  */)(& endptr));
#line 1108
          *(pdp_new + ds_idx) = tmp___5 * interval;
#line 1110
          tmp___8 = __errno_location();
          }
#line 1110
          if (*tmp___8) {
            {
#line 1111
            tmp___6 = __errno_location();
#line 1111
            tmp___7 = rrd_strerror(*tmp___6);
#line 1111
            rrd_set_error((char *)"converting \'%s\' to float: %s", *(updvals + (ds_idx + 1UL)),
                          tmp___7);
            }
#line 1113
            return (-1);
          }
          {
#line 1115
          setlocale(1, (char const   *)old_locale);
          }
#line 1116
          if ((int )*(endptr + 0) != 0) {
            {
#line 1117
            rrd_set_error((char *)"conversion of \'%s\' to float not complete: tail \'%s\'",
                          *(updvals + (ds_idx + 1UL)), endptr);
            }
#line 1120
            return (-1);
          }
#line 1122
          rate = *(pdp_new + ds_idx) / interval;
#line 1123
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 1125
          rrd_set_error((char *)"rrd contains unknown DS type : \'%s\'", (rrd->ds_def + ds_idx)->dst);
          }
#line 1127
          return (-1);
          switch_break: /* CIL Label */ ;
          }
          {
#line 1130
          tmp___9 = rrd_test_error();
          }
#line 1130
          if (tmp___9) {
#line 1131
            return (-1);
          }
#line 1136
          if (sizeof(rate) == sizeof(float )) {
            {
#line 1136
            tmp___10 = __isnanf((float )rate);
#line 1136
            tmp___14 = tmp___10;
            }
          } else {
#line 1136
            if (sizeof(rate) == sizeof(double )) {
              {
#line 1136
              tmp___11 = __isnan(rate);
#line 1136
              tmp___13 = tmp___11;
              }
            } else {
              {
#line 1136
              tmp___12 = __isnanl((long double )rate);
#line 1136
              tmp___13 = tmp___12;
              }
            }
#line 1136
            tmp___14 = tmp___13;
          }
#line 1136
          if (! tmp___14) {
#line 1136
            if (sizeof((rrd->ds_def + ds_idx)->par[2].u_val) == sizeof(float )) {
              {
#line 1136
              tmp___15 = __isnanf((float )(rrd->ds_def + ds_idx)->par[2].u_val);
#line 1136
              tmp___19 = tmp___15;
              }
            } else {
#line 1136
              if (sizeof((rrd->ds_def + ds_idx)->par[2].u_val) == sizeof(double )) {
                {
#line 1136
                tmp___16 = __isnan((rrd->ds_def + ds_idx)->par[2].u_val);
#line 1136
                tmp___18 = tmp___16;
                }
              } else {
                {
#line 1136
                tmp___17 = __isnanl((long double )(rrd->ds_def + ds_idx)->par[2].u_val);
#line 1136
                tmp___18 = tmp___17;
                }
              }
#line 1136
              tmp___19 = tmp___18;
            }
#line 1136
            if (tmp___19) {
              _L___0: /* CIL Label */ 
#line 1136
              if (sizeof((rrd->ds_def + ds_idx)->par[1].u_val) == sizeof(float )) {
                {
#line 1136
                tmp___20 = __isnanf((float )(rrd->ds_def + ds_idx)->par[1].u_val);
#line 1136
                tmp___24 = tmp___20;
                }
              } else {
#line 1136
                if (sizeof((rrd->ds_def + ds_idx)->par[1].u_val) == sizeof(double )) {
                  {
#line 1136
                  tmp___21 = __isnan((rrd->ds_def + ds_idx)->par[1].u_val);
#line 1136
                  tmp___23 = tmp___21;
                  }
                } else {
                  {
#line 1136
                  tmp___22 = __isnanl((long double )(rrd->ds_def + ds_idx)->par[1].u_val);
#line 1136
                  tmp___23 = tmp___22;
                  }
                }
#line 1136
                tmp___24 = tmp___23;
              }
#line 1136
              if (! tmp___24) {
#line 1136
                if (rate < (rrd->ds_def + ds_idx)->par[1].u_val) {
                  {
#line 1141
                  *(pdp_new + ds_idx) = rrd_set_to_DNAN();
                  }
                }
              }
            } else
#line 1136
            if (rate > (rrd->ds_def + ds_idx)->par[2].u_val) {
              {
#line 1141
              *(pdp_new + ds_idx) = rrd_set_to_DNAN();
              }
            } else {
#line 1136
              goto _L___0;
            }
          }
        } else {
          {
#line 1145
          *(pdp_new + ds_idx) = rrd_set_to_DNAN();
          }
        }
      } else {
        {
#line 1145
        *(pdp_new + ds_idx) = rrd_set_to_DNAN();
        }
      }
    } else {
      {
#line 1145
      *(pdp_new + ds_idx) = rrd_set_to_DNAN();
      }
    }
    {
#line 1158
    strncpy((char */* __restrict  */)((rrd->pdp_prep + ds_idx)->last_ds), (char const   */* __restrict  */)*(updvals + (ds_idx + 1UL)),
            (size_t )29);
#line 1160
    (rrd->pdp_prep + ds_idx)->last_ds[29] = (char )'\000';
#line 1025
    ds_idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1162
  return (0);
}
}
#line 1170 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int calculate_elapsed_steps(rrd_t *rrd , unsigned long current_time , unsigned long current_time_usec ,
                                   double interval , double *pre_int , double *post_int ,
                                   unsigned long *proc_pdp_cnt ) 
{ 
  unsigned long proc_pdp_st ;
  unsigned long occu_pdp_st ;
  unsigned long proc_pdp_age ;
  unsigned long occu_pdp_age ;

  {
#line 1187
  proc_pdp_age = (unsigned long )(rrd->live_head)->last_up % (rrd->stat_head)->pdp_step;
#line 1188
  proc_pdp_st = (unsigned long )(rrd->live_head)->last_up - proc_pdp_age;
#line 1191
  occu_pdp_age = current_time % (rrd->stat_head)->pdp_step;
#line 1192
  occu_pdp_st = current_time - occu_pdp_age;
#line 1194
  if (occu_pdp_st > proc_pdp_st) {
#line 1196
    *pre_int = (double )((long )occu_pdp_st - (rrd->live_head)->last_up);
#line 1199
    *pre_int -= (double )(rrd->live_head)->last_up_usec / (double )1e6f;
#line 1200
    *post_int = (double )occu_pdp_age;
#line 1201
    *post_int += (double )current_time_usec / (double )1e6f;
  } else {
#line 1203
    *pre_int = interval;
#line 1204
    *post_int = (double )0;
  }
#line 1207
  *proc_pdp_cnt = proc_pdp_st / (rrd->stat_head)->pdp_step;
#line 1221
  return ((int )((occu_pdp_st - proc_pdp_st) / (rrd->stat_head)->pdp_step));
}
}
#line 1227 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static void simple_update(rrd_t *rrd , double interval , rrd_value_t *pdp_new ) 
{ 
  int i ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1234
  i = 0;
  {
#line 1234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1234
    if (! (i < (int )(rrd->stat_head)->ds_cnt)) {
#line 1234
      goto while_break;
    }
#line 1235
    if (sizeof(*(pdp_new + i)) == sizeof(float )) {
      {
#line 1235
      tmp___5 = __isnanf((float )*(pdp_new + i));
#line 1235
      tmp___9 = tmp___5;
      }
    } else {
#line 1235
      if (sizeof(*(pdp_new + i)) == sizeof(double )) {
        {
#line 1235
        tmp___6 = __isnan(*(pdp_new + i));
#line 1235
        tmp___8 = tmp___6;
        }
      } else {
        {
#line 1235
        tmp___7 = __isnanl((long double )*(pdp_new + i));
#line 1235
        tmp___8 = tmp___7;
        }
      }
#line 1235
      tmp___9 = tmp___8;
    }
#line 1235
    if (tmp___9) {
      {
#line 1239
      tmp = floor(interval);
#line 1239
      (rrd->pdp_prep + i)->scratch[0].u_cnt = (unsigned long )((double )(rrd->pdp_prep + i)->scratch[0].u_cnt + tmp);
      }
    } else {
#line 1242
      if (sizeof((rrd->pdp_prep + i)->scratch[1].u_val) == sizeof(float )) {
        {
#line 1242
        tmp___0 = __isnanf((float )(rrd->pdp_prep + i)->scratch[1].u_val);
#line 1242
        tmp___4 = tmp___0;
        }
      } else {
#line 1242
        if (sizeof((rrd->pdp_prep + i)->scratch[1].u_val) == sizeof(double )) {
          {
#line 1242
          tmp___1 = __isnan((rrd->pdp_prep + i)->scratch[1].u_val);
#line 1242
          tmp___3 = tmp___1;
          }
        } else {
          {
#line 1242
          tmp___2 = __isnanl((long double )(rrd->pdp_prep + i)->scratch[1].u_val);
#line 1242
          tmp___3 = tmp___2;
          }
        }
#line 1242
        tmp___4 = tmp___3;
      }
#line 1242
      if (tmp___4) {
#line 1243
        (rrd->pdp_prep + i)->scratch[1].u_val = *(pdp_new + i);
      } else {
#line 1245
        (rrd->pdp_prep + i)->scratch[1].u_val += *(pdp_new + i);
      }
    }
#line 1234
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1258
  return;
}
}
#line 1265 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int process_all_pdp_st(rrd_t *rrd , double interval , double pre_int , double post_int ,
                              unsigned long elapsed_pdp_st , rrd_value_t *pdp_new ,
                              rrd_value_t *pdp_temp ) 
{ 
  unsigned long ds_idx ;
  int tmp ;

  {
#line 1281
  ds_idx = 0UL;
  {
#line 1281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1281
    if (! (ds_idx < (rrd->stat_head)->ds_cnt)) {
#line 1281
      goto while_break;
    }
    {
#line 1282
    tmp = process_pdp_st(rrd, ds_idx, interval, pre_int, post_int, (long )(elapsed_pdp_st * (rrd->stat_head)->pdp_step),
                         pdp_new, pdp_temp);
    }
#line 1282
    if (tmp == -1) {
#line 1285
      return (-1);
    }
#line 1281
    ds_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1300
  return (0);
}
}
#line 1310 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int process_pdp_st(rrd_t *rrd , unsigned long ds_idx , double interval , double pre_int ,
                          double post_int , long diff_pdp_st , rrd_value_t *pdp_new ,
                          rrd_value_t *pdp_temp ) 
{ 
  int i ;
  double pre_unknown ;
  unival *scratch ;
  unsigned long mrhb ;
  rpnstack_t rpnstack ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  rpnp_t *rpnp ;
  short tmp___9 ;
  enum dst_en tmp___10 ;
  double tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 1323
  pre_unknown = 0.0;
#line 1324
  scratch = (rrd->pdp_prep + ds_idx)->scratch;
#line 1325
  mrhb = (rrd->ds_def + ds_idx)->par[0].u_cnt;
#line 1329
  rpnstack_init(& rpnstack);
  }
#line 1332
  if (sizeof(*(pdp_new + ds_idx)) == sizeof(float )) {
    {
#line 1332
    tmp___4 = __isnanf((float )*(pdp_new + ds_idx));
#line 1332
    tmp___8 = tmp___4;
    }
  } else {
#line 1332
    if (sizeof(*(pdp_new + ds_idx)) == sizeof(double )) {
      {
#line 1332
      tmp___5 = __isnan(*(pdp_new + ds_idx));
#line 1332
      tmp___7 = tmp___5;
      }
    } else {
      {
#line 1332
      tmp___6 = __isnanl((long double )*(pdp_new + ds_idx));
#line 1332
      tmp___7 = tmp___6;
      }
    }
#line 1332
    tmp___8 = tmp___7;
  }
#line 1332
  if (tmp___8) {
#line 1336
    pre_unknown = pre_int;
  } else {
#line 1338
    if (sizeof((scratch + 1)->u_val) == sizeof(float )) {
      {
#line 1338
      tmp = __isnanf((float )(scratch + 1)->u_val);
#line 1338
      tmp___3 = tmp;
      }
    } else {
#line 1338
      if (sizeof((scratch + 1)->u_val) == sizeof(double )) {
        {
#line 1338
        tmp___0 = __isnan((scratch + 1)->u_val);
#line 1338
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 1338
        tmp___1 = __isnanl((long double )(scratch + 1)->u_val);
#line 1338
        tmp___2 = tmp___1;
        }
      }
#line 1338
      tmp___3 = tmp___2;
    }
#line 1338
    if (tmp___3) {
#line 1339
      (scratch + 1)->u_val = (rrd_value_t )0;
    }
#line 1341
    (scratch + 1)->u_val += (*(pdp_new + ds_idx) / interval) * pre_int;
  }
#line 1346
  if (interval > (double )mrhb) {
    {
#line 1349
    *(pdp_temp + ds_idx) = rrd_set_to_DNAN();
    }
  } else
#line 1346
  if ((double )(rrd->stat_head)->pdp_step / 2.0 < (double )((int )(scratch + 0)->u_cnt)) {
    {
#line 1349
    *(pdp_temp + ds_idx) = rrd_set_to_DNAN();
    }
  } else {
#line 1351
    *(pdp_temp + ds_idx) = (scratch + 1)->u_val / ((double )((unsigned long )diff_pdp_st - (scratch + 0)->u_cnt) - pre_unknown);
  }
  {
#line 1358
  tmp___10 = dst_conv((rrd->ds_def + ds_idx)->dst);
  }
#line 1358
  if ((unsigned int )tmp___10 == 4U) {
    {
#line 1361
    rpnp = rpn_expand((rpn_cdefds_t *)(& (rrd->ds_def + ds_idx)->par[0]));
    }
#line 1363
    if ((unsigned long )rpnp == (unsigned long )((void *)0)) {
      {
#line 1364
      rpnstack_free(& rpnstack);
      }
#line 1365
      return (-1);
    }
#line 1368
    i = 0;
    {
#line 1368
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1368
      if (! ((unsigned int )(rpnp + i)->op != 32U)) {
#line 1368
        goto while_break;
      }
#line 1369
      if ((unsigned int )(rpnp + i)->op == 1U) {
#line 1370
        (rpnp + i)->op = (enum op_en )0;
#line 1371
        (rpnp + i)->val = *(pdp_temp + (rpnp + i)->ptr);
      }
#line 1368
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1375
    tmp___9 = rpn_calc(rpnp, & rpnstack, 0L, pdp_temp, (int )ds_idx);
    }
#line 1375
    if ((int )tmp___9 == -1) {
      {
#line 1376
      free((void *)rpnp);
#line 1377
      rpnstack_free(& rpnstack);
      }
#line 1378
      return (-1);
    }
    {
#line 1380
    free((void *)rpnp);
    }
  }
#line 1384
  if (sizeof(*(pdp_new + ds_idx)) == sizeof(float )) {
    {
#line 1384
    tmp___12 = __isnanf((float )*(pdp_new + ds_idx));
#line 1384
    tmp___16 = tmp___12;
    }
  } else {
#line 1384
    if (sizeof(*(pdp_new + ds_idx)) == sizeof(double )) {
      {
#line 1384
      tmp___13 = __isnan(*(pdp_new + ds_idx));
#line 1384
      tmp___15 = tmp___13;
      }
    } else {
      {
#line 1384
      tmp___14 = __isnanl((long double )*(pdp_new + ds_idx));
#line 1384
      tmp___15 = tmp___14;
      }
    }
#line 1384
    tmp___16 = tmp___15;
  }
#line 1384
  if (tmp___16) {
    {
#line 1388
    tmp___11 = floor(post_int);
#line 1388
    (scratch + 0)->u_cnt = (unsigned long )tmp___11;
#line 1389
    (scratch + 1)->u_val = rrd_set_to_DNAN();
    }
  } else {
#line 1391
    (scratch + 0)->u_cnt = 0UL;
#line 1392
    (scratch + 1)->u_val = (*(pdp_new + ds_idx) / interval) * post_int;
  }
  {
#line 1394
  rpnstack_free(& rpnstack);
  }
#line 1395
  return (0);
}
}
#line 1406 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int update_all_cdp_prep(rrd_t *rrd , unsigned long *rra_step_cnt , unsigned long rra_begin ,
                               rrd_file_t *rrd_file , unsigned long elapsed_pdp_st ,
                               unsigned long proc_pdp_cnt , rrd_value_t **last_seasonal_coef ,
                               rrd_value_t **seasonal_coef , rrd_value_t *pdp_temp ,
                               unsigned long *skip_update , int *schedule_smooth ) 
{ 
  unsigned long rra_idx ;
  enum cf_en current_cf ;
  unsigned long rra_start ;
  unsigned long start_pdp_offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1428
  rra_start = rra_begin;
#line 1429
  rra_idx = 0UL;
  {
#line 1429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1429
    if (! (rra_idx < (rrd->stat_head)->rra_cnt)) {
#line 1429
      goto while_break;
    }
    {
#line 1430
    current_cf = cf_conv((char const   *)((rrd->rra_def + rra_idx)->cf_nam));
#line 1431
    start_pdp_offset = (rrd->rra_def + rra_idx)->pdp_cnt - proc_pdp_cnt % (rrd->rra_def + rra_idx)->pdp_cnt;
#line 1434
    *(skip_update + rra_idx) = 0UL;
    }
#line 1435
    if (start_pdp_offset <= elapsed_pdp_st) {
#line 1436
      *(rra_step_cnt + rra_idx) = (elapsed_pdp_st - start_pdp_offset) / (rrd->rra_def + rra_idx)->pdp_cnt + 1UL;
    } else {
#line 1439
      *(rra_step_cnt + rra_idx) = 0UL;
    }
#line 1442
    if ((unsigned int )current_cf == 5U) {
#line 1442
      goto _L;
    } else
#line 1442
    if ((unsigned int )current_cf == 7U) {
      _L: /* CIL Label */ 
#line 1447
      if (*(rra_step_cnt + rra_idx) > 1UL) {
        {
#line 1448
        *(skip_update + rra_idx) = 1UL;
#line 1449
        lookup_seasonal(rrd, rra_idx, rra_start, rrd_file, elapsed_pdp_st, last_seasonal_coef);
#line 1451
        lookup_seasonal(rrd, rra_idx, rra_start, rrd_file, elapsed_pdp_st + 1UL, seasonal_coef);
        }
      }
      {
#line 1455
      tmp = do_schedule_smooth(rrd, rra_idx, elapsed_pdp_st);
      }
#line 1455
      if (tmp) {
#line 1463
        *schedule_smooth = 1;
      }
    }
    {
#line 1466
    tmp___0 = rrd_test_error();
    }
#line 1466
    if (tmp___0) {
#line 1467
      return (-1);
    }
    {
#line 1469
    tmp___1 = update_cdp_prep(rrd, elapsed_pdp_st, start_pdp_offset, rra_step_cnt,
                              (int )rra_idx, pdp_temp, *last_seasonal_coef, *seasonal_coef,
                              (int )current_cf);
    }
#line 1469
    if (tmp___1 == -1) {
#line 1473
      return (-1);
    }
#line 1475
    rra_start += ((rrd->rra_def + rra_idx)->row_cnt * (rrd->stat_head)->ds_cnt) * sizeof(rrd_value_t );
#line 1429
    rra_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1479
  return (0);
}
}
#line 1485 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int do_schedule_smooth(rrd_t *rrd , unsigned long rra_idx , unsigned long elapsed_pdp_st ) 
{ 
  unsigned long cdp_idx ;
  unsigned long cur_row ;
  unsigned long row_cnt ;
  unsigned long seasonal_smooth_idx ;
  unsigned long *init_seasonal ;
  int tmp ;
  int tmp___0 ;

  {
#line 1490
  cdp_idx = rra_idx * (rrd->stat_head)->ds_cnt;
#line 1491
  cur_row = (rrd->rra_ptr + rra_idx)->cur_row;
#line 1492
  row_cnt = (rrd->rra_def + rra_idx)->row_cnt;
#line 1493
  seasonal_smooth_idx = (rrd->rra_def + rra_idx)->par[4].u_cnt;
#line 1495
  init_seasonal = & (rrd->cdp_prep + cdp_idx)->scratch[6].u_cnt;
#line 1502
  if (*init_seasonal > 3UL) {
#line 1505
    if (seasonal_smooth_idx > cur_row) {
#line 1508
      return (cur_row + elapsed_pdp_st >= seasonal_smooth_idx);
    }
#line 1512
    if (cur_row + elapsed_pdp_st >= row_cnt) {
#line 1512
      if (cur_row + elapsed_pdp_st >= row_cnt + seasonal_smooth_idx) {
#line 1512
        tmp = 1;
      } else {
#line 1512
        tmp = 0;
      }
    } else {
#line 1512
      tmp = 0;
    }
#line 1512
    return (tmp);
  }
#line 1516
  if (cur_row + elapsed_pdp_st >= row_cnt) {
#line 1516
    (*init_seasonal) ++;
#line 1516
    if (*init_seasonal) {
#line 1516
      tmp___0 = 1;
    } else {
#line 1516
      tmp___0 = 0;
    }
  } else {
#line 1516
    tmp___0 = 0;
  }
#line 1516
  return (tmp___0);
}
}
#line 1525 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int update_cdp_prep(rrd_t *rrd , unsigned long elapsed_pdp_st , unsigned long start_pdp_offset ,
                           unsigned long *rra_step_cnt , int rra_idx , rrd_value_t *pdp_temp ,
                           rrd_value_t *last_seasonal_coef , rrd_value_t *seasonal_coef ,
                           int current_cf ) 
{ 
  unsigned long ds_idx ;
  unsigned long cdp_idx ;
  int tmp ;

  {
#line 1540
  ds_idx = 0UL;
  {
#line 1540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1540
    if (! (ds_idx < (rrd->stat_head)->ds_cnt)) {
#line 1540
      goto while_break;
    }
#line 1542
    cdp_idx = (unsigned long )rra_idx * (rrd->stat_head)->ds_cnt + ds_idx;
#line 1544
    if ((rrd->rra_def + rra_idx)->pdp_cnt > 1UL) {
      {
#line 1545
      update_cdp((rrd->cdp_prep + cdp_idx)->scratch, current_cf, *(pdp_temp + ds_idx),
                 *(rra_step_cnt + rra_idx), elapsed_pdp_st, start_pdp_offset, (rrd->rra_def + rra_idx)->pdp_cnt,
                 (rrd->rra_def + rra_idx)->par[0].u_val, rra_idx, (int )ds_idx);
      }
    } else
#line 1554
    if (elapsed_pdp_st > 2UL) {
      {
#line 1555
      reset_cdp(rrd, elapsed_pdp_st, pdp_temp, last_seasonal_coef, seasonal_coef,
                rra_idx, (int )ds_idx, (int )cdp_idx, (enum cf_en )current_cf);
      }
    }
    {
#line 1561
    tmp = rrd_test_error();
    }
#line 1561
    if (tmp) {
#line 1562
      return (-1);
    }
#line 1540
    ds_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1564
  return (0);
}
}
#line 1571 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static void update_cdp(unival *scratch , int current_cf , rrd_value_t pdp_temp_val ,
                       unsigned long rra_step_cnt , unsigned long elapsed_pdp_st ,
                       unsigned long start_pdp_offset , unsigned long pdp_cnt , rrd_value_t xff ,
                       int i , int ii ) 
{ 
  rrd_value_t *cdp_val ;
  rrd_value_t *cdp_primary_val ;
  rrd_value_t *cdp_secondary_val ;
  unsigned long *cdp_unkn_pdp_cnt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1584
  cdp_val = & (scratch + 0)->u_val;
#line 1585
  cdp_primary_val = & (scratch + 8)->u_val;
#line 1586
  cdp_secondary_val = & (scratch + 9)->u_val;
#line 1587
  cdp_unkn_pdp_cnt = & (scratch + 1)->u_cnt;
#line 1589
  if (rra_step_cnt) {
#line 1594
    if (sizeof(pdp_temp_val) == sizeof(float )) {
      {
#line 1594
      tmp = __isnanf((float )pdp_temp_val);
#line 1594
      tmp___3 = tmp;
      }
    } else {
#line 1594
      if (sizeof(pdp_temp_val) == sizeof(double )) {
        {
#line 1594
        tmp___0 = __isnan(pdp_temp_val);
#line 1594
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 1594
        tmp___1 = __isnanl((long double )pdp_temp_val);
#line 1594
        tmp___2 = tmp___1;
        }
      }
#line 1594
      tmp___3 = tmp___2;
    }
#line 1594
    if (tmp___3) {
      {
#line 1595
      *cdp_unkn_pdp_cnt += start_pdp_offset;
#line 1596
      *cdp_secondary_val = rrd_set_to_DNAN();
      }
    } else {
#line 1602
      *cdp_secondary_val = pdp_temp_val;
    }
#line 1605
    if ((rrd_value_t )*cdp_unkn_pdp_cnt > (rrd_value_t )pdp_cnt * xff) {
      {
#line 1606
      *cdp_primary_val = rrd_set_to_DNAN();
      }
    } else {
      {
#line 1608
      initialize_cdp_val(scratch, current_cf, pdp_temp_val, start_pdp_offset, pdp_cnt);
      }
    }
    {
#line 1611
    *cdp_val = initialize_carry_over(pdp_temp_val, current_cf, elapsed_pdp_st, start_pdp_offset,
                                     pdp_cnt);
    }
#line 1618
    if (sizeof(pdp_temp_val) == sizeof(float )) {
      {
#line 1618
      tmp___4 = __isnanf((float )pdp_temp_val);
#line 1618
      tmp___8 = tmp___4;
      }
    } else {
#line 1618
      if (sizeof(pdp_temp_val) == sizeof(double )) {
        {
#line 1618
        tmp___5 = __isnan(pdp_temp_val);
#line 1618
        tmp___7 = tmp___5;
        }
      } else {
        {
#line 1618
        tmp___6 = __isnanl((long double )pdp_temp_val);
#line 1618
        tmp___7 = tmp___6;
        }
      }
#line 1618
      tmp___8 = tmp___7;
    }
#line 1618
    if (tmp___8) {
#line 1619
      *cdp_unkn_pdp_cnt = (elapsed_pdp_st - start_pdp_offset) % pdp_cnt;
    } else {
#line 1621
      *cdp_unkn_pdp_cnt = 0UL;
    }
  } else {
#line 1633
    if (sizeof(pdp_temp_val) == sizeof(float )) {
      {
#line 1633
      tmp___9 = __isnanf((float )pdp_temp_val);
#line 1633
      tmp___13 = tmp___9;
      }
    } else {
#line 1633
      if (sizeof(pdp_temp_val) == sizeof(double )) {
        {
#line 1633
        tmp___10 = __isnan(pdp_temp_val);
#line 1633
        tmp___12 = tmp___10;
        }
      } else {
        {
#line 1633
        tmp___11 = __isnanl((long double )pdp_temp_val);
#line 1633
        tmp___12 = tmp___11;
        }
      }
#line 1633
      tmp___13 = tmp___12;
    }
#line 1633
    if (tmp___13) {
#line 1634
      *cdp_unkn_pdp_cnt += elapsed_pdp_st;
    } else {
      {
#line 1636
      *cdp_val = calculate_cdp_val(*cdp_val, pdp_temp_val, elapsed_pdp_st, current_cf,
                                   i, ii);
      }
    }
  }
#line 1641
  return;
}
}
#line 1647 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static void initialize_cdp_val(unival *scratch , int current_cf , rrd_value_t pdp_temp_val ,
                               unsigned long start_pdp_offset , unsigned long pdp_cnt ) 
{ 
  rrd_value_t cum_val ;
  rrd_value_t cur_val ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  double tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  double tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  double tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  double tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;

  {
  {
#line 1657
  if (current_cf == 0) {
#line 1657
    goto case_0;
  }
#line 1664
  if (current_cf == 2) {
#line 1664
    goto case_2;
  }
#line 1683
  if (current_cf == 1) {
#line 1683
    goto case_1;
  }
#line 1702
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1658
  if (sizeof((scratch + 0)->u_val) == sizeof(float )) {
    {
#line 1658
    tmp___4 = __isnanf((float )(scratch + 0)->u_val);
#line 1658
    tmp___8 = tmp___4;
    }
  } else {
#line 1658
    if (sizeof((scratch + 0)->u_val) == sizeof(double )) {
      {
#line 1658
      tmp___5 = __isnan((scratch + 0)->u_val);
#line 1658
      tmp___7 = tmp___5;
      }
    } else {
      {
#line 1658
      tmp___6 = __isnanl((long double )(scratch + 0)->u_val);
#line 1658
      tmp___7 = tmp___6;
      }
    }
#line 1658
    tmp___8 = tmp___7;
  }
#line 1658
  if (tmp___8) {
#line 1658
    cum_val = 0.0;
  } else {
#line 1658
    cum_val = (scratch + 0)->u_val;
  }
#line 1659
  if (sizeof(pdp_temp_val) == sizeof(float )) {
    {
#line 1659
    tmp___14 = __isnanf((float )pdp_temp_val);
#line 1659
    tmp___18 = tmp___14;
    }
  } else {
#line 1659
    if (sizeof(pdp_temp_val) == sizeof(double )) {
      {
#line 1659
      tmp___15 = __isnan(pdp_temp_val);
#line 1659
      tmp___17 = tmp___15;
      }
    } else {
      {
#line 1659
      tmp___16 = __isnanl((long double )pdp_temp_val);
#line 1659
      tmp___17 = tmp___16;
      }
    }
#line 1659
    tmp___18 = tmp___17;
  }
#line 1659
  if (tmp___18) {
#line 1659
    cur_val = 0.0;
  } else {
#line 1659
    cur_val = pdp_temp_val;
  }
#line 1660
  (scratch + 8)->u_val = (cum_val + cur_val * (rrd_value_t )start_pdp_offset) / (rrd_value_t )(pdp_cnt - (scratch + 1)->u_cnt);
#line 1663
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1665
  if (sizeof((scratch + 0)->u_val) == sizeof(float )) {
    {
#line 1665
    tmp___25 = __isnanf((float )(scratch + 0)->u_val);
#line 1665
    tmp___29 = tmp___25;
    }
  } else {
#line 1665
    if (sizeof((scratch + 0)->u_val) == sizeof(double )) {
      {
#line 1665
      tmp___26 = __isnan((scratch + 0)->u_val);
#line 1665
      tmp___28 = tmp___26;
      }
    } else {
      {
#line 1665
      tmp___27 = __isnanl((long double )(scratch + 0)->u_val);
#line 1665
      tmp___28 = tmp___27;
      }
    }
#line 1665
    tmp___29 = tmp___28;
  }
#line 1665
  if (tmp___29) {
    {
#line 1665
    tmp___24 = rrd_set_to_DINF();
#line 1665
    cum_val = - tmp___24;
    }
  } else {
#line 1665
    cum_val = (scratch + 0)->u_val;
  }
#line 1666
  if (sizeof(pdp_temp_val) == sizeof(float )) {
    {
#line 1666
    tmp___36 = __isnanf((float )pdp_temp_val);
#line 1666
    tmp___40 = tmp___36;
    }
  } else {
#line 1666
    if (sizeof(pdp_temp_val) == sizeof(double )) {
      {
#line 1666
      tmp___37 = __isnan(pdp_temp_val);
#line 1666
      tmp___39 = tmp___37;
      }
    } else {
      {
#line 1666
      tmp___38 = __isnanl((long double )pdp_temp_val);
#line 1666
      tmp___39 = tmp___38;
      }
    }
#line 1666
    tmp___40 = tmp___39;
  }
#line 1666
  if (tmp___40) {
    {
#line 1666
    tmp___35 = rrd_set_to_DINF();
#line 1666
    cur_val = - tmp___35;
    }
  } else {
#line 1666
    cur_val = pdp_temp_val;
  }
#line 1678
  if (cur_val > cum_val) {
#line 1679
    (scratch + 8)->u_val = cur_val;
  } else {
#line 1681
    (scratch + 8)->u_val = cum_val;
  }
#line 1682
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1684
  if (sizeof((scratch + 0)->u_val) == sizeof(float )) {
    {
#line 1684
    tmp___47 = __isnanf((float )(scratch + 0)->u_val);
#line 1684
    tmp___51 = tmp___47;
    }
  } else {
#line 1684
    if (sizeof((scratch + 0)->u_val) == sizeof(double )) {
      {
#line 1684
      tmp___48 = __isnan((scratch + 0)->u_val);
#line 1684
      tmp___50 = tmp___48;
      }
    } else {
      {
#line 1684
      tmp___49 = __isnanl((long double )(scratch + 0)->u_val);
#line 1684
      tmp___50 = tmp___49;
      }
    }
#line 1684
    tmp___51 = tmp___50;
  }
#line 1684
  if (tmp___51) {
    {
#line 1684
    tmp___46 = rrd_set_to_DINF();
#line 1684
    cum_val = tmp___46;
    }
  } else {
#line 1684
    cum_val = (scratch + 0)->u_val;
  }
#line 1685
  if (sizeof(pdp_temp_val) == sizeof(float )) {
    {
#line 1685
    tmp___58 = __isnanf((float )pdp_temp_val);
#line 1685
    tmp___62 = tmp___58;
    }
  } else {
#line 1685
    if (sizeof(pdp_temp_val) == sizeof(double )) {
      {
#line 1685
      tmp___59 = __isnan(pdp_temp_val);
#line 1685
      tmp___61 = tmp___59;
      }
    } else {
      {
#line 1685
      tmp___60 = __isnanl((long double )pdp_temp_val);
#line 1685
      tmp___61 = tmp___60;
      }
    }
#line 1685
    tmp___62 = tmp___61;
  }
#line 1685
  if (tmp___62) {
    {
#line 1685
    tmp___57 = rrd_set_to_DINF();
#line 1685
    cur_val = tmp___57;
    }
  } else {
#line 1685
    cur_val = pdp_temp_val;
  }
#line 1696
  if (cur_val < cum_val) {
#line 1697
    (scratch + 8)->u_val = cur_val;
  } else {
#line 1699
    (scratch + 8)->u_val = cum_val;
  }
#line 1700
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1703
  (scratch + 8)->u_val = pdp_temp_val;
#line 1704
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1706
  return;
}
}
#line 1713 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static void reset_cdp(rrd_t *rrd , unsigned long elapsed_pdp_st , rrd_value_t *pdp_temp ,
                      rrd_value_t *last_seasonal_coef , rrd_value_t *seasonal_coef ,
                      int rra_idx , int ds_idx , int cdp_idx , enum cf_en current_cf ) 
{ 
  unival *scratch ;

  {
#line 1724
  scratch = (rrd->cdp_prep + cdp_idx)->scratch;
  {
#line 1733
  if ((unsigned int )current_cf == 7U) {
#line 1733
    goto case_7;
  }
#line 1733
  if ((unsigned int )current_cf == 5U) {
#line 1733
    goto case_7;
  }
#line 1742
  if ((unsigned int )current_cf == 9U) {
#line 1742
    goto case_9;
  }
#line 1742
  if ((unsigned int )current_cf == 4U) {
#line 1742
    goto case_9;
  }
#line 1749
  if ((unsigned int )current_cf == 6U) {
#line 1749
    goto case_6;
  }
#line 1753
  if ((unsigned int )current_cf == 8U) {
#line 1753
    goto case_8;
  }
#line 1728
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1729
  (scratch + 8)->u_val = *(pdp_temp + ds_idx);
#line 1730
  (scratch + 9)->u_val = *(pdp_temp + ds_idx);
#line 1731
  goto switch_break;
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1738
  (scratch + 3)->u_val = *(last_seasonal_coef + ds_idx);
#line 1739
  (scratch + 2)->u_val = *(seasonal_coef + ds_idx);
#line 1740
  goto switch_break;
  case_9: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1746
  (scratch + 6)->u_cnt += elapsed_pdp_st;
#line 1747
  (scratch + 7)->u_cnt += elapsed_pdp_st - 1UL;
  case_6: /* CIL Label */ 
  {
#line 1750
  (scratch + 8)->u_val = rrd_set_to_DNAN();
#line 1751
  (scratch + 9)->u_val = rrd_set_to_DNAN();
  }
#line 1752
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1755
  (scratch + 8)->u_val = (rrd_value_t )0;
#line 1756
  (scratch + 9)->u_val = (rrd_value_t )0;
#line 1760
  erase_violations(rrd, (unsigned long )cdp_idx, (unsigned long )rra_idx);
  }
#line 1761
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1763
  return;
}
}
#line 1765 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static rrd_value_t initialize_carry_over(rrd_value_t pdp_temp_val , int current_cf ,
                                         unsigned long elapsed_pdp_st , unsigned long start_pdp_offset ,
                                         unsigned long pdp_cnt ) 
{ 
  unsigned long pdp_into_cdp_cnt ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1772
  pdp_into_cdp_cnt = (elapsed_pdp_st - start_pdp_offset) % pdp_cnt;
#line 1773
  if (pdp_into_cdp_cnt == 0UL) {
#line 1773
    goto _L;
  } else {
#line 1773
    if (sizeof(pdp_temp_val) == sizeof(float )) {
      {
#line 1773
      tmp___2 = __isnanf((float )pdp_temp_val);
#line 1773
      tmp___6 = tmp___2;
      }
    } else {
#line 1773
      if (sizeof(pdp_temp_val) == sizeof(double )) {
        {
#line 1773
        tmp___3 = __isnan(pdp_temp_val);
#line 1773
        tmp___5 = tmp___3;
        }
      } else {
        {
#line 1773
        tmp___4 = __isnanl((long double )pdp_temp_val);
#line 1773
        tmp___5 = tmp___4;
        }
      }
#line 1773
      tmp___6 = tmp___5;
    }
#line 1773
    if (tmp___6) {
      _L: /* CIL Label */ 
      {
#line 1775
      if (current_cf == 2) {
#line 1775
        goto case_2;
      }
#line 1777
      if (current_cf == 1) {
#line 1777
        goto case_1;
      }
#line 1779
      if (current_cf == 0) {
#line 1779
        goto case_0;
      }
#line 1781
      goto switch_default;
      case_2: /* CIL Label */ 
      {
#line 1776
      tmp = rrd_set_to_DINF();
      }
#line 1776
      return (- tmp);
      case_1: /* CIL Label */ 
      {
#line 1778
      tmp___0 = rrd_set_to_DINF();
      }
#line 1778
      return (tmp___0);
      case_0: /* CIL Label */ 
#line 1780
      return ((rrd_value_t )0);
      switch_default: /* CIL Label */ 
      {
#line 1782
      tmp___1 = rrd_set_to_DNAN();
      }
#line 1782
      return (tmp___1);
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1787
      if (current_cf == 0) {
#line 1787
        goto case_0___0;
      }
#line 1789
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
#line 1788
      return (pdp_temp_val * (rrd_value_t )pdp_into_cdp_cnt);
      switch_default___0: /* CIL Label */ 
#line 1790
      return (pdp_temp_val);
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
}
}
#line 1801 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static rrd_value_t calculate_cdp_val(rrd_value_t cdp_val , rrd_value_t pdp_temp_val ,
                                     unsigned long elapsed_pdp_st , int current_cf ,
                                     int i  __attribute__((__unused__)) , int ii  __attribute__((__unused__)) ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  rrd_value_t tmp___4 ;
  rrd_value_t tmp___5 ;

  {
#line 1815
  if (sizeof(cdp_val) == sizeof(float )) {
    {
#line 1815
    tmp = __isnanf((float )cdp_val);
#line 1815
    tmp___3 = tmp;
    }
  } else {
#line 1815
    if (sizeof(cdp_val) == sizeof(double )) {
      {
#line 1815
      tmp___0 = __isnan(cdp_val);
#line 1815
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 1815
      tmp___1 = __isnanl((long double )cdp_val);
#line 1815
      tmp___2 = tmp___1;
      }
    }
#line 1815
    tmp___3 = tmp___2;
  }
#line 1815
  if (tmp___3) {
#line 1816
    if (current_cf == 0) {
#line 1817
      pdp_temp_val *= (rrd_value_t )elapsed_pdp_st;
    }
#line 1823
    return (pdp_temp_val);
  }
#line 1825
  if (current_cf == 0) {
#line 1826
    return (cdp_val + pdp_temp_val * (rrd_value_t )elapsed_pdp_st);
  }
#line 1827
  if (current_cf == 1) {
#line 1828
    if (pdp_temp_val < cdp_val) {
#line 1828
      tmp___4 = pdp_temp_val;
    } else {
#line 1828
      tmp___4 = cdp_val;
    }
#line 1828
    return (tmp___4);
  }
#line 1829
  if (current_cf == 2) {
#line 1830
    if (pdp_temp_val > cdp_val) {
#line 1830
      tmp___5 = pdp_temp_val;
    } else {
#line 1830
      tmp___5 = cdp_val;
    }
#line 1830
    return (tmp___5);
  }
#line 1832
  return (pdp_temp_val);
}
}
#line 1841 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int update_aberrant_cdps(rrd_t *rrd , rrd_file_t *rrd_file , unsigned long rra_begin ,
                                unsigned long elapsed_pdp_st , rrd_value_t *pdp_temp ,
                                rrd_value_t **seasonal_coef ) 
{ 
  unsigned long rra_idx ;
  unsigned long ds_idx ;
  unsigned long j ;
  unsigned short scratch_idx ;
  unsigned long rra_start ;
  enum cf_en current_cf ;
  int tmp ;

  {
#line 1859
  j = elapsed_pdp_st;
#line 1859
  scratch_idx = (unsigned short)8;
  {
#line 1859
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1859
    if (j > 0UL) {
#line 1859
      if (! (j < 3UL)) {
#line 1859
        goto while_break;
      }
    } else {
#line 1859
      goto while_break;
    }
#line 1861
    rra_start = rra_begin;
#line 1862
    rra_idx = 0UL;
    {
#line 1862
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1862
      if (! (rra_idx < (rrd->stat_head)->rra_cnt)) {
#line 1862
        goto while_break___0;
      }
#line 1863
      if ((rrd->rra_def + rra_idx)->pdp_cnt == 1UL) {
        {
#line 1864
        current_cf = cf_conv((char const   *)((rrd->rra_def + rra_idx)->cf_nam));
        }
#line 1865
        if ((unsigned int )current_cf == 5U) {
#line 1865
          goto _L;
        } else
#line 1865
        if ((unsigned int )current_cf == 7U) {
          _L: /* CIL Label */ 
#line 1866
          if ((int )scratch_idx == 8) {
            {
#line 1867
            lookup_seasonal(rrd, rra_idx, rra_start, rrd_file, elapsed_pdp_st + 1UL,
                            seasonal_coef);
            }
          } else {
            {
#line 1870
            lookup_seasonal(rrd, rra_idx, rra_start, rrd_file, elapsed_pdp_st + 2UL,
                            seasonal_coef);
            }
          }
        }
        {
#line 1874
        tmp = rrd_test_error();
        }
#line 1874
        if (tmp) {
#line 1875
          return (-1);
        }
#line 1877
        ds_idx = 0UL;
        {
#line 1877
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1877
          if (! (ds_idx < (rrd->stat_head)->ds_cnt)) {
#line 1877
            goto while_break___1;
          }
          {
#line 1878
          update_aberrant_CF(rrd, *(pdp_temp + ds_idx), current_cf, rra_idx * (rrd->stat_head)->ds_cnt + ds_idx,
                             rra_idx, ds_idx, scratch_idx, *seasonal_coef);
#line 1877
          ds_idx ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1884
      rra_start += ((rrd->rra_def + rra_idx)->row_cnt * (rrd->stat_head)->ds_cnt) * sizeof(rrd_value_t );
#line 1862
      rra_idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1859
    j --;
#line 1859
    scratch_idx = (unsigned short)9;
  }
  while_break: /* CIL Label */ ;
  }
#line 1888
  return (0);
}
}
#line 1898 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int write_to_rras(rrd_t *rrd , rrd_file_t *rrd_file , unsigned long *rra_step_cnt ,
                         unsigned long rra_begin , time_t current_time , unsigned long *skip_update ,
                         rrd_info_t **pcdp_summary ) 
{ 
  unsigned long rra_idx ;
  unsigned long rra_start ;
  time_t rra_time ;
  unsigned long ds_cnt ;
  rra_def_t *rra_def ;
  rra_ptr_t *rra_ptr ;
  unsigned short scratch_idx ;
  unsigned long step_subtract ;
  size_t rra_pos_new ;
  off_t tmp ;
  unsigned long step_time ;
  int tmp___0 ;
  char *__cil_tmp20 ;

  {
#line 1909
  rra_time = (time_t )0;
#line 1911
  ds_cnt = (rrd->stat_head)->ds_cnt;
#line 1914
  rra_start = rra_begin;
#line 1916
  rra_idx = 0UL;
  {
#line 1916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1916
    if (! (rra_idx < (rrd->stat_head)->rra_cnt)) {
#line 1916
      goto while_break;
    }
#line 1917
    rra_def = rrd->rra_def + rra_idx;
#line 1918
    rra_ptr = rrd->rra_ptr + rra_idx;
#line 1924
    scratch_idx = (unsigned short)8;
#line 1924
    step_subtract = 1UL;
    {
#line 1924
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1924
      if (! (*(rra_step_cnt + rra_idx) > 0UL)) {
#line 1924
        goto while_break___0;
      }
#line 1936
      (rra_ptr->cur_row) ++;
#line 1936
      if (rra_ptr->cur_row >= rra_def->row_cnt) {
#line 1937
        rra_ptr->cur_row = 0UL;
      }
#line 1940
      rra_pos_new = rra_start + (ds_cnt * rra_ptr->cur_row) * sizeof(rrd_value_t );
#line 1944
      if (rra_pos_new != rrd_file->pos) {
        {
#line 1945
        tmp = rrd_seek(rrd_file, (off_t )rra_pos_new, 0);
        }
#line 1945
        if (tmp != 0L) {
          {
#line 1946
          rrd_set_error((char *)"seek error in rrd");
          }
#line 1947
          return (-1);
        }
      }
#line 1954
      if (*(skip_update + rra_idx)) {
#line 1955
        goto __Cont;
      }
#line 1957
      if ((unsigned long )*pcdp_summary != (unsigned long )((void *)0)) {
#line 1958
        step_time = rra_def->pdp_cnt * (rrd->stat_head)->pdp_step;
#line 1960
        rra_time = (time_t )(((unsigned long )current_time - (unsigned long )current_time % step_time) - (*(rra_step_cnt + rra_idx) - step_subtract) * step_time);
      }
      {
#line 1964
      tmp___0 = write_RRA_row(rrd_file, rrd, rra_idx, scratch_idx, pcdp_summary, rra_time);
      }
#line 1964
      if (tmp___0 == -1) {
#line 1967
        return (-1);
      }
      {
#line 1969
      rrd_notify_row(rrd_file, (int )rra_idx, rra_pos_new, rra_time);
      }
      __Cont: /* CIL Label */ 
#line 1924
      (*(rra_step_cnt + rra_idx)) --;
#line 1924
      scratch_idx = (unsigned short)9;
#line 1924
      step_subtract = 2UL;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1972
    rra_start += (rra_def->row_cnt * ds_cnt) * sizeof(rrd_value_t );
#line 1916
    rra_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1975
  return (0);
}
}
#line 1983 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int write_RRA_row(rrd_file_t *rrd_file , rrd_t *rrd , unsigned long rra_idx ,
                         unsigned short CDP_scratch_idx , rrd_info_t **pcdp_summary ,
                         time_t rra_time ) 
{ 
  unsigned long ds_idx ;
  unsigned long cdp_idx ;
  rrd_infoval_t iv ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  ssize_t tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1994
  ds_idx = 0UL;
  {
#line 1994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1994
    if (! (ds_idx < (rrd->stat_head)->ds_cnt)) {
#line 1994
      goto while_break;
    }
#line 1996
    cdp_idx = rra_idx * (rrd->stat_head)->ds_cnt + ds_idx;
#line 2002
    if ((unsigned long )*pcdp_summary != (unsigned long )((void *)0)) {
      {
#line 2003
      iv.u_val = (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val;
#line 2005
      tmp = sprintf_alloc((char *)"[%lli]RRA[%s][%lu]DS[%s]", (long long )rra_time,
                          (rrd->rra_def + rra_idx)->cf_nam, (rrd->rra_def + rra_idx)->pdp_cnt,
                          (rrd->ds_def + ds_idx)->ds_nam);
#line 2005
      *pcdp_summary = rrd_info_push(*pcdp_summary, tmp, (rrd_info_type_t )0, iv);
      }
    }
    {
#line 2014
    tmp___0 = __errno_location();
#line 2014
    *tmp___0 = 0;
#line 2015
    tmp___3 = rrd_write(rrd_file, (void const   *)(& (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val),
                        sizeof(rrd_value_t ));
    }
#line 2015
    if ((unsigned long )tmp___3 != sizeof(rrd_value_t )) {
      {
#line 2018
      tmp___1 = __errno_location();
#line 2018
      tmp___2 = rrd_strerror(*tmp___1);
#line 2018
      rrd_set_error((char *)"writing rrd: %s", tmp___2);
      }
#line 2019
      return (-1);
    }
#line 1994
    ds_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2022
  return (0);
}
}
#line 2030 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_update.c"
static int smooth_all_rras(rrd_t *rrd , rrd_file_t *rrd_file , unsigned long rra_begin ) 
{ 
  unsigned long rra_start ;
  unsigned long rra_idx ;
  int tmp ;
  enum cf_en tmp___0 ;
  enum cf_en tmp___1 ;

  {
#line 2035
  rra_start = rra_begin;
#line 2038
  rra_idx = 0UL;
  {
#line 2038
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2038
    if (! (rra_idx < (rrd->stat_head)->rra_cnt)) {
#line 2038
      goto while_break;
    }
    {
#line 2039
    tmp___0 = cf_conv((char const   *)((rrd->rra_def + rra_idx)->cf_nam));
    }
#line 2039
    if ((unsigned int )tmp___0 == 7U) {
#line 2039
      goto _L;
    } else {
      {
#line 2039
      tmp___1 = cf_conv((char const   *)((rrd->rra_def + rra_idx)->cf_nam));
      }
#line 2039
      if ((unsigned int )tmp___1 == 5U) {
        _L: /* CIL Label */ 
        {
#line 2044
        apply_smoother(rrd, rra_idx, rra_start, rrd_file);
#line 2045
        tmp = rrd_test_error();
        }
#line 2045
        if (tmp) {
#line 2046
          return (-1);
        }
      }
    }
#line 2048
    rra_start += ((rrd->rra_def + rra_idx)->row_cnt * (rrd->stat_head)->ds_cnt) * sizeof(rrd_value_t );
#line 2038
    rra_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2051
  return (0);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 764
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 249 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime_r)(time_t const   * __restrict  __timer ,
                                                                                      struct tm * __restrict  __tp ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 58 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
#line 60
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 100
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 109
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 178
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 187
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fmod)(double __x ,
                                                                              double __y ) ;
#line 192
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isinf)(double __value )  __attribute__((__const__)) ;
#line 192
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isinff)(float __value )  __attribute__((__const__)) ;
#line 192
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isinfl)(long double __value )  __attribute__((__const__)) ;
#line 57 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.h"
void parseCDEF_DS(char const   *def , rrd_t *rrd , int ds_idx ) ;
#line 61
long lookup_DS(void *rrd_vptr , char *ds_name ) ;
#line 65
short rpn_compact(rpnp_t *rpnp , rpn_cdefds_t **rpnc , short *count ) ;
#line 71
void rpn_compact2str(rpn_cdefds_t *rpnc , ds_def_t *ds_def , char **str ) ;
#line 75
rpnp_t *rpn_parse(void *key_hash , char const   * const  expr_const , long (*lookup)(void * ,
                                                                                     char * ) ) ;
#line 15 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
short addop2str(enum op_en op___0 , enum op_en op_type , char *op_str , char **result_str ,
                unsigned short *offset ) ;
#line 21
int tzoffset(time_t now ) ;
#line 24 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
short rpn_compact(rpnp_t *rpnp , rpn_cdefds_t **rpnc , short *count ) 
{ 
  short i ;
  void *tmp ;
  double temp ;
  double tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 31
  *count = (short)0;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if (! ((unsigned int )(rpnp + *count)->op != 32U)) {
#line 33
      goto while_break;
    }
#line 34
    *count = (short )((int )*count + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  *count = (short )((int )*count + 1);
#line 35
  if ((int )*count > (int )((sizeof(unival ) * 10UL) / sizeof(rpn_cdefds_t ))) {
    {
#line 36
    rrd_set_error((char *)"Maximum %d RPN nodes permitted. Got %d RPN nodes at present.",
                  (int )((sizeof(unival ) * 10UL) / sizeof(rpn_cdefds_t )) - 1, (int )*count - 1);
    }
#line 38
    return ((short)-1);
  }
  {
#line 42
  tmp = calloc((size_t )*count, sizeof(rpn_cdefds_t ));
#line 42
  *rpnc = (rpn_cdefds_t *)tmp;
#line 43
  i = (short)0;
  }
  {
#line 43
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 43
    if (! ((unsigned int )(rpnp + i)->op != 32U)) {
#line 43
      goto while_break___0;
    }
#line 44
    (*rpnc + i)->op = (char )(rpnp + i)->op;
#line 45
    if ((unsigned int )(rpnp + i)->op == 0U) {
      {
#line 47
      tmp___0 = floor((rpnp + i)->val);
#line 47
      temp = tmp___0;
      }
#line 49
      if (temp < (double )-32768) {
        {
#line 50
        rrd_set_error((char *)"constants must be integers in the interval (%d, %d)",
                      -32768, 32767);
#line 53
        free((void *)*rpnc);
        }
#line 54
        return ((short)-1);
      } else
#line 49
      if (temp > (double )32767) {
        {
#line 50
        rrd_set_error((char *)"constants must be integers in the interval (%d, %d)",
                      -32768, 32767);
#line 53
        free((void *)*rpnc);
        }
#line 54
        return ((short)-1);
      }
#line 56
      (*rpnc + i)->val = (short )temp;
    } else
#line 57
    if ((unsigned int )(rpnp + i)->op == 1U) {
#line 58
      (*rpnc + i)->val = (short )(rpnp + i)->ptr;
    } else
#line 57
    if ((unsigned int )(rpnp + i)->op == 36U) {
#line 58
      (*rpnc + i)->val = (short )(rpnp + i)->ptr;
    }
#line 43
    i = (short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 62
  (*rpnc + ((int )*count - 1))->op = (char)32;
#line 63
  return ((short)0);
}
}
#line 66 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
rpnp_t *rpn_expand(rpn_cdefds_t *rpnc ) 
{ 
  short i ;
  rpnp_t *rpnp ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 74
  tmp = calloc((size_t )((int )((sizeof(unival ) * 10UL) / sizeof(rpn_cdefds_t ))),
               sizeof(rpnp_t ));
#line 74
  rpnp = (rpnp_t *)tmp;
  }
#line 75
  if ((unsigned long )rpnp == (unsigned long )((void *)0)) {
    {
#line 76
    rrd_set_error((char *)"failed allocating rpnp array");
    }
#line 77
    return ((rpnp_t *)((void *)0));
  }
#line 79
  i = (short)0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! ((int )(rpnc + i)->op != 32)) {
#line 79
      goto while_break;
    }
#line 80
    (rpnp + i)->op = (enum op_en )(rpnc + i)->op;
#line 81
    if ((unsigned int )(rpnp + i)->op == 0U) {
#line 82
      (rpnp + i)->val = (double )(rpnc + i)->val;
    } else
#line 83
    if ((unsigned int )(rpnp + i)->op == 1U) {
#line 84
      (rpnp + i)->ptr = (long )(rpnc + i)->val;
    } else
#line 83
    if ((unsigned int )(rpnp + i)->op == 36U) {
#line 84
      (rpnp + i)->ptr = (long )(rpnc + i)->val;
    }
#line 79
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  (rpnp + i)->op = (enum op_en )32;
#line 89
  return (rpnp);
}
}
#line 100 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
void rpn_compact2str(rpn_cdefds_t *rpnc , ds_def_t *ds_def , char **str ) 
{ 
  unsigned short i ;
  unsigned short offset ;
  char buffer[7] ;
  unsigned short tmp ;
  short tmp___0 ;
  char *ds_name ;
  short tmp___1 ;
  char *ds_name___0 ;
  short tmp___2 ;
  short tmp___3 ;
  short tmp___4 ;
  short tmp___5 ;
  short tmp___6 ;
  short tmp___7 ;
  short tmp___8 ;
  short tmp___9 ;
  short tmp___10 ;
  short tmp___11 ;
  short tmp___12 ;
  short tmp___13 ;
  short tmp___14 ;
  short tmp___15 ;
  short tmp___16 ;
  short tmp___17 ;
  short tmp___18 ;
  short tmp___19 ;
  short tmp___20 ;
  short tmp___21 ;
  short tmp___22 ;
  short tmp___23 ;
  short tmp___24 ;
  short tmp___25 ;
  short tmp___26 ;
  short tmp___27 ;
  short tmp___28 ;
  short tmp___29 ;
  short tmp___30 ;
  short tmp___31 ;
  short tmp___32 ;
  short tmp___33 ;
  short tmp___34 ;
  short tmp___35 ;
  short tmp___36 ;
  short tmp___37 ;
  short tmp___38 ;
  short tmp___39 ;
  short tmp___40 ;
  short tmp___41 ;
  short tmp___42 ;
  short tmp___43 ;
  short tmp___44 ;
  short tmp___45 ;
  short tmp___46 ;
  short tmp___47 ;
  short tmp___48 ;
  short tmp___49 ;
  void *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;

  {
#line 105
  offset = (unsigned short)0;
#line 108
  i = (unsigned short)0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((int )(rpnc + i)->op != 32)) {
#line 108
      goto while_break;
    }
#line 109
    if ((int )i > 0) {
#line 110
      tmp = offset;
#line 110
      offset = (unsigned short )((int )offset + 1);
#line 110
      *(*str + tmp) = (char )',';
    }
#line 115
    if ((int )(rpnc + i)->op == 0) {
      {
#line 120
      sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d",
              (int )(rpnc + i)->val);
#line 122
      tmp___0 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )0, buffer, str,
                          & offset);
      }
#line 122
      if ((int )tmp___0 == 1) {
#line 122
        goto __Cont;
      }
    }
#line 125
    if ((int )(rpnc + i)->op == 1) {
      {
#line 126
      ds_name = (ds_def + (rpnc + i)->val)->ds_nam;
#line 128
      tmp___1 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )1, ds_name, str,
                          & offset);
      }
#line 128
      if ((int )tmp___1 == 1) {
#line 128
        goto __Cont;
      }
    }
#line 131
    if ((int )(rpnc + i)->op == 36) {
      {
#line 132
      ds_name___0 = (ds_def + (rpnc + i)->val)->ds_nam;
#line 134
      tmp___2 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )1, ds_name___0,
                          str, & offset);
      }
#line 134
      if ((int )tmp___2 == 1) {
#line 134
        goto __Cont;
      }
    }
    {
#line 141
    tmp___3 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )8, (char *)"+",
                        str, & offset);
    }
#line 141
    if ((int )tmp___3 == 1) {
#line 141
      goto __Cont;
    }
    {
#line 142
    tmp___4 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )10, (char *)"-",
                        str, & offset);
    }
#line 142
    if ((int )tmp___4 == 1) {
#line 142
      goto __Cont;
    }
    {
#line 143
    tmp___5 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )11, (char *)"*",
                        str, & offset);
    }
#line 143
    if ((int )tmp___5 == 1) {
#line 143
      goto __Cont;
    }
    {
#line 144
    tmp___6 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )12, (char *)"/",
                        str, & offset);
    }
#line 144
    if ((int )tmp___6 == 1) {
#line 144
      goto __Cont;
    }
    {
#line 145
    tmp___7 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )9, (char *)"%",
                        str, & offset);
    }
#line 145
    if ((int )tmp___7 == 1) {
#line 145
      goto __Cont;
    }
    {
#line 146
    tmp___8 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )13, (char *)"SIN",
                        str, & offset);
    }
#line 146
    if ((int )tmp___8 == 1) {
#line 146
      goto __Cont;
    }
    {
#line 147
    tmp___9 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )17, (char *)"COS",
                        str, & offset);
    }
#line 147
    if ((int )tmp___9 == 1) {
#line 147
      goto __Cont;
    }
    {
#line 148
    tmp___10 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )18, (char *)"LOG",
                         str, & offset);
    }
#line 148
    if ((int )tmp___10 == 1) {
#line 148
      goto __Cont;
    }
    {
#line 149
    tmp___11 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )29, (char *)"FLOOR",
                         str, & offset);
    }
#line 149
    if ((int )tmp___11 == 1) {
#line 149
      goto __Cont;
    }
    {
#line 150
    tmp___12 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )30, (char *)"CEIL",
                         str, & offset);
    }
#line 150
    if ((int )tmp___12 == 1) {
#line 150
      goto __Cont;
    }
    {
#line 151
    tmp___13 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )19, (char *)"EXP",
                         str, & offset);
    }
#line 151
    if ((int )tmp___13 == 1) {
#line 151
      goto __Cont;
    }
    {
#line 152
    tmp___14 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )14, (char *)"DUP",
                         str, & offset);
    }
#line 152
    if ((int )tmp___14 == 1) {
#line 152
      goto __Cont;
    }
    {
#line 153
    tmp___15 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )15, (char *)"EXC",
                         str, & offset);
    }
#line 153
    if ((int )tmp___15 == 1) {
#line 153
      goto __Cont;
    }
    {
#line 154
    tmp___16 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )16, (char *)"POP",
                         str, & offset);
    }
#line 154
    if ((int )tmp___16 == 1) {
#line 154
      goto __Cont;
    }
    {
#line 155
    tmp___17 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )20, (char *)"LT",
                         str, & offset);
    }
#line 155
    if ((int )tmp___17 == 1) {
#line 155
      goto __Cont;
    }
    {
#line 156
    tmp___18 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )21, (char *)"LE",
                         str, & offset);
    }
#line 156
    if ((int )tmp___18 == 1) {
#line 156
      goto __Cont;
    }
    {
#line 157
    tmp___19 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )22, (char *)"GT",
                         str, & offset);
    }
#line 157
    if ((int )tmp___19 == 1) {
#line 157
      goto __Cont;
    }
    {
#line 158
    tmp___20 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )23, (char *)"GE",
                         str, & offset);
    }
#line 158
    if ((int )tmp___20 == 1) {
#line 158
      goto __Cont;
    }
    {
#line 159
    tmp___21 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )24, (char *)"EQ",
                         str, & offset);
    }
#line 159
    if ((int )tmp___21 == 1) {
#line 159
      goto __Cont;
    }
    {
#line 160
    tmp___22 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )25, (char *)"IF",
                         str, & offset);
    }
#line 160
    if ((int )tmp___22 == 1) {
#line 160
      goto __Cont;
    }
    {
#line 161
    tmp___23 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )26, (char *)"MIN",
                         str, & offset);
    }
#line 161
    if ((int )tmp___23 == 1) {
#line 161
      goto __Cont;
    }
    {
#line 162
    tmp___24 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )27, (char *)"MAX",
                         str, & offset);
    }
#line 162
    if ((int )tmp___24 == 1) {
#line 162
      goto __Cont;
    }
    {
#line 163
    tmp___25 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )28, (char *)"LIMIT",
                         str, & offset);
    }
#line 163
    if ((int )tmp___25 == 1) {
#line 163
      goto __Cont;
    }
    {
#line 164
    tmp___26 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )5, (char *)"UNKN",
                         str, & offset);
    }
#line 164
    if ((int )tmp___26 == 1) {
#line 164
      goto __Cont;
    }
    {
#line 165
    tmp___27 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )31, (char *)"UN",
                         str, & offset);
    }
#line 165
    if ((int )tmp___27 == 1) {
#line 165
      goto __Cont;
    }
    {
#line 166
    tmp___28 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )4, (char *)"NEGINF",
                         str, & offset);
    }
#line 166
    if ((int )tmp___28 == 1) {
#line 166
      goto __Cont;
    }
    {
#line 167
    tmp___29 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )34, (char *)"NE",
                         str, & offset);
    }
#line 167
    if ((int )tmp___29 == 1) {
#line 167
      goto __Cont;
    }
    {
#line 168
    tmp___30 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )3, (char *)"PREV",
                         str, & offset);
    }
#line 168
    if ((int )tmp___30 == 1) {
#line 168
      goto __Cont;
    }
    {
#line 169
    tmp___31 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )2, (char *)"INF",
                         str, & offset);
    }
#line 169
    if ((int )tmp___31 == 1) {
#line 169
      goto __Cont;
    }
    {
#line 170
    tmp___32 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )35, (char *)"ISINF",
                         str, & offset);
    }
#line 170
    if ((int )tmp___32 == 1) {
#line 170
      goto __Cont;
    }
    {
#line 171
    tmp___33 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )6, (char *)"NOW",
                         str, & offset);
    }
#line 171
    if ((int )tmp___33 == 1) {
#line 171
      goto __Cont;
    }
    {
#line 172
    tmp___34 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )33, (char *)"LTIME",
                         str, & offset);
    }
#line 172
    if ((int )tmp___34 == 1) {
#line 172
      goto __Cont;
    }
    {
#line 173
    tmp___35 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )7, (char *)"TIME",
                         str, & offset);
    }
#line 173
    if ((int )tmp___35 == 1) {
#line 173
      goto __Cont;
    }
    {
#line 174
    tmp___36 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )44, (char *)"ATAN2",
                         str, & offset);
    }
#line 174
    if ((int )tmp___36 == 1) {
#line 174
      goto __Cont;
    }
    {
#line 175
    tmp___37 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )38, (char *)"ATAN",
                         str, & offset);
    }
#line 175
    if ((int )tmp___37 == 1) {
#line 175
      goto __Cont;
    }
    {
#line 176
    tmp___38 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )39, (char *)"SQRT",
                         str, & offset);
    }
#line 176
    if ((int )tmp___38 == 1) {
#line 176
      goto __Cont;
    }
    {
#line 177
    tmp___39 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )40, (char *)"SORT",
                         str, & offset);
    }
#line 177
    if ((int )tmp___39 == 1) {
#line 177
      goto __Cont;
    }
    {
#line 178
    tmp___40 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )41, (char *)"REV",
                         str, & offset);
    }
#line 178
    if ((int )tmp___40 == 1) {
#line 178
      goto __Cont;
    }
    {
#line 179
    tmp___41 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )42, (char *)"TREND",
                         str, & offset);
    }
#line 179
    if ((int )tmp___41 == 1) {
#line 179
      goto __Cont;
    }
    {
#line 180
    tmp___42 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )43, (char *)"TRENDNAN",
                         str, & offset);
    }
#line 180
    if ((int )tmp___42 == 1) {
#line 180
      goto __Cont;
    }
    {
#line 181
    tmp___43 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )47, (char *)"PREDICT",
                         str, & offset);
    }
#line 181
    if ((int )tmp___43 == 1) {
#line 181
      goto __Cont;
    }
    {
#line 182
    tmp___44 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )48, (char *)"PREDICTSIGMA",
                         str, & offset);
    }
#line 182
    if ((int )tmp___44 == 1) {
#line 182
      goto __Cont;
    }
    {
#line 183
    tmp___45 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )45, (char *)"RAD2DEG",
                         str, & offset);
    }
#line 183
    if ((int )tmp___45 == 1) {
#line 183
      goto __Cont;
    }
    {
#line 184
    tmp___46 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )46, (char *)"DEG2RAD",
                         str, & offset);
    }
#line 184
    if ((int )tmp___46 == 1) {
#line 184
      goto __Cont;
    }
    {
#line 185
    tmp___47 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )49, (char *)"AVG",
                         str, & offset);
    }
#line 185
    if ((int )tmp___47 == 1) {
#line 185
      goto __Cont;
    }
    {
#line 186
    tmp___48 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )50, (char *)"ABS",
                         str, & offset);
    }
#line 186
    if ((int )tmp___48 == 1) {
#line 186
      goto __Cont;
    }
    {
#line 187
    tmp___49 = addop2str((enum op_en )(rpnc + i)->op, (enum op_en )51, (char *)"ADDNAN",
                         str, & offset);
    }
#line 187
    if ((int )tmp___49 == 1) {

    }
    __Cont: /* CIL Label */ 
#line 108
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  *(*str + offset) = (char )'\000';
#line 192
  return;
}
}
#line 194 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
short addop2str(enum op_en op___0 , enum op_en op_type , char *op_str , char **result_str ,
                unsigned short *offset ) 
{ 
  short op_len ;
  size_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;

  {
#line 201
  if ((unsigned int )op___0 == (unsigned int )op_type) {
    {
#line 204
    tmp = strlen((char const   *)op_str);
#line 204
    op_len = (short )tmp;
#line 205
    tmp___0 = realloc((void *)*result_str, (unsigned long )(((int )op_len + 1) + (int )*offset) * sizeof(char ));
#line 205
    *result_str = (char *)tmp___0;
    }
#line 208
    if ((unsigned long )*result_str == (unsigned long )((void *)0)) {
      {
#line 209
      rrd_set_error((char *)"failed to alloc memory in addop2str");
      }
#line 210
      return ((short)-1);
    }
    {
#line 212
    strncpy((char */* __restrict  */)(*result_str + *offset), (char const   */* __restrict  */)op_str,
            (size_t )op_len);
#line 213
    *offset = (unsigned short )((int )*offset + (int )op_len);
    }
#line 214
    return ((short)1);
  }
#line 216
  return ((short)0);
}
}
#line 219 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
void parseCDEF_DS(char const   *def , rrd_t *rrd , int ds_idx ) 
{ 
  rpnp_t *rpnp ;
  rpn_cdefds_t *rpnc ;
  short count ;
  short i ;
  short tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 224
  rpnp = (rpnp_t *)((void *)0);
#line 225
  rpnc = (rpn_cdefds_t *)((void *)0);
#line 228
  rpnp = rpn_parse((void *)rrd, (char const   */* const  */)def, & lookup_DS);
  }
#line 229
  if ((unsigned long )rpnp == (unsigned long )((void *)0)) {
    {
#line 230
    rrd_set_error((char *)"failed to parse computed data source");
    }
#line 231
    return;
  }
#line 237
  i = (short)0;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! ((unsigned int )(rpnp + i)->op != 32U)) {
#line 237
      goto while_break;
    }
#line 238
    if ((unsigned int )(rpnp + i)->op == 7U) {
      {
#line 242
      rrd_set_error((char *)"operators TIME, LTIME, PREV COUNT TREND TRENDNAN PREDICT PREDICTSIGMA are not supported with DS COMPUTE");
#line 244
      free((void *)rpnp);
      }
#line 245
      return;
    } else
#line 238
    if ((unsigned int )(rpnp + i)->op == 33U) {
      {
#line 242
      rrd_set_error((char *)"operators TIME, LTIME, PREV COUNT TREND TRENDNAN PREDICT PREDICTSIGMA are not supported with DS COMPUTE");
#line 244
      free((void *)rpnp);
      }
#line 245
      return;
    } else
#line 238
    if ((unsigned int )(rpnp + i)->op == 3U) {
      {
#line 242
      rrd_set_error((char *)"operators TIME, LTIME, PREV COUNT TREND TRENDNAN PREDICT PREDICTSIGMA are not supported with DS COMPUTE");
#line 244
      free((void *)rpnp);
      }
#line 245
      return;
    } else
#line 238
    if ((unsigned int )(rpnp + i)->op == 37U) {
      {
#line 242
      rrd_set_error((char *)"operators TIME, LTIME, PREV COUNT TREND TRENDNAN PREDICT PREDICTSIGMA are not supported with DS COMPUTE");
#line 244
      free((void *)rpnp);
      }
#line 245
      return;
    } else
#line 238
    if ((unsigned int )(rpnp + i)->op == 42U) {
      {
#line 242
      rrd_set_error((char *)"operators TIME, LTIME, PREV COUNT TREND TRENDNAN PREDICT PREDICTSIGMA are not supported with DS COMPUTE");
#line 244
      free((void *)rpnp);
      }
#line 245
      return;
    } else
#line 238
    if ((unsigned int )(rpnp + i)->op == 43U) {
      {
#line 242
      rrd_set_error((char *)"operators TIME, LTIME, PREV COUNT TREND TRENDNAN PREDICT PREDICTSIGMA are not supported with DS COMPUTE");
#line 244
      free((void *)rpnp);
      }
#line 245
      return;
    } else
#line 238
    if ((unsigned int )(rpnp + i)->op == 47U) {
      {
#line 242
      rrd_set_error((char *)"operators TIME, LTIME, PREV COUNT TREND TRENDNAN PREDICT PREDICTSIGMA are not supported with DS COMPUTE");
#line 244
      free((void *)rpnp);
      }
#line 245
      return;
    } else
#line 238
    if ((unsigned int )(rpnp + i)->op == 48U) {
      {
#line 242
      rrd_set_error((char *)"operators TIME, LTIME, PREV COUNT TREND TRENDNAN PREDICT PREDICTSIGMA are not supported with DS COMPUTE");
#line 244
      free((void *)rpnp);
      }
#line 245
      return;
    }
#line 237
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  tmp = rpn_compact(rpnp, & rpnc, & count);
  }
#line 248
  if ((int )tmp == -1) {
    {
#line 249
    free((void *)rpnp);
    }
#line 250
    return;
  }
  {
#line 253
  memcpy((void */* __restrict  */)((void *)(& (rrd->ds_def + ds_idx)->par[0])), (void const   */* __restrict  */)((void *)rpnc),
         (unsigned long )count * sizeof(rpn_cdefds_t ));
#line 255
  free((void *)rpnp);
#line 256
  free((void *)rpnc);
  }
#line 257
  return;
}
}
#line 264 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
long lookup_DS(void *rrd_vptr , char *ds_name ) 
{ 
  unsigned int i ;
  rrd_t *rrd ;
  int tmp ;

  {
#line 271
  rrd = (rrd_t *)rrd_vptr;
#line 273
  i = 0U;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! ((unsigned long )i < (rrd->stat_head)->ds_cnt)) {
#line 273
      goto while_break;
    }
    {
#line 274
    tmp = strcmp((char const   *)ds_name, (char const   *)((rrd->ds_def + i)->ds_nam));
    }
#line 274
    if (tmp == 0) {
#line 275
      return ((long )i);
    }
#line 273
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  return (-1L);
}
}
#line 289 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
rpnp_t *rpn_parse(void *key_hash , char const   * const  expr_const , long (*lookup)(void * ,
                                                                                     char * ) ) 
{ 
  int pos ;
  char *expr ;
  long steps ;
  rpnp_t *rpnp ;
  char vname[265] ;
  char *old_locale ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  int length ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  int tmp___50 ;
  long tmp___51 ;
  size_t tmp___52 ;
  int tmp___53 ;
  size_t tmp___54 ;
  size_t tmp___55 ;
  size_t tmp___56 ;
  int tmp___57 ;
  size_t tmp___58 ;
  size_t tmp___59 ;
  size_t tmp___60 ;
  int tmp___61 ;
  size_t tmp___62 ;
  size_t tmp___63 ;
  size_t tmp___64 ;
  int tmp___65 ;
  size_t tmp___66 ;
  size_t tmp___67 ;
  size_t tmp___68 ;
  int tmp___69 ;
  size_t tmp___70 ;
  size_t tmp___71 ;
  size_t tmp___72 ;
  int tmp___73 ;
  size_t tmp___74 ;
  size_t tmp___75 ;
  size_t tmp___76 ;
  int tmp___77 ;
  size_t tmp___78 ;
  size_t tmp___79 ;
  size_t tmp___80 ;
  int tmp___81 ;
  size_t tmp___82 ;
  size_t tmp___83 ;
  size_t tmp___84 ;
  int tmp___85 ;
  size_t tmp___86 ;
  size_t tmp___87 ;
  size_t tmp___88 ;
  int tmp___89 ;
  size_t tmp___90 ;
  size_t tmp___91 ;
  size_t tmp___92 ;
  int tmp___93 ;
  size_t tmp___94 ;
  size_t tmp___95 ;
  size_t tmp___96 ;
  int tmp___97 ;
  size_t tmp___98 ;
  size_t tmp___99 ;
  size_t tmp___100 ;
  int tmp___101 ;
  size_t tmp___102 ;
  size_t tmp___103 ;
  size_t tmp___104 ;
  int tmp___105 ;
  size_t tmp___106 ;
  size_t tmp___107 ;
  size_t tmp___108 ;
  int tmp___109 ;
  size_t tmp___110 ;
  size_t tmp___111 ;
  size_t tmp___112 ;
  int tmp___113 ;
  size_t tmp___114 ;
  size_t tmp___115 ;
  size_t tmp___116 ;
  int tmp___117 ;
  size_t tmp___118 ;
  size_t tmp___119 ;
  size_t tmp___120 ;
  int tmp___121 ;
  size_t tmp___122 ;
  size_t tmp___123 ;
  size_t tmp___124 ;
  int tmp___125 ;
  size_t tmp___126 ;
  size_t tmp___127 ;
  int tmp___128 ;
  size_t tmp___129 ;
  int tmp___130 ;
  size_t tmp___131 ;
  size_t tmp___132 ;
  size_t tmp___133 ;
  int tmp___134 ;
  size_t tmp___135 ;
  size_t tmp___136 ;
  size_t tmp___137 ;
  int tmp___138 ;
  size_t tmp___139 ;
  size_t tmp___140 ;
  size_t tmp___141 ;
  int tmp___142 ;
  size_t tmp___143 ;
  size_t tmp___144 ;
  size_t tmp___145 ;
  int tmp___146 ;
  size_t tmp___147 ;
  size_t tmp___148 ;
  size_t tmp___149 ;
  int tmp___150 ;
  size_t tmp___151 ;
  size_t tmp___152 ;
  size_t tmp___153 ;
  int tmp___154 ;
  size_t tmp___155 ;
  size_t tmp___156 ;
  size_t tmp___157 ;
  int tmp___158 ;
  size_t tmp___159 ;
  size_t tmp___160 ;
  size_t tmp___161 ;
  int tmp___162 ;
  size_t tmp___163 ;
  size_t tmp___164 ;
  size_t tmp___165 ;
  int tmp___166 ;
  size_t tmp___167 ;
  size_t tmp___168 ;
  size_t tmp___169 ;
  int tmp___170 ;
  size_t tmp___171 ;
  size_t tmp___172 ;
  size_t tmp___173 ;
  int tmp___174 ;
  size_t tmp___175 ;
  size_t tmp___176 ;
  size_t tmp___177 ;
  int tmp___178 ;
  size_t tmp___179 ;
  size_t tmp___180 ;
  size_t tmp___181 ;
  int tmp___182 ;
  size_t tmp___183 ;
  size_t tmp___184 ;
  size_t tmp___185 ;
  int tmp___186 ;
  size_t tmp___187 ;
  size_t tmp___188 ;
  size_t tmp___189 ;
  int tmp___190 ;
  size_t tmp___191 ;
  size_t tmp___192 ;
  size_t tmp___193 ;
  int tmp___194 ;
  size_t tmp___195 ;
  size_t tmp___196 ;
  size_t tmp___197 ;
  int tmp___198 ;
  size_t tmp___199 ;
  size_t tmp___200 ;
  size_t tmp___201 ;
  int tmp___202 ;
  size_t tmp___203 ;
  size_t tmp___204 ;
  size_t tmp___205 ;
  int tmp___206 ;
  size_t tmp___207 ;
  size_t tmp___208 ;
  size_t tmp___209 ;
  int tmp___210 ;
  size_t tmp___211 ;
  size_t tmp___212 ;
  size_t tmp___213 ;
  int tmp___214 ;
  size_t tmp___215 ;
  size_t tmp___216 ;
  size_t tmp___217 ;
  int tmp___218 ;
  size_t tmp___219 ;
  size_t tmp___220 ;
  size_t tmp___221 ;
  int tmp___222 ;
  size_t tmp___223 ;
  size_t tmp___224 ;
  size_t tmp___225 ;
  int tmp___226 ;
  size_t tmp___227 ;
  size_t tmp___228 ;
  size_t tmp___229 ;
  int tmp___230 ;
  size_t tmp___231 ;
  size_t tmp___232 ;
  size_t tmp___233 ;
  int tmp___234 ;
  size_t tmp___235 ;
  size_t tmp___236 ;
  size_t tmp___237 ;
  int tmp___238 ;
  size_t tmp___239 ;
  size_t tmp___240 ;
  size_t tmp___241 ;
  int tmp___242 ;
  size_t tmp___243 ;
  size_t tmp___244 ;
  int tmp___245 ;
  void *tmp___246 ;
  void *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  char *__cil_tmp277 ;
  char *__cil_tmp278 ;
  char *__cil_tmp279 ;
  char *__cil_tmp280 ;
  char *__cil_tmp281 ;
  char *__cil_tmp282 ;
  char *__cil_tmp283 ;
  char *__cil_tmp284 ;
  char *__cil_tmp285 ;
  char *__cil_tmp286 ;
  char *__cil_tmp287 ;
  char *__cil_tmp288 ;
  char *__cil_tmp289 ;
  char *__cil_tmp290 ;
  char *__cil_tmp291 ;
  char *__cil_tmp292 ;
  char *__cil_tmp293 ;
  char *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;
  char *__cil_tmp380 ;
  char *__cil_tmp381 ;
  char *__cil_tmp382 ;
  char *__cil_tmp383 ;
  char *__cil_tmp384 ;
  char *__cil_tmp385 ;
  char *__cil_tmp386 ;
  char *__cil_tmp387 ;
  char *__cil_tmp388 ;
  char *__cil_tmp389 ;
  char *__cil_tmp390 ;
  char *__cil_tmp391 ;
  char *__cil_tmp392 ;
  char *__cil_tmp393 ;
  char *__cil_tmp394 ;
  char *__cil_tmp395 ;
  char *__cil_tmp396 ;
  char *__cil_tmp397 ;
  char *__cil_tmp398 ;
  char *__cil_tmp399 ;
  char *__cil_tmp400 ;
  char *__cil_tmp401 ;
  char *__cil_tmp402 ;
  char *__cil_tmp403 ;
  char *__cil_tmp404 ;
  char *__cil_tmp405 ;
  char *__cil_tmp406 ;
  char *__cil_tmp407 ;
  char *__cil_tmp408 ;
  char *__cil_tmp409 ;
  char *__cil_tmp410 ;
  char *__cil_tmp411 ;
  char *__cil_tmp412 ;
  char *__cil_tmp413 ;
  char *__cil_tmp414 ;
  char *__cil_tmp415 ;
  char *__cil_tmp416 ;
  char *__cil_tmp417 ;
  char *__cil_tmp418 ;
  char *__cil_tmp419 ;
  char *__cil_tmp420 ;
  char *__cil_tmp421 ;
  char *__cil_tmp422 ;
  char *__cil_tmp423 ;
  char *__cil_tmp424 ;
  char *__cil_tmp425 ;
  char *__cil_tmp426 ;
  char *__cil_tmp427 ;
  char *__cil_tmp428 ;
  char *__cil_tmp429 ;
  char *__cil_tmp430 ;
  char *__cil_tmp431 ;
  char *__cil_tmp432 ;
  char *__cil_tmp433 ;
  char *__cil_tmp434 ;
  char *__cil_tmp435 ;
  char *__cil_tmp436 ;
  char *__cil_tmp437 ;
  char *__cil_tmp438 ;
  char *__cil_tmp439 ;
  char *__cil_tmp440 ;
  char *__cil_tmp441 ;
  char *__cil_tmp442 ;
  char *__cil_tmp443 ;
  char *__cil_tmp444 ;
  char *__cil_tmp445 ;
  char *__cil_tmp446 ;
  char *__cil_tmp447 ;
  char *__cil_tmp448 ;
  char *__cil_tmp449 ;
  char *__cil_tmp450 ;
  char *__cil_tmp451 ;
  char *__cil_tmp452 ;
  char *__cil_tmp453 ;
  char *__cil_tmp454 ;
  char *__cil_tmp455 ;
  char *__cil_tmp456 ;
  char *__cil_tmp457 ;
  char *__cil_tmp458 ;
  char *__cil_tmp459 ;
  char *__cil_tmp460 ;
  char *__cil_tmp461 ;
  char *__cil_tmp462 ;
  char *__cil_tmp463 ;
  char *__cil_tmp464 ;
  char *__cil_tmp465 ;
  char *__cil_tmp466 ;
  char *__cil_tmp467 ;
  char *__cil_tmp468 ;
  char *__cil_tmp469 ;
  char *__cil_tmp470 ;
  char *__cil_tmp471 ;
  char *__cil_tmp472 ;
  char *__cil_tmp473 ;
  char *__cil_tmp474 ;
  char *__cil_tmp475 ;
  char *__cil_tmp476 ;
  char *__cil_tmp477 ;
  char *__cil_tmp478 ;
  char *__cil_tmp479 ;
  char *__cil_tmp480 ;
  char *__cil_tmp481 ;
  char *__cil_tmp482 ;
  char *__cil_tmp483 ;
  char *__cil_tmp484 ;
  char *__cil_tmp485 ;
  char *__cil_tmp486 ;
  char *__cil_tmp487 ;
  char *__cil_tmp488 ;
  char *__cil_tmp489 ;
  char *__cil_tmp490 ;
  char *__cil_tmp491 ;
  char *__cil_tmp492 ;
  char *__cil_tmp493 ;
  char *__cil_tmp494 ;
  char *__cil_tmp495 ;
  char *__cil_tmp496 ;
  char *__cil_tmp497 ;
  char *__cil_tmp498 ;
  char *__cil_tmp499 ;
  char *__cil_tmp500 ;
  char *__cil_tmp501 ;
  char *__cil_tmp502 ;
  char *__cil_tmp503 ;
  char *__cil_tmp504 ;
  char *__cil_tmp505 ;
  char *__cil_tmp506 ;
  char *__cil_tmp507 ;
  char *__cil_tmp508 ;
  char *__cil_tmp509 ;
  char *__cil_tmp510 ;
  char *__cil_tmp511 ;
  char *__cil_tmp512 ;
  char *__cil_tmp513 ;
  char *__cil_tmp514 ;
  char *__cil_tmp515 ;
  char *__cil_tmp516 ;
  char *__cil_tmp517 ;
  char *__cil_tmp518 ;
  char *__cil_tmp519 ;
  char *__cil_tmp520 ;
  char *__cil_tmp521 ;
  char *__cil_tmp522 ;
  char *__cil_tmp523 ;
  char *__cil_tmp524 ;
  char *__cil_tmp525 ;
  char *__cil_tmp526 ;
  char *__cil_tmp527 ;
  char *__cil_tmp528 ;
  char *__cil_tmp529 ;
  char *__cil_tmp530 ;
  char *__cil_tmp531 ;
  char *__cil_tmp532 ;
  char *__cil_tmp533 ;
  char *__cil_tmp534 ;
  char *__cil_tmp535 ;
  char *__cil_tmp536 ;
  char *__cil_tmp537 ;
  char *__cil_tmp538 ;
  char *__cil_tmp539 ;
  char *__cil_tmp540 ;
  char *__cil_tmp541 ;
  char *__cil_tmp542 ;
  char *__cil_tmp543 ;
  char *__cil_tmp544 ;
  char *__cil_tmp545 ;
  char *__cil_tmp546 ;
  char *__cil_tmp547 ;
  char *__cil_tmp548 ;
  char *__cil_tmp549 ;
  char *__cil_tmp550 ;
  char *__cil_tmp551 ;
  char *__cil_tmp552 ;
  char *__cil_tmp553 ;
  char *__cil_tmp554 ;
  char *__cil_tmp555 ;

  {
  {
#line 295
  pos = 0;
#line 297
  steps = -1L;
#line 302
  old_locale = setlocale(1, (char const   *)((void *)0));
#line 303
  setlocale(1, "C");
#line 305
  rpnp = (rpnp_t *)((void *)0);
#line 306
  expr = (char *)expr_const;
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! *expr) {
#line 308
      goto while_break;
    }
    {
#line 309
    steps ++;
#line 309
    tmp___246 = realloc((void *)rpnp, (unsigned long )(steps + 2L) * sizeof(rpnp_t ));
#line 309
    rpnp = (rpnp_t *)tmp___246;
    }
#line 309
    if ((unsigned long )rpnp == (unsigned long )((void *)0)) {
      {
#line 311
      setlocale(1, (char const   *)old_locale);
      }
#line 312
      return ((rpnp_t *)((void *)0));
    } else {
      {
#line 315
      tmp___245 = sscanf((char const   */* __restrict  */)expr, (char const   */* __restrict  */)"%lf%n",
                         & (rpnp + steps)->val, & pos);
      }
#line 315
      if (tmp___245 == 1) {
#line 315
        if ((int )*(expr + pos) == 44) {
#line 317
          (rpnp + steps)->op = (enum op_en )0;
#line 318
          expr += pos;
        } else {
#line 315
          goto _L___47;
        }
      } else {
        _L___47: /* CIL Label */ 
        {
#line 341
        tmp___241 = strlen("+");
#line 341
        tmp___242 = strncmp((char const   *)expr, "+", tmp___241);
        }
#line 341
        if (tmp___242 == 0) {
          {
#line 341
          tmp___243 = strlen("+");
          }
#line 341
          if ((int )*(expr + tmp___243) == 44) {
            {
#line 341
            (rpnp + steps)->op = (enum op_en )8;
#line 341
            tmp = strlen("+");
#line 341
            expr += tmp;
            }
          } else {
            {
#line 341
            tmp___244 = strlen("+");
            }
#line 341
            if ((int )*(expr + tmp___244) == 0) {
              {
#line 341
              (rpnp + steps)->op = (enum op_en )8;
#line 341
              tmp = strlen("+");
#line 341
              expr += tmp;
              }
            } else {
#line 341
              goto _L___46;
            }
          }
        } else {
          _L___46: /* CIL Label */ 
          {
#line 342
          tmp___237 = strlen("-");
#line 342
          tmp___238 = strncmp((char const   *)expr, "-", tmp___237);
          }
#line 342
          if (tmp___238 == 0) {
            {
#line 342
            tmp___239 = strlen("-");
            }
#line 342
            if ((int )*(expr + tmp___239) == 44) {
              {
#line 342
              (rpnp + steps)->op = (enum op_en )10;
#line 342
              tmp___0 = strlen("-");
#line 342
              expr += tmp___0;
              }
            } else {
              {
#line 342
              tmp___240 = strlen("-");
              }
#line 342
              if ((int )*(expr + tmp___240) == 0) {
                {
#line 342
                (rpnp + steps)->op = (enum op_en )10;
#line 342
                tmp___0 = strlen("-");
#line 342
                expr += tmp___0;
                }
              } else {
#line 342
                goto _L___45;
              }
            }
          } else {
            _L___45: /* CIL Label */ 
            {
#line 343
            tmp___233 = strlen("*");
#line 343
            tmp___234 = strncmp((char const   *)expr, "*", tmp___233);
            }
#line 343
            if (tmp___234 == 0) {
              {
#line 343
              tmp___235 = strlen("*");
              }
#line 343
              if ((int )*(expr + tmp___235) == 44) {
                {
#line 343
                (rpnp + steps)->op = (enum op_en )11;
#line 343
                tmp___1 = strlen("*");
#line 343
                expr += tmp___1;
                }
              } else {
                {
#line 343
                tmp___236 = strlen("*");
                }
#line 343
                if ((int )*(expr + tmp___236) == 0) {
                  {
#line 343
                  (rpnp + steps)->op = (enum op_en )11;
#line 343
                  tmp___1 = strlen("*");
#line 343
                  expr += tmp___1;
                  }
                } else {
#line 343
                  goto _L___44;
                }
              }
            } else {
              _L___44: /* CIL Label */ 
              {
#line 344
              tmp___229 = strlen("/");
#line 344
              tmp___230 = strncmp((char const   *)expr, "/", tmp___229);
              }
#line 344
              if (tmp___230 == 0) {
                {
#line 344
                tmp___231 = strlen("/");
                }
#line 344
                if ((int )*(expr + tmp___231) == 44) {
                  {
#line 344
                  (rpnp + steps)->op = (enum op_en )12;
#line 344
                  tmp___2 = strlen("/");
#line 344
                  expr += tmp___2;
                  }
                } else {
                  {
#line 344
                  tmp___232 = strlen("/");
                  }
#line 344
                  if ((int )*(expr + tmp___232) == 0) {
                    {
#line 344
                    (rpnp + steps)->op = (enum op_en )12;
#line 344
                    tmp___2 = strlen("/");
#line 344
                    expr += tmp___2;
                    }
                  } else {
#line 344
                    goto _L___43;
                  }
                }
              } else {
                _L___43: /* CIL Label */ 
                {
#line 345
                tmp___225 = strlen("%");
#line 345
                tmp___226 = strncmp((char const   *)expr, "%", tmp___225);
                }
#line 345
                if (tmp___226 == 0) {
                  {
#line 345
                  tmp___227 = strlen("%");
                  }
#line 345
                  if ((int )*(expr + tmp___227) == 44) {
                    {
#line 345
                    (rpnp + steps)->op = (enum op_en )9;
#line 345
                    tmp___3 = strlen("%");
#line 345
                    expr += tmp___3;
                    }
                  } else {
                    {
#line 345
                    tmp___228 = strlen("%");
                    }
#line 345
                    if ((int )*(expr + tmp___228) == 0) {
                      {
#line 345
                      (rpnp + steps)->op = (enum op_en )9;
#line 345
                      tmp___3 = strlen("%");
#line 345
                      expr += tmp___3;
                      }
                    } else {
#line 345
                      goto _L___42;
                    }
                  }
                } else {
                  _L___42: /* CIL Label */ 
                  {
#line 346
                  tmp___221 = strlen("SIN");
#line 346
                  tmp___222 = strncmp((char const   *)expr, "SIN", tmp___221);
                  }
#line 346
                  if (tmp___222 == 0) {
                    {
#line 346
                    tmp___223 = strlen("SIN");
                    }
#line 346
                    if ((int )*(expr + tmp___223) == 44) {
                      {
#line 346
                      (rpnp + steps)->op = (enum op_en )13;
#line 346
                      tmp___4 = strlen("SIN");
#line 346
                      expr += tmp___4;
                      }
                    } else {
                      {
#line 346
                      tmp___224 = strlen("SIN");
                      }
#line 346
                      if ((int )*(expr + tmp___224) == 0) {
                        {
#line 346
                        (rpnp + steps)->op = (enum op_en )13;
#line 346
                        tmp___4 = strlen("SIN");
#line 346
                        expr += tmp___4;
                        }
                      } else {
#line 346
                        goto _L___41;
                      }
                    }
                  } else {
                    _L___41: /* CIL Label */ 
                    {
#line 347
                    tmp___217 = strlen("COS");
#line 347
                    tmp___218 = strncmp((char const   *)expr, "COS", tmp___217);
                    }
#line 347
                    if (tmp___218 == 0) {
                      {
#line 347
                      tmp___219 = strlen("COS");
                      }
#line 347
                      if ((int )*(expr + tmp___219) == 44) {
                        {
#line 347
                        (rpnp + steps)->op = (enum op_en )17;
#line 347
                        tmp___5 = strlen("COS");
#line 347
                        expr += tmp___5;
                        }
                      } else {
                        {
#line 347
                        tmp___220 = strlen("COS");
                        }
#line 347
                        if ((int )*(expr + tmp___220) == 0) {
                          {
#line 347
                          (rpnp + steps)->op = (enum op_en )17;
#line 347
                          tmp___5 = strlen("COS");
#line 347
                          expr += tmp___5;
                          }
                        } else {
#line 347
                          goto _L___40;
                        }
                      }
                    } else {
                      _L___40: /* CIL Label */ 
                      {
#line 348
                      tmp___213 = strlen("LOG");
#line 348
                      tmp___214 = strncmp((char const   *)expr, "LOG", tmp___213);
                      }
#line 348
                      if (tmp___214 == 0) {
                        {
#line 348
                        tmp___215 = strlen("LOG");
                        }
#line 348
                        if ((int )*(expr + tmp___215) == 44) {
                          {
#line 348
                          (rpnp + steps)->op = (enum op_en )18;
#line 348
                          tmp___6 = strlen("LOG");
#line 348
                          expr += tmp___6;
                          }
                        } else {
                          {
#line 348
                          tmp___216 = strlen("LOG");
                          }
#line 348
                          if ((int )*(expr + tmp___216) == 0) {
                            {
#line 348
                            (rpnp + steps)->op = (enum op_en )18;
#line 348
                            tmp___6 = strlen("LOG");
#line 348
                            expr += tmp___6;
                            }
                          } else {
#line 348
                            goto _L___39;
                          }
                        }
                      } else {
                        _L___39: /* CIL Label */ 
                        {
#line 349
                        tmp___209 = strlen("FLOOR");
#line 349
                        tmp___210 = strncmp((char const   *)expr, "FLOOR", tmp___209);
                        }
#line 349
                        if (tmp___210 == 0) {
                          {
#line 349
                          tmp___211 = strlen("FLOOR");
                          }
#line 349
                          if ((int )*(expr + tmp___211) == 44) {
                            {
#line 349
                            (rpnp + steps)->op = (enum op_en )29;
#line 349
                            tmp___7 = strlen("FLOOR");
#line 349
                            expr += tmp___7;
                            }
                          } else {
                            {
#line 349
                            tmp___212 = strlen("FLOOR");
                            }
#line 349
                            if ((int )*(expr + tmp___212) == 0) {
                              {
#line 349
                              (rpnp + steps)->op = (enum op_en )29;
#line 349
                              tmp___7 = strlen("FLOOR");
#line 349
                              expr += tmp___7;
                              }
                            } else {
#line 349
                              goto _L___38;
                            }
                          }
                        } else {
                          _L___38: /* CIL Label */ 
                          {
#line 350
                          tmp___205 = strlen("CEIL");
#line 350
                          tmp___206 = strncmp((char const   *)expr, "CEIL", tmp___205);
                          }
#line 350
                          if (tmp___206 == 0) {
                            {
#line 350
                            tmp___207 = strlen("CEIL");
                            }
#line 350
                            if ((int )*(expr + tmp___207) == 44) {
                              {
#line 350
                              (rpnp + steps)->op = (enum op_en )30;
#line 350
                              tmp___8 = strlen("CEIL");
#line 350
                              expr += tmp___8;
                              }
                            } else {
                              {
#line 350
                              tmp___208 = strlen("CEIL");
                              }
#line 350
                              if ((int )*(expr + tmp___208) == 0) {
                                {
#line 350
                                (rpnp + steps)->op = (enum op_en )30;
#line 350
                                tmp___8 = strlen("CEIL");
#line 350
                                expr += tmp___8;
                                }
                              } else {
#line 350
                                goto _L___37;
                              }
                            }
                          } else {
                            _L___37: /* CIL Label */ 
                            {
#line 351
                            tmp___201 = strlen("EXP");
#line 351
                            tmp___202 = strncmp((char const   *)expr, "EXP", tmp___201);
                            }
#line 351
                            if (tmp___202 == 0) {
                              {
#line 351
                              tmp___203 = strlen("EXP");
                              }
#line 351
                              if ((int )*(expr + tmp___203) == 44) {
                                {
#line 351
                                (rpnp + steps)->op = (enum op_en )19;
#line 351
                                tmp___9 = strlen("EXP");
#line 351
                                expr += tmp___9;
                                }
                              } else {
                                {
#line 351
                                tmp___204 = strlen("EXP");
                                }
#line 351
                                if ((int )*(expr + tmp___204) == 0) {
                                  {
#line 351
                                  (rpnp + steps)->op = (enum op_en )19;
#line 351
                                  tmp___9 = strlen("EXP");
#line 351
                                  expr += tmp___9;
                                  }
                                } else {
#line 351
                                  goto _L___36;
                                }
                              }
                            } else {
                              _L___36: /* CIL Label */ 
                              {
#line 352
                              tmp___197 = strlen("DUP");
#line 352
                              tmp___198 = strncmp((char const   *)expr, "DUP", tmp___197);
                              }
#line 352
                              if (tmp___198 == 0) {
                                {
#line 352
                                tmp___199 = strlen("DUP");
                                }
#line 352
                                if ((int )*(expr + tmp___199) == 44) {
                                  {
#line 352
                                  (rpnp + steps)->op = (enum op_en )14;
#line 352
                                  tmp___10 = strlen("DUP");
#line 352
                                  expr += tmp___10;
                                  }
                                } else {
                                  {
#line 352
                                  tmp___200 = strlen("DUP");
                                  }
#line 352
                                  if ((int )*(expr + tmp___200) == 0) {
                                    {
#line 352
                                    (rpnp + steps)->op = (enum op_en )14;
#line 352
                                    tmp___10 = strlen("DUP");
#line 352
                                    expr += tmp___10;
                                    }
                                  } else {
#line 352
                                    goto _L___35;
                                  }
                                }
                              } else {
                                _L___35: /* CIL Label */ 
                                {
#line 353
                                tmp___193 = strlen("EXC");
#line 353
                                tmp___194 = strncmp((char const   *)expr, "EXC", tmp___193);
                                }
#line 353
                                if (tmp___194 == 0) {
                                  {
#line 353
                                  tmp___195 = strlen("EXC");
                                  }
#line 353
                                  if ((int )*(expr + tmp___195) == 44) {
                                    {
#line 353
                                    (rpnp + steps)->op = (enum op_en )15;
#line 353
                                    tmp___11 = strlen("EXC");
#line 353
                                    expr += tmp___11;
                                    }
                                  } else {
                                    {
#line 353
                                    tmp___196 = strlen("EXC");
                                    }
#line 353
                                    if ((int )*(expr + tmp___196) == 0) {
                                      {
#line 353
                                      (rpnp + steps)->op = (enum op_en )15;
#line 353
                                      tmp___11 = strlen("EXC");
#line 353
                                      expr += tmp___11;
                                      }
                                    } else {
#line 353
                                      goto _L___34;
                                    }
                                  }
                                } else {
                                  _L___34: /* CIL Label */ 
                                  {
#line 354
                                  tmp___189 = strlen("POP");
#line 354
                                  tmp___190 = strncmp((char const   *)expr, "POP",
                                                      tmp___189);
                                  }
#line 354
                                  if (tmp___190 == 0) {
                                    {
#line 354
                                    tmp___191 = strlen("POP");
                                    }
#line 354
                                    if ((int )*(expr + tmp___191) == 44) {
                                      {
#line 354
                                      (rpnp + steps)->op = (enum op_en )16;
#line 354
                                      tmp___12 = strlen("POP");
#line 354
                                      expr += tmp___12;
                                      }
                                    } else {
                                      {
#line 354
                                      tmp___192 = strlen("POP");
                                      }
#line 354
                                      if ((int )*(expr + tmp___192) == 0) {
                                        {
#line 354
                                        (rpnp + steps)->op = (enum op_en )16;
#line 354
                                        tmp___12 = strlen("POP");
#line 354
                                        expr += tmp___12;
                                        }
                                      } else {
#line 354
                                        goto _L___33;
                                      }
                                    }
                                  } else {
                                    _L___33: /* CIL Label */ 
                                    {
#line 355
                                    tmp___185 = strlen("LTIME");
#line 355
                                    tmp___186 = strncmp((char const   *)expr, "LTIME",
                                                        tmp___185);
                                    }
#line 355
                                    if (tmp___186 == 0) {
                                      {
#line 355
                                      tmp___187 = strlen("LTIME");
                                      }
#line 355
                                      if ((int )*(expr + tmp___187) == 44) {
                                        {
#line 355
                                        (rpnp + steps)->op = (enum op_en )33;
#line 355
                                        tmp___13 = strlen("LTIME");
#line 355
                                        expr += tmp___13;
                                        }
                                      } else {
                                        {
#line 355
                                        tmp___188 = strlen("LTIME");
                                        }
#line 355
                                        if ((int )*(expr + tmp___188) == 0) {
                                          {
#line 355
                                          (rpnp + steps)->op = (enum op_en )33;
#line 355
                                          tmp___13 = strlen("LTIME");
#line 355
                                          expr += tmp___13;
                                          }
                                        } else {
#line 355
                                          goto _L___32;
                                        }
                                      }
                                    } else {
                                      _L___32: /* CIL Label */ 
                                      {
#line 356
                                      tmp___181 = strlen("LT");
#line 356
                                      tmp___182 = strncmp((char const   *)expr, "LT",
                                                          tmp___181);
                                      }
#line 356
                                      if (tmp___182 == 0) {
                                        {
#line 356
                                        tmp___183 = strlen("LT");
                                        }
#line 356
                                        if ((int )*(expr + tmp___183) == 44) {
                                          {
#line 356
                                          (rpnp + steps)->op = (enum op_en )20;
#line 356
                                          tmp___14 = strlen("LT");
#line 356
                                          expr += tmp___14;
                                          }
                                        } else {
                                          {
#line 356
                                          tmp___184 = strlen("LT");
                                          }
#line 356
                                          if ((int )*(expr + tmp___184) == 0) {
                                            {
#line 356
                                            (rpnp + steps)->op = (enum op_en )20;
#line 356
                                            tmp___14 = strlen("LT");
#line 356
                                            expr += tmp___14;
                                            }
                                          } else {
#line 356
                                            goto _L___31;
                                          }
                                        }
                                      } else {
                                        _L___31: /* CIL Label */ 
                                        {
#line 357
                                        tmp___177 = strlen("LE");
#line 357
                                        tmp___178 = strncmp((char const   *)expr,
                                                            "LE", tmp___177);
                                        }
#line 357
                                        if (tmp___178 == 0) {
                                          {
#line 357
                                          tmp___179 = strlen("LE");
                                          }
#line 357
                                          if ((int )*(expr + tmp___179) == 44) {
                                            {
#line 357
                                            (rpnp + steps)->op = (enum op_en )21;
#line 357
                                            tmp___15 = strlen("LE");
#line 357
                                            expr += tmp___15;
                                            }
                                          } else {
                                            {
#line 357
                                            tmp___180 = strlen("LE");
                                            }
#line 357
                                            if ((int )*(expr + tmp___180) == 0) {
                                              {
#line 357
                                              (rpnp + steps)->op = (enum op_en )21;
#line 357
                                              tmp___15 = strlen("LE");
#line 357
                                              expr += tmp___15;
                                              }
                                            } else {
#line 357
                                              goto _L___30;
                                            }
                                          }
                                        } else {
                                          _L___30: /* CIL Label */ 
                                          {
#line 358
                                          tmp___173 = strlen("GT");
#line 358
                                          tmp___174 = strncmp((char const   *)expr,
                                                              "GT", tmp___173);
                                          }
#line 358
                                          if (tmp___174 == 0) {
                                            {
#line 358
                                            tmp___175 = strlen("GT");
                                            }
#line 358
                                            if ((int )*(expr + tmp___175) == 44) {
                                              {
#line 358
                                              (rpnp + steps)->op = (enum op_en )22;
#line 358
                                              tmp___16 = strlen("GT");
#line 358
                                              expr += tmp___16;
                                              }
                                            } else {
                                              {
#line 358
                                              tmp___176 = strlen("GT");
                                              }
#line 358
                                              if ((int )*(expr + tmp___176) == 0) {
                                                {
#line 358
                                                (rpnp + steps)->op = (enum op_en )22;
#line 358
                                                tmp___16 = strlen("GT");
#line 358
                                                expr += tmp___16;
                                                }
                                              } else {
#line 358
                                                goto _L___29;
                                              }
                                            }
                                          } else {
                                            _L___29: /* CIL Label */ 
                                            {
#line 359
                                            tmp___169 = strlen("GE");
#line 359
                                            tmp___170 = strncmp((char const   *)expr,
                                                                "GE", tmp___169);
                                            }
#line 359
                                            if (tmp___170 == 0) {
                                              {
#line 359
                                              tmp___171 = strlen("GE");
                                              }
#line 359
                                              if ((int )*(expr + tmp___171) == 44) {
                                                {
#line 359
                                                (rpnp + steps)->op = (enum op_en )23;
#line 359
                                                tmp___17 = strlen("GE");
#line 359
                                                expr += tmp___17;
                                                }
                                              } else {
                                                {
#line 359
                                                tmp___172 = strlen("GE");
                                                }
#line 359
                                                if ((int )*(expr + tmp___172) == 0) {
                                                  {
#line 359
                                                  (rpnp + steps)->op = (enum op_en )23;
#line 359
                                                  tmp___17 = strlen("GE");
#line 359
                                                  expr += tmp___17;
                                                  }
                                                } else {
#line 359
                                                  goto _L___28;
                                                }
                                              }
                                            } else {
                                              _L___28: /* CIL Label */ 
                                              {
#line 360
                                              tmp___165 = strlen("EQ");
#line 360
                                              tmp___166 = strncmp((char const   *)expr,
                                                                  "EQ", tmp___165);
                                              }
#line 360
                                              if (tmp___166 == 0) {
                                                {
#line 360
                                                tmp___167 = strlen("EQ");
                                                }
#line 360
                                                if ((int )*(expr + tmp___167) == 44) {
                                                  {
#line 360
                                                  (rpnp + steps)->op = (enum op_en )24;
#line 360
                                                  tmp___18 = strlen("EQ");
#line 360
                                                  expr += tmp___18;
                                                  }
                                                } else {
                                                  {
#line 360
                                                  tmp___168 = strlen("EQ");
                                                  }
#line 360
                                                  if ((int )*(expr + tmp___168) == 0) {
                                                    {
#line 360
                                                    (rpnp + steps)->op = (enum op_en )24;
#line 360
                                                    tmp___18 = strlen("EQ");
#line 360
                                                    expr += tmp___18;
                                                    }
                                                  } else {
#line 360
                                                    goto _L___27;
                                                  }
                                                }
                                              } else {
                                                _L___27: /* CIL Label */ 
                                                {
#line 361
                                                tmp___161 = strlen("IF");
#line 361
                                                tmp___162 = strncmp((char const   *)expr,
                                                                    "IF", tmp___161);
                                                }
#line 361
                                                if (tmp___162 == 0) {
                                                  {
#line 361
                                                  tmp___163 = strlen("IF");
                                                  }
#line 361
                                                  if ((int )*(expr + tmp___163) == 44) {
                                                    {
#line 361
                                                    (rpnp + steps)->op = (enum op_en )25;
#line 361
                                                    tmp___19 = strlen("IF");
#line 361
                                                    expr += tmp___19;
                                                    }
                                                  } else {
                                                    {
#line 361
                                                    tmp___164 = strlen("IF");
                                                    }
#line 361
                                                    if ((int )*(expr + tmp___164) == 0) {
                                                      {
#line 361
                                                      (rpnp + steps)->op = (enum op_en )25;
#line 361
                                                      tmp___19 = strlen("IF");
#line 361
                                                      expr += tmp___19;
                                                      }
                                                    } else {
#line 361
                                                      goto _L___26;
                                                    }
                                                  }
                                                } else {
                                                  _L___26: /* CIL Label */ 
                                                  {
#line 362
                                                  tmp___157 = strlen("MIN");
#line 362
                                                  tmp___158 = strncmp((char const   *)expr,
                                                                      "MIN", tmp___157);
                                                  }
#line 362
                                                  if (tmp___158 == 0) {
                                                    {
#line 362
                                                    tmp___159 = strlen("MIN");
                                                    }
#line 362
                                                    if ((int )*(expr + tmp___159) == 44) {
                                                      {
#line 362
                                                      (rpnp + steps)->op = (enum op_en )26;
#line 362
                                                      tmp___20 = strlen("MIN");
#line 362
                                                      expr += tmp___20;
                                                      }
                                                    } else {
                                                      {
#line 362
                                                      tmp___160 = strlen("MIN");
                                                      }
#line 362
                                                      if ((int )*(expr + tmp___160) == 0) {
                                                        {
#line 362
                                                        (rpnp + steps)->op = (enum op_en )26;
#line 362
                                                        tmp___20 = strlen("MIN");
#line 362
                                                        expr += tmp___20;
                                                        }
                                                      } else {
#line 362
                                                        goto _L___25;
                                                      }
                                                    }
                                                  } else {
                                                    _L___25: /* CIL Label */ 
                                                    {
#line 363
                                                    tmp___153 = strlen("MAX");
#line 363
                                                    tmp___154 = strncmp((char const   *)expr,
                                                                        "MAX", tmp___153);
                                                    }
#line 363
                                                    if (tmp___154 == 0) {
                                                      {
#line 363
                                                      tmp___155 = strlen("MAX");
                                                      }
#line 363
                                                      if ((int )*(expr + tmp___155) == 44) {
                                                        {
#line 363
                                                        (rpnp + steps)->op = (enum op_en )27;
#line 363
                                                        tmp___21 = strlen("MAX");
#line 363
                                                        expr += tmp___21;
                                                        }
                                                      } else {
                                                        {
#line 363
                                                        tmp___156 = strlen("MAX");
                                                        }
#line 363
                                                        if ((int )*(expr + tmp___156) == 0) {
                                                          {
#line 363
                                                          (rpnp + steps)->op = (enum op_en )27;
#line 363
                                                          tmp___21 = strlen("MAX");
#line 363
                                                          expr += tmp___21;
                                                          }
                                                        } else {
#line 363
                                                          goto _L___24;
                                                        }
                                                      }
                                                    } else {
                                                      _L___24: /* CIL Label */ 
                                                      {
#line 364
                                                      tmp___149 = strlen("LIMIT");
#line 364
                                                      tmp___150 = strncmp((char const   *)expr,
                                                                          "LIMIT",
                                                                          tmp___149);
                                                      }
#line 364
                                                      if (tmp___150 == 0) {
                                                        {
#line 364
                                                        tmp___151 = strlen("LIMIT");
                                                        }
#line 364
                                                        if ((int )*(expr + tmp___151) == 44) {
                                                          {
#line 364
                                                          (rpnp + steps)->op = (enum op_en )28;
#line 364
                                                          tmp___22 = strlen("LIMIT");
#line 364
                                                          expr += tmp___22;
                                                          }
                                                        } else {
                                                          {
#line 364
                                                          tmp___152 = strlen("LIMIT");
                                                          }
#line 364
                                                          if ((int )*(expr + tmp___152) == 0) {
                                                            {
#line 364
                                                            (rpnp + steps)->op = (enum op_en )28;
#line 364
                                                            tmp___22 = strlen("LIMIT");
#line 364
                                                            expr += tmp___22;
                                                            }
                                                          } else {
#line 364
                                                            goto _L___23;
                                                          }
                                                        }
                                                      } else {
                                                        _L___23: /* CIL Label */ 
                                                        {
#line 366
                                                        tmp___145 = strlen("UNKN");
#line 366
                                                        tmp___146 = strncmp((char const   *)expr,
                                                                            "UNKN",
                                                                            tmp___145);
                                                        }
#line 366
                                                        if (tmp___146 == 0) {
                                                          {
#line 366
                                                          tmp___147 = strlen("UNKN");
                                                          }
#line 366
                                                          if ((int )*(expr + tmp___147) == 44) {
                                                            {
#line 366
                                                            (rpnp + steps)->op = (enum op_en )5;
#line 366
                                                            tmp___23 = strlen("UNKN");
#line 366
                                                            expr += tmp___23;
                                                            }
                                                          } else {
                                                            {
#line 366
                                                            tmp___148 = strlen("UNKN");
                                                            }
#line 366
                                                            if ((int )*(expr + tmp___148) == 0) {
                                                              {
#line 366
                                                              (rpnp + steps)->op = (enum op_en )5;
#line 366
                                                              tmp___23 = strlen("UNKN");
#line 366
                                                              expr += tmp___23;
                                                              }
                                                            } else {
#line 366
                                                              goto _L___22;
                                                            }
                                                          }
                                                        } else {
                                                          _L___22: /* CIL Label */ 
                                                          {
#line 367
                                                          tmp___141 = strlen("UN");
#line 367
                                                          tmp___142 = strncmp((char const   *)expr,
                                                                              "UN",
                                                                              tmp___141);
                                                          }
#line 367
                                                          if (tmp___142 == 0) {
                                                            {
#line 367
                                                            tmp___143 = strlen("UN");
                                                            }
#line 367
                                                            if ((int )*(expr + tmp___143) == 44) {
                                                              {
#line 367
                                                              (rpnp + steps)->op = (enum op_en )31;
#line 367
                                                              tmp___24 = strlen("UN");
#line 367
                                                              expr += tmp___24;
                                                              }
                                                            } else {
                                                              {
#line 367
                                                              tmp___144 = strlen("UN");
                                                              }
#line 367
                                                              if ((int )*(expr + tmp___144) == 0) {
                                                                {
#line 367
                                                                (rpnp + steps)->op = (enum op_en )31;
#line 367
                                                                tmp___24 = strlen("UN");
#line 367
                                                                expr += tmp___24;
                                                                }
                                                              } else {
#line 367
                                                                goto _L___21;
                                                              }
                                                            }
                                                          } else {
                                                            _L___21: /* CIL Label */ 
                                                            {
#line 368
                                                            tmp___137 = strlen("NEGINF");
#line 368
                                                            tmp___138 = strncmp((char const   *)expr,
                                                                                "NEGINF",
                                                                                tmp___137);
                                                            }
#line 368
                                                            if (tmp___138 == 0) {
                                                              {
#line 368
                                                              tmp___139 = strlen("NEGINF");
                                                              }
#line 368
                                                              if ((int )*(expr + tmp___139) == 44) {
                                                                {
#line 368
                                                                (rpnp + steps)->op = (enum op_en )4;
#line 368
                                                                tmp___25 = strlen("NEGINF");
#line 368
                                                                expr += tmp___25;
                                                                }
                                                              } else {
                                                                {
#line 368
                                                                tmp___140 = strlen("NEGINF");
                                                                }
#line 368
                                                                if ((int )*(expr + tmp___140) == 0) {
                                                                  {
#line 368
                                                                  (rpnp + steps)->op = (enum op_en )4;
#line 368
                                                                  tmp___25 = strlen("NEGINF");
#line 368
                                                                  expr += tmp___25;
                                                                  }
                                                                } else {
#line 368
                                                                  goto _L___20;
                                                                }
                                                              }
                                                            } else {
                                                              _L___20: /* CIL Label */ 
                                                              {
#line 369
                                                              tmp___133 = strlen("NE");
#line 369
                                                              tmp___134 = strncmp((char const   *)expr,
                                                                                  "NE",
                                                                                  tmp___133);
                                                              }
#line 369
                                                              if (tmp___134 == 0) {
                                                                {
#line 369
                                                                tmp___135 = strlen("NE");
                                                                }
#line 369
                                                                if ((int )*(expr + tmp___135) == 44) {
                                                                  {
#line 369
                                                                  (rpnp + steps)->op = (enum op_en )34;
#line 369
                                                                  tmp___26 = strlen("NE");
#line 369
                                                                  expr += tmp___26;
                                                                  }
                                                                } else {
                                                                  {
#line 369
                                                                  tmp___136 = strlen("NE");
                                                                  }
#line 369
                                                                  if ((int )*(expr + tmp___136) == 0) {
                                                                    {
#line 369
                                                                    (rpnp + steps)->op = (enum op_en )34;
#line 369
                                                                    tmp___26 = strlen("NE");
#line 369
                                                                    expr += tmp___26;
                                                                    }
                                                                  } else {
#line 369
                                                                    goto _L___19;
                                                                  }
                                                                }
                                                              } else {
                                                                _L___19: /* CIL Label */ 
                                                                {
#line 370
                                                                tmp___129 = strlen("COUNT");
#line 370
                                                                tmp___130 = strncmp((char const   *)expr,
                                                                                    "COUNT",
                                                                                    tmp___129);
                                                                }
#line 370
                                                                if (tmp___130 == 0) {
                                                                  {
#line 370
                                                                  tmp___131 = strlen("COUNT");
                                                                  }
#line 370
                                                                  if ((int )*(expr + tmp___131) == 44) {
                                                                    {
#line 370
                                                                    (rpnp + steps)->op = (enum op_en )37;
#line 370
                                                                    tmp___27 = strlen("COUNT");
#line 370
                                                                    expr += tmp___27;
                                                                    }
                                                                  } else {
                                                                    {
#line 370
                                                                    tmp___132 = strlen("COUNT");
                                                                    }
#line 370
                                                                    if ((int )*(expr + tmp___132) == 0) {
                                                                      {
#line 370
                                                                      (rpnp + steps)->op = (enum op_en )37;
#line 370
                                                                      tmp___27 = strlen("COUNT");
#line 370
                                                                      expr += tmp___27;
                                                                      }
                                                                    } else {
#line 370
                                                                      goto _L___18;
                                                                    }
                                                                  }
                                                                } else {
                                                                  _L___18: /* CIL Label */ 
                                                                  {
#line 371
                                                                  tmp___128 = sscanf((char const   */* __restrict  */)expr,
                                                                                     (char const   */* __restrict  */)"PREV(%255[-_A-Za-z0-9])",
                                                                                     vname);
                                                                  }
#line 371
                                                                  if (tmp___128 == 1) {
                                                                    {
#line 371
                                                                    length = 0;
#line 371
                                                                    tmp___28 = strlen("PREV");
#line 371
                                                                    tmp___29 = strlen((char const   *)(vname));
#line 371
                                                                    length = (int )((tmp___28 + tmp___29) + 2UL);
                                                                    }
#line 371
                                                                    if ((int )*(expr + length) == 44) {
#line 371
                                                                      tmp___30 = 1;
                                                                    } else
#line 371
                                                                    if ((int )*(expr + length) == 0) {
#line 371
                                                                      tmp___30 = 1;
                                                                    } else {
#line 371
                                                                      tmp___30 = 0;
                                                                    }
#line 371
                                                                    if (tmp___30) {
                                                                      {
#line 371
                                                                      (rpnp + steps)->op = (enum op_en )36;
#line 371
                                                                      (rpnp + steps)->ptr = (*lookup)(key_hash,
                                                                                                      vname);
                                                                      }
#line 371
                                                                      if ((rpnp + steps)->ptr < 0L) {
                                                                        {
#line 371
                                                                        rrd_set_error((char *)"variable \'%s\' not found",
                                                                                      vname);
#line 371
                                                                        free((void *)rpnp);
                                                                        }
#line 371
                                                                        return ((rpnp_t *)((void *)0));
                                                                      } else {
#line 371
                                                                        expr += length;
                                                                      }
                                                                    }
                                                                  } else {
                                                                    {
#line 372
                                                                    tmp___124 = strlen("PREV");
#line 372
                                                                    tmp___125 = strncmp((char const   *)expr,
                                                                                        "PREV",
                                                                                        tmp___124);
                                                                    }
#line 372
                                                                    if (tmp___125 == 0) {
                                                                      {
#line 372
                                                                      tmp___126 = strlen("PREV");
                                                                      }
#line 372
                                                                      if ((int )*(expr + tmp___126) == 44) {
                                                                        {
#line 372
                                                                        (rpnp + steps)->op = (enum op_en )3;
#line 372
                                                                        tmp___31 = strlen("PREV");
#line 372
                                                                        expr += tmp___31;
                                                                        }
                                                                      } else {
                                                                        {
#line 372
                                                                        tmp___127 = strlen("PREV");
                                                                        }
#line 372
                                                                        if ((int )*(expr + tmp___127) == 0) {
                                                                          {
#line 372
                                                                          (rpnp + steps)->op = (enum op_en )3;
#line 372
                                                                          tmp___31 = strlen("PREV");
#line 372
                                                                          expr += tmp___31;
                                                                          }
                                                                        } else {
#line 372
                                                                          goto _L___17;
                                                                        }
                                                                      }
                                                                    } else {
                                                                      _L___17: /* CIL Label */ 
                                                                      {
#line 373
                                                                      tmp___120 = strlen("INF");
#line 373
                                                                      tmp___121 = strncmp((char const   *)expr,
                                                                                          "INF",
                                                                                          tmp___120);
                                                                      }
#line 373
                                                                      if (tmp___121 == 0) {
                                                                        {
#line 373
                                                                        tmp___122 = strlen("INF");
                                                                        }
#line 373
                                                                        if ((int )*(expr + tmp___122) == 44) {
                                                                          {
#line 373
                                                                          (rpnp + steps)->op = (enum op_en )2;
#line 373
                                                                          tmp___32 = strlen("INF");
#line 373
                                                                          expr += tmp___32;
                                                                          }
                                                                        } else {
                                                                          {
#line 373
                                                                          tmp___123 = strlen("INF");
                                                                          }
#line 373
                                                                          if ((int )*(expr + tmp___123) == 0) {
                                                                            {
#line 373
                                                                            (rpnp + steps)->op = (enum op_en )2;
#line 373
                                                                            tmp___32 = strlen("INF");
#line 373
                                                                            expr += tmp___32;
                                                                            }
                                                                          } else {
#line 373
                                                                            goto _L___16;
                                                                          }
                                                                        }
                                                                      } else {
                                                                        _L___16: /* CIL Label */ 
                                                                        {
#line 374
                                                                        tmp___116 = strlen("ISINF");
#line 374
                                                                        tmp___117 = strncmp((char const   *)expr,
                                                                                            "ISINF",
                                                                                            tmp___116);
                                                                        }
#line 374
                                                                        if (tmp___117 == 0) {
                                                                          {
#line 374
                                                                          tmp___118 = strlen("ISINF");
                                                                          }
#line 374
                                                                          if ((int )*(expr + tmp___118) == 44) {
                                                                            {
#line 374
                                                                            (rpnp + steps)->op = (enum op_en )35;
#line 374
                                                                            tmp___33 = strlen("ISINF");
#line 374
                                                                            expr += tmp___33;
                                                                            }
                                                                          } else {
                                                                            {
#line 374
                                                                            tmp___119 = strlen("ISINF");
                                                                            }
#line 374
                                                                            if ((int )*(expr + tmp___119) == 0) {
                                                                              {
#line 374
                                                                              (rpnp + steps)->op = (enum op_en )35;
#line 374
                                                                              tmp___33 = strlen("ISINF");
#line 374
                                                                              expr += tmp___33;
                                                                              }
                                                                            } else {
#line 374
                                                                              goto _L___15;
                                                                            }
                                                                          }
                                                                        } else {
                                                                          _L___15: /* CIL Label */ 
                                                                          {
#line 375
                                                                          tmp___112 = strlen("NOW");
#line 375
                                                                          tmp___113 = strncmp((char const   *)expr,
                                                                                              "NOW",
                                                                                              tmp___112);
                                                                          }
#line 375
                                                                          if (tmp___113 == 0) {
                                                                            {
#line 375
                                                                            tmp___114 = strlen("NOW");
                                                                            }
#line 375
                                                                            if ((int )*(expr + tmp___114) == 44) {
                                                                              {
#line 375
                                                                              (rpnp + steps)->op = (enum op_en )6;
#line 375
                                                                              tmp___34 = strlen("NOW");
#line 375
                                                                              expr += tmp___34;
                                                                              }
                                                                            } else {
                                                                              {
#line 375
                                                                              tmp___115 = strlen("NOW");
                                                                              }
#line 375
                                                                              if ((int )*(expr + tmp___115) == 0) {
                                                                                {
#line 375
                                                                                (rpnp + steps)->op = (enum op_en )6;
#line 375
                                                                                tmp___34 = strlen("NOW");
#line 375
                                                                                expr += tmp___34;
                                                                                }
                                                                              } else {
#line 375
                                                                                goto _L___14;
                                                                              }
                                                                            }
                                                                          } else {
                                                                            _L___14: /* CIL Label */ 
                                                                            {
#line 376
                                                                            tmp___108 = strlen("TIME");
#line 376
                                                                            tmp___109 = strncmp((char const   *)expr,
                                                                                                "TIME",
                                                                                                tmp___108);
                                                                            }
#line 376
                                                                            if (tmp___109 == 0) {
                                                                              {
#line 376
                                                                              tmp___110 = strlen("TIME");
                                                                              }
#line 376
                                                                              if ((int )*(expr + tmp___110) == 44) {
                                                                                {
#line 376
                                                                                (rpnp + steps)->op = (enum op_en )7;
#line 376
                                                                                tmp___35 = strlen("TIME");
#line 376
                                                                                expr += tmp___35;
                                                                                }
                                                                              } else {
                                                                                {
#line 376
                                                                                tmp___111 = strlen("TIME");
                                                                                }
#line 376
                                                                                if ((int )*(expr + tmp___111) == 0) {
                                                                                  {
#line 376
                                                                                  (rpnp + steps)->op = (enum op_en )7;
#line 376
                                                                                  tmp___35 = strlen("TIME");
#line 376
                                                                                  expr += tmp___35;
                                                                                  }
                                                                                } else {
#line 376
                                                                                  goto _L___13;
                                                                                }
                                                                              }
                                                                            } else {
                                                                              _L___13: /* CIL Label */ 
                                                                              {
#line 377
                                                                              tmp___104 = strlen("ATAN2");
#line 377
                                                                              tmp___105 = strncmp((char const   *)expr,
                                                                                                  "ATAN2",
                                                                                                  tmp___104);
                                                                              }
#line 377
                                                                              if (tmp___105 == 0) {
                                                                                {
#line 377
                                                                                tmp___106 = strlen("ATAN2");
                                                                                }
#line 377
                                                                                if ((int )*(expr + tmp___106) == 44) {
                                                                                  {
#line 377
                                                                                  (rpnp + steps)->op = (enum op_en )44;
#line 377
                                                                                  tmp___36 = strlen("ATAN2");
#line 377
                                                                                  expr += tmp___36;
                                                                                  }
                                                                                } else {
                                                                                  {
#line 377
                                                                                  tmp___107 = strlen("ATAN2");
                                                                                  }
#line 377
                                                                                  if ((int )*(expr + tmp___107) == 0) {
                                                                                    {
#line 377
                                                                                    (rpnp + steps)->op = (enum op_en )44;
#line 377
                                                                                    tmp___36 = strlen("ATAN2");
#line 377
                                                                                    expr += tmp___36;
                                                                                    }
                                                                                  } else {
#line 377
                                                                                    goto _L___12;
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                _L___12: /* CIL Label */ 
                                                                                {
#line 378
                                                                                tmp___100 = strlen("ATAN");
#line 378
                                                                                tmp___101 = strncmp((char const   *)expr,
                                                                                                    "ATAN",
                                                                                                    tmp___100);
                                                                                }
#line 378
                                                                                if (tmp___101 == 0) {
                                                                                  {
#line 378
                                                                                  tmp___102 = strlen("ATAN");
                                                                                  }
#line 378
                                                                                  if ((int )*(expr + tmp___102) == 44) {
                                                                                    {
#line 378
                                                                                    (rpnp + steps)->op = (enum op_en )38;
#line 378
                                                                                    tmp___37 = strlen("ATAN");
#line 378
                                                                                    expr += tmp___37;
                                                                                    }
                                                                                  } else {
                                                                                    {
#line 378
                                                                                    tmp___103 = strlen("ATAN");
                                                                                    }
#line 378
                                                                                    if ((int )*(expr + tmp___103) == 0) {
                                                                                      {
#line 378
                                                                                      (rpnp + steps)->op = (enum op_en )38;
#line 378
                                                                                      tmp___37 = strlen("ATAN");
#line 378
                                                                                      expr += tmp___37;
                                                                                      }
                                                                                    } else {
#line 378
                                                                                      goto _L___11;
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  _L___11: /* CIL Label */ 
                                                                                  {
#line 379
                                                                                  tmp___96 = strlen("SQRT");
#line 379
                                                                                  tmp___97 = strncmp((char const   *)expr,
                                                                                                     "SQRT",
                                                                                                     tmp___96);
                                                                                  }
#line 379
                                                                                  if (tmp___97 == 0) {
                                                                                    {
#line 379
                                                                                    tmp___98 = strlen("SQRT");
                                                                                    }
#line 379
                                                                                    if ((int )*(expr + tmp___98) == 44) {
                                                                                      {
#line 379
                                                                                      (rpnp + steps)->op = (enum op_en )39;
#line 379
                                                                                      tmp___38 = strlen("SQRT");
#line 379
                                                                                      expr += tmp___38;
                                                                                      }
                                                                                    } else {
                                                                                      {
#line 379
                                                                                      tmp___99 = strlen("SQRT");
                                                                                      }
#line 379
                                                                                      if ((int )*(expr + tmp___99) == 0) {
                                                                                        {
#line 379
                                                                                        (rpnp + steps)->op = (enum op_en )39;
#line 379
                                                                                        tmp___38 = strlen("SQRT");
#line 379
                                                                                        expr += tmp___38;
                                                                                        }
                                                                                      } else {
#line 379
                                                                                        goto _L___10;
                                                                                      }
                                                                                    }
                                                                                  } else {
                                                                                    _L___10: /* CIL Label */ 
                                                                                    {
#line 380
                                                                                    tmp___92 = strlen("SORT");
#line 380
                                                                                    tmp___93 = strncmp((char const   *)expr,
                                                                                                       "SORT",
                                                                                                       tmp___92);
                                                                                    }
#line 380
                                                                                    if (tmp___93 == 0) {
                                                                                      {
#line 380
                                                                                      tmp___94 = strlen("SORT");
                                                                                      }
#line 380
                                                                                      if ((int )*(expr + tmp___94) == 44) {
                                                                                        {
#line 380
                                                                                        (rpnp + steps)->op = (enum op_en )40;
#line 380
                                                                                        tmp___39 = strlen("SORT");
#line 380
                                                                                        expr += tmp___39;
                                                                                        }
                                                                                      } else {
                                                                                        {
#line 380
                                                                                        tmp___95 = strlen("SORT");
                                                                                        }
#line 380
                                                                                        if ((int )*(expr + tmp___95) == 0) {
                                                                                          {
#line 380
                                                                                          (rpnp + steps)->op = (enum op_en )40;
#line 380
                                                                                          tmp___39 = strlen("SORT");
#line 380
                                                                                          expr += tmp___39;
                                                                                          }
                                                                                        } else {
#line 380
                                                                                          goto _L___9;
                                                                                        }
                                                                                      }
                                                                                    } else {
                                                                                      _L___9: /* CIL Label */ 
                                                                                      {
#line 381
                                                                                      tmp___88 = strlen("REV");
#line 381
                                                                                      tmp___89 = strncmp((char const   *)expr,
                                                                                                         "REV",
                                                                                                         tmp___88);
                                                                                      }
#line 381
                                                                                      if (tmp___89 == 0) {
                                                                                        {
#line 381
                                                                                        tmp___90 = strlen("REV");
                                                                                        }
#line 381
                                                                                        if ((int )*(expr + tmp___90) == 44) {
                                                                                          {
#line 381
                                                                                          (rpnp + steps)->op = (enum op_en )41;
#line 381
                                                                                          tmp___40 = strlen("REV");
#line 381
                                                                                          expr += tmp___40;
                                                                                          }
                                                                                        } else {
                                                                                          {
#line 381
                                                                                          tmp___91 = strlen("REV");
                                                                                          }
#line 381
                                                                                          if ((int )*(expr + tmp___91) == 0) {
                                                                                            {
#line 381
                                                                                            (rpnp + steps)->op = (enum op_en )41;
#line 381
                                                                                            tmp___40 = strlen("REV");
#line 381
                                                                                            expr += tmp___40;
                                                                                            }
                                                                                          } else {
#line 381
                                                                                            goto _L___8;
                                                                                          }
                                                                                        }
                                                                                      } else {
                                                                                        _L___8: /* CIL Label */ 
                                                                                        {
#line 382
                                                                                        tmp___84 = strlen("TREND");
#line 382
                                                                                        tmp___85 = strncmp((char const   *)expr,
                                                                                                           "TREND",
                                                                                                           tmp___84);
                                                                                        }
#line 382
                                                                                        if (tmp___85 == 0) {
                                                                                          {
#line 382
                                                                                          tmp___86 = strlen("TREND");
                                                                                          }
#line 382
                                                                                          if ((int )*(expr + tmp___86) == 44) {
                                                                                            {
#line 382
                                                                                            (rpnp + steps)->op = (enum op_en )42;
#line 382
                                                                                            tmp___41 = strlen("TREND");
#line 382
                                                                                            expr += tmp___41;
                                                                                            }
                                                                                          } else {
                                                                                            {
#line 382
                                                                                            tmp___87 = strlen("TREND");
                                                                                            }
#line 382
                                                                                            if ((int )*(expr + tmp___87) == 0) {
                                                                                              {
#line 382
                                                                                              (rpnp + steps)->op = (enum op_en )42;
#line 382
                                                                                              tmp___41 = strlen("TREND");
#line 382
                                                                                              expr += tmp___41;
                                                                                              }
                                                                                            } else {
#line 382
                                                                                              goto _L___7;
                                                                                            }
                                                                                          }
                                                                                        } else {
                                                                                          _L___7: /* CIL Label */ 
                                                                                          {
#line 383
                                                                                          tmp___80 = strlen("TRENDNAN");
#line 383
                                                                                          tmp___81 = strncmp((char const   *)expr,
                                                                                                             "TRENDNAN",
                                                                                                             tmp___80);
                                                                                          }
#line 383
                                                                                          if (tmp___81 == 0) {
                                                                                            {
#line 383
                                                                                            tmp___82 = strlen("TRENDNAN");
                                                                                            }
#line 383
                                                                                            if ((int )*(expr + tmp___82) == 44) {
                                                                                              {
#line 383
                                                                                              (rpnp + steps)->op = (enum op_en )43;
#line 383
                                                                                              tmp___42 = strlen("TRENDNAN");
#line 383
                                                                                              expr += tmp___42;
                                                                                              }
                                                                                            } else {
                                                                                              {
#line 383
                                                                                              tmp___83 = strlen("TRENDNAN");
                                                                                              }
#line 383
                                                                                              if ((int )*(expr + tmp___83) == 0) {
                                                                                                {
#line 383
                                                                                                (rpnp + steps)->op = (enum op_en )43;
#line 383
                                                                                                tmp___42 = strlen("TRENDNAN");
#line 383
                                                                                                expr += tmp___42;
                                                                                                }
                                                                                              } else {
#line 383
                                                                                                goto _L___6;
                                                                                              }
                                                                                            }
                                                                                          } else {
                                                                                            _L___6: /* CIL Label */ 
                                                                                            {
#line 384
                                                                                            tmp___76 = strlen("PREDICT");
#line 384
                                                                                            tmp___77 = strncmp((char const   *)expr,
                                                                                                               "PREDICT",
                                                                                                               tmp___76);
                                                                                            }
#line 384
                                                                                            if (tmp___77 == 0) {
                                                                                              {
#line 384
                                                                                              tmp___78 = strlen("PREDICT");
                                                                                              }
#line 384
                                                                                              if ((int )*(expr + tmp___78) == 44) {
                                                                                                {
#line 384
                                                                                                (rpnp + steps)->op = (enum op_en )47;
#line 384
                                                                                                tmp___43 = strlen("PREDICT");
#line 384
                                                                                                expr += tmp___43;
                                                                                                }
                                                                                              } else {
                                                                                                {
#line 384
                                                                                                tmp___79 = strlen("PREDICT");
                                                                                                }
#line 384
                                                                                                if ((int )*(expr + tmp___79) == 0) {
                                                                                                  {
#line 384
                                                                                                  (rpnp + steps)->op = (enum op_en )47;
#line 384
                                                                                                  tmp___43 = strlen("PREDICT");
#line 384
                                                                                                  expr += tmp___43;
                                                                                                  }
                                                                                                } else {
#line 384
                                                                                                  goto _L___5;
                                                                                                }
                                                                                              }
                                                                                            } else {
                                                                                              _L___5: /* CIL Label */ 
                                                                                              {
#line 385
                                                                                              tmp___72 = strlen("PREDICTSIGMA");
#line 385
                                                                                              tmp___73 = strncmp((char const   *)expr,
                                                                                                                 "PREDICTSIGMA",
                                                                                                                 tmp___72);
                                                                                              }
#line 385
                                                                                              if (tmp___73 == 0) {
                                                                                                {
#line 385
                                                                                                tmp___74 = strlen("PREDICTSIGMA");
                                                                                                }
#line 385
                                                                                                if ((int )*(expr + tmp___74) == 44) {
                                                                                                  {
#line 385
                                                                                                  (rpnp + steps)->op = (enum op_en )48;
#line 385
                                                                                                  tmp___44 = strlen("PREDICTSIGMA");
#line 385
                                                                                                  expr += tmp___44;
                                                                                                  }
                                                                                                } else {
                                                                                                  {
#line 385
                                                                                                  tmp___75 = strlen("PREDICTSIGMA");
                                                                                                  }
#line 385
                                                                                                  if ((int )*(expr + tmp___75) == 0) {
                                                                                                    {
#line 385
                                                                                                    (rpnp + steps)->op = (enum op_en )48;
#line 385
                                                                                                    tmp___44 = strlen("PREDICTSIGMA");
#line 385
                                                                                                    expr += tmp___44;
                                                                                                    }
                                                                                                  } else {
#line 385
                                                                                                    goto _L___4;
                                                                                                  }
                                                                                                }
                                                                                              } else {
                                                                                                _L___4: /* CIL Label */ 
                                                                                                {
#line 386
                                                                                                tmp___68 = strlen("RAD2DEG");
#line 386
                                                                                                tmp___69 = strncmp((char const   *)expr,
                                                                                                                   "RAD2DEG",
                                                                                                                   tmp___68);
                                                                                                }
#line 386
                                                                                                if (tmp___69 == 0) {
                                                                                                  {
#line 386
                                                                                                  tmp___70 = strlen("RAD2DEG");
                                                                                                  }
#line 386
                                                                                                  if ((int )*(expr + tmp___70) == 44) {
                                                                                                    {
#line 386
                                                                                                    (rpnp + steps)->op = (enum op_en )45;
#line 386
                                                                                                    tmp___45 = strlen("RAD2DEG");
#line 386
                                                                                                    expr += tmp___45;
                                                                                                    }
                                                                                                  } else {
                                                                                                    {
#line 386
                                                                                                    tmp___71 = strlen("RAD2DEG");
                                                                                                    }
#line 386
                                                                                                    if ((int )*(expr + tmp___71) == 0) {
                                                                                                      {
#line 386
                                                                                                      (rpnp + steps)->op = (enum op_en )45;
#line 386
                                                                                                      tmp___45 = strlen("RAD2DEG");
#line 386
                                                                                                      expr += tmp___45;
                                                                                                      }
                                                                                                    } else {
#line 386
                                                                                                      goto _L___3;
                                                                                                    }
                                                                                                  }
                                                                                                } else {
                                                                                                  _L___3: /* CIL Label */ 
                                                                                                  {
#line 387
                                                                                                  tmp___64 = strlen("DEG2RAD");
#line 387
                                                                                                  tmp___65 = strncmp((char const   *)expr,
                                                                                                                     "DEG2RAD",
                                                                                                                     tmp___64);
                                                                                                  }
#line 387
                                                                                                  if (tmp___65 == 0) {
                                                                                                    {
#line 387
                                                                                                    tmp___66 = strlen("DEG2RAD");
                                                                                                    }
#line 387
                                                                                                    if ((int )*(expr + tmp___66) == 44) {
                                                                                                      {
#line 387
                                                                                                      (rpnp + steps)->op = (enum op_en )46;
#line 387
                                                                                                      tmp___46 = strlen("DEG2RAD");
#line 387
                                                                                                      expr += tmp___46;
                                                                                                      }
                                                                                                    } else {
                                                                                                      {
#line 387
                                                                                                      tmp___67 = strlen("DEG2RAD");
                                                                                                      }
#line 387
                                                                                                      if ((int )*(expr + tmp___67) == 0) {
                                                                                                        {
#line 387
                                                                                                        (rpnp + steps)->op = (enum op_en )46;
#line 387
                                                                                                        tmp___46 = strlen("DEG2RAD");
#line 387
                                                                                                        expr += tmp___46;
                                                                                                        }
                                                                                                      } else {
#line 387
                                                                                                        goto _L___2;
                                                                                                      }
                                                                                                    }
                                                                                                  } else {
                                                                                                    _L___2: /* CIL Label */ 
                                                                                                    {
#line 388
                                                                                                    tmp___60 = strlen("AVG");
#line 388
                                                                                                    tmp___61 = strncmp((char const   *)expr,
                                                                                                                       "AVG",
                                                                                                                       tmp___60);
                                                                                                    }
#line 388
                                                                                                    if (tmp___61 == 0) {
                                                                                                      {
#line 388
                                                                                                      tmp___62 = strlen("AVG");
                                                                                                      }
#line 388
                                                                                                      if ((int )*(expr + tmp___62) == 44) {
                                                                                                        {
#line 388
                                                                                                        (rpnp + steps)->op = (enum op_en )49;
#line 388
                                                                                                        tmp___47 = strlen("AVG");
#line 388
                                                                                                        expr += tmp___47;
                                                                                                        }
                                                                                                      } else {
                                                                                                        {
#line 388
                                                                                                        tmp___63 = strlen("AVG");
                                                                                                        }
#line 388
                                                                                                        if ((int )*(expr + tmp___63) == 0) {
                                                                                                          {
#line 388
                                                                                                          (rpnp + steps)->op = (enum op_en )49;
#line 388
                                                                                                          tmp___47 = strlen("AVG");
#line 388
                                                                                                          expr += tmp___47;
                                                                                                          }
                                                                                                        } else {
#line 388
                                                                                                          goto _L___1;
                                                                                                        }
                                                                                                      }
                                                                                                    } else {
                                                                                                      _L___1: /* CIL Label */ 
                                                                                                      {
#line 389
                                                                                                      tmp___56 = strlen("ABS");
#line 389
                                                                                                      tmp___57 = strncmp((char const   *)expr,
                                                                                                                         "ABS",
                                                                                                                         tmp___56);
                                                                                                      }
#line 389
                                                                                                      if (tmp___57 == 0) {
                                                                                                        {
#line 389
                                                                                                        tmp___58 = strlen("ABS");
                                                                                                        }
#line 389
                                                                                                        if ((int )*(expr + tmp___58) == 44) {
                                                                                                          {
#line 389
                                                                                                          (rpnp + steps)->op = (enum op_en )50;
#line 389
                                                                                                          tmp___48 = strlen("ABS");
#line 389
                                                                                                          expr += tmp___48;
                                                                                                          }
                                                                                                        } else {
                                                                                                          {
#line 389
                                                                                                          tmp___59 = strlen("ABS");
                                                                                                          }
#line 389
                                                                                                          if ((int )*(expr + tmp___59) == 0) {
                                                                                                            {
#line 389
                                                                                                            (rpnp + steps)->op = (enum op_en )50;
#line 389
                                                                                                            tmp___48 = strlen("ABS");
#line 389
                                                                                                            expr += tmp___48;
                                                                                                            }
                                                                                                          } else {
#line 389
                                                                                                            goto _L___0;
                                                                                                          }
                                                                                                        }
                                                                                                      } else {
                                                                                                        _L___0: /* CIL Label */ 
                                                                                                        {
#line 390
                                                                                                        tmp___52 = strlen("ADDNAN");
#line 390
                                                                                                        tmp___53 = strncmp((char const   *)expr,
                                                                                                                           "ADDNAN",
                                                                                                                           tmp___52);
                                                                                                        }
#line 390
                                                                                                        if (tmp___53 == 0) {
                                                                                                          {
#line 390
                                                                                                          tmp___54 = strlen("ADDNAN");
                                                                                                          }
#line 390
                                                                                                          if ((int )*(expr + tmp___54) == 44) {
                                                                                                            {
#line 390
                                                                                                            (rpnp + steps)->op = (enum op_en )51;
#line 390
                                                                                                            tmp___49 = strlen("ADDNAN");
#line 390
                                                                                                            expr += tmp___49;
                                                                                                            }
                                                                                                          } else {
                                                                                                            {
#line 390
                                                                                                            tmp___55 = strlen("ADDNAN");
                                                                                                            }
#line 390
                                                                                                            if ((int )*(expr + tmp___55) == 0) {
                                                                                                              {
#line 390
                                                                                                              (rpnp + steps)->op = (enum op_en )51;
#line 390
                                                                                                              tmp___49 = strlen("ADDNAN");
#line 390
                                                                                                              expr += tmp___49;
                                                                                                              }
                                                                                                            } else {
#line 390
                                                                                                              goto _L;
                                                                                                            }
                                                                                                          }
                                                                                                        } else {
                                                                                                          _L: /* CIL Label */ 
                                                                                                          {
#line 392
                                                                                                          tmp___50 = sscanf((char const   */* __restrict  */)expr,
                                                                                                                            (char const   */* __restrict  */)"%255[-_A-Za-z0-9]%n",
                                                                                                                            vname,
                                                                                                                            & pos);
                                                                                                          }
#line 392
                                                                                                          if (tmp___50 == 1) {
                                                                                                            {
#line 392
                                                                                                            tmp___51 = (*lookup)(key_hash,
                                                                                                                                 vname);
#line 392
                                                                                                            (rpnp + steps)->ptr = tmp___51;
                                                                                                            }
#line 392
                                                                                                            if (tmp___51 != -1L) {
#line 395
                                                                                                              (rpnp + steps)->op = (enum op_en )1;
#line 396
                                                                                                              expr += pos;
                                                                                                            } else {
                                                                                                              {
#line 400
                                                                                                              rrd_set_error((char *)"don\'t undestand \'%s\'",
                                                                                                                            expr);
#line 401
                                                                                                              setlocale(1,
                                                                                                                        (char const   *)old_locale);
#line 402
                                                                                                              free((void *)rpnp);
                                                                                                              }
#line 403
                                                                                                              return ((rpnp_t *)((void *)0));
                                                                                                            }
                                                                                                          } else {
                                                                                                            {
#line 400
                                                                                                            rrd_set_error((char *)"don\'t undestand \'%s\'",
                                                                                                                          expr);
#line 401
                                                                                                            setlocale(1,
                                                                                                                      (char const   *)old_locale);
#line 402
                                                                                                            free((void *)rpnp);
                                                                                                            }
#line 403
                                                                                                            return ((rpnp_t *)((void *)0));
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 406
    if ((int )*expr == 0) {
#line 407
      goto while_break;
    }
#line 408
    if ((int )*expr == 44) {
#line 409
      expr ++;
    } else {
      {
#line 411
      setlocale(1, (char const   *)old_locale);
#line 412
      free((void *)rpnp);
      }
#line 413
      return ((rpnp_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 416
  (rpnp + (steps + 1L))->op = (enum op_en )32;
#line 417
  setlocale(1, (char const   *)old_locale);
  }
#line 418
  return (rpnp);
}
}
#line 421 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
void rpnstack_init(rpnstack_t *rpnstack ) 
{ 


  {
#line 424
  rpnstack->s = (double *)((void *)0);
#line 425
  rpnstack->dc_stacksize = 0L;
#line 426
  rpnstack->dc_stackblock = 100L;
#line 427
  return;
}
}
#line 429 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
void rpnstack_free(rpnstack_t *rpnstack ) 
{ 


  {
#line 432
  if ((unsigned long )rpnstack->s != (unsigned long )((void *)0)) {
    {
#line 433
    free((void *)rpnstack->s);
    }
  }
#line 434
  rpnstack->dc_stacksize = 0L;
#line 435
  return;
}
}
#line 437 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
static int rpn_compare_double(void const   *x , void const   *y ) 
{ 
  double diff ;
  int tmp ;
  int tmp___0 ;

  {
#line 441
  diff = (double )(*((double const   *)x) - *((double const   *)y));
#line 443
  if (diff < (double )0) {
#line 443
    tmp___0 = -1;
  } else {
#line 443
    if (diff > (double )0) {
#line 443
      tmp = 1;
    } else {
#line 443
      tmp = 0;
    }
#line 443
    tmp___0 = tmp;
  }
#line 443
  return (tmp___0);
}
}
#line 461 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
short rpn_calc(rpnp_t *rpnp , rpnstack_t *rpnstack , long data_idx , rrd_value_t *output ,
               int output_idx ) 
{ 
  int rpi ;
  long stptr ;
  void *tmp ;
  double tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  double dummy ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int spn ;
  long tmp___138 ;
  int spn___0 ;
  long tmp___139 ;
  double *p ;
  double *q ;
  double x ;
  double *tmp___140 ;
  double *tmp___141 ;
  int locstepsize ;
  int shifts ;
  double val ;
  double tmp___142 ;
  time_t dsstep ;
  int dscount ;
  int locstep ;
  double tmp___143 ;
  double sum ;
  double sum2 ;
  int count ;
  int doshifts ;
  int loop ;
  int shiftstep ;
  double tmp___144 ;
  int i ;
  int offset ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  time_t dur ;
  time_t step ;
  int ignorenan ;
  double accum ;
  int i___0 ;
  int count___0 ;
  double val___0 ;
  int tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  int tmp___155 ;
  double tmp___156 ;
  double tmp___157 ;
  int i___1 ;
  long tmp___158 ;
  double sum___0 ;
  int count___1 ;
  double val___1 ;
  long tmp___159 ;
  int tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  int tmp___164 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;

  {
#line 469
  stptr = -1L;
#line 472
  rpi = 0;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! ((unsigned int )(rpnp + rpi)->op != 32U)) {
#line 472
      goto while_break;
    }
#line 474
    if (stptr + 5L > rpnstack->dc_stacksize) {
      {
#line 476
      rpnstack->dc_stacksize += rpnstack->dc_stackblock;
#line 477
      tmp = realloc((void *)rpnstack->s, (unsigned long )rpnstack->dc_stacksize * sizeof(*(rpnstack->s)));
#line 477
      rpnstack->s = (double *)tmp;
      }
#line 480
      if ((unsigned long )rpnstack->s == (unsigned long )((void *)0)) {
        {
#line 481
        rrd_set_error((char *)"RPN stack overflow");
        }
#line 482
        return ((short)-1);
      }
    }
    {
#line 492
    if ((unsigned int )(rpnp + rpi)->op == 0U) {
#line 492
      goto case_0;
    }
#line 496
    if ((unsigned int )(rpnp + rpi)->op == 36U) {
#line 496
      goto case_36;
    }
#line 496
    if ((unsigned int )(rpnp + rpi)->op == 1U) {
#line 496
      goto case_36;
    }
#line 524
    if ((unsigned int )(rpnp + rpi)->op == 37U) {
#line 524
      goto case_37;
    }
#line 527
    if ((unsigned int )(rpnp + rpi)->op == 3U) {
#line 527
      goto case_3;
    }
#line 534
    if ((unsigned int )(rpnp + rpi)->op == 5U) {
#line 534
      goto case_5;
    }
#line 537
    if ((unsigned int )(rpnp + rpi)->op == 2U) {
#line 537
      goto case_2;
    }
#line 540
    if ((unsigned int )(rpnp + rpi)->op == 4U) {
#line 540
      goto case_4;
    }
#line 543
    if ((unsigned int )(rpnp + rpi)->op == 6U) {
#line 543
      goto case_6;
    }
#line 546
    if ((unsigned int )(rpnp + rpi)->op == 7U) {
#line 546
      goto case_7;
    }
#line 551
    if ((unsigned int )(rpnp + rpi)->op == 33U) {
#line 551
      goto case_33;
    }
#line 555
    if ((unsigned int )(rpnp + rpi)->op == 8U) {
#line 555
      goto case_8;
    }
#line 561
    if ((unsigned int )(rpnp + rpi)->op == 51U) {
#line 561
      goto case_51;
    }
#line 575
    if ((unsigned int )(rpnp + rpi)->op == 10U) {
#line 575
      goto case_10;
    }
#line 581
    if ((unsigned int )(rpnp + rpi)->op == 11U) {
#line 581
      goto case_11;
    }
#line 587
    if ((unsigned int )(rpnp + rpi)->op == 12U) {
#line 587
      goto case_12;
    }
#line 593
    if ((unsigned int )(rpnp + rpi)->op == 9U) {
#line 593
      goto case_9;
    }
#line 599
    if ((unsigned int )(rpnp + rpi)->op == 13U) {
#line 599
      goto case_13;
    }
#line 603
    if ((unsigned int )(rpnp + rpi)->op == 38U) {
#line 603
      goto case_38;
    }
#line 607
    if ((unsigned int )(rpnp + rpi)->op == 45U) {
#line 607
      goto case_45;
    }
#line 611
    if ((unsigned int )(rpnp + rpi)->op == 46U) {
#line 611
      goto case_46;
    }
#line 615
    if ((unsigned int )(rpnp + rpi)->op == 44U) {
#line 615
      goto case_44;
    }
#line 621
    if ((unsigned int )(rpnp + rpi)->op == 17U) {
#line 621
      goto case_17;
    }
#line 625
    if ((unsigned int )(rpnp + rpi)->op == 30U) {
#line 625
      goto case_30;
    }
#line 629
    if ((unsigned int )(rpnp + rpi)->op == 29U) {
#line 629
      goto case_29;
    }
#line 633
    if ((unsigned int )(rpnp + rpi)->op == 18U) {
#line 633
      goto case_18;
    }
#line 637
    if ((unsigned int )(rpnp + rpi)->op == 14U) {
#line 637
      goto case_14;
    }
#line 642
    if ((unsigned int )(rpnp + rpi)->op == 16U) {
#line 642
      goto case_16;
    }
#line 646
    if ((unsigned int )(rpnp + rpi)->op == 15U) {
#line 646
      goto case_15;
    }
#line 656
    if ((unsigned int )(rpnp + rpi)->op == 19U) {
#line 656
      goto case_19;
    }
#line 660
    if ((unsigned int )(rpnp + rpi)->op == 20U) {
#line 660
      goto case_20;
    }
#line 670
    if ((unsigned int )(rpnp + rpi)->op == 21U) {
#line 670
      goto case_21;
    }
#line 680
    if ((unsigned int )(rpnp + rpi)->op == 22U) {
#line 680
      goto case_22;
    }
#line 690
    if ((unsigned int )(rpnp + rpi)->op == 23U) {
#line 690
      goto case_23;
    }
#line 700
    if ((unsigned int )(rpnp + rpi)->op == 34U) {
#line 700
      goto case_34;
    }
#line 710
    if ((unsigned int )(rpnp + rpi)->op == 24U) {
#line 710
      goto case_24;
    }
#line 720
    if ((unsigned int )(rpnp + rpi)->op == 25U) {
#line 720
      goto case_25;
    }
#line 729
    if ((unsigned int )(rpnp + rpi)->op == 26U) {
#line 729
      goto case_26;
    }
#line 738
    if ((unsigned int )(rpnp + rpi)->op == 27U) {
#line 738
      goto case_27;
    }
#line 747
    if ((unsigned int )(rpnp + rpi)->op == 28U) {
#line 747
      goto case_28;
    }
#line 760
    if ((unsigned int )(rpnp + rpi)->op == 31U) {
#line 760
      goto case_31;
    }
#line 764
    if ((unsigned int )(rpnp + rpi)->op == 35U) {
#line 764
      goto case_35;
    }
#line 768
    if ((unsigned int )(rpnp + rpi)->op == 39U) {
#line 768
      goto case_39;
    }
#line 772
    if ((unsigned int )(rpnp + rpi)->op == 40U) {
#line 772
      goto case_40;
    }
#line 782
    if ((unsigned int )(rpnp + rpi)->op == 41U) {
#line 782
      goto case_41;
    }
#line 801
    if ((unsigned int )(rpnp + rpi)->op == 48U) {
#line 801
      goto case_48;
    }
#line 801
    if ((unsigned int )(rpnp + rpi)->op == 47U) {
#line 801
      goto case_48;
    }
#line 879
    if ((unsigned int )(rpnp + rpi)->op == 43U) {
#line 879
      goto case_43;
    }
#line 879
    if ((unsigned int )(rpnp + rpi)->op == 42U) {
#line 879
      goto case_43;
    }
#line 913
    if ((unsigned int )(rpnp + rpi)->op == 49U) {
#line 913
      goto case_49;
    }
#line 939
    if ((unsigned int )(rpnp + rpi)->op == 50U) {
#line 939
      goto case_50;
    }
#line 943
    if ((unsigned int )(rpnp + rpi)->op == 32U) {
#line 943
      goto case_32;
    }
#line 491
    goto switch_break;
    case_0: /* CIL Label */ 
#line 493
    stptr ++;
#line 493
    *(rpnstack->s + stptr) = (rpnp + rpi)->val;
#line 494
    goto switch_break;
    case_36: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 498
    if ((rpnp + rpi)->ds_cnt == 0L) {
      {
#line 499
      rrd_set_error((char *)"VDEF made it into rpn_calc... aborting");
      }
#line 500
      return ((short)-1);
    } else {
#line 508
      if ((unsigned int )(rpnp + rpi)->op == 1U) {
#line 509
        stptr ++;
#line 509
        *(rpnstack->s + stptr) = *((rpnp + rpi)->data);
      } else
#line 511
      if (output_idx <= 0) {
        {
#line 512
        stptr ++;
#line 512
        *(rpnstack->s + stptr) = rrd_set_to_DNAN();
        }
      } else {
#line 514
        stptr ++;
#line 514
        *(rpnstack->s + stptr) = *((rpnp + rpi)->data - (rpnp + rpi)->ds_cnt);
      }
#line 519
      if (data_idx % (rpnp + rpi)->step == 0L) {
#line 520
        (rpnp + rpi)->data += (rpnp + rpi)->ds_cnt;
      }
    }
#line 523
    goto switch_break;
    case_37: /* CIL Label */ 
#line 525
    stptr ++;
#line 525
    *(rpnstack->s + stptr) = (double )(output_idx + 1);
#line 526
    goto switch_break;
    case_3: /* CIL Label */ 
#line 528
    if (output_idx <= 0) {
      {
#line 529
      stptr ++;
#line 529
      *(rpnstack->s + stptr) = rrd_set_to_DNAN();
      }
    } else {
#line 531
      stptr ++;
#line 531
      *(rpnstack->s + stptr) = *(output + (output_idx - 1));
    }
#line 533
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 535
    stptr ++;
#line 535
    *(rpnstack->s + stptr) = rrd_set_to_DNAN();
    }
#line 536
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 538
    stptr ++;
#line 538
    *(rpnstack->s + stptr) = rrd_set_to_DINF();
    }
#line 539
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 541
    stptr ++;
#line 541
    tmp___0 = rrd_set_to_DINF();
#line 541
    *(rpnstack->s + stptr) = - tmp___0;
    }
#line 542
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 544
    stptr ++;
#line 544
    tmp___1 = time((time_t *)((void *)0));
#line 544
    *(rpnstack->s + stptr) = (double )tmp___1;
    }
#line 545
    goto switch_break;
    case_7: /* CIL Label */ 
#line 549
    stptr ++;
#line 549
    *(rpnstack->s + stptr) = (double )data_idx;
#line 550
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 552
    stptr ++;
#line 552
    tmp___2 = tzoffset(data_idx);
#line 552
    *(rpnstack->s + stptr) = (double )tmp___2 + (double )data_idx;
    }
#line 554
    goto switch_break;
    case_8: /* CIL Label */ 
#line 556
    if (stptr < 1L) {
      {
#line 556
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 556
      return ((short)-1);
    }
#line 557
    *(rpnstack->s + (stptr - 1L)) += *(rpnstack->s + stptr);
#line 559
    stptr --;
#line 560
    goto switch_break;
    case_51: /* CIL Label */ 
#line 562
    if (stptr < 1L) {
      {
#line 562
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 562
      return ((short)-1);
    }
#line 563
    if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(float )) {
      {
#line 563
      tmp___8 = __isnanf((float )*(rpnstack->s + (stptr - 1L)));
#line 563
      tmp___12 = tmp___8;
      }
    } else {
#line 563
      if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(double )) {
        {
#line 563
        tmp___9 = __isnan(*(rpnstack->s + (stptr - 1L)));
#line 563
        tmp___11 = tmp___9;
        }
      } else {
        {
#line 563
        tmp___10 = __isnanl((long double )*(rpnstack->s + (stptr - 1L)));
#line 563
        tmp___11 = tmp___10;
        }
      }
#line 563
      tmp___12 = tmp___11;
    }
#line 563
    if (tmp___12) {
#line 564
      *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
    } else {
#line 565
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
        {
#line 565
        tmp___3 = __isnanf((float )*(rpnstack->s + stptr));
#line 565
        tmp___7 = tmp___3;
        }
      } else {
#line 565
        if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
          {
#line 565
          tmp___4 = __isnan(*(rpnstack->s + stptr));
#line 565
          tmp___6 = tmp___4;
          }
        } else {
          {
#line 565
          tmp___5 = __isnanl((long double )*(rpnstack->s + stptr));
#line 565
          tmp___6 = tmp___5;
          }
        }
#line 565
        tmp___7 = tmp___6;
      }
#line 565
      if (! tmp___7) {
#line 569
        *(rpnstack->s + (stptr - 1L)) += *(rpnstack->s + stptr);
      }
    }
#line 573
    stptr --;
#line 574
    goto switch_break;
    case_10: /* CIL Label */ 
#line 576
    if (stptr < 1L) {
      {
#line 576
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 576
      return ((short)-1);
    }
#line 577
    *(rpnstack->s + (stptr - 1L)) -= *(rpnstack->s + stptr);
#line 579
    stptr --;
#line 580
    goto switch_break;
    case_11: /* CIL Label */ 
#line 582
    if (stptr < 1L) {
      {
#line 582
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 582
      return ((short)-1);
    }
#line 583
    *(rpnstack->s + (stptr - 1L)) *= *(rpnstack->s + stptr);
#line 585
    stptr --;
#line 586
    goto switch_break;
    case_12: /* CIL Label */ 
#line 588
    if (stptr < 1L) {
      {
#line 588
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 588
      return ((short)-1);
    }
#line 589
    *(rpnstack->s + (stptr - 1L)) /= *(rpnstack->s + stptr);
#line 591
    stptr --;
#line 592
    goto switch_break;
    case_9: /* CIL Label */ 
#line 594
    if (stptr < 1L) {
      {
#line 594
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 594
      return ((short)-1);
    }
    {
#line 595
    *(rpnstack->s + (stptr - 1L)) = fmod(*(rpnstack->s + (stptr - 1L)), *(rpnstack->s + stptr));
#line 597
    stptr --;
    }
#line 598
    goto switch_break;
    case_13: /* CIL Label */ 
#line 600
    if (stptr < 0L) {
      {
#line 600
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 600
      return ((short)-1);
    }
    {
#line 601
    *(rpnstack->s + stptr) = sin(*(rpnstack->s + stptr));
    }
#line 602
    goto switch_break;
    case_38: /* CIL Label */ 
#line 604
    if (stptr < 0L) {
      {
#line 604
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 604
      return ((short)-1);
    }
    {
#line 605
    *(rpnstack->s + stptr) = atan(*(rpnstack->s + stptr));
    }
#line 606
    goto switch_break;
    case_45: /* CIL Label */ 
#line 608
    if (stptr < 0L) {
      {
#line 608
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 608
      return ((short)-1);
    }
#line 609
    *(rpnstack->s + stptr) = 57.29577951 * *(rpnstack->s + stptr);
#line 610
    goto switch_break;
    case_46: /* CIL Label */ 
#line 612
    if (stptr < 0L) {
      {
#line 612
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 612
      return ((short)-1);
    }
#line 613
    *(rpnstack->s + stptr) = 0.0174532952 * *(rpnstack->s + stptr);
#line 614
    goto switch_break;
    case_44: /* CIL Label */ 
#line 616
    if (stptr < 1L) {
      {
#line 616
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 616
      return ((short)-1);
    }
    {
#line 617
    *(rpnstack->s + (stptr - 1L)) = atan2(*(rpnstack->s + (stptr - 1L)), *(rpnstack->s + stptr));
#line 619
    stptr --;
    }
#line 620
    goto switch_break;
    case_17: /* CIL Label */ 
#line 622
    if (stptr < 0L) {
      {
#line 622
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 622
      return ((short)-1);
    }
    {
#line 623
    *(rpnstack->s + stptr) = cos(*(rpnstack->s + stptr));
    }
#line 624
    goto switch_break;
    case_30: /* CIL Label */ 
#line 626
    if (stptr < 0L) {
      {
#line 626
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 626
      return ((short)-1);
    }
    {
#line 627
    *(rpnstack->s + stptr) = ceil(*(rpnstack->s + stptr));
    }
#line 628
    goto switch_break;
    case_29: /* CIL Label */ 
#line 630
    if (stptr < 0L) {
      {
#line 630
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 630
      return ((short)-1);
    }
    {
#line 631
    *(rpnstack->s + stptr) = floor(*(rpnstack->s + stptr));
    }
#line 632
    goto switch_break;
    case_18: /* CIL Label */ 
#line 634
    if (stptr < 0L) {
      {
#line 634
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 634
      return ((short)-1);
    }
    {
#line 635
    *(rpnstack->s + stptr) = log(*(rpnstack->s + stptr));
    }
#line 636
    goto switch_break;
    case_14: /* CIL Label */ 
#line 638
    if (stptr < 0L) {
      {
#line 638
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 638
      return ((short)-1);
    }
#line 639
    *(rpnstack->s + (stptr + 1L)) = *(rpnstack->s + stptr);
#line 640
    stptr ++;
#line 641
    goto switch_break;
    case_16: /* CIL Label */ 
#line 643
    if (stptr < 0L) {
      {
#line 643
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 643
      return ((short)-1);
    }
#line 644
    stptr --;
#line 645
    goto switch_break;
    case_15: /* CIL Label */ 
#line 647
    if (stptr < 1L) {
      {
#line 647
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 647
      return ((short)-1);
    }
#line 651
    dummy = *(rpnstack->s + stptr);
#line 652
    *(rpnstack->s + stptr) = *(rpnstack->s + (stptr - 1L));
#line 653
    *(rpnstack->s + (stptr - 1L)) = dummy;
#line 655
    goto switch_break;
    case_19: /* CIL Label */ 
#line 657
    if (stptr < 0L) {
      {
#line 657
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 657
      return ((short)-1);
    }
    {
#line 658
    *(rpnstack->s + stptr) = exp(*(rpnstack->s + stptr));
    }
#line 659
    goto switch_break;
    case_20: /* CIL Label */ 
#line 661
    if (stptr < 1L) {
      {
#line 661
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 661
      return ((short)-1);
    }
#line 662
    if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(float )) {
      {
#line 662
      tmp___18 = __isnanf((float )*(rpnstack->s + (stptr - 1L)));
#line 662
      tmp___22 = tmp___18;
      }
    } else {
#line 662
      if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(double )) {
        {
#line 662
        tmp___19 = __isnan(*(rpnstack->s + (stptr - 1L)));
#line 662
        tmp___21 = tmp___19;
        }
      } else {
        {
#line 662
        tmp___20 = __isnanl((long double )*(rpnstack->s + (stptr - 1L)));
#line 662
        tmp___21 = tmp___20;
        }
      }
#line 662
      tmp___22 = tmp___21;
    }
#line 662
    if (! tmp___22) {
#line 663
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
        {
#line 663
        tmp___13 = __isnanf((float )*(rpnstack->s + stptr));
#line 663
        tmp___17 = tmp___13;
        }
      } else {
#line 663
        if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
          {
#line 663
          tmp___14 = __isnan(*(rpnstack->s + stptr));
#line 663
          tmp___16 = tmp___14;
          }
        } else {
          {
#line 663
          tmp___15 = __isnanl((long double )*(rpnstack->s + stptr));
#line 663
          tmp___16 = tmp___15;
          }
        }
#line 663
        tmp___17 = tmp___16;
      }
#line 663
      if (tmp___17) {
#line 664
        *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
      } else
#line 666
      if (*(rpnstack->s + (stptr - 1L)) < *(rpnstack->s + stptr)) {
#line 666
        *(rpnstack->s + (stptr - 1L)) = 1.0;
      } else {
#line 666
        *(rpnstack->s + (stptr - 1L)) = 0.0;
      }
    }
#line 668
    stptr --;
#line 669
    goto switch_break;
    case_21: /* CIL Label */ 
#line 671
    if (stptr < 1L) {
      {
#line 671
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 671
      return ((short)-1);
    }
#line 672
    if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(float )) {
      {
#line 672
      tmp___28 = __isnanf((float )*(rpnstack->s + (stptr - 1L)));
#line 672
      tmp___32 = tmp___28;
      }
    } else {
#line 672
      if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(double )) {
        {
#line 672
        tmp___29 = __isnan(*(rpnstack->s + (stptr - 1L)));
#line 672
        tmp___31 = tmp___29;
        }
      } else {
        {
#line 672
        tmp___30 = __isnanl((long double )*(rpnstack->s + (stptr - 1L)));
#line 672
        tmp___31 = tmp___30;
        }
      }
#line 672
      tmp___32 = tmp___31;
    }
#line 672
    if (! tmp___32) {
#line 673
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
        {
#line 673
        tmp___23 = __isnanf((float )*(rpnstack->s + stptr));
#line 673
        tmp___27 = tmp___23;
        }
      } else {
#line 673
        if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
          {
#line 673
          tmp___24 = __isnan(*(rpnstack->s + stptr));
#line 673
          tmp___26 = tmp___24;
          }
        } else {
          {
#line 673
          tmp___25 = __isnanl((long double )*(rpnstack->s + stptr));
#line 673
          tmp___26 = tmp___25;
          }
        }
#line 673
        tmp___27 = tmp___26;
      }
#line 673
      if (tmp___27) {
#line 674
        *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
      } else
#line 676
      if (*(rpnstack->s + (stptr - 1L)) <= *(rpnstack->s + stptr)) {
#line 676
        *(rpnstack->s + (stptr - 1L)) = 1.0;
      } else {
#line 676
        *(rpnstack->s + (stptr - 1L)) = 0.0;
      }
    }
#line 678
    stptr --;
#line 679
    goto switch_break;
    case_22: /* CIL Label */ 
#line 681
    if (stptr < 1L) {
      {
#line 681
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 681
      return ((short)-1);
    }
#line 682
    if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(float )) {
      {
#line 682
      tmp___38 = __isnanf((float )*(rpnstack->s + (stptr - 1L)));
#line 682
      tmp___42 = tmp___38;
      }
    } else {
#line 682
      if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(double )) {
        {
#line 682
        tmp___39 = __isnan(*(rpnstack->s + (stptr - 1L)));
#line 682
        tmp___41 = tmp___39;
        }
      } else {
        {
#line 682
        tmp___40 = __isnanl((long double )*(rpnstack->s + (stptr - 1L)));
#line 682
        tmp___41 = tmp___40;
        }
      }
#line 682
      tmp___42 = tmp___41;
    }
#line 682
    if (! tmp___42) {
#line 683
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
        {
#line 683
        tmp___33 = __isnanf((float )*(rpnstack->s + stptr));
#line 683
        tmp___37 = tmp___33;
        }
      } else {
#line 683
        if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
          {
#line 683
          tmp___34 = __isnan(*(rpnstack->s + stptr));
#line 683
          tmp___36 = tmp___34;
          }
        } else {
          {
#line 683
          tmp___35 = __isnanl((long double )*(rpnstack->s + stptr));
#line 683
          tmp___36 = tmp___35;
          }
        }
#line 683
        tmp___37 = tmp___36;
      }
#line 683
      if (tmp___37) {
#line 684
        *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
      } else
#line 686
      if (*(rpnstack->s + (stptr - 1L)) > *(rpnstack->s + stptr)) {
#line 686
        *(rpnstack->s + (stptr - 1L)) = 1.0;
      } else {
#line 686
        *(rpnstack->s + (stptr - 1L)) = 0.0;
      }
    }
#line 688
    stptr --;
#line 689
    goto switch_break;
    case_23: /* CIL Label */ 
#line 691
    if (stptr < 1L) {
      {
#line 691
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 691
      return ((short)-1);
    }
#line 692
    if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(float )) {
      {
#line 692
      tmp___48 = __isnanf((float )*(rpnstack->s + (stptr - 1L)));
#line 692
      tmp___52 = tmp___48;
      }
    } else {
#line 692
      if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(double )) {
        {
#line 692
        tmp___49 = __isnan(*(rpnstack->s + (stptr - 1L)));
#line 692
        tmp___51 = tmp___49;
        }
      } else {
        {
#line 692
        tmp___50 = __isnanl((long double )*(rpnstack->s + (stptr - 1L)));
#line 692
        tmp___51 = tmp___50;
        }
      }
#line 692
      tmp___52 = tmp___51;
    }
#line 692
    if (! tmp___52) {
#line 693
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
        {
#line 693
        tmp___43 = __isnanf((float )*(rpnstack->s + stptr));
#line 693
        tmp___47 = tmp___43;
        }
      } else {
#line 693
        if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
          {
#line 693
          tmp___44 = __isnan(*(rpnstack->s + stptr));
#line 693
          tmp___46 = tmp___44;
          }
        } else {
          {
#line 693
          tmp___45 = __isnanl((long double )*(rpnstack->s + stptr));
#line 693
          tmp___46 = tmp___45;
          }
        }
#line 693
        tmp___47 = tmp___46;
      }
#line 693
      if (tmp___47) {
#line 694
        *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
      } else
#line 696
      if (*(rpnstack->s + (stptr - 1L)) >= *(rpnstack->s + stptr)) {
#line 696
        *(rpnstack->s + (stptr - 1L)) = 1.0;
      } else {
#line 696
        *(rpnstack->s + (stptr - 1L)) = 0.0;
      }
    }
#line 698
    stptr --;
#line 699
    goto switch_break;
    case_34: /* CIL Label */ 
#line 701
    if (stptr < 1L) {
      {
#line 701
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 701
      return ((short)-1);
    }
#line 702
    if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(float )) {
      {
#line 702
      tmp___58 = __isnanf((float )*(rpnstack->s + (stptr - 1L)));
#line 702
      tmp___62 = tmp___58;
      }
    } else {
#line 702
      if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(double )) {
        {
#line 702
        tmp___59 = __isnan(*(rpnstack->s + (stptr - 1L)));
#line 702
        tmp___61 = tmp___59;
        }
      } else {
        {
#line 702
        tmp___60 = __isnanl((long double )*(rpnstack->s + (stptr - 1L)));
#line 702
        tmp___61 = tmp___60;
        }
      }
#line 702
      tmp___62 = tmp___61;
    }
#line 702
    if (! tmp___62) {
#line 703
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
        {
#line 703
        tmp___53 = __isnanf((float )*(rpnstack->s + stptr));
#line 703
        tmp___57 = tmp___53;
        }
      } else {
#line 703
        if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
          {
#line 703
          tmp___54 = __isnan(*(rpnstack->s + stptr));
#line 703
          tmp___56 = tmp___54;
          }
        } else {
          {
#line 703
          tmp___55 = __isnanl((long double )*(rpnstack->s + stptr));
#line 703
          tmp___56 = tmp___55;
          }
        }
#line 703
        tmp___57 = tmp___56;
      }
#line 703
      if (tmp___57) {
#line 704
        *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
      } else
#line 706
      if (*(rpnstack->s + (stptr - 1L)) == *(rpnstack->s + stptr)) {
#line 706
        *(rpnstack->s + (stptr - 1L)) = 0.0;
      } else {
#line 706
        *(rpnstack->s + (stptr - 1L)) = 1.0;
      }
    }
#line 708
    stptr --;
#line 709
    goto switch_break;
    case_24: /* CIL Label */ 
#line 711
    if (stptr < 1L) {
      {
#line 711
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 711
      return ((short)-1);
    }
#line 712
    if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(float )) {
      {
#line 712
      tmp___68 = __isnanf((float )*(rpnstack->s + (stptr - 1L)));
#line 712
      tmp___72 = tmp___68;
      }
    } else {
#line 712
      if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(double )) {
        {
#line 712
        tmp___69 = __isnan(*(rpnstack->s + (stptr - 1L)));
#line 712
        tmp___71 = tmp___69;
        }
      } else {
        {
#line 712
        tmp___70 = __isnanl((long double )*(rpnstack->s + (stptr - 1L)));
#line 712
        tmp___71 = tmp___70;
        }
      }
#line 712
      tmp___72 = tmp___71;
    }
#line 712
    if (! tmp___72) {
#line 713
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
        {
#line 713
        tmp___63 = __isnanf((float )*(rpnstack->s + stptr));
#line 713
        tmp___67 = tmp___63;
        }
      } else {
#line 713
        if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
          {
#line 713
          tmp___64 = __isnan(*(rpnstack->s + stptr));
#line 713
          tmp___66 = tmp___64;
          }
        } else {
          {
#line 713
          tmp___65 = __isnanl((long double )*(rpnstack->s + stptr));
#line 713
          tmp___66 = tmp___65;
          }
        }
#line 713
        tmp___67 = tmp___66;
      }
#line 713
      if (tmp___67) {
#line 714
        *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
      } else
#line 716
      if (*(rpnstack->s + (stptr - 1L)) == *(rpnstack->s + stptr)) {
#line 716
        *(rpnstack->s + (stptr - 1L)) = 1.0;
      } else {
#line 716
        *(rpnstack->s + (stptr - 1L)) = 0.0;
      }
    }
#line 718
    stptr --;
#line 719
    goto switch_break;
    case_25: /* CIL Label */ 
#line 721
    if (stptr < 2L) {
      {
#line 721
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 721
      return ((short)-1);
    }
#line 722
    if (sizeof(*(rpnstack->s + (stptr - 2L))) == sizeof(float )) {
      {
#line 722
      tmp___78 = __isnanf((float )*(rpnstack->s + (stptr - 2L)));
#line 722
      tmp___82 = tmp___78;
      }
    } else {
#line 722
      if (sizeof(*(rpnstack->s + (stptr - 2L))) == sizeof(double )) {
        {
#line 722
        tmp___79 = __isnan(*(rpnstack->s + (stptr - 2L)));
#line 722
        tmp___81 = tmp___79;
        }
      } else {
        {
#line 722
        tmp___80 = __isnanl((long double )*(rpnstack->s + (stptr - 2L)));
#line 722
        tmp___81 = tmp___80;
        }
      }
#line 722
      tmp___82 = tmp___81;
    }
#line 722
    if (tmp___82) {
#line 722
      *(rpnstack->s + (stptr - 2L)) = *(rpnstack->s + stptr);
    } else
#line 722
    if (*(rpnstack->s + (stptr - 2L)) == 0.0) {
#line 722
      *(rpnstack->s + (stptr - 2L)) = *(rpnstack->s + stptr);
    } else {
#line 722
      *(rpnstack->s + (stptr - 2L)) = *(rpnstack->s + (stptr - 1L));
    }
#line 726
    stptr --;
#line 727
    stptr --;
#line 728
    goto switch_break;
    case_26: /* CIL Label */ 
#line 730
    if (stptr < 1L) {
      {
#line 730
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 730
      return ((short)-1);
    }
#line 731
    if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(float )) {
      {
#line 731
      tmp___88 = __isnanf((float )*(rpnstack->s + (stptr - 1L)));
#line 731
      tmp___92 = tmp___88;
      }
    } else {
#line 731
      if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(double )) {
        {
#line 731
        tmp___89 = __isnan(*(rpnstack->s + (stptr - 1L)));
#line 731
        tmp___91 = tmp___89;
        }
      } else {
        {
#line 731
        tmp___90 = __isnanl((long double )*(rpnstack->s + (stptr - 1L)));
#line 731
        tmp___91 = tmp___90;
        }
      }
#line 731
      tmp___92 = tmp___91;
    }
#line 731
    if (! tmp___92) {
#line 732
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
        {
#line 732
        tmp___83 = __isnanf((float )*(rpnstack->s + stptr));
#line 732
        tmp___87 = tmp___83;
        }
      } else {
#line 732
        if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
          {
#line 732
          tmp___84 = __isnan(*(rpnstack->s + stptr));
#line 732
          tmp___86 = tmp___84;
          }
        } else {
          {
#line 732
          tmp___85 = __isnanl((long double )*(rpnstack->s + stptr));
#line 732
          tmp___86 = tmp___85;
          }
        }
#line 732
        tmp___87 = tmp___86;
      }
#line 732
      if (tmp___87) {
#line 733
        *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
      } else
#line 734
      if (*(rpnstack->s + (stptr - 1L)) > *(rpnstack->s + stptr)) {
#line 735
        *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
      }
    }
#line 736
    stptr --;
#line 737
    goto switch_break;
    case_27: /* CIL Label */ 
#line 739
    if (stptr < 1L) {
      {
#line 739
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 739
      return ((short)-1);
    }
#line 740
    if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(float )) {
      {
#line 740
      tmp___98 = __isnanf((float )*(rpnstack->s + (stptr - 1L)));
#line 740
      tmp___102 = tmp___98;
      }
    } else {
#line 740
      if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(double )) {
        {
#line 740
        tmp___99 = __isnan(*(rpnstack->s + (stptr - 1L)));
#line 740
        tmp___101 = tmp___99;
        }
      } else {
        {
#line 740
        tmp___100 = __isnanl((long double )*(rpnstack->s + (stptr - 1L)));
#line 740
        tmp___101 = tmp___100;
        }
      }
#line 740
      tmp___102 = tmp___101;
    }
#line 740
    if (! tmp___102) {
#line 741
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
        {
#line 741
        tmp___93 = __isnanf((float )*(rpnstack->s + stptr));
#line 741
        tmp___97 = tmp___93;
        }
      } else {
#line 741
        if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
          {
#line 741
          tmp___94 = __isnan(*(rpnstack->s + stptr));
#line 741
          tmp___96 = tmp___94;
          }
        } else {
          {
#line 741
          tmp___95 = __isnanl((long double )*(rpnstack->s + stptr));
#line 741
          tmp___96 = tmp___95;
          }
        }
#line 741
        tmp___97 = tmp___96;
      }
#line 741
      if (tmp___97) {
#line 742
        *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
      } else
#line 743
      if (*(rpnstack->s + (stptr - 1L)) < *(rpnstack->s + stptr)) {
#line 744
        *(rpnstack->s + (stptr - 1L)) = *(rpnstack->s + stptr);
      }
    }
#line 745
    stptr --;
#line 746
    goto switch_break;
    case_28: /* CIL Label */ 
#line 748
    if (stptr < 2L) {
      {
#line 748
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 748
      return ((short)-1);
    }
#line 749
    if (sizeof(*(rpnstack->s + (stptr - 2L))) == sizeof(float )) {
      {
#line 749
      tmp___113 = __isnanf((float )*(rpnstack->s + (stptr - 2L)));
#line 749
      tmp___117 = tmp___113;
      }
    } else {
#line 749
      if (sizeof(*(rpnstack->s + (stptr - 2L))) == sizeof(double )) {
        {
#line 749
        tmp___114 = __isnan(*(rpnstack->s + (stptr - 2L)));
#line 749
        tmp___116 = tmp___114;
        }
      } else {
        {
#line 749
        tmp___115 = __isnanl((long double )*(rpnstack->s + (stptr - 2L)));
#line 749
        tmp___116 = tmp___115;
        }
      }
#line 749
      tmp___117 = tmp___116;
    }
#line 749
    if (! tmp___117) {
#line 750
      if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(float )) {
        {
#line 750
        tmp___108 = __isnanf((float )*(rpnstack->s + (stptr - 1L)));
#line 750
        tmp___112 = tmp___108;
        }
      } else {
#line 750
        if (sizeof(*(rpnstack->s + (stptr - 1L))) == sizeof(double )) {
          {
#line 750
          tmp___109 = __isnan(*(rpnstack->s + (stptr - 1L)));
#line 750
          tmp___111 = tmp___109;
          }
        } else {
          {
#line 750
          tmp___110 = __isnanl((long double )*(rpnstack->s + (stptr - 1L)));
#line 750
          tmp___111 = tmp___110;
          }
        }
#line 750
        tmp___112 = tmp___111;
      }
#line 750
      if (tmp___112) {
#line 751
        *(rpnstack->s + (stptr - 2L)) = *(rpnstack->s + (stptr - 1L));
      } else {
#line 752
        if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
          {
#line 752
          tmp___103 = __isnanf((float )*(rpnstack->s + stptr));
#line 752
          tmp___107 = tmp___103;
          }
        } else {
#line 752
          if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
            {
#line 752
            tmp___104 = __isnan(*(rpnstack->s + stptr));
#line 752
            tmp___106 = tmp___104;
            }
          } else {
            {
#line 752
            tmp___105 = __isnanl((long double )*(rpnstack->s + stptr));
#line 752
            tmp___106 = tmp___105;
            }
          }
#line 752
          tmp___107 = tmp___106;
        }
#line 752
        if (tmp___107) {
#line 753
          *(rpnstack->s + (stptr - 2L)) = *(rpnstack->s + stptr);
        } else
#line 754
        if (*(rpnstack->s + (stptr - 2L)) < *(rpnstack->s + (stptr - 1L))) {
          {
#line 755
          *(rpnstack->s + (stptr - 2L)) = rrd_set_to_DNAN();
          }
        } else
#line 756
        if (*(rpnstack->s + (stptr - 2L)) > *(rpnstack->s + stptr)) {
          {
#line 757
          *(rpnstack->s + (stptr - 2L)) = rrd_set_to_DNAN();
          }
        }
      }
    }
#line 758
    stptr -= 2L;
#line 759
    goto switch_break;
    case_31: /* CIL Label */ 
#line 761
    if (stptr < 0L) {
      {
#line 761
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 761
      return ((short)-1);
    }
#line 762
    if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
      {
#line 762
      tmp___123 = __isnanf((float )*(rpnstack->s + stptr));
#line 762
      tmp___127 = tmp___123;
      }
    } else {
#line 762
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
        {
#line 762
        tmp___124 = __isnan(*(rpnstack->s + stptr));
#line 762
        tmp___126 = tmp___124;
        }
      } else {
        {
#line 762
        tmp___125 = __isnanl((long double )*(rpnstack->s + stptr));
#line 762
        tmp___126 = tmp___125;
        }
      }
#line 762
      tmp___127 = tmp___126;
    }
#line 762
    if (tmp___127) {
#line 762
      *(rpnstack->s + stptr) = 1.0;
    } else {
#line 762
      *(rpnstack->s + stptr) = 0.0;
    }
#line 763
    goto switch_break;
    case_35: /* CIL Label */ 
#line 765
    if (stptr < 0L) {
      {
#line 765
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 765
      return ((short)-1);
    }
#line 766
    if (sizeof(*(rpnstack->s + stptr)) == sizeof(float )) {
      {
#line 766
      tmp___133 = __isinff((float )*(rpnstack->s + stptr));
#line 766
      tmp___137 = tmp___133;
      }
    } else {
#line 766
      if (sizeof(*(rpnstack->s + stptr)) == sizeof(double )) {
        {
#line 766
        tmp___134 = __isinf(*(rpnstack->s + stptr));
#line 766
        tmp___136 = tmp___134;
        }
      } else {
        {
#line 766
        tmp___135 = __isinfl((long double )*(rpnstack->s + stptr));
#line 766
        tmp___136 = tmp___135;
        }
      }
#line 766
      tmp___137 = tmp___136;
    }
#line 766
    if (tmp___137) {
#line 766
      *(rpnstack->s + stptr) = 1.0;
    } else {
#line 766
      *(rpnstack->s + stptr) = 0.0;
    }
#line 767
    goto switch_break;
    case_39: /* CIL Label */ 
#line 769
    if (stptr < 0L) {
      {
#line 769
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 769
      return ((short)-1);
    }
    {
#line 770
    *(rpnstack->s + stptr) = sqrt(*(rpnstack->s + stptr));
    }
#line 771
    goto switch_break;
    case_40: /* CIL Label */ 
#line 773
    if (stptr < 0L) {
      {
#line 773
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 773
      return ((short)-1);
    }
#line 775
    tmp___138 = stptr;
#line 775
    stptr --;
#line 775
    spn = (int )*(rpnstack->s + tmp___138);
#line 777
    if (stptr < (long )(spn - 1)) {
      {
#line 777
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 777
      return ((short)-1);
    }
    {
#line 778
    qsort((void *)(((rpnstack->s + stptr) - spn) + 1), (size_t )spn, sizeof(double ),
          & rpn_compare_double);
    }
#line 781
    goto switch_break;
    case_41: /* CIL Label */ 
#line 783
    if (stptr < 0L) {
      {
#line 783
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 783
      return ((short)-1);
    }
#line 785
    tmp___139 = stptr;
#line 785
    stptr --;
#line 785
    spn___0 = (int )*(rpnstack->s + tmp___139);
#line 788
    if (stptr < (long )(spn___0 - 1)) {
      {
#line 788
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 788
      return ((short)-1);
    }
#line 790
    p = ((rpnstack->s + stptr) - spn___0) + 1;
#line 791
    q = rpnstack->s + stptr;
    {
#line 792
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 792
      if (! ((unsigned long )p < (unsigned long )q)) {
#line 792
        goto while_break___0;
      }
#line 793
      x = *q;
#line 795
      tmp___140 = q;
#line 795
      q --;
#line 795
      *tmp___140 = *p;
#line 796
      tmp___141 = p;
#line 796
      p ++;
#line 796
      *tmp___141 = x;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 799
    goto switch_break;
    case_48: /* CIL Label */ 
    case_47: /* CIL Label */ 
#line 802
    if (stptr < 2L) {
      {
#line 802
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 802
      return ((short)-1);
    }
#line 805
    stptr --;
#line 805
    locstepsize = (int )*(rpnstack->s + stptr);
#line 807
    stptr --;
#line 807
    shifts = (int )*(rpnstack->s + stptr);
#line 808
    if (stptr < (long )shifts) {
      {
#line 808
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 808
      return ((short)-1);
    }
#line 810
    if (shifts < 0) {
#line 811
      stptr --;
    } else {
#line 813
      stptr -= (long )shifts;
    }
    {
#line 816
    tmp___142 = rrd_set_to_DNAN();
#line 816
    val = tmp___142;
#line 818
    dsstep = (rpnp + (rpi - 1))->step;
#line 819
    dscount = (int )(rpnp + (rpi - 1))->ds_cnt;
#line 820
    tmp___143 = ceil((double )((float )locstepsize / (float )dsstep));
#line 820
    locstep = (int )tmp___143;
#line 823
    sum = (double )0;
#line 824
    sum2 = (double )0;
#line 825
    count = 0;
#line 827
    doshifts = shifts;
    }
#line 828
    if (shifts < 0) {
#line 828
      doshifts = - shifts;
    }
#line 829
    loop = 0;
    {
#line 829
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 829
      if (! (loop < doshifts)) {
#line 829
        goto while_break___1;
      }
#line 831
      shiftstep = 1;
#line 832
      if (shifts < 0) {
#line 833
        shiftstep = (int )((double )loop * *(rpnstack->s + stptr));
      } else {
#line 835
        shiftstep = (int )*(rpnstack->s + (stptr + (long )loop));
      }
#line 837
      if (shiftstep < 0) {
        {
#line 838
        rrd_set_error((char *)"negative shift step not allowed: %i", shiftstep);
        }
#line 839
        return ((short)-1);
      }
      {
#line 841
      tmp___144 = ceil((double )((float )shiftstep / (float )dsstep));
#line 841
      shiftstep = (int )tmp___144;
#line 843
      i = 0;
      }
      {
#line 843
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 843
        if (! (i <= locstep)) {
#line 843
          goto while_break___2;
        }
#line 845
        offset = shiftstep + i;
#line 847
        if (offset >= 0) {
#line 847
          if (offset < output_idx) {
#line 849
            val = *((rpnp + (rpi - 1))->data + - dscount * offset);
#line 851
            if (sizeof(val) == sizeof(float )) {
              {
#line 851
              tmp___145 = __isnanf((float )val);
#line 851
              tmp___149 = tmp___145;
              }
            } else {
#line 851
              if (sizeof(val) == sizeof(double )) {
                {
#line 851
                tmp___146 = __isnan(val);
#line 851
                tmp___148 = tmp___146;
                }
              } else {
                {
#line 851
                tmp___147 = __isnanl((long double )val);
#line 851
                tmp___148 = tmp___147;
                }
              }
#line 851
              tmp___149 = tmp___148;
            }
#line 851
            if (! tmp___149) {
#line 852
              sum += val;
#line 853
              sum2 += val * val;
#line 854
              count ++;
            }
          }
        }
#line 843
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 829
      loop ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 860
    val = rrd_set_to_DNAN();
    }
#line 861
    if ((unsigned int )(rpnp + rpi)->op == 47U) {
#line 862
      if (count > 0) {
#line 863
        val = sum / (double )count;
      }
    } else
#line 866
    if (count > 1) {
#line 867
      val = (double )count * sum2 - sum * sum;
#line 868
      if (val < (double )0) {
        {
#line 869
        val = rrd_set_to_DNAN();
        }
      } else {
        {
#line 871
        val = sqrt(val / ((double )((float )count) * ((double )((float )count) - 1.0)));
        }
      }
    }
#line 875
    *(rpnstack->s + stptr) = val;
#line 877
    goto switch_break;
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
#line 880
    if (stptr < 1L) {
      {
#line 880
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 880
      return ((short)-1);
    }
#line 881
    if (rpi < 2) {
      {
#line 882
      rrd_set_error((char *)"malformed trend arguments");
      }
#line 883
      return ((short)-1);
    } else
#line 881
    if ((unsigned int )(rpnp + (rpi - 2))->op != 1U) {
      {
#line 882
      rrd_set_error((char *)"malformed trend arguments");
      }
#line 883
      return ((short)-1);
    } else {
      {
#line 885
      dur = (time_t )*(rpnstack->s + stptr);
#line 886
      step = (rpnp + (rpi - 2))->step;
#line 888
      tmp___157 = ceil((double )((float )dur / (float )step));
      }
#line 888
      if (output_idx + 1 >= (int )tmp___157) {
#line 889
        ignorenan = (unsigned int )(rpnp + rpi)->op == 42U;
#line 890
        accum = 0.0;
#line 891
        i___0 = -1;
#line 894
        count___0 = 0;
        {
#line 896
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 897
          tmp___150 = i___0;
#line 897
          i___0 --;
#line 897
          val___0 = *((rpnp + (rpi - 2))->data + (rpnp + (rpi - 2))->ds_cnt * (long )tmp___150);
#line 899
          if (ignorenan) {
#line 900
            accum += val___0;
#line 901
            count___0 ++;
          } else {
#line 899
            if (sizeof(val___0) == sizeof(float )) {
              {
#line 899
              tmp___151 = __isnanf((float )val___0);
#line 899
              tmp___155 = tmp___151;
              }
            } else {
#line 899
              if (sizeof(val___0) == sizeof(double )) {
                {
#line 899
                tmp___152 = __isnan(val___0);
#line 899
                tmp___154 = tmp___152;
                }
              } else {
                {
#line 899
                tmp___153 = __isnanl((long double )val___0);
#line 899
                tmp___154 = tmp___153;
                }
              }
#line 899
              tmp___155 = tmp___154;
            }
#line 899
            if (! tmp___155) {
#line 900
              accum += val___0;
#line 901
              count___0 ++;
            }
          }
#line 904
          dur -= step;
#line 896
          if (! (dur > 0L)) {
#line 896
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 907
        stptr --;
#line 907
        if (count___0 == 0) {
          {
#line 907
          tmp___156 = rrd_set_to_DNAN();
#line 907
          *(rpnstack->s + stptr) = tmp___156;
          }
        } else {
#line 907
          *(rpnstack->s + stptr) = accum / (double )count___0;
        }
      } else {
        {
#line 910
        stptr --;
#line 910
        *(rpnstack->s + stptr) = rrd_set_to_DNAN();
        }
      }
    }
#line 912
    goto switch_break;
    case_49: /* CIL Label */ 
#line 914
    if (stptr < 0L) {
      {
#line 914
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 914
      return ((short)-1);
    }
#line 916
    tmp___158 = stptr;
#line 916
    stptr --;
#line 916
    i___1 = (int )*(rpnstack->s + tmp___158);
#line 917
    sum___0 = (double )0;
#line 918
    count___1 = 0;
#line 920
    if (stptr < (long )(i___1 - 1)) {
      {
#line 920
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 920
      return ((short)-1);
    }
    {
#line 921
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 921
      if (! (i___1 > 0)) {
#line 921
        goto while_break___4;
      }
#line 922
      tmp___159 = stptr;
#line 922
      stptr --;
#line 922
      val___1 = *(rpnstack->s + tmp___159);
#line 924
      i___1 --;
#line 925
      if (sizeof(val___1) == sizeof(float )) {
        {
#line 925
        tmp___160 = __isnanf((float )val___1);
#line 925
        tmp___164 = tmp___160;
        }
      } else {
#line 925
        if (sizeof(val___1) == sizeof(double )) {
          {
#line 925
          tmp___161 = __isnan(val___1);
#line 925
          tmp___163 = tmp___161;
          }
        } else {
          {
#line 925
          tmp___162 = __isnanl((long double )val___1);
#line 925
          tmp___163 = tmp___162;
          }
        }
#line 925
        tmp___164 = tmp___163;
      }
#line 925
      if (tmp___164) {
#line 926
        goto while_continue___4;
      }
#line 928
      count___1 ++;
#line 929
      sum___0 += val___1;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 932
    if (count___1 > 0) {
#line 933
      stptr ++;
#line 933
      *(rpnstack->s + stptr) = sum___0 / (double )count___1;
    } else {
      {
#line 935
      stptr ++;
#line 935
      *(rpnstack->s + stptr) = rrd_set_to_DNAN();
      }
    }
#line 938
    goto switch_break;
    case_50: /* CIL Label */ 
#line 940
    if (stptr < 0L) {
      {
#line 940
      rrd_set_error((char *)"RPN stack underflow");
      }
#line 940
      return ((short)-1);
    }
    {
#line 941
    *(rpnstack->s + stptr) = fabs(*(rpnstack->s + stptr));
    }
#line 942
    goto switch_break;
    case_32: /* CIL Label */ 
#line 944
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 472
    rpi ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 948
  if (stptr != 0L) {
    {
#line 949
    rrd_set_error((char *)"RPN final stack size != 1");
    }
#line 950
    return ((short)-1);
  }
#line 953
  *(output + output_idx) = *(rpnstack->s + 0);
#line 954
  return ((short)0);
}
}
#line 959 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_rpncalc.c"
int tzoffset(time_t now ) 
{ 
  int gm_sec ;
  int gm_min ;
  int gm_hour ;
  int gm_yday ;
  int gm_year ;
  int l_sec ;
  int l_min ;
  int l_hour ;
  int l_yday ;
  int l_year ;
  struct tm t ;
  int off ;

  {
  {
#line 967
  gmtime_r((time_t const   */* __restrict  */)(& now), (struct tm */* __restrict  */)(& t));
#line 968
  gm_sec = t.tm_sec;
#line 969
  gm_min = t.tm_min;
#line 970
  gm_hour = t.tm_hour;
#line 971
  gm_yday = t.tm_yday;
#line 972
  gm_year = t.tm_year;
#line 973
  localtime_r((time_t const   */* __restrict  */)(& now), (struct tm */* __restrict  */)(& t));
#line 974
  l_sec = t.tm_sec;
#line 975
  l_min = t.tm_min;
#line 976
  l_hour = t.tm_hour;
#line 977
  l_yday = t.tm_yday;
#line 978
  l_year = t.tm_year;
#line 979
  off = ((l_sec - gm_sec) + (l_min - gm_min) * 60) + (l_hour - gm_hour) * 3600;
  }
#line 981
  if (l_yday > gm_yday) {
#line 982
    off += 86400;
  } else
#line 981
  if (l_year > gm_year) {
#line 982
    off += 86400;
  } else
#line 983
  if (l_yday < gm_yday) {
#line 984
    off -= 86400;
  } else
#line 983
  if (l_year < gm_year) {
#line 984
    off -= 86400;
  }
#line 986
  return (off);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 305 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_proc_start_end(rrd_time_value_t *start_tv , rrd_time_value_t *end_tv , time_t *start ,
                       time_t *end ) ;
#line 145 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static struct SpecialToken  const  VariousWords[54]  = 
#line 145 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
  {      {(char *)"midnight", 0}, 
        {(char *)"noon", 1}, 
        {(char *)"teatime", 2}, 
        {(char *)"am", 4}, 
        {(char *)"pm", 3}, 
        {(char *)"tomorrow", 7}, 
        {(char *)"yesterday", 5}, 
        {(char *)"today", 6}, 
        {(char *)"now", 8}, 
        {(char *)"n", 8}, 
        {(char *)"start", 9}, 
        {(char *)"s", 9}, 
        {(char *)"end", 10}, 
        {(char *)"e", 10}, 
        {(char *)"epoch", 11}, 
        {(char *)"jan", 28}, 
        {(char *)"feb", 29}, 
        {(char *)"mar", 30}, 
        {(char *)"apr", 31}, 
        {(char *)"may", 32}, 
        {(char *)"jun", 33}, 
        {(char *)"jul", 34}, 
        {(char *)"aug", 35}, 
        {(char *)"sep", 36}, 
        {(char *)"oct", 37}, 
        {(char *)"nov", 38}, 
        {(char *)"dec", 39}, 
        {(char *)"january", 28}, 
        {(char *)"february", 29}, 
        {(char *)"march", 30}, 
        {(char *)"april", 31}, 
        {(char *)"may", 32}, 
        {(char *)"june", 33}, 
        {(char *)"july", 34}, 
        {(char *)"august", 35}, 
        {(char *)"september", 36}, 
        {(char *)"october", 37}, 
        {(char *)"november", 38}, 
        {(char *)"december", 39}, 
        {(char *)"sunday", 40}, 
        {(char *)"sun", 40}, 
        {(char *)"monday", 41}, 
        {(char *)"mon", 41}, 
        {(char *)"tuesday", 42}, 
        {(char *)"tue", 42}, 
        {(char *)"wednesday", 43}, 
        {(char *)"wed", 43}, 
        {(char *)"thursday", 44}, 
        {(char *)"thu", 44}, 
        {(char *)"friday", 45}, 
        {(char *)"fri", 45}, 
        {(char *)"saturday", 46}, 
        {(char *)"sat", 46}, 
        {(char *)((void *)0), 0}};
#line 203 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static struct SpecialToken  const  TimeMultipliers[27]  = 
#line 203
  {      {(char *)"second", 12}, 
        {(char *)"seconds", 12}, 
        {(char *)"sec", 12}, 
        {(char *)"s", 12}, 
        {(char *)"minute", 13}, 
        {(char *)"minutes", 13}, 
        {(char *)"min", 13}, 
        {(char *)"m", 19}, 
        {(char *)"hour", 14}, 
        {(char *)"hours", 14}, 
        {(char *)"hr", 14}, 
        {(char *)"h", 14}, 
        {(char *)"day", 15}, 
        {(char *)"days", 15}, 
        {(char *)"d", 15}, 
        {(char *)"week", 16}, 
        {(char *)"weeks", 16}, 
        {(char *)"wk", 16}, 
        {(char *)"w", 16}, 
        {(char *)"month", 17}, 
        {(char *)"months", 17}, 
        {(char *)"mon", 17}, 
        {(char *)"year", 18}, 
        {(char *)"years", 18}, 
        {(char *)"yr", 18}, 
        {(char *)"y", 18}, 
        {(char *)((void *)0), 0}};
#line 239 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static struct SpecialToken  const  *Specials  ;
#line 241 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char const   **scp  ;
#line 242 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char scc  ;
#line 243 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char const   *sct  ;
#line 244 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static int need  ;
#line 246 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char *sc_token  =    (char *)((void *)0);
#line 247 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static size_t sc_len  ;
#line 248 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static int sc_tokid  ;
#line 251
static void EnsureMemFree(void) ;
#line 254 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static void EnsureMemFree(void) 
{ 


  {
#line 257
  if (sc_token) {
    {
#line 258
    free((void *)sc_token);
#line 259
    sc_token = (char *)((void *)0);
    }
  }
#line 261
  return;
}
}
#line 301 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char errmsg[1024]  ;
#line 303 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char *ve(char *fmt , va_list ap ) 
{ 


  {
  {
#line 308
  vsnprintf((char */* __restrict  */)(errmsg), (size_t )1024, (char const   */* __restrict  */)fmt,
            ap);
#line 312
  EnsureMemFree();
  }
#line 313
  return (errmsg);
}
}
#line 316 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char *e(char *fmt  , ...) 
{ 
  char *err ;
  va_list ap ;

  {
  {
#line 323
  __builtin_va_start(ap, fmt);
#line 324
  err = ve(fmt, ap);
#line 325
  __builtin_va_end(ap);
  }
#line 326
  return (err);
}
}
#line 332 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static int mystrcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 336
  p1 = (unsigned char const   *)s1;
#line 337
  p2 = (unsigned char const   *)s2;
#line 340
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 341
    return (0);
  }
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 344
    tmp = p1;
#line 344
    p1 ++;
#line 344
    tmp___0 = tolower((int )*tmp);
#line 344
    c1 = (unsigned char )tmp___0;
#line 345
    tmp___1 = p2;
#line 345
    p2 ++;
#line 345
    tmp___2 = tolower((int )*tmp___1);
#line 345
    c2 = (unsigned char )tmp___2;
    }
#line 346
    if ((int )c1 == 0) {
#line 347
      goto while_break;
    }
#line 343
    if (! ((int )c1 == (int )c2)) {
#line 343
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  return ((int )c1 - (int )c2);
}
}
#line 357 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static int parse_token(char *arg ) 
{ 
  int i ;
  int tmp ;

  {
#line 362
  i = 0;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! ((unsigned long )(Specials + i)->name != (unsigned long )((void *)0))) {
#line 362
      goto while_break;
    }
    {
#line 363
    tmp = mystrcasecmp((char const   *)(Specials + i)->name, (char const   *)arg);
    }
#line 363
    if (tmp == 0) {
#line 364
      sc_tokid = (int )(Specials + i)->value;
#line 364
      return (sc_tokid);
    }
#line 362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  sc_tokid = 26;
#line 367
  return (sc_tokid);
}
}
#line 375 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char *init_scanner(int argc , char const   **argv ) 
{ 
  char const   **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp7 ;

  {
#line 379
  scp = argv;
#line 380
  scc = (char )argc;
#line 381
  need = 1;
#line 382
  sc_len = (size_t )1;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    tmp___1 = argc;
#line 383
    argc --;
#line 383
    if (! (tmp___1 > 0)) {
#line 383
      goto while_break;
    }
    {
#line 384
    tmp = argv;
#line 384
    argv ++;
#line 384
    tmp___0 = strlen(*tmp);
#line 384
    sc_len += tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 386
  tmp___2 = malloc(sc_len * sizeof(char ));
#line 386
  sc_token = (char *)tmp___2;
  }
#line 387
  if ((unsigned long )sc_token == (unsigned long )((void *)0)) {
#line 388
    return ((char *)"Failed to allocate memory");
  }
#line 389
  return ((char *)((void *)0));
}
}
#line 395 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static int token(void) 
{ 
  int idx ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;

  {
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 401
    memset((void *)sc_token, '\000', sc_len);
#line 402
    sc_tokid = -1;
#line 403
    idx = 0;
    }
#line 408
    if (need) {
#line 409
      if ((int )scc < 1) {
#line 410
        return (sc_tokid);
      }
#line 411
      sct = *scp;
#line 412
      scp ++;
#line 413
      scc = (char )((int )scc - 1);
#line 414
      need = 0;
    }
    {
#line 420
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 420
      tmp = __ctype_b_loc();
      }
#line 420
      if (! ((int const   )*(*tmp + (int )((unsigned char )*sct)) & 8192)) {
#line 420
        if (! ((int const   )*sct == 95)) {
#line 420
          if (! ((int const   )*sct == 44)) {
#line 420
            goto while_break___0;
          }
        }
      }
#line 421
      sct ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 422
    if (! *sct) {
#line 423
      need = 1;
#line 424
      goto while_continue;
    }
    {
#line 429
    tmp___0 = sct;
#line 429
    sct ++;
#line 429
    *(sc_token + 0) = (char )*tmp___0;
#line 433
    tmp___7 = __ctype_b_loc();
    }
#line 433
    if ((int const   )*(*tmp___7 + (int )((unsigned char )*(sc_token + 0))) & 2048) {
      {
#line 434
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 434
        tmp___2 = __ctype_b_loc();
        }
#line 434
        if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*sct)) & 2048)) {
#line 434
          goto while_break___1;
        }
#line 435
        idx ++;
#line 435
        tmp___1 = sct;
#line 435
        sct ++;
#line 435
        *(sc_token + idx) = (char )*tmp___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 436
      idx ++;
#line 436
      *(sc_token + idx) = (char )'\000';
#line 437
      sc_tokid = 20;
#line 437
      return (sc_tokid);
    } else {
      {
#line 438
      tmp___6 = __ctype_b_loc();
      }
#line 438
      if ((int const   )*(*tmp___6 + (int )((unsigned char )*(sc_token + 0))) & 1024) {
        {
#line 439
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 439
          tmp___4 = __ctype_b_loc();
          }
#line 439
          if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*sct)) & 1024)) {
#line 439
            goto while_break___2;
          }
#line 440
          idx ++;
#line 440
          tmp___3 = sct;
#line 440
          sct ++;
#line 440
          *(sc_token + idx) = (char )*tmp___3;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 441
        idx ++;
#line 441
        *(sc_token + idx) = (char )'\000';
#line 442
        tmp___5 = parse_token(sc_token);
        }
#line 442
        return (tmp___5);
      } else {
        {
#line 445
        if ((int )*(sc_token + 0) == 58) {
#line 445
          goto case_58;
        }
#line 447
        if ((int )*(sc_token + 0) == 46) {
#line 447
          goto case_46;
        }
#line 449
        if ((int )*(sc_token + 0) == 43) {
#line 449
          goto case_43;
        }
#line 451
        if ((int )*(sc_token + 0) == 45) {
#line 451
          goto case_45;
        }
#line 453
        if ((int )*(sc_token + 0) == 47) {
#line 453
          goto case_47;
        }
#line 455
        goto switch_default;
        case_58: /* CIL Label */ 
#line 446
        sc_tokid = 24;
#line 446
        return (sc_tokid);
        case_46: /* CIL Label */ 
#line 448
        sc_tokid = 23;
#line 448
        return (sc_tokid);
        case_43: /* CIL Label */ 
#line 450
        sc_tokid = 21;
#line 450
        return (sc_tokid);
        case_45: /* CIL Label */ 
#line 452
        sc_tokid = 22;
#line 452
        return (sc_tokid);
        case_47: /* CIL Label */ 
#line 454
        sc_tokid = 25;
#line 454
        return (sc_tokid);
        switch_default: /* CIL Label */ 
#line 457
        sct --;
#line 458
        sc_tokid = -1;
#line 458
        return (sc_tokid);
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 467 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char *expect2(int desired , char *complain_fmt  , ...) 
{ 
  va_list ap ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 474
  __builtin_va_start(ap, complain_fmt);
#line 475
  tmp___0 = token();
  }
#line 475
  if (tmp___0 != desired) {
    {
#line 476
    tmp = ve(complain_fmt, ap);
    }
#line 476
    return (tmp);
  }
  {
#line 478
  __builtin_va_end(ap);
  }
#line 479
  return ((char *)((void *)0));
}
}
#line 493
static char *plus_minus(rrd_time_value_t *ptv , int doop ) ;
#line 493 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static int op  =    21;
#line 494 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static int prev_multiplier  =    -1;
#line 489 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char *plus_minus(rrd_time_value_t *ptv , int doop ) 
{ 
  int delta ;
  char *_e ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 497
  if (doop >= 0) {
#line 498
    op = doop;
#line 499
    if (op == 21) {
#line 499
      tmp = '+';
    } else {
#line 499
      tmp = '-';
    }
    {
#line 499
    _e = expect2(20, (char *)"There should be number after \'%c\'", tmp);
    }
#line 499
    if (_e) {
      {
#line 499
      EnsureMemFree();
      }
#line 499
      return (_e);
    }
#line 502
    prev_multiplier = -1;
  }
  {
#line 507
  delta = atoi((char const   *)sc_token);
#line 509
  tmp___0 = token();
  }
#line 509
  if (tmp___0 == 19) {
    {
#line 515
    if (prev_multiplier == 18) {
#line 515
      goto case_18;
    }
#line 515
    if (prev_multiplier == 17) {
#line 515
      goto case_18;
    }
#line 515
    if (prev_multiplier == 16) {
#line 515
      goto case_18;
    }
#line 515
    if (prev_multiplier == 15) {
#line 515
      goto case_18;
    }
#line 521
    if (prev_multiplier == 14) {
#line 521
      goto case_14;
    }
#line 521
    if (prev_multiplier == 13) {
#line 521
      goto case_14;
    }
#line 521
    if (prev_multiplier == 12) {
#line 521
      goto case_14;
    }
#line 525
    goto switch_default;
    case_18: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
#line 516
    sc_tokid = 17;
#line 517
    goto switch_break;
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 522
    sc_tokid = 13;
#line 523
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 526
    if (delta < 6) {
#line 528
      sc_tokid = 17;
    } else {
#line 530
      sc_tokid = 13;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 533
  prev_multiplier = sc_tokid;
  {
#line 535
  if (sc_tokid == 18) {
#line 535
    goto case_18___0;
  }
#line 540
  if (sc_tokid == 17) {
#line 540
    goto case_17___0;
  }
#line 545
  if (sc_tokid == 16) {
#line 545
    goto case_16___0;
  }
#line 548
  if (sc_tokid == 15) {
#line 548
    goto case_15___0;
  }
#line 553
  if (sc_tokid == 14) {
#line 553
    goto case_14___0;
  }
#line 556
  if (sc_tokid == 13) {
#line 556
    goto case_13___0;
  }
#line 559
  if (sc_tokid == 12) {
#line 559
    goto case_12___0;
  }
#line 562
  goto switch_default___0;
  case_18___0: /* CIL Label */ 
#line 536
  if (op == 21) {
#line 536
    tmp___1 = delta;
  } else {
#line 536
    tmp___1 = - delta;
  }
#line 536
  ptv->tm.tm_year += tmp___1;
#line 539
  return ((char *)((void *)0));
  case_17___0: /* CIL Label */ 
#line 541
  if (op == 21) {
#line 541
    tmp___2 = delta;
  } else {
#line 541
    tmp___2 = - delta;
  }
#line 541
  ptv->tm.tm_mon += tmp___2;
#line 544
  return ((char *)((void *)0));
  case_16___0: /* CIL Label */ 
#line 546
  delta *= 7;
  case_15___0: /* CIL Label */ 
#line 549
  if (op == 21) {
#line 549
    tmp___3 = delta;
  } else {
#line 549
    tmp___3 = - delta;
  }
#line 549
  ptv->tm.tm_mday += tmp___3;
#line 552
  return ((char *)((void *)0));
  case_14___0: /* CIL Label */ 
#line 554
  if (op == 21) {
#line 554
    tmp___4 = (delta * 60) * 60;
  } else {
#line 554
    tmp___4 = (- delta * 60) * 60;
  }
#line 554
  ptv->offset += (long )tmp___4;
#line 555
  return ((char *)((void *)0));
  case_13___0: /* CIL Label */ 
#line 557
  if (op == 21) {
#line 557
    tmp___5 = delta * 60;
  } else {
#line 557
    tmp___5 = - delta * 60;
  }
#line 557
  ptv->offset += (long )tmp___5;
#line 558
  return ((char *)((void *)0));
  case_12___0: /* CIL Label */ 
#line 560
  if (op == 21) {
#line 560
    tmp___6 = delta;
  } else {
#line 560
    tmp___6 = - delta;
  }
#line 560
  ptv->offset += (long )tmp___6;
#line 561
  return ((char *)((void *)0));
  switch_default___0: /* CIL Label */ 
#line 563
  if (op == 21) {
#line 563
    tmp___7 = delta;
  } else {
#line 563
    tmp___7 = - delta;
  }
#line 563
  ptv->offset += (long )tmp___7;
#line 564
  return ((char *)((void *)0));
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 566
  tmp___8 = e((char *)"well-known time unit expected after %d", delta);
  }
#line 566
  return (tmp___8);
#line 568
  return ((char *)((void *)0));
}
}
#line 575 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char *tod(rrd_time_value_t *ptv ) 
{ 
  int hour ;
  int minute ;
  int tlen ;
  int scc_sv ;
  char const   *sct_sv ;
  int sc_tokid_sv ;
  size_t tmp ;
  char *_e ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 578
  minute = 0;
#line 582
  scc_sv = (int )scc;
#line 583
  sct_sv = sct;
#line 584
  sc_tokid_sv = sc_tokid;
#line 586
  tmp = strlen((char const   *)sc_token);
#line 586
  tlen = (int )tmp;
  }
#line 590
  if (tlen > 2) {
#line 591
    return ((char *)((void *)0));
  }
  {
#line 594
  hour = atoi((char const   *)sc_token);
#line 596
  token();
  }
#line 597
  if (sc_tokid == 25) {
    {
#line 599
    scc = (char )scc_sv;
#line 600
    sct = sct_sv;
#line 601
    sc_tokid = sc_tokid_sv;
#line 602
    sprintf((char */* __restrict  */)sc_token, (char const   */* __restrict  */)"%d",
            hour);
    }
#line 603
    return ((char *)((void *)0));
  } else
#line 597
  if (sc_tokid == 23) {
    {
#line 599
    scc = (char )scc_sv;
#line 600
    sct = sct_sv;
#line 601
    sc_tokid = sc_tokid_sv;
#line 602
    sprintf((char */* __restrict  */)sc_token, (char const   */* __restrict  */)"%d",
            hour);
    }
#line 603
    return ((char *)((void *)0));
  }
#line 605
  if (sc_tokid == 24) {
    {
#line 606
    _e = expect2(20, (char *)"Parsing HH:MM syntax, expecting MM as number, got none");
    }
#line 606
    if (_e) {
      {
#line 606
      EnsureMemFree();
      }
#line 606
      return (_e);
    }
    {
#line 608
    minute = atoi((char const   *)sc_token);
    }
#line 609
    if (minute > 59) {
      {
#line 610
      tmp___0 = e((char *)"parsing HH:MM syntax, got MM = %d (>59!)", minute);
      }
#line 610
      return (tmp___0);
    }
    {
#line 612
    token();
    }
  }
#line 617
  if (sc_tokid == 4) {
#line 617
    goto _L;
  } else
#line 617
  if (sc_tokid == 3) {
    _L: /* CIL Label */ 
#line 618
    if (hour > 12) {
      {
#line 619
      tmp___1 = e((char *)"there cannot be more than 12 AM or PM hours");
      }
#line 619
      return (tmp___1);
    }
#line 621
    if (sc_tokid == 3) {
#line 622
      if (hour != 12) {
#line 623
        hour += 12;
      }
    } else
#line 625
    if (hour == 12) {
#line 626
      hour = 0;
    }
    {
#line 628
    token();
    }
  } else
#line 629
  if (hour > 23) {
    {
#line 631
    scc = (char )scc_sv;
#line 632
    sct = sct_sv;
#line 633
    sc_tokid = sc_tokid_sv;
#line 634
    sprintf((char */* __restrict  */)sc_token, (char const   */* __restrict  */)"%d",
            hour);
    }
#line 635
    return ((char *)((void *)0));
  }
#line 637
  ptv->tm.tm_hour = hour;
#line 638
  ptv->tm.tm_min = minute;
#line 639
  ptv->tm.tm_sec = 0;
#line 641
  if (ptv->tm.tm_hour == 24) {
#line 642
    ptv->tm.tm_hour = 0;
#line 643
    (ptv->tm.tm_mday) ++;
  }
#line 645
  return ((char *)((void *)0));
}
}
#line 652 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char *assign_date(rrd_time_value_t *ptv , long mday , long mon , long year ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 658
  if (year > 138L) {
#line 659
    if (year > 1970L) {
#line 660
      year -= 1900L;
    } else {
      {
#line 662
      tmp = e((char *)"invalid year %d (should be either 00-99 or >1900)", year);
      }
#line 662
      return (tmp);
    }
  } else
#line 665
  if (year >= 0L) {
#line 665
    if (year < 38L) {
#line 666
      year += 100L;
    }
  }
#line 670
  if (year < 70L) {
    {
#line 671
    tmp___0 = e((char *)"won\'t handle dates before epoch (01/01/1970), sorry");
    }
#line 671
    return (tmp___0);
  }
#line 674
  ptv->tm.tm_mday = (int )mday;
#line 675
  ptv->tm.tm_mon = (int )mon;
#line 676
  ptv->tm.tm_year = (int )year;
#line 678
  return ((char *)((void *)0));
}
}
#line 685 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
static char *day(rrd_time_value_t *ptv ) 
{ 
  time_t mday ;
  time_t wday ;
  time_t mon ;
  time_t year ;
  char *_e ;
  int tmp ;
  char *_e___0 ;
  struct tm *tmp___0 ;
  char cmon[3] ;
  char cmday[3] ;
  char cyear[5] ;
  int sep ;
  char *_e___1 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *_e___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long x ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *_e___3 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 689
  mday = (time_t )0;
#line 689
  year = (time_t )ptv->tm.tm_year;
  {
#line 692
  if (sc_tokid == 5) {
#line 692
    goto case_5;
  }
#line 696
  if (sc_tokid == 6) {
#line 696
    goto case_6;
  }
#line 699
  if (sc_tokid == 7) {
#line 699
    goto case_7;
  }
#line 716
  if (sc_tokid == 39) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 38) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 37) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 36) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 35) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 34) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 33) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 32) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 31) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 30) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 29) {
#line 716
    goto case_39;
  }
#line 716
  if (sc_tokid == 28) {
#line 716
    goto case_39;
  }
#line 737
  if (sc_tokid == 46) {
#line 737
    goto case_46;
  }
#line 737
  if (sc_tokid == 45) {
#line 737
    goto case_46;
  }
#line 737
  if (sc_tokid == 44) {
#line 737
    goto case_46;
  }
#line 737
  if (sc_tokid == 43) {
#line 737
    goto case_46;
  }
#line 737
  if (sc_tokid == 42) {
#line 737
    goto case_46;
  }
#line 737
  if (sc_tokid == 41) {
#line 737
    goto case_46;
  }
#line 737
  if (sc_tokid == 40) {
#line 737
    goto case_46;
  }
#line 755
  if (sc_tokid == 20) {
#line 755
    goto case_20;
  }
#line 691
  goto switch_break;
  case_5: /* CIL Label */ 
#line 693
  (ptv->tm.tm_mday) --;
  case_6: /* CIL Label */ 
  {
#line 697
  token();
  }
#line 698
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 700
  (ptv->tm.tm_mday) ++;
#line 702
  token();
  }
#line 703
  goto switch_break;
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  {
#line 719
  mon = (time_t )(sc_tokid - 28);
#line 720
  _e = expect2(20, (char *)"the day of the month should follow month name");
  }
#line 720
  if (_e) {
    {
#line 720
    EnsureMemFree();
    }
#line 720
    return (_e);
  }
  {
#line 721
  mday = atol((char const   *)sc_token);
#line 722
  tmp = token();
  }
#line 722
  if (tmp == 20) {
    {
#line 723
    year = atol((char const   *)sc_token);
#line 724
    token();
    }
  } else {
#line 726
    year = (time_t )ptv->tm.tm_year;
  }
  {
#line 728
  _e___0 = assign_date(ptv, mday, mon, year);
  }
#line 728
  if (_e___0) {
    {
#line 728
    EnsureMemFree();
    }
#line 728
    return (_e___0);
  }
#line 729
  goto switch_break;
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  {
#line 740
  wday = (time_t )(sc_tokid - 40);
#line 741
  ptv->tm.tm_mday = (int )((time_t )ptv->tm.tm_mday + (wday - (time_t )ptv->tm.tm_wday));
#line 744
  token();
  }
#line 745
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 758
  mon = atol((char const   *)sc_token);
  }
#line 759
  if (mon > 315360000L) {
    {
#line 760
    tmp___0 = localtime((time_t const   *)(& mon));
#line 760
    ptv->tm = *tmp___0;
#line 762
    token();
    }
#line 763
    goto switch_break;
  }
#line 766
  if (mon > 19700101L) {
#line 766
    if (mon < 24000101L) {
      {
#line 769
      strncpy((char */* __restrict  */)(cyear), (char const   */* __restrict  */)sc_token,
              (size_t )4);
#line 770
      cyear[4] = (char )'\000';
#line 771
      year = atol((char const   *)(cyear));
#line 772
      strncpy((char */* __restrict  */)(cmon), (char const   */* __restrict  */)(sc_token + 4),
              (size_t )2);
#line 773
      cmon[2] = (char )'\000';
#line 774
      mon = atol((char const   *)(cmon));
#line 775
      strncpy((char */* __restrict  */)(cmday), (char const   */* __restrict  */)(sc_token + 6),
              (size_t )2);
#line 776
      cmday[2] = (char )'\000';
#line 777
      mday = atol((char const   *)(cmday));
#line 778
      token();
      }
    } else {
#line 766
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 780
    token();
    }
#line 782
    if (mon <= 31L) {
#line 782
      if (sc_tokid == 25) {
#line 782
        goto _L;
      } else
#line 782
      if (sc_tokid == 23) {
        _L: /* CIL Label */ 
#line 785
        sep = sc_tokid;
#line 786
        if (sep == 23) {
#line 786
          tmp___1 = '.';
        } else {
#line 786
          tmp___1 = '/';
        }
#line 786
        if (sep == 23) {
#line 786
          tmp___2 = "month";
        } else {
#line 786
          tmp___2 = "day";
        }
        {
#line 786
        _e___1 = expect2(20, (char *)"there should be %s number after \'%c\'", tmp___2,
                         tmp___1);
        }
#line 786
        if (_e___1) {
          {
#line 786
          EnsureMemFree();
          }
#line 786
          return (_e___1);
        }
        {
#line 789
        mday = atol((char const   *)sc_token);
#line 790
        tmp___4 = token();
        }
#line 790
        if (tmp___4 == sep) {
#line 791
          if (sep == 23) {
#line 791
            tmp___3 = '.';
          } else {
#line 791
            tmp___3 = '/';
          }
          {
#line 791
          _e___2 = expect2(20, (char *)"there should be year number after \'%c\'",
                           tmp___3);
          }
#line 791
          if (_e___2) {
            {
#line 791
            EnsureMemFree();
            }
#line 791
            return (_e___2);
          }
          {
#line 794
          year = atol((char const   *)sc_token);
#line 795
          token();
          }
        }
#line 800
        if (sep == 23) {
#line 801
          x = mday;
#line 803
          mday = mon;
#line 804
          mon = x;
        }
      }
    }
  }
#line 809
  mon --;
#line 810
  if (mon < 0L) {
    {
#line 811
    tmp___5 = e((char *)"did you really mean month %d?", mon + 1L);
    }
#line 811
    return (tmp___5);
  } else
#line 810
  if (mon > 11L) {
    {
#line 811
    tmp___5 = e((char *)"did you really mean month %d?", mon + 1L);
    }
#line 811
    return (tmp___5);
  }
#line 813
  if (mday < 1L) {
    {
#line 814
    tmp___6 = e((char *)"I\'m afraid that %d is not a valid day of the month", mday);
    }
#line 814
    return (tmp___6);
  } else
#line 813
  if (mday > 31L) {
    {
#line 814
    tmp___6 = e((char *)"I\'m afraid that %d is not a valid day of the month", mday);
    }
#line 814
    return (tmp___6);
  }
  {
#line 817
  _e___3 = assign_date(ptv, mday, mon, year);
  }
#line 817
  if (_e___3) {
    {
#line 817
    EnsureMemFree();
    }
#line 817
    return (_e___3);
  }
#line 818
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 820
  return ((char *)((void *)0));
}
}
#line 836 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
char *rrd_parsetime(char const   *tspec , rrd_time_value_t *ptv ) 
{ 
  time_t now ;
  time_t tmp ;
  int hr ;
  char *_e ;
  struct tm *tmp___0 ;
  int time_reference ;
  char *tmp___1 ;
  char *tmp___2 ;
  long hour_sv ;
  long year_sv ;
  char *_e___0 ;
  char *_e___1 ;
  char *_e___2 ;
  char *_e___3 ;
  char *_e___4 ;
  char *_e___5 ;
  char *tmp___3 ;
  char *_e___6 ;
  char *_e___7 ;
  char *tmp___4 ;
  char *tmp___5 ;
  time_t tmp___6 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 840
  tmp = time((time_t *)((void *)0));
#line 840
  now = tmp;
#line 841
  hr = 0;
#line 845
  Specials = VariousWords;
#line 847
  _e = init_scanner(1, & tspec);
  }
#line 847
  if (_e) {
    {
#line 847
    EnsureMemFree();
    }
#line 847
    return (_e);
  }
  {
#line 850
  ptv->type = (rrd_timetype_t )0;
#line 851
  ptv->offset = 0L;
#line 852
  tmp___0 = localtime((time_t const   *)(& now));
#line 852
  ptv->tm = *tmp___0;
#line 853
  ptv->tm.tm_isdst = -1;
#line 855
  token();
  }
  {
#line 858
  if (sc_tokid == 22) {
#line 858
    goto case_22;
  }
#line 858
  if (sc_tokid == 21) {
#line 858
    goto case_22;
  }
#line 861
  if (sc_tokid == 11) {
#line 861
    goto case_11;
  }
#line 864
  if (sc_tokid == 9) {
#line 864
    goto case_9;
  }
#line 867
  if (sc_tokid == 10) {
#line 867
    goto case_10;
  }
#line 878
  if (sc_tokid == 8) {
#line 878
    goto case_8;
  }
#line 894
  if (sc_tokid == 20) {
#line 894
    goto case_20;
  }
#line 927
  if (sc_tokid == 39) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 38) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 37) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 36) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 35) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 34) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 33) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 32) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 31) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 30) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 29) {
#line 927
    goto case_39;
  }
#line 927
  if (sc_tokid == 28) {
#line 927
    goto case_39;
  }
#line 941
  if (sc_tokid == 2) {
#line 941
    goto case_2;
  }
#line 944
  if (sc_tokid == 1) {
#line 944
    goto case_1;
  }
#line 947
  if (sc_tokid == 0) {
#line 947
    goto case_0;
  }
#line 959
  goto switch_default;
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 859
  goto switch_break;
  case_11: /* CIL Label */ 
#line 862
  ptv->type = (rrd_timetype_t )3;
#line 863
  goto KeepItRelative;
  case_9: /* CIL Label */ 
#line 865
  ptv->type = (rrd_timetype_t )1;
#line 866
  goto KeepItRelative;
  case_10: /* CIL Label */ 
#line 868
  ptv->type = (rrd_timetype_t )2;
  KeepItRelative: 
#line 870
  ptv->tm.tm_sec = 0;
#line 871
  ptv->tm.tm_min = 0;
#line 872
  ptv->tm.tm_hour = 0;
#line 873
  ptv->tm.tm_mday = 0;
#line 874
  ptv->tm.tm_mon = 0;
#line 875
  ptv->tm.tm_year = 0;
  case_8: /* CIL Label */ 
  {
#line 880
  time_reference = sc_tokid;
#line 882
  token();
  }
#line 883
  if (sc_tokid == 21) {
#line 884
    goto switch_break;
  } else
#line 883
  if (sc_tokid == 22) {
#line 884
    goto switch_break;
  }
#line 885
  if (time_reference != 8) {
    {
#line 886
    tmp___1 = e((char *)"\'start\' or \'end\' MUST be followed by +|- offset");
    }
#line 886
    return (tmp___1);
  } else
#line 887
  if (sc_tokid != -1) {
    {
#line 888
    tmp___2 = e((char *)"if \'now\' is followed by a token it must be +|- offset");
    }
#line 888
    return (tmp___2);
  }
#line 891
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 896
  hour_sv = (long )ptv->tm.tm_hour;
#line 897
  year_sv = (long )ptv->tm.tm_year;
#line 899
  ptv->tm.tm_hour = 30;
#line 900
  ptv->tm.tm_year = 30000;
#line 902
  _e___0 = tod(ptv);
  }
#line 902
  if (_e___0) {
    {
#line 902
    EnsureMemFree();
    }
#line 902
    return (_e___0);
  }
  {
#line 903
  _e___1 = day(ptv);
  }
#line 903
  if (_e___1) {
    {
#line 903
    EnsureMemFree();
    }
#line 903
    return (_e___1);
  }
#line 904
  if (ptv->tm.tm_hour == 30) {
#line 904
    if (ptv->tm.tm_year != 30000) {
      {
#line 905
      _e___2 = tod(ptv);
      }
#line 905
      if (_e___2) {
        {
#line 905
        EnsureMemFree();
        }
#line 905
        return (_e___2);
      }
    }
  }
#line 907
  if (ptv->tm.tm_hour == 30) {
#line 908
    ptv->tm.tm_hour = (int )hour_sv;
  }
#line 910
  if (ptv->tm.tm_year == 30000) {
#line 911
    ptv->tm.tm_year = (int )year_sv;
  }
#line 914
  goto switch_break;
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  {
#line 928
  _e___3 = day(ptv);
  }
#line 928
  if (_e___3) {
    {
#line 928
    EnsureMemFree();
    }
#line 928
    return (_e___3);
  }
#line 929
  if (sc_tokid != 20) {
#line 930
    goto switch_break;
  }
  {
#line 931
  _e___4 = tod(ptv);
  }
#line 931
  if (_e___4) {
    {
#line 931
    EnsureMemFree();
    }
#line 931
    return (_e___4);
  }
#line 932
  goto switch_break;
  case_2: /* CIL Label */ 
#line 942
  hr += 4;
  case_1: /* CIL Label */ 
#line 945
  hr += 12;
  case_0: /* CIL Label */ 
  {
#line 952
  ptv->tm.tm_hour = hr;
#line 953
  ptv->tm.tm_min = 0;
#line 954
  ptv->tm.tm_sec = 0;
#line 956
  token();
#line 957
  _e___5 = day(ptv);
  }
#line 957
  if (_e___5) {
    {
#line 957
    EnsureMemFree();
    }
#line 957
    return (_e___5);
  }
#line 958
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 960
  tmp___3 = e((char *)"unparsable time: %s%s", sc_token, sct);
  }
#line 960
  return (tmp___3);
#line 961
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 969
  if (sc_tokid == 21) {
#line 969
    goto _L;
  } else
#line 969
  if (sc_tokid == 22) {
    _L: /* CIL Label */ 
#line 970
    Specials = TimeMultipliers;
    {
#line 971
    while (1) {
      while_continue: /* CIL Label */ ;
#line 971
      if (! (sc_tokid == 21)) {
#line 971
        if (! (sc_tokid == 22)) {
#line 971
          if (! (sc_tokid == 20)) {
#line 971
            goto while_break;
          }
        }
      }
#line 972
      if (sc_tokid == 20) {
        {
#line 973
        _e___6 = plus_minus(ptv, -1);
        }
#line 973
        if (_e___6) {
          {
#line 973
          EnsureMemFree();
          }
#line 973
          return (_e___6);
        }
      } else {
        {
#line 975
        _e___7 = plus_minus(ptv, sc_tokid);
        }
#line 975
        if (_e___7) {
          {
#line 975
          EnsureMemFree();
          }
#line 975
          return (_e___7);
        }
      }
      {
#line 976
      token();
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 982
  if (sc_tokid != -1) {
    {
#line 983
    tmp___4 = e((char *)"unparsable trailing text: \'...%s%s\'", sc_token, sct);
    }
#line 983
    return (tmp___4);
  }
#line 986
  if ((unsigned int )ptv->type == 0U) {
    {
#line 987
    tmp___6 = mktime(& ptv->tm);
    }
#line 987
    if (tmp___6 == -1L) {
      {
#line 990
      tmp___5 = e((char *)"the specified time is incorrect (out of range?)");
      }
#line 990
      return (tmp___5);
    }
  }
  {
#line 992
  EnsureMemFree();
  }
#line 993
  return ((char *)((void *)0));
}
}
#line 997 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_parsetime.c"
int rrd_proc_start_end(rrd_time_value_t *start_tv , rrd_time_value_t *end_tv , time_t *start ,
                       time_t *end ) 
{ 
  struct tm tmtmp ;
  time_t tmp ;
  struct tm *tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  struct tm tmtmp___0 ;
  time_t tmp___3 ;
  struct tm *tmp___4 ;
  time_t tmp___5 ;
  time_t tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1003
  if ((unsigned int )start_tv->type == 2U) {
#line 1003
    if ((unsigned int )end_tv->type == 1U) {
      {
#line 1005
      rrd_set_error((char *)"the start and end times cannot be specified relative to each other");
      }
#line 1007
      return (-1);
    }
  }
#line 1010
  if ((unsigned int )start_tv->type == 1U) {
    {
#line 1011
    rrd_set_error((char *)"the start time cannot be specified relative to itself");
    }
#line 1013
    return (-1);
  }
#line 1016
  if ((unsigned int )end_tv->type == 2U) {
    {
#line 1017
    rrd_set_error((char *)"the end time cannot be specified relative to itself");
    }
#line 1018
    return (-1);
  }
#line 1021
  if ((unsigned int )start_tv->type == 2U) {
    {
#line 1024
    tmp = mktime(& end_tv->tm);
#line 1024
    *end = tmp + end_tv->offset;
#line 1025
    tmp___0 = localtime((time_t const   *)end);
#line 1025
    tmtmp = *tmp___0;
#line 1026
    tmtmp.tm_mday += start_tv->tm.tm_mday;
#line 1027
    tmtmp.tm_mon += start_tv->tm.tm_mon;
#line 1028
    tmtmp.tm_year += start_tv->tm.tm_year;
#line 1030
    tmp___1 = mktime(& tmtmp);
#line 1030
    *start = tmp___1 + start_tv->offset;
    }
  } else {
    {
#line 1032
    tmp___2 = mktime(& start_tv->tm);
#line 1032
    *start = tmp___2 + start_tv->offset;
    }
  }
#line 1034
  if ((unsigned int )end_tv->type == 1U) {
    {
#line 1037
    tmp___3 = mktime(& start_tv->tm);
#line 1037
    *start = tmp___3 + start_tv->offset;
#line 1038
    tmp___4 = localtime((time_t const   *)start);
#line 1038
    tmtmp___0 = *tmp___4;
#line 1039
    tmtmp___0.tm_mday += end_tv->tm.tm_mday;
#line 1040
    tmtmp___0.tm_mon += end_tv->tm.tm_mon;
#line 1041
    tmtmp___0.tm_year += end_tv->tm.tm_year;
#line 1043
    tmp___5 = mktime(& tmtmp___0);
#line 1043
    *end = tmp___5 + end_tv->offset;
    }
  } else {
    {
#line 1045
    tmp___6 = mktime(& end_tv->tm);
#line 1045
    *end = tmp___6 + end_tv->offset;
    }
  }
#line 1047
  return (0);
}
}
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 89
extern int msync(void *__addr , size_t __len , int __flags ) ;
#line 94
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) madvise)(void *__addr ,
                                                                              size_t __len ,
                                                                              int __advice ) ;
#line 213 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 238
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) posix_fadvise)(int __fd ,
                                                                                    off_t __offset ,
                                                                                    off_t __len ,
                                                                                    int __advise ) ;
#line 260
extern int posix_fallocate(int __fd , off_t __offset , off_t __len ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 223 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
void rrd_freemem(void *mem ) ;
#line 387
void rrd_dontneed(rrd_file_t *rrd_file , rrd_t *rrd ) ;
#line 394
ssize_t rrd_read(rrd_file_t *rrd_file , void *buf , size_t count ) ;
#line 404
void rrd_flush(rrd_file_t *rrd_file  __attribute__((__unused__)) ) ;
#line 412
off_t rrd_tell(rrd_file_t *rrd_file ) ;
#line 424
unsigned long rrd_select_initial_row(rrd_file_t *rrd_file  __attribute__((__unused__)) ,
                                     int rra_idx  __attribute__((__unused__)) , rra_def_t *rra ) ;
#line 121 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.h"
off_t rrd_get_header_size(rrd_t *rrd ) ;
#line 94 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
rrd_file_t *rrd_open(char const   * const  file_name , rrd_t *rrd , unsigned int rdwr ) 
{ 
  unsigned long ui ;
  int flags ;
  int version ;
  ssize_t _page_size ;
  long tmp ;
  char *data ;
  off_t offset ;
  struct stat statb ;
  rrd_file_t *rrd_file ;
  rrd_simple_file_t *rrd_simple_file ;
  size_t newfile_size ;
  size_t header_len ;
  size_t value_cnt ;
  size_t data_len ;
  off_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  int *tmp___12 ;
  char const   *tmp___13 ;
  size_t wanted ;
  int tmp___14 ;
  int tmp___15 ;
  size_t wanted___0 ;
  size_t wanted___1 ;
  void *tmp___16 ;
  size_t wanted___2 ;
  size_t wanted___3 ;
  size_t wanted___4 ;
  size_t wanted___5 ;
  size_t wanted___6 ;
  unsigned long row_cnt ;
  size_t correct_len ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
  {
#line 100
  flags = 0;
#line 104
  tmp = sysconf(30);
#line 104
  _page_size = tmp;
#line 105
  data = (char *)((void *)-1);
#line 107
  offset = (off_t )0;
#line 109
  rrd_file = (rrd_file_t *)((void *)0);
#line 110
  rrd_simple_file = (rrd_simple_file_t *)((void *)0);
#line 111
  newfile_size = (size_t )0;
  }
#line 115
  if (rdwr & (unsigned int )(1 << 2)) {
#line 115
    if ((unsigned long )rrd->stat_head != (unsigned long )((void *)0)) {
      {
#line 117
      tmp___0 = rrd_get_header_size(rrd);
#line 117
      header_len = (size_t )tmp___0;
#line 119
      value_cnt = (size_t )0;
#line 120
      ui = 0UL;
      }
      {
#line 120
      while (1) {
        while_continue: /* CIL Label */ ;
#line 120
        if (! (ui < (rrd->stat_head)->rra_cnt)) {
#line 120
          goto while_break;
        }
#line 121
        value_cnt += (rrd->stat_head)->ds_cnt * (rrd->rra_def + ui)->row_cnt;
#line 120
        ui ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 123
      data_len = sizeof(rrd_value_t ) * value_cnt;
#line 125
      newfile_size = header_len + data_len;
    }
  }
  {
#line 128
  tmp___1 = malloc(sizeof(rrd_file_t ));
#line 128
  rrd_file = (rrd_file_t *)tmp___1;
  }
#line 129
  if ((unsigned long )rrd_file == (unsigned long )((void *)0)) {
    {
#line 130
    rrd_set_error((char *)"allocating rrd_file descriptor for \'%s\'", file_name);
    }
#line 131
    return ((rrd_file_t *)((void *)0));
  }
  {
#line 133
  memset((void *)rrd_file, 0, sizeof(rrd_file_t ));
#line 135
  rrd_file->pvt = malloc(sizeof(rrd_simple_file_t ));
  }
#line 136
  if ((unsigned long )rrd_file->pvt == (unsigned long )((void *)0)) {
    {
#line 137
    rrd_set_error((char *)"allocating rrd_simple_file for \'%s\'", file_name);
    }
#line 138
    return ((rrd_file_t *)((void *)0));
  }
  {
#line 140
  memset(rrd_file->pvt, 0, sizeof(rrd_simple_file_t ));
#line 141
  rrd_simple_file = (rrd_simple_file_t *)rrd_file->pvt;
  }
#line 144
  if ((rdwr & (unsigned int )(1 | (1 << 1))) == (unsigned int )(1 | (1 << 1))) {
    {
#line 147
    rrd_set_error((char *)"in read/write request mask");
#line 148
    exit(-1);
    }
  }
#line 153
  rrd_simple_file->mm_prot = 1;
#line 154
  rrd_simple_file->mm_flags = 0;
#line 157
  if (rdwr & 1U) {
#line 158
    flags = flags;
#line 161
    rrd_simple_file->mm_flags = 2;
#line 164
    rrd_simple_file->mm_flags |= 16384;
  } else {
#line 168
    if (rdwr & (unsigned int )(1 << 1)) {
#line 169
      flags |= 2;
#line 171
      rrd_simple_file->mm_flags = 1;
#line 172
      rrd_simple_file->mm_prot |= 2;
    }
#line 175
    if (rdwr & (unsigned int )(1 << 2)) {
#line 176
      flags |= 576;
    }
#line 178
    if (rdwr & (unsigned int )(1 << 5)) {
#line 179
      flags |= 128;
    }
  }
#line 182
  if (rdwr & (unsigned int )(1 << 3)) {
#line 184
    rrd_simple_file->mm_flags |= 32768;
#line 187
    rrd_simple_file->mm_flags |= 65536;
  }
  {
#line 194
  tmp___4 = open((char const   *)file_name, flags, 438);
#line 194
  rrd_simple_file->fd = tmp___4;
  }
#line 194
  if (tmp___4 < 0) {
    {
#line 195
    tmp___2 = __errno_location();
#line 195
    tmp___3 = rrd_strerror(*tmp___2);
#line 195
    rrd_set_error((char *)"opening \'%s\': %s", file_name, tmp___3);
    }
#line 196
    goto out_free;
  }
#line 216
  if (newfile_size == 0UL) {
    {
#line 216
    tmp___7 = fstat(rrd_simple_file->fd, & statb);
    }
#line 216
    if (tmp___7 < 0) {
      {
#line 217
      tmp___5 = __errno_location();
#line 217
      tmp___6 = rrd_strerror(*tmp___5);
#line 217
      rrd_set_error((char *)"fstat \'%s\': %s", file_name, tmp___6);
      }
#line 218
      goto out_close;
    }
  }
#line 220
  if (newfile_size == 0UL) {
#line 221
    rrd_file->file_len = (size_t )statb.st_size;
  } else {
    {
#line 223
    rrd_file->file_len = newfile_size;
#line 225
    tmp___10 = posix_fallocate(rrd_simple_file->fd, (off_t )0, (off_t )newfile_size);
    }
#line 225
    if (tmp___10 == -1) {
      {
#line 226
      tmp___8 = __errno_location();
#line 226
      tmp___9 = rrd_strerror(*tmp___8);
#line 226
      rrd_set_error((char *)"posix_fallocate \'%s\': %s", file_name, tmp___9);
      }
#line 228
      goto out_close;
    }
  }
  {
#line 244
  posix_fadvise(rrd_simple_file->fd, (off_t )0, (off_t )0, 1);
#line 292
  tmp___11 = mmap((void *)0, rrd_file->file_len, rrd_simple_file->mm_prot, rrd_simple_file->mm_flags,
                  rrd_simple_file->fd, offset);
#line 292
  data = (char *)tmp___11;
  }
#line 297
  if ((unsigned long )data == (unsigned long )((void *)-1)) {
    {
#line 298
    tmp___12 = __errno_location();
#line 298
    tmp___13 = rrd_strerror(*tmp___12);
#line 298
    rrd_set_error((char *)"mmaping file \'%s\': %s", file_name, tmp___13);
    }
#line 300
    goto out_close;
  }
#line 302
  rrd_simple_file->file_start = data;
#line 304
  if (rdwr & (unsigned int )(1 << 2)) {
#line 305
    goto out_done;
  }
#line 307
  if (rdwr & (unsigned int )(1 << 4)) {
    {
#line 309
    madvise((void *)data, rrd_file->file_len, 3);
#line 310
    madvise((void *)data, rrd_file->file_len, 2);
    }
  } else {
    {
#line 313
    madvise((void *)data, rrd_file->file_len, 1);
#line 315
    madvise((void *)data, sizeof(stat_head_t ), 3);
#line 316
    madvise((void *)data, sizeof(stat_head_t ), 1);
    }
  }
#line 320
  wanted = sizeof(stat_head_t );
#line 320
  if ((size_t )offset + wanted > rrd_file->file_len) {
    {
#line 320
    rrd_set_error((char *)"reached EOF while loading header rrd->stat_head");
    }
#line 320
    goto out_nullify_head;
  }
  {
#line 320
  rrd->stat_head = (stat_head_t *)((void *)(data + offset));
#line 320
  offset = (off_t )((size_t )offset + wanted);
#line 324
  tmp___14 = memcmp((void const   *)((rrd->stat_head)->cookie), (void const   *)"RRD",
                    sizeof("RRD"));
  }
#line 324
  if (tmp___14 != 0) {
    {
#line 325
    rrd_set_error((char *)"\'%s\' is not an RRD file", file_name);
    }
#line 326
    goto out_nullify_head;
  }
#line 329
  if ((rrd->stat_head)->float_cookie != 8.642135E130) {
    {
#line 330
    rrd_set_error((char *)"This RRD was created on another architecture");
    }
#line 331
    goto out_nullify_head;
  }
  {
#line 334
  version = atoi((char const   *)((rrd->stat_head)->version));
#line 336
  tmp___15 = atoi("0004");
  }
#line 336
  if (version > tmp___15) {
    {
#line 337
    rrd_set_error((char *)"can\'t handle RRD file version %s", (rrd->stat_head)->version);
    }
#line 339
    goto out_nullify_head;
  }
  {
#line 343
  madvise((void *)(data + (offset & ~ (_page_size - 1L))), sizeof(ds_def_t ) * (rrd->stat_head)->ds_cnt,
          3);
#line 346
  wanted___0 = sizeof(ds_def_t ) * (rrd->stat_head)->ds_cnt;
  }
#line 346
  if ((size_t )offset + wanted___0 > rrd_file->file_len) {
    {
#line 346
    rrd_set_error((char *)"reached EOF while loading header rrd->ds_def");
    }
#line 346
    goto out_nullify_head;
  }
  {
#line 346
  rrd->ds_def = (ds_def_t *)((void *)(data + offset));
#line 346
  offset = (off_t )((size_t )offset + wanted___0);
#line 351
  madvise((void *)(data + (offset & ~ (_page_size - 1L))), sizeof(rra_def_t ) * (rrd->stat_head)->rra_cnt,
          3);
#line 354
  wanted___1 = sizeof(rra_def_t ) * (rrd->stat_head)->rra_cnt;
  }
#line 354
  if ((size_t )offset + wanted___1 > rrd_file->file_len) {
    {
#line 354
    rrd_set_error((char *)"reached EOF while loading header rrd->rra_def");
    }
#line 354
    goto out_nullify_head;
  }
#line 354
  rrd->rra_def = (rra_def_t *)((void *)(data + offset));
#line 354
  offset = (off_t )((size_t )offset + wanted___1);
#line 358
  if (version < 3) {
    {
#line 359
    tmp___16 = malloc(sizeof(live_head_t ));
#line 359
    rrd->live_head = (live_head_t *)tmp___16;
    }
#line 360
    if ((unsigned long )rrd->live_head == (unsigned long )((void *)0)) {
      {
#line 361
      rrd_set_error((char *)"live_head_t malloc");
      }
#line 362
      goto out_close;
    }
    {
#line 366
    madvise((void *)(data + (offset & ~ (_page_size - 1L))), sizeof(time_t ), 3);
#line 368
    wanted___2 = sizeof(time_t );
    }
#line 368
    if ((size_t )offset + wanted___2 > rrd_file->file_len) {
      {
#line 368
      rrd_set_error((char *)"reached EOF while loading header rrd->legacy_last_up");
      }
#line 368
      goto out_nullify_head;
    }
#line 368
    rrd->legacy_last_up = (time_t *)((void *)(data + offset));
#line 368
    offset = (off_t )((size_t )offset + wanted___2);
#line 371
    (rrd->live_head)->last_up = *(rrd->legacy_last_up);
#line 372
    (rrd->live_head)->last_up_usec = 0L;
  } else {
    {
#line 376
    madvise((void *)(data + (offset & ~ (_page_size - 1L))), sizeof(live_head_t ),
            3);
#line 379
    wanted___3 = sizeof(live_head_t );
    }
#line 379
    if ((size_t )offset + wanted___3 > rrd_file->file_len) {
      {
#line 379
      rrd_set_error((char *)"reached EOF while loading header rrd->live_head");
      }
#line 379
      goto out_nullify_head;
    }
#line 379
    rrd->live_head = (live_head_t *)((void *)(data + offset));
#line 379
    offset = (off_t )((size_t )offset + wanted___3);
  }
#line 382
  wanted___4 = sizeof(pdp_prep_t ) * (rrd->stat_head)->ds_cnt;
#line 382
  if ((size_t )offset + wanted___4 > rrd_file->file_len) {
    {
#line 382
    rrd_set_error((char *)"reached EOF while loading header rrd->pdp_prep");
    }
#line 382
    goto out_nullify_head;
  }
#line 382
  rrd->pdp_prep = (pdp_prep_t *)((void *)(data + offset));
#line 382
  offset = (off_t )((size_t )offset + wanted___4);
#line 384
  wanted___5 = sizeof(cdp_prep_t ) * ((rrd->stat_head)->rra_cnt * (rrd->stat_head)->ds_cnt);
#line 384
  if ((size_t )offset + wanted___5 > rrd_file->file_len) {
    {
#line 384
    rrd_set_error((char *)"reached EOF while loading header rrd->cdp_prep");
    }
#line 384
    goto out_nullify_head;
  }
#line 384
  rrd->cdp_prep = (cdp_prep_t *)((void *)(data + offset));
#line 384
  offset = (off_t )((size_t )offset + wanted___5);
#line 386
  wanted___6 = sizeof(rra_ptr_t ) * (rrd->stat_head)->rra_cnt;
#line 386
  if ((size_t )offset + wanted___6 > rrd_file->file_len) {
    {
#line 386
    rrd_set_error((char *)"reached EOF while loading header rrd->rra_ptr");
    }
#line 386
    goto out_nullify_head;
  }
#line 386
  rrd->rra_ptr = (rra_ptr_t *)((void *)(data + offset));
#line 386
  offset = (off_t )((size_t )offset + wanted___6);
#line 389
  rrd_file->header_len = (size_t )offset;
#line 390
  rrd_file->pos = (size_t )offset;
#line 393
  row_cnt = 0UL;
#line 395
  ui = 0UL;
  {
#line 395
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 395
    if (! (ui < (rrd->stat_head)->rra_cnt)) {
#line 395
      goto while_break___0;
    }
#line 396
    row_cnt += (rrd->rra_def + ui)->row_cnt;
#line 395
    ui ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 398
  correct_len = rrd_file->header_len + (sizeof(rrd_value_t ) * row_cnt) * (rrd->stat_head)->ds_cnt;
#line 401
  if (correct_len > rrd_file->file_len) {
    {
#line 403
    rrd_set_error((char *)"\'%s\' is too small (should be %ld bytes)", file_name,
                  (long long )correct_len);
    }
#line 405
    goto out_nullify_head;
  }
  out_done: 
#line 410
  return (rrd_file);
  out_nullify_head: 
#line 412
  rrd->stat_head = (stat_head_t *)((void *)0);
  out_close: 
#line 415
  if ((unsigned long )data != (unsigned long )((void *)-1)) {
    {
#line 416
    munmap((void *)data, rrd_file->file_len);
    }
  }
  {
#line 419
  close(rrd_simple_file->fd);
  }
  out_free: 
  {
#line 421
  free(rrd_file->pvt);
#line 422
  free((void *)rrd_file);
  }
#line 423
  return ((rrd_file_t *)((void *)0));
}
}
#line 480 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
int rrd_lock(rrd_file_t *rrd_file ) 
{ 
  int rcstat ;
  rrd_simple_file_t *rrd_simple_file ;
  struct flock lock___0 ;

  {
  {
#line 485
  rrd_simple_file = (rrd_simple_file_t *)rrd_file->pvt;
#line 499
  lock___0.l_type = (short)1;
#line 500
  lock___0.l_len = (__off_t )0;
#line 501
  lock___0.l_start = (__off_t )0;
#line 502
  lock___0.l_whence = (short)0;
#line 504
  rcstat = fcntl(rrd_simple_file->fd, 6, & lock___0);
  }
#line 508
  return (rcstat);
}
}
#line 513 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
void rrd_dontneed(rrd_file_t *rrd_file , rrd_t *rrd ) 
{ 
  rrd_simple_file_t *rrd_simple_file ;
  size_t dontneed_start ;
  size_t rra_start ;
  size_t active_block ;
  size_t i ;
  ssize_t _page_size ;
  long tmp ;
  char *__cil_tmp10 ;

  {
  {
#line 517
  rrd_simple_file = (rrd_simple_file_t *)rrd_file->pvt;
#line 523
  tmp = sysconf(30);
#line 523
  _page_size = tmp;
  }
#line 525
  if ((unsigned long )rrd_file == (unsigned long )((void *)0)) {
    {
#line 527
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rrd_dontneed: Argument \'rrd_file\' is NULL.\n");
    }
#line 529
    return;
  }
#line 537
  rra_start = rrd_file->header_len;
#line 538
  dontneed_start = (rra_start & (unsigned long )(~ (_page_size - 1L))) + (unsigned long )_page_size;
#line 539
  i = (size_t )0;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! (i < (rrd->stat_head)->rra_cnt)) {
#line 539
      goto while_break;
    }
#line 540
    active_block = (rra_start + ((rrd->rra_ptr + i)->cur_row * (rrd->stat_head)->ds_cnt) * sizeof(rrd_value_t )) & (unsigned long )(~ (_page_size - 1L));
#line 544
    if (active_block > dontneed_start) {
      {
#line 546
      madvise((void *)(rrd_simple_file->file_start + dontneed_start), (active_block - dontneed_start) - 1UL,
              4);
#line 551
      posix_fadvise(rrd_simple_file->fd, (off_t )dontneed_start, (off_t )((active_block - dontneed_start) - 1UL),
                    4);
      }
    }
#line 556
    dontneed_start = active_block;
#line 559
    if ((rrd->stat_head)->pdp_step * (rrd->rra_def + i)->pdp_cnt - (unsigned long )(rrd->live_head)->last_up % ((rrd->stat_head)->pdp_step * (rrd->rra_def + i)->pdp_cnt) < 600UL) {
#line 562
      dontneed_start += (size_t )_page_size;
    }
#line 564
    rra_start += ((rrd->rra_def + i)->row_cnt * (rrd->stat_head)->ds_cnt) * sizeof(rrd_value_t );
#line 539
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  if (dontneed_start < rrd_file->file_len) {
    {
#line 571
    madvise((void *)(rrd_simple_file->file_start + dontneed_start), rrd_file->file_len - dontneed_start,
            4);
#line 575
    posix_fadvise(rrd_simple_file->fd, (off_t )dontneed_start, (off_t )(rrd_file->file_len - dontneed_start),
                  4);
    }
  }
#line 585
  return;
}
}
#line 591 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
int rrd_close(rrd_file_t *rrd_file ) 
{ 
  rrd_simple_file_t *rrd_simple_file ;
  int ret ;
  int *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 595
  rrd_simple_file = (rrd_simple_file_t *)rrd_file->pvt;
#line 599
  ret = msync((void *)rrd_simple_file->file_start, rrd_file->file_len, 1);
  }
#line 600
  if (ret != 0) {
    {
#line 601
    tmp = __errno_location();
#line 601
    tmp___0 = rrd_strerror(*tmp);
#line 601
    rrd_set_error((char *)"msync rrd_file: %s", tmp___0);
    }
  }
  {
#line 602
  ret = munmap((void *)rrd_simple_file->file_start, rrd_file->file_len);
  }
#line 603
  if (ret != 0) {
    {
#line 604
    tmp___1 = __errno_location();
#line 604
    tmp___2 = rrd_strerror(*tmp___1);
#line 604
    rrd_set_error((char *)"munmap rrd_file: %s", tmp___2);
    }
  }
  {
#line 606
  ret = close(rrd_simple_file->fd);
  }
#line 607
  if (ret != 0) {
    {
#line 608
    tmp___3 = __errno_location();
#line 608
    tmp___4 = rrd_strerror(*tmp___3);
#line 608
    rrd_set_error((char *)"closing file: %s", tmp___4);
    }
  }
  {
#line 609
  free(rrd_file->pvt);
#line 610
  free((void *)rrd_file);
#line 611
  rrd_file = (rrd_file_t *)((void *)0);
  }
#line 612
  return (ret);
}
}
#line 618 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
off_t rrd_seek(rrd_file_t *rrd_file , off_t off , int whence ) 
{ 
  off_t ret ;

  {
#line 623
  ret = (off_t )0;
#line 630
  if (whence == 0) {
#line 631
    rrd_file->pos = (size_t )off;
  } else
#line 632
  if (whence == 1) {
#line 633
    rrd_file->pos += (size_t )off;
  } else
#line 634
  if (whence == 2) {
#line 635
    rrd_file->pos = rrd_file->file_len + (size_t )off;
  }
#line 643
  return ((off_t )(ret < 0L));
}
}
#line 649 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
off_t rrd_tell(rrd_file_t *rrd_file ) 
{ 


  {
#line 652
  return ((off_t )rrd_file->pos);
}
}
#line 659 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
ssize_t rrd_read(rrd_file_t *rrd_file , void *buf , size_t count ) 
{ 
  rrd_simple_file_t *rrd_simple_file ;
  size_t _cnt ;
  ssize_t _surplus ;

  {
#line 664
  rrd_simple_file = (rrd_simple_file_t *)rrd_file->pvt;
#line 666
  _cnt = count;
#line 669
  if (rrd_file->pos > rrd_file->file_len) {
#line 670
    return ((ssize_t )0);
  } else
#line 669
  if (_cnt == 0UL) {
#line 670
    return ((ssize_t )0);
  }
#line 671
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 672
    return ((ssize_t )-1);
  }
#line 673
  _surplus = (ssize_t )((rrd_file->pos + _cnt) - rrd_file->file_len);
#line 674
  if (_surplus > 0L) {
#line 675
    _cnt -= (size_t )_surplus;
  }
#line 677
  if (_cnt == 0UL) {
#line 678
    return ((ssize_t )0);
  }
  {
#line 679
  buf = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(rrd_simple_file->file_start + rrd_file->pos),
               _cnt);
#line 681
  rrd_file->pos += _cnt;
  }
#line 682
  return ((ssize_t )_cnt);
}
}
#line 698 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
ssize_t rrd_write(rrd_file_t *rrd_file , void const   *buf , size_t count ) 
{ 
  rrd_simple_file_t *rrd_simple_file ;
  size_t old_size ;
  char *__cil_tmp6 ;

  {
#line 703
  rrd_simple_file = (rrd_simple_file_t *)rrd_file->pvt;
#line 705
  old_size = rrd_file->file_len;
#line 706
  if (count == 0UL) {
#line 707
    return ((ssize_t )0);
  }
#line 708
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 709
    return ((ssize_t )-1);
  }
#line 711
  if (rrd_file->pos + count > old_size) {
    {
#line 713
    rrd_set_error((char *)"attempting to write beyond end of file");
    }
#line 714
    return ((ssize_t )-1);
  }
  {
#line 716
  memcpy((void */* __restrict  */)(rrd_simple_file->file_start + rrd_file->pos), (void const   */* __restrict  */)buf,
         count);
#line 717
  rrd_file->pos += count;
  }
#line 718
  return ((ssize_t )count);
}
}
#line 731 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
void rrd_flush(rrd_file_t *rrd_file  __attribute__((__unused__)) ) 
{ 


  {
#line 734
  return;
}
}
#line 738 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
void rrd_init(rrd_t *rrd ) 
{ 


  {
#line 741
  rrd->stat_head = (stat_head_t *)((void *)0);
#line 742
  rrd->ds_def = (ds_def_t *)((void *)0);
#line 743
  rrd->rra_def = (rra_def_t *)((void *)0);
#line 744
  rrd->live_head = (live_head_t *)((void *)0);
#line 745
  rrd->legacy_last_up = (time_t *)((void *)0);
#line 746
  rrd->rra_ptr = (rra_ptr_t *)((void *)0);
#line 747
  rrd->pdp_prep = (pdp_prep_t *)((void *)0);
#line 748
  rrd->cdp_prep = (cdp_prep_t *)((void *)0);
#line 749
  rrd->rrd_value = (rrd_value_t *)((void *)0);
#line 750
  return;
}
}
#line 756 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
void rrd_free(rrd_t *rrd ) 
{ 


  {
#line 759
  if (rrd->legacy_last_up) {
    {
#line 760
    free((void *)rrd->live_head);
    }
  }
#line 762
  return;
}
}
#line 782 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
void rrd_freemem(void *mem ) 
{ 


  {
  {
#line 785
  free(mem);
  }
#line 786
  return;
}
}
#line 793 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
void rrd_notify_row(rrd_file_t *rrd_file  __attribute__((__unused__)) , int rra_idx  __attribute__((__unused__)) ,
                    unsigned long rra_row  __attribute__((__unused__)) , time_t rra_time  __attribute__((__unused__)) ) 
{ 


  {
#line 799
  return;
}
}
#line 808 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_open.c"
unsigned long rrd_select_initial_row(rrd_file_t *rrd_file  __attribute__((__unused__)) ,
                                     int rra_idx  __attribute__((__unused__)) , rra_def_t *rra ) 
{ 
  long tmp ;

  {
  {
#line 814
  tmp = rrd_random();
  }
#line 814
  return ((unsigned long )tmp % rra->row_cnt);
}
}
#line 412 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 298 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
rrd_context_t *rrd_get_context(void) ;
#line 20 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_not_thread_safe.c"
static rrd_context_t global_ctx  =    {{(char )'\000'}, {(char )'\000'}};
#line 27 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_not_thread_safe.c"
rrd_context_t *rrd_get_context(void) 
{ 


  {
#line 30
  return (& global_ctx);
}
}
#line 38 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_not_thread_safe.c"
char const   *rrd_strerror(int err ) 
{ 
  char *tmp ;

  {
  {
#line 41
  tmp = strerror(err);
  }
#line 41
  return ((char const   *)tmp);
}
}
#line 1 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_nan_inf.c"
int done_nan  =    0;
#line 2 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_nan_inf.c"
int done_inf  =    0;
#line 4 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_nan_inf.c"
double dnan  ;
#line 5 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_nan_inf.c"
double dinf  ;
#line 22 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_nan_inf.c"
double rrd_set_to_DNAN(void) 
{ 


  {
#line 25
  if (! done_nan) {
#line 26
    dnan = 0.0 / 0.0;
#line 27
    done_nan = 1;
  }
#line 29
  return (dnan);
}
}
#line 32 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_nan_inf.c"
double rrd_set_to_DINF(void) 
{ 


  {
#line 35
  if (! done_inf) {
#line 36
    dinf = 1.0 / 0.0;
#line 37
    done_inf = 1;
  }
#line 39
  return (dinf);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 399
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 148 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
rrd_info_t *rrd_info(int argc , char **argv ) ;
#line 156
void rrd_info_print(rrd_info_t *data ) ;
#line 158
void rrd_info_free(rrd_info_t *data ) ;
#line 233
rrd_info_t *rrd_info_r(char *filename ) ;
#line 72 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.h"
int rrdc_flush_if_daemon(char const   *opt_daemon , char const   *filename ) ;
#line 20 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_info.c"
char *sprintf_alloc(char *fmt  , ...) 
{ 
  char *str ;
  va_list argp ;
  int tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 24
  str = (char *)((void *)0);
#line 27
  __builtin_va_start(argp, fmt);
#line 28
  tmp = vasprintf((char **/* __restrict  */)(& str), (char const   */* __restrict  */)fmt,
                  argp);
  }
#line 28
  if (tmp == -1) {
    {
#line 29
    __builtin_va_end(argp);
#line 30
    rrd_set_error((char *)"vasprintf failed.");
    }
#line 31
    return ((char *)((void *)0));
  }
  {
#line 45
  __builtin_va_end(argp);
  }
#line 46
  return (str);
}
}
#line 51 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_info.c"
rrd_info_t *rrd_info_push(rrd_info_t *info , char *key , rrd_info_type_t type , rrd_infoval_t value ) 
{ 
  rrd_info_t *next ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 57
  tmp = malloc(sizeof(*next));
#line 57
  next = (rrd_info_t *)tmp;
#line 58
  next->next = (rrd_info_t *)0;
  }
#line 59
  if (info) {
#line 60
    info->next = next;
  }
#line 61
  next->type = type;
#line 62
  next->key = key;
  {
#line 64
  if ((unsigned int )type == 0U) {
#line 64
    goto case_0;
  }
#line 67
  if ((unsigned int )type == 1U) {
#line 67
    goto case_1;
  }
#line 70
  if ((unsigned int )type == 3U) {
#line 70
    goto case_3;
  }
#line 73
  if ((unsigned int )type == 2U) {
#line 73
    goto case_2;
  }
#line 77
  if ((unsigned int )type == 4U) {
#line 77
    goto case_4;
  }
#line 63
  goto switch_break;
  case_0: /* CIL Label */ 
#line 65
  next->value.u_val = value.u_val;
#line 66
  goto switch_break;
  case_1: /* CIL Label */ 
#line 68
  next->value.u_cnt = value.u_cnt;
#line 69
  goto switch_break;
  case_3: /* CIL Label */ 
#line 71
  next->value.u_int = value.u_int;
#line 72
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 74
  tmp___0 = strlen((char const   *)value.u_str);
#line 74
  tmp___1 = malloc(sizeof(char ) * (tmp___0 + 1UL));
#line 74
  next->value.u_str = (char *)tmp___1;
#line 75
  strcpy((char */* __restrict  */)next->value.u_str, (char const   */* __restrict  */)value.u_str);
  }
#line 76
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 78
  next->value.u_blo.size = value.u_blo.size;
#line 79
  tmp___2 = malloc(sizeof(unsigned char ) * value.u_blo.size);
#line 79
  next->value.u_blo.ptr = (unsigned char *)tmp___2;
#line 81
  memcpy((void */* __restrict  */)next->value.u_blo.ptr, (void const   */* __restrict  */)value.u_blo.ptr,
         value.u_blo.size);
  }
#line 82
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 84
  return (next);
}
}
#line 102 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_info.c"
static struct option long_options[2]  = {      {"daemon", 1, (int *)0, 'd'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 88 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_info.c"
rrd_info_t *rrd_info(int argc , char **argv ) 
{ 
  rrd_info_t *info ;
  char *opt_daemon ;
  int status ;
  int opt ;
  int option_index ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 93
  opt_daemon = (char *)((void *)0);
#line 96
  optind = 0;
#line 97
  opterr = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    option_index = 0;
#line 107
    opt = getopt_long(argc, (char * const  *)argv, "d:", (struct option  const  *)(long_options),
                      & option_index);
    }
#line 109
    if (opt == -1) {
#line 110
      goto while_break;
    }
    {
#line 113
    if (opt == 100) {
#line 113
      goto case_100;
    }
#line 124
    goto switch_default;
    case_100: /* CIL Label */ 
#line 114
    if ((unsigned long )opt_daemon != (unsigned long )((void *)0)) {
      {
#line 115
      free((void *)opt_daemon);
      }
    }
    {
#line 116
    opt_daemon = strdup((char const   *)optarg);
    }
#line 117
    if ((unsigned long )opt_daemon == (unsigned long )((void *)0)) {
      {
#line 119
      rrd_set_error((char *)"strdup failed.");
      }
#line 120
      return ((rrd_info_t *)((void *)0));
    }
#line 122
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 125
    rrd_set_error((char *)"Usage: rrdtool %s [--daemon <addr>] <file>", *(argv + 0));
    }
#line 127
    return ((rrd_info_t *)((void *)0));
#line 128
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  if (argc - optind != 1) {
    {
#line 133
    rrd_set_error((char *)"Usage: rrdtool %s [--daemon <addr>] <file>", *(argv + 0));
    }
#line 135
    return ((rrd_info_t *)((void *)0));
  }
  {
#line 138
  status = rrdc_flush_if_daemon((char const   *)opt_daemon, (char const   *)*(argv + optind));
  }
#line 139
  if (opt_daemon) {
    {
#line 139
    free((void *)opt_daemon);
    }
  }
#line 140
  if (status) {
#line 140
    return ((rrd_info_t *)((void *)0));
  }
  {
#line 142
  info = rrd_info_r(*(argv + optind));
  }
#line 144
  return (info);
}
}
#line 147 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_info.c"
rrd_info_t *rrd_info_r(char *filename ) 
{ 
  unsigned int i ;
  unsigned int ii ;
  rrd_t rrd ;
  rrd_info_t *data ;
  rrd_info_t *cd ;
  rrd_infoval_t info ;
  rrd_file_t *rrd_file ;
  enum cf_en current_cf ;
  enum dst_en current_ds ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  off_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *buffer ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  unsigned short j ;
  char *violations_array ;
  char history[29] ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  void *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;

  {
  {
#line 150
  ii = 0U;
#line 152
  data = (rrd_info_t *)((void *)0);
#line 158
  rrd_init(& rrd);
#line 159
  rrd_file = rrd_open((char const   */* const  */)filename, & rrd, 1U);
  }
#line 160
  if ((unsigned long )rrd_file == (unsigned long )((void *)0)) {
#line 161
    goto err_free;
  }
  {
#line 163
  info.u_str = filename;
#line 164
  tmp = sprintf_alloc((char *)"filename");
#line 164
  cd = rrd_info_push((rrd_info_t *)((void *)0), tmp, (rrd_info_type_t )2, info);
#line 165
  data = cd;
#line 167
  info.u_str = (rrd.stat_head)->version;
#line 168
  tmp___0 = sprintf_alloc((char *)"rrd_version");
#line 168
  cd = rrd_info_push(cd, tmp___0, (rrd_info_type_t )2, info);
#line 170
  info.u_cnt = (rrd.stat_head)->pdp_step;
#line 171
  tmp___1 = sprintf_alloc((char *)"step");
#line 171
  cd = rrd_info_push(cd, tmp___1, (rrd_info_type_t )1, info);
#line 173
  info.u_cnt = (unsigned long )(rrd.live_head)->last_up;
#line 174
  tmp___2 = sprintf_alloc((char *)"last_update");
#line 174
  cd = rrd_info_push(cd, tmp___2, (rrd_info_type_t )1, info);
#line 176
  tmp___3 = rrd_get_header_size(& rrd);
#line 176
  info.u_cnt = (unsigned long )tmp___3;
#line 177
  tmp___4 = sprintf_alloc((char *)"header_size");
#line 177
  cd = rrd_info_push(cd, tmp___4, (rrd_info_type_t )1, info);
#line 179
  i = 0U;
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )i < (rrd.stat_head)->ds_cnt)) {
#line 179
      goto while_break;
    }
    {
#line 181
    info.u_cnt = (unsigned long )i;
#line 182
    tmp___5 = sprintf_alloc((char *)"ds[%s].index", (rrd.ds_def + i)->ds_nam);
#line 182
    cd = rrd_info_push(cd, tmp___5, (rrd_info_type_t )1, info);
#line 186
    info.u_str = (rrd.ds_def + i)->dst;
#line 187
    tmp___6 = sprintf_alloc((char *)"ds[%s].type", (rrd.ds_def + i)->ds_nam);
#line 187
    cd = rrd_info_push(cd, tmp___6, (rrd_info_type_t )2, info);
#line 191
    current_ds = dst_conv((rrd.ds_def + i)->dst);
    }
    {
#line 193
    if ((unsigned int )current_ds == 4U) {
#line 193
      goto case_4;
    }
#line 207
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 195
    buffer = (char *)((void *)0);
#line 197
    rpn_compact2str((rpn_cdefds_t *)(& (rrd.ds_def + i)->par[0]), rrd.ds_def, & buffer);
#line 199
    info.u_str = buffer;
#line 200
    tmp___7 = sprintf_alloc((char *)"ds[%s].cdef", (rrd.ds_def + i)->ds_nam);
#line 200
    cd = rrd_info_push(cd, tmp___7, (rrd_info_type_t )2, info);
#line 204
    free((void *)buffer);
    }
#line 206
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 208
    info.u_cnt = (rrd.ds_def + i)->par[0].u_cnt;
#line 209
    tmp___8 = sprintf_alloc((char *)"ds[%s].minimal_heartbeat", (rrd.ds_def + i)->ds_nam);
#line 209
    cd = rrd_info_push(cd, tmp___8, (rrd_info_type_t )1, info);
#line 214
    info.u_val = (rrd.ds_def + i)->par[1].u_val;
#line 215
    tmp___9 = sprintf_alloc((char *)"ds[%s].min", (rrd.ds_def + i)->ds_nam);
#line 215
    cd = rrd_info_push(cd, tmp___9, (rrd_info_type_t )0, info);
#line 220
    info.u_val = (rrd.ds_def + i)->par[2].u_val;
#line 221
    tmp___10 = sprintf_alloc((char *)"ds[%s].max", (rrd.ds_def + i)->ds_nam);
#line 221
    cd = rrd_info_push(cd, tmp___10, (rrd_info_type_t )0, info);
    }
#line 225
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 228
    info.u_str = (rrd.pdp_prep + i)->last_ds;
#line 229
    tmp___11 = sprintf_alloc((char *)"ds[%s].last_ds", (rrd.ds_def + i)->ds_nam);
#line 229
    cd = rrd_info_push(cd, tmp___11, (rrd_info_type_t )2, info);
#line 234
    info.u_val = (rrd.pdp_prep + i)->scratch[1].u_val;
#line 235
    tmp___12 = sprintf_alloc((char *)"ds[%s].value", (rrd.ds_def + i)->ds_nam);
#line 235
    cd = rrd_info_push(cd, tmp___12, (rrd_info_type_t )0, info);
#line 240
    info.u_cnt = (rrd.pdp_prep + i)->scratch[0].u_cnt;
#line 241
    tmp___13 = sprintf_alloc((char *)"ds[%s].unknown_sec", (rrd.ds_def + i)->ds_nam);
#line 241
    cd = rrd_info_push(cd, tmp___13, (rrd_info_type_t )1, info);
#line 179
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  i = 0U;
  {
#line 247
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 247
    if (! ((unsigned long )i < (rrd.stat_head)->rra_cnt)) {
#line 247
      goto while_break___0;
    }
    {
#line 248
    info.u_str = (rrd.rra_def + i)->cf_nam;
#line 249
    tmp___14 = sprintf_alloc((char *)"rra[%d].cf", i);
#line 249
    cd = rrd_info_push(cd, tmp___14, (rrd_info_type_t )2, info);
#line 251
    current_cf = cf_conv((char const   *)((rrd.rra_def + i)->cf_nam));
#line 253
    info.u_cnt = (rrd.rra_def + i)->row_cnt;
#line 254
    tmp___15 = sprintf_alloc((char *)"rra[%d].rows", i);
#line 254
    cd = rrd_info_push(cd, tmp___15, (rrd_info_type_t )1, info);
#line 257
    info.u_cnt = (rrd.rra_ptr + i)->cur_row;
#line 258
    tmp___16 = sprintf_alloc((char *)"rra[%d].cur_row", i);
#line 258
    cd = rrd_info_push(cd, tmp___16, (rrd_info_type_t )1, info);
#line 261
    info.u_cnt = (rrd.rra_def + i)->pdp_cnt;
#line 262
    tmp___17 = sprintf_alloc((char *)"rra[%d].pdp_per_row", i);
#line 262
    cd = rrd_info_push(cd, tmp___17, (rrd_info_type_t )1, info);
    }
    {
#line 267
    if ((unsigned int )current_cf == 9U) {
#line 267
      goto case_9;
    }
#line 267
    if ((unsigned int )current_cf == 4U) {
#line 267
      goto case_9;
    }
#line 276
    if ((unsigned int )current_cf == 7U) {
#line 276
      goto case_7;
    }
#line 276
    if ((unsigned int )current_cf == 5U) {
#line 276
      goto case_7;
    }
#line 288
    if ((unsigned int )current_cf == 8U) {
#line 288
      goto case_8;
    }
#line 303
    if ((unsigned int )current_cf == 6U) {
#line 303
      goto case_6;
    }
#line 305
    goto switch_default___0;
    case_9: /* CIL Label */ 
    case_4___0: /* CIL Label */ 
    {
#line 268
    info.u_val = (rrd.rra_def + i)->par[1].u_val;
#line 269
    tmp___18 = sprintf_alloc((char *)"rra[%d].alpha", i);
#line 269
    cd = rrd_info_push(cd, tmp___18, (rrd_info_type_t )0, info);
#line 271
    info.u_val = (rrd.rra_def + i)->par[2].u_val;
#line 272
    tmp___19 = sprintf_alloc((char *)"rra[%d].beta", i);
#line 272
    cd = rrd_info_push(cd, tmp___19, (rrd_info_type_t )0, info);
    }
#line 274
    goto switch_break___0;
    case_7: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 277
    info.u_val = (rrd.rra_def + i)->par[1].u_val;
#line 278
    tmp___20 = sprintf_alloc((char *)"rra[%d].gamma", i);
#line 278
    cd = rrd_info_push(cd, tmp___20, (rrd_info_type_t )0, info);
#line 280
    tmp___22 = atoi((char const   *)((rrd.stat_head)->version));
    }
#line 280
    if (tmp___22 >= 4) {
      {
#line 281
      info.u_val = (rrd.rra_def + i)->par[2].u_val;
#line 283
      tmp___21 = sprintf_alloc((char *)"rra[%d].smoothing_window", i);
#line 283
      cd = rrd_info_push(cd, tmp___21, (rrd_info_type_t )0, info);
      }
    }
#line 287
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 289
    info.u_val = (rrd.rra_def + i)->par[1].u_val;
#line 290
    tmp___23 = sprintf_alloc((char *)"rra[%d].delta_pos", i);
#line 290
    cd = rrd_info_push(cd, tmp___23, (rrd_info_type_t )0, info);
#line 292
    info.u_val = (rrd.rra_def + i)->par[2].u_val;
#line 293
    tmp___24 = sprintf_alloc((char *)"rra[%d].delta_neg", i);
#line 293
    cd = rrd_info_push(cd, tmp___24, (rrd_info_type_t )0, info);
#line 295
    info.u_cnt = (rrd.rra_def + i)->par[5].u_cnt;
#line 296
    tmp___25 = sprintf_alloc((char *)"rra[%d].failure_threshold", i);
#line 296
    cd = rrd_info_push(cd, tmp___25, (rrd_info_type_t )1, info);
#line 299
    info.u_cnt = (rrd.rra_def + i)->par[4].u_cnt;
#line 300
    tmp___26 = sprintf_alloc((char *)"rra[%d].window_length", i);
#line 300
    cd = rrd_info_push(cd, tmp___26, (rrd_info_type_t )1, info);
    }
#line 302
    goto switch_break___0;
    case_6: /* CIL Label */ 
#line 304
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 306
    info.u_val = (rrd.rra_def + i)->par[0].u_val;
#line 307
    tmp___27 = sprintf_alloc((char *)"rra[%d].xff", i);
#line 307
    cd = rrd_info_push(cd, tmp___27, (rrd_info_type_t )0, info);
    }
#line 309
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 312
    ii = 0U;
    {
#line 312
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 312
      if (! ((unsigned long )ii < (rrd.stat_head)->ds_cnt)) {
#line 312
        goto while_break___1;
      }
      {
#line 315
      if ((unsigned int )current_cf == 9U) {
#line 315
        goto case_9___0;
      }
#line 315
      if ((unsigned int )current_cf == 4U) {
#line 315
        goto case_9___0;
      }
#line 337
      if ((unsigned int )current_cf == 5U) {
#line 337
        goto case_5___0;
      }
#line 346
      if ((unsigned int )current_cf == 7U) {
#line 346
        goto case_7___0;
      }
#line 355
      if ((unsigned int )current_cf == 6U) {
#line 355
        goto case_6___0;
      }
#line 357
      if ((unsigned int )current_cf == 8U) {
#line 357
        goto case_8___0;
      }
#line 376
      goto switch_default___1;
      case_9___0: /* CIL Label */ 
      case_4___1: /* CIL Label */ 
      {
#line 316
      info.u_val = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[2].u_val;
#line 319
      tmp___28 = sprintf_alloc((char *)"rra[%d].cdp_prep[%d].intercept", i, ii);
#line 319
      cd = rrd_info_push(cd, tmp___28, (rrd_info_type_t )0, info);
#line 323
      info.u_val = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[4].u_val;
#line 326
      tmp___29 = sprintf_alloc((char *)"rra[%d].cdp_prep[%d].slope", i, ii);
#line 326
      cd = rrd_info_push(cd, tmp___29, (rrd_info_type_t )0, info);
#line 329
      info.u_cnt = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[6].u_cnt;
#line 332
      tmp___30 = sprintf_alloc((char *)"rra[%d].cdp_prep[%d].NaN_count", i, ii);
#line 332
      cd = rrd_info_push(cd, tmp___30, (rrd_info_type_t )1, info);
      }
#line 336
      goto switch_break___1;
      case_5___0: /* CIL Label */ 
      {
#line 338
      info.u_val = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[2].u_val;
#line 341
      tmp___31 = sprintf_alloc((char *)"rra[%d].cdp_prep[%d].seasonal", i, ii);
#line 341
      cd = rrd_info_push(cd, tmp___31, (rrd_info_type_t )0, info);
      }
#line 345
      goto switch_break___1;
      case_7___0: /* CIL Label */ 
      {
#line 347
      info.u_val = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[2].u_val;
#line 350
      tmp___32 = sprintf_alloc((char *)"rra[%d].cdp_prep[%d].deviation", i, ii);
#line 350
      cd = rrd_info_push(cd, tmp___32, (rrd_info_type_t )0, info);
      }
#line 354
      goto switch_break___1;
      case_6___0: /* CIL Label */ 
#line 356
      goto switch_break___1;
      case_8___0: /* CIL Label */ 
#line 363
      violations_array = (char *)((rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch);
#line 366
      j = (unsigned short)0;
      {
#line 366
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 366
        if (! ((unsigned long )j < (rrd.rra_def + i)->par[4].u_cnt)) {
#line 366
          goto while_break___2;
        }
#line 367
        if ((int )*(violations_array + j) == 1) {
#line 367
          history[j] = (char )'1';
        } else {
#line 367
          history[j] = (char )'0';
        }
#line 366
        j = (unsigned short )((int )j + 1);
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 368
      history[j] = (char )'\000';
#line 369
      info.u_str = history;
#line 370
      tmp___33 = sprintf_alloc((char *)"rra[%d].cdp_prep[%d].history", i, ii);
#line 370
      cd = rrd_info_push(cd, tmp___33, (rrd_info_type_t )2, info);
      }
#line 375
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
      {
#line 377
      info.u_val = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[0].u_val;
#line 380
      tmp___34 = sprintf_alloc((char *)"rra[%d].cdp_prep[%d].value", i, ii);
#line 380
      cd = rrd_info_push(cd, tmp___34, (rrd_info_type_t )0, info);
#line 383
      info.u_cnt = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[1].u_cnt;
#line 386
      tmp___35 = sprintf_alloc((char *)"rra[%d].cdp_prep[%d].unknown_datapoints",
                               i, ii);
#line 386
      cd = rrd_info_push(cd, tmp___35, (rrd_info_type_t )1, info);
      }
#line 390
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 312
      ii ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 247
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 395
  rrd_close(rrd_file);
  }
  err_free: 
  {
#line 397
  rrd_free(& rrd);
  }
#line 398
  return (data);
}
}
#line 402 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_info.c"
void rrd_info_print(rrd_info_t *data ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! data) {
#line 405
      goto while_break;
    }
    {
#line 406
    printf((char const   */* __restrict  */)"%s = ", data->key);
    }
    {
#line 409
    if ((unsigned int )data->type == 0U) {
#line 409
      goto case_0;
    }
#line 415
    if ((unsigned int )data->type == 1U) {
#line 415
      goto case_1;
    }
#line 418
    if ((unsigned int )data->type == 3U) {
#line 418
      goto case_3;
    }
#line 421
    if ((unsigned int )data->type == 2U) {
#line 421
      goto case_2;
    }
#line 424
    if ((unsigned int )data->type == 4U) {
#line 424
      goto case_4;
    }
#line 408
    goto switch_break;
    case_0: /* CIL Label */ 
#line 410
    if (sizeof(data->value.u_val) == sizeof(float )) {
      {
#line 410
      tmp = __isnanf((float )data->value.u_val);
#line 410
      tmp___3 = tmp;
      }
    } else {
#line 410
      if (sizeof(data->value.u_val) == sizeof(double )) {
        {
#line 410
        tmp___0 = __isnan(data->value.u_val);
#line 410
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 410
        tmp___1 = __isnanl((long double )data->value.u_val);
#line 410
        tmp___2 = tmp___1;
        }
      }
#line 410
      tmp___3 = tmp___2;
    }
#line 410
    if (tmp___3) {
      {
#line 411
      printf((char const   */* __restrict  */)"NaN\n");
      }
    } else {
      {
#line 413
      printf((char const   */* __restrict  */)"%0.10e\n", data->value.u_val);
      }
    }
#line 414
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 416
    printf((char const   */* __restrict  */)"%lu\n", data->value.u_cnt);
    }
#line 417
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 419
    printf((char const   */* __restrict  */)"%d\n", data->value.u_int);
    }
#line 420
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 422
    printf((char const   */* __restrict  */)"\"%s\"\n", data->value.u_str);
    }
#line 423
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 425
    printf((char const   */* __restrict  */)"BLOB_SIZE:%lu\n", data->value.u_blo.size);
#line 426
    fwrite((void const   */* __restrict  */)data->value.u_blo.ptr, data->value.u_blo.size,
           (size_t )1, (FILE */* __restrict  */)stdout);
    }
#line 427
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 429
    data = data->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  return;
}
}
#line 433 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_info.c"
void rrd_info_free(rrd_info_t *data ) 
{ 
  rrd_info_t *save ;

  {
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (! data) {
#line 438
      goto while_break;
    }
#line 439
    save = data;
#line 440
    if (data->key) {
#line 441
      if ((unsigned int )data->type == 2U) {
        {
#line 442
        free((void *)data->value.u_str);
        }
      }
#line 444
      if ((unsigned int )data->type == 4U) {
        {
#line 445
        free((void *)data->value.u_blo.ptr);
        }
      }
      {
#line 447
      free((void *)data->key);
      }
    }
    {
#line 449
    data = data->next;
#line 450
    free((void *)save);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  return;
}
}
#line 5 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_update.h"
int update_hwpredict(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx ,
                     unsigned long ds_idx , unsigned short CDP_scratch_idx , hw_functions_t *functions ) ;
#line 13
int update_seasonal(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx , unsigned long ds_idx ,
                    unsigned short CDP_scratch_idx , rrd_value_t *seasonal_coef ,
                    hw_functions_t *functions ) ;
#line 22
int update_devpredict(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx ,
                      unsigned long ds_idx , unsigned short CDP_scratch_idx ) ;
#line 29
int update_devseasonal(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx ,
                       unsigned long ds_idx , unsigned short CDP_scratch_idx , rrd_value_t *seasonal_dev ,
                       hw_functions_t *functions ) ;
#line 38
int update_failures(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx , unsigned long ds_idx ,
                    unsigned short CDP_scratch_idx , hw_functions_t *functions ) ;
#line 10 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_update.c"
static void init_slope_intercept(unival *coefs , unsigned short CDP_scratch_idx ) 
{ 


  {
#line 17
  (coefs + 2)->u_val = (coefs + CDP_scratch_idx)->u_val;
#line 18
  (coefs + 3)->u_val = (coefs + CDP_scratch_idx)->u_val;
#line 20
  (coefs + 4)->u_val = 0.0;
#line 21
  (coefs + 5)->u_val = 0.0;
#line 23
  (coefs + 6)->u_cnt = 1UL;
#line 24
  (coefs + 7)->u_cnt = 1UL;
#line 25
  return;
}
}
#line 27 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_update.c"
static int hw_is_violation(rrd_value_t observed , rrd_value_t prediction , rrd_value_t deviation ,
                           rrd_value_t delta_pos , rrd_value_t delta_neg ) 
{ 
  int tmp ;

  {
#line 34
  if (observed > prediction + delta_pos * deviation) {
#line 34
    tmp = 1;
  } else
#line 34
  if (observed < prediction - delta_neg * deviation) {
#line 34
    tmp = 1;
  } else {
#line 34
    tmp = 0;
  }
#line 34
  return (tmp);
}
}
#line 38 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_update.c"
int update_hwpredict(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx ,
                     unsigned long ds_idx , unsigned short CDP_scratch_idx , hw_functions_t *functions ) 
{ 
  rrd_value_t prediction ;
  unsigned long dependent_rra_idx ;
  unsigned long seasonal_cdp_idx ;
  unival *coefs ;
  rra_def_t *current_rra ;
  rrd_value_t seasonal_coef ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 48
  coefs = (rrd->cdp_prep + cdp_idx)->scratch;
#line 49
  current_rra = rrd->rra_def + rra_idx;
#line 53
  (coefs + 3)->u_val = (coefs + 2)->u_val;
#line 54
  (coefs + 5)->u_val = (coefs + 4)->u_val;
#line 55
  (coefs + 7)->u_cnt = (coefs + 6)->u_cnt;
#line 58
  dependent_rra_idx = current_rra->par[3].u_cnt;
#line 59
  seasonal_cdp_idx = dependent_rra_idx * (rrd->stat_head)->ds_cnt + ds_idx;
#line 61
  if (dependent_rra_idx < rra_idx) {
#line 61
    seasonal_coef = (rrd->cdp_prep + seasonal_cdp_idx)->scratch[3].u_val;
  } else {
#line 61
    seasonal_coef = (rrd->cdp_prep + seasonal_cdp_idx)->scratch[2].u_val;
  }
#line 66
  if (sizeof((coefs + 2)->u_val) == sizeof(float )) {
    {
#line 66
    tmp___14 = __isnanf((float )(coefs + 2)->u_val);
#line 66
    tmp___18 = tmp___14;
    }
  } else {
#line 66
    if (sizeof((coefs + 2)->u_val) == sizeof(double )) {
      {
#line 66
      tmp___15 = __isnan((coefs + 2)->u_val);
#line 66
      tmp___17 = tmp___15;
      }
    } else {
      {
#line 66
      tmp___16 = __isnanl((long double )(coefs + 2)->u_val);
#line 66
      tmp___17 = tmp___16;
      }
    }
#line 66
    tmp___18 = tmp___17;
  }
#line 66
  if (tmp___18) {
#line 66
    goto _L;
  } else {
#line 66
    if (sizeof((coefs + 4)->u_val) == sizeof(float )) {
      {
#line 66
      tmp___19 = __isnanf((float )(coefs + 4)->u_val);
#line 66
      tmp___23 = tmp___19;
      }
    } else {
#line 66
      if (sizeof((coefs + 4)->u_val) == sizeof(double )) {
        {
#line 66
        tmp___20 = __isnan((coefs + 4)->u_val);
#line 66
        tmp___22 = tmp___20;
        }
      } else {
        {
#line 66
        tmp___21 = __isnanl((long double )(coefs + 4)->u_val);
#line 66
        tmp___22 = tmp___21;
        }
      }
#line 66
      tmp___23 = tmp___22;
    }
#line 66
    if (tmp___23) {
#line 66
      goto _L;
    } else {
#line 66
      if (sizeof(seasonal_coef) == sizeof(float )) {
        {
#line 66
        tmp___24 = __isnanf((float )seasonal_coef);
#line 66
        tmp___28 = tmp___24;
        }
      } else {
#line 66
        if (sizeof(seasonal_coef) == sizeof(double )) {
          {
#line 66
          tmp___25 = __isnan(seasonal_coef);
#line 66
          tmp___27 = tmp___25;
          }
        } else {
          {
#line 66
          tmp___26 = __isnanl((long double )seasonal_coef);
#line 66
          tmp___27 = tmp___26;
          }
        }
#line 66
        tmp___28 = tmp___27;
      }
#line 66
      if (tmp___28) {
        _L: /* CIL Label */ 
        {
#line 69
        prediction = rrd_set_to_DNAN();
        }
#line 72
        if (sizeof((coefs + 2)->u_val) == sizeof(float )) {
          {
#line 72
          tmp = __isnanf((float )(coefs + 2)->u_val);
#line 72
          tmp___3 = tmp;
          }
        } else {
#line 72
          if (sizeof((coefs + 2)->u_val) == sizeof(double )) {
            {
#line 72
            tmp___0 = __isnan((coefs + 2)->u_val);
#line 72
            tmp___2 = tmp___0;
            }
          } else {
            {
#line 72
            tmp___1 = __isnanl((long double )(coefs + 2)->u_val);
#line 72
            tmp___2 = tmp___1;
            }
          }
#line 72
          tmp___3 = tmp___2;
        }
#line 72
        if (tmp___3) {
#line 72
          if (sizeof((coefs + CDP_scratch_idx)->u_val) == sizeof(float )) {
            {
#line 72
            tmp___4 = __isnanf((float )(coefs + CDP_scratch_idx)->u_val);
#line 72
            tmp___8 = tmp___4;
            }
          } else {
#line 72
            if (sizeof((coefs + CDP_scratch_idx)->u_val) == sizeof(double )) {
              {
#line 72
              tmp___5 = __isnan((coefs + CDP_scratch_idx)->u_val);
#line 72
              tmp___7 = tmp___5;
              }
            } else {
              {
#line 72
              tmp___6 = __isnanl((long double )(coefs + CDP_scratch_idx)->u_val);
#line 72
              tmp___7 = tmp___6;
              }
            }
#line 72
            tmp___8 = tmp___7;
          }
#line 72
          if (! tmp___8) {
            {
#line 74
            init_slope_intercept(coefs, CDP_scratch_idx);
            }
          }
        }
      } else {
        {
#line 78
        prediction = (*(functions->predict))((coefs + 2)->u_val, (coefs + 4)->u_val,
                                             (int )(coefs + 6)->u_cnt, seasonal_coef);
        }
#line 88
        if (sizeof((coefs + CDP_scratch_idx)->u_val) == sizeof(float )) {
          {
#line 88
          tmp___9 = __isnanf((float )(coefs + CDP_scratch_idx)->u_val);
#line 88
          tmp___13 = tmp___9;
          }
        } else {
#line 88
          if (sizeof((coefs + CDP_scratch_idx)->u_val) == sizeof(double )) {
            {
#line 88
            tmp___10 = __isnan((coefs + CDP_scratch_idx)->u_val);
#line 88
            tmp___12 = tmp___10;
            }
          } else {
            {
#line 88
            tmp___11 = __isnanl((long double )(coefs + CDP_scratch_idx)->u_val);
#line 88
            tmp___12 = tmp___11;
            }
          }
#line 88
          tmp___13 = tmp___12;
        }
#line 88
        if (tmp___13) {
#line 91
          ((coefs + 6)->u_cnt) ++;
        } else {
          {
#line 94
          (coefs + 2)->u_val = (*(functions->intercept))(current_rra->par[1].u_val,
                                                         (coefs + CDP_scratch_idx)->u_val,
                                                         seasonal_coef, coefs);
#line 100
          (coefs + 4)->u_val = (*(functions->slope))(current_rra->par[2].u_val, coefs);
#line 104
          (coefs + 6)->u_cnt = 1UL;
          }
        }
      }
    }
  }
#line 113
  (coefs + CDP_scratch_idx)->u_val = prediction;
#line 114
  return (0);
}
}
#line 117 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_update.c"
int update_seasonal(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx , unsigned long ds_idx ,
                    unsigned short CDP_scratch_idx , rrd_value_t *seasonal_coef ,
                    hw_functions_t *functions ) 
{ 
  rrd_value_t intercept ;
  rrd_value_t seasonal ;
  rra_def_t *current_rra ;
  rra_def_t *hw_rra ;
  unsigned long hw_cdp_idx ;
  unival *coefs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
#line 128
  current_rra = rrd->rra_def + rra_idx;
#line 129
  hw_rra = rrd->rra_def + current_rra->par[3].u_cnt;
#line 133
  hw_cdp_idx = current_rra->par[3].u_cnt * (rrd->stat_head)->ds_cnt + ds_idx;
#line 135
  coefs = (rrd->cdp_prep + hw_cdp_idx)->scratch;
#line 138
  seasonal = (rrd->cdp_prep + cdp_idx)->scratch[2].u_val;
#line 139
  (rrd->cdp_prep + cdp_idx)->scratch[3].u_val = seasonal;
#line 140
  (rrd->cdp_prep + cdp_idx)->scratch[2].u_val = *(seasonal_coef + ds_idx);
#line 143
  if (sizeof((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val) == sizeof(float )) {
    {
#line 143
    tmp = __isnanf((float )(rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
#line 143
    tmp___3 = tmp;
    }
  } else {
#line 143
    if (sizeof((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val) == sizeof(double )) {
      {
#line 143
      tmp___0 = __isnan((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
#line 143
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 143
      tmp___1 = __isnanl((long double )(rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
#line 143
      tmp___2 = tmp___1;
      }
    }
#line 143
    tmp___3 = tmp___2;
  }
#line 143
  if (tmp___3) {
#line 146
    (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = seasonal;
#line 147
    return (0);
  }
#line 151
  if (current_rra->par[3].u_cnt < rra_idx) {
#line 154
    if (sizeof((coefs + 3)->u_val) == sizeof(float )) {
      {
#line 154
      tmp___9 = __isnanf((float )(coefs + 3)->u_val);
#line 154
      tmp___13 = tmp___9;
      }
    } else {
#line 154
      if (sizeof((coefs + 3)->u_val) == sizeof(double )) {
        {
#line 154
        tmp___10 = __isnan((coefs + 3)->u_val);
#line 154
        tmp___12 = tmp___10;
        }
      } else {
        {
#line 154
        tmp___11 = __isnanl((long double )(coefs + 3)->u_val);
#line 154
        tmp___12 = tmp___11;
        }
      }
#line 154
      tmp___13 = tmp___12;
    }
#line 154
    if (tmp___13) {
      {
#line 157
      (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = rrd_set_to_DNAN();
      }
    } else {
#line 154
      if (sizeof((coefs + 5)->u_val) == sizeof(float )) {
        {
#line 154
        tmp___14 = __isnanf((float )(coefs + 5)->u_val);
#line 154
        tmp___18 = tmp___14;
        }
      } else {
#line 154
        if (sizeof((coefs + 5)->u_val) == sizeof(double )) {
          {
#line 154
          tmp___15 = __isnan((coefs + 5)->u_val);
#line 154
          tmp___17 = tmp___15;
          }
        } else {
          {
#line 154
          tmp___16 = __isnanl((long double )(coefs + 5)->u_val);
#line 154
          tmp___17 = tmp___16;
          }
        }
#line 154
        tmp___18 = tmp___17;
      }
#line 154
      if (tmp___18) {
        {
#line 157
        (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = rrd_set_to_DNAN();
        }
      } else {
#line 158
        if (sizeof(seasonal) == sizeof(float )) {
          {
#line 158
          tmp___4 = __isnanf((float )seasonal);
#line 158
          tmp___8 = tmp___4;
          }
        } else {
#line 158
          if (sizeof(seasonal) == sizeof(double )) {
            {
#line 158
            tmp___5 = __isnan(seasonal);
#line 158
            tmp___7 = tmp___5;
            }
          } else {
            {
#line 158
            tmp___6 = __isnanl((long double )seasonal);
#line 158
            tmp___7 = tmp___6;
            }
          }
#line 158
          tmp___8 = tmp___7;
        }
#line 158
        if (tmp___8) {
          {
#line 164
          (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = (*(functions->init_seasonality))((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val,
                                                                                                       (coefs + 3)->u_val);
          }
        } else {
          {
#line 170
          intercept = (coefs + 2)->u_val;
#line 172
          (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = (*(functions->seasonality))(current_rra->par[1].u_val,
                                                                                                  (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val,
                                                                                                  intercept,
                                                                                                  seasonal);
          }
        }
      }
    }
  } else {
#line 191
    if (sizeof((coefs + 2)->u_val) == sizeof(float )) {
      {
#line 191
      tmp___24 = __isnanf((float )(coefs + 2)->u_val);
#line 191
      tmp___28 = tmp___24;
      }
    } else {
#line 191
      if (sizeof((coefs + 2)->u_val) == sizeof(double )) {
        {
#line 191
        tmp___25 = __isnan((coefs + 2)->u_val);
#line 191
        tmp___27 = tmp___25;
        }
      } else {
        {
#line 191
        tmp___26 = __isnanl((long double )(coefs + 2)->u_val);
#line 191
        tmp___27 = tmp___26;
        }
      }
#line 191
      tmp___28 = tmp___27;
    }
#line 191
    if (tmp___28) {
#line 195
      (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = functions->identity;
    } else {
#line 191
      if (sizeof((coefs + 4)->u_val) == sizeof(float )) {
        {
#line 191
        tmp___29 = __isnanf((float )(coefs + 4)->u_val);
#line 191
        tmp___33 = tmp___29;
        }
      } else {
#line 191
        if (sizeof((coefs + 4)->u_val) == sizeof(double )) {
          {
#line 191
          tmp___30 = __isnan((coefs + 4)->u_val);
#line 191
          tmp___32 = tmp___30;
          }
        } else {
          {
#line 191
          tmp___31 = __isnanl((long double )(coefs + 4)->u_val);
#line 191
          tmp___32 = tmp___31;
          }
        }
#line 191
        tmp___33 = tmp___32;
      }
#line 191
      if (tmp___33) {
#line 195
        (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = functions->identity;
      } else {
#line 197
        if (sizeof(seasonal) == sizeof(float )) {
          {
#line 197
          tmp___19 = __isnanf((float )seasonal);
#line 197
          tmp___23 = tmp___19;
          }
        } else {
#line 197
          if (sizeof(seasonal) == sizeof(double )) {
            {
#line 197
            tmp___20 = __isnan(seasonal);
#line 197
            tmp___22 = tmp___20;
            }
          } else {
            {
#line 197
            tmp___21 = __isnanl((long double )seasonal);
#line 197
            tmp___22 = tmp___21;
            }
          }
#line 197
          tmp___23 = tmp___22;
        }
#line 197
        if (tmp___23) {
          {
#line 205
          (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = (*(functions->init_seasonality))((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val,
                                                                                                       (coefs + 2)->u_val);
          }
        } else {
          {
#line 212
          intercept = (*(functions->intercept))(hw_rra->par[1].u_val, (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val,
                                                seasonal, coefs);
#line 217
          (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = (*(functions->seasonality))(current_rra->par[1].u_val,
                                                                                                  (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val,
                                                                                                  intercept,
                                                                                                  seasonal);
          }
        }
      }
    }
  }
#line 229
  return (0);
}
}
#line 232 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_update.c"
int update_devpredict(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx ,
                      unsigned long ds_idx , unsigned short CDP_scratch_idx ) 
{ 
  unsigned long seasonal_cdp_idx ;

  {
#line 242
  seasonal_cdp_idx = (rrd->rra_def + rra_idx)->par[3].u_cnt * (rrd->stat_head)->ds_cnt + ds_idx;
#line 246
  if ((rrd->rra_def + rra_idx)->par[3].u_cnt < rra_idx) {
#line 248
    (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = (rrd->cdp_prep + seasonal_cdp_idx)->scratch[3].u_val;
  } else {
#line 254
    (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = (rrd->cdp_prep + seasonal_cdp_idx)->scratch[2].u_val;
  }
#line 259
  return (0);
}
}
#line 262 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_update.c"
int update_devseasonal(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx ,
                       unsigned long ds_idx , unsigned short CDP_scratch_idx , rrd_value_t *seasonal_dev ,
                       hw_functions_t *functions ) 
{ 
  rrd_value_t prediction ;
  rrd_value_t seasonal_coef ;
  double tmp ;
  rra_def_t *current_rra ;
  unsigned long hw_rra_idx ;
  unsigned long hw_cdp_idx ;
  unsigned long seasonal_cdp_idx ;
  unival *coefs ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;

  {
  {
#line 271
  prediction = (rrd_value_t )0;
#line 271
  tmp = rrd_set_to_DNAN();
#line 271
  seasonal_coef = tmp;
#line 272
  current_rra = rrd->rra_def + rra_idx;
#line 275
  hw_rra_idx = current_rra->par[3].u_cnt;
#line 276
  hw_cdp_idx = hw_rra_idx * (rrd->stat_head)->ds_cnt + ds_idx;
#line 278
  coefs = (rrd->cdp_prep + hw_cdp_idx)->scratch;
#line 280
  (rrd->cdp_prep + cdp_idx)->scratch[3].u_val = (rrd->cdp_prep + cdp_idx)->scratch[2].u_val;
#line 283
  (rrd->cdp_prep + cdp_idx)->scratch[2].u_val = *(seasonal_dev + ds_idx);
#line 289
  seasonal_cdp_idx = (rrd->rra_def + hw_rra_idx)->par[3].u_cnt * (rrd->stat_head)->ds_cnt + ds_idx;
  }
#line 292
  if ((rrd->rra_def + hw_rra_idx)->par[3].u_cnt < rra_idx) {
#line 294
    seasonal_coef = (rrd->cdp_prep + seasonal_cdp_idx)->scratch[3].u_val;
  } else {
#line 299
    seasonal_coef = (rrd->cdp_prep + seasonal_cdp_idx)->scratch[2].u_val;
  }
#line 304
  if (hw_rra_idx < rra_idx) {
#line 306
    if (sizeof((coefs + 3)->u_val) == sizeof(float )) {
      {
#line 306
      tmp___0 = __isnanf((float )(coefs + 3)->u_val);
#line 306
      tmp___4 = tmp___0;
      }
    } else {
#line 306
      if (sizeof((coefs + 3)->u_val) == sizeof(double )) {
        {
#line 306
        tmp___1 = __isnan((coefs + 3)->u_val);
#line 306
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 306
        tmp___2 = __isnanl((long double )(coefs + 3)->u_val);
#line 306
        tmp___3 = tmp___2;
        }
      }
#line 306
      tmp___4 = tmp___3;
    }
#line 306
    if (tmp___4) {
      {
#line 309
      (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = rrd_set_to_DNAN();
      }
#line 310
      return (0);
    } else {
#line 306
      if (sizeof((coefs + 5)->u_val) == sizeof(float )) {
        {
#line 306
        tmp___5 = __isnanf((float )(coefs + 5)->u_val);
#line 306
        tmp___9 = tmp___5;
        }
      } else {
#line 306
        if (sizeof((coefs + 5)->u_val) == sizeof(double )) {
          {
#line 306
          tmp___6 = __isnan((coefs + 5)->u_val);
#line 306
          tmp___8 = tmp___6;
          }
        } else {
          {
#line 306
          tmp___7 = __isnanl((long double )(coefs + 5)->u_val);
#line 306
          tmp___8 = tmp___7;
          }
        }
#line 306
        tmp___9 = tmp___8;
      }
#line 306
      if (tmp___9) {
        {
#line 309
        (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = rrd_set_to_DNAN();
        }
#line 310
        return (0);
      } else {
#line 306
        if (sizeof(seasonal_coef) == sizeof(float )) {
          {
#line 306
          tmp___10 = __isnanf((float )seasonal_coef);
#line 306
          tmp___14 = tmp___10;
          }
        } else {
#line 306
          if (sizeof(seasonal_coef) == sizeof(double )) {
            {
#line 306
            tmp___11 = __isnan(seasonal_coef);
#line 306
            tmp___13 = tmp___11;
            }
          } else {
            {
#line 306
            tmp___12 = __isnanl((long double )seasonal_coef);
#line 306
            tmp___13 = tmp___12;
            }
          }
#line 306
          tmp___14 = tmp___13;
        }
#line 306
        if (tmp___14) {
          {
#line 309
          (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = rrd_set_to_DNAN();
          }
#line 310
          return (0);
        } else {
          {
#line 312
          prediction = (*(functions->predict))((coefs + 3)->u_val, (coefs + 5)->u_val,
                                               (int )(coefs + 7)->u_cnt, seasonal_coef);
          }
        }
      }
    }
  } else {
#line 320
    if (sizeof((coefs + 2)->u_val) == sizeof(float )) {
      {
#line 320
      tmp___15 = __isnanf((float )(coefs + 2)->u_val);
#line 320
      tmp___19 = tmp___15;
      }
    } else {
#line 320
      if (sizeof((coefs + 2)->u_val) == sizeof(double )) {
        {
#line 320
        tmp___16 = __isnan((coefs + 2)->u_val);
#line 320
        tmp___18 = tmp___16;
        }
      } else {
        {
#line 320
        tmp___17 = __isnanl((long double )(coefs + 2)->u_val);
#line 320
        tmp___18 = tmp___17;
        }
      }
#line 320
      tmp___19 = tmp___18;
    }
#line 320
    if (tmp___19) {
      {
#line 323
      (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = rrd_set_to_DNAN();
      }
#line 324
      return (0);
    } else {
#line 320
      if (sizeof((coefs + 4)->u_val) == sizeof(float )) {
        {
#line 320
        tmp___20 = __isnanf((float )(coefs + 4)->u_val);
#line 320
        tmp___24 = tmp___20;
        }
      } else {
#line 320
        if (sizeof((coefs + 4)->u_val) == sizeof(double )) {
          {
#line 320
          tmp___21 = __isnan((coefs + 4)->u_val);
#line 320
          tmp___23 = tmp___21;
          }
        } else {
          {
#line 320
          tmp___22 = __isnanl((long double )(coefs + 4)->u_val);
#line 320
          tmp___23 = tmp___22;
          }
        }
#line 320
        tmp___24 = tmp___23;
      }
#line 320
      if (tmp___24) {
        {
#line 323
        (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = rrd_set_to_DNAN();
        }
#line 324
        return (0);
      } else {
#line 320
        if (sizeof(seasonal_coef) == sizeof(float )) {
          {
#line 320
          tmp___25 = __isnanf((float )seasonal_coef);
#line 320
          tmp___29 = tmp___25;
          }
        } else {
#line 320
          if (sizeof(seasonal_coef) == sizeof(double )) {
            {
#line 320
            tmp___26 = __isnan(seasonal_coef);
#line 320
            tmp___28 = tmp___26;
            }
          } else {
            {
#line 320
            tmp___27 = __isnanl((long double )seasonal_coef);
#line 320
            tmp___28 = tmp___27;
            }
          }
#line 320
          tmp___29 = tmp___28;
        }
#line 320
        if (tmp___29) {
          {
#line 323
          (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = rrd_set_to_DNAN();
          }
#line 324
          return (0);
        } else {
          {
#line 326
          prediction = (*(functions->predict))((coefs + 2)->u_val, (coefs + 4)->u_val,
                                               (int )(coefs + 6)->u_cnt, seasonal_coef);
          }
        }
      }
    }
  }
#line 333
  if (sizeof((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val) == sizeof(float )) {
    {
#line 333
    tmp___35 = __isnanf((float )(rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
#line 333
    tmp___39 = tmp___35;
    }
  } else {
#line 333
    if (sizeof((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val) == sizeof(double )) {
      {
#line 333
      tmp___36 = __isnan((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
#line 333
      tmp___38 = tmp___36;
      }
    } else {
      {
#line 333
      tmp___37 = __isnanl((long double )(rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
#line 333
      tmp___38 = tmp___37;
      }
    }
#line 333
    tmp___39 = tmp___38;
  }
#line 333
  if (tmp___39) {
#line 336
    (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = (rrd->cdp_prep + cdp_idx)->scratch[3].u_val;
  } else {
#line 339
    if (sizeof((rrd->cdp_prep + cdp_idx)->scratch[3].u_val) == sizeof(float )) {
      {
#line 339
      tmp___30 = __isnanf((float )(rrd->cdp_prep + cdp_idx)->scratch[3].u_val);
#line 339
      tmp___34 = tmp___30;
      }
    } else {
#line 339
      if (sizeof((rrd->cdp_prep + cdp_idx)->scratch[3].u_val) == sizeof(double )) {
        {
#line 339
        tmp___31 = __isnan((rrd->cdp_prep + cdp_idx)->scratch[3].u_val);
#line 339
        tmp___33 = tmp___31;
        }
      } else {
        {
#line 339
        tmp___32 = __isnanl((long double )(rrd->cdp_prep + cdp_idx)->scratch[3].u_val);
#line 339
        tmp___33 = tmp___32;
        }
      }
#line 339
      tmp___34 = tmp___33;
    }
#line 339
    if (tmp___34) {
      {
#line 346
      (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = (*(functions->init_seasonal_deviation))(prediction,
                                                                                                          (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
      }
    } else {
      {
#line 353
      (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = (*(functions->seasonal_deviation))((rrd->rra_def + rra_idx)->par[1].u_val,
                                                                                                     prediction,
                                                                                                     (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val,
                                                                                                     (rrd->cdp_prep + cdp_idx)->scratch[3].u_val);
      }
    }
  }
#line 364
  return (0);
}
}
#line 369 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_update.c"
int update_failures(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx , unsigned long ds_idx ,
                    unsigned short CDP_scratch_idx , hw_functions_t *functions ) 
{ 
  rra_def_t *current_rra ;
  unsigned long dev_rra_idx ;
  rra_def_t *dev_rra ;
  unsigned long hw_rra_idx ;
  rra_def_t *hw_rra ;
  unsigned long seasonal_rra_idx ;
  unsigned long temp_cdp_idx ;
  rrd_value_t deviation ;
  double tmp ;
  rrd_value_t seasonal_coef ;
  double tmp___0 ;
  rrd_value_t prediction ;
  double tmp___1 ;
  char violation ;
  unsigned short violation_cnt ;
  unsigned short i ;
  char *violations_array ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 379
  current_rra = rrd->rra_def + rra_idx;
#line 380
  dev_rra_idx = current_rra->par[3].u_cnt;
#line 381
  dev_rra = rrd->rra_def + dev_rra_idx;
#line 382
  hw_rra_idx = dev_rra->par[3].u_cnt;
#line 383
  hw_rra = rrd->rra_def + hw_rra_idx;
#line 384
  seasonal_rra_idx = hw_rra->par[3].u_cnt;
#line 386
  tmp = rrd_set_to_DNAN();
#line 386
  deviation = tmp;
#line 387
  tmp___0 = rrd_set_to_DNAN();
#line 387
  seasonal_coef = tmp___0;
#line 388
  tmp___1 = rrd_set_to_DNAN();
#line 388
  prediction = tmp___1;
#line 389
  violation = (char)0;
#line 390
  violation_cnt = (unsigned short)0;
#line 394
  temp_cdp_idx = dev_rra_idx * (rrd->stat_head)->ds_cnt + ds_idx;
  }
#line 395
  if (rra_idx < seasonal_rra_idx) {
#line 397
    deviation = (rrd->cdp_prep + temp_cdp_idx)->scratch[2].u_val;
  } else {
#line 401
    deviation = (rrd->cdp_prep + temp_cdp_idx)->scratch[3].u_val;
  }
#line 405
  if (sizeof(deviation) == sizeof(float )) {
    {
#line 405
    tmp___8 = __isnanf((float )deviation);
#line 405
    tmp___12 = tmp___8;
    }
  } else {
#line 405
    if (sizeof(deviation) == sizeof(double )) {
      {
#line 405
      tmp___9 = __isnan(deviation);
#line 405
      tmp___11 = tmp___9;
      }
    } else {
      {
#line 405
      tmp___10 = __isnanl((long double )deviation);
#line 405
      tmp___11 = tmp___10;
      }
    }
#line 405
    tmp___12 = tmp___11;
  }
#line 405
  if (! tmp___12) {
#line 407
    temp_cdp_idx = seasonal_rra_idx * (rrd->stat_head)->ds_cnt + ds_idx;
#line 408
    if (rra_idx < seasonal_rra_idx) {
#line 410
      seasonal_coef = (rrd->cdp_prep + temp_cdp_idx)->scratch[2].u_val;
    } else {
#line 414
      seasonal_coef = (rrd->cdp_prep + temp_cdp_idx)->scratch[3].u_val;
    }
#line 421
    temp_cdp_idx = hw_rra_idx * (rrd->stat_head)->ds_cnt + ds_idx;
#line 422
    if (rra_idx < hw_rra_idx) {
      {
#line 424
      prediction = (*(functions->predict))((rrd->cdp_prep + temp_cdp_idx)->scratch[2].u_val,
                                           (rrd->cdp_prep + temp_cdp_idx)->scratch[4].u_val,
                                           (int )(rrd->cdp_prep + temp_cdp_idx)->scratch[6].u_cnt,
                                           seasonal_coef);
      }
    } else {
      {
#line 434
      prediction = (*(functions->predict))((rrd->cdp_prep + temp_cdp_idx)->scratch[3].u_val,
                                           (rrd->cdp_prep + temp_cdp_idx)->scratch[5].u_val,
                                           (int )(rrd->cdp_prep + temp_cdp_idx)->scratch[7].u_cnt,
                                           seasonal_coef);
      }
    }
#line 445
    if (sizeof((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val) == sizeof(float )) {
      {
#line 445
      tmp___3 = __isnanf((float )(rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
#line 445
      tmp___7 = tmp___3;
      }
    } else {
#line 445
      if (sizeof((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val) == sizeof(double )) {
        {
#line 445
        tmp___4 = __isnan((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
#line 445
        tmp___6 = tmp___4;
        }
      } else {
        {
#line 445
        tmp___5 = __isnanl((long double )(rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
#line 445
        tmp___6 = tmp___5;
        }
      }
#line 445
      tmp___7 = tmp___6;
    }
#line 445
    if (tmp___7) {
#line 453
      violation = (char)1;
    } else {
      {
#line 446
      tmp___2 = hw_is_violation((rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val,
                                prediction, deviation, current_rra->par[1].u_val,
                                current_rra->par[2].u_val);
      }
#line 446
      if (tmp___2) {
#line 450
        violation = (char)1;
      }
    }
  }
#line 459
  violation_cnt = (unsigned short )violation;
#line 460
  violations_array = (char *)((void *)((rrd->cdp_prep + cdp_idx)->scratch));
#line 461
  i = (unsigned short )current_rra->par[4].u_cnt;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! ((int )i > 1)) {
#line 461
      goto while_break;
    }
#line 463
    *(violations_array + ((int )i - 1)) = *(violations_array + ((int )i - 2));
#line 464
    violation_cnt = (unsigned short )((int )violation_cnt + (int )*(violations_array + ((int )i - 1)));
#line 461
    i = (unsigned short )((int )i - 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  *(violations_array + 0) = violation;
#line 468
  if ((unsigned long )violation_cnt < current_rra->par[5].u_cnt) {
#line 470
    (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = 0.0;
  } else {
#line 472
    (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = 1.0;
  }
#line 474
  return ((int )(rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val);
}
}
#line 15 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.h"
rrd_value_t hw_additive_calculate_prediction(rrd_value_t intercept , rrd_value_t slope ,
                                             int null_count , rrd_value_t seasonal_coef ) ;
#line 21
rrd_value_t hw_additive_calculate_intercept(rrd_value_t hw_alpha , rrd_value_t observed ,
                                            rrd_value_t seasonal_coef , unival *coefs ) ;
#line 27
rrd_value_t hw_additive_calculate_seasonality(rrd_value_t hw_gamma , rrd_value_t observed ,
                                              rrd_value_t intercept , rrd_value_t seasonal_coef ) ;
#line 33
rrd_value_t hw_additive_init_seasonality(rrd_value_t seasonal_coef , rrd_value_t intercept ) ;
#line 41
rrd_value_t hw_multiplicative_calculate_prediction(rrd_value_t intercept , rrd_value_t slope ,
                                                   int null_count , rrd_value_t seasonal_coef ) ;
#line 47
rrd_value_t hw_multiplicative_calculate_intercept(rrd_value_t hw_alpha , rrd_value_t observed ,
                                                  rrd_value_t seasonal_coef , unival *coefs ) ;
#line 53
rrd_value_t hw_multiplicative_calculate_seasonality(rrd_value_t hw_gamma , rrd_value_t observed ,
                                                    rrd_value_t intercept , rrd_value_t seasonal_coef ) ;
#line 59
rrd_value_t hw_multiplicative_init_seasonality(rrd_value_t seasonal_coef , rrd_value_t intercept ) ;
#line 67
rrd_value_t hw_calculate_slope(rrd_value_t hw_beta , unival *coefs ) ;
#line 71
rrd_value_t hw_calculate_seasonal_deviation(rrd_value_t hw_gamma , rrd_value_t prediction ,
                                            rrd_value_t observed , rrd_value_t last ) ;
#line 77
rrd_value_t hw_init_seasonal_deviation(rrd_value_t prediction , rrd_value_t observed ) ;
#line 21 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_additive_calculate_prediction(rrd_value_t intercept , rrd_value_t slope ,
                                             int null_count , rrd_value_t seasonal_coef ) 
{ 


  {
#line 27
  return ((intercept + slope * (rrd_value_t )null_count) + seasonal_coef);
}
}
#line 30 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_additive_calculate_intercept(rrd_value_t hw_alpha , rrd_value_t observed ,
                                            rrd_value_t seasonal_coef , unival *coefs ) 
{ 


  {
#line 36
  return (hw_alpha * (observed - seasonal_coef) + ((rrd_value_t )1 - hw_alpha) * ((coefs + 2)->u_val + (coefs + 4)->u_val * (rrd_value_t )(coefs + 6)->u_cnt));
}
}
#line 43 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_additive_calculate_seasonality(rrd_value_t hw_gamma , rrd_value_t observed ,
                                              rrd_value_t intercept , rrd_value_t seasonal_coef ) 
{ 


  {
#line 49
  return (hw_gamma * (observed - intercept) + ((rrd_value_t )1 - hw_gamma) * seasonal_coef);
}
}
#line 53 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_additive_init_seasonality(rrd_value_t seasonal_coef , rrd_value_t intercept ) 
{ 


  {
#line 57
  return (seasonal_coef - intercept);
}
}
#line 64 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_multiplicative_calculate_prediction(rrd_value_t intercept , rrd_value_t slope ,
                                                   int null_count , rrd_value_t seasonal_coef ) 
{ 


  {
#line 70
  return ((intercept + slope * (rrd_value_t )null_count) * seasonal_coef);
}
}
#line 73 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_multiplicative_calculate_intercept(rrd_value_t hw_alpha , rrd_value_t observed ,
                                                  rrd_value_t seasonal_coef , unival *coefs ) 
{ 
  double tmp ;

  {
#line 79
  if (seasonal_coef <= (rrd_value_t )0) {
    {
#line 80
    tmp = rrd_set_to_DNAN();
    }
#line 80
    return (tmp);
  }
#line 83
  return (hw_alpha * (observed / seasonal_coef) + ((rrd_value_t )1 - hw_alpha) * ((coefs + 2)->u_val + (coefs + 4)->u_val * (rrd_value_t )(coefs + 6)->u_cnt));
}
}
#line 90 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_multiplicative_calculate_seasonality(rrd_value_t hw_gamma , rrd_value_t observed ,
                                                    rrd_value_t intercept , rrd_value_t seasonal_coef ) 
{ 
  double tmp ;

  {
#line 96
  if (intercept <= (rrd_value_t )0) {
    {
#line 97
    tmp = rrd_set_to_DNAN();
    }
#line 97
    return (tmp);
  }
#line 100
  return (hw_gamma * (observed / intercept) + ((rrd_value_t )1 - hw_gamma) * seasonal_coef);
}
}
#line 104 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_multiplicative_init_seasonality(rrd_value_t seasonal_coef , rrd_value_t intercept ) 
{ 
  double tmp ;

  {
#line 108
  if (intercept <= (rrd_value_t )0) {
    {
#line 109
    tmp = rrd_set_to_DNAN();
    }
#line 109
    return (tmp);
  }
#line 112
  return (seasonal_coef / intercept);
}
}
#line 119 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_calculate_slope(rrd_value_t hw_beta , unival *coefs ) 
{ 


  {
#line 123
  return (hw_beta * ((coefs + 2)->u_val - (coefs + 3)->u_val) + ((rrd_value_t )1 - hw_beta) * (coefs + 4)->u_val);
}
}
#line 128 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_calculate_seasonal_deviation(rrd_value_t hw_gamma , rrd_value_t prediction ,
                                            rrd_value_t observed , rrd_value_t last ) 
{ 
  double tmp ;

  {
  {
#line 134
  tmp = fabs(prediction - observed);
  }
#line 134
  return (hw_gamma * tmp + ((rrd_value_t )1 - hw_gamma) * last);
}
}
#line 138 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw_math.c"
rrd_value_t hw_init_seasonal_deviation(rrd_value_t prediction , rrd_value_t observed ) 
{ 
  double tmp ;

  {
  {
#line 142
  tmp = fabs(prediction - observed);
  }
#line 142
  return (tmp);
}
}
#line 774 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 37 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.h"
void reset_aberrant_coefficients(rrd_t *rrd , rrd_file_t *rrd_file , unsigned long ds_idx ) ;
#line 41
void init_hwpredict_cdp(cdp_prep_t *cdp ) ;
#line 43
void init_seasonal_cdp(cdp_prep_t *cdp ) ;
#line 54
int queue_alloc(FIFOqueue **q , int capacity ) ;
#line 57
void queue_dealloc(FIFOqueue *q ) ;
#line 59
void queue_push(FIFOqueue *q , rrd_value_t value ) ;
#line 62
int queue_isempty(FIFOqueue *q ) ;
#line 64
rrd_value_t queue_pop(FIFOqueue *q ) ;
#line 21 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
static unsigned long MyMod(long val , unsigned long mod ) ;
#line 25 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
int lookup_seasonal(rrd_t *rrd , unsigned long rra_idx , unsigned long rra_start ,
                    rrd_file_t *rrd_file , unsigned long offset , rrd_value_t **seasonal_coef ) 
{ 
  unsigned long pos_tmp ;
  unsigned long row_idx ;
  void *tmp ;
  ssize_t tmp___0 ;
  off_t tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 37
  row_idx = (rrd->rra_ptr + rra_idx)->cur_row + offset;
#line 40
  if (row_idx >= (rrd->rra_def + rra_idx)->row_cnt) {
#line 41
    row_idx %= (rrd->rra_def + rra_idx)->row_cnt;
  }
#line 45
  pos_tmp = rra_start + (row_idx * (rrd->stat_head)->ds_cnt) * sizeof(rrd_value_t );
#line 50
  if ((unsigned long )*seasonal_coef == (unsigned long )((void *)0)) {
    {
#line 51
    tmp = malloc((rrd->stat_head)->ds_cnt * sizeof(rrd_value_t ));
#line 51
    *seasonal_coef = (rrd_value_t *)tmp;
    }
  }
#line 54
  if ((unsigned long )*seasonal_coef == (unsigned long )((void *)0)) {
    {
#line 55
    rrd_set_error((char *)"memory allocation failure: seasonal coef");
    }
#line 56
    return (-1);
  }
  {
#line 59
  tmp___1 = rrd_seek(rrd_file, (off_t )pos_tmp, 0);
  }
#line 59
  if (tmp___1) {
    {
#line 75
    rrd_set_error((char *)"seek operation failed in lookup_seasonal(): %lu\n", pos_tmp);
    }
  } else {
    {
#line 60
    tmp___0 = rrd_read(rrd_file, (void *)*seasonal_coef, sizeof(rrd_value_t ) * (rrd->stat_head)->ds_cnt);
    }
#line 60
    if (tmp___0 == (ssize_t )(sizeof(rrd_value_t ) * (rrd->stat_head)->ds_cnt)) {
#line 69
      return (0);
    } else {
      {
#line 71
      rrd_set_error((char *)"read operation failed in lookup_seasonal(): %lu\n", pos_tmp);
      }
    }
  }
#line 79
  return (-1);
}
}
#line 85 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
void erase_violations(rrd_t *rrd , unsigned long cdp_idx , unsigned long rra_idx ) 
{ 
  unsigned short i ;
  char *violations_array ;
  enum cf_en tmp ;

  {
  {
#line 94
  tmp = cf_conv((char const   *)((rrd->rra_def + rra_idx)->cf_nam));
  }
#line 94
  if ((unsigned int )tmp != 8U) {
#line 99
    return;
  }
#line 111
  violations_array = (char *)((void *)((rrd->cdp_prep + cdp_idx)->scratch));
#line 114
  i = (unsigned short )(rrd->rra_def + rra_idx)->par[4].u_cnt;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int )i > 0)) {
#line 114
      goto while_break;
    }
#line 115
    *(violations_array + ((int )i - 1)) = (char)0;
#line 114
    i = (unsigned short )((int )i - 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 128 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
int apply_smoother(rrd_t *rrd , unsigned long rra_idx , unsigned long rra_start ,
                   rrd_file_t *rrd_file ) 
{ 
  unsigned long i ;
  unsigned long j ;
  unsigned long k ;
  unsigned long totalbytes ;
  rrd_value_t *rrd_values ;
  unsigned long row_length ;
  unsigned long row_count ;
  unsigned long offset ;
  FIFOqueue **buffers ;
  rrd_value_t *working_average ;
  rrd_value_t *baseline ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  off_t tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  rrd_value_t tmp___15 ;
  rrd_value_t (*init_seasonality)(rrd_value_t seasonal_coef , rrd_value_t intercept ) ;
  enum cf_en tmp___16 ;
  off_t tmp___17 ;
  ssize_t tmp___18 ;
  enum cf_en tmp___19 ;
  off_t tmp___20 ;
  ssize_t tmp___21 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
  {
#line 137
  row_length = (rrd->stat_head)->ds_cnt;
#line 138
  row_count = (rrd->rra_def + rra_idx)->row_cnt;
#line 144
  tmp___1 = atoi((char const   *)((rrd->stat_head)->version));
  }
#line 144
  if (tmp___1 >= 4) {
    {
#line 145
    tmp = floor(((rrd->rra_def + rra_idx)->par[2].u_val / (rrd_value_t )2) * (rrd_value_t )row_count);
#line 145
    offset = (unsigned long )tmp;
    }
  } else {
    {
#line 149
    tmp___0 = floor((0.05 / (double )2) * (double )row_count);
#line 149
    offset = (unsigned long )tmp___0;
    }
  }
#line 152
  if (offset == 0UL) {
#line 153
    return (0);
  }
  {
#line 156
  totalbytes = (sizeof(rrd_value_t ) * row_length) * row_count;
#line 157
  tmp___2 = malloc(totalbytes);
#line 157
  rrd_values = (rrd_value_t *)tmp___2;
  }
#line 158
  if ((unsigned long )rrd_values == (unsigned long )((void *)0)) {
    {
#line 159
    rrd_set_error((char *)"apply smoother: memory allocation failure");
    }
#line 160
    return (-1);
  }
  {
#line 164
  tmp___3 = rrd_seek(rrd_file, (off_t )rra_start, 0);
  }
#line 164
  if (tmp___3) {
    {
#line 165
    rrd_set_error((char *)"seek to rra %d failed", rra_start);
#line 166
    free((void *)rrd_values);
    }
#line 167
    return (-1);
  }
#line 172
  i = 0UL;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! (i < row_count)) {
#line 172
      goto while_break;
    }
#line 173
    j = 0UL;
    {
#line 173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 173
      if (! (j < row_length)) {
#line 173
        goto while_break___0;
      }
      {
#line 174
      tmp___6 = rrd_read(rrd_file, (void *)(rrd_values + (i * row_length + j)), sizeof(rrd_value_t ));
      }
#line 174
      if (tmp___6 != (ssize_t )sizeof(rrd_value_t )) {
        {
#line 178
        tmp___4 = __errno_location();
#line 178
        tmp___5 = rrd_strerror(*tmp___4);
#line 178
        rrd_set_error((char *)"reading value failed: %s", tmp___5);
        }
      }
#line 181
      if (sizeof(*(rrd_values + (i * row_length + j))) == sizeof(float )) {
        {
#line 181
        tmp___7 = __isnanf((float )*(rrd_values + (i * row_length + j)));
#line 181
        tmp___11 = tmp___7;
        }
      } else {
#line 181
        if (sizeof(*(rrd_values + (i * row_length + j))) == sizeof(double )) {
          {
#line 181
          tmp___8 = __isnan(*(rrd_values + (i * row_length + j)));
#line 181
          tmp___10 = tmp___8;
          }
        } else {
          {
#line 181
          tmp___9 = __isnanl((long double )*(rrd_values + (i * row_length + j)));
#line 181
          tmp___10 = tmp___9;
          }
        }
#line 181
        tmp___11 = tmp___10;
      }
#line 181
      if (tmp___11) {
        {
#line 188
        free((void *)rrd_values);
        }
#line 189
        return (0);
      }
#line 173
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 172
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  tmp___12 = malloc(sizeof(FIFOqueue *) * row_length);
#line 195
  buffers = (FIFOqueue **)tmp___12;
#line 196
  i = 0UL;
  }
  {
#line 196
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 196
    if (! (i < row_length)) {
#line 196
      goto while_break___1;
    }
    {
#line 197
    queue_alloc(buffers + i, (int )(2UL * offset + 1UL));
#line 196
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 200
  tmp___13 = calloc(row_length, sizeof(rrd_value_t ));
#line 200
  working_average = (rrd_value_t *)tmp___13;
#line 201
  tmp___14 = calloc(row_length, sizeof(rrd_value_t ));
#line 201
  baseline = (rrd_value_t *)tmp___14;
#line 204
  i = 0UL;
  }
  {
#line 204
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 204
    if (! (i < 2UL * offset)) {
#line 204
      goto while_break___2;
    }
    {
#line 205
    k = MyMod((long )(i - offset), row_count);
#line 206
    j = 0UL;
    }
    {
#line 206
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 206
      if (! (j < row_length)) {
#line 206
        goto while_break___3;
      }
      {
#line 207
      queue_push(*(buffers + j), *(rrd_values + (k * row_length + j)));
#line 208
      *(working_average + j) += *(rrd_values + (k * row_length + j));
#line 206
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 204
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 213
  i = offset;
  {
#line 213
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 213
    if (! (i < row_count + offset)) {
#line 213
      goto while_break___4;
    }
#line 214
    j = 0UL;
    {
#line 214
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 214
      if (! (j < row_length)) {
#line 214
        goto while_break___5;
      }
      {
#line 215
      k = MyMod((long )i, row_count);
#line 217
      *(working_average + j) += *(rrd_values + (k * row_length + j));
#line 218
      queue_push(*(buffers + j), *(rrd_values + (k * row_length + j)));
#line 221
      k = MyMod((long )(i - offset), row_count);
#line 224
      *(rrd_values + (k * row_length + j)) = *(working_average + j) / (rrd_value_t )(2UL * offset + 1UL);
#line 226
      *(baseline + j) += *(rrd_values + (k * row_length + j));
#line 229
      tmp___15 = queue_pop(*(buffers + j));
#line 229
      *(working_average + j) -= tmp___15;
#line 214
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 213
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 233
  i = 0UL;
  {
#line 233
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 233
    if (! (i < row_length)) {
#line 233
      goto while_break___6;
    }
    {
#line 234
    queue_dealloc(*(buffers + i));
#line 235
    *(baseline + i) /= (rrd_value_t )row_count;
#line 233
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 237
  free((void *)buffers);
#line 238
  free((void *)working_average);
#line 240
  tmp___19 = cf_conv((char const   *)((rrd->rra_def + rra_idx)->cf_nam));
  }
#line 240
  if ((unsigned int )tmp___19 == 5U) {
    {
#line 246
    tmp___16 = cf_conv((char const   *)((rrd->rra_def + (rrd->rra_def + rra_idx)->par[3].u_cnt)->cf_nam));
    }
    {
#line 247
    if ((unsigned int )tmp___16 == 4U) {
#line 247
      goto case_4;
    }
#line 250
    if ((unsigned int )tmp___16 == 9U) {
#line 250
      goto case_9;
    }
#line 253
    goto switch_default;
    case_4: /* CIL Label */ 
#line 248
    init_seasonality = & hw_additive_init_seasonality;
#line 249
    goto switch_break;
    case_9: /* CIL Label */ 
#line 251
    init_seasonality = & hw_multiplicative_init_seasonality;
#line 252
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 254
    rrd_set_error((char *)"apply smoother: SEASONAL rra doesn\'t have valid dependency: %s",
                  (rrd->rra_def + (rrd->rra_def + rra_idx)->par[3].u_cnt)->cf_nam);
    }
#line 257
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 260
    j = 0UL;
    {
#line 260
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 260
      if (! (j < row_length)) {
#line 260
        goto while_break___7;
      }
#line 261
      i = 0UL;
      {
#line 261
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 261
        if (! (i < row_count)) {
#line 261
          goto while_break___8;
        }
        {
#line 262
        *(rrd_values + (i * row_length + j)) = (*init_seasonality)(*(rrd_values + (i * row_length + j)),
                                                                   *(baseline + j));
#line 261
        i ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 268
      offset = (rrd->rra_def + rra_idx)->par[3].u_cnt * row_length + j;
#line 269
      (rrd->cdp_prep + offset)->scratch[2].u_val += *(baseline + j);
#line 260
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 273
    tmp___17 = rrd_seek(rrd_file, (off_t )((((sizeof(stat_head_t ) + (rrd->stat_head)->ds_cnt * sizeof(ds_def_t )) + (rrd->stat_head)->rra_cnt * sizeof(rra_def_t )) + sizeof(live_head_t )) + (rrd->stat_head)->ds_cnt * sizeof(pdp_prep_t )),
                        0);
    }
#line 273
    if (tmp___17) {
      {
#line 278
      rrd_set_error((char *)"apply_smoother: seek to cdp_prep failed");
#line 279
      free((void *)rrd_values);
      }
#line 280
      return (-1);
    }
    {
#line 282
    tmp___18 = rrd_write(rrd_file, (void const   *)rrd->cdp_prep, (sizeof(cdp_prep_t ) * (rrd->stat_head)->rra_cnt) * (rrd->stat_head)->ds_cnt);
    }
#line 282
    if (tmp___18 != (ssize_t )((sizeof(cdp_prep_t ) * (rrd->stat_head)->rra_cnt) * (rrd->stat_head)->ds_cnt)) {
      {
#line 287
      rrd_set_error((char *)"apply_smoother: cdp_prep write failed");
#line 288
      free((void *)rrd_values);
      }
#line 289
      return (-1);
    }
  }
  {
#line 295
  tmp___20 = rrd_seek(rrd_file, (off_t )rra_start, 0);
  }
#line 295
  if (tmp___20) {
    {
#line 296
    rrd_set_error((char *)"apply_smoother: seek to pos %d failed", rra_start);
#line 297
    free((void *)rrd_values);
    }
#line 298
    return (-1);
  }
  {
#line 301
  tmp___21 = rrd_write(rrd_file, (void const   *)rrd_values, (sizeof(rrd_value_t ) * row_length) * row_count);
  }
#line 301
  if (tmp___21 != (ssize_t )((sizeof(rrd_value_t ) * row_length) * row_count)) {
    {
#line 304
    rrd_set_error((char *)"apply_smoother: write failed to %lu", rra_start);
#line 305
    free((void *)rrd_values);
    }
#line 306
    return (-1);
  }
  {
#line 309
  free((void *)rrd_values);
#line 310
  free((void *)baseline);
  }
#line 311
  return (0);
}
}
#line 316 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
void reset_aberrant_coefficients(rrd_t *rrd , rrd_file_t *rrd_file , unsigned long ds_idx ) 
{ 
  unsigned long cdp_idx ;
  unsigned long rra_idx ;
  unsigned long i ;
  unsigned long cdp_start ;
  unsigned long rra_start ;
  rrd_value_t nan_buffer ;
  double tmp ;
  enum cf_en tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 323
  tmp = rrd_set_to_DNAN();
#line 323
  nan_buffer = tmp;
#line 326
  cdp_start = (((sizeof(stat_head_t ) + (rrd->stat_head)->ds_cnt * sizeof(ds_def_t )) + (rrd->stat_head)->rra_cnt * sizeof(rra_def_t )) + sizeof(live_head_t )) + (rrd->stat_head)->ds_cnt * sizeof(pdp_prep_t );
#line 331
  rra_start = (cdp_start + ((rrd->stat_head)->ds_cnt * (rrd->stat_head)->rra_cnt) * sizeof(cdp_prep_t )) + (rrd->stat_head)->rra_cnt * sizeof(rra_ptr_t );
#line 336
  rra_idx = 0UL;
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (rra_idx < (rrd->stat_head)->rra_cnt)) {
#line 336
      goto while_break;
    }
    {
#line 337
    cdp_idx = rra_idx * (rrd->stat_head)->ds_cnt + ds_idx;
#line 338
    tmp___0 = cf_conv((char const   *)((rrd->rra_def + rra_idx)->cf_nam));
    }
    {
#line 340
    if ((unsigned int )tmp___0 == 9U) {
#line 340
      goto case_9;
    }
#line 340
    if ((unsigned int )tmp___0 == 4U) {
#line 340
      goto case_9;
    }
#line 344
    if ((unsigned int )tmp___0 == 7U) {
#line 344
      goto case_7;
    }
#line 344
    if ((unsigned int )tmp___0 == 5U) {
#line 344
      goto case_7;
    }
#line 367
    if ((unsigned int )tmp___0 == 8U) {
#line 367
      goto case_8;
    }
#line 370
    goto switch_default;
    case_9: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 341
    init_hwpredict_cdp(rrd->cdp_prep + cdp_idx);
    }
#line 342
    goto switch_break;
    case_7: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 348
    (rrd->cdp_prep + cdp_idx)->scratch[2].u_val = rrd_set_to_DNAN();
#line 349
    (rrd->cdp_prep + cdp_idx)->scratch[3].u_val = rrd_set_to_DNAN();
#line 351
    rrd_seek(rrd_file, (off_t )(rra_start + ds_idx * sizeof(rrd_value_t )), 0);
#line 355
    i = 0UL;
    }
    {
#line 355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 355
      if (! (i < (rrd->rra_def + rra_idx)->row_cnt)) {
#line 355
        goto while_break___0;
      }
      {
#line 356
      tmp___1 = rrd_write(rrd_file, (void const   *)(& nan_buffer), sizeof(rrd_value_t ));
      }
#line 356
      if ((unsigned long )tmp___1 != sizeof(rrd_value_t )) {
        {
#line 358
        rrd_set_error((char *)"reset_aberrant_coefficients: write failed data source %lu rra %s",
                      ds_idx, (rrd->rra_def + rra_idx)->cf_nam);
        }
#line 361
        return;
      }
      {
#line 363
      rrd_seek(rrd_file, (off_t )(((rrd->stat_head)->ds_cnt - 1UL) * sizeof(rrd_value_t )),
               1);
#line 355
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 368
    erase_violations(rrd, cdp_idx, rra_idx);
    }
#line 369
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 371
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 374
    rra_start += ((rrd->rra_def + rra_idx)->row_cnt * (rrd->stat_head)->ds_cnt) * sizeof(rrd_value_t );
#line 336
    rra_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 377
  rrd_seek(rrd_file, (off_t )cdp_start, 0);
#line 378
  tmp___2 = rrd_write(rrd_file, (void const   *)rrd->cdp_prep, (sizeof(cdp_prep_t ) * (rrd->stat_head)->rra_cnt) * (rrd->stat_head)->ds_cnt);
  }
#line 378
  if (tmp___2 != (ssize_t )((sizeof(cdp_prep_t ) * (rrd->stat_head)->rra_cnt) * (rrd->stat_head)->ds_cnt)) {
    {
#line 383
    rrd_set_error((char *)"reset_aberrant_coefficients: cdp_prep write failed");
    }
  }
#line 385
  return;
}
}
#line 387 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
void init_hwpredict_cdp(cdp_prep_t *cdp ) 
{ 


  {
  {
#line 390
  cdp->scratch[2].u_val = rrd_set_to_DNAN();
#line 391
  cdp->scratch[3].u_val = rrd_set_to_DNAN();
#line 392
  cdp->scratch[4].u_val = rrd_set_to_DNAN();
#line 393
  cdp->scratch[5].u_val = rrd_set_to_DNAN();
#line 394
  cdp->scratch[6].u_cnt = 1UL;
#line 395
  cdp->scratch[7].u_cnt = 1UL;
  }
#line 396
  return;
}
}
#line 398 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
void init_seasonal_cdp(cdp_prep_t *cdp ) 
{ 


  {
  {
#line 401
  cdp->scratch[2].u_val = rrd_set_to_DNAN();
#line 402
  cdp->scratch[3].u_val = rrd_set_to_DNAN();
#line 403
  cdp->scratch[6].u_cnt = 1UL;
  }
#line 404
  return;
}
}
#line 416 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
static hw_functions_t hw_multiplicative_functions  = 
#line 416
     {& hw_multiplicative_calculate_prediction, & hw_multiplicative_calculate_intercept,
    & hw_calculate_slope, & hw_multiplicative_calculate_seasonality, & hw_multiplicative_init_seasonality,
    & hw_calculate_seasonal_deviation, & hw_init_seasonal_deviation, 1.0};
#line 427 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
static hw_functions_t hw_additive_functions  = 
#line 427
     {& hw_additive_calculate_prediction, & hw_additive_calculate_intercept, & hw_calculate_slope,
    & hw_additive_calculate_seasonality, & hw_additive_init_seasonality, & hw_calculate_seasonal_deviation,
    & hw_init_seasonal_deviation, 0.0};
#line 406 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
int update_aberrant_CF(rrd_t *rrd , rrd_value_t pdp_val , enum cf_en current_cf ,
                       unsigned long cdp_idx , unsigned long rra_idx , unsigned long ds_idx ,
                       unsigned short CDP_scratch_idx , rrd_value_t *seasonal_coef ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  enum cf_en tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  enum cf_en tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  enum cf_en tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 438
  (rrd->cdp_prep + cdp_idx)->scratch[CDP_scratch_idx].u_val = pdp_val;
  {
#line 440
  if ((unsigned int )current_cf == 4U) {
#line 440
    goto case_4;
  }
#line 443
  if ((unsigned int )current_cf == 9U) {
#line 443
    goto case_9;
  }
#line 447
  if ((unsigned int )current_cf == 6U) {
#line 447
    goto case_6;
  }
#line 450
  if ((unsigned int )current_cf == 5U) {
#line 450
    goto case_5;
  }
#line 463
  if ((unsigned int )current_cf == 7U) {
#line 463
    goto case_7;
  }
#line 476
  if ((unsigned int )current_cf == 8U) {
#line 476
    goto case_8;
  }
#line 491
  goto switch_default___2;
  case_4: /* CIL Label */ 
  {
#line 441
  tmp = update_hwpredict(rrd, cdp_idx, rra_idx, ds_idx, CDP_scratch_idx, & hw_additive_functions);
  }
#line 441
  return (tmp);
  case_9: /* CIL Label */ 
  {
#line 444
  tmp___0 = update_hwpredict(rrd, cdp_idx, rra_idx, ds_idx, CDP_scratch_idx, & hw_multiplicative_functions);
  }
#line 444
  return (tmp___0);
  case_6: /* CIL Label */ 
  {
#line 448
  tmp___1 = update_devpredict(rrd, cdp_idx, rra_idx, ds_idx, CDP_scratch_idx);
  }
#line 448
  return (tmp___1);
  case_5: /* CIL Label */ 
  {
#line 451
  tmp___2 = cf_conv((char const   *)((rrd->rra_def + (rrd->rra_def + rra_idx)->par[3].u_cnt)->cf_nam));
  }
  {
#line 452
  if ((unsigned int )tmp___2 == 4U) {
#line 452
    goto case_4___0;
  }
#line 456
  if ((unsigned int )tmp___2 == 9U) {
#line 456
    goto case_9___0;
  }
#line 460
  goto switch_default;
  case_4___0: /* CIL Label */ 
  {
#line 453
  tmp___3 = update_seasonal(rrd, cdp_idx, rra_idx, ds_idx, CDP_scratch_idx, seasonal_coef,
                            & hw_additive_functions);
  }
#line 453
  return (tmp___3);
  case_9___0: /* CIL Label */ 
  {
#line 457
  tmp___4 = update_seasonal(rrd, cdp_idx, rra_idx, ds_idx, CDP_scratch_idx, seasonal_coef,
                            & hw_multiplicative_functions);
  }
#line 457
  return (tmp___4);
  switch_default: /* CIL Label */ 
#line 461
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
  case_7: /* CIL Label */ 
  {
#line 464
  tmp___5 = cf_conv((char const   *)((rrd->rra_def + (rrd->rra_def + rra_idx)->par[3].u_cnt)->cf_nam));
  }
  {
#line 465
  if ((unsigned int )tmp___5 == 4U) {
#line 465
    goto case_4___1;
  }
#line 469
  if ((unsigned int )tmp___5 == 9U) {
#line 469
    goto case_9___1;
  }
#line 473
  goto switch_default___0;
  case_4___1: /* CIL Label */ 
  {
#line 466
  tmp___6 = update_devseasonal(rrd, cdp_idx, rra_idx, ds_idx, CDP_scratch_idx, seasonal_coef,
                               & hw_additive_functions);
  }
#line 466
  return (tmp___6);
  case_9___1: /* CIL Label */ 
  {
#line 470
  tmp___7 = update_devseasonal(rrd, cdp_idx, rra_idx, ds_idx, CDP_scratch_idx, seasonal_coef,
                               & hw_multiplicative_functions);
  }
#line 470
  return (tmp___7);
  switch_default___0: /* CIL Label */ 
#line 474
  return (-1);
  switch_break___1: /* CIL Label */ ;
  }
  case_8: /* CIL Label */ 
  {
#line 477
  tmp___8 = cf_conv((char const   *)((rrd->rra_def + (rrd->rra_def + (rrd->rra_def + rra_idx)->par[3].u_cnt)->par[3].u_cnt)->cf_nam));
  }
  {
#line 480
  if ((unsigned int )tmp___8 == 4U) {
#line 480
    goto case_4___2;
  }
#line 483
  if ((unsigned int )tmp___8 == 9U) {
#line 483
    goto case_9___2;
  }
#line 487
  goto switch_default___1;
  case_4___2: /* CIL Label */ 
  {
#line 481
  tmp___9 = update_failures(rrd, cdp_idx, rra_idx, ds_idx, CDP_scratch_idx, & hw_additive_functions);
  }
#line 481
  return (tmp___9);
  case_9___2: /* CIL Label */ 
  {
#line 484
  tmp___10 = update_failures(rrd, cdp_idx, rra_idx, ds_idx, CDP_scratch_idx, & hw_multiplicative_functions);
  }
#line 484
  return (tmp___10);
  switch_default___1: /* CIL Label */ 
#line 488
  return (-1);
  switch_break___2: /* CIL Label */ ;
  }
  switch_default___2: /* CIL Label */ 
#line 492
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 494
  return (-1);
}
}
#line 497 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
static unsigned long MyMod(long val , unsigned long mod ) 
{ 
  unsigned long new_val ;
  int tmp ;

  {
#line 503
  if (val < 0L) {
    {
#line 504
    tmp = abs((int )val);
#line 504
    new_val = (unsigned long )tmp % mod;
    }
  } else {
#line 506
    new_val = (unsigned long )val % mod;
  }
#line 508
  if (val < 0L) {
#line 509
    return (mod - new_val);
  } else {
#line 511
    return (new_val);
  }
}
}
#line 516 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
int queue_alloc(FIFOqueue **q , int capacity ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 520
  tmp = malloc(sizeof(FIFOqueue ));
#line 520
  *q = (FIFOqueue *)tmp;
  }
#line 521
  if ((unsigned long )*q == (unsigned long )((void *)0)) {
#line 522
    return (-1);
  }
  {
#line 523
  tmp___0 = malloc(sizeof(rrd_value_t ) * (unsigned long )capacity);
#line 523
  (*q)->queue = (rrd_value_t *)tmp___0;
  }
#line 524
  if ((unsigned long )(*q)->queue == (unsigned long )((void *)0)) {
    {
#line 525
    free((void *)*q);
    }
#line 526
    return (-1);
  }
#line 528
  (*q)->capacity = capacity;
#line 529
  (*q)->head = capacity;
#line 530
  (*q)->tail = 0;
#line 531
  return (0);
}
}
#line 534 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
int queue_isempty(FIFOqueue *q ) 
{ 


  {
#line 537
  return (q->head % q->capacity == q->tail);
}
}
#line 540 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
void queue_push(FIFOqueue *q , rrd_value_t value ) 
{ 
  int tmp ;

  {
#line 544
  tmp = q->tail;
#line 544
  (q->tail) ++;
#line 544
  *(q->queue + tmp) = value;
#line 545
  q->tail %= q->capacity;
#line 546
  return;
}
}
#line 548 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
rrd_value_t queue_pop(FIFOqueue *q ) 
{ 
  int tmp ;

  {
#line 551
  q->head %= q->capacity;
#line 552
  tmp = q->head;
#line 552
  (q->head) ++;
#line 552
  return (*(q->queue + tmp));
}
}
#line 555 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.c"
void queue_dealloc(FIFOqueue *q ) 
{ 


  {
  {
#line 558
  free((void *)q->queue);
#line 559
  free((void *)q);
  }
#line 560
  return;
}
}
#line 59 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.c"
enum dst_en dst_conv(char *string ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 62
  tmp = strcmp("COUNTER", (char const   *)string);
  }
#line 62
  if (tmp == 0) {
#line 62
    return ((enum dst_en )0);
  }
  {
#line 63
  tmp___0 = strcmp("ABSOLUTE", (char const   *)string);
  }
#line 63
  if (tmp___0 == 0) {
#line 63
    return ((enum dst_en )1);
  }
  {
#line 64
  tmp___1 = strcmp("GAUGE", (char const   *)string);
  }
#line 64
  if (tmp___1 == 0) {
#line 64
    return ((enum dst_en )2);
  }
  {
#line 65
  tmp___2 = strcmp("DERIVE", (char const   *)string);
  }
#line 65
  if (tmp___2 == 0) {
#line 65
    return ((enum dst_en )3);
  }
  {
#line 66
  tmp___3 = strcmp("COMPUTE", (char const   *)string);
  }
#line 66
  if (tmp___3 == 0) {
#line 66
    return ((enum dst_en )4);
  }
  {
#line 67
  rrd_set_error((char *)"unknown data acquisition function \'%s\'", string);
  }
#line 68
  return ((enum dst_en )-1);
}
}
#line 72 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.c"
enum cf_en cf_conv(char const   *string ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 76
  tmp = strcmp("AVERAGE", string);
  }
#line 76
  if (tmp == 0) {
#line 76
    return ((enum cf_en )0);
  }
  {
#line 77
  tmp___0 = strcmp("MIN", string);
  }
#line 77
  if (tmp___0 == 0) {
#line 77
    return ((enum cf_en )1);
  }
  {
#line 78
  tmp___1 = strcmp("MAX", string);
  }
#line 78
  if (tmp___1 == 0) {
#line 78
    return ((enum cf_en )2);
  }
  {
#line 79
  tmp___2 = strcmp("LAST", string);
  }
#line 79
  if (tmp___2 == 0) {
#line 79
    return ((enum cf_en )3);
  }
  {
#line 80
  tmp___3 = strcmp("HWPREDICT", string);
  }
#line 80
  if (tmp___3 == 0) {
#line 80
    return ((enum cf_en )4);
  }
  {
#line 81
  tmp___4 = strcmp("MHWPREDICT", string);
  }
#line 81
  if (tmp___4 == 0) {
#line 81
    return ((enum cf_en )9);
  }
  {
#line 82
  tmp___5 = strcmp("DEVPREDICT", string);
  }
#line 82
  if (tmp___5 == 0) {
#line 82
    return ((enum cf_en )6);
  }
  {
#line 83
  tmp___6 = strcmp("SEASONAL", string);
  }
#line 83
  if (tmp___6 == 0) {
#line 83
    return ((enum cf_en )5);
  }
  {
#line 84
  tmp___7 = strcmp("DEVSEASONAL", string);
  }
#line 84
  if (tmp___7 == 0) {
#line 84
    return ((enum cf_en )7);
  }
  {
#line 85
  tmp___8 = strcmp("FAILURES", string);
  }
#line 85
  if (tmp___8 == 0) {
#line 85
    return ((enum cf_en )8);
  }
  {
#line 86
  rrd_set_error((char *)"unknown consolidation function \'%s\'", string);
  }
#line 87
  return ((enum cf_en )-1);
}
}
#line 92 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.c"
long ds_match(rrd_t *rrd , char *ds_nam ) 
{ 
  unsigned long i ;
  int tmp ;
  char *__cil_tmp5 ;

  {
#line 98
  i = 0UL;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < (rrd->stat_head)->ds_cnt)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp = strcmp((char const   *)ds_nam, (char const   *)((rrd->ds_def + i)->ds_nam));
    }
#line 99
    if (tmp == 0) {
#line 100
      return ((long )i);
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  rrd_set_error((char *)"unknown data source name \'%s\'", ds_nam);
  }
#line 102
  return (-1L);
}
}
#line 105 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_format.c"
off_t rrd_get_header_size(rrd_t *rrd ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 108
  tmp___1 = atoi((char const   *)((rrd->stat_head)->version));
  }
#line 108
  if (tmp___1 < 3) {
#line 108
    tmp___0 = sizeof(time_t );
  } else {
#line 108
    tmp___0 = sizeof(live_head_t );
  }
#line 108
  return ((off_t )((((((sizeof(stat_head_t ) + sizeof(ds_def_t ) * (rrd->stat_head)->ds_cnt) + sizeof(rra_def_t ) * (rrd->stat_head)->rra_cnt) + tmp___0) + sizeof(pdp_prep_t ) * (rrd->stat_head)->ds_cnt) + (sizeof(cdp_prep_t ) * (rrd->stat_head)->ds_cnt) * (rrd->stat_head)->rra_cnt) + sizeof(rra_ptr_t ) * (rrd->stat_head)->rra_cnt));
}
}
#line 315 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
void rrd_clear_error(void) ;
#line 329
rrd_context_t *rrd_new_context(void) ;
#line 331
void rrd_free_context(rrd_context_t *rrd_ctx ) ;
#line 42 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_error.c"
void rrd_set_error(char *fmt  , ...) 
{ 
  va_list argp ;
  rrd_context_t *tmp ;
  rrd_context_t *tmp___0 ;

  {
  {
#line 48
  rrd_clear_error();
#line 49
  __builtin_va_start(argp, fmt);
#line 51
  tmp___0 = rrd_get_context();
#line 51
  vsnprintf((char */* __restrict  */)(tmp___0->rrd_error), sizeof(tmp->rrd_error),
            (char const   */* __restrict  */)fmt, argp);
#line 55
  __builtin_va_end(argp);
  }
#line 56
  return;
}
}
#line 58 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_error.c"
int rrd_test_error(void) 
{ 
  rrd_context_t *tmp ;

  {
  {
#line 61
  tmp = rrd_get_context();
  }
#line 61
  return ((int )tmp->rrd_error[0] != 0);
}
}
#line 64 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_error.c"
void rrd_clear_error(void) 
{ 
  rrd_context_t *tmp ;

  {
  {
#line 67
  tmp = rrd_get_context();
#line 67
  tmp->rrd_error[0] = (char )'\000';
  }
#line 68
  return;
}
}
#line 70 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_error.c"
char *rrd_get_error(void) 
{ 
  rrd_context_t *tmp ;

  {
  {
#line 73
  tmp = rrd_get_context();
  }
#line 73
  return (tmp->rrd_error);
}
}
#line 121 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_error.c"
rrd_context_t *rrd_new_context(void) 
{ 
  rrd_context_t *rrd_ctx ;
  void *tmp ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 124
  tmp = malloc(sizeof(rrd_context_t ));
#line 124
  rrd_ctx = (rrd_context_t *)tmp;
  }
#line 126
  if (! rrd_ctx) {
#line 127
    return ((rrd_context_t *)((void *)0));
  }
#line 130
  rrd_ctx->rrd_error[0] = (char )'\000';
#line 131
  rrd_ctx->lib_errstr[0] = (char )'\000';
#line 132
  return (rrd_ctx);
}
}
#line 135 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_error.c"
void rrd_free_context(rrd_context_t *rrd_ctx ) 
{ 


  {
#line 138
  if (rrd_ctx) {
    {
#line 139
    free((void *)rrd_ctx);
    }
  }
#line 141
  return;
}
}
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 41 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_diff.c"
double rrd_diff(char *a , char *b ) 
{ 
  char res[31] ;
  char *a1 ;
  char *b1 ;
  char *r1 ;
  char *fix ;
  int c ;
  int x ;
  int m ;
  char a_neg ;
  char b_neg ;
  double result ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  double tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  double tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  double tmp___14 ;
  size_t tmp___15 ;
  unsigned short const   **tmp___16 ;
  double tmp___17 ;
  void *__cil_tmp33 ;

  {
#line 47
  a_neg = (char)0;
#line 47
  b_neg = (char)0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 50
    tmp = __ctype_b_loc();
    }
#line 50
    if ((int const   )*(*tmp + (int )*a) & 2048) {
#line 50
      goto while_break;
    } else
#line 50
    if ((int )*a == 0) {
#line 50
      goto while_break;
    }
#line 51
    if ((int )*a == 45) {
#line 52
      a_neg = (char)1;
    }
#line 53
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  fix = a;
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 56
    tmp___0 = __ctype_b_loc();
    }
#line 56
    if (! ((int const   )*(*tmp___0 + (int )*fix) & 2048)) {
#line 56
      goto while_break___0;
    }
#line 57
    fix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 58
  *fix = (char)0;
  {
#line 59
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 59
    tmp___1 = __ctype_b_loc();
    }
#line 59
    if ((int const   )*(*tmp___1 + (int )*b) & 2048) {
#line 59
      goto while_break___1;
    } else
#line 59
    if ((int )*b == 0) {
#line 59
      goto while_break___1;
    }
#line 60
    if ((int )*b == 45) {
#line 61
      b_neg = (char)1;
    }
#line 62
    b ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 64
  fix = b;
  {
#line 65
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 65
    tmp___2 = __ctype_b_loc();
    }
#line 65
    if (! ((int const   )*(*tmp___2 + (int )*fix) & 2048)) {
#line 65
      goto while_break___2;
    }
#line 66
    fix ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 67
  *fix = (char)0;
#line 68
  tmp___4 = __ctype_b_loc();
  }
#line 68
  if ((int const   )*(*tmp___4 + (int )*a) & 2048) {
    {
#line 68
    tmp___5 = __ctype_b_loc();
    }
#line 68
    if (! ((int const   )*(*tmp___5 + (int )*b) & 2048)) {
      {
#line 69
      tmp___3 = rrd_set_to_DNAN();
      }
#line 69
      return (tmp___3);
    }
  } else {
    {
#line 69
    tmp___3 = rrd_set_to_DNAN();
    }
#line 69
    return (tmp___3);
  }
#line 70
  if ((int )a_neg + (int )b_neg == 1) {
    {
#line 71
    tmp___6 = rrd_set_to_DNAN();
    }
#line 71
    return (tmp___6);
  }
  {
#line 72
  tmp___7 = strlen((char const   *)a);
#line 72
  a1 = a + (tmp___7 - 1UL);
#line 73
  tmp___12 = strlen((char const   *)a);
#line 73
  tmp___13 = strlen((char const   *)b);
  }
#line 73
  if (tmp___12 > tmp___13) {
    {
#line 73
    tmp___10 = strlen((char const   *)a);
#line 73
    m = (int )tmp___10;
    }
  } else {
    {
#line 73
    tmp___11 = strlen((char const   *)b);
#line 73
    m = (int )tmp___11;
    }
  }
#line 74
  if (m > 30) {
    {
#line 75
    tmp___14 = rrd_set_to_DNAN();
    }
#line 75
    return (tmp___14);
  }
#line 77
  r1 = & res[m + 1];
#line 78
  b1 = res;
  {
#line 78
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 78
    if (! ((unsigned long )b1 <= (unsigned long )r1)) {
#line 78
      goto while_break___3;
    }
#line 79
    *b1 = (char )' ';
#line 78
    b1 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 80
  tmp___15 = strlen((char const   *)b);
#line 80
  b1 = b + (tmp___15 - 1UL);
#line 81
  *(r1 + 1) = (char)0;
#line 82
  c = 0;
#line 83
  x = 0;
  }
  {
#line 83
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 83
    if (! (x < m)) {
#line 83
      goto while_break___4;
    }
#line 84
    if ((unsigned long )a1 >= (unsigned long )a) {
#line 84
      if ((unsigned long )b1 >= (unsigned long )b) {
#line 85
        *r1 = (char )((((int )*a1 - c) - (int )*b1) + 48);
      } else {
#line 84
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 86
    if ((unsigned long )a1 >= (unsigned long )a) {
#line 87
      *r1 = (char )((int )*a1 - c);
    } else {
#line 89
      *r1 = (char )(((48 - (int )*b1) - c) + 48);
    }
#line 91
    if ((int )*r1 < 48) {
#line 92
      *r1 = (char )((int )*r1 + 10);
#line 93
      c = 1;
    } else
#line 94
    if ((int )*r1 > 57) {
#line 95
      *r1 = (char )((int )*r1 - 10);
#line 96
      c = 1;
    } else {
#line 98
      c = 0;
    }
#line 100
    a1 --;
#line 101
    b1 --;
#line 102
    r1 --;
#line 83
    x ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 104
  if (c) {
#line 105
    r1 = & res[m + 1];
#line 106
    x = 0;
    {
#line 106
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 106
      tmp___16 = __ctype_b_loc();
      }
#line 106
      if ((int const   )*(*tmp___16 + (int )*r1) & 2048) {
#line 106
        if (! (x < m)) {
#line 106
          goto while_break___5;
        }
      } else {
#line 106
        goto while_break___5;
      }
#line 107
      *r1 = (char )(((57 - (int )*r1) + c) + 48);
#line 108
      if ((int )*r1 > 57) {
#line 109
        *r1 = (char )((int )*r1 - 10);
#line 110
        c = 1;
      } else {
#line 112
        c = 0;
      }
#line 106
      x ++;
#line 106
      r1 --;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 115
    tmp___17 = atof((char const   *)(res));
#line 115
    result = - tmp___17;
    }
  } else {
    {
#line 117
    result = atof((char const   *)(res));
    }
  }
#line 119
  if ((int )a_neg + (int )b_neg == 2) {
#line 120
    result = - result;
  }
#line 122
  return (result);
}
}
#line 80 "/usr/include/getopt.h"
extern int optopt ;
#line 358 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 145 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_create(int argc , char **argv ) ;
#line 227
int rrd_create_r(char const   *filename , unsigned long pdp_step , time_t last_up ,
                 int argc , char const   **argv ) ;
#line 85 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.h"
int rrd_create_fn(char const   *file_name , rrd_t *rrd ) ;
#line 17 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_hw.h"
int create_hw_contingent_rras(rrd_t *rrd , unsigned short period , unsigned long hashed_name ) ;
#line 18 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_create.c"
static int opt_no_overwrite  =    0;
#line 24
unsigned long FnvHash(char const   *str ) ;
#line 30
void parseGENERIC_DS(char const   *def , rrd_t *rrd , int ds_idx ) ;
#line 35
static void rrd_free2(rrd_t *rrd ) ;
#line 38 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_create.c"
int rrd_create(int argc , char **argv ) 
{ 
  struct option long_options___5[4] ;
  int option_index ;
  int opt ;
  time_t last_up ;
  time_t tmp ;
  unsigned long pdp_step ;
  rrd_time_value_t last_up_tv ;
  char *parsetime_error ;
  long long_tmp ;
  int rc ;
  time_t tmp___0 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 42
  long_options___5[0].name = "start";
#line 42
  long_options___5[0].has_arg = 1;
#line 42
  long_options___5[0].flag = (int *)0;
#line 42
  long_options___5[0].val = 'b';
#line 42
  long_options___5[1].name = "step";
#line 42
  long_options___5[1].has_arg = 1;
#line 42
  long_options___5[1].flag = (int *)0;
#line 42
  long_options___5[1].val = 's';
#line 42
  long_options___5[2].name = "no-overwrite";
#line 42
  long_options___5[2].has_arg = 0;
#line 42
  long_options___5[2].flag = (int *)0;
#line 42
  long_options___5[2].val = 'O';
#line 42
  long_options___5[3].name = (char const   *)0;
#line 42
  long_options___5[3].has_arg = 0;
#line 42
  long_options___5[3].flag = (int *)0;
#line 42
  long_options___5[3].val = 0;
#line 48
  option_index = 0;
#line 50
  tmp = time((time_t *)((void *)0));
#line 50
  last_up = tmp - 10L;
#line 51
  pdp_step = 300UL;
#line 53
  parsetime_error = (char *)((void *)0);
#line 57
  optind = 0;
#line 58
  opterr = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    opt = getopt_long(argc, (char * const  *)argv, "Ob:s:", (struct option  const  *)(long_options___5),
                      & option_index);
    }
#line 63
    if (opt == -1) {
#line 64
      goto while_break;
    }
    {
#line 67
    if (opt == 98) {
#line 67
      goto case_98;
    }
#line 88
    if (opt == 115) {
#line 88
      goto case_115;
    }
#line 97
    if (opt == 79) {
#line 97
      goto case_79;
    }
#line 101
    if (opt == 63) {
#line 101
      goto case_63;
    }
#line 66
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 68
    parsetime_error = rrd_parsetime((char const   *)optarg, & last_up_tv);
    }
#line 68
    if (parsetime_error) {
      {
#line 69
      rrd_set_error((char *)"start time: %s", parsetime_error);
      }
#line 70
      return (-1);
    }
#line 72
    if ((unsigned int )last_up_tv.type == 2U) {
      {
#line 74
      rrd_set_error((char *)"specifying time relative to the \'start\' or \'end\' makes no sense here");
      }
#line 76
      return (-1);
    } else
#line 72
    if ((unsigned int )last_up_tv.type == 1U) {
      {
#line 74
      rrd_set_error((char *)"specifying time relative to the \'start\' or \'end\' makes no sense here");
      }
#line 76
      return (-1);
    }
    {
#line 79
    tmp___0 = mktime(& last_up_tv.tm);
#line 79
    last_up = tmp___0 + last_up_tv.offset;
    }
#line 81
    if (last_up < 315360000L) {
      {
#line 82
      rrd_set_error((char *)"the first entry to the RRD should be after 1980");
      }
#line 84
      return (-1);
    }
#line 86
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 89
    long_tmp = atol((char const   *)optarg);
    }
#line 90
    if (long_tmp < 1L) {
      {
#line 91
      rrd_set_error((char *)"step size should be no less than one second");
      }
#line 92
      return (-1);
    }
#line 94
    pdp_step = (unsigned long )long_tmp;
#line 95
    goto switch_break;
    case_79: /* CIL Label */ 
#line 98
    opt_no_overwrite = 1;
#line 99
    goto switch_break;
    case_63: /* CIL Label */ 
#line 102
    if (optopt != 0) {
      {
#line 103
      rrd_set_error((char *)"unknown option \'%c\'", optopt);
      }
    } else {
      {
#line 105
      rrd_set_error((char *)"unknown option \'%s\'", *(argv + (optind - 1)));
      }
    }
#line 106
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  if (optind == argc) {
    {
#line 110
    rrd_set_error((char *)"need name of an rrd file to create");
    }
#line 111
    return (-1);
  }
  {
#line 113
  rc = rrd_create_r((char const   *)*(argv + optind), pdp_step, last_up, (argc - optind) - 1,
                    (char const   **)((argv + optind) + 1));
  }
#line 117
  return (rc);
}
}
#line 121 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_create.c"
int rrd_create_r(char const   *filename , unsigned long pdp_step , time_t last_up ,
                 int argc , char const   **argv ) 
{ 
  rrd_t rrd ;
  long i ;
  int offset ;
  char *token___0 ;
  char dummychar1[2] ;
  char dummychar2[2] ;
  unsigned short token_idx ;
  unsigned short error_flag ;
  unsigned short period ;
  unsigned long hashed_name ;
  void *tmp ;
  void *tmp___0 ;
  unsigned int ii ;
  size_t old_size ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  enum dst_en tmp___5 ;
  int tmp___6 ;
  char *argvcopy ;
  char *tokptr ;
  int cf_id ;
  size_t old_size___0 ;
  int row_cnt ;
  int token_min ;
  void *tmp___7 ;
  int tmp___8 ;
  enum cf_en tmp___9 ;
  enum cf_en tmp___10 ;
  enum cf_en tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  enum cf_en tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  enum cf_en tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  enum cf_en tmp___36 ;
  enum cf_en tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;

  {
  {
#line 133
  period = (unsigned short)0;
#line 137
  rrd_init(& rrd);
#line 139
  tmp = calloc((size_t )1, sizeof(stat_head_t ));
#line 139
  rrd.stat_head = (stat_head_t *)tmp;
  }
#line 139
  if ((unsigned long )rrd.stat_head == (unsigned long )((void *)0)) {
    {
#line 140
    rrd_set_error((char *)"allocating rrd.stat_head");
#line 141
    rrd_free2(& rrd);
    }
#line 142
    return (-1);
  }
  {
#line 146
  tmp___0 = calloc((size_t )1, sizeof(live_head_t ));
#line 146
  rrd.live_head = (live_head_t *)tmp___0;
  }
#line 146
  if ((unsigned long )rrd.live_head == (unsigned long )((void *)0)) {
    {
#line 147
    rrd_set_error((char *)"allocating rrd.live_head");
#line 148
    rrd_free2(& rrd);
    }
#line 149
    return (-1);
  }
  {
#line 153
  strcpy((char */* __restrict  */)((rrd.stat_head)->cookie), (char const   */* __restrict  */)"RRD");
#line 154
  strcpy((char */* __restrict  */)((rrd.stat_head)->version), (char const   */* __restrict  */)"0003");
#line 155
  (rrd.stat_head)->float_cookie = 8.642135E130;
#line 156
  (rrd.stat_head)->ds_cnt = 0UL;
#line 157
  (rrd.stat_head)->rra_cnt = 0UL;
#line 158
  (rrd.stat_head)->pdp_step = pdp_step;
#line 161
  rrd.ds_def = (ds_def_t *)((void *)0);
#line 162
  rrd.rra_def = (rra_def_t *)((void *)0);
#line 164
  (rrd.live_head)->last_up = last_up;
#line 170
  hashed_name = FnvHash(filename);
#line 171
  i = 0L;
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i < (long )argc)) {
#line 171
      goto while_break;
    }
    {
#line 174
    tmp___39 = strncmp(*(argv + i), "DS:", (size_t )3);
    }
#line 174
    if (tmp___39 == 0) {
      {
#line 175
      old_size = sizeof(ds_def_t ) * (rrd.stat_head)->ds_cnt;
#line 177
      tmp___1 = realloc((void *)rrd.ds_def, old_size + sizeof(ds_def_t ));
#line 177
      rrd.ds_def = (ds_def_t *)tmp___1;
      }
#line 177
      if ((unsigned long )rrd.ds_def == (unsigned long )((void *)0)) {
        {
#line 180
        rrd_set_error((char *)"allocating rrd.ds_def");
#line 181
        rrd_free2(& rrd);
        }
#line 182
        return (-1);
      }
      {
#line 184
      memset((void *)(rrd.ds_def + (rrd.stat_head)->ds_cnt), 0, sizeof(ds_def_t ));
#line 186
      tmp___2 = sscanf((char const   */* __restrict  */)(*(argv + i) + 3), (char const   */* __restrict  */)"%19[a-zA-Z0-9_-]%1[:]%19[A-Z]%1[:]%n",
                       (rrd.ds_def + (rrd.stat_head)->ds_cnt)->ds_nam, dummychar1,
                       (rrd.ds_def + (rrd.stat_head)->ds_cnt)->dst, dummychar2, & offset);
      }
      {
#line 193
      if (tmp___2 == 1) {
#line 193
        goto case_1;
      }
#line 193
      if (tmp___2 == 0) {
#line 193
        goto case_1;
      }
#line 197
      if (tmp___2 == 3) {
#line 197
        goto case_3;
      }
#line 197
      if (tmp___2 == 2) {
#line 197
        goto case_3;
      }
#line 201
      if (tmp___2 == 5) {
#line 201
        goto case_5;
      }
#line 201
      if (tmp___2 == 4) {
#line 201
        goto case_5;
      }
#line 209
      goto switch_default;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
      {
#line 194
      rrd_set_error((char *)"Invalid DS name");
      }
#line 195
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
      {
#line 198
      rrd_set_error((char *)"Invalid DS type");
      }
#line 199
      goto switch_break;
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 202
      ii = 0U;
      {
#line 202
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 202
        if (! ((unsigned long )ii < (rrd.stat_head)->ds_cnt)) {
#line 202
          goto while_break___0;
        }
        {
#line 203
        tmp___3 = strcmp((char const   *)((rrd.ds_def + (rrd.stat_head)->ds_cnt)->ds_nam),
                         (char const   *)((rrd.ds_def + ii)->ds_nam));
        }
#line 203
        if (tmp___3 == 0) {
          {
#line 205
          rrd_set_error((char *)"Duplicate DS name: %s", (rrd.ds_def + ii)->ds_nam);
          }
        }
#line 202
        ii ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 208
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 210
      rrd_set_error((char *)"invalid DS format");
      }
      switch_break: /* CIL Label */ ;
      }
      {
#line 212
      tmp___4 = rrd_test_error();
      }
#line 212
      if (tmp___4) {
        {
#line 213
        rrd_free2(& rrd);
        }
#line 214
        return (-1);
      }
      {
#line 218
      tmp___5 = dst_conv((rrd.ds_def + (rrd.stat_head)->ds_cnt)->dst);
      }
      {
#line 222
      if ((unsigned int )tmp___5 == 3U) {
#line 222
        goto case_3___0;
      }
#line 222
      if ((unsigned int )tmp___5 == 2U) {
#line 222
        goto case_3___0;
      }
#line 222
      if ((unsigned int )tmp___5 == 1U) {
#line 222
        goto case_3___0;
      }
#line 222
      if ((unsigned int )tmp___5 == 0U) {
#line 222
        goto case_3___0;
      }
#line 226
      if ((unsigned int )tmp___5 == 4U) {
#line 226
        goto case_4___0;
      }
#line 230
      goto switch_default___0;
      case_3___0: /* CIL Label */ 
      case_2___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
      {
#line 223
      parseGENERIC_DS(*(argv + i) + (offset + 3), & rrd, (int )(rrd.stat_head)->ds_cnt);
      }
#line 225
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
      {
#line 227
      parseCDEF_DS(*(argv + i) + (offset + 3), & rrd, (int )(rrd.stat_head)->ds_cnt);
      }
#line 229
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 231
      rrd_set_error((char *)"invalid DS type specified");
      }
#line 232
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 235
      tmp___6 = rrd_test_error();
      }
#line 235
      if (tmp___6) {
        {
#line 236
        rrd_free2(& rrd);
        }
#line 237
        return (-1);
      }
#line 239
      ((rrd.stat_head)->ds_cnt) ++;
    } else {
      {
#line 240
      tmp___38 = strncmp(*(argv + i), "RRA:", (size_t )4);
      }
#line 240
      if (tmp___38 == 0) {
        {
#line 242
        tokptr = (char *)"";
#line 243
        cf_id = -1;
#line 244
        old_size___0 = sizeof(rra_def_t ) * (rrd.stat_head)->rra_cnt;
#line 246
        token_min = 4;
#line 247
        tmp___7 = realloc((void *)rrd.rra_def, old_size___0 + sizeof(rra_def_t ));
#line 247
        rrd.rra_def = (rra_def_t *)tmp___7;
        }
#line 247
        if ((unsigned long )rrd.rra_def == (unsigned long )((void *)0)) {
          {
#line 250
          rrd_set_error((char *)"allocating rrd.rra_def");
#line 251
          rrd_free2(& rrd);
          }
#line 252
          return (-1);
        }
        {
#line 254
        memset((void *)(rrd.rra_def + (rrd.stat_head)->rra_cnt), 0, sizeof(rra_def_t ));
#line 257
        argvcopy = strdup(*(argv + i));
#line 258
        token___0 = strtok_r((char */* __restrict  */)(argvcopy + 4), (char const   */* __restrict  */)":",
                             (char **/* __restrict  */)(& tokptr));
#line 259
        error_flag = (unsigned short)0;
#line 259
        token_idx = error_flag;
        }
        {
#line 261
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 261
          if (! ((unsigned long )token___0 != (unsigned long )((void *)0))) {
#line 261
            goto while_break___1;
          }
          {
#line 263
          if ((int )token_idx == 0) {
#line 263
            goto case_0___1;
          }
#line 326
          if ((int )token_idx == 1) {
#line 326
            goto case_1___1;
          }
#line 352
          if ((int )token_idx == 2) {
#line 352
            goto case_2___1;
          }
#line 400
          if ((int )token_idx == 3) {
#line 400
            goto case_3___1;
          }
#line 456
          if ((int )token_idx == 4) {
#line 456
            goto case_4___5;
          }
#line 506
          if ((int )token_idx == 5) {
#line 506
            goto case_5___5;
          }
#line 516
          goto switch_default___6;
          case_0___1: /* CIL Label */ 
          {
#line 264
          tmp___8 = sscanf((char const   */* __restrict  */)token___0, (char const   */* __restrict  */)"%19[A-Z]",
                           (rrd.rra_def + (rrd.stat_head)->rra_cnt)->cf_nam);
          }
#line 264
          if (tmp___8 != 1) {
            {
#line 267
            rrd_set_error((char *)"Failed to parse CF name");
            }
          }
          {
#line 268
          tmp___9 = cf_conv((char const   *)((rrd.rra_def + (rrd.stat_head)->rra_cnt)->cf_nam));
#line 268
          cf_id = (int )tmp___9;
          }
          {
#line 270
          if (cf_id == 9) {
#line 270
            goto case_9;
          }
#line 272
          if (cf_id == 4) {
#line 272
            goto case_4___1;
          }
#line 283
          if (cf_id == 7) {
#line 283
            goto case_7;
          }
#line 285
          if (cf_id == 5) {
#line 285
            goto case_5___0;
          }
#line 295
          if (cf_id == 6) {
#line 295
            goto case_6;
          }
#line 302
          if (cf_id == 8) {
#line 302
            goto case_8;
          }
#line 316
          if (cf_id == -1) {
#line 316
            goto case_neg_1;
          }
#line 320
          goto switch_default___1;
          case_9: /* CIL Label */ 
          {
#line 271
          strcpy((char */* __restrict  */)((rrd.stat_head)->version), (char const   */* __restrict  */)"0004");
          }
          case_4___1: /* CIL Label */ 
#line 273
          token_min = 5;
#line 275
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[1].u_val = 0.1;
#line 277
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[2].u_val = 1.0 / (double )288;
#line 279
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[3].u_cnt = (rrd.stat_head)->rra_cnt;
#line 282
          goto switch_break___2;
          case_7: /* CIL Label */ 
#line 284
          token_min = 3;
          case_5___0: /* CIL Label */ 
#line 286
          if (cf_id == 5) {
#line 287
            token_min = 4;
          }
#line 290
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[1].u_val = 0.1;
#line 292
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[2].u_val = 0.05;
          case_6: /* CIL Label */ 
#line 296
          if (cf_id == 6) {
#line 297
            token_min = 3;
          }
#line 299
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[3].u_cnt = 0xffffffffffffffffUL;
#line 301
          goto switch_break___2;
          case_8: /* CIL Label */ 
#line 303
          token_min = 5;
#line 304
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[1].u_val = 2.0;
#line 306
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[2].u_val = 2.0;
#line 308
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[4].u_cnt = 3UL;
#line 310
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[5].u_cnt = 2UL;
#line 312
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[3].u_cnt = 0xffffffffffffffffUL;
#line 314
          goto switch_break___2;
          case_neg_1: /* CIL Label */ 
          {
#line 317
          rrd_set_error((char *)"Unrecognized consolidation function %s", (rrd.rra_def + (rrd.stat_head)->rra_cnt)->cf_nam);
          }
          switch_default___1: /* CIL Label */ 
#line 321
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
#line 324
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->pdp_cnt = 1UL;
#line 325
          goto switch_break___1;
          case_1___1: /* CIL Label */ 
          {
#line 327
          tmp___10 = cf_conv((char const   *)((rrd.rra_def + (rrd.stat_head)->rra_cnt)->cf_nam));
          }
          {
#line 334
          if ((unsigned int )tmp___10 == 8U) {
#line 334
            goto case_8___0;
          }
#line 334
          if ((unsigned int )tmp___10 == 6U) {
#line 334
            goto case_8___0;
          }
#line 334
          if ((unsigned int )tmp___10 == 5U) {
#line 334
            goto case_8___0;
          }
#line 334
          if ((unsigned int )tmp___10 == 7U) {
#line 334
            goto case_8___0;
          }
#line 334
          if ((unsigned int )tmp___10 == 9U) {
#line 334
            goto case_8___0;
          }
#line 334
          if ((unsigned int )tmp___10 == 4U) {
#line 334
            goto case_8___0;
          }
#line 340
          goto switch_default___2;
          case_8___0: /* CIL Label */ 
          case_6___0: /* CIL Label */ 
          case_5___1: /* CIL Label */ 
          case_7___0: /* CIL Label */ 
          case_9___0: /* CIL Label */ 
          case_4___2: /* CIL Label */ 
          {
#line 335
          row_cnt = atoi((char const   *)token___0);
          }
#line 336
          if (row_cnt <= 0) {
            {
#line 337
            rrd_set_error((char *)"Invalid row count: %i", row_cnt);
            }
          }
#line 338
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->row_cnt = (unsigned long )row_cnt;
#line 339
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 341
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[0].u_val = atof((char const   *)token___0);
          }
#line 343
          if ((rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[0].u_val < 0.0) {
            {
#line 347
            rrd_set_error((char *)"Invalid xff: must be between 0 and 1");
            }
          } else
#line 343
          if ((rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[0].u_val >= 1.0) {
            {
#line 347
            rrd_set_error((char *)"Invalid xff: must be between 0 and 1");
            }
          }
#line 349
          goto switch_break___3;
          switch_break___3: /* CIL Label */ ;
          }
#line 351
          goto switch_break___1;
          case_2___1: /* CIL Label */ 
          {
#line 353
          tmp___11 = cf_conv((char const   *)((rrd.rra_def + (rrd.stat_head)->rra_cnt)->cf_nam));
          }
          {
#line 356
          if ((unsigned int )tmp___11 == 9U) {
#line 356
            goto case_9___1;
          }
#line 356
          if ((unsigned int )tmp___11 == 4U) {
#line 356
            goto case_9___1;
          }
#line 364
          if ((unsigned int )tmp___11 == 5U) {
#line 364
            goto case_5___2;
          }
#line 364
          if ((unsigned int )tmp___11 == 7U) {
#line 364
            goto case_5___2;
          }
#line 375
          if ((unsigned int )tmp___11 == 8U) {
#line 375
            goto case_8___1;
          }
#line 385
          if ((unsigned int )tmp___11 == 6U) {
#line 385
            goto case_6___1;
          }
#line 392
          goto switch_default___3;
          case_9___1: /* CIL Label */ 
          case_4___3: /* CIL Label */ 
          {
#line 357
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[1].u_val = atof((char const   *)token___0);
#line 359
          tmp___12 = atof((char const   *)token___0);
          }
#line 359
          if (tmp___12 <= 0.0) {
            {
#line 360
            rrd_set_error((char *)"Invalid alpha: must be between 0 and 1");
            }
          } else {
            {
#line 359
            tmp___13 = atof((char const   *)token___0);
            }
#line 359
            if (tmp___13 >= 1.0) {
              {
#line 360
              rrd_set_error((char *)"Invalid alpha: must be between 0 and 1");
              }
            }
          }
#line 362
          goto switch_break___4;
          case_5___2: /* CIL Label */ 
          case_7___1: /* CIL Label */ 
          {
#line 365
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[1].u_val = atof((char const   *)token___0);
#line 367
          tmp___14 = atof((char const   *)token___0);
          }
#line 367
          if (tmp___14 <= 0.0) {
            {
#line 368
            rrd_set_error((char *)"Invalid gamma: must be between 0 and 1");
            }
          } else {
            {
#line 367
            tmp___15 = atof((char const   *)token___0);
            }
#line 367
            if (tmp___15 >= 1.0) {
              {
#line 368
              rrd_set_error((char *)"Invalid gamma: must be between 0 and 1");
              }
            }
          }
#line 370
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[4].u_cnt = hashed_name % (rrd.rra_def + (rrd.stat_head)->rra_cnt)->row_cnt;
#line 374
          goto switch_break___4;
          case_8___1: /* CIL Label */ 
          {
#line 377
          tmp___16 = atoi((char const   *)token___0);
#line 377
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[5].u_cnt = (unsigned long )tmp___16;
#line 379
          tmp___17 = atoi((char const   *)token___0);
          }
#line 379
          if (tmp___17 < 1) {
            {
#line 381
            rrd_set_error((char *)"Failure threshold is out of range %d, %d", 1, 28);
            }
          } else {
            {
#line 379
            tmp___18 = atoi((char const   *)token___0);
            }
#line 379
            if (tmp___18 > 28) {
              {
#line 381
              rrd_set_error((char *)"Failure threshold is out of range %d, %d", 1,
                            28);
              }
            }
          }
#line 384
          goto switch_break___4;
          case_6___1: /* CIL Label */ 
          {
#line 388
          tmp___19 = atoi((char const   *)token___0);
#line 388
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[3].u_cnt = (unsigned long )(tmp___19 - 1);
          }
#line 391
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 393
          tmp___20 = atoi((char const   *)token___0);
#line 393
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->pdp_cnt = (unsigned long )tmp___20;
#line 395
          tmp___21 = atoi((char const   *)token___0);
          }
#line 395
          if (tmp___21 < 1) {
            {
#line 396
            rrd_set_error((char *)"Invalid step: must be >= 1");
            }
          }
#line 397
          goto switch_break___4;
          switch_break___4: /* CIL Label */ ;
          }
#line 399
          goto switch_break___1;
          case_3___1: /* CIL Label */ 
          {
#line 401
          tmp___22 = cf_conv((char const   *)((rrd.rra_def + (rrd.stat_head)->rra_cnt)->cf_nam));
          }
          {
#line 404
          if ((unsigned int )tmp___22 == 9U) {
#line 404
            goto case_9___2;
          }
#line 404
          if ((unsigned int )tmp___22 == 4U) {
#line 404
            goto case_9___2;
          }
#line 412
          if ((unsigned int )tmp___22 == 5U) {
#line 412
            goto case_5___3;
          }
#line 412
          if ((unsigned int )tmp___22 == 7U) {
#line 412
            goto case_5___3;
          }
#line 420
          if ((unsigned int )tmp___22 == 8U) {
#line 420
            goto case_8___2;
          }
#line 437
          if ((unsigned int )tmp___22 == 6U) {
#line 437
            goto case_6___2;
          }
#line 442
          goto switch_default___4;
          case_9___2: /* CIL Label */ 
          case_4___4: /* CIL Label */ 
          {
#line 405
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[2].u_val = atof((char const   *)token___0);
#line 407
          tmp___23 = atof((char const   *)token___0);
          }
#line 407
          if (tmp___23 < 0.0) {
            {
#line 408
            rrd_set_error((char *)"Invalid beta: must be between 0 and 1");
            }
          } else {
            {
#line 407
            tmp___24 = atof((char const   *)token___0);
            }
#line 407
            if (tmp___24 > 1.0) {
              {
#line 408
              rrd_set_error((char *)"Invalid beta: must be between 0 and 1");
              }
            }
          }
#line 410
          goto switch_break___5;
          case_5___3: /* CIL Label */ 
          case_7___2: /* CIL Label */ 
          {
#line 416
          tmp___25 = atoi((char const   *)token___0);
#line 416
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[3].u_cnt = (unsigned long )(tmp___25 - 1);
          }
#line 419
          goto switch_break___5;
          case_8___2: /* CIL Label */ 
          {
#line 422
          tmp___26 = atoi((char const   *)token___0);
#line 422
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[4].u_cnt = (unsigned long )tmp___26;
#line 424
          tmp___27 = atoi((char const   *)token___0);
          }
#line 424
          if (tmp___27 < 1) {
            {
#line 426
            rrd_set_error((char *)"Window length is out of range %d, %d", 1, 28);
            }
          } else {
            {
#line 424
            tmp___28 = atoi((char const   *)token___0);
            }
#line 424
            if (tmp___28 > 28) {
              {
#line 426
              rrd_set_error((char *)"Window length is out of range %d, %d", 1, 28);
              }
            }
          }
#line 430
          if ((rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[4].u_cnt < (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[5].u_cnt) {
            {
#line 434
            rrd_set_error((char *)"Window length is shorter than the failure threshold");
            }
          }
#line 436
          goto switch_break___5;
          case_6___2: /* CIL Label */ 
          {
#line 439
          rrd_set_error((char *)"Unexpected extra argument for consolidation function DEVPREDICT");
          }
#line 441
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 443
          row_cnt = atoi((char const   *)token___0);
          }
#line 444
          if (row_cnt <= 0) {
            {
#line 445
            rrd_set_error((char *)"Invalid row count: %i", row_cnt);
            }
          }
#line 452
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->row_cnt = (unsigned long )row_cnt;
#line 453
          goto switch_break___5;
          switch_break___5: /* CIL Label */ ;
          }
#line 455
          goto switch_break___1;
          case_4___5: /* CIL Label */ 
          {
#line 457
          tmp___29 = cf_conv((char const   *)((rrd.rra_def + (rrd.stat_head)->rra_cnt)->cf_nam));
          }
          {
#line 459
          if ((unsigned int )tmp___29 == 8U) {
#line 459
            goto case_8___3;
          }
#line 467
          if ((unsigned int )tmp___29 == 5U) {
#line 467
            goto case_5___4;
          }
#line 467
          if ((unsigned int )tmp___29 == 7U) {
#line 467
            goto case_5___4;
          }
#line 490
          if ((unsigned int )tmp___29 == 9U) {
#line 490
            goto case_9___3;
          }
#line 490
          if ((unsigned int )tmp___29 == 4U) {
#line 490
            goto case_9___3;
          }
#line 498
          goto switch_default___5;
          case_8___3: /* CIL Label */ 
          {
#line 462
          tmp___30 = atoi((char const   *)token___0);
#line 462
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[3].u_cnt = (unsigned long )(tmp___30 - 1);
          }
#line 465
          goto switch_break___6;
          case_5___4: /* CIL Label */ 
          case_7___3: /* CIL Label */ 
          {
#line 469
          tmp___31 = sscanf((char const   */* __restrict  */)token___0, (char const   */* __restrict  */)"smoothing-window=%lf",
                            & (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[2].u_val);
          }
#line 469
          if (tmp___31) {
            {
#line 473
            strcpy((char */* __restrict  */)((rrd.stat_head)->version), (char const   */* __restrict  */)"0004");
            }
#line 474
            if ((rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[2].u_val < 0.0) {
              {
#line 479
              rrd_set_error((char *)"Invalid smoothing-window %f: must be between 0 and 1",
                            (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[2].u_val);
              }
            } else
#line 474
            if ((rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[2].u_val > 1.0) {
              {
#line 479
              rrd_set_error((char *)"Invalid smoothing-window %f: must be between 0 and 1",
                            (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[2].u_val);
              }
            }
          } else {
            {
#line 486
            rrd_set_error((char *)"Invalid option %s", token___0);
            }
          }
#line 488
          goto switch_break___6;
          case_9___3: /* CIL Label */ 
          case_4___6: /* CIL Label */ 
          {
#line 492
          tmp___32 = atoi((char const   *)token___0);
#line 492
          period = (unsigned short )tmp___32;
          }
#line 493
          if ((unsigned long )period > (rrd.rra_def + (rrd.stat_head)->rra_cnt)->row_cnt) {
            {
#line 495
            rrd_set_error((char *)"Length of seasonal cycle exceeds length of HW prediction array");
            }
          }
#line 497
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 500
          rrd_set_error((char *)"Unexpected extra argument for consolidation function %s",
                        (rrd.rra_def + (rrd.stat_head)->rra_cnt)->cf_nam);
          }
#line 503
          goto switch_break___6;
          switch_break___6: /* CIL Label */ ;
          }
#line 505
          goto switch_break___1;
          case_5___5: /* CIL Label */ 
          {
#line 513
          tmp___33 = atoi((char const   *)token___0);
#line 513
          (rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[3].u_cnt = (unsigned long )(tmp___33 - 1);
          }
#line 515
          goto switch_break___1;
          switch_default___6: /* CIL Label */ 
          {
#line 518
          rrd_set_error((char *)"Unknown error");
          }
#line 519
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
          {
#line 521
          tmp___34 = rrd_test_error();
          }
#line 521
          if (tmp___34) {
            {
#line 523
            free((void *)argvcopy);
#line 524
            rrd_free2(& rrd);
            }
#line 525
            return (-1);
          }
          {
#line 527
          token___0 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                               (char **/* __restrict  */)(& tokptr));
#line 528
          token_idx = (unsigned short )((int )token_idx + 1);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 530
        free((void *)argvcopy);
        }
#line 531
        if ((int )token_idx < token_min) {
          {
#line 532
          rrd_set_error((char *)"Expected at least %i arguments for RRA but got %i",
                        token_min, (int )token_idx);
#line 533
          rrd_free2(& rrd);
          }
#line 534
          return (-1);
        }
        {
#line 544
        tmp___36 = cf_conv((char const   *)((rrd.rra_def + (rrd.stat_head)->rra_cnt)->cf_nam));
        }
#line 544
        if ((unsigned int )tmp___36 == 4U) {
#line 544
          goto _L;
        } else {
          {
#line 544
          tmp___37 = cf_conv((char const   *)((rrd.rra_def + (rrd.stat_head)->rra_cnt)->cf_nam));
          }
#line 544
          if ((unsigned int )tmp___37 == 9U) {
            _L: /* CIL Label */ 
#line 544
            if ((rrd.rra_def + (rrd.stat_head)->rra_cnt)->par[3].u_cnt == (rrd.stat_head)->rra_cnt) {
              {
#line 553
              tmp___35 = create_hw_contingent_rras(& rrd, period, hashed_name);
              }
#line 553
              if (tmp___35 == -1) {
                {
#line 555
                rrd_set_error((char *)"creating contingent RRA");
#line 556
                rrd_free2(& rrd);
                }
#line 557
                return (-1);
              }
            }
          }
        }
#line 560
        ((rrd.stat_head)->rra_cnt) ++;
      } else {
        {
#line 562
        rrd_set_error((char *)"can\'t parse argument \'%s\'", *(argv + i));
#line 563
        rrd_free2(& rrd);
        }
#line 564
        return (-1);
      }
    }
#line 171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  if ((rrd.stat_head)->rra_cnt < 1UL) {
    {
#line 570
    rrd_set_error((char *)"you must define at least one Round Robin Archive");
#line 571
    rrd_free2(& rrd);
    }
#line 572
    return (-1);
  }
#line 575
  if ((rrd.stat_head)->ds_cnt < 1UL) {
    {
#line 576
    rrd_set_error((char *)"you must define at least one Data Source");
#line 577
    rrd_free2(& rrd);
    }
#line 578
    return (-1);
  }
  {
#line 580
  tmp___40 = rrd_create_fn(filename, & rrd);
  }
#line 580
  return (tmp___40);
}
}
#line 583 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_create.c"
void parseGENERIC_DS(char const   *def , rrd_t *rrd , int ds_idx ) 
{ 
  char minstr[20] ;
  char maxstr[20] ;
  char *old_locale ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 598
  old_locale = setlocale(1, (char const   *)((void *)0));
#line 599
  setlocale(1, "C");
#line 600
  tmp___9 = sscanf((char const   */* __restrict  */)def, (char const   */* __restrict  */)"%lu:%18[^:]:%18[^:]",
                   & (rrd->ds_def + ds_idx)->par[0].u_cnt, minstr, maxstr);
  }
#line 600
  if (tmp___9 == 3) {
#line 603
    if ((int )minstr[0] == 85) {
#line 603
      if ((int )minstr[1] == 0) {
        {
#line 604
        (rrd->ds_def + ds_idx)->par[1].u_val = rrd_set_to_DNAN();
        }
      } else {
        {
#line 606
        (rrd->ds_def + ds_idx)->par[1].u_val = atof((char const   *)(minstr));
        }
      }
    } else {
      {
#line 606
      (rrd->ds_def + ds_idx)->par[1].u_val = atof((char const   *)(minstr));
      }
    }
#line 608
    if ((int )maxstr[0] == 85) {
#line 608
      if ((int )maxstr[1] == 0) {
        {
#line 609
        (rrd->ds_def + ds_idx)->par[2].u_val = rrd_set_to_DNAN();
        }
      } else {
        {
#line 611
        (rrd->ds_def + ds_idx)->par[2].u_val = atof((char const   *)(maxstr));
        }
      }
    } else {
      {
#line 611
      (rrd->ds_def + ds_idx)->par[2].u_val = atof((char const   *)(maxstr));
      }
    }
#line 613
    if (sizeof((rrd->ds_def + ds_idx)->par[1].u_val) == sizeof(float )) {
      {
#line 613
      tmp = __isnanf((float )(rrd->ds_def + ds_idx)->par[1].u_val);
#line 613
      tmp___3 = tmp;
      }
    } else {
#line 613
      if (sizeof((rrd->ds_def + ds_idx)->par[1].u_val) == sizeof(double )) {
        {
#line 613
        tmp___0 = __isnan((rrd->ds_def + ds_idx)->par[1].u_val);
#line 613
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 613
        tmp___1 = __isnanl((long double )(rrd->ds_def + ds_idx)->par[1].u_val);
#line 613
        tmp___2 = tmp___1;
        }
      }
#line 613
      tmp___3 = tmp___2;
    }
#line 613
    if (! tmp___3) {
#line 613
      if (sizeof((rrd->ds_def + ds_idx)->par[2].u_val) == sizeof(float )) {
        {
#line 613
        tmp___4 = __isnanf((float )(rrd->ds_def + ds_idx)->par[2].u_val);
#line 613
        tmp___8 = tmp___4;
        }
      } else {
#line 613
        if (sizeof((rrd->ds_def + ds_idx)->par[2].u_val) == sizeof(double )) {
          {
#line 613
          tmp___5 = __isnan((rrd->ds_def + ds_idx)->par[2].u_val);
#line 613
          tmp___7 = tmp___5;
          }
        } else {
          {
#line 613
          tmp___6 = __isnanl((long double )(rrd->ds_def + ds_idx)->par[2].u_val);
#line 613
          tmp___7 = tmp___6;
          }
        }
#line 613
        tmp___8 = tmp___7;
      }
#line 613
      if (! tmp___8) {
#line 613
        if ((rrd->ds_def + ds_idx)->par[1].u_val >= (rrd->ds_def + ds_idx)->par[2].u_val) {
          {
#line 617
          rrd_set_error((char *)"min must be less than max in DS definition");
#line 618
          setlocale(1, (char const   *)old_locale);
          }
#line 619
          return;
        }
      }
    }
  } else {
    {
#line 622
    rrd_set_error((char *)"failed to parse data source %s", def);
    }
  }
  {
#line 624
  setlocale(1, (char const   *)old_locale);
  }
#line 625
  return;
}
}
#line 629 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_create.c"
int create_hw_contingent_rras(rrd_t *rrd , unsigned short period , unsigned long hashed_name ) 
{ 
  size_t old_size ;
  rra_def_t *current_rra ;
  unsigned long hw_index ;
  rra_def_t *tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 638
  hw_index = (rrd->stat_head)->rra_cnt;
#line 641
  ((rrd->stat_head)->rra_cnt) ++;
#line 643
  old_size = sizeof(rra_def_t ) * (rrd->stat_head)->rra_cnt;
#line 644
  tmp___0 = realloc((void *)rrd->rra_def, old_size + 4UL * sizeof(rra_def_t ));
#line 644
  tmp = (rra_def_t *)tmp___0;
#line 644
  rrd->rra_def = tmp;
  }
#line 644
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 647
    rrd_free2(rrd);
#line 648
    rrd_set_error((char *)"allocating rrd.rra_def");
    }
#line 649
    return (-1);
  }
  {
#line 652
  memset((void *)(rrd->rra_def + (rrd->stat_head)->rra_cnt), 0, 4UL * sizeof(rra_def_t ));
#line 656
  current_rra = rrd->rra_def + (rrd->stat_head)->rra_cnt;
#line 657
  strcpy((char */* __restrict  */)(current_rra->cf_nam), (char const   */* __restrict  */)"SEASONAL");
#line 658
  current_rra->row_cnt = (unsigned long )period;
#line 659
  current_rra->par[4].u_cnt = hashed_name % (unsigned long )period;
#line 660
  current_rra->pdp_cnt = 1UL;
#line 661
  current_rra->par[1].u_val = (rrd->rra_def + hw_index)->par[1].u_val;
#line 663
  current_rra->par[3].u_cnt = hw_index;
#line 664
  (rrd->rra_def + hw_index)->par[3].u_cnt = (rrd->stat_head)->rra_cnt;
#line 668
  ((rrd->stat_head)->rra_cnt) ++;
#line 669
  current_rra = rrd->rra_def + (rrd->stat_head)->rra_cnt;
#line 670
  strcpy((char */* __restrict  */)(current_rra->cf_nam), (char const   */* __restrict  */)"DEVSEASONAL");
#line 671
  current_rra->row_cnt = (unsigned long )period;
#line 672
  current_rra->par[4].u_cnt = hashed_name % (unsigned long )period;
#line 673
  current_rra->pdp_cnt = 1UL;
#line 674
  current_rra->par[1].u_val = (rrd->rra_def + hw_index)->par[1].u_val;
#line 676
  current_rra->par[3].u_cnt = hw_index;
#line 679
  ((rrd->stat_head)->rra_cnt) ++;
#line 680
  current_rra = rrd->rra_def + (rrd->stat_head)->rra_cnt;
#line 681
  strcpy((char */* __restrict  */)(current_rra->cf_nam), (char const   */* __restrict  */)"DEVPREDICT");
#line 682
  current_rra->row_cnt = (rrd->rra_def + hw_index)->row_cnt;
#line 683
  current_rra->pdp_cnt = 1UL;
#line 684
  current_rra->par[3].u_cnt = hw_index + 2UL;
#line 687
  ((rrd->stat_head)->rra_cnt) ++;
#line 688
  current_rra = rrd->rra_def + (rrd->stat_head)->rra_cnt;
#line 689
  strcpy((char */* __restrict  */)(current_rra->cf_nam), (char const   */* __restrict  */)"FAILURES");
#line 690
  current_rra->row_cnt = (unsigned long )period;
#line 691
  current_rra->pdp_cnt = 1UL;
#line 692
  current_rra->par[1].u_val = 2.0;
#line 693
  current_rra->par[2].u_val = 2.0;
#line 694
  current_rra->par[5].u_cnt = 7UL;
#line 695
  current_rra->par[4].u_cnt = 9UL;
#line 696
  current_rra->par[3].u_cnt = hw_index + 2UL;
  }
#line 697
  return (0);
}
}
#line 702 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_create.c"
int rrd_create_fn(char const   *file_name , rrd_t *rrd ) 
{ 
  unsigned long i ;
  unsigned long ii ;
  rrd_value_t *unknown ;
  int unkn_cnt ;
  rrd_file_t *rrd_file_dn ;
  rrd_t rrd_dn ;
  unsigned int rrd_flags ;
  int *tmp ;
  char const   *tmp___0 ;
  pdp_prep_t *tmp___1 ;
  void *tmp___2 ;
  cdp_prep_t *tmp___3 ;
  void *tmp___4 ;
  enum cf_en tmp___5 ;
  rra_ptr_t *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  ssize_t tmp___12 ;
  int *tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 711
  rrd_flags = (unsigned int )((1 << 1) | (1 << 2));
#line 713
  if (opt_no_overwrite) {
#line 714
    rrd_flags |= (unsigned int )(1 << 5);
  }
#line 717
  unkn_cnt = 0;
#line 718
  i = 0UL;
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;
#line 718
    if (! (i < (rrd->stat_head)->rra_cnt)) {
#line 718
      goto while_break;
    }
#line 719
    unkn_cnt = (int )((unsigned long )unkn_cnt + (rrd->stat_head)->ds_cnt * (rrd->rra_def + i)->row_cnt);
#line 718
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 721
  rrd_file_dn = rrd_open((char const   */* const  */)file_name, rrd, rrd_flags);
  }
#line 721
  if ((unsigned long )rrd_file_dn == (unsigned long )((void *)0)) {
    {
#line 722
    tmp = __errno_location();
#line 722
    tmp___0 = rrd_strerror(*tmp);
#line 722
    rrd_set_error((char *)"creating \'%s\': %s", file_name, tmp___0);
#line 723
    rrd_free2(rrd);
    }
#line 724
    return (-1);
  }
  {
#line 727
  rrd_write(rrd_file_dn, (void const   *)rrd->stat_head, sizeof(stat_head_t ));
#line 729
  rrd_write(rrd_file_dn, (void const   *)rrd->ds_def, sizeof(ds_def_t ) * (rrd->stat_head)->ds_cnt);
#line 731
  rrd_write(rrd_file_dn, (void const   *)rrd->rra_def, sizeof(rra_def_t ) * (rrd->stat_head)->rra_cnt);
#line 734
  rrd_write(rrd_file_dn, (void const   *)rrd->live_head, sizeof(live_head_t ));
#line 736
  tmp___2 = calloc((size_t )1, sizeof(pdp_prep_t ));
#line 736
  tmp___1 = (pdp_prep_t *)tmp___2;
#line 736
  rrd->pdp_prep = tmp___1;
  }
#line 736
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 737
    rrd_set_error((char *)"allocating pdp_prep");
#line 738
    rrd_free2(rrd);
#line 739
    rrd_close(rrd_file_dn);
    }
#line 740
    return (-1);
  }
  {
#line 743
  strcpy((char */* __restrict  */)((rrd->pdp_prep)->last_ds), (char const   */* __restrict  */)"U");
#line 745
  (rrd->pdp_prep)->scratch[1].u_val = 0.0;
#line 746
  (rrd->pdp_prep)->scratch[0].u_cnt = (unsigned long )(rrd->live_head)->last_up % (rrd->stat_head)->pdp_step;
#line 749
  i = 0UL;
  }
  {
#line 749
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 749
    if (! (i < (rrd->stat_head)->ds_cnt)) {
#line 749
      goto while_break___0;
    }
    {
#line 750
    rrd_write(rrd_file_dn, (void const   *)rrd->pdp_prep, sizeof(pdp_prep_t ));
#line 749
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 752
  tmp___4 = calloc((size_t )1, sizeof(cdp_prep_t ));
#line 752
  tmp___3 = (cdp_prep_t *)tmp___4;
#line 752
  rrd->cdp_prep = tmp___3;
  }
#line 752
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 753
    rrd_set_error((char *)"allocating cdp_prep");
#line 754
    rrd_free2(rrd);
#line 755
    rrd_close(rrd_file_dn);
    }
#line 756
    return (-1);
  }
#line 760
  i = 0UL;
  {
#line 760
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 760
    if (! (i < (rrd->stat_head)->rra_cnt)) {
#line 760
      goto while_break___1;
    }
    {
#line 761
    tmp___5 = cf_conv((char const   *)((rrd->rra_def + i)->cf_nam));
    }
    {
#line 763
    if ((unsigned int )tmp___5 == 9U) {
#line 763
      goto case_9;
    }
#line 763
    if ((unsigned int )tmp___5 == 4U) {
#line 763
      goto case_9;
    }
#line 767
    if ((unsigned int )tmp___5 == 7U) {
#line 767
      goto case_7;
    }
#line 767
    if ((unsigned int )tmp___5 == 5U) {
#line 767
      goto case_7;
    }
#line 770
    if ((unsigned int )tmp___5 == 8U) {
#line 770
      goto case_8;
    }
#line 779
    goto switch_default;
    case_9: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 764
    init_hwpredict_cdp(rrd->cdp_prep);
    }
#line 765
    goto switch_break;
    case_7: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 768
    init_seasonal_cdp(rrd->cdp_prep);
    }
#line 769
    goto switch_break;
    case_8: /* CIL Label */ 
#line 772
    ii = 0UL;
    {
#line 772
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 772
      if (! (ii < 10UL)) {
#line 772
        goto while_break___2;
      }
#line 776
      (rrd->cdp_prep)->scratch[ii].u_val = 0.0;
#line 772
      ii ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 778
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 781
    (rrd->cdp_prep)->scratch[0].u_val = rrd_set_to_DNAN();
#line 783
    (rrd->cdp_prep)->scratch[1].u_cnt = (((unsigned long )(rrd->live_head)->last_up - (rrd->pdp_prep)->scratch[0].u_cnt) % ((rrd->stat_head)->pdp_step * (rrd->rra_def + i)->pdp_cnt)) / (rrd->stat_head)->pdp_step;
    }
#line 788
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 791
    ii = 0UL;
    {
#line 791
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 791
      if (! (ii < (rrd->stat_head)->ds_cnt)) {
#line 791
        goto while_break___3;
      }
      {
#line 792
      rrd_write(rrd_file_dn, (void const   *)rrd->cdp_prep, sizeof(cdp_prep_t ));
#line 791
      ii ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 760
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 799
  tmp___7 = calloc((size_t )1, sizeof(rra_ptr_t ));
#line 799
  tmp___6 = (rra_ptr_t *)tmp___7;
#line 799
  rrd->rra_ptr = tmp___6;
  }
#line 799
  if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
    {
#line 800
    rrd_set_error((char *)"allocating rra_ptr");
#line 801
    rrd_free2(rrd);
#line 802
    rrd_close(rrd_file_dn);
    }
#line 803
    return (-1);
  }
#line 810
  i = 0UL;
  {
#line 810
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 810
    if (! (i < (rrd->stat_head)->rra_cnt)) {
#line 810
      goto while_break___4;
    }
    {
#line 811
    (rrd->rra_ptr)->cur_row = rrd_select_initial_row(rrd_file_dn, (int )i, rrd->rra_def + i);
#line 812
    rrd_write(rrd_file_dn, (void const   *)rrd->rra_ptr, sizeof(rra_ptr_t ));
#line 810
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 816
  tmp___8 = malloc(512UL * sizeof(rrd_value_t ));
#line 816
  unknown = (rrd_value_t *)tmp___8;
  }
#line 816
  if ((unsigned long )unknown == (unsigned long )((void *)0)) {
    {
#line 817
    rrd_set_error((char *)"allocating unknown");
#line 818
    rrd_free2(rrd);
#line 819
    rrd_close(rrd_file_dn);
    }
#line 820
    return (-1);
  }
#line 822
  i = 0UL;
  {
#line 822
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 822
    if (! (i < 512UL)) {
#line 822
      goto while_break___5;
    }
    {
#line 823
    *(unknown + i) = rrd_set_to_DNAN();
#line 822
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 825
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 825
    if (! (unkn_cnt > 0)) {
#line 825
      goto while_break___6;
    }
#line 826
    if (unkn_cnt < 512) {
#line 826
      tmp___11 = unkn_cnt;
    } else {
#line 826
      tmp___11 = 512;
    }
    {
#line 826
    tmp___12 = rrd_write(rrd_file_dn, (void const   *)unknown, sizeof(rrd_value_t ) * (unsigned long )tmp___11);
    }
#line 826
    if (tmp___12 < 0L) {
      {
#line 828
      tmp___9 = __errno_location();
#line 828
      tmp___10 = rrd_strerror(*tmp___9);
#line 828
      rrd_set_error((char *)"creating rrd: %s", tmp___10);
      }
#line 829
      return (-1);
    }
#line 832
    unkn_cnt -= 512;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 834
  free((void *)unknown);
#line 835
  rrd_free2(rrd);
#line 836
  tmp___15 = rrd_close(rrd_file_dn);
  }
#line 836
  if (tmp___15 == -1) {
    {
#line 837
    tmp___13 = __errno_location();
#line 837
    tmp___14 = rrd_strerror(*tmp___13);
#line 837
    rrd_set_error((char *)"creating rrd: %s", tmp___14);
    }
#line 838
    return (-1);
  }
  {
#line 841
  rrd_init(& rrd_dn);
#line 842
  rrd_file_dn = rrd_open((char const   */* const  */)file_name, & rrd_dn, 1U);
  }
#line 842
  if ((unsigned long )rrd_file_dn != (unsigned long )((void *)0)) {
    {
#line 844
    rrd_dontneed(rrd_file_dn, & rrd_dn);
#line 846
    rrd_close(rrd_file_dn);
    }
  }
#line 848
  return (0);
}
}
#line 852 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_create.c"
static void rrd_free2(rrd_t *rrd ) 
{ 


  {
  {
#line 855
  free((void *)rrd->live_head);
#line 856
  free((void *)rrd->stat_head);
#line 857
  free((void *)rrd->ds_def);
#line 858
  free((void *)rrd->rra_def);
#line 859
  free((void *)rrd->rra_ptr);
#line 860
  free((void *)rrd->pdp_prep);
#line 861
  free((void *)rrd->cdp_prep);
#line 862
  free((void *)rrd->rrd_value);
  }
#line 863
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 288 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 516
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 209
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 733
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 66 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.h"
int rrdc_disconnect(void) ;
#line 71
int rrdc_flush(char const   *filename ) ;
#line 98
int rrdc_stats_get(rrdc_stats_t **ret_stats ) ;
#line 99
void rrdc_stats_free(rrdc_stats_t *ret_stats ) ;
#line 764 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 58 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static pthread_mutex_t lock  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 59 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static int sd  =    -1;
#line 60 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static FILE *sh  =    (FILE *)((void *)0);
#line 61 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static char *sd_path  =    (char *)((void *)0);
#line 71 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static char const   *get_path(char const   *path , char *resolved_path ) 
{ 
  char const   *ret ;
  int is_unix ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 73
  ret = path;
#line 74
  is_unix = 0;
#line 76
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 77
    return ((char const   *)((void *)0));
  } else
#line 76
  if ((unsigned long )resolved_path == (unsigned long )((void *)0)) {
#line 77
    return ((char const   *)((void *)0));
  } else
#line 76
  if ((unsigned long )sd_path == (unsigned long )((void *)0)) {
#line 77
    return ((char const   *)((void *)0));
  }
#line 79
  if ((int )*sd_path == 47) {
#line 81
    is_unix = 1;
  } else {
    {
#line 79
    tmp = strlen("unix:");
#line 79
    tmp___0 = strncmp("unix:", (char const   *)sd_path, tmp);
    }
#line 79
    if (tmp___0 == 0) {
#line 81
      is_unix = 1;
    }
  }
#line 83
  if (is_unix) {
    {
#line 85
    tmp___1 = realpath((char const   */* __restrict  */)path, (char */* __restrict  */)resolved_path);
#line 85
    ret = (char const   *)tmp___1;
    }
#line 86
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
      {
#line 87
      tmp___2 = __errno_location();
#line 87
      tmp___3 = rrd_strerror(*tmp___2);
#line 87
      rrd_set_error((char *)"realpath(%s): %s", path, tmp___3);
      }
    }
#line 88
    return (ret);
  } else
#line 92
  if ((int const   )*path == 47) {
    {
#line 94
    rrd_set_error((char *)"absolute path names not allowed when talking to a remote daemon");
    }
#line 96
    return ((char const   *)((void *)0));
  }
#line 100
  return (path);
}
}
#line 104 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static void close_connection(void) 
{ 


  {
#line 106
  if ((unsigned long )sh != (unsigned long )((void *)0)) {
    {
#line 108
    fclose(sh);
#line 109
    sh = (FILE *)((void *)0);
#line 110
    sd = -1;
    }
  } else
#line 112
  if (sd >= 0) {
    {
#line 114
    close(sd);
#line 115
    sd = -1;
    }
  }
#line 118
  if ((unsigned long )sd_path != (unsigned long )((void *)0)) {
    {
#line 119
    free((void *)sd_path);
    }
  }
#line 120
  sd_path = (char *)((void *)0);
#line 121
  return;
}
}
#line 123 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static int buffer_add_string(char const   *str , char **buffer_ret , size_t *buffer_size_ret ) 
{ 
  char *buffer ;
  size_t buffer_size ;
  size_t buffer_pos ;
  size_t i ;
  int status ;

  {
#line 132
  buffer = *buffer_ret;
#line 133
  buffer_size = *buffer_size_ret;
#line 134
  buffer_pos = (size_t )0;
#line 136
  i = (size_t )0;
#line 137
  status = -1;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (buffer_pos < buffer_size)) {
#line 138
      goto while_break;
    }
#line 140
    if ((int const   )*(str + i) == 0) {
#line 142
      *(buffer + buffer_pos) = (char )' ';
#line 143
      buffer_pos ++;
#line 144
      status = 0;
#line 145
      goto while_break;
    } else
#line 147
    if ((int const   )*(str + i) == 32) {
#line 147
      goto _L;
    } else
#line 147
    if ((int const   )*(str + i) == 92) {
      _L: /* CIL Label */ 
#line 149
      if (buffer_pos >= buffer_size - 1UL) {
#line 150
        goto while_break;
      }
#line 151
      *(buffer + buffer_pos) = (char )'\\';
#line 152
      buffer_pos ++;
#line 153
      *(buffer + buffer_pos) = (char )*(str + i);
#line 154
      buffer_pos ++;
    } else {
#line 158
      *(buffer + buffer_pos) = (char )*(str + i);
#line 159
      buffer_pos ++;
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if (status != 0) {
#line 165
    return (-1);
  }
#line 167
  *buffer_ret = buffer + buffer_pos;
#line 168
  *buffer_size_ret = buffer_size - buffer_pos;
#line 170
  return (0);
}
}
#line 173 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static int buffer_add_value(char const   *value , char **buffer_ret , size_t *buffer_size_ret ) 
{ 
  char temp[4096] ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 178
  tmp___0 = strncmp(value, "N:", (size_t )2);
  }
#line 178
  if (tmp___0 == 0) {
    {
#line 179
    tmp = time((time_t *)((void *)0));
#line 179
    snprintf((char */* __restrict  */)(temp), sizeof(temp), (char const   */* __restrict  */)"%lu:%s",
             (unsigned long )tmp, value + 2);
    }
  } else {
    {
#line 182
    strncpy((char */* __restrict  */)(temp), (char const   */* __restrict  */)value,
            sizeof(temp));
    }
  }
  {
#line 183
  temp[sizeof(temp) - 1UL] = (char)0;
#line 185
  tmp___1 = buffer_add_string((char const   *)(temp), buffer_ret, buffer_size_ret);
  }
#line 185
  return (tmp___1);
}
}
#line 191 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static int chomp(char *str ) 
{ 
  size_t len ;
  int removed ;

  {
#line 196
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 197
    return (-1);
  }
  {
#line 199
  len = strlen((char const   *)str);
#line 200
  removed = 0;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (len > 0UL) {
#line 201
      if (! ((int )*(str + (len - 1UL)) == 10)) {
#line 201
        if (! ((int )*(str + (len - 1UL)) == 13)) {
#line 201
          goto while_break;
        }
      }
    } else {
#line 201
      goto while_break;
    }
#line 203
    *(str + (len - 1UL)) = (char)0;
#line 204
    len --;
#line 205
    removed ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return (removed);
}
}
#line 211 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static void response_free(rrdc_response_t *res ) 
{ 
  size_t i ;

  {
#line 213
  if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 214
    return;
  }
#line 216
  if ((unsigned long )res->lines != (unsigned long )((void *)0)) {
#line 220
    i = (size_t )0;
    {
#line 220
    while (1) {
      while_continue: /* CIL Label */ ;
#line 220
      if (! (i < res->lines_num)) {
#line 220
        goto while_break;
      }
#line 221
      if ((unsigned long )*(res->lines + i) != (unsigned long )((void *)0)) {
        {
#line 222
        free((void *)*(res->lines + i));
        }
      }
#line 220
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 223
    free((void *)res->lines);
    }
  }
  {
#line 226
  free((void *)res);
  }
#line 227
  return;
}
}
#line 229 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static int response_read(rrdc_response_t **ret_response ) 
{ 
  rrdc_response_t *ret ;
  int status ;
  char buffer[4096] ;
  char *buffer_ptr ;
  size_t i ;
  void *tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 231
  ret = (rrdc_response_t *)((void *)0);
#line 232
  status = 0;
#line 241
  if ((unsigned long )sh == (unsigned long )((void *)0)) {
    {
#line 242
    while (1) {
      while_continue: /* CIL Label */ ;
#line 242
      status = -1;
#line 242
      goto err_out;
#line 242
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 244
  tmp = malloc(sizeof(rrdc_response_t ));
#line 244
  ret = (rrdc_response_t *)tmp;
  }
#line 245
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 246
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 246
      status = -2;
#line 246
      goto err_out;
#line 246
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 247
  memset((void *)ret, 0, sizeof(*ret));
#line 248
  ret->lines = (char **)((void *)0);
#line 249
  ret->lines_num = (size_t )0;
#line 251
  buffer_ptr = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)sh);
  }
#line 252
  if ((unsigned long )buffer_ptr == (unsigned long )((void *)0)) {
    {
#line 253
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 253
      status = -3;
#line 253
      goto err_out;
#line 253
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 255
  chomp(buffer);
#line 257
  tmp___0 = strtol((char const   */* __restrict  */)(buffer), (char **/* __restrict  */)(& ret->message),
                   0);
#line 257
  ret->status = (int )tmp___0;
  }
#line 258
  if ((unsigned long )(buffer) == (unsigned long )ret->message) {
    {
#line 259
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 259
      status = -4;
#line 259
      goto err_out;
#line 259
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 262
  tmp___1 = strspn((char const   *)ret->message, " \t");
#line 262
  ret->message += tmp___1;
  }
#line 264
  if (ret->status <= 0) {
#line 266
    if (ret->status < 0) {
      {
#line 267
      rrd_set_error((char *)"rrdcached: %s", ret->message);
      }
    }
#line 268
    goto out;
  }
  {
#line 271
  tmp___2 = malloc(sizeof(char *) * (unsigned long )ret->status);
#line 271
  ret->lines = (char **)tmp___2;
  }
#line 272
  if ((unsigned long )ret->lines == (unsigned long )((void *)0)) {
    {
#line 273
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 273
      status = -5;
#line 273
      goto err_out;
#line 273
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 275
  memset((void *)ret->lines, 0, sizeof(char *) * (unsigned long )ret->status);
#line 276
  ret->lines_num = (size_t )ret->status;
#line 278
  i = (size_t )0;
  }
  {
#line 278
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 278
    if (! (i < ret->lines_num)) {
#line 278
      goto while_break___4;
    }
    {
#line 280
    buffer_ptr = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)sh);
    }
#line 281
    if ((unsigned long )buffer_ptr == (unsigned long )((void *)0)) {
      {
#line 282
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 282
        status = -6;
#line 282
        goto err_out;
#line 282
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 284
    chomp(buffer);
#line 286
    *(ret->lines + i) = strdup((char const   *)(buffer));
    }
#line 287
    if ((unsigned long )*(ret->lines + i) == (unsigned long )((void *)0)) {
      {
#line 288
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 288
        status = -7;
#line 288
        goto err_out;
#line 288
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 278
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  out: 
  {
#line 292
  *ret_response = ret;
#line 293
  fflush(sh);
  }
#line 294
  return (status);
  err_out: 
  {
#line 297
  response_free(ret);
#line 298
  close_connection();
  }
#line 299
  return (status);
}
}
#line 305 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static int request(char const   *buffer , size_t buffer_size , rrdc_response_t **ret_response ) 
{ 
  int status ;
  rrdc_response_t *res ;
  size_t tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 311
  if ((unsigned long )sh == (unsigned long )((void *)0)) {
#line 312
    return (107);
  }
  {
#line 314
  tmp = fwrite((void const   */* __restrict  */)buffer, buffer_size, (size_t )1, (FILE */* __restrict  */)sh);
#line 314
  status = (int )tmp;
  }
#line 315
  if (status != 1) {
    {
#line 317
    close_connection();
#line 318
    rrd_set_error((char *)"request: socket error (%d) while talking to rrdcached",
                  status);
    }
#line 320
    return (-1);
  }
  {
#line 322
  fflush(sh);
#line 324
  res = (rrdc_response_t *)((void *)0);
#line 325
  status = response_read(& res);
  }
#line 327
  if (status != 0) {
#line 329
    if (status < 0) {
      {
#line 330
      rrd_set_error((char *)"request: internal error while talking to rrdcached");
      }
    }
#line 331
    return (status);
  }
#line 334
  *ret_response = res;
#line 335
  return (0);
}
}
#line 341 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
int rrdc_is_connected(char const   *daemon_addr ) 
{ 
  char *addr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 343
  if (sd < 0) {
#line 344
    return (0);
  } else
#line 345
  if ((unsigned long )daemon_addr == (unsigned long )((void *)0)) {
    {
#line 353
    tmp = getenv("RRDCACHED_ADDRESS");
#line 353
    addr = tmp;
    }
#line 354
    if ((unsigned long )addr != (unsigned long )((void *)0)) {
      {
#line 354
      tmp___0 = strcmp((char const   *)addr, "");
      }
#line 354
      if (tmp___0 != 0) {
#line 355
        return (1);
      } else {
#line 357
        return (0);
      }
    } else {
#line 357
      return (0);
    }
  } else {
    {
#line 359
    tmp___1 = strcmp(daemon_addr, (char const   *)sd_path);
    }
#line 359
    if (tmp___1 == 0) {
#line 360
      return (1);
    } else {
#line 362
      return (0);
    }
  }
}
}
#line 366 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static int rrdc_connect_unix(char const   *path ) 
{ 
  struct sockaddr_un sa ;
  int status ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 371
  if (! ((unsigned long )path != (unsigned long )((void *)0))) {
    {
#line 371
    __assert_fail("path != ((void *)0)", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c",
                  371U, "rrdc_connect_unix");
    }
  }
#line 372
  if (! (sd == -1)) {
    {
#line 372
    __assert_fail("sd == -1", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c",
                  372U, "rrdc_connect_unix");
    }
  }
  {
#line 374
  sd = socket(1, 1, 0);
  }
#line 375
  if (sd < 0) {
    {
#line 377
    tmp = __errno_location();
#line 377
    status = *tmp;
    }
#line 378
    return (status);
  }
  {
#line 381
  memset((void *)(& sa), 0, sizeof(sa));
#line 382
  sa.sun_family = (sa_family_t )1;
#line 383
  strncpy((char */* __restrict  */)(sa.sun_path), (char const   */* __restrict  */)path,
          sizeof(sa.sun_path) - 1UL);
#line 385
  status = connect(sd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sa)),
                   (socklen_t )sizeof(sa));
  }
#line 386
  if (status != 0) {
    {
#line 388
    tmp___0 = __errno_location();
#line 388
    status = *tmp___0;
#line 389
    close_connection();
    }
#line 390
    return (status);
  }
  {
#line 393
  sh = fdopen(sd, "r+");
  }
#line 394
  if ((unsigned long )sh == (unsigned long )((void *)0)) {
    {
#line 396
    tmp___1 = __errno_location();
#line 396
    status = *tmp___1;
#line 397
    close_connection();
    }
#line 398
    return (status);
  }
#line 401
  return (0);
}
}
#line 404 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
static int rrdc_connect_network(char const   *addr_orig ) 
{ 
  struct addrinfo ai_hints ;
  struct addrinfo *ai_res ;
  struct addrinfo *ai_ptr ;
  char addr_copy[1025] ;
  char *addr ;
  char *port ;
  int status ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 413
  if (! ((unsigned long )addr_orig != (unsigned long )((void *)0))) {
    {
#line 413
    __assert_fail("addr_orig != ((void *)0)", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c",
                  413U, "rrdc_connect_network");
    }
  }
#line 414
  if (! (sd == -1)) {
    {
#line 414
    __assert_fail("sd == -1", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c",
                  414U, "rrdc_connect_network");
    }
  }
  {
#line 416
  strncpy((char */* __restrict  */)(addr_copy), (char const   */* __restrict  */)addr_orig,
          sizeof(addr_copy));
#line 417
  addr_copy[sizeof(addr_copy) - 1UL] = (char )'\000';
#line 418
  addr = addr_copy;
#line 421
  memset((void *)(& ai_hints), 0, sizeof(ai_hints));
#line 422
  ai_hints.ai_flags = 0;
#line 424
  ai_hints.ai_flags |= 32;
#line 426
  ai_hints.ai_family = 0;
#line 427
  ai_hints.ai_socktype = 1;
#line 429
  port = (char *)((void *)0);
  }
#line 430
  if ((int )*addr == 91) {
    {
#line 433
    addr ++;
#line 435
    port = strchr((char const   *)addr, ']');
    }
#line 436
    if ((unsigned long )port == (unsigned long )((void *)0)) {
      {
#line 438
      rrd_set_error((char *)"malformed address: %s", addr_orig);
      }
#line 439
      return (-1);
    }
#line 441
    *port = (char)0;
#line 442
    port ++;
#line 444
    if ((int )*port == 58) {
#line 445
      port ++;
    } else
#line 446
    if ((int )*port == 0) {
#line 447
      port = (char *)((void *)0);
    } else {
      {
#line 450
      rrd_set_error((char *)"garbage after address: %s", port);
      }
#line 451
      return (-1);
    }
  } else {
    {
#line 456
    port = rindex((char const   *)addr, ':');
    }
#line 457
    if ((unsigned long )port != (unsigned long )((void *)0)) {
#line 459
      *port = (char)0;
#line 460
      port ++;
    }
  }
#line 464
  ai_res = (struct addrinfo *)((void *)0);
#line 465
  if ((unsigned long )port == (unsigned long )((void *)0)) {
#line 465
    tmp = "42217";
  } else {
#line 465
    tmp = (char const   *)port;
  }
  {
#line 465
  status = getaddrinfo((char const   */* __restrict  */)addr, (char const   */* __restrict  */)tmp,
                       (struct addrinfo  const  */* __restrict  */)(& ai_hints), (struct addrinfo **/* __restrict  */)(& ai_res));
  }
#line 468
  if (status != 0) {
    {
#line 470
    tmp___0 = gai_strerror(status);
    }
#line 470
    if ((unsigned long )port == (unsigned long )((void *)0)) {
#line 470
      tmp___1 = "42217";
    } else {
#line 470
      tmp___1 = (char const   *)port;
    }
    {
#line 470
    rrd_set_error((char *)"failed to resolve address `%s\' (port %s): %s", addr, tmp___1,
                  tmp___0);
    }
#line 473
    return (-1);
  }
#line 476
  ai_ptr = ai_res;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! ((unsigned long )ai_ptr != (unsigned long )((void *)0))) {
#line 476
      goto while_break;
    }
    {
#line 478
    sd = socket(ai_ptr->ai_family, ai_ptr->ai_socktype, ai_ptr->ai_protocol);
    }
#line 479
    if (sd < 0) {
      {
#line 481
      tmp___2 = __errno_location();
#line 481
      status = *tmp___2;
#line 482
      sd = -1;
      }
#line 483
      goto __Cont;
    }
    {
#line 486
    status = connect(sd, (struct sockaddr  const  */* __restrict  */)ai_ptr->ai_addr,
                     ai_ptr->ai_addrlen);
    }
#line 487
    if (status != 0) {
      {
#line 489
      tmp___3 = __errno_location();
#line 489
      status = *tmp___3;
#line 490
      close_connection();
      }
#line 491
      goto __Cont;
    }
    {
#line 494
    sh = fdopen(sd, "r+");
    }
#line 495
    if ((unsigned long )sh == (unsigned long )((void *)0)) {
      {
#line 497
      tmp___4 = __errno_location();
#line 497
      status = *tmp___4;
#line 498
      close_connection();
      }
#line 499
      goto __Cont;
    }
#line 502
    if (! (status == 0)) {
      {
#line 502
      __assert_fail("status == 0", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c",
                    502U, "rrdc_connect_network");
      }
    }
#line 503
    goto while_break;
    __Cont: /* CIL Label */ 
#line 476
    ai_ptr = ai_ptr->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 506
  freeaddrinfo(ai_res);
  }
#line 508
  return (status);
}
}
#line 511 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
int rrdc_connect(char const   *addr ) 
{ 
  int status ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *err ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 513
  status = 0;
#line 515
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    {
#line 516
    tmp = getenv("RRDCACHED_ADDRESS");
#line 516
    addr = (char const   *)tmp;
    }
  }
#line 519
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 520
    addr = (char const   *)((void *)0);
#line 521
    return (0);
  } else {
    {
#line 519
    tmp___0 = strcmp(addr, "");
    }
#line 519
    if (tmp___0 == 0) {
#line 520
      addr = (char const   *)((void *)0);
#line 521
      return (0);
    }
  }
  {
#line 524
  pthread_mutex_lock(& lock);
  }
#line 526
  if (sd >= 0) {
#line 526
    if ((unsigned long )sd_path != (unsigned long )((void *)0)) {
      {
#line 526
      tmp___1 = strcmp(addr, (char const   *)sd_path);
      }
#line 526
      if (tmp___1 == 0) {
        {
#line 529
        pthread_mutex_unlock(& lock);
        }
#line 530
        return (0);
      } else {
        {
#line 534
        close_connection();
        }
      }
    } else {
      {
#line 534
      close_connection();
      }
    }
  } else {
    {
#line 534
    close_connection();
    }
  }
  {
#line 537
  rrd_clear_error();
#line 538
  tmp___3 = strlen("unix:");
#line 538
  tmp___4 = strncmp("unix:", addr, tmp___3);
  }
#line 538
  if (tmp___4 == 0) {
    {
#line 539
    tmp___2 = strlen("unix:");
#line 539
    status = rrdc_connect_unix(addr + tmp___2);
    }
  } else
#line 540
  if ((int const   )*(addr + 0) == 47) {
    {
#line 541
    status = rrdc_connect_unix(addr);
    }
  } else {
    {
#line 543
    status = rrdc_connect_network(addr);
    }
  }
#line 545
  if (status == 0) {
#line 545
    if (sd >= 0) {
      {
#line 546
      sd_path = strdup(addr);
      }
    } else {
#line 545
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 549
    tmp___8 = rrd_test_error();
    }
#line 549
    if (tmp___8) {
      {
#line 549
      tmp___6 = rrd_get_error();
#line 549
      tmp___7 = (char const   *)tmp___6;
      }
    } else {
#line 549
      tmp___7 = "Internal error";
    }
    {
#line 549
    err = (char *)tmp___7;
#line 552
    err = strdup((char const   *)err);
    }
#line 553
    if (status < 0) {
#line 553
      if (err) {
#line 553
        tmp___9 = (char const   *)err;
      } else {
#line 553
        tmp___9 = "Internal error";
      }
#line 553
      tmp___11 = tmp___9;
    } else {
      {
#line 553
      tmp___10 = rrd_strerror(status);
#line 553
      tmp___11 = tmp___10;
      }
    }
    {
#line 553
    rrd_set_error((char *)"Unable to connect to rrdcached: %s", tmp___11);
    }
#line 557
    if ((unsigned long )err != (unsigned long )((void *)0)) {
      {
#line 558
      free((void *)err);
      }
    }
  }
  {
#line 561
  pthread_mutex_unlock(& lock);
  }
#line 562
  return (status);
}
}
#line 565 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
int rrdc_disconnect(void) 
{ 


  {
  {
#line 567
  pthread_mutex_lock(& lock);
#line 569
  close_connection();
#line 571
  pthread_mutex_unlock(& lock);
  }
#line 573
  return (0);
}
}
#line 576 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
int rrdc_update(char const   *filename , int values_num , char const   * const  *values ) 
{ 
  char buffer[4096] ;
  char *buffer_ptr ;
  size_t buffer_free ;
  size_t buffer_size ;
  rrdc_response_t *res ;
  int status ;
  int i ;
  char file_path[4096] ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 588
  memset((void *)(buffer), 0, sizeof(buffer));
#line 589
  buffer_ptr = & buffer[0];
#line 590
  buffer_free = sizeof(buffer);
#line 592
  status = buffer_add_string("update", & buffer_ptr, & buffer_free);
  }
#line 593
  if (status != 0) {
#line 594
    return (105);
  }
  {
#line 596
  pthread_mutex_lock(& lock);
#line 597
  filename = get_path(filename, file_path);
  }
#line 598
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 600
    pthread_mutex_unlock(& lock);
    }
#line 601
    return (-1);
  }
  {
#line 604
  status = buffer_add_string(filename, & buffer_ptr, & buffer_free);
  }
#line 605
  if (status != 0) {
    {
#line 607
    pthread_mutex_unlock(& lock);
    }
#line 608
    return (105);
  }
#line 611
  i = 0;
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! (i < values_num)) {
#line 611
      goto while_break;
    }
    {
#line 613
    status = buffer_add_value((char const   *)*(values + i), & buffer_ptr, & buffer_free);
    }
#line 614
    if (status != 0) {
      {
#line 616
      pthread_mutex_unlock(& lock);
      }
#line 617
      return (105);
    }
#line 611
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  if (! (buffer_free < sizeof(buffer))) {
    {
#line 621
    __assert_fail("buffer_free < sizeof (buffer)", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c",
                  621U, "rrdc_update");
    }
  }
#line 622
  buffer_size = sizeof(buffer) - buffer_free;
#line 623
  if (! ((int )buffer[buffer_size - 1UL] == 32)) {
    {
#line 623
    __assert_fail("buffer[buffer_size - 1] == \' \'", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c",
                  623U, "rrdc_update");
    }
  }
  {
#line 624
  buffer[buffer_size - 1UL] = (char )'\n';
#line 626
  res = (rrdc_response_t *)((void *)0);
#line 627
  status = request((char const   *)(buffer), buffer_size, & res);
#line 628
  pthread_mutex_unlock(& lock);
  }
#line 630
  if (status != 0) {
#line 631
    return (status);
  }
  {
#line 633
  status = res->status;
#line 634
  response_free(res);
  }
#line 636
  return (status);
}
}
#line 639 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
int rrdc_flush(char const   *filename ) 
{ 
  char buffer[4096] ;
  char *buffer_ptr ;
  size_t buffer_free ;
  size_t buffer_size ;
  rrdc_response_t *res ;
  int status ;
  char file_path[4096] ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 649
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 650
    return (-1);
  }
  {
#line 652
  memset((void *)(buffer), 0, sizeof(buffer));
#line 653
  buffer_ptr = & buffer[0];
#line 654
  buffer_free = sizeof(buffer);
#line 656
  status = buffer_add_string("flush", & buffer_ptr, & buffer_free);
  }
#line 657
  if (status != 0) {
#line 658
    return (105);
  }
  {
#line 660
  pthread_mutex_lock(& lock);
#line 661
  filename = get_path(filename, file_path);
  }
#line 662
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
#line 664
    pthread_mutex_unlock(& lock);
    }
#line 665
    return (-1);
  }
  {
#line 668
  status = buffer_add_string(filename, & buffer_ptr, & buffer_free);
  }
#line 669
  if (status != 0) {
    {
#line 671
    pthread_mutex_unlock(& lock);
    }
#line 672
    return (105);
  }
#line 675
  if (! (buffer_free < sizeof(buffer))) {
    {
#line 675
    __assert_fail("buffer_free < sizeof (buffer)", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c",
                  675U, "rrdc_flush");
    }
  }
#line 676
  buffer_size = sizeof(buffer) - buffer_free;
#line 677
  if (! ((int )buffer[buffer_size - 1UL] == 32)) {
    {
#line 677
    __assert_fail("buffer[buffer_size - 1] == \' \'", "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c",
                  677U, "rrdc_flush");
    }
  }
  {
#line 678
  buffer[buffer_size - 1UL] = (char )'\n';
#line 680
  res = (rrdc_response_t *)((void *)0);
#line 681
  status = request((char const   *)(buffer), buffer_size, & res);
#line 682
  pthread_mutex_unlock(& lock);
  }
#line 684
  if (status != 0) {
#line 685
    return (status);
  }
  {
#line 687
  status = res->status;
#line 688
  response_free(res);
  }
#line 690
  return (status);
}
}
#line 697 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
int rrdc_flush_if_daemon(char const   *opt_daemon , char const   *filename ) 
{ 
  int status ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 699
  status = 0;
#line 701
  rrdc_connect(opt_daemon);
#line 703
  tmp___1 = rrdc_is_connected(opt_daemon);
  }
#line 703
  if (tmp___1) {
    {
#line 705
    rrd_clear_error();
#line 706
    status = rrdc_flush(filename);
    }
#line 708
    if (status != 0) {
      {
#line 708
      tmp___0 = rrd_test_error();
      }
#line 708
      if (! tmp___0) {
#line 710
        if (status > 0) {
          {
#line 712
          tmp = rrd_strerror(status);
#line 712
          rrd_set_error((char *)"rrdc_flush (%s) failed: %s", filename, tmp);
          }
        } else
#line 715
        if (status < 0) {
          {
#line 717
          rrd_set_error((char *)"rrdc_flush (%s) failed with status %i.", filename,
                        status);
          }
        }
      }
    }
  }
#line 723
  return (status);
}
}
#line 727 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
int rrdc_stats_get(rrdc_stats_t **ret_stats ) 
{ 
  rrdc_stats_t *head ;
  rrdc_stats_t *tail ;
  rrdc_response_t *res ;
  int status ;
  size_t i ;
  size_t tmp ;
  char *key ;
  char *value ;
  char *endptr ;
  rrdc_stats_t *s ;
  void *tmp___0 ;
  char *tmp___1 ;
  long long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 747
  res = (rrdc_response_t *)((void *)0);
#line 748
  pthread_mutex_lock(& lock);
#line 749
  tmp = strlen("STATS\n");
#line 749
  status = request("STATS\n", tmp, & res);
#line 750
  pthread_mutex_unlock(& lock);
  }
#line 752
  if (status != 0) {
#line 753
    return (status);
  }
#line 755
  if (res->status <= 0) {
    {
#line 757
    response_free(res);
    }
#line 758
    return (5);
  }
#line 761
  head = (rrdc_stats_t *)((void *)0);
#line 762
  tail = (rrdc_stats_t *)((void *)0);
#line 763
  i = (size_t )0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (! (i < res->lines_num)) {
#line 763
      goto while_break;
    }
    {
#line 770
    key = *(res->lines + i);
#line 771
    value = strchr((char const   *)key, ':');
    }
#line 772
    if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 773
      goto __Cont;
    }
#line 774
    *value = (char)0;
#line 775
    value ++;
    {
#line 777
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 777
      if (! ((int )*(value + 0) == 32)) {
#line 777
        if (! ((int )*(value + 0) == 9)) {
#line 777
          goto while_break___0;
        }
      }
#line 778
      value ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 780
    tmp___0 = malloc(sizeof(rrdc_stats_t ));
#line 780
    s = (rrdc_stats_t *)tmp___0;
    }
#line 781
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 782
      goto __Cont;
    }
    {
#line 783
    memset((void *)s, 0, sizeof(*s));
#line 785
    tmp___1 = strdup((char const   *)key);
#line 785
    s->name = (char const   *)tmp___1;
#line 787
    endptr = (char *)((void *)0);
#line 788
    tmp___9 = strcmp("QueueLength", (char const   *)key);
    }
#line 788
    if (tmp___9 == 0) {
      {
#line 792
      s->type = (uint16_t )1;
#line 793
      s->value.gauge = strtod((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr));
      }
    } else {
      {
#line 788
      tmp___10 = strcmp("TreeDepth", (char const   *)key);
      }
#line 788
      if (tmp___10 == 0) {
        {
#line 792
        s->type = (uint16_t )1;
#line 793
        s->value.gauge = strtod((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr));
        }
      } else {
        {
#line 788
        tmp___11 = strcmp("TreeNodesNumber", (char const   *)key);
        }
#line 788
        if (tmp___11 == 0) {
          {
#line 792
          s->type = (uint16_t )1;
#line 793
          s->value.gauge = strtod((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr));
          }
        } else {
          {
#line 795
          tmp___3 = strcmp("DataSetsWritten", (char const   *)key);
          }
#line 795
          if (tmp___3 == 0) {
            {
#line 802
            s->type = (uint16_t )2;
#line 803
            tmp___2 = strtoll((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                              0);
#line 803
            s->value.counter = (uint64_t )tmp___2;
            }
          } else {
            {
#line 795
            tmp___4 = strcmp("FlushesReceived", (char const   *)key);
            }
#line 795
            if (tmp___4 == 0) {
              {
#line 802
              s->type = (uint16_t )2;
#line 803
              tmp___2 = strtoll((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                                0);
#line 803
              s->value.counter = (uint64_t )tmp___2;
              }
            } else {
              {
#line 795
              tmp___5 = strcmp("JournalBytes", (char const   *)key);
              }
#line 795
              if (tmp___5 == 0) {
                {
#line 802
                s->type = (uint16_t )2;
#line 803
                tmp___2 = strtoll((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                                  0);
#line 803
                s->value.counter = (uint64_t )tmp___2;
                }
              } else {
                {
#line 795
                tmp___6 = strcmp("JournalRotate", (char const   *)key);
                }
#line 795
                if (tmp___6 == 0) {
                  {
#line 802
                  s->type = (uint16_t )2;
#line 803
                  tmp___2 = strtoll((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                                    0);
#line 803
                  s->value.counter = (uint64_t )tmp___2;
                  }
                } else {
                  {
#line 795
                  tmp___7 = strcmp("UpdatesReceived", (char const   *)key);
                  }
#line 795
                  if (tmp___7 == 0) {
                    {
#line 802
                    s->type = (uint16_t )2;
#line 803
                    tmp___2 = strtoll((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                                      0);
#line 803
                    s->value.counter = (uint64_t )tmp___2;
                    }
                  } else {
                    {
#line 795
                    tmp___8 = strcmp("UpdatesWritten", (char const   *)key);
                    }
#line 795
                    if (tmp___8 == 0) {
                      {
#line 802
                      s->type = (uint16_t )2;
#line 803
                      tmp___2 = strtoll((char const   */* __restrict  */)value, (char **/* __restrict  */)(& endptr),
                                        0);
#line 803
                      s->value.counter = (uint64_t )tmp___2;
                      }
                    } else {
                      {
#line 807
                      free((void *)s);
                      }
#line 808
                      goto __Cont;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 812
    if ((unsigned long )endptr == (unsigned long )value) {
      {
#line 814
      free((void *)s);
      }
#line 815
      goto __Cont;
    }
#line 818
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 820
      head = s;
#line 821
      tail = s;
#line 822
      s->next = (struct rrdc_stats_s *)((void *)0);
    } else {
#line 826
      tail->next = s;
#line 827
      tail = s;
    }
    __Cont: /* CIL Label */ 
#line 763
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 831
  response_free(res);
  }
#line 833
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 835
    return (71);
  }
#line 840
  *ret_stats = head;
#line 841
  return (0);
}
}
#line 844 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_client.c"
void rrdc_stats_free(rrdc_stats_t *ret_stats ) 
{ 
  rrdc_stats_t *this ;
  rrdc_stats_t *next ;

  {
#line 848
  this = ret_stats;
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 849
      goto while_break;
    }
#line 853
    next = this->next;
#line 855
    if ((unsigned long )this->name != (unsigned long )((void *)0)) {
      {
#line 857
      free((void *)((char *)this->name));
#line 858
      this->name = (char const   *)((void *)0);
      }
    }
    {
#line 860
    free((void *)this);
#line 862
    this = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 864
  return;
}
}
#line 102 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/fnv.h"
Fnv32_t fnv_32_buf(void const   *buf , size_t len , Fnv32_t hval ) ;
#line 107
Fnv32_t fnv_32_str(char const   *str , Fnv32_t hval ) ;
#line 88 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/hash_32.c"
Fnv32_t fnv_32_buf(void const   *buf , size_t len , Fnv32_t hval ) 
{ 
  unsigned char const   *bp ;
  unsigned char const   *be ;
  unsigned char const   *tmp ;

  {
#line 93
  bp = (unsigned char const   *)buf;
#line 94
  be = bp + len;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! ((unsigned long )bp < (unsigned long )be)) {
#line 99
      goto while_break;
    }
#line 102
    hval *= 16777619UL;
#line 105
    tmp = bp;
#line 105
    bp ++;
#line 105
    hval ^= (Fnv32_t )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  return (hval);
}
}
#line 129 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/hash_32.c"
Fnv32_t fnv_32_str(char const   *str , Fnv32_t hval ) 
{ 
  unsigned char const   *s ;
  unsigned char const   *tmp ;

  {
#line 133
  s = (unsigned char const   *)str;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! *s) {
#line 138
      goto while_break;
    }
#line 141
    hval *= 16777619UL;
#line 144
    tmp = s;
#line 144
    s ++;
#line 144
    hval ^= (Fnv32_t )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (hval);
}
}
#line 152 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/hash_32.c"
unsigned long FnvHash(char const   *str ) 
{ 
  Fnv32_t tmp ;

  {
  {
#line 155
  tmp = fnv_32_str(str, (Fnv32_t )2166136261U);
  }
#line 155
  return (tmp);
}
}
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 1609 "/usr/include/libpng12/png.h"
extern png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                          void (*error_fn)(png_structp  , png_const_charp  ) ,
                                          void (*warn_fn)(png_structp  , png_const_charp  ) ) ;
#line 1659
extern png_infop png_create_info_struct(png_structp png_ptr ) ;
#line 1682
extern void png_read_info(png_structp png_ptr , png_infop info_ptr ) ;
#line 1905
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 2056
extern void png_init_io(png_structp png_ptr , png_FILE_p fp ) ;
#line 2295
extern png_uint_32 png_get_image_width(png_structp png_ptr , png_infop info_ptr ) ;
#line 2299
extern png_uint_32 png_get_image_height(png_structp png_ptr , png_infop info_ptr ) ;
#line 80 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.h"
int PngSize(FILE *fd , long *width , long *height ) ;
#line 10 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/pngsize.c"
int PngSize(FILE *fd , long *width , long *height ) 
{ 
  png_structp png_read_ptr ;
  png_structp tmp ;
  png_infop info_ptr ;
  png_infop tmp___0 ;
  int tmp___1 ;
  png_uint_32 tmp___2 ;
  png_uint_32 tmp___3 ;
  char *__cil_tmp11 ;

  {
  {
#line 15
  tmp = png_create_read_struct("1.2.51", (void *)0, (void (*)(png_structp  , png_const_charp  ))((void *)0),
                               (void (*)(png_structp  , png_const_charp  ))((void *)0));
#line 15
  png_read_ptr = tmp;
#line 22
  tmp___0 = png_create_info_struct(png_read_ptr);
#line 22
  info_ptr = tmp___0;
#line 24
  *width = 0L;
#line 25
  *height = 0L;
#line 41
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(png_read_ptr->jmpbuf));
  }
#line 41
  if (tmp___1) {
    {
#line 42
    png_destroy_read_struct(& png_read_ptr, & info_ptr, (png_infopp )((void *)0));
    }
#line 43
    return (0);
  }
  {
#line 46
  png_init_io(png_read_ptr, fd);
#line 47
  png_read_info(png_read_ptr, info_ptr);
#line 48
  tmp___2 = png_get_image_width(png_read_ptr, info_ptr);
#line 48
  *width = (long )tmp___2;
#line 49
  tmp___3 = png_get_image_height(png_read_ptr, info_ptr);
#line 49
  *height = (long )tmp___3;
#line 51
  png_destroy_read_struct(& png_read_ptr, & info_ptr, (png_infopp )((void *)0));
  }
#line 52
  if (*width > 0L) {
#line 52
    if (*height > 0L) {
#line 53
      return (1);
    } else {
#line 55
      return (0);
    }
  } else {
#line 55
    return (0);
  }
}
}
#line 504 "/usr/include/cairo/cairo.h"
extern void cairo_save(cairo_t *cr ) ;
#line 507
extern void cairo_restore(cairo_t *cr ) ;
#line 650
extern void cairo_set_source_rgba(cairo_t *cr , double red , double green , double blue ,
                                  double alpha ) ;
#line 753
extern void cairo_set_line_width(cairo_t *cr , double width ) ;
#line 801
extern void cairo_set_dash(cairo_t *cr , double const   *dashes , int num_dashes ,
                           double offset ) ;
#line 810
extern void cairo_translate(cairo_t *cr , double tx , double ty ) ;
#line 816
extern void cairo_rotate(cairo_t *cr , double angle ) ;
#line 830
extern void cairo_user_to_device(cairo_t *cr , double *x , double *y ) ;
#line 833
extern void cairo_user_to_device_distance(cairo_t *cr , double *dx , double *dy ) ;
#line 836
extern void cairo_device_to_user(cairo_t *cr , double *x , double *y ) ;
#line 843
extern void cairo_new_path(cairo_t *cr ) ;
#line 846
extern void cairo_move_to(cairo_t *cr , double x , double y ) ;
#line 852
extern void cairo_line_to(cairo_t *cr , double x , double y ) ;
#line 903
extern void cairo_close_path(cairo_t *cr ) ;
#line 929
extern void cairo_stroke(cairo_t *cr ) ;
#line 935
extern void cairo_fill(cairo_t *cr ) ;
#line 1927
extern double cairo_get_line_width(cairo_t *cr ) ;
#line 120 "/usr/include/glib-2.0/glib/gconvert.h"
extern gchar *g_locale_to_utf8(gchar const   *opsysstring , gssize len , gsize *bytes_read ,
                               gsize *bytes_written , GError **error )  __attribute__((__malloc__)) ;
#line 68 "/usr/include/glib-2.0/glib/gmem.h"
extern void g_free(gpointer mem ) ;
#line 35 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
#pragma GCC diagnostic push
#line 35
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 35
#pragma GCC diagnostic pop
#line 36
#pragma GCC diagnostic push
#line 36
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 36
#pragma GCC diagnostic pop
#line 37
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 37
#pragma GCC diagnostic pop
#line 38
#pragma GCC diagnostic push
#line 38
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 38
#pragma GCC diagnostic pop
#line 39
#pragma GCC diagnostic push
#line 39
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 39
#pragma GCC diagnostic pop
#line 40
#pragma GCC diagnostic push
#line 40
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 40
#pragma GCC diagnostic pop
#line 41
#pragma GCC diagnostic push
#line 41
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 41
#pragma GCC diagnostic pop
#line 42
#pragma GCC diagnostic push
#line 42
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 42
#pragma GCC diagnostic pop
#line 43
#pragma GCC diagnostic push
#line 43
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 43
#pragma GCC diagnostic pop
#line 44
#pragma GCC diagnostic push
#line 44
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 44
#pragma GCC diagnostic pop
#line 45
#pragma GCC diagnostic push
#line 45
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 45
#pragma GCC diagnostic pop
#line 46
#pragma GCC diagnostic push
#line 46
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 46
#pragma GCC diagnostic pop
#line 47
#pragma GCC diagnostic push
#line 47
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 47
#pragma GCC diagnostic pop
#line 48
#pragma GCC diagnostic push
#line 48
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 48
#pragma GCC diagnostic pop
#line 49
#pragma GCC diagnostic push
#line 49
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 49
#pragma GCC diagnostic pop
#line 50
#pragma GCC diagnostic push
#line 50
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 50
#pragma GCC diagnostic pop
#line 51
#pragma GCC diagnostic push
#line 51
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 51
#pragma GCC diagnostic pop
#line 52
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 52
#pragma GCC diagnostic pop
#line 53
#pragma GCC diagnostic push
#line 53
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 53
#pragma GCC diagnostic pop
#line 54
#pragma GCC diagnostic push
#line 54
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 54
#pragma GCC diagnostic pop
#line 55
#pragma GCC diagnostic push
#line 55
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 55
#pragma GCC diagnostic pop
#line 56
#pragma GCC diagnostic push
#line 56
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 56
#pragma GCC diagnostic pop
#line 57
#pragma GCC diagnostic push
#line 57
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 57
#pragma GCC diagnostic pop
#line 58
#pragma GCC diagnostic push
#line 58
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 58
#pragma GCC diagnostic pop
#line 59
#pragma GCC diagnostic push
#line 59
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 59
#pragma GCC diagnostic pop
#line 60
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 60
#pragma GCC diagnostic pop
#line 61
#pragma GCC diagnostic push
#line 61
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 61
#pragma GCC diagnostic pop
#line 62
#pragma GCC diagnostic push
#line 62
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 62
#pragma GCC diagnostic pop
#line 63
#pragma GCC diagnostic push
#line 63
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 63
#pragma GCC diagnostic pop
#line 64
#pragma GCC diagnostic push
#line 64
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 64
#pragma GCC diagnostic pop
#line 65
#pragma GCC diagnostic push
#line 65
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 65
#pragma GCC diagnostic pop
#line 66
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 66
#pragma GCC diagnostic pop
#line 67
#pragma GCC diagnostic push
#line 67
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 67
#pragma GCC diagnostic pop
#line 68
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 68
#pragma GCC diagnostic pop
#line 69
#pragma GCC diagnostic push
#line 69
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 69
#pragma GCC diagnostic pop
#line 70
#pragma GCC diagnostic push
#line 70
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 70
#pragma GCC diagnostic pop
#line 71
#pragma GCC diagnostic push
#line 71
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 71
#pragma GCC diagnostic pop
#line 72
#pragma GCC diagnostic push
#line 72
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 72
#pragma GCC diagnostic pop
#line 73
#pragma GCC diagnostic push
#line 73
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 73
#pragma GCC diagnostic pop
#line 74
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 74
#pragma GCC diagnostic pop
#line 75
#pragma GCC diagnostic push
#line 75
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 75
#pragma GCC diagnostic pop
#line 76
#pragma GCC diagnostic push
#line 76
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 76
#pragma GCC diagnostic pop
#line 77
#pragma GCC diagnostic push
#line 77
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 77
#pragma GCC diagnostic pop
#line 78
#pragma GCC diagnostic push
#line 78
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 78
#pragma GCC diagnostic pop
#line 79
#pragma GCC diagnostic push
#line 79
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 79
#pragma GCC diagnostic pop
#line 80
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 80
#pragma GCC diagnostic pop
#line 81
#pragma GCC diagnostic push
#line 81
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 81
#pragma GCC diagnostic pop
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
#pragma GCC diagnostic push
#line 24
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 24
#pragma GCC diagnostic pop
#line 25
#pragma GCC diagnostic push
#line 25
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 25
#pragma GCC diagnostic pop
#line 26
#pragma GCC diagnostic push
#line 26
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 26
#pragma GCC diagnostic pop
#line 27
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 27
#pragma GCC diagnostic pop
#line 222 "/usr/include/pango-1.0/pango/pango-font.h"
extern gboolean pango_font_description_equal(PangoFontDescription const   *desc1 ,
                                             PangoFontDescription const   *desc2 )  __attribute__((__pure__)) ;
#line 57 "/usr/include/pango-1.0/pango/pango-tabs.h"
extern PangoTabArray *pango_tab_array_new(gint initial_size , gboolean positions_in_pixels ) ;
#line 66
extern void pango_tab_array_free(PangoTabArray *tab_array ) ;
#line 70
extern void pango_tab_array_set_tab(PangoTabArray *tab_array , gint tab_index , PangoTabAlign alignment ,
                                    gint location ) ;
#line 144 "/usr/include/pango-1.0/pango/pango-layout.h"
extern void pango_layout_set_text(PangoLayout *layout , char const   *text , int length ) ;
#line 151
extern void pango_layout_set_markup(PangoLayout *layout , char const   *markup , int length ) ;
#line 161
extern void pango_layout_set_font_description(PangoLayout *layout , PangoFontDescription const   *desc ) ;
#line 164
extern PangoFontDescription const   *pango_layout_get_font_description(PangoLayout *layout ) ;
#line 192
extern void pango_layout_set_tabs(PangoLayout *layout , PangoTabArray *tabs ) ;
#line 245
extern void pango_layout_get_pixel_extents(PangoLayout *layout , PangoRectangle *ink_rect ,
                                           PangoRectangle *logical_rect ) ;
#line 127 "/usr/include/pango-1.0/pango/pangocairo.h"
extern void pango_cairo_update_layout(cairo_t *cr , PangoLayout *layout ) ;
#line 141
extern void pango_cairo_show_layout(cairo_t *cr , PangoLayout *layout ) ;
#line 416 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
void gfx_line(image_desc_t *im , double X0 , double Y0 , double X1 , double Y1 , double width ,
              gfx_color_t color ) ;
#line 425
void gfx_dashed_line(image_desc_t *im , double X0 , double Y0 , double X1 , double Y1 ,
                     double width , gfx_color_t color , double dash_on , double dash_off ) ;
#line 437
void gfx_new_area(image_desc_t *im , double X0 , double Y0 , double X1 , double Y1 ,
                  double X2 , double Y2 , gfx_color_t color ) ;
#line 448
void gfx_add_point(image_desc_t *im , double x , double y ) ;
#line 454
void gfx_close_path(image_desc_t *im ) ;
#line 459
void gfx_text(image_desc_t *im , double x , double y , gfx_color_t color , PangoFontDescription *font_desc ,
              double tabwidth , double angle , enum gfx_h_align_en h_align , enum gfx_v_align_en v_align ,
              char const   *text ) ;
#line 472
double gfx_get_text_width(image_desc_t *im , double start , PangoFontDescription *font_desc ,
                          double tabwidth , char *text ) ;
#line 481
struct gfx_color_t gfx_hex_to_col(unsigned long color ) ;
#line 484
void gfx_line_fit(image_desc_t *im , double *x , double *y ) ;
#line 489
void gfx_area_fit(image_desc_t *im , double *x , double *y ) ;
#line 25 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
void gfx_line(image_desc_t *im , double X0 , double Y0 , double X1 , double Y1 , double width ,
              gfx_color_t color ) 
{ 


  {
  {
#line 34
  gfx_dashed_line(im, X0, Y0, X1, Y1, width, color, (double )0, (double )0);
  }
#line 35
  return;
}
}
#line 37 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
void gfx_dashed_line(image_desc_t *im , double X0 , double Y0 , double X1 , double Y1 ,
                     double width , gfx_color_t color , double dash_on , double dash_off ) 
{ 
  cairo_t *cr ;
  double dashes[2] ;
  double x ;
  double y ;
  void *__cil_tmp14 ;

  {
  {
#line 48
  cr = im->cr;
#line 50
  x = (double )0;
#line 51
  y = (double )0;
#line 53
  dashes[0] = dash_on;
#line 54
  dashes[1] = dash_off;
#line 56
  cairo_save(cr);
#line 57
  cairo_new_path(cr);
#line 58
  cairo_set_line_width(cr, width);
#line 59
  gfx_line_fit(im, & x, & y);
#line 60
  gfx_line_fit(im, & X0, & Y0);
#line 61
  cairo_move_to(cr, X0, Y0);
#line 62
  gfx_line_fit(im, & X1, & Y1);
#line 63
  cairo_line_to(cr, X1, Y1);
  }
#line 64
  if (dash_on > (double )0) {
    {
#line 65
    cairo_set_dash(cr, (double const   *)(dashes), 2, x);
    }
  } else
#line 64
  if (dash_off > (double )0) {
    {
#line 65
    cairo_set_dash(cr, (double const   *)(dashes), 2, x);
    }
  }
  {
#line 66
  cairo_set_source_rgba(cr, color.red, color.green, color.blue, color.alpha);
#line 68
  cairo_stroke(cr);
#line 69
  cairo_restore(cr);
  }
#line 70
  return;
}
}
#line 73 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
void gfx_new_area(image_desc_t *im , double X0 , double Y0 , double X1 , double Y1 ,
                  double X2 , double Y2 , gfx_color_t color ) 
{ 
  cairo_t *cr ;

  {
  {
#line 83
  cr = im->cr;
#line 85
  cairo_new_path(cr);
#line 86
  gfx_area_fit(im, & X0, & Y0);
#line 87
  cairo_move_to(cr, X0, Y0);
#line 88
  gfx_area_fit(im, & X1, & Y1);
#line 89
  cairo_line_to(cr, X1, Y1);
#line 90
  gfx_area_fit(im, & X2, & Y2);
#line 91
  cairo_line_to(cr, X2, Y2);
#line 92
  cairo_set_source_rgba(cr, color.red, color.green, color.blue, color.alpha);
  }
#line 94
  return;
}
}
#line 97 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
void gfx_add_point(image_desc_t *im , double x , double y ) 
{ 
  cairo_t *cr ;

  {
  {
#line 102
  cr = im->cr;
#line 104
  gfx_area_fit(im, & x, & y);
#line 105
  cairo_line_to(cr, x, y);
  }
#line 106
  return;
}
}
#line 108 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
void gfx_close_path(image_desc_t *im ) 
{ 
  cairo_t *cr ;

  {
  {
#line 111
  cr = im->cr;
#line 113
  cairo_close_path(cr);
#line 114
  cairo_fill(cr);
  }
#line 115
  return;
}
}
#line 130
static PangoLayout *gfx_prep_text(image_desc_t *im , double x , gfx_color_t color ,
                                  PangoFontDescription *font_desc , double tabwidth ,
                                  char const   *text ) ;
#line 130 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
static double last_tabwidth  =    (double )-1;
#line 118 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
static PangoLayout *gfx_prep_text(image_desc_t *im , double x , gfx_color_t color ,
                                  PangoFontDescription *font_desc , double tabwidth ,
                                  char const   *text ) 
{ 
  PangoLayout *layout ;
  PangoFontDescription const   *pfd ;
  cairo_t *cr ;
  long i ;
  long tab_count ;
  size_t tmp ;
  long tab_shift ;
  double tmp___0 ;
  int border ;
  gchar *utf8_text ;
  PangoTabArray *tab_array ;
  gboolean tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 126
  layout = im->layout;
#line 128
  cr = im->cr;
#line 138
  tmp = strlen(text);
#line 138
  tab_count = (long )tmp;
#line 139
  tmp___0 = fmod(x, tabwidth);
#line 139
  tab_shift = (long )tmp___0;
#line 140
  border = (int )(im->text_prop[4].size * 2.0);
  }
#line 144
  if (last_tabwidth < (double )0) {
#line 144
    goto _L;
  } else
#line 144
  if (last_tabwidth != tabwidth) {
    _L: /* CIL Label */ 
    {
#line 147
    last_tabwidth = tabwidth;
#line 148
    tab_array = pango_tab_array_new((gint )tab_count, 1);
#line 149
    i = 1L;
    }
    {
#line 149
    while (1) {
      while_continue: /* CIL Label */ ;
#line 149
      if (! (i <= tab_count)) {
#line 149
        goto while_break;
      }
      {
#line 150
      pango_tab_array_set_tab(tab_array, (gint )i, (PangoTabAlign )0, (gint )((tabwidth * (double )i - (double )tab_shift) + (double )border));
#line 149
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 154
    pango_layout_set_tabs(layout, tab_array);
#line 155
    pango_tab_array_free(tab_array);
    }
  }
  {
#line 157
  pfd = pango_layout_get_font_description(layout);
  }
#line 159
  if (! pfd) {
    {
#line 160
    pango_layout_set_font_description(layout, (PangoFontDescription const   *)font_desc);
    }
  } else {
    {
#line 159
    tmp___1 = pango_font_description_equal(pfd, (PangoFontDescription const   *)font_desc);
    }
#line 159
    if (! tmp___1) {
      {
#line 160
      pango_layout_set_font_description(layout, (PangoFontDescription const   *)font_desc);
      }
    }
  }
  {
#line 164
  cairo_new_path(cr);
#line 165
  cairo_set_source_rgba(cr, color.red, color.green, color.blue, color.alpha);
#line 176
  utf8_text = g_locale_to_utf8(text, (gssize )-1, (gsize *)((void *)0), (gsize *)((void *)0),
                               (GError **)((void *)0));
  }
#line 181
  if (im->with_markup) {
#line 182
    if (utf8_text) {
#line 182
      tmp___2 = (char const   *)utf8_text;
    } else {
#line 182
      tmp___2 = text;
    }
    {
#line 182
    pango_layout_set_markup(layout, tmp___2, -1);
    }
  } else {
#line 184
    if (utf8_text) {
#line 184
      tmp___3 = (char const   *)utf8_text;
    } else {
#line 184
      tmp___3 = text;
    }
    {
#line 184
    pango_layout_set_text(layout, tmp___3, -1);
    }
  }
  {
#line 186
  g_free((gpointer )utf8_text);
  }
#line 187
  return (layout);
}
}
#line 191 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
double gfx_get_text_width(image_desc_t *im , double start , PangoFontDescription *font_desc ,
                          double tabwidth , char *text ) 
{ 
  PangoLayout *layout ;
  PangoRectangle log_rect ;
  gfx_color_t color ;

  {
  {
#line 200
  color.red = (double )0;
#line 200
  color.green = (double )0;
#line 200
  color.blue = (double )0;
#line 200
  color.alpha = (double )0;
#line 201
  layout = gfx_prep_text(im, start, color, font_desc, tabwidth, (char const   *)text);
#line 202
  pango_layout_get_pixel_extents(layout, (PangoRectangle *)((void *)0), & log_rect);
  }
#line 204
  return ((double )log_rect.width);
}
}
#line 207 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
void gfx_text(image_desc_t *im , double x , double y , gfx_color_t color , PangoFontDescription *font_desc ,
              double tabwidth , double angle , enum gfx_h_align_en h_align , enum gfx_v_align_en v_align ,
              char const   *text ) 
{ 
  PangoLayout *layout ;
  PangoRectangle log_rect ;
  cairo_t *cr ;
  double sx ;
  double sy ;

  {
  {
#line 221
  cr = im->cr;
#line 222
  sx = (double )0;
#line 223
  sy = (double )0;
#line 225
  cairo_save(cr);
#line 226
  cairo_translate(cr, x, y);
#line 229
  layout = gfx_prep_text(im, x, color, font_desc, tabwidth, text);
#line 230
  pango_layout_get_pixel_extents(layout, (PangoRectangle *)((void *)0), & log_rect);
#line 231
  cairo_rotate(cr, (- angle * 3.1415926535897932384626433832795028841971693993751) / 180.0);
#line 232
  sx = (double )log_rect.x;
  }
  {
#line 234
  if ((unsigned int )h_align == 2U) {
#line 234
    goto case_2;
  }
#line 237
  if ((unsigned int )h_align == 3U) {
#line 237
    goto case_3;
  }
#line 240
  if ((unsigned int )h_align == 1U) {
#line 240
    goto case_1;
  }
#line 242
  if ((unsigned int )h_align == 0U) {
#line 242
    goto case_0;
  }
#line 233
  goto switch_break;
  case_2: /* CIL Label */ 
#line 235
  sx -= (double )log_rect.width;
#line 236
  goto switch_break;
  case_3: /* CIL Label */ 
#line 238
  sx -= (double )(log_rect.width / 2);
#line 239
  goto switch_break;
  case_1: /* CIL Label */ 
#line 241
  goto switch_break;
  case_0: /* CIL Label */ 
#line 243
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 245
  sy = (double )log_rect.y;
  {
#line 247
  if ((unsigned int )v_align == 1U) {
#line 247
    goto case_1___0;
  }
#line 249
  if ((unsigned int )v_align == 3U) {
#line 249
    goto case_3___0;
  }
#line 252
  if ((unsigned int )v_align == 2U) {
#line 252
    goto case_2___0;
  }
#line 255
  if ((unsigned int )v_align == 0U) {
#line 255
    goto case_0___0;
  }
#line 246
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 248
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 250
  sy -= (double )(log_rect.height / 2);
#line 251
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 253
  sy -= (double )log_rect.height;
#line 254
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 256
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 258
  pango_cairo_update_layout(cr, layout);
#line 259
  cairo_move_to(cr, sx, sy);
#line 260
  pango_cairo_show_layout(cr, layout);
#line 262
  cairo_restore(cr);
  }
#line 264
  return;
}
}
#line 267 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
struct gfx_color_t gfx_hex_to_col(unsigned long color ) 
{ 
  struct gfx_color_t gfx_color ;

  {
#line 272
  gfx_color.red = (1.0 / 255.0) * (double )((color & 4278190080UL) >> 24);
#line 273
  gfx_color.green = (1.0 / 255.0) * (double )((color & 16711680UL) >> 16);
#line 274
  gfx_color.blue = (1.0 / 255.0) * (double )((color & 65280UL) >> 8);
#line 275
  gfx_color.alpha = (1.0 / 255.0) * (double )(color & 255UL);
#line 276
  return (gfx_color);
}
}
#line 281 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
void gfx_line_fit(image_desc_t *im , double *x , double *y ) 
{ 
  cairo_t *cr ;
  double line_width ;
  double line_height ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 286
  cr = im->cr;
#line 290
  if (! im->gridfit) {
#line 291
    return;
  }
  {
#line 292
  cairo_user_to_device(cr, x, y);
#line 293
  line_width = cairo_get_line_width(cr);
#line 294
  line_height = line_width;
#line 295
  cairo_user_to_device_distance(cr, & line_width, & line_height);
#line 296
  tmp = ceil(line_width / 2.0);
#line 296
  line_width = line_width / 2.0 - tmp;
#line 297
  tmp___0 = ceil(line_height / 2.0);
#line 297
  line_height = line_height / 2.0 - tmp___0;
#line 298
  tmp___1 = floor(*x - 0.5);
#line 298
  *x = tmp___1 - line_width;
#line 299
  tmp___2 = ceil(*y + 0.5);
#line 299
  *y = tmp___2 + line_height;
#line 300
  cairo_device_to_user(cr, x, y);
  }
#line 301
  return;
}
}
#line 305 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_gfx.c"
void gfx_area_fit(image_desc_t *im , double *x , double *y ) 
{ 
  cairo_t *cr ;

  {
#line 310
  cr = im->cr;
#line 312
  if (! im->gridfit) {
#line 313
    return;
  }
  {
#line 314
  cairo_user_to_device(cr, x, y);
#line 315
  *x = floor(*x);
#line 316
  *y = ceil(*y);
#line 317
  cairo_device_to_user(cr, x, y);
  }
#line 318
  return;
}
}
#line 211 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_xport(int argc , char **argv , int *xsize  __attribute__((__unused__)) , time_t *start ,
              time_t *end , unsigned long *step , unsigned long *col_cnt , char ***legend_v ,
              rrd_value_t **data ) ;
#line 35 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
#pragma GCC diagnostic push
#line 35
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 35
#pragma GCC diagnostic pop
#line 36
#pragma GCC diagnostic push
#line 36
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 36
#pragma GCC diagnostic pop
#line 37
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 37
#pragma GCC diagnostic pop
#line 38
#pragma GCC diagnostic push
#line 38
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 38
#pragma GCC diagnostic pop
#line 39
#pragma GCC diagnostic push
#line 39
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 39
#pragma GCC diagnostic pop
#line 40
#pragma GCC diagnostic push
#line 40
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 40
#pragma GCC diagnostic pop
#line 41
#pragma GCC diagnostic push
#line 41
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 41
#pragma GCC diagnostic pop
#line 42
#pragma GCC diagnostic push
#line 42
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 42
#pragma GCC diagnostic pop
#line 43
#pragma GCC diagnostic push
#line 43
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 43
#pragma GCC diagnostic pop
#line 44
#pragma GCC diagnostic push
#line 44
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 44
#pragma GCC diagnostic pop
#line 45
#pragma GCC diagnostic push
#line 45
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 45
#pragma GCC diagnostic pop
#line 46
#pragma GCC diagnostic push
#line 46
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 46
#pragma GCC diagnostic pop
#line 47
#pragma GCC diagnostic push
#line 47
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 47
#pragma GCC diagnostic pop
#line 48
#pragma GCC diagnostic push
#line 48
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 48
#pragma GCC diagnostic pop
#line 49
#pragma GCC diagnostic push
#line 49
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 49
#pragma GCC diagnostic pop
#line 50
#pragma GCC diagnostic push
#line 50
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 50
#pragma GCC diagnostic pop
#line 51
#pragma GCC diagnostic push
#line 51
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 51
#pragma GCC diagnostic pop
#line 52
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 52
#pragma GCC diagnostic pop
#line 53
#pragma GCC diagnostic push
#line 53
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 53
#pragma GCC diagnostic pop
#line 54
#pragma GCC diagnostic push
#line 54
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 54
#pragma GCC diagnostic pop
#line 55
#pragma GCC diagnostic push
#line 55
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 55
#pragma GCC diagnostic pop
#line 56
#pragma GCC diagnostic push
#line 56
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 56
#pragma GCC diagnostic pop
#line 57
#pragma GCC diagnostic push
#line 57
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 57
#pragma GCC diagnostic pop
#line 58
#pragma GCC diagnostic push
#line 58
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 58
#pragma GCC diagnostic pop
#line 59
#pragma GCC diagnostic push
#line 59
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 59
#pragma GCC diagnostic pop
#line 60
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 60
#pragma GCC diagnostic pop
#line 61
#pragma GCC diagnostic push
#line 61
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 61
#pragma GCC diagnostic pop
#line 62
#pragma GCC diagnostic push
#line 62
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 62
#pragma GCC diagnostic pop
#line 63
#pragma GCC diagnostic push
#line 63
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 63
#pragma GCC diagnostic pop
#line 64
#pragma GCC diagnostic push
#line 64
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 64
#pragma GCC diagnostic pop
#line 65
#pragma GCC diagnostic push
#line 65
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 65
#pragma GCC diagnostic pop
#line 66
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 66
#pragma GCC diagnostic pop
#line 67
#pragma GCC diagnostic push
#line 67
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 67
#pragma GCC diagnostic pop
#line 68
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 68
#pragma GCC diagnostic pop
#line 69
#pragma GCC diagnostic push
#line 69
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 69
#pragma GCC diagnostic pop
#line 70
#pragma GCC diagnostic push
#line 70
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 70
#pragma GCC diagnostic pop
#line 71
#pragma GCC diagnostic push
#line 71
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 71
#pragma GCC diagnostic pop
#line 72
#pragma GCC diagnostic push
#line 72
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 72
#pragma GCC diagnostic pop
#line 73
#pragma GCC diagnostic push
#line 73
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 73
#pragma GCC diagnostic pop
#line 74
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 74
#pragma GCC diagnostic pop
#line 75
#pragma GCC diagnostic push
#line 75
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 75
#pragma GCC diagnostic pop
#line 76
#pragma GCC diagnostic push
#line 76
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 76
#pragma GCC diagnostic pop
#line 77
#pragma GCC diagnostic push
#line 77
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 77
#pragma GCC diagnostic pop
#line 78
#pragma GCC diagnostic push
#line 78
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 78
#pragma GCC diagnostic pop
#line 79
#pragma GCC diagnostic push
#line 79
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 79
#pragma GCC diagnostic pop
#line 80
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 80
#pragma GCC diagnostic pop
#line 81
#pragma GCC diagnostic push
#line 81
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 81
#pragma GCC diagnostic pop
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
#pragma GCC diagnostic push
#line 24
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 24
#pragma GCC diagnostic pop
#line 25
#pragma GCC diagnostic push
#line 25
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 25
#pragma GCC diagnostic pop
#line 26
#pragma GCC diagnostic push
#line 26
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 26
#pragma GCC diagnostic pop
#line 27
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 27
#pragma GCC diagnostic pop
#line 311 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
int im_free(image_desc_t *im ) ;
#line 332
int data_fetch(image_desc_t *im ) ;
#line 340
long lcd(long *num ) ;
#line 342
int data_calc(image_desc_t *im ) ;
#line 382
void rrd_graph_init(image_desc_t *im ) ;
#line 389
void rrd_graph_script(int argc , char **argv , image_desc_t * const  im , int optno ) ;
#line 32 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_xport.c"
int rrd_xport_fn(image_desc_t *im , time_t *start , time_t *end , unsigned long *step ,
                 unsigned long *col_cnt , char ***legend_v , rrd_value_t **data ) ;
#line 44 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_xport.c"
int rrd_xport(int argc , char **argv , int *xsize  __attribute__((__unused__)) , time_t *start ,
              time_t *end , unsigned long *step , unsigned long *col_cnt , char ***legend_v ,
              rrd_value_t **data ) 
{ 
  image_desc_t im ;
  time_t start_tmp ;
  time_t end_tmp ;
  rrd_time_value_t start_tv ;
  rrd_time_value_t end_tv ;
  char *parsetime_error ;
  struct option long_options___5[8] ;
  int option_index ;
  int opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int status ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
  {
#line 58
  start_tmp = (time_t )0;
#line 58
  end_tmp = (time_t )0;
#line 60
  parsetime_error = (char *)((void *)0);
#line 62
  long_options___5[0].name = "start";
#line 62
  long_options___5[0].has_arg = 1;
#line 62
  long_options___5[0].flag = (int *)0;
#line 62
  long_options___5[0].val = 's';
#line 62
  long_options___5[1].name = "end";
#line 62
  long_options___5[1].has_arg = 1;
#line 62
  long_options___5[1].flag = (int *)0;
#line 62
  long_options___5[1].val = 'e';
#line 62
  long_options___5[2].name = "maxrows";
#line 62
  long_options___5[2].has_arg = 1;
#line 62
  long_options___5[2].flag = (int *)0;
#line 62
  long_options___5[2].val = 'm';
#line 62
  long_options___5[3].name = "step";
#line 62
  long_options___5[3].has_arg = 1;
#line 62
  long_options___5[3].flag = (int *)0;
#line 62
  long_options___5[3].val = 261;
#line 62
  long_options___5[4].name = "enumds";
#line 62
  long_options___5[4].has_arg = 0;
#line 62
  long_options___5[4].flag = (int *)0;
#line 62
  long_options___5[4].val = 262;
#line 62
  long_options___5[5].name = "json";
#line 62
  long_options___5[5].has_arg = 0;
#line 62
  long_options___5[5].flag = (int *)0;
#line 62
  long_options___5[5].val = 263;
#line 62
  long_options___5[6].name = "daemon";
#line 62
  long_options___5[6].has_arg = 1;
#line 62
  long_options___5[6].flag = (int *)0;
#line 62
  long_options___5[6].val = 'd';
#line 62
  long_options___5[7].name = (char const   *)0;
#line 62
  long_options___5[7].has_arg = 0;
#line 62
  long_options___5[7].flag = (int *)0;
#line 62
  long_options___5[7].val = 0;
#line 73
  optind = 0;
#line 74
  opterr = 0;
#line 76
  rrd_graph_init(& im);
#line 78
  rrd_parsetime("end-24h", & start_tv);
#line 79
  rrd_parsetime("now", & end_tv);
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 82
    option_index = 0;
#line 85
    opt = getopt_long(argc, (char * const  *)argv, "s:e:m:d:", (struct option  const  *)(long_options___5),
                      & option_index);
    }
#line 87
    if (opt == -1) {
#line 88
      goto while_break;
    }
    {
#line 91
    if (opt == 261) {
#line 91
      goto case_261;
    }
#line 94
    if (opt == 262) {
#line 94
      goto case_262;
    }
#line 96
    if (opt == 115) {
#line 96
      goto case_115;
    }
#line 102
    if (opt == 101) {
#line 102
      goto case_101;
    }
#line 108
    if (opt == 109) {
#line 108
      goto case_109;
    }
#line 115
    if (opt == 100) {
#line 115
      goto case_100;
    }
#line 133
    if (opt == 63) {
#line 133
      goto case_63;
    }
#line 90
    goto switch_break;
    case_261: /* CIL Label */ 
    {
#line 92
    tmp = atoi((char const   *)optarg);
#line 92
    im.step = (unsigned long )tmp;
    }
#line 93
    goto switch_break;
    case_262: /* CIL Label */ 
#line 95
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 97
    parsetime_error = rrd_parsetime((char const   *)optarg, & start_tv);
    }
#line 97
    if (parsetime_error) {
      {
#line 98
      rrd_set_error((char *)"start time: %s", parsetime_error);
      }
#line 99
      return (-1);
    }
#line 101
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 103
    parsetime_error = rrd_parsetime((char const   *)optarg, & end_tv);
    }
#line 103
    if (parsetime_error) {
      {
#line 104
      rrd_set_error((char *)"end time: %s", parsetime_error);
      }
#line 105
      return (-1);
    }
#line 107
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 109
    im.xsize = atol((char const   *)optarg);
    }
#line 110
    if (im.xsize < 10L) {
      {
#line 111
      rrd_set_error((char *)"maxrows below 10 rows");
      }
#line 112
      return (-1);
    }
#line 114
    goto switch_break;
    case_100: /* CIL Label */ 
#line 117
    if ((unsigned long )im.daemon_addr != (unsigned long )((void *)0)) {
      {
#line 119
      rrd_set_error((char *)"You cannot specify --daemon more than once.");
      }
#line 121
      return (-1);
    }
    {
#line 124
    im.daemon_addr = strdup((char const   *)optarg);
    }
#line 125
    if ((unsigned long )im.daemon_addr == (unsigned long )((void *)0)) {
      {
#line 127
      rrd_set_error((char *)"strdup error");
      }
#line 128
      return (-1);
    }
#line 130
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 134
    rrd_set_error((char *)"unknown option \'%s\'", *(argv + (optind - 1)));
    }
#line 135
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  tmp___0 = rrd_proc_start_end(& start_tv, & end_tv, & start_tmp, & end_tmp);
  }
#line 139
  if (tmp___0 == -1) {
#line 140
    return (-1);
  }
#line 143
  if (start_tmp < 315360000L) {
    {
#line 144
    rrd_set_error((char *)"the first entry to fetch should be after 1980 (%ld)", start_tmp);
    }
#line 146
    return (-1);
  }
#line 149
  if (end_tmp < start_tmp) {
    {
#line 150
    rrd_set_error((char *)"start (%ld) should be less than end (%ld)", start_tmp,
                  end_tmp);
    }
#line 152
    return (-1);
  }
#line 155
  im.start = start_tmp;
#line 156
  im.end = end_tmp;
#line 157
  if ((long )im.step > (im.end - im.start) / im.xsize) {
#line 157
    im.step = (unsigned long )((long )im.step);
  } else {
#line 157
    im.step = (unsigned long )((im.end - im.start) / im.xsize);
  }
  {
#line 159
  rrd_graph_script(argc, argv, & im, 0);
#line 160
  tmp___1 = rrd_test_error();
  }
#line 160
  if (tmp___1) {
    {
#line 161
    im_free(& im);
    }
#line 162
    return (-1);
  }
#line 165
  if (im.gdes_c == 0L) {
    {
#line 166
    rrd_set_error((char *)"can\'t make an xport without contents");
#line 167
    im_free(& im);
    }
#line 168
    return (-1);
  }
  {
#line 172
  tmp___2 = rrdc_connect((char const   *)im.daemon_addr);
#line 172
  status = tmp___2;
  }
#line 173
  if (status != 0) {
#line 173
    return (status);
  }
  {
#line 176
  tmp___3 = rrd_xport_fn(& im, start, end, step, col_cnt, legend_v, data);
  }
#line 176
  if (tmp___3 == -1) {
    {
#line 177
    im_free(& im);
    }
#line 178
    return (-1);
  }
  {
#line 181
  im_free(& im);
  }
#line 182
  return (0);
}
}
#line 187 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_xport.c"
int rrd_xport_fn(image_desc_t *im , time_t *start , time_t *end , unsigned long *step ,
                 unsigned long *col_cnt , char ***legend_v , rrd_value_t **data ) 
{ 
  int i ;
  int j ;
  unsigned long dst_row ;
  unsigned long row_cnt ;
  rrd_value_t *dstptr ;
  unsigned long xport_counter ;
  int *ref_list ;
  long *step_list ;
  long *step_list_ptr ;
  char **legend_list ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  rrd_value_t *tmp___10 ;
  void *tmp___11 ;
  long vidx ;
  time_t now ;
  rrd_value_t *tmp___12 ;
  double tmp___13 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 199
  i = 0;
#line 199
  j = 0;
#line 203
  xport_counter = 0UL;
#line 211
  tmp = data_fetch(im);
  }
#line 211
  if (tmp == -1) {
#line 212
    return (-1);
  }
  {
#line 215
  tmp___0 = data_calc(im);
  }
#line 215
  if (tmp___0 == -1) {
#line 216
    return (-1);
  }
#line 219
  *col_cnt = 0UL;
#line 220
  i = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! ((long )i < im->gdes_c)) {
#line 220
      goto while_break;
    }
    {
#line 222
    if ((unsigned int )(im->gdes + i)->gf == 14U) {
#line 222
      goto case_14;
    }
#line 225
    goto switch_default;
    case_14: /* CIL Label */ 
#line 223
    (*col_cnt) ++;
#line 224
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 226
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  if (*col_cnt == 0UL) {
    {
#line 230
    rrd_set_error((char *)"no XPORT found, nothing to do");
    }
#line 231
    return (-1);
  }
  {
#line 235
  tmp___1 = malloc(sizeof(int ) * *col_cnt);
#line 235
  ref_list = (int *)tmp___1;
  }
#line 236
  if ((unsigned long )ref_list == (unsigned long )((void *)0)) {
#line 237
    return (-1);
  }
  {
#line 241
  tmp___2 = malloc(sizeof(char *) * *col_cnt);
#line 241
  legend_list = (char **)tmp___2;
  }
#line 242
  if ((unsigned long )legend_list == (unsigned long )((void *)0)) {
    {
#line 243
    free((void *)ref_list);
    }
#line 244
    return (-1);
  }
  {
#line 248
  tmp___3 = malloc(sizeof(long ) * (*col_cnt + 1UL));
#line 248
  step_list = (long *)tmp___3;
#line 249
  step_list_ptr = step_list;
#line 250
  j = 0;
#line 251
  i = 0;
  }
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    if (! ((long )i < im->gdes_c)) {
#line 251
      goto while_break___0;
    }
    {
#line 253
    if ((unsigned int )(im->gdes + i)->gf == 14U) {
#line 253
      goto case_14___0;
    }
#line 278
    goto switch_default___0;
    case_14___0: /* CIL Label */ 
    {
#line 254
    tmp___4 = xport_counter;
#line 254
    xport_counter ++;
#line 254
    *(ref_list + tmp___4) = i;
#line 255
    *step_list_ptr = (long )(im->gdes + (im->gdes + i)->vidx)->step;
#line 257
    step_list_ptr ++;
#line 260
    tmp___6 = malloc(sizeof(char ) * 205UL);
#line 260
    tmp___5 = (char *)tmp___6;
#line 260
    *(legend_list + j) = tmp___5;
    }
#line 260
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      {
#line 262
      free((void *)ref_list);
#line 263
      *data = (rrd_value_t *)((void *)0);
      }
      {
#line 264
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 264
        j --;
#line 264
        if (! (j > -1)) {
#line 264
          goto while_break___1;
        }
        {
#line 265
        free((void *)*(legend_list + j));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 266
      free((void *)legend_list);
#line 267
      free((void *)step_list);
#line 268
      rrd_set_error((char *)"malloc xport legend entry");
      }
#line 269
      return (-1);
    }
#line 272
    if ((im->gdes + i)->legend) {
      {
#line 274
      tmp___7 = j;
#line 274
      j ++;
#line 274
      strcpy((char */* __restrict  */)*(legend_list + tmp___7), (char const   */* __restrict  */)((im->gdes + i)->legend));
      }
    } else {
#line 276
      tmp___8 = j;
#line 276
      j ++;
#line 276
      *(*(legend_list + tmp___8) + 0) = (char )'\000';
    }
#line 277
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 279
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 251
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 282
  *step_list_ptr = 0L;
#line 284
  tmp___9 = lcd(step_list);
#line 284
  *step = (unsigned long )tmp___9;
#line 286
  free((void *)step_list);
#line 288
  *start = (time_t )((unsigned long )im->start - (unsigned long )im->start % *step);
#line 289
  *end = (time_t )(((unsigned long )im->end - (unsigned long )im->end % *step) + *step);
#line 294
  row_cnt = (unsigned long )(*end - *start) / *step;
#line 295
  tmp___11 = malloc((*col_cnt * row_cnt) * sizeof(rrd_value_t ));
#line 295
  tmp___10 = (rrd_value_t *)tmp___11;
#line 295
  *data = tmp___10;
  }
#line 295
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
    {
#line 297
    free((void *)ref_list);
#line 298
    free((void *)legend_list);
#line 299
    rrd_set_error((char *)"malloc xport data area");
    }
#line 300
    return (-1);
  }
#line 302
  dstptr = *data;
#line 305
  dst_row = 0UL;
  {
#line 305
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 305
    if (! ((int )dst_row < (int )row_cnt)) {
#line 305
      goto while_break___2;
    }
#line 306
    i = 0;
    {
#line 306
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 306
      if (! (i < (int )*col_cnt)) {
#line 306
        goto while_break___3;
      }
      {
#line 307
      vidx = (im->gdes + *(ref_list + i))->vidx;
#line 308
      now = (time_t )((unsigned long )*start + dst_row * *step);
#line 309
      tmp___12 = dstptr;
#line 309
      dstptr ++;
#line 309
      tmp___13 = floor((double )(now - (im->gdes + vidx)->start) / (double )(im->gdes + vidx)->step);
#line 309
      *tmp___12 = *((im->gdes + vidx)->data + ((unsigned long )tmp___13 * (im->gdes + vidx)->ds_cnt + (unsigned long )(im->gdes + vidx)->ds));
#line 306
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 305
    dst_row ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 319
  *legend_v = legend_list;
#line 320
  free((void *)ref_list);
  }
#line 321
  return (0);
}
}
#line 66 "/usr/include/glib-2.0/glib/ghash.h"
extern gboolean g_hash_table_insert(GHashTable *hash_table , gpointer key , gpointer value ) ;
#line 93
extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table , gconstpointer lookup_key ,
                                             gpointer *orig_key , gpointer *value ) ;
#line 215 "/usr/include/glib-2.0/glib/gstrfuncs.h"
extern gchar *g_strdup(gchar const   *str )  __attribute__((__malloc__)) ;
#line 35 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
#pragma GCC diagnostic push
#line 35
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 35
#pragma GCC diagnostic pop
#line 36
#pragma GCC diagnostic push
#line 36
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 36
#pragma GCC diagnostic pop
#line 37
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 37
#pragma GCC diagnostic pop
#line 38
#pragma GCC diagnostic push
#line 38
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 38
#pragma GCC diagnostic pop
#line 39
#pragma GCC diagnostic push
#line 39
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 39
#pragma GCC diagnostic pop
#line 40
#pragma GCC diagnostic push
#line 40
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 40
#pragma GCC diagnostic pop
#line 41
#pragma GCC diagnostic push
#line 41
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 41
#pragma GCC diagnostic pop
#line 42
#pragma GCC diagnostic push
#line 42
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 42
#pragma GCC diagnostic pop
#line 43
#pragma GCC diagnostic push
#line 43
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 43
#pragma GCC diagnostic pop
#line 44
#pragma GCC diagnostic push
#line 44
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 44
#pragma GCC diagnostic pop
#line 45
#pragma GCC diagnostic push
#line 45
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 45
#pragma GCC diagnostic pop
#line 46
#pragma GCC diagnostic push
#line 46
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 46
#pragma GCC diagnostic pop
#line 47
#pragma GCC diagnostic push
#line 47
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 47
#pragma GCC diagnostic pop
#line 48
#pragma GCC diagnostic push
#line 48
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 48
#pragma GCC diagnostic pop
#line 49
#pragma GCC diagnostic push
#line 49
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 49
#pragma GCC diagnostic pop
#line 50
#pragma GCC diagnostic push
#line 50
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 50
#pragma GCC diagnostic pop
#line 51
#pragma GCC diagnostic push
#line 51
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 51
#pragma GCC diagnostic pop
#line 52
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 52
#pragma GCC diagnostic pop
#line 53
#pragma GCC diagnostic push
#line 53
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 53
#pragma GCC diagnostic pop
#line 54
#pragma GCC diagnostic push
#line 54
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 54
#pragma GCC diagnostic pop
#line 55
#pragma GCC diagnostic push
#line 55
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 55
#pragma GCC diagnostic pop
#line 56
#pragma GCC diagnostic push
#line 56
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 56
#pragma GCC diagnostic pop
#line 57
#pragma GCC diagnostic push
#line 57
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 57
#pragma GCC diagnostic pop
#line 58
#pragma GCC diagnostic push
#line 58
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 58
#pragma GCC diagnostic pop
#line 59
#pragma GCC diagnostic push
#line 59
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 59
#pragma GCC diagnostic pop
#line 60
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 60
#pragma GCC diagnostic pop
#line 61
#pragma GCC diagnostic push
#line 61
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 61
#pragma GCC diagnostic pop
#line 62
#pragma GCC diagnostic push
#line 62
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 62
#pragma GCC diagnostic pop
#line 63
#pragma GCC diagnostic push
#line 63
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 63
#pragma GCC diagnostic pop
#line 64
#pragma GCC diagnostic push
#line 64
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 64
#pragma GCC diagnostic pop
#line 65
#pragma GCC diagnostic push
#line 65
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 65
#pragma GCC diagnostic pop
#line 66
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 66
#pragma GCC diagnostic pop
#line 67
#pragma GCC diagnostic push
#line 67
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 67
#pragma GCC diagnostic pop
#line 68
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 68
#pragma GCC diagnostic pop
#line 69
#pragma GCC diagnostic push
#line 69
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 69
#pragma GCC diagnostic pop
#line 70
#pragma GCC diagnostic push
#line 70
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 70
#pragma GCC diagnostic pop
#line 71
#pragma GCC diagnostic push
#line 71
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 71
#pragma GCC diagnostic pop
#line 72
#pragma GCC diagnostic push
#line 72
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 72
#pragma GCC diagnostic pop
#line 73
#pragma GCC diagnostic push
#line 73
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 73
#pragma GCC diagnostic pop
#line 74
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 74
#pragma GCC diagnostic pop
#line 75
#pragma GCC diagnostic push
#line 75
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 75
#pragma GCC diagnostic pop
#line 76
#pragma GCC diagnostic push
#line 76
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 76
#pragma GCC diagnostic pop
#line 77
#pragma GCC diagnostic push
#line 77
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 77
#pragma GCC diagnostic pop
#line 78
#pragma GCC diagnostic push
#line 78
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 78
#pragma GCC diagnostic pop
#line 79
#pragma GCC diagnostic push
#line 79
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 79
#pragma GCC diagnostic pop
#line 80
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 80
#pragma GCC diagnostic pop
#line 81
#pragma GCC diagnostic push
#line 81
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 81
#pragma GCC diagnostic pop
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
#pragma GCC diagnostic push
#line 24
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 24
#pragma GCC diagnostic pop
#line 25
#pragma GCC diagnostic push
#line 25
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 25
#pragma GCC diagnostic pop
#line 26
#pragma GCC diagnostic push
#line 26
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 26
#pragma GCC diagnostic pop
#line 27
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 27
#pragma GCC diagnostic pop
#line 301 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
enum gf_en gf_conv(char *string ) ;
#line 334
long find_var(image_desc_t *im , char *key ) ;
#line 337
long find_var_wrapper(void *arg1 , char *key ) ;
#line 376
int gdes_alloc(image_desc_t *im ) ;
#line 378
int scan_for_col(char const   * const  input , int len , char * const  output ) ;
#line 401
int vdef_parse(struct graph_desc_t *gdes , char const   * const  str ) ;
#line 51 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_find_gf(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ) ;
#line 56
int rrd_parse_legend(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ) ;
#line 61
int rrd_parse_color(char const   * const  string , graph_desc_t * const  gdp ) ;
#line 65
int rrd_parse_textalign(char const   * const  line , unsigned int * const  eaten ,
                        graph_desc_t * const  gdp ) ;
#line 71
int rrd_parse_CF(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                 enum cf_en * const  cf ) ;
#line 77
int rrd_parse_print(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                    image_desc_t * const  im ) ;
#line 83
int rrd_parse_shift(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                    image_desc_t * const  im ) ;
#line 89
int rrd_parse_xport(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                    image_desc_t * const  im ) ;
#line 95
int rrd_parse_PVHLAST(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                      image_desc_t * const  im ) ;
#line 101
int rrd_parse_make_vname(char const   * const  line , unsigned int * const  eaten ,
                         graph_desc_t * const  gdp , image_desc_t * const  im ) ;
#line 107
int rrd_parse_find_vname(char const   * const  line , unsigned int * const  eaten ,
                         graph_desc_t * const  gdp , image_desc_t * const  im ) ;
#line 113
int rrd_parse_def(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                  image_desc_t * const  im ) ;
#line 119
int rrd_parse_vdef(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                   image_desc_t * const  im ) ;
#line 125
int rrd_parse_cdef(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                   image_desc_t * const  im ) ;
#line 131 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_find_gf(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ) 
{ 
  char funcname[11] ;
  char c1 ;
  int i ;
  enum gf_en tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 136
  c1 = (char)0;
#line 137
  i = 0;
#line 140
  sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"DEBUG%n",
         & i);
  }
#line 141
  if (i) {
#line 142
    gdp->debug = 1;
#line 143
    *eaten += (unsigned int )i;
#line 144
    i = 0;
#line 145
    if (gdp->debug) {
      {
#line 145
      printf((char const   */* __restrict  */)"Scanning line \'%s\'\n", line + *eaten);
      }
    }
  }
  {
#line 147
  i = 0;
#line 148
  c1 = (char )'\000';
#line 149
  sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%10[A-Z]%n%c",
         funcname, & i, & c1);
  }
#line 150
  if (! i) {
    {
#line 151
    rrd_set_error((char *)"Could not make sense out of \'%s\'", line);
    }
#line 152
    return (1);
  }
  {
#line 154
  *eaten += (unsigned int )i;
#line 155
  tmp = gf_conv(funcname);
#line 155
  gdp->gf = tmp;
  }
#line 155
  if ((int )tmp == -1) {
    {
#line 156
    rrd_set_error((char *)"\'%s\' is not a valid function name", funcname);
    }
#line 157
    return (1);
  } else
#line 159
  if (gdp->debug) {
    {
#line 159
    printf((char const   */* __restrict  */)"- found function name \'%s\'\n", funcname);
    }
  }
#line 162
  if ((int )c1 == 0) {
    {
#line 163
    rrd_set_error((char *)"Function %s needs parameters.  Line: %s\n", funcname, line);
    }
#line 165
    return (1);
  }
#line 167
  if ((int )c1 == 58) {
#line 168
    (*eaten) ++;
  }
  {
#line 174
  if ((unsigned int )gdp->gf == 5U) {
#line 174
    goto case_5;
  }
#line 209
  goto switch_default;
  case_5: /* CIL Label */ 
#line 175
  if ((int )c1 == 58) {
#line 176
    gdp->linewidth = (double )1;
#line 177
    if (gdp->debug) {
      {
#line 177
      printf((char const   */* __restrict  */)"- using default width of 1\n");
      }
    }
  } else {
    {
#line 179
    i = 0;
#line 180
    sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%lf:%n",
           & gdp->linewidth, & i);
    }
#line 181
    if (! i) {
      {
#line 182
      rrd_set_error((char *)"Cannot parse line width \'%s\' in line \'%s\'\n", line + *eaten,
                    line);
      }
#line 184
      return (1);
    } else {
#line 186
      if (gdp->debug) {
        {
#line 186
        printf((char const   */* __restrict  */)"- scanned width %f\n", gdp->linewidth);
        }
      }
#line 187
      if (sizeof(gdp->linewidth) == sizeof(float )) {
        {
#line 187
        tmp___0 = __isnanf((float )gdp->linewidth);
#line 187
        tmp___4 = tmp___0;
        }
      } else {
#line 187
        if (sizeof(gdp->linewidth) == sizeof(double )) {
          {
#line 187
          tmp___1 = __isnan(gdp->linewidth);
#line 187
          tmp___3 = tmp___1;
          }
        } else {
          {
#line 187
          tmp___2 = __isnanl((long double )gdp->linewidth);
#line 187
          tmp___3 = tmp___2;
          }
        }
#line 187
        tmp___4 = tmp___3;
      }
#line 187
      if (tmp___4) {
        {
#line 188
        rrd_set_error((char *)"LINE width \'%s\' is not a number in line \'%s\'\n",
                      line + *eaten, line);
        }
#line 191
        return (1);
      }
#line 193
      if (sizeof(gdp->linewidth) == sizeof(float )) {
        {
#line 193
        tmp___5 = __isinff((float )gdp->linewidth);
#line 193
        tmp___9 = tmp___5;
        }
      } else {
#line 193
        if (sizeof(gdp->linewidth) == sizeof(double )) {
          {
#line 193
          tmp___6 = __isinf(gdp->linewidth);
#line 193
          tmp___8 = tmp___6;
          }
        } else {
          {
#line 193
          tmp___7 = __isinfl((long double )gdp->linewidth);
#line 193
          tmp___8 = tmp___7;
          }
        }
#line 193
        tmp___9 = tmp___8;
      }
#line 193
      if (tmp___9) {
        {
#line 194
        rrd_set_error((char *)"LINE width \'%s\' is out of range in line \'%s\'\n",
                      line + *eaten, line);
        }
#line 197
        return (1);
      }
#line 199
      if (gdp->linewidth < (double )0) {
        {
#line 200
        rrd_set_error((char *)"LINE width \'%s\' is less than 0 in line \'%s\'\n",
                      line + *eaten, line);
        }
#line 203
        return (1);
      }
    }
#line 206
    *eaten += (unsigned int )i;
  }
#line 208
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 210
  if ((int )c1 == 58) {
#line 211
    goto switch_break;
  }
  {
#line 212
  rrd_set_error((char *)"Malformed \'%s\' command in line \'%s\'\n", line + *eaten,
                line);
  }
#line 214
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 216
  if ((int const   )*(line + *eaten) == 0) {
    {
#line 217
    rrd_set_error((char *)"Expected some arguments after \'%s\'\n", line);
    }
#line 218
    return (1);
  }
#line 220
  return (0);
}
}
#line 223 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_legend(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ) 
{ 
  int i ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 230
  if ((int const   )*(line + *eaten) == 0) {
#line 230
    goto _L;
  } else
#line 230
  if ((int const   )*(line + *eaten) == 58) {
    _L: /* CIL Label */ 
#line 231
    if (gdp->debug) {
      {
#line 231
      printf((char const   */* __restrict  */)"- no (or: empty) legend found\n");
      }
    }
#line 232
    return (0);
  }
  {
#line 235
  i = scan_for_col((char const   */* const  */)(line + *eaten), 200, (char */* const  */)(gdp->legend));
#line 237
  *eaten += (unsigned int )i;
  }
#line 239
  if ((int const   )*(line + *eaten) != 0) {
#line 239
    if ((int const   )*(line + *eaten) != 58) {
      {
#line 240
      rrd_set_error((char *)"Legend too long");
      }
#line 241
      return (1);
    } else {
#line 243
      return (0);
    }
  } else {
#line 243
    return (0);
  }
}
}
#line 247 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_color(char const   * const  string , graph_desc_t * const  gdp ) 
{ 
  unsigned int r ;
  unsigned int g ;
  unsigned int b ;
  unsigned int a ;
  unsigned int i ;
  unsigned short const   **tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 251
  r = 0U;
#line 251
  g = 0U;
#line 251
  b = 0U;
#line 251
  a = 0U;
#line 260
  i = 0U;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (*(string + i)) {
      {
#line 261
      tmp = __ctype_b_loc();
      }
#line 261
      if (! ((int const   )*(*tmp + (int )((unsigned int )*(string + i))) & 4096)) {
#line 261
        goto while_break;
      }
    } else {
#line 261
      goto while_break;
    }
#line 262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  if ((int const   )*(string + i) != 0) {
#line 264
    return (1);
  }
  {
#line 267
  if (i == 4U) {
#line 267
    goto case_4;
  }
#line 267
  if (i == 3U) {
#line 267
    goto case_4;
  }
#line 277
  if (i == 8U) {
#line 277
    goto case_8;
  }
#line 277
  if (i == 6U) {
#line 277
    goto case_8;
  }
#line 282
  goto switch_default;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 268
  sscanf((char const   */* __restrict  */)string, (char const   */* __restrict  */)"%1x%1x%1x%1x",
         & r, & g, & b, & a);
#line 269
  r *= 17U;
#line 270
  g *= 17U;
#line 271
  b *= 17U;
#line 272
  a *= 17U;
  }
#line 273
  if (i == 3U) {
#line 274
    a = 255U;
  }
#line 275
  goto switch_break;
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 278
  sscanf((char const   */* __restrict  */)string, (char const   */* __restrict  */)"%02x%02x%02x%02x",
         & r, & g, & b, & a);
  }
#line 279
  if (i == 6U) {
#line 280
    a = 255U;
  }
#line 281
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 283
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 285
  gdp->col = gfx_hex_to_col((unsigned long )((((r << 24) | (g << 16)) | (b << 8)) | a));
  }
#line 286
  return (0);
}
}
#line 289 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_CF(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                 enum cf_en * const  cf ) 
{ 
  char symname[20] ;
  int i ;
  enum cf_en tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 296
  i = 0;
#line 298
  sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%19[A-Z]%n",
         symname, & i);
  }
#line 299
  if (! i) {
    {
#line 300
    rrd_set_error((char *)"Cannot parse CF in \'%s\'", line);
    }
#line 301
    return (1);
  } else
#line 299
  if ((int const   )*(line + (*eaten + (unsigned int )i)) != 0) {
#line 299
    if ((int const   )*(line + (*eaten + (unsigned int )i)) != 58) {
      {
#line 300
      rrd_set_error((char *)"Cannot parse CF in \'%s\'", line);
      }
#line 301
      return (1);
    }
  }
#line 303
  *eaten += (unsigned int )i;
#line 304
  if (gdp->debug) {
    {
#line 304
    printf((char const   */* __restrict  */)"- using CF \'%s\'\n", symname);
    }
  }
  {
#line 306
  tmp = cf_conv((char const   *)(symname));
#line 306
  *cf = tmp;
  }
#line 306
  if ((int )tmp == -1) {
    {
#line 307
    rrd_set_error((char *)"Unknown CF \'%s\' in \'%s\'", symname, line);
    }
#line 308
    return (1);
  }
#line 311
  if ((int const   )*(line + *eaten) != 0) {
#line 312
    (*eaten) ++;
  }
#line 313
  return (0);
}
}
#line 324 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_find_vname(char const   * const  line , unsigned int * const  eaten ,
                         graph_desc_t * const  gdp , image_desc_t * const  im ) 
{ 
  char tmpstr[256] ;
  int i ;
  long vidx ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 334
  i = 0;
#line 335
  sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%255[-_A-Za-z0-9]%n",
         tmpstr, & i);
  }
#line 336
  if (! i) {
    {
#line 337
    rrd_set_error((char *)"Could not parse line \'%s\'", line);
    }
#line 338
    return (-1);
  }
#line 340
  if ((int const   )*(line + (*eaten + (unsigned int )i)) != 58) {
#line 340
    if ((int const   )*(line + (*eaten + (unsigned int )i)) != 0) {
      {
#line 341
      rrd_set_error((char *)"Could not parse line \'%s\'", line);
      }
#line 342
      return (-1);
    }
  }
#line 344
  if (gdp->debug) {
    {
#line 344
    printf((char const   */* __restrict  */)"- Considering \'%s\'\n", tmpstr);
    }
  }
  {
#line 346
  vidx = find_var((image_desc_t *)im, tmpstr);
  }
#line 346
  if (vidx < 0L) {
#line 347
    if (gdp->debug) {
      {
#line 347
      printf((char const   */* __restrict  */)"- Not a vname\n");
      }
    }
    {
#line 348
    rrd_set_error((char *)"Not a valid vname: %s in line %s", tmpstr, line);
    }
#line 349
    return (-1);
  }
#line 351
  if (gdp->debug) {
    {
#line 351
    printf((char const   */* __restrict  */)"- Found vname \'%s\' vidx \'%li\'\n",
           tmpstr, gdp->vidx);
    }
  }
#line 352
  if ((int const   )*(line + (*eaten + (unsigned int )i)) == 58) {
#line 353
    i ++;
  }
#line 354
  *eaten += (unsigned int )i;
#line 355
  return ((int )vidx);
}
}
#line 359 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_print(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                    image_desc_t * const  im ) 
{ 
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 369
  tmp___0 = rrd_parse_find_vname(line, eaten, gdp, im);
#line 369
  tmp = (long )tmp___0;
#line 369
  gdp->vidx = tmp;
  }
#line 369
  if (tmp < 0L) {
#line 370
    return (1);
  }
  {
#line 374
  if ((unsigned int )(im->gdes + gdp->vidx)->gf == 11U) {
#line 374
    goto case_11;
  }
#line 374
  if ((unsigned int )(im->gdes + gdp->vidx)->gf == 10U) {
#line 374
    goto case_11;
  }
#line 379
  if ((unsigned int )(im->gdes + gdp->vidx)->gf == 12U) {
#line 379
    goto case_12;
  }
#line 382
  goto switch_default;
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 375
  if (gdp->debug) {
    {
#line 375
    printf((char const   */* __restrict  */)"- vname is of type DEF or CDEF, looking for CF\n");
    }
  }
  {
#line 376
  tmp___1 = rrd_parse_CF(line, eaten, gdp, (enum cf_en */* const  */)(& gdp->cf));
  }
#line 376
  if (tmp___1) {
#line 377
    return (1);
  }
#line 378
  goto switch_break;
  case_12: /* CIL Label */ 
#line 380
  if (gdp->debug) {
    {
#line 380
    printf((char const   */* __restrict  */)"- vname is of type VDEF\n");
    }
  }
#line 381
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 383
  rrd_set_error((char *)"Encountered unknown type variable \'%s\'", (im->gdes + gdp->vidx)->vname);
  }
#line 385
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 388
  tmp___2 = rrd_parse_legend(line, eaten, gdp);
  }
#line 388
  if (tmp___2) {
#line 389
    return (1);
  }
  {
#line 392
  strcpy((char */* __restrict  */)(gdp->format), (char const   */* __restrict  */)(gdp->legend));
#line 393
  gdp->legend[0] = (char )'\000';
  }
#line 395
  if ((unsigned int )(im->gdes + gdp->vidx)->gf == 12U) {
    {
#line 395
    tmp___4 = strcmp((char const   *)(line + *eaten), ":strftime");
    }
#line 395
    if (tmp___4 == 0) {
      {
#line 397
      gdp->strftm = 1;
#line 398
      tmp___3 = strlen(":strftime");
#line 398
      *eaten = (unsigned int )((size_t )*eaten + tmp___3);
      }
    }
  }
#line 400
  return (0);
}
}
#line 405 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_shift(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                    image_desc_t * const  im ) 
{ 
  int i ;
  long tmp ;
  int tmp___0 ;
  long time_tmp ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 413
  tmp___0 = rrd_parse_find_vname(line, eaten, gdp, im);
#line 413
  tmp = (long )tmp___0;
#line 413
  gdp->vidx = tmp;
  }
#line 413
  if (tmp < 0L) {
#line 414
    return (1);
  }
  {
#line 418
  if ((unsigned int )(im->gdes + gdp->vidx)->gf == 11U) {
#line 418
    goto case_11;
  }
#line 418
  if ((unsigned int )(im->gdes + gdp->vidx)->gf == 10U) {
#line 418
    goto case_11;
  }
#line 421
  if ((unsigned int )(im->gdes + gdp->vidx)->gf == 12U) {
#line 421
    goto case_12;
  }
#line 425
  goto switch_default;
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 419
  if (gdp->debug) {
    {
#line 419
    printf((char const   */* __restrict  */)"- vname is of type DEF or CDEF, OK\n");
    }
  }
#line 420
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 422
  rrd_set_error((char *)"Cannot shift a VDEF: \'%s\' in line \'%s\'\n", (im->gdes + gdp->vidx)->vname,
                line);
  }
#line 424
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 426
  rrd_set_error((char *)"Encountered unknown type variable \'%s\' in line \'%s\'",
                (im->gdes + gdp->vidx)->vname, line);
  }
#line 428
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 431
  tmp___2 = rrd_parse_find_vname(line, eaten, gdp, im);
#line 431
  gdp->shidx = tmp___2;
  }
#line 431
  if (tmp___2 >= 0) {
    {
#line 434
    if ((unsigned int )(im->gdes + gdp->shidx)->gf == 11U) {
#line 434
      goto case_11___0;
    }
#line 434
    if ((unsigned int )(im->gdes + gdp->shidx)->gf == 10U) {
#line 434
      goto case_11___0;
    }
#line 438
    if ((unsigned int )(im->gdes + gdp->shidx)->gf == 12U) {
#line 438
      goto case_12___0;
    }
#line 441
    goto switch_default___0;
    case_11___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    {
#line 435
    rrd_set_error((char *)"Offset cannot be a (C)DEF: \'%s\' in line \'%s\'\n", (im->gdes + gdp->shidx)->vname,
                  line);
    }
#line 437
    return (1);
    case_12___0: /* CIL Label */ 
#line 439
    if (gdp->debug) {
      {
#line 439
      printf((char const   */* __restrict  */)"- vname is of type VDEF, OK\n");
      }
    }
#line 440
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 442
    rrd_set_error((char *)"Encountered unknown type variable \'%s\' in line \'%s\'",
                  (im->gdes + gdp->vidx)->vname, line);
    }
#line 445
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 448
    time_tmp = 0L;
#line 450
    rrd_clear_error();
#line 451
    i = 0;
#line 452
    sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%li%n",
           & time_tmp, & i);
#line 453
    gdp->shval = time_tmp;
#line 454
    tmp___1 = strlen(line + *eaten);
    }
#line 454
    if (i != (int )tmp___1) {
      {
#line 455
      rrd_set_error((char *)"Not a valid offset: %s in line %s", line + *eaten, line);
      }
#line 457
      return (1);
    }
#line 459
    *eaten += (unsigned int )i;
#line 460
    if (gdp->debug) {
      {
#line 460
      printf((char const   */* __restrict  */)"- offset is number %li\n", gdp->shval);
      }
    }
#line 461
    gdp->shidx = -1;
  }
#line 463
  return (0);
}
}
#line 468 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_xport(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                    image_desc_t * const  im ) 
{ 
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 474
  tmp___0 = rrd_parse_find_vname(line, eaten, gdp, im);
#line 474
  tmp = (long )tmp___0;
#line 474
  gdp->vidx = tmp;
  }
#line 474
  if (tmp < 0L) {
#line 475
    return (1);
  }
  {
#line 479
  if ((unsigned int )(im->gdes + gdp->vidx)->gf == 11U) {
#line 479
    goto case_11;
  }
#line 479
  if ((unsigned int )(im->gdes + gdp->vidx)->gf == 10U) {
#line 479
    goto case_11;
  }
#line 482
  if ((unsigned int )(im->gdes + gdp->vidx)->gf == 12U) {
#line 482
    goto case_12;
  }
#line 486
  goto switch_default;
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 480
  if (gdp->debug) {
    {
#line 480
    printf((char const   */* __restrict  */)"- vname is of type DEF or CDEF, OK\n");
    }
  }
#line 481
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 483
  rrd_set_error((char *)"Cannot xport a VDEF: \'%s\' in line \'%s\'\n", (im->gdes + gdp->vidx)->vname,
                line);
  }
#line 485
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 487
  rrd_set_error((char *)"Encountered unknown type variable \'%s\' in line \'%s\'",
                (im->gdes + gdp->vidx)->vname, line);
  }
#line 489
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 491
  if (gdp->debug) {
    {
#line 491
    printf((char const   */* __restrict  */)"- looking for legend in \'%s\'\n", line + *eaten);
    }
  }
  {
#line 492
  tmp___1 = rrd_parse_legend(line, eaten, gdp);
  }
#line 492
  if (tmp___1) {
#line 493
    return (1);
  }
#line 494
  return (0);
}
}
#line 497 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_textalign(char const   * const  line , unsigned int * const  eaten ,
                        graph_desc_t * const  gdp ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 502
  tmp___2 = strcmp(line + *eaten, "left");
  }
#line 502
  if (tmp___2 == 0) {
#line 503
    gdp->txtalign = (enum txa_en )0;
  } else {
    {
#line 504
    tmp___1 = strcmp(line + *eaten, "right");
    }
#line 504
    if (tmp___1 == 0) {
#line 505
      gdp->txtalign = (enum txa_en )1;
    } else {
      {
#line 506
      tmp___0 = strcmp(line + *eaten, "justified");
      }
#line 506
      if (tmp___0 == 0) {
#line 507
        gdp->txtalign = (enum txa_en )3;
      } else {
        {
#line 508
        tmp = strcmp(line + *eaten, "center");
        }
#line 508
        if (tmp == 0) {
#line 509
          gdp->txtalign = (enum txa_en )2;
        } else {
          {
#line 511
          rrd_set_error((char *)"Unknown alignement type \'%s\'", line + *eaten);
          }
#line 512
          return (1);
        }
      }
    }
  }
  {
#line 514
  tmp___3 = strlen(line + *eaten);
#line 514
  *eaten = (unsigned int )((size_t )*eaten + tmp___3);
  }
#line 515
  return (0);
}
}
#line 538 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
static int spacecnt  =    0;
#line 529 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_PVHLAST(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                      image_desc_t * const  im ) 
{ 
  int i ;
  int j ;
  int k ;
  int colorfound ;
  char tmpstr[265] ;
  float one_space ;
  double tmp ;
  float target_space ;
  double tmp___0 ;
  long time_tmp ;
  long tmp___1 ;
  int tmp___2 ;
  int err ;
  char *linecp ;
  char *tmp___3 ;
  int spi ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  char csv[64] ;
  char *pch ;
  float dsh ;
  int count ;
  char *saveptr ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;

  {
#line 536
  colorfound = 0;
#line 540
  if (spacecnt == 0) {
    {
#line 541
    tmp = gfx_get_text_width((image_desc_t *)im, (double )0, im->text_prop[4].font_desc,
                             im->tabwidth, (char *)"    ");
#line 541
    one_space = (float )(tmp / 4.0);
#line 546
    tmp___0 = gfx_get_text_width((image_desc_t *)im, (double )0, im->text_prop[4].font_desc,
                                 im->tabwidth, (char *)"oo");
#line 546
    target_space = (float )tmp___0;
#line 552
    spacecnt = (int )(target_space / one_space);
    }
#line 553
    if (gdp->debug) {
      {
#line 553
      printf((char const   */* __restrict  */)"- spacecnt: %i onespace: %f targspace: %f\n",
             spacecnt, (double )one_space, (double )target_space);
      }
    }
  }
#line 558
  if (gdp->debug) {
    {
#line 558
    printf((char const   */* __restrict  */)"- parsing \'%s\'\n", line + *eaten);
    }
  }
#line 561
  if ((unsigned int )gdp->gf == 7U) {
#line 562
    gdp->stack = 1;
  }
  {
#line 565
  i = scan_for_col((char const   */* const  */)(line + *eaten), 264, (char */* const  */)(tmpstr));
  }
#line 566
  if ((int const   )*(line + (*eaten + (unsigned int )i)) != 0) {
#line 566
    if ((int const   )*(line + (*eaten + (unsigned int )i)) != 58) {
      {
#line 567
      rrd_set_error((char *)"Cannot parse line \'%s\'", line);
      }
#line 568
      return (1);
    }
  }
#line 571
  j = i;
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    if (j > 0) {
#line 572
      if (! ((int )tmpstr[j] != 35)) {
#line 572
        goto while_break;
      }
    } else {
#line 572
      goto while_break;
    }
#line 573
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 575
  if (j) {
#line 576
    tmpstr[j] = (char )'\000';
  }
#line 590
  if (gdp->debug) {
    {
#line 590
    printf((char const   */* __restrict  */)"- examining string \'%s\'\n", tmpstr);
    }
  }
  {
#line 591
  tmp___1 = find_var((image_desc_t *)im, tmpstr);
#line 591
  gdp->vidx = tmp___1;
  }
#line 591
  if (tmp___1 >= 0L) {
#line 592
    if (gdp->debug) {
      {
#line 592
      printf((char const   */* __restrict  */)"- found vname: \'%s\' vidx %li\n",
             tmpstr, gdp->vidx);
      }
    }
    {
#line 595
    if ((unsigned int )gdp->gf == 3U) {
#line 595
      goto case_3;
    }
#line 595
    if ((unsigned int )gdp->gf == 4U) {
#line 595
      goto case_3;
    }
#line 602
    goto switch_default;
    case_3: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 596
    if ((unsigned int )(im->gdes + gdp->vidx)->gf != 12U) {
      {
#line 597
      rrd_set_error((char *)"Using vname %s of wrong type in line %s\n", (im->gdes + gdp->gf)->vname,
                    line);
      }
#line 599
      return (1);
    }
#line 601
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 605
    time_tmp = 0L;
#line 607
    if (gdp->debug) {
      {
#line 607
      printf((char const   */* __restrict  */)"- it is not an existing vname\n");
      }
    }
    {
#line 609
    if ((unsigned int )gdp->gf == 4U) {
#line 609
      goto case_4___0;
    }
#line 622
    goto switch_default___0;
    case_4___0: /* CIL Label */ 
    {
#line 610
    k = 0;
#line 611
    sscanf((char const   */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"%li%n",
           & time_tmp, & k);
#line 612
    gdp->xrule = time_tmp;
    }
#line 613
    if (j != 0) {
#line 613
      if (k == j) {
#line 613
        goto _L;
      } else {
#line 613
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 613
    if (j == 0) {
#line 613
      if (k == i) {
        _L: /* CIL Label */ 
#line 614
        if (gdp->debug) {
          {
#line 614
          printf((char const   */* __restrict  */)"- found time: %li\n", gdp->xrule);
          }
        }
      } else {
#line 613
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 616
      if (gdp->debug) {
        {
#line 616
        printf((char const   */* __restrict  */)"- is is not a valid number: %li\n",
               gdp->xrule);
        }
      }
      {
#line 617
      rrd_set_error((char *)"parameter \'%s\' does not represent time in line %s\n",
                    tmpstr, line);
      }
#line 620
      return (1);
    }
    switch_default___0: /* CIL Label */ 
    {
#line 623
    k = 0;
#line 624
    sscanf((char const   */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"%lf%n",
           & gdp->yrule, & k);
    }
#line 625
    if (j != 0) {
#line 625
      if (k == j) {
#line 625
        goto _L___2;
      } else {
#line 625
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 625
    if (j == 0) {
#line 625
      if (k == i) {
        _L___2: /* CIL Label */ 
#line 626
        if (gdp->debug) {
          {
#line 626
          printf((char const   */* __restrict  */)"- found number: %lf\n", gdp->yrule);
          }
        }
      } else {
#line 625
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 628
      if (gdp->debug) {
        {
#line 628
        printf((char const   */* __restrict  */)"- is is not a valid number: %lf\n",
               gdp->yrule);
        }
      }
      {
#line 629
      rrd_set_error((char *)"parameter \'%s\' does not represent a number in line %s\n",
                    tmpstr, line);
      }
#line 632
      return (1);
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 637
  if (j) {
#line 638
    j ++;
#line 639
    if (gdp->debug) {
      {
#line 639
      printf((char const   */* __restrict  */)"- examining color \'%s\'\n", & tmpstr[j]);
      }
    }
    {
#line 640
    tmp___2 = rrd_parse_color((char const   */* const  */)(& tmpstr[j]), gdp);
    }
#line 640
    if (tmp___2) {
      {
#line 641
      rrd_set_error((char *)"Could not parse color in \'%s\'", & tmpstr[j]);
      }
#line 642
      return (1);
    }
#line 644
    if (gdp->debug) {
      {
#line 644
      printf((char const   */* __restrict  */)"- parsed color %0.0f,%0.0f,%0.0f,%0.0f\n",
             gdp->col.red, gdp->col.green, gdp->col.blue, gdp->col.alpha);
      }
    }
#line 646
    colorfound = 1;
  } else
#line 648
  if (gdp->debug) {
    {
#line 648
    printf((char const   */* __restrict  */)"- no color present in \'%s\'\n", tmpstr);
    }
  }
#line 651
  *eaten += (unsigned int )i;
#line 652
  if ((int const   )*(line + *eaten) != 0) {
#line 653
    (*eaten) ++;
  }
#line 656
  if ((unsigned int )gdp->gf == 8U) {
#line 657
    if (gdp->debug) {
      {
#line 657
      printf((char const   */* __restrict  */)"- parsing \'%s\'\n", line + *eaten);
      }
    }
#line 658
    if (gdp->debug) {
      {
#line 658
      printf((char const   */* __restrict  */)"- looking for optional TICK number\n");
      }
    }
    {
#line 659
    j = 0;
#line 660
    sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%lf%n",
           & gdp->yrule, & j);
    }
#line 661
    if (j) {
#line 662
      if ((int const   )*(line + (*eaten + (unsigned int )j)) != 0) {
#line 662
        if ((int const   )*(line + (*eaten + (unsigned int )j)) != 58) {
          {
#line 663
          rrd_set_error((char *)"Cannot parse TICK fraction \'%s\'", line);
          }
#line 664
          return (1);
        }
      }
#line 666
      if (gdp->debug) {
        {
#line 666
        printf((char const   */* __restrict  */)"- found number %f\n", gdp->yrule);
        }
      }
#line 667
      if (gdp->yrule > 1.0) {
        {
#line 668
        rrd_set_error((char *)"Tick factor should be <= 1.0");
        }
#line 669
        return (1);
      } else
#line 667
      if (gdp->yrule < - 1.0) {
        {
#line 668
        rrd_set_error((char *)"Tick factor should be <= 1.0");
        }
#line 669
        return (1);
      }
#line 671
      *eaten += (unsigned int )j;
    } else {
#line 673
      if (gdp->debug) {
        {
#line 673
        printf((char const   */* __restrict  */)"- not found, defaulting to 0.1\n");
        }
      }
#line 674
      gdp->yrule = 0.1;
    }
#line 676
    if ((int const   )*(line + *eaten) == 0) {
#line 677
      if (gdp->debug) {
        {
#line 677
        printf((char const   */* __restrict  */)"- done parsing line\n");
        }
      }
#line 678
      return (0);
    } else
#line 680
    if ((int const   )*(line + *eaten) == 58) {
#line 681
      (*eaten) ++;
    } else {
      {
#line 683
      rrd_set_error((char *)"Can\'t make sense of that TICK line");
      }
#line 684
      return (1);
    }
  }
#line 689
  if (gdp->debug) {
    {
#line 689
    printf((char const   */* __restrict  */)"- parsing \'%s\'\n", line + *eaten);
    }
  }
#line 699
  if (colorfound) {
    {
#line 700
    err = 0;
#line 701
    tmp___3 = strdup((char const   *)line);
#line 701
    linecp = tmp___3;
    }
#line 703
    if (gdp->debug) {
      {
#line 703
      printf((char const   */* __restrict  */)"- looking for optional legend\n");
      }
    }
#line 705
    if (gdp->debug) {
      {
#line 705
      printf((char const   */* __restrict  */)"- examining \'%s\'\n", line + *eaten);
      }
    }
#line 706
    if ((int )*(linecp + *eaten) != 0) {
#line 706
      if ((int )*(linecp + *eaten) != 58) {
#line 711
        spi = 0;
        {
#line 711
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 711
          if (spi < spacecnt) {
#line 711
            if (! (*eaten > 1U)) {
#line 711
              goto while_break___0;
            }
          } else {
#line 711
            goto while_break___0;
          }
#line 712
          (*eaten) --;
#line 712
          *(linecp + *eaten) = (char )' ';
#line 711
          spi ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 716
    tmp___4 = rrd_parse_legend((char const   */* const  */)linecp, eaten, gdp);
    }
#line 716
    if (tmp___4) {
#line 717
      err = 1;
    }
    {
#line 718
    free((void *)linecp);
    }
#line 719
    if (err) {
#line 720
      return (1);
    }
#line 722
    if (gdp->debug) {
      {
#line 722
      printf((char const   */* __restrict  */)"- found legend \'%s\'\n", & gdp->legend[2]);
      }
    }
  } else {
#line 724
    if (gdp->debug) {
      {
#line 724
      printf((char const   */* __restrict  */)"- skipping empty legend\n");
      }
    }
#line 725
    if ((int const   )*(line + *eaten) != 0) {
#line 725
      if ((int const   )*(line + *eaten) != 58) {
        {
#line 726
        rrd_set_error((char *)"Legend set but no color: %s", line + *eaten);
        }
#line 727
        return (1);
      }
    }
  }
#line 730
  if ((int const   )*(line + *eaten) == 0) {
#line 731
    if (gdp->debug) {
      {
#line 731
      printf((char const   */* __restrict  */)"- done parsing line\n");
      }
    }
#line 732
    return (0);
  }
#line 734
  (*eaten) ++;
#line 737
  if ((unsigned int )gdp->gf != 3U) {
#line 737
    if ((unsigned int )gdp->gf != 4U) {
#line 737
      if ((unsigned int )gdp->gf != 8U) {
#line 741
        if (gdp->debug) {
          {
#line 741
          printf((char const   */* __restrict  */)"- parsing \'%s\', looking for STACK\n",
                 line + *eaten);
          }
        }
        {
#line 742
        j = scan_for_col((char const   */* const  */)(line + *eaten), 5, (char */* const  */)(tmpstr));
#line 743
        tmp___5 = strcmp("STACK", (char const   *)(tmpstr));
        }
#line 743
        if (tmp___5) {
#line 758
          if (gdp->debug) {
            {
#line 758
            printf((char const   */* __restrict  */)"- not STACKing\n");
            }
          }
        } else {
#line 744
          if (gdp->debug) {
            {
#line 744
            printf((char const   */* __restrict  */)"- found STACK\n");
            }
          }
#line 745
          gdp->stack = 1;
#line 746
          *eaten += (unsigned int )j;
#line 747
          if ((int const   )*(line + *eaten) == 58) {
#line 748
            (*eaten) ++;
          } else
#line 749
          if ((int const   )*(line + *eaten) == 0) {
#line 750
            if (gdp->debug) {
              {
#line 750
              printf((char const   */* __restrict  */)"- done parsing line\n");
              }
            }
#line 751
            return (0);
          } else {
#line 753
            if (gdp->debug) {
              {
#line 753
              printf((char const   */* __restrict  */)"- found %s instead of just STACK\n",
                     line + *eaten);
              }
            }
            {
#line 754
            rrd_set_error((char *)"STACK expected but %s found", line + *eaten);
            }
#line 755
            return (1);
          }
        }
      }
    }
  }
#line 761
  if (gdp->debug) {
    {
#line 761
    printf((char const   */* __restrict  */)"- parsing \'%s\', looking for skipscale\n",
           line + *eaten);
    }
  }
  {
#line 762
  j = scan_for_col((char const   */* const  */)(line + *eaten), 9, (char */* const  */)(tmpstr));
#line 763
  tmp___6 = strcmp("skipscale", (char const   *)(tmpstr));
  }
#line 763
  if (! tmp___6) {
#line 764
    if (gdp->debug) {
      {
#line 764
      printf((char const   */* __restrict  */)"- found skipscale\n");
      }
    }
#line 765
    gdp->skipscale = 1;
#line 766
    *eaten += (unsigned int )j;
#line 767
    if ((int const   )*(line + *eaten) == 58) {
#line 768
      (*eaten) ++;
    } else
#line 769
    if ((int const   )*(line + *eaten) == 0) {
#line 770
      if (gdp->debug) {
        {
#line 770
        printf((char const   */* __restrict  */)"- done parsing line\n");
        }
      }
#line 771
      return (0);
    } else {
#line 773
      if (gdp->debug) {
        {
#line 773
        printf((char const   */* __restrict  */)"- found %s instead of just skipscale\n",
               line + *eaten);
        }
      }
      {
#line 774
      rrd_set_error((char *)"skipscale expected but %s found", line + *eaten);
      }
#line 775
      return (1);
    }
  }
#line 779
  if (gdp->debug) {
    {
#line 779
    printf((char const   */* __restrict  */)"- still more, should be dashes[=...]\n");
    }
  }
#line 780
  if (gdp->debug) {
    {
#line 780
    printf((char const   */* __restrict  */)"- parsing \'%s\'\n", line + *eaten);
    }
  }
#line 781
  if ((int const   )*(line + *eaten) != 0) {
    {
#line 787
    j = scan_for_col((char const   */* const  */)(line + *eaten), 64, (char */* const  */)(tmpstr));
#line 789
    tmp___11 = strcmp((char const   *)(tmpstr), "dashes");
    }
#line 789
    if (tmp___11 == 0) {
#line 792
      if (gdp->debug) {
        {
#line 792
        printf((char const   */* __restrict  */)"- found %s\n", tmpstr);
        }
      }
      {
#line 795
      gdp->dash = 1;
#line 796
      tmp___7 = malloc(sizeof(double ));
#line 796
      gdp->p_dashes = (double *)tmp___7;
#line 797
      *(gdp->p_dashes + 0) = (double )5;
#line 798
      gdp->ndash = 1;
#line 799
      gdp->offset = (double )0;
#line 800
      *eaten += (unsigned int )j;
      }
    } else {
      {
#line 801
      tmp___10 = sscanf((char const   */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"dashes=%s",
                        tmpstr);
      }
#line 801
      if (tmp___10) {
        {
#line 806
        count = 0;
#line 809
        strcpy((char */* __restrict  */)(csv), (char const   */* __restrict  */)(tmpstr));
#line 811
        pch = strtok_r((char */* __restrict  */)(tmpstr), (char const   */* __restrict  */)",",
                       (char **/* __restrict  */)(& saveptr));
        }
        {
#line 812
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 812
          if (! ((unsigned long )pch != (unsigned long )((void *)0))) {
#line 812
            goto while_break___1;
          }
          {
#line 813
          pch = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",",
                         (char **/* __restrict  */)(& saveptr));
#line 814
          count ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 816
        if (gdp->debug) {
          {
#line 816
          printf((char const   */* __restrict  */)"- %d dash value(s) found: ", count);
          }
        }
#line 817
        if (count > 0) {
          {
#line 818
          gdp->dash = 1;
#line 819
          gdp->ndash = count;
#line 820
          tmp___8 = malloc(sizeof(double ) * (unsigned long )count);
#line 820
          gdp->p_dashes = (double *)tmp___8;
#line 821
          pch = strtok_r((char */* __restrict  */)(csv), (char const   */* __restrict  */)",",
                         (char **/* __restrict  */)(& saveptr));
#line 822
          count = 0;
          }
          {
#line 823
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 823
            if (! ((unsigned long )pch != (unsigned long )((void *)0))) {
#line 823
              goto while_break___2;
            }
            {
#line 824
            tmp___9 = sscanf((char const   */* __restrict  */)pch, (char const   */* __restrict  */)"%f",
                             & dsh);
            }
#line 824
            if (tmp___9) {
#line 825
              *(gdp->p_dashes + count) = (double )dsh;
#line 826
              if (gdp->debug) {
                {
#line 826
                printf((char const   */* __restrict  */)"%.1f ", *(gdp->p_dashes + count));
                }
              }
#line 827
              count ++;
            }
            {
#line 829
            pch = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",",
                           (char **/* __restrict  */)(& saveptr));
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 831
          if (gdp->debug) {
            {
#line 831
            printf((char const   */* __restrict  */)"\n");
            }
          }
        } else
#line 833
        if (gdp->debug) {
          {
#line 833
          printf((char const   */* __restrict  */)"- syntax error. No dash lengths found!\n");
          }
        }
#line 834
        *eaten += (unsigned int )j;
      } else
#line 836
      if (gdp->debug) {
        {
#line 836
        printf((char const   */* __restrict  */)"- error: expected dashes[=...], found %s\n",
               tmpstr);
        }
      }
    }
#line 837
    if ((int const   )*(line + *eaten) == 58) {
#line 838
      (*eaten) ++;
    } else
#line 839
    if ((int const   )*(line + *eaten) == 0) {
#line 840
      if (gdp->debug) {
        {
#line 840
        printf((char const   */* __restrict  */)"- done parsing line\n");
        }
      }
#line 841
      return (0);
    }
    {
#line 846
    j = scan_for_col((char const   */* const  */)(line + *eaten), 16, (char */* const  */)(tmpstr));
#line 847
    tmp___12 = sscanf((char const   */* __restrict  */)(tmpstr), (char const   */* __restrict  */)"dash-offset=%lf",
                      & gdp->offset);
    }
#line 847
    if (tmp___12) {
#line 848
      if (gdp->debug) {
        {
#line 848
        printf((char const   */* __restrict  */)"- found dash-offset=%.1f\n", gdp->offset);
        }
      }
#line 849
      gdp->dash = 1;
#line 850
      *eaten += (unsigned int )j;
#line 851
      if ((int const   )*(line + *eaten) == 58) {
#line 852
        (*eaten) ++;
      }
    }
#line 854
    if ((int const   )*(line + *eaten) == 0) {
#line 855
      if (gdp->debug) {
        {
#line 855
        printf((char const   */* __restrict  */)"- done parsing line\n");
        }
      }
#line 856
      return (0);
    }
  }
#line 859
  if ((int const   )*(line + *eaten) == 0) {
#line 860
    if (gdp->debug) {
      {
#line 860
      printf((char const   */* __restrict  */)"- done parsing line\n");
      }
    }
#line 861
    return (0);
  }
#line 863
  (*eaten) ++;
#line 864
  if (gdp->debug) {
    {
#line 864
    printf((char const   */* __restrict  */)"- parsing \'%s\'\n", line + *eaten);
    }
  }
#line 866
  return (0);
}
}
#line 869 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_make_vname(char const   * const  line , unsigned int * const  eaten ,
                         graph_desc_t * const  gdp , image_desc_t * const  im ) 
{ 
  char tmpstr[265] ;
  int i ;
  long tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 876
  i = 0;
#line 878
  sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%255[-_A-Za-z0-9]=%n",
         tmpstr, & i);
  }
#line 879
  if (! i) {
    {
#line 880
    rrd_set_error((char *)"Cannot parse vname from \'%s\'", line);
    }
#line 881
    return (1);
  }
#line 883
  if ((int const   )*(line + (*eaten + (unsigned int )i)) == 0) {
    {
#line 884
    rrd_set_error((char *)"String ends after the = sign on \'%s\'", line);
    }
#line 885
    return (1);
  }
#line 887
  if (gdp->debug) {
    {
#line 887
    printf((char const   */* __restrict  */)"- found candidate \'%s\'\n", tmpstr);
    }
  }
  {
#line 889
  tmp = find_var((image_desc_t *)im, tmpstr);
#line 889
  gdp->vidx = tmp;
  }
#line 889
  if (tmp >= 0L) {
    {
#line 890
    rrd_set_error((char *)"Attempting to reuse \'%s\'", (im->gdes + gdp->vidx)->vname);
    }
#line 891
    return (1);
  }
  {
#line 893
  strcpy((char */* __restrict  */)(gdp->vname), (char const   */* __restrict  */)(tmpstr));
  }
#line 894
  if (gdp->debug) {
    {
#line 894
    printf((char const   */* __restrict  */)"- created vname \'%s\' vidx %lu\n", gdp->vname,
           im->gdes_c - 1L);
    }
  }
#line 895
  *eaten += (unsigned int )i;
#line 896
  return (0);
}
}
#line 899 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_def(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                  image_desc_t * const  im ) 
{ 
  int i ;
  char command[7] ;
  char tmpstr[256] ;
  rrd_time_value_t start_tv ;
  rrd_time_value_t end_tv ;
  time_t start_tmp ;
  time_t end_tmp ;
  char *parsetime_error ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
#line 905
  i = 0;
#line 909
  start_tmp = (time_t )0;
#line 909
  end_tmp = (time_t )0;
#line 910
  parsetime_error = (char *)((void *)0);
#line 912
  end_tv.type = (rrd_timetype_t )0;
#line 912
  start_tv.type = end_tv.type;
#line 913
  end_tv.offset = 0L;
#line 913
  start_tv.offset = end_tv.offset;
#line 914
  localtime_r((time_t const   */* __restrict  */)(& gdp->start), (struct tm */* __restrict  */)(& start_tv.tm));
#line 915
  localtime_r((time_t const   */* __restrict  */)(& gdp->end), (struct tm */* __restrict  */)(& end_tv.tm));
  }
#line 917
  if (gdp->debug) {
    {
#line 917
    printf((char const   */* __restrict  */)"- parsing \'%s\'\n", line + *eaten);
    }
  }
#line 918
  if (gdp->debug) {
    {
#line 918
    printf((char const   */* __restrict  */)"- from line \'%s\'\n", line);
    }
  }
  {
#line 920
  tmp = rrd_parse_make_vname(line, eaten, gdp, im);
  }
#line 920
  if (tmp) {
#line 921
    return (1);
  }
  {
#line 922
  i = scan_for_col((char const   */* const  */)(line + *eaten), (int )(sizeof(gdp->rrd) - 1UL),
                   (char */* const  */)(gdp->rrd));
  }
#line 923
  if ((int const   )*(line + (*eaten + (unsigned int )i)) != 58) {
    {
#line 924
    rrd_set_error((char *)"Problems reading database name");
    }
#line 925
    return (1);
  }
#line 927
  i ++;
#line 927
  *eaten += (unsigned int )i;
#line 928
  if (gdp->debug) {
    {
#line 928
    printf((char const   */* __restrict  */)"- using file \'%s\'\n", gdp->rrd);
    }
  }
  {
#line 930
  i = 0;
#line 931
  sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%19[a-zA-Z0-9_-]:%n",
         gdp->ds_nam, & i);
  }
#line 932
  if (! i) {
    {
#line 933
    rrd_set_error((char *)"Cannot parse DS in \'%s\'", line);
    }
#line 934
    return (1);
  }
#line 936
  *eaten += (unsigned int )i;
#line 937
  if (gdp->debug) {
    {
#line 937
    printf((char const   */* __restrict  */)"- using DS \'%s\'\n", gdp->ds_nam);
    }
  }
  {
#line 939
  tmp___0 = rrd_parse_CF(line, eaten, gdp, (enum cf_en */* const  */)(& gdp->cf));
  }
#line 939
  if (tmp___0) {
#line 940
    return (1);
  }
#line 941
  gdp->cf_reduce = gdp->cf;
#line 943
  if ((int const   )*(line + *eaten) == 0) {
#line 944
    return (0);
  }
  {
#line 946
  while (1) {
    while_continue: /* CIL Label */ ;
#line 947
    if (gdp->debug) {
      {
#line 947
      printf((char const   */* __restrict  */)"- optional parameter follows: %s\n",
             line + *eaten);
      }
    }
    {
#line 948
    i = 0;
#line 949
    sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%6[a-z]=%n",
           command, & i);
    }
#line 950
    if (! i) {
      {
#line 951
      rrd_set_error((char *)"Parse error in \'%s\'", line);
      }
#line 952
      return (1);
    }
#line 954
    *eaten += (unsigned int )i;
#line 955
    if (gdp->debug) {
      {
#line 955
      printf((char const   */* __restrict  */)"- processing \'%s\'\n", command);
      }
    }
    {
#line 956
    tmp___5 = strcmp("reduce", (char const   *)(command));
    }
#line 956
    if (tmp___5) {
      {
#line 961
      tmp___4 = strcmp("step", (char const   *)(command));
      }
#line 961
      if (tmp___4) {
        {
#line 967
        tmp___3 = strcmp("start", (char const   *)(command));
        }
#line 967
        if (tmp___3) {
          {
#line 975
          tmp___2 = strcmp("end", (char const   *)(command));
          }
#line 975
          if (tmp___2) {
            {
#line 984
            rrd_set_error((char *)"Parse error in \'%s\'", line);
            }
#line 985
            return (1);
          } else {
            {
#line 976
            i = scan_for_col((char const   */* const  */)(line + *eaten), 255, (char */* const  */)(tmpstr));
#line 977
            *eaten += (unsigned int )i;
#line 978
            parsetime_error = rrd_parsetime((char const   *)(tmpstr), & end_tv);
            }
#line 978
            if (parsetime_error) {
              {
#line 979
              rrd_set_error((char *)"end time: %s", parsetime_error);
              }
#line 980
              return (1);
            }
#line 982
            if (gdp->debug) {
              {
#line 982
              printf((char const   */* __restrict  */)"- done parsing:  \'%s\'\n",
                     line + *eaten);
              }
            }
          }
        } else {
          {
#line 968
          i = scan_for_col((char const   */* const  */)(line + *eaten), 255, (char */* const  */)(tmpstr));
#line 969
          *eaten += (unsigned int )i;
#line 970
          parsetime_error = rrd_parsetime((char const   *)(tmpstr), & start_tv);
          }
#line 970
          if (parsetime_error) {
            {
#line 971
            rrd_set_error((char *)"start time: %s", parsetime_error);
            }
#line 972
            return (1);
          }
#line 974
          if (gdp->debug) {
            {
#line 974
            printf((char const   */* __restrict  */)"- done parsing:  \'%s\'\n", line + *eaten);
            }
          }
        }
      } else {
        {
#line 962
        i = 0;
#line 963
        sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%lu%n",
               & gdp->step, & i);
#line 964
        gdp->step_orig = gdp->step;
#line 965
        *eaten += (unsigned int )i;
        }
#line 966
        if (gdp->debug) {
          {
#line 966
          printf((char const   */* __restrict  */)"- using step %lu\n", gdp->step);
          }
        }
      }
    } else {
      {
#line 957
      tmp___1 = rrd_parse_CF(line, eaten, gdp, (enum cf_en */* const  */)(& gdp->cf_reduce));
      }
#line 957
      if (tmp___1) {
#line 958
        return (1);
      }
#line 959
      if ((int const   )*(line + *eaten) != 0) {
#line 960
        (*eaten) --;
      }
    }
#line 987
    if ((int const   )*(line + *eaten) == 0) {
#line 988
      goto while_break;
    }
#line 989
    if ((int const   )*(line + *eaten) != 58) {
#line 990
      if (gdp->debug) {
        {
#line 990
        printf((char const   */* __restrict  */)"- Expected to see end of string but got \'%s\'\n",
               line + *eaten);
        }
      }
      {
#line 992
      rrd_set_error((char *)"Parse error in \'%s\'", line);
      }
#line 993
      return (1);
    }
#line 995
    (*eaten) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  tmp___6 = rrd_proc_start_end(& start_tv, & end_tv, & start_tmp, & end_tmp);
  }
#line 997
  if (tmp___6 == -1) {
#line 999
    return (1);
  }
#line 1001
  if (start_tmp < 315360000L) {
    {
#line 1002
    rrd_set_error((char *)"the first entry to fetch should be after 1980 (%ld)", start_tmp);
    }
#line 1004
    return (1);
  }
#line 1007
  if (end_tmp < start_tmp) {
    {
#line 1008
    rrd_set_error((char *)"start (%ld) should be less than end (%ld)", start_tmp,
                  end_tmp);
    }
#line 1010
    return (1);
  }
#line 1013
  gdp->start = start_tmp;
#line 1014
  gdp->end = end_tmp;
#line 1015
  gdp->start_orig = start_tmp;
#line 1016
  gdp->end_orig = end_tmp;
#line 1018
  if (gdp->debug) {
    {
#line 1018
    printf((char const   */* __restrict  */)"- start time %lu\n", gdp->start);
    }
  }
#line 1019
  if (gdp->debug) {
    {
#line 1019
    printf((char const   */* __restrict  */)"- end   time %lu\n", gdp->end);
    }
  }
#line 1021
  return (0);
}
}
#line 1024 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_vdef(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                   image_desc_t * const  im ) 
{ 
  char tmpstr[256] ;
  int i ;
  int tmp ;
  long tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1031
  i = 0;
#line 1033
  if (gdp->debug) {
    {
#line 1033
    printf((char const   */* __restrict  */)"- parsing \'%s\'\n", line + *eaten);
    }
  }
  {
#line 1034
  tmp = rrd_parse_make_vname(line, eaten, gdp, im);
  }
#line 1034
  if (tmp) {
#line 1035
    return (1);
  }
  {
#line 1037
  sscanf((char const   */* __restrict  */)(line + *eaten), (char const   */* __restrict  */)"%255[-_A-Za-z0-9],%n",
         tmpstr, & i);
  }
#line 1038
  if (! i) {
    {
#line 1039
    rrd_set_error((char *)"Cannot parse line \'%s\'", line);
    }
#line 1040
    return (1);
  }
  {
#line 1042
  tmp___0 = find_var((image_desc_t *)im, tmpstr);
#line 1042
  gdp->vidx = tmp___0;
  }
#line 1042
  if (tmp___0 < 0L) {
    {
#line 1043
    rrd_set_error((char *)"Not a valid vname: %s in line %s", tmpstr, line);
    }
#line 1044
    return (1);
  }
#line 1046
  if ((unsigned int )(im->gdes + gdp->vidx)->gf != 10U) {
#line 1046
    if ((unsigned int )(im->gdes + gdp->vidx)->gf != 11U) {
      {
#line 1047
      rrd_set_error((char *)"variable \'%s\' not DEF nor CDEF in VDEF \'%s\'", tmpstr,
                    gdp->vname);
      }
#line 1049
      return (1);
    }
  }
#line 1051
  if (gdp->debug) {
    {
#line 1051
    printf((char const   */* __restrict  */)"- found vname: \'%s\' vidx %li\n", tmpstr,
           gdp->vidx);
    }
  }
#line 1052
  *eaten += (unsigned int )i;
#line 1054
  if (gdp->debug) {
    {
#line 1054
    printf((char const   */* __restrict  */)"- calling vdef_parse with param \'%s\'\n",
           line + *eaten);
    }
  }
  {
#line 1055
  vdef_parse((struct graph_desc_t *)gdp, (char const   */* const  */)(line + *eaten));
  }
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if ((int const   )*(line + *eaten) != 0) {
#line 1056
      if (! ((int const   )*(line + *eaten) != 58)) {
#line 1056
        goto while_break;
      }
    } else {
#line 1056
      goto while_break;
    }
#line 1057
    (*eaten) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1059
  return (0);
}
}
#line 1062 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
int rrd_parse_cdef(char const   * const  line , unsigned int * const  eaten , graph_desc_t * const  gdp ,
                   image_desc_t * const  im ) 
{ 
  int tmp ;
  rpnp_t *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1068
  if (gdp->debug) {
    {
#line 1068
    printf((char const   */* __restrict  */)"- parsing \'%s\'\n", line + *eaten);
    }
  }
  {
#line 1069
  tmp = rrd_parse_make_vname(line, eaten, gdp, im);
  }
#line 1069
  if (tmp) {
#line 1070
    return (1);
  }
  {
#line 1071
  tmp___0 = rpn_parse((void *)im, (char const   */* const  */)(line + *eaten), & find_var_wrapper);
#line 1071
  gdp->rpnp = tmp___0;
  }
#line 1071
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 1073
    rrd_set_error((char *)"invalid rpn expression in: %s", line + *eaten);
    }
#line 1074
    return (1);
  }
  {
#line 1076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1076
    if ((int const   )*(line + *eaten) != 0) {
#line 1076
      if (! ((int const   )*(line + *eaten) != 58)) {
#line 1076
        goto while_break;
      }
    } else {
#line 1076
      goto while_break;
    }
#line 1077
    (*eaten) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1078
  return (0);
}
}
#line 1081 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph_helper.c"
void rrd_graph_script(int argc , char **argv , image_desc_t * const  im , int optno ) 
{ 
  int i ;
  enum gf_en last_gf ;
  float last_linewidth ;
  graph_desc_t *gdp ;
  unsigned int eaten ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  char *key ;
  char *tmp___14 ;
  gchar *tmp___15 ;
  gboolean tmp___16 ;
  gchar *tmp___17 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 1090
  last_gf = (enum gf_en )0;
#line 1091
  last_linewidth = (float )0.0;
#line 1093
  i = optind + optno;
  {
#line 1093
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1093
    if (! (i < argc)) {
#line 1093
      goto while_break;
    }
    {
#line 1095
    eaten = 0U;
#line 1097
    tmp = gdes_alloc((image_desc_t *)im);
    }
#line 1097
    if (tmp) {
#line 1098
      return;
    }
    {
#line 1099
    gdp = im->gdes + (im->gdes_c - 1L);
#line 1104
    tmp___0 = rrd_parse_find_gf((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                                (graph_desc_t */* const  */)gdp);
    }
#line 1104
    if (tmp___0) {
#line 1105
      return;
    }
    {
#line 1108
    if ((unsigned int )gdp->gf == 13U) {
#line 1108
      goto case_13;
    }
#line 1112
    if ((unsigned int )gdp->gf == 9U) {
#line 1112
      goto case_9;
    }
#line 1116
    if ((unsigned int )gdp->gf == 14U) {
#line 1116
      goto case_14;
    }
#line 1120
    if ((unsigned int )gdp->gf == 0U) {
#line 1120
      goto case_0;
    }
#line 1122
    if ((unsigned int )gdp->gf == 1U) {
#line 1122
      goto case_1;
    }
#line 1126
    if ((unsigned int )gdp->gf == 2U) {
#line 1126
      goto case_2;
    }
#line 1134
    if ((unsigned int )gdp->gf == 8U) {
#line 1134
      goto case_8;
    }
#line 1134
    if ((unsigned int )gdp->gf == 6U) {
#line 1134
      goto case_8;
    }
#line 1134
    if ((unsigned int )gdp->gf == 5U) {
#line 1134
      goto case_8;
    }
#line 1134
    if ((unsigned int )gdp->gf == 3U) {
#line 1134
      goto case_8;
    }
#line 1134
    if ((unsigned int )gdp->gf == 4U) {
#line 1134
      goto case_8;
    }
#line 1140
    if ((unsigned int )gdp->gf == 7U) {
#line 1140
      goto case_7;
    }
#line 1153
    if ((unsigned int )gdp->gf == 10U) {
#line 1153
      goto case_10;
    }
#line 1157
    if ((unsigned int )gdp->gf == 11U) {
#line 1157
      goto case_11;
    }
#line 1161
    if ((unsigned int )gdp->gf == 12U) {
#line 1161
      goto case_12;
    }
#line 1107
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 1109
    tmp___1 = rrd_parse_shift((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                              (graph_desc_t */* const  */)gdp, im);
    }
#line 1109
    if (tmp___1) {
#line 1110
      return;
    }
#line 1111
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 1113
    tmp___2 = rrd_parse_textalign((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                                  (graph_desc_t */* const  */)gdp);
    }
#line 1113
    if (tmp___2) {
#line 1114
      return;
    }
#line 1115
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 1117
    tmp___3 = rrd_parse_xport((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                              (graph_desc_t */* const  */)gdp, im);
    }
#line 1117
    if (tmp___3) {
#line 1118
      return;
    }
#line 1119
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1121
    (im->prt_c) ++;
    case_1: /* CIL Label */ 
    {
#line 1123
    tmp___4 = rrd_parse_print((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                              (graph_desc_t */* const  */)gdp, im);
    }
#line 1123
    if (tmp___4) {
#line 1124
      return;
    }
#line 1125
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1127
    tmp___5 = rrd_parse_legend((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                               (graph_desc_t */* const  */)gdp);
    }
#line 1127
    if (tmp___5) {
#line 1128
      return;
    }
#line 1129
    goto switch_break;
    case_8: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 1135
    tmp___6 = rrd_parse_PVHLAST((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                                (graph_desc_t */* const  */)gdp, im);
    }
#line 1135
    if (tmp___6) {
#line 1136
      return;
    }
#line 1137
    last_gf = gdp->gf;
#line 1138
    last_linewidth = (float )gdp->linewidth;
#line 1139
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1141
    tmp___7 = rrd_parse_PVHLAST((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                                (graph_desc_t */* const  */)gdp, im);
    }
#line 1141
    if (tmp___7) {
#line 1142
      return;
    }
#line 1143
    if ((unsigned int )last_gf == 5U) {
#line 1144
      gdp->gf = last_gf;
#line 1145
      gdp->linewidth = (double )last_linewidth;
    } else
#line 1143
    if ((unsigned int )last_gf == 6U) {
#line 1144
      gdp->gf = last_gf;
#line 1145
      gdp->linewidth = (double )last_linewidth;
    } else {
      {
#line 1147
      rrd_set_error((char *)"STACK must follow LINE or AREA! command:\n%s", *(argv + i) + eaten,
                    *(argv + i));
      }
#line 1149
      return;
    }
#line 1151
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 1154
    tmp___8 = rrd_parse_def((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                            (graph_desc_t */* const  */)gdp, im);
    }
#line 1154
    if (tmp___8) {
#line 1155
      return;
    }
#line 1156
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 1158
    tmp___9 = rrd_parse_cdef((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                             (graph_desc_t */* const  */)gdp, im);
    }
#line 1158
    if (tmp___9) {
#line 1159
      return;
    }
#line 1160
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 1162
    tmp___10 = rrd_parse_vdef((char const   */* const  */)*(argv + i), (unsigned int */* const  */)(& eaten),
                              (graph_desc_t */* const  */)gdp, im);
    }
#line 1162
    if (tmp___10) {
#line 1163
      return;
    }
#line 1164
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1166
    if (gdp->debug) {
#line 1167
      if (gdp->debug) {
        {
#line 1167
        tmp___11 = strlen((char const   *)*(argv + i));
#line 1167
        printf((char const   */* __restrict  */)"used %i out of %zi chars\n", eaten,
               tmp___11);
        }
      }
#line 1168
      if (gdp->debug) {
        {
#line 1168
        printf((char const   */* __restrict  */)"parsed line: \'%s\'\n", *(argv + i));
        }
      }
#line 1169
      if (gdp->debug) {
        {
#line 1169
        printf((char const   */* __restrict  */)"remaining: \'%s\'\n", *(argv + i) + eaten);
        }
      }
      {
#line 1170
      tmp___12 = strlen((char const   *)*(argv + i));
      }
#line 1170
      if ((size_t )eaten >= tmp___12) {
#line 1171
        if (gdp->debug) {
          {
#line 1171
          printf((char const   */* __restrict  */)"Command finished successfully\n");
          }
        }
      }
    }
    {
#line 1173
    tmp___13 = strlen((char const   *)*(argv + i));
    }
#line 1173
    if ((size_t )eaten < tmp___13) {
      {
#line 1174
      rrd_set_error((char *)"I don\'t understand \'%s\' in command: \'%s\'.", *(argv + i) + eaten,
                    *(argv + i));
      }
#line 1176
      return;
    }
    {
#line 1178
    tmp___14 = sprintf_alloc((char *)"%s:%d:%d:%d:%d", gdp->rrd, (unsigned int )gdp->cf,
                             (unsigned int )gdp->cf_reduce, gdp->start_orig, gdp->end_orig,
                             gdp->step_orig);
#line 1178
    key = tmp___14;
    }
#line 1179
    if ((unsigned int )gdp->gf == 10U) {
      {
#line 1179
      tmp___16 = g_hash_table_lookup_extended(im->rrd_map, (gconstpointer )key, (gpointer *)((void *)0),
                                              (gpointer *)((void *)0));
      }
#line 1179
      if (! tmp___16) {
        {
#line 1180
        tmp___15 = g_strdup((gchar const   *)key);
#line 1180
        g_hash_table_insert(im->gdef_map, (gpointer )tmp___15, (gpointer )(im->gdes_c - 1L));
        }
      }
    }
    {
#line 1182
    free((void *)key);
    }
#line 1183
    if ((unsigned int )gdp->gf == 10U) {
      {
#line 1184
      tmp___17 = g_strdup((gchar const   *)(gdp->vname));
#line 1184
      g_hash_table_insert(im->gdef_map, (gpointer )tmp___17, (gpointer )(im->gdes_c - 1L));
      }
    } else
#line 1183
    if ((unsigned int )gdp->gf == 12U) {
      {
#line 1184
      tmp___17 = g_strdup((gchar const   *)(gdp->vname));
#line 1184
      g_hash_table_insert(im->gdef_map, (gpointer )tmp___17, (gpointer )(im->gdes_c - 1L));
      }
    } else
#line 1183
    if ((unsigned int )gdp->gf == 11U) {
      {
#line 1184
      tmp___17 = g_strdup((gchar const   *)(gdp->vname));
#line 1184
      g_hash_table_insert(im->gdef_map, (gpointer )tmp___17, (gpointer )(im->gdes_c - 1L));
      }
    }
#line 1093
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1187
  return;
}
}
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 293
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) tzset)(void) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 341
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log10)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 195
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __finite)(double __value )  __attribute__((__const__)) ;
#line 309
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) round)(double __x )  __attribute__((__const__)) ;
#line 195
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __finitef)(float __value )  __attribute__((__const__)) ;
#line 195
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __finitel)(long double __value )  __attribute__((__const__)) ;
#line 166 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_graph(int argc , char **argv , char ***prdata , int *xsize , int *ysize ,
              FILE *stream , double *ymin , double *ymax ) ;
#line 175
rrd_info_t *rrd_graph_v(int argc , char **argv ) ;
#line 88 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.h"
int rrd_fetch_fn(char const   *filename , enum cf_en cf_idx , time_t *start , time_t *end ,
                 unsigned long *step , unsigned long *ds_cnt , char ***ds_namv , rrd_value_t **data ) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 583 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 482 "/usr/include/cairo/cairo.h"
extern cairo_t *cairo_create(cairo_surface_t *target ) ;
#line 488
extern void cairo_destroy(cairo_t *cr ) ;
#line 715
extern void cairo_set_antialias(cairo_t *cr , cairo_antialias_t antialias ) ;
#line 774
extern void cairo_set_line_cap(cairo_t *cr , cairo_line_cap_t line_cap ) ;
#line 798
extern void cairo_set_line_join(cairo_t *cr , cairo_line_join_t line_join ) ;
#line 813
extern void cairo_scale(cairo_t *cr , double sx , double sy ) ;
#line 893
extern void cairo_rectangle(cairo_t *cr , double x , double y , double width , double height ) ;
#line 944
extern void cairo_show_page(cairo_t *cr ) ;
#line 969
extern void cairo_reset_clip(cairo_t *cr ) ;
#line 972
extern void cairo_clip(cairo_t *cr ) ;
#line 1368
extern cairo_font_options_t *cairo_font_options_create(void) ;
#line 1374
extern void cairo_font_options_destroy(cairo_font_options_t *options ) ;
#line 1390
extern void cairo_font_options_set_antialias(cairo_font_options_t *options , cairo_antialias_t antialias ) ;
#line 1402
extern void cairo_font_options_set_hint_style(cairo_font_options_t *options , cairo_hint_style_t hint_style ) ;
#line 1408
extern void cairo_font_options_set_hint_metrics(cairo_font_options_t *options , cairo_hint_metrics_t hint_metrics ) ;
#line 2095
extern cairo_status_t cairo_status(cairo_t *cr ) ;
#line 2098
extern char const   *cairo_status_to_string(cairo_status_t status ) ;
#line 2304
extern void cairo_surface_finish(cairo_surface_t *surface ) ;
#line 2307
extern void cairo_surface_destroy(cairo_surface_t *surface ) ;
#line 2408
extern cairo_status_t cairo_surface_write_to_png(cairo_surface_t *surface , char const   *filename ) ;
#line 2412
extern cairo_status_t cairo_surface_write_to_png_stream(cairo_surface_t *surface ,
                                                        cairo_status_t (*write_func)(void *closure ,
                                                                                     unsigned char const   *data ,
                                                                                     unsigned int length ) ,
                                                        void *closure ) ;
#line 2514
extern cairo_surface_t *cairo_image_surface_create(cairo_format_t format , int width ,
                                                   int height ) ;
#line 61 "/usr/include/cairo/cairo-pdf.h"
extern cairo_surface_t *cairo_pdf_surface_create(char const   *filename , double width_in_points ,
                                                 double height_in_points ) ;
#line 66
extern cairo_surface_t *cairo_pdf_surface_create_for_stream(cairo_status_t (*write_func)(void *closure ,
                                                                                         unsigned char const   *data ,
                                                                                         unsigned int length ) ,
                                                            void *closure , double width_in_points ,
                                                            double height_in_points ) ;
#line 56 "/usr/include/cairo/cairo-svg.h"
extern cairo_surface_t *cairo_svg_surface_create(char const   *filename , double width_in_points ,
                                                 double height_in_points ) ;
#line 61
extern cairo_surface_t *cairo_svg_surface_create_for_stream(cairo_status_t (*write_func)(void *closure ,
                                                                                         unsigned char const   *data ,
                                                                                         unsigned int length ) ,
                                                            void *closure , double width_in_points ,
                                                            double height_in_points ) ;
#line 67
extern void cairo_svg_surface_restrict_to_version(cairo_surface_t *surface , cairo_svg_version_t version ) ;
#line 66 "/usr/include/cairo/cairo-ps.h"
extern cairo_surface_t *cairo_ps_surface_create(char const   *filename , double width_in_points ,
                                                double height_in_points ) ;
#line 71
extern cairo_surface_t *cairo_ps_surface_create_for_stream(cairo_status_t (*write_func)(void *closure ,
                                                                                        unsigned char const   *data ,
                                                                                        unsigned int length ) ,
                                                           void *closure , double width_in_points ,
                                                           double height_in_points ) ;
#line 59 "/usr/include/glib-2.0/glib/ghash.h"
extern GHashTable *g_hash_table_new_full(guint (*hash_func)(gconstpointer key ) ,
                                         gboolean (*key_equal_func)(gconstpointer a ,
                                                                    gconstpointer b ) ,
                                         void (*key_destroy_func)(gpointer data ) ,
                                         void (*value_destroy_func)(gpointer data ) ) ;
#line 64
extern void g_hash_table_destroy(GHashTable *hash_table ) ;
#line 153
extern gboolean g_str_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 156
extern guint g_str_hash(gconstpointer v ) ;
#line 35 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
#pragma GCC diagnostic push
#line 35
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 35
#pragma GCC diagnostic pop
#line 36
#pragma GCC diagnostic push
#line 36
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 36
#pragma GCC diagnostic pop
#line 37
#pragma GCC diagnostic push
#line 37
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 37
#pragma GCC diagnostic pop
#line 38
#pragma GCC diagnostic push
#line 38
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 38
#pragma GCC diagnostic pop
#line 39
#pragma GCC diagnostic push
#line 39
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 39
#pragma GCC diagnostic pop
#line 40
#pragma GCC diagnostic push
#line 40
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 40
#pragma GCC diagnostic pop
#line 41
#pragma GCC diagnostic push
#line 41
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 41
#pragma GCC diagnostic pop
#line 42
#pragma GCC diagnostic push
#line 42
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 42
#pragma GCC diagnostic pop
#line 43
#pragma GCC diagnostic push
#line 43
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 43
#pragma GCC diagnostic pop
#line 44
#pragma GCC diagnostic push
#line 44
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 44
#pragma GCC diagnostic pop
#line 45
#pragma GCC diagnostic push
#line 45
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 45
#pragma GCC diagnostic pop
#line 46
#pragma GCC diagnostic push
#line 46
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 46
#pragma GCC diagnostic pop
#line 47
#pragma GCC diagnostic push
#line 47
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 47
#pragma GCC diagnostic pop
#line 48
#pragma GCC diagnostic push
#line 48
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 48
#pragma GCC diagnostic pop
#line 49
#pragma GCC diagnostic push
#line 49
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 49
#pragma GCC diagnostic pop
#line 50
#pragma GCC diagnostic push
#line 50
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 50
#pragma GCC diagnostic pop
#line 51
#pragma GCC diagnostic push
#line 51
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 51
#pragma GCC diagnostic pop
#line 52
#pragma GCC diagnostic push
#line 52
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 52
#pragma GCC diagnostic pop
#line 53
#pragma GCC diagnostic push
#line 53
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 53
#pragma GCC diagnostic pop
#line 54
#pragma GCC diagnostic push
#line 54
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 54
#pragma GCC diagnostic pop
#line 55
#pragma GCC diagnostic push
#line 55
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 55
#pragma GCC diagnostic pop
#line 56
#pragma GCC diagnostic push
#line 56
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 56
#pragma GCC diagnostic pop
#line 57
#pragma GCC diagnostic push
#line 57
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 57
#pragma GCC diagnostic pop
#line 58
#pragma GCC diagnostic push
#line 58
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 58
#pragma GCC diagnostic pop
#line 59
#pragma GCC diagnostic push
#line 59
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 59
#pragma GCC diagnostic pop
#line 60
#pragma GCC diagnostic push
#line 60
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 60
#pragma GCC diagnostic pop
#line 61
#pragma GCC diagnostic push
#line 61
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 61
#pragma GCC diagnostic pop
#line 62
#pragma GCC diagnostic push
#line 62
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 62
#pragma GCC diagnostic pop
#line 63
#pragma GCC diagnostic push
#line 63
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 63
#pragma GCC diagnostic pop
#line 64
#pragma GCC diagnostic push
#line 64
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 64
#pragma GCC diagnostic pop
#line 65
#pragma GCC diagnostic push
#line 65
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 65
#pragma GCC diagnostic pop
#line 66
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 66
#pragma GCC diagnostic pop
#line 67
#pragma GCC diagnostic push
#line 67
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 67
#pragma GCC diagnostic pop
#line 68
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 68
#pragma GCC diagnostic pop
#line 69
#pragma GCC diagnostic push
#line 69
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 69
#pragma GCC diagnostic pop
#line 70
#pragma GCC diagnostic push
#line 70
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 70
#pragma GCC diagnostic pop
#line 71
#pragma GCC diagnostic push
#line 71
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 71
#pragma GCC diagnostic pop
#line 72
#pragma GCC diagnostic push
#line 72
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 72
#pragma GCC diagnostic pop
#line 73
#pragma GCC diagnostic push
#line 73
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 73
#pragma GCC diagnostic pop
#line 74
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 74
#pragma GCC diagnostic pop
#line 75
#pragma GCC diagnostic push
#line 75
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 75
#pragma GCC diagnostic pop
#line 76
#pragma GCC diagnostic push
#line 76
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 76
#pragma GCC diagnostic pop
#line 77
#pragma GCC diagnostic push
#line 77
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 77
#pragma GCC diagnostic pop
#line 78
#pragma GCC diagnostic push
#line 78
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 78
#pragma GCC diagnostic pop
#line 79
#pragma GCC diagnostic push
#line 79
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 79
#pragma GCC diagnostic pop
#line 80
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 80
#pragma GCC diagnostic pop
#line 81
#pragma GCC diagnostic push
#line 81
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 81
#pragma GCC diagnostic pop
#line 479 "/usr/include/glib-2.0/gobject/gobject.h"
extern void g_object_unref(gpointer object ) ;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
#pragma GCC diagnostic push
#line 24
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 24
#pragma GCC diagnostic pop
#line 25
#pragma GCC diagnostic push
#line 25
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 25
#pragma GCC diagnostic pop
#line 26
#pragma GCC diagnostic push
#line 26
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 26
#pragma GCC diagnostic pop
#line 27
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#line 27
#pragma GCC diagnostic pop
#line 224 "/usr/include/pango-1.0/pango/pango-font.h"
extern void pango_font_description_free(PangoFontDescription *desc ) ;
#line 245
extern void pango_font_description_set_size(PangoFontDescription *desc , gint size ) ;
#line 270
extern PangoFontDescription *pango_font_description_from_string(char const   *str ) ;
#line 135 "/usr/include/pango-1.0/pango/pango-layout.h"
extern PangoLayout *pango_layout_new(PangoContext *context ) ;
#line 138
extern PangoContext *pango_layout_get_context(PangoLayout *layout ) ;
#line 208
extern void pango_layout_context_changed(PangoLayout *layout ) ;
#line 84 "/usr/include/pango-1.0/pango/pangocairo.h"
extern PangoFontMap *pango_cairo_font_map_get_default(void) ;
#line 92
extern PangoContext __attribute__((__deprecated__("Use \'pango_font_map_create_context\' instead")))  *pango_cairo_font_map_create_context(PangoCairoFontMap *fontmap ) ;
#line 105
extern void pango_cairo_update_context(cairo_t *cr , PangoContext *context ) ;
#line 108
extern void pango_cairo_context_set_font_options(PangoContext *context , cairo_font_options_t const   *options ) ;
#line 112
extern void pango_cairo_context_set_resolution(PangoContext *context , double dpi ) ;
#line 295 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.h"
int xtr(image_desc_t *im , time_t mytime ) ;
#line 298
double ytr(image_desc_t *im , double value ) ;
#line 303
enum gfx_if_en if_conv(char *string ) ;
#line 305
enum tmt_en tmt_conv(char *string ) ;
#line 307
enum grc_en grc_conv(char *string ) ;
#line 309
enum text_prop_en text_prop_conv(char *string ) ;
#line 313
void auto_scale(image_desc_t *im , double *value , char **symb_ptr , double *magfact ) ;
#line 318
void si_unit(image_desc_t *im ) ;
#line 320
void expand_range(image_desc_t *im ) ;
#line 322
void apply_gridfit(image_desc_t *im ) ;
#line 324
void reduce_data(enum cf_en cf , unsigned long cur_step , time_t *start , time_t *end ,
                 unsigned long *step , unsigned long *ds_cnt , rrd_value_t **data ) ;
#line 344
int data_proc(image_desc_t *im ) ;
#line 346
time_t find_first_time(time_t start , enum tmt_en baseint , long basestep ) ;
#line 350
time_t find_next_time(time_t current , enum tmt_en baseint , long basestep ) ;
#line 354
int print_calc(image_desc_t *im ) ;
#line 356
int leg_place(image_desc_t *im , int calc_width ) ;
#line 359
int calc_horizontal_grid(image_desc_t *im ) ;
#line 361
int draw_horizontal_grid(image_desc_t *im ) ;
#line 363
int horizontal_log_grid(image_desc_t *im ) ;
#line 365
void vertical_grid(image_desc_t *im ) ;
#line 367
void axis_paint(image_desc_t *im ) ;
#line 369
void grid_paint(image_desc_t *im ) ;
#line 371
int lazy_check(image_desc_t *im ) ;
#line 373
int graph_paint(image_desc_t *im ) ;
#line 385
void rrd_graph_options(int argc , char **argv , image_desc_t *im ) ;
#line 394
int rrd_graph_color(image_desc_t *im , char *var , char *err , int optional ) ;
#line 399
int bad_format(char *fmt ) ;
#line 404
int vdef_calc(image_desc_t *im , int gdi ) ;
#line 407
int vdef_percent_compar(void const   *a , void const   *b ) ;
#line 410
int graph_size_location(image_desc_t *im , int elements ) ;
#line 496
void grinfo_push(image_desc_t *im , char *key , rrd_info_type_t type , rrd_infoval_t value ) ;
#line 48 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
text_prop_t text_prop[6]  = {      {8.0, {(char )'D', (char )'e', (char )'j', (char )'a', (char )'V', (char )'u',
            (char )' ', (char )'S', (char )'a', (char )'n', (char )'s', (char )' ',
            (char )'M', (char )'o', (char )'n', (char )'o', (char )',', (char )'B',
            (char )'i', (char )'t', (char )'s', (char )'t', (char )'r', (char )'e',
            (char )'a', (char )'m', (char )' ', (char )'V', (char )'e', (char )'r',
            (char )'a', (char )' ', (char )'S', (char )'a', (char )'n', (char )'s',
            (char )' ', (char )'M', (char )'o', (char )'n', (char )'o', (char )',',
            (char )'m', (char )'o', (char )'n', (char )'o', (char )'s', (char )'p',
            (char )'a', (char )'c', (char )'e', (char )',', (char )'C', (char )'o',
            (char )'u', (char )'r', (char )'i', (char )'e', (char )'r', (char )'\000'},
      (PangoFontDescription *)((void *)0)}, 
        {9.0, {(char )'D', (char )'e', (char )'j', (char )'a', (char )'V', (char )'u',
            (char )' ', (char )'S', (char )'a', (char )'n', (char )'s', (char )' ',
            (char )'M', (char )'o', (char )'n', (char )'o', (char )',', (char )'B',
            (char )'i', (char )'t', (char )'s', (char )'t', (char )'r', (char )'e',
            (char )'a', (char )'m', (char )' ', (char )'V', (char )'e', (char )'r',
            (char )'a', (char )' ', (char )'S', (char )'a', (char )'n', (char )'s',
            (char )' ', (char )'M', (char )'o', (char )'n', (char )'o', (char )',',
            (char )'m', (char )'o', (char )'n', (char )'o', (char )'s', (char )'p',
            (char )'a', (char )'c', (char )'e', (char )',', (char )'C', (char )'o',
            (char )'u', (char )'r', (char )'i', (char )'e', (char )'r', (char )'\000'},
      (PangoFontDescription *)((void *)0)}, 
        {7.0, {(char )'D', (char )'e', (char )'j', (char )'a', (char )'V', (char )'u',
            (char )' ', (char )'S', (char )'a', (char )'n', (char )'s', (char )' ',
            (char )'M', (char )'o', (char )'n', (char )'o', (char )',', (char )'B',
            (char )'i', (char )'t', (char )'s', (char )'t', (char )'r', (char )'e',
            (char )'a', (char )'m', (char )' ', (char )'V', (char )'e', (char )'r',
            (char )'a', (char )' ', (char )'S', (char )'a', (char )'n', (char )'s',
            (char )' ', (char )'M', (char )'o', (char )'n', (char )'o', (char )',',
            (char )'m', (char )'o', (char )'n', (char )'o', (char )'s', (char )'p',
            (char )'a', (char )'c', (char )'e', (char )',', (char )'C', (char )'o',
            (char )'u', (char )'r', (char )'i', (char )'e', (char )'r', (char )'\000'},
      (PangoFontDescription *)((void *)0)}, 
        {8.0, {(char )'D', (char )'e', (char )'j', (char )'a', (char )'V', (char )'u',
            (char )' ', (char )'S', (char )'a', (char )'n', (char )'s', (char )' ',
            (char )'M', (char )'o', (char )'n', (char )'o', (char )',', (char )'B',
            (char )'i', (char )'t', (char )'s', (char )'t', (char )'r', (char )'e',
            (char )'a', (char )'m', (char )' ', (char )'V', (char )'e', (char )'r',
            (char )'a', (char )' ', (char )'S', (char )'a', (char )'n', (char )'s',
            (char )' ', (char )'M', (char )'o', (char )'n', (char )'o', (char )',',
            (char )'m', (char )'o', (char )'n', (char )'o', (char )'s', (char )'p',
            (char )'a', (char )'c', (char )'e', (char )',', (char )'C', (char )'o',
            (char )'u', (char )'r', (char )'i', (char )'e', (char )'r', (char )'\000'},
      (PangoFontDescription *)((void *)0)}, 
        {8.0, {(char )'D', (char )'e', (char )'j', (char )'a', (char )'V', (char )'u',
            (char )' ', (char )'S', (char )'a', (char )'n', (char )'s', (char )' ',
            (char )'M', (char )'o', (char )'n', (char )'o', (char )',', (char )'B',
            (char )'i', (char )'t', (char )'s', (char )'t', (char )'r', (char )'e',
            (char )'a', (char )'m', (char )' ', (char )'V', (char )'e', (char )'r',
            (char )'a', (char )' ', (char )'S', (char )'a', (char )'n', (char )'s',
            (char )' ', (char )'M', (char )'o', (char )'n', (char )'o', (char )',',
            (char )'m', (char )'o', (char )'n', (char )'o', (char )'s', (char )'p',
            (char )'a', (char )'c', (char )'e', (char )',', (char )'C', (char )'o',
            (char )'u', (char )'r', (char )'i', (char )'e', (char )'r', (char )'\000'},
      (PangoFontDescription *)((void *)0)}, 
        {5.5, {(char )'D', (char )'e', (char )'j', (char )'a', (char )'V', (char )'u',
            (char )' ', (char )'S', (char )'a', (char )'n', (char )'s', (char )' ',
            (char )'M', (char )'o', (char )'n', (char )'o', (char )',', (char )'B',
            (char )'i', (char )'t', (char )'s', (char )'t', (char )'r', (char )'e',
            (char )'a', (char )'m', (char )' ', (char )'V', (char )'e', (char )'r',
            (char )'a', (char )' ', (char )'S', (char )'a', (char )'n', (char )'s',
            (char )' ', (char )'M', (char )'o', (char )'n', (char )'o', (char )',',
            (char )'m', (char )'o', (char )'n', (char )'o', (char )'s', (char )'p',
            (char )'a', (char )'c', (char )'e', (char )',', (char )'C', (char )'o',
            (char )'u', (char )'r', (char )'i', (char )'e', (char )'r', (char )'\000'},
      (PangoFontDescription *)((void *)0)}};
#line 62 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
xlab_t xlab[20]  = 
#line 62
  {      {0L, 0L, (enum tmt_en )0, 30L, (enum tmt_en )1, 5L, (enum tmt_en )1, 5L, 0L,
      (char *)"%H:%M"}, 
        {2L, 0L, (enum tmt_en )1, 1L, (enum tmt_en )1, 5L, (enum tmt_en )1, 5L, 0L, (char *)"%H:%M"}, 
        {5L,
      0L, (enum tmt_en )1, 2L, (enum tmt_en )1, 10L, (enum tmt_en )1, 10L, 0L, (char *)"%H:%M"}, 
        {10L,
      0L, (enum tmt_en )1, 5L, (enum tmt_en )1, 20L, (enum tmt_en )1, 20L, 0L, (char *)"%H:%M"}, 
        {30L,
      0L, (enum tmt_en )1, 10L, (enum tmt_en )2, 1L, (enum tmt_en )2, 1L, 0L, (char *)"%H:%M"}, 
        {60L,
      0L, (enum tmt_en )1, 30L, (enum tmt_en )2, 2L, (enum tmt_en )2, 2L, 0L, (char *)"%H:%M"}, 
        {60L,
      86400L, (enum tmt_en )1, 30L, (enum tmt_en )2, 2L, (enum tmt_en )2, 6L, 0L,
      (char *)"%a %H:%M"}, 
        {180L, 0L, (enum tmt_en )2, 1L, (enum tmt_en )2, 6L, (enum tmt_en )2, 6L, 0L,
      (char *)"%H:%M"}, 
        {180L, 86400L, (enum tmt_en )2, 1L, (enum tmt_en )2, 6L, (enum tmt_en )2, 12L,
      0L, (char *)"%a %H:%M"}, 
        {600L, 0L, (enum tmt_en )2, 6L, (enum tmt_en )3, 1L, (enum tmt_en )3, 1L, 86400L,
      (char *)"%a"}, 
        {1200L, 0L, (enum tmt_en )2, 6L, (enum tmt_en )3, 1L, (enum tmt_en )3, 1L, 86400L,
      (char *)"%d"}, 
        {1800L, 0L, (enum tmt_en )2, 12L, (enum tmt_en )3, 1L, (enum tmt_en )3, 2L, 86400L,
      (char *)"%a %d"}, 
        {2400L, 0L, (enum tmt_en )2, 12L, (enum tmt_en )3, 1L, (enum tmt_en )3, 2L, 86400L,
      (char *)"%a"}, 
        {3600L, 0L, (enum tmt_en )3, 1L, (enum tmt_en )4, 1L, (enum tmt_en )4, 1L, 604800L,
      (char *)"Week %V"}, 
        {10800L, 0L, (enum tmt_en )4, 1L, (enum tmt_en )5, 1L, (enum tmt_en )4, 2L, 604800L,
      (char *)"Week %V"}, 
        {21600L, 0L, (enum tmt_en )5, 1L, (enum tmt_en )5, 1L, (enum tmt_en )5, 1L, 2592000L,
      (char *)"%b"}, 
        {172800L, 0L, (enum tmt_en )5, 1L, (enum tmt_en )5, 3L, (enum tmt_en )5, 3L,
      2592000L, (char *)"%b"}, 
        {315360L, 0L, (enum tmt_en )5, 3L, (enum tmt_en )6, 1L, (enum tmt_en )6, 1L,
      31536000L, (char *)"%Y"}, 
        {864000L, 0L, (enum tmt_en )6, 1L, (enum tmt_en )6, 1L, (enum tmt_en )6, 1L,
      31536000L, (char *)"%y"}, 
        {-1L, 0L, (enum tmt_en )5, 0L, (enum tmt_en )5, 0L, (enum tmt_en )5, 0L, 0L,
      (char *)""}};
#line 110 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
ylab_t ylab[13]  = 
#line 110
  {      {0.1, {1, 2, 5, 10}}, 
        {0.2, {1, 5, 10, 20}}, 
        {0.5, {1, 2, 4, 10}}, 
        {1.0, {1, 2, 5, 10}}, 
        {2.0, {1, 5, 10, 20}}, 
        {5.0, {1, 2, 4, 10}}, 
        {10.0, {1, 2, 5, 10}}, 
        {20.0, {1, 5, 10, 20}}, 
        {50.0, {1, 2, 4, 10}}, 
        {100.0, {1, 2, 5, 10}}, 
        {200.0, {1, 5, 10, 20}}, 
        {500.0, {1, 2, 4, 10}}, 
        {0.0, {0, 0, 0, 0}}};
#line 152 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
gfx_color_t graph_col[10]  = 
#line 152
  {      {1.00, 1.00, 1.00, 1.00}, 
        {0.95, 0.95, 0.95, 1.00}, 
        {0.81, 0.81, 0.81, 1.00}, 
        {0.62, 0.62, 0.62, 1.00}, 
        {0.56, 0.56, 0.56, 0.75}, 
        {0.87, 0.31, 0.31, 0.60}, 
        {0.00, 0.00, 0.00, 1.00}, 
        {0.50, 0.12, 0.12, 1.00}, 
        {0.12, 0.12, 0.12, 1.00}, 
        {0.00, 0.00, 0.00, 1.00}};
#line 181 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
static double pixie  ;
#line 177 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int xtr(image_desc_t *im , time_t mytime ) 
{ 


  {
#line 183
  if (mytime == 0L) {
#line 184
    pixie = (double )im->xsize / (double )(im->end - im->start);
#line 185
    return ((int )im->xorigin);
  }
#line 187
  return ((int )((double )im->xorigin + pixie * (double )(mytime - im->start)));
}
}
#line 195 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
static double pixie___0  ;
#line 191 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
double ytr(image_desc_t *im , double value ) 
{ 
  double yval ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 198
  if (sizeof(value) == sizeof(float )) {
    {
#line 198
    tmp___3 = __isnanf((float )value);
#line 198
    tmp___7 = tmp___3;
    }
  } else {
#line 198
    if (sizeof(value) == sizeof(double )) {
      {
#line 198
      tmp___4 = __isnan(value);
#line 198
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 198
      tmp___5 = __isnanl((long double )value);
#line 198
      tmp___6 = tmp___5;
      }
    }
#line 198
    tmp___7 = tmp___6;
  }
#line 198
  if (tmp___7) {
#line 199
    if (! im->logarithmic) {
#line 200
      pixie___0 = (double )im->ysize / (im->maxval - im->minval);
    } else {
      {
#line 202
      tmp = log10(im->maxval);
#line 202
      tmp___0 = log10(im->minval);
#line 202
      pixie___0 = (double )im->ysize / (tmp - tmp___0);
      }
    }
#line 204
    yval = (double )im->yorigin;
  } else
#line 205
  if (! im->logarithmic) {
#line 206
    yval = (double )im->yorigin - pixie___0 * (value - im->minval);
  } else
#line 208
  if (value < im->minval) {
#line 209
    yval = (double )im->yorigin;
  } else {
    {
#line 211
    tmp___1 = log10(value);
#line 211
    tmp___2 = log10(im->minval);
#line 211
    yval = (double )im->yorigin - pixie___0 * (tmp___1 - tmp___2);
    }
  }
#line 214
  return (yval);
}
}
#line 225 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
enum gf_en gf_conv(char *string ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 229
  tmp = strcmp("PRINT", (char const   *)string);
  }
#line 229
  if (tmp == 0) {
#line 229
    return ((enum gf_en )0);
  }
  {
#line 230
  tmp___0 = strcmp("GPRINT", (char const   *)string);
  }
#line 230
  if (tmp___0 == 0) {
#line 230
    return ((enum gf_en )1);
  }
  {
#line 231
  tmp___1 = strcmp("COMMENT", (char const   *)string);
  }
#line 231
  if (tmp___1 == 0) {
#line 231
    return ((enum gf_en )2);
  }
  {
#line 232
  tmp___2 = strcmp("HRULE", (char const   *)string);
  }
#line 232
  if (tmp___2 == 0) {
#line 232
    return ((enum gf_en )3);
  }
  {
#line 233
  tmp___3 = strcmp("VRULE", (char const   *)string);
  }
#line 233
  if (tmp___3 == 0) {
#line 233
    return ((enum gf_en )4);
  }
  {
#line 234
  tmp___4 = strcmp("LINE", (char const   *)string);
  }
#line 234
  if (tmp___4 == 0) {
#line 234
    return ((enum gf_en )5);
  }
  {
#line 235
  tmp___5 = strcmp("AREA", (char const   *)string);
  }
#line 235
  if (tmp___5 == 0) {
#line 235
    return ((enum gf_en )6);
  }
  {
#line 236
  tmp___6 = strcmp("STACK", (char const   *)string);
  }
#line 236
  if (tmp___6 == 0) {
#line 236
    return ((enum gf_en )7);
  }
  {
#line 237
  tmp___7 = strcmp("TICK", (char const   *)string);
  }
#line 237
  if (tmp___7 == 0) {
#line 237
    return ((enum gf_en )8);
  }
  {
#line 238
  tmp___8 = strcmp("TEXTALIGN", (char const   *)string);
  }
#line 238
  if (tmp___8 == 0) {
#line 238
    return ((enum gf_en )9);
  }
  {
#line 239
  tmp___9 = strcmp("DEF", (char const   *)string);
  }
#line 239
  if (tmp___9 == 0) {
#line 239
    return ((enum gf_en )10);
  }
  {
#line 240
  tmp___10 = strcmp("CDEF", (char const   *)string);
  }
#line 240
  if (tmp___10 == 0) {
#line 240
    return ((enum gf_en )11);
  }
  {
#line 241
  tmp___11 = strcmp("VDEF", (char const   *)string);
  }
#line 241
  if (tmp___11 == 0) {
#line 241
    return ((enum gf_en )12);
  }
  {
#line 242
  tmp___12 = strcmp("XPORT", (char const   *)string);
  }
#line 242
  if (tmp___12 == 0) {
#line 242
    return ((enum gf_en )14);
  }
  {
#line 243
  tmp___13 = strcmp("SHIFT", (char const   *)string);
  }
#line 243
  if (tmp___13 == 0) {
#line 243
    return ((enum gf_en )13);
  }
#line 245
  return ((enum gf_en )-1);
}
}
#line 248 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
enum gfx_if_en if_conv(char *string ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 252
  tmp = strcmp("PNG", (char const   *)string);
  }
#line 252
  if (tmp == 0) {
#line 252
    return ((enum gfx_if_en )0);
  }
  {
#line 253
  tmp___0 = strcmp("SVG", (char const   *)string);
  }
#line 253
  if (tmp___0 == 0) {
#line 253
    return ((enum gfx_if_en )1);
  }
  {
#line 254
  tmp___1 = strcmp("EPS", (char const   *)string);
  }
#line 254
  if (tmp___1 == 0) {
#line 254
    return ((enum gfx_if_en )2);
  }
  {
#line 255
  tmp___2 = strcmp("PDF", (char const   *)string);
  }
#line 255
  if (tmp___2 == 0) {
#line 255
    return ((enum gfx_if_en )3);
  }
#line 257
  return ((enum gfx_if_en )-1);
}
}
#line 260 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
enum tmt_en tmt_conv(char *string ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 264
  tmp = strcmp("SECOND", (char const   *)string);
  }
#line 264
  if (tmp == 0) {
#line 264
    return ((enum tmt_en )0);
  }
  {
#line 265
  tmp___0 = strcmp("MINUTE", (char const   *)string);
  }
#line 265
  if (tmp___0 == 0) {
#line 265
    return ((enum tmt_en )1);
  }
  {
#line 266
  tmp___1 = strcmp("HOUR", (char const   *)string);
  }
#line 266
  if (tmp___1 == 0) {
#line 266
    return ((enum tmt_en )2);
  }
  {
#line 267
  tmp___2 = strcmp("DAY", (char const   *)string);
  }
#line 267
  if (tmp___2 == 0) {
#line 267
    return ((enum tmt_en )3);
  }
  {
#line 268
  tmp___3 = strcmp("WEEK", (char const   *)string);
  }
#line 268
  if (tmp___3 == 0) {
#line 268
    return ((enum tmt_en )4);
  }
  {
#line 269
  tmp___4 = strcmp("MONTH", (char const   *)string);
  }
#line 269
  if (tmp___4 == 0) {
#line 269
    return ((enum tmt_en )5);
  }
  {
#line 270
  tmp___5 = strcmp("YEAR", (char const   *)string);
  }
#line 270
  if (tmp___5 == 0) {
#line 270
    return ((enum tmt_en )6);
  }
#line 271
  return ((enum tmt_en )-1);
}
}
#line 274 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
enum grc_en grc_conv(char *string ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 278
  tmp = strcmp("BACK", (char const   *)string);
  }
#line 278
  if (tmp == 0) {
#line 278
    return ((enum grc_en )1);
  }
  {
#line 279
  tmp___0 = strcmp("CANVAS", (char const   *)string);
  }
#line 279
  if (tmp___0 == 0) {
#line 279
    return ((enum grc_en )0);
  }
  {
#line 280
  tmp___1 = strcmp("SHADEA", (char const   *)string);
  }
#line 280
  if (tmp___1 == 0) {
#line 280
    return ((enum grc_en )2);
  }
  {
#line 281
  tmp___2 = strcmp("SHADEB", (char const   *)string);
  }
#line 281
  if (tmp___2 == 0) {
#line 281
    return ((enum grc_en )3);
  }
  {
#line 282
  tmp___3 = strcmp("GRID", (char const   *)string);
  }
#line 282
  if (tmp___3 == 0) {
#line 282
    return ((enum grc_en )4);
  }
  {
#line 283
  tmp___4 = strcmp("MGRID", (char const   *)string);
  }
#line 283
  if (tmp___4 == 0) {
#line 283
    return ((enum grc_en )5);
  }
  {
#line 284
  tmp___5 = strcmp("FONT", (char const   *)string);
  }
#line 284
  if (tmp___5 == 0) {
#line 284
    return ((enum grc_en )6);
  }
  {
#line 285
  tmp___6 = strcmp("ARROW", (char const   *)string);
  }
#line 285
  if (tmp___6 == 0) {
#line 285
    return ((enum grc_en )7);
  }
  {
#line 286
  tmp___7 = strcmp("AXIS", (char const   *)string);
  }
#line 286
  if (tmp___7 == 0) {
#line 286
    return ((enum grc_en )8);
  }
  {
#line 287
  tmp___8 = strcmp("FRAME", (char const   *)string);
  }
#line 287
  if (tmp___8 == 0) {
#line 287
    return ((enum grc_en )9);
  }
#line 289
  return ((enum grc_en )-1);
}
}
#line 292 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
enum text_prop_en text_prop_conv(char *string ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 296
  tmp = strcmp("DEFAULT", (char const   *)string);
  }
#line 296
  if (tmp == 0) {
#line 296
    return ((enum text_prop_en )0);
  }
  {
#line 297
  tmp___0 = strcmp("TITLE", (char const   *)string);
  }
#line 297
  if (tmp___0 == 0) {
#line 297
    return ((enum text_prop_en )1);
  }
  {
#line 298
  tmp___1 = strcmp("AXIS", (char const   *)string);
  }
#line 298
  if (tmp___1 == 0) {
#line 298
    return ((enum text_prop_en )2);
  }
  {
#line 299
  tmp___2 = strcmp("UNIT", (char const   *)string);
  }
#line 299
  if (tmp___2 == 0) {
#line 299
    return ((enum text_prop_en )3);
  }
  {
#line 300
  tmp___3 = strcmp("LEGEND", (char const   *)string);
  }
#line 300
  if (tmp___3 == 0) {
#line 300
    return ((enum text_prop_en )4);
  }
  {
#line 301
  tmp___4 = strcmp("WATERMARK", (char const   *)string);
  }
#line 301
  if (tmp___4 == 0) {
#line 301
    return ((enum text_prop_en )5);
  }
#line 302
  return ((enum text_prop_en )-1);
}
}
#line 308 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int im_free(image_desc_t *im ) 
{ 
  unsigned long i ;
  unsigned long ii ;
  cairo_status_t status ;
  char const   *tmp ;
  char *__cil_tmp6 ;

  {
#line 312
  status = (cairo_status_t )0;
#line 314
  if ((unsigned long )im == (unsigned long )((void *)0)) {
#line 315
    return (0);
  }
#line 317
  if ((unsigned long )im->daemon_addr != (unsigned long )((void *)0)) {
    {
#line 318
    free((void *)im->daemon_addr);
    }
  }
#line 320
  if (im->gdef_map) {
    {
#line 321
    g_hash_table_destroy(im->gdef_map);
    }
  }
#line 324
  if (im->rrd_map) {
    {
#line 325
    g_hash_table_destroy(im->rrd_map);
    }
  }
#line 328
  i = 0UL;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! (i < (unsigned long )((unsigned int )im->gdes_c))) {
#line 328
      goto while_break;
    }
#line 329
    if ((im->gdes + i)->data_first) {
      {
#line 331
      free((void *)(im->gdes + i)->data);
      }
#line 332
      if ((im->gdes + i)->ds_namv) {
#line 333
        ii = 0UL;
        {
#line 333
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 333
          if (! (ii < (im->gdes + i)->ds_cnt)) {
#line 333
            goto while_break___0;
          }
          {
#line 334
          free((void *)*((im->gdes + i)->ds_namv + ii));
#line 333
          ii ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 335
        free((void *)(im->gdes + i)->ds_namv);
        }
      }
    }
#line 339
    if ((unsigned long )(im->gdes + i)->p_dashes != (unsigned long )((void *)0)) {
      {
#line 340
      free((void *)(im->gdes + i)->p_dashes);
      }
    }
    {
#line 342
    free((void *)(im->gdes + i)->p_data);
#line 343
    free((void *)(im->gdes + i)->rpnp);
#line 328
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 345
  free((void *)im->gdes);
#line 347
  i = 0UL;
  }
  {
#line 347
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 347
    if (! (i < sizeof(text_prop) / sizeof(text_prop[0]))) {
#line 347
      goto while_break___1;
    }
    {
#line 348
    pango_font_description_free(im->text_prop[i].font_desc);
#line 349
    im->text_prop[i].font_desc = (PangoFontDescription *)((void *)0);
#line 347
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 352
  if (im->font_options) {
    {
#line 353
    cairo_font_options_destroy(im->font_options);
    }
  }
#line 355
  if (im->cr) {
    {
#line 356
    status = cairo_status(im->cr);
#line 357
    cairo_destroy(im->cr);
    }
  }
#line 361
  if (im->rendered_image) {
    {
#line 362
    free((void *)im->rendered_image);
    }
  }
#line 365
  if (im->layout) {
    {
#line 366
    g_object_unref((gpointer )im->layout);
    }
  }
#line 369
  if (im->surface) {
    {
#line 370
    cairo_surface_destroy(im->surface);
    }
  }
#line 372
  if (status) {
    {
#line 373
    tmp = cairo_status_to_string(status);
#line 373
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OOPS: Cairo has issues it can\'t even die: %s\n",
            tmp);
    }
  }
#line 376
  return (0);
}
}
#line 380 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void auto_scale(image_desc_t *im , double *value , char **symb_ptr , double *magfact ) 
{ 
  char *symbol[13] ;
  int symbcenter ;
  int sindex ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 387
  symbol[0] = (char *)"a";
#line 387
  symbol[1] = (char *)"f";
#line 387
  symbol[2] = (char *)"p";
#line 387
  symbol[3] = (char *)"n";
#line 387
  symbol[4] = (char *)"u";
#line 387
  symbol[5] = (char *)"m";
#line 387
  symbol[6] = (char *)" ";
#line 387
  symbol[7] = (char *)"k";
#line 387
  symbol[8] = (char *)"M";
#line 387
  symbol[9] = (char *)"G";
#line 387
  symbol[10] = (char *)"T";
#line 387
  symbol[11] = (char *)"P";
#line 387
  symbol[12] = (char *)"E";
#line 402
  symbcenter = 6;
#line 405
  if (*value == 0.0) {
#line 406
    sindex = 0;
#line 407
    *magfact = 1.0;
  } else {
#line 405
    if (sizeof(*value) == sizeof(float )) {
      {
#line 405
      tmp___3 = __isnanf((float )*value);
#line 405
      tmp___7 = tmp___3;
      }
    } else {
#line 405
      if (sizeof(*value) == sizeof(double )) {
        {
#line 405
        tmp___4 = __isnan(*value);
#line 405
        tmp___6 = tmp___4;
        }
      } else {
        {
#line 405
        tmp___5 = __isnanl((long double )*value);
#line 405
        tmp___6 = tmp___5;
        }
      }
#line 405
      tmp___7 = tmp___6;
    }
#line 405
    if (tmp___7) {
#line 406
      sindex = 0;
#line 407
      *magfact = 1.0;
    } else {
      {
#line 409
      tmp = fabs(*value);
#line 409
      tmp___0 = log(tmp);
#line 409
      tmp___1 = log((double )im->base);
#line 409
      tmp___2 = floor(tmp___0 / tmp___1);
#line 409
      sindex = (int )tmp___2;
#line 410
      *magfact = pow((double )im->base, (double )sindex);
#line 411
      *value /= *magfact;
      }
    }
  }
#line 413
  if (sindex <= symbcenter) {
#line 413
    if (sindex >= - symbcenter) {
#line 414
      *symb_ptr = symbol[sindex + symbcenter];
    } else {
#line 416
      *symb_ptr = (char *)"?";
    }
  } else {
#line 416
    *symb_ptr = (char *)"?";
  }
#line 418
  return;
}
}
#line 422 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
static char si_symbol[17]  = 
#line 422
  {      (char )'y',      (char )'z',      (char )'a',      (char )'f', 
        (char )'p',      (char )'n',      (char )'u',      (char )'m', 
        (char )' ',      (char )'k',      (char )'M',      (char )'G', 
        (char )'T',      (char )'P',      (char )'E',      (char )'Z', 
        (char )'Y'};
#line 441 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
static int const   si_symbcenter  =    (int const   )8;
#line 444 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void si_unit(image_desc_t *im ) 
{ 
  double digits ;
  double viewdigits ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;

  {
  {
#line 449
  viewdigits = (double )0;
#line 451
  tmp___4 = fabs(im->minval);
#line 451
  tmp___5 = fabs(im->maxval);
  }
#line 451
  if (tmp___4 > tmp___5) {
    {
#line 451
    tmp___1 = fabs(im->minval);
#line 451
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 451
    tmp___2 = fabs(im->maxval);
#line 451
    tmp___3 = tmp___2;
    }
  }
  {
#line 451
  tmp___6 = log(tmp___3);
#line 451
  tmp___7 = log((double )im->base);
#line 451
  digits = floor(tmp___6 / tmp___7);
  }
#line 455
  if (im->unitsexponent != 9999) {
    {
#line 457
    viewdigits = floor((double )(im->unitsexponent / 3));
    }
  } else {
#line 459
    viewdigits = digits;
  }
  {
#line 462
  im->magfact = pow((double )im->base, digits);
#line 468
  tmp___8 = pow((double )im->base, viewdigits);
#line 468
  im->viewfactor = (float )(im->magfact / tmp___8);
  }
#line 470
  if (viewdigits + (double )si_symbcenter < (double )sizeof(si_symbol)) {
#line 470
    if (viewdigits + (double )si_symbcenter >= (double )0) {
#line 472
      im->symbol = si_symbol[(int )viewdigits + (int )si_symbcenter];
    } else {
#line 474
      im->symbol = (char )'?';
    }
  } else {
#line 474
    im->symbol = (char )'?';
  }
#line 475
  return;
}
}
#line 479 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void expand_range(image_desc_t *im ) 
{ 
  double sensiblevalues[48] ;
  double scaled_min ;
  double scaled_max ;
  double adj ;
  int i ;
  double delt ;
  double fact ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *__cil_tmp26 ;

  {
#line 482
  sensiblevalues[0] = 1000.0;
#line 482
  sensiblevalues[1] = 900.0;
#line 482
  sensiblevalues[2] = 800.0;
#line 482
  sensiblevalues[3] = 750.0;
#line 482
  sensiblevalues[4] = 700.0;
#line 482
  sensiblevalues[5] = 600.0;
#line 482
  sensiblevalues[6] = 500.0;
#line 482
  sensiblevalues[7] = 400.0;
#line 482
  sensiblevalues[8] = 300.0;
#line 482
  sensiblevalues[9] = 250.0;
#line 482
  sensiblevalues[10] = 200.0;
#line 482
  sensiblevalues[11] = 125.0;
#line 482
  sensiblevalues[12] = 100.0;
#line 482
  sensiblevalues[13] = 90.0;
#line 482
  sensiblevalues[14] = 80.0;
#line 482
  sensiblevalues[15] = 75.0;
#line 482
  sensiblevalues[16] = 70.0;
#line 482
  sensiblevalues[17] = 60.0;
#line 482
  sensiblevalues[18] = 50.0;
#line 482
  sensiblevalues[19] = 40.0;
#line 482
  sensiblevalues[20] = 30.0;
#line 482
  sensiblevalues[21] = 25.0;
#line 482
  sensiblevalues[22] = 20.0;
#line 482
  sensiblevalues[23] = 10.0;
#line 482
  sensiblevalues[24] = 9.0;
#line 482
  sensiblevalues[25] = 8.0;
#line 482
  sensiblevalues[26] = 7.0;
#line 482
  sensiblevalues[27] = 6.0;
#line 482
  sensiblevalues[28] = 5.0;
#line 482
  sensiblevalues[29] = 4.0;
#line 482
  sensiblevalues[30] = 3.5;
#line 482
  sensiblevalues[31] = 3.0;
#line 482
  sensiblevalues[32] = 2.5;
#line 482
  sensiblevalues[33] = 2.0;
#line 482
  sensiblevalues[34] = 1.8;
#line 482
  sensiblevalues[35] = 1.5;
#line 482
  sensiblevalues[36] = 1.2;
#line 482
  sensiblevalues[37] = 1.0;
#line 482
  sensiblevalues[38] = 0.8;
#line 482
  sensiblevalues[39] = 0.7;
#line 482
  sensiblevalues[40] = 0.6;
#line 482
  sensiblevalues[41] = 0.5;
#line 482
  sensiblevalues[42] = 0.4;
#line 482
  sensiblevalues[43] = 0.3;
#line 482
  sensiblevalues[44] = 0.2;
#line 482
  sensiblevalues[45] = 0.1;
#line 482
  sensiblevalues[46] = 0.0;
#line 482
  sensiblevalues[47] = (double )-1;
#line 503
  if (sizeof(im->ygridstep) == sizeof(float )) {
    {
#line 503
    tmp___11 = __isnanf((float )im->ygridstep);
#line 503
    tmp___15 = tmp___11;
    }
  } else {
#line 503
    if (sizeof(im->ygridstep) == sizeof(double )) {
      {
#line 503
      tmp___12 = __isnan(im->ygridstep);
#line 503
      tmp___14 = tmp___12;
      }
    } else {
      {
#line 503
      tmp___13 = __isnanl((long double )im->ygridstep);
#line 503
      tmp___14 = tmp___13;
      }
    }
#line 503
    tmp___15 = tmp___14;
  }
#line 503
  if (tmp___15) {
#line 504
    if (im->extra_flags & 2) {
      {
#line 510
      delt = im->maxval - im->minval;
#line 511
      adj = delt * 0.1;
#line 512
      tmp___4 = fabs(im->minval);
#line 512
      tmp___5 = fabs(im->maxval);
      }
#line 512
      if (tmp___4 > tmp___5) {
        {
#line 512
        tmp___1 = fabs(im->minval);
#line 512
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 512
        tmp___2 = fabs(im->maxval);
#line 512
        tmp___3 = tmp___2;
        }
      }
      {
#line 512
      tmp___6 = log10(tmp___3 / im->magfact);
#line 512
      tmp___7 = floor(tmp___6);
#line 512
      tmp___8 = pow(10.0, tmp___7 - (double )2);
#line 512
      fact = 2.0 * tmp___8;
      }
#line 516
      if (delt < fact) {
#line 517
        adj = (fact - delt) * 0.55;
      }
#line 524
      im->minval -= adj;
#line 525
      im->maxval += adj;
    } else
#line 526
    if (im->extra_flags & 4) {
#line 530
      adj = (im->maxval - im->minval) * 0.1;
#line 531
      im->minval -= adj;
    } else
#line 532
    if (im->extra_flags & 8) {
#line 536
      adj = (im->maxval - im->minval) * 0.1;
#line 537
      im->maxval += adj;
    } else {
#line 539
      scaled_min = im->minval / im->magfact;
#line 540
      scaled_max = im->maxval / im->magfact;
#line 542
      i = 1;
      {
#line 542
      while (1) {
        while_continue: /* CIL Label */ ;
#line 542
        if (! (sensiblevalues[i] > (double )0)) {
#line 542
          goto while_break;
        }
#line 543
        if (sensiblevalues[i - 1] >= scaled_min) {
#line 543
          if (sensiblevalues[i] <= scaled_min) {
#line 545
            im->minval = sensiblevalues[i] * im->magfact;
          }
        }
#line 547
        if (- sensiblevalues[i - 1] <= scaled_min) {
#line 547
          if (- sensiblevalues[i] >= scaled_min) {
#line 549
            im->minval = - sensiblevalues[i - 1] * im->magfact;
          }
        }
#line 551
        if (sensiblevalues[i - 1] >= scaled_max) {
#line 551
          if (sensiblevalues[i] <= scaled_max) {
#line 553
            im->maxval = sensiblevalues[i - 1] * im->magfact;
          }
        }
#line 555
        if (- sensiblevalues[i - 1] <= scaled_max) {
#line 555
          if (- sensiblevalues[i] >= scaled_max) {
#line 557
            im->maxval = - sensiblevalues[i] * im->magfact;
          }
        }
#line 542
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 562
    tmp___9 = floor(im->minval / ((double )im->ylabfact * im->ygridstep));
#line 562
    im->minval = ((double )im->ylabfact * im->ygridstep) * tmp___9;
#line 564
    tmp___10 = ceil(im->maxval / ((double )im->ylabfact * im->ygridstep));
#line 564
    im->maxval = ((double )im->ylabfact * im->ygridstep) * tmp___10;
    }
  }
#line 572
  return;
}
}
#line 575 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void apply_gridfit(image_desc_t *im ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  double ya ;
  double yb ;
  double ypix ;
  double ypixfrac ;
  double log10_range ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double y_pixel_delta ;
  double tmp___14 ;
  double tmp___15 ;
  double factor ;
  double tmp___16 ;
  double new_log10_range ;
  double new_ymax_log10 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double yfrac ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double ypos1 ;
  double tmp___26 ;
  double ypos2 ;
  double tmp___27 ;
  double y_pixel_delta___0 ;
  double factor___0 ;
  double tmp___28 ;
  double new_range ;
  double gridstep ;
  double minor_y ;
  double minor_y_px ;
  double minor_y_px_frac ;
  double tmp___29 ;
  double tmp___30 ;
  double tmp___31 ;
  double tmp___32 ;
  double yfrac___0 ;
  double range ;
  double tmp___33 ;

  {
#line 578
  if (sizeof(im->minval) == sizeof(float )) {
    {
#line 578
    tmp = __isnanf((float )im->minval);
#line 578
    tmp___3 = tmp;
    }
  } else {
#line 578
    if (sizeof(im->minval) == sizeof(double )) {
      {
#line 578
      tmp___0 = __isnan(im->minval);
#line 578
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 578
      tmp___1 = __isnanl((long double )im->minval);
#line 578
      tmp___2 = tmp___1;
      }
    }
#line 578
    tmp___3 = tmp___2;
  }
#line 578
  if (tmp___3) {
#line 579
    return;
  } else {
#line 578
    if (sizeof(im->maxval) == sizeof(float )) {
      {
#line 578
      tmp___4 = __isnanf((float )im->maxval);
#line 578
      tmp___8 = tmp___4;
      }
    } else {
#line 578
      if (sizeof(im->maxval) == sizeof(double )) {
        {
#line 578
        tmp___5 = __isnan(im->maxval);
#line 578
        tmp___7 = tmp___5;
        }
      } else {
        {
#line 578
        tmp___6 = __isnanl((long double )im->maxval);
#line 578
        tmp___7 = tmp___6;
        }
      }
#line 578
      tmp___8 = tmp___7;
    }
#line 578
    if (tmp___8) {
#line 579
      return;
    }
  }
  {
#line 580
  tmp___9 = rrd_set_to_DNAN();
#line 580
  ytr(im, tmp___9);
  }
#line 581
  if (im->logarithmic) {
    {
#line 583
    tmp___10 = log10(im->maxval);
#line 583
    tmp___11 = log10(im->minval);
#line 583
    log10_range = tmp___10 - tmp___11;
#line 585
    tmp___12 = log10(im->minval);
#line 585
    tmp___13 = floor(tmp___12);
#line 585
    ya = pow((double )10, tmp___13);
    }
    {
#line 586
    while (1) {
      while_continue: /* CIL Label */ ;
#line 586
      if (! (ya < im->minval)) {
#line 586
        goto while_break;
      }
#line 587
      ya *= (double )10;
    }
    while_break: /* CIL Label */ ;
    }
#line 588
    if (ya > im->maxval) {
#line 589
      return;
    }
#line 590
    yb = ya * (double )10;
#line 591
    if (yb <= im->maxval) {
      {
#line 595
      tmp___14 = ytr(im, ya);
#line 595
      tmp___15 = ytr(im, yb);
#line 595
      y_pixel_delta = tmp___14 - tmp___15;
#line 596
      tmp___16 = floor(y_pixel_delta);
#line 596
      factor = y_pixel_delta / tmp___16;
#line 597
      new_log10_range = factor * log10_range;
#line 598
      tmp___17 = log10(im->minval);
#line 598
      new_ymax_log10 = tmp___17 + new_log10_range;
#line 600
      im->maxval = pow((double )10, new_ymax_log10);
#line 601
      tmp___18 = rrd_set_to_DNAN();
#line 601
      ytr(im, tmp___18);
#line 602
      tmp___19 = log10(im->maxval);
#line 602
      tmp___20 = log10(im->minval);
#line 602
      log10_range = tmp___19 - tmp___20;
      }
    }
    {
#line 607
    tmp___21 = ytr(im, ya);
#line 607
    ypix = tmp___21 + (double )im->ysize;
#line 608
    tmp___22 = floor(ypix);
#line 608
    ypixfrac = ypix - tmp___22;
    }
#line 609
    if (ypixfrac > (double )0) {
#line 609
      if (ypixfrac < (double )1) {
        {
#line 610
        yfrac = ypixfrac / (double )im->ysize;
#line 612
        tmp___23 = log10(im->minval);
#line 612
        im->minval = pow((double )10, tmp___23 - yfrac * log10_range);
#line 613
        tmp___24 = log10(im->maxval);
#line 613
        im->maxval = pow((double )10, tmp___24 - yfrac * log10_range);
#line 614
        tmp___25 = rrd_set_to_DNAN();
#line 614
        ytr(im, tmp___25);
        }
      }
    }
  } else {
    {
#line 619
    tmp___26 = ytr(im, im->minval);
#line 619
    ypos1 = tmp___26;
#line 620
    tmp___27 = ytr(im, im->minval + im->ygrid_scale.gridstep);
#line 620
    ypos2 = tmp___27;
#line 621
    y_pixel_delta___0 = ypos1 - ypos2;
#line 622
    tmp___28 = floor(y_pixel_delta___0);
#line 622
    factor___0 = y_pixel_delta___0 / tmp___28;
#line 623
    new_range = factor___0 * (im->maxval - im->minval);
#line 624
    gridstep = im->ygrid_scale.gridstep;
    }
#line 627
    if (im->maxval > 0.0) {
#line 628
      im->maxval = im->minval + new_range;
    } else {
#line 630
      im->minval = im->maxval - new_range;
    }
    {
#line 631
    tmp___29 = rrd_set_to_DNAN();
#line 631
    ytr(im, tmp___29);
#line 633
    tmp___30 = floor(im->minval / gridstep);
#line 633
    minor_y = gridstep * tmp___30;
    }
    {
#line 634
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 634
      if (! (minor_y < im->minval)) {
#line 634
        goto while_break___0;
      }
#line 635
      minor_y += gridstep;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 636
    tmp___31 = ytr(im, minor_y);
#line 636
    minor_y_px = tmp___31 + (double )im->ysize;
#line 637
    tmp___32 = floor(minor_y_px);
#line 637
    minor_y_px_frac = minor_y_px - tmp___32;
    }
#line 638
    if (minor_y_px_frac > (double )0) {
#line 638
      if (minor_y_px_frac < (double )1) {
        {
#line 639
        yfrac___0 = minor_y_px_frac / (double )im->ysize;
#line 640
        range = im->maxval - im->minval;
#line 642
        im->minval -= yfrac___0 * range;
#line 643
        im->maxval -= yfrac___0 * range;
#line 644
        tmp___33 = rrd_set_to_DNAN();
#line 644
        ytr(im, tmp___33);
        }
      }
    }
    {
#line 646
    calc_horizontal_grid(im);
    }
  }
#line 648
  return;
}
}
#line 652 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void reduce_data(enum cf_en cf , unsigned long cur_step , time_t *start , time_t *end ,
                 unsigned long *step , unsigned long *ds_cnt , rrd_value_t **data ) 
{ 
  int i ;
  int reduce_factor ;
  double tmp ;
  unsigned long col ;
  unsigned long dst_row ;
  unsigned long row_cnt ;
  unsigned long start_offset ;
  unsigned long end_offset ;
  unsigned long skiprows ;
  rrd_value_t *srcptr ;
  rrd_value_t *dstptr ;
  rrd_value_t *tmp___0 ;
  rrd_value_t newval ;
  double tmp___1 ;
  unsigned long validval ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  rrd_value_t *tmp___12 ;
  rrd_value_t *tmp___13 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 661
  tmp = ceil((double )*step / (double )cur_step);
#line 661
  reduce_factor = (int )tmp;
#line 662
  skiprows = 0UL;
#line 666
  *step = cur_step * (unsigned long )reduce_factor;
#line 667
  dstptr = *data;
#line 668
  srcptr = *data;
#line 669
  row_cnt = (unsigned long )(*end - *start) / cur_step;
#line 693
  end_offset = (unsigned long )*end % *step;
#line 694
  start_offset = (unsigned long )*start % *step;
  }
#line 706
  if (start_offset) {
#line 707
    *start = (time_t )((unsigned long )*start - start_offset);
#line 708
    skiprows = (unsigned long )reduce_factor - start_offset / cur_step;
#line 709
    srcptr += skiprows * *ds_cnt;
#line 710
    col = 0UL;
    {
#line 710
    while (1) {
      while_continue: /* CIL Label */ ;
#line 710
      if (! (col < *ds_cnt)) {
#line 710
        goto while_break;
      }
      {
#line 711
      tmp___0 = dstptr;
#line 711
      dstptr ++;
#line 711
      *tmp___0 = rrd_set_to_DNAN();
#line 710
      col ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 712
    row_cnt -= skiprows;
  }
#line 721
  if (end_offset) {
#line 722
    *end = (time_t )(((unsigned long )*end - end_offset) + *step);
#line 723
    skiprows = end_offset / cur_step;
#line 724
    row_cnt -= skiprows;
  }
#line 733
  if (row_cnt % (unsigned long )reduce_factor) {
    {
#line 734
    printf((char const   */* __restrict  */)"SANITY CHECK: %lu rows cannot be reduced by %i \n",
           row_cnt, reduce_factor);
#line 736
    printf((char const   */* __restrict  */)"BUG in reduce_data()\n");
#line 737
    exit(1);
    }
  }
#line 744
  dst_row = 0UL;
  {
#line 744
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 744
    if (! ((long )row_cnt >= (long )reduce_factor)) {
#line 744
      goto while_break___0;
    }
#line 745
    col = 0UL;
    {
#line 745
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 745
      if (! (col < *ds_cnt)) {
#line 745
        goto while_break___1;
      }
      {
#line 746
      tmp___1 = rrd_set_to_DNAN();
#line 746
      newval = tmp___1;
#line 747
      validval = 0UL;
#line 749
      i = 0;
      }
      {
#line 749
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 749
        if (! (i < reduce_factor)) {
#line 749
          goto while_break___2;
        }
#line 750
        if (sizeof(*(srcptr + ((unsigned long )i * *ds_cnt + col))) == sizeof(float )) {
          {
#line 750
          tmp___2 = __isnanf((float )*(srcptr + ((unsigned long )i * *ds_cnt + col)));
#line 750
          tmp___6 = tmp___2;
          }
        } else {
#line 750
          if (sizeof(*(srcptr + ((unsigned long )i * *ds_cnt + col))) == sizeof(double )) {
            {
#line 750
            tmp___3 = __isnan(*(srcptr + ((unsigned long )i * *ds_cnt + col)));
#line 750
            tmp___5 = tmp___3;
            }
          } else {
            {
#line 750
            tmp___4 = __isnanl((long double )*(srcptr + ((unsigned long )i * *ds_cnt + col)));
#line 750
            tmp___5 = tmp___4;
            }
          }
#line 750
          tmp___6 = tmp___5;
        }
#line 750
        if (tmp___6) {
#line 751
          goto __Cont;
        }
#line 753
        validval ++;
#line 754
        if (sizeof(newval) == sizeof(float )) {
          {
#line 754
          tmp___7 = __isnanf((float )newval);
#line 754
          tmp___11 = tmp___7;
          }
        } else {
#line 754
          if (sizeof(newval) == sizeof(double )) {
            {
#line 754
            tmp___8 = __isnan(newval);
#line 754
            tmp___10 = tmp___8;
            }
          } else {
            {
#line 754
            tmp___9 = __isnanl((long double )newval);
#line 754
            tmp___10 = tmp___9;
            }
          }
#line 754
          tmp___11 = tmp___10;
        }
#line 754
        if (tmp___11) {
#line 755
          newval = *(srcptr + ((unsigned long )i * *ds_cnt + col));
        } else {
          {
#line 763
          if ((unsigned int )cf == 0U) {
#line 763
            goto case_0;
          }
#line 763
          if ((unsigned int )cf == 5U) {
#line 763
            goto case_0;
          }
#line 763
          if ((unsigned int )cf == 6U) {
#line 763
            goto case_0;
          }
#line 763
          if ((unsigned int )cf == 7U) {
#line 763
            goto case_0;
          }
#line 763
          if ((unsigned int )cf == 9U) {
#line 763
            goto case_0;
          }
#line 763
          if ((unsigned int )cf == 4U) {
#line 763
            goto case_0;
          }
#line 766
          if ((unsigned int )cf == 1U) {
#line 766
            goto case_1;
          }
#line 771
          if ((unsigned int )cf == 2U) {
#line 771
            goto case_2;
          }
#line 771
          if ((unsigned int )cf == 8U) {
#line 771
            goto case_2;
          }
#line 774
          if ((unsigned int )cf == 3U) {
#line 774
            goto case_3;
          }
#line 757
          goto switch_break;
          case_0: /* CIL Label */ 
          case_5: /* CIL Label */ 
          case_6: /* CIL Label */ 
          case_7: /* CIL Label */ 
          case_9: /* CIL Label */ 
          case_4: /* CIL Label */ 
#line 764
          newval += *(srcptr + ((unsigned long )i * *ds_cnt + col));
#line 765
          goto switch_break;
          case_1: /* CIL Label */ 
#line 767
          if (newval < *(srcptr + ((unsigned long )i * *ds_cnt + col))) {
#line 767
            newval = newval;
          } else {
#line 767
            newval = *(srcptr + ((unsigned long )i * *ds_cnt + col));
          }
#line 768
          goto switch_break;
          case_2: /* CIL Label */ 
          case_8: /* CIL Label */ 
#line 772
          if (newval > *(srcptr + ((unsigned long )i * *ds_cnt + col))) {
#line 772
            newval = newval;
          } else {
#line 772
            newval = *(srcptr + ((unsigned long )i * *ds_cnt + col));
          }
#line 773
          goto switch_break;
          case_3: /* CIL Label */ 
#line 775
          newval = *(srcptr + ((unsigned long )i * *ds_cnt + col));
#line 776
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
        __Cont: /* CIL Label */ 
#line 749
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 780
      if (validval == 0UL) {
        {
#line 781
        newval = rrd_set_to_DNAN();
        }
      } else {
        {
#line 789
        if ((unsigned int )cf == 0U) {
#line 789
          goto case_0___0;
        }
#line 789
        if ((unsigned int )cf == 5U) {
#line 789
          goto case_0___0;
        }
#line 789
        if ((unsigned int )cf == 6U) {
#line 789
          goto case_0___0;
        }
#line 789
        if ((unsigned int )cf == 7U) {
#line 789
          goto case_0___0;
        }
#line 789
        if ((unsigned int )cf == 9U) {
#line 789
          goto case_0___0;
        }
#line 789
        if ((unsigned int )cf == 4U) {
#line 789
          goto case_0___0;
        }
#line 795
        if ((unsigned int )cf == 3U) {
#line 795
          goto case_3___0;
        }
#line 795
        if ((unsigned int )cf == 2U) {
#line 795
          goto case_3___0;
        }
#line 795
        if ((unsigned int )cf == 8U) {
#line 795
          goto case_3___0;
        }
#line 795
        if ((unsigned int )cf == 1U) {
#line 795
          goto case_3___0;
        }
#line 783
        goto switch_break___0;
        case_0___0: /* CIL Label */ 
        case_5___0: /* CIL Label */ 
        case_6___0: /* CIL Label */ 
        case_7___0: /* CIL Label */ 
        case_9___0: /* CIL Label */ 
        case_4___0: /* CIL Label */ 
#line 790
        newval /= (rrd_value_t )validval;
#line 791
        goto switch_break___0;
        case_3___0: /* CIL Label */ 
        case_2___0: /* CIL Label */ 
        case_8___0: /* CIL Label */ 
        case_1___0: /* CIL Label */ 
#line 796
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
#line 799
      tmp___12 = dstptr;
#line 799
      dstptr ++;
#line 799
      *tmp___12 = newval;
#line 745
      col ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 801
    srcptr += *ds_cnt * (unsigned long )reduce_factor;
#line 802
    row_cnt -= (unsigned long )reduce_factor;
#line 744
    dst_row ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 807
  if (end_offset) {
#line 808
    col = 0UL;
    {
#line 808
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 808
      if (! (col < *ds_cnt)) {
#line 808
        goto while_break___3;
      }
      {
#line 809
      tmp___13 = dstptr;
#line 809
      dstptr ++;
#line 809
      *tmp___13 = rrd_set_to_DNAN();
#line 808
      col ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 822
  return;
}
}
#line 828 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int data_fetch(image_desc_t *im ) 
{ 
  int i ;
  int ii ;
  gpointer value ;
  char *key ;
  char *tmp ;
  gboolean ok ;
  gboolean tmp___0 ;
  unsigned long ft_step ;
  int status ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 834
  i = 0;
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (! (i < (int )im->gdes_c)) {
#line 834
      goto while_break;
    }
#line 836
    if ((unsigned int )(im->gdes + i)->gf != 10U) {
#line 837
      goto __Cont;
    }
    {
#line 841
    tmp = sprintf_alloc((char *)"%s:%d:%d:%d:%d", (im->gdes + i)->rrd, (unsigned int )(im->gdes + i)->cf,
                        (unsigned int )(im->gdes + i)->cf_reduce, (im->gdes + i)->start_orig,
                        (im->gdes + i)->end_orig, (im->gdes + i)->step_orig);
#line 841
    key = tmp;
#line 842
    tmp___0 = g_hash_table_lookup_extended(im->rrd_map, (gconstpointer )key, (gpointer *)((void *)0),
                                           & value);
#line 842
    ok = tmp___0;
#line 843
    free((void *)key);
    }
#line 844
    if (ok) {
#line 845
      ii = (gint )((glong )value);
#line 846
      (im->gdes + i)->start = (im->gdes + ii)->start;
#line 847
      (im->gdes + i)->end = (im->gdes + ii)->end;
#line 848
      (im->gdes + i)->step = (im->gdes + ii)->step;
#line 849
      (im->gdes + i)->ds_cnt = (im->gdes + ii)->ds_cnt;
#line 850
      (im->gdes + i)->ds_namv = (im->gdes + ii)->ds_namv;
#line 851
      (im->gdes + i)->data = (im->gdes + ii)->data;
#line 852
      (im->gdes + i)->data_first = 0L;
    } else {
      {
#line 854
      ft_step = (im->gdes + i)->step;
#line 860
      tmp___2 = rrdc_is_connected((char const   *)im->daemon_addr);
      }
#line 860
      if (tmp___2) {
#line 864
        status = 0;
#line 865
        ii = 0;
        {
#line 865
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 865
          if (! (ii < i)) {
#line 865
            goto while_break___0;
          }
          {
#line 867
          tmp___1 = strcmp((char const   *)((im->gdes + i)->rrd), (char const   *)((im->gdes + ii)->rrd));
          }
#line 867
          if (tmp___1 == 0) {
#line 869
            status = 1;
#line 870
            goto while_break___0;
          }
#line 865
          ii ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 874
        if (status == 0) {
          {
#line 876
          status = rrdc_flush((char const   *)((im->gdes + i)->rrd));
          }
#line 877
          if (status != 0) {
            {
#line 879
            rrd_set_error((char *)"rrdc_flush (%s) failed with status %i.", (im->gdes + i)->rrd,
                          status);
            }
#line 881
            return (-1);
          }
        }
      }
      {
#line 886
      tmp___3 = rrd_fetch_fn((char const   *)((im->gdes + i)->rrd), (im->gdes + i)->cf,
                             & (im->gdes + i)->start, & (im->gdes + i)->end, & ft_step,
                             & (im->gdes + i)->ds_cnt, & (im->gdes + i)->ds_namv,
                             & (im->gdes + i)->data);
      }
#line 886
      if (tmp___3 == -1) {
#line 894
        return (-1);
      }
#line 896
      (im->gdes + i)->data_first = 1L;
#line 901
      if ((im->gdes + i)->step > im->step) {
#line 901
        (im->gdes + i)->step = (im->gdes + i)->step;
      } else {
#line 901
        (im->gdes + i)->step = im->step;
      }
#line 902
      if (ft_step < (im->gdes + i)->step) {
        {
#line 903
        reduce_data((im->gdes + i)->cf_reduce, ft_step, & (im->gdes + i)->start, & (im->gdes + i)->end,
                    & (im->gdes + i)->step, & (im->gdes + i)->ds_cnt, & (im->gdes + i)->data);
        }
      } else {
#line 910
        (im->gdes + i)->step = ft_step;
      }
    }
#line 915
    ii = 0;
    {
#line 915
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 915
      if (! (ii < (int )(im->gdes + i)->ds_cnt)) {
#line 915
        goto while_break___1;
      }
      {
#line 916
      tmp___4 = strcmp((char const   *)*((im->gdes + i)->ds_namv + ii), (char const   *)((im->gdes + i)->ds_nam));
      }
#line 916
      if (tmp___4 == 0) {
#line 917
        (im->gdes + i)->ds = (long )ii;
      }
#line 915
      ii ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 920
    if ((im->gdes + i)->ds == -1L) {
      {
#line 921
      rrd_set_error((char *)"No DS called \'%s\' in \'%s\'", (im->gdes + i)->ds_nam,
                    (im->gdes + i)->rrd);
      }
#line 923
      return (-1);
    }
    __Cont: /* CIL Label */ 
#line 834
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 927
  return (0);
}
}
#line 936 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
long find_var_wrapper(void *arg1 , char *key ) 
{ 
  long tmp ;

  {
  {
#line 940
  tmp = find_var((image_desc_t *)arg1, key);
  }
#line 940
  return (tmp);
}
}
#line 944 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
long find_var(image_desc_t *im , char *key ) 
{ 
  long match ;
  gpointer value ;
  gboolean ok ;
  gboolean tmp ;

  {
  {
#line 948
  match = -1L;
#line 950
  tmp = g_hash_table_lookup_extended(im->gdef_map, (gconstpointer )key, (gpointer *)((void *)0),
                                     & value);
#line 950
  ok = tmp;
  }
#line 951
  if (ok) {
#line 952
    match = (long )((gint )((glong )value));
  }
#line 957
  return (match);
}
}
#line 962 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
long lcd(long *num ) 
{ 
  long rest ;
  int i ;

  {
#line 968
  i = 0;
  {
#line 968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 968
    if (! (*(num + (i + 1)) != 0L)) {
#line 968
      goto while_break;
    }
    {
#line 969
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 970
      rest = *(num + i) % *(num + (i + 1));
#line 971
      *(num + i) = *(num + (i + 1));
#line 972
      *(num + (i + 1)) = rest;
#line 969
      if (! (rest != 0L)) {
#line 969
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 974
    *(num + (i + 1)) = *(num + i);
#line 968
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 977
  return (*(num + i));
}
}
#line 981 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int data_calc(image_desc_t *im ) 
{ 
  int gdi ;
  int dataidx ;
  long *steparray ;
  long rpi ;
  int stepcnt ;
  time_t now ;
  rpnstack_t rpnstack ;
  graph_desc_t *vdp ;
  int tmp ;
  long ptr ;
  void *tmp___0 ;
  long ptr___0 ;
  long diff ;
  long tmp___1 ;
  rrd_value_t *tmp___2 ;
  void *tmp___3 ;
  rpnp_t *rpnp ;
  short tmp___4 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 992
  rpnstack_init(& rpnstack);
#line 994
  gdi = 0;
  }
  {
#line 994
  while (1) {
    while_continue: /* CIL Label */ ;
#line 994
    if (! ((long )gdi < im->gdes_c)) {
#line 994
      goto while_break;
    }
    {
#line 999
    if ((unsigned int )(im->gdes + gdi)->gf == 14U) {
#line 999
      goto case_14;
    }
#line 1001
    if ((unsigned int )(im->gdes + gdi)->gf == 13U) {
#line 1001
      goto case_13;
    }
#line 1023
    if ((unsigned int )(im->gdes + gdi)->gf == 12U) {
#line 1023
      goto case_12;
    }
#line 1035
    if ((unsigned int )(im->gdes + gdi)->gf == 11U) {
#line 1035
      goto case_11;
    }
#line 1170
    goto switch_default;
    case_14: /* CIL Label */ 
#line 1000
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1002
    vdp = im->gdes + (im->gdes + gdi)->vidx;
#line 1005
    vdp->start -= vdp->shift;
#line 1006
    vdp->end -= vdp->shift;
#line 1009
    if ((im->gdes + gdi)->shidx >= 0) {
#line 1010
      vdp->shift = (time_t )(im->gdes + (im->gdes + gdi)->shidx)->vf.val;
    } else {
#line 1013
      vdp->shift = (im->gdes + gdi)->shval;
    }
#line 1016
    vdp->shift = (vdp->shift / (long )vdp->step) * (long )vdp->step;
#line 1019
    vdp->start += vdp->shift;
#line 1020
    vdp->end += vdp->shift;
#line 1021
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 1027
    (im->gdes + gdi)->ds_cnt = 0UL;
#line 1028
    tmp = vdef_calc(im, gdi);
    }
#line 1028
    if (tmp) {
      {
#line 1029
      rrd_set_error((char *)"Error processing VDEF \'%s\'", (im->gdes + gdi)->vname);
#line 1031
      rpnstack_free(& rpnstack);
      }
#line 1032
      return (-1);
    }
#line 1034
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1036
    (im->gdes + gdi)->ds_cnt = 1UL;
#line 1037
    (im->gdes + gdi)->ds = 0L;
#line 1038
    (im->gdes + gdi)->data_first = 1L;
#line 1039
    (im->gdes + gdi)->start = (time_t )0;
#line 1040
    (im->gdes + gdi)->end = (time_t )0;
#line 1041
    steparray = (long *)((void *)0);
#line 1042
    stepcnt = 0;
#line 1043
    dataidx = -1;
#line 1054
    rpi = 0L;
    {
#line 1054
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1054
      if (! ((unsigned int )((im->gdes + gdi)->rpnp + rpi)->op != 32U)) {
#line 1054
        goto while_break___0;
      }
#line 1055
      if ((unsigned int )((im->gdes + gdi)->rpnp + rpi)->op == 1U) {
#line 1055
        goto _L;
      } else
#line 1055
      if ((unsigned int )((im->gdes + gdi)->rpnp + rpi)->op == 36U) {
        _L: /* CIL Label */ 
#line 1057
        ptr = ((im->gdes + gdi)->rpnp + rpi)->ptr;
#line 1059
        if ((im->gdes + ptr)->ds_cnt == 0UL) {
#line 1067
          ((im->gdes + gdi)->rpnp + rpi)->val = (im->gdes + ptr)->vf.val;
#line 1068
          ((im->gdes + gdi)->rpnp + rpi)->op = (enum op_en )0;
        } else {
          {
#line 1073
          stepcnt ++;
#line 1073
          tmp___0 = realloc((void *)steparray, (unsigned long )(stepcnt + 1) * sizeof(*steparray));
#line 1073
          steparray = (long *)tmp___0;
          }
#line 1073
          if ((unsigned long )steparray == (unsigned long )((void *)0)) {
            {
#line 1077
            rrd_set_error((char *)"realloc steparray");
#line 1078
            rpnstack_free(& rpnstack);
            }
#line 1079
            return (-1);
          }
#line 1082
          *(steparray + (stepcnt - 1)) = (long )(im->gdes + ptr)->step;
#line 1090
          if ((im->gdes + gdi)->start < (im->gdes + ptr)->start) {
#line 1091
            (im->gdes + gdi)->start = (im->gdes + ptr)->start;
          }
#line 1093
          if ((im->gdes + gdi)->end == 0L) {
#line 1095
            (im->gdes + gdi)->end = (im->gdes + ptr)->end;
          } else
#line 1093
          if ((im->gdes + gdi)->end > (im->gdes + ptr)->end) {
#line 1095
            (im->gdes + gdi)->end = (im->gdes + ptr)->end;
          }
#line 1102
          ((im->gdes + gdi)->rpnp + rpi)->data = (im->gdes + ptr)->data + (im->gdes + ptr)->ds;
#line 1104
          ((im->gdes + gdi)->rpnp + rpi)->step = (long )(im->gdes + ptr)->step;
#line 1105
          ((im->gdes + gdi)->rpnp + rpi)->ds_cnt = (long )(im->gdes + ptr)->ds_cnt;
        }
      }
#line 1054
      rpi ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1116
    rpi = 0L;
    {
#line 1116
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1116
      if (! ((unsigned int )((im->gdes + gdi)->rpnp + rpi)->op != 32U)) {
#line 1116
        goto while_break___1;
      }
#line 1117
      if ((unsigned int )((im->gdes + gdi)->rpnp + rpi)->op == 1U) {
#line 1117
        goto _L___0;
      } else
#line 1117
      if ((unsigned int )((im->gdes + gdi)->rpnp + rpi)->op == 36U) {
        _L___0: /* CIL Label */ 
#line 1119
        ptr___0 = ((im->gdes + gdi)->rpnp + rpi)->ptr;
#line 1120
        diff = (im->gdes + gdi)->start - (im->gdes + ptr___0)->start;
#line 1123
        if (diff > 0L) {
#line 1124
          ((im->gdes + gdi)->rpnp + rpi)->data += ((unsigned long )diff / (im->gdes + ptr___0)->step) * (im->gdes + ptr___0)->ds_cnt;
        }
      }
#line 1116
      rpi ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1130
    if ((unsigned long )steparray == (unsigned long )((void *)0)) {
      {
#line 1131
      rrd_set_error((char *)"rpn expressions without DEF or CDEF variables are not supported");
#line 1133
      rpnstack_free(& rpnstack);
      }
#line 1134
      return (-1);
    }
    {
#line 1136
    *(steparray + stepcnt) = 0L;
#line 1140
    tmp___1 = lcd(steparray);
#line 1140
    (im->gdes + gdi)->step = (unsigned long )tmp___1;
#line 1141
    free((void *)steparray);
#line 1142
    tmp___3 = malloc(((unsigned long )((im->gdes + gdi)->end - (im->gdes + gdi)->start) / (im->gdes + gdi)->step) * sizeof(double ));
#line 1142
    tmp___2 = (rrd_value_t *)tmp___3;
#line 1142
    (im->gdes + gdi)->data = tmp___2;
    }
#line 1142
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
#line 1146
      rrd_set_error((char *)"malloc im->gdes[gdi].data");
#line 1147
      rpnstack_free(& rpnstack);
      }
#line 1148
      return (-1);
    }
#line 1154
    now = (time_t )((unsigned long )(im->gdes + gdi)->start + (im->gdes + gdi)->step);
    {
#line 1154
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1154
      if (! (now <= (im->gdes + gdi)->end)) {
#line 1154
        goto while_break___2;
      }
      {
#line 1156
      rpnp = (im->gdes + gdi)->rpnp;
#line 1162
      dataidx ++;
#line 1162
      tmp___4 = rpn_calc(rpnp, & rpnstack, now, (im->gdes + gdi)->data, dataidx);
      }
#line 1162
      if ((int )tmp___4 == -1) {
        {
#line 1165
        rpnstack_free(& rpnstack);
        }
#line 1166
        return (-1);
      }
#line 1154
      now = (time_t )((unsigned long )now + (im->gdes + gdi)->step);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1169
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1171
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 994
    gdi ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1174
  rpnstack_free(& rpnstack);
  }
#line 1175
  return (0);
}
}
#line 1182 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
static int AlmostEqual2sComplement(float A , float B , int maxUlps ) 
{ 
  int aInt ;
  int bInt ;
  int intDiff ;

  {
#line 1188
  aInt = *((int *)(& A));
#line 1189
  bInt = *((int *)(& B));
#line 1199
  if (aInt < 0) {
#line 1200
    aInt = (int )(2147483648L - (long )aInt);
  }
#line 1204
  if (bInt < 0) {
#line 1205
    bInt = (int )(2147483648L - (long )bInt);
  }
  {
#line 1207
  intDiff = abs(aInt - bInt);
  }
#line 1209
  if (intDiff <= maxUlps) {
#line 1210
    return (1);
  }
#line 1212
  return (0);
}
}
#line 1216 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int data_proc(image_desc_t *im ) 
{ 
  long i ;
  long ii ;
  double pixstep ;
  double paintval ;
  double minval ;
  double tmp ;
  double maxval ;
  double tmp___0 ;
  unsigned long gr_time ;
  rrd_value_t *tmp___1 ;
  void *tmp___2 ;
  long vidx ;
  double value ;
  double tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;

  {
  {
#line 1220
  pixstep = (double )(im->end - im->start) / (double )im->xsize;
#line 1224
  tmp = rrd_set_to_DNAN();
#line 1224
  minval = tmp;
#line 1224
  tmp___0 = rrd_set_to_DNAN();
#line 1224
  maxval = tmp___0;
#line 1229
  i = 0L;
  }
  {
#line 1229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1229
    if (! (i < im->gdes_c)) {
#line 1229
      goto while_break;
    }
#line 1230
    if ((unsigned int )(im->gdes + i)->gf == 5U) {
#line 1230
      goto _L;
    } else
#line 1230
    if ((unsigned int )(im->gdes + i)->gf == 6U) {
#line 1230
      goto _L;
    } else
#line 1230
    if ((unsigned int )(im->gdes + i)->gf == 8U) {
      _L: /* CIL Label */ 
      {
#line 1232
      tmp___2 = malloc((unsigned long )(im->xsize + 1L) * sizeof(rrd_value_t ));
#line 1232
      tmp___1 = (rrd_value_t *)tmp___2;
#line 1232
      (im->gdes + i)->p_data = tmp___1;
      }
#line 1232
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 1234
        rrd_set_error((char *)"malloc data_proc");
        }
#line 1235
        return (-1);
      }
    }
#line 1229
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1240
  i = 0L;
  {
#line 1240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1240
    if (! (i < im->xsize)) {
#line 1240
      goto while_break___0;
    }
#line 1243
    gr_time = (unsigned long )((double )im->start + pixstep * (double )i);
#line 1244
    paintval = 0.0;
#line 1246
    ii = 0L;
    {
#line 1246
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1246
      if (! (ii < im->gdes_c)) {
#line 1246
        goto while_break___1;
      }
      {
#line 1252
      if ((unsigned int )(im->gdes + ii)->gf == 8U) {
#line 1252
        goto case_8;
      }
#line 1252
      if ((unsigned int )(im->gdes + ii)->gf == 6U) {
#line 1252
        goto case_8;
      }
#line 1252
      if ((unsigned int )(im->gdes + ii)->gf == 5U) {
#line 1252
        goto case_8;
      }
#line 1299
      if ((unsigned int )(im->gdes + ii)->gf == 7U) {
#line 1299
        goto case_7;
      }
#line 1304
      goto switch_default;
      case_8: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
#line 1253
      if (! (im->gdes + ii)->stack) {
#line 1254
        paintval = 0.0;
      }
#line 1255
      value = (im->gdes + ii)->yrule;
#line 1256
      if (sizeof(value) == sizeof(float )) {
        {
#line 1256
        tmp___4 = __isnanf((float )value);
#line 1256
        tmp___8 = tmp___4;
        }
      } else {
#line 1256
        if (sizeof(value) == sizeof(double )) {
          {
#line 1256
          tmp___5 = __isnan(value);
#line 1256
          tmp___7 = tmp___5;
          }
        } else {
          {
#line 1256
          tmp___6 = __isnanl((long double )value);
#line 1256
          tmp___7 = tmp___6;
          }
        }
#line 1256
        tmp___8 = tmp___7;
      }
#line 1256
      if (tmp___8) {
#line 1256
        goto _L___0;
      } else
#line 1256
      if ((unsigned int )(im->gdes + ii)->gf == 8U) {
        _L___0: /* CIL Label */ 
#line 1260
        vidx = (im->gdes + ii)->vidx;
#line 1261
        if ((unsigned int )(im->gdes + vidx)->gf == 12U) {
#line 1262
          value = (im->gdes + vidx)->vf.val;
        } else
#line 1264
        if ((long )gr_time >= (im->gdes + vidx)->start) {
#line 1264
          if ((long )gr_time < (im->gdes + vidx)->end) {
            {
#line 1268
            tmp___3 = floor((double )(gr_time - (unsigned long )(im->gdes + vidx)->start) / (double )(im->gdes + vidx)->step);
#line 1268
            value = *((im->gdes + vidx)->data + ((unsigned long )tmp___3 * (im->gdes + vidx)->ds_cnt + (unsigned long )(im->gdes + vidx)->ds));
            }
          } else {
            {
#line 1278
            value = rrd_set_to_DNAN();
            }
          }
        } else {
          {
#line 1278
          value = rrd_set_to_DNAN();
          }
        }
      }
#line 1282
      if (sizeof(value) == sizeof(float )) {
        {
#line 1282
        tmp___24 = __isnanf((float )value);
#line 1282
        tmp___28 = tmp___24;
        }
      } else {
#line 1282
        if (sizeof(value) == sizeof(double )) {
          {
#line 1282
          tmp___25 = __isnan(value);
#line 1282
          tmp___27 = tmp___25;
          }
        } else {
          {
#line 1282
          tmp___26 = __isnanl((long double )value);
#line 1282
          tmp___27 = tmp___26;
          }
        }
#line 1282
        tmp___28 = tmp___27;
      }
#line 1282
      if (tmp___28) {
        {
#line 1296
        *((im->gdes + ii)->p_data + i) = rrd_set_to_DNAN();
        }
      } else {
#line 1283
        paintval += value;
#line 1284
        *((im->gdes + ii)->p_data + i) = paintval;
#line 1288
        if (sizeof(paintval) == sizeof(float )) {
          {
#line 1288
          tmp___19 = __finitef((float )paintval);
#line 1288
          tmp___23 = tmp___19;
          }
        } else {
#line 1288
          if (sizeof(paintval) == sizeof(double )) {
            {
#line 1288
            tmp___20 = __finite(paintval);
#line 1288
            tmp___22 = tmp___20;
            }
          } else {
            {
#line 1288
            tmp___21 = __finitel((long double )paintval);
#line 1288
            tmp___22 = tmp___21;
            }
          }
#line 1288
          tmp___23 = tmp___22;
        }
#line 1288
        if (tmp___23) {
#line 1288
          if ((unsigned int )(im->gdes + ii)->gf != 8U) {
#line 1288
            if (! (im->gdes + ii)->skipscale) {
#line 1289
              if (sizeof(minval) == sizeof(float )) {
                {
#line 1289
                tmp___9 = __isnanf((float )minval);
#line 1289
                tmp___13 = tmp___9;
                }
              } else {
#line 1289
                if (sizeof(minval) == sizeof(double )) {
                  {
#line 1289
                  tmp___10 = __isnan(minval);
#line 1289
                  tmp___12 = tmp___10;
                  }
                } else {
                  {
#line 1289
                  tmp___11 = __isnanl((long double )minval);
#line 1289
                  tmp___12 = tmp___11;
                  }
                }
#line 1289
                tmp___13 = tmp___12;
              }
#line 1289
              if (tmp___13) {
#line 1289
                goto _L___1;
              } else
#line 1289
              if (paintval < minval) {
                _L___1: /* CIL Label */ 
#line 1289
                if (im->logarithmic) {
#line 1289
                  if (! (paintval <= 0.0)) {
#line 1291
                    minval = paintval;
                  }
                } else {
#line 1291
                  minval = paintval;
                }
              }
#line 1292
              if (sizeof(maxval) == sizeof(float )) {
                {
#line 1292
                tmp___14 = __isnanf((float )maxval);
#line 1292
                tmp___18 = tmp___14;
                }
              } else {
#line 1292
                if (sizeof(maxval) == sizeof(double )) {
                  {
#line 1292
                  tmp___15 = __isnan(maxval);
#line 1292
                  tmp___17 = tmp___15;
                  }
                } else {
                  {
#line 1292
                  tmp___16 = __isnanl((long double )maxval);
#line 1292
                  tmp___17 = tmp___16;
                  }
                }
#line 1292
                tmp___18 = tmp___17;
              }
#line 1292
              if (tmp___18) {
#line 1293
                maxval = paintval;
              } else
#line 1292
              if (paintval > maxval) {
#line 1293
                maxval = paintval;
              }
            }
          }
        }
      }
#line 1298
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 1300
      rrd_set_error((char *)"STACK should already be turned into LINE or AREA here");
      }
#line 1302
      return (-1);
#line 1303
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1305
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1246
      ii ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1240
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1314
  if (im->logarithmic) {
#line 1315
    if (sizeof(minval) == sizeof(float )) {
      {
#line 1315
      tmp___29 = __isnanf((float )minval);
#line 1315
      tmp___33 = tmp___29;
      }
    } else {
#line 1315
      if (sizeof(minval) == sizeof(double )) {
        {
#line 1315
        tmp___30 = __isnan(minval);
#line 1315
        tmp___32 = tmp___30;
        }
      } else {
        {
#line 1315
        tmp___31 = __isnanl((long double )minval);
#line 1315
        tmp___32 = tmp___31;
        }
      }
#line 1315
      tmp___33 = tmp___32;
    }
#line 1315
    if (tmp___33) {
#line 1316
      minval = 0.0;
#line 1317
      maxval = 5.1;
    } else {
#line 1315
      if (sizeof(maxval) == sizeof(float )) {
        {
#line 1315
        tmp___34 = __isnanf((float )maxval);
#line 1315
        tmp___38 = tmp___34;
        }
      } else {
#line 1315
        if (sizeof(maxval) == sizeof(double )) {
          {
#line 1315
          tmp___35 = __isnan(maxval);
#line 1315
          tmp___37 = tmp___35;
          }
        } else {
          {
#line 1315
          tmp___36 = __isnanl((long double )maxval);
#line 1315
          tmp___37 = tmp___36;
          }
        }
#line 1315
        tmp___38 = tmp___37;
      }
#line 1315
      if (tmp___38) {
#line 1316
        minval = 0.0;
#line 1317
        maxval = 5.1;
      } else
#line 1315
      if (maxval <= (double )0) {
#line 1316
        minval = 0.0;
#line 1317
        maxval = 5.1;
      }
    }
#line 1321
    if (minval <= (double )0) {
#line 1322
      minval = maxval / 10e8;
    }
  } else {
#line 1325
    if (sizeof(minval) == sizeof(float )) {
      {
#line 1325
      tmp___39 = __isnanf((float )minval);
#line 1325
      tmp___43 = tmp___39;
      }
    } else {
#line 1325
      if (sizeof(minval) == sizeof(double )) {
        {
#line 1325
        tmp___40 = __isnan(minval);
#line 1325
        tmp___42 = tmp___40;
        }
      } else {
        {
#line 1325
        tmp___41 = __isnanl((long double )minval);
#line 1325
        tmp___42 = tmp___41;
        }
      }
#line 1325
      tmp___43 = tmp___42;
    }
#line 1325
    if (tmp___43) {
#line 1326
      minval = 0.0;
#line 1327
      maxval = 1.0;
    } else {
#line 1325
      if (sizeof(maxval) == sizeof(float )) {
        {
#line 1325
        tmp___44 = __isnanf((float )maxval);
#line 1325
        tmp___48 = tmp___44;
        }
      } else {
#line 1325
        if (sizeof(maxval) == sizeof(double )) {
          {
#line 1325
          tmp___45 = __isnan(maxval);
#line 1325
          tmp___47 = tmp___45;
          }
        } else {
          {
#line 1325
          tmp___46 = __isnanl((long double )maxval);
#line 1325
          tmp___47 = tmp___46;
          }
        }
#line 1325
        tmp___48 = tmp___47;
      }
#line 1325
      if (tmp___48) {
#line 1326
        minval = 0.0;
#line 1327
        maxval = 1.0;
      }
    }
  }
#line 1333
  if (sizeof(im->minval) == sizeof(float )) {
    {
#line 1333
    tmp___49 = __isnanf((float )im->minval);
#line 1333
    tmp___53 = tmp___49;
    }
  } else {
#line 1333
    if (sizeof(im->minval) == sizeof(double )) {
      {
#line 1333
      tmp___50 = __isnan(im->minval);
#line 1333
      tmp___52 = tmp___50;
      }
    } else {
      {
#line 1333
      tmp___51 = __isnanl((long double )im->minval);
#line 1333
      tmp___52 = tmp___51;
      }
    }
#line 1333
    tmp___53 = tmp___52;
  }
#line 1333
  if (tmp___53) {
#line 1333
    goto _L___2;
  } else
#line 1333
  if (! im->rigid) {
#line 1333
    if (im->minval > minval) {
      _L___2: /* CIL Label */ 
#line 1336
      if (im->logarithmic) {
#line 1337
        im->minval = minval / 2.0;
      } else {
#line 1339
        im->minval = minval;
      }
    }
  }
#line 1341
  if (sizeof(im->maxval) == sizeof(float )) {
    {
#line 1341
    tmp___54 = __isnanf((float )im->maxval);
#line 1341
    tmp___58 = tmp___54;
    }
  } else {
#line 1341
    if (sizeof(im->maxval) == sizeof(double )) {
      {
#line 1341
      tmp___55 = __isnan(im->maxval);
#line 1341
      tmp___57 = tmp___55;
      }
    } else {
      {
#line 1341
      tmp___56 = __isnanl((long double )im->maxval);
#line 1341
      tmp___57 = tmp___56;
      }
    }
#line 1341
    tmp___58 = tmp___57;
  }
#line 1341
  if (tmp___58) {
#line 1341
    goto _L___3;
  } else
#line 1341
  if (! im->rigid) {
#line 1341
    if (im->maxval < maxval) {
      _L___3: /* CIL Label */ 
#line 1344
      if (im->logarithmic) {
#line 1345
        im->maxval = maxval * 2.0;
      } else {
#line 1347
        im->maxval = maxval;
      }
    }
  }
#line 1351
  if (im->minval > im->maxval) {
#line 1352
    if (im->minval > (rrd_value_t )0) {
#line 1353
      im->minval = 0.99 * im->maxval;
    } else {
#line 1355
      im->minval = 1.01 * im->maxval;
    }
  }
  {
#line 1359
  tmp___60 = AlmostEqual2sComplement((float )im->minval, (float )im->maxval, 4);
  }
#line 1359
  if (tmp___60) {
#line 1360
    if (im->maxval > (rrd_value_t )0) {
#line 1361
      im->maxval *= 1.01;
    } else {
#line 1363
      im->maxval *= 0.99;
    }
    {
#line 1366
    tmp___59 = AlmostEqual2sComplement((float )im->maxval, (float )0, 4);
    }
#line 1366
    if (tmp___59) {
#line 1367
      im->maxval = 1.0;
    }
  }
#line 1370
  return (0);
}
}
#line 1374
static int find_first_weekday(void) ;
#line 1374 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
static int first_weekday  =    -1;
#line 1373 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
static int find_first_weekday(void) 
{ 
  char *tmp ;
  int week_1stday ;
  long week_1stday_l ;
  char *tmp___0 ;

  {
#line 1375
  if (first_weekday == -1) {
    {
#line 1379
    tmp = nl_langinfo(131176);
#line 1379
    first_weekday = (int )*(tmp + 0);
#line 1381
    tmp___0 = nl_langinfo(131174);
#line 1381
    week_1stday_l = (long )tmp___0;
    }
#line 1382
    if (week_1stday_l == 19971130L) {
#line 1382
      week_1stday = 0;
    } else
#line 1383
    if (week_1stday_l == 19971201L) {
#line 1383
      week_1stday = 1;
    } else {
#line 1386
      first_weekday = 1;
#line 1387
      return (first_weekday);
    }
#line 1389
    first_weekday = ((week_1stday + first_weekday) - 1) % 7;
  }
#line 1394
  return (first_weekday);
}
}
#line 1399 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
time_t find_first_time(time_t start , enum tmt_en baseint , long basestep ) 
{ 
  struct tm tm ;
  int tmp ;
  int tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 1407
  localtime_r((time_t const   */* __restrict  */)(& start), (struct tm */* __restrict  */)(& tm));
#line 1409
  tm.tm_isdst = -1;
  }
  {
#line 1412
  if ((unsigned int )baseint == 0U) {
#line 1412
    goto case_0;
  }
#line 1416
  if ((unsigned int )baseint == 1U) {
#line 1416
    goto case_1;
  }
#line 1421
  if ((unsigned int )baseint == 2U) {
#line 1421
    goto case_2;
  }
#line 1427
  if ((unsigned int )baseint == 3U) {
#line 1427
    goto case_3;
  }
#line 1434
  if ((unsigned int )baseint == 4U) {
#line 1434
    goto case_4;
  }
#line 1445
  if ((unsigned int )baseint == 5U) {
#line 1445
    goto case_5;
  }
#line 1454
  if ((unsigned int )baseint == 6U) {
#line 1454
    goto case_6;
  }
#line 1411
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1413
  tm.tm_sec = (int )((long )tm.tm_sec - (long )tm.tm_sec % basestep);
#line 1415
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1417
  tm.tm_sec = 0;
#line 1418
  tm.tm_min = (int )((long )tm.tm_min - (long )tm.tm_min % basestep);
#line 1420
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1422
  tm.tm_sec = 0;
#line 1423
  tm.tm_min = 0;
#line 1424
  tm.tm_hour = (int )((long )tm.tm_hour - (long )tm.tm_hour % basestep);
#line 1426
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1429
  tm.tm_sec = 0;
#line 1430
  tm.tm_min = 0;
#line 1431
  tm.tm_hour = 0;
#line 1433
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1436
  tm.tm_sec = 0;
#line 1437
  tm.tm_min = 0;
#line 1438
  tm.tm_hour = 0;
#line 1439
  tmp = find_first_weekday();
#line 1439
  tm.tm_mday -= tm.tm_wday - tmp;
  }
#line 1441
  if (tm.tm_wday == 0) {
    {
#line 1441
    tmp___0 = find_first_weekday();
    }
#line 1441
    if (tmp___0 > 0) {
#line 1442
      tm.tm_mday -= 7;
    }
  }
#line 1444
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1446
  tm.tm_sec = 0;
#line 1447
  tm.tm_min = 0;
#line 1448
  tm.tm_hour = 0;
#line 1449
  tm.tm_mday = 1;
#line 1450
  tm.tm_mon = (int )((long )tm.tm_mon - (long )tm.tm_mon % basestep);
#line 1452
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1455
  tm.tm_sec = 0;
#line 1456
  tm.tm_min = 0;
#line 1457
  tm.tm_hour = 0;
#line 1458
  tm.tm_mday = 1;
#line 1459
  tm.tm_mon = 0;
#line 1460
  tm.tm_year = (int )((long )tm.tm_year - (long )(tm.tm_year + 1900) % basestep);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1464
  tmp___1 = mktime(& tm);
  }
#line 1464
  return (tmp___1);
}
}
#line 1468 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
time_t find_next_time(time_t current , enum tmt_en baseint , long basestep ) 
{ 
  struct tm tm ;
  time_t madetime ;
  int limit ;
  int tmp ;

  {
  {
#line 1477
  localtime_r((time_t const   */* __restrict  */)(& current), (struct tm */* __restrict  */)(& tm));
#line 1479
  tm.tm_isdst = -1;
#line 1481
  limit = 2;
  }
  {
#line 1483
  if ((unsigned int )baseint == 0U) {
#line 1483
    goto case_0;
  }
#line 1484
  if ((unsigned int )baseint == 1U) {
#line 1484
    goto case_1;
  }
#line 1485
  if ((unsigned int )baseint == 2U) {
#line 1485
    goto case_2;
  }
#line 1486
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1483
  limit = 7200;
#line 1483
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1484
  limit = 120;
#line 1484
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1485
  limit = 2;
#line 1485
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1486
  limit = 2;
#line 1486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1488
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1490
    if ((unsigned int )baseint == 0U) {
#line 1490
      goto case_0___0;
    }
#line 1494
    if ((unsigned int )baseint == 1U) {
#line 1494
      goto case_1___0;
    }
#line 1498
    if ((unsigned int )baseint == 2U) {
#line 1498
      goto case_2___0;
    }
#line 1502
    if ((unsigned int )baseint == 3U) {
#line 1502
      goto case_3;
    }
#line 1506
    if ((unsigned int )baseint == 4U) {
#line 1506
      goto case_4;
    }
#line 1510
    if ((unsigned int )baseint == 5U) {
#line 1510
      goto case_5;
    }
#line 1514
    if ((unsigned int )baseint == 6U) {
#line 1514
      goto case_6;
    }
#line 1489
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 1491
    tm.tm_sec = (int )((long )tm.tm_sec + basestep);
#line 1493
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 1495
    tm.tm_min = (int )((long )tm.tm_min + basestep);
#line 1497
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1499
    tm.tm_hour = (int )((long )tm.tm_hour + basestep);
#line 1501
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 1503
    tm.tm_mday = (int )((long )tm.tm_mday + basestep);
#line 1505
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 1507
    tm.tm_mday = (int )((long )tm.tm_mday + 7L * basestep);
#line 1509
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 1511
    tm.tm_mon = (int )((long )tm.tm_mon + basestep);
#line 1513
    goto switch_break___0;
    case_6: /* CIL Label */ 
#line 1515
    tm.tm_year = (int )((long )tm.tm_year + basestep);
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1517
    madetime = mktime(& tm);
    }
#line 1488
    if (madetime == -1L) {
#line 1488
      tmp = limit;
#line 1488
      limit --;
#line 1488
      if (! (tmp >= 0)) {
#line 1488
        goto while_break;
      }
    } else {
#line 1488
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1520
  return (madetime);
}
}
#line 1527 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int print_calc(image_desc_t *im ) 
{ 
  long i ;
  long ii ;
  long validsteps ;
  double printval ;
  struct tm tmvdef ;
  int graphelement ;
  long vidx ;
  int max_ii ;
  double magfact ;
  char *si_symb ;
  char *percent_s ;
  int prline_cnt ;
  time_t now ;
  time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  rrd_infoval_t prline ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 1533
  graphelement = 0;
#line 1536
  magfact = (double )-1;
#line 1537
  si_symb = (char *)"";
#line 1539
  prline_cnt = 0;
#line 1542
  tmp = time((time_t *)((void *)0));
#line 1542
  now = tmp;
#line 1544
  localtime_r((time_t const   */* __restrict  */)(& now), (struct tm */* __restrict  */)(& tmvdef));
#line 1545
  i = 0L;
  }
  {
#line 1545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1545
    if (! (i < im->gdes_c)) {
#line 1545
      goto while_break;
    }
#line 1546
    vidx = (im->gdes + i)->vidx;
    {
#line 1549
    if ((unsigned int )(im->gdes + i)->gf == 1U) {
#line 1549
      goto case_1;
    }
#line 1549
    if ((unsigned int )(im->gdes + i)->gf == 0U) {
#line 1549
      goto case_1;
    }
#line 1664
    if ((unsigned int )(im->gdes + i)->gf == 8U) {
#line 1664
      goto case_8___0;
    }
#line 1664
    if ((unsigned int )(im->gdes + i)->gf == 6U) {
#line 1664
      goto case_8___0;
    }
#line 1664
    if ((unsigned int )(im->gdes + i)->gf == 5U) {
#line 1664
      goto case_8___0;
    }
#line 1667
    if ((unsigned int )(im->gdes + i)->gf == 3U) {
#line 1667
      goto case_3___0;
    }
#line 1673
    if ((unsigned int )(im->gdes + i)->gf == 4U) {
#line 1673
      goto case_4___0;
    }
#line 1688
    if ((unsigned int )(im->gdes + i)->gf == 14U) {
#line 1688
      goto case_14;
    }
#line 1688
    if ((unsigned int )(im->gdes + i)->gf == 13U) {
#line 1688
      goto case_14;
    }
#line 1688
    if ((unsigned int )(im->gdes + i)->gf == 12U) {
#line 1688
      goto case_14;
    }
#line 1688
    if ((unsigned int )(im->gdes + i)->gf == 11U) {
#line 1688
      goto case_14;
    }
#line 1688
    if ((unsigned int )(im->gdes + i)->gf == 10U) {
#line 1688
      goto case_14;
    }
#line 1688
    if ((unsigned int )(im->gdes + i)->gf == 9U) {
#line 1688
      goto case_14;
    }
#line 1688
    if ((unsigned int )(im->gdes + i)->gf == 2U) {
#line 1688
      goto case_14;
    }
#line 1690
    if ((unsigned int )(im->gdes + i)->gf == 7U) {
#line 1690
      goto case_7___0;
    }
#line 1547
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1554
    if ((unsigned int )(im->gdes + vidx)->gf == 12U) {
      {
#line 1555
      printval = (im->gdes + vidx)->vf.val;
#line 1556
      localtime_r((time_t const   */* __restrict  */)(& (im->gdes + vidx)->vf.when),
                  (struct tm */* __restrict  */)(& tmvdef));
      }
    } else {
      {
#line 1558
      max_ii = (int )(((unsigned long )((im->gdes + vidx)->end - (im->gdes + vidx)->start) / (im->gdes + vidx)->step) * (im->gdes + vidx)->ds_cnt);
#line 1560
      printval = rrd_set_to_DNAN();
#line 1561
      validsteps = 0L;
#line 1562
      ii = (im->gdes + vidx)->ds;
      }
      {
#line 1562
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1562
        if (! (ii < (long )max_ii)) {
#line 1562
          goto while_break___0;
        }
#line 1564
        if (sizeof(*((im->gdes + vidx)->data + ii)) == sizeof(float )) {
          {
#line 1564
          tmp___0 = __finitef((float )*((im->gdes + vidx)->data + ii));
#line 1564
          tmp___4 = tmp___0;
          }
        } else {
#line 1564
          if (sizeof(*((im->gdes + vidx)->data + ii)) == sizeof(double )) {
            {
#line 1564
            tmp___1 = __finite(*((im->gdes + vidx)->data + ii));
#line 1564
            tmp___3 = tmp___1;
            }
          } else {
            {
#line 1564
            tmp___2 = __finitel((long double )*((im->gdes + vidx)->data + ii));
#line 1564
            tmp___3 = tmp___2;
            }
          }
#line 1564
          tmp___4 = tmp___3;
        }
#line 1564
        if (! tmp___4) {
#line 1565
          goto __Cont;
        }
#line 1566
        if (sizeof(printval) == sizeof(float )) {
          {
#line 1566
          tmp___5 = __isnanf((float )printval);
#line 1566
          tmp___9 = tmp___5;
          }
        } else {
#line 1566
          if (sizeof(printval) == sizeof(double )) {
            {
#line 1566
            tmp___6 = __isnan(printval);
#line 1566
            tmp___8 = tmp___6;
            }
          } else {
            {
#line 1566
            tmp___7 = __isnanl((long double )printval);
#line 1566
            tmp___8 = tmp___7;
            }
          }
#line 1566
          tmp___9 = tmp___8;
        }
#line 1566
        if (tmp___9) {
#line 1567
          printval = *((im->gdes + vidx)->data + ii);
#line 1568
          validsteps ++;
#line 1569
          goto __Cont;
        }
        {
#line 1578
        if ((unsigned int )(im->gdes + i)->cf == 0U) {
#line 1578
          goto case_0___0;
        }
#line 1578
        if ((unsigned int )(im->gdes + i)->cf == 5U) {
#line 1578
          goto case_0___0;
        }
#line 1578
        if ((unsigned int )(im->gdes + i)->cf == 7U) {
#line 1578
          goto case_0___0;
        }
#line 1578
        if ((unsigned int )(im->gdes + i)->cf == 6U) {
#line 1578
          goto case_0___0;
        }
#line 1578
        if ((unsigned int )(im->gdes + i)->cf == 9U) {
#line 1578
          goto case_0___0;
        }
#line 1578
        if ((unsigned int )(im->gdes + i)->cf == 4U) {
#line 1578
          goto case_0___0;
        }
#line 1582
        if ((unsigned int )(im->gdes + i)->cf == 1U) {
#line 1582
          goto case_1___0;
        }
#line 1586
        if ((unsigned int )(im->gdes + i)->cf == 2U) {
#line 1586
          goto case_2;
        }
#line 1586
        if ((unsigned int )(im->gdes + i)->cf == 8U) {
#line 1586
          goto case_2;
        }
#line 1589
        if ((unsigned int )(im->gdes + i)->cf == 3U) {
#line 1589
          goto case_3;
        }
#line 1572
        goto switch_break___0;
        case_0___0: /* CIL Label */ 
        case_5: /* CIL Label */ 
        case_7: /* CIL Label */ 
        case_6: /* CIL Label */ 
        case_9: /* CIL Label */ 
        case_4: /* CIL Label */ 
#line 1579
        validsteps ++;
#line 1580
        printval += *((im->gdes + vidx)->data + ii);
#line 1581
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
#line 1583
        if (printval < *((im->gdes + vidx)->data + ii)) {
#line 1583
          printval = printval;
        } else {
#line 1583
          printval = *((im->gdes + vidx)->data + ii);
        }
#line 1584
        goto switch_break___0;
        case_2: /* CIL Label */ 
        case_8: /* CIL Label */ 
#line 1587
        if (printval > *((im->gdes + vidx)->data + ii)) {
#line 1587
          printval = printval;
        } else {
#line 1587
          printval = *((im->gdes + vidx)->data + ii);
        }
#line 1588
        goto switch_break___0;
        case_3: /* CIL Label */ 
#line 1590
        printval = *((im->gdes + vidx)->data + ii);
        switch_break___0: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ 
#line 1562
        ii = (long )((unsigned long )ii + (im->gdes + vidx)->ds_cnt);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1593
      if ((unsigned int )(im->gdes + i)->cf == 0U) {
#line 1593
        goto _L;
      } else
#line 1593
      if ((unsigned int )(im->gdes + i)->cf > 3U) {
        _L: /* CIL Label */ 
#line 1594
        if (validsteps > 1L) {
#line 1595
          printval /= (double )validsteps;
        }
      }
    }
#line 1600
    if (! (im->gdes + i)->strftm) {
      {
#line 1600
      percent_s = strstr((char const   *)((im->gdes + i)->format), "%S");
      }
#line 1600
      if ((unsigned long )percent_s != (unsigned long )((void *)0)) {
#line 1606
        if (magfact < 0.0) {
          {
#line 1607
          auto_scale(im, & printval, & si_symb, & magfact);
          }
#line 1608
          if (printval == 0.0) {
#line 1609
            magfact = - 1.0;
          }
        } else {
#line 1611
          printval /= magfact;
        }
#line 1613
        percent_s ++;
#line 1613
        *percent_s = (char )'s';
      } else {
#line 1600
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1614
    if (! (im->gdes + i)->strftm) {
      {
#line 1614
      tmp___10 = strstr((char const   *)((im->gdes + i)->format), "%s");
      }
#line 1614
      if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
        {
#line 1615
        auto_scale(im, & printval, & si_symb, & magfact);
        }
      }
    }
#line 1618
    if ((unsigned int )(im->gdes + i)->gf == 0U) {
#line 1621
      if ((im->gdes + i)->strftm) {
        {
#line 1622
        tmp___11 = malloc(202UL * sizeof(char ));
#line 1622
        prline.u_str = (char *)tmp___11;
#line 1623
        strftime((char */* __restrict  */)prline.u_str, (size_t )200, (char const   */* __restrict  */)((im->gdes + i)->format),
                 (struct tm  const  */* __restrict  */)(& tmvdef));
        }
      } else {
        {
#line 1625
        tmp___12 = bad_format((im->gdes + i)->format);
        }
#line 1625
        if (tmp___12) {
          {
#line 1626
          rrd_set_error((char *)"bad format for PRINT in \'%s\'", (im->gdes + i)->format);
          }
#line 1628
          return (-1);
        } else {
          {
#line 1630
          prline.u_str = sprintf_alloc((im->gdes + i)->format, printval, si_symb);
          }
        }
      }
      {
#line 1633
      tmp___13 = prline_cnt;
#line 1633
      prline_cnt ++;
#line 1633
      tmp___14 = sprintf_alloc((char *)"print[%ld]", tmp___13);
#line 1633
      grinfo_push(im, tmp___14, (rrd_info_type_t )2, prline);
#line 1636
      free((void *)prline.u_str);
      }
    } else {
#line 1640
      if ((im->gdes + i)->strftm) {
        {
#line 1641
        strftime((char */* __restrict  */)((im->gdes + i)->legend), (size_t )200,
                 (char const   */* __restrict  */)((im->gdes + i)->format), (struct tm  const  */* __restrict  */)(& tmvdef));
        }
      } else {
        {
#line 1644
        tmp___15 = bad_format((im->gdes + i)->format);
        }
#line 1644
        if (tmp___15) {
          {
#line 1645
          rrd_set_error((char *)"bad format for GPRINT in \'%s\'", (im->gdes + i)->format);
          }
#line 1648
          return (-1);
        }
        {
#line 1651
        snprintf((char */* __restrict  */)((im->gdes + i)->legend), (size_t )198,
                 (char const   */* __restrict  */)((im->gdes + i)->format), printval,
                 si_symb);
        }
      }
#line 1659
      graphelement = 1;
    }
#line 1661
    goto switch_break;
    case_8___0: /* CIL Label */ 
    case_6___0: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
#line 1665
    graphelement = 1;
#line 1666
    goto switch_break;
    case_3___0: /* CIL Label */ 
#line 1668
    if (sizeof((im->gdes + i)->yrule) == sizeof(float )) {
      {
#line 1668
      tmp___16 = __isnanf((float )(im->gdes + i)->yrule);
#line 1668
      tmp___20 = tmp___16;
      }
    } else {
#line 1668
      if (sizeof((im->gdes + i)->yrule) == sizeof(double )) {
        {
#line 1668
        tmp___17 = __isnan((im->gdes + i)->yrule);
#line 1668
        tmp___19 = tmp___17;
        }
      } else {
        {
#line 1668
        tmp___18 = __isnanl((long double )(im->gdes + i)->yrule);
#line 1668
        tmp___19 = tmp___18;
        }
      }
#line 1668
      tmp___20 = tmp___19;
    }
#line 1668
    if (tmp___20) {
#line 1669
      (im->gdes + i)->yrule = (im->gdes + vidx)->vf.val;
    }
#line 1671
    graphelement = 1;
#line 1672
    goto switch_break;
    case_4___0: /* CIL Label */ 
#line 1674
    if ((im->gdes + i)->xrule == 0L) {
#line 1675
      (im->gdes + i)->xrule = (im->gdes + vidx)->vf.when;
    }
#line 1677
    graphelement = 1;
#line 1678
    goto switch_break;
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
#line 1689
    goto switch_break;
    case_7___0: /* CIL Label */ 
    {
#line 1691
    rrd_set_error((char *)"STACK should already be turned into LINE or AREA here");
    }
#line 1693
    return (-1);
#line 1694
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1545
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1697
  return (graphelement);
}
}
#line 1703 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int leg_place(image_desc_t *im , int calc_width ) 
{ 
  int interleg ;
  int border ;
  int fill ;
  int fill_last ;
  double legendwidth ;
  int leg_c ;
  double leg_x ;
  int leg_y ;
  int leg_cc ;
  double glue ;
  int i ;
  int ii ;
  int mark ;
  char default_txtalign ;
  int *legspace ;
  char *tab ;
  char saved_legend[205] ;
  void *tmp ;
  char prt_fctn ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1708
  interleg = (int )(im->text_prop[4].size * 2.0);
#line 1709
  border = (int )(im->text_prop[4].size * 2.0);
#line 1710
  fill = 0;
#line 1712
  leg_c = 0;
#line 1713
  leg_x = (double )border;
#line 1714
  leg_y = 0;
#line 1716
  glue = (double )0;
#line 1717
  mark = 0;
#line 1718
  default_txtalign = (char)3;
#line 1723
  if (calc_width) {
#line 1724
    legendwidth = (double )0;
  } else {
#line 1727
    legendwidth = (double )(im->legendwidth - (long )(2 * border));
  }
#line 1731
  if (! (im->extra_flags & 16)) {
#line 1731
    if (! (im->extra_flags & 64)) {
      {
#line 1732
      tmp = malloc((unsigned long )im->gdes_c * sizeof(int ));
#line 1732
      legspace = (int *)tmp;
      }
#line 1732
      if ((unsigned long )legspace == (unsigned long )((void *)0)) {
        {
#line 1733
        rrd_set_error((char *)"malloc for legspace");
        }
#line 1734
        return (-1);
      }
#line 1737
      i = 0;
      {
#line 1737
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1737
        if (! ((long )i < im->gdes_c)) {
#line 1737
          goto while_break;
        }
#line 1739
        if (calc_width) {
          {
#line 1740
          strcpy((char */* __restrict  */)(saved_legend), (char const   */* __restrict  */)((im->gdes + i)->legend));
          }
        }
#line 1743
        fill_last = fill;
#line 1745
        if ((unsigned int )(im->gdes + i)->gf == 9U) {
#line 1746
          default_txtalign = (char )(im->gdes + i)->txtalign;
        }
#line 1749
        if (! (im->extra_flags & 128)) {
#line 1750
          if ((unsigned int )(im->gdes + i)->gf == 3U) {
#line 1750
            if ((im->gdes + i)->yrule < im->minval) {
#line 1753
              (im->gdes + i)->legend[0] = (char )'\000';
            } else
#line 1750
            if ((im->gdes + i)->yrule > im->maxval) {
#line 1753
              (im->gdes + i)->legend[0] = (char )'\000';
            }
          }
#line 1754
          if ((unsigned int )(im->gdes + i)->gf == 4U) {
#line 1754
            if ((im->gdes + i)->xrule < im->start) {
#line 1757
              (im->gdes + i)->legend[0] = (char )'\000';
            } else
#line 1754
            if ((im->gdes + i)->xrule > im->end) {
#line 1757
              (im->gdes + i)->legend[0] = (char )'\000';
            }
          }
        }
        {
#line 1761
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1761
          tab = strstr((char const   *)((im->gdes + i)->legend), "\\t");
          }
#line 1761
          if (! tab) {
#line 1761
            goto while_break___0;
          }
          {
#line 1762
          tmp___0 = strlen((char const   *)tab);
#line 1762
          memmove((void *)tab, (void const   *)(tab + 1), tmp___0);
#line 1763
          *(tab + 0) = (char)9;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1766
        tmp___1 = strlen((char const   *)((im->gdes + i)->legend));
#line 1766
        leg_cc = (int )tmp___1;
        }
#line 1768
        if (leg_cc >= 2) {
#line 1768
          if ((int )(im->gdes + i)->legend[leg_cc - 2] == 92) {
#line 1769
            prt_fctn = (im->gdes + i)->legend[leg_cc - 1];
#line 1770
            leg_cc -= 2;
#line 1771
            (im->gdes + i)->legend[leg_cc] = (char )'\000';
          } else {
#line 1773
            prt_fctn = (char )'\000';
          }
        } else {
#line 1773
          prt_fctn = (char )'\000';
        }
#line 1776
        if ((int )prt_fctn != 108) {
#line 1776
          if ((int )prt_fctn != 110) {
#line 1776
            if ((int )prt_fctn != 114) {
#line 1776
              if ((int )prt_fctn != 106) {
#line 1776
                if ((int )prt_fctn != 99) {
#line 1776
                  if ((int )prt_fctn != 117) {
#line 1776
                    if ((int )prt_fctn != 46) {
#line 1776
                      if ((int )prt_fctn != 115) {
#line 1776
                        if ((int )prt_fctn != 0) {
#line 1776
                          if ((int )prt_fctn != 103) {
                            {
#line 1783
                            free((void *)legspace);
#line 1784
                            rrd_set_error((char *)"Unknown control code at the end of \'%s\\%c\'",
                                          (im->gdes + i)->legend, (int )prt_fctn);
                            }
#line 1787
                            return (-1);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 1790
        if ((int )prt_fctn == 110) {
#line 1791
          prt_fctn = (char )'l';
        }
#line 1794
        if ((int )prt_fctn == 46) {
#line 1795
          prt_fctn = (char )'\000';
        }
        {
#line 1799
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1799
          if ((int )prt_fctn == 103) {
#line 1799
            if (leg_cc > 0) {
#line 1799
              if (! ((int )(im->gdes + i)->legend[leg_cc - 1] == 32)) {
#line 1799
                goto while_break___1;
              }
            } else {
#line 1799
              goto while_break___1;
            }
          } else {
#line 1799
            goto while_break___1;
          }
#line 1801
          leg_cc --;
#line 1802
          (im->gdes + i)->legend[leg_cc] = (char )'\000';
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1805
        if (leg_cc != 0) {
#line 1808
          if ((int )prt_fctn == 103) {
#line 1808
            *(legspace + i) = 0;
          } else {
#line 1808
            *(legspace + i) = interleg;
          }
#line 1809
          if (fill > 0) {
#line 1810
            fill += *(legspace + i);
          }
          {
#line 1812
          tmp___2 = gfx_get_text_width(im, (double )(fill + border), im->text_prop[4].font_desc,
                                       im->tabwidth, (im->gdes + i)->legend);
#line 1812
          fill = (int )((double )fill + tmp___2);
#line 1820
          leg_c ++;
          }
        } else {
#line 1822
          *(legspace + i) = 0;
        }
#line 1825
        if ((int )prt_fctn == 103) {
#line 1826
          prt_fctn = (char )'\000';
        }
#line 1829
        if ((int )prt_fctn == 0) {
#line 1830
          if (calc_width) {
#line 1830
            if ((double )fill > legendwidth) {
#line 1831
              legendwidth = (double )fill;
            }
          }
#line 1833
          if ((long )i == im->gdes_c - 1L) {
#line 1833
            goto _L;
          } else
#line 1833
          if ((double )fill > legendwidth) {
            _L: /* CIL Label */ 
            {
#line 1836
            if ((int )default_txtalign == 1) {
#line 1836
              goto case_1;
            }
#line 1839
            if ((int )default_txtalign == 2) {
#line 1839
              goto case_2;
            }
#line 1842
            if ((int )default_txtalign == 3) {
#line 1842
              goto case_3;
            }
#line 1845
            goto switch_default;
            case_1: /* CIL Label */ 
#line 1837
            prt_fctn = (char )'r';
#line 1838
            goto switch_break;
            case_2: /* CIL Label */ 
#line 1840
            prt_fctn = (char )'c';
#line 1841
            goto switch_break;
            case_3: /* CIL Label */ 
#line 1843
            prt_fctn = (char )'j';
#line 1844
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 1846
            prt_fctn = (char )'l';
#line 1847
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
#line 1851
          if ((double )fill > legendwidth) {
#line 1852
            if (leg_c > 1) {
#line 1854
              i --;
#line 1855
              fill = fill_last;
#line 1856
              leg_c --;
            }
          }
#line 1859
          if (leg_c == 1) {
#line 1859
            if ((int )prt_fctn == 106) {
#line 1860
              prt_fctn = (char )'l';
            }
          }
        }
#line 1864
        if ((int )prt_fctn != 0) {
#line 1865
          leg_x = (double )border;
#line 1866
          if (leg_c >= 2) {
#line 1866
            if ((int )prt_fctn == 106) {
#line 1867
              glue = (legendwidth - (double )fill) / (double )(leg_c - 1);
            } else {
#line 1869
              glue = (double )0;
            }
          } else {
#line 1869
            glue = (double )0;
          }
#line 1871
          if ((int )prt_fctn == 99) {
#line 1872
            leg_x = (double )border + (legendwidth - (double )fill) / 2.0;
          }
#line 1873
          if ((int )prt_fctn == 114) {
#line 1874
            leg_x = (legendwidth - (double )fill) + (double )border;
          }
#line 1875
          ii = mark;
          {
#line 1875
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1875
            if (! (ii <= i)) {
#line 1875
              goto while_break___2;
            }
#line 1876
            if ((int )(im->gdes + ii)->legend[0] == 0) {
#line 1877
              goto __Cont;
            }
            {
#line 1878
            (im->gdes + ii)->leg_x = leg_x;
#line 1879
            (im->gdes + ii)->leg_y = (double )(leg_y + border);
#line 1880
            tmp___3 = gfx_get_text_width(im, leg_x, im->text_prop[4].font_desc, im->tabwidth,
                                         (im->gdes + ii)->legend);
#line 1880
            leg_x += (tmp___3 + (double )*(legspace + ii)) + glue;
            }
            __Cont: /* CIL Label */ 
#line 1875
            ii ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1890
          if (leg_x > (double )border) {
#line 1891
            leg_y = (int )((double )leg_y + im->text_prop[4].size * 1.8);
          } else
#line 1890
          if ((int )prt_fctn == 115) {
#line 1891
            leg_y = (int )((double )leg_y + im->text_prop[4].size * 1.8);
          }
#line 1892
          if ((int )prt_fctn == 115) {
#line 1893
            leg_y = (int )((double )leg_y - im->text_prop[4].size);
          }
#line 1894
          if ((int )prt_fctn == 117) {
#line 1895
            leg_y = (int )((double )leg_y - im->text_prop[4].size * 1.8);
          }
#line 1897
          if (calc_width) {
#line 1897
            if ((double )fill > legendwidth) {
#line 1898
              legendwidth = (double )fill;
            }
          }
#line 1900
          fill = 0;
#line 1901
          leg_c = 0;
#line 1902
          mark = ii;
        }
#line 1905
        if (calc_width) {
          {
#line 1906
          strcpy((char */* __restrict  */)((im->gdes + i)->legend), (char const   */* __restrict  */)(saved_legend));
          }
        }
#line 1737
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1910
      if (calc_width) {
#line 1911
        im->legendwidth = (long )(legendwidth + (double )(2 * border));
      } else {
#line 1914
        im->legendheight = (long )((double )leg_y + (double )border * 0.6);
      }
      {
#line 1916
      free((void *)legspace);
      }
    }
  }
#line 1918
  return (0);
}
}
#line 1927 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int calc_horizontal_grid(image_desc_t *im ) 
{ 
  double range ;
  double scaledrange ;
  int pixel ;
  int i ;
  int gridind ;
  int decimals ;
  int fractionals ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  int len ;
  char const   *tmp___18 ;
  int len___0 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 1934
  gridind = 0;
#line 1937
  im->ygrid_scale.labfact = 2;
#line 1938
  range = im->maxval - im->minval;
#line 1939
  scaledrange = range / im->magfact;
#line 1942
  if (sizeof(scaledrange) == sizeof(float )) {
    {
#line 1942
    tmp = __isnanf((float )scaledrange);
#line 1942
    tmp___3 = tmp;
    }
  } else {
#line 1942
    if (sizeof(scaledrange) == sizeof(double )) {
      {
#line 1942
      tmp___0 = __isnan(scaledrange);
#line 1942
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 1942
      tmp___1 = __isnanl((long double )scaledrange);
#line 1942
      tmp___2 = tmp___1;
      }
    }
#line 1942
    tmp___3 = tmp___2;
  }
#line 1942
  if (tmp___3) {
#line 1943
    return (0);
  }
#line 1947
  pixel = 1;
#line 1948
  if (sizeof(im->ygridstep) == sizeof(float )) {
    {
#line 1948
    tmp___20 = __isnanf((float )im->ygridstep);
#line 1948
    tmp___24 = tmp___20;
    }
  } else {
#line 1948
    if (sizeof(im->ygridstep) == sizeof(double )) {
      {
#line 1948
      tmp___21 = __isnan(im->ygridstep);
#line 1948
      tmp___23 = tmp___21;
      }
    } else {
      {
#line 1948
      tmp___22 = __isnanl((long double )im->ygridstep);
#line 1948
      tmp___23 = tmp___22;
      }
    }
#line 1948
    tmp___24 = tmp___23;
  }
#line 1948
  if (tmp___24) {
#line 1949
    if (im->extra_flags & 1) {
      {
#line 1951
      tmp___9 = fabs(im->maxval);
#line 1951
      tmp___10 = fabs(im->minval);
      }
#line 1951
      if (tmp___9 > tmp___10) {
        {
#line 1951
        tmp___6 = fabs(im->maxval);
#line 1951
        tmp___8 = tmp___6;
        }
      } else {
        {
#line 1951
        tmp___7 = fabs(im->minval);
#line 1951
        tmp___8 = tmp___7;
        }
      }
      {
#line 1951
      tmp___11 = log10((tmp___8 * (double )im->viewfactor) / im->magfact);
#line 1951
      tmp___12 = ceil(tmp___11);
#line 1951
      decimals = (int )tmp___12;
      }
#line 1955
      if (decimals <= 0) {
#line 1956
        decimals = 1;
      }
      {
#line 1957
      tmp___13 = log10((range * (double )im->viewfactor) / im->magfact);
#line 1957
      tmp___14 = floor(tmp___13);
#line 1957
      tmp___15 = pow((double )10, tmp___14);
#line 1957
      im->ygrid_scale.gridstep = (tmp___15 / (double )im->viewfactor) * im->magfact;
      }
#line 1961
      if (im->ygrid_scale.gridstep == (double )0) {
#line 1962
        im->ygrid_scale.gridstep = 0.1;
      }
#line 1964
      if (range / im->ygrid_scale.gridstep < (double )5) {
#line 1964
        if (im->ygrid_scale.gridstep >= (double )30) {
#line 1966
          im->ygrid_scale.gridstep /= (double )10;
        }
      }
#line 1967
      if (range / im->ygrid_scale.gridstep > (double )15) {
#line 1968
        im->ygrid_scale.gridstep *= (double )10;
      }
#line 1969
      if (range / im->ygrid_scale.gridstep > (double )5) {
#line 1970
        im->ygrid_scale.labfact = 1;
#line 1971
        if (range / im->ygrid_scale.gridstep > (double )8) {
#line 1974
          im->ygrid_scale.labfact = 2;
        } else
#line 1971
        if (im->ygrid_scale.gridstep < 1.8 * im->text_prop[2].size) {
#line 1974
          im->ygrid_scale.labfact = 2;
        }
      } else {
#line 1976
        im->ygrid_scale.gridstep /= (double )5;
#line 1977
        im->ygrid_scale.labfact = 5;
      }
      {
#line 1979
      tmp___16 = log10(((im->ygrid_scale.gridstep * (double )im->ygrid_scale.labfact) * (double )im->viewfactor) / im->magfact);
#line 1979
      tmp___17 = floor(tmp___16);
#line 1979
      fractionals = (int )tmp___17;
      }
#line 1984
      if (fractionals < 0) {
#line 1985
        len = (decimals - fractionals) + 1;
#line 1987
        if (im->unitslength < len + 2) {
#line 1988
          im->unitslength = len + 2;
        }
#line 1989
        if ((int )im->symbol != 32) {
#line 1989
          tmp___18 = " %c";
        } else {
#line 1989
          tmp___18 = "";
        }
        {
#line 1989
        sprintf((char */* __restrict  */)(im->ygrid_scale.labfmt), (char const   */* __restrict  */)"%%%d.%df%s",
                len, - fractionals, tmp___18);
        }
      } else {
#line 1993
        len___0 = decimals + 1;
#line 1995
        if (im->unitslength < len___0 + 2) {
#line 1996
          im->unitslength = len___0 + 2;
        }
#line 1997
        if ((int )im->symbol != 32) {
#line 1997
          tmp___19 = " %c";
        } else {
#line 1997
          tmp___19 = "";
        }
        {
#line 1997
        sprintf((char */* __restrict  */)(im->ygrid_scale.labfmt), (char const   */* __restrict  */)"%%%d.0f%s",
                len___0, tmp___19);
        }
      }
    } else {
#line 2001
      i = 0;
      {
#line 2001
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2001
        if (! (ylab[i].grid > (double )0)) {
#line 2001
          goto while_break;
        }
#line 2002
        pixel = (int )((double )im->ysize / (scaledrange / ylab[i].grid));
#line 2003
        gridind = i;
#line 2004
        if (pixel >= 5) {
#line 2005
          goto while_break;
        }
#line 2001
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2008
      i = 0;
      {
#line 2008
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2008
        if (! (i < 4)) {
#line 2008
          goto while_break___0;
        }
#line 2009
        if ((double )(pixel * ylab[gridind].lfac[i]) >= 1.8 * im->text_prop[2].size) {
#line 2011
          im->ygrid_scale.labfact = ylab[gridind].lfac[i];
#line 2012
          goto while_break___0;
        }
#line 2008
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2016
      im->ygrid_scale.gridstep = ylab[gridind].grid * im->magfact;
    }
  } else {
#line 2019
    im->ygrid_scale.gridstep = im->ygridstep;
#line 2020
    im->ygrid_scale.labfact = im->ylabfact;
  }
#line 2022
  return (1);
}
}
#line 2025 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int draw_horizontal_grid(image_desc_t *im ) 
{ 
  int i ;
  double scaledstep ;
  char graph_label[100] ;
  int nlabels ;
  double X0 ;
  double X1 ;
  int sgrid ;
  int egrid ;
  double MaxY ;
  double second_axis_magfact ;
  char *second_axis_symb ;
  double Y0 ;
  double tmp ;
  double YN ;
  double tmp___0 ;
  char sisym ;
  int tmp___1 ;
  char graph_label_right[100] ;
  double sval ;
  double dummy ;
  double tmp___2 ;
  double tmp___3 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 2032
  nlabels = 0;
#line 2033
  X0 = (double )im->xorigin;
#line 2034
  X1 = (double )(im->xorigin + im->xsize);
#line 2035
  sgrid = (int )(im->minval / im->ygrid_scale.gridstep - (rrd_value_t )1);
#line 2036
  egrid = (int )(im->maxval / im->ygrid_scale.gridstep + (rrd_value_t )1);
#line 2038
  second_axis_magfact = (double )0;
#line 2039
  second_axis_symb = (char *)"";
#line 2041
  scaledstep = (im->ygrid_scale.gridstep / im->magfact) * (double )im->viewfactor;
#line 2044
  MaxY = scaledstep * (double )egrid;
#line 2045
  i = sgrid;
  {
#line 2045
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2045
    if (! (i <= egrid)) {
#line 2045
      goto while_break;
    }
    {
#line 2046
    tmp = ytr(im, im->ygrid_scale.gridstep * (double )i);
#line 2046
    Y0 = tmp;
#line 2048
    tmp___0 = ytr(im, im->ygrid_scale.gridstep * (double )(i + 1));
#line 2048
    YN = tmp___0;
#line 2051
    tmp___2 = floor(Y0 + 0.5);
    }
#line 2051
    if (tmp___2 >= (double )(im->yorigin - im->ysize)) {
      {
#line 2051
      tmp___3 = floor(Y0 + 0.5);
      }
#line 2051
      if (tmp___3 <= (double )im->yorigin) {
#line 2056
        if (i % im->ygrid_scale.labfact == 0) {
#line 2056
          goto _L___1;
        } else
#line 2056
        if (nlabels == 1) {
#line 2056
          if (YN < (double )(im->yorigin - im->ysize)) {
#line 2056
            goto _L___1;
          } else
#line 2056
          if (YN > (double )im->yorigin) {
            _L___1: /* CIL Label */ 
#line 2059
            if ((int )im->symbol == 32) {
#line 2060
              if (im->extra_flags & 1) {
                {
#line 2061
                sprintf((char */* __restrict  */)(graph_label), (char const   */* __restrict  */)(im->ygrid_scale.labfmt),
                        scaledstep * (double )i);
                }
              } else
#line 2065
              if (MaxY < (double )10) {
                {
#line 2066
                sprintf((char */* __restrict  */)(graph_label), (char const   */* __restrict  */)"%4.1f",
                        scaledstep * (double )i);
                }
              } else {
                {
#line 2069
                sprintf((char */* __restrict  */)(graph_label), (char const   */* __restrict  */)"%4.0f",
                        scaledstep * (double )i);
                }
              }
            } else {
#line 2074
              if (i == 0) {
#line 2074
                tmp___1 = ' ';
              } else {
#line 2074
                tmp___1 = (int )im->symbol;
              }
#line 2074
              sisym = (char )tmp___1;
#line 2076
              if (im->extra_flags & 1) {
                {
#line 2077
                sprintf((char */* __restrict  */)(graph_label), (char const   */* __restrict  */)(im->ygrid_scale.labfmt),
                        scaledstep * (double )i, (int )sisym);
                }
              } else
#line 2081
              if (MaxY < (double )10) {
                {
#line 2082
                sprintf((char */* __restrict  */)(graph_label), (char const   */* __restrict  */)"%4.1f %c",
                        scaledstep * (double )i, (int )sisym);
                }
              } else {
                {
#line 2085
                sprintf((char */* __restrict  */)(graph_label), (char const   */* __restrict  */)"%4.0f %c",
                        scaledstep * (double )i, (int )sisym);
                }
              }
            }
#line 2090
            nlabels ++;
#line 2091
            if (im->second_axis_scale != (double )0) {
#line 2093
              sval = (im->ygrid_scale.gridstep * (double )i) * im->second_axis_scale + im->second_axis_shift;
#line 2094
              if ((int )im->second_axis_format[0] == 0) {
#line 2095
                if (! second_axis_magfact) {
                  {
#line 2096
                  dummy = ((im->ygrid_scale.gridstep * (double )(sgrid + egrid)) / 2.0) * im->second_axis_scale + im->second_axis_shift;
#line 2097
                  auto_scale(im, & dummy, & second_axis_symb, & second_axis_magfact);
                  }
                }
#line 2099
                sval /= second_axis_magfact;
#line 2101
                if (MaxY < (double )10) {
                  {
#line 2102
                  sprintf((char */* __restrict  */)(graph_label_right), (char const   */* __restrict  */)"%5.1f %s",
                          sval, second_axis_symb);
                  }
                } else {
                  {
#line 2104
                  sprintf((char */* __restrict  */)(graph_label_right), (char const   */* __restrict  */)"%5.0f %s",
                          sval, second_axis_symb);
                  }
                }
              } else {
                {
#line 2108
                sprintf((char */* __restrict  */)(graph_label_right), (char const   */* __restrict  */)(im->second_axis_format),
                        sval, "");
                }
              }
              {
#line 2110
              gfx_text(im, X1 + (double )7, Y0, im->graph_col[6], im->text_prop[2].font_desc,
                       im->tabwidth, 0.0, (enum gfx_h_align_en )1, (enum gfx_v_align_en )3,
                       (char const   *)(graph_label_right));
              }
            }
            {
#line 2118
            gfx_text(im, X0 - im->text_prop[2].size, Y0, im->graph_col[6], im->text_prop[2].font_desc,
                     im->tabwidth, 0.0, (enum gfx_h_align_en )2, (enum gfx_v_align_en )3,
                     (char const   *)(graph_label));
#line 2129
            gfx_line(im, X0 - (double )2, Y0, X0, Y0, 0.6, im->graph_col[5]);
#line 2131
            gfx_line(im, X1, Y0, X1 + (double )2, Y0, 0.6, im->graph_col[5]);
#line 2133
            gfx_dashed_line(im, X0 - (double )2, Y0, X1 + (double )2, Y0, 0.6, im->graph_col[5],
                            im->grid_dash_on, im->grid_dash_off);
            }
          } else {
#line 2056
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 2140
        if (! (im->extra_flags & 32)) {
          {
#line 2141
          gfx_line(im, X0 - (double )2, Y0, X0, Y0, 0.4, im->graph_col[4]);
#line 2144
          gfx_line(im, X1, Y0, X1 + (double )2, Y0, 0.4, im->graph_col[4]);
#line 2146
          gfx_dashed_line(im, X0 - (double )1, Y0, X1 + (double )1, Y0, 0.4, im->graph_col[4],
                          im->grid_dash_on, im->grid_dash_off);
          }
        }
      }
    }
#line 2045
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2155
  return (1);
}
}
#line 2159
double frexp10(double x , double *e___0 ) ;
#line 2162 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
double frexp10(double x , double *e___0 ) 
{ 
  double mnt ;
  int iexp ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  {
#line 2169
  tmp = fabs(x);
#line 2169
  tmp___0 = log(tmp);
#line 2169
  tmp___1 = log((double )10);
#line 2169
  tmp___2 = floor(tmp___0 / tmp___1);
#line 2169
  iexp = (int )tmp___2;
#line 2170
  tmp___3 = pow(10.0, (double )iexp);
#line 2170
  mnt = x / tmp___3;
  }
#line 2171
  if (mnt >= 10.0) {
    {
#line 2172
    iexp ++;
#line 2173
    tmp___4 = pow(10.0, (double )iexp);
#line 2173
    mnt = x / tmp___4;
    }
  }
#line 2175
  *e___0 = (double )iexp;
#line 2176
  return (mnt);
}
}
#line 2181 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int horizontal_log_grid(image_desc_t *im ) 
{ 
  double yloglab[6][10] ;
  int i ;
  int j ;
  int val_exp ;
  int min_exp ;
  double nex ;
  double logscale ;
  int exfrac ;
  int mid ;
  double mspac ;
  int flab ;
  double value ;
  double tmp ;
  double pre_value ;
  double X0 ;
  double X1 ;
  double Y0 ;
  char graph_label[100] ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int scale ;
  double pvalue ;
  char symbol ;
  double tmp___6 ;
  char graph_label_right[100] ;
  double sval ;
  double mfac ;
  char *symb ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  void *__cil_tmp40 ;
  int __cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
#line 2185
  yloglab[0][0] = 1.0;
#line 2185
  yloglab[0][1] = 10.;
#line 2185
  yloglab[0][2] = 0.0;
#line 2185
  yloglab[0][3] = 0.0;
#line 2185
  yloglab[0][4] = 0.0;
#line 2185
  yloglab[0][5] = 0.0;
#line 2185
  yloglab[0][6] = 0.0;
#line 2185
  yloglab[0][7] = 0.0;
#line 2185
  yloglab[0][8] = 0.0;
#line 2185
  yloglab[0][9] = 0.0;
#line 2185
  yloglab[1][0] = 1.0;
#line 2185
  yloglab[1][1] = 5.0;
#line 2185
  yloglab[1][2] = 10.;
#line 2185
  yloglab[1][3] = 0.0;
#line 2185
  yloglab[1][4] = 0.0;
#line 2185
  yloglab[1][5] = 0.0;
#line 2185
  yloglab[1][6] = 0.0;
#line 2185
  yloglab[1][7] = 0.0;
#line 2185
  yloglab[1][8] = 0.0;
#line 2185
  yloglab[1][9] = 0.0;
#line 2185
  yloglab[2][0] = 1.0;
#line 2185
  yloglab[2][1] = 2.0;
#line 2185
  yloglab[2][2] = 5.0;
#line 2185
  yloglab[2][3] = 7.0;
#line 2185
  yloglab[2][4] = 10.;
#line 2185
  yloglab[2][5] = 0.0;
#line 2185
  yloglab[2][6] = 0.0;
#line 2185
  yloglab[2][7] = 0.0;
#line 2185
  yloglab[2][8] = 0.0;
#line 2185
  yloglab[2][9] = 0.0;
#line 2185
  yloglab[3][0] = 1.0;
#line 2185
  yloglab[3][1] = 2.0;
#line 2185
  yloglab[3][2] = 4.0;
#line 2185
  yloglab[3][3] = 6.0;
#line 2185
  yloglab[3][4] = 8.0;
#line 2185
  yloglab[3][5] = 10.;
#line 2185
  yloglab[3][6] = 0.0;
#line 2185
  yloglab[3][7] = 0.0;
#line 2185
  yloglab[3][8] = 0.0;
#line 2185
  yloglab[3][9] = 0.0;
#line 2185
  yloglab[4][0] = 1.0;
#line 2185
  yloglab[4][1] = 2.0;
#line 2185
  yloglab[4][2] = 3.0;
#line 2185
  yloglab[4][3] = 4.0;
#line 2185
  yloglab[4][4] = 5.0;
#line 2185
  yloglab[4][5] = 6.0;
#line 2185
  yloglab[4][6] = 7.0;
#line 2185
  yloglab[4][7] = 8.0;
#line 2185
  yloglab[4][8] = 9.0;
#line 2185
  yloglab[4][9] = 10.;
#line 2185
  yloglab[5][0] = (double )0;
#line 2185
  yloglab[5][1] = (double )0;
#line 2185
  yloglab[5][2] = (double )0;
#line 2185
  yloglab[5][3] = (double )0;
#line 2185
  yloglab[5][4] = (double )0;
#line 2185
  yloglab[5][5] = (double )0;
#line 2185
  yloglab[5][6] = (double )0;
#line 2185
  yloglab[5][7] = (double )0;
#line 2185
  yloglab[5][8] = (double )0;
#line 2185
  yloglab[5][9] = (double )0;
#line 2213
  exfrac = 1;
#line 2214
  mid = -1;
#line 2221
  nex = log10(im->maxval / im->minval);
#line 2222
  logscale = (double )im->ysize / nex;
  }
  {
#line 2224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2224
    if (! (logscale * (double )exfrac < (double )3 * im->text_prop[4].size)) {
#line 2224
      goto while_break;
    }
#line 2225
    if (exfrac == 1) {
#line 2226
      exfrac = 3;
    } else {
#line 2228
      exfrac += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2234
    mid ++;
#line 2235
    i = 0;
    {
#line 2235
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2235
      if (! (yloglab[mid][i + 1] < 10.0)) {
#line 2235
        goto while_break___1;
      }
#line 2235
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2236
    tmp___0 = log10(10.0 / yloglab[mid][i]);
#line 2236
    mspac = logscale * tmp___0;
    }
#line 2232
    if (mspac > (double )2 * im->text_prop[4].size) {
#line 2232
      if (! (yloglab[mid][0] > (double )0)) {
#line 2232
        goto while_break___0;
      }
    } else {
#line 2232
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2240
  if (mid) {
#line 2241
    mid --;
  }
#line 2243
  flab = 0;
  {
#line 2243
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2243
    if (yloglab[mid][flab] < (double )10) {
      {
#line 2243
      tmp___1 = frexp10(im->minval, & tmp);
      }
#line 2243
      if (! (tmp___1 > yloglab[mid][flab])) {
#line 2243
        goto while_break___2;
      }
    } else {
#line 2243
      goto while_break___2;
    }
#line 2243
    flab ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2246
  if (yloglab[mid][flab] == 10.0) {
#line 2247
    tmp += 1.0;
#line 2248
    flab = 0;
  }
#line 2250
  val_exp = (int )tmp;
#line 2251
  if (val_exp % exfrac) {
    {
#line 2252
    tmp___2 = abs(- val_exp % exfrac);
#line 2252
    val_exp += tmp___2;
    }
  }
  {
#line 2253
  X0 = (double )im->xorigin;
#line 2254
  X1 = (double )(im->xorigin + im->xsize);
#line 2256
  pre_value = rrd_set_to_DNAN();
  }
  {
#line 2257
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 2259
    tmp___3 = pow(10.0, (double )val_exp);
#line 2259
    value = yloglab[mid][flab] * tmp___3;
#line 2260
    tmp___4 = AlmostEqual2sComplement((float )value, (float )pre_value, 4);
    }
#line 2260
    if (tmp___4) {
#line 2261
      goto while_break___3;
    }
    {
#line 2262
    pre_value = value;
#line 2263
    Y0 = ytr(im, value);
#line 2264
    tmp___5 = floor(Y0 + 0.5);
    }
#line 2264
    if (tmp___5 <= (double )(im->yorigin - im->ysize)) {
#line 2265
      goto while_break___3;
    }
    {
#line 2267
    gfx_line(im, X0 - (double )2, Y0, X0, Y0, 0.6, im->graph_col[5]);
#line 2269
    gfx_line(im, X1, Y0, X1 + (double )2, Y0, 0.6, im->graph_col[5]);
#line 2271
    gfx_dashed_line(im, X0 - (double )2, Y0, X1 + (double )2, Y0, 0.6, im->graph_col[5],
                    im->grid_dash_on, im->grid_dash_off);
    }
#line 2278
    if (im->extra_flags & 256) {
      {
#line 2283
      tmp___6 = floor((double )val_exp / 3.0);
#line 2283
      scale = (int )tmp___6;
      }
#line 2284
      if (value >= 1.0) {
        {
#line 2285
        pvalue = pow(10.0, (double )(val_exp % 3));
        }
      } else {
        {
#line 2287
        pvalue = pow(10.0, (double )((val_exp + 1) % 3 + 2));
        }
      }
#line 2288
      pvalue *= yloglab[mid][flab];
#line 2289
      if (scale + (int )si_symbcenter < (int )sizeof(si_symbol)) {
#line 2289
        if (scale + (int )si_symbcenter >= 0) {
#line 2291
          symbol = si_symbol[scale + (int )si_symbcenter];
        } else {
#line 2293
          symbol = (char )'?';
        }
      } else {
#line 2293
        symbol = (char )'?';
      }
      {
#line 2294
      sprintf((char */* __restrict  */)(graph_label), (char const   */* __restrict  */)"%3.0f %c",
              pvalue, (int )symbol);
      }
    } else {
      {
#line 2296
      sprintf((char */* __restrict  */)(graph_label), (char const   */* __restrict  */)"%3.0e",
              value);
      }
    }
#line 2298
    if (im->second_axis_scale != (double )0) {
#line 2300
      sval = value * im->second_axis_scale + im->second_axis_shift;
#line 2301
      if ((int )im->second_axis_format[0] == 0) {
#line 2302
        if (im->extra_flags & 256) {
          {
#line 2303
          mfac = (double )1;
#line 2304
          symb = (char *)"";
#line 2305
          auto_scale(im, & sval, & symb, & mfac);
#line 2306
          sprintf((char */* __restrict  */)(graph_label_right), (char const   */* __restrict  */)"%4.0f %s",
                  sval, symb);
          }
        } else {
          {
#line 2309
          sprintf((char */* __restrict  */)(graph_label_right), (char const   */* __restrict  */)"%3.0e",
                  sval);
          }
        }
      } else {
        {
#line 2313
        sprintf((char */* __restrict  */)(graph_label_right), (char const   */* __restrict  */)(im->second_axis_format),
                sval, "");
        }
      }
      {
#line 2316
      gfx_text(im, X1 + (double )7, Y0, im->graph_col[6], im->text_prop[2].font_desc,
               im->tabwidth, 0.0, (enum gfx_h_align_en )1, (enum gfx_v_align_en )3,
               (char const   *)(graph_label_right));
      }
    }
    {
#line 2324
    gfx_text(im, X0 - im->text_prop[2].size, Y0, im->graph_col[6], im->text_prop[2].font_desc,
             im->tabwidth, 0.0, (enum gfx_h_align_en )2, (enum gfx_v_align_en )3,
             (char const   *)(graph_label));
    }
#line 2336
    if (mid < 4) {
#line 2336
      if (exfrac == 1) {
#line 2339
        if (flab == 0) {
#line 2340
          min_exp = val_exp - 1;
#line 2341
          i = 1;
          {
#line 2341
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 2341
            if (! (yloglab[mid][i] < 10.0)) {
#line 2341
              goto while_break___4;
            }
#line 2341
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 2342
          i = (int )(yloglab[mid][i - 1] + (double )1);
#line 2343
          j = 10;
        } else {
#line 2345
          min_exp = val_exp;
#line 2346
          i = (int )(yloglab[mid][flab - 1] + (double )1);
#line 2347
          j = (int )yloglab[mid][flab];
        }
        {
#line 2351
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2351
          if (! (i < j)) {
#line 2351
            goto while_break___5;
          }
          {
#line 2353
          tmp___7 = pow(10.0, (double )min_exp);
#line 2353
          value = (double )i * tmp___7;
          }
#line 2354
          if (value < im->minval) {
#line 2355
            goto __Cont;
          }
          {
#line 2356
          Y0 = ytr(im, value);
#line 2357
          tmp___8 = floor(Y0 + 0.5);
          }
#line 2357
          if (tmp___8 <= (double )(im->yorigin - im->ysize)) {
#line 2358
            goto while_break___5;
          }
          {
#line 2360
          gfx_line(im, X0 - (double )2, Y0, X0, Y0, 0.4, im->graph_col[4]);
#line 2363
          gfx_line(im, X1, Y0, X1 + (double )2, Y0, 0.4, im->graph_col[4]);
#line 2365
          gfx_dashed_line(im, X0 - (double )1, Y0, X1 + (double )1, Y0, 0.4, im->graph_col[4],
                          im->grid_dash_on, im->grid_dash_off);
          }
          __Cont: /* CIL Label */ 
#line 2351
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 2336
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2372
    if (exfrac > 1) {
#line 2373
      i = val_exp - (exfrac / 3) * 2;
      {
#line 2373
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2373
        if (! (i < val_exp)) {
#line 2373
          goto while_break___6;
        }
        {
#line 2374
        value = pow(10.0, (double )i);
        }
#line 2375
        if (value < im->minval) {
#line 2376
          goto __Cont___0;
        }
        {
#line 2377
        Y0 = ytr(im, value);
#line 2378
        tmp___9 = floor(Y0 + 0.5);
        }
#line 2378
        if (tmp___9 <= (double )(im->yorigin - im->ysize)) {
#line 2379
          goto while_break___6;
        }
        {
#line 2381
        gfx_line(im, X0 - (double )2, Y0, X0, Y0, 0.4, im->graph_col[4]);
#line 2384
        gfx_line(im, X1, Y0, X1 + (double )2, Y0, 0.4, im->graph_col[4]);
#line 2386
        gfx_dashed_line(im, X0 - (double )1, Y0, X1 + (double )1, Y0, 0.4, im->graph_col[4],
                        im->grid_dash_on, im->grid_dash_off);
        }
        __Cont___0: /* CIL Label */ 
#line 2373
        i += exfrac / 3;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 2396
    flab ++;
#line 2396
    if (yloglab[mid][flab] == 10.0) {
#line 2397
      flab = 0;
#line 2398
      val_exp += exfrac;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2403
  if (mid < 4) {
#line 2403
    if (exfrac == 1) {
#line 2406
      if (flab == 0) {
#line 2407
        min_exp = val_exp - 1;
#line 2408
        i = 1;
        {
#line 2408
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2408
          if (! (yloglab[mid][i] < 10.0)) {
#line 2408
            goto while_break___7;
          }
#line 2408
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 2409
        i = (int )(yloglab[mid][i - 1] + (double )1);
#line 2410
        j = 10;
      } else {
#line 2412
        min_exp = val_exp;
#line 2413
        i = (int )(yloglab[mid][flab - 1] + (double )1);
#line 2414
        j = (int )yloglab[mid][flab];
      }
      {
#line 2418
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2418
        if (! (i < j)) {
#line 2418
          goto while_break___8;
        }
        {
#line 2420
        tmp___10 = pow(10.0, (double )min_exp);
#line 2420
        value = (double )i * tmp___10;
        }
#line 2421
        if (value < im->minval) {
#line 2422
          goto __Cont___1;
        }
        {
#line 2423
        Y0 = ytr(im, value);
#line 2424
        tmp___11 = floor(Y0 + 0.5);
        }
#line 2424
        if (tmp___11 <= (double )(im->yorigin - im->ysize)) {
#line 2425
          goto while_break___8;
        }
        {
#line 2427
        gfx_line(im, X0 - (double )2, Y0, X0, Y0, 0.4, im->graph_col[4]);
#line 2429
        gfx_line(im, X1, Y0, X1 + (double )2, Y0, 0.4, im->graph_col[4]);
#line 2431
        gfx_dashed_line(im, X0 - (double )1, Y0, X1 + (double )1, Y0, 0.4, im->graph_col[4],
                        im->grid_dash_on, im->grid_dash_off);
        }
        __Cont___1: /* CIL Label */ 
#line 2418
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else {
#line 2403
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2440
  if (exfrac > 1) {
#line 2441
    i = val_exp - (exfrac / 3) * 2;
    {
#line 2441
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2441
      if (! (i < val_exp)) {
#line 2441
        goto while_break___9;
      }
      {
#line 2442
      value = pow(10.0, (double )i);
      }
#line 2443
      if (value < im->minval) {
#line 2444
        goto __Cont___2;
      }
      {
#line 2445
      Y0 = ytr(im, value);
#line 2446
      tmp___12 = floor(Y0 + 0.5);
      }
#line 2446
      if (tmp___12 <= (double )(im->yorigin - im->ysize)) {
#line 2447
        goto while_break___9;
      }
      {
#line 2449
      gfx_line(im, X0 - (double )2, Y0, X0, Y0, 0.4, im->graph_col[4]);
#line 2451
      gfx_line(im, X1, Y0, X1 + (double )2, Y0, 0.4, im->graph_col[4]);
#line 2453
      gfx_dashed_line(im, X0 - (double )1, Y0, X1 + (double )1, Y0, 0.4, im->graph_col[4],
                      im->grid_dash_on, im->grid_dash_off);
      }
      __Cont___2: /* CIL Label */ 
#line 2441
      i += exfrac / 3;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 2462
  return (1);
}
}
#line 2466 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void vertical_grid(image_desc_t *im ) 
{ 
  int xlab_sel ;
  time_t ti ;
  time_t tilab ;
  time_t timajor ;
  long factor ;
  char graph_label[100] ;
  double X0 ;
  double Y0 ;
  double Y1 ;
  struct tm tm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp15 ;

  {
#line 2478
  if (im->xlab_user.minsec == -1L) {
#line 2479
    factor = (im->end - im->start) / im->xsize;
#line 2480
    xlab_sel = 0;
    {
#line 2481
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2481
      if (xlab[xlab_sel + 1].minsec != -1L) {
#line 2481
        if (! (xlab[xlab_sel + 1].minsec <= factor)) {
#line 2481
          goto while_break;
        }
      } else {
#line 2481
        goto while_break;
      }
#line 2483
      xlab_sel ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2485
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2485
      if (xlab[xlab_sel - 1].minsec == xlab[xlab_sel].minsec) {
#line 2485
        if (! (xlab[xlab_sel].length > im->end - im->start)) {
#line 2485
          goto while_break___0;
        }
      } else {
#line 2485
        goto while_break___0;
      }
#line 2488
      xlab_sel --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2490
    im->xlab_user.gridtm = xlab[xlab_sel].gridtm;
#line 2491
    im->xlab_user.gridst = xlab[xlab_sel].gridst;
#line 2492
    im->xlab_user.mgridtm = xlab[xlab_sel].mgridtm;
#line 2493
    im->xlab_user.mgridst = xlab[xlab_sel].mgridst;
#line 2494
    im->xlab_user.labtm = xlab[xlab_sel].labtm;
#line 2495
    im->xlab_user.labst = xlab[xlab_sel].labst;
#line 2496
    im->xlab_user.precis = xlab[xlab_sel].precis;
#line 2497
    im->xlab_user.stst = xlab[xlab_sel].stst;
  }
#line 2501
  Y0 = (double )im->yorigin;
#line 2502
  Y1 = (double )(im->yorigin - im->ysize);
#line 2504
  if (! (im->extra_flags & 32)) {
    {
#line 2505
    ti = find_first_time(im->start, im->xlab_user.gridtm, im->xlab_user.gridst);
#line 2505
    timajor = find_first_time(im->start, im->xlab_user.mgridtm, im->xlab_user.mgridst);
    }
    {
#line 2505
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2505
      if (ti < im->end) {
#line 2505
        if (! (ti != -1L)) {
#line 2505
          goto while_break___1;
        }
      } else {
#line 2505
        goto while_break___1;
      }
#line 2523
      if (ti < im->start) {
#line 2524
        goto __Cont;
      } else
#line 2523
      if (ti > im->end) {
#line 2524
        goto __Cont;
      }
      {
#line 2525
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2525
        if (timajor < ti) {
#line 2525
          if (! (timajor != -1L)) {
#line 2525
            goto while_break___2;
          }
        } else {
#line 2525
          goto while_break___2;
        }
        {
#line 2526
        timajor = find_next_time(timajor, im->xlab_user.mgridtm, im->xlab_user.mgridst);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2531
      if (timajor == -1L) {
#line 2531
        goto while_break___1;
      }
#line 2532
      if (ti == timajor) {
#line 2533
        goto __Cont;
      }
      {
#line 2534
      tmp = xtr(im, ti);
#line 2534
      X0 = (double )tmp;
#line 2535
      gfx_line(im, X0, Y1 - (double )2, X0, Y1, 0.4, im->graph_col[4]);
#line 2537
      gfx_line(im, X0, Y0, X0, Y0 + (double )2, 0.4, im->graph_col[4]);
#line 2539
      gfx_dashed_line(im, X0, Y0 + (double )1, X0, Y1 - (double )1, 0.4, im->graph_col[4],
                      im->grid_dash_on, im->grid_dash_off);
      }
      __Cont: /* CIL Label */ 
      {
#line 2505
      ti = find_next_time(ti, im->xlab_user.gridtm, im->xlab_user.gridst);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 2548
  ti = find_first_time(im->start, im->xlab_user.mgridtm, im->xlab_user.mgridst);
  }
  {
#line 2548
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2548
    if (ti < im->end) {
#line 2548
      if (! (ti != -1L)) {
#line 2548
        goto while_break___3;
      }
    } else {
#line 2548
      goto while_break___3;
    }
#line 2559
    if (ti < im->start) {
#line 2560
      goto __Cont___0;
    } else
#line 2559
    if (ti > im->end) {
#line 2560
      goto __Cont___0;
    }
    {
#line 2561
    tmp___0 = xtr(im, ti);
#line 2561
    X0 = (double )tmp___0;
#line 2562
    gfx_line(im, X0, Y1 - (double )2, X0, Y1, 0.6, im->graph_col[5]);
#line 2564
    gfx_line(im, X0, Y0, X0, Y0 + (double )3, 0.6, im->graph_col[5]);
#line 2566
    gfx_dashed_line(im, X0, Y0 + (double )3, X0, Y1 - (double )2, 0.6, im->graph_col[5],
                    im->grid_dash_on, im->grid_dash_off);
    }
    __Cont___0: /* CIL Label */ 
    {
#line 2548
    ti = find_next_time(ti, im->xlab_user.mgridtm, im->xlab_user.mgridst);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2573
  ti = find_first_time(im->start - im->xlab_user.precis / 2L, im->xlab_user.labtm,
                       im->xlab_user.labst);
  }
  {
#line 2573
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2573
    if (ti <= im->end - im->xlab_user.precis / 2L) {
#line 2573
      if (! (ti != -1L)) {
#line 2573
        goto while_break___4;
      }
    } else {
#line 2573
      goto while_break___4;
    }
#line 2586
    tilab = ti + im->xlab_user.precis / 2L;
#line 2588
    if (tilab < im->start) {
#line 2589
      goto __Cont___1;
    } else
#line 2588
    if (tilab > im->end) {
#line 2589
      goto __Cont___1;
    }
    {
#line 2591
    localtime_r((time_t const   */* __restrict  */)(& tilab), (struct tm */* __restrict  */)(& tm));
#line 2592
    strftime((char */* __restrict  */)(graph_label), (size_t )99, (char const   */* __restrict  */)im->xlab_user.stst,
             (struct tm  const  */* __restrict  */)(& tm));
#line 2596
    tmp___1 = xtr(im, tilab);
#line 2596
    gfx_text(im, (double )tmp___1, Y0 + (double )3, im->graph_col[6], im->text_prop[2].font_desc,
             im->tabwidth, 0.0, (enum gfx_h_align_en )3, (enum gfx_v_align_en )1,
             (char const   *)(graph_label));
    }
    __Cont___1: /* CIL Label */ 
    {
#line 2573
    ti = find_next_time(ti, im->xlab_user.labtm, im->xlab_user.labst);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2607
  return;
}
}
#line 2610 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void axis_paint(image_desc_t *im ) 
{ 


  {
  {
#line 2622
  gfx_line(im, (double )(im->xorigin - 4L), (double )im->yorigin, (double )((im->xorigin + im->xsize) + 4L),
           (double )im->yorigin, 0.6, im->graph_col[8]);
#line 2626
  gfx_line(im, (double )im->xorigin, (double )(im->yorigin + 4L), (double )im->xorigin,
           (double )((im->yorigin - im->ysize) - 4L), 0.6, im->graph_col[8]);
#line 2632
  gfx_new_area(im, (double )((im->xorigin + im->xsize) + 2L), (double )(im->yorigin - 3L),
               (double )((im->xorigin + im->xsize) + 2L), (double )(im->yorigin + 3L),
               (double )((im->xorigin + im->xsize) + 7L), (double )im->yorigin, im->graph_col[7]);
#line 2634
  gfx_close_path(im);
#line 2635
  gfx_new_area(im, (double )(im->xorigin - 3L), (double )((im->yorigin - im->ysize) - 2L),
               (double )(im->xorigin + 3L), (double )((im->yorigin - im->ysize) - 2L),
               (double )im->xorigin, (double )((im->yorigin - im->ysize) - 7L), im->graph_col[7]);
#line 2637
  gfx_close_path(im);
  }
#line 2638
  if (im->second_axis_scale != (double )0) {
    {
#line 2639
    gfx_line(im, (double )(im->xorigin + im->xsize), (double )(im->yorigin + 4L),
             (double )(im->xorigin + im->xsize), (double )((im->yorigin - im->ysize) - 4L),
             0.6, im->graph_col[8]);
#line 2642
    gfx_new_area(im, (double )((im->xorigin + im->xsize) - 2L), (double )((im->yorigin - im->ysize) - 2L),
                 (double )((im->xorigin + im->xsize) + 3L), (double )((im->yorigin - im->ysize) - 2L),
                 (double )(im->xorigin + im->xsize), (double )((im->yorigin - im->ysize) - 7L),
                 im->graph_col[7]);
#line 2647
    gfx_close_path(im);
    }
  }
#line 2650
  return;
}
}
#line 2652 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void grid_paint(image_desc_t *im ) 
{ 
  long i ;
  int res ;
  double X0 ;
  double Y0 ;
  struct gfx_color_t water_color ;
  char *nodata ;
  double xpos ;
  long tmp ;
  double boxH ;
  double boxV ;
  double X1 ;
  double Y1 ;
  double tmp___0 ;
  double dashes[1] ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 2656
  res = 0;
#line 2660
  if (im->draw_3d_border > 0U) {
    {
#line 2662
    i = (long )im->draw_3d_border;
#line 2663
    gfx_new_area(im, (double )0, (double )im->yimg, (double )i, (double )(im->yimg - i),
                 (double )i, (double )i, im->graph_col[2]);
#line 2665
    gfx_add_point(im, (double )(im->ximg - i), (double )i);
#line 2666
    gfx_add_point(im, (double )im->ximg, (double )0);
#line 2667
    gfx_add_point(im, (double )0, (double )0);
#line 2668
    gfx_close_path(im);
#line 2669
    gfx_new_area(im, (double )i, (double )(im->yimg - i), (double )(im->ximg - i),
                 (double )(im->yimg - i), (double )(im->ximg - i), (double )i, im->graph_col[3]);
#line 2672
    gfx_add_point(im, (double )im->ximg, (double )0);
#line 2673
    gfx_add_point(im, (double )im->ximg, (double )im->yimg);
#line 2674
    gfx_add_point(im, (double )0, (double )im->yimg);
#line 2675
    gfx_close_path(im);
    }
  }
#line 2677
  if (im->draw_x_grid == 1) {
    {
#line 2678
    vertical_grid(im);
    }
  }
#line 2679
  if (im->draw_y_grid == 1) {
#line 2680
    if (im->logarithmic) {
      {
#line 2681
      res = horizontal_log_grid(im);
      }
    } else {
      {
#line 2683
      res = draw_horizontal_grid(im);
      }
    }
#line 2687
    if (! res) {
      {
#line 2688
      nodata = (char *)"No Data found";
#line 2690
      gfx_text(im, (double )(im->ximg / 2L), (double )((2L * im->yorigin - im->ysize) / 2L),
               im->graph_col[6], im->text_prop[2].font_desc, im->tabwidth, 0.0, (enum gfx_h_align_en )3,
               (enum gfx_v_align_en )3, (char const   *)nodata);
      }
    }
  }
#line 2703
  if ((int )im->ylegend[0] != 0) {
    {
#line 2704
    gfx_text(im, (double )(im->xOriginLegendY + 10L), (double )im->yOriginLegendY,
             im->graph_col[6], im->text_prop[3].font_desc, im->tabwidth, 90.0, (enum gfx_h_align_en )3,
             (enum gfx_v_align_en )3, (char const   *)(im->ylegend));
    }
  }
#line 2715
  if ((int )im->second_axis_legend[0] != 0) {
    {
#line 2716
    gfx_text(im, (double )(im->xOriginLegendY2 + 10L), (double )im->yOriginLegendY2,
             im->graph_col[6], im->text_prop[3].font_desc, im->tabwidth, 90.0, (enum gfx_h_align_en )3,
             (enum gfx_v_align_en )3, (char const   *)(im->second_axis_legend));
    }
  }
  {
#line 2728
  gfx_text(im, (double )im->xOriginTitle, (double )(im->yOriginTitle + 6L), im->graph_col[6],
           im->text_prop[1].font_desc, im->tabwidth, 0.0, (enum gfx_h_align_en )3,
           (enum gfx_v_align_en )1, (char const   *)(im->title));
  }
#line 2736
  if (! (im->extra_flags & 1024)) {
#line 2737
    water_color = im->graph_col[6];
#line 2738
    water_color.alpha = 0.3;
#line 2739
    if ((unsigned int )im->legendposition == 3U) {
#line 2739
      tmp = im->xOriginLegendY;
    } else {
#line 2739
      tmp = im->ximg - 4L;
    }
    {
#line 2739
    xpos = (double )tmp;
#line 2740
    gfx_text(im, xpos, (double )5, water_color, im->text_prop[5].font_desc, im->tabwidth,
             (double )-90, (enum gfx_h_align_en )1, (enum gfx_v_align_en )1, "RRDTOOL / TOBI OETIKER");
    }
  }
#line 2748
  if ((int )im->watermark[0] != 0) {
    {
#line 2749
    water_color = im->graph_col[6];
#line 2750
    water_color.alpha = 0.3;
#line 2751
    gfx_text(im, (double )(im->ximg / 2L), (double )(im->yimg - 6L), water_color,
             im->text_prop[5].font_desc, im->tabwidth, (double )0, (enum gfx_h_align_en )3,
             (enum gfx_v_align_en )2, (char const   *)(im->watermark));
    }
  }
#line 2761
  if (! (im->extra_flags & 16)) {
#line 2761
    if (! (im->extra_flags & 64)) {
#line 2762
      i = 0L;
      {
#line 2762
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2762
        if (! (i < im->gdes_c)) {
#line 2762
          goto while_break;
        }
#line 2763
        if ((int )(im->gdes + i)->legend[0] == 0) {
#line 2764
          goto __Cont;
        }
#line 2766
        X0 = (double )im->xOriginLegend + (im->gdes + i)->leg_x;
#line 2767
        if ((unsigned int )im->legenddirection == 0U) {
#line 2767
          Y0 = (double )im->yOriginLegend + (im->gdes + i)->leg_y;
        } else {
#line 2767
          Y0 = (double )(im->yOriginLegend + im->legendheight) - (im->gdes + i)->leg_y;
        }
        {
#line 2768
        gfx_text(im, X0, Y0, im->graph_col[6], im->text_prop[4].font_desc, im->tabwidth,
                 0.0, (enum gfx_h_align_en )1, (enum gfx_v_align_en )2, (char const   *)((im->gdes + i)->legend));
        }
#line 2777
        if ((unsigned int )(im->gdes + i)->gf != 0U) {
#line 2777
          if ((unsigned int )(im->gdes + i)->gf != 1U) {
#line 2777
            if ((unsigned int )(im->gdes + i)->gf != 2U) {
              {
#line 2782
              tmp___0 = gfx_get_text_width(im, (double )0, im->text_prop[4].font_desc,
                                           im->tabwidth, (char *)"o");
#line 2782
              boxH = tmp___0 * 1.2;
#line 2788
              boxV = boxH;
#line 2790
              Y0 -= boxV * 0.4;
              }
#line 2792
              if (im->dynamic_labels) {
#line 2792
                if ((unsigned int )(im->gdes + i)->gf == 3U) {
                  {
#line 2793
                  cairo_save(im->cr);
#line 2794
                  cairo_new_path(im->cr);
#line 2795
                  cairo_set_line_width(im->cr, 1.0);
#line 2796
                  gfx_line(im, X0, Y0 - boxV / (double )2, X0 + boxH, Y0 - boxV / (double )2,
                           1.0, (im->gdes + i)->col);
#line 2800
                  gfx_close_path(im);
                  }
                } else {
#line 2792
                  goto _L___1;
                }
              } else
              _L___1: /* CIL Label */ 
#line 2801
              if (im->dynamic_labels) {
#line 2801
                if ((unsigned int )(im->gdes + i)->gf == 4U) {
                  {
#line 2802
                  cairo_save(im->cr);
#line 2803
                  cairo_new_path(im->cr);
#line 2804
                  cairo_set_line_width(im->cr, 1.0);
#line 2805
                  gfx_line(im, X0 + boxH / (double )2, Y0, X0 + boxH / (double )2,
                           Y0 - boxV, 1.0, (im->gdes + i)->col);
#line 2809
                  gfx_close_path(im);
                  }
                } else {
#line 2801
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 2810
              if (im->dynamic_labels) {
#line 2810
                if ((unsigned int )(im->gdes + i)->gf == 5U) {
                  {
#line 2811
                  cairo_save(im->cr);
#line 2812
                  cairo_new_path(im->cr);
#line 2813
                  cairo_set_line_width(im->cr, (im->gdes + i)->linewidth);
#line 2814
                  gfx_line(im, X0, Y0, X0 + boxH, Y0 - boxV, (im->gdes + i)->linewidth,
                           (im->gdes + i)->col);
#line 2818
                  gfx_close_path(im);
                  }
                } else {
#line 2810
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
                {
#line 2821
                gfx_new_area(im, X0, Y0 - boxV, X0, Y0, X0 + boxH, Y0, im->graph_col[1]);
#line 2824
                gfx_add_point(im, X0 + boxH, Y0 - boxV);
#line 2825
                gfx_close_path(im);
#line 2826
                gfx_new_area(im, X0, Y0 - boxV, X0, Y0, X0 + boxH, Y0, (im->gdes + i)->col);
#line 2828
                gfx_add_point(im, X0 + boxH, Y0 - boxV);
#line 2829
                gfx_close_path(im);
#line 2830
                cairo_save(im->cr);
#line 2831
                cairo_new_path(im->cr);
#line 2832
                cairo_set_line_width(im->cr, 1.0);
#line 2833
                X1 = X0 + boxH;
#line 2834
                Y1 = Y0 - boxV;
#line 2835
                gfx_line_fit(im, & X0, & Y0);
#line 2836
                gfx_line_fit(im, & X1, & Y1);
#line 2837
                cairo_move_to(im->cr, X0, Y0);
#line 2838
                cairo_line_to(im->cr, X1, Y0);
#line 2839
                cairo_line_to(im->cr, X1, Y1);
#line 2840
                cairo_line_to(im->cr, X0, Y1);
#line 2841
                cairo_close_path(im->cr);
#line 2842
                cairo_set_source_rgba(im->cr, im->graph_col[9].red, im->graph_col[9].green,
                                      im->graph_col[9].blue, im->graph_col[9].alpha);
                }
              }
#line 2848
              if ((im->gdes + i)->dash) {
                {
#line 2850
                dashes[0] = 3.0;
#line 2853
                cairo_set_dash(im->cr, (double const   *)(dashes), 1, 0.0);
                }
              }
              {
#line 2855
              cairo_stroke(im->cr);
#line 2856
              cairo_restore(im->cr);
              }
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 2762
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2860
  return;
}
}
#line 2867 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int lazy_check(image_desc_t *im ) 
{ 
  FILE *fd ;
  int size ;
  struct stat imgstat ;
  size_t tmp ;
  int tmp___0 ;
  time_t tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 2870
  fd = (FILE *)((void *)0);
#line 2871
  size = 1;
#line 2874
  if (im->lazy == 0) {
#line 2875
    return (0);
  }
  {
#line 2876
  tmp = strlen((char const   *)(im->graphfile));
  }
#line 2876
  if (tmp == 0UL) {
#line 2877
    return (0);
  }
  {
#line 2878
  tmp___0 = stat((char const   */* __restrict  */)(im->graphfile), (struct stat */* __restrict  */)(& imgstat));
  }
#line 2878
  if (tmp___0 != 0) {
#line 2879
    return (0);
  }
  {
#line 2882
  tmp___1 = time((time_t *)((void *)0));
  }
#line 2882
  if (tmp___1 - imgstat.st_mtim.tv_sec > (im->end - im->start) / im->xsize) {
#line 2883
    return (0);
  }
  {
#line 2884
  fd = fopen((char const   */* __restrict  */)(im->graphfile), (char const   */* __restrict  */)"rb");
  }
#line 2884
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 2885
    return (0);
  }
  {
#line 2887
  if ((unsigned int )im->imgformat == 0U) {
#line 2887
    goto case_0;
  }
#line 2890
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 2888
  size = PngSize(fd, & im->ximg, & im->yimg);
  }
#line 2889
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2891
  size = 1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2893
  fclose(fd);
  }
#line 2894
  return (size);
}
}
#line 2898 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int graph_size_location(image_desc_t *im , int elements ) 
{ 
  int Xvertical ;
  int Xvertical2 ;
  int Ytitle ;
  int Xylabel ;
  int Xmain ;
  int Ymain ;
  int Yxlabel ;
  int Xspacing ;
  int Yspacing ;
  int Ywatermark ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 2932
  Xvertical = 0;
#line 2932
  Xvertical2 = 0;
#line 2932
  Ytitle = 0;
#line 2932
  Xylabel = 0;
#line 2932
  Xmain = 0;
#line 2932
  Ymain = 0;
#line 2932
  Yxlabel = 0;
#line 2932
  Xspacing = 15;
#line 2932
  Yspacing = 15;
#line 2932
  Ywatermark = 4;
#line 2937
  if (im->extra_flags & 64) {
    {
#line 2938
    im->xorigin = 0L;
#line 2939
    im->ximg = im->xsize;
#line 2940
    im->yimg = im->ysize;
#line 2941
    im->yorigin = im->ysize;
#line 2942
    xtr(im, (time_t )0);
#line 2943
    tmp = rrd_set_to_DNAN();
#line 2943
    ytr(im, tmp);
    }
#line 2944
    return (0);
  }
#line 2947
  if ((int )im->watermark[0] != 0) {
#line 2948
    Ywatermark = (int )(im->text_prop[5].size * (double )2);
  }
#line 2952
  if ((int )im->ylegend[0] != 0) {
#line 2953
    Xvertical = (int )(im->text_prop[3].size * (double )2);
  }
#line 2957
  if ((int )im->second_axis_legend[0] != 0) {
#line 2958
    Xvertical2 = (int )(im->text_prop[3].size * (double )2);
  } else {
#line 2961
    Xvertical2 = Xspacing;
  }
#line 2964
  if ((int )im->title[0] != 0) {
#line 2970
    Ytitle = (int )(im->text_prop[1].size * 2.6 + (double )10);
  } else {
#line 2974
    Ytitle = Yspacing;
  }
#line 2977
  if (elements) {
#line 2978
    if (im->draw_x_grid) {
#line 2980
      Yxlabel = (int )(im->text_prop[2].size * 2.5);
    }
#line 2982
    if (im->draw_y_grid) {
      {
#line 2984
      tmp___0 = gfx_get_text_width(im, (double )0, im->text_prop[2].font_desc, im->tabwidth,
                                   (char *)"0");
#line 2984
      Xylabel = (int )(tmp___0 * (double )im->unitslength);
      }
    } else
#line 2982
    if (im->forceleftspace) {
      {
#line 2984
      tmp___0 = gfx_get_text_width(im, (double )0, im->text_prop[2].font_desc, im->tabwidth,
                                   (char *)"0");
#line 2984
      Xylabel = (int )(tmp___0 * (double )im->unitslength);
      }
    }
  }
#line 2992
  Xylabel += Xspacing;
#line 2999
  im->legendheight = 0L;
#line 3000
  im->legendwidth = 0L;
#line 3001
  if (! (im->extra_flags & 16)) {
#line 3002
    if ((unsigned int )im->legendposition == 1U) {
#line 3002
      goto _L;
    } else
#line 3002
    if ((unsigned int )im->legendposition == 3U) {
      _L: /* CIL Label */ 
      {
#line 3003
      tmp___1 = leg_place(im, 1);
      }
#line 3003
      if (tmp___1 == -1) {
#line 3004
        return (-1);
      }
    }
  }
#line 3009
  if (im->extra_flags & 512) {
#line 3015
    im->ximg = im->xsize;
#line 3016
    im->yimg = im->ysize;
#line 3017
    Xmain = (int )im->ximg;
#line 3018
    Ymain = (int )im->yimg;
#line 3027
    Xmain -= Xylabel;
#line 3028
    if ((unsigned int )im->legendposition == 1U) {
#line 3028
      goto _L___0;
    } else
#line 3028
    if ((unsigned int )im->legendposition == 3U) {
      _L___0: /* CIL Label */ 
#line 3028
      if (! (im->extra_flags & 16)) {
#line 3029
        Xmain = (int )((long )Xmain - im->legendwidth);
      }
    }
#line 3031
    if (im->second_axis_scale != (double )0) {
#line 3032
      Xmain -= Xylabel;
    }
#line 3034
    if (! (im->extra_flags & 1024)) {
#line 3035
      Xmain -= Xspacing;
    }
#line 3038
    Xmain -= Xvertical + Xvertical2;
#line 3041
    if (Xmain < 1) {
#line 3042
      Xmain = 1;
    }
#line 3044
    im->xsize = (long )Xmain;
#line 3047
    if (! (im->extra_flags & 16)) {
#line 3048
      if ((unsigned int )im->legendposition == 0U) {
#line 3048
        goto _L___1;
      } else
#line 3048
      if ((unsigned int )im->legendposition == 2U) {
        _L___1: /* CIL Label */ 
        {
#line 3049
        im->legendwidth = im->ximg;
#line 3050
        tmp___2 = leg_place(im, 0);
        }
#line 3050
        if (tmp___2 == -1) {
#line 3051
          return (-1);
        }
      }
    }
#line 3056
    if ((unsigned int )im->legendposition == 0U) {
#line 3056
      goto _L___2;
    } else
#line 3056
    if ((unsigned int )im->legendposition == 2U) {
      _L___2: /* CIL Label */ 
#line 3056
      if (! (im->extra_flags & 16)) {
#line 3057
        Ymain = (int )((long )Ymain - ((long )Yxlabel + im->legendheight));
      } else {
#line 3060
        Ymain -= Yxlabel;
      }
    } else {
#line 3060
      Ymain -= Yxlabel;
    }
#line 3064
    Ymain -= Ytitle;
#line 3067
    if (im->extra_flags & 16) {
#line 3068
      Ymain = (int )((double )Ymain - 0.5 * (double )Yspacing);
    }
#line 3071
    if ((int )im->watermark[0] != 0) {
#line 3072
      Ymain -= Ywatermark;
    }
#line 3075
    if (Ymain < 1) {
#line 3076
      Ymain = 1;
    }
#line 3078
    im->ysize = (long )Ymain;
  } else {
#line 3087
    if (elements) {
#line 3088
      Xmain = (int )im->xsize;
#line 3089
      Ymain = (int )im->ysize;
    }
#line 3092
    im->ximg = (long )(Xmain + Xylabel);
#line 3093
    if (! (im->extra_flags & 1024)) {
#line 3094
      im->ximg += (long )Xspacing;
    }
#line 3097
    if ((unsigned int )im->legendposition == 1U) {
#line 3097
      goto _L___3;
    } else
#line 3097
    if ((unsigned int )im->legendposition == 3U) {
      _L___3: /* CIL Label */ 
#line 3097
      if (! (im->extra_flags & 16)) {
#line 3098
        im->ximg += im->legendwidth;
      }
    }
#line 3100
    if (im->second_axis_scale != (double )0) {
#line 3101
      im->ximg += (long )Xylabel;
    }
#line 3104
    im->ximg += (long )(Xvertical + Xvertical2);
#line 3106
    if (! (im->extra_flags & 16)) {
#line 3107
      if ((unsigned int )im->legendposition == 0U) {
#line 3107
        goto _L___4;
      } else
#line 3107
      if ((unsigned int )im->legendposition == 2U) {
        _L___4: /* CIL Label */ 
        {
#line 3108
        im->legendwidth = im->ximg;
#line 3109
        tmp___3 = leg_place(im, 0);
        }
#line 3109
        if (tmp___3 == -1) {
#line 3110
          return (-1);
        }
      }
    }
#line 3115
    im->yimg = (long )(Ymain + Yxlabel);
#line 3116
    if ((unsigned int )im->legendposition == 0U) {
#line 3116
      goto _L___5;
    } else
#line 3116
    if ((unsigned int )im->legendposition == 2U) {
      _L___5: /* CIL Label */ 
#line 3116
      if (! (im->extra_flags & 16)) {
#line 3117
        im->yimg += im->legendheight;
      }
    }
#line 3121
    if (Ytitle) {
#line 3122
      im->yimg += (long )Ytitle;
    } else {
#line 3124
      im->yimg = (long )((double )im->yimg + 1.5 * (double )Yspacing);
    }
#line 3127
    if (im->extra_flags & 16) {
#line 3128
      im->yimg = (long )((double )im->yimg + 0.5 * (double )Yspacing);
    }
#line 3131
    if ((int )im->watermark[0] != 0) {
#line 3132
      im->yimg += (long )Ywatermark;
    }
  }
#line 3143
  if (! (im->extra_flags & 16)) {
#line 3144
    if ((unsigned int )im->legendposition == 1U) {
#line 3144
      goto _L___6;
    } else
#line 3144
    if ((unsigned int )im->legendposition == 3U) {
      _L___6: /* CIL Label */ 
      {
#line 3145
      tmp___4 = leg_place(im, 0);
      }
#line 3145
      if (tmp___4 == -1) {
#line 3146
        return (-1);
      }
    }
  }
  {
#line 3156
  if ((unsigned int )im->legendposition == 0U) {
#line 3156
    goto case_0;
  }
#line 3177
  if ((unsigned int )im->legendposition == 1U) {
#line 3177
    goto case_1;
  }
#line 3198
  if ((unsigned int )im->legendposition == 2U) {
#line 3198
    goto case_2;
  }
#line 3219
  if ((unsigned int )im->legendposition == 3U) {
#line 3219
    goto case_3;
  }
#line 3155
  goto switch_break;
  case_0: /* CIL Label */ 
#line 3157
  im->xOriginTitle = im->ximg / 2L;
#line 3158
  im->yOriginTitle = 0L;
#line 3160
  im->xOriginLegend = 0L;
#line 3161
  im->yOriginLegend = (long )Ytitle;
#line 3163
  im->xOriginLegendY = 0L;
#line 3164
  im->yOriginLegendY = (((long )Ytitle + im->legendheight) + (long )(Ymain / 2)) + (long )Yxlabel;
#line 3166
  im->xorigin = (long )(Xvertical + Xylabel);
#line 3167
  im->yorigin = ((long )Ytitle + im->legendheight) + (long )Ymain;
#line 3169
  im->xOriginLegendY2 = (long )((Xvertical + Xylabel) + Xmain);
#line 3170
  if (im->second_axis_scale != (double )0) {
#line 3171
    im->xOriginLegendY2 += (long )Xylabel;
  }
#line 3173
  im->yOriginLegendY2 = (((long )Ytitle + im->legendheight) + (long )(Ymain / 2)) + (long )Yxlabel;
#line 3175
  goto switch_break;
  case_1: /* CIL Label */ 
#line 3178
  im->xOriginTitle = im->legendwidth + im->xsize / 2L;
#line 3179
  im->yOriginTitle = 0L;
#line 3181
  im->xOriginLegend = 0L;
#line 3182
  im->yOriginLegend = (long )Ytitle;
#line 3184
  im->xOriginLegendY = im->legendwidth;
#line 3185
  im->yOriginLegendY = (long )(Ytitle + Ymain / 2);
#line 3187
  im->xorigin = (im->legendwidth + (long )Xvertical) + (long )Xylabel;
#line 3188
  im->yorigin = (long )(Ytitle + Ymain);
#line 3190
  im->xOriginLegendY2 = ((im->legendwidth + (long )Xvertical) + (long )Xylabel) + (long )Xmain;
#line 3191
  if (im->second_axis_scale != (double )0) {
#line 3192
    im->xOriginLegendY2 += (long )Xylabel;
  }
#line 3194
  im->yOriginLegendY2 = (long )(Ytitle + Ymain / 2);
#line 3196
  goto switch_break;
  case_2: /* CIL Label */ 
#line 3199
  im->xOriginTitle = im->ximg / 2L;
#line 3200
  im->yOriginTitle = 0L;
#line 3202
  im->xOriginLegend = 0L;
#line 3203
  im->yOriginLegend = (long )((Ytitle + Ymain) + Yxlabel);
#line 3205
  im->xOriginLegendY = 0L;
#line 3206
  im->yOriginLegendY = (long )(Ytitle + Ymain / 2);
#line 3208
  im->xorigin = (long )(Xvertical + Xylabel);
#line 3209
  im->yorigin = (long )(Ytitle + Ymain);
#line 3211
  im->xOriginLegendY2 = (long )((Xvertical + Xylabel) + Xmain);
#line 3212
  if (im->second_axis_scale != (double )0) {
#line 3213
    im->xOriginLegendY2 += (long )Xylabel;
  }
#line 3215
  im->yOriginLegendY2 = (long )(Ytitle + Ymain / 2);
#line 3217
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3220
  im->xOriginTitle = im->xsize / 2L;
#line 3221
  im->yOriginTitle = 0L;
#line 3223
  im->xOriginLegend = (long )(((Xvertical + Xylabel) + Xmain) + Xvertical2);
#line 3224
  if (im->second_axis_scale != (double )0) {
#line 3225
    im->xOriginLegend += (long )Xylabel;
  }
#line 3227
  im->yOriginLegend = (long )Ytitle;
#line 3229
  im->xOriginLegendY = 0L;
#line 3230
  im->yOriginLegendY = (long )(Ytitle + Ymain / 2);
#line 3232
  im->xorigin = (long )(Xvertical + Xylabel);
#line 3233
  im->yorigin = (long )(Ytitle + Ymain);
#line 3235
  im->xOriginLegendY2 = (long )((Xvertical + Xylabel) + Xmain);
#line 3236
  if (im->second_axis_scale != (double )0) {
#line 3237
    im->xOriginLegendY2 += (long )Xylabel;
  }
#line 3239
  im->yOriginLegendY2 = (long )(Ytitle + Ymain / 2);
#line 3241
  if (! (im->extra_flags & 1024)) {
#line 3242
    im->xOriginTitle += (long )Xspacing;
#line 3243
    im->xOriginLegend += (long )Xspacing;
#line 3244
    im->xOriginLegendY += (long )Xspacing;
#line 3245
    im->xorigin += (long )Xspacing;
#line 3246
    im->xOriginLegendY2 += (long )Xspacing;
  }
#line 3248
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3251
  xtr(im, (time_t )0);
#line 3252
  tmp___5 = rrd_set_to_DNAN();
#line 3252
  ytr(im, tmp___5);
  }
#line 3253
  return (0);
}
}
#line 3256 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
static cairo_status_t cairo_output(void *closure , unsigned char const   *data , unsigned int length ) 
{ 
  image_desc_t *im ;
  void *tmp ;

  {
  {
#line 3262
  im = (image_desc_t *)closure;
#line 3264
  tmp = realloc((void *)im->rendered_image, im->rendered_image_size + (size_t )length);
#line 3264
  im->rendered_image = (unsigned char *)tmp;
  }
#line 3266
  if ((unsigned long )im->rendered_image == (unsigned long )((void *)0)) {
#line 3267
    return ((cairo_status_t )11);
  }
  {
#line 3268
  memcpy((void */* __restrict  */)(im->rendered_image + im->rendered_image_size),
         (void const   */* __restrict  */)data, (size_t )length);
#line 3269
  im->rendered_image_size += (size_t )length;
  }
#line 3270
  return ((cairo_status_t )0);
}
}
#line 3274 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int graph_paint(image_desc_t *im ) 
{ 
  int i ;
  int ii ;
  int lazy ;
  int tmp ;
  double areazero ;
  graph_desc_t *lastgdes ;
  rrd_infoval_t info ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  double tmp___15 ;
  cairo_surface_t *tmp___17 ;
  cairo_surface_t *tmp___18 ;
  size_t tmp___19 ;
  cairo_surface_t *tmp___21 ;
  cairo_surface_t *tmp___22 ;
  size_t tmp___23 ;
  cairo_surface_t *tmp___25 ;
  cairo_surface_t *tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  rrd_value_t diffval ;
  rrd_value_t maxlimit ;
  rrd_value_t minlimit ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  double last_y ;
  int draw_on ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  double x ;
  double y ;
  double x___0 ;
  double y___0 ;
  double tmp___48 ;
  double x1 ;
  double cairo_y1 ;
  double tmp___49 ;
  double x___1 ;
  double y___1 ;
  int tmp___50 ;
  int idxI ;
  double *foreY ;
  void *tmp___51 ;
  double *foreX ;
  void *tmp___52 ;
  double *backY ;
  void *tmp___53 ;
  double *backX ;
  void *tmp___54 ;
  int drawem ;
  double ybase ;
  double ytop ;
  int cntI ;
  int lastI ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  double extra ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  double tmp___71 ;
  double tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  cairo_status_t status ;
  cairo_status_t tmp___76 ;
  cairo_status_t tmp___77 ;
  size_t tmp___78 ;
  size_t tmp___79 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;

  {
  {
#line 3278
  tmp = lazy_check(im);
#line 3278
  lazy = tmp;
#line 3279
  areazero = 0.0;
#line 3280
  lastgdes = (graph_desc_t *)((void *)0);
#line 3286
  tmp___0 = data_fetch(im);
  }
#line 3286
  if (tmp___0 == -1) {
#line 3287
    return (-1);
  }
  {
#line 3289
  tmp___1 = data_calc(im);
  }
#line 3289
  if (tmp___1 == -1) {
#line 3290
    return (-1);
  }
  {
#line 3296
  i = print_calc(im);
  }
#line 3297
  if (i < 0) {
#line 3298
    return (-1);
  }
#line 3301
  if (i == 0) {
#line 3302
    return (0);
  }
  {
#line 3308
  tmp___2 = graph_size_location(im, i);
  }
#line 3308
  if (tmp___2 == -1) {
#line 3309
    return (-1);
  }
  {
#line 3311
  info.u_cnt = (unsigned long )im->xorigin;
#line 3312
  tmp___3 = sprintf_alloc((char *)"graph_left");
#line 3312
  grinfo_push(im, tmp___3, (rrd_info_type_t )1, info);
#line 3313
  info.u_cnt = (unsigned long )(im->yorigin - im->ysize);
#line 3314
  tmp___4 = sprintf_alloc((char *)"graph_top");
#line 3314
  grinfo_push(im, tmp___4, (rrd_info_type_t )1, info);
#line 3315
  info.u_cnt = (unsigned long )im->xsize;
#line 3316
  tmp___5 = sprintf_alloc((char *)"graph_width");
#line 3316
  grinfo_push(im, tmp___5, (rrd_info_type_t )1, info);
#line 3317
  info.u_cnt = (unsigned long )im->ysize;
#line 3318
  tmp___6 = sprintf_alloc((char *)"graph_height");
#line 3318
  grinfo_push(im, tmp___6, (rrd_info_type_t )1, info);
#line 3319
  info.u_cnt = (unsigned long )im->ximg;
#line 3320
  tmp___7 = sprintf_alloc((char *)"image_width");
#line 3320
  grinfo_push(im, tmp___7, (rrd_info_type_t )1, info);
#line 3321
  info.u_cnt = (unsigned long )im->yimg;
#line 3322
  tmp___8 = sprintf_alloc((char *)"image_height");
#line 3322
  grinfo_push(im, tmp___8, (rrd_info_type_t )1, info);
#line 3323
  info.u_cnt = (unsigned long )im->start;
#line 3324
  tmp___9 = sprintf_alloc((char *)"graph_start");
#line 3324
  grinfo_push(im, tmp___9, (rrd_info_type_t )1, info);
#line 3325
  info.u_cnt = (unsigned long )im->end;
#line 3326
  tmp___10 = sprintf_alloc((char *)"graph_end");
#line 3326
  grinfo_push(im, tmp___10, (rrd_info_type_t )1, info);
  }
#line 3329
  if (lazy) {
#line 3330
    return (0);
  }
  {
#line 3333
  tmp___11 = data_proc(im);
  }
#line 3333
  if (tmp___11 == -1) {
#line 3334
    return (-1);
  }
#line 3335
  if (! im->logarithmic) {
    {
#line 3336
    si_unit(im);
    }
  }
#line 3340
  if (! im->rigid) {
#line 3340
    if (! im->logarithmic) {
      {
#line 3341
      expand_range(im);
      }
    }
  }
  {
#line 3344
  info.u_val = im->minval;
#line 3345
  tmp___12 = sprintf_alloc((char *)"value_min");
#line 3345
  grinfo_push(im, tmp___12, (rrd_info_type_t )0, info);
#line 3346
  info.u_val = im->maxval;
#line 3347
  tmp___13 = sprintf_alloc((char *)"value_max");
#line 3347
  grinfo_push(im, tmp___13, (rrd_info_type_t )0, info);
#line 3350
  tmp___14 = calc_horizontal_grid(im);
  }
#line 3350
  if (! tmp___14) {
#line 3351
    return (-1);
  }
  {
#line 3353
  tmp___15 = rrd_set_to_DNAN();
#line 3353
  ytr(im, tmp___15);
#line 3358
  cairo_surface_destroy(im->surface);
  }
  {
#line 3360
  if ((unsigned int )im->imgformat == 0U) {
#line 3360
    goto case_0;
  }
#line 3366
  if ((unsigned int )im->imgformat == 3U) {
#line 3366
    goto case_3;
  }
#line 3374
  if ((unsigned int )im->imgformat == 2U) {
#line 3374
    goto case_2;
  }
#line 3383
  if ((unsigned int )im->imgformat == 1U) {
#line 3383
    goto case_1;
  }
#line 3359
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 3361
  im->surface = cairo_image_surface_create((cairo_format_t )0, (int )((double )im->ximg * im->zoom),
                                           (int )((double )im->yimg * im->zoom));
  }
#line 3365
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 3367
  im->gridfit = 0;
#line 3368
  tmp___19 = strlen((char const   *)(im->graphfile));
  }
#line 3368
  if (tmp___19) {
    {
#line 3368
    tmp___17 = cairo_pdf_surface_create((char const   *)(im->graphfile), (double )im->ximg * im->zoom,
                                        (double )im->yimg * im->zoom);
#line 3368
    im->surface = tmp___17;
    }
  } else {
    {
#line 3368
    tmp___18 = cairo_pdf_surface_create_for_stream(& cairo_output, (void *)im, (double )im->ximg * im->zoom,
                                                   (double )im->yimg * im->zoom);
#line 3368
    im->surface = tmp___18;
    }
  }
#line 3373
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3375
  im->gridfit = 0;
#line 3376
  tmp___23 = strlen((char const   *)(im->graphfile));
  }
#line 3376
  if (tmp___23) {
    {
#line 3376
    tmp___21 = cairo_ps_surface_create((char const   *)(im->graphfile), (double )im->ximg * im->zoom,
                                       (double )im->yimg * im->zoom);
#line 3376
    im->surface = tmp___21;
    }
  } else {
    {
#line 3376
    tmp___22 = cairo_ps_surface_create_for_stream(& cairo_output, (void *)im, (double )im->ximg * im->zoom,
                                                  (double )im->yimg * im->zoom);
#line 3376
    im->surface = tmp___22;
    }
  }
#line 3382
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 3384
  im->gridfit = 0;
#line 3385
  tmp___27 = strlen((char const   *)(im->graphfile));
  }
#line 3385
  if (tmp___27) {
    {
#line 3385
    tmp___25 = cairo_svg_surface_create((char const   *)(im->graphfile), (double )im->ximg * im->zoom,
                                        (double )im->yimg * im->zoom);
#line 3385
    im->surface = tmp___25;
    }
  } else {
    {
#line 3385
    tmp___26 = cairo_svg_surface_create_for_stream(& cairo_output, (void *)im, (double )im->ximg * im->zoom,
                                                   (double )im->yimg * im->zoom);
#line 3385
    im->surface = tmp___26;
    }
  }
  {
#line 3392
  cairo_svg_surface_restrict_to_version(im->surface, (cairo_svg_version_t )0);
  }
#line 3394
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 3396
  cairo_destroy(im->cr);
#line 3397
  im->cr = cairo_create(im->surface);
#line 3398
  cairo_set_antialias(im->cr, im->graph_antialias);
#line 3399
  cairo_scale(im->cr, im->zoom, im->zoom);
#line 3401
  gfx_new_area(im, (double )0, (double )0, (double )0, (double )im->yimg, (double )im->ximg,
               (double )im->yimg, im->graph_col[1]);
#line 3403
  gfx_add_point(im, (double )im->ximg, (double )0);
#line 3404
  gfx_close_path(im);
#line 3405
  gfx_new_area(im, (double )im->xorigin, (double )im->yorigin, (double )(im->xorigin + im->xsize),
               (double )im->yorigin, (double )(im->xorigin + im->xsize), (double )(im->yorigin - im->ysize),
               im->graph_col[0]);
#line 3412
  gfx_add_point(im, (double )im->xorigin, (double )(im->yorigin - im->ysize));
#line 3413
  gfx_close_path(im);
#line 3414
  cairo_rectangle(im->cr, (double )im->xorigin, (double )(im->yorigin - im->ysize) - 1.0,
                  (double )im->xsize, (double )im->ysize + 2.0);
#line 3416
  cairo_clip(im->cr);
  }
#line 3417
  if (im->minval > 0.0) {
#line 3418
    areazero = im->minval;
  }
#line 3419
  if (im->maxval < 0.0) {
#line 3420
    areazero = im->maxval;
  }
#line 3421
  i = 0;
  {
#line 3421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3421
    if (! ((long )i < im->gdes_c)) {
#line 3421
      goto while_break;
    }
    {
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 13U) {
#line 3433
      goto case_13;
    }
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 14U) {
#line 3433
      goto case_13;
    }
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 4U) {
#line 3433
      goto case_13;
    }
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 3U) {
#line 3433
      goto case_13;
    }
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 9U) {
#line 3433
      goto case_13;
    }
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 2U) {
#line 3433
      goto case_13;
    }
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 1U) {
#line 3433
      goto case_13;
    }
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 0U) {
#line 3433
      goto case_13;
    }
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 10U) {
#line 3433
      goto case_13;
    }
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 12U) {
#line 3433
      goto case_13;
    }
#line 3433
    if ((unsigned int )(im->gdes + i)->gf == 11U) {
#line 3433
      goto case_13;
    }
#line 3435
    if ((unsigned int )(im->gdes + i)->gf == 8U) {
#line 3435
      goto case_8;
    }
#line 3461
    if ((unsigned int )(im->gdes + i)->gf == 6U) {
#line 3461
      goto case_6;
    }
#line 3461
    if ((unsigned int )(im->gdes + i)->gf == 5U) {
#line 3461
      goto case_6;
    }
#line 3708
    if ((unsigned int )(im->gdes + i)->gf == 7U) {
#line 3708
      goto case_7;
    }
#line 3422
    goto switch_break___0;
    case_13: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 3434
    goto switch_break___0;
    case_8: /* CIL Label */ 
#line 3436
    ii = 0;
    {
#line 3436
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3436
      if (! ((long )ii < im->xsize)) {
#line 3436
        goto while_break___0;
      }
#line 3437
      if (sizeof(*((im->gdes + i)->p_data + ii)) == sizeof(float )) {
        {
#line 3437
        tmp___28 = __isnanf((float )*((im->gdes + i)->p_data + ii));
#line 3437
        tmp___32 = tmp___28;
        }
      } else {
#line 3437
        if (sizeof(*((im->gdes + i)->p_data + ii)) == sizeof(double )) {
          {
#line 3437
          tmp___29 = __isnan(*((im->gdes + i)->p_data + ii));
#line 3437
          tmp___31 = tmp___29;
          }
        } else {
          {
#line 3437
          tmp___30 = __isnanl((long double )*((im->gdes + i)->p_data + ii));
#line 3437
          tmp___31 = tmp___30;
          }
        }
#line 3437
        tmp___32 = tmp___31;
      }
#line 3437
      if (! tmp___32) {
#line 3437
        if (*((im->gdes + i)->p_data + ii) != 0.0) {
#line 3439
          if ((im->gdes + i)->yrule > (double )0) {
            {
#line 3440
            gfx_line(im, (double )(im->xorigin + (long )ii), (double )im->yorigin + 1.0,
                     (double )(im->xorigin + (long )ii), (double )im->yorigin - (im->gdes + i)->yrule * (double )im->ysize,
                     1.0, (im->gdes + i)->col);
            }
          } else
#line 3447
          if ((im->gdes + i)->yrule < (double )0) {
            {
#line 3448
            gfx_line(im, (double )(im->xorigin + (long )ii), (double )(im->yorigin - im->ysize) - 1.0,
                     (double )(im->xorigin + (long )ii), (double )(im->yorigin - im->ysize) - (im->gdes + i)->yrule * (double )im->ysize,
                     1.0, (im->gdes + i)->col);
            }
          }
        }
      }
#line 3436
      ii ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3459
    goto switch_break___0;
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
#line 3462
    diffval = im->maxval - im->minval;
#line 3463
    maxlimit = im->maxval + (rrd_value_t )9 * diffval;
#line 3464
    minlimit = im->minval - (rrd_value_t )9 * diffval;
#line 3465
    ii = 0;
    {
#line 3465
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3465
      if (! ((long )ii < im->xsize)) {
#line 3465
        goto while_break___1;
      }
#line 3467
      if (sizeof(*((im->gdes + i)->p_data + ii)) == sizeof(float )) {
        {
#line 3467
        tmp___33 = __isinff((float )*((im->gdes + i)->p_data + ii));
#line 3467
        tmp___37 = tmp___33;
        }
      } else {
#line 3467
        if (sizeof(*((im->gdes + i)->p_data + ii)) == sizeof(double )) {
          {
#line 3467
          tmp___34 = __isinf(*((im->gdes + i)->p_data + ii));
#line 3467
          tmp___36 = tmp___34;
          }
        } else {
          {
#line 3467
          tmp___35 = __isinfl((long double )*((im->gdes + i)->p_data + ii));
#line 3467
          tmp___36 = tmp___35;
          }
        }
#line 3467
        tmp___37 = tmp___36;
      }
#line 3467
      if (tmp___37) {
#line 3468
        if (*((im->gdes + i)->p_data + ii) > (rrd_value_t )0) {
#line 3469
          *((im->gdes + i)->p_data + ii) = im->maxval;
        } else {
#line 3471
          *((im->gdes + i)->p_data + ii) = im->minval;
        }
      }
#line 3476
      if (*((im->gdes + i)->p_data + ii) > maxlimit) {
#line 3477
        *((im->gdes + i)->p_data + ii) = maxlimit;
      }
#line 3479
      if (*((im->gdes + i)->p_data + ii) < minlimit) {
#line 3480
        *((im->gdes + i)->p_data + ii) = minlimit;
      }
#line 3465
      ii ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3495
    if ((im->gdes + i)->col.alpha != 0.0) {
#line 3497
      if ((unsigned int )(im->gdes + i)->gf == 5U) {
        {
#line 3498
        last_y = 0.0;
#line 3499
        draw_on = 0;
#line 3501
        cairo_save(im->cr);
#line 3502
        cairo_new_path(im->cr);
#line 3503
        cairo_set_line_width(im->cr, (im->gdes + i)->linewidth);
        }
#line 3504
        if ((im->gdes + i)->dash) {
          {
#line 3505
          cairo_set_dash(im->cr, (double const   *)(im->gdes + i)->p_dashes, (im->gdes + i)->ndash,
                         (im->gdes + i)->offset);
          }
        }
#line 3510
        ii = 1;
        {
#line 3510
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3510
          if (! ((long )ii < im->xsize)) {
#line 3510
            goto while_break___2;
          }
#line 3511
          if (sizeof(*((im->gdes + i)->p_data + ii)) == sizeof(float )) {
            {
#line 3511
            tmp___38 = __isnanf((float )*((im->gdes + i)->p_data + ii));
#line 3511
            tmp___42 = tmp___38;
            }
          } else {
#line 3511
            if (sizeof(*((im->gdes + i)->p_data + ii)) == sizeof(double )) {
              {
#line 3511
              tmp___39 = __isnan(*((im->gdes + i)->p_data + ii));
#line 3511
              tmp___41 = tmp___39;
              }
            } else {
              {
#line 3511
              tmp___40 = __isnanl((long double )*((im->gdes + i)->p_data + ii));
#line 3511
              tmp___41 = tmp___40;
              }
            }
#line 3511
            tmp___42 = tmp___41;
          }
#line 3511
          if (tmp___42) {
#line 3514
            draw_on = 0;
#line 3515
            goto __Cont;
          } else
#line 3511
          if (im->slopemode == 1) {
#line 3511
            if (sizeof(*((im->gdes + i)->p_data + (ii - 1))) == sizeof(float )) {
              {
#line 3511
              tmp___43 = __isnanf((float )*((im->gdes + i)->p_data + (ii - 1)));
#line 3511
              tmp___47 = tmp___43;
              }
            } else {
#line 3511
              if (sizeof(*((im->gdes + i)->p_data + (ii - 1))) == sizeof(double )) {
                {
#line 3511
                tmp___44 = __isnan(*((im->gdes + i)->p_data + (ii - 1)));
#line 3511
                tmp___46 = tmp___44;
                }
              } else {
                {
#line 3511
                tmp___45 = __isnanl((long double )*((im->gdes + i)->p_data + (ii - 1)));
#line 3511
                tmp___46 = tmp___45;
                }
              }
#line 3511
              tmp___47 = tmp___46;
            }
#line 3511
            if (tmp___47) {
#line 3514
              draw_on = 0;
#line 3515
              goto __Cont;
            }
          }
#line 3517
          if (draw_on == 0) {
            {
#line 3518
            last_y = ytr(im, *((im->gdes + i)->p_data + ii));
            }
#line 3519
            if (im->slopemode == 0) {
              {
#line 3520
              x = (double )((long )(ii - 1) + im->xorigin);
#line 3521
              y = last_y;
#line 3523
              gfx_line_fit(im, & x, & y);
#line 3524
              cairo_move_to(im->cr, x, y);
#line 3525
              x = (double )((long )ii + im->xorigin);
#line 3526
              y = last_y;
#line 3527
              gfx_line_fit(im, & x, & y);
#line 3528
              cairo_line_to(im->cr, x, y);
              }
            } else {
              {
#line 3530
              x___0 = (double )((long )(ii - 1) + im->xorigin);
#line 3531
              tmp___48 = ytr(im, *((im->gdes + i)->p_data + (ii - 1)));
#line 3531
              y___0 = tmp___48;
#line 3533
              gfx_line_fit(im, & x___0, & y___0);
#line 3534
              cairo_move_to(im->cr, x___0, y___0);
#line 3535
              x___0 = (double )((long )ii + im->xorigin);
#line 3536
              y___0 = last_y;
#line 3537
              gfx_line_fit(im, & x___0, & y___0);
#line 3538
              cairo_line_to(im->cr, x___0, y___0);
              }
            }
#line 3540
            draw_on = 1;
          } else {
            {
#line 3542
            x1 = (double )((long )ii + im->xorigin);
#line 3543
            tmp___49 = ytr(im, *((im->gdes + i)->p_data + ii));
#line 3543
            cairo_y1 = tmp___49;
            }
#line 3545
            if (im->slopemode == 0) {
              {
#line 3545
              tmp___50 = AlmostEqual2sComplement((float )cairo_y1, (float )last_y,
                                                 4);
              }
#line 3545
              if (! tmp___50) {
                {
#line 3547
                x___1 = (double )((long )(ii - 1) + im->xorigin);
#line 3548
                y___1 = cairo_y1;
#line 3550
                gfx_line_fit(im, & x___1, & y___1);
#line 3551
                cairo_line_to(im->cr, x___1, y___1);
                }
              }
            }
            {
#line 3553
            last_y = cairo_y1;
#line 3554
            gfx_line_fit(im, & x1, & cairo_y1);
#line 3555
            cairo_line_to(im->cr, x1, cairo_y1);
            }
          }
          __Cont: /* CIL Label */ 
#line 3510
          ii ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 3558
        cairo_set_source_rgba(im->cr, (im->gdes + i)->col.red, (im->gdes + i)->col.green,
                              (im->gdes + i)->col.blue, (im->gdes + i)->col.alpha);
#line 3565
        cairo_set_line_cap(im->cr, (cairo_line_cap_t )1);
#line 3566
        cairo_set_line_join(im->cr, (cairo_line_join_t )1);
#line 3567
        cairo_stroke(im->cr);
#line 3568
        cairo_restore(im->cr);
        }
      } else {
        {
#line 3570
        idxI = -1;
#line 3571
        tmp___51 = malloc((sizeof(double ) * (unsigned long )im->xsize) * 2UL);
#line 3571
        foreY = (double *)tmp___51;
#line 3573
        tmp___52 = malloc((sizeof(double ) * (unsigned long )im->xsize) * 2UL);
#line 3573
        foreX = (double *)tmp___52;
#line 3575
        tmp___53 = malloc((sizeof(double ) * (unsigned long )im->xsize) * 2UL);
#line 3575
        backY = (double *)tmp___53;
#line 3577
        tmp___54 = malloc((sizeof(double ) * (unsigned long )im->xsize) * 2UL);
#line 3577
        backX = (double *)tmp___54;
#line 3579
        drawem = 0;
#line 3581
        ii = 0;
        }
        {
#line 3581
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3581
          if (! ((long )ii <= im->xsize)) {
#line 3581
            goto while_break___3;
          }
#line 3584
          if (idxI > 0) {
#line 3584
            if (drawem != 0) {
#line 3584
              goto _L;
            } else
#line 3584
            if ((long )ii == im->xsize) {
              _L: /* CIL Label */ 
#line 3585
              cntI = 1;
#line 3586
              lastI = 0;
              {
#line 3588
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 3588
                if (cntI < idxI) {
                  {
#line 3588
                  tmp___55 = AlmostEqual2sComplement((float )*(foreY + lastI), (float )*(foreY + cntI),
                                                     4);
                  }
#line 3588
                  if (tmp___55) {
                    {
#line 3588
                    tmp___56 = AlmostEqual2sComplement((float )*(foreY + lastI), (float )*(foreY + (cntI + 1)),
                                                       4);
                    }
#line 3588
                    if (! tmp___56) {
#line 3588
                      goto while_break___4;
                    }
                  } else {
#line 3588
                    goto while_break___4;
                  }
                } else {
#line 3588
                  goto while_break___4;
                }
#line 3598
                cntI ++;
              }
              while_break___4: /* CIL Label */ ;
              }
              {
#line 3600
              gfx_new_area(im, *(backX + 0), *(backY + 0), *(foreX + 0), *(foreY + 0),
                           *(foreX + cntI), *(foreY + cntI), (im->gdes + i)->col);
              }
              {
#line 3605
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 3605
                if (! (cntI < idxI)) {
#line 3605
                  goto while_break___5;
                }
#line 3606
                lastI = cntI;
#line 3607
                cntI ++;
                {
#line 3608
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 3608
                  if (cntI < idxI) {
                    {
#line 3608
                    tmp___57 = AlmostEqual2sComplement((float )*(foreY + lastI), (float )*(foreY + cntI),
                                                       4);
                    }
#line 3608
                    if (tmp___57) {
                      {
#line 3608
                      tmp___58 = AlmostEqual2sComplement((float )*(foreY + lastI),
                                                         (float )*(foreY + (cntI + 1)),
                                                         4);
                      }
#line 3608
                      if (! tmp___58) {
#line 3608
                        goto while_break___6;
                      }
                    } else {
#line 3608
                      goto while_break___6;
                    }
                  } else {
#line 3608
                    goto while_break___6;
                  }
#line 3619
                  cntI ++;
                }
                while_break___6: /* CIL Label */ ;
                }
                {
#line 3621
                gfx_add_point(im, *(foreX + cntI), *(foreY + cntI));
                }
              }
              while_break___5: /* CIL Label */ ;
              }
              {
#line 3623
              gfx_add_point(im, *(backX + idxI), *(backY + idxI));
              }
              {
#line 3624
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 3624
                if (! (idxI > 1)) {
#line 3624
                  goto while_break___7;
                }
#line 3625
                lastI = idxI;
#line 3626
                idxI --;
                {
#line 3627
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 3627
                  if (idxI > 1) {
                    {
#line 3627
                    tmp___59 = AlmostEqual2sComplement((float )*(backY + lastI), (float )*(backY + idxI),
                                                       4);
                    }
#line 3627
                    if (tmp___59) {
                      {
#line 3627
                      tmp___60 = AlmostEqual2sComplement((float )*(backY + lastI),
                                                         (float )*(backY + (idxI - 1)),
                                                         4);
                      }
#line 3627
                      if (! tmp___60) {
#line 3627
                        goto while_break___8;
                      }
                    } else {
#line 3627
                      goto while_break___8;
                    }
                  } else {
#line 3627
                    goto while_break___8;
                  }
#line 3638
                  idxI --;
                }
                while_break___8: /* CIL Label */ ;
                }
                {
#line 3640
                gfx_add_point(im, *(backX + idxI), *(backY + idxI));
                }
              }
              while_break___7: /* CIL Label */ ;
              }
              {
#line 3642
              idxI = -1;
#line 3643
              drawem = 0;
#line 3644
              gfx_close_path(im);
              }
            }
          }
#line 3646
          if (drawem != 0) {
#line 3647
            drawem = 0;
#line 3648
            idxI = -1;
          }
#line 3650
          if ((long )ii == im->xsize) {
#line 3651
            goto while_break___3;
          }
#line 3652
          if (im->slopemode == 0) {
#line 3652
            if (ii == 0) {
#line 3653
              goto __Cont___0;
            }
          }
#line 3655
          if (sizeof(*((im->gdes + i)->p_data + ii)) == sizeof(float )) {
            {
#line 3655
            tmp___61 = __isnanf((float )*((im->gdes + i)->p_data + ii));
#line 3655
            tmp___65 = tmp___61;
            }
          } else {
#line 3655
            if (sizeof(*((im->gdes + i)->p_data + ii)) == sizeof(double )) {
              {
#line 3655
              tmp___62 = __isnan(*((im->gdes + i)->p_data + ii));
#line 3655
              tmp___64 = tmp___62;
              }
            } else {
              {
#line 3655
              tmp___63 = __isnanl((long double )*((im->gdes + i)->p_data + ii));
#line 3655
              tmp___64 = tmp___63;
              }
            }
#line 3655
            tmp___65 = tmp___64;
          }
#line 3655
          if (tmp___65) {
#line 3656
            drawem = 1;
#line 3657
            goto __Cont___0;
          }
          {
#line 3659
          ytop = ytr(im, *((im->gdes + i)->p_data + ii));
          }
#line 3660
          if (lastgdes) {
#line 3660
            if ((im->gdes + i)->stack) {
              {
#line 3661
              ybase = ytr(im, *(lastgdes->p_data + ii));
              }
            } else {
              {
#line 3663
              ybase = ytr(im, areazero);
              }
            }
          } else {
            {
#line 3663
            ybase = ytr(im, areazero);
            }
          }
#line 3665
          if (ybase == ytop) {
#line 3666
            drawem = 1;
#line 3667
            goto __Cont___0;
          }
#line 3670
          if (ybase > ytop) {
#line 3671
            extra = ytop;
#line 3673
            ytop = ybase;
#line 3674
            ybase = extra;
          }
#line 3676
          if (im->slopemode == 0) {
#line 3677
            idxI ++;
#line 3677
            *(backY + idxI) = ybase - 0.2;
#line 3678
            *(backX + idxI) = (double )(((long )ii + im->xorigin) - 1L);
#line 3679
            *(foreY + idxI) = ytop + 0.2;
#line 3680
            *(foreX + idxI) = (double )(((long )ii + im->xorigin) - 1L);
          }
#line 3682
          idxI ++;
#line 3682
          *(backY + idxI) = ybase - 0.2;
#line 3683
          *(backX + idxI) = (double )((long )ii + im->xorigin);
#line 3684
          *(foreY + idxI) = ytop + 0.2;
#line 3685
          *(foreX + idxI) = (double )((long )ii + im->xorigin);
          __Cont___0: /* CIL Label */ 
#line 3581
          ii ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 3688
        free((void *)foreY);
#line 3689
        free((void *)foreX);
#line 3690
        free((void *)backY);
#line 3691
        free((void *)backX);
        }
      }
    }
#line 3696
    ii = 0;
    {
#line 3696
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 3696
      if (! ((long )ii < im->xsize)) {
#line 3696
        goto while_break___9;
      }
#line 3697
      if (sizeof(*((im->gdes + i)->p_data + ii)) == sizeof(float )) {
        {
#line 3697
        tmp___66 = __isnanf((float )*((im->gdes + i)->p_data + ii));
#line 3697
        tmp___70 = tmp___66;
        }
      } else {
#line 3697
        if (sizeof(*((im->gdes + i)->p_data + ii)) == sizeof(double )) {
          {
#line 3697
          tmp___67 = __isnan(*((im->gdes + i)->p_data + ii));
#line 3697
          tmp___69 = tmp___67;
          }
        } else {
          {
#line 3697
          tmp___68 = __isnanl((long double )*((im->gdes + i)->p_data + ii));
#line 3697
          tmp___69 = tmp___68;
          }
        }
#line 3697
        tmp___70 = tmp___69;
      }
#line 3697
      if (tmp___70) {
#line 3698
        if (lastgdes) {
#line 3698
          if ((im->gdes + i)->stack) {
#line 3699
            *((im->gdes + i)->p_data + ii) = *(lastgdes->p_data + ii);
          } else {
#line 3701
            *((im->gdes + i)->p_data + ii) = areazero;
          }
        } else {
#line 3701
          *((im->gdes + i)->p_data + ii) = areazero;
        }
      }
#line 3696
      ii ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 3705
    lastgdes = im->gdes + i;
#line 3706
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 3709
    rrd_set_error((char *)"STACK should already be turned into LINE or AREA here");
    }
#line 3711
    return (-1);
#line 3712
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 3421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3715
  cairo_reset_clip(im->cr);
  }
#line 3718
  if (! (im->extra_flags & 64)) {
    {
#line 3719
    grid_paint(im);
    }
  }
#line 3720
  if (! (im->extra_flags & 64)) {
    {
#line 3721
    axis_paint(im);
    }
  }
#line 3723
  i = 0;
  {
#line 3723
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 3723
    if (! ((long )i < im->gdes_c)) {
#line 3723
      goto while_break___10;
    }
    {
#line 3726
    if ((unsigned int )(im->gdes + i)->gf == 3U) {
#line 3726
      goto case_3___1;
    }
#line 3743
    if ((unsigned int )(im->gdes + i)->gf == 4U) {
#line 3743
      goto case_4___0;
    }
#line 3763
    goto switch_default;
    case_3___1: /* CIL Label */ 
#line 3727
    if ((im->gdes + i)->yrule >= im->minval) {
#line 3727
      if ((im->gdes + i)->yrule <= im->maxval) {
        {
#line 3729
        cairo_save(im->cr);
        }
#line 3730
        if ((im->gdes + i)->dash) {
          {
#line 3731
          cairo_set_dash(im->cr, (double const   *)(im->gdes + i)->p_dashes, (im->gdes + i)->ndash,
                         (im->gdes + i)->offset);
          }
        }
        {
#line 3735
        tmp___71 = ytr(im, (im->gdes + i)->yrule);
#line 3735
        tmp___72 = ytr(im, (im->gdes + i)->yrule);
#line 3735
        gfx_line(im, (double )im->xorigin, tmp___72, (double )(im->xorigin + im->xsize),
                 tmp___71, 1.0, (im->gdes + i)->col);
#line 3739
        cairo_stroke(im->cr);
#line 3740
        cairo_restore(im->cr);
        }
      }
    }
#line 3742
    goto switch_break___1;
    case_4___0: /* CIL Label */ 
#line 3744
    if ((im->gdes + i)->xrule >= im->start) {
#line 3744
      if ((im->gdes + i)->xrule <= im->end) {
        {
#line 3746
        cairo_save(im->cr);
        }
#line 3747
        if ((im->gdes + i)->dash) {
          {
#line 3748
          cairo_set_dash(im->cr, (double const   *)(im->gdes + i)->p_dashes, (im->gdes + i)->ndash,
                         (im->gdes + i)->offset);
          }
        }
        {
#line 3752
        tmp___73 = xtr(im, (im->gdes + i)->xrule);
#line 3752
        tmp___74 = xtr(im, (im->gdes + i)->xrule);
#line 3752
        gfx_line(im, (double )tmp___74, (double )im->yorigin, (double )tmp___73, (double )(im->yorigin - im->ysize),
                 1.0, (im->gdes + i)->col);
#line 3759
        cairo_stroke(im->cr);
#line 3760
        cairo_restore(im->cr);
        }
      }
    }
#line 3762
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 3764
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 3723
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 3770
  if ((unsigned int )im->imgformat == 0U) {
#line 3770
    goto case_0___1;
  }
#line 3785
  goto switch_default___0;
  case_0___1: /* CIL Label */ 
  {
#line 3774
  tmp___78 = strlen((char const   *)(im->graphfile));
  }
#line 3774
  if (tmp___78) {
    {
#line 3774
    tmp___76 = cairo_surface_write_to_png(im->surface, (char const   *)(im->graphfile));
#line 3774
    status = tmp___76;
    }
  } else {
    {
#line 3774
    tmp___77 = cairo_surface_write_to_png_stream(im->surface, & cairo_output, (void *)im);
#line 3774
    status = tmp___77;
    }
  }
#line 3779
  if ((unsigned int )status != 0U) {
    {
#line 3780
    rrd_set_error((char *)"Could not save png to \'%s\'", im->graphfile);
    }
#line 3781
    return (1);
  }
#line 3783
  goto switch_break___2;
  switch_default___0: /* CIL Label */ 
  {
#line 3786
  tmp___79 = strlen((char const   *)(im->graphfile));
  }
#line 3786
  if (tmp___79) {
    {
#line 3787
    cairo_show_page(im->cr);
    }
  } else {
    {
#line 3789
    cairo_surface_finish(im->surface);
    }
  }
#line 3791
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 3794
  return (0);
}
}
#line 3802 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int gdes_alloc(image_desc_t *im ) 
{ 
  graph_desc_t *tmp ;
  void *tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 3806
  (im->gdes_c) ++;
#line 3807
  tmp___0 = realloc((void *)im->gdes, (unsigned long )im->gdes_c * sizeof(graph_desc_t ));
#line 3807
  tmp = (graph_desc_t *)tmp___0;
#line 3807
  im->gdes = tmp;
  }
#line 3807
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 3810
    rrd_set_error((char *)"realloc graph_descs");
    }
#line 3811
    return (-1);
  }
  {
#line 3815
  (im->gdes + (im->gdes_c - 1L))->step = im->step;
#line 3816
  (im->gdes + (im->gdes_c - 1L))->step_orig = im->step;
#line 3817
  (im->gdes + (im->gdes_c - 1L))->stack = 0;
#line 3818
  (im->gdes + (im->gdes_c - 1L))->skipscale = 0;
#line 3819
  (im->gdes + (im->gdes_c - 1L))->linewidth = (double )0;
#line 3820
  (im->gdes + (im->gdes_c - 1L))->debug = 0;
#line 3821
  (im->gdes + (im->gdes_c - 1L))->start = im->start;
#line 3822
  (im->gdes + (im->gdes_c - 1L))->start_orig = im->start;
#line 3823
  (im->gdes + (im->gdes_c - 1L))->end = im->end;
#line 3824
  (im->gdes + (im->gdes_c - 1L))->end_orig = im->end;
#line 3825
  (im->gdes + (im->gdes_c - 1L))->vname[0] = (char )'\000';
#line 3826
  (im->gdes + (im->gdes_c - 1L))->data = (rrd_value_t *)((void *)0);
#line 3827
  (im->gdes + (im->gdes_c - 1L))->ds_namv = (char **)((void *)0);
#line 3828
  (im->gdes + (im->gdes_c - 1L))->data_first = 0L;
#line 3829
  (im->gdes + (im->gdes_c - 1L))->p_data = (rrd_value_t *)((void *)0);
#line 3830
  (im->gdes + (im->gdes_c - 1L))->rpnp = (rpnp_t *)((void *)0);
#line 3831
  (im->gdes + (im->gdes_c - 1L))->p_dashes = (double *)((void *)0);
#line 3832
  (im->gdes + (im->gdes_c - 1L))->shift = (time_t )0.0;
#line 3833
  (im->gdes + (im->gdes_c - 1L))->dash = 0;
#line 3834
  (im->gdes + (im->gdes_c - 1L))->ndash = 0;
#line 3835
  (im->gdes + (im->gdes_c - 1L))->offset = (double )0;
#line 3836
  (im->gdes + (im->gdes_c - 1L))->col.red = 0.0;
#line 3837
  (im->gdes + (im->gdes_c - 1L))->col.green = 0.0;
#line 3838
  (im->gdes + (im->gdes_c - 1L))->col.blue = 0.0;
#line 3839
  (im->gdes + (im->gdes_c - 1L))->col.alpha = 0.0;
#line 3840
  (im->gdes + (im->gdes_c - 1L))->legend[0] = (char )'\000';
#line 3841
  (im->gdes + (im->gdes_c - 1L))->format[0] = (char )'\000';
#line 3842
  (im->gdes + (im->gdes_c - 1L))->strftm = 0;
#line 3843
  (im->gdes + (im->gdes_c - 1L))->rrd[0] = (char )'\000';
#line 3844
  (im->gdes + (im->gdes_c - 1L))->ds = -1L;
#line 3845
  (im->gdes + (im->gdes_c - 1L))->cf_reduce = (enum cf_en )0;
#line 3846
  (im->gdes + (im->gdes_c - 1L))->cf = (enum cf_en )0;
#line 3847
  (im->gdes + (im->gdes_c - 1L))->yrule = rrd_set_to_DNAN();
#line 3848
  (im->gdes + (im->gdes_c - 1L))->xrule = (time_t )0;
  }
#line 3849
  return (0);
}
}
#line 3854 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int scan_for_col(char const   * const  input , int len , char * const  output ) 
{ 
  int inp ;
  int outp ;
  int tmp ;
  int tmp___0 ;

  {
#line 3859
  outp = 0;
#line 3861
  inp = 0;
  {
#line 3861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3861
    if (inp < len) {
#line 3861
      if ((int const   )*(input + inp) != 58) {
#line 3861
        if (! ((int const   )*(input + inp) != 0)) {
#line 3861
          goto while_break;
        }
      } else {
#line 3861
        goto while_break;
      }
    } else {
#line 3861
      goto while_break;
    }
#line 3862
    if ((int const   )*(input + inp) == 92) {
#line 3862
      if ((int const   )*(input + (inp + 1)) != 0) {
#line 3862
        if ((int const   )*(input + (inp + 1)) == 92) {
#line 3865
          tmp = outp;
#line 3865
          outp ++;
#line 3865
          inp ++;
#line 3865
          *(output + tmp) = (char )*(input + inp);
        } else
#line 3862
        if ((int const   )*(input + (inp + 1)) == 58) {
#line 3865
          tmp = outp;
#line 3865
          outp ++;
#line 3865
          inp ++;
#line 3865
          *(output + tmp) = (char )*(input + inp);
        } else {
#line 3867
          tmp___0 = outp;
#line 3867
          outp ++;
#line 3867
          *(output + tmp___0) = (char )*(input + inp);
        }
      } else {
#line 3867
        tmp___0 = outp;
#line 3867
        outp ++;
#line 3867
        *(output + tmp___0) = (char )*(input + inp);
      }
    } else {
#line 3867
      tmp___0 = outp;
#line 3867
      outp ++;
#line 3867
      *(output + tmp___0) = (char )*(input + inp);
    }
#line 3861
    inp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3870
  *(output + outp) = (char )'\000';
#line 3871
  return (inp);
}
}
#line 3875 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int rrd_graph(int argc , char **argv , char ***prdata , int *xsize , int *ysize ,
              FILE *stream , double *ymin , double *ymax ) 
{ 
  int prlines ;
  rrd_info_t *grinfo ;
  rrd_info_t *walker ;
  char **tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  FILE *tmp___8 ;
  size_t tmp___9 ;
  FILE *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 3885
  prlines = 0;
#line 3886
  grinfo = (rrd_info_t *)((void *)0);
#line 3889
  grinfo = rrd_graph_v(argc, argv);
  }
#line 3890
  if ((unsigned long )grinfo == (unsigned long )((void *)0)) {
#line 3891
    return (-1);
  }
#line 3892
  walker = grinfo;
#line 3893
  *prdata = (char **)((void *)0);
  {
#line 3894
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3894
    if (! walker) {
#line 3894
      goto while_break;
    }
    {
#line 3895
    tmp___3 = strcmp((char const   *)walker->key, "image_info");
    }
#line 3895
    if (tmp___3 == 0) {
      {
#line 3896
      prlines ++;
#line 3897
      tmp___0 = realloc((void *)*prdata, (unsigned long )(prlines + 1) * sizeof(char *));
#line 3897
      tmp = (char **)tmp___0;
#line 3897
      *prdata = tmp;
      }
#line 3897
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
#line 3900
        rrd_set_error((char *)"realloc prdata");
        }
#line 3901
        return (0);
      }
      {
#line 3904
      tmp___1 = strlen((char const   *)walker->value.u_str);
#line 3904
      tmp___2 = malloc((tmp___1 + 2UL) * sizeof(char ));
#line 3904
      *(*prdata + (prlines - 1)) = (char *)tmp___2;
#line 3906
      strcpy((char */* __restrict  */)*(*prdata + (prlines - 1)), (char const   */* __restrict  */)walker->value.u_str);
#line 3907
      *(*prdata + prlines) = (char *)((void *)0);
      }
    }
#line 3910
    walker = walker->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 3912
  walker = grinfo;
#line 3913
  *xsize = 0;
#line 3914
  *ysize = 0;
#line 3915
  *ymin = (double )0;
#line 3916
  *ymax = (double )0;
  {
#line 3917
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3917
    if (! walker) {
#line 3917
      goto while_break___0;
    }
    {
#line 3918
    tmp___17 = strcmp((char const   *)walker->key, "image_width");
    }
#line 3918
    if (tmp___17 == 0) {
#line 3919
      *xsize = (int )walker->value.u_cnt;
    } else {
      {
#line 3920
      tmp___16 = strcmp((char const   *)walker->key, "image_height");
      }
#line 3920
      if (tmp___16 == 0) {
#line 3921
        *ysize = (int )walker->value.u_cnt;
      } else {
        {
#line 3922
        tmp___15 = strcmp((char const   *)walker->key, "value_min");
        }
#line 3922
        if (tmp___15 == 0) {
#line 3923
          *ymin = walker->value.u_val;
        } else {
          {
#line 3924
          tmp___14 = strcmp((char const   *)walker->key, "value_max");
          }
#line 3924
          if (tmp___14 == 0) {
#line 3925
            *ymax = walker->value.u_val;
          } else {
            {
#line 3926
            tmp___13 = strncmp((char const   *)walker->key, "print", (size_t )5);
            }
#line 3926
            if (tmp___13 == 0) {
              {
#line 3927
              prlines ++;
#line 3928
              tmp___5 = realloc((void *)*prdata, (unsigned long )(prlines + 1) * sizeof(char *));
#line 3928
              tmp___4 = (char **)tmp___5;
#line 3928
              *prdata = tmp___4;
              }
#line 3928
              if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
                {
#line 3931
                rrd_set_error((char *)"realloc prdata");
                }
#line 3932
                return (0);
              }
              {
#line 3934
              tmp___6 = strlen((char const   *)walker->value.u_str);
#line 3934
              tmp___7 = malloc((tmp___6 + 2UL) * sizeof(char ));
#line 3934
              *(*prdata + (prlines - 1)) = (char *)tmp___7;
#line 3936
              *(*prdata + prlines) = (char *)((void *)0);
#line 3937
              strcpy((char */* __restrict  */)*(*prdata + (prlines - 1)), (char const   */* __restrict  */)walker->value.u_str);
              }
            } else {
              {
#line 3938
              tmp___12 = strcmp((char const   *)walker->key, "image");
              }
#line 3938
              if (tmp___12 == 0) {
#line 3939
                if (stream) {
#line 3939
                  tmp___8 = stream;
                } else {
#line 3939
                  tmp___8 = stdout;
                }
                {
#line 3939
                tmp___9 = fwrite((void const   */* __restrict  */)walker->value.u_blo.ptr,
                                 walker->value.u_blo.size, (size_t )1, (FILE */* __restrict  */)tmp___8);
                }
#line 3939
                if (tmp___9 == 0UL) {
#line 3939
                  if (stream) {
#line 3939
                    tmp___10 = stream;
                  } else {
#line 3939
                    tmp___10 = stdout;
                  }
                  {
#line 3939
                  tmp___11 = ferror(tmp___10);
                  }
#line 3939
                  if (tmp___11) {
                    {
#line 3941
                    rrd_set_error((char *)"writing image");
                    }
#line 3942
                    return (0);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 3946
    walker = walker->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3948
  rrd_info_free(grinfo);
  }
#line 3949
  return (0);
}
}
#line 3959 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
rrd_info_t *rrd_graph_v(int argc , char **argv ) 
{ 
  image_desc_t im ;
  rrd_info_t *grinfo ;
  char *old_locale ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  rrd_infoval_t info ;
  char *path ;
  char *filename ;
  char *tmp___4 ;
  rrd_infoval_t img ;
  char *tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 3966
  rrd_graph_init(& im);
#line 3968
  old_locale = setlocale(1, (char const   *)((void *)0));
#line 3969
  setlocale(1, "C");
#line 3970
  rrd_graph_options(argc, argv, & im);
#line 3971
  tmp = rrd_test_error();
  }
#line 3971
  if (tmp) {
    {
#line 3972
    rrd_info_free(im.grinfo);
#line 3973
    im_free(& im);
    }
#line 3974
    return ((rrd_info_t *)((void *)0));
  }
#line 3977
  if (optind >= argc) {
    {
#line 3978
    rrd_info_free(im.grinfo);
#line 3979
    im_free(& im);
#line 3980
    rrd_set_error((char *)"missing filename");
    }
#line 3981
    return ((rrd_info_t *)((void *)0));
  }
  {
#line 3984
  tmp___0 = strlen((char const   *)*(argv + optind));
  }
#line 3984
  if (tmp___0 >= 4096UL) {
    {
#line 3985
    rrd_set_error((char *)"filename (including path) too long");
#line 3986
    rrd_info_free(im.grinfo);
#line 3987
    im_free(& im);
    }
#line 3988
    return ((rrd_info_t *)((void *)0));
  }
  {
#line 3991
  strncpy((char */* __restrict  */)(im.graphfile), (char const   */* __restrict  */)*(argv + optind),
          (size_t )4095);
#line 3992
  im.graphfile[4095] = (char )'\000';
#line 3994
  tmp___1 = strcmp((char const   *)(im.graphfile), "-");
  }
#line 3994
  if (tmp___1 == 0) {
#line 3995
    im.graphfile[0] = (char )'\000';
  }
  {
#line 3998
  rrd_graph_script(argc, argv, & im, 1);
#line 3999
  setlocale(1, (char const   *)old_locale);
#line 4001
  tmp___2 = rrd_test_error();
  }
#line 4001
  if (tmp___2) {
    {
#line 4002
    rrd_info_free(im.grinfo);
#line 4003
    im_free(& im);
    }
#line 4004
    return ((rrd_info_t *)((void *)0));
  }
  {
#line 4009
  tmp___3 = graph_paint(& im);
  }
#line 4009
  if (tmp___3 == -1) {
    {
#line 4010
    rrd_info_free(im.grinfo);
#line 4011
    im_free(& im);
    }
#line 4012
    return ((rrd_info_t *)((void *)0));
  }
#line 4020
  if (im.imginfo) {
    {
#line 4025
    path = strdup((char const   *)(im.graphfile));
#line 4026
    filename = __xpg_basename(path);
#line 4027
    info.u_str = sprintf_alloc(im.imginfo, filename, (long )(im.zoom * (double )im.ximg),
                               (long )(im.zoom * (double )im.yimg));
#line 4032
    tmp___4 = sprintf_alloc((char *)"image_info");
#line 4032
    grinfo_push(& im, tmp___4, (rrd_info_type_t )2, info);
#line 4033
    free((void *)info.u_str);
#line 4034
    free((void *)path);
    }
  }
#line 4036
  if (im.rendered_image) {
    {
#line 4039
    img.u_blo.size = im.rendered_image_size;
#line 4040
    img.u_blo.ptr = im.rendered_image;
#line 4041
    tmp___5 = sprintf_alloc((char *)"image");
#line 4041
    grinfo_push(& im, tmp___5, (rrd_info_type_t )4, img);
    }
  }
  {
#line 4043
  grinfo = im.grinfo;
#line 4044
  im_free(& im);
  }
#line 4045
  return (grinfo);
}
}
#line 4048 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
static void rrd_set_font_desc(image_desc_t *im , int prop , char *font , double size ) 
{ 


  {
#line 4051
  if (font) {
    {
#line 4052
    strncpy((char */* __restrict  */)(im->text_prop[prop].font), (char const   */* __restrict  */)font,
            sizeof(text_prop[prop].font) - 1UL);
#line 4053
    im->text_prop[prop].font[sizeof(text_prop[prop].font) - 1UL] = (char )'\000';
#line 4055
    pango_font_description_free(im->text_prop[prop].font_desc);
#line 4056
    im->text_prop[prop].font_desc = pango_font_description_from_string((char const   *)font);
    }
  }
#line 4058
  if (size > (double )0) {
#line 4059
    im->text_prop[prop].size = size;
  }
#line 4061
  if (im->text_prop[prop].font_desc) {
#line 4061
    if (im->text_prop[prop].size) {
      {
#line 4062
      pango_font_description_set_size(im->text_prop[prop].font_desc, (gint )(im->text_prop[prop].size * (double )1024));
      }
    }
  }
#line 4064
  return;
}
}
#line 4072 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
static PangoFontMap *fontmap  =    (PangoFontMap *)((void *)0);
#line 4066 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void rrd_graph_init(image_desc_t *im ) 
{ 
  unsigned int i ;
  char *deffont ;
  char *tmp ;
  PangoContext *context ;
  char *tmp___0 ;
  PangoContext __attribute__((__deprecated__("Use \'pango_font_map_create_context\' instead")))  *tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 4071
  tmp = getenv("RRD_DEFAULT_FONT");
#line 4071
  deffont = tmp;
#line 4076
  tzset();
#line 4078
  im->gdef_map = g_hash_table_new_full(& g_str_hash, & g_str_equal, & g_free, (void (*)(gpointer data ))((void *)0));
#line 4079
  im->rrd_map = g_hash_table_new_full(& g_str_hash, & g_str_equal, & g_free, (void (*)(gpointer data ))((void *)0));
#line 4080
  im->base = 1000L;
#line 4081
  im->daemon_addr = (char *)((void *)0);
#line 4082
  im->draw_x_grid = 1;
#line 4083
  im->draw_y_grid = 1;
#line 4084
  im->draw_3d_border = 2U;
#line 4085
  im->dynamic_labels = 0U;
#line 4086
  im->extra_flags = 0;
#line 4087
  im->font_options = cairo_font_options_create();
#line 4088
  im->forceleftspace = 0;
#line 4089
  im->gdes_c = 0L;
#line 4090
  im->gdes = (graph_desc_t *)((void *)0);
#line 4091
  im->graph_antialias = (cairo_antialias_t )2;
#line 4092
  im->grid_dash_off = (double )1;
#line 4093
  im->grid_dash_on = (double )1;
#line 4094
  im->gridfit = 1;
#line 4095
  im->grinfo = (rrd_info_t *)((void *)0);
#line 4096
  im->grinfo_current = (rrd_info_t *)((void *)0);
#line 4097
  im->imgformat = (enum gfx_if_en )0;
#line 4098
  im->imginfo = (char *)((void *)0);
#line 4099
  im->lazy = 0;
#line 4100
  im->legenddirection = (enum legend_direction )0;
#line 4101
  im->legendheight = 0L;
#line 4102
  im->legendposition = (enum legend_pos )2;
#line 4103
  im->legendwidth = 0L;
#line 4104
  im->logarithmic = 0;
#line 4105
  im->maxval = rrd_set_to_DNAN();
#line 4106
  im->minval = (rrd_value_t )0;
#line 4107
  im->minval = rrd_set_to_DNAN();
#line 4108
  im->magfact = (double )1;
#line 4109
  im->prt_c = 0L;
#line 4110
  im->rigid = 0;
#line 4111
  im->rendered_image_size = (size_t )0;
#line 4112
  im->rendered_image = (unsigned char *)((void *)0);
#line 4113
  im->slopemode = 0;
#line 4114
  im->step = 0UL;
#line 4115
  im->symbol = (char )' ';
#line 4116
  im->tabwidth = 40.0;
#line 4117
  im->title[0] = (char )'\000';
#line 4118
  im->unitsexponent = 9999;
#line 4119
  im->unitslength = 6;
#line 4120
  im->viewfactor = (float )1.0;
#line 4121
  im->watermark[0] = (char )'\000';
#line 4122
  im->with_markup = 0;
#line 4123
  im->ximg = 0L;
#line 4124
  im->xlab_user.minsec = -1L;
#line 4125
  im->xorigin = 0L;
#line 4126
  im->xOriginLegend = 0L;
#line 4127
  im->xOriginLegendY = 0L;
#line 4128
  im->xOriginLegendY2 = 0L;
#line 4129
  im->xOriginTitle = 0L;
#line 4130
  im->xsize = 400L;
#line 4131
  im->ygridstep = rrd_set_to_DNAN();
#line 4132
  im->yimg = 0L;
#line 4133
  im->ylegend[0] = (char )'\000';
#line 4134
  im->second_axis_scale = (double )0;
#line 4135
  im->second_axis_shift = (double )0;
#line 4136
  im->second_axis_legend[0] = (char )'\000';
#line 4137
  im->second_axis_format[0] = (char )'\000';
#line 4138
  im->yorigin = 0L;
#line 4139
  im->yOriginLegend = 0L;
#line 4140
  im->yOriginLegendY = 0L;
#line 4141
  im->yOriginLegendY2 = 0L;
#line 4142
  im->yOriginTitle = 0L;
#line 4143
  im->ysize = 100L;
#line 4144
  im->zoom = (double )1;
#line 4146
  im->surface = cairo_image_surface_create((cairo_format_t )0, 10, 10);
#line 4147
  im->cr = cairo_create(im->surface);
#line 4149
  i = 0U;
  }
  {
#line 4149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4149
    if (! ((unsigned long )i < sizeof(text_prop) / sizeof(text_prop[0]))) {
#line 4149
      goto while_break;
    }
#line 4150
    im->text_prop[i].size = (double )-1;
#line 4151
    im->text_prop[i].font_desc = (PangoFontDescription *)((void *)0);
#line 4152
    if (deffont) {
#line 4152
      tmp___0 = deffont;
    } else {
#line 4152
      tmp___0 = text_prop[i].font;
    }
    {
#line 4152
    rrd_set_font_desc(im, (int )i, tmp___0, text_prop[i].size);
#line 4149
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4155
  if ((unsigned long )fontmap == (unsigned long )((void *)0)) {
    {
#line 4156
    fontmap = pango_cairo_font_map_get_default();
    }
  }
  {
#line 4159
  tmp___1 = pango_cairo_font_map_create_context((PangoCairoFontMap *)fontmap);
#line 4159
  context = (PangoContext *)tmp___1;
#line 4161
  pango_cairo_context_set_resolution(context, (double )100);
#line 4163
  pango_cairo_update_context(im->cr, context);
#line 4165
  im->layout = pango_layout_new(context);
#line 4166
  g_object_unref((gpointer )context);
#line 4171
  cairo_font_options_set_hint_style(im->font_options, (cairo_hint_style_t )4);
#line 4173
  cairo_font_options_set_hint_metrics(im->font_options, (cairo_hint_metrics_t )2);
#line 4175
  cairo_font_options_set_antialias(im->font_options, (cairo_antialias_t )2);
#line 4179
  i = 0U;
  }
  {
#line 4179
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4179
    if (! ((unsigned long )i < sizeof(graph_col) / sizeof(graph_col[0]))) {
#line 4179
      goto while_break___0;
    }
#line 4180
    im->graph_col[i] = graph_col[i];
#line 4179
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4183
  return;
}
}
#line 4186 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void rrd_graph_options(int argc , char **argv , image_desc_t *im ) 
{ 
  int stroff ;
  char *parsetime_error ;
  char scan_gtm[12] ;
  char scan_mtm[12] ;
  char scan_ltm[12] ;
  char col_nam[12] ;
  time_t start_tmp ;
  time_t end_tmp ;
  long long_tmp ;
  rrd_time_value_t start_tv ;
  rrd_time_value_t end_tv ;
  unsigned long color ;
  struct option long_options___5[53] ;
  int option_index ;
  int opt ;
  int col_start ;
  int col_end ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  enum tmt_en tmp___8 ;
  enum tmt_en tmp___9 ;
  enum tmt_en tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  enum gfx_if_en tmp___18 ;
  int ci ;
  int col_len ;
  enum grc_en tmp___19 ;
  int tmp___20 ;
  char prop[15] ;
  double size ;
  int end ;
  int sindex ;
  int propidx ;
  size_t tmp___21 ;
  enum text_prop_en tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int status ;
  int tmp___29 ;
  PangoContext *tmp___30 ;
  int tmp___31 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  int __cil_tmp67 ;
  void *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;

  {
  {
#line 4193
  parsetime_error = (char *)((void *)0);
#line 4195
  start_tmp = (time_t )0;
#line 4195
  end_tmp = (time_t )0;
#line 4205
  long_options___5[0].name = "alt-autoscale";
#line 4205
  long_options___5[0].has_arg = 0;
#line 4205
  long_options___5[0].flag = (int *)0;
#line 4205
  long_options___5[0].val = 'A';
#line 4205
  long_options___5[1].name = "imgformat";
#line 4205
  long_options___5[1].has_arg = 1;
#line 4205
  long_options___5[1].flag = (int *)0;
#line 4205
  long_options___5[1].val = 'a';
#line 4205
  long_options___5[2].name = "font-smoothing-threshold";
#line 4205
  long_options___5[2].has_arg = 1;
#line 4205
  long_options___5[2].flag = (int *)0;
#line 4205
  long_options___5[2].val = 'B';
#line 4205
  long_options___5[3].name = "base";
#line 4205
  long_options___5[3].has_arg = 1;
#line 4205
  long_options___5[3].flag = (int *)0;
#line 4205
  long_options___5[3].val = 'b';
#line 4205
  long_options___5[4].name = "color";
#line 4205
  long_options___5[4].has_arg = 1;
#line 4205
  long_options___5[4].flag = (int *)0;
#line 4205
  long_options___5[4].val = 'c';
#line 4205
  long_options___5[5].name = "full-size-mode";
#line 4205
  long_options___5[5].has_arg = 0;
#line 4205
  long_options___5[5].flag = (int *)0;
#line 4205
  long_options___5[5].val = 'D';
#line 4205
  long_options___5[6].name = "daemon";
#line 4205
  long_options___5[6].has_arg = 1;
#line 4205
  long_options___5[6].flag = (int *)0;
#line 4205
  long_options___5[6].val = 'd';
#line 4205
  long_options___5[7].name = "slope-mode";
#line 4205
  long_options___5[7].has_arg = 0;
#line 4205
  long_options___5[7].flag = (int *)0;
#line 4205
  long_options___5[7].val = 'E';
#line 4205
  long_options___5[8].name = "end";
#line 4205
  long_options___5[8].has_arg = 1;
#line 4205
  long_options___5[8].flag = (int *)0;
#line 4205
  long_options___5[8].val = 'e';
#line 4205
  long_options___5[9].name = "force-rules-legend";
#line 4205
  long_options___5[9].has_arg = 0;
#line 4205
  long_options___5[9].flag = (int *)0;
#line 4205
  long_options___5[9].val = 'F';
#line 4205
  long_options___5[10].name = "imginfo";
#line 4205
  long_options___5[10].has_arg = 1;
#line 4205
  long_options___5[10].flag = (int *)0;
#line 4205
  long_options___5[10].val = 'f';
#line 4205
  long_options___5[11].name = "graph-render-mode";
#line 4205
  long_options___5[11].has_arg = 1;
#line 4205
  long_options___5[11].flag = (int *)0;
#line 4205
  long_options___5[11].val = 'G';
#line 4205
  long_options___5[12].name = "no-legend";
#line 4205
  long_options___5[12].has_arg = 0;
#line 4205
  long_options___5[12].flag = (int *)0;
#line 4205
  long_options___5[12].val = 'g';
#line 4205
  long_options___5[13].name = "height";
#line 4205
  long_options___5[13].has_arg = 1;
#line 4205
  long_options___5[13].flag = (int *)0;
#line 4205
  long_options___5[13].val = 'h';
#line 4205
  long_options___5[14].name = "no-minor";
#line 4205
  long_options___5[14].has_arg = 0;
#line 4205
  long_options___5[14].flag = (int *)0;
#line 4205
  long_options___5[14].val = 'I';
#line 4205
  long_options___5[15].name = "interlaced";
#line 4205
  long_options___5[15].has_arg = 0;
#line 4205
  long_options___5[15].flag = (int *)0;
#line 4205
  long_options___5[15].val = 'i';
#line 4205
  long_options___5[16].name = "alt-autoscale-min";
#line 4205
  long_options___5[16].has_arg = 0;
#line 4205
  long_options___5[16].flag = (int *)0;
#line 4205
  long_options___5[16].val = 'J';
#line 4205
  long_options___5[17].name = "only-graph";
#line 4205
  long_options___5[17].has_arg = 0;
#line 4205
  long_options___5[17].flag = (int *)0;
#line 4205
  long_options___5[17].val = 'j';
#line 4205
  long_options___5[18].name = "units-length";
#line 4205
  long_options___5[18].has_arg = 1;
#line 4205
  long_options___5[18].flag = (int *)0;
#line 4205
  long_options___5[18].val = 'L';
#line 4205
  long_options___5[19].name = "lower-limit";
#line 4205
  long_options___5[19].has_arg = 1;
#line 4205
  long_options___5[19].flag = (int *)0;
#line 4205
  long_options___5[19].val = 'l';
#line 4205
  long_options___5[20].name = "alt-autoscale-max";
#line 4205
  long_options___5[20].has_arg = 0;
#line 4205
  long_options___5[20].flag = (int *)0;
#line 4205
  long_options___5[20].val = 'M';
#line 4205
  long_options___5[21].name = "zoom";
#line 4205
  long_options___5[21].has_arg = 1;
#line 4205
  long_options___5[21].flag = (int *)0;
#line 4205
  long_options___5[21].val = 'm';
#line 4205
  long_options___5[22].name = "no-gridfit";
#line 4205
  long_options___5[22].has_arg = 0;
#line 4205
  long_options___5[22].flag = (int *)0;
#line 4205
  long_options___5[22].val = 'N';
#line 4205
  long_options___5[23].name = "font";
#line 4205
  long_options___5[23].has_arg = 1;
#line 4205
  long_options___5[23].flag = (int *)0;
#line 4205
  long_options___5[23].val = 'n';
#line 4205
  long_options___5[24].name = "logarithmic";
#line 4205
  long_options___5[24].has_arg = 0;
#line 4205
  long_options___5[24].flag = (int *)0;
#line 4205
  long_options___5[24].val = 'o';
#line 4205
  long_options___5[25].name = "pango-markup";
#line 4205
  long_options___5[25].has_arg = 0;
#line 4205
  long_options___5[25].flag = (int *)0;
#line 4205
  long_options___5[25].val = 'P';
#line 4205
  long_options___5[26].name = "font-render-mode";
#line 4205
  long_options___5[26].has_arg = 1;
#line 4205
  long_options___5[26].flag = (int *)0;
#line 4205
  long_options___5[26].val = 'R';
#line 4205
  long_options___5[27].name = "rigid";
#line 4205
  long_options___5[27].has_arg = 0;
#line 4205
  long_options___5[27].flag = (int *)0;
#line 4205
  long_options___5[27].val = 'r';
#line 4205
  long_options___5[28].name = "step";
#line 4205
  long_options___5[28].has_arg = 1;
#line 4205
  long_options___5[28].flag = (int *)0;
#line 4205
  long_options___5[28].val = 'S';
#line 4205
  long_options___5[29].name = "start";
#line 4205
  long_options___5[29].has_arg = 1;
#line 4205
  long_options___5[29].flag = (int *)0;
#line 4205
  long_options___5[29].val = 's';
#line 4205
  long_options___5[30].name = "tabwidth";
#line 4205
  long_options___5[30].has_arg = 1;
#line 4205
  long_options___5[30].flag = (int *)0;
#line 4205
  long_options___5[30].val = 'T';
#line 4205
  long_options___5[31].name = "title";
#line 4205
  long_options___5[31].has_arg = 1;
#line 4205
  long_options___5[31].flag = (int *)0;
#line 4205
  long_options___5[31].val = 't';
#line 4205
  long_options___5[32].name = "upper-limit";
#line 4205
  long_options___5[32].has_arg = 1;
#line 4205
  long_options___5[32].flag = (int *)0;
#line 4205
  long_options___5[32].val = 'u';
#line 4205
  long_options___5[33].name = "vertical-label";
#line 4205
  long_options___5[33].has_arg = 1;
#line 4205
  long_options___5[33].flag = (int *)0;
#line 4205
  long_options___5[33].val = 'v';
#line 4205
  long_options___5[34].name = "watermark";
#line 4205
  long_options___5[34].has_arg = 1;
#line 4205
  long_options___5[34].flag = (int *)0;
#line 4205
  long_options___5[34].val = 'W';
#line 4205
  long_options___5[35].name = "width";
#line 4205
  long_options___5[35].has_arg = 1;
#line 4205
  long_options___5[35].flag = (int *)0;
#line 4205
  long_options___5[35].val = 'w';
#line 4205
  long_options___5[36].name = "units-exponent";
#line 4205
  long_options___5[36].has_arg = 1;
#line 4205
  long_options___5[36].flag = (int *)0;
#line 4205
  long_options___5[36].val = 'X';
#line 4205
  long_options___5[37].name = "x-grid";
#line 4205
  long_options___5[37].has_arg = 1;
#line 4205
  long_options___5[37].flag = (int *)0;
#line 4205
  long_options___5[37].val = 'x';
#line 4205
  long_options___5[38].name = "alt-y-grid";
#line 4205
  long_options___5[38].has_arg = 0;
#line 4205
  long_options___5[38].flag = (int *)0;
#line 4205
  long_options___5[38].val = 'Y';
#line 4205
  long_options___5[39].name = "y-grid";
#line 4205
  long_options___5[39].has_arg = 1;
#line 4205
  long_options___5[39].flag = (int *)0;
#line 4205
  long_options___5[39].val = 'y';
#line 4205
  long_options___5[40].name = "lazy";
#line 4205
  long_options___5[40].has_arg = 0;
#line 4205
  long_options___5[40].flag = (int *)0;
#line 4205
  long_options___5[40].val = 'z';
#line 4205
  long_options___5[41].name = "units";
#line 4205
  long_options___5[41].has_arg = 1;
#line 4205
  long_options___5[41].flag = (int *)0;
#line 4205
  long_options___5[41].val = 255;
#line 4205
  long_options___5[42].name = "alt-y-mrtg";
#line 4205
  long_options___5[42].has_arg = 0;
#line 4205
  long_options___5[42].flag = (int *)0;
#line 4205
  long_options___5[42].val = 1000;
#line 4205
  long_options___5[43].name = "disable-rrdtool-tag";
#line 4205
  long_options___5[43].has_arg = 0;
#line 4205
  long_options___5[43].flag = (int *)0;
#line 4205
  long_options___5[43].val = 1001;
#line 4205
  long_options___5[44].name = "right-axis";
#line 4205
  long_options___5[44].has_arg = 1;
#line 4205
  long_options___5[44].flag = (int *)0;
#line 4205
  long_options___5[44].val = 1002;
#line 4205
  long_options___5[45].name = "right-axis-label";
#line 4205
  long_options___5[45].has_arg = 1;
#line 4205
  long_options___5[45].flag = (int *)0;
#line 4205
  long_options___5[45].val = 1003;
#line 4205
  long_options___5[46].name = "right-axis-format";
#line 4205
  long_options___5[46].has_arg = 1;
#line 4205
  long_options___5[46].flag = (int *)0;
#line 4205
  long_options___5[46].val = 1004;
#line 4205
  long_options___5[47].name = "legend-position";
#line 4205
  long_options___5[47].has_arg = 1;
#line 4205
  long_options___5[47].flag = (int *)0;
#line 4205
  long_options___5[47].val = 1005;
#line 4205
  long_options___5[48].name = "legend-direction";
#line 4205
  long_options___5[48].has_arg = 1;
#line 4205
  long_options___5[48].flag = (int *)0;
#line 4205
  long_options___5[48].val = 1006;
#line 4205
  long_options___5[49].name = "border";
#line 4205
  long_options___5[49].has_arg = 1;
#line 4205
  long_options___5[49].flag = (int *)0;
#line 4205
  long_options___5[49].val = 1007;
#line 4205
  long_options___5[50].name = "grid-dash";
#line 4205
  long_options___5[50].has_arg = 1;
#line 4205
  long_options___5[50].flag = (int *)0;
#line 4205
  long_options___5[50].val = 1008;
#line 4205
  long_options___5[51].name = "dynamic-labels";
#line 4205
  long_options___5[51].has_arg = 0;
#line 4205
  long_options___5[51].flag = (int *)0;
#line 4205
  long_options___5[51].val = 1009;
#line 4205
  long_options___5[52].name = (char const   *)0;
#line 4205
  long_options___5[52].has_arg = 0;
#line 4205
  long_options___5[52].flag = (int *)0;
#line 4205
  long_options___5[52].val = 0;
#line 4262
  optind = 0;
#line 4263
  opterr = 0;
#line 4264
  rrd_parsetime("end-24h", & start_tv);
#line 4265
  rrd_parsetime("now", & end_tv);
  }
  {
#line 4266
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4267
    option_index = 0;
#line 4271
    opt = getopt_long(argc, (char * const  *)argv, "Aa:B:b:c:Dd:Ee:Ff:G:gh:IiJjL:l:Mm:Nn:oPR:rS:s:T:t:u:v:W:w:X:x:Yy:z",
                      (struct option  const  *)(long_options___5), & option_index);
    }
#line 4274
    if (opt == -1) {
#line 4275
      goto while_break;
    }
    {
#line 4277
    if (opt == 73) {
#line 4277
      goto case_73;
    }
#line 4280
    if (opt == 89) {
#line 4280
      goto case_89;
    }
#line 4283
    if (opt == 65) {
#line 4283
      goto case_65;
    }
#line 4286
    if (opt == 74) {
#line 4286
      goto case_74;
    }
#line 4289
    if (opt == 77) {
#line 4289
      goto case_77;
    }
#line 4292
    if (opt == 106) {
#line 4292
      goto case_106;
    }
#line 4295
    if (opt == 103) {
#line 4295
      goto case_103;
    }
#line 4298
    if (opt == 1005) {
#line 4298
      goto case_1005;
    }
#line 4312
    if (opt == 1006) {
#line 4312
      goto case_1006;
    }
#line 4322
    if (opt == 70) {
#line 4322
      goto case_70;
    }
#line 4325
    if (opt == 1001) {
#line 4325
      goto case_1001;
    }
#line 4328
    if (opt == 255) {
#line 4328
      goto case_255;
    }
#line 4340
    if (opt == 88) {
#line 4340
      goto case_88;
    }
#line 4343
    if (opt == 76) {
#line 4343
      goto case_76;
    }
#line 4347
    if (opt == 84) {
#line 4347
      goto case_84;
    }
#line 4350
    if (opt == 83) {
#line 4350
      goto case_83;
    }
#line 4353
    if (opt == 78) {
#line 4353
      goto case_78;
    }
#line 4356
    if (opt == 80) {
#line 4356
      goto case_80;
    }
#line 4359
    if (opt == 115) {
#line 4359
      goto case_115;
    }
#line 4365
    if (opt == 101) {
#line 4365
      goto case_101;
    }
#line 4371
    if (opt == 120) {
#line 4371
      goto case_120;
    }
#line 4409
    if (opt == 121) {
#line 4409
      goto case_121;
    }
#line 4428
    if (opt == 1007) {
#line 4428
      goto case_1007;
    }
#line 4431
    if (opt == 1008) {
#line 4431
      goto case_1008;
    }
#line 4440
    if (opt == 1009) {
#line 4440
      goto case_1009;
    }
#line 4443
    if (opt == 1002) {
#line 4443
      goto case_1002;
    }
#line 4458
    if (opt == 1003) {
#line 4458
      goto case_1003;
    }
#line 4462
    if (opt == 1004) {
#line 4462
      goto case_1004;
    }
#line 4470
    if (opt == 118) {
#line 4470
      goto case_118;
    }
#line 4474
    if (opt == 117) {
#line 4474
      goto case_117;
    }
#line 4477
    if (opt == 108) {
#line 4477
      goto case_108;
    }
#line 4480
    if (opt == 98) {
#line 4480
      goto case_98;
    }
#line 4488
    if (opt == 119) {
#line 4488
      goto case_119;
    }
#line 4496
    if (opt == 104) {
#line 4496
      goto case_104;
    }
#line 4504
    if (opt == 68) {
#line 4504
      goto case_68;
    }
#line 4507
    if (opt == 105) {
#line 4507
      goto case_105;
    }
#line 4510
    if (opt == 114) {
#line 4510
      goto case_114;
    }
#line 4513
    if (opt == 102) {
#line 4513
      goto case_102;
    }
#line 4516
    if (opt == 97) {
#line 4516
      goto case_97;
    }
#line 4523
    if (opt == 122) {
#line 4523
      goto case_122;
    }
#line 4526
    if (opt == 69) {
#line 4526
      goto case_69;
    }
#line 4529
    if (opt == 111) {
#line 4529
      goto case_111;
    }
#line 4532
    if (opt == 99) {
#line 4532
      goto case_99;
    }
#line 4578
    if (opt == 110) {
#line 4578
      goto case_110;
    }
#line 4617
    if (opt == 109) {
#line 4617
      goto case_109;
    }
#line 4624
    if (opt == 116) {
#line 4624
      goto case_116;
    }
#line 4628
    if (opt == 82) {
#line 4628
      goto case_82;
    }
#line 4649
    if (opt == 71) {
#line 4649
      goto case_71;
    }
#line 4659
    if (opt == 66) {
#line 4659
      goto case_66;
    }
#line 4662
    if (opt == 87) {
#line 4662
      goto case_87;
    }
#line 4666
    if (opt == 100) {
#line 4666
      goto case_100;
    }
#line 4684
    if (opt == 63) {
#line 4684
      goto case_63;
    }
#line 4276
    goto switch_break;
    case_73: /* CIL Label */ 
#line 4278
    im->extra_flags |= 32;
#line 4279
    goto switch_break;
    case_89: /* CIL Label */ 
#line 4281
    im->extra_flags |= 1;
#line 4282
    goto switch_break;
    case_65: /* CIL Label */ 
#line 4284
    im->extra_flags |= 2;
#line 4285
    goto switch_break;
    case_74: /* CIL Label */ 
#line 4287
    im->extra_flags |= 4;
#line 4288
    goto switch_break;
    case_77: /* CIL Label */ 
#line 4290
    im->extra_flags |= 8;
#line 4291
    goto switch_break;
    case_106: /* CIL Label */ 
#line 4293
    im->extra_flags |= 64;
#line 4294
    goto switch_break;
    case_103: /* CIL Label */ 
#line 4296
    im->extra_flags |= 16;
#line 4297
    goto switch_break;
    case_1005: /* CIL Label */ 
    {
#line 4299
    tmp___2 = strcmp((char const   *)optarg, "north");
    }
#line 4299
    if (tmp___2 == 0) {
#line 4300
      im->legendposition = (enum legend_pos )0;
    } else {
      {
#line 4301
      tmp___1 = strcmp((char const   *)optarg, "west");
      }
#line 4301
      if (tmp___1 == 0) {
#line 4302
        im->legendposition = (enum legend_pos )1;
      } else {
        {
#line 4303
        tmp___0 = strcmp((char const   *)optarg, "south");
        }
#line 4303
        if (tmp___0 == 0) {
#line 4304
          im->legendposition = (enum legend_pos )2;
        } else {
          {
#line 4305
          tmp = strcmp((char const   *)optarg, "east");
          }
#line 4305
          if (tmp == 0) {
#line 4306
            im->legendposition = (enum legend_pos )3;
          } else {
            {
#line 4308
            rrd_set_error((char *)"unknown legend-position \'%s\'", optarg);
            }
#line 4309
            return;
          }
        }
      }
    }
#line 4311
    goto switch_break;
    case_1006: /* CIL Label */ 
    {
#line 4313
    tmp___4 = strcmp((char const   *)optarg, "topdown");
    }
#line 4313
    if (tmp___4 == 0) {
#line 4314
      im->legenddirection = (enum legend_direction )0;
    } else {
      {
#line 4315
      tmp___3 = strcmp((char const   *)optarg, "bottomup");
      }
#line 4315
      if (tmp___3 == 0) {
#line 4316
        im->legenddirection = (enum legend_direction )1;
      } else {
        {
#line 4318
        rrd_set_error((char *)"unknown legend-position \'%s\'", optarg);
        }
#line 4319
        return;
      }
    }
#line 4321
    goto switch_break;
    case_70: /* CIL Label */ 
#line 4323
    im->extra_flags |= 128;
#line 4324
    goto switch_break;
    case_1001: /* CIL Label */ 
#line 4326
    im->extra_flags |= 1024;
#line 4327
    goto switch_break;
    case_255: /* CIL Label */ 
#line 4329
    if (im->extra_flags & 256) {
      {
#line 4330
      rrd_set_error((char *)"--units can only be used once!");
      }
#line 4331
      return;
    }
    {
#line 4333
    tmp___5 = strcmp((char const   *)optarg, "si");
    }
#line 4333
    if (tmp___5 == 0) {
#line 4334
      im->extra_flags |= 256;
    } else {
      {
#line 4336
      rrd_set_error((char *)"invalid argument for --units: %s", optarg);
      }
#line 4337
      return;
    }
#line 4339
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 4341
    im->unitsexponent = atoi((char const   *)optarg);
    }
#line 4342
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 4344
    im->unitslength = atoi((char const   *)optarg);
#line 4345
    im->forceleftspace = 1;
    }
#line 4346
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 4348
    im->tabwidth = atof((char const   *)optarg);
    }
#line 4349
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 4351
    tmp___6 = atoi((char const   *)optarg);
#line 4351
    im->step = (unsigned long )tmp___6;
    }
#line 4352
    goto switch_break;
    case_78: /* CIL Label */ 
#line 4354
    im->gridfit = 0;
#line 4355
    goto switch_break;
    case_80: /* CIL Label */ 
#line 4357
    im->with_markup = 1;
#line 4358
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 4360
    parsetime_error = rrd_parsetime((char const   *)optarg, & start_tv);
    }
#line 4360
    if (parsetime_error) {
      {
#line 4361
      rrd_set_error((char *)"start time: %s", parsetime_error);
      }
#line 4362
      return;
    }
#line 4364
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 4366
    parsetime_error = rrd_parsetime((char const   *)optarg, & end_tv);
    }
#line 4366
    if (parsetime_error) {
      {
#line 4367
      rrd_set_error((char *)"end time: %s", parsetime_error);
      }
#line 4368
      return;
    }
#line 4370
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 4372
    tmp___7 = strcmp((char const   *)optarg, "none");
    }
#line 4372
    if (tmp___7 == 0) {
#line 4373
      im->draw_x_grid = 0;
#line 4374
      goto switch_break;
    }
    {
#line 4376
    tmp___11 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%10[A-Z]:%ld:%10[A-Z]:%ld:%10[A-Z]:%ld:%ld:%n",
                      scan_gtm, & im->xlab_user.gridst, scan_mtm, & im->xlab_user.mgridst,
                      scan_ltm, & im->xlab_user.labst, & im->xlab_user.precis, & stroff);
    }
#line 4376
    if (tmp___11 == 7) {
#line 4376
      if (stroff != 0) {
        {
#line 4385
        strncpy((char */* __restrict  */)(im->xlab_form), (char const   */* __restrict  */)(optarg + stroff),
                sizeof(im->xlab_form) - 1UL);
#line 4387
        im->xlab_form[sizeof(im->xlab_form) - 1UL] = (char )'\000';
#line 4388
        tmp___10 = tmt_conv(scan_gtm);
#line 4388
        im->xlab_user.gridtm = tmp___10;
        }
#line 4388
        if ((int )tmp___10 == -1) {
          {
#line 4390
          rrd_set_error((char *)"unknown keyword %s", scan_gtm);
          }
#line 4391
          return;
        } else {
          {
#line 4392
          tmp___9 = tmt_conv(scan_mtm);
#line 4392
          im->xlab_user.mgridtm = tmp___9;
          }
#line 4392
          if ((int )tmp___9 == -1) {
            {
#line 4395
            rrd_set_error((char *)"unknown keyword %s", scan_mtm);
            }
#line 4396
            return;
          } else {
            {
#line 4397
            tmp___8 = tmt_conv(scan_ltm);
#line 4397
            im->xlab_user.labtm = tmp___8;
            }
#line 4397
            if ((int )tmp___8 == -1) {
              {
#line 4399
              rrd_set_error((char *)"unknown keyword %s", scan_ltm);
              }
#line 4400
              return;
            }
          }
        }
#line 4402
        im->xlab_user.minsec = 1L;
#line 4403
        im->xlab_user.stst = im->xlab_form;
      } else {
        {
#line 4405
        rrd_set_error((char *)"invalid x-grid format");
        }
#line 4406
        return;
      }
    } else {
      {
#line 4405
      rrd_set_error((char *)"invalid x-grid format");
      }
#line 4406
      return;
    }
#line 4408
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 4411
    tmp___12 = strcmp((char const   *)optarg, "none");
    }
#line 4411
    if (tmp___12 == 0) {
#line 4412
      im->draw_y_grid = 0;
#line 4413
      goto switch_break;
    }
    {
#line 4415
    tmp___13 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%lf:%d",
                      & im->ygridstep, & im->ylabfact);
    }
#line 4415
    if (tmp___13 == 2) {
#line 4416
      if (im->ygridstep <= (double )0) {
        {
#line 4417
        rrd_set_error((char *)"grid step must be > 0");
        }
#line 4418
        return;
      } else
#line 4419
      if (im->ylabfact < 1) {
        {
#line 4420
        rrd_set_error((char *)"label factor must be > 0");
        }
#line 4421
        return;
      }
    } else {
      {
#line 4424
      rrd_set_error((char *)"invalid y-grid format");
      }
#line 4425
      return;
    }
#line 4427
    goto switch_break;
    case_1007: /* CIL Label */ 
    {
#line 4429
    tmp___14 = atoi((char const   *)optarg);
#line 4429
    im->draw_3d_border = (unsigned int )tmp___14;
    }
#line 4430
    goto switch_break;
    case_1008: /* CIL Label */ 
    {
#line 4432
    tmp___15 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%lf:%lf",
                      & im->grid_dash_on, & im->grid_dash_off);
    }
#line 4432
    if (tmp___15 != 2) {
      {
#line 4436
      rrd_set_error((char *)"expected grid-dash format float:float");
      }
#line 4437
      return;
    }
#line 4439
    goto switch_break;
    case_1009: /* CIL Label */ 
#line 4441
    im->dynamic_labels = 1U;
#line 4442
    goto switch_break;
    case_1002: /* CIL Label */ 
    {
#line 4445
    tmp___16 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%lf:%lf",
                      & im->second_axis_scale, & im->second_axis_shift);
    }
#line 4445
    if (tmp___16 == 2) {
#line 4449
      if (im->second_axis_scale == (double )0) {
        {
#line 4450
        rrd_set_error((char *)"the second_axis_scale  must not be 0");
        }
#line 4451
        return;
      }
    } else {
      {
#line 4454
      rrd_set_error((char *)"invalid right-axis format expected scale:shift");
      }
#line 4455
      return;
    }
#line 4457
    goto switch_break;
    case_1003: /* CIL Label */ 
    {
#line 4459
    strncpy((char */* __restrict  */)(im->second_axis_legend), (char const   */* __restrict  */)optarg,
            (size_t )150);
#line 4460
    im->second_axis_legend[150] = (char )'\000';
    }
#line 4461
    goto switch_break;
    case_1004: /* CIL Label */ 
    {
#line 4463
    tmp___17 = bad_format(optarg);
    }
#line 4463
    if (tmp___17) {
      {
#line 4464
      rrd_set_error((char *)"use either %le or %lf formats");
      }
#line 4465
      return;
    }
    {
#line 4467
    strncpy((char */* __restrict  */)(im->second_axis_format), (char const   */* __restrict  */)optarg,
            (size_t )150);
#line 4468
    im->second_axis_format[150] = (char )'\000';
    }
#line 4469
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 4471
    strncpy((char */* __restrict  */)(im->ylegend), (char const   */* __restrict  */)optarg,
            (size_t )150);
#line 4472
    im->ylegend[150] = (char )'\000';
    }
#line 4473
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 4475
    im->maxval = atof((char const   *)optarg);
    }
#line 4476
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 4478
    im->minval = atof((char const   *)optarg);
    }
#line 4479
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 4481
    im->base = atol((char const   *)optarg);
    }
#line 4482
    if (im->base != 1024L) {
#line 4482
      if (im->base != 1000L) {
        {
#line 4483
        rrd_set_error((char *)"the only sensible value for base apart from 1000 is 1024");
        }
#line 4485
        return;
      }
    }
#line 4487
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 4489
    long_tmp = atol((char const   *)optarg);
    }
#line 4490
    if (long_tmp < 10L) {
      {
#line 4491
      rrd_set_error((char *)"width below 10 pixels");
      }
#line 4492
      return;
    }
#line 4494
    im->xsize = long_tmp;
#line 4495
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 4497
    long_tmp = atol((char const   *)optarg);
    }
#line 4498
    if (long_tmp < 10L) {
      {
#line 4499
      rrd_set_error((char *)"height below 10 pixels");
      }
#line 4500
      return;
    }
#line 4502
    im->ysize = long_tmp;
#line 4503
    goto switch_break;
    case_68: /* CIL Label */ 
#line 4505
    im->extra_flags |= 512;
#line 4506
    goto switch_break;
    case_105: /* CIL Label */ 
#line 4509
    goto switch_break;
    case_114: /* CIL Label */ 
#line 4511
    im->rigid = 1;
#line 4512
    goto switch_break;
    case_102: /* CIL Label */ 
#line 4514
    im->imginfo = optarg;
#line 4515
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 4517
    tmp___18 = if_conv(optarg);
#line 4517
    im->imgformat = tmp___18;
    }
#line 4517
    if ((int )tmp___18 == -1) {
      {
#line 4519
      rrd_set_error((char *)"unsupported graphics format \'%s\'", optarg);
      }
#line 4520
      return;
    }
#line 4522
    goto switch_break;
    case_122: /* CIL Label */ 
#line 4524
    im->lazy = 1;
#line 4525
    goto switch_break;
    case_69: /* CIL Label */ 
#line 4527
    im->slopemode = 1;
#line 4528
    goto switch_break;
    case_111: /* CIL Label */ 
#line 4530
    im->logarithmic = 1;
#line 4531
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 4533
    tmp___20 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%10[A-Z]#%n%8lx%n",
                      col_nam, & col_start, & color, & col_end);
    }
#line 4533
    if (tmp___20 == 2) {
#line 4537
      col_len = col_end - col_start;
      {
#line 4540
      if (col_len == 3) {
#line 4540
        goto case_3;
      }
#line 4548
      if (col_len == 4) {
#line 4548
        goto case_4;
      }
#line 4558
      if (col_len == 6) {
#line 4558
        goto case_6;
      }
#line 4561
      if (col_len == 8) {
#line 4561
        goto case_8;
      }
#line 4563
      goto switch_default;
      case_3: /* CIL Label */ 
#line 4541
      color = (((color & 3840UL) * 1114112UL | (color & 240UL) * 69632UL) | (color & 15UL) * 4352UL) | 255UL;
#line 4547
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 4549
      color = (((color & 61440UL) * 69632UL | (color & 3840UL) * 4352UL) | (color & 240UL) * 272UL) | (color & 15UL) * 17UL;
#line 4557
      goto switch_break___0;
      case_6: /* CIL Label */ 
#line 4559
      color = (color << 8) + 255UL;
#line 4560
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 4562
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 4564
      rrd_set_error((char *)"the color format is #RRGGBB[AA]");
      }
#line 4565
      return;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 4567
      tmp___19 = grc_conv(col_nam);
#line 4567
      ci = (int )tmp___19;
      }
#line 4567
      if (ci != -1) {
        {
#line 4568
        im->graph_col[ci] = gfx_hex_to_col(color);
        }
      } else {
        {
#line 4570
        rrd_set_error((char *)"invalid color name \'%s\'", col_nam);
        }
#line 4571
        return;
      }
    } else {
      {
#line 4574
      rrd_set_error((char *)"invalid color def format");
      }
#line 4575
      return;
    }
#line 4577
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 4580
    size = (double )1;
#line 4583
    tmp___23 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%10[A-Z]:%lf%n",
                      prop, & size, & end);
    }
#line 4583
    if (tmp___23 >= 2) {
      {
#line 4586
      tmp___22 = text_prop_conv(prop);
#line 4586
      sindex = (int )tmp___22;
      }
#line 4586
      if (sindex != -1) {
#line 4587
        propidx = sindex;
        {
#line 4587
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4587
          if (! (propidx < 6)) {
#line 4587
            goto while_break___0;
          }
#line 4589
          if (size > (double )0) {
            {
#line 4590
            rrd_set_font_desc(im, propidx, (char *)((void *)0), size);
            }
          }
          {
#line 4592
          tmp___21 = strlen((char const   *)optarg);
          }
#line 4592
          if ((int )tmp___21 > end + 2) {
#line 4593
            if ((int )*(optarg + end) == 58) {
              {
#line 4594
              rrd_set_font_desc(im, propidx, (optarg + end) + 1, (double )0);
              }
            } else {
              {
#line 4596
              rrd_set_error((char *)"expected : after font size in \'%s\'", optarg);
              }
#line 4599
              return;
            }
          }
#line 4604
          if (propidx == sindex) {
#line 4604
            if (sindex != 0) {
#line 4605
              goto while_break___0;
            }
          }
#line 4587
          propidx ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 4608
        rrd_set_error((char *)"invalid fonttag \'%s\'", prop);
        }
#line 4609
        return;
      }
    } else {
      {
#line 4612
      rrd_set_error((char *)"invalid text property format");
      }
#line 4613
      return;
    }
#line 4615
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 4618
    im->zoom = atof((char const   *)optarg);
    }
#line 4619
    if (im->zoom <= 0.0) {
      {
#line 4620
      rrd_set_error((char *)"zoom factor must be > 0");
      }
#line 4621
      return;
    }
#line 4623
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 4625
    strncpy((char */* __restrict  */)(im->title), (char const   */* __restrict  */)optarg,
            (size_t )150);
#line 4626
    im->title[150] = (char )'\000';
    }
#line 4627
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 4629
    tmp___26 = strcmp((char const   *)optarg, "normal");
    }
#line 4629
    if (tmp___26 == 0) {
      {
#line 4630
      cairo_font_options_set_antialias(im->font_options, (cairo_antialias_t )2);
#line 4632
      cairo_font_options_set_hint_style(im->font_options, (cairo_hint_style_t )4);
      }
    } else {
      {
#line 4634
      tmp___25 = strcmp((char const   *)optarg, "light");
      }
#line 4634
      if (tmp___25 == 0) {
        {
#line 4635
        cairo_font_options_set_antialias(im->font_options, (cairo_antialias_t )2);
#line 4637
        cairo_font_options_set_hint_style(im->font_options, (cairo_hint_style_t )2);
        }
      } else {
        {
#line 4639
        tmp___24 = strcmp((char const   *)optarg, "mono");
        }
#line 4639
        if (tmp___24 == 0) {
          {
#line 4640
          cairo_font_options_set_antialias(im->font_options, (cairo_antialias_t )1);
#line 4642
          cairo_font_options_set_hint_style(im->font_options, (cairo_hint_style_t )4);
          }
        } else {
          {
#line 4645
          rrd_set_error((char *)"unknown font-render-mode \'%s\'", optarg);
          }
#line 4646
          return;
        }
      }
    }
#line 4648
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 4650
    tmp___28 = strcmp((char const   *)optarg, "normal");
    }
#line 4650
    if (tmp___28 == 0) {
#line 4651
      im->graph_antialias = (cairo_antialias_t )2;
    } else {
      {
#line 4652
      tmp___27 = strcmp((char const   *)optarg, "mono");
      }
#line 4652
      if (tmp___27 == 0) {
#line 4653
        im->graph_antialias = (cairo_antialias_t )1;
      } else {
        {
#line 4655
        rrd_set_error((char *)"unknown graph-render-mode \'%s\'", optarg);
        }
#line 4656
        return;
      }
    }
#line 4658
    goto switch_break;
    case_66: /* CIL Label */ 
#line 4661
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 4663
    strncpy((char */* __restrict  */)(im->watermark), (char const   */* __restrict  */)optarg,
            (size_t )100);
#line 4664
    im->watermark[99] = (char )'\000';
    }
#line 4665
    goto switch_break;
    case_100: /* CIL Label */ 
#line 4668
    if ((unsigned long )im->daemon_addr != (unsigned long )((void *)0)) {
      {
#line 4670
      rrd_set_error((char *)"You cannot specify --daemon more than once.");
      }
#line 4672
      return;
    }
    {
#line 4675
    im->daemon_addr = strdup((char const   *)optarg);
    }
#line 4676
    if ((unsigned long )im->daemon_addr == (unsigned long )((void *)0)) {
      {
#line 4678
      rrd_set_error((char *)"strdup failed");
      }
#line 4679
      return;
    }
#line 4682
    goto switch_break;
    case_63: /* CIL Label */ 
#line 4685
    if (optopt != 0) {
      {
#line 4686
      rrd_set_error((char *)"unknown option \'%c\'", optopt);
      }
    } else {
      {
#line 4688
      rrd_set_error((char *)"unknown option \'%s\'", *(argv + (optind - 1)));
      }
    }
#line 4689
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4694
  tmp___29 = rrdc_connect((char const   *)im->daemon_addr);
#line 4694
  status = tmp___29;
  }
#line 4695
  if (status != 0) {
#line 4695
    return;
  }
  {
#line 4698
  tmp___30 = pango_layout_get_context(im->layout);
#line 4698
  pango_cairo_context_set_font_options(tmp___30, (cairo_font_options_t const   *)im->font_options);
#line 4699
  pango_layout_context_changed(im->layout);
  }
#line 4703
  if (im->logarithmic) {
#line 4703
    if (im->minval <= (rrd_value_t )0) {
      {
#line 4704
      rrd_set_error((char *)"for a logarithmic yaxis you must specify a lower-limit > 0");
      }
#line 4706
      return;
    }
  }
  {
#line 4709
  tmp___31 = rrd_proc_start_end(& start_tv, & end_tv, & start_tmp, & end_tmp);
  }
#line 4709
  if (tmp___31 == -1) {
#line 4711
    return;
  }
#line 4714
  if (start_tmp < 315360000L) {
    {
#line 4715
    rrd_set_error((char *)"the first entry to fetch should be after 1980 (%ld)", start_tmp);
    }
#line 4718
    return;
  }
#line 4721
  if (end_tmp < start_tmp) {
    {
#line 4722
    rrd_set_error((char *)"start (%ld) should be less than end (%ld)", start_tmp,
                  end_tmp);
    }
#line 4724
    return;
  }
#line 4727
  im->start = start_tmp;
#line 4728
  im->end = end_tmp;
#line 4729
  if ((long )im->step > (im->end - im->start) / im->xsize) {
#line 4729
    im->step = (unsigned long )((long )im->step);
  } else {
#line 4729
    im->step = (unsigned long )((im->end - im->start) / im->xsize);
  }
#line 4730
  return;
}
}
#line 4732 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int rrd_graph_color(image_desc_t *im , char *var , char *err , int optional ) 
{ 
  char *color ;
  graph_desc_t *gdp ;
  int n ;
  char *rest ;
  unsigned long col ;
  size_t tmp ;
  int tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 4740
  gdp = im->gdes + (im->gdes_c - 1L);
#line 4742
  color = strstr((char const   *)var, "#");
  }
#line 4743
  if ((unsigned long )color == (unsigned long )((void *)0)) {
#line 4744
    if (optional == 0) {
      {
#line 4745
      rrd_set_error((char *)"Found no color in %s", err);
      }
#line 4746
      return (0);
    }
#line 4748
    return (0);
  } else {
    {
#line 4750
    n = 0;
#line 4754
    rest = strstr((char const   *)color, ":");
    }
#line 4755
    if ((unsigned long )rest != (unsigned long )((void *)0)) {
#line 4756
      n = (int )(rest - color);
    } else {
      {
#line 4758
      tmp = strlen((char const   *)color);
#line 4758
      n = (int )tmp;
      }
    }
    {
#line 4760
    if (n == 7) {
#line 4760
      goto case_7;
    }
#line 4766
    if (n == 9) {
#line 4766
      goto case_9;
    }
#line 4770
    goto switch_default;
    case_7: /* CIL Label */ 
    {
#line 4761
    sscanf((char const   */* __restrict  */)color, (char const   */* __restrict  */)"#%6lx%n",
           & col, & n);
#line 4762
    col = (col << 8) + 255UL;
    }
#line 4763
    if (n != 7) {
      {
#line 4764
      rrd_set_error((char *)"Color problem in %s", err);
      }
    }
#line 4765
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 4767
    sscanf((char const   */* __restrict  */)color, (char const   */* __restrict  */)"#%8lx%n",
           & col, & n);
    }
#line 4768
    if (n == 9) {
#line 4769
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 4771
    rrd_set_error((char *)"Color problem in %s", err);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 4773
    tmp___0 = rrd_test_error();
    }
#line 4773
    if (tmp___0) {
#line 4774
      return (0);
    }
    {
#line 4775
    gdp->col = gfx_hex_to_col(col);
    }
#line 4776
    return (n);
  }
}
}
#line 4781 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int bad_format(char *fmt ) 
{ 
  char *ptr ;
  int n ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 4785
  n = 0;
#line 4787
  ptr = fmt;
  {
#line 4788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4788
    if (! ((int )*ptr != 0)) {
#line 4788
      goto while_break;
    }
#line 4789
    tmp___0 = ptr;
#line 4789
    ptr ++;
#line 4789
    if ((int )*tmp___0 == 37) {
#line 4792
      if ((int )*ptr == 0) {
#line 4793
        return (1);
      }
#line 4795
      if ((int )*ptr == 115) {
#line 4796
        ptr ++;
      } else
#line 4795
      if ((int )*ptr == 83) {
#line 4796
        ptr ++;
      } else
#line 4795
      if ((int )*ptr == 37) {
#line 4796
        ptr ++;
      } else
#line 4798
      if ((int )*ptr == 99) {
#line 4799
        ptr ++;
#line 4800
        n = 1;
      } else {
#line 4806
        if ((int )*ptr == 32) {
#line 4807
          ptr ++;
        } else
#line 4806
        if ((int )*ptr == 43) {
#line 4807
          ptr ++;
        } else
#line 4806
        if ((int )*ptr == 45) {
#line 4807
          ptr ++;
        }
        {
#line 4809
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4809
          if ((int )*ptr >= 48) {
#line 4809
            if (! ((int )*ptr <= 57)) {
#line 4809
              goto while_break___0;
            }
          } else {
#line 4809
            goto while_break___0;
          }
#line 4810
          ptr ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 4811
        if ((int )*ptr == 46) {
#line 4812
          ptr ++;
        }
        {
#line 4813
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 4813
          if ((int )*ptr >= 48) {
#line 4813
            if (! ((int )*ptr <= 57)) {
#line 4813
              goto while_break___1;
            }
          } else {
#line 4813
            goto while_break___1;
          }
#line 4814
          ptr ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 4816
        tmp = ptr;
#line 4816
        ptr ++;
#line 4816
        if ((int )*tmp != 108) {
#line 4817
          return (1);
        }
#line 4818
        if ((int )*ptr == 101) {
#line 4819
          ptr ++;
        } else
#line 4818
        if ((int )*ptr == 102) {
#line 4819
          ptr ++;
        } else
#line 4818
        if ((int )*ptr == 103) {
#line 4819
          ptr ++;
        } else {
#line 4821
          return (1);
        }
#line 4822
        n ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4826
  return (n != 1);
}
}
#line 4830 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int vdef_parse(struct graph_desc_t *gdes , char const   * const  str ) 
{ 
  double param ;
  char func[30] ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
#line 4842
  n = 0;
#line 4843
  sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%le,%29[A-Z]%n",
         & param, func, & n);
#line 4844
  tmp___0 = strlen((char const   *)str);
  }
#line 4844
  if (! (n == (int )tmp___0)) {
    {
#line 4847
    n = 0;
#line 4848
    sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%29[A-Z]%n",
           func, & n);
#line 4849
    tmp = strlen((char const   *)str);
    }
#line 4849
    if (n == (int )tmp) {
      {
#line 4850
      param = rrd_set_to_DNAN();
      }
    } else {
      {
#line 4852
      rrd_set_error((char *)"Unknown function string \'%s\' in VDEF \'%s\'", str,
                    gdes->vname);
      }
#line 4855
      return (-1);
    }
  }
  {
#line 4858
  tmp___12 = strcmp("PERCENT", (char const   *)(func));
  }
#line 4858
  if (tmp___12) {
    {
#line 4860
    tmp___11 = strcmp("PERCENTNAN", (char const   *)(func));
    }
#line 4860
    if (tmp___11) {
      {
#line 4862
      tmp___10 = strcmp("MAXIMUM", (char const   *)(func));
      }
#line 4862
      if (tmp___10) {
        {
#line 4864
        tmp___9 = strcmp("AVERAGE", (char const   *)(func));
        }
#line 4864
        if (tmp___9) {
          {
#line 4866
          tmp___8 = strcmp("STDEV", (char const   *)(func));
          }
#line 4866
          if (tmp___8) {
            {
#line 4868
            tmp___7 = strcmp("MINIMUM", (char const   *)(func));
            }
#line 4868
            if (tmp___7) {
              {
#line 4870
              tmp___6 = strcmp("TOTAL", (char const   *)(func));
              }
#line 4870
              if (tmp___6) {
                {
#line 4872
                tmp___5 = strcmp("FIRST", (char const   *)(func));
                }
#line 4872
                if (tmp___5) {
                  {
#line 4874
                  tmp___4 = strcmp("LAST", (char const   *)(func));
                  }
#line 4874
                  if (tmp___4) {
                    {
#line 4876
                    tmp___3 = strcmp("LSLSLOPE", (char const   *)(func));
                    }
#line 4876
                    if (tmp___3) {
                      {
#line 4878
                      tmp___2 = strcmp("LSLINT", (char const   *)(func));
                      }
#line 4878
                      if (tmp___2) {
                        {
#line 4880
                        tmp___1 = strcmp("LSLCORREL", (char const   *)(func));
                        }
#line 4880
                        if (tmp___1) {
                          {
#line 4883
                          rrd_set_error((char *)"Unknown function \'%s\' in VDEF \'%s\'\n",
                                        func, gdes->vname);
                          }
#line 4885
                          return (-1);
                        } else {
#line 4881
                          gdes->vf.op = (enum vdef_op_en )10;
                        }
                      } else {
#line 4879
                        gdes->vf.op = (enum vdef_op_en )9;
                      }
                    } else {
#line 4877
                      gdes->vf.op = (enum vdef_op_en )8;
                    }
                  } else {
#line 4875
                    gdes->vf.op = (enum vdef_op_en )7;
                  }
                } else {
#line 4873
                  gdes->vf.op = (enum vdef_op_en )6;
                }
              } else {
#line 4871
                gdes->vf.op = (enum vdef_op_en )5;
              }
            } else {
#line 4869
              gdes->vf.op = (enum vdef_op_en )1;
            }
          } else {
#line 4867
            gdes->vf.op = (enum vdef_op_en )3;
          }
        } else {
#line 4865
          gdes->vf.op = (enum vdef_op_en )2;
        }
      } else {
#line 4863
        gdes->vf.op = (enum vdef_op_en )0;
      }
    } else {
#line 4861
      gdes->vf.op = (enum vdef_op_en )11;
    }
  } else {
#line 4859
    gdes->vf.op = (enum vdef_op_en )4;
  }
  {
#line 4889
  if ((unsigned int )gdes->vf.op == 11U) {
#line 4889
    goto case_11;
  }
#line 4889
  if ((unsigned int )gdes->vf.op == 4U) {
#line 4889
    goto case_11;
  }
#line 4916
  if ((unsigned int )gdes->vf.op == 10U) {
#line 4916
    goto case_10;
  }
#line 4916
  if ((unsigned int )gdes->vf.op == 9U) {
#line 4916
    goto case_10;
  }
#line 4916
  if ((unsigned int )gdes->vf.op == 8U) {
#line 4916
    goto case_10;
  }
#line 4916
  if ((unsigned int )gdes->vf.op == 7U) {
#line 4916
    goto case_10;
  }
#line 4916
  if ((unsigned int )gdes->vf.op == 6U) {
#line 4916
    goto case_10;
  }
#line 4916
  if ((unsigned int )gdes->vf.op == 5U) {
#line 4916
    goto case_10;
  }
#line 4916
  if ((unsigned int )gdes->vf.op == 1U) {
#line 4916
    goto case_10;
  }
#line 4916
  if ((unsigned int )gdes->vf.op == 3U) {
#line 4916
    goto case_10;
  }
#line 4916
  if ((unsigned int )gdes->vf.op == 2U) {
#line 4916
    goto case_10;
  }
#line 4916
  if ((unsigned int )gdes->vf.op == 0U) {
#line 4916
    goto case_10;
  }
#line 4887
  goto switch_break;
  case_11: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 4890
  if (sizeof(param) == sizeof(float )) {
    {
#line 4890
    tmp___13 = __isnanf((float )param);
#line 4890
    tmp___17 = tmp___13;
    }
  } else {
#line 4890
    if (sizeof(param) == sizeof(double )) {
      {
#line 4890
      tmp___14 = __isnan(param);
#line 4890
      tmp___16 = tmp___14;
      }
    } else {
      {
#line 4890
      tmp___15 = __isnanl((long double )param);
#line 4890
      tmp___16 = tmp___15;
      }
    }
#line 4890
    tmp___17 = tmp___16;
  }
#line 4890
  if (tmp___17) {
    {
#line 4891
    rrd_set_error((char *)"Function \'%s\' needs parameter in VDEF \'%s\'\n", func,
                  gdes->vname);
    }
#line 4894
    return (-1);
  }
#line 4896
  if (param >= 0.0) {
#line 4896
    if (param <= 100.0) {
      {
#line 4897
      gdes->vf.param = param;
#line 4898
      gdes->vf.val = rrd_set_to_DNAN();
#line 4899
      gdes->vf.when = (time_t )0;
      }
    } else {
      {
#line 4901
      rrd_set_error((char *)"Parameter \'%f\' out of range in VDEF \'%s\'\n", param,
                    gdes->vname);
      }
#line 4904
      return (-1);
    }
  } else {
    {
#line 4901
    rrd_set_error((char *)"Parameter \'%f\' out of range in VDEF \'%s\'\n", param,
                  gdes->vname);
    }
#line 4904
    return (-1);
  }
#line 4906
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 4917
  if (sizeof(param) == sizeof(float )) {
    {
#line 4917
    tmp___18 = __isnanf((float )param);
#line 4917
    tmp___22 = tmp___18;
    }
  } else {
#line 4917
    if (sizeof(param) == sizeof(double )) {
      {
#line 4917
      tmp___19 = __isnan(param);
#line 4917
      tmp___21 = tmp___19;
      }
    } else {
      {
#line 4917
      tmp___20 = __isnanl((long double )param);
#line 4917
      tmp___21 = tmp___20;
      }
    }
#line 4917
    tmp___22 = tmp___21;
  }
#line 4917
  if (tmp___22) {
    {
#line 4918
    gdes->vf.param = rrd_set_to_DNAN();
#line 4919
    gdes->vf.val = rrd_set_to_DNAN();
#line 4920
    gdes->vf.when = (time_t )0;
    }
  } else {
    {
#line 4922
    rrd_set_error((char *)"Function \'%s\' needs no parameter in VDEF \'%s\'\n", func,
                  gdes->vname);
    }
#line 4925
    return (-1);
  }
#line 4927
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4929
  return (0);
}
}
#line 4933 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int vdef_calc(image_desc_t *im , int gdi ) 
{ 
  graph_desc_t *src ;
  graph_desc_t *dst ;
  rrd_value_t *data ;
  long step ;
  long steps ;
  rrd_value_t *array ;
  int field ;
  void *tmp ;
  double tmp___0 ;
  rrd_value_t *array___0 ;
  int field___0 ;
  int nancount ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int cnt ;
  double sum ;
  double average ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  double tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int cnt___0 ;
  double SUMx ;
  double SUMy ;
  double SUMxy ;
  double SUMxx ;
  double SUMyy ;
  double slope ;
  double y_intercept ;
  double correl ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  double tmp___59 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;

  {
#line 4941
  dst = im->gdes + gdi;
#line 4942
  src = im->gdes + dst->vidx;
#line 4943
  data = src->data + src->ds;
#line 4945
  steps = (long )((unsigned long )(src->end - src->start) / src->step);
  {
#line 4952
  if ((unsigned int )dst->vf.op == 4U) {
#line 4952
    goto case_4;
  }
#line 4974
  if ((unsigned int )dst->vf.op == 11U) {
#line 4974
    goto case_11;
  }
#line 5002
  if ((unsigned int )dst->vf.op == 0U) {
#line 5002
    goto case_0;
  }
#line 5025
  if ((unsigned int )dst->vf.op == 2U) {
#line 5025
    goto case_2;
  }
#line 5025
  if ((unsigned int )dst->vf.op == 3U) {
#line 5025
    goto case_2;
  }
#line 5025
  if ((unsigned int )dst->vf.op == 5U) {
#line 5025
    goto case_2;
  }
#line 5060
  if ((unsigned int )dst->vf.op == 1U) {
#line 5060
    goto case_1;
  }
#line 5081
  if ((unsigned int )dst->vf.op == 6U) {
#line 5081
    goto case_6;
  }
#line 5097
  if ((unsigned int )dst->vf.op == 7U) {
#line 5097
    goto case_7;
  }
#line 5115
  if ((unsigned int )dst->vf.op == 10U) {
#line 5115
    goto case_10;
  }
#line 5115
  if ((unsigned int )dst->vf.op == 9U) {
#line 5115
    goto case_10;
  }
#line 5115
  if ((unsigned int )dst->vf.op == 8U) {
#line 5115
    goto case_10;
  }
#line 4951
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 4955
  tmp = malloc((unsigned long )steps * sizeof(double ));
#line 4955
  array = (rrd_value_t *)tmp;
  }
#line 4955
  if ((unsigned long )array == (unsigned long )((void *)0)) {
    {
#line 4956
    rrd_set_error((char *)"malloc VDEV_PERCENT");
    }
#line 4957
    return (-1);
  }
#line 4959
  step = 0L;
  {
#line 4959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4959
    if (! (step < steps)) {
#line 4959
      goto while_break;
    }
#line 4960
    *(array + step) = *(data + (unsigned long )step * src->ds_cnt);
#line 4959
    step ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4962
  qsort((void *)array, (size_t )step, sizeof(double ), & vdef_percent_compar);
#line 4963
  tmp___0 = round((dst->vf.param * (double )(steps - 1L)) / 100.0);
#line 4963
  field = (int )tmp___0;
#line 4964
  dst->vf.val = *(array + field);
#line 4965
  dst->vf.when = (time_t )0;
#line 4966
  free((void *)array);
  }
#line 4973
  goto switch_break;
  case_11: /* CIL Label */ 
#line 4978
  nancount = 0;
#line 4979
  step = 0L;
  {
#line 4979
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4979
    if (! (step < steps)) {
#line 4979
      goto while_break___0;
    }
#line 4980
    if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
      {
#line 4980
      tmp___1 = __isnanf((float )*(data + (unsigned long )step * src->ds_cnt));
#line 4980
      tmp___5 = tmp___1;
      }
    } else {
#line 4980
      if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
        {
#line 4980
        tmp___2 = __isnan(*(data + (unsigned long )step * src->ds_cnt));
#line 4980
        tmp___4 = tmp___2;
        }
      } else {
        {
#line 4980
        tmp___3 = __isnanl((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 4980
        tmp___4 = tmp___3;
        }
      }
#line 4980
      tmp___5 = tmp___4;
    }
#line 4980
    if (! tmp___5) {
#line 4980
      nancount ++;
    }
#line 4979
    step ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4983
  tmp___6 = malloc((unsigned long )nancount * sizeof(double ));
#line 4983
  array___0 = (rrd_value_t *)tmp___6;
  }
#line 4983
  if ((unsigned long )array___0 == (unsigned long )((void *)0)) {
    {
#line 4984
    rrd_set_error((char *)"malloc VDEV_PERCENT");
    }
#line 4985
    return (-1);
  }
#line 4988
  field___0 = 0;
#line 4989
  step = 0L;
  {
#line 4989
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4989
    if (! (step < steps)) {
#line 4989
      goto while_break___1;
    }
#line 4990
    if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
      {
#line 4990
      tmp___7 = __isnanf((float )*(data + (unsigned long )step * src->ds_cnt));
#line 4990
      tmp___11 = tmp___7;
      }
    } else {
#line 4990
      if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
        {
#line 4990
        tmp___8 = __isnan(*(data + (unsigned long )step * src->ds_cnt));
#line 4990
        tmp___10 = tmp___8;
        }
      } else {
        {
#line 4990
        tmp___9 = __isnanl((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 4990
        tmp___10 = tmp___9;
        }
      }
#line 4990
      tmp___11 = tmp___10;
    }
#line 4990
    if (! tmp___11) {
#line 4991
      *(array___0 + field___0) = *(data + (unsigned long )step * src->ds_cnt);
#line 4992
      field___0 ++;
    }
#line 4989
    step ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 4995
  qsort((void *)array___0, (size_t )nancount, sizeof(double ), & vdef_percent_compar);
#line 4996
  tmp___12 = round((dst->vf.param * (double )(nancount - 1)) / 100.0);
#line 4996
  field___0 = (int )tmp___12;
#line 4997
  dst->vf.val = *(array___0 + field___0);
#line 4998
  dst->vf.when = (time_t )0;
#line 4999
  free((void *)array___0);
  }
#line 5001
  goto switch_break;
  case_0: /* CIL Label */ 
#line 5003
  step = 0L;
  {
#line 5004
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5004
    if (step != steps) {
#line 5004
      if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
        {
#line 5004
        tmp___13 = __isnanf((float )*(data + (unsigned long )step * src->ds_cnt));
#line 5004
        tmp___17 = tmp___13;
        }
      } else {
#line 5004
        if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
          {
#line 5004
          tmp___14 = __isnan(*(data + (unsigned long )step * src->ds_cnt));
#line 5004
          tmp___16 = tmp___14;
          }
        } else {
          {
#line 5004
          tmp___15 = __isnanl((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 5004
          tmp___16 = tmp___15;
          }
        }
#line 5004
        tmp___17 = tmp___16;
      }
#line 5004
      if (! tmp___17) {
#line 5004
        goto while_break___2;
      }
    } else {
#line 5004
      goto while_break___2;
    }
#line 5005
    step ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5006
  if (step == steps) {
    {
#line 5007
    dst->vf.val = rrd_set_to_DNAN();
#line 5008
    dst->vf.when = (time_t )0;
    }
  } else {
#line 5010
    dst->vf.val = *(data + (unsigned long )step * src->ds_cnt);
#line 5011
    dst->vf.when = (time_t )((unsigned long )src->start + (unsigned long )(step + 1L) * src->step);
  }
  {
#line 5013
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5013
    if (! (step != steps)) {
#line 5013
      goto while_break___3;
    }
#line 5014
    if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
      {
#line 5014
      tmp___18 = __finitef((float )*(data + (unsigned long )step * src->ds_cnt));
#line 5014
      tmp___22 = tmp___18;
      }
    } else {
#line 5014
      if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
        {
#line 5014
        tmp___19 = __finite(*(data + (unsigned long )step * src->ds_cnt));
#line 5014
        tmp___21 = tmp___19;
        }
      } else {
        {
#line 5014
        tmp___20 = __finitel((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 5014
        tmp___21 = tmp___20;
        }
      }
#line 5014
      tmp___22 = tmp___21;
    }
#line 5014
    if (tmp___22) {
#line 5015
      if (*(data + (unsigned long )step * src->ds_cnt) > dst->vf.val) {
#line 5016
        dst->vf.val = *(data + (unsigned long )step * src->ds_cnt);
#line 5017
        dst->vf.when = (time_t )((unsigned long )src->start + (unsigned long )(step + 1L) * src->step);
      }
    }
#line 5020
    step ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5022
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 5026
  cnt = 0;
#line 5027
  sum = 0.0;
#line 5028
  average = 0.0;
#line 5030
  step = 0L;
  {
#line 5030
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 5030
    if (! (step < steps)) {
#line 5030
      goto while_break___4;
    }
#line 5031
    if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
      {
#line 5031
      tmp___23 = __finitef((float )*(data + (unsigned long )step * src->ds_cnt));
#line 5031
      tmp___27 = tmp___23;
      }
    } else {
#line 5031
      if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
        {
#line 5031
        tmp___24 = __finite(*(data + (unsigned long )step * src->ds_cnt));
#line 5031
        tmp___26 = tmp___24;
        }
      } else {
        {
#line 5031
        tmp___25 = __finitel((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 5031
        tmp___26 = tmp___25;
        }
      }
#line 5031
      tmp___27 = tmp___26;
    }
#line 5031
    if (tmp___27) {
#line 5032
      sum += *(data + (unsigned long )step * src->ds_cnt);
#line 5033
      cnt ++;
    }
#line 5030
    step ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 5036
  if (cnt) {
#line 5037
    if ((unsigned int )dst->vf.op == 5U) {
#line 5038
      dst->vf.val = sum * (double )src->step;
#line 5039
      dst->vf.when = (time_t )0;
    } else
#line 5040
    if ((unsigned int )dst->vf.op == 2U) {
#line 5041
      dst->vf.val = sum / (double )cnt;
#line 5042
      dst->vf.when = (time_t )0;
    } else {
#line 5044
      average = sum / (double )cnt;
#line 5045
      sum = 0.0;
#line 5046
      step = 0L;
      {
#line 5046
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 5046
        if (! (step < steps)) {
#line 5046
          goto while_break___5;
        }
#line 5047
        if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
          {
#line 5047
          tmp___29 = __finitef((float )*(data + (unsigned long )step * src->ds_cnt));
#line 5047
          tmp___33 = tmp___29;
          }
        } else {
#line 5047
          if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
            {
#line 5047
            tmp___30 = __finite(*(data + (unsigned long )step * src->ds_cnt));
#line 5047
            tmp___32 = tmp___30;
            }
          } else {
            {
#line 5047
            tmp___31 = __finitel((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 5047
            tmp___32 = tmp___31;
            }
          }
#line 5047
          tmp___33 = tmp___32;
        }
#line 5047
        if (tmp___33) {
          {
#line 5048
          tmp___28 = pow(*(data + (unsigned long )step * src->ds_cnt) - average, 2.0);
#line 5048
          sum += tmp___28;
          }
        }
#line 5046
        step ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 5051
      dst->vf.val = pow(sum / (double )cnt, 0.5);
#line 5052
      dst->vf.when = (time_t )0;
      }
    }
  } else {
    {
#line 5055
    dst->vf.val = rrd_set_to_DNAN();
#line 5056
    dst->vf.when = (time_t )0;
    }
  }
#line 5059
  goto switch_break;
  case_1: /* CIL Label */ 
#line 5061
  step = 0L;
  {
#line 5062
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 5062
    if (step != steps) {
#line 5062
      if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
        {
#line 5062
        tmp___34 = __isnanf((float )*(data + (unsigned long )step * src->ds_cnt));
#line 5062
        tmp___38 = tmp___34;
        }
      } else {
#line 5062
        if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
          {
#line 5062
          tmp___35 = __isnan(*(data + (unsigned long )step * src->ds_cnt));
#line 5062
          tmp___37 = tmp___35;
          }
        } else {
          {
#line 5062
          tmp___36 = __isnanl((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 5062
          tmp___37 = tmp___36;
          }
        }
#line 5062
        tmp___38 = tmp___37;
      }
#line 5062
      if (! tmp___38) {
#line 5062
        goto while_break___6;
      }
    } else {
#line 5062
      goto while_break___6;
    }
#line 5063
    step ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 5064
  if (step == steps) {
    {
#line 5065
    dst->vf.val = rrd_set_to_DNAN();
#line 5066
    dst->vf.when = (time_t )0;
    }
  } else {
#line 5068
    dst->vf.val = *(data + (unsigned long )step * src->ds_cnt);
#line 5069
    dst->vf.when = (time_t )((unsigned long )src->start + (unsigned long )(step + 1L) * src->step);
  }
  {
#line 5071
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 5071
    if (! (step != steps)) {
#line 5071
      goto while_break___7;
    }
#line 5072
    if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
      {
#line 5072
      tmp___39 = __finitef((float )*(data + (unsigned long )step * src->ds_cnt));
#line 5072
      tmp___43 = tmp___39;
      }
    } else {
#line 5072
      if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
        {
#line 5072
        tmp___40 = __finite(*(data + (unsigned long )step * src->ds_cnt));
#line 5072
        tmp___42 = tmp___40;
        }
      } else {
        {
#line 5072
        tmp___41 = __finitel((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 5072
        tmp___42 = tmp___41;
        }
      }
#line 5072
      tmp___43 = tmp___42;
    }
#line 5072
    if (tmp___43) {
#line 5073
      if (*(data + (unsigned long )step * src->ds_cnt) < dst->vf.val) {
#line 5074
        dst->vf.val = *(data + (unsigned long )step * src->ds_cnt);
#line 5075
        dst->vf.when = (time_t )((unsigned long )src->start + (unsigned long )(step + 1L) * src->step);
      }
    }
#line 5078
    step ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 5080
  goto switch_break;
  case_6: /* CIL Label */ 
#line 5086
  step = 0L;
  {
#line 5087
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 5087
    if (step != steps) {
#line 5087
      if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
        {
#line 5087
        tmp___44 = __isnanf((float )*(data + (unsigned long )step * src->ds_cnt));
#line 5087
        tmp___48 = tmp___44;
        }
      } else {
#line 5087
        if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
          {
#line 5087
          tmp___45 = __isnan(*(data + (unsigned long )step * src->ds_cnt));
#line 5087
          tmp___47 = tmp___45;
          }
        } else {
          {
#line 5087
          tmp___46 = __isnanl((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 5087
          tmp___47 = tmp___46;
          }
        }
#line 5087
        tmp___48 = tmp___47;
      }
#line 5087
      if (! tmp___48) {
#line 5087
        goto while_break___8;
      }
    } else {
#line 5087
      goto while_break___8;
    }
#line 5088
    step ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 5089
  if (step == steps) {
    {
#line 5090
    dst->vf.val = rrd_set_to_DNAN();
#line 5091
    dst->vf.when = (time_t )0;
    }
  } else {
#line 5093
    dst->vf.val = *(data + (unsigned long )step * src->ds_cnt);
#line 5094
    dst->vf.when = (time_t )((unsigned long )src->start + (unsigned long )step * src->step);
  }
#line 5096
  goto switch_break;
  case_7: /* CIL Label */ 
#line 5102
  step = steps - 1L;
  {
#line 5103
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 5103
    if (step >= 0L) {
#line 5103
      if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
        {
#line 5103
        tmp___49 = __isnanf((float )*(data + (unsigned long )step * src->ds_cnt));
#line 5103
        tmp___53 = tmp___49;
        }
      } else {
#line 5103
        if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
          {
#line 5103
          tmp___50 = __isnan(*(data + (unsigned long )step * src->ds_cnt));
#line 5103
          tmp___52 = tmp___50;
          }
        } else {
          {
#line 5103
          tmp___51 = __isnanl((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 5103
          tmp___52 = tmp___51;
          }
        }
#line 5103
        tmp___53 = tmp___52;
      }
#line 5103
      if (! tmp___53) {
#line 5103
        goto while_break___9;
      }
    } else {
#line 5103
      goto while_break___9;
    }
#line 5104
    step --;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 5105
  if (step < 0L) {
    {
#line 5106
    dst->vf.val = rrd_set_to_DNAN();
#line 5107
    dst->vf.when = (time_t )0;
    }
  } else {
#line 5109
    dst->vf.val = *(data + (unsigned long )step * src->ds_cnt);
#line 5110
    dst->vf.when = (time_t )((unsigned long )src->start + (unsigned long )(step + 1L) * src->step);
  }
#line 5112
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 5118
  cnt___0 = 0;
#line 5121
  SUMx = (double )0;
#line 5122
  SUMy = (double )0;
#line 5123
  SUMxy = (double )0;
#line 5124
  SUMxx = (double )0;
#line 5125
  SUMyy = (double )0;
#line 5126
  step = 0L;
  {
#line 5126
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 5126
    if (! (step < steps)) {
#line 5126
      goto while_break___10;
    }
#line 5127
    if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(float )) {
      {
#line 5127
      tmp___54 = __finitef((float )*(data + (unsigned long )step * src->ds_cnt));
#line 5127
      tmp___58 = tmp___54;
      }
    } else {
#line 5127
      if (sizeof(*(data + (unsigned long )step * src->ds_cnt)) == sizeof(double )) {
        {
#line 5127
        tmp___55 = __finite(*(data + (unsigned long )step * src->ds_cnt));
#line 5127
        tmp___57 = tmp___55;
        }
      } else {
        {
#line 5127
        tmp___56 = __finitel((long double )*(data + (unsigned long )step * src->ds_cnt));
#line 5127
        tmp___57 = tmp___56;
        }
      }
#line 5127
      tmp___58 = tmp___57;
    }
#line 5127
    if (tmp___58) {
#line 5128
      cnt___0 ++;
#line 5129
      SUMx += (double )step;
#line 5130
      SUMxx += (double )(step * step);
#line 5131
      SUMxy += (rrd_value_t )step * *(data + (unsigned long )step * src->ds_cnt);
#line 5132
      SUMy += *(data + (unsigned long )step * src->ds_cnt);
#line 5133
      SUMyy += *(data + (unsigned long )step * src->ds_cnt) * *(data + (unsigned long )step * src->ds_cnt);
    }
#line 5126
    step ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 5137
  slope = (SUMx * SUMy - (double )cnt___0 * SUMxy) / (SUMx * SUMx - (double )cnt___0 * SUMxx);
#line 5138
  y_intercept = (SUMy - slope * SUMx) / (double )cnt___0;
#line 5139
  tmp___59 = sqrt((SUMxx - (SUMx * SUMx) / (double )cnt___0) * (SUMyy - (SUMy * SUMy) / (double )cnt___0));
#line 5139
  correl = (SUMxy - (SUMx * SUMy) / (double )cnt___0) / tmp___59;
  }
#line 5144
  if (cnt___0) {
#line 5145
    if ((unsigned int )dst->vf.op == 8U) {
#line 5146
      dst->vf.val = slope;
#line 5147
      dst->vf.when = (time_t )0;
    } else
#line 5148
    if ((unsigned int )dst->vf.op == 9U) {
#line 5149
      dst->vf.val = y_intercept;
#line 5150
      dst->vf.when = (time_t )0;
    } else
#line 5151
    if ((unsigned int )dst->vf.op == 10U) {
#line 5152
      dst->vf.val = correl;
#line 5153
      dst->vf.when = (time_t )0;
    }
  } else {
    {
#line 5156
    dst->vf.val = rrd_set_to_DNAN();
#line 5157
    dst->vf.when = (time_t )0;
    }
  }
#line 5160
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5162
  return (0);
}
}
#line 5166 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
int vdef_percent_compar(void const   *a , void const   *b ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;

  {
#line 5177
  if (sizeof(*((double *)a)) == sizeof(float )) {
    {
#line 5177
    tmp = __isnanf((float )*((double *)a));
#line 5177
    tmp___3 = tmp;
    }
  } else {
#line 5177
    if (sizeof(*((double *)a)) == sizeof(double )) {
      {
#line 5177
      tmp___0 = __isnan(*((double *)a));
#line 5177
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 5177
      tmp___1 = __isnanl((long double )*((double *)a));
#line 5177
      tmp___2 = tmp___1;
      }
    }
#line 5177
    tmp___3 = tmp___2;
  }
#line 5177
  if (tmp___3) {
#line 5178
    return (-1);
  }
#line 5179
  if (sizeof(*((double *)b)) == sizeof(float )) {
    {
#line 5179
    tmp___4 = __isnanf((float )*((double *)b));
#line 5179
    tmp___8 = tmp___4;
    }
  } else {
#line 5179
    if (sizeof(*((double *)b)) == sizeof(double )) {
      {
#line 5179
      tmp___5 = __isnan(*((double *)b));
#line 5179
      tmp___7 = tmp___5;
      }
    } else {
      {
#line 5179
      tmp___6 = __isnanl((long double )*((double *)b));
#line 5179
      tmp___7 = tmp___6;
      }
    }
#line 5179
    tmp___8 = tmp___7;
  }
#line 5179
  if (tmp___8) {
#line 5180
    return (1);
  }
#line 5184
  if (sizeof(*((double *)a)) == sizeof(float )) {
    {
#line 5184
    tmp___14 = __isinff((float )*((double *)a));
#line 5184
    tmp___18 = tmp___14;
    }
  } else {
#line 5184
    if (sizeof(*((double *)a)) == sizeof(double )) {
      {
#line 5184
      tmp___15 = __isinf(*((double *)a));
#line 5184
      tmp___17 = tmp___15;
      }
    } else {
      {
#line 5184
      tmp___16 = __isinfl((long double )*((double *)a));
#line 5184
      tmp___17 = tmp___16;
      }
    }
#line 5184
    tmp___18 = tmp___17;
  }
#line 5184
  if (tmp___18) {
#line 5185
    if (sizeof(*((double *)a)) == sizeof(float )) {
      {
#line 5185
      tmp___9 = __isinff((float )*((double *)a));
#line 5185
      tmp___13 = tmp___9;
      }
    } else {
#line 5185
      if (sizeof(*((double *)a)) == sizeof(double )) {
        {
#line 5185
        tmp___10 = __isinf(*((double *)a));
#line 5185
        tmp___12 = tmp___10;
        }
      } else {
        {
#line 5185
        tmp___11 = __isinfl((long double )*((double *)a));
#line 5185
        tmp___12 = tmp___11;
        }
      }
#line 5185
      tmp___13 = tmp___12;
    }
#line 5185
    return (tmp___13);
  }
#line 5186
  if (sizeof(*((double *)b)) == sizeof(float )) {
    {
#line 5186
    tmp___24 = __isinff((float )*((double *)b));
#line 5186
    tmp___28 = tmp___24;
    }
  } else {
#line 5186
    if (sizeof(*((double *)b)) == sizeof(double )) {
      {
#line 5186
      tmp___25 = __isinf(*((double *)b));
#line 5186
      tmp___27 = tmp___25;
      }
    } else {
      {
#line 5186
      tmp___26 = __isinfl((long double )*((double *)b));
#line 5186
      tmp___27 = tmp___26;
      }
    }
#line 5186
    tmp___28 = tmp___27;
  }
#line 5186
  if (tmp___28) {
#line 5187
    if (sizeof(*((double *)b)) == sizeof(float )) {
      {
#line 5187
      tmp___19 = __isinff((float )*((double *)b));
#line 5187
      tmp___23 = tmp___19;
      }
    } else {
#line 5187
      if (sizeof(*((double *)b)) == sizeof(double )) {
        {
#line 5187
        tmp___20 = __isinf(*((double *)b));
#line 5187
        tmp___22 = tmp___20;
        }
      } else {
        {
#line 5187
        tmp___21 = __isinfl((long double )*((double *)b));
#line 5187
        tmp___22 = tmp___21;
        }
      }
#line 5187
      tmp___23 = tmp___22;
    }
#line 5187
    return (tmp___23);
  }
#line 5189
  if (*((double *)a) < *((double *)b)) {
#line 5190
    return (-1);
  } else {
#line 5192
    return (1);
  }
}
}
#line 5195 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_graph.c"
void grinfo_push(image_desc_t *im , char *key , rrd_info_type_t type , rrd_infoval_t value ) 
{ 


  {
  {
#line 5201
  im->grinfo_current = rrd_info_push(im->grinfo_current, key, type, value);
  }
#line 5202
  if ((unsigned long )im->grinfo == (unsigned long )((void *)0)) {
#line 5203
    im->grinfo = im->grinfo_current;
  }
#line 5205
  return;
}
}
#line 194 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_tune(int argc , char **argv ) ;
#line 49 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tune.c"
int set_hwarg(rrd_t *rrd , enum cf_en cf , enum rra_par_en rra_par , char *arg ) ;
#line 54
int set_deltaarg(rrd_t *rrd , enum rra_par_en rra_par , char *arg ) ;
#line 58
int set_windowarg(rrd_t *rrd , enum rra_par_en rra_par , char *arg ) ;
#line 63
int set_hwsmootharg(rrd_t *rrd , enum cf_en cf , enum rra_par_en rra_par , char *arg ) ;
#line 69 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tune.c"
int rrd_tune(int argc , char **argv ) 
{ 
  rrd_t rrd ;
  int matches ;
  int optcnt ;
  long ds ;
  char ds_nam[20] ;
  char ds_new[20] ;
  long heartbeat ;
  double min ;
  double max ;
  char dst[20] ;
  rrd_file_t *rrd_file ;
  struct option long_options___5[17] ;
  int option_index ;
  int opt ;
  char *old_locale ;
  enum dst_en tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int i ;
  char *buffer ;
  enum dst_en tmp___15 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  int __cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;

  {
  {
#line 75
  optcnt = 0;
#line 84
  long_options___5[0].name = "heartbeat";
#line 84
  long_options___5[0].has_arg = 1;
#line 84
  long_options___5[0].flag = (int *)0;
#line 84
  long_options___5[0].val = 'h';
#line 84
  long_options___5[1].name = "minimum";
#line 84
  long_options___5[1].has_arg = 1;
#line 84
  long_options___5[1].flag = (int *)0;
#line 84
  long_options___5[1].val = 'i';
#line 84
  long_options___5[2].name = "maximum";
#line 84
  long_options___5[2].has_arg = 1;
#line 84
  long_options___5[2].flag = (int *)0;
#line 84
  long_options___5[2].val = 'a';
#line 84
  long_options___5[3].name = "data-source-type";
#line 84
  long_options___5[3].has_arg = 1;
#line 84
  long_options___5[3].flag = (int *)0;
#line 84
  long_options___5[3].val = 'd';
#line 84
  long_options___5[4].name = "data-source-rename";
#line 84
  long_options___5[4].has_arg = 1;
#line 84
  long_options___5[4].flag = (int *)0;
#line 84
  long_options___5[4].val = 'r';
#line 84
  long_options___5[5].name = "deltapos";
#line 84
  long_options___5[5].has_arg = 1;
#line 84
  long_options___5[5].flag = (int *)0;
#line 84
  long_options___5[5].val = 'p';
#line 84
  long_options___5[6].name = "deltaneg";
#line 84
  long_options___5[6].has_arg = 1;
#line 84
  long_options___5[6].flag = (int *)0;
#line 84
  long_options___5[6].val = 'n';
#line 84
  long_options___5[7].name = "window-length";
#line 84
  long_options___5[7].has_arg = 1;
#line 84
  long_options___5[7].flag = (int *)0;
#line 84
  long_options___5[7].val = 'w';
#line 84
  long_options___5[8].name = "failure-threshold";
#line 84
  long_options___5[8].has_arg = 1;
#line 84
  long_options___5[8].flag = (int *)0;
#line 84
  long_options___5[8].val = 'f';
#line 84
  long_options___5[9].name = "alpha";
#line 84
  long_options___5[9].has_arg = 1;
#line 84
  long_options___5[9].flag = (int *)0;
#line 84
  long_options___5[9].val = 'x';
#line 84
  long_options___5[10].name = "beta";
#line 84
  long_options___5[10].has_arg = 1;
#line 84
  long_options___5[10].flag = (int *)0;
#line 84
  long_options___5[10].val = 'y';
#line 84
  long_options___5[11].name = "gamma";
#line 84
  long_options___5[11].has_arg = 1;
#line 84
  long_options___5[11].flag = (int *)0;
#line 84
  long_options___5[11].val = 'z';
#line 84
  long_options___5[12].name = "gamma-deviation";
#line 84
  long_options___5[12].has_arg = 1;
#line 84
  long_options___5[12].flag = (int *)0;
#line 84
  long_options___5[12].val = 'v';
#line 84
  long_options___5[13].name = "smoothing-window";
#line 84
  long_options___5[13].has_arg = 1;
#line 84
  long_options___5[13].flag = (int *)0;
#line 84
  long_options___5[13].val = 's';
#line 84
  long_options___5[14].name = "smoothing-window-deviation";
#line 84
  long_options___5[14].has_arg = 1;
#line 84
  long_options___5[14].flag = (int *)0;
#line 84
  long_options___5[14].val = 'S';
#line 84
  long_options___5[15].name = "aberrant-reset";
#line 84
  long_options___5[15].has_arg = 1;
#line 84
  long_options___5[15].flag = (int *)0;
#line 84
  long_options___5[15].val = 'b';
#line 84
  long_options___5[16].name = (char const   *)0;
#line 84
  long_options___5[16].has_arg = 0;
#line 84
  long_options___5[16].flag = (int *)0;
#line 84
  long_options___5[16].val = 0;
#line 105
  optind = 0;
#line 106
  opterr = 0;
#line 109
  rrd_init(& rrd);
#line 110
  rrd_file = rrd_open((char const   */* const  */)*(argv + 1), & rrd, (unsigned int )(1 << 1));
  }
#line 111
  if ((unsigned long )rrd_file == (unsigned long )((void *)0)) {
    {
#line 112
    rrd_free(& rrd);
    }
#line 113
    return (-1);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 117
    option_index = 0;
#line 119
    old_locale = (char *)"";
#line 121
    opt = getopt_long(argc, (char * const  *)argv, "h:i:a:d:r:p:n:w:f:x:y:z:v:b:",
                      (struct option  const  *)(long_options___5), & option_index);
    }
#line 123
    if (opt == -1) {
#line 124
      goto while_break;
    }
#line 126
    optcnt ++;
    {
#line 128
    if (opt == 104) {
#line 128
      goto case_104;
    }
#line 149
    if (opt == 105) {
#line 149
      goto case_105;
    }
#line 172
    if (opt == 97) {
#line 172
      goto case_97;
    }
#line 194
    if (opt == 100) {
#line 194
      goto case_100;
    }
#line 224
    if (opt == 114) {
#line 224
      goto case_114;
    }
#line 241
    if (opt == 112) {
#line 241
      goto case_112;
    }
#line 247
    if (opt == 110) {
#line 247
      goto case_110;
    }
#line 253
    if (opt == 102) {
#line 253
      goto case_102;
    }
#line 259
    if (opt == 119) {
#line 259
      goto case_119;
    }
#line 265
    if (opt == 120) {
#line 265
      goto case_120;
    }
#line 274
    if (opt == 121) {
#line 274
      goto case_121;
    }
#line 283
    if (opt == 122) {
#line 283
      goto case_122;
    }
#line 289
    if (opt == 118) {
#line 289
      goto case_118;
    }
#line 295
    if (opt == 98) {
#line 295
      goto case_98;
    }
#line 315
    if (opt == 115) {
#line 315
      goto case_115;
    }
#line 323
    if (opt == 83) {
#line 323
      goto case_83;
    }
#line 332
    if (opt == 63) {
#line 332
      goto case_63;
    }
#line 127
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 129
    old_locale = setlocale(1, (char const   *)((void *)0));
#line 130
    setlocale(1, "C");
#line 131
    matches = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%19[a-zA-Z0-9_-]:%ld",
                     ds_nam, & heartbeat);
    }
#line 131
    if (matches != 2) {
      {
#line 134
      rrd_set_error((char *)"invalid arguments for heartbeat");
#line 135
      rrd_free(& rrd);
#line 136
      rrd_close(rrd_file);
#line 137
      setlocale(1, (char const   *)old_locale);
      }
#line 138
      return (-1);
    }
    {
#line 140
    setlocale(1, (char const   *)old_locale);
#line 141
    ds = ds_match(& rrd, ds_nam);
    }
#line 141
    if (ds == -1L) {
      {
#line 142
      rrd_free(& rrd);
#line 143
      rrd_close(rrd_file);
      }
#line 144
      return (-1);
    }
#line 146
    (rrd.ds_def + ds)->par[0].u_cnt = (unsigned long )heartbeat;
#line 147
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 150
    old_locale = setlocale(1, (char const   *)((void *)0));
#line 151
    setlocale(1, "C");
#line 152
    matches = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%19[a-zA-Z0-9_-]:%lf",
                     ds_nam, & min);
    }
#line 152
    if (matches < 1) {
      {
#line 154
      rrd_set_error((char *)"invalid arguments for minimum ds value");
#line 155
      rrd_free(& rrd);
#line 156
      rrd_close(rrd_file);
#line 157
      setlocale(1, (char const   *)old_locale);
      }
#line 158
      return (-1);
    }
    {
#line 160
    setlocale(1, (char const   *)old_locale);
#line 161
    ds = ds_match(& rrd, ds_nam);
    }
#line 161
    if (ds == -1L) {
      {
#line 162
      rrd_free(& rrd);
#line 163
      rrd_close(rrd_file);
      }
#line 164
      return (-1);
    }
#line 167
    if (matches == 1) {
      {
#line 168
      min = rrd_set_to_DNAN();
      }
    }
#line 169
    (rrd.ds_def + ds)->par[1].u_val = min;
#line 170
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 173
    old_locale = setlocale(1, (char const   *)((void *)0));
#line 174
    setlocale(1, "C");
#line 175
    matches = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%19[a-zA-Z0-9_-]:%lf",
                     ds_nam, & max);
    }
#line 175
    if (matches < 1) {
      {
#line 177
      rrd_set_error((char *)"invalid arguments for maximum ds value");
#line 178
      rrd_free(& rrd);
#line 179
      rrd_close(rrd_file);
#line 180
      setlocale(1, (char const   *)old_locale);
      }
#line 181
      return (-1);
    }
    {
#line 183
    setlocale(1, (char const   *)old_locale);
#line 184
    ds = ds_match(& rrd, ds_nam);
    }
#line 184
    if (ds == -1L) {
      {
#line 185
      rrd_free(& rrd);
#line 186
      rrd_close(rrd_file);
      }
#line 187
      return (-1);
    }
#line 189
    if (matches == 1) {
      {
#line 190
      max = rrd_set_to_DNAN();
      }
    }
#line 191
    (rrd.ds_def + ds)->par[2].u_val = max;
#line 192
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 195
    matches = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%19[a-zA-Z0-9_-]:%19[A-Z]",
                     ds_nam, dst);
    }
#line 195
    if (matches != 2) {
      {
#line 197
      rrd_set_error((char *)"invalid arguments for data source type");
#line 198
      rrd_free(& rrd);
#line 199
      rrd_close(rrd_file);
      }
#line 200
      return (-1);
    }
    {
#line 202
    ds = ds_match(& rrd, ds_nam);
    }
#line 202
    if (ds == -1L) {
      {
#line 203
      rrd_free(& rrd);
#line 204
      rrd_close(rrd_file);
      }
#line 205
      return (-1);
    }
    {
#line 207
    tmp = dst_conv(dst);
    }
#line 207
    if ((int )tmp == -1) {
      {
#line 208
      rrd_free(& rrd);
#line 209
      rrd_close(rrd_file);
      }
#line 210
      return (-1);
    }
    {
#line 213
    tmp___0 = strncmp((char const   *)((rrd.ds_def + ds)->dst), (char const   *)(dst),
                      (size_t )19);
    }
#line 213
    if (tmp___0 != 0) {
      {
#line 214
      strncpy((char */* __restrict  */)((rrd.ds_def + ds)->dst), (char const   */* __restrict  */)(dst),
              (size_t )19);
#line 215
      (rrd.ds_def + ds)->dst[19] = (char )'\000';
#line 217
      (rrd.pdp_prep + ds)->last_ds[0] = (char )'U';
#line 218
      (rrd.pdp_prep + ds)->last_ds[1] = (char )'N';
#line 219
      (rrd.pdp_prep + ds)->last_ds[2] = (char )'K';
#line 220
      (rrd.pdp_prep + ds)->last_ds[3] = (char )'N';
#line 221
      (rrd.pdp_prep + ds)->last_ds[4] = (char )'\000';
      }
    }
#line 223
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 225
    matches = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%19[a-zA-Z0-9_-]:%19[a-zA-Z0-9_-]",
                     ds_nam, ds_new);
    }
#line 225
    if (matches != 2) {
      {
#line 228
      rrd_set_error((char *)"invalid arguments for data source type");
#line 229
      rrd_free(& rrd);
#line 230
      rrd_close(rrd_file);
      }
#line 231
      return (-1);
    }
    {
#line 233
    ds = ds_match(& rrd, ds_nam);
    }
#line 233
    if (ds == -1L) {
      {
#line 234
      rrd_free(& rrd);
#line 235
      rrd_close(rrd_file);
      }
#line 236
      return (-1);
    }
    {
#line 238
    strncpy((char */* __restrict  */)((rrd.ds_def + ds)->ds_nam), (char const   */* __restrict  */)(ds_new),
            (size_t )19);
#line 239
    (rrd.ds_def + ds)->ds_nam[19] = (char )'\000';
    }
#line 240
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 242
    tmp___1 = set_deltaarg(& rrd, (enum rra_par_en )1, optarg);
    }
#line 242
    if (tmp___1) {
      {
#line 243
      rrd_free(& rrd);
      }
#line 244
      return (-1);
    }
#line 246
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 248
    tmp___2 = set_deltaarg(& rrd, (enum rra_par_en )2, optarg);
    }
#line 248
    if (tmp___2) {
      {
#line 249
      rrd_free(& rrd);
      }
#line 250
      return (-1);
    }
#line 252
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 254
    tmp___3 = set_windowarg(& rrd, (enum rra_par_en )5, optarg);
    }
#line 254
    if (tmp___3) {
      {
#line 255
      rrd_free(& rrd);
      }
#line 256
      return (-1);
    }
#line 258
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 260
    tmp___4 = set_windowarg(& rrd, (enum rra_par_en )4, optarg);
    }
#line 260
    if (tmp___4) {
      {
#line 261
      rrd_free(& rrd);
      }
#line 262
      return (-1);
    }
#line 264
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 266
    tmp___6 = set_hwarg(& rrd, (enum cf_en )4, (enum rra_par_en )1, optarg);
    }
#line 266
    if (tmp___6) {
      {
#line 267
      tmp___5 = set_hwarg(& rrd, (enum cf_en )9, (enum rra_par_en )1, optarg);
      }
#line 267
      if (tmp___5) {
        {
#line 268
        rrd_free(& rrd);
        }
#line 269
        return (-1);
      }
      {
#line 271
      rrd_clear_error();
      }
    }
#line 273
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 275
    tmp___8 = set_hwarg(& rrd, (enum cf_en )4, (enum rra_par_en )2, optarg);
    }
#line 275
    if (tmp___8) {
      {
#line 276
      tmp___7 = set_hwarg(& rrd, (enum cf_en )9, (enum rra_par_en )2, optarg);
      }
#line 276
      if (tmp___7) {
        {
#line 277
        rrd_free(& rrd);
        }
#line 278
        return (-1);
      }
      {
#line 280
      rrd_clear_error();
      }
    }
#line 282
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 284
    tmp___9 = set_hwarg(& rrd, (enum cf_en )5, (enum rra_par_en )1, optarg);
    }
#line 284
    if (tmp___9) {
      {
#line 285
      rrd_free(& rrd);
      }
#line 286
      return (-1);
    }
#line 288
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 290
    tmp___10 = set_hwarg(& rrd, (enum cf_en )7, (enum rra_par_en )1, optarg);
    }
#line 290
    if (tmp___10) {
      {
#line 291
      rrd_free(& rrd);
      }
#line 292
      return (-1);
    }
#line 294
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 296
    tmp___11 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%19[a-zA-Z0-9_-]",
                      ds_nam);
    }
#line 296
    if (tmp___11 != 1) {
      {
#line 297
      rrd_set_error((char *)"invalid argument for aberrant-reset");
#line 298
      rrd_free(& rrd);
#line 299
      rrd_close(rrd_file);
      }
#line 300
      return (-1);
    }
    {
#line 302
    ds = ds_match(& rrd, ds_nam);
    }
#line 302
    if (ds == -1L) {
      {
#line 304
      rrd_free(& rrd);
#line 305
      rrd_close(rrd_file);
      }
#line 306
      return (-1);
    }
    {
#line 308
    reset_aberrant_coefficients(& rrd, rrd_file, (unsigned long )ds);
#line 309
    tmp___12 = rrd_test_error();
    }
#line 309
    if (tmp___12) {
      {
#line 310
      rrd_free(& rrd);
#line 311
      rrd_close(rrd_file);
      }
#line 312
      return (-1);
    }
#line 314
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 316
    strcpy((char */* __restrict  */)((rrd.stat_head)->version), (char const   */* __restrict  */)"0004");
#line 317
    tmp___13 = set_hwsmootharg(& rrd, (enum cf_en )5, (enum rra_par_en )2, optarg);
    }
#line 317
    if (tmp___13) {
      {
#line 319
      rrd_free(& rrd);
      }
#line 320
      return (-1);
    }
#line 322
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 324
    strcpy((char */* __restrict  */)((rrd.stat_head)->version), (char const   */* __restrict  */)"0004");
#line 325
    tmp___14 = set_hwsmootharg(& rrd, (enum cf_en )7, (enum rra_par_en )2, optarg);
    }
#line 325
    if (tmp___14) {
      {
#line 328
      rrd_free(& rrd);
      }
#line 329
      return (-1);
    }
#line 331
    goto switch_break;
    case_63: /* CIL Label */ 
#line 333
    if (optopt != 0) {
      {
#line 334
      rrd_set_error((char *)"unknown option \'%c\'", optopt);
      }
    } else {
      {
#line 336
      rrd_set_error((char *)"unknown option \'%s\'", *(argv + (optind - 1)));
      }
    }
    {
#line 337
    rrd_free(& rrd);
#line 338
    rrd_close(rrd_file);
    }
#line 339
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  if (optcnt > 0) {
    {
#line 343
    rrd_seek(rrd_file, (off_t )0, 0);
#line 344
    rrd_write(rrd_file, (void const   *)rrd.stat_head, sizeof(stat_head_t ));
#line 345
    rrd_write(rrd_file, (void const   *)rrd.ds_def, sizeof(ds_def_t ) * (rrd.stat_head)->ds_cnt);
#line 348
    rrd_write(rrd_file, (void const   *)rrd.rra_def, sizeof(rra_def_t ) * (rrd.stat_head)->rra_cnt);
    }
  } else {
#line 353
    i = 0;
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 353
      if (! (i < (int )(rrd.stat_head)->ds_cnt)) {
#line 353
        goto while_break___0;
      }
      {
#line 354
      tmp___15 = dst_conv((rrd.ds_def + i)->dst);
      }
#line 354
      if ((unsigned int )tmp___15 != 4U) {
        {
#line 355
        printf((char const   */* __restrict  */)"DS[%s] typ: %s\thbt: %ld\tmin: %1.4f\tmax: %1.4f\n",
               (rrd.ds_def + i)->ds_nam, (rrd.ds_def + i)->dst, (rrd.ds_def + i)->par[0].u_cnt,
               (rrd.ds_def + i)->par[1].u_val, (rrd.ds_def + i)->par[2].u_val);
        }
      } else {
        {
#line 362
        buffer = (char *)((void *)0);
#line 364
        rpn_compact2str((rpn_cdefds_t *)(& (rrd.ds_def + i)->par[0]), rrd.ds_def,
                        & buffer);
#line 367
        printf((char const   */* __restrict  */)"DS[%s] typ: %s\tcdef: %s\n", (rrd.ds_def + i)->ds_nam,
               (rrd.ds_def + i)->dst, buffer);
#line 369
        free((void *)buffer);
        }
      }
#line 353
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 372
  rrd_close(rrd_file);
#line 373
  rrd_free(& rrd);
  }
#line 374
  return (0);
}
}
#line 377 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tune.c"
int set_hwarg(rrd_t *rrd , enum cf_en cf , enum rra_par_en rra_par , char *arg ) 
{ 
  double param ;
  unsigned long i ;
  short rra_idx ;
  enum cf_en tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 385
  rra_idx = (short)-1;
#line 388
  param = atof((char const   *)arg);
  }
#line 389
  if (param <= 0.0) {
    {
#line 390
    rrd_set_error((char *)"Holt-Winters parameter must be between 0 and 1");
    }
#line 391
    return (-1);
  } else
#line 389
  if (param >= 1.0) {
    {
#line 390
    rrd_set_error((char *)"Holt-Winters parameter must be between 0 and 1");
    }
#line 391
    return (-1);
  }
#line 394
  i = 0UL;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (i < (rrd->stat_head)->rra_cnt)) {
#line 394
      goto while_break;
    }
    {
#line 395
    tmp = cf_conv((char const   *)((rrd->rra_def + i)->cf_nam));
    }
#line 395
    if ((unsigned int )tmp == (unsigned int )cf) {
#line 396
      rra_idx = (short )i;
#line 397
      goto while_break;
    }
#line 394
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  if ((int )rra_idx == -1) {
    {
#line 401
    rrd_set_error((char *)"Holt-Winters RRA does not exist in this RRD");
    }
#line 402
    return (-1);
  }
#line 406
  (rrd->rra_def + rra_idx)->par[rra_par].u_val = param;
#line 407
  return (0);
}
}
#line 410 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tune.c"
int set_hwsmootharg(rrd_t *rrd , enum cf_en cf , enum rra_par_en rra_par , char *arg ) 
{ 
  double param ;
  unsigned long i ;
  short rra_idx ;
  enum cf_en tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 418
  rra_idx = (short)-1;
#line 421
  param = atof((char const   *)arg);
  }
#line 424
  if (param < 0.0) {
    {
#line 425
    rrd_set_error((char *)"Holt-Winters parameter must be between 0 and 1");
    }
#line 426
    return (-1);
  } else
#line 424
  if (param > 1.0) {
    {
#line 425
    rrd_set_error((char *)"Holt-Winters parameter must be between 0 and 1");
    }
#line 426
    return (-1);
  }
#line 429
  i = 0UL;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (i < (rrd->stat_head)->rra_cnt)) {
#line 429
      goto while_break;
    }
    {
#line 430
    tmp = cf_conv((char const   *)((rrd->rra_def + i)->cf_nam));
    }
#line 430
    if ((unsigned int )tmp == (unsigned int )cf) {
#line 431
      rra_idx = (short )i;
#line 432
      goto while_break;
    }
#line 429
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  if ((int )rra_idx == -1) {
    {
#line 436
    rrd_set_error((char *)"Holt-Winters RRA does not exist in this RRD");
    }
#line 437
    return (-1);
  }
#line 441
  (rrd->rra_def + rra_idx)->par[rra_par].u_val = param;
#line 442
  return (0);
}
}
#line 445 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tune.c"
int set_deltaarg(rrd_t *rrd , enum rra_par_en rra_par , char *arg ) 
{ 
  rrd_value_t param ;
  unsigned long i ;
  short rra_idx ;
  enum cf_en tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 452
  rra_idx = (short)-1;
#line 454
  param = atof((char const   *)arg);
  }
#line 455
  if (param < 0.1) {
    {
#line 456
    rrd_set_error((char *)"Parameter specified is too small");
    }
#line 457
    return (-1);
  }
#line 460
  i = 0UL;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (i < (rrd->stat_head)->rra_cnt)) {
#line 460
      goto while_break;
    }
    {
#line 461
    tmp = cf_conv((char const   *)((rrd->rra_def + i)->cf_nam));
    }
#line 461
    if ((unsigned int )tmp == 8U) {
#line 462
      rra_idx = (short )i;
#line 463
      goto while_break;
    }
#line 460
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  if ((int )rra_idx == -1) {
    {
#line 467
    rrd_set_error((char *)"Failures RRA does not exist in this RRD");
    }
#line 468
    return (-1);
  }
#line 472
  (rrd->rra_def + rra_idx)->par[rra_par].u_val = param;
#line 473
  return (0);
}
}
#line 476 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tune.c"
int set_windowarg(rrd_t *rrd , enum rra_par_en rra_par , char *arg ) 
{ 
  unsigned long param ;
  unsigned long i ;
  unsigned long cdp_idx ;
  short rra_idx ;
  int tmp ;
  enum cf_en tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 483
  rra_idx = (short)-1;
#line 486
  tmp = atoi((char const   *)arg);
#line 486
  param = (unsigned long )tmp;
  }
#line 487
  if (param < 1UL) {
    {
#line 488
    rrd_set_error((char *)"Parameter must be between %d and %d", 1, 28);
    }
#line 490
    return (-1);
  } else
#line 487
  if (param > 28UL) {
    {
#line 488
    rrd_set_error((char *)"Parameter must be between %d and %d", 1, 28);
    }
#line 490
    return (-1);
  }
#line 493
  i = 0UL;
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! (i < (rrd->stat_head)->rra_cnt)) {
#line 493
      goto while_break;
    }
    {
#line 494
    tmp___0 = cf_conv((char const   *)((rrd->rra_def + i)->cf_nam));
    }
#line 494
    if ((unsigned int )tmp___0 == 8U) {
#line 495
      rra_idx = (short )i;
#line 496
      goto while_break;
    }
#line 493
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 499
  if ((int )rra_idx == -1) {
    {
#line 500
    rrd_set_error((char *)"Failures RRA does not exist in this RRD");
    }
#line 501
    return (-1);
  }
#line 505
  (rrd->rra_def + rra_idx)->par[rra_par].u_cnt = param;
#line 508
  i = 0UL;
  {
#line 508
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 508
    if (! (i < (rrd->stat_head)->ds_cnt)) {
#line 508
      goto while_break___0;
    }
    {
#line 509
    cdp_idx = (unsigned long )rra_idx * (rrd->stat_head)->ds_cnt + i;
#line 510
    erase_violations(rrd, cdp_idx, (unsigned long )rra_idx);
#line 508
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 512
  return (0);
}
}
#line 204 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_resize(int argc , char **argv ) ;
#line 13 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_resize.c"
int rrd_resize(int argc , char **argv ) 
{ 
  char *infilename ;
  char outfilename[11] ;
  rrd_t rrdold ;
  rrd_t rrdnew ;
  rrd_value_t buffer ;
  int version ;
  unsigned long l ;
  unsigned long rra ;
  long modify ;
  unsigned long target_rra ;
  int shrink ;
  char *endptr ;
  rrd_file_t *rrd_file ;
  rrd_file_t *rrd_out_file ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  long remove_end ;
  unsigned int tmp___10 ;
  ssize_t b_read ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  int __cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  int __cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
  {
#line 17
  outfilename[0] = (char )'r';
#line 17
  outfilename[1] = (char )'e';
#line 17
  outfilename[2] = (char )'s';
#line 17
  outfilename[3] = (char )'i';
#line 17
  outfilename[4] = (char )'z';
#line 17
  outfilename[5] = (char )'e';
#line 17
  outfilename[6] = (char )'.';
#line 17
  outfilename[7] = (char )'r';
#line 17
  outfilename[8] = (char )'r';
#line 17
  outfilename[9] = (char )'d';
#line 17
  outfilename[10] = (char )'\000';
#line 24
  shrink = 0;
#line 28
  infilename = *(argv + 1);
#line 29
  tmp = strcmp((char const   *)infilename, "resize.rrd");
  }
#line 29
  if (! tmp) {
    {
#line 30
    rrd_set_error((char *)"resize.rrd is a reserved name");
    }
#line 31
    return (-1);
  }
#line 33
  if (argc != 5) {
    {
#line 34
    rrd_set_error((char *)"wrong number of parameters");
    }
#line 35
    return (-1);
  }
  {
#line 38
  tmp___0 = strtol((char const   */* __restrict  */)*(argv + 2), (char **/* __restrict  */)(& endptr),
                   0);
#line 38
  target_rra = (unsigned long )tmp___0;
#line 40
  tmp___2 = strcmp((char const   *)*(argv + 3), "GROW");
  }
#line 40
  if (tmp___2) {
    {
#line 42
    tmp___1 = strcmp((char const   *)*(argv + 3), "SHRINK");
    }
#line 42
    if (tmp___1) {
      {
#line 45
      rrd_set_error((char *)"I can only GROW or SHRINK");
      }
#line 46
      return (-1);
    } else {
#line 43
      shrink = 1;
    }
  } else {
#line 41
    shrink = 0;
  }
  {
#line 49
  modify = strtol((char const   */* __restrict  */)*(argv + 4), (char **/* __restrict  */)(& endptr),
                  0);
  }
#line 51
  if (modify < 1L) {
    {
#line 52
    rrd_set_error((char *)"Please grow or shrink with at least 1 row");
    }
#line 53
    return (-1);
  }
#line 56
  if (shrink) {
#line 57
    modify = - modify;
  }
  {
#line 60
  rrd_init(& rrdold);
#line 61
  rrd_file = rrd_open((char const   */* const  */)infilename, & rrdold, (unsigned int )((1 << 1) | (1 << 4)));
  }
#line 62
  if ((unsigned long )rrd_file == (unsigned long )((void *)0)) {
    {
#line 63
    rrd_free(& rrdold);
    }
#line 64
    return (-1);
  }
  {
#line 67
  tmp___3 = rrd_lock(rrd_file);
  }
#line 67
  if (tmp___3 != 0) {
    {
#line 68
    rrd_set_error((char *)"could not lock original RRD");
#line 69
    rrd_free(& rrdold);
#line 70
    rrd_close(rrd_file);
    }
#line 71
    return (-1);
  }
#line 75
  if (target_rra >= (rrdold.stat_head)->rra_cnt) {
    {
#line 76
    rrd_set_error((char *)"no such RRA in this RRD");
#line 77
    rrd_free(& rrdold);
#line 78
    rrd_close(rrd_file);
    }
#line 79
    return (-1);
  }
#line 82
  if (modify < 0L) {
#line 83
    if ((long )(rrdold.rra_def + target_rra)->row_cnt <= - modify) {
      {
#line 84
      rrd_set_error((char *)"This RRA is not that big");
#line 85
      rrd_free(& rrdold);
#line 86
      rrd_close(rrd_file);
      }
#line 87
      return (-1);
    }
  }
  {
#line 90
  rrd_init(& rrdnew);
#line 94
  tmp___4 = calloc((size_t )1, sizeof(stat_head_t ));
#line 94
  rrdnew.stat_head = (stat_head_t *)tmp___4;
  }
#line 94
  if ((unsigned long )rrdnew.stat_head == (unsigned long )((void *)0)) {
    {
#line 95
    rrd_set_error((char *)"allocating stat_head for new RRD");
#line 96
    rrd_free(& rrdold);
#line 97
    rrd_close(rrd_file);
    }
#line 98
    return (-1);
  }
  {
#line 100
  memcpy((void */* __restrict  */)rrdnew.stat_head, (void const   */* __restrict  */)rrdold.stat_head,
         sizeof(stat_head_t ));
#line 102
  tmp___5 = malloc(sizeof(rra_def_t ) * (rrdold.stat_head)->rra_cnt);
#line 102
  rrdnew.rra_def = (rra_def_t *)tmp___5;
  }
#line 102
  if ((unsigned long )rrdnew.rra_def == (unsigned long )((void *)0)) {
    {
#line 103
    rrd_set_error((char *)"allocating rra_def for new RRD");
#line 104
    rrd_free(& rrdnew);
#line 105
    rrd_free(& rrdold);
#line 106
    rrd_close(rrd_file);
    }
#line 107
    return (-1);
  }
  {
#line 109
  memcpy((void */* __restrict  */)rrdnew.rra_def, (void const   */* __restrict  */)rrdold.rra_def,
         sizeof(rra_def_t ) * (rrdold.stat_head)->rra_cnt);
#line 112
  (rrdnew.rra_def + target_rra)->row_cnt += (unsigned long )modify;
#line 114
  rrd_out_file = rrd_open((char const   */* const  */)(outfilename), & rrdnew, (unsigned int )((1 << 1) | (1 << 2)));
  }
#line 115
  if ((unsigned long )rrd_out_file == (unsigned long )((void *)0)) {
    {
#line 116
    tmp___6 = __errno_location();
#line 116
    tmp___7 = rrd_strerror(*tmp___6);
#line 116
    rrd_set_error((char *)"Can\'t create \'%s\': %s", outfilename, tmp___7);
#line 118
    rrd_free(& rrdnew);
#line 119
    rrd_free(& rrdold);
#line 120
    rrd_close(rrd_file);
    }
#line 121
    return (-1);
  }
  {
#line 123
  tmp___8 = rrd_lock(rrd_out_file);
  }
#line 123
  if (tmp___8 != 0) {
    {
#line 124
    rrd_set_error((char *)"could not lock new RRD");
#line 125
    rrd_free(& rrdnew);
#line 126
    rrd_free(& rrdold);
#line 127
    rrd_close(rrd_file);
#line 128
    rrd_close(rrd_out_file);
    }
#line 129
    return (-1);
  }
  {
#line 132
  tmp___9 = malloc(sizeof(rra_ptr_t ) * (rrdold.stat_head)->rra_cnt);
#line 132
  rrdnew.rra_ptr = (rra_ptr_t *)tmp___9;
  }
#line 132
  if ((unsigned long )rrdnew.rra_ptr == (unsigned long )((void *)0)) {
    {
#line 133
    rrd_set_error((char *)"allocating rra_ptr for new RRD");
#line 134
    rrd_free(& rrdnew);
#line 135
    rrd_free(& rrdold);
#line 136
    rrd_close(rrd_file);
#line 137
    rrd_close(rrd_out_file);
    }
#line 138
    return (-1);
  }
  {
#line 143
  (rrdnew.rra_def + target_rra)->row_cnt -= (unsigned long )modify;
#line 145
  rrdnew.ds_def = rrdold.ds_def;
#line 146
  rrdnew.live_head = rrdold.live_head;
#line 147
  rrdnew.pdp_prep = rrdold.pdp_prep;
#line 148
  rrdnew.cdp_prep = rrdold.cdp_prep;
#line 149
  memcpy((void */* __restrict  */)rrdnew.rra_ptr, (void const   */* __restrict  */)rrdold.rra_ptr,
         sizeof(rra_ptr_t ) * (rrdold.stat_head)->rra_cnt);
#line 152
  version = atoi((char const   *)((rrdold.stat_head)->version));
  }
  {
#line 154
  if (version == 4) {
#line 154
    goto case_4;
  }
#line 156
  if (version == 3) {
#line 156
    goto case_3;
  }
#line 158
  if (version == 1) {
#line 158
    goto case_1;
  }
#line 161
  goto switch_default;
  case_4: /* CIL Label */ 
#line 155
  goto switch_break;
  case_3: /* CIL Label */ 
#line 157
  goto switch_break;
  case_1: /* CIL Label */ 
#line 159
  (rrdnew.stat_head)->version[3] = (char )'3';
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 162
  rrd_set_error((char *)"Do not know how to handle RRD version %s", (rrdold.stat_head)->version);
#line 165
  rrdnew.ds_def = (ds_def_t *)((void *)0);
#line 166
  rrdnew.live_head = (live_head_t *)((void *)0);
#line 167
  rrdnew.pdp_prep = (pdp_prep_t *)((void *)0);
#line 168
  rrdnew.cdp_prep = (cdp_prep_t *)((void *)0);
#line 170
  rrd_free(& rrdnew);
#line 171
  rrd_free(& rrdold);
#line 172
  rrd_close(rrd_file);
#line 173
  rrd_close(rrd_out_file);
  }
#line 174
  return (-1);
#line 175
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 179
  rrd_write(rrd_out_file, (void const   *)rrdnew.stat_head, sizeof(stat_head_t ));
#line 180
  rrd_write(rrd_out_file, (void const   *)rrdnew.ds_def, sizeof(ds_def_t ) * (rrdnew.stat_head)->ds_cnt);
#line 182
  rrd_write(rrd_out_file, (void const   *)rrdnew.rra_def, sizeof(rra_def_t ) * (rrdnew.stat_head)->rra_cnt);
#line 184
  rrd_write(rrd_out_file, (void const   *)rrdnew.live_head, sizeof(live_head_t ));
#line 185
  rrd_write(rrd_out_file, (void const   *)rrdnew.pdp_prep, sizeof(pdp_prep_t ) * (rrdnew.stat_head)->ds_cnt);
#line 187
  rrd_write(rrd_out_file, (void const   *)rrdnew.cdp_prep, (sizeof(cdp_prep_t ) * (rrdnew.stat_head)->ds_cnt) * (rrdnew.stat_head)->rra_cnt);
#line 190
  rrd_write(rrd_out_file, (void const   *)rrdnew.rra_ptr, sizeof(rra_ptr_t ) * (rrdnew.stat_head)->rra_cnt);
#line 200
  l = 0UL;
#line 201
  rra = 0UL;
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (rra < target_rra)) {
#line 201
      goto while_break;
    }
#line 202
    l += (rrdnew.stat_head)->ds_cnt * (rrdnew.rra_def + rra)->row_cnt;
#line 201
    rra ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! (l > 0UL)) {
#line 204
      goto while_break___0;
    }
    {
#line 205
    rrd_read(rrd_file, (void *)(& buffer), sizeof(rrd_value_t ));
#line 206
    rrd_write(rrd_out_file, (void const   *)(& buffer), sizeof(rrd_value_t ));
#line 207
    l --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 211
  if (modify > 0L) {
#line 215
    l = (rrdnew.stat_head)->ds_cnt * ((rrdnew.rra_ptr + target_rra)->cur_row + 1UL);
    {
#line 217
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 217
      if (! (l > 0UL)) {
#line 217
        goto while_break___1;
      }
      {
#line 218
      rrd_read(rrd_file, (void *)(& buffer), sizeof(rrd_value_t ));
#line 219
      rrd_write(rrd_out_file, (void const   *)(& buffer), sizeof(rrd_value_t ));
#line 220
      l --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 222
    buffer = rrd_set_to_DNAN();
#line 223
    l = (rrdnew.stat_head)->ds_cnt * (unsigned long )modify;
    }
    {
#line 224
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 224
      if (! (l > 0UL)) {
#line 224
        goto while_break___2;
      }
      {
#line 225
      rrd_write(rrd_out_file, (void const   *)(& buffer), sizeof(rrd_value_t ));
#line 226
      l --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 233
    remove_end = 0L;
#line 235
    remove_end = (long )(((rrdnew.rra_ptr + target_rra)->cur_row - (unsigned long )modify) % (rrdnew.rra_def + target_rra)->row_cnt);
#line 238
    if (remove_end <= (long )(rrdnew.rra_ptr + target_rra)->cur_row) {
      {
#line 240
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 240
        if (! (remove_end >= 0L)) {
#line 240
          goto while_break___3;
        }
        {
#line 241
        rrd_seek(rrd_file, (off_t )(sizeof(rrd_value_t ) * (rrdnew.stat_head)->ds_cnt),
                 1);
#line 244
        ((rrdnew.rra_ptr + target_rra)->cur_row) --;
#line 245
        ((rrdnew.rra_def + target_rra)->row_cnt) --;
#line 246
        remove_end --;
#line 247
        modify ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 249
      remove_end = (long )((rrdnew.rra_def + target_rra)->row_cnt - 1UL);
    }
#line 251
    l = 0UL;
    {
#line 251
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 251
      if (! (l <= (rrdnew.rra_ptr + target_rra)->cur_row)) {
#line 251
        goto while_break___4;
      }
#line 254
      tmp___10 = 0U;
      {
#line 254
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 254
        if (! ((unsigned long )tmp___10 < (rrdnew.stat_head)->ds_cnt)) {
#line 254
          goto while_break___5;
        }
        {
#line 255
        rrd_read(rrd_file, (void *)(& buffer), sizeof(rrd_value_t ));
#line 256
        rrd_write(rrd_out_file, (void const   *)(& buffer), sizeof(rrd_value_t ));
#line 254
        tmp___10 ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 251
      l ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 259
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 259
      if (! (modify < 0L)) {
#line 259
        goto while_break___6;
      }
      {
#line 260
      rrd_seek(rrd_file, (off_t )(sizeof(rrd_value_t ) * (rrdnew.stat_head)->ds_cnt),
               1);
#line 263
      ((rrdnew.rra_def + target_rra)->row_cnt) --;
#line 264
      modify ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 269
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 271
    b_read = rrd_read(rrd_file, (void *)(& buffer), sizeof(rrd_value_t ));
    }
#line 271
    if (b_read <= 0L) {
#line 272
      goto while_break___7;
    }
#line 273
    if (rrd_out_file->pos + (size_t )b_read > rrd_out_file->file_len) {
      {
#line 274
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: ignoring last %zu bytes\nWARNING: if you see this message multiple times for a single file you\'re in trouble\n",
              b_read);
      }
#line 275
      goto while_continue___7;
    }
    {
#line 277
    rrd_write(rrd_out_file, (void const   *)(& buffer), (size_t )b_read);
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 279
  (rrdnew.rra_def + target_rra)->row_cnt += (unsigned long )modify;
#line 280
  rrd_seek(rrd_out_file, (off_t )(sizeof(stat_head_t ) + sizeof(ds_def_t ) * (rrdnew.stat_head)->ds_cnt),
           0);
#line 283
  rrd_write(rrd_out_file, (void const   *)rrdnew.rra_def, sizeof(rra_def_t ) * (rrdnew.stat_head)->rra_cnt);
#line 285
  rrd_seek(rrd_out_file, (off_t )sizeof(live_head_t ), 1);
#line 286
  rrd_seek(rrd_out_file, (off_t )(sizeof(pdp_prep_t ) * (rrdnew.stat_head)->ds_cnt),
           1);
#line 288
  rrd_seek(rrd_out_file, (off_t )((sizeof(cdp_prep_t ) * (rrdnew.stat_head)->ds_cnt) * (rrdnew.stat_head)->rra_cnt),
           1);
#line 291
  rrd_write(rrd_out_file, (void const   *)rrdnew.rra_ptr, sizeof(rra_ptr_t ) * (rrdnew.stat_head)->rra_cnt);
#line 293
  rrd_close(rrd_file);
#line 294
  rrd_close(rrd_out_file);
#line 295
  rrd_free(& rrdold);
#line 297
  rrdnew.ds_def = (ds_def_t *)((void *)0);
#line 298
  rrdnew.live_head = (live_head_t *)((void *)0);
#line 299
  rrdnew.pdp_prep = (pdp_prep_t *)((void *)0);
#line 300
  rrdnew.cdp_prep = (cdp_prep_t *)((void *)0);
#line 302
  rrd_free(& rrdnew);
  }
#line 303
  return (0);
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) labs)(long __x )  __attribute__((__const__)) ;
#line 179 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_fetch(int argc , char **argv , time_t *start , time_t *end , unsigned long *step ,
              unsigned long *ds_cnt , char ***ds_namv , rrd_value_t **data ) ;
#line 243
int rrd_fetch_r(char const   *filename , char const   *cf , time_t *start , time_t *end ,
                unsigned long *step , unsigned long *ds_cnt , char ***ds_namv , rrd_value_t **data ) ;
#line 61 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_fetch.c"
int rrd_fetch(int argc , char **argv , time_t *start , time_t *end , unsigned long *step ,
              unsigned long *ds_cnt , char ***ds_namv , rrd_value_t **data ) 
{ 
  long step_tmp ;
  time_t start_tmp ;
  time_t end_tmp ;
  char const   *cf ;
  char *opt_daemon ;
  int status ;
  rrd_time_value_t start_tv ;
  rrd_time_value_t end_tv ;
  char *parsetime_error ;
  struct option long_options___5[5] ;
  int option_index ;
  int opt ;
  int tmp ;
  void *__cil_tmp22 ;
  int __cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 73
  step_tmp = 1L;
#line 74
  start_tmp = (time_t )0;
#line 74
  end_tmp = (time_t )0;
#line 76
  opt_daemon = (char *)((void *)0);
#line 80
  parsetime_error = (char *)((void *)0);
#line 81
  long_options___5[0].name = "resolution";
#line 81
  long_options___5[0].has_arg = 1;
#line 81
  long_options___5[0].flag = (int *)0;
#line 81
  long_options___5[0].val = 'r';
#line 81
  long_options___5[1].name = "start";
#line 81
  long_options___5[1].has_arg = 1;
#line 81
  long_options___5[1].flag = (int *)0;
#line 81
  long_options___5[1].val = 's';
#line 81
  long_options___5[2].name = "end";
#line 81
  long_options___5[2].has_arg = 1;
#line 81
  long_options___5[2].flag = (int *)0;
#line 81
  long_options___5[2].val = 'e';
#line 81
  long_options___5[3].name = "daemon";
#line 81
  long_options___5[3].has_arg = 1;
#line 81
  long_options___5[3].flag = (int *)0;
#line 81
  long_options___5[3].val = 'd';
#line 81
  long_options___5[4].name = (char const   *)0;
#line 81
  long_options___5[4].has_arg = 0;
#line 81
  long_options___5[4].flag = (int *)0;
#line 81
  long_options___5[4].val = 0;
#line 89
  optind = 0;
#line 90
  opterr = 0;
#line 93
  rrd_parsetime("end-24h", & start_tv);
#line 94
  rrd_parsetime("now", & end_tv);
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    option_index = 0;
#line 100
    opt = getopt_long(argc, (char * const  *)argv, "r:s:e:d:", (struct option  const  *)(long_options___5),
                      & option_index);
    }
#line 102
    if (opt == -1) {
#line 103
      goto while_break;
    }
    {
#line 106
    if (opt == 115) {
#line 106
      goto case_115;
    }
#line 112
    if (opt == 101) {
#line 112
      goto case_101;
    }
#line 118
    if (opt == 114) {
#line 118
      goto case_114;
    }
#line 122
    if (opt == 100) {
#line 122
      goto case_100;
    }
#line 133
    if (opt == 63) {
#line 133
      goto case_63;
    }
#line 105
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 107
    parsetime_error = rrd_parsetime((char const   *)optarg, & start_tv);
    }
#line 107
    if (parsetime_error) {
      {
#line 108
      rrd_set_error((char *)"start time: %s", parsetime_error);
      }
#line 109
      return (-1);
    }
#line 111
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 113
    parsetime_error = rrd_parsetime((char const   *)optarg, & end_tv);
    }
#line 113
    if (parsetime_error) {
      {
#line 114
      rrd_set_error((char *)"end time: %s", parsetime_error);
      }
#line 115
      return (-1);
    }
#line 117
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 119
    step_tmp = atol((char const   *)optarg);
    }
#line 120
    goto switch_break;
    case_100: /* CIL Label */ 
#line 123
    if ((unsigned long )opt_daemon != (unsigned long )((void *)0)) {
      {
#line 124
      free((void *)opt_daemon);
      }
    }
    {
#line 125
    opt_daemon = strdup((char const   *)optarg);
    }
#line 126
    if ((unsigned long )opt_daemon == (unsigned long )((void *)0)) {
      {
#line 128
      rrd_set_error((char *)"strdup failed.");
      }
#line 129
      return (-1);
    }
#line 131
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 134
    rrd_set_error((char *)"unknown option \'-%c\'", optopt);
    }
#line 135
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  tmp = rrd_proc_start_end(& start_tv, & end_tv, & start_tmp, & end_tmp);
  }
#line 140
  if (tmp == -1) {
#line 141
    return (-1);
  }
#line 145
  if (start_tmp < 315360000L) {
    {
#line 146
    rrd_set_error((char *)"the first entry to fetch should be after 1980");
    }
#line 147
    return (-1);
  }
#line 150
  if (end_tmp < start_tmp) {
    {
#line 151
    rrd_set_error((char *)"start (%ld) should be less than end (%ld)", start_tmp,
                  end_tmp);
    }
#line 153
    return (-1);
  }
#line 156
  *start = start_tmp;
#line 157
  *end = end_tmp;
#line 159
  if (step_tmp < 1L) {
    {
#line 160
    rrd_set_error((char *)"step must be >= 1 second");
    }
#line 161
    return (-1);
  }
#line 163
  *step = (unsigned long )step_tmp;
#line 165
  if (optind + 1 >= argc) {
    {
#line 166
    rrd_set_error((char *)"Usage: rrdtool %s <file> <CF> [options]", *(argv + 0));
    }
#line 167
    return (-1);
  }
  {
#line 170
  status = rrdc_flush_if_daemon((char const   *)opt_daemon, (char const   *)*(argv + optind));
  }
#line 171
  if (opt_daemon) {
    {
#line 171
    free((void *)opt_daemon);
    }
  }
#line 172
  if (status) {
#line 172
    return (-1);
  }
  {
#line 174
  cf = (char const   *)*(argv + (optind + 1));
#line 176
  status = rrd_fetch_r((char const   *)*(argv + optind), cf, start, end, step, ds_cnt,
                       ds_namv, data);
  }
#line 178
  if (status != 0) {
#line 179
    return (-1);
  }
#line 180
  return (0);
}
}
#line 183 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_fetch.c"
int rrd_fetch_r(char const   *filename , char const   *cf , time_t *start , time_t *end ,
                unsigned long *step , unsigned long *ds_cnt , char ***ds_namv , rrd_value_t **data ) 
{ 
  enum cf_en cf_idx ;
  int tmp ;

  {
  {
#line 197
  cf_idx = cf_conv(cf);
  }
#line 197
  if ((int )cf_idx == -1) {
#line 198
    return (-1);
  }
  {
#line 201
  tmp = rrd_fetch_fn(filename, cf_idx, start, end, step, ds_cnt, ds_namv, data);
  }
#line 201
  return (tmp);
}
}
#line 205 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_fetch.c"
int rrd_fetch_fn(char const   *filename , enum cf_en cf_idx , time_t *start , time_t *end ,
                 unsigned long *step , unsigned long *ds_cnt , char ***ds_namv , rrd_value_t **data ) 
{ 
  long i ;
  long ii ;
  time_t cal_start ;
  time_t cal_end ;
  time_t rra_start_time ;
  time_t rra_end_time ;
  long best_full_rra ;
  long best_part_rra ;
  long chosen_rra ;
  long rra_pointer ;
  long best_full_step_diff ;
  long best_part_step_diff ;
  long tmp_step_diff ;
  long tmp_match ;
  long best_match ;
  long full_match ;
  long rra_base ;
  off_t start_offset ;
  off_t end_offset ;
  int first_full ;
  int first_part ;
  rrd_t rrd ;
  rrd_file_t *rrd_file ;
  rrd_value_t *data_ptr ;
  unsigned long rows ;
  char **tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  enum cf_en tmp___3 ;
  rrd_value_t *tmp___4 ;
  void *tmp___5 ;
  off_t tmp___6 ;
  rrd_value_t *tmp___7 ;
  rrd_value_t *tmp___8 ;
  off_t tmp___9 ;
  ssize_t tmp___10 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
  {
#line 219
  best_full_rra = 0L;
#line 219
  best_part_rra = 0L;
#line 219
  chosen_rra = 0L;
#line 219
  rra_pointer = 0L;
#line 221
  best_full_step_diff = 0L;
#line 221
  best_part_step_diff = 0L;
#line 221
  tmp_step_diff = 0L;
#line 221
  tmp_match = 0L;
#line 221
  best_match = 0L;
#line 225
  first_full = 1;
#line 226
  first_part = 1;
#line 245
  rrd_init(& rrd);
#line 246
  rrd_file = rrd_open((char const   */* const  */)filename, & rrd, 1U);
  }
#line 247
  if ((unsigned long )rrd_file == (unsigned long )((void *)0)) {
#line 248
    goto err_free;
  }
  {
#line 252
  tmp___0 = malloc((rrd.stat_head)->ds_cnt * sizeof(char *));
#line 252
  tmp = (char **)tmp___0;
#line 252
  *ds_namv = tmp;
  }
#line 252
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 254
    rrd_set_error((char *)"malloc fetch ds_namv array");
    }
#line 255
    goto err_close;
  }
#line 258
  i = 0L;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! ((unsigned long )i < (rrd.stat_head)->ds_cnt)) {
#line 258
      goto while_break;
    }
    {
#line 259
    tmp___2 = malloc(sizeof(char ) * 20UL);
#line 259
    tmp___1 = (char *)tmp___2;
#line 259
    *(*ds_namv + i) = tmp___1;
    }
#line 259
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 260
      rrd_set_error((char *)"malloc fetch ds_namv entry");
      }
#line 261
      goto err_free_ds_namv;
    }
    {
#line 263
    strncpy((char */* __restrict  */)*(*ds_namv + i), (char const   */* __restrict  */)((rrd.ds_def + i)->ds_nam),
            (size_t )19);
#line 264
    *(*(*ds_namv + i) + 19) = (char )'\000';
#line 258
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  i = 0L;
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! ((unsigned long )((unsigned int )i) < (rrd.stat_head)->rra_cnt)) {
#line 269
      goto while_break___0;
    }
    {
#line 270
    tmp___3 = cf_conv((char const   *)((rrd.rra_def + i)->cf_nam));
    }
#line 270
    if ((unsigned int )tmp___3 == (unsigned int )cf_idx) {
      {
#line 272
      cal_end = (time_t )((unsigned long )(rrd.live_head)->last_up - (unsigned long )(rrd.live_head)->last_up % ((rrd.rra_def + i)->pdp_cnt * (rrd.stat_head)->pdp_step));
#line 277
      cal_start = (time_t )((unsigned long )cal_end - ((rrd.rra_def + i)->pdp_cnt * (rrd.rra_def + i)->row_cnt) * (rrd.stat_head)->pdp_step);
#line 282
      full_match = *end - *start;
#line 289
      tmp_step_diff = labs((long )(*step - (rrd.stat_head)->pdp_step * (rrd.rra_def + i)->pdp_cnt));
      }
#line 292
      if (cal_start <= *start) {
#line 293
        if (first_full) {
#line 294
          first_full = 0;
#line 295
          best_full_step_diff = tmp_step_diff;
#line 296
          best_full_rra = i;
        } else
#line 293
        if (tmp_step_diff < best_full_step_diff) {
#line 294
          first_full = 0;
#line 295
          best_full_step_diff = tmp_step_diff;
#line 296
          best_full_rra = i;
        }
      } else {
#line 306
        tmp_match = full_match;
#line 307
        if (cal_start > *start) {
#line 308
          tmp_match -= cal_start - *start;
        }
#line 309
        if (first_part) {
#line 316
          first_part = 0;
#line 317
          best_match = tmp_match;
#line 318
          best_part_step_diff = tmp_step_diff;
#line 319
          best_part_rra = i;
        } else
#line 309
        if (best_match < tmp_match) {
#line 316
          first_part = 0;
#line 317
          best_match = tmp_match;
#line 318
          best_part_step_diff = tmp_step_diff;
#line 319
          best_part_rra = i;
        } else
#line 309
        if (best_match == tmp_match) {
#line 309
          if (tmp_step_diff < best_part_step_diff) {
#line 316
            first_part = 0;
#line 317
            best_match = tmp_match;
#line 318
            best_part_step_diff = tmp_step_diff;
#line 319
            best_part_rra = i;
          }
        }
      }
    }
#line 269
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  if (first_full == 0) {
#line 331
    chosen_rra = best_full_rra;
  } else
#line 332
  if (first_part == 0) {
#line 333
    chosen_rra = best_part_rra;
  } else {
    {
#line 335
    rrd_set_error((char *)"the RRD does not contain an RRA matching the chosen CF");
    }
#line 337
    goto err_free_all_ds_namv;
  }
  {
#line 341
  *step = (rrd.stat_head)->pdp_step * (rrd.rra_def + chosen_rra)->pdp_cnt;
#line 342
  *start = (time_t )((unsigned long )*start - (unsigned long )*start % *step);
#line 343
  *end = (time_t )((unsigned long )*end + (*step - (unsigned long )*end % *step));
#line 344
  rows = (unsigned long )(*end - *start) / *step + 1UL;
#line 358
  *ds_cnt = (rrd.stat_head)->ds_cnt;
#line 359
  tmp___5 = malloc((*ds_cnt * rows) * sizeof(rrd_value_t ));
#line 359
  tmp___4 = (rrd_value_t *)tmp___5;
#line 359
  *data = tmp___4;
  }
#line 359
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
    {
#line 360
    rrd_set_error((char *)"malloc fetch data area");
    }
#line 361
    goto err_free_all_ds_namv;
  }
#line 364
  data_ptr = *data;
#line 367
  rra_base = (long )rrd_file->header_len;
#line 368
  i = 0L;
  {
#line 368
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 368
    if (! (i < chosen_rra)) {
#line 368
      goto while_break___1;
    }
#line 369
    rra_base = (long )((unsigned long )rra_base + (*ds_cnt * (rrd.rra_def + i)->row_cnt) * sizeof(rrd_value_t ));
#line 368
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 372
  rra_end_time = (time_t )((unsigned long )(rrd.live_head)->last_up - (unsigned long )(rrd.live_head)->last_up % *step);
#line 374
  rra_start_time = (time_t )((unsigned long )rra_end_time - *step * ((rrd.rra_def + chosen_rra)->row_cnt - 1UL));
#line 377
  start_offset = (off_t )((((long long )*start + (long long )*step) - (long long )rra_start_time) / (long long )*step);
#line 378
  end_offset = (off_t )(((long long )rra_end_time - (long long )*end) / (long long )*step);
#line 385
  if (*start <= rra_end_time) {
#line 385
    if (*end >= rra_start_time - (off_t )*step) {
#line 386
      if (start_offset <= 0L) {
#line 387
        rra_pointer = (long )((rrd.rra_ptr + chosen_rra)->cur_row + 1UL);
      } else {
#line 389
        rra_pointer = (long )(((rrd.rra_ptr + chosen_rra)->cur_row + 1UL) + (unsigned long )start_offset);
      }
      {
#line 391
      rra_pointer %= (long )((int )(rrd.rra_def + chosen_rra)->row_cnt);
#line 393
      tmp___6 = rrd_seek(rrd_file, (off_t )((unsigned long )rra_base + ((unsigned long )rra_pointer * *ds_cnt) * sizeof(rrd_value_t )),
                         0);
      }
#line 393
      if (tmp___6 != 0L) {
        {
#line 396
        rrd_set_error((char *)"seek error in RRA");
        }
#line 397
        goto err_free_data;
      }
    }
  }
#line 407
  i = start_offset;
  {
#line 407
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 407
    if (! (i < (off_t )((int )(rrd.rra_def + chosen_rra)->row_cnt) - end_offset)) {
#line 407
      goto while_break___2;
    }
#line 410
    if (i < 0L) {
#line 414
      ii = 0L;
      {
#line 414
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 414
        if (! ((unsigned long )((unsigned int )ii) < *ds_cnt)) {
#line 414
          goto while_break___3;
        }
        {
#line 415
        tmp___7 = data_ptr;
#line 415
        data_ptr ++;
#line 415
        *tmp___7 = rrd_set_to_DNAN();
#line 414
        ii ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 422
    if (i >= (long )((int )(rrd.rra_def + chosen_rra)->row_cnt)) {
#line 426
      ii = 0L;
      {
#line 426
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 426
        if (! ((unsigned long )((unsigned int )ii) < *ds_cnt)) {
#line 426
          goto while_break___4;
        }
        {
#line 427
        tmp___8 = data_ptr;
#line 427
        data_ptr ++;
#line 427
        *tmp___8 = rrd_set_to_DNAN();
#line 426
        ii ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 435
      if (rra_pointer >= (long )((int )(rrd.rra_def + chosen_rra)->row_cnt)) {
        {
#line 436
        rra_pointer = (long )((unsigned long )rra_pointer - (rrd.rra_def + chosen_rra)->row_cnt);
#line 437
        tmp___9 = rrd_seek(rrd_file, (off_t )((unsigned long )rra_base + ((unsigned long )rra_pointer * *ds_cnt) * sizeof(rrd_value_t )),
                           0);
        }
#line 437
        if (tmp___9 != 0L) {
          {
#line 440
          rrd_set_error((char *)"wrap seek in RRA did fail");
          }
#line 441
          goto err_free_data;
        }
      }
      {
#line 448
      tmp___10 = rrd_read(rrd_file, (void *)data_ptr, sizeof(rrd_value_t ) * *ds_cnt);
      }
#line 448
      if (tmp___10 != (ssize_t )(sizeof(rrd_value_t ) * *ds_cnt)) {
        {
#line 450
        rrd_set_error((char *)"fetching cdp from rra");
        }
#line 451
        goto err_free_data;
      }
#line 458
      data_ptr += *ds_cnt;
#line 459
      rra_pointer ++;
    }
#line 407
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 467
  rrd_close(rrd_file);
#line 468
  rrd_free(& rrd);
  }
#line 469
  return (0);
  err_free_data: 
  {
#line 471
  free((void *)*data);
#line 472
  *data = (rrd_value_t *)((void *)0);
  }
  err_free_all_ds_namv: 
#line 474
  i = 0L;
  {
#line 474
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 474
    if (! ((unsigned long )i < (rrd.stat_head)->ds_cnt)) {
#line 474
      goto while_break___5;
    }
    {
#line 475
    free((void *)*(*ds_namv + i));
#line 474
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  err_free_ds_namv: 
  {
#line 477
  free((void *)*ds_namv);
  }
  err_close: 
  {
#line 479
  rrd_close(rrd_file);
  }
  err_free: 
  {
#line 481
  rrd_free(& rrd);
  }
#line 482
  return (-1);
}
}
#line 221 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_flushcached(int argc , char **argv ) ;
#line 38 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_flushcached.c"
static struct option long_options___0[2]  = {      {"daemon", 1, (int *)0, 'd'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 25 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_flushcached.c"
int rrd_flushcached(int argc , char **argv ) 
{ 
  char *opt_daemon ;
  int status ;
  int i ;
  int opt ;
  int tmp ;
  char *error ;
  int remaining ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 27
  opt_daemon = (char *)((void *)0);
#line 32
  optind = 0;
#line 33
  opterr = 0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 44
    opt = getopt_long(argc, (char * const  *)argv, "d:", (struct option  const  *)(long_options___0),
                      (int *)((void *)0));
    }
#line 46
    if (opt == -1) {
#line 47
      goto while_break;
    }
    {
#line 51
    if (opt == 100) {
#line 51
      goto case_100;
    }
#line 62
    goto switch_default;
    case_100: /* CIL Label */ 
#line 52
    if ((unsigned long )opt_daemon != (unsigned long )((void *)0)) {
      {
#line 53
      free((void *)opt_daemon);
      }
    }
    {
#line 54
    opt_daemon = strdup((char const   *)optarg);
    }
#line 55
    if ((unsigned long )opt_daemon == (unsigned long )((void *)0)) {
      {
#line 57
      rrd_set_error((char *)"strdup failed.");
      }
#line 58
      return (-1);
    }
#line 60
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 63
    rrd_set_error((char *)"Usage: rrdtool %s [--daemon <addr>] <file>", *(argv + 0));
    }
#line 65
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  if (argc - optind < 1) {
    {
#line 71
    rrd_set_error((char *)"Usage: rrdtool %s [--daemon <addr>] <file> [<file> ...]",
                  *(argv + 0));
    }
#line 72
    return (-1);
  }
  {
#line 76
  status = rrdc_connect((char const   *)opt_daemon);
  }
#line 77
  if (status != 0) {
#line 77
    goto out;
  }
  {
#line 79
  tmp = rrdc_is_connected((char const   *)opt_daemon);
  }
#line 79
  if (! tmp) {
    {
#line 81
    rrd_set_error((char *)"Daemon address unknown. Please use the \"--daemon\" option to set an address on the command line or set the \"%s\" environment variable.",
                  "RRDCACHED_ADDRESS");
#line 85
    status = -1;
    }
#line 86
    goto out;
  }
#line 89
  status = 0;
#line 90
  i = optind;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (i < argc)) {
#line 90
      goto while_break___0;
    }
    {
#line 92
    status = rrdc_flush((char const   *)*(argv + i));
    }
#line 93
    if (status) {
      {
#line 98
      tmp___0 = rrd_get_error();
#line 98
      error = strdup((char const   *)tmp___0);
#line 99
      remaining = (argc - optind) - 1;
      }
#line 101
      if (remaining == 1) {
#line 101
        tmp___1 = "";
      } else {
#line 101
        tmp___1 = "s";
      }
#line 101
      if (! error) {
#line 101
        tmp___2 = "unknown error";
      } else
#line 101
      if ((int )*error == 0) {
#line 101
        tmp___2 = "unknown error";
      } else {
#line 101
        tmp___2 = (char const   *)error;
      }
      {
#line 101
      rrd_set_error((char *)"Flushing of file \"%s\" failed: %s. Skipping remaining %i file%s.",
                    *(argv + i), tmp___2, remaining, tmp___1);
#line 105
      free((void *)error);
      }
#line 106
      goto while_break___0;
    }
#line 90
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  out: 
#line 111
  if (opt_daemon) {
    {
#line 111
    free((void *)opt_daemon);
    }
  }
#line 113
  return (status);
}
}
#line 191 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_dump(int argc , char **argv ) ;
#line 252
int rrd_dump_r(char const   *filename , char *outname ) ;
#line 265
int rrd_dump_cb_r(char const   *filename , int opt_header , size_t (*cb)(void const   * ,
                                                                         size_t  ,
                                                                         void * ) ,
                  void *user ) ;
#line 55 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_dump.c"
size_t rrd_dump_opt_cb_fileout(void const   *data , size_t len , void *user ) ;
#line 60
int rrd_dump_opt_r(char const   *filename , char *outname , int opt_noheader ) ;
#line 65 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_dump.c"
int rrd_dump_cb_r(char const   *filename , int opt_header , size_t (*cb)(void const   * ,
                                                                         size_t  ,
                                                                         void * ) ,
                  void *user ) 
{ 
  unsigned int i ;
  unsigned int ii ;
  unsigned int ix ;
  unsigned int iii ;
  time_t now ;
  char somestring[255] ;
  rrd_value_t my_cdp ;
  off_t rra_base ;
  off_t rra_start ;
  off_t rra_next ;
  rrd_file_t *rrd_file ;
  rrd_t rrd ;
  rrd_value_t value ;
  struct tm tm ;
  char *old_locale ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char buffer[256] ;
  size_t tmp___9 ;
  char buffer___0[256] ;
  size_t tmp___10 ;
  int tmp___11 ;
  char buffer___1[256] ;
  size_t tmp___12 ;
  char buffer___2[256] ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  char buffer___3[256] ;
  size_t tmp___15 ;
  char buffer___4[256] ;
  size_t tmp___16 ;
  char buffer___5[256] ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  char buffer___6[256] ;
  size_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  char buffer___7[256] ;
  size_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *str ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  enum dst_en tmp___35 ;
  size_t tmp___36 ;
  char buffer___8[256] ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  char buffer___9[256] ;
  size_t tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  char buffer___10[256] ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  long timer ;
  size_t tmp___48 ;
  char buffer___11[256] ;
  size_t tmp___49 ;
  char buffer___12[256] ;
  size_t tmp___50 ;
  size_t tmp___51 ;
  enum cf_en tmp___52 ;
  char buffer___13[256] ;
  size_t tmp___53 ;
  char buffer___14[256] ;
  size_t tmp___54 ;
  char buffer___15[256] ;
  size_t tmp___55 ;
  char buffer___16[256] ;
  size_t tmp___56 ;
  char buffer___17[256] ;
  size_t tmp___57 ;
  char buffer___18[256] ;
  size_t tmp___58 ;
  int tmp___59 ;
  char buffer___19[256] ;
  size_t tmp___60 ;
  char buffer___20[256] ;
  size_t tmp___61 ;
  char buffer___21[256] ;
  size_t tmp___62 ;
  char buffer___22[256] ;
  size_t tmp___63 ;
  char buffer___23[256] ;
  size_t tmp___64 ;
  char buffer___24[256] ;
  size_t tmp___65 ;
  char buffer___25[256] ;
  size_t tmp___66 ;
  size_t tmp___67 ;
  size_t tmp___68 ;
  unsigned long ivalue ;
  size_t tmp___69 ;
  size_t tmp___70 ;
  char buffer___26[256] ;
  size_t tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  size_t tmp___77 ;
  char buffer___27[256] ;
  size_t tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  enum cf_en tmp___84 ;
  size_t tmp___85 ;
  char buffer___28[256] ;
  size_t tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  size_t tmp___92 ;
  char buffer___29[256] ;
  size_t tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  size_t tmp___99 ;
  char buffer___30[256] ;
  size_t tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  size_t tmp___106 ;
  char buffer___31[256] ;
  size_t tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  char buffer___32[256] ;
  size_t tmp___113 ;
  char buffer___33[256] ;
  size_t tmp___114 ;
  size_t tmp___115 ;
  char buffer___34[256] ;
  size_t tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  size_t tmp___122 ;
  char buffer___35[256] ;
  size_t tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  char buffer___36[256] ;
  size_t tmp___129 ;
  unsigned short vidx ;
  char *violations_array ;
  size_t tmp___130 ;
  char buffer___37[256] ;
  size_t tmp___131 ;
  size_t tmp___132 ;
  size_t tmp___133 ;
  char buffer___38[256] ;
  size_t tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  char buffer___39[256] ;
  size_t tmp___140 ;
  size_t tmp___141 ;
  size_t tmp___142 ;
  size_t tmp___143 ;
  char buffer___40[256] ;
  size_t tmp___144 ;
  size_t tmp___145 ;
  char buffer___41[256] ;
  size_t tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  size_t tmp___152 ;
  size_t tmp___153 ;
  size_t tmp___154 ;
  int tmp___155 ;
  void *__cil_tmp225 ;
  void *__cil_tmp226 ;
  void *__cil_tmp227 ;
  void *__cil_tmp228 ;
  void *__cil_tmp229 ;
  void *__cil_tmp230 ;
  void *__cil_tmp231 ;
  void *__cil_tmp232 ;
  void *__cil_tmp233 ;
  void *__cil_tmp234 ;
  void *__cil_tmp235 ;
  void *__cil_tmp236 ;
  void *__cil_tmp237 ;
  void *__cil_tmp238 ;
  void *__cil_tmp239 ;
  void *__cil_tmp240 ;
  void *__cil_tmp241 ;
  void *__cil_tmp242 ;
  void *__cil_tmp243 ;
  void *__cil_tmp244 ;
  void *__cil_tmp245 ;
  void *__cil_tmp246 ;
  void *__cil_tmp247 ;
  void *__cil_tmp248 ;
  void *__cil_tmp249 ;
  void *__cil_tmp250 ;
  void *__cil_tmp251 ;
  void *__cil_tmp252 ;
  void *__cil_tmp253 ;
  void *__cil_tmp254 ;
  void *__cil_tmp255 ;
  void *__cil_tmp256 ;
  void *__cil_tmp257 ;
  void *__cil_tmp258 ;
  void *__cil_tmp259 ;
  void *__cil_tmp260 ;
  void *__cil_tmp261 ;
  void *__cil_tmp262 ;
  void *__cil_tmp263 ;
  void *__cil_tmp264 ;
  void *__cil_tmp265 ;
  void *__cil_tmp266 ;
  void *__cil_tmp267 ;
  void *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  char *__cil_tmp277 ;
  char *__cil_tmp278 ;
  char *__cil_tmp279 ;
  char *__cil_tmp280 ;
  char *__cil_tmp281 ;
  char *__cil_tmp282 ;
  char *__cil_tmp283 ;
  char *__cil_tmp284 ;
  char *__cil_tmp285 ;
  char *__cil_tmp286 ;
  char *__cil_tmp287 ;
  char *__cil_tmp288 ;
  char *__cil_tmp289 ;
  char *__cil_tmp290 ;
  char *__cil_tmp291 ;
  char *__cil_tmp292 ;
  char *__cil_tmp293 ;
  char *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;
  char *__cil_tmp380 ;
  char *__cil_tmp381 ;
  char *__cil_tmp382 ;
  char *__cil_tmp383 ;
  char *__cil_tmp384 ;
  char *__cil_tmp385 ;
  char *__cil_tmp386 ;
  char *__cil_tmp387 ;
  char *__cil_tmp388 ;
  char *__cil_tmp389 ;
  char *__cil_tmp390 ;
  char *__cil_tmp391 ;
  char *__cil_tmp392 ;
  char *__cil_tmp393 ;
  char *__cil_tmp394 ;
  char *__cil_tmp395 ;
  char *__cil_tmp396 ;
  char *__cil_tmp397 ;
  char *__cil_tmp398 ;
  char *__cil_tmp399 ;
  char *__cil_tmp400 ;
  char *__cil_tmp401 ;

  {
#line 71
  iii = 0U;
#line 80
  old_locale = (char *)"";
#line 94
  if (! cb) {
#line 95
    return (-1);
  }
  {
#line 98
  rrd_init(& rrd);
#line 100
  rrd_file = rrd_open((char const   */* const  */)filename, & rrd, (unsigned int )(1 | (1 << 3)));
  }
#line 101
  if ((unsigned long )rrd_file == (unsigned long )((void *)0)) {
    {
#line 102
    rrd_free(& rrd);
    }
#line 103
    return (-1);
  }
  {
#line 106
  old_locale = setlocale(1, (char const   *)((void *)0));
#line 107
  setlocale(1, "C");
  }
#line 110
  if (opt_header == 1) {
    {
#line 111
    tmp = strlen("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
#line 111
    (*cb)((void const   *)"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n", tmp, user);
#line 112
    tmp___0 = strlen("<!DOCTYPE rrd SYSTEM \"http://oss.oetiker.ch/rrdtool/rrdtool.dtd\">\n");
#line 112
    (*cb)((void const   *)"<!DOCTYPE rrd SYSTEM \"http://oss.oetiker.ch/rrdtool/rrdtool.dtd\">\n",
          tmp___0, user);
#line 113
    tmp___1 = strlen("<!-- Round Robin Database Dump -->\n");
#line 113
    (*cb)((void const   *)"<!-- Round Robin Database Dump -->\n", tmp___1, user);
#line 114
    tmp___2 = strlen("<rrd>\n");
#line 114
    (*cb)((void const   *)"<rrd>\n", tmp___2, user);
    }
  } else
#line 115
  if (opt_header == 2) {
    {
#line 116
    tmp___3 = strlen("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
#line 116
    (*cb)((void const   *)"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n", tmp___3,
          user);
#line 117
    tmp___4 = strlen("<!-- Round Robin Database Dump -->\n");
#line 117
    (*cb)((void const   *)"<!-- Round Robin Database Dump -->\n", tmp___4, user);
#line 118
    tmp___5 = strlen("<rrd xmlns=\"http://oss.oetiker.ch/rrdtool/rrdtool-dump.xml\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n");
#line 118
    (*cb)((void const   *)"<rrd xmlns=\"http://oss.oetiker.ch/rrdtool/rrdtool-dump.xml\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n",
          tmp___5, user);
#line 120
    tmp___6 = strlen("\txsi:schemaLocation=\"http://oss.oetiker.ch/rrdtool/rrdtool-dump.xml http://oss.oetiker.ch/rrdtool/rrdtool-dump.xsd\">\n");
#line 120
    (*cb)((void const   *)"\txsi:schemaLocation=\"http://oss.oetiker.ch/rrdtool/rrdtool-dump.xml http://oss.oetiker.ch/rrdtool/rrdtool-dump.xsd\">\n",
          tmp___6, user);
    }
  } else {
    {
#line 123
    tmp___7 = strlen("<!-- Round Robin Database Dump -->\n");
#line 123
    (*cb)((void const   *)"<!-- Round Robin Database Dump -->\n", tmp___7, user);
#line 124
    tmp___8 = strlen("<rrd>\n");
#line 124
    (*cb)((void const   *)"<rrd>\n", tmp___8, user);
    }
  }
  {
#line 127
  tmp___11 = atoi((char const   *)((rrd.stat_head)->version));
  }
#line 127
  if (tmp___11 <= 3) {
    {
#line 128
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 128
      snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"\t<version>%s</version>\n",
               "0003");
#line 128
      tmp___9 = strlen((char const   *)(buffer));
#line 128
      (*cb)((void const   *)(buffer), tmp___9, user);
      }
#line 128
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 130
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 130
      snprintf((char */* __restrict  */)(buffer___0), sizeof(buffer___0), (char const   */* __restrict  */)"\t<version>%s</version>\n",
               "0004");
#line 130
      tmp___10 = strlen((char const   *)(buffer___0));
#line 130
      (*cb)((void const   *)(buffer___0), tmp___10, user);
      }
#line 130
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 133
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 133
    snprintf((char */* __restrict  */)(buffer___1), sizeof(buffer___1), (char const   */* __restrict  */)"\t<step>%lu</step> <!-- Seconds -->\n",
             (rrd.stat_head)->pdp_step);
#line 133
    tmp___12 = strlen((char const   *)(buffer___1));
#line 133
    (*cb)((void const   *)(buffer___1), tmp___12, user);
    }
#line 133
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 137
  localtime_r((time_t const   */* __restrict  */)(& (rrd.live_head)->last_up), (struct tm */* __restrict  */)(& tm));
#line 138
  strftime((char */* __restrict  */)(somestring), (size_t )255, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S %Z",
           (struct tm  const  */* __restrict  */)(& tm));
  }
  {
#line 142
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 142
    snprintf((char */* __restrict  */)(buffer___2), sizeof(buffer___2), (char const   */* __restrict  */)"\t<lastupdate>%lld</lastupdate> <!-- %s -->\n\n",
             (long long )(rrd.live_head)->last_up, somestring);
#line 142
    tmp___13 = strlen((char const   *)(buffer___2));
#line 142
    (*cb)((void const   *)(buffer___2), tmp___13, user);
    }
#line 142
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 144
  i = 0U;
  {
#line 144
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 144
    if (! ((unsigned long )i < (rrd.stat_head)->ds_cnt)) {
#line 144
      goto while_break___3;
    }
    {
#line 145
    tmp___14 = strlen("\t<ds>\n");
#line 145
    (*cb)((void const   *)"\t<ds>\n", tmp___14, user);
    }
    {
#line 147
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 147
      snprintf((char */* __restrict  */)(buffer___3), sizeof(buffer___3), (char const   */* __restrict  */)"\t\t<name> %s </name>\n",
               (rrd.ds_def + i)->ds_nam);
#line 147
      tmp___15 = strlen((char const   *)(buffer___3));
#line 147
      (*cb)((void const   *)(buffer___3), tmp___15, user);
      }
#line 147
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 149
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 149
      snprintf((char */* __restrict  */)(buffer___4), sizeof(buffer___4), (char const   */* __restrict  */)"\t\t<type> %s </type>\n",
               (rrd.ds_def + i)->dst);
#line 149
      tmp___16 = strlen((char const   *)(buffer___4));
#line 149
      (*cb)((void const   *)(buffer___4), tmp___16, user);
      }
#line 149
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 151
    tmp___35 = dst_conv((rrd.ds_def + i)->dst);
    }
#line 151
    if ((unsigned int )tmp___35 != 4U) {
      {
#line 152
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 152
        snprintf((char */* __restrict  */)(buffer___5), sizeof(buffer___5), (char const   */* __restrict  */)"\t\t<minimal_heartbeat>%lu</minimal_heartbeat>\n",
                 (rrd.ds_def + i)->par[0].u_cnt);
#line 152
        tmp___17 = strlen((char const   *)(buffer___5));
#line 152
        (*cb)((void const   *)(buffer___5), tmp___17, user);
        }
#line 152
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 155
      if (sizeof((rrd.ds_def + i)->par[1].u_val) == sizeof(float )) {
        {
#line 155
        tmp___20 = __isnanf((float )(rrd.ds_def + i)->par[1].u_val);
#line 155
        tmp___24 = tmp___20;
        }
      } else {
#line 155
        if (sizeof((rrd.ds_def + i)->par[1].u_val) == sizeof(double )) {
          {
#line 155
          tmp___21 = __isnan((rrd.ds_def + i)->par[1].u_val);
#line 155
          tmp___23 = tmp___21;
          }
        } else {
          {
#line 155
          tmp___22 = __isnanl((long double )(rrd.ds_def + i)->par[1].u_val);
#line 155
          tmp___23 = tmp___22;
          }
        }
#line 155
        tmp___24 = tmp___23;
      }
#line 155
      if (tmp___24) {
        {
#line 156
        tmp___18 = strlen("\t\t<min>NaN</min>\n");
#line 156
        (*cb)((void const   *)"\t\t<min>NaN</min>\n", tmp___18, user);
        }
      } else {
        {
#line 158
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 158
          snprintf((char */* __restrict  */)(buffer___6), sizeof(buffer___6), (char const   */* __restrict  */)"\t\t<min>%0.10e</min>\n",
                   (rrd.ds_def + i)->par[1].u_val);
#line 158
          tmp___19 = strlen((char const   *)(buffer___6));
#line 158
          (*cb)((void const   *)(buffer___6), tmp___19, user);
          }
#line 158
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 162
      if (sizeof((rrd.ds_def + i)->par[2].u_val) == sizeof(float )) {
        {
#line 162
        tmp___27 = __isnanf((float )(rrd.ds_def + i)->par[2].u_val);
#line 162
        tmp___31 = tmp___27;
        }
      } else {
#line 162
        if (sizeof((rrd.ds_def + i)->par[2].u_val) == sizeof(double )) {
          {
#line 162
          tmp___28 = __isnan((rrd.ds_def + i)->par[2].u_val);
#line 162
          tmp___30 = tmp___28;
          }
        } else {
          {
#line 162
          tmp___29 = __isnanl((long double )(rrd.ds_def + i)->par[2].u_val);
#line 162
          tmp___30 = tmp___29;
          }
        }
#line 162
        tmp___31 = tmp___30;
      }
#line 162
      if (tmp___31) {
        {
#line 163
        tmp___25 = strlen("\t\t<max>NaN</max>\n");
#line 163
        (*cb)((void const   *)"\t\t<max>NaN</max>\n", tmp___25, user);
        }
      } else {
        {
#line 165
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 165
          snprintf((char */* __restrict  */)(buffer___7), sizeof(buffer___7), (char const   */* __restrict  */)"\t\t<max>%0.10e</max>\n",
                   (rrd.ds_def + i)->par[2].u_val);
#line 165
          tmp___26 = strlen((char const   *)(buffer___7));
#line 165
          (*cb)((void const   *)(buffer___7), tmp___26, user);
          }
#line 165
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 169
      str = (char *)((void *)0);
#line 171
      rpn_compact2str((rpn_cdefds_t *)(& (rrd.ds_def + i)->par[0]), rrd.ds_def, & str);
#line 176
      tmp___32 = strlen("\t\t<cdef> ");
#line 176
      (*cb)((void const   *)"\t\t<cdef> ", tmp___32, user);
#line 177
      tmp___33 = strlen((char const   *)str);
#line 177
      (*cb)((void const   *)str, tmp___33, user);
#line 178
      tmp___34 = strlen(" </cdef>\n");
#line 178
      (*cb)((void const   *)" </cdef>\n", tmp___34, user);
#line 180
      free((void *)str);
      }
    }
    {
#line 183
    tmp___36 = strlen("\n\t\t<!-- PDP Status -->\n");
#line 183
    (*cb)((void const   *)"\n\t\t<!-- PDP Status -->\n", tmp___36, user);
    }
    {
#line 184
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 184
      snprintf((char */* __restrict  */)(buffer___8), sizeof(buffer___8), (char const   */* __restrict  */)"\t\t<last_ds>%s</last_ds>\n",
               (rrd.pdp_prep + i)->last_ds);
#line 184
      tmp___37 = strlen((char const   *)(buffer___8));
#line 184
      (*cb)((void const   *)(buffer___8), tmp___37, user);
      }
#line 184
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 187
    if (sizeof((rrd.pdp_prep + i)->scratch[1].u_val) == sizeof(float )) {
      {
#line 187
      tmp___40 = __isnanf((float )(rrd.pdp_prep + i)->scratch[1].u_val);
#line 187
      tmp___44 = tmp___40;
      }
    } else {
#line 187
      if (sizeof((rrd.pdp_prep + i)->scratch[1].u_val) == sizeof(double )) {
        {
#line 187
        tmp___41 = __isnan((rrd.pdp_prep + i)->scratch[1].u_val);
#line 187
        tmp___43 = tmp___41;
        }
      } else {
        {
#line 187
        tmp___42 = __isnanl((long double )(rrd.pdp_prep + i)->scratch[1].u_val);
#line 187
        tmp___43 = tmp___42;
        }
      }
#line 187
      tmp___44 = tmp___43;
    }
#line 187
    if (tmp___44) {
      {
#line 188
      tmp___38 = strlen("\t\t<value>NaN</value>\n");
#line 188
      (*cb)((void const   *)"\t\t<value>NaN</value>\n", tmp___38, user);
      }
    } else {
      {
#line 190
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 190
        snprintf((char */* __restrict  */)(buffer___9), sizeof(buffer___9), (char const   */* __restrict  */)"\t\t<value>%0.10e</value>\n",
                 (rrd.pdp_prep + i)->scratch[1].u_val);
#line 190
        tmp___39 = strlen((char const   *)(buffer___9));
#line 190
        (*cb)((void const   *)(buffer___9), tmp___39, user);
        }
#line 190
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
    {
#line 194
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 194
      snprintf((char */* __restrict  */)(buffer___10), sizeof(buffer___10), (char const   */* __restrict  */)"\t\t<unknown_sec> %lu </unknown_sec>\n",
               (rrd.pdp_prep + i)->scratch[0].u_cnt);
#line 194
      tmp___45 = strlen((char const   *)(buffer___10));
#line 194
      (*cb)((void const   *)(buffer___10), tmp___45, user);
      }
#line 194
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 197
    tmp___46 = strlen("\t</ds>\n\n");
#line 197
    (*cb)((void const   *)"\t</ds>\n\n", tmp___46, user);
#line 144
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 200
  tmp___47 = strlen("\t<!-- Round Robin Archives -->\n");
#line 200
  (*cb)((void const   *)"\t<!-- Round Robin Archives -->\n", tmp___47, user);
#line 202
  rra_base = (off_t )rrd_file->header_len;
#line 203
  rra_next = rra_base;
#line 205
  i = 0U;
  }
  {
#line 205
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 205
    if (! ((unsigned long )i < (rrd.stat_head)->rra_cnt)) {
#line 205
      goto while_break___12;
    }
    {
#line 207
    timer = 0L;
#line 209
    rra_start = rra_next;
#line 210
    rra_next = (off_t )((unsigned long )rra_next + ((rrd.stat_head)->ds_cnt * (rrd.rra_def + i)->row_cnt) * sizeof(rrd_value_t ));
#line 213
    tmp___48 = strlen("\t<rra>\n");
#line 213
    (*cb)((void const   *)"\t<rra>\n", tmp___48, user);
    }
    {
#line 215
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 215
      snprintf((char */* __restrict  */)(buffer___11), sizeof(buffer___11), (char const   */* __restrict  */)"\t\t<cf>%s</cf>\n",
               (rrd.rra_def + i)->cf_nam);
#line 215
      tmp___49 = strlen((char const   *)(buffer___11));
#line 215
      (*cb)((void const   *)(buffer___11), tmp___49, user);
      }
#line 215
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 217
    while (1) {
      while_continue___14: /* CIL Label */ ;
      {
#line 217
      snprintf((char */* __restrict  */)(buffer___12), sizeof(buffer___12), (char const   */* __restrict  */)"\t\t<pdp_per_row>%lu</pdp_per_row> <!-- %lu seconds -->\n\n",
               (rrd.rra_def + i)->pdp_cnt, (rrd.rra_def + i)->pdp_cnt * (rrd.stat_head)->pdp_step);
#line 217
      tmp___50 = strlen((char const   *)(buffer___12));
#line 217
      (*cb)((void const   *)(buffer___12), tmp___50, user);
      }
#line 217
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 222
    tmp___51 = strlen("\t\t<params>\n");
#line 222
    (*cb)((void const   *)"\t\t<params>\n", tmp___51, user);
#line 224
    tmp___52 = cf_conv((char const   *)((rrd.rra_def + i)->cf_nam));
    }
    {
#line 226
    if ((unsigned int )tmp___52 == 9U) {
#line 226
      goto case_9;
    }
#line 226
    if ((unsigned int )tmp___52 == 4U) {
#line 226
      goto case_9;
    }
#line 237
    if ((unsigned int )tmp___52 == 7U) {
#line 237
      goto case_7;
    }
#line 237
    if ((unsigned int )tmp___52 == 5U) {
#line 237
      goto case_7;
    }
#line 252
    if ((unsigned int )tmp___52 == 8U) {
#line 252
      goto case_8;
    }
#line 266
    if ((unsigned int )tmp___52 == 6U) {
#line 266
      goto case_6;
    }
#line 274
    goto switch_default;
    case_9: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 227
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
#line 227
      snprintf((char */* __restrict  */)(buffer___13), sizeof(buffer___13), (char const   */* __restrict  */)"\t\t<hw_alpha>%0.10e</hw_alpha>\n",
               (rrd.rra_def + i)->par[1].u_val);
#line 227
      tmp___53 = strlen((char const   *)(buffer___13));
#line 227
      (*cb)((void const   *)(buffer___13), tmp___53, user);
      }
#line 227
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 230
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 230
      snprintf((char */* __restrict  */)(buffer___14), sizeof(buffer___14), (char const   */* __restrict  */)"\t\t<hw_beta>%0.10e</hw_beta>\n",
               (rrd.rra_def + i)->par[2].u_val);
#line 230
      tmp___54 = strlen((char const   *)(buffer___14));
#line 230
      (*cb)((void const   *)(buffer___14), tmp___54, user);
      }
#line 230
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 233
    while (1) {
      while_continue___17: /* CIL Label */ ;
      {
#line 233
      snprintf((char */* __restrict  */)(buffer___15), sizeof(buffer___15), (char const   */* __restrict  */)"\t\t<dependent_rra_idx>%lu</dependent_rra_idx>\n",
               (rrd.rra_def + i)->par[3].u_cnt);
#line 233
      tmp___55 = strlen((char const   *)(buffer___15));
#line 233
      (*cb)((void const   *)(buffer___15), tmp___55, user);
      }
#line 233
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 235
    goto switch_break;
    case_7: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 238
    while (1) {
      while_continue___18: /* CIL Label */ ;
      {
#line 238
      snprintf((char */* __restrict  */)(buffer___16), sizeof(buffer___16), (char const   */* __restrict  */)"\t\t<seasonal_gamma>%0.10e</seasonal_gamma>\n",
               (rrd.rra_def + i)->par[1].u_val);
#line 238
      tmp___56 = strlen((char const   *)(buffer___16));
#line 238
      (*cb)((void const   *)(buffer___16), tmp___56, user);
      }
#line 238
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 241
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 241
      snprintf((char */* __restrict  */)(buffer___17), sizeof(buffer___17), (char const   */* __restrict  */)"\t\t<seasonal_smooth_idx>%lu</seasonal_smooth_idx>\n",
               (rrd.rra_def + i)->par[4].u_cnt);
#line 241
      tmp___57 = strlen((char const   *)(buffer___17));
#line 241
      (*cb)((void const   *)(buffer___17), tmp___57, user);
      }
#line 241
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 244
    tmp___59 = atoi((char const   *)((rrd.stat_head)->version));
    }
#line 244
    if (tmp___59 >= 4) {
      {
#line 245
      while (1) {
        while_continue___20: /* CIL Label */ ;
        {
#line 245
        snprintf((char */* __restrict  */)(buffer___18), sizeof(buffer___18), (char const   */* __restrict  */)"\t\t<smoothing_window>%0.10e</smoothing_window>\n",
                 (rrd.rra_def + i)->par[2].u_val);
#line 245
        tmp___58 = strlen((char const   *)(buffer___18));
#line 245
        (*cb)((void const   *)(buffer___18), tmp___58, user);
        }
#line 245
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
    {
#line 249
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 249
      snprintf((char */* __restrict  */)(buffer___19), sizeof(buffer___19), (char const   */* __restrict  */)"\t\t<dependent_rra_idx>%lu</dependent_rra_idx>\n",
               (rrd.rra_def + i)->par[3].u_cnt);
#line 249
      tmp___60 = strlen((char const   *)(buffer___19));
#line 249
      (*cb)((void const   *)(buffer___19), tmp___60, user);
      }
#line 249
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 251
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 253
    while (1) {
      while_continue___22: /* CIL Label */ ;
      {
#line 253
      snprintf((char */* __restrict  */)(buffer___20), sizeof(buffer___20), (char const   */* __restrict  */)"\t\t<delta_pos>%0.10e</delta_pos>\n",
               (rrd.rra_def + i)->par[1].u_val);
#line 253
      tmp___61 = strlen((char const   *)(buffer___20));
#line 253
      (*cb)((void const   *)(buffer___20), tmp___61, user);
      }
#line 253
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 256
    while (1) {
      while_continue___23: /* CIL Label */ ;
      {
#line 256
      snprintf((char */* __restrict  */)(buffer___21), sizeof(buffer___21), (char const   */* __restrict  */)"\t\t<delta_neg>%0.10e</delta_neg>\n",
               (rrd.rra_def + i)->par[2].u_val);
#line 256
      tmp___62 = strlen((char const   *)(buffer___21));
#line 256
      (*cb)((void const   *)(buffer___21), tmp___62, user);
      }
#line 256
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 259
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
#line 259
      snprintf((char */* __restrict  */)(buffer___22), sizeof(buffer___22), (char const   */* __restrict  */)"\t\t<window_len>%lu</window_len>\n",
               (rrd.rra_def + i)->par[4].u_cnt);
#line 259
      tmp___63 = strlen((char const   *)(buffer___22));
#line 259
      (*cb)((void const   *)(buffer___22), tmp___63, user);
      }
#line 259
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 262
    while (1) {
      while_continue___25: /* CIL Label */ ;
      {
#line 262
      snprintf((char */* __restrict  */)(buffer___23), sizeof(buffer___23), (char const   */* __restrict  */)"\t\t<failure_threshold>%lu</failure_threshold>\n",
               (rrd.rra_def + i)->par[5].u_cnt);
#line 262
      tmp___64 = strlen((char const   *)(buffer___23));
#line 262
      (*cb)((void const   *)(buffer___23), tmp___64, user);
      }
#line 262
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    case_6: /* CIL Label */ 
    {
#line 267
    while (1) {
      while_continue___26: /* CIL Label */ ;
      {
#line 267
      snprintf((char */* __restrict  */)(buffer___24), sizeof(buffer___24), (char const   */* __restrict  */)"\t\t<dependent_rra_idx>%lu</dependent_rra_idx>\n",
               (rrd.rra_def + i)->par[3].u_cnt);
#line 267
      tmp___65 = strlen((char const   *)(buffer___24));
#line 267
      (*cb)((void const   *)(buffer___24), tmp___65, user);
      }
#line 267
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 269
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 275
    while (1) {
      while_continue___27: /* CIL Label */ ;
      {
#line 275
      snprintf((char */* __restrict  */)(buffer___25), sizeof(buffer___25), (char const   */* __restrict  */)"\t\t<xff>%0.10e</xff>\n",
               (rrd.rra_def + i)->par[0].u_val);
#line 275
      tmp___66 = strlen((char const   *)(buffer___25));
#line 275
      (*cb)((void const   *)(buffer___25), tmp___66, user);
      }
#line 275
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 277
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 280
    tmp___67 = strlen("\t\t</params>\n");
#line 280
    (*cb)((void const   *)"\t\t</params>\n", tmp___67, user);
#line 281
    tmp___68 = strlen("\t\t<cdp_prep>\n");
#line 281
    (*cb)((void const   *)"\t\t<cdp_prep>\n", tmp___68, user);
#line 283
    ii = 0U;
    }
    {
#line 283
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 283
      if (! ((unsigned long )ii < (rrd.stat_head)->ds_cnt)) {
#line 283
        goto while_break___28;
      }
      {
#line 286
      tmp___69 = strlen("\t\t\t<ds>\n");
#line 286
      (*cb)((void const   *)"\t\t\t<ds>\n", tmp___69, user);
#line 292
      value = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[8].u_val;
      }
#line 294
      if (sizeof(value) == sizeof(float )) {
        {
#line 294
        tmp___72 = __isnanf((float )value);
#line 294
        tmp___76 = tmp___72;
        }
      } else {
#line 294
        if (sizeof(value) == sizeof(double )) {
          {
#line 294
          tmp___73 = __isnan(value);
#line 294
          tmp___75 = tmp___73;
          }
        } else {
          {
#line 294
          tmp___74 = __isnanl((long double )value);
#line 294
          tmp___75 = tmp___74;
          }
        }
#line 294
        tmp___76 = tmp___75;
      }
#line 294
      if (tmp___76) {
        {
#line 295
        tmp___70 = strlen("\t\t\t<primary_value>NaN</primary_value>\n");
#line 295
        (*cb)((void const   *)"\t\t\t<primary_value>NaN</primary_value>\n", tmp___70,
              user);
        }
      } else {
        {
#line 297
        while (1) {
          while_continue___29: /* CIL Label */ ;
          {
#line 297
          snprintf((char */* __restrict  */)(buffer___26), sizeof(buffer___26), (char const   */* __restrict  */)"\t\t\t<primary_value>%0.10e</primary_value>\n",
                   value);
#line 297
          tmp___71 = strlen((char const   *)(buffer___26));
#line 297
          (*cb)((void const   *)(buffer___26), tmp___71, user);
          }
#line 297
          goto while_break___29;
        }
        while_break___29: /* CIL Label */ ;
        }
      }
#line 300
      value = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[9].u_val;
#line 302
      if (sizeof(value) == sizeof(float )) {
        {
#line 302
        tmp___79 = __isnanf((float )value);
#line 302
        tmp___83 = tmp___79;
        }
      } else {
#line 302
        if (sizeof(value) == sizeof(double )) {
          {
#line 302
          tmp___80 = __isnan(value);
#line 302
          tmp___82 = tmp___80;
          }
        } else {
          {
#line 302
          tmp___81 = __isnanl((long double )value);
#line 302
          tmp___82 = tmp___81;
          }
        }
#line 302
        tmp___83 = tmp___82;
      }
#line 302
      if (tmp___83) {
        {
#line 303
        tmp___77 = strlen("\t\t\t<secondary_value>NaN</secondary_value>\n");
#line 303
        (*cb)((void const   *)"\t\t\t<secondary_value>NaN</secondary_value>\n", tmp___77,
              user);
        }
      } else {
        {
#line 305
        while (1) {
          while_continue___30: /* CIL Label */ ;
          {
#line 305
          snprintf((char */* __restrict  */)(buffer___27), sizeof(buffer___27), (char const   */* __restrict  */)"\t\t\t<secondary_value>%0.10e</secondary_value>\n",
                   value);
#line 305
          tmp___78 = strlen((char const   *)(buffer___27));
#line 305
          (*cb)((void const   *)(buffer___27), tmp___78, user);
          }
#line 305
          goto while_break___30;
        }
        while_break___30: /* CIL Label */ ;
        }
      }
      {
#line 308
      tmp___84 = cf_conv((char const   *)((rrd.rra_def + i)->cf_nam));
      }
      {
#line 310
      if ((unsigned int )tmp___84 == 9U) {
#line 310
        goto case_9___0;
      }
#line 310
      if ((unsigned int )tmp___84 == 4U) {
#line 310
        goto case_9___0;
      }
#line 352
      if ((unsigned int )tmp___84 == 7U) {
#line 352
        goto case_7___0;
      }
#line 352
      if ((unsigned int )tmp___84 == 5U) {
#line 352
        goto case_7___0;
      }
#line 373
      if ((unsigned int )tmp___84 == 6U) {
#line 373
        goto case_6___0;
      }
#line 375
      if ((unsigned int )tmp___84 == 8U) {
#line 375
        goto case_8___0;
      }
#line 393
      goto switch_default___0;
      case_9___0: /* CIL Label */ 
      case_4___0: /* CIL Label */ 
#line 311
      value = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[2].u_val;
#line 313
      if (sizeof(value) == sizeof(float )) {
        {
#line 313
        tmp___87 = __isnanf((float )value);
#line 313
        tmp___91 = tmp___87;
        }
      } else {
#line 313
        if (sizeof(value) == sizeof(double )) {
          {
#line 313
          tmp___88 = __isnan(value);
#line 313
          tmp___90 = tmp___88;
          }
        } else {
          {
#line 313
          tmp___89 = __isnanl((long double )value);
#line 313
          tmp___90 = tmp___89;
          }
        }
#line 313
        tmp___91 = tmp___90;
      }
#line 313
      if (tmp___91) {
        {
#line 314
        tmp___85 = strlen("\t\t\t<intercept>NaN</intercept>\n");
#line 314
        (*cb)((void const   *)"\t\t\t<intercept>NaN</intercept>\n", tmp___85, user);
        }
      } else {
        {
#line 316
        while (1) {
          while_continue___31: /* CIL Label */ ;
          {
#line 316
          snprintf((char */* __restrict  */)(buffer___28), sizeof(buffer___28), (char const   */* __restrict  */)"\t\t\t<intercept>%0.10e</intercept>\n",
                   value);
#line 316
          tmp___86 = strlen((char const   *)(buffer___28));
#line 316
          (*cb)((void const   *)(buffer___28), tmp___86, user);
          }
#line 316
          goto while_break___31;
        }
        while_break___31: /* CIL Label */ ;
        }
      }
#line 319
      value = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[3].u_val;
#line 321
      if (sizeof(value) == sizeof(float )) {
        {
#line 321
        tmp___94 = __isnanf((float )value);
#line 321
        tmp___98 = tmp___94;
        }
      } else {
#line 321
        if (sizeof(value) == sizeof(double )) {
          {
#line 321
          tmp___95 = __isnan(value);
#line 321
          tmp___97 = tmp___95;
          }
        } else {
          {
#line 321
          tmp___96 = __isnanl((long double )value);
#line 321
          tmp___97 = tmp___96;
          }
        }
#line 321
        tmp___98 = tmp___97;
      }
#line 321
      if (tmp___98) {
        {
#line 322
        tmp___92 = strlen("\t\t\t<last_intercept>NaN</last_intercept>\n");
#line 322
        (*cb)((void const   *)"\t\t\t<last_intercept>NaN</last_intercept>\n", tmp___92,
              user);
        }
      } else {
        {
#line 324
        while (1) {
          while_continue___32: /* CIL Label */ ;
          {
#line 324
          snprintf((char */* __restrict  */)(buffer___29), sizeof(buffer___29), (char const   */* __restrict  */)"\t\t\t<last_intercept>%0.10e</last_intercept>\n",
                   value);
#line 324
          tmp___93 = strlen((char const   *)(buffer___29));
#line 324
          (*cb)((void const   *)(buffer___29), tmp___93, user);
          }
#line 324
          goto while_break___32;
        }
        while_break___32: /* CIL Label */ ;
        }
      }
#line 327
      value = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[4].u_val;
#line 329
      if (sizeof(value) == sizeof(float )) {
        {
#line 329
        tmp___101 = __isnanf((float )value);
#line 329
        tmp___105 = tmp___101;
        }
      } else {
#line 329
        if (sizeof(value) == sizeof(double )) {
          {
#line 329
          tmp___102 = __isnan(value);
#line 329
          tmp___104 = tmp___102;
          }
        } else {
          {
#line 329
          tmp___103 = __isnanl((long double )value);
#line 329
          tmp___104 = tmp___103;
          }
        }
#line 329
        tmp___105 = tmp___104;
      }
#line 329
      if (tmp___105) {
        {
#line 330
        tmp___99 = strlen("\t\t\t<slope>NaN</slope>\n");
#line 330
        (*cb)((void const   *)"\t\t\t<slope>NaN</slope>\n", tmp___99, user);
        }
      } else {
        {
#line 332
        while (1) {
          while_continue___33: /* CIL Label */ ;
          {
#line 332
          snprintf((char */* __restrict  */)(buffer___30), sizeof(buffer___30), (char const   */* __restrict  */)"\t\t\t<slope>%0.10e</slope>\n",
                   value);
#line 332
          tmp___100 = strlen((char const   *)(buffer___30));
#line 332
          (*cb)((void const   *)(buffer___30), tmp___100, user);
          }
#line 332
          goto while_break___33;
        }
        while_break___33: /* CIL Label */ ;
        }
      }
#line 335
      value = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[5].u_val;
#line 337
      if (sizeof(value) == sizeof(float )) {
        {
#line 337
        tmp___108 = __isnanf((float )value);
#line 337
        tmp___112 = tmp___108;
        }
      } else {
#line 337
        if (sizeof(value) == sizeof(double )) {
          {
#line 337
          tmp___109 = __isnan(value);
#line 337
          tmp___111 = tmp___109;
          }
        } else {
          {
#line 337
          tmp___110 = __isnanl((long double )value);
#line 337
          tmp___111 = tmp___110;
          }
        }
#line 337
        tmp___112 = tmp___111;
      }
#line 337
      if (tmp___112) {
        {
#line 338
        tmp___106 = strlen("\t\t\t<last_slope>NaN</last_slope>\n");
#line 338
        (*cb)((void const   *)"\t\t\t<last_slope>NaN</last_slope>\n", tmp___106, user);
        }
      } else {
        {
#line 340
        while (1) {
          while_continue___34: /* CIL Label */ ;
          {
#line 340
          snprintf((char */* __restrict  */)(buffer___31), sizeof(buffer___31), (char const   */* __restrict  */)"\t\t\t<last_slope>%0.10e</last_slope>\n",
                   value);
#line 340
          tmp___107 = strlen((char const   *)(buffer___31));
#line 340
          (*cb)((void const   *)(buffer___31), tmp___107, user);
          }
#line 340
          goto while_break___34;
        }
        while_break___34: /* CIL Label */ ;
        }
      }
#line 343
      ivalue = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[6].u_cnt;
      {
#line 345
      while (1) {
        while_continue___35: /* CIL Label */ ;
        {
#line 345
        snprintf((char */* __restrict  */)(buffer___32), sizeof(buffer___32), (char const   */* __restrict  */)"\t\t\t<nan_count>%lu</nan_count>\n",
                 ivalue);
#line 345
        tmp___113 = strlen((char const   *)(buffer___32));
#line 345
        (*cb)((void const   *)(buffer___32), tmp___113, user);
        }
#line 345
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
#line 347
      ivalue = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[7].u_cnt;
      {
#line 349
      while (1) {
        while_continue___36: /* CIL Label */ ;
        {
#line 349
        snprintf((char */* __restrict  */)(buffer___33), sizeof(buffer___33), (char const   */* __restrict  */)"\t\t\t<last_nan_count>%lu</last_nan_count>\n",
                 ivalue);
#line 349
        tmp___114 = strlen((char const   *)(buffer___33));
#line 349
        (*cb)((void const   *)(buffer___33), tmp___114, user);
        }
#line 349
        goto while_break___36;
      }
      while_break___36: /* CIL Label */ ;
      }
#line 350
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
      case_5___0: /* CIL Label */ 
#line 353
      value = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[2].u_val;
#line 355
      if (sizeof(value) == sizeof(float )) {
        {
#line 355
        tmp___117 = __isnanf((float )value);
#line 355
        tmp___121 = tmp___117;
        }
      } else {
#line 355
        if (sizeof(value) == sizeof(double )) {
          {
#line 355
          tmp___118 = __isnan(value);
#line 355
          tmp___120 = tmp___118;
          }
        } else {
          {
#line 355
          tmp___119 = __isnanl((long double )value);
#line 355
          tmp___120 = tmp___119;
          }
        }
#line 355
        tmp___121 = tmp___120;
      }
#line 355
      if (tmp___121) {
        {
#line 356
        tmp___115 = strlen("\t\t\t<seasonal>NaN</seasonal>\n");
#line 356
        (*cb)((void const   *)"\t\t\t<seasonal>NaN</seasonal>\n", tmp___115, user);
        }
      } else {
        {
#line 358
        while (1) {
          while_continue___37: /* CIL Label */ ;
          {
#line 358
          snprintf((char */* __restrict  */)(buffer___34), sizeof(buffer___34), (char const   */* __restrict  */)"\t\t\t<seasonal>%0.10e</seasonal>\n",
                   value);
#line 358
          tmp___116 = strlen((char const   *)(buffer___34));
#line 358
          (*cb)((void const   *)(buffer___34), tmp___116, user);
          }
#line 358
          goto while_break___37;
        }
        while_break___37: /* CIL Label */ ;
        }
      }
#line 361
      value = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[3].u_val;
#line 363
      if (sizeof(value) == sizeof(float )) {
        {
#line 363
        tmp___124 = __isnanf((float )value);
#line 363
        tmp___128 = tmp___124;
        }
      } else {
#line 363
        if (sizeof(value) == sizeof(double )) {
          {
#line 363
          tmp___125 = __isnan(value);
#line 363
          tmp___127 = tmp___125;
          }
        } else {
          {
#line 363
          tmp___126 = __isnanl((long double )value);
#line 363
          tmp___127 = tmp___126;
          }
        }
#line 363
        tmp___128 = tmp___127;
      }
#line 363
      if (tmp___128) {
        {
#line 364
        tmp___122 = strlen("\t\t\t<last_seasonal>NaN</last_seasonal>\n");
#line 364
        (*cb)((void const   *)"\t\t\t<last_seasonal>NaN</last_seasonal>\n", tmp___122,
              user);
        }
      } else {
        {
#line 366
        while (1) {
          while_continue___38: /* CIL Label */ ;
          {
#line 366
          snprintf((char */* __restrict  */)(buffer___35), sizeof(buffer___35), (char const   */* __restrict  */)"\t\t\t<last_seasonal>%0.10e</last_seasonal>\n",
                   value);
#line 366
          tmp___123 = strlen((char const   *)(buffer___35));
#line 366
          (*cb)((void const   *)(buffer___35), tmp___123, user);
          }
#line 366
          goto while_break___38;
        }
        while_break___38: /* CIL Label */ ;
        }
      }
#line 369
      ivalue = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[6].u_cnt;
      {
#line 371
      while (1) {
        while_continue___39: /* CIL Label */ ;
        {
#line 371
        snprintf((char */* __restrict  */)(buffer___36), sizeof(buffer___36), (char const   */* __restrict  */)"\t\t\t<init_flag>%lu</init_flag>\n",
                 ivalue);
#line 371
        tmp___129 = strlen((char const   *)(buffer___36));
#line 371
        (*cb)((void const   *)(buffer___36), tmp___129, user);
        }
#line 371
        goto while_break___39;
      }
      while_break___39: /* CIL Label */ ;
      }
#line 372
      goto switch_break___0;
      case_6___0: /* CIL Label */ 
#line 374
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
      {
#line 378
      violations_array = (char *)((void *)((rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch));
#line 380
      tmp___130 = strlen("\t\t\t<history>");
#line 380
      (*cb)((void const   *)"\t\t\t<history>", tmp___130, user);
#line 381
      vidx = (unsigned short)0;
      }
      {
#line 381
      while (1) {
        while_continue___40: /* CIL Label */ ;
#line 381
        if (! ((unsigned long )vidx < (rrd.rra_def + i)->par[4].u_cnt)) {
#line 381
          goto while_break___40;
        }
        {
#line 384
        while (1) {
          while_continue___41: /* CIL Label */ ;
          {
#line 384
          snprintf((char */* __restrict  */)(buffer___37), sizeof(buffer___37), (char const   */* __restrict  */)"%d",
                   (int )*(violations_array + vidx));
#line 384
          tmp___131 = strlen((char const   *)(buffer___37));
#line 384
          (*cb)((void const   *)(buffer___37), tmp___131, user);
          }
#line 384
          goto while_break___41;
        }
        while_break___41: /* CIL Label */ ;
        }
#line 381
        vidx = (unsigned short )((int )vidx + 1);
      }
      while_break___40: /* CIL Label */ ;
      }
      {
#line 386
      tmp___132 = strlen("</history>\n");
#line 386
      (*cb)((void const   *)"</history>\n", tmp___132, user);
      }
#line 388
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 394
      value = (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[0].u_val;
#line 395
      if (sizeof(value) == sizeof(float )) {
        {
#line 395
        tmp___135 = __isnanf((float )value);
#line 395
        tmp___139 = tmp___135;
        }
      } else {
#line 395
        if (sizeof(value) == sizeof(double )) {
          {
#line 395
          tmp___136 = __isnan(value);
#line 395
          tmp___138 = tmp___136;
          }
        } else {
          {
#line 395
          tmp___137 = __isnanl((long double )value);
#line 395
          tmp___138 = tmp___137;
          }
        }
#line 395
        tmp___139 = tmp___138;
      }
#line 395
      if (tmp___139) {
        {
#line 396
        tmp___133 = strlen("\t\t\t<value>NaN</value>\n");
#line 396
        (*cb)((void const   *)"\t\t\t<value>NaN</value>\n", tmp___133, user);
        }
      } else {
        {
#line 398
        while (1) {
          while_continue___42: /* CIL Label */ ;
          {
#line 398
          snprintf((char */* __restrict  */)(buffer___38), sizeof(buffer___38), (char const   */* __restrict  */)"\t\t\t<value>%0.10e</value>\n",
                   value);
#line 398
          tmp___134 = strlen((char const   *)(buffer___38));
#line 398
          (*cb)((void const   *)(buffer___38), tmp___134, user);
          }
#line 398
          goto while_break___42;
        }
        while_break___42: /* CIL Label */ ;
        }
      }
      {
#line 401
      while (1) {
        while_continue___43: /* CIL Label */ ;
        {
#line 401
        snprintf((char */* __restrict  */)(buffer___39), sizeof(buffer___39), (char const   */* __restrict  */)"\t\t\t<unknown_datapoints>%lu</unknown_datapoints>\n",
                 (rrd.cdp_prep + ((unsigned long )i * (rrd.stat_head)->ds_cnt + (unsigned long )ii))->scratch[1].u_cnt);
#line 401
        tmp___140 = strlen((char const   *)(buffer___39));
#line 401
        (*cb)((void const   *)(buffer___39), tmp___140, user);
        }
#line 401
        goto while_break___43;
      }
      while_break___43: /* CIL Label */ ;
      }
#line 404
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 406
      tmp___141 = strlen("\t\t\t</ds>\n");
#line 406
      (*cb)((void const   *)"\t\t\t</ds>\n", tmp___141, user);
#line 283
      ii ++;
      }
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 408
    tmp___142 = strlen("\t\t</cdp_prep>\n");
#line 408
    (*cb)((void const   *)"\t\t</cdp_prep>\n", tmp___142, user);
#line 410
    tmp___143 = strlen("\t\t<database>\n");
#line 410
    (*cb)((void const   *)"\t\t<database>\n", tmp___143, user);
#line 411
    rrd_seek(rrd_file, (off_t )((unsigned long )rra_start + (((rrd.rra_ptr + i)->cur_row + 1UL) * (rrd.stat_head)->ds_cnt) * sizeof(rrd_value_t )),
             0);
#line 414
    timer = - ((long )((rrd.rra_def + i)->row_cnt - 1UL));
#line 415
    ii = (unsigned int )(rrd.rra_ptr + i)->cur_row;
#line 416
    ix = 0U;
    }
    {
#line 416
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 416
      if (! ((unsigned long )ix < (rrd.rra_def + i)->row_cnt)) {
#line 416
        goto while_break___44;
      }
#line 417
      ii ++;
#line 418
      if ((unsigned long )ii >= (rrd.rra_def + i)->row_cnt) {
        {
#line 419
        rrd_seek(rrd_file, rra_start, 0);
#line 420
        ii = 0U;
        }
      }
      {
#line 422
      now = (time_t )(((unsigned long )(rrd.live_head)->last_up - (unsigned long )(rrd.live_head)->last_up % ((rrd.rra_def + i)->pdp_cnt * (rrd.stat_head)->pdp_step)) + ((unsigned long )timer * (rrd.rra_def + i)->pdp_cnt) * (rrd.stat_head)->pdp_step);
#line 427
      timer ++;
#line 429
      localtime_r((time_t const   */* __restrict  */)(& now), (struct tm */* __restrict  */)(& tm));
#line 430
      strftime((char */* __restrict  */)(somestring), (size_t )255, (char const   */* __restrict  */)"%Y-%m-%d %H:%M:%S %Z",
               (struct tm  const  */* __restrict  */)(& tm));
      }
      {
#line 434
      while (1) {
        while_continue___45: /* CIL Label */ ;
        {
#line 434
        snprintf((char */* __restrict  */)(buffer___40), sizeof(buffer___40), (char const   */* __restrict  */)"\t\t\t<!-- %s / %lld --> <row>",
                 somestring, (long long )now);
#line 434
        tmp___144 = strlen((char const   *)(buffer___40));
#line 434
        (*cb)((void const   *)(buffer___40), tmp___144, user);
        }
#line 434
        goto while_break___45;
      }
      while_break___45: /* CIL Label */ ;
      }
#line 435
      iii = 0U;
      {
#line 435
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 435
        if (! ((unsigned long )iii < (rrd.stat_head)->ds_cnt)) {
#line 435
          goto while_break___46;
        }
        {
#line 436
        rrd_read(rrd_file, (void *)(& my_cdp), sizeof(rrd_value_t ));
        }
#line 437
        if (sizeof(my_cdp) == sizeof(float )) {
          {
#line 437
          tmp___147 = __isnanf((float )my_cdp);
#line 437
          tmp___151 = tmp___147;
          }
        } else {
#line 437
          if (sizeof(my_cdp) == sizeof(double )) {
            {
#line 437
            tmp___148 = __isnan(my_cdp);
#line 437
            tmp___150 = tmp___148;
            }
          } else {
            {
#line 437
            tmp___149 = __isnanl((long double )my_cdp);
#line 437
            tmp___150 = tmp___149;
            }
          }
#line 437
          tmp___151 = tmp___150;
        }
#line 437
        if (tmp___151) {
          {
#line 438
          tmp___145 = strlen("<v>NaN</v>");
#line 438
          (*cb)((void const   *)"<v>NaN</v>", tmp___145, user);
          }
        } else {
          {
#line 440
          while (1) {
            while_continue___47: /* CIL Label */ ;
            {
#line 440
            snprintf((char */* __restrict  */)(buffer___41), sizeof(buffer___41),
                     (char const   */* __restrict  */)"<v>%0.10e</v>", my_cdp);
#line 440
            tmp___146 = strlen((char const   *)(buffer___41));
#line 440
            (*cb)((void const   *)(buffer___41), tmp___146, user);
            }
#line 440
            goto while_break___47;
          }
          while_break___47: /* CIL Label */ ;
          }
        }
#line 435
        iii ++;
      }
      while_break___46: /* CIL Label */ ;
      }
      {
#line 443
      tmp___152 = strlen("</row>\n");
#line 443
      (*cb)((void const   *)"</row>\n", tmp___152, user);
#line 416
      ix ++;
      }
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 445
    tmp___153 = strlen("\t\t</database>\n\t</rra>\n");
#line 445
    (*cb)((void const   *)"\t\t</database>\n\t</rra>\n", tmp___153, user);
#line 205
    i ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 448
  tmp___154 = strlen("</rrd>\n");
#line 448
  (*cb)((void const   *)"</rrd>\n", tmp___154, user);
#line 450
  rrd_free(& rrd);
#line 452
  setlocale(1, (char const   *)old_locale);
#line 454
  tmp___155 = rrd_close(rrd_file);
  }
#line 454
  return (tmp___155);
}
}
#line 464 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_dump.c"
size_t rrd_dump_opt_cb_fileout(void const   *data , size_t len , void *user ) 
{ 
  size_t tmp ;

  {
  {
#line 469
  tmp = fwrite((void const   */* __restrict  */)data, (size_t )1, len, (FILE */* __restrict  */)((FILE *)user));
  }
#line 469
  return (tmp);
}
}
#line 472 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_dump.c"
int rrd_dump_opt_r(char const   *filename , char *outname , int opt_noheader ) 
{ 
  FILE *out_file ;
  int res ;
  char *__cil_tmp6 ;

  {
#line 480
  out_file = (FILE *)((void *)0);
#line 481
  if (outname) {
    {
#line 482
    out_file = fopen((char const   */* __restrict  */)outname, (char const   */* __restrict  */)"w");
    }
#line 482
    if (! out_file) {
#line 483
      return (-1);
    }
  } else {
#line 486
    out_file = stdout;
  }
  {
#line 489
  res = rrd_dump_cb_r(filename, opt_noheader, & rrd_dump_opt_cb_fileout, (void *)out_file);
  }
#line 491
  if ((unsigned long )out_file != (unsigned long )stdout) {
    {
#line 492
    fclose(out_file);
    }
  }
#line 495
  return (res);
}
}
#line 499 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_dump.c"
int rrd_dump_r(char const   *filename , char *outname ) 
{ 
  int tmp ;

  {
  {
#line 503
  tmp = rrd_dump_opt_r(filename, outname, 0);
  }
#line 503
  return (tmp);
}
}
#line 527 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_dump.c"
static struct option long_options___1[4]  = {      {"daemon", 1, (int *)0, 'd'}, 
        {"header", 1, (int *)0, 'h'}, 
        {"no-header", 0, (int *)0, 'n'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 506 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_dump.c"
int rrd_dump(int argc , char **argv ) 
{ 
  int rc ;
  int opt_header ;
  char *opt_daemon ;
  int opt ;
  int option_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 516
  opt_header = 1;
#line 517
  opt_daemon = (char *)((void *)0);
#line 521
  optind = 0;
#line 522
  opterr = 0;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 526
    option_index = 0;
#line 534
    opt = getopt_long(argc, (char * const  *)argv, "d:h:n", (struct option  const  *)(long_options___1),
                      & option_index);
    }
#line 536
    if (opt == -1) {
#line 537
      goto while_break;
    }
    {
#line 540
    if (opt == 100) {
#line 540
      goto case_100;
    }
#line 551
    if (opt == 110) {
#line 551
      goto case_110;
    }
#line 555
    if (opt == 104) {
#line 555
      goto case_104;
    }
#line 565
    goto switch_default;
    case_100: /* CIL Label */ 
#line 541
    if ((unsigned long )opt_daemon != (unsigned long )((void *)0)) {
      {
#line 542
      free((void *)opt_daemon);
      }
    }
    {
#line 543
    opt_daemon = strdup((char const   *)optarg);
    }
#line 544
    if ((unsigned long )opt_daemon == (unsigned long )((void *)0)) {
      {
#line 546
      rrd_set_error((char *)"strdup failed.");
      }
#line 547
      return (-1);
    }
#line 549
    goto switch_break;
    case_110: /* CIL Label */ 
#line 552
    opt_header = 0;
#line 553
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 556
    tmp___1 = strcmp((char const   *)optarg, "dtd");
    }
#line 556
    if (tmp___1 == 0) {
#line 557
      opt_header = 1;
    } else {
      {
#line 558
      tmp___0 = strcmp((char const   *)optarg, "xsd");
      }
#line 558
      if (tmp___0 == 0) {
#line 559
        opt_header = 2;
      } else {
        {
#line 560
        tmp = strcmp((char const   *)optarg, "none");
        }
#line 560
        if (tmp == 0) {
#line 561
          opt_header = 0;
        }
      }
    }
#line 563
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 566
    rrd_set_error((char *)"usage rrdtool %s [--header|-h {none,xsd,dtd}] [--no-header]file.rrd [file.xml]",
                  *(argv + 0));
    }
#line 568
    return (-1);
#line 569
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 573
  if (argc - optind < 1) {
    {
#line 574
    rrd_set_error((char *)"usage rrdtool %s [--header|-h {none,xsd,dtd}] [--no-header]file.rrd [file.xml]",
                  *(argv + 0));
    }
#line 576
    return (-1);
  } else
#line 573
  if (argc - optind > 2) {
    {
#line 574
    rrd_set_error((char *)"usage rrdtool %s [--header|-h {none,xsd,dtd}] [--no-header]file.rrd [file.xml]",
                  *(argv + 0));
    }
#line 576
    return (-1);
  }
  {
#line 579
  rc = rrdc_flush_if_daemon((char const   *)opt_daemon, (char const   *)*(argv + optind));
  }
#line 580
  if (opt_daemon) {
    {
#line 580
    free((void *)opt_daemon);
    }
  }
#line 581
  if (rc) {
#line 581
    return (rc);
  }
#line 583
  if (argc - optind == 2) {
    {
#line 584
    rc = rrd_dump_opt_r((char const   *)*(argv + optind), *(argv + (optind + 1)),
                        opt_header);
    }
  } else {
    {
#line 586
    rc = rrd_dump_opt_r((char const   *)*(argv + optind), (char *)((void *)0), opt_header);
    }
  }
#line 589
  return (rc);
}
}
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 188 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_restore(int argc , char **argv ) ;
#line 40 "/usr/include/libxml2/libxml/xmlstring.h"
extern xmlChar *xmlStrdup(xmlChar const   *cur ) ;
#line 60
extern xmlChar const   *xmlStrcasestr(xmlChar const   *str , xmlChar const   *val ) ;
#line 70
extern int xmlStrcasecmp(xmlChar const   *str1 , xmlChar const   *str2 ) ;
#line 251 "/usr/include/libxml2/libxml/globals.h"
extern void (*xmlFree)(void *mem ) ;
#line 114 "/usr/include/libxml2/libxml/xmlreader.h"
extern xmlTextReaderPtr xmlNewTextReaderFilename(char const   *URI ) ;
#line 117
extern void xmlFreeTextReader(xmlTextReaderPtr reader ) ;
#line 128
extern int xmlTextReaderRead(xmlTextReaderPtr reader ) ;
#line 159
extern int xmlTextReaderNodeType(xmlTextReaderPtr reader ) ;
#line 194
extern xmlChar *xmlTextReaderName(xmlTextReaderPtr reader ) ;
#line 202
extern xmlChar *xmlTextReaderValue(xmlTextReaderPtr reader ) ;
#line 259
extern int xmlTextReaderGetParserLineNumber(xmlTextReaderPtr reader ) ;
#line 39 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int opt_range_check  =    0;
#line 40 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int opt_force_overwrite  =    0;
#line 48 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static xmlChar *get_xml_element(xmlTextReaderPtr reader ) 
{ 
  int type ;
  xmlChar *name ;
  xmlChar *value ;
  int tmp ;
  xmlChar *temp ;
  xmlChar *temp2 ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    tmp___1 = xmlTextReaderRead(reader);
    }
#line 52
    if (! tmp___1) {
#line 52
      goto while_break;
    }
    {
#line 55
    type = xmlTextReaderNodeType(reader);
    }
#line 56
    if (type == 3) {
      {
#line 58
      value = xmlTextReaderValue(reader);
#line 59
      tmp = xmlTextReaderGetParserLineNumber(reader);
#line 59
      rrd_set_error((char *)"line %d: expected element but found text \'%s\'", tmp,
                    value);
#line 61
      (*xmlFree)((void *)value);
      }
#line 62
      return ((xmlChar *)((void *)0));
    }
#line 65
    if (type != 1) {
#line 65
      if (type != 15) {
#line 66
        goto while_continue;
      }
    }
    {
#line 68
    name = xmlTextReaderName(reader);
    }
#line 69
    if (type == 15) {
      {
#line 72
      tmp___0 = sprintf_alloc((char *)"/%s", name);
#line 72
      temp = (xmlChar *)tmp___0;
#line 73
      temp2 = xmlStrdup((xmlChar const   *)temp);
#line 74
      free((void *)temp);
#line 75
      (*xmlFree)((void *)name);
      }
#line 76
      return (temp2);
    }
#line 79
    return (name);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  rrd_set_error((char *)"the xml ended while we were looking for an element");
  }
#line 82
  return ((xmlChar *)((void *)0));
}
}
#line 85 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static void local_rrd_free(rrd_t *rrd ) 
{ 


  {
  {
#line 87
  free((void *)rrd->live_head);
#line 88
  free((void *)rrd->stat_head);
#line 89
  free((void *)rrd->ds_def);
#line 90
  free((void *)rrd->rra_def);
#line 91
  free((void *)rrd->rra_ptr);
#line 92
  free((void *)rrd->pdp_prep);
#line 93
  free((void *)rrd->cdp_prep);
#line 94
  free((void *)rrd->rrd_value);
#line 95
  free((void *)rrd);
  }
#line 96
  return;
}
}
#line 99 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int expect_element(xmlTextReaderPtr reader , char *exp_name ) 
{ 
  xmlChar *name ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 104
  name = get_xml_element(reader);
  }
#line 105
  if (! name) {
#line 106
    return (-1);
  }
  {
#line 107
  tmp___0 = xmlStrcasecmp((xmlChar const   *)name, (xmlChar const   *)((xmlChar *)exp_name));
  }
#line 107
  if (tmp___0 != 0) {
    {
#line 108
    tmp = xmlTextReaderGetParserLineNumber(reader);
#line 108
    rrd_set_error((char *)"line %d: expected <%s> element but found <%s>", tmp, name,
                  exp_name);
#line 110
    (*xmlFree)((void *)name);
    }
#line 111
    return (-1);
  }
  {
#line 113
  (*xmlFree)((void *)name);
  }
#line 114
  return (0);
}
}
#line 117 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int expect_element_end(xmlTextReaderPtr reader , char *exp_name ) 
{ 
  xmlChar *name ;
  xmlChar *temp ;
  xmlChar *temp2 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 123
  tmp___0 = xmlTextReaderNodeType(reader);
  }
#line 123
  if (tmp___0 == 15) {
    {
#line 126
    temp = xmlTextReaderName(reader);
#line 127
    tmp = sprintf_alloc((char *)"/%s", temp);
#line 127
    temp2 = (xmlChar *)tmp;
#line 128
    name = xmlStrdup((xmlChar const   *)temp2);
#line 129
    (*xmlFree)((void *)temp);
#line 130
    free((void *)temp2);
    }
  } else {
    {
#line 132
    name = get_xml_element(reader);
    }
  }
#line 135
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 136
    return (-1);
  }
  {
#line 137
  tmp___2 = xmlStrcasecmp((xmlChar const   *)(name + 1), (xmlChar const   *)((xmlChar *)exp_name));
  }
#line 137
  if (tmp___2 != 0) {
    {
#line 138
    tmp___1 = xmlTextReaderGetParserLineNumber(reader);
#line 138
    rrd_set_error((char *)"line %d: expected </%s> end element but found <%s>", tmp___1,
                  exp_name, name);
#line 140
    (*xmlFree)((void *)name);
    }
#line 141
    return (-1);
  } else
#line 137
  if ((int )*(name + 0) != 47) {
    {
#line 138
    tmp___1 = xmlTextReaderGetParserLineNumber(reader);
#line 138
    rrd_set_error((char *)"line %d: expected </%s> end element but found <%s>", tmp___1,
                  exp_name, name);
#line 140
    (*xmlFree)((void *)name);
    }
#line 141
    return (-1);
  }
  {
#line 143
  (*xmlFree)((void *)name);
  }
#line 144
  return (0);
}
}
#line 148 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static xmlChar *get_xml_text(xmlTextReaderPtr reader ) 
{ 
  xmlChar *ret ;
  xmlChar *text ;
  xmlChar *begin_ptr ;
  xmlChar *end_ptr ;
  int type ;
  xmlChar *name ;
  int tmp ;
  xmlChar *tmp___0 ;
  unsigned short const   **tmp___1 ;
  xmlChar *tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 152
    tmp___4 = xmlTextReaderRead(reader);
    }
#line 152
    if (! tmp___4) {
#line 152
      goto while_break;
    }
    {
#line 158
    type = xmlTextReaderNodeType(reader);
    }
#line 159
    if (type == 1) {
      {
#line 161
      name = xmlTextReaderName(reader);
#line 162
      tmp = xmlTextReaderGetParserLineNumber(reader);
#line 162
      rrd_set_error((char *)"line %d: expected a value but found a <%s> element",
                    tmp, name);
#line 165
      (*xmlFree)((void *)name);
      }
#line 166
      return ((xmlChar *)((void *)0));
    }
#line 174
    if (type == 15) {
      {
#line 175
      tmp___0 = xmlStrdup((xmlChar const   *)((xmlChar *)""));
      }
#line 175
      return (tmp___0);
    }
#line 179
    if (type != 3) {
#line 180
      goto while_continue;
    }
    {
#line 182
    text = xmlTextReaderValue(reader);
#line 184
    begin_ptr = text;
    }
    {
#line 185
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 185
      if ((int )*(begin_ptr + 0) != 0) {
        {
#line 185
        tmp___1 = __ctype_b_loc();
        }
#line 185
        if (! ((int const   )*(*tmp___1 + (int )*(begin_ptr + 0)) & 8192)) {
#line 185
          goto while_break___0;
        }
      } else {
#line 185
        goto while_break___0;
      }
#line 186
      begin_ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 187
    if ((int )*(begin_ptr + 0) == 0) {
      {
#line 188
      (*xmlFree)((void *)text);
#line 189
      tmp___2 = xmlStrdup((xmlChar const   *)((xmlChar *)""));
      }
#line 189
      return (tmp___2);
    }
#line 191
    end_ptr = begin_ptr;
    {
#line 192
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 192
      if ((int )*(end_ptr + 0) != 0) {
        {
#line 192
        tmp___3 = __ctype_b_loc();
        }
#line 192
        if ((int const   )*(*tmp___3 + (int )*(end_ptr + 0)) & 8192) {
#line 192
          goto while_break___1;
        }
      } else {
#line 192
        goto while_break___1;
      }
#line 193
      end_ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 194
    *(end_ptr + 0) = (xmlChar )0;
#line 196
    ret = xmlStrdup((xmlChar const   *)begin_ptr);
#line 197
    (*xmlFree)((void *)text);
    }
#line 198
    return (ret);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 200
  rrd_set_error((char *)"file ended while looking for text");
  }
#line 201
  return ((xmlChar *)((void *)0));
}
}
#line 205 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int get_xml_string(xmlTextReaderPtr reader , char *value , int max_len ) 
{ 
  xmlChar *str ;

  {
  {
#line 211
  str = get_xml_text(reader);
  }
#line 212
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    {
#line 213
    strncpy((char */* __restrict  */)value, (char const   */* __restrict  */)((char *)str),
            (size_t )max_len);
#line 214
    (*xmlFree)((void *)str);
    }
#line 215
    return (0);
  } else {
#line 218
    return (-1);
  }
}
}
#line 222 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int get_xml_time_t(xmlTextReaderPtr reader , time_t *value ) 
{ 
  xmlChar *text ;
  time_t temp ;
  int *tmp ;
  long long tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp11 ;

  {
  {
#line 228
  text = get_xml_text(reader);
  }
#line 228
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 229
    tmp = __errno_location();
#line 229
    *tmp = 0;
#line 233
    tmp___0 = strtoll((char const   */* __restrict  */)((char *)text), (char **/* __restrict  */)((void *)0),
                      0);
#line 233
    temp = (time_t )tmp___0;
#line 237
    tmp___4 = __errno_location();
    }
#line 237
    if (*tmp___4 > 0) {
      {
#line 238
      tmp___1 = __errno_location();
#line 238
      tmp___2 = rrd_strerror(*tmp___1);
#line 238
      tmp___3 = xmlTextReaderGetParserLineNumber(reader);
#line 238
      rrd_set_error((char *)"ling %d: get_xml_time_t from \'%s\' %s", tmp___3, text,
                    tmp___2);
#line 241
      (*xmlFree)((void *)text);
      }
#line 242
      return (-1);
    }
    {
#line 244
    (*xmlFree)((void *)text);
#line 245
    *value = temp;
    }
#line 246
    return (0);
  }
#line 248
  return (-1);
}
}
#line 251 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int get_xml_ulong(xmlTextReaderPtr reader , unsigned long *value ) 
{ 
  xmlChar *text ;
  unsigned long temp ;
  int *tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp10 ;

  {
  {
#line 258
  text = get_xml_text(reader);
  }
#line 258
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 259
    tmp = __errno_location();
#line 259
    *tmp = 0;
#line 260
    temp = strtoul((char const   */* __restrict  */)((char *)text), (char **/* __restrict  */)((void *)0),
                   0);
#line 261
    tmp___3 = __errno_location();
    }
#line 261
    if (*tmp___3 > 0) {
      {
#line 262
      tmp___0 = __errno_location();
#line 262
      tmp___1 = rrd_strerror(*tmp___0);
#line 262
      tmp___2 = xmlTextReaderGetParserLineNumber(reader);
#line 262
      rrd_set_error((char *)"ling %d: get_xml_ulong from \'%s\' %s", tmp___2, text,
                    tmp___1);
#line 265
      (*xmlFree)((void *)text);
      }
#line 266
      return (-1);
    }
    {
#line 268
    (*xmlFree)((void *)text);
#line 269
    *value = temp;
    }
#line 270
    return (0);
  }
#line 272
  return (-1);
}
}
#line 275 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int get_xml_double(xmlTextReaderPtr reader , double *value ) 
{ 
  xmlChar *text ;
  double temp ;
  double tmp ;
  xmlChar const   *tmp___0 ;
  xmlChar const   *tmp___1 ;
  xmlChar const   *tmp___2 ;
  xmlChar const   *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 282
  text = get_xml_text(reader);
  }
#line 282
  if ((unsigned long )text != (unsigned long )((void *)0)) {
    {
#line 283
    tmp___3 = xmlStrcasestr((xmlChar const   *)text, (xmlChar const   *)((xmlChar *)"nan"));
    }
#line 283
    if (tmp___3) {
      {
#line 284
      *value = rrd_set_to_DNAN();
#line 285
      (*xmlFree)((void *)text);
      }
#line 286
      return (0);
    } else {
      {
#line 288
      tmp___2 = xmlStrcasestr((xmlChar const   *)text, (xmlChar const   *)((xmlChar *)"-inf"));
      }
#line 288
      if (tmp___2) {
        {
#line 289
        tmp = rrd_set_to_DINF();
#line 289
        *value = - tmp;
#line 290
        (*xmlFree)((void *)text);
        }
#line 291
        return (0);
      } else {
        {
#line 293
        tmp___0 = xmlStrcasestr((xmlChar const   *)text, (xmlChar const   *)((xmlChar *)"+inf"));
        }
#line 293
        if (tmp___0) {
          {
#line 295
          *value = rrd_set_to_DINF();
#line 296
          (*xmlFree)((void *)text);
          }
#line 297
          return (0);
        } else {
          {
#line 293
          tmp___1 = xmlStrcasestr((xmlChar const   *)text, (xmlChar const   *)((xmlChar *)"inf"));
          }
#line 293
          if (tmp___1) {
            {
#line 295
            *value = rrd_set_to_DINF();
#line 296
            (*xmlFree)((void *)text);
            }
#line 297
            return (0);
          }
        }
      }
    }
    {
#line 299
    tmp___4 = __errno_location();
#line 299
    *tmp___4 = 0;
#line 300
    temp = strtod((char const   */* __restrict  */)((char *)text), (char **/* __restrict  */)((void *)0));
#line 301
    tmp___8 = __errno_location();
    }
#line 301
    if (*tmp___8 > 0) {
      {
#line 302
      tmp___5 = __errno_location();
#line 302
      tmp___6 = rrd_strerror(*tmp___5);
#line 302
      tmp___7 = xmlTextReaderGetParserLineNumber(reader);
#line 302
      rrd_set_error((char *)"ling %d: get_xml_double from \'%s\' %s", tmp___7, text,
                    tmp___6);
#line 305
      (*xmlFree)((void *)text);
      }
#line 306
      return (-1);
    }
    {
#line 308
    (*xmlFree)((void *)text);
#line 309
    *value = temp;
    }
#line 310
    return (0);
  }
#line 312
  return (-1);
}
}
#line 316 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int value_check_range(rrd_value_t *rrd_value , ds_def_t const   *ds_def ) 
{ 
  double min ;
  double max ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 323
  if (opt_range_check == 0) {
#line 324
    return (0);
  }
#line 326
  min = (double )ds_def->par[1].u_val;
#line 327
  max = (double )ds_def->par[2].u_val;
#line 329
  if (sizeof(min) == sizeof(float )) {
    {
#line 329
    tmp = __isnanf((float )min);
#line 329
    tmp___3 = tmp;
    }
  } else {
#line 329
    if (sizeof(min) == sizeof(double )) {
      {
#line 329
      tmp___0 = __isnan(min);
#line 329
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 329
      tmp___1 = __isnanl((long double )min);
#line 329
      tmp___2 = tmp___1;
      }
    }
#line 329
    tmp___3 = tmp___2;
  }
#line 329
  if (tmp___3) {
    _L: /* CIL Label */ 
#line 329
    if (sizeof(max) == sizeof(float )) {
      {
#line 329
      tmp___4 = __isnanf((float )max);
#line 329
      tmp___8 = tmp___4;
      }
    } else {
#line 329
      if (sizeof(max) == sizeof(double )) {
        {
#line 329
        tmp___5 = __isnan(max);
#line 329
        tmp___7 = tmp___5;
        }
      } else {
        {
#line 329
        tmp___6 = __isnanl((long double )max);
#line 329
        tmp___7 = tmp___6;
        }
      }
#line 329
      tmp___8 = tmp___7;
    }
#line 329
    if (! tmp___8) {
#line 329
      if (*rrd_value > max) {
        {
#line 331
        *rrd_value = rrd_set_to_DNAN();
        }
      }
    }
  } else
#line 329
  if (*rrd_value < min) {
    {
#line 331
    *rrd_value = rrd_set_to_DNAN();
    }
  } else {
#line 329
    goto _L;
  }
#line 333
  return (0);
}
}
#line 340 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_rra_database_row(xmlTextReaderPtr reader , rrd_t *rrd , rrd_value_t *rrd_value ) 
{ 
  unsigned int values_count ;
  int status ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 345
  values_count = 0U;
#line 348
  status = 0;
#line 349
  values_count = 0U;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! ((unsigned long )values_count < (rrd->stat_head)->ds_cnt)) {
#line 349
      goto while_break;
    }
    {
#line 350
    tmp = expect_element(reader, (char *)"v");
    }
#line 350
    if (tmp == 0) {
      {
#line 351
      status = get_xml_double(reader, rrd_value + values_count);
      }
#line 352
      if (status == 0) {
        {
#line 353
        value_check_range(rrd_value + values_count, (ds_def_t const   *)(rrd->ds_def + values_count));
        }
      } else {
#line 356
        goto while_break;
      }
    } else {
#line 358
      return (-1);
    }
    {
#line 359
    tmp___0 = expect_element(reader, (char *)"/v");
    }
#line 359
    if (tmp___0 == -1) {
#line 360
      return (-1);
    }
#line 349
    values_count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return (status);
}
}
#line 366 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_rra_database(xmlTextReaderPtr reader , rrd_t *rrd ) 
{ 
  rra_def_t *cur_rra_def ;
  unsigned int total_row_cnt ;
  int status ;
  int i ;
  xmlChar *element ;
  rrd_value_t *temp ;
  rrd_value_t *cur_rrd_value ;
  unsigned int total_values_count ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 376
  total_row_cnt = 0U;
#line 377
  i = 0;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! (i < (int )(rrd->stat_head)->rra_cnt - 1)) {
#line 377
      goto while_break;
    }
#line 378
    total_row_cnt = (unsigned int )((unsigned long )total_row_cnt + (rrd->rra_def + i)->row_cnt);
#line 377
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  cur_rra_def = rrd->rra_def + i;
#line 382
  status = 0;
  {
#line 383
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 383
    element = get_xml_element(reader);
    }
#line 383
    if (! ((unsigned long )element != (unsigned long )((void *)0))) {
#line 383
      goto while_break___0;
    }
    {
#line 384
    tmp___2 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"row");
    }
#line 384
    if (tmp___2 == 0) {
      {
#line 387
      total_values_count = (unsigned int )((rrd->stat_head)->ds_cnt * (unsigned long )(total_row_cnt + 1U));
#line 391
      tmp = realloc((void *)rrd->rrd_value, sizeof(rrd_value_t ) * (unsigned long )total_values_count);
#line 391
      temp = (rrd_value_t *)tmp;
      }
#line 394
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
        {
#line 395
        rrd_set_error((char *)"parse_tag_rra_database: realloc failed.");
#line 396
        status = -1;
        }
#line 397
        goto while_break___0;
      }
      {
#line 399
      rrd->rrd_value = temp;
#line 400
      cur_rrd_value = rrd->rrd_value + (rrd->stat_head)->ds_cnt * (unsigned long )total_row_cnt;
#line 402
      memset((void *)cur_rrd_value, '\000', sizeof(rrd_value_t ) * (rrd->stat_head)->ds_cnt);
#line 404
      total_row_cnt ++;
#line 405
      (cur_rra_def->row_cnt) ++;
#line 407
      status = parse_tag_rra_database_row(reader, rrd, cur_rrd_value);
      }
#line 409
      if (status == 0) {
        {
#line 410
        status = expect_element(reader, (char *)"/row");
        }
      }
    } else {
      {
#line 413
      tmp___1 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"/database");
      }
#line 413
      if (tmp___1 == 0) {
        {
#line 414
        (*xmlFree)((void *)element);
        }
#line 415
        goto while_break___0;
      } else {
        {
#line 418
        tmp___0 = xmlTextReaderGetParserLineNumber(reader);
#line 418
        rrd_set_error((char *)"line %d: found unexpected tag: %s", tmp___0, element);
#line 420
        status = -1;
        }
      }
    }
    {
#line 423
    (*xmlFree)((void *)element);
    }
#line 424
    if (status != 0) {
#line 425
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 427
  return (status);
}
}
#line 433 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_rra_cdp_prep_ds_history(xmlTextReaderPtr reader , cdp_prep_t *cdp_prep ) 
{ 
  xmlChar *history ;
  char *history_ptr ;
  int i ;

  {
  {
#line 442
  history = get_xml_text(reader);
  }
#line 442
  if ((unsigned long )history != (unsigned long )((void *)0)) {
#line 443
    history_ptr = (char *)(& cdp_prep->scratch[0]);
#line 444
    i = 0;
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
#line 444
      if (! ((int )*(history + i) != 0)) {
#line 444
        goto while_break;
      }
#line 445
      if ((int )*(history + i) == 49) {
#line 445
        *(history_ptr + i) = (char)1;
      } else {
#line 445
        *(history_ptr + i) = (char)0;
      }
#line 444
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 446
    (*xmlFree)((void *)history);
    }
#line 447
    return (0);
  }
#line 449
  return (-1);
}
}
#line 452 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_rra_cdp_prep_ds(xmlTextReaderPtr reader , rrd_t *rrd , cdp_prep_t *cdp_prep ) 
{ 
  int status ;
  xmlChar *element ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 459
  memset((void *)cdp_prep, '\000', sizeof(cdp_prep_t ));
#line 461
  status = -1;
#line 463
  tmp = atoi((char const   *)((rrd->stat_head)->version));
  }
#line 463
  if (tmp == 1) {
#line 464
    cdp_prep->scratch[8].u_val = 0.0;
#line 465
    cdp_prep->scratch[9].u_val = 0.0;
  }
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 468
    element = get_xml_element(reader);
    }
#line 468
    if (! ((unsigned long )element != (unsigned long )((void *)0))) {
#line 468
      goto while_break;
    }
    {
#line 469
    tmp___14 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"primary_value");
    }
#line 469
    if (tmp___14 == 0) {
      {
#line 470
      status = get_xml_double(reader, & cdp_prep->scratch[8].u_val);
      }
    } else {
      {
#line 472
      tmp___13 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"secondary_value");
      }
#line 472
      if (tmp___13 == 0) {
        {
#line 473
        status = get_xml_double(reader, & cdp_prep->scratch[9].u_val);
        }
      } else {
        {
#line 475
        tmp___12 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"intercept");
        }
#line 475
        if (tmp___12 == 0) {
          {
#line 476
          status = get_xml_double(reader, & cdp_prep->scratch[2].u_val);
          }
        } else {
          {
#line 479
          tmp___11 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"last_intercept");
          }
#line 479
          if (tmp___11 == 0) {
            {
#line 481
            status = get_xml_double(reader, & cdp_prep->scratch[3].u_val);
            }
          } else {
            {
#line 485
            tmp___10 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"slope");
            }
#line 485
            if (tmp___10 == 0) {
              {
#line 486
              status = get_xml_double(reader, & cdp_prep->scratch[4].u_val);
              }
            } else {
              {
#line 489
              tmp___9 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"last_slope");
              }
#line 489
              if (tmp___9 == 0) {
                {
#line 490
                status = get_xml_double(reader, & cdp_prep->scratch[5].u_val);
                }
              } else {
                {
#line 493
                tmp___8 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"nan_count");
                }
#line 493
                if (tmp___8 == 0) {
                  {
#line 494
                  status = get_xml_ulong(reader, & cdp_prep->scratch[6].u_cnt);
                  }
                } else {
                  {
#line 497
                  tmp___7 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"last_nan_count");
                  }
#line 497
                  if (tmp___7 == 0) {
                    {
#line 499
                    status = get_xml_ulong(reader, & cdp_prep->scratch[7].u_cnt);
                    }
                  } else {
                    {
#line 503
                    tmp___6 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"seasonal");
                    }
#line 503
                    if (tmp___6 == 0) {
                      {
#line 504
                      status = get_xml_double(reader, & cdp_prep->scratch[2].u_val);
                      }
                    } else {
                      {
#line 507
                      tmp___5 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"last_seasonal");
                      }
#line 507
                      if (tmp___5 == 0) {
                        {
#line 509
                        status = get_xml_double(reader, & cdp_prep->scratch[3].u_val);
                        }
                      } else {
                        {
#line 513
                        tmp___4 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"init_flag");
                        }
#line 513
                        if (tmp___4 == 0) {
                          {
#line 514
                          status = get_xml_ulong(reader, & cdp_prep->scratch[6].u_cnt);
                          }
                        } else {
                          {
#line 517
                          tmp___3 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"history");
                          }
#line 517
                          if (tmp___3 == 0) {
                            {
#line 518
                            status = parse_tag_rra_cdp_prep_ds_history(reader, cdp_prep);
                            }
                          } else {
                            {
#line 519
                            tmp___2 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"value");
                            }
#line 519
                            if (tmp___2 == 0) {
                              {
#line 520
                              status = get_xml_double(reader, & cdp_prep->scratch[0].u_val);
                              }
                            } else {
                              {
#line 522
                              tmp___1 = xmlStrcasecmp((xmlChar const   *)element,
                                                      (xmlChar const   *)"unknown_datapoints");
                              }
#line 522
                              if (tmp___1 == 0) {
                                {
#line 524
                                status = get_xml_ulong(reader, & cdp_prep->scratch[1].u_cnt);
                                }
                              } else {
                                {
#line 527
                                tmp___0 = xmlStrcasecmp((xmlChar const   *)element,
                                                        (xmlChar const   *)"/ds");
                                }
#line 527
                                if (tmp___0 == 0) {
                                  {
#line 529
                                  (*xmlFree)((void *)element);
                                  }
#line 530
                                  goto while_break;
                                } else {
                                  {
#line 533
                                  rrd_set_error((char *)"parse_tag_rra_cdp_prep: Unknown tag: %s",
                                                element);
#line 535
                                  status = -1;
#line 536
                                  (*xmlFree)((void *)element);
                                  }
#line 537
                                  goto while_break;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 539
    if (status != 0) {
      {
#line 540
      (*xmlFree)((void *)element);
      }
#line 541
      goto while_break;
    }
    {
#line 543
    status = expect_element_end(reader, (char *)element);
#line 544
    (*xmlFree)((void *)element);
    }
#line 545
    if (status != 0) {
#line 546
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 548
  return (status);
}
}
#line 551 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_rra_cdp_prep(xmlTextReaderPtr reader , rrd_t *rrd , cdp_prep_t *cdp_prep ) 
{ 
  int status ;
  unsigned int ds_count ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 560
  status = 0;
#line 561
  ds_count = 0U;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! ((unsigned long )ds_count < (rrd->stat_head)->ds_cnt)) {
#line 561
      goto while_break;
    }
    {
#line 562
    tmp = expect_element(reader, (char *)"ds");
    }
#line 562
    if (tmp == 0) {
      {
#line 563
      status = parse_tag_rra_cdp_prep_ds(reader, rrd, cdp_prep + ds_count);
      }
#line 565
      if (status != 0) {
#line 566
        goto while_break;
      }
    } else {
#line 568
      status = -1;
#line 569
      goto while_break;
    }
#line 561
    ds_count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 572
  if (status == 0) {
    {
#line 573
    status = expect_element(reader, (char *)"/cdp_prep");
    }
  }
#line 574
  return (status);
}
}
#line 580 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_rra_params(xmlTextReaderPtr reader , rra_def_t *rra_def ) 
{ 
  xmlChar *element ;
  int status ;
  unsigned int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 587
  status = -1;
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 588
    element = get_xml_element(reader);
    }
#line 588
    if (! ((unsigned long )element != (unsigned long )((void *)0))) {
#line 588
      goto while_break;
    }
    {
#line 592
    tmp___12 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"hw_alpha");
    }
#line 592
    if (tmp___12 == 0) {
      {
#line 593
      status = get_xml_double(reader, & rra_def->par[1].u_val);
      }
    } else {
      {
#line 595
      tmp___11 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"hw_beta");
      }
#line 595
      if (tmp___11 == 0) {
        {
#line 596
        status = get_xml_double(reader, & rra_def->par[2].u_val);
        }
      } else {
        {
#line 598
        tmp___10 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"dependent_rra_idx");
        }
#line 598
        if (tmp___10 == 0) {
          {
#line 600
          status = get_xml_ulong(reader, & rra_def->par[3].u_cnt);
          }
        } else {
          {
#line 606
          tmp___9 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"seasonal_gamma");
          }
#line 606
          if (tmp___9 == 0) {
            {
#line 608
            status = get_xml_double(reader, & rra_def->par[1].u_val);
            }
          } else {
            {
#line 611
            tmp___8 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"seasonal_smooth_idx");
            }
#line 611
            if (tmp___8 == 0) {
              {
#line 613
              status = get_xml_ulong(reader, & rra_def->par[4].u_cnt);
              }
            } else {
              {
#line 617
              tmp___7 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"smoothing_window");
              }
#line 617
              if (tmp___7 == 0) {
                {
#line 619
                status = get_xml_double(reader, & rra_def->par[2].u_val);
                }
              } else {
                {
#line 628
                tmp___6 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"delta_pos");
                }
#line 628
                if (tmp___6 == 0) {
                  {
#line 629
                  status = get_xml_double(reader, & rra_def->par[1].u_val);
                  }
                } else {
                  {
#line 631
                  tmp___5 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"delta_neg");
                  }
#line 631
                  if (tmp___5 == 0) {
                    {
#line 632
                    status = get_xml_double(reader, & rra_def->par[2].u_val);
                    }
                  } else {
                    {
#line 634
                    tmp___4 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"window_len");
                    }
#line 634
                    if (tmp___4 == 0) {
                      {
#line 635
                      status = get_xml_ulong(reader, & rra_def->par[4].u_cnt);
                      }
                    } else {
                      {
#line 638
                      tmp___3 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"failure_threshold");
                      }
#line 638
                      if (tmp___3 == 0) {
                        {
#line 640
                        status = get_xml_ulong(reader, & rra_def->par[5].u_cnt);
                        }
                      } else {
                        {
#line 647
                        tmp___2 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"xff");
                        }
#line 647
                        if (tmp___2 == 0) {
                          {
#line 648
                          status = get_xml_double(reader, & rra_def->par[0].u_val);
                          }
                        } else {
                          {
#line 654
                          tmp___1 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"value");
                          }
#line 654
                          if (tmp___1 == 0) {
#line 655
                            i = 0U;
#line 657
                            i = 0U;
                            {
#line 657
                            while (1) {
                              while_continue___0: /* CIL Label */ ;
#line 657
                              if (! ((unsigned long )i < sizeof(rra_def->par) / sizeof(rra_def->par[0]))) {
#line 657
                                goto while_break___0;
                              }
#line 658
                              if (i == 3U) {
                                {
#line 661
                                status = get_xml_ulong(reader, & rra_def->par[i].u_cnt);
                                }
                              } else
#line 658
                              if (i == 4U) {
                                {
#line 661
                                status = get_xml_ulong(reader, & rra_def->par[i].u_cnt);
                                }
                              } else
#line 658
                              if (i == 5U) {
                                {
#line 661
                                status = get_xml_ulong(reader, & rra_def->par[i].u_cnt);
                                }
                              } else {
                                {
#line 665
                                status = get_xml_double(reader, & rra_def->par[i].u_val);
                                }
                              }
#line 668
                              if (status != 0) {
#line 669
                                goto while_break___0;
                              }
#line 670
                              if ((unsigned long )(i - 1U) < sizeof(rra_def->par) / sizeof(rra_def->par[0])) {
                                {
#line 671
                                status = expect_element(reader, (char *)"/value");
                                }
#line 672
                                if (status == 0) {
                                  {
#line 673
                                  status = expect_element(reader, (char *)"value");
                                  }
                                }
                              }
#line 676
                              if (status != 0) {
#line 677
                                goto while_break___0;
                              }
#line 657
                              i ++;
                            }
                            while_break___0: /* CIL Label */ ;
                            }
                          } else {
                            {
#line 681
                            tmp___0 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"/params");
                            }
#line 681
                            if (tmp___0 == 0) {
                              {
#line 682
                              (*xmlFree)((void *)element);
                              }
#line 683
                              return (status);
                            } else {
                              {
#line 686
                              tmp = xmlTextReaderGetParserLineNumber(reader);
#line 686
                              rrd_set_error((char *)"line %d: parse_tag_rra_params: Unknown tag: %s",
                                            tmp, element);
#line 688
                              status = -1;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 690
    status = expect_element_end(reader, (char *)element);
#line 691
    (*xmlFree)((void *)element);
    }
#line 692
    if (status != 0) {
#line 693
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 695
  return (status);
}
}
#line 701 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_rra_cf(xmlTextReaderPtr reader , rra_def_t *rra_def ) 
{ 
  int status ;
  enum cf_en tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 707
  status = get_xml_string(reader, rra_def->cf_nam, (int )sizeof(rra_def->cf_nam));
  }
#line 709
  if (status != 0) {
#line 710
    return (status);
  }
  {
#line 712
  tmp = cf_conv((char const   *)(rra_def->cf_nam));
#line 712
  status = (int )tmp;
  }
#line 713
  if (status == -1) {
    {
#line 714
    rrd_set_error((char *)"parse_tag_rra_cf: Unknown consolidation function: %s",
                  rra_def->cf_nam);
    }
#line 716
    return (-1);
  }
#line 719
  return (0);
}
}
#line 722 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_rra(xmlTextReaderPtr reader , rrd_t *rrd ) 
{ 
  int status ;
  xmlChar *element ;
  rra_def_t *cur_rra_def ;
  cdp_prep_t *cur_cdp_prep ;
  rra_ptr_t *cur_rra_ptr ;
  rra_def_t *temp ;
  void *tmp ;
  cdp_prep_t *temp___0 ;
  void *tmp___0 ;
  rra_ptr_t *temp___1 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 737
  tmp = realloc((void *)rrd->rra_def, sizeof(rra_def_t ) * ((rrd->stat_head)->rra_cnt + 1UL));
#line 737
  temp = (rra_def_t *)tmp;
  }
#line 740
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 741
    rrd_set_error((char *)"parse_tag_rra: realloc failed.");
    }
#line 742
    return (-1);
  }
  {
#line 744
  rrd->rra_def = temp;
#line 745
  cur_rra_def = rrd->rra_def + (rrd->stat_head)->rra_cnt;
#line 746
  memset((void *)cur_rra_def, '\000', sizeof(rra_def_t ));
#line 753
  tmp___0 = realloc((void *)rrd->cdp_prep, (sizeof(cdp_prep_t ) * (rrd->stat_head)->ds_cnt) * ((rrd->stat_head)->rra_cnt + 1UL));
#line 753
  temp___0 = (cdp_prep_t *)tmp___0;
  }
#line 756
  if ((unsigned long )temp___0 == (unsigned long )((void *)0)) {
    {
#line 757
    rrd_set_error((char *)"parse_tag_rra: realloc failed.");
    }
#line 758
    return (-1);
  }
  {
#line 760
  rrd->cdp_prep = temp___0;
#line 761
  cur_cdp_prep = rrd->cdp_prep + (rrd->stat_head)->ds_cnt * (rrd->stat_head)->rra_cnt;
#line 763
  memset((void *)cur_cdp_prep, '\000', sizeof(cdp_prep_t ) * (rrd->stat_head)->ds_cnt);
#line 771
  tmp___1 = realloc((void *)rrd->rra_ptr, sizeof(rra_ptr_t ) * ((rrd->stat_head)->rra_cnt + 1UL));
#line 771
  temp___1 = (rra_ptr_t *)tmp___1;
  }
#line 774
  if ((unsigned long )temp___1 == (unsigned long )((void *)0)) {
    {
#line 775
    rrd_set_error((char *)"parse_tag_rra: realloc failed.");
    }
#line 776
    return (-1);
  }
  {
#line 778
  rrd->rra_ptr = temp___1;
#line 779
  cur_rra_ptr = rrd->rra_ptr + (rrd->stat_head)->rra_cnt;
#line 780
  memset((void *)cur_rra_ptr, '\000', sizeof(rra_ptr_t ));
#line 784
  ((rrd->stat_head)->rra_cnt) ++;
#line 786
  status = 0;
  }
  {
#line 787
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 787
    element = get_xml_element(reader);
    }
#line 787
    if (! ((unsigned long )element != (unsigned long )((void *)0))) {
#line 787
      goto while_break;
    }
    {
#line 788
    tmp___11 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"cf");
    }
#line 788
    if (tmp___11 == 0) {
      {
#line 789
      status = parse_tag_rra_cf(reader, cur_rra_def);
      }
    } else {
      {
#line 790
      tmp___10 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"pdp_per_row");
      }
#line 790
      if (tmp___10 == 0) {
        {
#line 791
        status = get_xml_ulong(reader, & cur_rra_def->pdp_cnt);
        }
      } else {
        {
#line 793
        tmp___8 = atoi((char const   *)((rrd->stat_head)->version));
        }
#line 793
        if (tmp___8 == 1) {
          {
#line 793
          tmp___9 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"xff");
          }
#line 793
          if (tmp___9 == 0) {
            {
#line 795
            status = get_xml_double(reader, & cur_rra_def->par[0].u_val);
            }
          } else {
#line 793
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 798
          tmp___6 = atoi((char const   *)((rrd->stat_head)->version));
          }
#line 798
          if (tmp___6 >= 2) {
            {
#line 798
            tmp___7 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"params");
            }
#line 798
            if (tmp___7 == 0) {
              {
#line 800
              (*xmlFree)((void *)element);
#line 801
              status = parse_tag_rra_params(reader, cur_rra_def);
              }
#line 802
              if (status == 0) {
#line 803
                goto while_continue;
              } else {
#line 805
                return (status);
              }
            } else {
#line 798
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 807
            tmp___5 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"cdp_prep");
            }
#line 807
            if (tmp___5 == 0) {
              {
#line 808
              (*xmlFree)((void *)element);
#line 809
              status = parse_tag_rra_cdp_prep(reader, rrd, cur_cdp_prep);
              }
#line 810
              if (status == 0) {
#line 811
                goto while_continue;
              } else {
#line 813
                return (status);
              }
            } else {
              {
#line 815
              tmp___4 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"database");
              }
#line 815
              if (tmp___4 == 0) {
                {
#line 816
                (*xmlFree)((void *)element);
#line 817
                status = parse_tag_rra_database(reader, rrd);
                }
#line 818
                if (status == 0) {
#line 819
                  goto while_continue;
                } else {
#line 821
                  return (status);
                }
              } else {
                {
#line 823
                tmp___3 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"/rra");
                }
#line 823
                if (tmp___3 == 0) {
                  {
#line 824
                  (*xmlFree)((void *)element);
                  }
#line 825
                  return (status);
                } else {
                  {
#line 828
                  tmp___2 = xmlTextReaderGetParserLineNumber(reader);
#line 828
                  rrd_set_error((char *)"line %d: parse_tag_rra: Unknown tag: %s",
                                tmp___2, element);
#line 830
                  status = -1;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 832
    if (status != 0) {
      {
#line 833
      (*xmlFree)((void *)element);
      }
#line 834
      return (status);
    }
    {
#line 836
    status = expect_element_end(reader, (char *)element);
#line 837
    (*xmlFree)((void *)element);
    }
#line 838
    if (status != 0) {
#line 839
      return (status);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 843
  tmp___12 = rrd_random();
#line 843
  cur_rra_ptr->cur_row = (unsigned long )tmp___12 % cur_rra_def->row_cnt;
  }
#line 845
  return (status);
}
}
#line 851 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_ds_cdef(xmlTextReaderPtr reader , rrd_t *rrd ) 
{ 
  xmlChar *cdef ;
  int tmp ;

  {
  {
#line 857
  cdef = get_xml_text(reader);
  }
#line 858
  if ((unsigned long )cdef != (unsigned long )((void *)0)) {
    {
#line 861
    parseCDEF_DS((char const   *)((char *)cdef), rrd, (int )((rrd->stat_head)->ds_cnt - 1UL));
#line 862
    (*xmlFree)((void *)cdef);
#line 863
    tmp = rrd_test_error();
    }
#line 863
    if (tmp) {
#line 864
      return (-1);
    } else {
#line 866
      return (0);
    }
  }
#line 868
  return (-1);
}
}
#line 871 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_ds_type(xmlTextReaderPtr reader , ds_def_t *ds_def ) 
{ 
  char *dst ;
  xmlChar *tmp ;
  int status ;
  enum dst_en tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 876
  tmp = get_xml_text(reader);
#line 876
  dst = (char *)tmp;
  }
#line 877
  if ((unsigned long )dst != (unsigned long )((void *)0)) {
    {
#line 879
    tmp___0 = dst_conv(dst);
#line 879
    status = (int )tmp___0;
    }
#line 880
    if (status == -1) {
      {
#line 881
      rrd_set_error((char *)"parse_tag_ds_type: Unknown data source type: %s", dst);
      }
#line 883
      return (-1);
    }
    {
#line 885
    strncpy((char */* __restrict  */)(ds_def->dst), (char const   */* __restrict  */)dst,
            sizeof(ds_def->dst) - 1UL);
#line 886
    ds_def->dst[sizeof(ds_def->dst) - 1UL] = (char )'\000';
#line 887
    (*xmlFree)((void *)dst);
    }
#line 888
    return (0);
  }
#line 890
  return (-1);
}
}
#line 893 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_ds(xmlTextReaderPtr reader , rrd_t *rrd ) 
{ 
  int status ;
  xmlChar *element ;
  ds_def_t *cur_ds_def ;
  pdp_prep_t *cur_pdp_prep ;
  ds_def_t *temp ;
  void *tmp ;
  pdp_prep_t *temp___0 ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 908
  if ((rrd->stat_head)->rra_cnt > 0UL) {
    {
#line 909
    rrd_set_error((char *)"parse_tag_ds: All data source definitions MUST precede the RRA definitions!");
    }
#line 911
    return (-1);
  }
  {
#line 918
  tmp = realloc((void *)rrd->ds_def, sizeof(ds_def_t ) * ((rrd->stat_head)->ds_cnt + 1UL));
#line 918
  temp = (ds_def_t *)tmp;
  }
#line 921
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 922
    rrd_set_error((char *)"parse_tag_ds: malloc failed.");
    }
#line 923
    return (-1);
  }
  {
#line 925
  rrd->ds_def = temp;
#line 926
  cur_ds_def = rrd->ds_def + (rrd->stat_head)->ds_cnt;
#line 927
  memset((void *)cur_ds_def, '\000', sizeof(ds_def_t ));
#line 934
  tmp___0 = realloc((void *)rrd->pdp_prep, sizeof(pdp_prep_t ) * ((rrd->stat_head)->ds_cnt + 1UL));
#line 934
  temp___0 = (pdp_prep_t *)tmp___0;
  }
#line 937
  if ((unsigned long )temp___0 == (unsigned long )((void *)0)) {
    {
#line 938
    rrd_set_error((char *)"parse_tag_ds: malloc failed.");
    }
#line 939
    return (-1);
  }
  {
#line 941
  rrd->pdp_prep = temp___0;
#line 942
  cur_pdp_prep = rrd->pdp_prep + (rrd->stat_head)->ds_cnt;
#line 943
  memset((void *)cur_pdp_prep, '\000', sizeof(pdp_prep_t ));
#line 947
  ((rrd->stat_head)->ds_cnt) ++;
#line 949
  status = 0;
  }
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 950
    element = get_xml_element(reader);
    }
#line 950
    if (! ((unsigned long )element != (unsigned long )((void *)0))) {
#line 950
      goto while_break;
    }
    {
#line 951
    tmp___10 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"name");
    }
#line 951
    if (tmp___10 == 0) {
      {
#line 952
      status = get_xml_string(reader, cur_ds_def->ds_nam, (int )sizeof(cur_ds_def->ds_nam));
      }
    } else {
      {
#line 954
      tmp___9 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"type");
      }
#line 954
      if (tmp___9 == 0) {
        {
#line 955
        status = parse_tag_ds_type(reader, cur_ds_def);
        }
      } else {
        {
#line 956
        tmp___8 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"minimal_heartbeat");
        }
#line 956
        if (tmp___8 == 0) {
          {
#line 958
          status = get_xml_ulong(reader, & cur_ds_def->par[0].u_cnt);
          }
        } else {
          {
#line 961
          tmp___7 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"min");
          }
#line 961
          if (tmp___7 == 0) {
            {
#line 962
            status = get_xml_double(reader, & cur_ds_def->par[1].u_val);
            }
          } else {
            {
#line 964
            tmp___6 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"max");
            }
#line 964
            if (tmp___6 == 0) {
              {
#line 965
              status = get_xml_double(reader, & cur_ds_def->par[2].u_val);
              }
            } else {
              {
#line 967
              tmp___5 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"cdef");
              }
#line 967
              if (tmp___5 == 0) {
                {
#line 968
                status = parse_tag_ds_cdef(reader, rrd);
                }
              } else {
                {
#line 969
                tmp___4 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"last_ds");
                }
#line 969
                if (tmp___4 == 0) {
                  {
#line 970
                  status = get_xml_string(reader, cur_pdp_prep->last_ds, (int )sizeof(cur_pdp_prep->last_ds));
                  }
                } else {
                  {
#line 973
                  tmp___3 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"value");
                  }
#line 973
                  if (tmp___3 == 0) {
                    {
#line 974
                    status = get_xml_double(reader, & cur_pdp_prep->scratch[1].u_val);
                    }
                  } else {
                    {
#line 977
                    tmp___2 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"unknown_sec");
                    }
#line 977
                    if (tmp___2 == 0) {
                      {
#line 978
                      status = get_xml_ulong(reader, & cur_pdp_prep->scratch[0].u_cnt);
                      }
                    } else {
                      {
#line 981
                      tmp___1 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"/ds");
                      }
#line 981
                      if (tmp___1 == 0) {
                        {
#line 982
                        (*xmlFree)((void *)element);
                        }
#line 983
                        goto while_break;
                      } else {
                        {
#line 986
                        rrd_set_error((char *)"parse_tag_ds: Unknown tag: %s", element);
#line 987
                        status = -1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 989
    if (status != 0) {
      {
#line 990
      (*xmlFree)((void *)element);
      }
#line 991
      goto while_break;
    }
    {
#line 993
    status = expect_element_end(reader, (char *)element);
#line 994
    (*xmlFree)((void *)element);
    }
#line 995
    if (status != 0) {
#line 996
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  return (status);
}
}
#line 1005 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int parse_tag_rrd(xmlTextReaderPtr reader , rrd_t *rrd ) 
{ 
  int status ;
  xmlChar *element ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1012
  status = 0;
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1013
    element = get_xml_element(reader);
    }
#line 1013
    if (! ((unsigned long )element != (unsigned long )((void *)0))) {
#line 1013
      goto while_break;
    }
    {
#line 1014
    tmp___4 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"version");
    }
#line 1014
    if (tmp___4 == 0) {
      {
#line 1015
      status = get_xml_string(reader, (rrd->stat_head)->version, (int )sizeof((rrd->stat_head)->version));
      }
    } else {
      {
#line 1018
      tmp___3 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"step");
      }
#line 1018
      if (tmp___3 == 0) {
        {
#line 1019
        status = get_xml_ulong(reader, & (rrd->stat_head)->pdp_step);
        }
      } else {
        {
#line 1021
        tmp___2 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"lastupdate");
        }
#line 1021
        if (tmp___2 == 0) {
          {
#line 1022
          status = get_xml_time_t(reader, & (rrd->live_head)->last_up);
          }
        } else {
          {
#line 1024
          tmp___1 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"ds");
          }
#line 1024
          if (tmp___1 == 0) {
            {
#line 1025
            (*xmlFree)((void *)element);
#line 1026
            status = parse_tag_ds(reader, rrd);
            }
#line 1028
            if (status == 0) {
#line 1029
              goto while_continue;
            } else {
#line 1031
              return (status);
            }
          } else {
            {
#line 1033
            tmp___0 = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"rra");
            }
#line 1033
            if (tmp___0 == 0) {
              {
#line 1034
              (*xmlFree)((void *)element);
#line 1035
              status = parse_tag_rra(reader, rrd);
              }
#line 1036
              if (status == 0) {
#line 1037
                goto while_continue;
              } else {
#line 1039
                return (status);
              }
            } else {
              {
#line 1041
              tmp = xmlStrcasecmp((xmlChar const   *)element, (xmlChar const   *)"/rrd");
              }
#line 1041
              if (tmp == 0) {
                {
#line 1042
                (*xmlFree)((void *)element);
                }
#line 1043
                return (status);
              } else {
                {
#line 1046
                rrd_set_error((char *)"parse_tag_rrd: Unknown tag: %s", element);
#line 1047
                status = -1;
                }
              }
            }
          }
        }
      }
    }
#line 1050
    if (status != 0) {
      {
#line 1051
      (*xmlFree)((void *)element);
      }
#line 1052
      goto while_break;
    }
    {
#line 1054
    status = expect_element_end(reader, (char *)element);
#line 1055
    (*xmlFree)((void *)element);
    }
#line 1056
    if (status != 0) {
#line 1057
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1059
  return (status);
}
}
#line 1062 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static rrd_t *parse_file(char const   *filename ) 
{ 
  xmlTextReaderPtr reader ;
  int status ;
  rrd_t *rrd ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1070
  reader = xmlNewTextReaderFilename(filename);
  }
#line 1071
  if ((unsigned long )reader == (unsigned long )((void *)0)) {
    {
#line 1072
    rrd_set_error((char *)"Could not create xml reader for: %s", filename);
    }
#line 1073
    return ((rrd_t *)((void *)0));
  }
  {
#line 1076
  tmp = expect_element(reader, (char *)"rrd");
  }
#line 1076
  if (tmp != 0) {
    {
#line 1077
    xmlFreeTextReader(reader);
    }
#line 1078
    return ((rrd_t *)((void *)0));
  }
  {
#line 1081
  tmp___0 = malloc(sizeof(rrd_t ));
#line 1081
  rrd = (rrd_t *)tmp___0;
  }
#line 1082
  if ((unsigned long )rrd == (unsigned long )((void *)0)) {
    {
#line 1083
    rrd_set_error((char *)"parse_file: malloc failed.");
#line 1084
    xmlFreeTextReader(reader);
    }
#line 1085
    return ((rrd_t *)((void *)0));
  }
  {
#line 1087
  memset((void *)rrd, '\000', sizeof(rrd_t ));
#line 1089
  tmp___1 = malloc(sizeof(stat_head_t ));
#line 1089
  rrd->stat_head = (stat_head_t *)tmp___1;
  }
#line 1090
  if ((unsigned long )rrd->stat_head == (unsigned long )((void *)0)) {
    {
#line 1091
    rrd_set_error((char *)"parse_tag_rrd: malloc failed.");
#line 1092
    xmlFreeTextReader(reader);
#line 1093
    free((void *)rrd);
    }
#line 1094
    return ((rrd_t *)((void *)0));
  }
  {
#line 1096
  memset((void *)rrd->stat_head, '\000', sizeof(stat_head_t ));
#line 1098
  strncpy((char */* __restrict  */)((rrd->stat_head)->cookie), (char const   */* __restrict  */)"RRD",
          sizeof((rrd->stat_head)->cookie));
#line 1099
  (rrd->stat_head)->float_cookie = 8.642135E130;
#line 1101
  tmp___2 = malloc(sizeof(live_head_t ));
#line 1101
  rrd->live_head = (live_head_t *)tmp___2;
  }
#line 1102
  if ((unsigned long )rrd->live_head == (unsigned long )((void *)0)) {
    {
#line 1103
    rrd_set_error((char *)"parse_tag_rrd: malloc failed.");
#line 1104
    xmlFreeTextReader(reader);
#line 1105
    free((void *)rrd->stat_head);
#line 1106
    free((void *)rrd);
    }
#line 1107
    return ((rrd_t *)((void *)0));
  }
  {
#line 1109
  memset((void *)rrd->live_head, '\000', sizeof(live_head_t ));
#line 1111
  status = parse_tag_rrd(reader, rrd);
#line 1113
  xmlFreeTextReader(reader);
  }
#line 1115
  if (status != 0) {
    {
#line 1116
    local_rrd_free(rrd);
#line 1117
    rrd = (rrd_t *)((void *)0);
    }
  }
#line 1120
  return (rrd);
}
}
#line 1123 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static int write_file(char const   *file_name , rrd_t *rrd ) 
{ 
  FILE *fh ;
  unsigned int i ;
  unsigned int rra_offset ;
  int fd_flags ;
  int fd ;
  int *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long num_rows ;
  unsigned long cur_row ;
  unsigned long ds_cnt ;
  int tmp___5 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 1131
  tmp___3 = strcmp("-", file_name);
  }
#line 1131
  if (tmp___3 == 0) {
#line 1132
    fh = stdout;
  } else {
#line 1134
    fd_flags = 65;
#line 1141
    if (opt_force_overwrite == 0) {
#line 1142
      fd_flags |= 128;
    }
    {
#line 1144
    fd = open(file_name, fd_flags, 438);
    }
#line 1145
    if (fd == -1) {
      {
#line 1146
      tmp = __errno_location();
#line 1146
      tmp___0 = rrd_strerror(*tmp);
#line 1146
      rrd_set_error((char *)"creating \'%s\': %s", file_name, tmp___0);
      }
#line 1148
      return (-1);
    }
    {
#line 1151
    fh = fdopen(fd, "wb");
    }
#line 1152
    if ((unsigned long )fh == (unsigned long )((void *)0)) {
      {
#line 1153
      tmp___1 = __errno_location();
#line 1153
      tmp___2 = rrd_strerror(*tmp___1);
#line 1153
      rrd_set_error((char *)"fdopen failed: %s", tmp___2);
#line 1154
      close(fd);
      }
#line 1155
      return (-1);
    }
  }
  {
#line 1158
  tmp___4 = atoi((char const   *)((rrd->stat_head)->version));
  }
#line 1158
  if (tmp___4 < 3) {
    {
#line 1160
    strcpy((char */* __restrict  */)((rrd->stat_head)->version), (char const   */* __restrict  */)"0003");
    }
  }
  {
#line 1162
  fwrite((void const   */* __restrict  */)rrd->stat_head, sizeof(stat_head_t ), (size_t )1,
         (FILE */* __restrict  */)fh);
#line 1163
  fwrite((void const   */* __restrict  */)rrd->ds_def, sizeof(ds_def_t ), (rrd->stat_head)->ds_cnt,
         (FILE */* __restrict  */)fh);
#line 1164
  fwrite((void const   */* __restrict  */)rrd->rra_def, sizeof(rra_def_t ), (rrd->stat_head)->rra_cnt,
         (FILE */* __restrict  */)fh);
#line 1165
  fwrite((void const   */* __restrict  */)rrd->live_head, sizeof(live_head_t ), (size_t )1,
         (FILE */* __restrict  */)fh);
#line 1166
  fwrite((void const   */* __restrict  */)rrd->pdp_prep, sizeof(pdp_prep_t ), (rrd->stat_head)->ds_cnt,
         (FILE */* __restrict  */)fh);
#line 1167
  fwrite((void const   */* __restrict  */)rrd->cdp_prep, sizeof(cdp_prep_t ), (rrd->stat_head)->rra_cnt * (rrd->stat_head)->ds_cnt,
         (FILE */* __restrict  */)fh);
#line 1169
  fwrite((void const   */* __restrict  */)rrd->rra_ptr, sizeof(rra_ptr_t ), (rrd->stat_head)->rra_cnt,
         (FILE */* __restrict  */)fh);
#line 1172
  rra_offset = 0U;
#line 1173
  i = 0U;
  }
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! ((unsigned long )i < (rrd->stat_head)->rra_cnt)) {
#line 1173
      goto while_break;
    }
#line 1174
    num_rows = (rrd->rra_def + i)->row_cnt;
#line 1175
    cur_row = (rrd->rra_ptr + i)->cur_row;
#line 1176
    ds_cnt = (rrd->stat_head)->ds_cnt;
#line 1177
    if (num_rows > 0UL) {
      {
#line 1178
      fwrite((void const   */* __restrict  */)(rrd->rrd_value + ((((unsigned long )rra_offset + num_rows) - 1UL) - cur_row) * ds_cnt),
             sizeof(rrd_value_t ), (cur_row + 1UL) * ds_cnt, (FILE */* __restrict  */)fh);
#line 1182
      fwrite((void const   */* __restrict  */)(rrd->rrd_value + (unsigned long )rra_offset * ds_cnt),
             sizeof(rrd_value_t ), ((num_rows - 1UL) - cur_row) * ds_cnt, (FILE */* __restrict  */)fh);
#line 1185
      rra_offset = (unsigned int )((unsigned long )rra_offset + num_rows);
      }
    }
#line 1173
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1190
  tmp___5 = ferror(fh);
  }
#line 1190
  if (tmp___5) {
    {
#line 1191
    rrd_set_error((char *)"a file error occurred while creating \'%s\'", file_name);
#line 1192
    fclose(fh);
    }
#line 1193
    return (-1);
  }
  {
#line 1196
  fclose(fh);
  }
#line 1197
  return (0);
}
}
#line 1212 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
static struct option long_options___2[3]  = {      {"range-check", 0, (int *)0, 'r'}, 
        {"force-overwrite", 0, (int *)0, 'f'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 1200 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_restore.c"
int rrd_restore(int argc , char **argv ) 
{ 
  rrd_t *rrd ;
  char *old_locale ;
  int opt ;
  int option_index ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1207
  optind = 0;
#line 1208
  opterr = 0;
  {
#line 1209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1211
    option_index = 0;
#line 1218
    opt = getopt_long(argc, (char * const  *)argv, "rf", (struct option  const  *)(long_options___2),
                      & option_index);
    }
#line 1220
    if (opt == -1) {
#line 1221
      goto while_break;
    }
    {
#line 1224
    if (opt == 114) {
#line 1224
      goto case_114;
    }
#line 1228
    if (opt == 102) {
#line 1228
      goto case_102;
    }
#line 1232
    goto switch_default;
    case_114: /* CIL Label */ 
#line 1225
    opt_range_check = 1;
#line 1226
    goto switch_break;
    case_102: /* CIL Label */ 
#line 1229
    opt_force_overwrite = 1;
#line 1230
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1233
    rrd_set_error((char *)"usage rrdtool %s [--range-check|-r] [--force-overwrite/-f]  file.xml file.rrd",
                  *(argv + 0));
    }
#line 1236
    return (-1);
#line 1237
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1241
  if (argc - optind != 2) {
    {
#line 1242
    rrd_set_error((char *)"usage rrdtool %s [--range-check/-r] [--force-overwrite/-f] file.xml file.rrd",
                  *(argv + 0));
    }
#line 1244
    return (-1);
  }
  {
#line 1247
  old_locale = setlocale(1, "C");
#line 1249
  rrd = parse_file((char const   *)*(argv + optind));
#line 1251
  setlocale(1, (char const   *)old_locale);
  }
#line 1253
  if ((unsigned long )rrd == (unsigned long )((void *)0)) {
#line 1254
    return (-1);
  }
  {
#line 1256
  tmp = write_file((char const   *)*(argv + (optind + 1)), rrd);
  }
#line 1256
  if (tmp != 0) {
    {
#line 1257
    local_rrd_free(rrd);
    }
#line 1258
    return (-1);
  }
  {
#line 1260
  local_rrd_free(rrd);
  }
#line 1263
  return (0);
}
}
#line 201 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
time_t rrd_first(int argc , char **argv ) ;
#line 261
time_t rrd_first_r(char const   *filename , int const   rraindex ) ;
#line 13 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_first.c"
time_t rrd_first(int argc , char **argv ) 
{ 
  int target_rraindex ;
  char *endptr ;
  struct option long_options___5[2] ;
  int option_index ;
  int opt ;
  long tmp ;
  time_t tmp___0 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 17
  target_rraindex = 0;
#line 19
  long_options___5[0].name = "rraindex";
#line 19
  long_options___5[0].has_arg = 1;
#line 19
  long_options___5[0].flag = (int *)0;
#line 19
  long_options___5[0].val = 129;
#line 19
  long_options___5[1].name = (char const   *)0;
#line 19
  long_options___5[1].has_arg = 0;
#line 19
  long_options___5[1].flag = (int *)0;
#line 19
  long_options___5[1].val = 0;
#line 24
  optind = 0;
#line 25
  opterr = 0;
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 28
    option_index = 0;
#line 31
    opt = getopt_long(argc, (char * const  *)argv, "", (struct option  const  *)(long_options___5),
                      & option_index);
    }
#line 33
    if (opt == -1) {
#line 34
      goto while_break;
    }
    {
#line 37
    if (opt == 129) {
#line 37
      goto case_129;
    }
#line 44
    goto switch_default;
    case_129: /* CIL Label */ 
    {
#line 38
    tmp = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& endptr),
                 0);
#line 38
    target_rraindex = (int )tmp;
    }
#line 39
    if (target_rraindex < 0) {
      {
#line 40
      rrd_set_error((char *)"invalid rraindex number");
      }
#line 41
      return ((time_t )-1);
    }
#line 43
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 45
    rrd_set_error((char *)"usage rrdtool %s [--rraindex number] file.rrd", *(argv + 0));
    }
#line 47
    return ((time_t )-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  if (optind >= argc) {
    {
#line 52
    rrd_set_error((char *)"not enough arguments");
    }
#line 53
    return ((time_t )-1);
  }
  {
#line 56
  tmp___0 = rrd_first_r((char const   *)*(argv + optind), target_rraindex);
  }
#line 56
  return (tmp___0);
}
}
#line 60 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_first.c"
time_t rrd_first_r(char const   *filename , int const   rraindex ) 
{ 
  off_t rra_start ;
  off_t timer ;
  time_t then ;
  rrd_t rrd ;
  rrd_file_t *rrd_file ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 65
  then = (time_t )-1;
#line 69
  rrd_init(& rrd);
#line 70
  rrd_file = rrd_open((char const   */* const  */)filename, & rrd, 1U);
  }
#line 71
  if ((unsigned long )rrd_file == (unsigned long )((void *)0)) {
#line 72
    goto err_free;
  }
#line 75
  if (rraindex < 0) {
    {
#line 76
    rrd_set_error((char *)"invalid rraindex number");
    }
#line 77
    goto err_close;
  } else
#line 75
  if (rraindex >= (int const   )((int )(rrd.stat_head)->rra_cnt)) {
    {
#line 76
    rrd_set_error((char *)"invalid rraindex number");
    }
#line 77
    goto err_close;
  }
  {
#line 80
  rra_start = (off_t )rrd_file->header_len;
#line 81
  rrd_seek(rrd_file, (off_t )((unsigned long )rra_start + (((rrd.rra_ptr + rraindex)->cur_row + 1UL) * (rrd.stat_head)->ds_cnt) * sizeof(rrd_value_t )),
           0);
#line 85
  timer = - ((long )((rrd.rra_def + rraindex)->row_cnt - 1UL));
  }
#line 86
  if ((rrd.rra_ptr + rraindex)->cur_row + 1UL > (rrd.rra_def + rraindex)->row_cnt) {
    {
#line 87
    rrd_seek(rrd_file, rra_start, 0);
    }
  }
#line 89
  then = (time_t )(((unsigned long )(rrd.live_head)->last_up - (unsigned long )(rrd.live_head)->last_up % ((rrd.rra_def + rraindex)->pdp_cnt * (rrd.stat_head)->pdp_step)) + ((unsigned long )timer * (rrd.rra_def + rraindex)->pdp_cnt) * (rrd.stat_head)->pdp_step);
  err_close: 
  {
#line 94
  rrd_close(rrd_file);
  }
  err_free: 
  {
#line 96
  rrd_free(& rrd);
  }
#line 97
  return (then);
}
}
#line 200 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
int rrd_lastupdate(int argc , char **argv ) ;
#line 256
int rrd_lastupdate_r(char const   *filename , time_t *ret_last_update , unsigned long *ret_ds_count ,
                     char ***ret_ds_names , char ***ret_last_ds ) ;
#line 29 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_lastupdate.c"
static struct option long_options___3[2]  = {      {"daemon", 1, (int *)0, 'd'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 13 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_lastupdate.c"
int rrd_lastupdate(int argc , char **argv ) 
{ 
  time_t last_update ;
  char **ds_names ;
  char **last_ds ;
  unsigned long ds_count ;
  unsigned long i ;
  int status ;
  char *opt_daemon ;
  int opt ;
  int option_index ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 21
  opt_daemon = (char *)((void *)0);
#line 23
  optind = 0;
#line 24
  opterr = 0;
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 28
    option_index = 0;
#line 34
    opt = getopt_long(argc, (char * const  *)argv, "d:", (struct option  const  *)(long_options___3),
                      & option_index);
    }
#line 36
    if (opt == -1) {
#line 37
      goto while_break;
    }
    {
#line 40
    if (opt == 100) {
#line 40
      goto case_100;
    }
#line 51
    goto switch_default;
    case_100: /* CIL Label */ 
#line 41
    if ((unsigned long )opt_daemon != (unsigned long )((void *)0)) {
      {
#line 42
      free((void *)opt_daemon);
      }
    }
    {
#line 43
    opt_daemon = strdup((char const   *)optarg);
    }
#line 44
    if ((unsigned long )opt_daemon == (unsigned long )((void *)0)) {
      {
#line 46
      rrd_set_error((char *)"strdup failed.");
      }
#line 47
      return (-1);
    }
#line 49
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 52
    rrd_set_error((char *)"Usage: rrdtool %s [--daemon <addr>] <file>", *(argv + 0));
    }
#line 54
    return (-1);
#line 55
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  if (argc - optind != 1) {
    {
#line 60
    rrd_set_error((char *)"Usage: rrdtool %s [--daemon <addr>] <file>", *(argv + 0));
    }
#line 62
    return (-1);
  }
  {
#line 65
  status = rrdc_flush_if_daemon((char const   *)opt_daemon, (char const   *)*(argv + optind));
  }
#line 66
  if (opt_daemon) {
    {
#line 66
    free((void *)opt_daemon);
    }
  }
#line 67
  if (status) {
#line 67
    return (-1);
  }
  {
#line 69
  status = rrd_lastupdate_r((char const   *)*(argv + optind), & last_update, & ds_count,
                            & ds_names, & last_ds);
  }
#line 71
  if (status != 0) {
#line 72
    return (status);
  }
#line 74
  i = 0UL;
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (! (i < ds_count)) {
#line 74
      goto while_break___0;
    }
    {
#line 75
    printf((char const   */* __restrict  */)" %s", *(ds_names + i));
#line 74
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 76
  printf((char const   */* __restrict  */)"\n\n");
#line 78
  printf((char const   */* __restrict  */)"%10lu:", last_update);
#line 79
  i = 0UL;
  }
  {
#line 79
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 79
    if (! (i < ds_count)) {
#line 79
      goto while_break___1;
    }
    {
#line 80
    printf((char const   */* __restrict  */)" %s", *(last_ds + i));
#line 81
    free((void *)*(last_ds + i));
#line 82
    free((void *)*(ds_names + i));
#line 79
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 84
  printf((char const   */* __restrict  */)"\n");
#line 86
  free((void *)last_ds);
#line 87
  free((void *)ds_names);
  }
#line 89
  return (0);
}
}
#line 92 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_lastupdate.c"
int rrd_lastupdate_r(char const   *filename , time_t *ret_last_update , unsigned long *ret_ds_count ,
                     char ***ret_ds_names , char ***ret_last_ds ) 
{ 
  unsigned long i ;
  rrd_t rrd ;
  rrd_file_t *rrd_file ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 98
  i = 0UL;
#line 102
  rrd_init(& rrd);
#line 103
  rrd_file = rrd_open((char const   */* const  */)filename, & rrd, 1U);
  }
#line 104
  if ((unsigned long )rrd_file == (unsigned long )((void *)0)) {
    {
#line 105
    rrd_free(& rrd);
    }
#line 106
    return (-1);
  }
  {
#line 109
  *ret_last_update = (rrd.live_head)->last_up;
#line 110
  *ret_ds_count = (rrd.stat_head)->ds_cnt;
#line 111
  tmp = malloc((rrd.stat_head)->ds_cnt * sizeof(char *));
#line 111
  *ret_ds_names = (char **)tmp;
  }
#line 112
  if ((unsigned long )*ret_ds_names == (unsigned long )((void *)0)) {
    {
#line 113
    rrd_set_error((char *)"malloc fetch ret_ds_names array");
#line 114
    rrd_close(rrd_file);
#line 115
    rrd_free(& rrd);
    }
#line 116
    return (-1);
  }
  {
#line 118
  memset((void *)*ret_ds_names, 0, (rrd.stat_head)->ds_cnt * sizeof(char *));
#line 120
  tmp___0 = malloc((rrd.stat_head)->ds_cnt * sizeof(char *));
#line 120
  *ret_last_ds = (char **)tmp___0;
  }
#line 121
  if ((unsigned long )*ret_last_ds == (unsigned long )((void *)0)) {
    {
#line 122
    rrd_set_error((char *)"malloc fetch ret_last_ds array");
#line 123
    free((void *)*ret_ds_names);
#line 124
    *ret_ds_names = (char **)((void *)0);
#line 125
    rrd_close(rrd_file);
#line 126
    rrd_free(& rrd);
    }
#line 127
    return (-1);
  }
  {
#line 129
  memset((void *)*ret_last_ds, 0, (rrd.stat_head)->ds_cnt * sizeof(char *));
#line 131
  i = 0UL;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < (rrd.stat_head)->ds_cnt)) {
#line 131
      goto while_break;
    }
    {
#line 132
    *(*ret_ds_names + i) = sprintf_alloc((char *)"%s", (rrd.ds_def + i)->ds_nam);
#line 133
    *(*ret_last_ds + i) = sprintf_alloc((char *)"%s", (rrd.pdp_prep + i)->last_ds);
    }
#line 135
    if ((unsigned long )*(*ret_ds_names + i) == (unsigned long )((void *)0)) {
#line 136
      goto while_break;
    } else
#line 135
    if ((unsigned long )*(*ret_last_ds + i) == (unsigned long )((void *)0)) {
#line 136
      goto while_break;
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  if (i < (rrd.stat_head)->ds_cnt) {
    {
#line 142
    rrd_set_error((char *)"sprintf_alloc failed");
#line 143
    i = 0UL;
    }
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 143
      if (! (i < (rrd.stat_head)->ds_cnt)) {
#line 143
        goto while_break___0;
      }
#line 144
      if ((unsigned long )*(*ret_ds_names + i) != (unsigned long )((void *)0)) {
        {
#line 146
        free((void *)*(*ret_ds_names + i));
#line 147
        *(*ret_ds_names + i) = (char *)((void *)0);
        }
      }
#line 149
      if ((unsigned long )*(*ret_last_ds + i) != (unsigned long )((void *)0)) {
        {
#line 151
        free((void *)*(*ret_last_ds + i));
#line 152
        *(*ret_last_ds + i) = (char *)((void *)0);
        }
      }
#line 143
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 155
    free((void *)*ret_ds_names);
#line 156
    *ret_ds_names = (char **)((void *)0);
#line 157
    free((void *)*ret_last_ds);
#line 158
    *ret_last_ds = (char **)((void *)0);
#line 159
    rrd_close(rrd_file);
#line 160
    rrd_free(& rrd);
    }
#line 161
    return (-1);
  }
  {
#line 164
  rrd_free(& rrd);
#line 165
  rrd_close(rrd_file);
  }
#line 166
  return (0);
}
}
#line 197 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
time_t rrd_last(int argc , char **argv ) ;
#line 255
time_t rrd_last_r(char const   *filename ) ;
#line 25 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_last.c"
static struct option long_options___4[2]  = {      {"daemon", 1, (int *)0, 'd'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 12 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_last.c"
time_t rrd_last(int argc , char **argv ) 
{ 
  char *opt_daemon ;
  int status ;
  int opt ;
  int option_index ;
  time_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 16
  opt_daemon = (char *)((void *)0);
#line 19
  optind = 0;
#line 20
  opterr = 0;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 24
    option_index = 0;
#line 30
    opt = getopt_long(argc, (char * const  *)argv, "d:", (struct option  const  *)(long_options___4),
                      & option_index);
    }
#line 32
    if (opt == -1) {
#line 33
      goto while_break;
    }
    {
#line 36
    if (opt == 100) {
#line 36
      goto case_100;
    }
#line 47
    goto switch_default;
    case_100: /* CIL Label */ 
#line 37
    if ((unsigned long )opt_daemon != (unsigned long )((void *)0)) {
      {
#line 38
      free((void *)opt_daemon);
      }
    }
    {
#line 39
    opt_daemon = strdup((char const   *)optarg);
    }
#line 40
    if ((unsigned long )opt_daemon == (unsigned long )((void *)0)) {
      {
#line 42
      rrd_set_error((char *)"strdup failed.");
      }
#line 43
      return ((time_t )-1);
    }
#line 45
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 48
    rrd_set_error((char *)"Usage: rrdtool %s [--daemon <addr>] <file>", *(argv + 0));
    }
#line 50
    return ((time_t )-1);
#line 51
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (argc - optind != 1) {
    {
#line 56
    rrd_set_error((char *)"Usage: rrdtool %s [--daemon <addr>] <file>", *(argv + 0));
    }
#line 58
    return ((time_t )-1);
  }
  {
#line 61
  status = rrdc_flush_if_daemon((char const   *)opt_daemon, (char const   *)*(argv + optind));
  }
#line 62
  if (opt_daemon) {
    {
#line 62
    free((void *)opt_daemon);
    }
  }
#line 63
  if (status) {
#line 63
    return ((time_t )-1);
  }
  {
#line 65
  tmp = rrd_last_r((char const   *)*(argv + optind));
  }
#line 65
  return (tmp);
}
}
#line 68 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_last.c"
time_t rrd_last_r(char const   *filename ) 
{ 
  time_t lastup ;
  rrd_file_t *rrd_file ;
  rrd_t rrd ;

  {
  {
#line 71
  lastup = (time_t )-1;
#line 76
  rrd_init(& rrd);
#line 77
  rrd_file = rrd_open((char const   */* const  */)filename, & rrd, 1U);
  }
#line 78
  if ((unsigned long )rrd_file != (unsigned long )((void *)0)) {
    {
#line 79
    lastup = (rrd.live_head)->last_up;
#line 80
    rrd_close(rrd_file);
    }
  }
  {
#line 82
  rrd_free(& rrd);
  }
#line 83
  return (lastup);
}
}
#line 207 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd.h"
char *rrd_strversion(void) ;
#line 209
double rrd_version(void) ;
#line 11 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_version.c"
double rrd_version(void) 
{ 


  {
#line 14
  return (1.4008);
}
}
#line 17 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_version.c"
char *rrd_strversion(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 20
  return ((char *)"1.4.8");
}
}
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrusage)(__rusage_who_t __who ,
                                                                                struct rusage *__usage ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 695
extern int puts(char const   *__s ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 26 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.c"
void PrintUsage(char *cmd ) ;
#line 28
int CountArgs(char *aLine ) ;
#line 30
int CreateArgs(char *pName , char *aLine , char **argv ) ;
#line 34
int HandleInputLine(int argc , char **argv , FILE *out ) ;
#line 38 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.c"
int RemoteMode  =    0;
#line 39 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.c"
int ChangeRoot  =    0;
#line 46 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.c"
void PrintUsage(char *cmd ) 
{ 
  char const   *help_main ;
  char const   *help_list ;
  char const   *help_listremote ;
  char const   *help_create ;
  char const   *help_dump ;
  char const   *help_info ;
  char const   *help_restore ;
  char const   *help_last ;
  char const   *help_lastupdate ;
  char const   *help_first ;
  char const   *help_update ;
  char const   *help_updatev ;
  char const   *help_fetch ;
  char const   *help_flushcached ;
  char const   *help_graph0 ;
  char const   *help_graphv0 ;
  char const   *help_graph1 ;
  char const   *help_graph2 ;
  char const   *help_graph3 ;
  char const   *help_tune1 ;
  char const   *help_tune2 ;
  char const   *help_resize ;
  char const   *help_xport ;
  char const   *help_quit ;
  char const   *help_ls ;
  char const   *help_cd ;
  char const   *help_mkdir ;
  char const   *help_pwd ;
  char const   *help_lic ;
  int help_cmd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;

  {
#line 50
  help_main = "RRDtool %s  Copyright 1997-2013 by Tobias Oetiker <tobi@oetiker.ch>\n               Compiled %s %s\n\nUsage: rrdtool [options] command command_options\n";
#line 56
  help_list = "Valid commands: create, update, updatev, graph, graphv,  dump, restore,\n\t\tlast, lastupdate, first, info, fetch, tune,\n\t\tresize, xport, flushcached\n";
#line 62
  help_listremote = "Valid remote commands: quit, ls, cd, mkdir, pwd\n";
#line 66
  help_create = "* create - create a new RRD\n\n\trrdtool create filename [--start|-b start time]\n\t\t[--step|-s step]\n\t\t[--no-overwrite|-O]\n\t\t[DS:ds-name:DST:dst arguments]\n\t\t[RRA:CF:cf arguments]\n";
#line 74
  help_dump = "* dump - dump an RRD to XML\n\n\trrdtool dump filename.rrd >filename.xml\n";
#line 78
  help_info = "* info - returns the configuration and status of the RRD\n\n\trrdtool info filename.rrd\n";
#line 82
  help_restore = "* restore - restore an RRD file from its XML form\n\n\trrdtool restore [--range-check|-r] [--force-overwrite|-f] filename.xml filename.rrd\n";
#line 86
  help_last = "* last - show last update time for RRD\n\n\trrdtool last filename.rrd\n";
#line 90
  help_lastupdate = "* lastupdate - returns the most recent datum stored for\n  each DS in an RRD\n\n\trrdtool lastupdate filename.rrd\n";
#line 94
  help_first = "* first - show first update time for RRA within an RRD\n\n\trrdtool first filename.rrd [--rraindex number]\n";
#line 98
  help_update = "* update - update an RRD\n\n\trrdtool update filename\n\t\t[--template|-t ds-name:ds-name:...]\n\t\t[--daemon <address>]\n\t\ttime|N:value[:value...]\n\n\t\tat-time@value[:value...]\n\n\t\t[ time:value[:value...] ..]\n";
#line 107
  help_updatev = "* updatev - a verbose version of update\n\treturns information about values, RRAs, and datasources updated\n\n\trrdtool updatev filename\n\t\t[--template|-t ds-name:ds-name:...]\n\t\ttime|N:value[:value...]\n\n\t\tat-time@value[:value...]\n\n\t\t[ time:value[:value...] ..]\n";
#line 116
  help_fetch = "* fetch - fetch data out of an RRD\n\n\trrdtool fetch filename.rrd CF\n\t\t[-r|--resolution resolution]\n\t\t[-s|--start start] [-e|--end end]\n\t\t[--daemon <address>]\n";
#line 123
  help_flushcached = "* flushcached - flush cached data out to an RRD file\n\n\trrdtool flushcached filename.rrd\n\t\t[--daemon <address>]\n";
#line 130
  help_graph0 = "* graph - generate a graph from one or several RRD\n\n\trrdtool graph filename [-s|--start seconds] [-e|--end seconds]\n";
#line 133
  help_graphv0 = "* graphv - generate a graph from one or several RRD\n           with meta data printed before the graph\n\n\trrdtool graphv filename [-s|--start seconds] [-e|--end seconds]\n";
#line 137
  help_graph1 = "\t\t[-x|--x-grid x-axis grid and label]\n\t\t[-Y|--alt-y-grid] [--full-size-mode]\n\t\t[-y|--y-grid y-axis grid and label]\n\t\t[-v|--vertical-label string] [-w|--width pixels]\n\t\t[--right-axis scale:shift] [--right-axis-label label]\n\t\t[--right-axis-format format]\n\t\t[-h|--height pixels] [-o|--logarithmic]\n\t\t[-u|--upper-limit value] [-z|--lazy]\n\t\t[-l|--lower-limit value] [-r|--rigid]\n\t\t[-g|--no-legend] [--daemon <address>]\n\t\t[-F|--force-rules-legend]\n\t\t[-j|--only-graph]\n";
#line 149
  help_graph2 = "\t\t[-n|--font FONTTAG:size:font]\n\t\t[-m|--zoom factor]\n\t\t[-A|--alt-autoscale]\n\t\t[-M|--alt-autoscale-max]\n\t\t[-G|--graph-render-mode {normal,mono}]\n\t\t[-R|--font-render-mode {normal,light,mono}]\n\t\t[-B|--font-smoothing-threshold size]\n\t\t[-T|--tabwidth width]\n\t\t[-E|--slope-mode]\n\t\t[-P|--pango-markup]\n\t\t[-N|--no-gridfit]\n\t\t[-X|--units-exponent value]\n\t\t[-L|--units-length value]\n\t\t[-S|--step seconds]\n\t\t[-f|--imginfo printfstr]\n\t\t[-a|--imgformat PNG]\n\t\t[-c|--color COLORTAG#rrggbb[aa]]\n\t\t[--border width\n\t\t[-t|--title string]\n\t\t[-W|--watermark string]\n\t\t[DEF:vname=rrd:ds-name:CF]\n";
#line 171
  help_graph3 = "\t\t[CDEF:vname=rpn-expression]\n\t\t[VDEF:vdefname=rpn-expression]\n\t\t[PRINT:vdefname:format]\n\t\t[GPRINT:vdefname:format]\n\t\t[COMMENT:text]\n\t\t[SHIFT:vname:offset]\n\t\t[TEXTALIGN:{left|right|justified|center}]\n\t\t[TICK:vname#rrggbb[aa][:[fraction][:legend]]]\n\t\t[HRULE:value#rrggbb[aa][:legend]]\n\t\t[VRULE:value#rrggbb[aa][:legend]]\n\t\t[LINE[width]:vname[#rrggbb[aa][:[legend][:STACK]]]]\n\t\t[AREA:vname[#rrggbb[aa][:[legend][:STACK]]]]\n\t\t[PRINT:vname:CF:format] (deprecated)\n\t\t[GPRINT:vname:CF:format] (deprecated)\n\t\t[STACK:vname[#rrggbb[aa][:legend]]] (deprecated)\n";
#line 186
  help_tune1 = " * tune -  Modify some basic properties of an RRD\n\n\trrdtool tune filename\n\t\t[--heartbeat|-h ds-name:heartbeat]\n\t\t[--data-source-type|-d ds-name:DST]\n\t\t[--data-source-rename|-r old-name:new-name]\n\t\t[--minimum|-i ds-name:min] [--maximum|-a ds-name:max]\n\t\t[--deltapos scale-value] [--deltaneg scale-value]\n\t\t[--failure-threshold integer]\n\t\t[--window-length integer]\n\t\t[--alpha adaptation-parameter]\n";
#line 197
  help_tune2 = "\t\t[--beta adaptation-parameter]\n\t\t[--gamma adaptation-parameter]\n\t\t[--gamma-deviation adaptation-parameter]\n\t\t[--aberrant-reset ds-name]\n";
#line 202
  help_resize = " * resize - alter the length of one of the RRAs in an RRD\n\n\trrdtool resize filename rranum GROW|SHRINK rows\n";
#line 206
  help_xport = "* xport - generate XML dump from one or several RRD\n\n\trrdtool xport [-s|--start seconds] [-e|--end seconds]\n\t\t[-m|--maxrows rows]\n\t\t[--step seconds]\n\t\t[--enumds] [--json]\n\t\t[DEF:vname=rrd:ds-name:CF]\n\t\t[CDEF:vname=rpn-expression]\n\t\t[XPORT:vname:legend]\n";
#line 213
  help_quit = " * quit - closing a session in remote mode\n\n\trrdtool quit\n";
#line 216
  help_ls = " * ls - lists all *.rrd files in current directory\n\n\trrdtool ls\n";
#line 219
  help_cd = " * cd - changes the current directory\n\n\trrdtool cd new directory\n";
#line 222
  help_mkdir = " * mkdir - creates a new directory\n\n\trrdtool mkdir newdirectoryname\n";
#line 225
  help_pwd = " * pwd - returns the current working directory\n\n\trrdtool pwd\n";
#line 228
  help_lic = "RRDtool is distributed under the Terms of the GNU General\nPublic License Version 2. (www.gnu.org/copyleft/gpl.html)\n\nFor more information read the RRD manpages\n";
#line 238
  help_cmd = 0;
#line 240
  if (cmd) {
    {
#line 241
    tmp___19 = strcmp((char const   *)cmd, "create");
    }
#line 241
    if (tmp___19) {
      {
#line 243
      tmp___18 = strcmp((char const   *)cmd, "dump");
      }
#line 243
      if (tmp___18) {
        {
#line 245
        tmp___17 = strcmp((char const   *)cmd, "info");
        }
#line 245
        if (tmp___17) {
          {
#line 247
          tmp___16 = strcmp((char const   *)cmd, "restore");
          }
#line 247
          if (tmp___16) {
            {
#line 249
            tmp___15 = strcmp((char const   *)cmd, "last");
            }
#line 249
            if (tmp___15) {
              {
#line 251
              tmp___14 = strcmp((char const   *)cmd, "lastupdate");
              }
#line 251
              if (tmp___14) {
                {
#line 253
                tmp___13 = strcmp((char const   *)cmd, "first");
                }
#line 253
                if (tmp___13) {
                  {
#line 255
                  tmp___12 = strcmp((char const   *)cmd, "update");
                  }
#line 255
                  if (tmp___12) {
                    {
#line 257
                    tmp___11 = strcmp((char const   *)cmd, "updatev");
                    }
#line 257
                    if (tmp___11) {
                      {
#line 259
                      tmp___10 = strcmp((char const   *)cmd, "fetch");
                      }
#line 259
                      if (tmp___10) {
                        {
#line 261
                        tmp___9 = strcmp((char const   *)cmd, "flushcached");
                        }
#line 261
                        if (tmp___9) {
                          {
#line 263
                          tmp___8 = strcmp((char const   *)cmd, "graph");
                          }
#line 263
                          if (tmp___8) {
                            {
#line 265
                            tmp___7 = strcmp((char const   *)cmd, "graphv");
                            }
#line 265
                            if (tmp___7) {
                              {
#line 267
                              tmp___6 = strcmp((char const   *)cmd, "tune");
                              }
#line 267
                              if (tmp___6) {
                                {
#line 269
                                tmp___5 = strcmp((char const   *)cmd, "resize");
                                }
#line 269
                                if (tmp___5) {
                                  {
#line 271
                                  tmp___4 = strcmp((char const   *)cmd, "xport");
                                  }
#line 271
                                  if (tmp___4) {
                                    {
#line 273
                                    tmp___3 = strcmp((char const   *)cmd, "quit");
                                    }
#line 273
                                    if (tmp___3) {
                                      {
#line 275
                                      tmp___2 = strcmp((char const   *)cmd, "ls");
                                      }
#line 275
                                      if (tmp___2) {
                                        {
#line 277
                                        tmp___1 = strcmp((char const   *)cmd, "cd");
                                        }
#line 277
                                        if (tmp___1) {
                                          {
#line 279
                                          tmp___0 = strcmp((char const   *)cmd, "mkdir");
                                          }
#line 279
                                          if (tmp___0) {
                                            {
#line 281
                                            tmp = strcmp((char const   *)cmd, "pwd");
                                            }
#line 281
                                            if (! tmp) {
#line 282
                                              help_cmd = 19;
                                            }
                                          } else {
#line 280
                                            help_cmd = 18;
                                          }
                                        } else {
#line 278
                                          help_cmd = 17;
                                        }
                                      } else {
#line 276
                                        help_cmd = 16;
                                      }
                                    } else {
#line 274
                                      help_cmd = 15;
                                    }
                                  } else {
#line 272
                                    help_cmd = 14;
                                  }
                                } else {
#line 270
                                  help_cmd = 13;
                                }
                              } else {
#line 268
                                help_cmd = 12;
                              }
                            } else {
#line 266
                              help_cmd = 11;
                            }
                          } else {
#line 264
                            help_cmd = 10;
                          }
                        } else {
#line 262
                          help_cmd = 21;
                        }
                      } else {
#line 260
                        help_cmd = 9;
                      }
                    } else {
#line 258
                      help_cmd = 20;
                    }
                  } else {
#line 256
                    help_cmd = 8;
                  }
                } else {
#line 254
                  help_cmd = 7;
                }
              } else {
#line 252
                help_cmd = 6;
              }
            } else {
#line 250
              help_cmd = 5;
            }
          } else {
#line 248
            help_cmd = 4;
          }
        } else {
#line 246
          help_cmd = 3;
        }
      } else {
#line 244
        help_cmd = 2;
      }
    } else {
#line 242
      help_cmd = 1;
    }
  }
  {
#line 284
  tmp___20 = gettext(help_main);
#line 284
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)tmp___20,
          "1.4.8", "Jul  9 2015", "12:06:22");
#line 285
  fflush(stdout);
  }
  {
#line 287
  if (help_cmd == 0) {
#line 287
    goto case_0;
  }
#line 293
  if (help_cmd == 1) {
#line 293
    goto case_1;
  }
#line 296
  if (help_cmd == 2) {
#line 296
    goto case_2;
  }
#line 299
  if (help_cmd == 3) {
#line 299
    goto case_3;
  }
#line 302
  if (help_cmd == 4) {
#line 302
    goto case_4;
  }
#line 305
  if (help_cmd == 5) {
#line 305
    goto case_5;
  }
#line 308
  if (help_cmd == 6) {
#line 308
    goto case_6;
  }
#line 311
  if (help_cmd == 7) {
#line 311
    goto case_7;
  }
#line 314
  if (help_cmd == 8) {
#line 314
    goto case_8;
  }
#line 317
  if (help_cmd == 20) {
#line 317
    goto case_20;
  }
#line 320
  if (help_cmd == 9) {
#line 320
    goto case_9;
  }
#line 323
  if (help_cmd == 21) {
#line 323
    goto case_21;
  }
#line 326
  if (help_cmd == 10) {
#line 326
    goto case_10;
  }
#line 332
  if (help_cmd == 11) {
#line 332
    goto case_11;
  }
#line 338
  if (help_cmd == 12) {
#line 338
    goto case_12;
  }
#line 342
  if (help_cmd == 13) {
#line 342
    goto case_13;
  }
#line 345
  if (help_cmd == 14) {
#line 345
    goto case_14;
  }
#line 348
  if (help_cmd == 15) {
#line 348
    goto case_15;
  }
#line 351
  if (help_cmd == 16) {
#line 351
    goto case_16;
  }
#line 354
  if (help_cmd == 17) {
#line 354
    goto case_17;
  }
#line 357
  if (help_cmd == 18) {
#line 357
    goto case_18;
  }
#line 360
  if (help_cmd == 19) {
#line 360
    goto case_19;
  }
#line 286
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 288
  tmp___21 = gettext(help_list);
#line 288
  puts((char const   *)tmp___21);
  }
#line 289
  if (RemoteMode) {
    {
#line 290
    tmp___22 = gettext(help_listremote);
#line 290
    puts((char const   *)tmp___22);
    }
  }
#line 292
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 294
  tmp___23 = gettext(help_create);
#line 294
  puts((char const   *)tmp___23);
  }
#line 295
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 297
  tmp___24 = gettext(help_dump);
#line 297
  puts((char const   *)tmp___24);
  }
#line 298
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 300
  tmp___25 = gettext(help_info);
#line 300
  puts((char const   *)tmp___25);
  }
#line 301
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 303
  tmp___26 = gettext(help_restore);
#line 303
  puts((char const   *)tmp___26);
  }
#line 304
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 306
  tmp___27 = gettext(help_last);
#line 306
  puts((char const   *)tmp___27);
  }
#line 307
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 309
  tmp___28 = gettext(help_lastupdate);
#line 309
  puts((char const   *)tmp___28);
  }
#line 310
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 312
  tmp___29 = gettext(help_first);
#line 312
  puts((char const   *)tmp___29);
  }
#line 313
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 315
  tmp___30 = gettext(help_update);
#line 315
  puts((char const   *)tmp___30);
  }
#line 316
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 318
  tmp___31 = gettext(help_updatev);
#line 318
  puts((char const   *)tmp___31);
  }
#line 319
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 321
  tmp___32 = gettext(help_fetch);
#line 321
  puts((char const   *)tmp___32);
  }
#line 322
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 324
  tmp___33 = gettext(help_flushcached);
#line 324
  puts((char const   *)tmp___33);
  }
#line 325
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 327
  tmp___34 = gettext(help_graph0);
#line 327
  puts((char const   *)tmp___34);
#line 328
  tmp___35 = gettext(help_graph1);
#line 328
  puts((char const   *)tmp___35);
#line 329
  tmp___36 = gettext(help_graph2);
#line 329
  puts((char const   *)tmp___36);
#line 330
  tmp___37 = gettext(help_graph3);
#line 330
  puts((char const   *)tmp___37);
  }
#line 331
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 333
  tmp___38 = gettext(help_graphv0);
#line 333
  puts((char const   *)tmp___38);
#line 334
  tmp___39 = gettext(help_graph1);
#line 334
  puts((char const   *)tmp___39);
#line 335
  tmp___40 = gettext(help_graph2);
#line 335
  puts((char const   *)tmp___40);
#line 336
  tmp___41 = gettext(help_graph3);
#line 336
  puts((char const   *)tmp___41);
  }
#line 337
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 339
  tmp___42 = gettext(help_tune1);
#line 339
  puts((char const   *)tmp___42);
#line 340
  tmp___43 = gettext(help_tune2);
#line 340
  puts((char const   *)tmp___43);
  }
#line 341
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 343
  tmp___44 = gettext(help_resize);
#line 343
  puts((char const   *)tmp___44);
  }
#line 344
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 346
  tmp___45 = gettext(help_xport);
#line 346
  puts((char const   *)tmp___45);
  }
#line 347
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 349
  tmp___46 = gettext(help_quit);
#line 349
  puts((char const   *)tmp___46);
  }
#line 350
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 352
  tmp___47 = gettext(help_ls);
#line 352
  puts((char const   *)tmp___47);
  }
#line 353
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 355
  tmp___48 = gettext(help_cd);
#line 355
  puts((char const   *)tmp___48);
  }
#line 356
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 358
  tmp___49 = gettext(help_mkdir);
#line 358
  puts((char const   *)tmp___49);
  }
#line 359
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 361
  tmp___50 = gettext(help_pwd);
#line 361
  puts((char const   *)tmp___50);
  }
#line 362
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 364
  tmp___51 = gettext(help_lic);
#line 364
  puts((char const   *)tmp___51);
  }
#line 365
  return;
}
}
#line 367 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.c"
static char *fgetslong(char **aLinePtr , FILE *stream ) 
{ 
  char *linebuf ;
  size_t bufsize ;
  int eolpos ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 372
  bufsize = (size_t )10000;
#line 373
  eolpos = 0;
#line 375
  tmp___0 = feof(stream);
  }
#line 375
  if (tmp___0) {
#line 376
    tmp = (char *)0;
#line 376
    *aLinePtr = tmp;
#line 376
    return (tmp);
  }
  {
#line 377
  tmp___1 = malloc(bufsize);
#line 377
  linebuf = (char *)tmp___1;
  }
#line 377
  if (! linebuf) {
    {
#line 378
    perror("fgetslong: malloc");
#line 379
    exit(1);
    }
  }
#line 381
  *(linebuf + 0) = (char )'\000';
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 382
    tmp___5 = fgets((char */* __restrict  */)(linebuf + eolpos), 10000, (FILE */* __restrict  */)stream);
    }
#line 382
    if (! tmp___5) {
#line 382
      goto while_break;
    }
    {
#line 383
    tmp___2 = strlen((char const   *)(linebuf + eolpos));
#line 383
    eolpos = (int )((size_t )eolpos + tmp___2);
    }
#line 384
    if ((int )*(linebuf + (eolpos - 1)) == 10) {
#line 385
      tmp___3 = linebuf;
#line 385
      *aLinePtr = tmp___3;
#line 385
      return (tmp___3);
    }
    {
#line 386
    bufsize += 10000UL;
#line 387
    tmp___4 = realloc((void *)linebuf, bufsize);
#line 387
    linebuf = (char *)tmp___4;
    }
#line 387
    if (! linebuf) {
      {
#line 388
      free((void *)linebuf);
#line 389
      perror("fgetslong: realloc");
#line 390
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (*(linebuf + 0)) {
#line 394
    tmp___6 = linebuf;
#line 394
    *aLinePtr = tmp___6;
#line 394
    return (tmp___6);
  }
  {
#line 396
  free((void *)linebuf);
#line 397
  tmp___7 = (char *)0;
#line 397
  *aLinePtr = tmp___7;
  }
#line 397
  return (tmp___7);
}
}
#line 400 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.c"
int main(int argc , char **argv ) 
{ 
  char **myargv ;
  char *aLine ;
  char *firstdir ;
  struct rusage myusage ;
  struct timeval starttime ;
  struct timeval currenttime ;
  int *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  __uid_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *aLineOrig ;
  void *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 406
  firstdir = (char *)"";
#line 417
  setlocale(6, "");
  }
#line 429
  if (argc == 1) {
    {
#line 430
    PrintUsage((char *)"");
    }
#line 431
    return (0);
  }
#line 434
  if (argc == 2) {
#line 434
    goto _L___0;
  } else
#line 434
  if (argc == 3) {
    _L___0: /* CIL Label */ 
    {
#line 434
    tmp___15 = strcmp("-", (char const   *)*(argv + 1));
    }
#line 434
    if (tmp___15) {
#line 434
      goto _L;
    } else {
      {
#line 440
      gettimeofday((struct timeval */* __restrict  */)(& starttime), (__timezone_ptr_t )((void *)0));
#line 442
      RemoteMode = 1;
      }
#line 443
      if (argc == 3) {
        {
#line 443
        tmp___4 = strcmp("", (char const   *)*(argv + 2));
        }
#line 443
        if (tmp___4) {
          {
#line 445
          tmp___3 = getuid();
          }
#line 445
          if (tmp___3 == 0U) {
            {
#line 454
            tmp___2 = chroot((char const   *)*(argv + 2));
            }
#line 454
            if (tmp___2 != 0) {
              {
#line 455
              tmp = __errno_location();
#line 455
              tmp___0 = rrd_strerror(*tmp);
#line 455
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: chroot %s: %s\n",
                      *(argv + 2), tmp___0);
#line 456
              tmp___1 = __errno_location();
#line 456
              exit(*tmp___1);
              }
            }
#line 458
            ChangeRoot = 1;
#line 459
            firstdir = (char *)"/";
          } else {
#line 467
            firstdir = *(argv + 2);
          }
        }
      }
      {
#line 470
      tmp___9 = strcmp((char const   *)firstdir, "");
      }
#line 470
      if (tmp___9) {
        {
#line 471
        tmp___8 = chdir((char const   *)firstdir);
        }
#line 471
        if (tmp___8 != 0) {
          {
#line 472
          tmp___5 = __errno_location();
#line 472
          tmp___6 = rrd_strerror(*tmp___5);
#line 472
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: chdir %s %s\n",
                  firstdir, tmp___6);
#line 473
          tmp___7 = __errno_location();
#line 473
          exit(*tmp___7);
          }
        }
      }
      {
#line 477
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 477
        tmp___12 = fgetslong(& aLine, stdin);
        }
#line 477
        if (! tmp___12) {
#line 477
          goto while_break;
        }
        {
#line 478
        aLineOrig = aLine;
#line 479
        argc = CountArgs(aLine);
        }
#line 479
        if (argc == 0) {
          {
#line 480
          free((void *)aLine);
#line 481
          printf((char const   */* __restrict  */)"ERROR: not enough arguments\n");
          }
#line 482
          goto while_continue;
        }
        {
#line 484
        tmp___10 = malloc((unsigned long )(argc + 1) * sizeof(char *));
#line 484
        myargv = (char **)tmp___10;
        }
#line 484
        if ((unsigned long )myargv == (unsigned long )((void *)0)) {
          {
#line 486
          perror("malloc");
#line 487
          exit(1);
          }
        }
        {
#line 489
        argc = CreateArgs(*(argv + 0), aLine, myargv);
        }
#line 489
        if (argc < 0) {
          {
#line 490
          printf((char const   */* __restrict  */)"ERROR: creating arguments\n");
          }
        } else {
          {
#line 492
          tmp___11 = HandleInputLine(argc, myargv, stdout);
          }
#line 492
          if (tmp___11 == 0) {
            {
#line 494
            getrusage((__rusage_who_t )0, & myusage);
#line 495
            gettimeofday((struct timeval */* __restrict  */)(& currenttime), (__timezone_ptr_t )((void *)0));
#line 496
            printf((char const   */* __restrict  */)"OK u:%1.2f s:%1.2f r:%1.2f\n",
                   (double )myusage.ru_utime.tv_sec + (double )myusage.ru_utime.tv_usec / 1000000.0,
                   (double )myusage.ru_stime.tv_sec + (double )myusage.ru_stime.tv_usec / 1000000.0,
                   (double )(currenttime.tv_sec - starttime.tv_sec) + (double )(currenttime.tv_usec - starttime.tv_usec) / 1000000.0);
            }
          }
        }
        {
#line 510
        fflush(stdout);
#line 511
        free((void *)myargv);
#line 512
        free((void *)aLineOrig);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else
  _L: /* CIL Label */ 
#line 514
  if (argc == 2) {
    {
#line 515
    PrintUsage(*(argv + 1));
#line 516
    exit(0);
    }
  } else
#line 517
  if (argc == 3) {
    {
#line 517
    tmp___14 = strcmp((char const   *)*(argv + 1), "help");
    }
#line 517
    if (tmp___14) {
      {
#line 521
      tmp___13 = HandleInputLine(argc, argv, stderr);
#line 521
      exit(tmp___13);
      }
    } else {
      {
#line 518
      PrintUsage(*(argv + 2));
#line 519
      exit(0);
      }
    }
  } else {
    {
#line 521
    tmp___13 = HandleInputLine(argc, argv, stderr);
#line 521
    exit(tmp___13);
    }
  }
#line 523
  return (0);
}
}
#line 528 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.c"
int HandleInputLine(int argc , char **argv , FILE *out ) 
{ 
  DIR *curdir ;
  struct dirent *dent ;
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *cwd ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char const   *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  rrd_info_t *data ;
  int tmp___26 ;
  double tmp___27 ;
  time_t tmp___28 ;
  time_t tmp___29 ;
  time_t start ;
  time_t end ;
  time_t ti ;
  unsigned long step ;
  unsigned long ds_cnt ;
  unsigned long i ;
  unsigned long ii ;
  rrd_value_t *data___0 ;
  rrd_value_t *datai ;
  char **ds_namv ;
  rrd_value_t *tmp___30 ;
  int tmp___31 ;
  int xxsize ;
  unsigned long j ;
  time_t start___0 ;
  time_t end___0 ;
  time_t ti___0 ;
  unsigned long step___0 ;
  unsigned long col_cnt ;
  unsigned long row_cnt ;
  rrd_value_t *data___1 ;
  rrd_value_t *ptr ;
  char **legend_v ;
  int enumds ;
  int json ;
  int i___0 ;
  size_t vtag_s ;
  size_t tmp___32 ;
  char *vtag ;
  void *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *old_locale ;
  char *tmp___36 ;
  char *entry ;
  rrd_value_t newval ;
  double tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  char const   *tmp___48 ;
  int tmp___49 ;
  char **calcpr ;
  int xsize ;
  int ysize ;
  double ymin ;
  double ymax ;
  int i___1 ;
  int tostdout ;
  int tmp___50 ;
  int imginfo ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  rrd_info_t *grinfo ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  char *tmp___75 ;
  int tmp___76 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  char *__cil_tmp277 ;

  {
#line 543
  if (RemoteMode) {
#line 544
    if (argc > 1) {
      {
#line 544
      tmp = strcmp("quit", (char const   *)*(argv + 1));
      }
#line 544
      if (tmp == 0) {
#line 545
        if (argc != 2) {
          {
#line 546
          printf((char const   */* __restrict  */)"ERROR: invalid parameter count for quit\n");
          }
#line 547
          return (1);
        }
        {
#line 549
        exit(0);
        }
      }
    }
#line 552
    if (argc > 1) {
      {
#line 552
      tmp___3 = strcmp("cd", (char const   *)*(argv + 1));
      }
#line 552
      if (tmp___3 == 0) {
#line 553
        if (argc != 3) {
          {
#line 554
          printf((char const   */* __restrict  */)"ERROR: invalid parameter count for cd\n");
          }
#line 555
          return (1);
        }
        {
#line 565
        tmp___2 = chdir((char const   *)*(argv + 2));
        }
#line 565
        if (tmp___2 != 0) {
          {
#line 566
          tmp___0 = __errno_location();
#line 566
          tmp___1 = rrd_strerror(*tmp___0);
#line 566
          printf((char const   */* __restrict  */)"ERROR: chdir %s %s\n", *(argv + 2),
                 tmp___1);
          }
#line 567
          return (1);
        }
#line 569
        return (0);
      }
    }
#line 571
    if (argc > 1) {
      {
#line 571
      tmp___6 = strcmp("pwd", (char const   *)*(argv + 1));
      }
#line 571
      if (tmp___6 == 0) {
#line 573
        if (argc != 2) {
          {
#line 574
          printf((char const   */* __restrict  */)"ERROR: invalid parameter count for pwd\n");
          }
#line 575
          return (1);
        }
        {
#line 577
        cwd = getcwd((char *)((void *)0), (size_t )4096);
        }
#line 578
        if ((unsigned long )cwd == (unsigned long )((void *)0)) {
          {
#line 579
          tmp___4 = __errno_location();
#line 579
          tmp___5 = rrd_strerror(*tmp___4);
#line 579
          printf((char const   */* __restrict  */)"ERROR: getcwd %s\n", tmp___5);
          }
#line 580
          return (1);
        }
        {
#line 582
        printf((char const   */* __restrict  */)"%s\n", cwd);
#line 583
        free((void *)cwd);
        }
#line 584
        return (0);
      }
    }
#line 586
    if (argc > 1) {
      {
#line 586
      tmp___10 = strcmp("mkdir", (char const   *)*(argv + 1));
      }
#line 586
      if (tmp___10 == 0) {
#line 587
        if (argc != 3) {
          {
#line 588
          printf((char const   */* __restrict  */)"ERROR: invalid parameter count for mkdir\n");
          }
#line 589
          return (1);
        }
        {
#line 599
        tmp___9 = mkdir((char const   *)*(argv + 2), (__mode_t )511);
        }
#line 599
        if (tmp___9 != 0) {
          {
#line 600
          tmp___7 = __errno_location();
#line 600
          tmp___8 = rrd_strerror(*tmp___7);
#line 600
          printf((char const   */* __restrict  */)"ERROR: mkdir %s: %s\n", *(argv + 2),
                 tmp___8);
          }
#line 601
          return (1);
        }
#line 603
        return (0);
      }
    }
#line 605
    if (argc > 1) {
      {
#line 605
      tmp___20 = strcmp("ls", (char const   *)*(argv + 1));
      }
#line 605
      if (tmp___20 == 0) {
#line 606
        if (argc != 2) {
          {
#line 607
          printf((char const   */* __restrict  */)"ERROR: invalid parameter count for ls\n");
          }
#line 608
          return (1);
        }
        {
#line 610
        curdir = opendir(".");
        }
#line 610
        if ((unsigned long )curdir != (unsigned long )((void *)0)) {
          {
#line 611
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 611
            dent = readdir(curdir);
            }
#line 611
            if (! ((unsigned long )dent != (unsigned long )((void *)0))) {
#line 611
              goto while_break;
            }
            {
#line 612
            tmp___16 = stat((char const   */* __restrict  */)(dent->d_name), (struct stat */* __restrict  */)(& st));
            }
#line 612
            if (! tmp___16) {
#line 613
              if ((st.st_mode & 61440U) == 16384U) {
                {
#line 614
                printf((char const   */* __restrict  */)"d %s\n", dent->d_name);
                }
              }
              {
#line 616
              tmp___15 = strlen((char const   *)(dent->d_name));
              }
#line 616
              if (tmp___15 > 4UL) {
#line 616
                if ((st.st_mode & 61440U) == 32768U) {
                  {
#line 617
                  tmp___11 = strlen((char const   *)(dent->d_name));
#line 617
                  tmp___12 = strcmp((char const   *)((dent->d_name + tmp___11) - 4),
                                    ".rrd");
                  }
#line 617
                  if (tmp___12) {
                    {
#line 617
                    tmp___13 = strlen((char const   *)(dent->d_name));
#line 617
                    tmp___14 = strcmp((char const   *)((dent->d_name + tmp___13) - 4),
                                      ".RRD");
                    }
#line 617
                    if (! tmp___14) {
                      {
#line 621
                      printf((char const   */* __restrict  */)"- %s\n", dent->d_name);
                      }
                    }
                  } else {
                    {
#line 621
                    printf((char const   */* __restrict  */)"- %s\n", dent->d_name);
                    }
                  }
                }
              }
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 626
          closedir(curdir);
          }
        } else {
          {
#line 628
          tmp___17 = __errno_location();
#line 628
          tmp___18 = rrd_strerror(*tmp___17);
#line 628
          printf((char const   */* __restrict  */)"ERROR: opendir .: %s\n", tmp___18);
#line 629
          tmp___19 = __errno_location();
          }
#line 629
          return (*tmp___19);
        }
#line 631
        return (0);
      }
    }
  }
#line 636
  if (argc < 3) {
    {
#line 641
    PrintUsage((char *)"");
    }
#line 642
    return (0);
  } else {
    {
#line 636
    tmp___21 = strcmp("help", (char const   *)*(argv + 1));
    }
#line 636
    if (tmp___21 == 0) {
      {
#line 641
      PrintUsage((char *)"");
      }
#line 642
      return (0);
    } else {
      {
#line 636
      tmp___22 = strcmp("--help", (char const   *)*(argv + 1));
      }
#line 636
      if (tmp___22 == 0) {
        {
#line 641
        PrintUsage((char *)"");
        }
#line 642
        return (0);
      } else {
        {
#line 636
        tmp___23 = strcmp("-help", (char const   *)*(argv + 1));
        }
#line 636
        if (tmp___23 == 0) {
          {
#line 641
          PrintUsage((char *)"");
          }
#line 642
          return (0);
        } else {
          {
#line 636
          tmp___24 = strcmp("-?", (char const   *)*(argv + 1));
          }
#line 636
          if (tmp___24 == 0) {
            {
#line 641
            PrintUsage((char *)"");
            }
#line 642
            return (0);
          } else {
            {
#line 636
            tmp___25 = strcmp("-h", (char const   *)*(argv + 1));
            }
#line 636
            if (tmp___25 == 0) {
              {
#line 641
              PrintUsage((char *)"");
              }
#line 642
              return (0);
            }
          }
        }
      }
    }
  }
  {
#line 645
  tmp___74 = strcmp("create", (char const   *)*(argv + 1));
  }
#line 645
  if (tmp___74 == 0) {
    {
#line 646
    rrd_create(argc - 1, argv + 1);
    }
  } else {
    {
#line 647
    tmp___73 = strcmp("dump", (char const   *)*(argv + 1));
    }
#line 647
    if (tmp___73 == 0) {
      {
#line 648
      rrd_dump(argc - 1, argv + 1);
      }
    } else {
      {
#line 649
      tmp___71 = strcmp("info", (char const   *)*(argv + 1));
      }
#line 649
      if (tmp___71 == 0) {
#line 649
        goto _L;
      } else {
        {
#line 649
        tmp___72 = strcmp("updatev", (char const   *)*(argv + 1));
        }
#line 649
        if (tmp___72 == 0) {
          _L: /* CIL Label */ 
          {
#line 652
          tmp___26 = strcmp("info", (char const   *)*(argv + 1));
          }
#line 652
          if (tmp___26 == 0) {
            {
#line 654
            data = rrd_info(argc - 1, argv + 1);
            }
          } else {
            {
#line 656
            data = rrd_update_v(argc - 1, argv + 1);
            }
          }
          {
#line 657
          rrd_info_print(data);
#line 658
          rrd_info_free(data);
          }
        } else {
          {
#line 661
          tmp___66 = strcmp("--version", (char const   *)*(argv + 1));
          }
#line 661
          if (tmp___66 == 0) {
            {
#line 665
            tmp___27 = rrd_version();
#line 665
            printf((char const   */* __restrict  */)"RRDtool 1.4.8  Copyright by Tobi Oetiker, 1997-2008 (%f)\n",
                   tmp___27);
            }
          } else {
            {
#line 661
            tmp___67 = strcmp("version", (char const   *)*(argv + 1));
            }
#line 661
            if (tmp___67 == 0) {
              {
#line 665
              tmp___27 = rrd_version();
#line 665
              printf((char const   */* __restrict  */)"RRDtool 1.4.8  Copyright by Tobi Oetiker, 1997-2008 (%f)\n",
                     tmp___27);
              }
            } else {
              {
#line 661
              tmp___68 = strcmp("v", (char const   *)*(argv + 1));
              }
#line 661
              if (tmp___68 == 0) {
                {
#line 665
                tmp___27 = rrd_version();
#line 665
                printf((char const   */* __restrict  */)"RRDtool 1.4.8  Copyright by Tobi Oetiker, 1997-2008 (%f)\n",
                       tmp___27);
                }
              } else {
                {
#line 661
                tmp___69 = strcmp("-v", (char const   *)*(argv + 1));
                }
#line 661
                if (tmp___69 == 0) {
                  {
#line 665
                  tmp___27 = rrd_version();
#line 665
                  printf((char const   */* __restrict  */)"RRDtool 1.4.8  Copyright by Tobi Oetiker, 1997-2008 (%f)\n",
                         tmp___27);
                  }
                } else {
                  {
#line 661
                  tmp___70 = strcmp("-version", (char const   *)*(argv + 1));
                  }
#line 661
                  if (tmp___70 == 0) {
                    {
#line 665
                    tmp___27 = rrd_version();
#line 665
                    printf((char const   */* __restrict  */)"RRDtool 1.4.8  Copyright by Tobi Oetiker, 1997-2008 (%f)\n",
                           tmp___27);
                    }
                  } else {
                    {
#line 668
                    tmp___65 = strcmp("restore", (char const   *)*(argv + 1));
                    }
#line 668
                    if (tmp___65 == 0) {
                      {
#line 669
                      rrd_restore(argc - 1, argv + 1);
                      }
                    } else {
                      {
#line 670
                      tmp___64 = strcmp("resize", (char const   *)*(argv + 1));
                      }
#line 670
                      if (tmp___64 == 0) {
                        {
#line 671
                        rrd_resize(argc - 1, argv + 1);
                        }
                      } else {
                        {
#line 672
                        tmp___63 = strcmp("last", (char const   *)*(argv + 1));
                        }
#line 672
                        if (tmp___63 == 0) {
                          {
#line 673
                          tmp___28 = rrd_last(argc - 1, argv + 1);
#line 673
                          printf((char const   */* __restrict  */)"%ld\n", tmp___28);
                          }
                        } else {
                          {
#line 674
                          tmp___62 = strcmp("lastupdate", (char const   *)*(argv + 1));
                          }
#line 674
                          if (tmp___62 == 0) {
                            {
#line 675
                            rrd_lastupdate(argc - 1, argv + 1);
                            }
                          } else {
                            {
#line 676
                            tmp___61 = strcmp("first", (char const   *)*(argv + 1));
                            }
#line 676
                            if (tmp___61 == 0) {
                              {
#line 677
                              tmp___29 = rrd_first(argc - 1, argv + 1);
#line 677
                              printf((char const   */* __restrict  */)"%ld\n", tmp___29);
                              }
                            } else {
                              {
#line 678
                              tmp___60 = strcmp("update", (char const   *)*(argv + 1));
                              }
#line 678
                              if (tmp___60 == 0) {
                                {
#line 679
                                rrd_update(argc - 1, argv + 1);
                                }
                              } else {
                                {
#line 680
                                tmp___59 = strcmp("fetch", (char const   *)*(argv + 1));
                                }
#line 680
                                if (tmp___59 == 0) {
                                  {
#line 686
                                  tmp___31 = rrd_fetch(argc - 1, argv + 1, & start,
                                                       & end, & step, & ds_cnt, & ds_namv,
                                                       & data___0);
                                  }
#line 686
                                  if (tmp___31 == 0) {
                                    {
#line 689
                                    datai = data___0;
#line 690
                                    printf((char const   */* __restrict  */)"           ");
#line 691
                                    i = 0UL;
                                    }
                                    {
#line 691
                                    while (1) {
                                      while_continue___0: /* CIL Label */ ;
#line 691
                                      if (! (i < ds_cnt)) {
#line 691
                                        goto while_break___0;
                                      }
                                      {
#line 692
                                      printf((char const   */* __restrict  */)"%20s",
                                             *(ds_namv + i));
#line 691
                                      i ++;
                                      }
                                    }
                                    while_break___0: /* CIL Label */ ;
                                    }
                                    {
#line 693
                                    printf((char const   */* __restrict  */)"\n\n");
#line 694
                                    ti = (time_t )((unsigned long )start + step);
                                    }
                                    {
#line 694
                                    while (1) {
                                      while_continue___1: /* CIL Label */ ;
#line 694
                                      if (! (ti <= end)) {
#line 694
                                        goto while_break___1;
                                      }
                                      {
#line 695
                                      printf((char const   */* __restrict  */)"%10lu:",
                                             ti);
#line 696
                                      ii = 0UL;
                                      }
                                      {
#line 696
                                      while (1) {
                                        while_continue___2: /* CIL Label */ ;
#line 696
                                        if (! (ii < ds_cnt)) {
#line 696
                                          goto while_break___2;
                                        }
                                        {
#line 697
                                        tmp___30 = datai;
#line 697
                                        datai ++;
#line 697
                                        printf((char const   */* __restrict  */)" %0.10e",
                                               *tmp___30);
#line 696
                                        ii ++;
                                        }
                                      }
                                      while_break___2: /* CIL Label */ ;
                                      }
                                      {
#line 698
                                      printf((char const   */* __restrict  */)"\n");
#line 694
                                      ti = (time_t )((unsigned long )ti + step);
                                      }
                                    }
                                    while_break___1: /* CIL Label */ ;
                                    }
#line 700
                                    i = 0UL;
                                    {
#line 700
                                    while (1) {
                                      while_continue___3: /* CIL Label */ ;
#line 700
                                      if (! (i < ds_cnt)) {
#line 700
                                        goto while_break___3;
                                      }
                                      {
#line 701
                                      free((void *)*(ds_namv + i));
#line 700
                                      i ++;
                                      }
                                    }
                                    while_break___3: /* CIL Label */ ;
                                    }
                                    {
#line 702
                                    free((void *)ds_namv);
#line 703
                                    free((void *)data___0);
                                    }
                                  }
                                } else {
                                  {
#line 705
                                  tmp___58 = strcmp("xport", (char const   *)*(argv + 1));
                                  }
#line 705
                                  if (tmp___58 == 0) {
                                    {
#line 708
                                    j = 0UL;
#line 713
                                    enumds = 0;
#line 714
                                    json = 0;
#line 716
                                    tmp___32 = strlen("v");
#line 716
                                    vtag_s = tmp___32 + 10UL;
#line 717
                                    tmp___33 = malloc(vtag_s);
#line 717
                                    vtag = (char *)tmp___33;
#line 719
                                    i___0 = 2;
                                    }
                                    {
#line 719
                                    while (1) {
                                      while_continue___4: /* CIL Label */ ;
#line 719
                                      if (! (i___0 < argc)) {
#line 719
                                        goto while_break___4;
                                      }
                                      {
#line 720
                                      tmp___34 = strcmp("--enumds", (char const   *)*(argv + i___0));
                                      }
#line 720
                                      if (tmp___34 == 0) {
#line 721
                                        enumds = 1;
                                      }
                                      {
#line 722
                                      tmp___35 = strcmp("--json", (char const   *)*(argv + i___0));
                                      }
#line 722
                                      if (tmp___35 == 0) {
#line 723
                                        json = 1;
                                      }
#line 719
                                      i___0 ++;
                                    }
                                    while_break___4: /* CIL Label */ ;
                                    }
                                    {
#line 726
                                    tmp___49 = rrd_xport(argc - 1, argv + 1, & xxsize,
                                                         & start___0, & end___0, & step___0,
                                                         & col_cnt, & legend_v, & data___1);
                                    }
#line 726
                                    if (tmp___49 == 0) {
                                      {
#line 729
                                      tmp___36 = setlocale(1, (char const   *)((void *)0));
#line 729
                                      old_locale = tmp___36;
#line 730
                                      setlocale(1, "C");
#line 731
                                      row_cnt = (unsigned long )(end___0 - start___0) / step___0;
#line 732
                                      ptr = data___1;
                                      }
#line 733
                                      if (json == 0) {
                                        {
#line 734
                                        printf((char const   */* __restrict  */)"<?xml version=\"1.0\" encoding=\"%s\"?>\n\n",
                                               "ISO-8859-1");
#line 736
                                        printf((char const   */* __restrict  */)"<%s>\n",
                                               "xport");
#line 737
                                        printf((char const   */* __restrict  */)"  <%s>\n",
                                               "meta");
                                        }
                                      } else {
                                        {
#line 740
                                        printf((char const   */* __restrict  */)"{ about: \'RRDtool xport JSON output\',\n  meta: {\n");
                                        }
                                      }
#line 751
                                      if (json) {
                                        {
#line 751
                                        printf((char const   */* __restrict  */)"    \"%s\": %lld,\n",
                                               "start", (long long )start___0 + (long long )step___0);
                                        }
                                      } else {
                                        {
#line 751
                                        printf((char const   */* __restrict  */)"    <%s>%lld</%s>\n",
                                               "start", (long long )start___0 + (long long )step___0,
                                               "start");
                                        }
                                      }
#line 752
                                      if (json) {
                                        {
#line 752
                                        printf((char const   */* __restrict  */)"    \"%s\": %lu,\n",
                                               "step", step___0);
                                        }
                                      } else {
                                        {
#line 752
                                        printf((char const   */* __restrict  */)"    <%s>%lu</%s>\n",
                                               "step", step___0, "step");
                                        }
                                      }
#line 753
                                      if (json) {
                                        {
#line 753
                                        printf((char const   */* __restrict  */)"    \"%s\": %lld,\n",
                                               "end", (long long )start___0 + (long long )step___0);
                                        }
                                      } else {
                                        {
#line 753
                                        printf((char const   */* __restrict  */)"    <%s>%lld</%s>\n",
                                               "end", (long long )start___0 + (long long )step___0,
                                               "end");
                                        }
                                      }
#line 754
                                      if (! json) {
#line 755
                                        if (json) {
                                          {
#line 755
                                          printf((char const   */* __restrict  */)"    \"%s\": %lu,\n",
                                                 "rows", row_cnt);
                                          }
                                        } else {
                                          {
#line 755
                                          printf((char const   */* __restrict  */)"    <%s>%lu</%s>\n",
                                                 "rows", row_cnt, "rows");
                                          }
                                        }
#line 756
                                        if (json) {
                                          {
#line 756
                                          printf((char const   */* __restrict  */)"    \"%s\": %lu,\n",
                                                 "columns", col_cnt);
                                          }
                                        } else {
                                          {
#line 756
                                          printf((char const   */* __restrict  */)"    <%s>%lu</%s>\n",
                                                 "columns", col_cnt, "columns");
                                          }
                                        }
                                      }
#line 759
                                      if (json) {
                                        {
#line 760
                                        printf((char const   */* __restrict  */)"    \"%s\": [\n",
                                               "legend");
                                        }
                                      } else {
                                        {
#line 763
                                        printf((char const   */* __restrict  */)"    <%s>\n",
                                               "legend");
                                        }
                                      }
#line 765
                                      j = 0UL;
                                      {
#line 765
                                      while (1) {
                                        while_continue___5: /* CIL Label */ ;
#line 765
                                        if (! (j < col_cnt)) {
#line 765
                                          goto while_break___5;
                                        }
#line 766
                                        entry = (char *)((void *)0);
#line 767
                                        entry = *(legend_v + j);
#line 768
                                        if (json) {
                                          {
#line 769
                                          printf((char const   */* __restrict  */)"      \'%s\'",
                                                 entry);
                                          }
#line 770
                                          if (j < col_cnt - 1UL) {
                                            {
#line 771
                                            printf((char const   */* __restrict  */)",");
                                            }
                                          }
                                          {
#line 773
                                          printf((char const   */* __restrict  */)"\n");
                                          }
                                        } else {
                                          {
#line 776
                                          printf((char const   */* __restrict  */)"      <%s>%s</%s>\n",
                                                 "entry", entry, "entry");
                                          }
                                        }
                                        {
#line 779
                                        free((void *)entry);
#line 765
                                        j ++;
                                        }
                                      }
                                      while_break___5: /* CIL Label */ ;
                                      }
                                      {
#line 781
                                      free((void *)legend_v);
                                      }
#line 782
                                      if (json) {
                                        {
#line 783
                                        printf((char const   */* __restrict  */)"          ]\n     },\n");
                                        }
                                      } else {
                                        {
#line 786
                                        printf((char const   */* __restrict  */)"    </%s>\n",
                                               "legend");
#line 787
                                        printf((char const   */* __restrict  */)"  </%s>\n",
                                               "meta");
                                        }
                                      }
#line 790
                                      if (json) {
                                        {
#line 791
                                        printf((char const   */* __restrict  */)"  \"%s\": [\n",
                                               "data");
                                        }
                                      } else {
                                        {
#line 793
                                        printf((char const   */* __restrict  */)"  <%s>\n",
                                               "data");
                                        }
                                      }
#line 795
                                      ti___0 = (time_t )((unsigned long )start___0 + step___0);
                                      {
#line 795
                                      while (1) {
                                        while_continue___6: /* CIL Label */ ;
#line 795
                                        if (! (ti___0 <= end___0)) {
#line 795
                                          goto while_break___6;
                                        }
#line 796
                                        if (json) {
                                          {
#line 797
                                          printf((char const   */* __restrict  */)"    [ ");
                                          }
                                        } else {
                                          {
#line 800
                                          printf((char const   */* __restrict  */)"    <%s>",
                                                 "row");
#line 801
                                          printf((char const   */* __restrict  */)"<%s>%lld</%s>",
                                                 "t", (long long )ti___0, "t");
                                          }
                                        }
#line 803
                                        j = 0UL;
                                        {
#line 803
                                        while (1) {
                                          while_continue___7: /* CIL Label */ ;
#line 803
                                          if (! (j < col_cnt)) {
#line 803
                                            goto while_break___7;
                                          }
                                          {
#line 804
                                          tmp___37 = rrd_set_to_DNAN();
#line 804
                                          newval = tmp___37;
#line 805
                                          newval = *ptr;
                                          }
#line 806
                                          if (json) {
#line 807
                                            if (sizeof(newval) == sizeof(float )) {
                                              {
#line 807
                                              tmp___38 = __isnanf((float )newval);
#line 807
                                              tmp___42 = tmp___38;
                                              }
                                            } else {
#line 807
                                              if (sizeof(newval) == sizeof(double )) {
                                                {
#line 807
                                                tmp___39 = __isnan(newval);
#line 807
                                                tmp___41 = tmp___39;
                                                }
                                              } else {
                                                {
#line 807
                                                tmp___40 = __isnanl((long double )newval);
#line 807
                                                tmp___41 = tmp___40;
                                                }
                                              }
#line 807
                                              tmp___42 = tmp___41;
                                            }
#line 807
                                            if (tmp___42) {
                                              {
#line 808
                                              printf((char const   */* __restrict  */)"null");
                                              }
                                            } else {
                                              {
#line 810
                                              printf((char const   */* __restrict  */)"%0.10e",
                                                     newval);
                                              }
                                            }
#line 812
                                            if (j < col_cnt - 1UL) {
                                              {
#line 813
                                              printf((char const   */* __restrict  */)", ");
                                              }
                                            }
                                          } else {
#line 817
                                            if (enumds == 1) {
                                              {
#line 818
                                              snprintf((char */* __restrict  */)vtag,
                                                       vtag_s, (char const   */* __restrict  */)"%s%lu",
                                                       "v", j);
                                              }
                                            } else {
                                              {
#line 820
                                              snprintf((char */* __restrict  */)vtag,
                                                       vtag_s, (char const   */* __restrict  */)"%s",
                                                       "v");
                                              }
                                            }
#line 821
                                            if (sizeof(newval) == sizeof(float )) {
                                              {
#line 821
                                              tmp___43 = __isnanf((float )newval);
#line 821
                                              tmp___47 = tmp___43;
                                              }
                                            } else {
#line 821
                                              if (sizeof(newval) == sizeof(double )) {
                                                {
#line 821
                                                tmp___44 = __isnan(newval);
#line 821
                                                tmp___46 = tmp___44;
                                                }
                                              } else {
                                                {
#line 821
                                                tmp___45 = __isnanl((long double )newval);
#line 821
                                                tmp___46 = tmp___45;
                                                }
                                              }
#line 821
                                              tmp___47 = tmp___46;
                                            }
#line 821
                                            if (tmp___47) {
                                              {
#line 822
                                              printf((char const   */* __restrict  */)"<%s>NaN</%s>",
                                                     vtag, vtag);
                                              }
                                            } else {
                                              {
#line 824
                                              printf((char const   */* __restrict  */)"<%s>%0.10e</%s>",
                                                     vtag, newval, vtag);
                                              }
                                            }
                                          }
#line 827
                                          ptr ++;
#line 803
                                          j ++;
                                        }
                                        while_break___7: /* CIL Label */ ;
                                        }
#line 829
                                        if (json) {
#line 830
                                          if (ti___0 < end___0) {
#line 830
                                            tmp___48 = " ],\n";
                                          } else {
#line 830
                                            tmp___48 = "  ]\n";
                                          }
                                          {
#line 830
                                          printf((char const   */* __restrict  */)tmp___48);
                                          }
                                        } else {
                                          {
#line 833
                                          printf((char const   */* __restrict  */)"</%s>\n",
                                                 "row");
                                          }
                                        }
#line 795
                                        ti___0 = (time_t )((unsigned long )ti___0 + step___0);
                                      }
                                      while_break___6: /* CIL Label */ ;
                                      }
                                      {
#line 836
                                      free((void *)data___1);
                                      }
#line 837
                                      if (json) {
                                        {
#line 838
                                        printf((char const   */* __restrict  */)"  ]\n}\n");
                                        }
                                      } else {
                                        {
#line 841
                                        printf((char const   */* __restrict  */)"  </%s>\n",
                                               "data");
#line 842
                                        printf((char const   */* __restrict  */)"</%s>\n",
                                               "xport");
                                        }
                                      }
                                      {
#line 844
                                      setlocale(1, (char const   *)old_locale);
                                      }
                                    }
                                    {
#line 846
                                    free((void *)vtag);
                                    }
                                  } else {
                                    {
#line 850
                                    tmp___57 = strcmp("graph", (char const   *)*(argv + 1));
                                    }
#line 850
                                    if (tmp___57 == 0) {
                                      {
#line 860
                                      tmp___50 = strcmp((char const   *)*(argv + 2),
                                                        "-");
#line 860
                                      tostdout = tmp___50 == 0;
#line 861
                                      imginfo = 0;
#line 863
                                      i___1 = 2;
                                      }
                                      {
#line 863
                                      while (1) {
                                        while_continue___8: /* CIL Label */ ;
#line 863
                                        if (! (i___1 < argc)) {
#line 863
                                          goto while_break___8;
                                        }
                                        {
#line 864
                                        tmp___51 = strcmp((char const   *)*(argv + i___1),
                                                          "--imginfo");
                                        }
#line 864
                                        if (tmp___51 == 0) {
#line 866
                                          imginfo = 1;
#line 867
                                          goto while_break___8;
                                        } else {
                                          {
#line 864
                                          tmp___52 = strcmp((char const   *)*(argv + i___1),
                                                            "-f");
                                          }
#line 864
                                          if (tmp___52 == 0) {
#line 866
                                            imginfo = 1;
#line 867
                                            goto while_break___8;
                                          }
                                        }
#line 863
                                        i___1 ++;
                                      }
                                      while_break___8: /* CIL Label */ ;
                                      }
                                      {
#line 870
                                      tmp___53 = rrd_graph(argc - 1, argv + 1, & calcpr,
                                                           & xsize, & ysize, (FILE *)((void *)0),
                                                           & ymin, & ymax);
                                      }
#line 870
                                      if (tmp___53 == 0) {
#line 873
                                        if (! tostdout) {
#line 873
                                          if (! imginfo) {
                                            {
#line 874
                                            printf((char const   */* __restrict  */)"%dx%d\n",
                                                   xsize, ysize);
                                            }
                                          }
                                        }
#line 875
                                        if (calcpr) {
#line 876
                                          i___1 = 0;
                                          {
#line 876
                                          while (1) {
                                            while_continue___9: /* CIL Label */ ;
#line 876
                                            if (! *(calcpr + i___1)) {
#line 876
                                              goto while_break___9;
                                            }
#line 877
                                            if (! tostdout) {
                                              {
#line 878
                                              printf((char const   */* __restrict  */)"%s\n",
                                                     *(calcpr + i___1));
                                              }
                                            }
                                            {
#line 879
                                            free((void *)*(calcpr + i___1));
#line 876
                                            i___1 ++;
                                            }
                                          }
                                          while_break___9: /* CIL Label */ ;
                                          }
                                          {
#line 881
                                          free((void *)calcpr);
                                          }
                                        }
                                      }
                                    } else {
                                      {
#line 888
                                      tmp___56 = strcmp("graphv", (char const   *)*(argv + 1));
                                      }
#line 888
                                      if (tmp___56 == 0) {
                                        {
#line 890
                                        grinfo = (rrd_info_t *)((void *)0);
#line 892
                                        grinfo = rrd_graph_v(argc - 1, argv + 1);
                                        }
#line 893
                                        if (grinfo) {
                                          {
#line 894
                                          rrd_info_print(grinfo);
#line 895
                                          rrd_info_free(grinfo);
                                          }
                                        }
                                      } else {
                                        {
#line 900
                                        tmp___55 = strcmp("tune", (char const   *)*(argv + 1));
                                        }
#line 900
                                        if (tmp___55 == 0) {
                                          {
#line 901
                                          rrd_tune(argc - 1, argv + 1);
                                          }
                                        } else {
                                          {
#line 903
                                          tmp___54 = strcmp("flushcached", (char const   *)*(argv + 1));
                                          }
#line 903
                                          if (tmp___54 == 0) {
                                            {
#line 904
                                            rrd_flushcached(argc - 1, argv + 1);
                                            }
                                          } else {
                                            {
#line 907
                                            rrd_set_error((char *)"unknown function \'%s\'",
                                                          *(argv + 1));
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 909
  tmp___76 = rrd_test_error();
  }
#line 909
  if (tmp___76) {
    {
#line 910
    tmp___75 = rrd_get_error();
#line 910
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"ERROR: %s\n",
            tmp___75);
#line 911
    rrd_clear_error();
    }
#line 912
    return (1);
  }
#line 914
  return (0);
}
}
#line 917 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.c"
int CountArgs(char *aLine ) 
{ 
  int i ;
  int aCount ;
  int inarg ;

  {
#line 920
  i = 0;
#line 921
  aCount = 0;
#line 922
  inarg = 0;
  {
#line 924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 924
    if (! ((int )*(aLine + i) == 32)) {
#line 924
      goto while_break;
    }
#line 925
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 926
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 926
    if (! ((int )*(aLine + i) != 0)) {
#line 926
      goto while_break___0;
    }
#line 927
    if ((int )*(aLine + i) == 32) {
#line 927
      if (inarg) {
#line 928
        inarg = 0;
      }
    }
#line 930
    if ((int )*(aLine + i) != 32) {
#line 930
      if (! inarg) {
#line 931
        inarg = 1;
#line 932
        aCount ++;
      }
    }
#line 934
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 936
  return (aCount);
}
}
#line 942 "/home/jkwonk/work/benchmark/rrdtool-1.4.8/src/rrd_tool.c"
int CreateArgs(char *pName , char *aLine , char **argv ) 
{ 
  char *getP ;
  char *putP ;
  char **pargv ;
  char Quote ;
  int inArg ;
  int len ;
  int argc ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 948
  pargv = argv;
#line 949
  Quote = (char)0;
#line 950
  inArg = 0;
#line 952
  argc = 1;
#line 954
  tmp = strlen((char const   *)aLine);
#line 954
  len = (int )tmp;
  }
  {
#line 956
  while (1) {
    while_continue: /* CIL Label */ ;
#line 956
    if (len) {
#line 956
      if (! ((int )*(aLine + len) <= 32)) {
#line 956
        goto while_break;
      }
    } else {
#line 956
      goto while_break;
    }
#line 957
    *(aLine + len) = (char)0;
#line 958
    len --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 961
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 961
    if (*aLine) {
#line 961
      if (! ((int )*aLine <= 32)) {
#line 961
        goto while_break___0;
      }
    } else {
#line 961
      goto while_break___0;
    }
#line 962
    aLine ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 963
  *(pargv + 0) = pName;
#line 964
  argc = 1;
#line 965
  getP = aLine;
#line 966
  putP = aLine;
  {
#line 967
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 967
    if (! *getP) {
#line 967
      goto while_break___1;
    }
    {
#line 969
    if ((int )*getP == 32) {
#line 969
      goto case_32;
    }
#line 978
    if ((int )*getP == 39) {
#line 978
      goto case_39;
    }
#line 978
    if ((int )*getP == 34) {
#line 978
      goto case_39;
    }
#line 993
    goto switch_default;
    case_32: /* CIL Label */ 
#line 970
    if (Quote) {
#line 971
      tmp___0 = putP;
#line 971
      putP ++;
#line 971
      *tmp___0 = *getP;
    } else
#line 972
    if (inArg) {
#line 973
      tmp___1 = putP;
#line 973
      putP ++;
#line 973
      *tmp___1 = (char)0;
#line 974
      inArg = 0;
    }
#line 976
    goto switch_break;
    case_39: /* CIL Label */ 
    case_34: /* CIL Label */ 
#line 979
    if ((int )Quote != 0) {
#line 980
      if ((int )Quote == (int )*getP) {
#line 981
        Quote = (char)0;
      } else {
#line 983
        tmp___2 = putP;
#line 983
        putP ++;
#line 983
        *tmp___2 = *getP;
      }
    } else {
#line 986
      if (! inArg) {
#line 987
        tmp___3 = argc;
#line 987
        argc ++;
#line 987
        *(pargv + tmp___3) = putP;
#line 988
        inArg = 1;
      }
#line 990
      Quote = *getP;
    }
#line 992
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 994
    if (! inArg) {
#line 995
      tmp___4 = argc;
#line 995
      argc ++;
#line 995
      *(pargv + tmp___4) = putP;
#line 996
      inArg = 1;
    }
#line 998
    tmp___5 = putP;
#line 998
    putP ++;
#line 998
    *tmp___5 = *getP;
#line 999
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1001
    getP ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1004
  *putP = (char )'\000';
#line 1005
  if (Quote) {
#line 1006
    return (-1);
  } else {
#line 1008
    return (argc);
  }
}
}

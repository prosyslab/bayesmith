/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 823
struct obstack ;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h"
typedef int wchar_t;
#line 805 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 247 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/os.h"
typedef char *slot_t;
#line 50 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 76 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct __anonstruct_40 {
   int32_t tv_sec ;
   int32_t tv_usec ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   int32_t ut_session ;
   struct __anonstruct_40 ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 63 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.h"
enum state_t {
    LIT = 0,
    ESC = 1,
    ASTR = 2,
    STRESC = 3,
    CSI = 4,
    PRIN = 5,
    PRINESC = 6,
    PRINCSI = 7,
    PRIN4 = 8
} ;
#line 77
enum string_t {
    NONE = 0,
    DCS = 1,
    OSC = 2,
    APC = 3,
    PM = 4,
    AKA = 5,
    GM = 6,
    STATUS = 7
} ;
#line 30 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/sched.h"
struct event {
   struct event *next ;
   void (*handler)(void * , char * ) ;
   char *data ;
   int fd ;
   int type ;
   int pri ;
   struct timeval timeout ;
   int queued ;
   int active ;
   int *condpos ;
   int *condneg ;
};
#line 44 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.h"
typedef unsigned char *AclBits;
#line 52
struct acluser ;
#line 50 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.h"
struct aclusergroup {
   struct acluser *u ;
   struct aclusergroup *next ;
};
#line 64 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.h"
struct plop {
   char *buf ;
   int len ;
   int enc ;
};
#line 78 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.h"
struct acluser {
   struct acluser *u_next ;
   char u_name[257] ;
   char *u_password ;
   int u_checkpassword ;
   int u_detachwin ;
   int u_detachotherwin ;
   int u_Esc ;
   int u_MetaEsc ;
   struct plop u_plop ;
   int u_id ;
   AclBits u_umask_w_bits[3] ;
   struct aclusergroup *u_group ;
};
#line 44 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/comm.h"
struct action {
   int nr ;
   char **args ;
   int *argl ;
   int quiet ;
};
#line 38 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.h"
struct mchar ;
#line 40 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.h"
struct LayFuncs {
   void (*lf_LayProcess)(char ** , int * ) ;
   void (*lf_LayAbort)(void) ;
   void (*lf_LayRedisplayLine)(int  , int  , int  , int  ) ;
   void (*lf_LayClearLine)(int  , int  , int  , int  ) ;
   int (*lf_LayRewrite)(int  , int  , int  , struct mchar * , int  ) ;
   int (*lf_LayResize)(int  , int  ) ;
   void (*lf_LayRestore)(void) ;
   void (*lf_LayFree)(void * ) ;
};
#line 55
struct canvas ;
#line 69 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.h"
struct __anonstruct_41 {
   unsigned char buffer[3] ;
   int len ;
   int start ;
};
#line 78 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.h"
struct __anonstruct_42 {
   int d ;
   int *left ;
   int *right ;
   int top ;
   int bottom ;
   int lines ;
};
#line 53 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.h"
struct layer {
   struct canvas *l_cvlist ;
   int l_width ;
   int l_height ;
   int l_x ;
   int l_y ;
   int l_encoding ;
   struct LayFuncs *l_layfn ;
   void *l_data ;
   struct layer *l_next ;
   struct layer *l_bottom ;
   int l_blocking ;
   int l_mode ;
   struct __anonstruct_41 l_mouseevent ;
   struct __anonstruct_42 l_pause ;
};
#line 15 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/term.h"
union tcu {
   int flg ;
   int num ;
   char *str ;
};
#line 117 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.h"
struct mode {
   struct termios tio ;
};
#line 60 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/image.h"
struct mchar {
   unsigned char image ;
   unsigned char attr ;
   unsigned char font ;
   unsigned char fontx ;
   unsigned char color ;
   unsigned char mbcs ;
};
#line 70 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/image.h"
struct mline {
   unsigned char *image ;
   unsigned char *attr ;
   unsigned char *font ;
   unsigned char *fontx ;
   unsigned char *color ;
};
#line 43 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.h"
struct display ;
#line 52
struct viewport ;
#line 40 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.h"
struct canvas {
   struct canvas *c_next ;
   struct display *c_display ;
   struct canvas *c_slnext ;
   struct canvas *c_slprev ;
   struct canvas *c_slperp ;
   struct canvas *c_slback ;
   int c_slorient ;
   int c_slweight ;
   struct viewport *c_vplist ;
   struct layer *c_layer ;
   struct canvas *c_lnext ;
   struct layer c_blank ;
   int c_xoff ;
   int c_yoff ;
   int c_xs ;
   int c_xe ;
   int c_ys ;
   int c_ye ;
   struct event c_captev ;
};
#line 65
struct win ;
#line 37 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.h"
struct layout {
   struct layout *lay_next ;
   char *lay_title ;
   int lay_number ;
   struct canvas lay_canvas ;
   struct canvas *lay_forecv ;
   struct canvas *lay_cvlist ;
   int lay_autosave ;
};
#line 35 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/viewport.h"
struct viewport {
   struct viewport *v_next ;
   struct canvas *v_canvas ;
   int v_xoff ;
   int v_yoff ;
   int v_xs ;
   int v_xe ;
   int v_ys ;
   int v_ye ;
};
#line 61 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.h"
struct mouse_parse {
   char sgrmode ;
   char state ;
   int params[3] ;
};
#line 68 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.h"
struct display {
   struct display *d_next ;
   struct acluser *d_user ;
   struct canvas d_canvas ;
   struct canvas *d_cvlist ;
   struct canvas *d_forecv ;
   struct layout *d_layout ;
   void (*d_processinput)(char * , int  ) ;
   char *d_processinputdata ;
   int d_vpxmin ;
   int d_vpxmax ;
   struct win *d_fore ;
   struct win *d_other ;
   int d_nonblock ;
   char d_termname[33] ;
   char *d_tentry ;
   char d_tcinited ;
   int d_width ;
   int d_height ;
   int d_defwidth ;
   int d_defheight ;
   int d_top ;
   int d_bot ;
   int d_x ;
   int d_y ;
   struct mchar d_rend ;
   int d_col16change ;
   char d_atyp ;
   int d_mbcs ;
   int d_encoding ;
   int d_decodestate ;
   int d_realfont ;
   int d_insert ;
   int d_keypad ;
   int d_cursorkeys ;
   int d_revvid ;
   int d_curvis ;
   int d_has_hstatus ;
   int d_hstatus ;
   int d_lp_missing ;
   int d_mouse ;
   int d_extmouse ;
   struct mouse_parse d_mouse_parse ;
   int d_mousetrack ;
   int d_xtermosc[4] ;
   struct mchar d_lpchar ;
   struct timeval d_status_time ;
   int d_status ;
   char d_status_bell ;
   int d_status_len ;
   char *d_status_lastmsg ;
   int d_status_buflen ;
   int d_status_lastx ;
   int d_status_lasty ;
   int d_status_obuflen ;
   int d_status_obuffree ;
   int d_status_obufpos ;
   struct event d_statusev ;
   struct event d_hstatusev ;
   int d_kaablamm ;
   struct action *d_ESCseen ;
   int d_userpid ;
   char d_usertty[4096] ;
   int d_userfd ;
   struct event d_readev ;
   struct event d_writeev ;
   struct event d_blockedev ;
   struct mode d_OldMode ;
   struct mode d_NewMode ;
   int d_flow ;
   int d_intrc ;
   char *d_obuf ;
   int d_obuflen ;
   int d_obufmax ;
   int d_obuflenmax ;
   char *d_obufp ;
   int d_obuffree ;
   int d_auto_nuke ;
   int d_nseqs ;
   int d_aseqs ;
   unsigned char *d_kmaps ;
   unsigned char *d_seqp ;
   int d_seql ;
   unsigned char *d_seqh ;
   struct event d_mapev ;
   int d_dontmap ;
   int d_mapdefault ;
   union tcu d_tcs[201] ;
   char *d_attrtab[6] ;
   char d_attrtyp[6] ;
   int d_hascolor ;
   short d_dospeed ;
   char d_c0_tab[256] ;
   char ***d_xtable ;
   int d_UPcost ;
   int d_DOcost ;
   int d_LEcost ;
   int d_NDcost ;
   int d_CRcost ;
   int d_IMcost ;
   int d_EIcost ;
   int d_NLcost ;
   int d_printfd ;
   slot_t d_loginslot ;
   struct utmp d_utmp_logintty ;
   int d_loginttymode ;
   int d_blocked ;
   int d_blocked_fuzz ;
   struct event d_idleev ;
   int d_blankerpid ;
   struct event d_blankerev ;
};
#line 66 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.h"
struct pseudowin {
   int p_fdpat ;
   int p_pid ;
   int p_ptyfd ;
   struct event p_readev ;
   struct event p_writeev ;
   char p_cmd[768] ;
   char p_tty[768] ;
   char p_inbuf[4096] ;
   int p_inlen ;
};
#line 126 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.h"
struct paster {
   char *pa_pastebuf ;
   char *pa_pasteptr ;
   int pa_pastelen ;
   struct layer *pa_pastelayer ;
   struct event pa_slowev ;
};
#line 196 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.h"
struct cursor {
   int on ;
   int x ;
   int y ;
   struct mchar Rend ;
   int Charset ;
   int CharsetR ;
   int Charsets[4] ;
};
#line 232
struct logfile ;
#line 288 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.h"
struct __anonstruct_43 {
   int on ;
   struct mline *mlines ;
   int width ;
   int height ;
   int histheight ;
   struct mline *hlines ;
   int histidx ;
   struct cursor cursor ;
};
#line 138 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.h"
struct win {
   struct win *w_next ;
   int w_type ;
   void *w_data ;
   struct layer w_layer ;
   struct layer *w_savelayer ;
   int w_blocked ;
   struct pseudowin *w_pwin ;
   struct display *w_pdisplay ;
   struct display *w_lastdisp ;
   int w_number ;
   struct event w_readev ;
   struct event w_writeev ;
   struct event w_silenceev ;
   struct event w_zombieev ;
   int w_poll_zombie_timeout ;
   int w_ptyfd ;
   char w_inbuf[4096] ;
   int w_inlen ;
   char w_outbuf[4096] ;
   int w_outlen ;
   int w_aflag ;
   int w_dynamicaka ;
   char *w_title ;
   char *w_akachange ;
   char w_akabuf[768] ;
   int w_autoaka ;
   struct win *w_group ;
   int w_intermediate ;
   int w_args[64] ;
   int w_NumArgs ;
   int w_wlock ;
   struct acluser *w_wlockuser ;
   AclBits w_userbits[3] ;
   AclBits w_lio_notify ;
   AclBits w_mon_notify ;
   enum state_t w_state ;
   enum string_t w_StringType ;
   struct mline *w_mlines ;
   struct mchar w_rend ;
   char w_FontL ;
   char w_FontR ;
   char w_FontE ;
   int w_Charset ;
   int w_CharsetR ;
   int w_charsets[4] ;
   int w_ss ;
   struct cursor w_saved ;
   int w_top ;
   int w_bot ;
   int w_wrap ;
   int w_origin ;
   int w_insert ;
   int w_keypad ;
   int w_cursorkeys ;
   int w_revvid ;
   int w_curinv ;
   int w_curvvis ;
   int w_autolf ;
   char *w_hstatus ;
   int w_gr ;
   int w_c1 ;
   int w_bce ;
   int w_decodestate ;
   int w_mbcs ;
   char w_string[768] ;
   char *w_stringp ;
   char *w_tabs ;
   int w_bell ;
   int w_flow ;
   struct logfile *w_log ;
   int w_logsilence ;
   int w_monitor ;
   int w_silencewait ;
   int w_silence ;
   char w_vbwait ;
   char w_norefresh ;
   char w_xtermosc[4][768] ;
   int w_mouse ;
   int w_extmouse ;
   int w_slowpaste ;
   int w_histheight ;
   int w_histidx ;
   int w_scrollback_height ;
   struct mline *w_hlines ;
   struct paster w_paster ;
   int w_pid ;
   int w_deadpid ;
   char *w_cmdargs[64] ;
   char *w_dir ;
   char *w_term ;
   int w_lflag ;
   slot_t w_slot ;
   struct utmp w_savut ;
   char w_tty[768] ;
   int w_zauto ;
   struct display *w_zdisplay ;
   struct __anonstruct_43 w_alt ;
   struct event w_destroyev ;
   int w_exitstatus ;
};
#line 53 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
struct encoding {
   char *name ;
   char *charsets ;
   int deffont ;
   int usegr ;
   int noc1 ;
   char *fontlist ;
};
#line 281 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
struct recodetab {
   unsigned short (*tab)[2] ;
   int flags ;
};
#line 660 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
struct combchar {
   unsigned int c1 ;
   unsigned int c2 ;
   unsigned int next ;
   unsigned int prev ;
};
#line 936 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
struct interval {
   int first ;
   int last ;
};
#line 36 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/nethack.c"
struct nlstrans {
   char *from ;
   char *to ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 254 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 79 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_at ;
#line 79
struct sockaddr_ax25 ;
#line 79
struct sockaddr_dl ;
#line 79
struct sockaddr_eon ;
#line 79
struct sockaddr_in ;
#line 79
struct sockaddr_in6 ;
#line 79
struct sockaddr_inarp ;
#line 79
struct sockaddr_ipx ;
#line 79
struct sockaddr_iso ;
#line 79
struct sockaddr_ns ;
#line 79
struct sockaddr_un ;
#line 79
struct sockaddr_x25 ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/socket.h"
union __anonunion_260 {
   struct sockaddr *__sockaddr__ ;
   struct sockaddr_at *__sockaddr_at__ ;
   struct sockaddr_ax25 *__sockaddr_ax25__ ;
   struct sockaddr_dl *__sockaddr_dl__ ;
   struct sockaddr_eon *__sockaddr_eon__ ;
   struct sockaddr_in *__sockaddr_in__ ;
   struct sockaddr_in6 *__sockaddr_in6__ ;
   struct sockaddr_inarp *__sockaddr_inarp__ ;
   struct sockaddr_ipx *__sockaddr_ipx__ ;
   struct sockaddr_iso *__sockaddr_iso__ ;
   struct sockaddr_ns *__sockaddr_ns__ ;
   struct sockaddr_un *__sockaddr_un__ ;
   struct sockaddr_x25 *__sockaddr_x25__ ;
};
#line 80 "/usr/include/x86_64-linux-gnu/sys/socket.h"
typedef union __anonunion_260 __SOCKADDR_ARG;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 119 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 213 "/usr/include/netinet/in.h"
union __anonunion_262 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 211 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_262 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[8] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_272 {
   __fd_mask fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_272 fd_set;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone *__timezone_ptr_t;
#line 23 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.h"
struct ListData ;
#line 25 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.h"
struct ListRow {
   void *data ;
   struct ListRow *next ;
   struct ListRow *prev ;
   int y ;
};
#line 32 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.h"
struct GenericList {
   int (*gl_printheader)(struct ListData * ) ;
   int (*gl_printfooter)(struct ListData * ) ;
   int (*gl_printrow)(struct ListData * , struct ListRow * ) ;
   int (*gl_pinput)(struct ListData * , char **inp , int *len ) ;
   int (*gl_freerow)(struct ListData * , struct ListRow * ) ;
   int (*gl_free)(struct ListData * ) ;
   int (*gl_matchrow)(struct ListData * , struct ListRow * , char const   * ) ;
};
#line 43 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.h"
struct ListData {
   char const   *name ;
   struct ListRow *root ;
   struct ListRow *selected ;
   struct ListRow *top ;
   struct GenericList *list_fn ;
   char *search ;
   void *data ;
};
#line 52 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
struct gl_Window_Data {
   struct win *group ;
   int order ;
   int onblank ;
   int nested ;
   struct win *fore ;
};
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 30 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.h"
struct logfile {
   struct logfile *next ;
   FILE *fp ;
   char *name ;
   int opencount ;
   int writecount ;
   int flushcount ;
   struct stat *st ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 39 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 5 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/comm.h"
struct comm {
   char *name ;
   int flags ;
   AclBits userbits[1] ;
};
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 93 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.h"
enum move_t {
    M_NONE = 0,
    M_UP = 1,
    M_CUP = 2,
    M_DO = 3,
    M_CDO = 4,
    M_LE = 5,
    M_CLE = 6,
    M_RI = 7,
    M_CRI = 8,
    M_RW = 9,
    M_CR = 10
} ;
#line 37 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.h"
struct NewWindow {
   int StartAt ;
   char *aka ;
   char **args ;
   char *dir ;
   char *term ;
   int aflag ;
   int dynamicaka ;
   int flowflag ;
   int lflag ;
   int histheight ;
   int monitor ;
   int wlock ;
   int silence ;
   int wrap ;
   int Lflag ;
   int slow ;
   int gr ;
   int c1 ;
   int bce ;
   int encoding ;
   char *hstatus ;
   char *charset ;
   int poll_zombie_timeout ;
};
#line 304 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.h"
struct baud_values {
   int idx ;
   int bps ;
   int sym ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 9 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/term.h"
struct term {
   char *tcname ;
   int type ;
};
#line 44 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.h"
struct kmap_ext {
   char *str ;
   int fl ;
   struct action um ;
   struct action dm ;
   struct action mm ;
};
#line 227 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
struct kclass {
   struct kclass *next ;
   char *name ;
   struct action ktab[338] ;
};
#line 247 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
struct digraph {
   unsigned char d[2] ;
   int value ;
};
#line 6387 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
struct inputsu {
   struct acluser **up ;
   char name[24] ;
   char pw1[130] ;
   char pw2[130] ;
};
#line 199 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.h"
struct __anonstruct_940 {
   int lflag ;
   int aflag ;
   int flowflag ;
   int hheight ;
   int nargs ;
   char line[4096] ;
   char dir[4096] ;
   char screenterm[33] ;
};
#line 211 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.h"
struct __anonstruct_941 {
   char auser[257] ;
   int apid ;
   int adaptflag ;
   int lines ;
   int columns ;
   char preselect[20] ;
   int esc ;
   int meta_esc ;
   char envterm[33] ;
   int encoding ;
   int detachfirst ;
};
#line 225 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.h"
struct __anonstruct_942 {
   char duser[257] ;
   int dpid ;
};
#line 231 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.h"
struct __anonstruct_943 {
   char auser[257] ;
   int nargs ;
   char cmd[4096] ;
   int apid ;
   char preselect[20] ;
   char writeback[4096] ;
};
#line 197 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.h"
union __anonunion_944 {
   struct __anonstruct_940 create ;
   struct __anonstruct_941 attach ;
   struct __anonstruct_942 detach ;
   struct __anonstruct_943 command ;
   char message[8192] ;
};
#line 192 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.h"
struct msg {
   int protocol_revision ;
   int type ;
   char m_tty[4096] ;
   union __anonunion_944 m ;
};
#line 44 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/input.c"
struct inpline {
   char buf[769] ;
   int len ;
   int pos ;
   struct inpline *next ;
   struct inpline *prev ;
};
#line 58 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/input.c"
struct inpdata {
   struct inpline inp ;
   int inpmaxlen ;
   char *inpstring ;
   int inpstringlen ;
   int inpmode ;
   void (*inpfinfunc)(char *buf , int len , char *priv ) ;
   char *priv ;
   int privdata ;
   char *search ;
};
#line 130 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
struct helpdata {
   char *class ;
   struct action *ktabp ;
   int maxrow ;
   int grow ;
   int numcols ;
   int numrows ;
   int num_names ;
   int numskip ;
   int numpages ;
   int command_search ;
   int command_bindings ;
   int refgrow ;
   int refcommand_search ;
   int inter ;
   int mcom ;
   int mkey ;
   int nact[190] ;
};
#line 451 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
struct copydata {
   char *cps ;
   char *savedcps ;
   char *refcps ;
   char *refsavedcps ;
};
#line 711 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
struct bindkeydata {
   char *title ;
   struct action *tab ;
   int pos ;
   int last ;
   int page ;
   int pages ;
};
#line 49 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.h"
struct __anonstruct_1323 {
   int flag ;
   int target ;
   int direction ;
};
#line 30 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.h"
struct markdata {
   struct win *md_window ;
   struct acluser *md_user ;
   int cx ;
   int cy ;
   int x1 ;
   int y1 ;
   int second ;
   int left_mar ;
   int right_mar ;
   int nonl ;
   int rep_cnt ;
   int append_mode ;
   int write_buffer ;
   int hist_offset ;
   char isstr[100] ;
   int isstrl ;
   char isistr[200] ;
   int isistrl ;
   int isdir ;
   int isstartpos ;
   int isstartdir ;
   struct __anonstruct_1323 f_cmd ;
};
#line 83 "/usr/include/x86_64-linux-gnu/sys/socket.h"
union __anonunion_1338 {
   struct sockaddr *__sockaddr__ ;
   struct sockaddr_at *__sockaddr_at__ ;
   struct sockaddr_ax25 *__sockaddr_ax25__ ;
   struct sockaddr_dl *__sockaddr_dl__ ;
   struct sockaddr_eon *__sockaddr_eon__ ;
   struct sockaddr_in *__sockaddr_in__ ;
   struct sockaddr_in6 *__sockaddr_in6__ ;
   struct sockaddr_inarp *__sockaddr_inarp__ ;
   struct sockaddr_ipx *__sockaddr_ipx__ ;
   struct sockaddr_iso *__sockaddr_iso__ ;
   struct sockaddr_ns *__sockaddr_ns__ ;
   struct sockaddr_un *__sockaddr_un__ ;
   struct sockaddr_x25 *__sockaddr_x25__ ;
};
#line 84 "/usr/include/x86_64-linux-gnu/sys/socket.h"
typedef union __anonunion_1338 __CONST_SOCKADDR_ARG;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 144 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
struct sent {
   struct sent *next ;
   int mode ;
   char *name ;
};
#line 1640 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
struct pwdata {
   int l ;
   char buf[257] ;
   struct msg m ;
};
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_1422 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_1422 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1436 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1437 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 71 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1438 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 79 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1439 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1440 {
   void *_lower ;
   void *_upper ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_1441 {
   struct __anonstruct_1440 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 89 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1442 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion_1441 _bounds ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1443 {
   long si_band ;
   int si_fd ;
};
#line 116 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1444 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_1445 {
   int _pad[28] ;
   struct __anonstruct_1436 _kill ;
   struct __anonstruct_1437 _timer ;
   struct __anonstruct_1438 _rt ;
   struct __anonstruct_1439 _sigchld ;
   struct __anonstruct_1442 _sigfault ;
   struct __anonstruct_1443 _sigpoll ;
   struct __anonstruct_1444 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_1446 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion_1445 _sifields ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_1446 siginfo_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion_1449 {
   __sighandler_t sa_handler ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion_1449 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 150 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
struct backtick ;
#line 2238 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
struct backtick {
   struct backtick *next ;
   int num ;
   int tick ;
   int lifespan ;
   time_t bestbefore ;
   char result[768] ;
   char **cmdv ;
   struct event ev ;
   char *buf ;
   int bufi ;
};
#line 390 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 391
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern _IO_FILE *stdin ;
#line 136
extern _IO_FILE *stdout ;
#line 312
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 318
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 320
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 327
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 333
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 335
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 340
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 352
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 355
__inline extern  __attribute__((__nothrow__)) int __asprintf(char **__ptr , char const   *__fmt 
                                                             , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 365
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 368
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 484
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 495
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 496
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 506
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 524
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 587
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 646
__inline extern size_t fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 826
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 829
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 46
  __cil_tmp1 = _IO_getc(stdin);
  }
#line 46
  return (__cil_tmp1);
}
}
#line 53
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 55
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 55
  if (__cil_tmp2) {
    {
#line 55
    __cil_tmp3 = __uflow(__fp);
#line 55
    tmp = __cil_tmp3;
    }
  } else {
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 55
  return (tmp);
}
}
#line 70
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 72
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 72
  if (__cil_tmp1) {
    {
#line 72
    __cil_tmp2 = __uflow(stdin);
#line 72
    tmp = __cil_tmp2;
    }
  } else {
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 72
  return (tmp);
}
}
#line 79
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 81
  __cil_tmp2 = _IO_putc(__c, stdout);
  }
#line 81
  return (__cil_tmp2);
}
}
#line 88
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 90
  if (__cil_tmp3) {
    {
#line 90
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp = __cil_tmp4;
    }
  } else {
#line 90
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    *__cil_tmp5 = (char )__c;
#line 90
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 90
  return (tmp);
}
}
#line 105
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 107
  if (__cil_tmp2) {
    {
#line 107
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp = __cil_tmp3;
    }
  } else {
#line 107
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    *__cil_tmp4 = (char )__c;
#line 107
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 107
  return (tmp);
}
}
#line 115
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 115 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) 
{ 
  __ssize_t __cil_tmp4 ;

  {
  {
#line 117
  __cil_tmp4 = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 117
  return (__cil_tmp4);
}
}
#line 125
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 125 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 132
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 31 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 33
  __cil_tmp3 = __builtin_object_size((void const   *)__s, 1);
  }
  {
#line 33
  __cil_tmp4 = __builtin_va_arg_pack();
#line 33
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 33
  return (__cil_tmp5);
}
}
#line 43
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 46
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
#line 46
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 46
  return (__cil_tmp5);
}
}
#line 61
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 64
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
  {
#line 64
  __cil_tmp5 = __builtin_va_arg_pack();
#line 64
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 64
  return (__cil_tmp6);
}
}
#line 74
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 74 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 77
  __cil_tmp5 = __builtin_object_size((void const   *)__s, 1);
#line 77
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 77
  return (__cil_tmp6);
}
}
#line 85
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 87
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 88
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 95
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 97
  __cil_tmp3 = __builtin_va_arg_pack();
#line 97
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 97
  return (__cil_tmp4);
}
}
#line 102
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 104
  __cil_tmp2 = __builtin_va_arg_pack();
#line 104
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 104
  return (__cil_tmp3);
}
}
#line 114
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 114 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 117
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 117
  return (__cil_tmp3);
}
}
#line 124
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 127
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 127
  return (__cil_tmp4);
}
}
#line 131
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 133
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 139
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 141
  __cil_tmp3 = __builtin_va_arg_pack();
#line 141
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 141
  return (__cil_tmp4);
}
}
#line 150
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 152
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 152
  return (__cil_tmp4);
}
}
#line 158
extern  __attribute__((__nothrow__)) int __asprintf_chk(char **__ptr , int __flag ,
                                                        char const   *__fmt  , ...) ;
#line 161
extern  __attribute__((__nothrow__)) int __vasprintf_chk(char **__ptr , int __flag ,
                                                         char const   *__fmt , __gnuc_va_list __arg ) ;
#line 164
extern  __attribute__((__nothrow__)) int __obstack_printf_chk(struct obstack *__obstack ,
                                                              int __flag , char const   *__format 
                                                              , ...) ;
#line 168
extern  __attribute__((__nothrow__)) int __obstack_vprintf_chk(struct obstack *__obstack ,
                                                               int __flag , char const   *__format ,
                                                               __gnuc_va_list __args ) ;
#line 176
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 176 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int asprintf(char **__ptr , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 178
  __cil_tmp3 = __builtin_va_arg_pack();
#line 178
  __cil_tmp4 = __asprintf_chk(__ptr, 1, __fmt, __cil_tmp3);
  }
#line 178
  return (__cil_tmp4);
}
}
#line 191
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 191 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_printf(struct obstack *__obstack , char const   *__fmt 
                                   , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 194
  __cil_tmp3 = __builtin_va_arg_pack();
#line 194
  __cil_tmp4 = __obstack_printf_chk(__obstack, 1, __fmt, __cil_tmp3);
  }
#line 194
  return (__cil_tmp4);
}
}
#line 207
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vasprintf(char **__ptr , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 210
  __cil_tmp4 = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  }
#line 210
  return (__cil_tmp4);
}
}
#line 214
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 214 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_vprintf(struct obstack *__obstack , char const   *__fmt ,
                                    __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 217
  __cil_tmp4 = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  }
#line 217
  return (__cil_tmp4);
}
}
#line 240
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 242
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 252
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 252 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 254
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
#line 254
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 256
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 256
    if (! __cil_tmp5) {
      {
      {
#line 257
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 257
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 257
      return (__cil_tmp7);
    } else
#line 256
    if (__n <= 0) {
      {
      {
#line 257
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 257
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 257
      return (__cil_tmp7);
    }
    {
#line 259
    __cil_tmp8 = __builtin_object_size((void const   *)__s, 1);
    }
#line 259
    if ((size_t )__n > __cil_tmp8) {
      {
#line 260
      __cil_tmp9 = __builtin_object_size((void const   *)__s, 1);
#line 260
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 260
      return (__cil_tmp10);
    }
  }
  {
#line 262
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 262
  return (__cil_tmp11);
}
}
#line 265
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 268
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 272
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 281
__inline extern size_t fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 281 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 284
  __cil_tmp5 = __builtin_object_size((void const   *)__ptr, 0);
  }
#line 284
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 286
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 286
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 286
    if (! __cil_tmp6) {
      {
      {
      {
#line 289
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 289
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 289
      return (__cil_tmp9);
    } else
#line 286
    if (! __cil_tmp7) {
      {
      {
      {
#line 289
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 289
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 289
      return (__cil_tmp9);
    } else
#line 286
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 289
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 289
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 289
      return (__cil_tmp9);
    }
    {
#line 291
    __cil_tmp10 = __builtin_object_size((void const   *)__ptr, 0);
    }
#line 291
    if (__size * __n > __cil_tmp10) {
      {
#line 292
      __cil_tmp11 = __builtin_object_size((void const   *)__ptr, 0);
#line 292
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp12);
    }
  }
  {
#line 294
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 294
  return (__cil_tmp13);
}
}
#line 298
extern char *__fgets_unlocked_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 300
extern char *__fgets_unlocked_alias(char *__s , int __n , FILE *__stream ) ;
#line 303
extern char *__fgets_unlocked_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 310
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 310 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 312
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
#line 312
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 314
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 314
    if (! __cil_tmp5) {
      {
      {
#line 315
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 315
      __cil_tmp7 = __fgets_unlocked_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 315
      return (__cil_tmp7);
    } else
#line 314
    if (__n <= 0) {
      {
      {
#line 315
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 315
      __cil_tmp7 = __fgets_unlocked_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 315
      return (__cil_tmp7);
    }
    {
#line 317
    __cil_tmp8 = __builtin_object_size((void const   *)__s, 1);
    }
#line 317
    if ((size_t )__n > __cil_tmp8) {
      {
#line 318
      __cil_tmp9 = __builtin_object_size((void const   *)__s, 1);
#line 318
      __cil_tmp10 = __fgets_unlocked_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 318
      return (__cil_tmp10);
    }
  }
  {
#line 320
  __cil_tmp11 = __fgets_unlocked_alias(__s, __n, __stream);
  }
#line 320
  return (__cil_tmp11);
}
}
#line 326
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 329
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 333
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 342
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 342 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  long __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  char *__cil_tmp22 ;
  size_t __cil_tmp23 ;

  {
  {
#line 345
  __cil_tmp5 = __builtin_object_size((void const   *)__ptr, 0);
  }
#line 345
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 347
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 347
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 347
    if (! __cil_tmp6) {
      {
      {
      {
#line 350
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 350
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 350
      return (__cil_tmp9);
    } else
#line 347
    if (! __cil_tmp7) {
      {
      {
      {
#line 350
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 350
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 350
      return (__cil_tmp9);
    } else
#line 347
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 350
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 350
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 350
      return (__cil_tmp9);
    }
    {
#line 353
    __cil_tmp10 = __builtin_object_size((void const   *)__ptr, 0);
    }
#line 353
    if (__size * __n > __cil_tmp10) {
      {
#line 354
      __cil_tmp11 = __builtin_object_size((void const   *)__ptr, 0);
#line 354
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 354
      return (__cil_tmp12);
    }
  }
  {
#line 359
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 359
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 359
  if (__cil_tmp13) {
#line 359
    if (__cil_tmp14) {
#line 359
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 359
        if (__size * __n <= 8UL) {
#line 364
          __cnt = __size * __n;
#line 365
          __cptr = (char *)__ptr;
#line 366
          if (__cnt == 0UL) {
#line 367
            return ((size_t )0);
          }
          {
#line 369
          while (1) {
            while_continue: /* CIL Label */ ;
#line 369
            if (! (__cnt > 0UL)) {
#line 369
              goto while_break;
            }
            {
#line 371
            __cil_tmp18 = __builtin_expect((long )(__stream->_IO_read_ptr >= __stream->_IO_read_end),
                                           (long )0);
            }
#line 371
            if (__cil_tmp18) {
              {
#line 371
              __cil_tmp19 = __uflow(__stream);
#line 371
              tmp = __cil_tmp19;
              }
            } else {
#line 371
              (__stream->_IO_read_ptr) ++;
#line 371
              tmp = (int )*((unsigned char *)__stream->_IO_read_ptr);
            }
#line 371
            __c = tmp;
#line 372
            if (__c == -1) {
#line 373
              goto while_break;
            }
#line 374
            __cil_tmp22 = __cptr;
#line 374
            __cptr ++;
#line 374
            *__cil_tmp22 = (char )__c;
          }
          while_break: /* CIL Label */ ;
          }
#line 369
          __cnt --;
#line 376
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 379
  __cil_tmp23 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 379
  return (__cil_tmp23);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 74
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 75
__inline extern  __attribute__((__nothrow__)) __dev_t gnu_dev_makedev(unsigned int __major ,
                                                                      unsigned int __minor )  __attribute__((__gnu_inline__)) ;
#line 79
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_major(__dev_t __dev ) 
{ 
  unsigned int __major ;

  {
#line 79
  __major = (unsigned int )((__dev & 1048320UL) >> 8);
#line 79
  __major |= 0UL;
#line 79
  return (__major);
}
}
#line 80
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_minor(__dev_t __dev ) 
{ 
  unsigned int __minor ;

  {
#line 80
  __minor = (unsigned int )(__dev & 255UL);
#line 80
  __minor |= (__dev & 17592184995840UL) >> 12;
#line 80
  return (__minor);
}
}
#line 81
__inline extern  __attribute__((__nothrow__)) __dev_t gnu_dev_makedev(unsigned int __major ,
                                                                      unsigned int __minor )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern __dev_t gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 
  __dev_t __dev ;

  {
#line 81
  __dev = (__dev_t )(__major & 4095U) << 8;
#line 81
  __dev |= (__dev_t )(__major & 4294963200U) << 32;
#line 81
  __dev |= (__dev_t )(__minor & 255U);
#line 81
  __dev |= (__dev_t )(__minor & 4294967040U) << 12;
#line 81
  return (__dev);
}
}
#line 363 "/usr/include/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 407
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 514
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__)) ;
#line 528
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__)) ;
#line 626
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 692
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 777
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 811
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 822
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 859
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 880
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 898
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 25
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 27
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 34
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size((void const   *)__buf, 0);
  }
#line 36
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 38
    __cil_tmp5 = __builtin_constant_p(__nbytes);
    }
#line 38
    if (! __cil_tmp5) {
      {
#line 39
      __cil_tmp6 = __builtin_object_size((void const   *)__buf, 0);
#line 39
      __cil_tmp7 = __read_chk(__fd, __buf, __nbytes, __cil_tmp6);
      }
#line 39
      return (__cil_tmp7);
    }
    {
#line 41
    __cil_tmp8 = __builtin_object_size((void const   *)__buf, 0);
    }
#line 41
    if (__nbytes > __cil_tmp8) {
      {
#line 42
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 0);
#line 42
      __cil_tmp10 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp9);
      }
#line 42
      return (__cil_tmp10);
    }
  }
  {
#line 44
  __cil_tmp11 = __read_alias(__fd, __buf, __nbytes);
  }
#line 44
  return (__cil_tmp11);
}
}
#line 48
extern ssize_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                           size_t __bufsize ) ;
#line 50
extern ssize_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                             size_t __bufsize ) ;
#line 52
extern ssize_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 55
extern ssize_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 58
extern ssize_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                size_t __bufsize ) ;
#line 63
extern ssize_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                  size_t __bufsize ) ;
#line 72
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 72 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 74
  __cil_tmp5 = __builtin_object_size((void const   *)__buf, 0);
  }
#line 74
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 76
    __cil_tmp6 = __builtin_constant_p(__nbytes);
    }
#line 76
    if (! __cil_tmp6) {
      {
#line 77
      __cil_tmp7 = __builtin_object_size((void const   *)__buf, 0);
#line 77
      __cil_tmp8 = __pread_chk(__fd, __buf, __nbytes, __offset, __cil_tmp7);
      }
#line 77
      return (__cil_tmp8);
    }
    {
#line 79
    __cil_tmp9 = __builtin_object_size((void const   *)__buf, 0);
    }
#line 79
    if (__nbytes > __cil_tmp9) {
      {
#line 80
      __cil_tmp10 = __builtin_object_size((void const   *)__buf, 0);
#line 80
      __cil_tmp11 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp10);
      }
#line 80
      return (__cil_tmp11);
    }
  }
  {
#line 83
  __cil_tmp12 = __pread_alias(__fd, __buf, __nbytes, __offset);
  }
#line 83
  return (__cil_tmp12);
}
}
#line 105
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 107
  __cil_tmp5 = __builtin_object_size((void const   *)__buf, 0);
  }
#line 107
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 109
    __cil_tmp6 = __builtin_constant_p(__nbytes);
    }
#line 109
    if (! __cil_tmp6) {
      {
#line 110
      __cil_tmp7 = __builtin_object_size((void const   *)__buf, 0);
#line 110
      __cil_tmp8 = __pread64_chk(__fd, __buf, __nbytes, __offset, __cil_tmp7);
      }
#line 110
      return (__cil_tmp8);
    }
    {
#line 112
    __cil_tmp9 = __builtin_object_size((void const   *)__buf, 0);
    }
#line 112
    if (__nbytes > __cil_tmp9) {
      {
#line 113
      __cil_tmp10 = __builtin_object_size((void const   *)__buf, 0);
#line 113
      __cil_tmp11 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp10);
      }
#line 113
      return (__cil_tmp11);
    }
  }
  {
#line 117
  __cil_tmp12 = __pread64_alias(__fd, __buf, __nbytes, __offset);
  }
#line 117
  return (__cil_tmp12);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 139
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlink(char const   *__path , char *__buf , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 142
  __cil_tmp4 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 142
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 144
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 144
    if (! __cil_tmp5) {
      {
#line 145
      __cil_tmp6 = __builtin_object_size((void const   *)__buf, 1);
#line 145
      __cil_tmp7 = __readlink_chk(__path, __buf, __len, __cil_tmp6);
      }
#line 145
      return (__cil_tmp7);
    }
    {
#line 147
    __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 147
    if (__len > __cil_tmp8) {
      {
#line 148
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 1);
#line 148
      __cil_tmp10 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp9);
      }
#line 148
      return (__cil_tmp10);
    }
  }
  {
#line 150
  __cil_tmp11 = __readlink_alias(__path, __buf, __len);
  }
#line 150
  return (__cil_tmp11);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 173
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 173 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlinkat(int __fd , char const   *__path , char *__buf ,
                                   size_t __len ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 176
  __cil_tmp5 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 176
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 178
    __cil_tmp6 = __builtin_constant_p(__len);
    }
#line 178
    if (! __cil_tmp6) {
      {
#line 179
      __cil_tmp7 = __builtin_object_size((void const   *)__buf, 1);
#line 179
      __cil_tmp8 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp7);
      }
#line 179
      return (__cil_tmp8);
    }
    {
#line 181
    __cil_tmp9 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 181
    if (__len > __cil_tmp9) {
      {
#line 182
      __cil_tmp10 = __builtin_object_size((void const   *)__buf, 1);
#line 182
      __cil_tmp11 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp10);
      }
#line 182
      return (__cil_tmp11);
    }
  }
  {
#line 185
  __cil_tmp12 = __readlinkat_alias(__fd, __path, __buf, __len);
  }
#line 185
  return (__cil_tmp12);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 193
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__)) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getcwd(char *__buf , size_t __size ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 202
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 204
    __cil_tmp4 = __builtin_constant_p(__size);
    }
#line 204
    if (! __cil_tmp4) {
      {
#line 205
      __cil_tmp5 = __builtin_object_size((void const   *)__buf, 1);
#line 205
      __cil_tmp6 = __getcwd_chk(__buf, __size, __cil_tmp5);
      }
#line 205
      return (__cil_tmp6);
    }
    {
#line 207
    __cil_tmp7 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 207
    if (__size > __cil_tmp7) {
      {
#line 208
      __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
#line 208
      __cil_tmp9 = __getcwd_chk_warn(__buf, __size, __cil_tmp8);
      }
#line 208
      return (__cil_tmp9);
    }
  }
  {
#line 210
  __cil_tmp10 = __getcwd_alias(__buf, __size);
  }
#line 210
  return (__cil_tmp10);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 221
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__)) ;
#line 221 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getwd(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 223
  __cil_tmp2 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 223
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 224
    __cil_tmp3 = __builtin_object_size((void const   *)__buf, 1);
#line 224
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 224
    return (__cil_tmp4);
  }
  {
#line 225
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 225
  return (__cil_tmp5);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t confstr(int __name , char *__buf , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 242
  __cil_tmp4 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 242
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 244
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 244
    if (! __cil_tmp5) {
      {
#line 245
      __cil_tmp6 = __builtin_object_size((void const   *)__buf, 1);
#line 245
      __cil_tmp7 = __confstr_chk(__name, __buf, __len, __cil_tmp6);
      }
#line 245
      return (__cil_tmp7);
    }
    {
#line 247
    __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 247
    if (__cil_tmp8 < __len) {
      {
#line 248
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 1);
#line 248
      __cil_tmp10 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp9);
      }
#line 248
      return (__cil_tmp10);
    }
  }
  {
#line 250
  __cil_tmp11 = __confstr_alias(__name, __buf, __len);
  }
#line 250
  return (__cil_tmp11);
}
}
#line 254
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t __list[] ,
                                                         size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t __list[] ) ;
#line 258
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t __list[] ,
                                                              size_t __listlen ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getgroups(int __size , __gid_t __list[] ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_object_size((void const   *)__list, 1);
  }
#line 267
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 269
    __cil_tmp4 = __builtin_constant_p(__size);
    }
#line 269
    if (! __cil_tmp4) {
      {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void const   *)__list, 1);
      }
      {
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
      }
#line 270
      return (__cil_tmp6);
    } else
#line 269
    if (__size < 0) {
      {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void const   *)__list, 1);
      }
      {
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
      }
#line 270
      return (__cil_tmp6);
    }
    {
#line 272
    __cil_tmp7 = __builtin_object_size((void const   *)__list, 1);
    }
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > __cil_tmp7) {
      {
#line 273
      __cil_tmp8 = __builtin_object_size((void const   *)__list, 1);
#line 273
      __cil_tmp9 = __getgroups_chk_warn(__size, __list, __cil_tmp8);
      }
#line 273
      return (__cil_tmp9);
    }
  }
  {
#line 275
  __cil_tmp10 = __getgroups_alias(__size, __list);
  }
#line 275
  return (__cil_tmp10);
}
}
#line 279
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 284
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 291 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 293
  __cil_tmp4 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 293
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 295
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 295
    if (! __cil_tmp5) {
      {
#line 296
      __cil_tmp6 = __builtin_object_size((void const   *)__buf, 1);
#line 296
      __cil_tmp7 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 296
      return (__cil_tmp7);
    }
    {
#line 298
    __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 298
    if (__buflen > __cil_tmp8) {
      {
#line 299
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 1);
#line 299
      __cil_tmp10 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 299
      return (__cil_tmp10);
    }
  }
  {
#line 301
  __cil_tmp11 = __ttyname_r_alias(__fd, __buf, __buflen);
  }
#line 301
  return (__cil_tmp11);
}
}
#line 306
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 308
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 310
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 317
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 317 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getlogin_r(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 319
  __cil_tmp3 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 319
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 321
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 321
    if (! __cil_tmp4) {
      {
#line 322
      __cil_tmp5 = __builtin_object_size((void const   *)__buf, 1);
#line 322
      __cil_tmp6 = __getlogin_r_chk(__buf, __buflen, __cil_tmp5);
      }
#line 322
      return (__cil_tmp6);
    }
    {
#line 324
    __cil_tmp7 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 324
    if (__buflen > __cil_tmp7) {
      {
#line 325
      __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
#line 325
      __cil_tmp9 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 325
      return (__cil_tmp9);
    }
  }
  {
#line 327
  __cil_tmp10 = __getlogin_r_alias(__buf, __buflen);
  }
#line 327
  return (__cil_tmp10);
}
}
#line 333
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 337
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 344 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int gethostname(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 346
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 348
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 348
    if (! __cil_tmp4) {
      {
#line 349
      __cil_tmp5 = __builtin_object_size((void const   *)__buf, 1);
#line 349
      __cil_tmp6 = __gethostname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 349
      return (__cil_tmp6);
    }
    {
#line 351
    __cil_tmp7 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 351
    if (__buflen > __cil_tmp7) {
      {
#line 352
      __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
#line 352
      __cil_tmp9 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 352
      return (__cil_tmp9);
    }
  }
  {
#line 354
  __cil_tmp10 = __gethostname_alias(__buf, __buflen);
  }
#line 354
  return (__cil_tmp10);
}
}
#line 360
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 365
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getdomainname(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 375
  __cil_tmp3 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 375
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 377
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 377
    if (! __cil_tmp4) {
      {
#line 378
      __cil_tmp5 = __builtin_object_size((void const   *)__buf, 1);
#line 378
      __cil_tmp6 = __getdomainname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 378
      return (__cil_tmp6);
    }
    {
#line 380
    __cil_tmp7 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 380
    if (__buflen > __cil_tmp7) {
      {
#line 381
      __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
#line 381
      __cil_tmp9 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 381
      return (__cil_tmp9);
    }
  }
  {
#line 383
  __cil_tmp10 = __getdomainname_alias(__buf, __buflen);
  }
#line 383
  return (__cil_tmp10);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 539
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 797
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__)) ;
#line 817
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 926 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 930
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 995
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size((void const   *)__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp4 = __builtin_object_size((void const   *)__resolved, 1);
    }
#line 42
    if (__cil_tmp4 < 4096UL) {
      {
#line 43
      __cil_tmp5 = __builtin_object_size((void const   *)__resolved, 1);
#line 43
      __cil_tmp6 = __realpath_chk_warn(__name, __resolved, __cil_tmp5);
      }
#line 43
      return (__cil_tmp6);
    }
    {
#line 45
    __cil_tmp7 = __builtin_object_size((void const   *)__resolved, 1);
#line 45
    __cil_tmp8 = __realpath_chk(__name, __resolved, __cil_tmp7);
    }
#line 45
    return (__cil_tmp8);
  }
  {
#line 48
  __cil_tmp9 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp9);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size((void const   *)__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size((void const   *)__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size((void const   *)__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size((void const   *)__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size((void const   *)__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size((void const   *)__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size((void const   *)__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size((void const   *)__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size((void const   *)__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size((void const   *)__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size((void const   *)__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 38 "/usr/include/strings.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 0);
#line 25
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 0);
#line 31
  __cil_tmp4 = __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 42 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__)) ;
#line 46
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 60
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__)) ;
#line 121
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 124
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 129
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 132
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 377
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 435
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 451
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 459
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 45
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 45 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *mempcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 48
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 0);
#line 48
  __cil_tmp5 = __builtin___mempcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 48
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 95
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 97
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 1);
#line 97
  __cil_tmp4 = __builtin___stpcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 97
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size((void const   *)__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void const   *)__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void const   *)__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 77 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.h"
void RethinkViewportOffsets(struct canvas *cv ) ;
#line 47 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/viewport.h"
int RethinkDisplayViewports(void) ;
#line 34 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/viewport.c"
struct display *display ;
#line 36 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/viewport.c"
int RethinkDisplayViewports(void) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  struct viewport *vpn ;
  void *__cil_tmp4 ;

  {
#line 41
  cv = display->d_cvlist;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! cv) {
#line 41
      goto while_break;
    }
#line 42
    vp = cv->c_vplist;
    {
#line 42
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 42
      if (! vp) {
#line 42
        goto while_break___0;
      }
      {
#line 43
      vp->v_canvas = (struct canvas *)0;
#line 44
      vpn = vp->v_next;
#line 45
      bzero((void *)((char *)vp), sizeof(*vp));
#line 46
      free((void *)vp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 42
    vp = vpn;
#line 48
    cv->c_vplist = (struct viewport *)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  cv = cv->c_next;
#line 50
  display->d_vpxmin = - 1;
#line 51
  display->d_vpxmax = - 1;
#line 53
  cv = display->d_cvlist;
  {
#line 53
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 53
    if (! cv) {
#line 53
      goto while_break___1;
    }
    {
#line 54
    __cil_tmp4 = malloc(sizeof(*vp));
#line 54
    vp = (struct viewport *)__cil_tmp4;
    }
#line 54
    if (vp == (struct viewport *)0) {
#line 55
      return (- 1);
    }
#line 103
    vp->v_canvas = cv;
#line 104
    vp->v_xs = cv->c_xs;
#line 105
    vp->v_ys = cv->c_ys;
#line 106
    vp->v_xe = cv->c_xe;
#line 107
    vp->v_ye = cv->c_ye;
#line 108
    vp->v_xoff = cv->c_xoff;
#line 109
    vp->v_yoff = cv->c_yoff;
#line 110
    vp->v_next = cv->c_vplist;
#line 111
    cv->c_vplist = vp;
#line 114
    if (cv->c_xs < display->d_vpxmin) {
#line 115
      display->d_vpxmin = cv->c_xs;
    } else
#line 114
    if (display->d_vpxmin == -1) {
#line 115
      display->d_vpxmin = cv->c_xs;
    }
#line 116
    if (cv->c_xe > display->d_vpxmax) {
#line 117
      display->d_vpxmax = cv->c_xe;
    } else
#line 116
    if (display->d_vpxmax == -1) {
#line 117
      display->d_vpxmax = cv->c_xe;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 53
  cv = cv->c_next;
#line 119
  return (0);
}
}
#line 122 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/viewport.c"
void RethinkViewportOffsets(struct canvas *cv ) 
{ 
  struct viewport *vp ;

  {
#line 125
  vp = cv->c_vplist;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! vp) {
#line 125
      goto while_break;
    }
#line 126
    vp->v_xoff = cv->c_xoff;
#line 127
    vp->v_yoff = cv->c_yoff;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  vp = vp->v_next;
  return;
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s ) ;
#line 67 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.h"
void SetCanvasWindow(struct canvas *cv , struct win *wi ) ;
#line 70
int MakeDefaultCanvas(void) ;
#line 74
void FreeCanvas(struct canvas *cv ) ;
#line 75
void ResizeCanvas(struct canvas *cv ) ;
#line 76
void RecreateCanvasChain(void) ;
#line 80
void DupLayoutCv(struct canvas *cvf , struct canvas *cvt , int save ) ;
#line 81
void PutWindowCv(struct canvas *cv ) ;
#line 48 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.h"
void AutosaveLayout(struct layout *lay ) ;
#line 49
void LoadLayout(struct layout *lay , struct canvas *cv ) ;
#line 50
void NewLayout(char *title , int startat ) ;
#line 51
void SaveLayout(char *name , struct canvas *cv ) ;
#line 52
void ShowLayouts(int where ) ;
#line 53
struct layout *FindLayout(char *name ) ;
#line 54
void UpdateLayoutCanvas(struct canvas *cv , struct win *wi ) ;
#line 55
struct layout *CreateLayout(char *title , int startat ) ;
#line 56
void RemoveLayout(struct layout *lay ) ;
#line 57
int LayoutDumpCanvas(struct canvas *cv , char *filename ) ;
#line 59
void RenameLayout(struct layout *layout , char const   *name ) ;
#line 60
int RenumberLayout(struct layout *layout , int number ) ;
#line 45 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void Msg(int err , char const   *fmt  , ...) ;
#line 87
FILE *secfopen(char *name , char *mode ) ;
#line 208
void Activate(int norefresh ) ;
#line 328
void ResizeLayersToCanvases(void) ;
#line 355
char *SaveStr(char const   *str ) ;
#line 459
void KillLayerChain(struct layer *lay ) ;
#line 35 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
int captionalways ;
#line 37
struct layout *layouts ;
#line 38
struct layout *laytab[10] ;
#line 39
struct layout layout_last_marker ;
#line 40 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
struct layout *layout_attach  =    & layout_last_marker;
#line 42 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
void FreeLayoutCv(struct canvas *cv ) 
{ 
  struct canvas *cnext ;
  struct canvas *c ;

  {
#line 44
  c = cv;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! cv) {
#line 45
      goto while_break;
    }
#line 46
    if (cv->c_slperp) {
      {
#line 47
      FreeLayoutCv(cv->c_slperp);
#line 48
      free((void *)cv->c_slperp);
#line 49
      cv->c_slperp = (struct canvas *)0;
      }
    }
#line 51
    cnext = cv->c_slnext;
#line 52
    cv->c_slnext = (struct canvas *)0;
#line 53
    if (cv != c) {
      {
#line 54
      free((void *)cv);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  cv = cnext;
  return;
}
}
#line 58 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
struct layout *CreateLayout(char *title , int startat ) 
{ 
  struct layout *lay ;
  struct layout **pl ;
  int i ;
  void *__cil_tmp6 ;

  {
#line 63
  if (startat >= 10) {
#line 64
    startat = 0;
  } else
#line 63
  if (startat < 0) {
#line 64
    startat = 0;
  }
#line 65
  i = startat;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! 1) {
#line 65
      goto while_break;
    }
#line 66
    if (! laytab[i]) {
#line 67
      goto while_break;
    }
#line 68
    i ++;
#line 68
    if (i == 10) {
#line 69
      i = 0;
    }
#line 70
    if (i == startat) {
      {
#line 71
      Msg(0, (char const   *)((char *)"No more layouts\n"));
      }
#line 72
      return ((struct layout *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  __cil_tmp6 = calloc((unsigned long )1, sizeof(*lay));
#line 75
  lay = (struct layout *)__cil_tmp6;
#line 76
  lay->lay_title = SaveStr((char const   *)title);
#line 77
  lay->lay_autosave = 1;
#line 78
  lay->lay_number = i;
#line 79
  laytab[i] = lay;
#line 80
  lay->lay_next = (struct layout *)0;
#line 82
  pl = & layouts;
  }
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    if (! *pl) {
#line 83
      goto while_break___0;
    }
#line 84
    pl = & (*pl)->lay_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  *pl = lay;
#line 86
  return (lay);
}
}
#line 89 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
void SaveLayout(char *name , struct canvas *cv ) 
{ 
  struct layout *lay ;
  struct canvas *fcv ;
  int __cil_tmp5 ;

  {
#line 93
  lay = layouts;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! lay) {
#line 93
      goto while_break;
    }
    {
#line 94
    __cil_tmp5 = strcmp((char const   *)lay->lay_title, (char const   *)name);
    }
#line 94
    if (! __cil_tmp5) {
#line 95
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  lay = lay->lay_next;
#line 96
  if (lay) {
    {
#line 97
    FreeLayoutCv(& lay->lay_canvas);
    }
  } else {
    {
#line 99
    lay = CreateLayout(name, 0);
    }
  }
#line 100
  if (! lay) {
#line 101
    return;
  }
  {
#line 102
  fcv = display->d_forecv;
#line 103
  DupLayoutCv(cv, & lay->lay_canvas, 1);
#line 104
  lay->lay_forecv = display->d_forecv;
#line 105
  display->d_forecv = fcv;
#line 106
  display->d_layout = lay;
  }
  return;
}
}
#line 109 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
void AutosaveLayout(struct layout *lay ) 
{ 
  struct canvas *fcv ;

  {
#line 112
  if (! lay) {
#line 113
    return;
  } else
#line 112
  if (! lay->lay_autosave) {
#line 113
    return;
  }
  {
#line 114
  FreeLayoutCv(& lay->lay_canvas);
#line 115
  fcv = display->d_forecv;
#line 116
  DupLayoutCv(& display->d_canvas, & lay->lay_canvas, 1);
#line 117
  lay->lay_forecv = display->d_forecv;
#line 118
  display->d_forecv = fcv;
  }
  return;
}
}
#line 121 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
struct layout *FindLayout(char *name ) 
{ 
  struct layout *lay ;
  char *s ;
  int i ;
  int __cil_tmp6 ;

  {
#line 126
  s = name;
#line 126
  i = 0;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((int )*s >= 48 && (int )*s <= 57)) {
#line 126
      goto while_break;
    }
#line 127
    i = i * 10 + ((int )*s - 48);
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  s ++;
#line 128
  if (! *s) {
#line 128
    if (s != name) {
#line 128
      if (i >= 0) {
#line 128
        if (i < 10) {
#line 129
          return (laytab[i]);
        }
      }
    }
  }
#line 130
  lay = layouts;
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! lay) {
#line 130
      goto while_break___0;
    }
    {
#line 131
    __cil_tmp6 = strcmp((char const   *)lay->lay_title, (char const   *)name);
    }
#line 131
    if (! __cil_tmp6) {
#line 132
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 130
  lay = lay->lay_next;
#line 133
  return (lay);
}
}
#line 136 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
void LoadLayout(struct layout *lay , struct canvas *cv ) 
{ 


  {
  {
#line 138
  AutosaveLayout(display->d_layout);
  }
#line 139
  if (! lay) {
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
#line 140
      if (! display->d_canvas.c_slperp) {
#line 140
        goto while_break;
      }
      {
#line 141
      FreeCanvas(display->d_canvas.c_slperp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 142
    MakeDefaultCanvas();
#line 143
    SetCanvasWindow(display->d_forecv, (struct win *)0);
#line 144
    display->d_layout = (struct layout *)0;
    }
#line 145
    return;
  }
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 147
    if (! display->d_canvas.c_slperp) {
#line 147
      goto while_break___0;
    }
    {
#line 148
    FreeCanvas(display->d_canvas.c_slperp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 149
  display->d_cvlist = (struct canvas *)0;
#line 150
  display->d_forecv = lay->lay_forecv;
#line 151
  if (! display->d_forecv) {
    {
#line 152
    MakeDefaultCanvas();
    }
  }
  {
#line 153
  DupLayoutCv(& lay->lay_canvas, & display->d_canvas, 0);
#line 154
  display->d_canvas.c_ys = display->d_has_hstatus == 4;
#line 155
  display->d_canvas.c_ye = ((display->d_height - 1) - ((display->d_canvas.c_slperp && (display->d_canvas.c_slperp)->c_slnext) || captionalways)) - (display->d_has_hstatus == 1);
#line 157
  ResizeCanvas(& display->d_canvas);
#line 158
  RecreateCanvasChain();
#line 159
  RethinkDisplayViewports();
#line 160
  PutWindowCv(& display->d_canvas);
#line 161
  ResizeLayersToCanvases();
#line 162
  display->d_layout = lay;
  }
  return;
}
}
#line 165 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
void NewLayout(char *title , int startat ) 
{ 
  struct layout *lay ;
  struct canvas *fcv ;

  {
  {
#line 170
  lay = CreateLayout(title, startat);
  }
#line 171
  if (! lay) {
#line 172
    return;
  }
#line 174
  if (display) {
    {
#line 175
    LoadLayout((struct layout *)0, & display->d_canvas);
#line 176
    fcv = display->d_forecv;
#line 177
    DupLayoutCv(& display->d_canvas, & lay->lay_canvas, 1);
#line 178
    lay->lay_forecv = display->d_forecv;
#line 179
    display->d_forecv = fcv;
#line 180
    display->d_layout = lay;
    }
  } else {
#line 183
    layout_attach = lay;
  }
#line 185
  lay->lay_autosave = 1;
  return;
}
}
#line 189 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
static char *AddLayoutsInfo(char *buf , int len , int where ) 
{ 
  char *s ;
  char *ss ;
  char *t ;
  struct layout *p ;
  struct layout **pp ;
  int l ;
  size_t __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  size_t __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 195
  ss = buf;
#line 195
  s = ss;
#line 196
  pp = (struct layout **)laytab;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (pp < (struct layout **)laytab + 10)) {
#line 196
      goto while_break;
    }
#line 197
    if (pp - (struct layout **)laytab == (long )where) {
#line 197
      if (ss == buf) {
#line 198
        ss = s;
      }
    }
#line 199
    p = *pp;
#line 199
    if (p == (struct layout *)0) {
#line 200
      goto while_continue;
    }
    {
#line 201
    t = p->lay_title;
#line 202
    __cil_tmp10 = strlen((char const   *)t);
#line 202
    l = (int )__cil_tmp10;
    }
#line 203
    if (l > 20) {
#line 204
      l = 20;
    }
#line 205
    if ((s - buf) + (long )l > (long )(len - 24)) {
#line 206
      goto while_break;
    }
#line 207
    if (s > buf) {
#line 208
      __cil_tmp11 = s;
#line 208
      s ++;
#line 208
      *__cil_tmp11 = (char )' ';
#line 209
      __cil_tmp12 = s;
#line 209
      s ++;
#line 209
      *__cil_tmp12 = (char )' ';
    }
    {
#line 211
    sprintf(s, (char const   *)((char *)"%d"), p->lay_number);
    }
#line 212
    if (p->lay_number == where) {
#line 213
      ss = s;
    }
    {
#line 214
    __cil_tmp13 = strlen((char const   *)s);
    }
#line 214
    s += __cil_tmp13;
#line 215
    if (display) {
#line 215
      if (p == display->d_layout) {
#line 216
        __cil_tmp14 = s;
#line 216
        s ++;
#line 216
        *__cil_tmp14 = (char )'*';
      }
    }
    {
#line 217
    __cil_tmp15 = s;
#line 217
    s ++;
#line 217
    *__cil_tmp15 = (char )' ';
#line 218
    strncpy(s, (char const   *)t, (unsigned long )l);
#line 219
    s += l;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  pp ++;
#line 221
  *s = (char )0;
#line 222
  return (ss);
}
}
#line 225 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
void ShowLayouts(int where ) 
{ 
  char buf[1024] ;
  char *s ;
  char *ss ;
  size_t __cil_tmp6 ;

  {
#line 230
  if (! display) {
#line 231
    return;
  }
#line 232
  if (! layouts) {
    {
#line 233
    Msg(0, (char const   *)((char *)"No layouts defined\n"));
    }
#line 234
    return;
  }
#line 236
  if (where == -1) {
#line 236
    if (display->d_layout) {
#line 237
      where = (display->d_layout)->lay_number;
    }
  }
  {
#line 238
  ss = AddLayoutsInfo((char *)buf, (int )sizeof(buf), where);
#line 239
  __cil_tmp6 = strlen((char const   *)((char *)buf));
#line 239
  s = (char *)buf + __cil_tmp6;
  }
#line 240
  if (ss - (char *)buf > (long )(display->d_width / 2)) {
#line 241
    ss -= display->d_width / 2;
#line 242
    if (s - ss < (long )display->d_width) {
#line 243
      ss = s - display->d_width;
#line 244
      if (ss < (char *)buf) {
#line 245
        ss = (char *)buf;
      }
    }
  } else {
#line 249
    ss = (char *)buf;
  }
  {
#line 250
  Msg(0, (char const   *)((char *)"%s"), ss);
  }
  return;
}
}
#line 253 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
void RemoveLayout(struct layout *lay ) 
{ 
  struct layout **layp ;
  struct layout *tmp ;
  struct layout *tmp___0 ;
  struct canvas *tmp___1 ;

  {
#line 255
  layp = & layouts;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! *layp) {
#line 257
      goto while_break;
    }
#line 258
    if (*layp == lay) {
#line 259
      *layp = lay->lay_next;
#line 260
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  layp = & (*layp)->lay_next;
#line 263
  laytab[lay->lay_number] = (struct layout *)0;
#line 265
  if (display) {
#line 265
    if (display->d_layout == lay) {
#line 266
      display->d_layout = (struct layout *)0;
    }
  }
  {
#line 268
  FreeLayoutCv(& lay->lay_canvas);
  }
#line 270
  if (lay->lay_title) {
    {
#line 271
    free((void *)lay->lay_title);
    }
  }
  {
#line 272
  free((void *)lay);
  }
#line 274
  if (layouts) {
#line 275
    if (display && display->d_layout) {
#line 275
      tmp___0 = display->d_layout;
    } else {
#line 275
      if (*layp) {
#line 275
        tmp = *layp;
      } else {
#line 275
        tmp = layouts;
      }
#line 275
      tmp___0 = tmp;
    }
#line 275
    if (display) {
#line 275
      tmp___1 = & display->d_canvas;
    } else {
#line 275
      tmp___1 = (struct canvas *)0;
    }
    {
#line 275
    LoadLayout(tmp___0, tmp___1);
    }
  }
  {
#line 277
  Activate(0);
  }
  return;
}
}
#line 280 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
void UpdateLayoutCanvas(struct canvas *cv , struct win *wi ) 
{ 
  struct layer *l ;

  {
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! cv) {
#line 282
      goto while_break;
    }
#line 283
    if (cv->c_layer) {
#line 283
      if ((struct win *)((cv->c_layer)->l_bottom)->l_data == wi) {
#line 285
        l = cv->c_layer;
#line 286
        cv->c_layer = (struct layer *)0;
#line 287
        if (l->l_cvlist == (struct canvas *)0) {
#line 287
          if (wi == (struct win *)0) {
            {
            {
#line 288
            KillLayerChain(l);
            }
            }
          } else
#line 287
          if (l != wi->w_savelayer) {
            {
            {
#line 288
            KillLayerChain(l);
            }
            }
          }
        }
#line 290
        l = & cv->c_blank;
#line 291
        l->l_data = (void *)0;
#line 292
        if (l->l_cvlist != cv) {
#line 293
          cv->c_lnext = l->l_cvlist;
#line 294
          l->l_cvlist = cv;
        }
#line 296
        cv->c_layer = l;
      }
    }
#line 300
    if (cv->c_slperp) {
      {
#line 301
      UpdateLayoutCanvas(cv->c_slperp, wi);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  cv = cv->c_slnext;
  return;
}
}
#line 306 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
static void dump_canvas(struct canvas *cv , FILE *file ) 
{ 
  struct canvas *c ;
  char *tmp ;

  {
#line 309
  c = cv->c_slperp;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (c && c->c_slnext)) {
#line 309
      goto while_break;
    }
#line 310
    if (c->c_slorient == 1 << 1) {
#line 310
      tmp = (char *)" -v";
    } else {
#line 310
      tmp = (char *)"";
    }
    {
#line 310
    fprintf(file, (char const   *)((char *)"split%s\n"), tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  c = c->c_slnext;
#line 312
  c = cv->c_slperp;
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    if (! c) {
#line 312
      goto while_break___0;
    }
#line 313
    if (c->c_slperp) {
      {
#line 314
      dump_canvas(c, file);
      }
    } else {
      {
#line 316
      fprintf(file, (char const   *)((char *)"focus\n"));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 312
  c = c->c_slnext;
  return;
}
}
#line 320 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
int LayoutDumpCanvas(struct canvas *cv , char *filename ) 
{ 
  FILE *file ;
  FILE *__cil_tmp4 ;

  {
  {
#line 322
  __cil_tmp4 = secfopen(filename, (char *)"a");
#line 322
  file = __cil_tmp4;
  }
#line 323
  if (! file) {
#line 324
    return (0);
  }
  {
#line 325
  dump_canvas(cv, file);
#line 326
  fclose(file);
  }
#line 327
  return (1);
}
}
#line 330 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
void RenameLayout(struct layout *layout , char const   *name ) 
{ 


  {
  {
#line 332
  free((void *)layout->lay_title);
#line 333
  layout->lay_title = SaveStr(name);
  }
  return;
}
}
#line 336 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layout.c"
int RenumberLayout(struct layout *layout , int number ) 
{ 
  int old ;
  struct layout *lay ;

  {
#line 340
  old = layout->lay_number;
#line 341
  if (number < 0) {
#line 342
    return (0);
  } else
#line 341
  if (number >= 10) {
#line 342
    return (0);
  }
#line 343
  lay = laytab[number];
#line 344
  laytab[number] = layout;
#line 345
  layout->lay_number = number;
#line 346
  laytab[old] = lay;
#line 347
  if (lay) {
#line 348
    lay->lay_number = old;
  }
#line 349
  return (1);
}
}
#line 162 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.h"
void LayerCleanupMemory(struct layer *layer ) ;
#line 69 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.h"
struct canvas *FindCanvas(int x , int y ) ;
#line 71
int AddCanvas(int orient ) ;
#line 72
void RemCanvas(void) ;
#line 73
void OneCanvas(void) ;
#line 78
int CountCanvasPerp(struct canvas *cv ) ;
#line 79
void EqualizeCanvas(struct canvas *cv , int gflag ) ;
#line 80 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void WindowChanged(struct win *p , int what ) ;
#line 144
void WListLinkChanged(void) ;
#line 159
int ReleaseAutoWritelock(struct display *dis , struct win *w ) ;
#line 160
int ObtainAutoWritelock(struct display *d , struct win *w ) ;
#line 272
void RefreshLine(int y , int from , int to , int isblank ) ;
#line 278
void GotoPos(int x2 , int y2 ) ;
#line 336
void evenq(struct event *ev ) ;
#line 337
void evdeq(struct event *ev ) ;
#line 338
void SetTimeout(struct event *ev , int timo ) ;
#line 72 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.h"
void display_windows(int onblank , int order , struct win *group ) ;
#line 36 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
struct win *fore ;
#line 36
struct win *windows ;
#line 37
struct layer *flayer ;
#line 39
struct LayFuncs BlankLf ;
#line 40
extern int focusminwidth ;
#line 40
extern int focusminheight ;
#line 43 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
static void CanvasInitBlank(struct canvas *cv ) 
{ 


  {
#line 46
  cv->c_blank.l_cvlist = cv;
#line 47
  cv->c_blank.l_width = (cv->c_xe - cv->c_xs) + 1;
#line 48
  cv->c_blank.l_height = (cv->c_ye - cv->c_ys) + 1;
#line 49
  cv->c_blank.l_y = 0;
#line 49
  cv->c_blank.l_x = cv->c_blank.l_y;
#line 50
  cv->c_blank.l_layfn = & BlankLf;
#line 51
  cv->c_blank.l_data = (void *)0;
#line 52
  cv->c_blank.l_next = (struct layer *)0;
#line 53
  cv->c_blank.l_bottom = & cv->c_blank;
#line 54
  cv->c_blank.l_blocking = 0;
#line 55
  cv->c_layer = & cv->c_blank;
  return;
}
}
#line 59 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
static void FreePerp(struct canvas *pcv ) 
{ 
  struct canvas *cv ;

  {
#line 64
  if (! pcv->c_slperp) {
#line 65
    return;
  }
#line 66
  cv = pcv->c_slperp;
#line 67
  cv->c_slprev = pcv->c_slprev;
#line 68
  if (cv->c_slprev) {
#line 69
    (cv->c_slprev)->c_slnext = cv;
  }
#line 70
  cv->c_slback = pcv->c_slback;
#line 71
  if (cv->c_slback) {
#line 71
    if ((cv->c_slback)->c_slperp == pcv) {
#line 72
      (cv->c_slback)->c_slperp = cv;
    }
  }
#line 73
  cv->c_slorient = pcv->c_slorient;
#line 74
  cv->c_slweight = pcv->c_slweight;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! cv->c_slnext) {
#line 75
      goto while_break;
    }
#line 77
    cv = cv->c_slnext;
#line 78
    cv->c_slorient = pcv->c_slorient;
#line 79
    cv->c_slback = pcv->c_slback;
#line 80
    cv->c_slweight = pcv->c_slweight;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  cv->c_slnext = pcv->c_slnext;
#line 83
  if (cv->c_slnext) {
#line 84
    (cv->c_slnext)->c_slprev = cv;
  }
  {
#line 85
  LayerCleanupMemory(& pcv->c_blank);
#line 86
  free((void *)pcv);
  }
  return;
}
}
#line 90 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
void FreeCanvas(struct canvas *cv ) 
{ 
  struct viewport *vp ;
  struct viewport *nvp ;
  struct canvas **cvp ;
  struct win *p ;
  struct canvas *tmp ;
  struct win *tmp___2 ;

  {
#line 97
  if (cv->c_slprev) {
#line 98
    (cv->c_slprev)->c_slnext = cv->c_slnext;
  }
#line 99
  if (cv->c_slnext) {
#line 100
    (cv->c_slnext)->c_slprev = cv->c_slprev;
  }
#line 101
  if (cv->c_slback) {
#line 101
    if ((cv->c_slback)->c_slperp == cv) {
#line 102
      if (cv->c_slnext) {
#line 102
        tmp = cv->c_slnext;
      } else {
#line 102
        tmp = cv->c_slprev;
      }
#line 102
      (cv->c_slback)->c_slperp = tmp;
    }
  }
#line 103
  if (cv->c_slperp) {
    {
#line 105
    while (1) {
      while_continue: /* CIL Label */ ;
#line 105
      if (! cv->c_slperp) {
#line 105
        goto while_break;
      }
      {
#line 106
      FreeCanvas(cv->c_slperp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 107
    LayerCleanupMemory(& cv->c_blank);
#line 108
    free((void *)cv);
    }
#line 109
    return;
  }
#line 112
  if (display) {
#line 114
    if (display->d_forecv == cv) {
#line 115
      display->d_forecv = (struct canvas *)0;
    }
#line 118
    cvp = & display->d_cvlist;
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 118
      if (! *cvp) {
#line 118
        goto while_break___0;
      }
#line 119
      if (*cvp == cv) {
#line 121
        *cvp = cv->c_next;
#line 122
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 118
    cvp = & (*cvp)->c_next;
  }
#line 125
  if (cv->c_layer) {
#line 125
    tmp___2 = (struct win *)((cv->c_layer)->l_bottom)->l_data;
  } else {
#line 125
    tmp___2 = (struct win *)0;
  }
  {
#line 125
  p = tmp___2;
#line 126
  SetCanvasWindow(cv, (struct win *)0);
  }
#line 127
  if (p) {
    {
#line 128
    WindowChanged(p, 'u');
    }
  }
#line 129
  if (flayer == cv->c_layer) {
#line 130
    flayer = (struct layer *)0;
  }
#line 131
  vp = cv->c_vplist;
  {
#line 131
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 131
    if (! vp) {
#line 131
      goto while_break___1;
    }
    {
#line 133
    vp->v_canvas = (struct canvas *)0;
#line 134
    nvp = vp->v_next;
#line 135
    vp->v_next = (struct viewport *)0;
#line 136
    free((void *)vp);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 131
  vp = nvp;
#line 138
  evdeq(& cv->c_captev);
#line 139
  LayerCleanupMemory(& cv->c_blank);
#line 140
  free((void *)cv);
  }
  return;
}
}
#line 144 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
int CountCanvas(struct canvas *cv ) 
{ 
  int num ;
  struct canvas *cvp ;
  int nump ;
  int n ;

  {
#line 147
  num = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! cv) {
#line 148
      goto while_break;
    }
#line 150
    if (cv->c_slperp) {
#line 153
      nump = 1;
#line 154
      cvp = cv->c_slperp;
      {
#line 154
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 154
        if (! cvp) {
#line 154
          goto while_break___0;
        }
#line 155
        if (cvp->c_slperp) {
          {
#line 157
          n = CountCanvas(cvp->c_slperp);
          }
#line 158
          if (n > nump) {
#line 159
            nump = n;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 154
      cvp = cvp->c_slnext;
#line 161
      num += nump;
    } else {
#line 164
      num ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  cv = cv->c_slnext;
#line 166
  return (num);
}
}
#line 170 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
int CountCanvasPerp(struct canvas *cv ) 
{ 
  struct canvas *cvp ;
  int num ;
  int n ;

  {
#line 174
  num = 1;
#line 175
  cvp = cv->c_slperp;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! cvp) {
#line 175
      goto while_break;
    }
#line 176
    if (cvp->c_slperp) {
      {
#line 178
      n = CountCanvas(cvp->c_slperp);
      }
#line 179
      if (n > num) {
#line 180
        num = n;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  cvp = cvp->c_slnext;
#line 182
  return (num);
}
}
#line 186 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
struct canvas *FindCanvas(int x , int y ) 
{ 
  struct canvas *cv ;
  struct canvas *mcv ;
  int m ;
  int mm ;
  struct canvas *tmp ;

  {
#line 189
  mcv = (struct canvas *)0;
#line 190
  mm = 0;
#line 192
  cv = display->d_cvlist;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! cv) {
#line 192
      goto while_break;
    }
#line 195
    if (x >= cv->c_xs) {
#line 195
      if (x <= cv->c_xe) {
#line 195
        if (y >= cv->c_ys) {
#line 195
          if (y <= cv->c_ye + 1) {
#line 196
            return (cv);
          }
        }
      }
    }
#line 197
    if (cv == display->d_forecv) {
#line 198
      goto while_continue;
    }
#line 199
    m = 0;
#line 200
    if (x >= (display->d_forecv)->c_xs) {
#line 200
      if (x <= (display->d_forecv)->c_xe) {
#line 202
        if (x < cv->c_xs) {
#line 203
          goto while_continue;
        } else
#line 202
        if (x > cv->c_xe) {
#line 203
          goto while_continue;
        }
#line 204
        if (y < (display->d_forecv)->c_ys) {
#line 204
          if (y < cv->c_ys) {
#line 205
            goto while_continue;
          }
        }
#line 206
        if (y > (display->d_forecv)->c_ye + 1) {
#line 206
          if (y > cv->c_ye + 1) {
#line 207
            goto while_continue;
          }
        }
#line 208
        if (y < cv->c_ys) {
#line 209
          m = cv->c_ys - y;
        }
#line 210
        if (y > cv->c_ye + 1) {
#line 211
          m = y - (cv->c_ye + 1);
        }
      }
    }
#line 213
    if (y >= (display->d_forecv)->c_ys) {
#line 213
      if (y <= (display->d_forecv)->c_ye + 1) {
#line 215
        if (y < cv->c_ys) {
#line 216
          goto while_continue;
        } else
#line 215
        if (y > cv->c_ye + 1) {
#line 216
          goto while_continue;
        }
#line 217
        if (x < (display->d_forecv)->c_xs) {
#line 217
          if (x < cv->c_xs) {
#line 218
            goto while_continue;
          }
        }
#line 219
        if (x > (display->d_forecv)->c_xe) {
#line 219
          if (x > cv->c_xe) {
#line 220
            goto while_continue;
          }
        }
#line 221
        if (x < cv->c_xs) {
#line 222
          m = cv->c_xs - x;
        }
#line 223
        if (x > cv->c_xe) {
#line 224
          m = x - cv->c_xe;
        }
      }
    }
#line 226
    if (m) {
#line 226
      if (! mm) {
#line 228
        mcv = cv;
#line 229
        mm = m;
      } else
#line 226
      if (m < mm) {
#line 228
        mcv = cv;
#line 229
        mm = m;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  cv = cv->c_next;
#line 232
  if (mcv) {
#line 232
    tmp = mcv;
  } else {
#line 232
    tmp = display->d_forecv;
  }
#line 232
  return (tmp);
}
}
#line 236 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
void SetCanvasWindow(struct canvas *cv , struct win *wi ) 
{ 
  struct win *p ;
  struct win **pp ;
  struct layer *l ;
  struct canvas *cvp ;
  struct canvas **cvpp ;
  struct display *d ;
  struct layer *oldflayer ;

  {
#line 240
  p = (struct win *)0;
#line 244
  l = cv->c_layer;
#line 245
  display = cv->c_display;
#line 247
  if (l) {
#line 250
    cvpp = & l->l_cvlist;
    {
#line 250
    while (1) {
      while_continue: /* CIL Label */ ;
#line 250
      if (! cvp) {
#line 250
        goto while_break;
      }
#line 251
      if (cvp == cv) {
#line 252
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 250
    cvpp = & cvp->c_lnext;
    {
#line 253
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 253
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 254
    *cvpp = cvp->c_lnext;
#line 256
    p = (struct win *)(l->l_bottom)->l_data;
#line 257
    l = cv->c_layer;
#line 258
    cv->c_layer = (struct layer *)0;
#line 260
    if (p) {
#line 260
      if (cv == display->d_forecv) {
        {
#line 263
        ReleaseAutoWritelock(display, p);
        }
#line 265
        if (p->w_silence) {
          {
#line 267
          SetTimeout(& p->w_silenceev, p->w_silencewait * 1000);
#line 268
          evenq(& p->w_silenceev);
          }
        }
#line 270
        display->d_other = fore;
#line 271
        display->d_fore = (struct win *)0;
      }
    }
#line 273
    if (l->l_cvlist == (struct canvas *)0) {
#line 273
      if (p == (struct win *)0) {
        {
        {
#line 274
        KillLayerChain(l);
        }
        }
      } else
#line 273
      if (l != p->w_savelayer) {
        {
        {
#line 274
        KillLayerChain(l);
        }
        }
      }
    }
  }
#line 278
  if (wi) {
#line 278
    if (wi->w_type != 3) {
#line 280
      l = & wi->w_layer;
#line 281
      if (wi->w_savelayer) {
#line 281
        if (wi->w_blocked) {
#line 282
          l = wi->w_savelayer;
        } else
#line 281
        if ((wi->w_savelayer)->l_cvlist == (struct canvas *)0) {
#line 282
          l = wi->w_savelayer;
        }
      }
    } else {
#line 278
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 286
    l = & cv->c_blank;
#line 287
    if (wi) {
#line 288
      l->l_data = (void *)((char *)wi);
    } else {
#line 290
      l->l_data = (void *)0;
    }
  }
  {
#line 294
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 294
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 295
  cv->c_lnext = l->l_cvlist;
#line 296
  l->l_cvlist = cv;
#line 297
  cv->c_layer = l;
#line 298
  cv->c_xoff = cv->c_xs;
#line 299
  cv->c_yoff = cv->c_ys;
#line 300
  RethinkViewportOffsets(cv);
  }
#line 302
  if (flayer == (struct layer *)0) {
#line 303
    flayer = l;
  }
#line 305
  if (wi) {
#line 305
    if (wi->w_type == 3) {
      {
#line 308
      d = display;
#line 309
      oldflayer = flayer;
#line 310
      flayer = l;
#line 311
      display_windows(0, 0, wi);
#line 312
      flayer = oldflayer;
#line 313
      display = d;
      }
    }
  }
#line 316
  if (wi) {
#line 316
    if (display->d_other == wi) {
#line 317
      display->d_other = wi->w_next;
    }
  }
#line 318
  if (cv == display->d_forecv) {
#line 320
    display->d_fore = wi;
#line 321
    fore = display->d_fore;
#line 322
    if (wi) {
      {
#line 325
      ObtainAutoWritelock(display, wi);
      }
#line 330
      if (windows != wi) {
#line 332
        pp = & windows;
        {
#line 332
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 332
          if (! p) {
#line 332
            goto while_break___2;
          }
#line 333
          if (p == wi) {
#line 334
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 332
        pp = & p->w_next;
        {
#line 335
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 335
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 336
        *pp = p->w_next;
#line 337
        p->w_next = windows;
#line 338
        windows = p;
#line 339
        WListLinkChanged();
        }
      }
    }
  }
  return;
}
}
#line 346 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
static void cv_winid_fn(struct event *ev , char *data ) 
{ 
  int ox ;
  int oy ;
  struct canvas *cv ;

  {
#line 351
  cv = (struct canvas *)data;
#line 353
  display = cv->c_display;
#line 354
  if (display->d_status == 1) {
    {
#line 356
    SetTimeout(ev, 1);
#line 357
    evenq(ev);
    }
#line 358
    return;
  }
#line 360
  ox = display->d_x;
#line 361
  oy = display->d_y;
#line 362
  if (cv->c_ye + 1 < display->d_height) {
    {
#line 363
    RefreshLine(cv->c_ye + 1, 0, display->d_width - 1, 0);
    }
  }
#line 364
  if (ox != -1) {
#line 364
    if (oy != -1) {
      {
#line 365
      GotoPos(ox, oy);
      }
    }
  }
  return;
}
}
#line 369 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
int MakeDefaultCanvas(void) 
{ 
  struct canvas *cv ;
  void *__cil_tmp2 ;

  {
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  __cil_tmp2 = calloc((unsigned long )1, sizeof(*cv));
#line 374
  cv = (struct canvas *)__cil_tmp2;
  }
#line 374
  if (cv == (struct canvas *)0) {
#line 375
    return (- 1);
  }
#line 376
  cv->c_xs = 0;
#line 377
  cv->c_xe = display->d_width - 1;
#line 378
  cv->c_ys = display->d_has_hstatus == 4;
#line 379
  cv->c_ye = ((display->d_height - 1) - (display->d_has_hstatus == 1)) - captionalways;
  {
#line 380
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 380
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 381
  cv->c_xoff = 0;
#line 382
  cv->c_yoff = 0;
#line 383
  cv->c_next = (struct canvas *)0;
#line 384
  cv->c_display = display;
#line 385
  cv->c_vplist = (struct viewport *)0;
#line 386
  cv->c_slnext = (struct canvas *)0;
#line 387
  cv->c_slprev = (struct canvas *)0;
#line 388
  cv->c_slperp = (struct canvas *)0;
#line 389
  cv->c_slweight = 1;
#line 390
  cv->c_slback = & display->d_canvas;
#line 391
  display->d_canvas.c_slperp = cv;
#line 392
  display->d_canvas.c_xs = cv->c_xs;
#line 393
  display->d_canvas.c_xe = cv->c_xe;
#line 394
  display->d_canvas.c_ys = cv->c_ys;
#line 395
  display->d_canvas.c_ye = cv->c_ye;
#line 396
  cv->c_slorient = 0;
#line 397
  cv->c_captev.type = 0;
#line 398
  cv->c_captev.data = (char *)cv;
#line 399
  cv->c_captev.handler = cv_winid_fn;
#line 401
  CanvasInitBlank(cv);
#line 402
  cv->c_lnext = (struct canvas *)0;
#line 404
  display->d_cvlist = cv;
#line 405
  RethinkDisplayViewports();
#line 406
  display->d_forecv = cv;
  }
#line 407
  return (0);
}
}
#line 411 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
static struct canvas **CreateCanvasChainRec(struct canvas *cv , struct canvas **cvp ) 
{ 


  {
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! cv) {
#line 415
      goto while_break;
    }
#line 417
    if (cv->c_slperp) {
      {
#line 418
      cvp = CreateCanvasChainRec(cv->c_slperp, cvp);
      }
    } else {
#line 421
      *cvp = cv;
#line 422
      cvp = & cv->c_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  cv = cv->c_slnext;
#line 425
  return (cvp);
}
}
#line 429 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
void RecreateCanvasChain(void) 
{ 
  struct canvas **cvp ;

  {
  {
#line 432
  cvp = CreateCanvasChainRec(display->d_canvas.c_slperp, & display->d_cvlist);
#line 433
  *cvp = (struct canvas *)0;
  }
  return;
}
}
#line 437 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
void EqualizeCanvas(struct canvas *cv , int gflag ) 
{ 
  struct canvas *cv2 ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! cv) {
#line 442
      goto while_break;
    }
#line 444
    if (cv->c_slperp) {
#line 444
      if (gflag) {
        {
#line 446
        cv->c_slweight = CountCanvasPerp(cv);
#line 447
        cv2 = cv->c_slperp;
        }
        {
#line 447
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 447
          if (! cv2) {
#line 447
            goto while_break___0;
          }
#line 448
          if (cv2->c_slperp) {
            {
#line 449
            EqualizeCanvas(cv2->c_slperp, gflag);
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 447
        cv2 = cv2->c_slnext;
      } else {
#line 452
        cv->c_slweight = 1;
      }
    } else {
#line 452
      cv->c_slweight = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  cv = cv->c_slnext;
  return;
}
}
#line 457 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
void ResizeCanvas(struct canvas *cv ) 
{ 
  struct canvas *cv2 ;
  struct canvas *cvn ;
  struct canvas *fcv ;
  int nh ;
  int i ;
  int maxi ;
  int hh ;
  int m ;
  int w ;
  int wsum ;
  int need ;
  int got ;
  int xs ;
  int ys ;
  int xe ;
  int ye ;
  int focusmin ;
  int tmp ;
  int __cil_tmp20 ;
  int tmp___3 ;
  int __cil_tmp22 ;
  int tmp___4 ;
  int tmp___5 ;
  int __cil_tmp25 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int __cil_tmp33 ;
  int tmp___11 ;
  int tmp___12 ;
  int hx ;

  {
#line 464
  focusmin = 0;
#line 466
  xs = cv->c_xs;
#line 467
  ys = cv->c_ys;
#line 468
  xe = cv->c_xe;
#line 469
  ye = cv->c_ye;
#line 470
  cv = cv->c_slperp;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 472
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 472
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 473
  if (cv == (struct canvas *)0) {
#line 474
    return;
  }
#line 475
  if (cv->c_slorient == 0) {
    {
#line 477
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 477
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 478
    cv->c_xs = xs;
#line 479
    cv->c_xe = xe;
#line 480
    cv->c_ys = ys;
#line 481
    cv->c_ye = ye;
#line 482
    cv->c_xoff = cv->c_xs;
#line 483
    cv->c_yoff = cv->c_ys;
#line 484
    cv->c_blank.l_width = (cv->c_xe - cv->c_xs) + 1;
#line 485
    cv->c_blank.l_height = (cv->c_ye - cv->c_ys) + 1;
#line 486
    return;
  }
#line 489
  fcv = (struct canvas *)0;
#line 490
  if (focusminwidth) {
    _L: /* CIL Label */ 
    {
#line 492
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 492
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 493
    cv2 = display->d_forecv;
    {
#line 494
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 494
      if (! cv2->c_slback) {
#line 494
        goto while_break___3;
      }
#line 496
      if (cv2->c_slback == cv->c_slback) {
#line 498
        fcv = cv2;
#line 499
        if (cv->c_slorient == 1) {
#line 499
          tmp = focusminheight;
        } else {
#line 499
          tmp = focusminwidth;
        }
#line 499
        focusmin = tmp;
#line 500
        if (focusmin > 0) {
#line 501
          __cil_tmp20 = focusmin;
#line 501
          focusmin --;
        } else
#line 502
        if (focusmin < 0) {
#line 503
          if (cv->c_slorient == 1) {
#line 503
            tmp___3 = (ye - ys) + 2;
          } else {
#line 503
            tmp___3 = (xe - xs) + 2;
          }
#line 503
          focusmin = tmp___3;
        }
        {
#line 504
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 504
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 506
      cv2 = cv2->c_slback;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 490
  if (focusminheight) {
#line 490
    goto _L;
  }
#line 509
  if (focusmin) {
    {
#line 511
    __cil_tmp22 = CountCanvas(cv);
#line 511
    m = __cil_tmp22 * 2;
    }
#line 512
    if (cv->c_slorient == 1) {
#line 512
      tmp___4 = (ye - ys) + 2;
    } else {
#line 512
      tmp___4 = (xe - xs) + 2;
    }
#line 512
    nh = tmp___4;
#line 513
    nh -= m;
#line 514
    if (nh < 0) {
#line 515
      nh = 0;
    }
#line 516
    if (focusmin > nh) {
#line 517
      focusmin = nh;
    }
    {
#line 518
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 518
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 522
  wsum = 0;
#line 522
  cv2 = cv;
  {
#line 522
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 522
    if (! cv2) {
#line 522
      goto while_break___6;
    }
    {
#line 524
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 524
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 525
    wsum += cv2->c_slweight;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 522
  cv2 = cv2->c_slnext;
  {
#line 527
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 527
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 528
  if (wsum == 0) {
#line 529
    wsum = 1;
  }
#line 530
  w = wsum;
#line 533
  if (cv->c_slorient == 1) {
#line 533
    tmp___5 = (ye - ys) + 2;
  } else {
#line 533
    tmp___5 = (xe - xs) + 2;
  }
#line 533
  nh = tmp___5;
#line 534
  got = 0;
#line 534
  need = got;
#line 534
  cv2 = cv;
  {
#line 534
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 534
    if (! cv2) {
#line 534
      goto while_break___9;
    }
#line 536
    if (cv2->c_slperp) {
      {
#line 536
      __cil_tmp25 = CountCanvasPerp(cv2);
#line 536
      tmp___6 = __cil_tmp25 * 2 - 1;
      }
    } else {
#line 536
      tmp___6 = 1;
    }
#line 536
    m = tmp___6;
#line 537
    if (cv2 == fcv) {
#line 538
      m += focusmin;
    }
#line 539
    if (cv2->c_slweight) {
#line 539
      tmp___7 = (nh * cv2->c_slweight) / w;
    } else {
#line 539
      tmp___7 = 0;
    }
#line 539
    hh = tmp___7;
#line 540
    w -= cv2->c_slweight;
#line 541
    nh -= hh;
    {
#line 542
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 542
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 543
    if (hh <= m + 1) {
#line 544
      need += (m + 1) - hh;
    } else {
#line 546
      got += (hh - m) - 1;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 534
  cv2 = cv2->c_slnext;
  {
#line 548
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 548
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 549
  if (need > got) {
#line 550
    need = got;
  }
#line 553
  if (cv->c_slorient == 1) {
#line 553
    tmp___8 = (ye - ys) + 2;
  } else {
#line 553
    tmp___8 = (xe - xs) + 2;
  }
#line 553
  nh = tmp___8;
#line 554
  if (cv->c_slorient == 1) {
#line 554
    tmp___9 = ys;
  } else {
#line 554
    tmp___9 = xs;
  }
#line 554
  i = tmp___9;
#line 555
  if (cv->c_slorient == 1) {
#line 555
    tmp___10 = ye;
  } else {
#line 555
    tmp___10 = xe;
  }
#line 555
  maxi = tmp___10;
#line 556
  w = wsum;
  {
#line 557
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 557
    if (! cv) {
#line 557
      goto while_break___12;
    }
#line 559
    cvn = cv->c_slnext;
#line 560
    if (i > maxi) {
#line 562
      if (cv->c_slprev) {
#line 562
        if (! (cv->c_slback)->c_slback) {
#line 562
          if (! (cv->c_slprev)->c_slperp) {
#line 562
            if (! (cv->c_slprev)->c_slprev) {
#line 564
              (cv->c_slprev)->c_slorient = 0;
#line 565
              if (! captionalways) {
#line 567
                ((cv->c_slback)->c_ye) ++;
#line 568
                ((cv->c_slprev)->c_ye) ++;
              }
            }
          }
        }
      }
      {
#line 571
      SetCanvasWindow(cv, (struct win *)0);
#line 572
      FreeCanvas(cv);
      }
#line 573
      goto while_continue___12;
    }
#line 575
    if (cv->c_slperp) {
      {
#line 575
      __cil_tmp33 = CountCanvasPerp(cv);
#line 575
      tmp___11 = __cil_tmp33 * 2 - 1;
      }
    } else {
#line 575
      tmp___11 = 1;
    }
#line 575
    m = tmp___11;
#line 576
    if (cv == fcv) {
#line 577
      m += focusmin;
    }
#line 578
    if (cv->c_slweight) {
#line 578
      tmp___12 = (nh * cv->c_slweight) / w;
    } else {
#line 578
      tmp___12 = 0;
    }
#line 578
    hh = tmp___12;
#line 579
    w -= cv->c_slweight;
#line 580
    nh -= hh;
    {
#line 581
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 581
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 582
    if (hh <= m + 1) {
#line 584
      hh = m + 1;
      {
#line 585
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 585
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    } else {
#line 589
      hx = 1;
#line 590
      if (got != 0) {
#line 591
        hx = (need * ((hh - m) - 1)) / got;
      } else {
        {
#line 593
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 593
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      {
#line 595
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 595
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 596
      got -= (hh - m) - 1;
#line 597
      hh -= hx;
#line 598
      need -= hx;
      {
#line 599
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 599
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
    {
#line 601
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 601
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 603
    if (i + hh > maxi + 2) {
#line 605
      hh = (maxi + 2) - i;
      {
#line 606
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 606
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
    }
#line 608
    if (i + hh == maxi + 1) {
#line 610
      hh ++;
      {
#line 611
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 611
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
#line 613
    if (cv->c_slorient == 1) {
#line 615
      cv->c_xs = xs;
#line 616
      cv->c_xe = xe;
#line 617
      cv->c_ys = i;
#line 618
      cv->c_ye = (i + hh) - 2;
#line 619
      cv->c_xoff = xs;
#line 620
      cv->c_yoff = i;
    } else {
#line 624
      cv->c_xs = i;
#line 625
      cv->c_xe = (i + hh) - 2;
#line 626
      cv->c_ys = ys;
#line 627
      cv->c_ye = ye;
#line 628
      cv->c_xoff = i;
#line 629
      cv->c_yoff = ys;
    }
#line 631
    cv->c_xoff = cv->c_xs;
#line 632
    cv->c_yoff = cv->c_ys;
#line 633
    cv->c_blank.l_width = (cv->c_xe - cv->c_xs) + 1;
#line 634
    cv->c_blank.l_height = (cv->c_ye - cv->c_ys) + 1;
#line 635
    if (cv->c_slperp) {
      {
#line 637
      ResizeCanvas(cv);
      }
#line 638
      if (! (cv->c_slperp)->c_slnext) {
        {
#line 640
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 640
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
        {
#line 641
        FreePerp(cv->c_slperp);
#line 642
        FreePerp(cv);
        }
      }
    }
#line 645
    i += hh;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 557
  cv = cvn;
  return;
}
}
#line 650 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
static struct canvas *AddPerp(struct canvas *cv ) 
{ 
  struct canvas *pcv ;
  void *__cil_tmp3 ;

  {
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 656
  __cil_tmp3 = calloc((unsigned long )1, sizeof(*cv));
#line 656
  pcv = (struct canvas *)__cil_tmp3;
  }
#line 656
  if (pcv == (struct canvas *)0) {
#line 657
    return ((struct canvas *)0);
  }
#line 658
  pcv->c_next = (struct canvas *)0;
#line 659
  pcv->c_display = cv->c_display;
#line 660
  pcv->c_slnext = cv->c_slnext;
#line 661
  pcv->c_slprev = cv->c_slprev;
#line 662
  pcv->c_slperp = cv;
#line 663
  pcv->c_slback = cv->c_slback;
#line 664
  if (cv->c_slback) {
#line 664
    if ((cv->c_slback)->c_slperp == cv) {
#line 665
      (cv->c_slback)->c_slperp = pcv;
    }
  }
#line 666
  pcv->c_slorient = cv->c_slorient;
#line 667
  pcv->c_xoff = 0;
#line 668
  pcv->c_yoff = 0;
#line 669
  pcv->c_xs = cv->c_xs;
#line 670
  pcv->c_xe = cv->c_xe;
#line 671
  pcv->c_ys = cv->c_ys;
#line 672
  pcv->c_ye = cv->c_ye;
#line 673
  if (pcv->c_slnext) {
#line 674
    (pcv->c_slnext)->c_slprev = pcv;
  }
#line 675
  if (pcv->c_slprev) {
#line 676
    (pcv->c_slprev)->c_slnext = pcv;
  }
  {
#line 677
  pcv->c_slweight = cv->c_slweight;
#line 678
  CanvasInitBlank(pcv);
#line 679
  cv->c_slweight = 1;
#line 680
  cv->c_slnext = (struct canvas *)0;
#line 681
  cv->c_slprev = (struct canvas *)0;
#line 682
  cv->c_slperp = (struct canvas *)0;
#line 683
  cv->c_slback = pcv;
#line 684
  cv->c_slorient = 0;
  }
#line 685
  return (pcv);
}
}
#line 689 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
int AddCanvas(int orient ) 
{ 
  struct canvas *cv ;
  int xs ;
  int xe ;
  int ys ;
  int ye ;
  int h ;
  int num ;
  struct canvas *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  void *__cil_tmp12 ;

  {
#line 696
  cv = display->d_forecv;
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
#line 697
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 699
  if (cv->c_slorient != 0) {
#line 699
    if (cv->c_slorient != orient) {
      {
#line 700
      __cil_tmp9 = AddPerp(cv);
      }
#line 700
      if (! __cil_tmp9) {
#line 701
        return (- 1);
      }
    }
  }
#line 703
  cv = display->d_forecv;
#line 704
  xs = (cv->c_slback)->c_xs;
#line 705
  xe = (cv->c_slback)->c_xe;
#line 706
  ys = (cv->c_slback)->c_ys;
#line 707
  ye = (cv->c_slback)->c_ye;
#line 708
  if (! captionalways) {
#line 708
    if (cv == display->d_canvas.c_slperp) {
#line 708
      if (! cv->c_slnext) {
#line 709
        __cil_tmp10 = ye;
#line 709
        ye --;
      }
    }
  }
  {
#line 710
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 710
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 711
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 711
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 713
  __cil_tmp11 = CountCanvas((cv->c_slback)->c_slperp);
#line 713
  num = __cil_tmp11 + 1;
  }
  {
#line 714
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 714
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 715
  if (orient == 1) {
#line 716
    h = (ye - ys) + 1;
  } else {
#line 718
    h = (xe - xs) + 1;
  }
#line 720
  h -= 2 * num - 1;
#line 721
  if (h < 0) {
#line 722
    return (- 1);
  }
  {
#line 724
  __cil_tmp12 = calloc((unsigned long )1, sizeof(*cv));
#line 724
  cv = (struct canvas *)__cil_tmp12;
  }
#line 724
  if (cv == (struct canvas *)0) {
#line 725
    return (- 1);
  }
#line 727
  ((display->d_forecv)->c_slback)->c_ye = ye;
#line 728
  (display->d_forecv)->c_slorient = orient;
#line 729
  cv->c_slnext = (display->d_forecv)->c_slnext;
#line 730
  cv->c_slprev = display->d_forecv;
#line 731
  (display->d_forecv)->c_slnext = cv;
#line 732
  if (cv->c_slnext) {
#line 733
    (cv->c_slnext)->c_slprev = cv;
  }
  {
#line 734
  cv->c_slorient = orient;
#line 735
  cv->c_slback = (display->d_forecv)->c_slback;
#line 737
  cv->c_xs = xs;
#line 738
  cv->c_xe = xe;
#line 739
  cv->c_ys = ys;
#line 740
  cv->c_ye = ye;
#line 741
  cv->c_xoff = 0;
#line 742
  cv->c_yoff = 0;
#line 743
  cv->c_display = display;
#line 744
  cv->c_vplist = (struct viewport *)0;
#line 745
  cv->c_captev.type = 0;
#line 746
  cv->c_captev.data = (char *)cv;
#line 747
  cv->c_captev.handler = cv_winid_fn;
#line 749
  CanvasInitBlank(cv);
#line 750
  cv->c_lnext = (struct canvas *)0;
#line 752
  cv->c_next = (struct canvas *)0;
#line 754
  cv = cv->c_slback;
#line 755
  EqualizeCanvas(cv->c_slperp, 0);
#line 756
  ResizeCanvas(cv);
#line 757
  RecreateCanvasChain();
#line 758
  RethinkDisplayViewports();
#line 759
  ResizeLayersToCanvases();
  }
#line 760
  return (0);
}
}
#line 764 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
void RemCanvas(void) 
{ 
  int ye ;
  struct canvas *cv ;
  struct canvas *tmp ;

  {
  {
#line 769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 769
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  cv = display->d_forecv;
#line 771
  ye = (cv->c_slback)->c_ye;
#line 772
  if (cv->c_slorient == 0) {
#line 773
    return;
  }
  {
#line 774
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 774
    if (! cv->c_slprev) {
#line 774
      goto while_break___0;
    }
#line 775
    cv = cv->c_slprev;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 776
  if (! cv->c_slnext) {
#line 777
    return;
  }
#line 778
  if (! (cv->c_slnext)->c_slnext) {
#line 778
    if ((cv->c_slback)->c_slback) {
#line 781
      cv = display->d_forecv;
      {
#line 782
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 782
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 783
      if (cv->c_slprev) {
#line 783
        tmp = cv->c_slprev;
      } else {
#line 783
        tmp = cv->c_slnext;
      }
      {
#line 783
      FreePerp(tmp);
#line 784
      FreePerp(cv->c_slback);
      }
    }
  }
#line 787
  cv = display->d_forecv;
#line 788
  display->d_forecv = cv->c_slprev;
#line 789
  if (! display->d_forecv) {
#line 790
    display->d_forecv = cv->c_slnext;
  }
  {
#line 791
  FreeCanvas(cv);
#line 793
  cv = display->d_forecv;
  }
  {
#line 794
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 794
    if (! (display->d_forecv)->c_slperp) {
#line 794
      goto while_break___2;
    }
#line 795
    display->d_forecv = (display->d_forecv)->c_slperp;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 798
  if (! cv->c_slnext) {
#line 798
    if (! cv->c_slprev) {
#line 798
      if (! (cv->c_slback)->c_slback) {
#line 798
        if (! cv->c_slperp) {
#line 800
          cv->c_slorient = 0;
#line 801
          if (! captionalways) {
#line 802
            ye ++;
#line 802
            (cv->c_slback)->c_ye = ye;
          }
        }
      }
    }
  }
  {
#line 804
  cv = cv->c_slback;
#line 805
  EqualizeCanvas(cv->c_slperp, 0);
#line 806
  ResizeCanvas(cv);
#line 808
  display->d_fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
#line 809
  flayer = (display->d_forecv)->c_layer;
#line 811
  RecreateCanvasChain();
#line 812
  RethinkDisplayViewports();
#line 813
  ResizeLayersToCanvases();
  }
  return;
}
}
#line 817 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
void OneCanvas(void) 
{ 
  struct canvas *cv ;
  struct canvas *ocv ;

  {
#line 819
  cv = display->d_forecv;
#line 819
  ocv = (struct canvas *)0;
#line 821
  if (cv->c_slprev) {
#line 823
    ocv = cv->c_slprev;
#line 824
    (cv->c_slprev)->c_slnext = cv->c_slnext;
  }
#line 826
  if (cv->c_slnext) {
#line 828
    ocv = cv->c_slnext;
#line 829
    (cv->c_slnext)->c_slprev = cv->c_slprev;
  }
#line 831
  if (! ocv) {
#line 832
    return;
  }
#line 833
  if (cv->c_slback) {
#line 833
    if ((cv->c_slback)->c_slperp == cv) {
#line 834
      (cv->c_slback)->c_slperp = ocv;
    }
  }
#line 835
  cv->c_slorient = 0;
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! display->d_canvas.c_slperp) {
#line 836
      goto while_break;
    }
    {
#line 837
    FreeCanvas(display->d_canvas.c_slperp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  cv = display->d_forecv;
#line 839
  display->d_canvas.c_slperp = cv;
#line 840
  cv->c_slback = & display->d_canvas;
#line 841
  cv->c_slnext = (struct canvas *)0;
#line 842
  cv->c_slprev = (struct canvas *)0;
  {
#line 843
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 843
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 844
  if (! captionalways) {
#line 845
    (display->d_canvas.c_ye) ++;
  }
  {
#line 846
  ResizeCanvas(& display->d_canvas);
#line 847
  RecreateCanvasChain();
#line 848
  RethinkDisplayViewports();
#line 849
  ResizeLayersToCanvases();
  }
  return;
}
}
#line 853 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
void DupLayoutCv(struct canvas *cvf , struct canvas *cvt , int save ) 
{ 
  struct win *p ;
  struct win *tmp ;
  struct layer *tmp___11 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    if (! cvf) {
#line 857
      goto while_break;
    }
#line 859
    cvt->c_slorient = cvf->c_slorient;
#line 860
    cvt->c_slweight = cvf->c_slweight;
#line 861
    if (cvf == display->d_forecv) {
#line 862
      display->d_forecv = cvt;
    }
#line 863
    if (! save) {
#line 865
      cvt->c_display = display;
#line 866
      if (! cvf->c_slperp) {
#line 868
        cvt->c_captev.type = 0;
#line 869
        cvt->c_captev.data = (char *)cvt;
#line 870
        cvt->c_captev.handler = cv_winid_fn;
#line 871
        cvt->c_blank.l_cvlist = (struct canvas *)0;
#line 872
        cvt->c_blank.l_layfn = & BlankLf;
#line 873
        cvt->c_blank.l_bottom = & cvt->c_blank;
      }
#line 875
      cvt->c_layer = cvf->c_layer;
    } else {
#line 879
      if (cvf->c_layer) {
#line 879
        tmp = (struct win *)((cvf->c_layer)->l_bottom)->l_data;
      } else {
#line 879
        tmp = (struct win *)0;
      }
#line 879
      p = tmp;
#line 880
      if (p) {
#line 880
        tmp___11 = & p->w_layer;
      } else {
#line 880
        tmp___11 = (struct layer *)0;
      }
#line 880
      cvt->c_layer = tmp___11;
    }
#line 882
    if (cvf->c_slperp) {
      {
#line 884
      __cil_tmp7 = calloc((unsigned long )1, sizeof(struct canvas ));
#line 884
      cvt->c_slperp = (struct canvas *)__cil_tmp7;
#line 885
      (cvt->c_slperp)->c_slback = cvt;
#line 886
      CanvasInitBlank(cvt->c_slperp);
#line 887
      DupLayoutCv(cvf->c_slperp, cvt->c_slperp, save);
      }
    }
#line 889
    if (cvf->c_slnext) {
      {
#line 891
      __cil_tmp8 = calloc((unsigned long )1, sizeof(struct canvas ));
#line 891
      cvt->c_slnext = (struct canvas *)__cil_tmp8;
#line 892
      (cvt->c_slnext)->c_slprev = cvt;
#line 893
      (cvt->c_slnext)->c_slback = cvt->c_slback;
#line 894
      CanvasInitBlank(cvt->c_slnext);
      }
    }
#line 896
    cvf = cvf->c_slnext;
#line 897
    cvt = cvt->c_slnext;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 902 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.c"
void PutWindowCv(struct canvas *cv ) 
{ 
  struct win *p ;
  struct win *tmp ;

  {
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 906
    if (! cv) {
#line 906
      goto while_break;
    }
#line 908
    if (cv->c_slperp) {
      {
#line 910
      PutWindowCv(cv->c_slperp);
      }
#line 911
      goto while_continue;
    }
#line 913
    if (cv->c_layer) {
#line 913
      tmp = (struct win *)(cv->c_layer)->l_data;
    } else {
#line 913
      tmp = (struct win *)0;
    }
    {
#line 913
    p = tmp;
#line 914
    cv->c_layer = (struct layer *)0;
#line 915
    SetCanvasWindow(cv, p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 906
  cv = cv->c_slnext;
  return;
}
}
#line 549 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 74 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void SetCharsets(struct win *p , char *s ) ;
#line 305
void Resize_obuf(void) ;
#line 461
void ExitOverlayPage(void) ;
#line 483
void InitBuiltinTabs(void) ;
#line 484
struct mchar *recode_mchar(struct mchar *mc , int from , int to ) ;
#line 485
struct mline *recode_mline(struct mline *ml , int w , int from , int to ) ;
#line 486
int FromUtf8(int c , int *utf8charp ) ;
#line 487
void AddUtf8(int c ) ;
#line 488
int ToUtf8(char *p , int c ) ;
#line 489
int ToUtf8_comb(char *p , int c ) ;
#line 490
int utf8_isdouble(int c ) ;
#line 491
int utf8_iscomb(int c ) ;
#line 492
void utf8_handle_comb(int c , struct mchar *mc ) ;
#line 493
int ContainsSpecialDeffont(struct mline *ml , int xs , int xe , int encoding ) ;
#line 494
int LoadFontTranslation(int font , char *file ) ;
#line 495
void LoadFontTranslationsForEncoding(int encoding ) ;
#line 497
void WinSwitchEncoding(struct win *p , int encoding ) ;
#line 498
int FindEncoding(char *name ) ;
#line 499
char *EncodingName(int encoding ) ;
#line 500
int EncodingDefFont(int encoding ) ;
#line 501
void ResetEncoding(struct win *p ) ;
#line 502
int CanEncodeFont(int encoding , int f ) ;
#line 503
int DecodeChar(int c , int encoding , int *statep ) ;
#line 504
int RecodeBuf(unsigned char *fbuf , int flen , int fenc , int tenc , unsigned char *tbuf ) ;
#line 506
int PrepareEncodedChar(int c ) ;
#line 509
int EncodeChar(char *bp , int c , int encoding , int *fontp ) ;
#line 32 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
unsigned char *null ;
#line 33
struct display *displays ;
#line 36
char *screenencodings ;
#line 39
int cjkwidth ;
#line 42
static int encmatch(char *s1 , char *s2 ) ;
#line 44
static int recode_char(int c , int to_utf , int font ) ;
#line 45
static int recode_char_to_encoding(int c , int encoding ) ;
#line 46
static void comb_tofront(int root , int i ) ;
#line 48
static int recode_char_dw(int c , int *c2p , int to_utf , int font ) ;
#line 49
static int recode_char_dw_to_encoding(int c , int *c2p , int encoding ) ;
#line 66 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
struct encoding encodings[]  = 
#line 66
  {      {(char *)"C", (char *)0, 0, 0, 0, (char *)0}, 
        {(char *)"eucJP", (char *)"B\002I\00401", 0, 1, 0, (char *)"\002\004I"}, 
        {(char *)"SJIS", (char *)"BIBB01", 0, 1, 1, (char *)"\002I"}, 
        {(char *)"eucKR", (char *)"B\003BB01", 0, 1, 0, (char *)"\003"}, 
        {(char *)"eucCN", (char *)"B\001BB01", 0, 1, 0, (char *)"\001"}, 
        {(char *)"Big5", (char *)"B\030BB01", 0, 1, 0, (char *)"\030"}, 
        {(char *)"KOI8-R", (char *)0, 161, 0, 1, (char *)0}, 
        {(char *)"CP1251", (char *)0, 191, 0, 1, (char *)0}, 
        {(char *)"UTF-8", (char *)0, - 1, 0, 0, (char *)0}, 
        {(char *)"ISO8859-2", (char *)0, 194, 0, 0, (char *)0}, 
        {(char *)"ISO8859-3", (char *)0, 195, 0, 0, (char *)0}, 
        {(char *)"ISO8859-4", (char *)0, 196, 0, 0, (char *)0}, 
        {(char *)"ISO8859-5", (char *)0, 204, 0, 0, (char *)0}, 
        {(char *)"ISO8859-6", (char *)0, 199, 0, 0, (char *)0}, 
        {(char *)"ISO8859-7", (char *)0, 198, 0, 0, (char *)0}, 
        {(char *)"ISO8859-8", (char *)0, 200, 0, 0, (char *)0}, 
        {(char *)"ISO8859-9", (char *)0, 205, 0, 0, (char *)0}, 
        {(char *)"ISO8859-10", (char *)0, 214, 0, 0, (char *)0}, 
        {(char *)"ISO8859-15", (char *)0, 226, 0, 0, (char *)0}, 
        {(char *)"jis", (char *)0, 0, 0, 0, (char *)"\002\004I"}, 
        {(char *)"GBK", (char *)"B\031BB01", 226, 1, 1, (char *)"\031"}};
#line 92 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
static unsigned short builtin_tabs[][2]  = 
#line 92
  { {        (unsigned short )48,        (unsigned short )0}, 
   {        (unsigned short )95,        (unsigned short )9646}, 
   {        (unsigned short )96,        (unsigned short )9670}, 
   {        (unsigned short )97,        (unsigned short )9618}, 
   {        (unsigned short )98,        (unsigned short )9225}, 
   {        (unsigned short )99,        (unsigned short )9228}, 
   {        (unsigned short )100,        (unsigned short )9229}, 
   {        (unsigned short )101,        (unsigned short )9226}, 
   {        (unsigned short )102,        (unsigned short )176}, 
   {        (unsigned short )103,        (unsigned short )177}, 
   {        (unsigned short )104,        (unsigned short )9252}, 
   {        (unsigned short )105,        (unsigned short )9227}, 
   {        (unsigned short )106,        (unsigned short )9496}, 
   {        (unsigned short )107,        (unsigned short )9488}, 
   {        (unsigned short )108,        (unsigned short )9484}, 
   {        (unsigned short )109,        (unsigned short )9492}, 
   {        (unsigned short )110,        (unsigned short )9532}, 
   {        (unsigned short )111,        (unsigned short )9146}, 
   {        (unsigned short )112,        (unsigned short )9147}, 
   {        (unsigned short )113,        (unsigned short )9472}, 
   {        (unsigned short )114,        (unsigned short )9148}, 
   {        (unsigned short )115,        (unsigned short )9149}, 
   {        (unsigned short )116,        (unsigned short )9500}, 
   {        (unsigned short )117,        (unsigned short )9508}, 
   {        (unsigned short )118,        (unsigned short )9524}, 
   {        (unsigned short )119,        (unsigned short )9516}, 
   {        (unsigned short )120,        (unsigned short )9474}, 
   {        (unsigned short )121,        (unsigned short )8804}, 
   {        (unsigned short )122,        (unsigned short )8805}, 
   {        (unsigned short )123,        (unsigned short )960}, 
   {        (unsigned short )124,        (unsigned short )8800}, 
   {        (unsigned short )125,        (unsigned short )163}, 
   {        (unsigned short )126,        (unsigned short )183}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )52,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )163}, 
   {        (unsigned short )64,        (unsigned short )190}, 
   {        (unsigned short )91,        (unsigned short )255}, 
   {        (unsigned short )92,        (unsigned short )189}, 
   {        (unsigned short )93,        (unsigned short )124}, 
   {        (unsigned short )123,        (unsigned short )168}, 
   {        (unsigned short )124,        (unsigned short )102}, 
   {        (unsigned short )125,        (unsigned short )188}, 
   {        (unsigned short )126,        (unsigned short )180}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )53,        (unsigned short )0}, 
   {        (unsigned short )91,        (unsigned short )196}, 
   {        (unsigned short )92,        (unsigned short )214}, 
   {        (unsigned short )93,        (unsigned short )197}, 
   {        (unsigned short )94,        (unsigned short )220}, 
   {        (unsigned short )96,        (unsigned short )233}, 
   {        (unsigned short )123,        (unsigned short )228}, 
   {        (unsigned short )124,        (unsigned short )246}, 
   {        (unsigned short )125,        (unsigned short )229}, 
   {        (unsigned short )126,        (unsigned short )252}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )54,        (unsigned short )0}, 
   {        (unsigned short )64,        (unsigned short )196}, 
   {        (unsigned short )91,        (unsigned short )198}, 
   {        (unsigned short )92,        (unsigned short )216}, 
   {        (unsigned short )93,        (unsigned short )197}, 
   {        (unsigned short )94,        (unsigned short )220}, 
   {        (unsigned short )96,        (unsigned short )228}, 
   {        (unsigned short )123,        (unsigned short )230}, 
   {        (unsigned short )124,        (unsigned short )248}, 
   {        (unsigned short )125,        (unsigned short )229}, 
   {        (unsigned short )126,        (unsigned short )252}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )55,        (unsigned short )0}, 
   {        (unsigned short )64,        (unsigned short )201}, 
   {        (unsigned short )91,        (unsigned short )196}, 
   {        (unsigned short )92,        (unsigned short )214}, 
   {        (unsigned short )93,        (unsigned short )197}, 
   {        (unsigned short )94,        (unsigned short )220}, 
   {        (unsigned short )96,        (unsigned short )233}, 
   {        (unsigned short )123,        (unsigned short )228}, 
   {        (unsigned short )124,        (unsigned short )246}, 
   {        (unsigned short )125,        (unsigned short )229}, 
   {        (unsigned short )126,        (unsigned short )252}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )61,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )249}, 
   {        (unsigned short )64,        (unsigned short )224}, 
   {        (unsigned short )91,        (unsigned short )233}, 
   {        (unsigned short )92,        (unsigned short )231}, 
   {        (unsigned short )93,        (unsigned short )234}, 
   {        (unsigned short )94,        (unsigned short )238}, 
   {        (unsigned short )95,        (unsigned short )232}, 
   {        (unsigned short )96,        (unsigned short )244}, 
   {        (unsigned short )123,        (unsigned short )228}, 
   {        (unsigned short )124,        (unsigned short )246}, 
   {        (unsigned short )125,        (unsigned short )252}, 
   {        (unsigned short )126,        (unsigned short )251}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )65,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )163}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )75,        (unsigned short )0}, 
   {        (unsigned short )64,        (unsigned short )167}, 
   {        (unsigned short )91,        (unsigned short )196}, 
   {        (unsigned short )92,        (unsigned short )214}, 
   {        (unsigned short )93,        (unsigned short )220}, 
   {        (unsigned short )123,        (unsigned short )228}, 
   {        (unsigned short )124,        (unsigned short )246}, 
   {        (unsigned short )125,        (unsigned short )252}, 
   {        (unsigned short )126,        (unsigned short )223}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )81,        (unsigned short )0}, 
   {        (unsigned short )64,        (unsigned short )224}, 
   {        (unsigned short )91,        (unsigned short )226}, 
   {        (unsigned short )92,        (unsigned short )231}, 
   {        (unsigned short )93,        (unsigned short )234}, 
   {        (unsigned short )94,        (unsigned short )238}, 
   {        (unsigned short )96,        (unsigned short )244}, 
   {        (unsigned short )123,        (unsigned short )233}, 
   {        (unsigned short )124,        (unsigned short )249}, 
   {        (unsigned short )125,        (unsigned short )232}, 
   {        (unsigned short )126,        (unsigned short )251}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )82,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )163}, 
   {        (unsigned short )64,        (unsigned short )224}, 
   {        (unsigned short )91,        (unsigned short )176}, 
   {        (unsigned short )92,        (unsigned short )231}, 
   {        (unsigned short )93,        (unsigned short )167}, 
   {        (unsigned short )123,        (unsigned short )233}, 
   {        (unsigned short )124,        (unsigned short )249}, 
   {        (unsigned short )125,        (unsigned short )232}, 
   {        (unsigned short )126,        (unsigned short )168}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )89,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )163}, 
   {        (unsigned short )64,        (unsigned short )167}, 
   {        (unsigned short )91,        (unsigned short )176}, 
   {        (unsigned short )92,        (unsigned short )231}, 
   {        (unsigned short )93,        (unsigned short )233}, 
   {        (unsigned short )96,        (unsigned short )249}, 
   {        (unsigned short )123,        (unsigned short )224}, 
   {        (unsigned short )124,        (unsigned short )242}, 
   {        (unsigned short )125,        (unsigned short )232}, 
   {        (unsigned short )126,        (unsigned short )236}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )90,        (unsigned short )0}, 
   {        (unsigned short )35,        (unsigned short )163}, 
   {        (unsigned short )64,        (unsigned short )167}, 
   {        (unsigned short )91,        (unsigned short )161}, 
   {        (unsigned short )92,        (unsigned short )209}, 
   {        (unsigned short )93,        (unsigned short )191}, 
   {        (unsigned short )123,        (unsigned short )176}, 
   {        (unsigned short )124,        (unsigned short )241}, 
   {        (unsigned short )125,        (unsigned short )231}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )226,        (unsigned short )0}, 
   {        (unsigned short )164,        (unsigned short )8364}, 
   {        (unsigned short )166,        (unsigned short )352}, 
   {        (unsigned short )168,        (unsigned short )353}, 
   {        (unsigned short )180,        (unsigned short )381}, 
   {        (unsigned short )184,        (unsigned short )382}, 
   {        (unsigned short )188,        (unsigned short )338}, 
   {        (unsigned short )189,        (unsigned short )339}, 
   {        (unsigned short )190,        (unsigned short )376}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )74,        (unsigned short )0}, 
   {        (unsigned short )92,        (unsigned short )165}, 
   {        (unsigned short )126,        (unsigned short )8254}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )73,        (unsigned short )0}, 
   {        (unsigned short )33,        (unsigned short )65377}, 
   {        (unsigned short )32863,        (unsigned short )65439}, 
   {        (unsigned short )0,        (unsigned short )0}, 
   {        (unsigned short )0,        (unsigned short )0}};
#line 291
static struct recodetab recodetabs[256] ;
#line 294 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
void InitBuiltinTabs(void) 
{ 
  unsigned short (*p)[2] ;

  {
#line 297
  p = (unsigned short (*)[2])builtin_tabs;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! (*p)[0]) {
#line 297
      goto while_break;
    }
#line 299
    recodetabs[(*p)[0]].flags = 2;
#line 300
    recodetabs[(*p)[0]].tab = p + 1;
#line 301
    p ++;
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 302
      if (! (*p)[0]) {
#line 302
        goto while_break___0;
      }
#line 303
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  p ++;
  return;
}
}
#line 308 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
static int recode_char(int c , int to_utf , int font ) 
{ 
  int f ;
  unsigned short (*p)[2] ;
  int tmp ;
  int tmp___12 ;

  {
#line 314
  if (to_utf) {
#line 316
    if (c < 256) {
#line 317
      return (c);
    }
#line 318
    f = (c >> 8) & 255;
#line 319
    c &= 255;
    {
#line 323
    if (f == 'C') {
#line 323
      goto case_67;
    }
#line 326
    if (f == 'E') {
#line 326
      goto case_69;
    }
#line 329
    if (f == 'H') {
#line 329
      goto case_72;
    }
#line 332
    goto switch_default;
    case_67: /* CIL Label */ 
#line 324
    f ^= 118;
#line 325
    goto switch_break;
    case_69: /* CIL Label */ 
#line 327
    f ^= 115;
#line 328
    goto switch_break;
    case_72: /* CIL Label */ 
#line 330
    f ^= 127;
#line 331
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 333
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 335
    p = recodetabs[f].tab;
#line 336
    if (p == (unsigned short (*)[2])0) {
#line 336
      if (recodetabs[f].flags == 0) {
        {
#line 338
        LoadFontTranslation(f, (char *)0);
#line 339
        p = recodetabs[f].tab;
        }
      }
    }
#line 341
    if (p) {
      {
#line 342
      while (1) {
        while_continue: /* CIL Label */ ;
#line 342
        if (! (*p)[0]) {
#line 342
          goto while_break;
        }
#line 344
        if ((int )(*(p + 0))[0] & 32768) {
#line 344
          if (c <= ((int )(*(p + 0))[0] & 32767)) {
#line 344
            if (c >= (int )(*(p + -1))[0]) {
#line 345
              return ((c - (int )(*(p + -1))[0]) + (int )(*(p + -1))[1]);
            }
          }
        }
#line 346
        if ((int )(*p)[0] == c) {
#line 347
          return ((int )(*p)[1]);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 342
      p ++;
    }
#line 349
    return (c & 255);
  }
#line 351
  if (font == -1) {
#line 353
    if (c < 256) {
#line 354
      return (c);
    }
#line 355
    font = 32;
    {
#line 355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 355
      if (! (font < 128)) {
#line 355
        goto while_break___0;
      }
#line 357
      p = recodetabs[font].tab;
#line 358
      if (p) {
        {
#line 359
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 359
          if (! (*p)[1]) {
#line 359
            goto while_break___1;
          }
#line 361
          if ((int )(*(p + 0))[0] & 32768) {
#line 361
            if (c <= (int )(*(p + 0))[1]) {
#line 361
              if (c >= (int )(*(p + -1))[1]) {
#line 362
                return (((c - (int )(*(p + -1))[1]) + (int )(*(p + -1))[0]) | (font << 8));
              }
            }
          }
#line 363
          if ((int )(*p)[1] == c) {
#line 364
            return ((int )(*p)[0] | (font << 8));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 359
        p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 355
    font ++;
#line 367
    return ('?');
  }
#line 369
  if (c < 128) {
#line 369
    if ((font & 128) != 0) {
#line 370
      return (c);
    }
  }
#line 371
  if (font >= 32) {
#line 373
    p = recodetabs[font].tab;
#line 374
    if (p == (unsigned short (*)[2])0) {
#line 374
      if (recodetabs[font].flags == 0) {
        {
#line 376
        LoadFontTranslation(font, (char *)0);
#line 377
        p = recodetabs[font].tab;
        }
      }
    }
#line 379
    if (p) {
      {
#line 380
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 380
        if (! (*p)[1]) {
#line 380
          goto while_break___2;
        }
#line 382
        if ((int )(*(p + 0))[0] & 32768) {
#line 382
          if (c <= (int )(*(p + 0))[1]) {
#line 382
            if (c >= (int )(*(p + -1))[1]) {
#line 383
              if (font & 128) {
#line 383
                tmp = 0;
              } else {
#line 383
                tmp = font << 8;
              }
#line 383
              return (((c - (int )(*(p + -1))[1]) + (int )(*(p + -1))[0]) | tmp);
            }
          }
        }
#line 384
        if ((int )(*p)[1] == c) {
#line 385
          if (font & 128) {
#line 385
            tmp___12 = 0;
          } else {
#line 385
            tmp___12 = font << 8;
          }
#line 385
          return ((int )(*p)[0] | tmp___12);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 380
      p ++;
    }
  }
#line 388
  return (- 1);
}
}
#line 394 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
static int recode_char_dw(int c , int *c2p , int to_utf , int font ) 
{ 
  int f ;
  unsigned short (*p)[2] ;
  int __cil_tmp7 ;

  {
#line 400
  if (to_utf) {
#line 402
    f = (c >> 8) & 255;
#line 403
    c = ((c & 255) << 8) | (*c2p & 255);
#line 404
    *c2p = 65535;
#line 405
    p = recodetabs[f].tab;
#line 406
    if (p == (unsigned short (*)[2])0) {
#line 406
      if (recodetabs[f].flags == 0) {
        {
#line 408
        LoadFontTranslation(f, (char *)0);
#line 409
        p = recodetabs[f].tab;
        }
      }
    }
#line 411
    if (p) {
      {
#line 412
      while (1) {
        while_continue: /* CIL Label */ ;
#line 412
        if (! (*p)[0]) {
#line 412
          goto while_break;
        }
#line 413
        if ((int )(*p)[0] == c) {
          {
#line 416
          __cil_tmp7 = utf8_isdouble((int )(*p)[1]);
          }
#line 416
          if (! __cil_tmp7) {
#line 417
            *c2p = ' ';
          }
#line 419
          return ((int )(*p)[1]);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 412
      p ++;
    }
#line 421
    return (65311);
  }
#line 423
  if (font == -1) {
#line 425
    font = 0;
    {
#line 425
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 425
      if (! (font < 24)) {
#line 425
        goto while_break___0;
      }
#line 427
      p = recodetabs[font].tab;
#line 428
      if (p) {
        {
#line 429
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 429
          if (! (*p)[1]) {
#line 429
            goto while_break___1;
          }
#line 430
          if ((int )(*p)[1] == c) {
#line 432
            *c2p = (((int )(*p)[0] & 255) | (font << 8)) | 32768;
#line 433
            return (((int )(*p)[0] >> 8) | (font << 8));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 429
        p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 425
    font ++;
#line 436
    *c2p = '?';
#line 437
    return ('?');
  }
#line 439
  if (font < 32) {
#line 441
    p = recodetabs[font].tab;
#line 442
    if (p == (unsigned short (*)[2])0) {
#line 442
      if (recodetabs[font].flags == 0) {
        {
#line 444
        LoadFontTranslation(font, (char *)0);
#line 445
        p = recodetabs[font].tab;
        }
      }
    }
#line 447
    if (p) {
      {
#line 448
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 448
        if (! (*p)[1]) {
#line 448
          goto while_break___2;
        }
#line 449
        if ((int )(*p)[1] == c) {
#line 451
          *c2p = (((int )(*p)[0] & 255) | (font << 8)) | 32768;
#line 452
          return (((int )(*p)[0] >> 8) | (font << 8));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 448
      p ++;
    }
  }
#line 455
  return (- 1);
}
}
#line 460 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
static int recode_char_to_encoding(int c , int encoding ) 
{ 
  char *fp ;
  int x ;
  int __cil_tmp5 ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp9 ;

  {
#line 466
  if (encoding == 8) {
    {
#line 467
    __cil_tmp5 = recode_char(c, 1, - 1);
    }
#line 467
    return (__cil_tmp5);
  }
#line 468
  fp = encodings[encoding].fontlist;
#line 468
  if (fp != (char *)0) {
    {
#line 469
    while (1) {
      while_continue: /* CIL Label */ ;
#line 469
      if (! *fp) {
#line 469
        goto while_break;
      }
      {
#line 470
      __cil_tmp6 = fp;
#line 470
      fp ++;
#line 470
      __cil_tmp7 = recode_char(c, 0, (int )((unsigned char )*__cil_tmp6));
#line 470
      x = __cil_tmp7;
      }
#line 470
      if (x != -1) {
#line 471
        return (x);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 472
  if (encodings[encoding].deffont) {
    {
#line 473
    x = recode_char(c, 0, encodings[encoding].deffont);
    }
#line 473
    if (x != -1) {
#line 474
      return (x);
    }
  }
  {
#line 475
  __cil_tmp9 = recode_char(c, 0, - 1);
  }
#line 475
  return (__cil_tmp9);
}
}
#line 480 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
static int recode_char_dw_to_encoding(int c , int *c2p , int encoding ) 
{ 
  char *fp ;
  int x ;
  int __cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp10 ;

  {
#line 486
  if (encoding == 8) {
    {
#line 487
    __cil_tmp6 = recode_char_dw(c, c2p, 1, - 1);
    }
#line 487
    return (__cil_tmp6);
  }
#line 488
  fp = encodings[encoding].fontlist;
#line 488
  if (fp != (char *)0) {
    {
#line 489
    while (1) {
      while_continue: /* CIL Label */ ;
#line 489
      if (! *fp) {
#line 489
        goto while_break;
      }
      {
#line 490
      __cil_tmp7 = fp;
#line 490
      fp ++;
#line 490
      __cil_tmp8 = recode_char_dw(c, c2p, 0, (int )((unsigned char )*__cil_tmp7));
#line 490
      x = __cil_tmp8;
      }
#line 490
      if (x != -1) {
#line 491
        return (x);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 492
  if (encodings[encoding].deffont) {
    {
#line 493
    x = recode_char_dw(c, c2p, 0, encodings[encoding].deffont);
    }
#line 493
    if (x != -1) {
#line 494
      return (x);
    }
  }
  {
#line 495
  __cil_tmp10 = recode_char_dw(c, c2p, 0, - 1);
  }
#line 495
  return (__cil_tmp10);
}
}
#line 501 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
struct mchar *recode_mchar(struct mchar *mc , int from , int to ) 
{ 
  static struct mchar rmc ;
  int c ;
  int c2 ;

  {
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  if (from == to) {
#line 510
    return (mc);
  } else
#line 509
  if (from != 8) {
#line 509
    if (to != 8) {
#line 510
      return (mc);
    }
  }
#line 511
  rmc = *mc;
#line 512
  if ((int )rmc.font == 0) {
#line 512
    if (from != 8) {
#line 513
      rmc.font = (unsigned char )encodings[from].deffont;
    }
  }
#line 514
  if ((int )rmc.font == 0) {
#line 515
    return (mc);
  }
#line 516
  c = (int )rmc.image | ((int )rmc.font << 8);
#line 517
  if (from == 8) {
#line 518
    c |= (int )rmc.fontx << 16;
  }
#line 520
  if (rmc.mbcs) {
    {
#line 522
    c2 = (int )rmc.mbcs;
#line 523
    c = recode_char_dw_to_encoding(c, & c2, to);
#line 524
    rmc.mbcs = (unsigned char )c2;
    }
  } else {
    {
#line 528
    c = recode_char_to_encoding(c, to);
    }
  }
#line 529
  rmc.image = (unsigned char )(c & 255);
#line 530
  rmc.font = (unsigned char )((c >> 8) & 255);
#line 531
  if (to == 8) {
#line 532
    rmc.fontx = (unsigned char )((c >> 16) & 255);
  }
#line 533
  return (& rmc);
}
}
#line 537 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
struct mline *recode_mline(struct mline *ml , int w , int from , int to ) 
{ 
  static int maxlen ;
  static int last ;
  static struct mline rml[2] ;
  static struct mline *rl ;
  int i ;
  int c ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  int __cil_tmp24 ;
  int c2 ;

  {
#line 547
  if (from == to) {
#line 548
    return (ml);
  } else
#line 547
  if (from != 8) {
#line 547
    if (to != 8) {
#line 548
      return (ml);
    } else {
#line 547
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 547
  if (w == 0) {
#line 548
    return (ml);
  }
#line 549
  if (ml->font == null) {
#line 549
    if (ml->fontx == null) {
#line 549
      if (encodings[from].deffont == 0) {
#line 550
        return (ml);
      }
    }
  }
#line 551
  if (w > maxlen) {
#line 553
    i = 0;
    {
#line 553
    while (1) {
      while_continue: /* CIL Label */ ;
#line 553
      if (! (i < 2)) {
#line 553
        goto while_break;
      }
#line 555
      if (rml[i].image == (unsigned char *)0) {
        {
#line 556
        __cil_tmp11 = malloc((unsigned long )w);
#line 556
        rml[i].image = (unsigned char *)__cil_tmp11;
        }
      } else {
        {
#line 558
        __cil_tmp12 = realloc((void *)rml[i].image, (unsigned long )w);
#line 558
        rml[i].image = (unsigned char *)__cil_tmp12;
        }
      }
#line 559
      if (rml[i].font == (unsigned char *)0) {
        {
#line 560
        __cil_tmp13 = malloc((unsigned long )w);
#line 560
        rml[i].font = (unsigned char *)__cil_tmp13;
        }
      } else {
        {
#line 562
        __cil_tmp14 = realloc((void *)rml[i].font, (unsigned long )w);
#line 562
        rml[i].font = (unsigned char *)__cil_tmp14;
        }
      }
#line 563
      if (rml[i].fontx == (unsigned char *)0) {
        {
#line 564
        __cil_tmp15 = malloc((unsigned long )w);
#line 564
        rml[i].fontx = (unsigned char *)__cil_tmp15;
        }
      } else {
        {
#line 566
        __cil_tmp16 = realloc((void *)rml[i].fontx, (unsigned long )w);
#line 566
        rml[i].fontx = (unsigned char *)__cil_tmp16;
        }
      }
#line 567
      if (rml[i].image == (unsigned char *)0) {
#line 569
        maxlen = 0;
#line 570
        return (ml);
      } else
#line 567
      if (rml[i].font == (unsigned char *)0) {
#line 569
        maxlen = 0;
#line 570
        return (ml);
      } else
#line 567
      if (rml[i].fontx == (unsigned char *)0) {
#line 569
        maxlen = 0;
#line 570
        return (ml);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 553
    i ++;
#line 573
    maxlen = w;
  }
  {
#line 576
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 576
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 577
  i = 0;
  {
#line 577
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 577
    if (! (i < w)) {
#line 577
      goto while_break___1;
    }
    {
#line 578
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 578
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 577
  i ++;
  {
#line 579
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 579
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 580
  i = 0;
  {
#line 580
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 580
    if (! (i < w)) {
#line 580
      goto while_break___4;
    }
    {
#line 581
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 581
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 580
  i ++;
  {
#line 582
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 582
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 583
  i = 0;
  {
#line 583
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 583
    if (! (i < w)) {
#line 583
      goto while_break___7;
    }
    {
#line 584
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 584
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 583
  i ++;
  {
#line 585
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 585
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 586
  i = 0;
  {
#line 586
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 586
    if (! (i < w)) {
#line 586
      goto while_break___10;
    }
    {
#line 587
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 587
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 586
  i ++;
  {
#line 588
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 588
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 589
  i = 0;
  {
#line 589
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 589
    if (! (i < w)) {
#line 589
      goto while_break___13;
    }
    {
#line 590
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 590
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 589
  i ++;
  {
#line 591
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 591
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 592
  i = 0;
  {
#line 592
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 592
    if (! (i < w)) {
#line 592
      goto while_break___16;
    }
    {
#line 593
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 593
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 592
  i ++;
  {
#line 594
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 594
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 596
  rl = (struct mline *)rml + last;
#line 597
  rl->attr = ml->attr;
#line 599
  rl->color = ml->color;
#line 604
  i = 0;
  {
#line 604
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 604
    if (! (i < w)) {
#line 604
      goto while_break___19;
    }
#line 606
    c = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 607
    if (from == 8) {
#line 608
      c |= (int )*(ml->fontx + i) << 16;
    }
#line 609
    if (from != 8) {
#line 609
      if (c < 256) {
#line 610
        c |= encodings[from].deffont << 8;
      }
    }
    {
#line 612
    __cil_tmp24 = utf8_isdouble(c);
    }
#line 612
    if (from != 8) {
#line 612
      if ((c & 7936) != 0) {
#line 612
        if ((c & 57344) == 0) {
          _L___13: /* CIL Label */ 
#line 614
          if (i + 1 == w) {
#line 615
            c = '?';
          } else {
            {
#line 619
            i ++;
#line 620
            c2 = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 621
            c = recode_char_dw_to_encoding(c, & c2, to);
            }
#line 622
            if (to == 8) {
#line 623
              *(rl->fontx + (i - 1)) = (unsigned char )((c >> 16) & 255);
            }
#line 624
            *(rl->font + (i - 1)) = (unsigned char )((c >> 8) & 255);
#line 625
            *(rl->image + (i - 1)) = (unsigned char )(c & 255);
#line 626
            c = c2;
          }
        } else {
#line 612
          goto _L___14;
        }
      } else {
#line 612
        goto _L___14;
      }
    } else
    _L___14: /* CIL Label */ 
#line 612
    if (from == 8) {
#line 612
      if (__cil_tmp24) {
#line 612
        goto _L___13;
      } else {
        {
        {
#line 631
        c = recode_char_to_encoding(c, to);
        }
        }
      }
    } else {
      {
      {
#line 631
      c = recode_char_to_encoding(c, to);
      }
      }
    }
#line 632
    *(rl->image + i) = (unsigned char )(c & 255);
#line 633
    *(rl->font + i) = (unsigned char )((c >> 8) & 255);
#line 634
    if (to == 8) {
#line 635
      *(rl->fontx + i) = (unsigned char )((c >> 16) & 255);
    }
  }
  while_break___19: /* CIL Label */ ;
  }
#line 604
  i ++;
#line 637
  last ^= 1;
  {
#line 638
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 638
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 639
  i = 0;
  {
#line 639
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 639
    if (! (i < w)) {
#line 639
      goto while_break___21;
    }
    {
#line 640
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 640
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
  }
  while_break___21: /* CIL Label */ ;
  }
#line 639
  i ++;
  {
#line 641
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 641
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 642
  i = 0;
  {
#line 642
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 642
    if (! (i < w)) {
#line 642
      goto while_break___24;
    }
    {
#line 643
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 643
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
  }
  while_break___24: /* CIL Label */ ;
  }
#line 642
  i ++;
  {
#line 644
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 644
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 645
  i = 0;
  {
#line 645
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 645
    if (! (i < w)) {
#line 645
      goto while_break___27;
    }
    {
#line 646
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 646
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
  }
  while_break___27: /* CIL Label */ ;
  }
#line 645
  i ++;
  {
#line 647
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 647
    goto while_break___29;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 648
  i = 0;
  {
#line 648
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 648
    if (! (i < w)) {
#line 648
      goto while_break___30;
    }
    {
#line 649
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 649
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
  }
  while_break___30: /* CIL Label */ ;
  }
#line 648
  i ++;
  {
#line 650
  while (1) {
    while_continue___32: /* CIL Label */ ;
#line 650
    goto while_break___32;
  }
  while_break___32: /* CIL Label */ ;
  }
#line 651
  i = 0;
  {
#line 651
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 651
    if (! (i < w)) {
#line 651
      goto while_break___33;
    }
    {
#line 652
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 652
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
  }
  while_break___33: /* CIL Label */ ;
  }
#line 651
  i ++;
  {
#line 653
  while (1) {
    while_continue___35: /* CIL Label */ ;
#line 653
    goto while_break___35;
  }
  while_break___35: /* CIL Label */ ;
  }
#line 654
  i = 0;
  {
#line 654
  while (1) {
    while_continue___36: /* CIL Label */ ;
#line 654
    if (! (i < w)) {
#line 654
      goto while_break___36;
    }
    {
#line 655
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 655
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
  }
  while_break___36: /* CIL Label */ ;
  }
#line 654
  i ++;
  {
#line 656
  while (1) {
    while_continue___38: /* CIL Label */ ;
#line 656
    goto while_break___38;
  }
  while_break___38: /* CIL Label */ ;
  }
#line 657
  return (rl);
}
}
#line 666
struct combchar **combchars ;
#line 669 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
void AddUtf8(int c ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 673
  if (c >= 55296) {
#line 673
    if (c < 57344) {
#line 673
      if (combchars) {
#line 673
        if (*(combchars + (c - 55296))) {
          {
#line 675
          AddUtf8((int )(*(combchars + (c - 55296)))->c1);
#line 676
          c = (int )(*(combchars + (c - 55296)))->c2;
          }
        }
      }
    }
  }
#line 678
  if (c >= 65536) {
#line 680
    if (c >= 2097152) {
      {
#line 682
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 682
        (display->d_obuffree) --;
#line 682
        if (display->d_obuffree <= 0) {
          {
#line 682
          Resize_obuf();
          }
        }
#line 682
        __cil_tmp2 = display->d_obufp;
#line 682
        (display->d_obufp) ++;
#line 682
        *__cil_tmp2 = (char )(((c & 50331648) >> 12) ^ 248);
#line 682
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 683
      c = (c & 16777215) ^ (112 << 18);
    }
    {
#line 685
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 685
      (display->d_obuffree) --;
#line 685
      if (display->d_obuffree <= 0) {
        {
#line 685
        Resize_obuf();
        }
      }
#line 685
      __cil_tmp3 = display->d_obufp;
#line 685
      (display->d_obufp) ++;
#line 685
      *__cil_tmp3 = (char )(((c & 33292288) >> 18) ^ 240);
#line 685
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 686
    c = (c & 262143) ^ (96 << 12);
  }
#line 688
  if (c >= 2048) {
    {
#line 690
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 690
      (display->d_obuffree) --;
#line 690
      if (display->d_obuffree <= 0) {
        {
#line 690
        Resize_obuf();
        }
      }
#line 690
      __cil_tmp4 = display->d_obufp;
#line 690
      (display->d_obufp) ++;
#line 690
      *__cil_tmp4 = (char )(((c & 520192) >> 12) ^ 224);
#line 690
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 691
    c = (c & 4095) ^ (64 << 6);
  }
#line 693
  if (c >= 128) {
    {
#line 695
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 695
      (display->d_obuffree) --;
#line 695
      if (display->d_obuffree <= 0) {
        {
#line 695
        Resize_obuf();
        }
      }
#line 695
      __cil_tmp5 = display->d_obufp;
#line 695
      (display->d_obufp) ++;
#line 695
      *__cil_tmp5 = (char )(((c & 8128) >> 6) ^ 192);
#line 695
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 696
    c = (c & 63) | 128;
  }
  {
#line 698
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 698
    (display->d_obuffree) --;
#line 698
    if (display->d_obuffree <= 0) {
      {
#line 698
      Resize_obuf();
      }
    }
#line 698
    __cil_tmp6 = display->d_obufp;
#line 698
    (display->d_obufp) ++;
#line 698
    *__cil_tmp6 = (char )c;
#line 698
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  return;
}
}
#line 702 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int ToUtf8_comb(char *p , int c ) 
{ 
  int l ;
  char *tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 708
  if (c >= 55296) {
#line 708
    if (c < 57344) {
#line 708
      if (combchars) {
#line 708
        if (*(combchars + (c - 55296))) {
          {
#line 710
          l = ToUtf8_comb(p, (int )(*(combchars + (c - 55296)))->c1);
          }
#line 711
          if (p) {
#line 711
            tmp = p + l;
          } else {
#line 711
            tmp = (char *)0;
          }
          {
#line 711
          __cil_tmp6 = ToUtf8(tmp, (int )(*(combchars + (c - 55296)))->c2);
          }
#line 711
          return (l + __cil_tmp6);
        }
      }
    }
  }
  {
#line 713
  __cil_tmp7 = ToUtf8(p, c);
  }
#line 713
  return (__cil_tmp7);
}
}
#line 717 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int ToUtf8(char *p , int c ) 
{ 
  int l ;
  char *__cil_tmp4 ;
  char *__cil_tmp6 ;
  char *__cil_tmp8 ;
  char *__cil_tmp10 ;
  char *__cil_tmp12 ;

  {
#line 721
  l = 1;
#line 722
  if (c >= 65536) {
#line 724
    if (c >= 2097152) {
#line 726
      if (p) {
#line 727
        __cil_tmp4 = p;
#line 727
        p ++;
#line 727
        *__cil_tmp4 = (char )(((c & 50331648) >> 12) ^ 248);
      }
#line 728
      l ++;
#line 729
      c = (c & 16777215) ^ (112 << 18);
    }
#line 731
    if (p) {
#line 732
      __cil_tmp6 = p;
#line 732
      p ++;
#line 732
      *__cil_tmp6 = (char )(((c & 33292288) >> 18) ^ 240);
    }
#line 733
    l ++;
#line 734
    c = (c & 262143) ^ (96 << 12);
  }
#line 736
  if (c >= 2048) {
#line 738
    if (p) {
#line 739
      __cil_tmp8 = p;
#line 739
      p ++;
#line 739
      *__cil_tmp8 = (char )(((c & 520192) >> 12) ^ 224);
    }
#line 740
    l ++;
#line 741
    c = (c & 4095) | 4096;
  }
#line 743
  if (c >= 128) {
#line 745
    if (p) {
#line 746
      __cil_tmp10 = p;
#line 746
      p ++;
#line 746
      *__cil_tmp10 = (char )(((c & 8128) >> 6) ^ 192);
    }
#line 747
    l ++;
#line 748
    c = (c & 63) | 128;
  }
#line 750
  if (p) {
#line 751
    __cil_tmp12 = p;
#line 751
    p ++;
#line 751
    *__cil_tmp12 = (char )c;
  }
#line 752
  return (l);
}
}
#line 762 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int FromUtf8(int c , int *utf8charp ) 
{ 
  int utf8char ;
  int tmp ;

  {
#line 765
  utf8char = *utf8charp;
#line 766
  if (utf8char) {
#line 768
    if ((c & 192) != 128) {
#line 770
      *utf8charp = 0;
#line 771
      return (- 2);
    } else {
#line 774
      c = (c & 63) | (utf8char << 6);
    }
#line 775
    if (! (utf8char & 1073741824)) {
#line 778
      if (((unsigned int )c & 2181571552U) == 2147483648U) {
#line 779
        c = (int )4261412863U;
      } else
#line 780
      if ((c & 34087408) == 33554432) {
#line 781
        c = (int )4294443007U;
      } else
#line 782
      if ((c & 532728) == 524288) {
#line 783
        c = (int )4294955008U;
      } else
#line 784
      if ((c & 8316) == 8192) {
#line 785
        c = (int )4294967152U;
      }
    }
  } else
#line 791
  if (c >= 254) {
#line 792
    c = 65533;
  } else
#line 793
  if (c >= 252) {
#line 794
    c = (int )((unsigned int )(c & 1) | 3221225468U);
  } else
#line 795
  if (c >= 248) {
#line 796
    c = (int )((unsigned int )(c & 3) | 3221225216U);
  } else
#line 797
  if (c >= 240) {
#line 798
    c = (int )((unsigned int )(c & 7) | 3221209088U);
  } else
#line 799
  if (c >= 224) {
#line 800
    c = (int )((unsigned int )(c & 15) | 3220176896U);
  } else
#line 801
  if (c >= 194) {
#line 802
    c = (int )((unsigned int )(c & 31) | 4227858432U);
  } else
#line 803
  if (c >= 192) {
#line 804
    c = (int )4261412863U;
  } else
#line 805
  if (c >= 128) {
#line 806
    c = 65533;
  }
#line 808
  if ((unsigned int )c & 2147483648U) {
#line 808
    tmp = c;
  } else {
#line 808
    tmp = 0;
  }
#line 808
  utf8char = tmp;
#line 808
  *utf8charp = utf8char;
#line 809
  if (utf8char) {
#line 810
    return (- 1);
  }
#line 815
  if ((unsigned int )c & 4286578688U) {
#line 816
    c = 65533;
  }
#line 818
  if (c >= 55296) {
#line 818
    if (c <= 57343) {
#line 819
      c = 65533;
    } else
#line 818
    if (c == 65534) {
#line 819
      c = 65533;
    } else
#line 818
    if (c == 65535) {
#line 819
      c = 65533;
    }
  }
#line 820
  return (c);
}
}
#line 825 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
void WinSwitchEncoding(struct win *p , int encoding ) 
{ 
  int i ;
  int j ;
  int c ;
  struct mline *ml ;
  struct display *d ;
  struct canvas *cv ;
  struct layer *oldflayer ;
  struct mline *tmp ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int c2 ;
  void *__cil_tmp16 ;
  void *__cil_tmp18 ;

  {
#line 835
  if ((p->w_layer.l_encoding == 8) == (encoding == 8)) {
#line 837
    p->w_layer.l_encoding = encoding;
#line 838
    return;
  }
#line 840
  oldflayer = flayer;
#line 841
  d = displays;
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;
#line 841
    if (! d) {
#line 841
      goto while_break;
    }
#line 842
    cv = d->d_cvlist;
    {
#line 842
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 842
      if (! cv) {
#line 842
        goto while_break___0;
      }
#line 843
      if (p == (struct win *)((cv->c_layer)->l_bottom)->l_data) {
#line 845
        flayer = cv->c_layer;
        {
#line 846
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 846
          if (! flayer->l_next) {
#line 846
            goto while_break___1;
          }
#line 848
          if (oldflayer == flayer) {
#line 849
            oldflayer = flayer->l_next;
          }
          {
#line 850
          ExitOverlayPage();
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 842
    cv = cv->c_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 841
  d = d->d_next;
#line 853
  flayer = oldflayer;
#line 854
  j = 0;
  {
#line 854
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 854
    if (! (j < p->w_layer.l_height + p->w_histheight)) {
#line 854
      goto while_break___2;
    }
#line 857
    if (j < p->w_layer.l_height) {
#line 857
      tmp = & *(p->w_mlines + j);
    } else {
#line 857
      tmp = & *(p->w_hlines + (j - p->w_layer.l_height));
    }
#line 857
    ml = tmp;
#line 861
    if (ml->font == null) {
#line 861
      if (ml->fontx == (unsigned char *)0) {
#line 861
        if (encodings[p->w_layer.l_encoding].deffont == 0) {
#line 862
          goto while_continue___2;
        }
      }
    }
#line 863
    i = 0;
    {
#line 863
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 863
      if (! (i < p->w_layer.l_width)) {
#line 863
        goto while_break___3;
      }
#line 865
      c = (int )*(ml->image + i) | ((int )*(ml->font + i) << 8);
#line 866
      if (p->w_layer.l_encoding == 8) {
#line 867
        c |= (int )*(ml->fontx + i) << 16;
      }
#line 868
      if (p->w_layer.l_encoding != 8) {
#line 868
        if (c < 256) {
#line 869
          c |= encodings[p->w_layer.l_encoding].deffont << 8;
        }
      }
#line 870
      if (c < 256) {
#line 871
        goto while_continue___3;
      }
#line 872
      if (ml->font == null) {
        {
#line 874
        __cil_tmp11 = calloc((unsigned long )(p->w_layer.l_width + 1), (unsigned long )1);
#line 874
        ml->font = (unsigned char *)__cil_tmp11;
        }
#line 874
        if (ml->font == (unsigned char *)0) {
#line 876
          ml->font = null;
#line 877
          goto while_break___3;
        }
      }
      {
#line 881
      __cil_tmp12 = utf8_isdouble(c);
      }
#line 881
      if (p->w_layer.l_encoding != 8) {
#line 881
        if ((c & 7936) != 0) {
#line 881
          if ((c & 57344) == 0) {
            _L: /* CIL Label */ 
#line 883
            if (i + 1 == p->w_layer.l_width) {
#line 884
              c = '?';
            } else {
              {
#line 888
              i ++;
#line 889
              c2 = ((int )*(ml->image + i) | ((int )*(ml->font + i) << 8)) | ((int )*(ml->fontx + i) << 16);
#line 890
              c = recode_char_dw_to_encoding(c, & c2, encoding);
              }
#line 891
              if (encoding == 8) {
#line 893
                if (c > 65536) {
#line 893
                  if (ml->fontx == null) {
                    {
#line 895
                    __cil_tmp16 = calloc((unsigned long )(p->w_layer.l_width + 1),
                                         (unsigned long )1);
#line 895
                    ml->fontx = (unsigned char *)__cil_tmp16;
                    }
#line 895
                    if (ml->fontx == (unsigned char *)0) {
#line 897
                      ml->fontx = null;
#line 898
                      goto while_break___3;
                    }
                  }
                }
#line 901
                *(ml->fontx + (i - 1)) = (unsigned char )((c >> 16) & 255);
              } else {
#line 904
                ml->fontx = null;
              }
#line 905
              *(ml->font + (i - 1)) = (unsigned char )((c >> 8) & 255);
#line 906
              *(ml->image + (i - 1)) = (unsigned char )(c & 255);
#line 907
              c = c2;
            }
          } else {
#line 881
            goto _L___16;
          }
        } else {
#line 881
          goto _L___16;
        }
      } else
      _L___16: /* CIL Label */ 
#line 881
      if (p->w_layer.l_encoding == 8) {
#line 881
        if (__cil_tmp12) {
#line 881
          goto _L;
        } else {
          {
          {
#line 912
          c = recode_char_to_encoding(c, encoding);
          }
          }
        }
      } else {
        {
        {
#line 912
        c = recode_char_to_encoding(c, encoding);
        }
        }
      }
#line 913
      *(ml->image + i) = (unsigned char )(c & 255);
#line 914
      *(ml->font + i) = (unsigned char )((c >> 8) & 255);
#line 915
      if (encoding == 8) {
#line 917
        if (c > 65536) {
#line 917
          if (ml->fontx == null) {
            {
#line 919
            __cil_tmp18 = calloc((unsigned long )(p->w_layer.l_width + 1), (unsigned long )1);
#line 919
            ml->fontx = (unsigned char *)__cil_tmp18;
            }
#line 919
            if (ml->fontx == (unsigned char *)0) {
#line 921
              ml->fontx = null;
#line 922
              goto while_break___3;
            }
          }
        }
#line 925
        *(ml->fontx + i) = (unsigned char )((c >> 16) & 255);
      } else {
#line 928
        ml->fontx = null;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 863
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 854
  j ++;
#line 931
  p->w_layer.l_encoding = encoding;
#line 932
  return;
}
}
#line 942 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
static int bisearch(int ucs , struct interval *table , int max ) 
{ 
  int min ;
  int mid ;

  {
#line 943
  min = 0;
#line 946
  if (ucs < (table + 0)->first) {
#line 947
    return (0);
  } else
#line 946
  if (ucs > (table + max)->last) {
#line 947
    return (0);
  }
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 948
    if (! (max >= min)) {
#line 948
      goto while_break;
    }
#line 949
    mid = (min + max) / 2;
#line 950
    if (ucs > (table + mid)->last) {
#line 951
      min = mid + 1;
    } else
#line 952
    if (ucs < (table + mid)->first) {
#line 953
      max = mid - 1;
    } else {
#line 955
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 958
  return (0);
}
}
#line 962 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int utf8_isdouble(int c ) 
{ 
  static struct interval ambiguous[] ;
  static struct interval wide[] ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 1266
  __cil_tmp5 = bisearch(c, (struct interval *)ambiguous, (int )(sizeof(ambiguous) / sizeof(struct interval ) - 1UL));
  }
  {
#line 1266
  __cil_tmp4 = bisearch(c, (struct interval *)wide, (int )(sizeof(wide) / sizeof(struct interval ) - 1UL));
  }
#line 1266
  return (__cil_tmp4 || (cjkwidth && __cil_tmp5));
}
}
#line 1274 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int utf8_iscomb(int c ) 
{ 
  static struct interval combining[] ;
  int __cil_tmp3 ;

  {
  {
#line 1329
  __cil_tmp3 = bisearch(c, (struct interval *)combining, (int )(sizeof(combining) / sizeof(struct interval ) - 1UL));
  }
#line 1329
  return (__cil_tmp3);
}
}
#line 1333 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
static void comb_tofront(int root , int i ) 
{ 


  {
  {
#line 1336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1336
    if (! 1) {
#line 1336
      goto while_break;
    }
    {
#line 1338
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1338
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1339
    (*(combchars + (*(combchars + i))->prev))->next = (*(combchars + i))->next;
#line 1340
    (*(combchars + (*(combchars + i))->next))->prev = (*(combchars + i))->prev;
#line 1341
    (*(combchars + i))->next = (*(combchars + root))->next;
#line 1342
    (*(combchars + i))->prev = (unsigned int )root;
#line 1343
    (*(combchars + (*(combchars + root))->next))->prev = (unsigned int )i;
#line 1344
    (*(combchars + root))->next = (unsigned int )i;
#line 1345
    i = (int )(*(combchars + i))->c1;
#line 1346
    if (i < 55296) {
#line 1347
      return;
    } else
#line 1346
    if (i >= 57344) {
#line 1347
      return;
    }
#line 1348
    i -= 55296;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1353 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
void utf8_handle_comb(int c , struct mchar *mc ) 
{ 
  int root ;
  int i ;
  int c1 ;
  int isdouble ;
  int __cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int tmp ;
  void *__cil_tmp13 ;

  {
  {
#line 1360
  c1 = ((int )mc->image | ((int )mc->font << 8)) | ((int )mc->fontx << 16);
#line 1361
  __cil_tmp7 = utf8_isdouble(c1);
#line 1361
  isdouble = c1 >= 4352 && __cil_tmp7;
  }
#line 1362
  if (! combchars) {
    {
#line 1364
    __cil_tmp8 = calloc((unsigned long )2050, sizeof(struct combchar *));
#line 1364
    combchars = (struct combchar **)__cil_tmp8;
    }
#line 1365
    if (! combchars) {
#line 1366
      return;
    }
    {
#line 1367
    __cil_tmp9 = malloc(sizeof(struct combchar ));
#line 1367
    *(combchars + 2048) = (struct combchar *)__cil_tmp9;
#line 1368
    __cil_tmp10 = malloc(sizeof(struct combchar ));
#line 1368
    *(combchars + 2049) = (struct combchar *)__cil_tmp10;
    }
#line 1369
    if (! *(combchars + 2048)) {
      _L: /* CIL Label */ 
#line 1371
      if (*(combchars + 2048)) {
        {
#line 1372
        free((void *)*(combchars + 2048));
        }
      }
#line 1373
      if (*(combchars + 2049)) {
        {
#line 1374
        free((void *)*(combchars + 2049));
        }
      }
      {
#line 1375
      free((void *)combchars);
      }
#line 1376
      return;
    } else
#line 1369
    if (! *(combchars + 2049)) {
#line 1369
      goto _L;
    }
#line 1378
    (*(combchars + 2048))->c1 = (unsigned int )0;
#line 1379
    (*(combchars + 2048))->c2 = (unsigned int )1792;
#line 1380
    (*(combchars + 2048))->next = (unsigned int )2048;
#line 1381
    (*(combchars + 2048))->prev = (unsigned int )2048;
#line 1382
    (*(combchars + 2049))->c1 = (unsigned int )1792;
#line 1383
    (*(combchars + 2049))->c2 = (unsigned int )2048;
#line 1384
    (*(combchars + 2049))->next = (unsigned int )2049;
#line 1385
    (*(combchars + 2049))->prev = (unsigned int )2049;
  }
#line 1387
  if (isdouble) {
#line 1387
    tmp = 2049;
  } else {
#line 1387
    tmp = 2048;
  }
#line 1387
  root = tmp;
#line 1388
  i = (int )(*(combchars + root))->c1;
  {
#line 1388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1388
    if (! ((unsigned int )i < (*(combchars + root))->c2)) {
#line 1388
      goto while_break;
    }
#line 1390
    if (! *(combchars + i)) {
#line 1391
      goto while_break;
    }
#line 1392
    if ((*(combchars + i))->c1 == (unsigned int )c1) {
#line 1392
      if ((*(combchars + i))->c2 == (unsigned int )c) {
#line 1393
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1388
  i ++;
#line 1395
  if ((unsigned int )i == (*(combchars + root))->c2) {
#line 1398
    if (c1 >= 55296) {
#line 1398
      if (c1 < 57344) {
        {
#line 1399
        comb_tofront(root, c1 - 55296);
        }
      }
    }
#line 1400
    i = (int )(*(combchars + root))->prev;
#line 1401
    if (c1 == i + 55296) {
      {
#line 1404
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1404
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1405
      mc->image = (unsigned char )'?';
#line 1406
      mc->font = (unsigned char )0;
#line 1407
      return;
    }
  } else
#line 1411
  if (! *(combchars + i)) {
    {
#line 1413
    __cil_tmp13 = malloc(sizeof(struct combchar ));
#line 1413
    *(combchars + i) = (struct combchar *)__cil_tmp13;
    }
#line 1414
    if (! *(combchars + i)) {
#line 1415
      return;
    }
#line 1416
    (*(combchars + i))->prev = (unsigned int )i;
#line 1417
    (*(combchars + i))->next = (unsigned int )i;
  }
#line 1419
  (*(combchars + i))->c1 = (unsigned int )c1;
#line 1420
  (*(combchars + i))->c2 = (unsigned int )c;
#line 1421
  mc->image = (unsigned char )(i & 255);
#line 1422
  mc->font = (unsigned char )((i >> 8) + 216);
#line 1423
  mc->fontx = (unsigned char )0;
  {
#line 1424
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1424
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1425
  comb_tofront(root, i);
  }
  return;
}
}
#line 1442 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
static int encmatch(char *s1 , char *s2 ) 
{ 
  int c1 ;
  int c2 ;

  {
  {
#line 1447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1449
    c1 = (int )((unsigned char )*s1);
#line 1450
    if (c1 >= 65) {
#line 1450
      if (c1 <= 90) {
#line 1451
        c1 += 32;
      }
    }
#line 1452
    if (! (c1 >= 97 && c1 <= 122)) {
#line 1452
      if (! (c1 >= 48 && c1 <= 57)) {
#line 1454
        s1 ++;
#line 1455
        goto while_continue;
      }
    }
#line 1457
    c2 = (int )((unsigned char )*s2);
#line 1458
    if (c2 >= 65) {
#line 1458
      if (c2 <= 90) {
#line 1459
        c2 += 32;
      }
    }
#line 1460
    if (! (c2 >= 97 && c2 <= 122)) {
#line 1460
      if (! (c2 >= 48 && c2 <= 57)) {
#line 1462
        s2 ++;
#line 1463
        goto while_continue;
      }
    }
#line 1465
    if (c1 != c2) {
#line 1466
      return (0);
    }
#line 1467
    s1 ++;
#line 1468
    s2 ++;
#line 1447
    if (! c1) {
#line 1447
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1471
  return (1);
}
}
#line 1475 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int FindEncoding(char *name ) 
{ 
  int encoding ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 1480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1480
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1481
  if (name == (char *)0) {
#line 1482
    return (0);
  } else
#line 1481
  if ((int )*name == 0) {
#line 1482
    return (0);
  }
  {
#line 1483
  __cil_tmp3 = encmatch(name, (char *)"euc");
  }
#line 1483
  if (__cil_tmp3) {
#line 1484
    name = (char *)"eucJP";
  }
  {
#line 1485
  __cil_tmp5 = encmatch(name, (char *)"iso8859-1");
  }
  {
#line 1485
  __cil_tmp4 = encmatch(name, (char *)"off");
  }
#line 1485
  if (__cil_tmp4) {
#line 1486
    return (0);
  } else
#line 1485
  if (__cil_tmp5) {
#line 1486
    return (0);
  }
#line 1491
  encoding = 0;
  {
#line 1491
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1491
    if (! (encoding < (int )(sizeof(encodings) / sizeof(*((struct encoding *)encodings))))) {
#line 1491
      goto while_break___0;
    }
    {
#line 1492
    __cil_tmp6 = encmatch(name, encodings[encoding].name);
    }
#line 1492
    if (__cil_tmp6) {
      {
#line 1495
      LoadFontTranslationsForEncoding(encoding);
      }
#line 1497
      return (encoding);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1491
  encoding ++;
#line 1499
  return (- 1);
}
}
#line 1503 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
char *EncodingName(int encoding ) 
{ 


  {
#line 1506
  if (encoding >= (int )(sizeof(encodings) / sizeof(*((struct encoding *)encodings)))) {
#line 1507
    return ((char *)0);
  }
#line 1508
  return (encodings[encoding].name);
}
}
#line 1512 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int EncodingDefFont(int encoding ) 
{ 


  {
#line 1515
  return (encodings[encoding].deffont);
}
}
#line 1519 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
void ResetEncoding(struct win *p ) 
{ 
  char *c ;
  int encoding ;

  {
#line 1523
  encoding = p->w_layer.l_encoding;
#line 1525
  c = encodings[encoding].charsets;
#line 1526
  if (c) {
    {
#line 1527
    SetCharsets(p, c);
    }
  }
  {
#line 1529
  LoadFontTranslationsForEncoding(encoding);
  }
#line 1531
  if (encodings[encoding].usegr) {
#line 1533
    p->w_gr = 2;
#line 1534
    p->w_FontE = *(encodings[encoding].charsets + 1);
  } else {
#line 1537
    p->w_FontE = (char )0;
  }
#line 1538
  if (encodings[encoding].noc1) {
#line 1539
    p->w_c1 = 0;
  }
  return;
}
}
#line 1552 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int DecodeChar(int c , int encoding , int *statep ) 
{ 
  int t ;
  int __cil_tmp6 ;
  int tmp ;

  {
  {
#line 1559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1559
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1561
  if (encoding == 8) {
    {
#line 1563
    c = FromUtf8(c, statep);
    }
#line 1564
    if (c >= 65536) {
#line 1565
      c = ((c & 8323072) << 8) | (c & 65535);
    }
#line 1566
    return (c);
  }
#line 1569
  if (encoding == 2) {
#line 1571
    if (! *statep) {
#line 1573
      if (129 <= c) {
#line 1573
        if (c <= 159) {
#line 1575
          *statep = c;
#line 1576
          return (- 1);
        } else {
#line 1573
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1573
      if (224 <= c) {
#line 1573
        if (c <= 239) {
#line 1575
          *statep = c;
#line 1576
          return (- 1);
        }
      }
#line 1578
      if (c < 128) {
#line 1579
        return (c);
      }
#line 1580
      return (c | (73 << 16));
    }
#line 1582
    t = c;
#line 1583
    c = *statep;
#line 1584
    *statep = 0;
#line 1585
    if (64 <= t) {
#line 1585
      if (t <= 252) {
#line 1585
        if (t != 127) {
#line 1587
          if (c <= 159) {
#line 1588
            c = (c - 129) * 2 + 33;
          } else {
#line 1590
            c = (c - 193) * 2 + 33;
          }
#line 1591
          if (t <= 126) {
#line 1592
            t -= 31;
          } else
#line 1593
          if (t <= 158) {
#line 1594
            t -= 32;
          } else {
#line 1596
            __cil_tmp6 = c;
#line 1596
            c ++;
#line 1596
            t -= 126;
          }
#line 1597
          return (((c << 8) | t) | (2 << 16));
        }
      }
    }
#line 1599
    return (t);
  }
#line 1601
  if (encoding == 1) {
    _L___18: /* CIL Label */ 
#line 1603
    if (! *statep) {
#line 1605
      if (c & 128) {
#line 1607
        *statep = c;
#line 1608
        return (- 1);
      }
#line 1610
      return (c);
    }
#line 1612
    t = c;
#line 1613
    c = *statep;
#line 1614
    *statep = 0;
#line 1615
    if (encoding == 1) {
#line 1617
      if (c == 142) {
#line 1618
        return (t | (73 << 16));
      }
#line 1619
      if (c == 143) {
#line 1621
        *statep = t | (4 << 8);
#line 1622
        return (- 1);
      }
    }
#line 1625
    c &= 65407;
#line 1626
    t &= 127;
#line 1627
    c = (c << 8) | t;
#line 1628
    if (encoding == 3) {
#line 1629
      return (c | (3 << 16));
    }
#line 1630
    if (encoding == 4) {
#line 1631
      return (c | (1 << 16));
    }
#line 1632
    if (c & (4 << 16)) {
#line 1633
      return (c);
    } else {
#line 1635
      return (c | (2 << 16));
    }
  } else
#line 1601
  if (encoding == 3) {
#line 1601
    goto _L___18;
  } else
#line 1601
  if (encoding == 4) {
#line 1601
    goto _L___18;
  }
#line 1637
  if (encoding == 5) {
    _L___20: /* CIL Label */ 
#line 1639
    if (! *statep) {
#line 1641
      if (c & 128) {
#line 1643
        if (encoding == 20) {
#line 1643
          if (c == 128) {
#line 1644
            return (164 | (226 << 16));
          }
        }
#line 1645
        *statep = c;
#line 1646
        return (- 1);
      }
#line 1648
      return (c);
    }
#line 1650
    t = c;
#line 1651
    c = *statep;
#line 1652
    *statep = 0;
#line 1653
    c &= 127;
#line 1654
    if (encoding == 5) {
#line 1654
      tmp = 24 << 16;
    } else {
#line 1654
      tmp = 25 << 16;
    }
#line 1654
    return (((c << 8) | t) | tmp);
  } else
#line 1637
  if (encoding == 20) {
#line 1637
    goto _L___20;
  }
#line 1656
  return (c | (encodings[encoding].deffont << 16));
}
}
#line 1660 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int EncodeChar(char *bp , int c , int encoding , int *fontp ) 
{ 
  int t ;
  int f ;
  int l ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  int c2 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int c2___0 ;
  int tmp ;
  int tmp___21 ;
  int tmp___22 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  int tmp___23 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp45 ;

  {
  {
#line 1668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1668
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1669
  if (c == -1) {
#line 1669
    if (fontp) {
#line 1671
      if (*fontp == 0) {
#line 1672
        return (0);
      }
#line 1673
      if (bp) {
#line 1675
        __cil_tmp8 = bp;
#line 1675
        bp ++;
#line 1675
        *__cil_tmp8 = (char )27;
#line 1676
        __cil_tmp9 = bp;
#line 1676
        bp ++;
#line 1676
        *__cil_tmp9 = (char )'(';
#line 1677
        __cil_tmp10 = bp;
#line 1677
        bp ++;
#line 1677
        *__cil_tmp10 = (char )'B';
      }
#line 1679
      return (3);
    }
  }
#line 1681
  f = (c >> 16) & 255;
#line 1684
  if (encoding == 8) {
#line 1686
    if (f) {
#line 1689
      if (f) {
#line 1689
        if ((f & 96) == 0) {
          {
#line 1691
          c2 = c & 255;
#line 1692
          c = ((c >> 8) & 255) | (f << 8);
#line 1693
          c = recode_char_dw_to_encoding(c, & c2, encoding);
          }
        } else {
          {
#line 1698
          c = (c & 255) | (f << 8);
          {
#line 1699
          c = recode_char_to_encoding(c, encoding);
          }
          }
        }
      } else {
        {
#line 1698
        c = (c & 255) | (f << 8);
        {
#line 1699
        c = recode_char_to_encoding(c, encoding);
        }
        }
      }
    }
    {
#line 1702
    __cil_tmp14 = ToUtf8(bp, c);
    }
#line 1702
    return (__cil_tmp14);
  }
#line 1704
  if (f == 0) {
#line 1704
    if ((c & 2130771712) != 0) {
#line 1706
      if (c >= 65536) {
#line 1707
        c = ((c & 8323072) >> 8) | (c & 65535);
      }
      {
#line 1709
      __cil_tmp15 = utf8_isdouble(c);
      }
#line 1709
      if (__cil_tmp15) {
        {
#line 1711
        c2___0 = 65535;
#line 1712
        c = recode_char_dw_to_encoding(c, & c2___0, encoding);
#line 1713
        c = (c << 8) | (c2___0 & 255);
        }
      } else {
        {
#line 1718
        c = recode_char_to_encoding(c, encoding);
#line 1719
        c = ((c & 65280) << 8) | (c & 255);
        }
      }
      {
#line 1721
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1721
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1722
      f = c >> 16;
    }
  }
#line 1725
  if (f & 128) {
#line 1726
    f = 0;
  }
#line 1728
  if (encoding == 2) {
#line 1730
    if (f == 73) {
#line 1731
      c = (c & 255) | 128;
    } else
#line 1732
    if (f == 2) {
#line 1734
      if (! bp) {
#line 1735
        return (2);
      }
#line 1736
      t = c & 255;
#line 1737
      c = (c >> 8) & 255;
#line 1738
      if (c & 1) {
#line 1738
        if (t <= 95) {
#line 1738
          tmp = 31;
        } else {
#line 1738
          tmp = 32;
        }
#line 1738
        tmp___21 = tmp;
      } else {
#line 1738
        tmp___21 = 126;
      }
#line 1738
      t += tmp___21;
#line 1739
      if (c < 95) {
#line 1739
        tmp___22 = 129;
      } else {
#line 1739
        tmp___22 = 193;
      }
#line 1739
      c = (c - 33) / 2 + tmp___22;
#line 1740
      __cil_tmp22 = bp;
#line 1740
      bp ++;
#line 1740
      *__cil_tmp22 = (char )c;
#line 1741
      __cil_tmp23 = bp;
#line 1741
      bp ++;
#line 1741
      *__cil_tmp23 = (char )t;
#line 1742
      return (2);
    }
  }
#line 1745
  if (encoding == 1) {
#line 1747
    if (f == 73) {
#line 1749
      if (bp) {
#line 1751
        __cil_tmp24 = bp;
#line 1751
        bp ++;
#line 1751
        *__cil_tmp24 = (char )142;
#line 1752
        __cil_tmp25 = bp;
#line 1752
        bp ++;
#line 1752
        *__cil_tmp25 = (char )c;
      }
#line 1754
      return (2);
    }
#line 1756
    if (f == 2) {
#line 1758
      if (bp) {
#line 1760
        __cil_tmp26 = bp;
#line 1760
        bp ++;
#line 1760
        *__cil_tmp26 = (char )((c >> 8) | 128);
#line 1761
        __cil_tmp27 = bp;
#line 1761
        bp ++;
#line 1761
        *__cil_tmp27 = (char )(c | 128);
      }
#line 1763
      return (2);
    }
#line 1765
    if (f == 4) {
#line 1767
      if (bp) {
#line 1769
        __cil_tmp28 = bp;
#line 1769
        bp ++;
#line 1769
        *__cil_tmp28 = (char )143;
#line 1770
        __cil_tmp29 = bp;
#line 1770
        bp ++;
#line 1770
        *__cil_tmp29 = (char )(c >> 8);
#line 1771
        __cil_tmp30 = bp;
#line 1771
        bp ++;
#line 1771
        *__cil_tmp30 = (char )c;
      }
#line 1773
      return (3);
    }
  }
#line 1776
  if (encoding == 3) {
#line 1776
    if (f == 3) {
      _L: /* CIL Label */ 
#line 1778
      if (bp) {
#line 1780
        __cil_tmp31 = bp;
#line 1780
        bp ++;
#line 1780
        *__cil_tmp31 = (char )((c >> 8) | 128);
#line 1781
        __cil_tmp32 = bp;
#line 1781
        bp ++;
#line 1781
        *__cil_tmp32 = (char )(c | 128);
      }
#line 1783
      return (2);
    } else {
#line 1776
      goto _L___23;
    }
  } else
  _L___23: /* CIL Label */ 
#line 1776
  if (encoding == 4) {
#line 1776
    if (f == 1) {
#line 1776
      goto _L;
    }
  }
#line 1785
  if (encoding == 5) {
#line 1785
    if (f == 24) {
      _L___24: /* CIL Label */ 
#line 1787
      if (bp) {
#line 1789
        __cil_tmp33 = bp;
#line 1789
        bp ++;
#line 1789
        *__cil_tmp33 = (char )((c >> 8) | 128);
#line 1790
        __cil_tmp34 = bp;
#line 1790
        bp ++;
#line 1790
        *__cil_tmp34 = (char )c;
      }
#line 1792
      return (2);
    } else {
#line 1785
      goto _L___25;
    }
  } else
  _L___25: /* CIL Label */ 
#line 1785
  if (encoding == 20) {
#line 1785
    if (f == 25) {
#line 1785
      goto _L___24;
    }
  }
#line 1794
  if (encoding == 20) {
#line 1794
    if (f == 0) {
#line 1794
      if (c == 164) {
#line 1795
        c = 128;
      }
    }
  }
#line 1797
  l = 0;
#line 1798
  if (fontp) {
#line 1798
    if (f != *fontp) {
#line 1800
      *fontp = f;
#line 1801
      if (f) {
#line 1801
        if (f < 32) {
#line 1803
          if (bp) {
#line 1805
            __cil_tmp35 = bp;
#line 1805
            bp ++;
#line 1805
            *__cil_tmp35 = (char )27;
#line 1806
            __cil_tmp36 = bp;
#line 1806
            bp ++;
#line 1806
            *__cil_tmp36 = (char )'$';
#line 1807
            if (f > 2) {
#line 1808
              __cil_tmp37 = bp;
#line 1808
              bp ++;
#line 1808
              *__cil_tmp37 = (char )'(';
            }
#line 1809
            __cil_tmp38 = bp;
#line 1809
            bp ++;
#line 1809
            *__cil_tmp38 = (char )(64 + f);
          }
#line 1811
          if (f > 2) {
#line 1811
            tmp___23 = 4;
          } else {
#line 1811
            tmp___23 = 3;
          }
#line 1811
          l += tmp___23;
        } else {
#line 1801
          goto _L___26;
        }
      } else
      _L___26: /* CIL Label */ 
#line 1813
      if (f < 128) {
#line 1815
        if (f == 0) {
#line 1816
          f = 'B';
        }
#line 1817
        if (bp) {
#line 1819
          __cil_tmp40 = bp;
#line 1819
          bp ++;
#line 1819
          *__cil_tmp40 = (char )27;
#line 1820
          __cil_tmp41 = bp;
#line 1820
          bp ++;
#line 1820
          *__cil_tmp41 = (char )'(';
#line 1821
          __cil_tmp42 = bp;
#line 1821
          bp ++;
#line 1821
          *__cil_tmp42 = (char )f;
        }
#line 1823
        l += 3;
      }
    }
  }
#line 1826
  if (c & 65280) {
#line 1828
    if (bp) {
#line 1829
      __cil_tmp43 = bp;
#line 1829
      bp ++;
#line 1829
      *__cil_tmp43 = (char )(c >> 8);
    }
#line 1830
    l ++;
  }
#line 1832
  if (bp) {
#line 1833
    __cil_tmp45 = bp;
#line 1833
    bp ++;
#line 1833
    *__cil_tmp45 = (char )c;
  }
#line 1834
  return (l + 1);
}
}
#line 1838 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int CanEncodeFont(int encoding , int f ) 
{ 


  {
  {
#line 1844
  if (encoding == 8) {
#line 1844
    goto case_8;
  }
#line 1847
  if (encoding == 2) {
#line 1847
    goto case_2;
  }
#line 1849
  if (encoding == 1) {
#line 1849
    goto case_1;
  }
#line 1851
  if (encoding == 3) {
#line 1851
    goto case_3;
  }
#line 1853
  if (encoding == 4) {
#line 1853
    goto case_4;
  }
#line 1855
  if (encoding == 5) {
#line 1855
    goto case_5;
  }
#line 1857
  if (encoding == 20) {
#line 1857
    goto case_20;
  }
#line 1859
  goto switch_default;
  case_8: /* CIL Label */ 
#line 1845
  return (1);
  case_2: /* CIL Label */ 
#line 1848
  return (f == 2 || f == 73);
  case_1: /* CIL Label */ 
#line 1850
  return ((f == 2 || f == 73) || f == 4);
  case_3: /* CIL Label */ 
#line 1852
  return (f == 3);
  case_4: /* CIL Label */ 
#line 1854
  return (f == 1);
  case_5: /* CIL Label */ 
#line 1856
  return (f == 24);
  case_20: /* CIL Label */ 
#line 1858
  return (f == 25);
  switch_default: /* CIL Label */ 
#line 1860
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1862
  return (0);
}
}
#line 1867 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int PrepareEncodedChar(int c ) 
{ 
  int encoding ;
  int t ;
  int f ;
  int tmp ;
  int tmp___27 ;
  int tmp___28 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1871
  t = 0;
#line 1874
  encoding = display->d_encoding;
#line 1875
  f = (int )display->d_rend.font;
#line 1876
  t = display->d_mbcs;
#line 1877
  if (encoding == 2) {
#line 1879
    if (f == 73) {
#line 1880
      return (c | 128);
    } else
#line 1881
    if (f == 2) {
#line 1883
      if (c & 1) {
#line 1883
        if (t <= 95) {
#line 1883
          tmp = 31;
        } else {
#line 1883
          tmp = 32;
        }
#line 1883
        tmp___27 = tmp;
      } else {
#line 1883
        tmp___27 = 126;
      }
#line 1883
      t += tmp___27;
#line 1884
      if (c < 95) {
#line 1884
        tmp___28 = 129;
      } else {
#line 1884
        tmp___28 = 193;
      }
#line 1884
      c = (c - 33) / 2 + tmp___28;
#line 1885
      display->d_mbcs = t;
    }
#line 1887
    return (c);
  }
#line 1889
  if (encoding == 1) {
#line 1891
    if (f == 73) {
      {
#line 1893
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1893
        (display->d_obuffree) --;
#line 1893
        if (display->d_obuffree <= 0) {
          {
#line 1893
          Resize_obuf();
          }
        }
#line 1893
        __cil_tmp8 = display->d_obufp;
#line 1893
        (display->d_obufp) ++;
#line 1893
        *__cil_tmp8 = (char )142;
#line 1893
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1894
      return (c | 128);
    }
#line 1896
    if (f == 2) {
#line 1898
      display->d_mbcs = t | 128;
#line 1899
      return (c | 128);
    }
#line 1901
    if (f == 4) {
      {
#line 1903
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1903
        (display->d_obuffree) --;
#line 1903
        if (display->d_obuffree <= 0) {
          {
#line 1903
          Resize_obuf();
          }
        }
#line 1903
        __cil_tmp9 = display->d_obufp;
#line 1903
        (display->d_obufp) ++;
#line 1903
        *__cil_tmp9 = (char )143;
#line 1903
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1904
      display->d_mbcs = t | 128;
#line 1905
      return (c | 128);
    }
  }
#line 1908
  if (encoding == 3) {
#line 1908
    if (f == 3) {
#line 1910
      display->d_mbcs = t | 128;
#line 1911
      return (c | 128);
    } else {
#line 1908
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1908
  if (encoding == 4) {
#line 1908
    if (f == 1) {
#line 1910
      display->d_mbcs = t | 128;
#line 1911
      return (c | 128);
    }
  }
#line 1913
  if (encoding == 5) {
#line 1913
    if (f == 24) {
#line 1914
      return (c | 128);
    } else {
#line 1913
      goto _L___29;
    }
  } else
  _L___29: /* CIL Label */ 
#line 1913
  if (encoding == 20) {
#line 1913
    if (f == 25) {
#line 1914
      return (c | 128);
    }
  }
#line 1915
  return (c);
}
}
#line 1920 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int RecodeBuf(unsigned char *fbuf , int flen , int fenc , int tenc , unsigned char *tbuf ) 
{ 
  int c ;
  int i ;
  int j ;
  int decstate ;
  int font ;
  int __cil_tmp12 ;
  char *tmp ;
  int __cil_tmp14 ;
  char *tmp___0 ;
  int __cil_tmp17 ;

  {
#line 1927
  decstate = 0;
#line 1927
  font = 0;
#line 1929
  j = 0;
#line 1929
  i = j;
  {
#line 1929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1929
    if (! (i < flen)) {
#line 1929
      goto while_break;
    }
    {
#line 1931
    c = (int )*(fbuf + i);
#line 1932
    c = DecodeChar(c, fenc, & decstate);
    }
#line 1933
    if (c == -2) {
#line 1934
      __cil_tmp12 = i;
#line 1934
      i --;
    }
#line 1935
    if (c < 0) {
#line 1936
      goto while_continue;
    }
#line 1937
    if (tbuf) {
#line 1937
      tmp = (char *)tbuf + j;
    } else {
#line 1937
      tmp = (char *)0;
    }
    {
#line 1937
    __cil_tmp14 = EncodeChar(tmp, c, tenc, & font);
    }
#line 1937
    j += __cil_tmp14;
  }
  while_break: /* CIL Label */ ;
  }
#line 1929
  i ++;
#line 1939
  if (tbuf) {
#line 1939
    tmp___0 = (char *)tbuf + j;
  } else {
#line 1939
    tmp___0 = (char *)0;
  }
  {
#line 1939
  __cil_tmp17 = EncodeChar(tmp___0, - 1, tenc, & font);
  }
#line 1939
  j += __cil_tmp17;
#line 1940
  return (j);
}
}
#line 1945 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int ContainsSpecialDeffont(struct mline *ml , int xs , int xe , int encoding ) 
{ 
  unsigned char *f ;
  unsigned char *i ;
  int c ;
  int x ;
  int dx ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;

  {
#line 1953
  if (encoding == 8) {
#line 1954
    return (0);
  } else
#line 1953
  if (encodings[encoding].deffont == 0) {
#line 1954
    return (0);
  }
#line 1955
  i = ml->image + xs;
#line 1956
  f = ml->font + xs;
#line 1957
  dx = (xe - xs) + 1;
  {
#line 1958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1958
    if (! (__cil_tmp10 > 0)) {
#line 1958
      goto while_break;
    }
#line 1960
    __cil_tmp11 = f;
#line 1960
    f ++;
#line 1960
    if (*__cil_tmp11) {
#line 1961
      goto while_continue;
    }
    {
#line 1962
    __cil_tmp12 = i;
#line 1962
    i ++;
#line 1962
    c = (int )*__cil_tmp12;
#line 1963
    x = recode_char_to_encoding(c | (encodings[encoding].deffont << 8), 8);
    }
#line 1964
    if (c != x) {
      {
#line 1966
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1966
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1967
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1970
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1970
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1971
  return (0);
}
}
#line 1976 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
int LoadFontTranslation(int font , char *file ) 
{ 
  char buf[1024] ;
  char *myfile ;
  FILE *f ;
  int i ;
  int fo ;
  int x ;
  int u ;
  int c ;
  int ok ;
  unsigned short (*p)[2] ;
  unsigned short (*tab)[2] ;
  size_t __cil_tmp14 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  void *__cil_tmp23 ;
  int __cil_tmp25 ;
  int __cil_tmp29 ;
  int tmp ;

  {
#line 1987
  myfile = file;
#line 1988
  if (myfile == (char *)0) {
#line 1990
    if (font == 0) {
#line 1991
      return (- 1);
    } else
#line 1990
    if (screenencodings == (char *)0) {
#line 1991
      return (- 1);
    }
    {
#line 1992
    __cil_tmp14 = strlen((char const   *)screenencodings);
    }
#line 1992
    if (__cil_tmp14 > sizeof(buf) - 10UL) {
#line 1993
      return (- 1);
    }
    {
#line 1994
    sprintf((char *)buf, (char const   *)((char *)"%s/%02x"), screenencodings, font & 255);
#line 1995
    myfile = (char *)buf;
    }
  }
  {
#line 1997
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1997
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1998
  f = secfopen(myfile, (char *)"r");
  }
#line 1998
  if (f == (FILE *)0) {
#line 1999
    return (- 1);
  }
#line 2000
  ok = 0;
#line 2000
  i = ok;
  {
#line 2001
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2001
    if (! 1) {
#line 2001
      goto while_break___0;
    }
    {
#line 2003
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2003
      if (! (i < 12)) {
#line 2003
        goto while_break___1;
      }
      {
#line 2004
      __cil_tmp16 = _IO_getc(f);
      }
#line 2004
      if (__cil_tmp16 != (int )*((char *)"ScreenI2UTF8" + i)) {
#line 2005
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2003
    i ++;
#line 2006
    __cil_tmp18 = _IO_getc(f);
    }
#line 2006
    if (__cil_tmp18 != 0) {
#line 2007
      goto while_break___0;
    }
    {
#line 2008
    fo = _IO_getc(f);
    }
#line 2009
    if (fo == -1) {
#line 2010
      goto while_break___0;
    }
#line 2011
    if (font != -1) {
#line 2011
      if (font != fo) {
#line 2012
        goto while_break___0;
      }
    }
    {
#line 2013
    i = _IO_getc(f);
#line 2014
    x = _IO_getc(f);
    }
#line 2015
    if (x == -1) {
#line 2016
      goto while_break___0;
    }
    {
#line 2017
    i = (i << 8) | x;
#line 2018
    _IO_getc(f);
    }
    {
#line 2019
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2019
      if (! (x && x != -1)) {
#line 2019
        goto while_break___2;
      }
      {
#line 2020
      _IO_getc(f);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2021
    __cil_tmp23 = malloc(sizeof(*p) * (unsigned long )(i + 1));
#line 2021
    p = (unsigned short (*)[2])__cil_tmp23;
    }
#line 2021
    if (p == (unsigned short (*)[2])0) {
#line 2022
      goto while_break___0;
    }
#line 2023
    tab = p;
    {
#line 2024
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2024
      if (! (i > 0)) {
#line 2024
        goto while_break___3;
      }
      {
#line 2026
      x = _IO_getc(f);
#line 2027
      __cil_tmp25 = _IO_getc(f);
#line 2027
      x = (x << 8) | __cil_tmp25;
#line 2028
      u = _IO_getc(f);
#line 2029
      c = _IO_getc(f);
#line 2030
      u = (u << 8) | c;
      }
#line 2031
      if (c == -1) {
#line 2032
        goto while_break___3;
      }
#line 2033
      (*p)[0] = (unsigned short )x;
#line 2034
      (*p)[1] = (unsigned short )u;
#line 2035
      p ++;
#line 2036
      __cil_tmp29 = i;
#line 2036
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2038
    (*p)[0] = (unsigned short )0;
#line 2039
    (*p)[1] = (unsigned short )0;
#line 2040
    if (i) {
      {
      {
#line 2042
      free((void *)tab);
      }
      }
#line 2043
      goto while_break___0;
    } else
#line 2040
    if ((int )(*(tab + 0))[0] & 32768) {
      {
      {
#line 2042
      free((void *)tab);
      }
      }
#line 2043
      goto while_break___0;
    }
#line 2045
    if (recodetabs[fo].tab) {
#line 2045
      if ((recodetabs[fo].flags & 1) != 0) {
        {
#line 2046
        free((void *)recodetabs[fo].tab);
        }
      }
    }
#line 2047
    recodetabs[fo].tab = tab;
#line 2048
    recodetabs[fo].flags = 1;
    {
#line 2049
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2049
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2050
    c = _IO_getc(f);
    }
#line 2051
    if (c == -1) {
#line 2053
      ok = 1;
#line 2054
      goto while_break___0;
    }
#line 2056
    if (c != 83) {
#line 2057
      goto while_break___0;
    }
#line 2058
    i = 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2060
  fclose(f);
  }
#line 2061
  if (font != -1) {
#line 2061
    if (file == (char *)0) {
#line 2061
      if (recodetabs[font].flags == 0) {
#line 2062
        recodetabs[font].flags = 4;
      }
    }
  }
#line 2063
  if (ok) {
#line 2063
    tmp = 0;
  } else {
#line 2063
    tmp = - 1;
  }
#line 2063
  return (tmp);
}
}
#line 2067 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/encoding.c"
void LoadFontTranslationsForEncoding(int encoding ) 
{ 
  char *c ;
  int f ;

  {
  {
#line 2073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2073
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2074
  c = encodings[encoding].fontlist;
#line 2074
  if (c != (char *)0) {
    {
#line 2075
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2075
      if (! (f != 0)) {
#line 2075
        goto while_break___0;
      }
#line 2076
      if (recodetabs[f].flags == 0) {
        {
#line 2077
        LoadFontTranslation(f, (char *)0);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2078
  f = encodings[encoding].deffont;
#line 2079
  if (f > 0) {
#line 2079
    if (recodetabs[f].flags == 0) {
      {
#line 2080
      LoadFontTranslation(f, (char *)0);
      }
    }
  }
  return;
}
}
#line 33 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/nethack.c"
int nethackflag ;
#line 42 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/nethack.c"
static struct nlstrans nethacktrans[]  = 
#line 42
  {      {(char *)"Cannot lock terminal - fork failed", (char *)"Cannot fork terminal - lock failed"}, 
        {(char *)"Got only %d bytes from %s",
      (char *)"You choke on your food: %d bytes from %s"}, 
        {(char *)"Copy mode - Column %d Line %d(+%d) (%d,%d)", (char *)"Welcome to hacker\'s treasure zoo - Column %d Line %d(+%d) (%d,%d)"}, 
        {(char *)"First mark set - Column %d Line %d",
      (char *)"You drop a magic marker - Column %d Line %d"}, 
        {(char *)"Copy mode aborted", (char *)"You escaped the dungeon."}, 
        {(char *)"Filter removed.", (char *)"You have a sad feeling for a moment..."}, 
        {(char *)"Window %d (%s) killed.",
      (char *)"You destroy poor window %d (%s)."}, 
        {(char *)"Window %d (%s) is now being monitored for all activity.", (char *)"You feel like someone is watching you..."}, 
        {(char *)"Window %d (%s) is no longer being monitored for activity.",
      (char *)"You no longer sense the watcher\'s presence."}, 
        {(char *)"empty buffer", (char *)"Nothing happens."}, 
        {(char *)"switched to audible bell.", (char *)"Suddenly you can\'t see your bell!"}, 
        {(char *)"switched to visual bell.",
      (char *)"Your bell is no longer invisible."}, 
        {(char *)"The window is now being monitored for %d sec. silence.", (char *)"You feel like someone is waiting for %d sec. silence..."}, 
        {(char *)"The window is no longer being monitored for silence.",
      (char *)"You no longer sense the watcher\'s silence."}, 
        {(char *)"No other window.", (char *)"You cannot escape from window %d!"}, 
        {(char *)"Logfile \"%s\" closed.", (char *)"You put away your scroll of logging named \"%s\"."}, 
        {(char *)"Error opening logfile \"%s\"",
      (char *)"You don\'t seem to have a scroll of logging named \"%s\"."}, 
        {(char *)"Creating logfile \"%s\".", (char *)"You start writing on your scroll of logging named \"%s\"."}, 
        {(char *)"Appending to logfile \"%s\".",
      (char *)"You add to your scroll of logging named \"%s\"."}, 
        {(char *)"Detach aborted.", (char *)"The blast of disintegration whizzes by you!"}, 
        {(char *)"Empty register.",
      (char *)"Nothing happens."}, 
        {(char *)"[ Passwords don\'t match - checking turned off ]", (char *)"[ Passwords don\'t match - your armor crumbles away ]"}, 
        {(char *)"Aborted because of window size change.",
      (char *)"KAABLAMM!!!  You triggered a land mine!"}, 
        {(char *)"Out of memory.", (char *)"Who was that Maude person anyway?"}, 
        {(char *)"getpwuid() can\'t identify your account!", (char *)"An alarm sounds through the dungeon...\nThe Keystone Kops are after you!"}, 
        {(char *)"Must be connected to a terminal.",
      (char *)"You must play from a terminal."}, 
        {(char *)"No Sockets found in %s.\n", (char *)"This room is empty (%s).\n"}, 
        {(char *)"New screen...", (char *)"Be careful!  New screen tonight."}, 
        {(char *)"Child has been stopped, restarting.", (char *)"You regain consciousness."}, 
        {(char *)"There are screens on:",
      (char *)"Your inventory:"}, 
        {(char *)"There is a screen on:", (char *)"Your inventory:"}, 
        {(char *)"There are several screens on:", (char *)"Prove thyself worthy or perish:"}, 
        {(char *)"There is a suitable screen on:",
      (char *)"You see here a good looking screen:"}, 
        {(char *)"There are several suitable screens on:", (char *)"You may wish for a screen, what do you want?"}, 
        {(char *)"%d socket%s wiped out.",
      (char *)"You hear %d distant explosion%s."}, 
        {(char *)"Remove dead screens with \'screen -wipe\'.", (char *)"The dead screen%s touch%s you. Try \'screen -wipe\'."}, 
        {(char *)"Illegal reattach attempt from terminal %s.",
      (char *)"\'%s\' tries to touch your session, but fails."}, 
        {(char *)"Could not write %s", (char *)"%s is too hard to dig in"}, 
        {(char *)0, (char *)0}};
#line 124 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/nethack.c"
char const   *DoNLS(char const   *from ) 
{ 
  struct nlstrans *t ;
  int __cil_tmp3 ;

  {
#line 130
  if (nethackflag) {
#line 132
    t = (struct nlstrans *)nethacktrans;
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (! t->from) {
#line 132
        goto while_break;
      }
      {
#line 133
      __cil_tmp3 = strcmp(from, (char const   *)t->from);
      }
#line 133
      if (__cil_tmp3 == 0) {
#line 134
        return ((char const   *)t->to);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 132
    t ++;
  }
#line 137
  return (from);
}
}
#line 302 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__)) ;
#line 309
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__)) ;
#line 309 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) 
{ 


  {
#line 311
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
#line 313
    return ((struct cmsghdr *)0);
  }
#line 315
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
#line 317
  if ((unsigned char *)(__cmsg + 1) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 322
    return ((struct cmsghdr *)0);
  } else
#line 317
  if ((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 322
    return ((struct cmsghdr *)0);
  }
#line 323
  return (__cmsg);
}
}
#line 145 "/usr/include/x86_64-linux-gnu/sys/socket.h"
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags )  __attribute__((__gnu_inline__)) ;
#line 163
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
#line 25
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 27
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags ) ;
#line 34
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags )  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 36
  __cil_tmp5 = __builtin_object_size((void const   *)__buf, 0);
  }
#line 36
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 38
    __cil_tmp6 = __builtin_constant_p(__n);
    }
#line 38
    if (! __cil_tmp6) {
      {
#line 39
      __cil_tmp7 = __builtin_object_size((void const   *)__buf, 0);
#line 39
      __cil_tmp8 = __recv_chk(__fd, __buf, __n, __cil_tmp7, __flags);
      }
#line 39
      return (__cil_tmp8);
    }
    {
#line 41
    __cil_tmp9 = __builtin_object_size((void const   *)__buf, 0);
    }
#line 41
    if (__n > __cil_tmp9) {
      {
#line 42
      __cil_tmp10 = __builtin_object_size((void const   *)__buf, 0);
#line 42
      __cil_tmp11 = __recv_chk_warn(__fd, __buf, __n, __cil_tmp10, __flags);
      }
#line 42
      return (__cil_tmp11);
    }
  }
  {
#line 44
  __cil_tmp12 = __recv_alias(__fd, __buf, __n, __flags);
  }
#line 44
  return (__cil_tmp12);
}
}
#line 47
extern ssize_t __recvfrom_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                              int __flags , __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 51
extern ssize_t __recvfrom_alias(int __fd , void *__buf , size_t __n , int __flags ,
                                __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 55
extern ssize_t __recvfrom_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                                   int __flags , __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 64
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len ) 
{ 
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  ssize_t __cil_tmp13 ;
  ssize_t __cil_tmp14 ;

  {
  {
#line 67
  __cil_tmp7 = __builtin_object_size((void const   *)__buf, 0);
  }
#line 67
  if (__cil_tmp7 != 0xffffffffffffffffUL) {
    {
#line 69
    __cil_tmp8 = __builtin_constant_p(__n);
    }
#line 69
    if (! __cil_tmp8) {
      {
#line 70
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 0);
#line 70
      __cil_tmp10 = __recvfrom_chk(__fd, __buf, __n, __cil_tmp9, __flags, __addr,
                                   __addr_len);
      }
#line 70
      return (__cil_tmp10);
    }
    {
#line 72
    __cil_tmp11 = __builtin_object_size((void const   *)__buf, 0);
    }
#line 72
    if (__n > __cil_tmp11) {
      {
#line 73
      __cil_tmp12 = __builtin_object_size((void const   *)__buf, 0);
#line 73
      __cil_tmp13 = __recvfrom_chk_warn(__fd, __buf, __n, __cil_tmp12, __flags, __addr,
                                        __addr_len);
      }
#line 73
      return (__cil_tmp13);
    }
  }
  {
#line 76
  __cil_tmp14 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
  }
#line 76
  return (__cil_tmp14);
}
}
#line 157 "/usr/include/fcntl.h"
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 167
__inline extern int open64(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 181
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 192
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
  {
#line 46
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = __builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = __builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 64
extern int __open64_2(char const   *__path , int __oflag ) ;
#line 65
extern int __open64_alias(char const   *__path , int __oflag  , ...) ;
#line 67
extern void __open64_too_many_args(void) ;
#line 69
extern void __open64_missing_mode(void) ;
#line 73
__inline extern int open64(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open64(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 75
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 75
  if (__cil_tmp3 > 1) {
    {
#line 76
    __open64_too_many_args();
    }
  }
  {
#line 78
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 78
  if (__cil_tmp4) {
    {
#line 80
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 80
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 80
      if (__cil_tmp5 < 1) {
        {
#line 82
        __open64_missing_mode();
#line 83
        __cil_tmp6 = __open64_2(__path, __oflag);
        }
#line 83
        return (__cil_tmp6);
      }
    } else
#line 80
    if ((__oflag & 4259840) == 4259840) {
#line 80
      goto _L;
    }
    {
#line 85
    __cil_tmp7 = __builtin_va_arg_pack();
#line 85
    __cil_tmp8 = __open64_alias(__path, __oflag, __cil_tmp7);
    }
#line 85
    return (__cil_tmp8);
  }
  {
#line 88
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 88
  if (__cil_tmp9 < 1) {
    {
#line 89
    __cil_tmp10 = __open64_2(__path, __oflag);
    }
#line 89
    return (__cil_tmp10);
  }
  {
#line 91
  __cil_tmp11 = __builtin_va_arg_pack();
#line 91
  __cil_tmp12 = __open64_alias(__path, __oflag, __cil_tmp11);
  }
#line 91
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
  {
#line 122
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = __builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = __builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 140
extern int __openat64_2(int __fd , char const   *__path , int __oflag ) ;
#line 142
extern int __openat64_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 145
extern void __openat64_too_many_args(void) ;
#line 147
extern void __openat64_missing_mode(void) ;
#line 151
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 151 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 153
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 153
  if (__cil_tmp4 > 1) {
    {
#line 154
    __openat64_too_many_args();
    }
  }
  {
#line 156
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 156
  if (__cil_tmp5) {
    {
#line 158
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 158
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 158
      if (__cil_tmp6 < 1) {
        {
#line 160
        __openat64_missing_mode();
#line 161
        __cil_tmp7 = __openat64_2(__fd, __path, __oflag);
        }
#line 161
        return (__cil_tmp7);
      }
    } else
#line 158
    if ((__oflag & 4259840) == 4259840) {
#line 158
      goto _L;
    }
    {
#line 163
    __cil_tmp8 = __builtin_va_arg_pack();
#line 163
    __cil_tmp9 = __openat64_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 163
    return (__cil_tmp9);
  }
  {
#line 166
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 166
  if (__cil_tmp10 < 1) {
    {
#line 167
    __cil_tmp11 = __openat64_2(__fd, __path, __oflag);
    }
#line 167
    return (__cil_tmp11);
  }
  {
#line 169
  __cil_tmp12 = __builtin_va_arg_pack();
#line 169
  __cil_tmp13 = __openat64_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 169
  return (__cil_tmp13);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , __timezone_ptr_t __tz ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 46 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void Panic(int err , char const   *fmt  , ...) ;
#line 339
void sched(void) ;
#line 39 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/sched.c"
static struct event *evs ;
#line 40
static struct event *tevs ;
#line 41
static struct event *nextev ;
#line 42
static int calctimeout ;
#line 44
static struct event *calctimo(void) ;
#line 50 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/sched.c"
void evenq(struct event *ev ) 
{ 
  struct event *evp ;
  struct event **evpp ;

  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if (ev->queued) {
#line 56
    return;
  }
#line 57
  evpp = & evs;
#line 58
  if (ev->type == 0) {
#line 60
    calctimeout = 1;
#line 61
    evpp = & tevs;
  }
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! evp) {
#line 63
      goto while_break___0;
    }
#line 64
    if (ev->pri > evp->pri) {
#line 65
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 63
  evpp = & evp->next;
#line 66
  ev->next = evp;
#line 67
  *evpp = ev;
#line 68
  ev->queued = 1;
  return;
}
}
#line 72 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/sched.c"
void evdeq(struct event *ev ) 
{ 
  struct event *evp ;
  struct event **evpp ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (! ev->queued) {
#line 78
    return;
  }
#line 79
  evpp = & evs;
#line 80
  if (ev->type == 0) {
#line 82
    calctimeout = 1;
#line 83
    evpp = & tevs;
  }
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 85
    if (! evp) {
#line 85
      goto while_break___0;
    }
#line 86
    if (evp == ev) {
#line 87
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  evpp = & evp->next;
  {
#line 88
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 88
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 89
  *evpp = ev->next;
#line 90
  ev->queued = 0;
#line 91
  if (ev == nextev) {
#line 92
    nextev = nextev->next;
  }
  return;
}
}
#line 96 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/sched.c"
static struct event *calctimo(void) 
{ 
  struct event *ev ;
  struct event *min ;
  long mins ;

  {
#line 101
  min = tevs;
#line 101
  if (min == (struct event *)0) {
#line 102
    return ((struct event *)0);
  }
#line 103
  mins = min->timeout.tv_sec;
#line 104
  ev = tevs->next;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! ev) {
#line 104
      goto while_break;
    }
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 107
    if (mins < ev->timeout.tv_sec) {
#line 108
      goto while_continue;
    }
#line 109
    if (mins > ev->timeout.tv_sec) {
#line 111
      min = ev;
#line 112
      mins = ev->timeout.tv_sec;
    } else
#line 109
    if (min->timeout.tv_usec > ev->timeout.tv_usec) {
#line 111
      min = ev;
#line 112
      mins = ev->timeout.tv_sec;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  ev = ev->next;
#line 115
  return (min);
}
}
#line 119 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/sched.c"
void sched(void) 
{ 
  struct event *ev ;
  fd_set r ;
  fd_set w ;
  fd_set *set ;
  struct event *timeoutev ;
  struct timeval timeout ;
  int nsel ;
  __time_t __cil_tmp9 ;
  int tmp ;
  struct timeval *tmp___0 ;
  int __cil_tmp16 ;
  int *__cil_tmp17 ;
  int *__cil_tmp18 ;
  fd_set *tmp___30 ;
  int __cil_tmp20 ;
  int tmp___31 ;

  {
#line 123
  timeoutev = (struct event *)0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! 1) {
#line 127
      goto while_break;
    }
#line 129
    if (calctimeout) {
      {
#line 130
      timeoutev = calctimo();
      }
    }
#line 131
    if (timeoutev) {
      {
#line 133
      gettimeofday(& timeout, (struct timezone *)((void *)0));
#line 135
      timeout.tv_sec = timeoutev->timeout.tv_sec - timeout.tv_sec;
#line 136
      timeout.tv_usec = timeoutev->timeout.tv_usec - timeout.tv_usec;
      }
#line 137
      if (timeout.tv_usec < 0L) {
#line 139
        timeout.tv_usec += (long )1000000;
#line 140
        __cil_tmp9 = timeout.tv_sec;
#line 140
        (timeout.tv_sec) --;
      }
#line 142
      if (timeout.tv_sec < 0L) {
#line 144
        timeout.tv_usec = (__suseconds_t )0;
#line 145
        timeout.tv_sec = (__time_t )0;
      }
    }
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      __asm__  ("cld; rep; stosq":);
#line 161
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 162
    while (1) {
      while_continue___1: /* CIL Label */ ;
      __asm__  ("cld; rep; stosq":);
#line 162
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 163
    ev = evs;
    {
#line 163
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 163
      if (! ev) {
#line 163
        goto while_break___2;
      }
#line 165
      if (ev->condneg) {
#line 165
        tmp = *(ev->condneg);
      } else {
#line 165
        tmp = 0;
      }
#line 165
      if (ev->condpos) {
#line 165
        if (*(ev->condpos) <= tmp) {
          {
#line 167
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 167
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 168
          goto while_continue___2;
        }
      }
#line 170
      if (ev->type == 1) {
#line 171
        r.fds_bits[0] |= (__fd_mask )(1UL << ev->fd % (8 * (int )sizeof(__fd_mask )));
      } else
#line 172
      if (ev->type == 2) {
#line 173
        w.fds_bits[0] |= (__fd_mask )(1UL << ev->fd % (8 * (int )sizeof(__fd_mask )));
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 163
    ev = ev->next;
#line 189
    if (timeoutev) {
#line 189
      tmp___0 = & timeout;
    } else {
#line 189
      tmp___0 = (struct timeval *)0;
    }
    {
#line 189
    __cil_tmp16 = select(1024, & r, & w, (fd_set *)0, tmp___0);
#line 189
    nsel = __cil_tmp16;
    }
#line 190
    if (nsel < 0) {
      {
#line 192
      __cil_tmp17 = __errno_location();
      }
#line 192
      if (*__cil_tmp17 != 4) {
        {
#line 204
        __cil_tmp18 = __errno_location();
#line 204
        Panic(*__cil_tmp18, (char const   *)((char *)"select"));
        }
      }
#line 206
      nsel = 0;
    } else
#line 208
    if (nsel == 0) {
      {
#line 210
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 210
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 211
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 211
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 212
      evdeq(timeoutev);
#line 213
      (timeoutev->handler)(timeoutev, timeoutev->data);
      }
    }
#line 220
    if (nsel) {
#line 221
      nsel = 2048;
    }
#line 224
    ev = evs;
    {
#line 224
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 224
      if (! ev) {
#line 224
        goto while_break___6;
      }
#line 226
      nextev = ev->next;
#line 227
      if (ev->type != 3) {
#line 229
        if (ev->type == 1) {
#line 229
          tmp___30 = & r;
        } else {
#line 229
          tmp___30 = & w;
        }
#line 229
        set = tmp___30;
#line 230
        if (nsel == 0) {
#line 231
          goto while_continue___6;
        } else
#line 230
        if (! ((set->fds_bits[0] & (__fd_mask )(1UL << ev->fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 231
          goto while_continue___6;
        }
#line 232
        __cil_tmp20 = nsel;
#line 232
        nsel --;
      }
#line 234
      if (ev->condneg) {
#line 234
        tmp___31 = *(ev->condneg);
      } else {
#line 234
        tmp___31 = 0;
      }
#line 234
      if (ev->condpos) {
#line 234
        if (*(ev->condpos) <= tmp___31) {
#line 235
          goto while_continue___6;
        }
      }
      {
#line 236
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 236
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 237
      (ev->handler)(ev, ev->data);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 224
    ev = nextev;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 243 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/sched.c"
void SetTimeout(struct event *ev , int timo ) 
{ 


  {
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 248
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 249
  gettimeofday(& ev->timeout, (struct timezone *)((void *)0));
#line 250
  ev->timeout.tv_sec += (long )(timo / 1000);
#line 251
  ev->timeout.tv_usec += (long )((timo % 1000) * 1000);
  }
#line 252
  if (ev->timeout.tv_usec > 1000000L) {
#line 254
    ev->timeout.tv_usec -= (long )1000000;
#line 255
    (ev->timeout.tv_sec) ++;
  }
#line 257
  if (ev->queued) {
#line 258
    calctimeout = 1;
  }
  return;
}
}
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 353 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.h"
int WindowChangeNumber(int old , int dest ) ;
#line 58 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
char *MakeWinMsgEv(char *str , struct win *win , int esc , int padlen , struct event *ev ,
                   int rec ) ;
#line 133
void Input(char *istr , int len , int mode , void (*finfunc)(char *buf , int len ,
                                                             char *priv ) , char *priv ,
           int data ) ;
#line 143
void WListUpdatecv(struct canvas *cv , struct win *p ) ;
#line 205
void DoAction(struct action *act , int key ) ;
#line 210
void SetForeWindow(struct win *wi ) ;
#line 231
void ApplyAttrColor(int i , struct mchar *mc ) ;
#line 232
void SwitchWindow(int n ) ;
#line 357
char *InStr(char *str , char const   *pat ) ;
#line 401
int AclCheckPermWin(struct acluser *u , int mode , struct win *w ) ;
#line 433
void LGotoPos(struct layer *l , int x , int y ) ;
#line 437
void LPutWinMsg(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) ;
#line 455
void LMsg(int err , char const   *fmt  , ...) ;
#line 57 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.h"
struct LayFuncs ListLf ;
#line 60
struct ListRow *glist_add_row(struct ListData *ldata , void *data , struct ListRow *after ) ;
#line 62
void glist_remove_rows(struct ListData *ldata ) ;
#line 64
void glist_display_all(struct ListData *list ) ;
#line 66
struct ListData *glist_display(struct GenericList *list , char const   *name ) ;
#line 68
void glist_abort(void) ;
#line 39 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
char *wlisttit ;
#line 40
char *wliststr ;
#line 42
struct mchar mchar_blank ;
#line 42
struct mchar mchar_so ;
#line 43
int renditions[3] ;
#line 45
struct win **wtab ;
#line 46
extern int maxwin ;
#line 48
char *noargs[1] ;
#line 50 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static char ListID[]  =    "window";
#line 89 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static int window_ancestor(struct win *a , struct win *d ) 
{ 


  {
#line 91
  if (! a) {
#line 92
    return (1);
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! d) {
#line 93
      goto while_break;
    }
#line 94
    if (d->w_group == a) {
#line 95
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  d = d->w_group;
#line 96
  return (0);
}
}
#line 100 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static void window_kill_confirm(char *buf , int len , char *data ) 
{ 
  struct win *w ;
  struct action act ;

  {
#line 102
  w = windows;
#line 105
  if (len) {
    {
    {
#line 107
    memset((void *)buf, 0, (unsigned long )len);
    }
    }
#line 108
    return;
  } else
#line 105
  if ((int )*buf != 121) {
#line 105
    if ((int )*buf != 89) {
      {
      {
#line 107
      memset((void *)buf, 0, (unsigned long )len);
      }
      }
#line 108
      return;
    }
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! w) {
#line 112
      goto while_break;
    }
#line 113
    if (w == (struct win *)data) {
#line 114
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  w = w->w_next;
#line 116
  if (! w) {
#line 117
    return;
  }
  {
#line 120
  fore = w;
#line 121
  act.nr = 96;
#line 122
  act.args = (char **)noargs;
#line 123
  act.argl = (int *)0;
#line 124
  act.quiet = 0;
#line 125
  DoAction(& act, - 1);
  }
  return;
}
}
#line 129 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static struct ListRow *gl_Window_add_group(struct ListData *ldata , struct ListRow *row ) 
{ 
  struct gl_Window_Data *wdata ;
  struct win *group ;
  struct win *w ;
  struct ListRow *cur ;
  struct win *_ww ;
  struct win **_ww___0 ;
  struct win *_witer ;

  {
#line 132
  wdata = (struct gl_Window_Data *)ldata->data;
#line 133
  group = (struct win *)row->data;
#line 134
  cur = row;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    if (wdata->order == 1) {
#line 138
      _ww = windows;
      {
#line 138
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 138
        if (! _ww) {
#line 138
          goto while_break___1;
        }
#line 138
        w = _ww;
#line 138
        if (w->w_group != group) {
#line 138
          goto while_continue___1;
        }
        {
#line 138
        cur = glist_add_row(ldata, (void *)w, cur);
        }
#line 138
        if (w == wdata->fore) {
#line 138
          ldata->selected = cur;
        }
#line 138
        if (w->w_type == 3) {
          {
#line 138
          cur = gl_Window_add_group(ldata, cur);
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 138
      _ww = _ww->w_next;
    } else {
#line 138
      _witer = windows;
#line 138
      _ww___0 = wtab;
      {
#line 138
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 138
        if (! (_witer && _ww___0 - wtab < (long )maxwin)) {
#line 138
          goto while_break___2;
        }
#line 138
        w = *_ww___0;
#line 138
        if (! w) {
#line 138
          goto while_continue___2;
        }
#line 138
        if (w->w_group != group) {
#line 138
          goto while_continue___2;
        }
        {
#line 138
        cur = glist_add_row(ldata, (void *)w, cur);
        }
#line 138
        if (w == wdata->fore) {
#line 138
          ldata->selected = cur;
        }
#line 138
        if (w->w_type == 3) {
          {
#line 138
          cur = gl_Window_add_group(ldata, cur);
          }
        }
#line 138
        _witer = _witer->w_next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 138
      _ww___0 ++;
    }
#line 138
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 150
  return (cur);
}
}
#line 154 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static void gl_Window_rebuild(struct ListData *ldata ) 
{ 
  struct ListRow *row ;
  struct gl_Window_Data *wdata ;
  struct win *w ;
  struct win *_ww ;
  struct win **_ww___0 ;
  struct win *_witer ;

  {
#line 156
  row = (struct ListRow *)((void *)0);
#line 157
  wdata = (struct gl_Window_Data *)ldata->data;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (wdata->order == 1) {
#line 160
      _ww = windows;
      {
#line 160
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 160
        if (! _ww) {
#line 160
          goto while_break___0;
        }
#line 160
        w = _ww;
#line 160
        if (w->w_group != wdata->group) {
#line 160
          goto while_continue___0;
        }
        {
#line 160
        row = glist_add_row(ldata, (void *)w, row);
        }
#line 160
        if (w == wdata->fore) {
#line 160
          ldata->selected = row;
        }
#line 160
        if (w->w_type == 3) {
#line 160
          if (wdata->nested) {
            {
#line 160
            row = gl_Window_add_group(ldata, row);
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 160
      _ww = _ww->w_next;
    } else {
#line 160
      _witer = windows;
#line 160
      _ww___0 = wtab;
      {
#line 160
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 160
        if (! (_witer && _ww___0 - wtab < (long )maxwin)) {
#line 160
          goto while_break___1;
        }
#line 160
        w = *_ww___0;
#line 160
        if (! w) {
#line 160
          goto while_continue___1;
        }
#line 160
        if (w->w_group != wdata->group) {
#line 160
          goto while_continue___1;
        }
        {
#line 160
        row = glist_add_row(ldata, (void *)w, row);
        }
#line 160
        if (w == wdata->fore) {
#line 160
          ldata->selected = row;
        }
#line 160
        if (w->w_type == 3) {
#line 160
          if (wdata->nested) {
            {
#line 160
            row = gl_Window_add_group(ldata, row);
            }
          }
        }
#line 160
        _witer = _witer->w_next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 160
      _ww___0 ++;
    }
#line 160
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  glist_display_all(ldata);
  }
  return;
}
}
#line 173 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static struct ListRow *gl_Window_findrow(struct ListData *ldata , struct win *p ) 
{ 
  struct ListRow *row ;

  {
#line 175
  row = ldata->root;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! row) {
#line 176
      goto while_break;
    }
#line 178
    if (row->data == (void *)p) {
#line 179
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  row = row->next;
#line 181
  return (row);
}
}
#line 185 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static int gl_Window_remove(struct ListData *ldata , struct win *p ) 
{ 
  struct ListRow *row ;
  struct ListRow *__cil_tmp4 ;
  struct ListRow *tmp ;
  struct ListRow *tmp___32 ;

  {
  {
#line 187
  __cil_tmp4 = gl_Window_findrow(ldata, p);
#line 187
  row = __cil_tmp4;
  }
#line 188
  if (! row) {
#line 189
    return (0);
  }
#line 192
  if (row->next) {
#line 193
    (row->next)->prev = row->prev;
  }
#line 194
  if (row->prev) {
#line 195
    (row->prev)->next = row->next;
  }
#line 197
  if (ldata->selected == row) {
#line 198
    if (row->prev) {
#line 198
      tmp = row->prev;
    } else {
#line 198
      tmp = row->next;
    }
#line 198
    ldata->selected = tmp;
  }
#line 199
  if (ldata->top == row) {
#line 200
    if (row->prev) {
#line 200
      tmp___32 = row->prev;
    } else {
#line 200
      tmp___32 = row->next;
    }
#line 200
    ldata->top = tmp___32;
  }
#line 201
  if (ldata->root == row) {
#line 202
    ldata->root = row->next;
  }
  {
#line 204
  ((ldata->list_fn)->gl_freerow)(ldata, row);
#line 205
  free((void *)row);
  }
#line 207
  return (1);
}
}
#line 211 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static int gl_Window_header(struct ListData *ldata ) 
{ 
  char *str ;
  struct gl_Window_Data *wdata ;
  int g ;
  size_t __cil_tmp5 ;
  size_t __cil_tmp7 ;

  {
#line 214
  wdata = (struct gl_Window_Data *)ldata->data;
#line 217
  g = wdata->group != (struct win *)((void *)0);
#line 217
  if (g) {
    {
#line 219
    LPutWinMsg(flayer, (char *)"Group: ", 7, & mchar_blank, 0, 0);
#line 220
    __cil_tmp5 = strlen((char const   *)(wdata->group)->w_title);
#line 220
    LPutWinMsg(flayer, (wdata->group)->w_title, (int )__cil_tmp5, & mchar_blank, 7,
               0);
    }
  }
  {
#line 223
  str = MakeWinMsgEv(wlisttit, (struct win *)0, '%', flayer->l_width, (struct event *)0,
                     0);
#line 225
  __cil_tmp7 = strlen((char const   *)str);
#line 225
  LPutWinMsg(flayer, str, (int )__cil_tmp7, & mchar_blank, 0, g);
  }
#line 226
  return (2 + g);
}
}
#line 230 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static int gl_Window_footer(struct ListData *ldata ) 
{ 


  {
#line 232
  return (0);
}
}
#line 236 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static int gl_Window_row(struct ListData *ldata , struct ListRow *lrow ) 
{ 
  char *str ;
  struct win *w ;
  struct win *g ;
  int xoff ;
  struct mchar *mchar ;
  struct mchar mchar_rend ;
  struct gl_Window_Data *wdata ;

  {
#line 242
  mchar_rend = mchar_blank;
#line 243
  wdata = (struct gl_Window_Data *)ldata->data;
#line 245
  w = (struct win *)lrow->data;
#line 252
  g = w->w_group;
#line 252
  xoff = 0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (g != wdata->group)) {
#line 252
      goto while_break;
    }
#line 253
    xoff += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  g = g->w_group;
#line 254
  str = MakeWinMsgEv(wliststr, w, '%', flayer->l_width - xoff, (struct event *)((void *)0),
                     0);
  }
#line 255
  if (ldata->selected == lrow) {
#line 256
    mchar = & mchar_so;
  } else
#line 257
  if (w->w_monitor == 3) {
#line 257
    if (renditions[1] != -1) {
      {
#line 259
      mchar = & mchar_rend;
#line 260
      ApplyAttrColor(renditions[1], mchar);
      }
    } else {
#line 257
      goto _L___35;
    }
  } else
  _L___35: /* CIL Label */ 
#line 262
  if (w->w_bell == 2) {
    _L___34: /* CIL Label */ 
#line 262
    if (renditions[0] != -1) {
      {
#line 264
      mchar = & mchar_rend;
#line 265
      ApplyAttrColor(renditions[0], mchar);
      }
    } else {
#line 262
      goto _L___33;
    }
  } else
#line 262
  if (w->w_bell == 1) {
#line 262
    goto _L___34;
  } else
  _L___33: /* CIL Label */ 
#line 267
  if (w->w_silence == 2) {
    _L: /* CIL Label */ 
#line 267
    if (renditions[2] != -1) {
      {
#line 269
      mchar = & mchar_rend;
#line 270
      ApplyAttrColor(renditions[2], mchar);
      }
    } else {
#line 273
      mchar = & mchar_blank;
    }
  } else
#line 267
  if (w->w_silence == 3) {
#line 267
    goto _L;
  } else {
#line 273
    mchar = & mchar_blank;
  }
  {
#line 275
  LPutWinMsg(flayer, str, flayer->l_width, mchar, xoff, lrow->y);
  }
#line 276
  if (xoff) {
    {
#line 277
    LPutWinMsg(flayer, (char *)"", xoff, mchar, 0, lrow->y);
    }
  }
#line 279
  return (1);
}
}
#line 283 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static int gl_Window_input(struct ListData *ldata , char **inp , int *len ) 
{ 
  struct win *win ;
  unsigned char ch ;
  struct display *cd ;
  struct gl_Window_Data *wdata ;
  int __cil_tmp8 ;
  int tmp ;
  int order ;
  int tmp___38 ;
  struct win *g ;
  int order___0 ;
  int tmp___39 ;
  struct win *pw ;
  struct win *nw ;
  char str[768] ;
  int fnumber ;
  int tmp___40 ;
  struct ListRow *row ;
  struct win *w ;
  struct ListRow *old ;

  {
#line 287
  cd = display;
#line 288
  wdata = (struct gl_Window_Data *)ldata->data;
#line 290
  if (! ldata->selected) {
#line 291
    return (0);
  }
#line 293
  ch = (unsigned char )*(*inp);
#line 294
  (*inp) ++;
#line 295
  (*len) --;
#line 297
  win = (struct win *)(ldata->selected)->data;
  {
#line 302
  if ((int )ch == '\r') {
#line 302
    goto case_13;
  }
#line 302
  if ((int )ch == '\n') {
#line 302
    goto case_13;
  }
#line 302
  if ((int )ch == ' ') {
#line 302
    goto case_13;
  }
#line 322
  if ((int )ch == 'm') {
#line 322
    goto case_109;
  }
#line 329
  if ((int )ch == 'g') {
#line 329
    goto case_103;
  }
#line 336
  if ((int )ch == 'a') {
#line 336
    goto case_97;
  }
#line 355
  if ((int )ch == 127) {
#line 355
    goto case_127;
  }
#line 355
  if ((int )ch == 8) {
#line 355
    goto case_127;
  }
#line 379
  if ((int )ch == ',') {
#line 379
    goto case_44;
  }
#line 394
  if ((int )ch == '.') {
#line 394
    goto case_46;
  }
#line 406
  if ((int )ch == 'K') {
#line 406
    goto case_75;
  }
#line 416
  if ((int )ch == 7) {
#line 416
    goto case_7;
  }
#line 416
  if ((int )ch == 27) {
#line 416
    goto case_7;
  }
#line 427
  goto switch_default;
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 303
  if (! win) {
#line 304
    goto switch_break;
  }
  {
#line 306
  __cil_tmp8 = AclCheckPermWin(display->d_user, 2, win);
  }
#line 306
  if (display) {
#line 306
    if (__cil_tmp8) {
#line 307
      return (0);
    }
  }
#line 309
  if (wdata->group) {
#line 309
    if (! wdata->onblank) {
#line 309
      if ((struct win *)(flayer->l_bottom)->l_data) {
#line 309
        if (((struct win *)(flayer->l_bottom)->l_data)->w_type == 3) {
          {
#line 310
          SwitchWindow(win->w_number);
          }
        } else {
#line 309
          goto _L;
        }
      } else {
#line 309
        goto _L;
      }
    } else {
#line 309
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 314
    glist_abort();
#line 315
    display = cd;
    }
#line 316
    if (display->d_fore != win) {
      {
#line 317
      SwitchWindow(win->w_number);
      }
    }
  }
#line 319
  *len = 0;
#line 320
  goto switch_break;
  case_109: /* CIL Label */ 
#line 324
  if (wdata->order == 1) {
#line 324
    tmp = 0;
  } else {
#line 324
    tmp = 1;
  }
  {
#line 324
  wdata->order = tmp;
#line 325
  glist_remove_rows(ldata);
#line 326
  gl_Window_rebuild(ldata);
  }
#line 327
  goto switch_break;
  case_103: /* CIL Label */ 
#line 331
  wdata->nested = ! wdata->nested;
  {
#line 332
  glist_remove_rows(ldata);
#line 333
  gl_Window_rebuild(ldata);
  }
#line 334
  goto switch_break;
  case_97: /* CIL Label */ 
#line 338
  if (wdata->group) {
#line 340
    if (wdata->nested) {
#line 340
      tmp___38 = 2;
    } else {
#line 340
      tmp___38 = 0;
    }
    {
#line 340
    order = wdata->order | tmp___38;
#line 341
    glist_abort();
#line 342
    display = cd;
#line 343
    display_windows(1, order, (struct win *)((void *)0));
#line 344
    *len = 0;
    }
  } else
#line 346
  if (! wdata->nested) {
    {
#line 348
    wdata->nested = 1;
#line 349
    glist_remove_rows(ldata);
#line 350
    gl_Window_rebuild(ldata);
    }
  }
#line 352
  goto switch_break;
  case_127: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 356
  if (! wdata->group) {
#line 357
    goto switch_break;
  }
#line 358
  if ((wdata->group)->w_group) {
    {
#line 361
    g = (wdata->group)->w_group;
#line 362
    glist_abort();
#line 363
    display = cd;
#line 364
    SetForeWindow(g);
#line 365
    *len = 0;
    }
  } else {
#line 371
    if (wdata->nested) {
#line 371
      tmp___39 = 2;
    } else {
#line 371
      tmp___39 = 0;
    }
    {
#line 371
    order___0 = wdata->order | tmp___39;
#line 372
    glist_abort();
#line 373
    display = cd;
#line 374
    display_windows(1, order___0, (struct win *)((void *)0));
#line 375
    *len = 0;
    }
  }
#line 377
  goto switch_break;
  case_44: /* CIL Label */ 
#line 380
  if (wdata->order == 0) {
#line 380
    if ((ldata->selected)->prev) {
#line 382
      pw = (struct win *)((ldata->selected)->prev)->data;
#line 383
      if (win->w_group != pw->w_group) {
#line 384
        goto switch_break;
      }
      {
#line 389
      wdata->fore = win;
#line 390
      WindowChangeNumber(win->w_number, pw->w_number);
      }
    }
  }
#line 392
  goto switch_break;
  case_46: /* CIL Label */ 
#line 395
  if (wdata->order == 0) {
#line 395
    if ((ldata->selected)->next) {
#line 397
      nw = (struct win *)((ldata->selected)->next)->data;
#line 398
      if (win->w_group != nw->w_group) {
#line 399
        goto switch_break;
      }
      {
#line 401
      wdata->fore = win;
#line 402
      WindowChangeNumber(win->w_number, nw->w_number);
      }
    }
  }
#line 404
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 409
  snprintf((char *)str, sizeof(str) - 1UL, (char const   *)((char *)"Really kill window %d (%s) [y/n]"),
           win->w_number, win->w_title);
#line 411
  Input((char *)str, 1, 2, window_kill_confirm, (char *)win, 0);
  }
#line 413
  goto switch_break;
  case_7: /* CIL Label */ 
  case_27: /* CIL Label */ 
#line 417
  if (! (((wdata->group && ! wdata->onblank) && (struct win *)(flayer->l_bottom)->l_data) && ((struct win *)(flayer->l_bottom)->l_data)->w_type == 3)) {
#line 419
    if (wdata->onblank) {
#line 419
      tmp___40 = (wdata->fore)->w_number;
    } else {
#line 419
      tmp___40 = - 1;
    }
    {
#line 419
    fnumber = tmp___40;
#line 420
    glist_abort();
#line 421
    display = cd;
    }
#line 422
    if (fnumber >= 0) {
      {
#line 423
      SwitchWindow(fnumber);
      }
    }
#line 424
    *len = 0;
  }
#line 426
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 428
  if ((int )ch >= 48) {
#line 428
    if ((int )ch <= 57) {
#line 430
      row = ldata->root;
      {
#line 431
      while (1) {
        while_continue: /* CIL Label */ ;
#line 431
        if (! row) {
#line 431
          goto while_break;
        }
#line 433
        w = (struct win *)row->data;
#line 434
        if (w->w_number == (int )ch - 48) {
#line 436
          old = ldata->selected;
#line 437
          if (old == row) {
#line 438
            goto while_break;
          }
#line 439
          ldata->selected = row;
#line 440
          if ((ldata->selected)->y == -1) {
            {
#line 444
            ldata->top = row;
#line 445
            glist_display_all(ldata);
            }
          } else {
            {
#line 450
            ((ldata->list_fn)->gl_printrow)(ldata, old);
#line 451
            ((ldata->list_fn)->gl_printrow)(ldata, ldata->selected);
#line 452
            flayer->l_y = (ldata->selected)->y;
#line 453
            LGotoPos(flayer, flayer->l_x, flayer->l_y);
            }
          }
#line 455
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 431
      row = row->next;
#line 458
      goto switch_break;
    }
  }
#line 460
  (*inp) --;
#line 461
  (*len) ++;
#line 462
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 464
  return (1);
}
}
#line 468 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static int gl_Window_freerow(struct ListData *ldata , struct ListRow *row ) 
{ 


  {
#line 470
  return (0);
}
}
#line 474 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static int gl_Window_free(struct ListData *ldata ) 
{ 


  {
#line 476
  if (ldata->data == (void *)0) {
    {
#line 476
    abort();
    }
  } else {
    {
#line 476
    free(ldata->data);
    }
  }
#line 476
  ldata->data = (void *)0;
#line 477
  return (0);
}
}
#line 481 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static int gl_Window_match(struct ListData *ldata , struct ListRow *row , char const   *needle ) 
{ 
  struct win *w ;
  char *__cil_tmp5 ;

  {
  {
#line 483
  w = (struct win *)row->data;
#line 484
  __cil_tmp5 = InStr(w->w_title, needle);
  }
#line 484
  if (__cil_tmp5) {
#line 485
    return (1);
  }
#line 486
  return (0);
}
}
#line 489 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static struct GenericList gl_Window  =    {gl_Window_header, gl_Window_footer, gl_Window_row, gl_Window_input, gl_Window_freerow,
    gl_Window_free, gl_Window_match};
#line 501 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
void display_windows(int onblank , int order , struct win *group ) 
{ 
  struct win *p ;
  struct ListData *ldata ;
  struct gl_Window_Data *wdata ;
  void *__cil_tmp8 ;

  {
#line 507
  if (flayer->l_width < 10) {
    {
    {
#line 509
    LMsg(0, (char const   *)((char *)"Window size too small for window list page"));
    }
    }
#line 510
    return;
  } else
#line 507
  if (flayer->l_height < 6) {
    {
    {
#line 509
    LMsg(0, (char const   *)((char *)"Window size too small for window list page"));
    }
    }
#line 510
    return;
  }
#line 513
  if (group) {
#line 514
    onblank = 0;
  }
#line 516
  if (onblank) {
    {
#line 518
    while (1) {
      while_continue: /* CIL Label */ ;
#line 518
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 519
    if (! display) {
      {
#line 521
      LMsg(0, (char const   *)((char *)"windowlist -b: display required"));
      }
#line 522
      return;
    }
#line 524
    p = display->d_fore;
#line 525
    if (p) {
      {
#line 527
      SetForeWindow((struct win *)0);
      }
#line 528
      if (p->w_group) {
#line 530
        display->d_fore = p->w_group;
#line 531
        flayer->l_data = (void *)((char *)p->w_group);
      }
      {
#line 533
      Activate(0);
      }
    }
#line 535
    if (flayer->l_width < 10) {
      {
      {
#line 537
      LMsg(0, (char const   *)((char *)"Window size too small for window list page"));
      }
      }
#line 538
      return;
    } else
#line 535
    if (flayer->l_height < 6) {
      {
      {
#line 537
      LMsg(0, (char const   *)((char *)"Window size too small for window list page"));
      }
      }
#line 538
      return;
    }
  } else {
#line 542
    p = (struct win *)(flayer->l_bottom)->l_data;
  }
#line 543
  if (! group) {
#line 543
    if (p) {
#line 544
      group = p->w_group;
    }
  }
  {
#line 546
  ldata = glist_display(& gl_Window, (char const   *)((char *)ListID));
  }
#line 547
  if (! ldata) {
#line 549
    if (onblank) {
#line 549
      if (p) {
        {
#line 552
        SetForeWindow(p);
#line 553
        Activate(1);
        }
      }
    }
#line 555
    return;
  }
  {
#line 558
  __cil_tmp8 = calloc((unsigned long )1, sizeof(struct gl_Window_Data ));
#line 558
  wdata = (struct gl_Window_Data *)__cil_tmp8;
#line 559
  wdata->group = group;
#line 560
  wdata->order = order & -3;
#line 561
  wdata->nested = ! (! (order & 2));
#line 562
  wdata->onblank = onblank;
#line 565
  wdata->fore = windows;
  }
  {
#line 566
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 566
    if (! (wdata->fore && (wdata->fore)->w_group != group)) {
#line 566
      goto while_break___0;
    }
#line 567
    wdata->fore = (wdata->fore)->w_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 569
  ldata->data = (void *)wdata;
#line 571
  gl_Window_rebuild(ldata);
  }
  return;
}
}
#line 575 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
static void WListUpdate(struct win *p , struct ListData *ldata ) 
{ 
  struct gl_Window_Data *wdata ;
  struct ListRow *row ;
  struct ListRow *rbefore ;
  struct win *before ;
  int d ;
  int sel ;
  int __cil_tmp10 ;
  struct win **w ;
  struct win **__cil_tmp12 ;

  {
#line 577
  wdata = (struct gl_Window_Data *)ldata->data;
#line 580
  d = 0;
#line 580
  sel = 0;
#line 582
  if (! p) {
#line 584
    if (ldata->selected) {
#line 585
      wdata->fore = (struct win *)(ldata->selected)->data;
    }
    {
#line 586
    glist_remove_rows(ldata);
#line 587
    gl_Window_rebuild(ldata);
    }
#line 588
    return;
  }
#line 592
  d = 1;
#line 593
  if (wdata->order == 0) {
    _L: /* CIL Label */ 
#line 595
    if (p->w_group != wdata->group) {
#line 597
      if (! wdata->nested) {
#line 598
        d = 0;
      } else {
        {
#line 600
        d = window_ancestor(wdata->group, p);
        }
      }
    }
  } else
#line 593
  if (wdata->order == 1) {
#line 593
    goto _L;
  }
#line 604
  if (! d) {
    {
#line 606
    __cil_tmp10 = gl_Window_remove(ldata, p);
    }
#line 606
    if (__cil_tmp10) {
      {
#line 607
      glist_display_all(ldata);
      }
    }
#line 608
    return;
  }
#line 615
  before = (struct win *)((void *)0);
#line 616
  if (wdata->order == 1) {
#line 618
    if (windows != p) {
#line 619
      before = windows;
      {
#line 619
      while (1) {
        while_continue: /* CIL Label */ ;
#line 619
        if (! before) {
#line 619
          goto while_break;
        }
#line 620
        if (before->w_next == p) {
#line 621
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 619
      before = before->w_next;
    }
  } else
#line 623
  if (wdata->order == 0) {
#line 625
    if (p->w_number != 0) {
#line 627
      w = (wtab + p->w_number) - 1;
      {
#line 628
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 628
        if (! (w >= wtab)) {
#line 628
          goto while_break___0;
        }
#line 630
        if (*w) {
#line 630
          if ((*w)->w_group == wdata->group) {
#line 632
            before = *w;
#line 633
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 628
      __cil_tmp12 = w;
#line 628
      w --;
    }
  }
#line 640
  if (before) {
    {
#line 641
    rbefore = gl_Window_findrow(ldata, before);
    }
  } else
#line 642
  if (wdata->nested) {
#line 642
    if (p->w_group) {
      {
#line 643
      rbefore = gl_Window_findrow(ldata, p->w_group);
      }
    } else {
#line 645
      rbefore = (struct ListRow *)((void *)0);
    }
  } else {
#line 645
    rbefore = (struct ListRow *)((void *)0);
  }
  {
#line 648
  row = gl_Window_findrow(ldata, p);
  }
#line 649
  if (row) {
#line 651
    if (row->prev != rbefore) {
      {
#line 653
      sel = (ldata->selected)->data == (void *)p;
#line 654
      gl_Window_remove(ldata, p);
      }
    } else {
#line 657
      p = (struct win *)((void *)0);
    }
  }
#line 659
  if (p) {
    {
#line 661
    row = glist_add_row(ldata, (void *)p, rbefore);
    }
#line 662
    if (sel) {
#line 663
      ldata->selected = row;
    }
  }
  {
#line 665
  glist_display_all(ldata);
  }
  return;
}
}
#line 669 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
void WListUpdatecv(struct canvas *cv , struct win *p ) 
{ 
  struct ListData *ldata ;
  struct gl_Window_Data *wdata ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
#line 676
  if ((cv->c_layer)->l_layfn != & ListLf) {
#line 677
    return;
  }
#line 678
  ldata = (struct ListData *)(cv->c_layer)->l_data;
#line 679
  if (ldata->name != (char const   *)((char *)ListID)) {
#line 680
    return;
  }
  {
#line 681
  wdata = (struct gl_Window_Data *)ldata->data;
#line 682
  olddisplay = display;
#line 682
  oldflayer = flayer;
#line 682
  l = cv->c_layer;
#line 682
  cvlist = l->l_cvlist;
#line 682
  cvlnext = cv->c_lnext;
#line 682
  flayer = l;
#line 682
  l->l_cvlist = cv;
#line 682
  cv->c_lnext = (struct canvas *)0;
#line 682
  WListUpdate(p, ldata);
#line 682
  flayer = oldflayer;
#line 682
  l->l_cvlist = cvlist;
#line 682
  cv->c_lnext = cvlnext;
#line 682
  display = olddisplay;
  }
  return;
}
}
#line 686 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_window.c"
void WListLinkChanged(void) 
{ 
  struct display *olddisplay ;
  struct canvas *cv ;
  struct ListData *ldata ;
  struct gl_Window_Data *wdata ;
  struct display *olddisplay___41 ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
#line 688
  olddisplay = display;
#line 693
  display = displays;
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 693
    if (! display) {
#line 693
      goto while_break;
    }
#line 694
    cv = display->d_cvlist;
    {
#line 694
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 694
      if (! cv) {
#line 694
        goto while_break___0;
      }
#line 696
      if (! cv->c_layer) {
#line 697
        goto while_continue___0;
      } else
#line 696
      if ((cv->c_layer)->l_layfn != & ListLf) {
#line 697
        goto while_continue___0;
      }
#line 698
      ldata = (struct ListData *)(cv->c_layer)->l_data;
#line 699
      if (ldata->name != (char const   *)((char *)ListID)) {
#line 700
        goto while_continue___0;
      }
#line 701
      wdata = (struct gl_Window_Data *)ldata->data;
#line 702
      if (! (wdata->order & 1)) {
#line 703
        goto while_continue___0;
      }
      {
#line 704
      olddisplay___41 = display;
#line 704
      oldflayer = flayer;
#line 704
      l = cv->c_layer;
#line 704
      cvlist = l->l_cvlist;
#line 704
      cvlnext = cv->c_lnext;
#line 704
      flayer = l;
#line 704
      l->l_cvlist = cv;
#line 704
      cv->c_lnext = (struct canvas *)0;
#line 704
      WListUpdate((struct win *)0, ldata);
#line 704
      flayer = oldflayer;
#line 704
      l->l_cvlist = cvlist;
#line 704
      cv->c_lnext = cvlnext;
#line 704
      display = olddisplay___41;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 694
    cv = cv->c_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 693
  display = display->d_next;
#line 706
  display = olddisplay;
  return;
}
}
#line 41 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void Detach(int mode ) ;
#line 140
void display_displays(void) ;
#line 361
void centerline(char *str , int y ) ;
#line 362
void leftline(char *str , int y , struct mchar *rend ) ;
#line 46 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_display.c"
static char ListID___0[]  =    "display";
#line 70 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_display.c"
static int gl_Display_header(struct ListData *ldata ) 
{ 


  {
  {
#line 72
  leftline((char *)"term-type   size         user interface           window       Perms",
           0, (struct mchar *)0);
#line 73
  leftline((char *)"---------- ------- ---------- ----------------- ----------     -----",
           1, (struct mchar *)0);
  }
#line 74
  return (2);
}
}
#line 78 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_display.c"
static int gl_Display_footer(struct ListData *ldata ) 
{ 


  {
  {
#line 80
  centerline((char *)"[Press Space to refresh; Return to end.]", flayer->l_height - 1);
  }
#line 81
  return (1);
}
}
#line 85 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_display.c"
static int gl_Display_row(struct ListData *ldata , struct ListRow *lrow ) 
{ 
  struct display *d ;
  char tbuf[80] ;
  static char *blockstates[5] ;
  struct win *w ;
  struct mchar m_current ;
  char *tmp ;
  int l ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  int tmp___42 ;
  int __cil_tmp13 ;
  int tmp___43 ;
  int tmp___44 ;
  int __cil_tmp16 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int __cil_tmp20 ;
  int tmp___48 ;
  struct mchar *tmp___49 ;
  struct mchar *tmp___50 ;

  {
#line 87
  d = (struct display *)lrow->data;
#line 89
  blockstates[0] = (char *)"nb";
#line 89
  blockstates[1] = (char *)"NB";
#line 89
  blockstates[2] = (char *)"Z<";
#line 89
  blockstates[3] = (char *)"Z>";
#line 89
  blockstates[4] = (char *)"BL";
#line 90
  w = d->d_fore;
#line 91
  m_current = mchar_blank;
#line 92
  m_current.attr = (unsigned char )(1 << 2);
#line 94
  if ((d->d_blocked || d->d_nonblock >= 0) && d->d_blocked <= 4) {
#line 94
    tmp = blockstates[d->d_blocked];
  } else {
#line 94
    tmp = (char *)"  ";
  }
  {
#line 94
  sprintf((char *)tbuf, (char const   *)((char *)" %-10.10s%4dx%-4d%10.10s@%-16.16s%s"),
          (char *)d->d_termname, d->d_width, d->d_height, (char *)(d->d_user)->u_name,
          (char *)d->d_usertty, tmp);
  }
#line 99
  if (w) {
    {
#line 101
    __cil_tmp10 = strlen((char const   *)w->w_title);
#line 101
    l = (int )(10UL - __cil_tmp10);
    }
#line 102
    if (l < 0) {
#line 103
      l = 0;
    }
    {
#line 104
    __cil_tmp11 = strlen((char const   *)((char *)tbuf));
    }
#line 104
    tmp___42 = ' ';
    {
#line 104
    __cil_tmp13 = AclCheckPermWin(d->d_user, 2, w);
    }
#line 104
    if (__cil_tmp13) {
#line 104
      tmp___44 = '-';
    } else {
#line 104
      if (w->w_wlock == 0 || d->d_user == w->w_wlockuser) {
#line 104
        tmp___43 = 'r';
      } else {
#line 104
        tmp___43 = 'R';
      }
#line 104
      tmp___44 = tmp___43;
    }
    {
#line 104
    __cil_tmp16 = AclCheckPermWin(d->d_user, 2, w);
    }
#line 104
    if (__cil_tmp16) {
#line 104
      tmp___47 = '-';
    } else {
#line 104
      if (w->w_wlock == 0) {
#line 104
        tmp___46 = 'w';
      } else {
#line 104
        if (d->d_user == w->w_wlockuser) {
#line 104
          tmp___45 = 'W';
        } else {
#line 104
          tmp___45 = 'v';
        }
#line 104
        tmp___46 = tmp___45;
      }
#line 104
      tmp___47 = tmp___46;
    }
    {
#line 104
    __cil_tmp20 = AclCheckPermWin(d->d_user, 2, w);
    }
#line 104
    if (__cil_tmp20) {
#line 104
      tmp___48 = '-';
    } else {
#line 104
      tmp___48 = 'x';
    }
    {
#line 104
    sprintf((char *)tbuf + __cil_tmp11, (char const   *)((char *)"%3d(%.10s)%*s%c%c%c%c"),
            w->w_number, w->w_title, l, (char *)"", tmp___42, tmp___44, tmp___47,
            tmp___48);
    }
  }
#line 127
  if (lrow == ldata->selected) {
#line 127
    tmp___50 = & mchar_so;
  } else {
#line 127
    if (d == display) {
#line 127
      tmp___49 = & m_current;
    } else {
#line 127
      tmp___49 = (struct mchar *)0;
    }
#line 127
    tmp___50 = tmp___49;
  }
  {
#line 127
  leftline((char *)tbuf, lrow->y, tmp___50);
  }
#line 129
  return (1);
}
}
#line 133 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_display.c"
static void gl_Display_rebuild(struct ListData *ldata ) 
{ 
  struct display *d ;
  struct ListRow *row ;

  {
#line 137
  row = (struct ListRow *)((void *)0);
#line 138
  d = displays;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! d) {
#line 138
      goto while_break;
    }
    {
#line 140
    row = glist_add_row(ldata, (void *)d, row);
    }
#line 141
    if (d == display) {
#line 142
      ldata->selected = row;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  d = d->d_next;
#line 145
  glist_display_all(ldata);
  }
  return;
}
}
#line 149 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_display.c"
static int gl_Display_input(struct ListData *ldata , char **inp , int *len ) 
{ 
  struct display *cd ;
  unsigned char ch ;
  int tmp ;

  {
#line 151
  cd = display;
#line 154
  if (! ldata->selected) {
#line 155
    return (0);
  }
#line 157
  ch = (unsigned char )*(*inp);
#line 158
  (*inp) ++;
#line 159
  (*len) --;
  {
#line 163
  if ((int )ch == ' ') {
#line 163
    goto case_32;
  }
#line 169
  if ((int )ch == '\n') {
#line 169
    goto case_10;
  }
#line 169
  if ((int )ch == '\r') {
#line 169
    goto case_10;
  }
#line 176
  if ((int )ch == 'D') {
#line 176
    goto case_68;
  }
#line 176
  if ((int )ch == 'd') {
#line 176
    goto case_68;
  }
#line 193
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 164
  glist_remove_rows(ldata);
  }
  {
#line 165
  gl_Display_rebuild(ldata);
  }
#line 166
  goto switch_break;
  case_10: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
#line 170
  glist_abort();
  }
#line 171
  *len = 0;
#line 172
  goto switch_break;
  case_68: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 177
  display = (struct display *)(ldata->selected)->data;
#line 178
  if (display == cd) {
#line 179
    goto switch_break;
  }
#line 180
  if ((int )ch == 68) {
#line 180
    tmp = 4;
  } else {
#line 180
    tmp = 2;
  }
  {
#line 180
  Detach(tmp);
#line 187
  display = cd;
#line 188
  glist_remove_rows(ldata);
#line 189
  gl_Display_rebuild(ldata);
  }
#line 190
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 195
  (*inp) --;
#line 196
  (*len) ++;
#line 197
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 199
  return (1);
}
}
#line 203 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_display.c"
static int gl_Display_freerow(struct ListData *ldata , struct ListRow *row ) 
{ 


  {
#line 206
  return (0);
}
}
#line 210 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_display.c"
static int gl_Display_free(struct ListData *ldata ) 
{ 


  {
#line 213
  return (0);
}
}
#line 216 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_display.c"
static struct GenericList gl_Display  =    {gl_Display_header, gl_Display_footer, gl_Display_row, gl_Display_input, gl_Display_freerow,
    gl_Display_free, (void *)0};
#line 228 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_display.c"
void display_displays(void) 
{ 
  struct ListData *ldata ;

  {
#line 231
  if (flayer->l_width < 10) {
    {
    {
#line 233
    LMsg(0, (char const   *)((char *)"Window size too small for displays page"));
    }
    }
#line 234
    return;
  } else
#line 231
  if (flayer->l_height < 5) {
    {
    {
#line 233
    LMsg(0, (char const   *)((char *)"Window size too small for displays page"));
    }
    }
#line 234
    return;
  }
  {
#line 237
  ldata = glist_display(& gl_Display, (char const   *)((char *)ListID___0));
  }
#line 238
  if (! ldata) {
#line 239
    return;
  }
  {
#line 241
  gl_Display_rebuild(ldata);
  }
  return;
}
}
#line 257 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void DefClearLine(int y , int xs , int xe , int bce ) ;
#line 260
void DefRestore(void) ;
#line 440
void LClearAll(struct layer *l , int uself ) ;
#line 441
void LClearArea(struct layer *l , int xs , int ys , int xe , int ye , int bce , int uself ) ;
#line 443
void LRefreshAll(struct layer *l , int isblank ) ;
#line 460
int InitOverlayPage(int datasize , struct LayFuncs *lf , int block ) ;
#line 462
int LayProcessMouse(struct layer *l , unsigned char ch ) ;
#line 463
void LayProcessMouseSwitch(struct layer *l , int s ) ;
#line 33 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static void ListProcess(char **ppbuf , int *plen ) ;
#line 34
static void ListAbort(void) ;
#line 35
static void ListRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 36
static void ListClearLine(int y , int xs , int xe , int bce ) ;
#line 37
static int ListRewrite(int y , int xs , int xe , struct mchar *rend , int doit ) ;
#line 38
static int ListResize(int wi , int he ) ;
#line 39
static void ListRestore(void) ;
#line 40
static void ListFree(void *d ) ;
#line 42 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
struct LayFuncs ListLf  = 
#line 42
     {ListProcess, ListAbort, ListRedisplayLine, ListClearLine, ListRewrite, ListResize,
    ListRestore, ListFree};
#line 56 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
struct ListData *glist_display(struct GenericList *list , char const   *name ) 
{ 
  struct ListData *ldata ;
  int __cil_tmp4 ;

  {
  {
#line 60
  __cil_tmp4 = InitOverlayPage((int )sizeof(struct ListData ), & ListLf, 0);
  }
#line 60
  if (__cil_tmp4) {
#line 61
    return ((struct ListData *)((void *)0));
  }
#line 62
  ldata = (struct ListData *)flayer->l_data;
#line 64
  ldata->name = name;
#line 65
  ldata->list_fn = list;
#line 67
  flayer->l_mode = 1;
#line 68
  flayer->l_x = 0;
#line 69
  flayer->l_y = flayer->l_height - 1;
#line 71
  return (ldata);
}
}
#line 75 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static void glist_decide_top(struct ListData *ldata ) 
{ 
  int count ;
  struct ListRow *top ;
  int __cil_tmp4 ;

  {
#line 77
  count = flayer->l_height - 5;
#line 78
  top = ldata->selected;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (count && top != ldata->root)) {
#line 79
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 79
  __cil_tmp4 = count;
#line 79
  count --;
#line 79
  top = top->prev;
#line 81
  ldata->top = top;
  return;
}
}
#line 85 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static struct ListRow *glist_search_dir(struct ListData *ldata , struct ListRow *start ,
                                        int dir ) 
{ 
  struct ListRow *row ;
  struct ListRow *tmp ;
  int __cil_tmp6 ;
  struct ListRow *tmp___51 ;
  int __cil_tmp8 ;
  struct ListRow *tmp___52 ;

  {
#line 87
  if (dir == 1) {
#line 87
    tmp = start->next;
  } else {
#line 87
    tmp = start->prev;
  }
#line 87
  row = tmp;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! row) {
#line 88
      goto while_break;
    }
    {
#line 89
    __cil_tmp6 = ((ldata->list_fn)->gl_matchrow)(ldata, row, (char const   *)ldata->search);
    }
#line 89
    if (__cil_tmp6) {
#line 90
      return (row);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  if (dir == 1) {
#line 88
    tmp___51 = row->next;
  } else {
#line 88
    tmp___51 = row->prev;
  }
#line 88
  row = tmp___51;
#line 92
  if (dir == 1) {
#line 93
    row = ldata->root;
  } else
#line 97
  if (! start->next) {
#line 98
    row = start;
  } else {
#line 100
    row = start->next;
    {
#line 100
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! row->next) {
#line 100
        goto while_break___0;
      }

    }
    while_break___0: /* CIL Label */ ;
    }
#line 100
    row = row->next;
  }
  {
#line 104
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 104
    if (! (row != start)) {
#line 104
      goto while_break___1;
    }
    {
#line 105
    __cil_tmp8 = ((ldata->list_fn)->gl_matchrow)(ldata, row, (char const   *)ldata->search);
    }
#line 105
    if (__cil_tmp8) {
#line 106
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 104
  if (dir == 1) {
#line 104
    tmp___52 = row->next;
  } else {
#line 104
    tmp___52 = row->prev;
  }
#line 104
  row = tmp___52;
#line 108
  return (row);
}
}
#line 112 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static void glist_search(char *buf , int len , char *data ) 
{ 
  struct ListData *ldata ;
  struct ListRow *row ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 114
  ldata = (struct ListData *)data;
#line 117
  if (ldata->search) {
#line 118
    if (ldata->search == (char *)0) {
      {
#line 118
      abort();
      }
    } else {
      {
#line 118
      free((void *)ldata->search);
      }
    }
#line 118
    ldata->search = (char *)0;
  }

#line 119
  if (len > 0) {
    {
#line 120
    ldata->search = SaveStr((char const   *)buf);
    }
  } else {
#line 122
    return;
  }
#line 124
  row = ldata->selected;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! row) {
#line 124
      goto while_break;
    }
    {
#line 125
    __cil_tmp7 = ((ldata->list_fn)->gl_matchrow)(ldata, row, (char const   *)ldata->search);
    }
#line 125
    if (__cil_tmp7) {
#line 126
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  row = row->next;
#line 128
  if (! row) {
#line 129
    row = ldata->root;
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! (row != ldata->selected)) {
#line 129
        goto while_break___0;
      }
      {
#line 130
      __cil_tmp8 = ((ldata->list_fn)->gl_matchrow)(ldata, row, (char const   *)ldata->search);
      }
#line 130
      if (__cil_tmp8) {
#line 131
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 129
    row = row->next;
  }
#line 133
  if (row == ldata->selected) {
#line 134
    return;
  }
#line 136
  ldata->selected = row;
#line 137
  if ((ldata->selected)->y == -1) {
    {
#line 138
    glist_decide_top(ldata);
    }
  }
  {
#line 139
  glist_display_all(ldata);
  }
  return;
}
}
#line 142 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static void ListProcess(char **ppbuf , int *plen ) 
{ 
  struct ListData *ldata ;
  int count ;
  struct ListRow *old ;
  unsigned char ch ;
  int __cil_tmp7 ;
  int r ;
  int __cil_tmp9 ;
  char *s ;
  char *ss ;
  int n ;
  int button ;
  int y ;
  struct ListRow *r___0 ;

  {
#line 144
  ldata = (struct ListData *)flayer->l_data;
#line 145
  count = 0;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (*plen > 0)) {
#line 147
      goto while_break;
    }
    {
#line 152
    __cil_tmp7 = ((ldata->list_fn)->gl_pinput)(ldata, ppbuf, plen);
    }
#line 152
    if (! flayer->l_mouseevent.start) {
#line 152
      if ((ldata->list_fn)->gl_pinput) {
#line 152
        if (__cil_tmp7) {
#line 154
          goto while_continue;
        }
      }
    }
#line 156
    ch = (unsigned char )*(*ppbuf);
#line 157
    (*ppbuf) ++;
#line 158
    (*plen) --;
#line 160
    if (flayer->l_mouseevent.start) {
      {
#line 162
      __cil_tmp9 = LayProcessMouse(flayer, ch);
#line 162
      r = __cil_tmp9;
      }
#line 163
      if (r == -1) {
        {
#line 165
        LayProcessMouseSwitch(flayer, 0);
        }
#line 166
        goto while_continue;
      } else
#line 170
      if (r) {
#line 171
        ch = (unsigned char )146;
      } else {
#line 173
        goto while_continue;
      }
    }
#line 177
    if (! ldata->selected) {
#line 179
      *plen = 0;
#line 180
      goto while_break;
    }
#line 183
    old = ldata->selected;
    processchar: 
    {
#line 188
    if ((int )ch == ' ') {
#line 188
      goto case_32;
    }
#line 192
    if ((int )ch == '\n') {
#line 192
      goto case_10;
    }
#line 192
    if ((int )ch == '\r') {
#line 192
      goto case_10;
    }
#line 197
    if ((int )ch == 'k') {
#line 197
      goto case_107;
    }
#line 197
    if ((int )ch == 16) {
#line 197
      goto case_107;
    }
#line 197
    if ((int )ch == 144) {
#line 197
      goto case_107;
    }
#line 205
    if ((int )ch == 'j') {
#line 205
      goto case_106;
    }
#line 205
    if ((int )ch == 14) {
#line 205
      goto case_106;
    }
#line 205
    if ((int )ch == 142) {
#line 205
      goto case_106;
    }
#line 212
    if ((int )ch == 7) {
#line 212
      goto case_7;
    }
#line 212
    if ((int )ch == 27) {
#line 212
      goto case_7;
    }
#line 218
    if ((int )ch == 1) {
#line 218
      goto case_1;
    }
#line 218
    if ((int )ch == 129) {
#line 218
      goto case_1;
    }
#line 223
    if ((int )ch == 5) {
#line 223
      goto case_5;
    }
#line 223
    if ((int )ch == 133) {
#line 223
      goto case_5;
    }
#line 234
    if ((int )ch == 6) {
#line 234
      goto case_6;
    }
#line 234
    if ((int )ch == 4) {
#line 234
      goto case_6;
    }
#line 242
    if ((int )ch == 2) {
#line 242
      goto case_2;
    }
#line 242
    if ((int )ch == 21) {
#line 242
      goto case_2;
    }
#line 249
    if ((int )ch == '/') {
#line 249
      goto case_47;
    }
#line 268
    if ((int )ch == 'n') {
#line 268
      goto case_110;
    }
#line 273
    if ((int )ch == 'N') {
#line 273
      goto case_78;
    }
#line 279
    if ((int )ch == 146) {
#line 279
      goto case_146;
    }
#line 186
    goto switch_break;
    case_32: /* CIL Label */ 
#line 189
    goto switch_break;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 193
    goto switch_break;
    case_107: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_144: /* CIL Label */ 
#line 198
    if (! (ldata->selected)->prev) {
#line 199
      goto switch_break;
    }
#line 200
    ldata->selected = old->prev;
#line 201
    goto switch_break;
    case_106: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_142: /* CIL Label */ 
#line 206
    if (! (ldata->selected)->next) {
#line 207
      goto switch_break;
    }
#line 208
    ldata->selected = old->next;
#line 209
    goto switch_break;
    case_7: /* CIL Label */ 
    case_27: /* CIL Label */ 
    {
#line 213
    ListAbort();
    }
#line 214
    *plen = 0;
#line 215
    return;
    case_1: /* CIL Label */ 
    case_129: /* CIL Label */ 
#line 219
    ldata->selected = ldata->root;
#line 220
    goto switch_break;
    case_5: /* CIL Label */ 
    case_133: /* CIL Label */ 
    {
#line 224
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 224
      if (! (ldata->selected)->next) {
#line 224
        goto while_break___0;
      }
#line 225
      ldata->selected = (ldata->selected)->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 226
    if ((ldata->selected)->y != -1) {

    }
#line 231
    goto switch_break;
    case_6: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 235
    count = (flayer->l_height - 4) >> ((int )ch == 4);
    {
#line 236
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 236
      if (! ((ldata->selected)->next && count)) {
#line 236
        goto while_break___1;
      }

    }
    while_break___1: /* CIL Label */ ;
    }
#line 237
    ldata->selected = (ldata->selected)->next;
#line 239
    goto switch_break;
    case_2: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 243
    count = (flayer->l_height - 4) >> ((int )ch == 21);
    {
#line 244
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 244
      if (! ((ldata->selected)->prev && count)) {
#line 244
        goto while_break___2;
      }

    }
    while_break___2: /* CIL Label */ ;
    }
#line 245
    ldata->selected = (ldata->selected)->prev;
#line 247
    goto switch_break;
    case_47: /* CIL Label */ 
#line 250
    if ((ldata->list_fn)->gl_matchrow) {
      {
#line 253
      Input((char *)"Search: ", 80, 0, glist_search, (char *)ldata, 0);
#line 254
      s = ldata->search;
      }
#line 254
      if (s) {
        {
#line 256
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 256
          if (! *s) {
#line 256
            goto while_break___3;
          }
          {
#line 258
          ss = s;
#line 259
          n = 1;
#line 260
          (*((flayer->l_layfn)->lf_LayProcess))(& ss, & n);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 256
        s ++;
      }
    }
#line 264
    goto switch_break;
    case_110: /* CIL Label */ 
#line 269
    if ((ldata->list_fn)->gl_matchrow) {
#line 269
      if (ldata->search) {
        {
#line 270
        ldata->selected = glist_search_dir(ldata, ldata->selected, 1);
        }
      }
    }
#line 271
    goto switch_break;
    case_78: /* CIL Label */ 
#line 274
    if ((ldata->list_fn)->gl_matchrow) {
#line 274
      if (ldata->search) {
        {
#line 275
        ldata->selected = glist_search_dir(ldata, ldata->selected, - 1);
        }
      }
    }
#line 276
    goto switch_break;
    case_146: /* CIL Label */ 
#line 280
    if (flayer->l_mouseevent.start) {
#line 282
      button = (int )flayer->l_mouseevent.buffer[0];
#line 283
      if (button == 97) {
#line 284
        ch = (unsigned char )'j';
      } else
#line 285
      if (button == 96) {
#line 286
        ch = (unsigned char )'k';
      } else
#line 287
      if (button == 32) {
#line 289
        y = (int )flayer->l_mouseevent.buffer[2];
#line 290
        r___0 = ldata->top;
#line 291
        r___0 = ldata->top;
        {
#line 291
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 291
          if (! ((r___0 && r___0->y != -1) && r___0->y != y)) {
#line 291
            goto while_break___4;
          }

        }
        while_break___4: /* CIL Label */ ;
        }
#line 291
        r___0 = r___0->next;
#line 293
        if (r___0) {
#line 293
          if (r___0->y == y) {
#line 294
            ldata->selected = r___0;
          }
        }
#line 295
        ch = (unsigned char )0;
      } else {
#line 298
        ch = (unsigned char )0;
      }
      {
#line 299
      LayProcessMouseSwitch(flayer, 0);
      }
#line 300
      if (ch) {
#line 301
        goto processchar;
      }
    } else {
      {
#line 304
      LayProcessMouseSwitch(flayer, 1);
      }
    }
#line 305
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 308
    if (old == ldata->selected) {
#line 309
      goto while_continue;
    }
#line 311
    if ((ldata->selected)->y == -1) {
      {
#line 315
      glist_decide_top(ldata);
#line 316
      glist_display_all(ldata);
      }
    } else {
      {
#line 321
      ((ldata->list_fn)->gl_printrow)(ldata, old);
#line 322
      ((ldata->list_fn)->gl_printrow)(ldata, ldata->selected);
#line 323
      flayer->l_y = (ldata->selected)->y;
#line 324
      LGotoPos(flayer, flayer->l_x, flayer->l_y);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 329 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static void ListAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    oldlay = flayer;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 331
    flayer = flayer->l_next;
#line 331
    oldcvlist = flayer->l_cvlist;
    {
#line 331
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 331
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 331
    flayer->l_cvlist = oldlay->l_cvlist;
#line 331
    cv = flayer->l_cvlist;
    {
#line 331
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 331
      if (! cv) {
#line 331
        goto while_break___2;
      }
#line 331
      cv->c_layer = flayer;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 331
    cv = cv->c_lnext;
#line 331
    LRefreshAll(flayer, 0);
#line 331
    flayer = oldlay;
#line 331
    cv = flayer->l_cvlist;
    }
    {
#line 331
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 331
      if (! cv) {
#line 331
        goto while_break___3;
      }
#line 331
      cv->c_layer = flayer;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 331
    cv = cv->c_lnext;
#line 331
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 331
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 332
  ExitOverlayPage();
  }
  return;
}
}
#line 335 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static void ListFree(void *d ) 
{ 
  struct ListData *ldata ;

  {
  {
#line 337
  ldata = (struct ListData *)d;
#line 338
  glist_remove_rows(ldata);
  }
#line 339
  if ((ldata->list_fn)->gl_free) {
    {
#line 340
    ((ldata->list_fn)->gl_free)(ldata);
    }
  }
#line 341
  if (ldata->search) {
#line 342
    if (ldata->search == (char *)0) {
      {
#line 342
      abort();
      }
    } else {
      {
#line 342
      free((void *)ldata->search);
      }
    }
#line 342
    ldata->search = (char *)0;
  }

  return;
}
}
#line 345 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static void ListRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  struct ListData *ldata ;
  struct ListRow *row ;

  {
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  ldata = (struct ListData *)flayer->l_data;
#line 351
  if (y < 0) {
    {
#line 353
    glist_display_all(ldata);
    }
#line 354
    return;
  }
#line 357
  if (! isblank) {
    {
#line 358
    LClearArea(flayer, xs, y, xe, y, 0, 0);
    }
  }
#line 360
  if (ldata->top) {
#line 360
    if (y < (ldata->top)->y) {
      {
#line 361
      ((ldata->list_fn)->gl_printheader)(ldata);
      }
    } else {
#line 360
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 362
  if (y + 1 == flayer->l_height) {
    {
#line 363
    ((ldata->list_fn)->gl_printfooter)(ldata);
    }
  } else {
#line 367
    row = ldata->top;
    {
#line 367
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 367
      if (! (row && row->y != -1)) {
#line 367
        goto while_break___0;
      }
#line 368
      if (row->y == y) {
        {
#line 370
        ((ldata->list_fn)->gl_printrow)(ldata, row);
        }
#line 371
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 367
    row = row->next;
  }
  return;
}
}
#line 376 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static void ListClearLine(int y , int xs , int xe , int bce ) 
{ 


  {
  {
#line 378
  DefClearLine(y, xs, xe, bce);
  }
  return;
}
}
#line 381 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static int ListRewrite(int y , int xs , int xe , struct mchar *rend , int doit ) 
{ 


  {
#line 383
  return (1000);
}
}
#line 386 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static int ListResize(int wi , int he ) 
{ 


  {
#line 388
  if (wi < 10) {
#line 389
    return (- 1);
  } else
#line 388
  if (he < 5) {
#line 389
    return (- 1);
  }
#line 391
  flayer->l_width = wi;
#line 392
  flayer->l_height = he;
#line 393
  flayer->l_y = he - 1;
#line 395
  return (0);
}
}
#line 398 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
static void ListRestore(void) 
{ 


  {
  {
#line 400
  DefRestore();
  }
  return;
}
}
#line 404 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
struct ListRow *glist_add_row(struct ListData *ldata , void *data , struct ListRow *after ) 
{ 
  struct ListRow *r ;
  void *__cil_tmp5 ;

  {
  {
#line 406
  __cil_tmp5 = calloc((unsigned long )1, sizeof(struct ListRow ));
#line 406
  r = (struct ListRow *)__cil_tmp5;
#line 407
  r->data = data;
  }
#line 409
  if (after) {
#line 411
    r->next = after->next;
#line 412
    r->prev = after;
#line 413
    after->next = r;
#line 414
    if (r->next) {
#line 415
      (r->next)->prev = r;
    }
  } else {
#line 419
    r->next = ldata->root;
#line 420
    if (ldata->root) {
#line 421
      (ldata->root)->prev = r;
    }
#line 422
    ldata->root = r;
  }
#line 425
  return (r);
}
}
#line 429 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
void glist_remove_rows(struct ListData *ldata ) 
{ 
  struct ListRow *row ;
  struct ListRow *r ;

  {
#line 432
  row = ldata->root;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! row) {
#line 432
      goto while_break;
    }
    {
#line 434
    r = row;
#line 435
    row = row->next;
#line 436
    ((ldata->list_fn)->gl_freerow)(ldata, r);
#line 437
    free((void *)r);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  ldata->top = (struct ListRow *)((void *)0);
#line 439
  ldata->selected = ldata->top;
#line 439
  ldata->root = ldata->selected;
  return;
}
}
#line 443 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
void glist_display_all(struct ListData *list ) 
{ 
  int y ;
  struct ListRow *row ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 448
  LClearAll(flayer, 0);
#line 450
  y = ((list->list_fn)->gl_printheader)(list);
  }
#line 452
  if (! list->top) {
#line 453
    list->top = list->root;
  }
#line 454
  if (! list->selected) {
#line 455
    list->selected = list->root;
  }
#line 457
  row = list->root;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! (row != list->top)) {
#line 457
      goto while_break;
    }
#line 458
    row->y = - 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  row = row->next;
#line 460
  row = list->top;
  {
#line 460
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 460
    if (! row) {
#line 460
      goto while_break___0;
    }
    {
#line 462
    __cil_tmp5 = y;
#line 462
    y ++;
#line 462
    row->y = __cil_tmp5;
#line 463
    __cil_tmp6 = ((list->list_fn)->gl_printrow)(list, row);
    }
#line 463
    if (! __cil_tmp6) {
#line 465
      row->y = - 1;
#line 466
      __cil_tmp7 = y;
#line 466
      y --;
    }
#line 468
    if (y + 1 == flayer->l_height) {
#line 469
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 460
  row = row->next;
  {
#line 471
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 471
    if (! row) {
#line 471
      goto while_break___1;
    }
#line 472
    row->y = - 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 471
  row = row->next;
#line 474
  ((list->list_fn)->gl_printfooter)(list);
  }
#line 475
  if (list->selected) {
#line 475
    if ((list->selected)->y != -1) {
#line 476
      flayer->l_y = (list->selected)->y;
    } else {
#line 478
      flayer->l_y = flayer->l_height - 1;
    }
  } else {
#line 478
    flayer->l_y = flayer->l_height - 1;
  }
  {
#line 479
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
  return;
}
}
#line 482 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/list_generic.c"
void glist_abort(void) 
{ 


  {
  {
#line 484
  ListAbort();
  }
  return;
}
}
#line 396 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 144 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.h"
void LayPause(struct layer *layer , int pause___0 ) ;
#line 155
void LayPauseUpdateRegion(struct layer *layer , int xs , int xe , int ys , int ye ) ;
#line 60 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void PutWinMsg(char *s , int start , int max ) ;
#line 103
void SetFlow(int on ) ;
#line 266
void PUTCHARLP(int c ) ;
#line 268
void ClearArea(int x1 , int y1 , int xs , int xe , int x2 , int y2 , int bce , int uselayfn ) ;
#line 269
void ClearLine(struct mline *oml , int y , int from , int to , int bce ) ;
#line 271
void RefreshArea(int xs , int ys , int xe , int ye , int isblank ) ;
#line 277
void DisplayLine(struct mline *oml , struct mline *ml , int y , int from , int to ) ;
#line 280
void ScrollH(int y , int xs , int xe , int n , int bce , struct mline *oml ) ;
#line 281
void ScrollV(int xs , int ys , int xe , int ye , int n , int bce ) ;
#line 282
void PutChar(struct mchar *c , int x , int y ) ;
#line 283
void InsChar(struct mchar *c , int x , int xe , int y , struct mline *oml ) ;
#line 284
void WrapChar(struct mchar *c , int x , int y , int xs , int ys , int xe , int ye ,
              int ins ) ;
#line 287
void KeypadMode(int on ) ;
#line 288
void CursorkeysMode(int on ) ;
#line 290
void CursorVisibility(int v ) ;
#line 291
void MouseMode(int mode ) ;
#line 292
void ExtMouseMode(int mode ) ;
#line 296
void SetRendition(struct mchar *mc ) ;
#line 298
void MakeStatus(char *msg ) ;
#line 299
void RemoveStatus(void) ;
#line 434
void LPutChar(struct layer *l , struct mchar *c , int x , int y ) ;
#line 435
void LInsChar(struct layer *l , struct mchar *c , int x , int y , struct mline *ol ) ;
#line 436
void LPutStr(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) ;
#line 438
void LScrollH(struct layer *l , int n , int y , int xs , int xe , int bce , struct mline *ol ) ;
#line 439
void LScrollV(struct layer *l , int n , int ys , int ye , int bce ) ;
#line 442
void LClearLine(struct layer *l , int y , int xs , int xe , int bce , struct mline *ol ) ;
#line 444
void LCDisplayLine(struct layer *l , struct mline *ml , int y , int xs , int xe ,
                   int isblank ) ;
#line 445
void LCDisplayLineWrap(struct layer *l , struct mline *ml , int y , int from , int to ,
                       int isblank ) ;
#line 446
void LSetRendition(struct layer *l , struct mchar *r ) ;
#line 447
void LWrapChar(struct layer *l , struct mchar *c , int y , int top , int bot , int ins ) ;
#line 448
void LCursorVisibility(struct layer *l , int vis ) ;
#line 449
void LSetFlow(struct layer *l , int flow ) ;
#line 450
void LKeypadMode(struct layer *l , int on ) ;
#line 451
void LCursorkeysMode(struct layer *l , int on ) ;
#line 452
void LMouseMode(struct layer *l , int on ) ;
#line 453
void LExtMouseMode(struct layer *l , int on ) ;
#line 41 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
extern struct mline mline_blank ;
#line 41
extern struct mline mline_null ;
#line 45
struct LayFuncs WinLf ;
#line 49
static struct mline *mloff(struct mline *ml , int off ) ;
#line 60 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
static struct mline *mloff(struct mline *ml , int off ) 
{ 
  static struct mline mml ;

  {
#line 63
  if (ml == (struct mline *)0) {
#line 64
    return ((struct mline *)0);
  }
#line 66
  mml.image = ml->image + off;
#line 67
  mml.attr = ml->attr + off;
#line 69
  mml.font = ml->font + off;
#line 70
  mml.fontx = ml->fontx + off;
#line 74
  mml.color = ml->color + off;
#line 80
  return (& mml);
}
}
#line 98 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LGotoPos(struct layer *l , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int x2 ;
  int y2 ;

  {
#line 104
  if (l->l_pause.d) {
    {
#line 105
    LayPauseUpdateRegion(l, x, x, y, y);
    }
  }
#line 111
  cv = l->l_cvlist;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! cv) {
#line 111
      goto while_break;
    }
#line 111
    if (l->l_pause.d) {
#line 111
      if (cv->c_slorient) {
#line 111
        goto while_continue;
      }
    }
#line 111
    display = cv->c_display;
#line 111
    if (display->d_blocked) {
#line 111
      goto while_continue;
    }
#line 111
    if (cv != display->d_forecv) {
#line 111
      goto while_continue;
    }
#line 111
    x2 = x + cv->c_xoff;
#line 111
    y2 = y + cv->c_yoff;
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 111
    if (x2 < cv->c_xs) {
#line 111
      x2 = cv->c_xs;
    }
#line 111
    if (y2 < cv->c_ys) {
#line 111
      y2 = cv->c_ys;
    }
#line 111
    if (x2 > cv->c_xe) {
#line 111
      x2 = cv->c_xe;
    }
#line 111
    if (y2 > cv->c_ye) {
#line 111
      y2 = cv->c_ye;
    }
#line 111
    vp = cv->c_vplist;
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 111
      if (! vp) {
#line 111
        goto while_break___1;
      }
#line 111
      if (x2 < vp->v_xs) {
#line 111
        goto while_continue___1;
      } else
#line 111
      if (x2 > vp->v_xe) {
#line 111
        goto while_continue___1;
      }
#line 111
      if (y2 < vp->v_ys) {
#line 111
        goto while_continue___1;
      } else
#line 111
      if (y2 > vp->v_ye) {
#line 111
        goto while_continue___1;
      }
      {
#line 111
      GotoPos(x2, y2);
      }
#line 111
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 111
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  cv = cv->c_lnext;
  return;
}
}
#line 141 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LScrollH(struct layer *l , int n , int y , int xs , int xe , int bce , struct mline *ol ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int y2 ;
  int xs2 ;
  int xe2 ;
  struct mline *__cil_tmp13 ;
  struct mline *tmp ;

  {
#line 147
  if (n == 0) {
#line 148
    return;
  }
#line 149
  if (l->l_pause.d) {
    {
#line 150
    LayPauseUpdateRegion(l, xs, xe, y, y);
    }
  }
#line 152
  cv = l->l_cvlist;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! cv) {
#line 152
      goto while_break;
    }
#line 152
    if (l->l_pause.d) {
#line 152
      if (cv->c_slorient) {
#line 152
        goto while_continue;
      }
    }
#line 152
    vp = cv->c_vplist;
    {
#line 152
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 152
      if (! vp) {
#line 152
        goto while_break___0;
      }
#line 152
      y2 = y + vp->v_yoff;
#line 152
      if (y2 < vp->v_ys) {
#line 152
        goto while_continue___0;
      } else
#line 152
      if (y2 > vp->v_ye) {
#line 152
        goto while_continue___0;
      }
#line 152
      xs2 = xs + vp->v_xoff;
#line 152
      xe2 = xe + vp->v_xoff;
#line 152
      if (xs2 < vp->v_xs) {
#line 152
        xs2 = vp->v_xs;
      }
#line 152
      if (xe2 > vp->v_xe) {
#line 152
        xe2 = vp->v_xe;
      }
#line 152
      if (xs2 > xe2) {
#line 152
        goto while_continue___0;
      }
#line 152
      display = cv->c_display;
#line 152
      if (display->d_blocked) {
#line 152
        goto while_continue___0;
      }
#line 152
      if (ol) {
        {
#line 152
        __cil_tmp13 = mloff(ol, - vp->v_xoff);
#line 152
        tmp = __cil_tmp13;
        }
      } else {
#line 152
        tmp = (struct mline *)0;
      }
      {
#line 152
      ScrollH(y2, xs2, xe2, n, bce, tmp);
      }
#line 152
      if (xe2 - xs2 == xe - xs) {
#line 152
        goto while_continue___0;
      }
#line 152
      if (n > 0) {
#line 152
        xs2 = (xe2 + 1) - n;
#line 152
        xe2 = (xe + vp->v_xoff) - n;
      } else {
#line 152
        xe2 = (xs2 - 1) - n;
#line 152
        xs2 = (xs + vp->v_xoff) - n;
      }
#line 152
      if (xs2 < vp->v_xs) {
#line 152
        xs2 = vp->v_xs;
      }
#line 152
      if (xe2 > vp->v_xe) {
#line 152
        xe2 = vp->v_xe;
      }
#line 152
      if (xs2 <= xe2) {
        {
#line 152
        RefreshArea(xs2, y2, xe2, y2, 1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 152
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  cv = cv->c_lnext;
  return;
}
}
#line 190 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LScrollV(struct layer *l , int n , int ys , int ye , int bce ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int ys2 ;
  int ye2 ;
  int xs2 ;
  int xe2 ;

  {
#line 195
  if (n == 0) {
#line 196
    return;
  }
#line 197
  if (l->l_pause.d) {
    {
#line 198
    LayPauseUpdateRegion(l, 0, l->l_width - 1, ys, ye);
    }
  }
#line 199
  cv = l->l_cvlist;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! cv) {
#line 199
      goto while_break;
    }
#line 199
    if (l->l_pause.d) {
#line 199
      if (cv->c_slorient) {
#line 199
        goto while_continue;
      }
    }
#line 199
    vp = cv->c_vplist;
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (! vp) {
#line 199
        goto while_break___0;
      }
#line 199
      xs2 = vp->v_xoff;
#line 199
      xe2 = (l->l_width - 1) + vp->v_xoff;
#line 199
      ys2 = ys + vp->v_yoff;
#line 199
      ye2 = ye + vp->v_yoff;
#line 199
      if (xs2 < vp->v_xs) {
#line 199
        xs2 = vp->v_xs;
      }
#line 199
      if (xe2 > vp->v_xe) {
#line 199
        xe2 = vp->v_xe;
      }
#line 199
      if (ys2 < vp->v_ys) {
#line 199
        ys2 = vp->v_ys;
      }
#line 199
      if (ye2 > vp->v_ye) {
#line 199
        ye2 = vp->v_ye;
      }
#line 199
      if (ys2 > ye2) {
#line 199
        goto while_continue___0;
      } else
#line 199
      if (xs2 > xe2) {
#line 199
        goto while_continue___0;
      }
#line 199
      display = cv->c_display;
#line 199
      if (display->d_blocked) {
#line 199
        goto while_continue___0;
      }
      {
#line 199
      ScrollV(vp->v_xs, ys2, vp->v_xe, ye2, n, bce);
      }
      {
#line 199
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 199
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 199
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 199
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 199
      if (ye2 - ys2 == ye - ys) {
#line 199
        goto while_continue___0;
      }
#line 199
      if (n > 0) {
#line 199
        ys2 = (ye2 + 1) - n;
#line 199
        ye2 = (ye + vp->v_yoff) - n;
      } else {
#line 199
        ye2 = (ys2 - 1) - n;
#line 199
        ys2 = (ys + vp->v_yoff) - n;
      }
      {
#line 199
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 199
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 199
      if (ys2 < vp->v_ys) {
#line 199
        ys2 = vp->v_ys;
      }
#line 199
      if (ye2 > vp->v_ye) {
#line 199
        ye2 = vp->v_ye;
      }
      {
#line 199
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 199
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 199
      if (ys2 <= ye2) {
        {
#line 199
        RefreshArea(xs2, ys2, xe2, ye2, 1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 199
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  cv = cv->c_lnext;
  return;
}
}
#line 250 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LInsChar(struct layer *l , struct mchar *c , int x , int y , struct mline *ol ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  int f ;
  struct mchar *c2 ;
  struct mchar cc ;
  struct mline *rol ;
  int i ;
  struct mline *__cil_tmp16 ;
  struct mline *tmp ;
  struct mchar *__cil_tmp18 ;
  struct mchar *tmp___53 ;
  struct mline *__cil_tmp20 ;

  {
#line 258
  if (l->l_pause.d) {
    {
#line 259
    LayPauseUpdateRegion(l, x, l->l_width - 1, y, y);
    }
  }
#line 260
  cv = l->l_cvlist;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! cv) {
#line 260
      goto while_break;
    }
#line 260
    if (l->l_pause.d) {
#line 260
      if (cv->c_slorient) {
#line 260
        goto while_continue;
      }
    }
#line 260
    vp = cv->c_vplist;
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 260
      if (! vp) {
#line 260
        goto while_break___0;
      }
#line 260
      y2 = y + vp->v_yoff;
#line 260
      if (y2 < vp->v_ys) {
#line 260
        goto while_continue___0;
      } else
#line 260
      if (y2 > vp->v_ye) {
#line 260
        goto while_continue___0;
      }
#line 260
      xs2 = x + vp->v_xoff;
#line 260
      xe2 = (l->l_width - 1) + vp->v_xoff;
#line 260
      c2 = c;
#line 260
      f = 0;
#line 260
      if (xs2 < vp->v_xs) {
#line 260
        xs2 = vp->v_xs;
#line 260
        c2 = & mchar_blank;
#line 260
        if (ol) {
#line 260
          i = (xs2 - vp->v_xoff) - 1;
#line 260
          if (i >= 0) {
#line 260
            if (i < l->l_width) {
              {
#line 260
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 260
                cc.image = *(ol->image + i);
#line 260
                cc.attr = *(ol->attr + i);
#line 260
                cc.font = *(ol->font + i);
#line 260
                cc.fontx = *(ol->fontx + i);
#line 260
                cc.color = *(ol->color + i);
#line 260
                cc.mbcs = (unsigned char )0;
#line 260
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 260
              c2 = & cc;
            }
          }
        } else {
#line 260
          f = 1;
        }
      }
#line 260
      if (xe2 > vp->v_xe) {
#line 260
        xe2 = vp->v_xe;
      }
#line 260
      if (xs2 > xe2) {
#line 260
        goto while_continue___0;
      }
#line 260
      display = cv->c_display;
#line 260
      if (display->d_blocked) {
#line 260
        goto while_continue___0;
      }
#line 260
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 260
        __cil_tmp16 = recode_mline(ol, l->l_width, l->l_encoding, display->d_encoding);
#line 260
        tmp = __cil_tmp16;
        }
      } else {
#line 260
        tmp = ol;
      }
#line 260
      rol = tmp;
#line 260
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 260
        __cil_tmp18 = recode_mchar(c2, l->l_encoding, display->d_encoding);
#line 260
        tmp___53 = __cil_tmp18;
        }
      } else {
#line 260
        tmp___53 = c2;
      }
      {
#line 260
      __cil_tmp20 = mloff(rol, - vp->v_xoff);
#line 260
      InsChar(tmp___53, xs2, xe2, y2, __cil_tmp20);
      }
#line 260
      if (f) {
        {
#line 260
        RefreshArea(xs2, y2, xs2, y2, 1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  cv = cv->c_lnext;
  return;
}
}
#line 299 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LPutChar(struct layer *l , struct mchar *c , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int x2 ;
  int y2 ;
  int tmp ;
  struct mchar *__cil_tmp10 ;
  struct mchar *tmp___54 ;

  {
#line 312
  if (l->l_pause.d) {
#line 313
    if ((int )c->mbcs) {
#line 313
      tmp = 1;
    } else {
#line 313
      tmp = 0;
    }
    {
#line 313
    LayPauseUpdateRegion(l, x, x + tmp, y, y);
    }
  }
#line 323
  cv = l->l_cvlist;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! cv) {
#line 323
      goto while_break;
    }
#line 323
    if (l->l_pause.d) {
#line 323
      if (cv->c_slorient) {
#line 323
        goto while_continue;
      }
    }
#line 323
    display = cv->c_display;
#line 323
    if (display->d_blocked) {
#line 323
      goto while_continue;
    }
#line 323
    vp = cv->c_vplist;
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 323
      if (! vp) {
#line 323
        goto while_break___0;
      }
#line 323
      y2 = y + vp->v_yoff;
#line 323
      if (y2 < vp->v_ys) {
#line 323
        goto while_continue___0;
      } else
#line 323
      if (y2 > vp->v_ye) {
#line 323
        goto while_continue___0;
      }
#line 323
      x2 = x + vp->v_xoff;
#line 323
      if (x2 < vp->v_xs) {
#line 323
        goto while_continue___0;
      } else
#line 323
      if (x2 > vp->v_xe) {
#line 323
        goto while_continue___0;
      }
#line 323
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 323
        __cil_tmp10 = recode_mchar(c, l->l_encoding, display->d_encoding);
#line 323
        tmp___54 = __cil_tmp10;
        }
      } else {
#line 323
        tmp___54 = c;
      }
      {
#line 323
      PutChar(tmp___54, x2, y2);
      }
#line 323
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 323
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  cv = cv->c_lnext;
  return;
}
}
#line 343 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LPutStr(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  char *s2 ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  struct mchar mc ;
  char *__cil_tmp14 ;
  struct mchar *__cil_tmp15 ;
  struct mchar *tmp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 350
  if (x + n > l->l_width) {
#line 351
    n = l->l_width - x;
  }
#line 360
  if (l->l_pause.d) {
    {
#line 361
    LayPauseUpdateRegion(l, x, (x + n) - 1, y, y);
    }
  }
#line 363
  cv = l->l_cvlist;
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! cv) {
#line 363
      goto while_break;
    }
#line 363
    if (l->l_pause.d) {
#line 363
      if (cv->c_slorient) {
#line 363
        goto while_continue;
      }
    }
#line 363
    vp = cv->c_vplist;
    {
#line 363
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 363
      if (! vp) {
#line 363
        goto while_break___0;
      }
#line 363
      y2 = y + vp->v_yoff;
#line 363
      if (y2 < vp->v_ys) {
#line 363
        goto while_continue___0;
      } else
#line 363
      if (y2 > vp->v_ye) {
#line 363
        goto while_continue___0;
      }
#line 363
      xs2 = x + vp->v_xoff;
#line 363
      xe2 = (xs2 + n) - 1;
#line 363
      if (xs2 < vp->v_xs) {
#line 363
        xs2 = vp->v_xs;
      }
#line 363
      if (xe2 > vp->v_xe) {
#line 363
        xe2 = vp->v_xe;
      }
#line 363
      if (xs2 > xe2) {
#line 363
        goto while_continue___0;
      }
#line 363
      display = cv->c_display;
#line 363
      if (display->d_blocked) {
#line 363
        goto while_continue___0;
      }
      {
#line 363
      GotoPos(xs2, y2);
#line 363
      SetRendition(r);
#line 363
      s2 = ((s + xs2) - x) - vp->v_xoff;
      }
#line 363
      if (display->d_encoding == 8) {
#line 363
        if (l->l_encoding != 8) {
#line 363
          if ((int )r->font) {
            _L: /* CIL Label */ 
#line 363
            mc = *r;
            {
#line 363
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 363
              if (! (xs2 <= xe2)) {
#line 363
                goto while_break___1;
              }
#line 363
              __cil_tmp14 = s2;
#line 363
              s2 ++;
#line 363
              mc.image = (unsigned char )*__cil_tmp14;
#line 363
              if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
                {
#line 363
                __cil_tmp15 = recode_mchar(& mc, l->l_encoding, display->d_encoding);
#line 363
                tmp = __cil_tmp15;
                }
              } else {
#line 363
                tmp = & mc;
              }
              {
#line 363
              __cil_tmp17 = xs2;
#line 363
              xs2 ++;
#line 363
              PutChar(tmp, __cil_tmp17, y2);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 363
            goto while_continue___0;
          } else
#line 363
          if ((int )r->fontx) {
#line 363
            goto _L;
          } else
#line 363
          if (l->l_encoding) {
#line 363
            goto _L;
          }
        }
      }
      {
#line 363
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 363
        if (! (__cil_tmp18 <= xe2)) {
#line 363
          goto while_break___2;
        }
        {
#line 363
        __cil_tmp19 = s2;
#line 363
        s2 ++;
#line 363
        PUTCHARLP((int )*__cil_tmp19);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 363
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  cv = cv->c_lnext;
  return;
}
}
#line 402 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LPutWinMsg(struct layer *l , char *s , int n , struct mchar *r , int x , int y ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  int len ;
  int len2 ;
  struct mchar or ;
  size_t __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 409
  if (x + n > l->l_width) {
#line 410
    n = l->l_width - x;
  }
#line 419
  if (l->l_pause.d) {
    {
#line 420
    LayPauseUpdateRegion(l, x, (x + n) - 1, y, y);
    }
  }
  {
#line 422
  __cil_tmp15 = strlen((char const   *)s);
#line 422
  len = (int )__cil_tmp15;
  }
#line 423
  if (len > n) {
#line 424
    len = n;
  }
#line 426
  cv = l->l_cvlist;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! cv) {
#line 426
      goto while_break;
    }
#line 426
    if (l->l_pause.d) {
#line 426
      if (cv->c_slorient) {
#line 426
        goto while_continue;
      }
    }
#line 426
    vp = cv->c_vplist;
    {
#line 426
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 426
      if (! vp) {
#line 426
        goto while_break___0;
      }
#line 426
      y2 = y + vp->v_yoff;
#line 426
      if (y2 < vp->v_ys) {
#line 426
        goto while_continue___0;
      } else
#line 426
      if (y2 > vp->v_ye) {
#line 426
        goto while_continue___0;
      }
#line 426
      xs2 = x + vp->v_xoff;
#line 426
      xe2 = (xs2 + n) - 1;
#line 426
      if (xs2 < vp->v_xs) {
#line 426
        xs2 = vp->v_xs;
      }
#line 426
      if (xe2 > vp->v_xe) {
#line 426
        xe2 = vp->v_xe;
      }
#line 426
      if (xs2 > xe2) {
#line 426
        goto while_continue___0;
      }
#line 426
      display = cv->c_display;
#line 426
      if (display->d_blocked) {
#line 426
        goto while_continue___0;
      }
      {
#line 426
      GotoPos(xs2, y2);
#line 426
      SetRendition(r);
#line 426
      len2 = (xe2 - (x + vp->v_xoff)) + 1;
      }
#line 426
      if (len2 > len) {
#line 426
        len2 = len;
      }
      {
#line 426
      PutWinMsg(s, (xs2 - x) - vp->v_xoff, len2);
#line 426
      xs2 = (x + vp->v_xoff) + len2;
      }
#line 426
      if (xs2 < vp->v_xs) {
#line 426
        xs2 = vp->v_xs;
      }
      {
#line 426
      or = display->d_rend;
#line 426
      GotoPos(xs2, y2);
#line 426
      SetRendition(& or);
      }
      {
#line 426
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 426
        if (! (__cil_tmp16 <= xe2)) {
#line 426
          goto while_break___1;
        }
        {
#line 426
        PUTCHARLP(' ');
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 426
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  cv = cv->c_lnext;
  return;
}
}
#line 461 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LClearLine(struct layer *l , int y , int xs , int xe , int bce , struct mline *ol ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int y2 ;
  int xs2 ;
  int xe2 ;
  struct mline *__cil_tmp12 ;
  struct mline *tmp ;
  struct mline *__cil_tmp14 ;
  struct mline *tmp___56 ;

  {
#line 468
  if (xs >= l->l_width) {
#line 469
    xs = l->l_width - 1;
  }
#line 470
  if (xe >= l->l_width) {
#line 471
    xe = l->l_width - 1;
  }
#line 472
  if (l->l_pause.d) {
    {
#line 473
    LayPauseUpdateRegion(l, xs, xe, y, y);
    }
  }
#line 475
  cv = l->l_cvlist;
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! cv) {
#line 475
      goto while_break;
    }
#line 475
    if (l->l_pause.d) {
#line 475
      if (cv->c_slorient) {
#line 475
        goto while_continue;
      }
    }
#line 475
    vp = cv->c_vplist;
    {
#line 475
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 475
      if (! vp) {
#line 475
        goto while_break___0;
      }
#line 475
      xs2 = xs + vp->v_xoff;
#line 475
      xe2 = xe + vp->v_xoff;
#line 475
      y2 = y + vp->v_yoff;
#line 475
      if (y2 < vp->v_ys) {
#line 475
        goto while_continue___0;
      } else
#line 475
      if (y2 > vp->v_ye) {
#line 475
        goto while_continue___0;
      }
#line 475
      if (xs2 < vp->v_xs) {
#line 475
        xs2 = vp->v_xs;
      }
#line 475
      if (xe2 > vp->v_xe) {
#line 475
        xe2 = vp->v_xe;
      }
#line 475
      if (xs2 > xe2) {
#line 475
        goto while_continue___0;
      }
#line 475
      display = cv->c_display;
#line 475
      if (display->d_blocked) {
#line 475
        goto while_continue___0;
      }
#line 475
      if (ol) {
#line 475
        if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
          {
#line 475
          __cil_tmp12 = recode_mline(ol, l->l_width, l->l_encoding, display->d_encoding);
#line 475
          tmp = __cil_tmp12;
          }
        } else {
#line 475
          tmp = ol;
        }
        {
#line 475
        __cil_tmp14 = mloff(tmp, - vp->v_xoff);
#line 475
        tmp___56 = __cil_tmp14;
        }
      } else {
#line 475
        tmp___56 = (struct mline *)0;
      }
      {
#line 475
      ClearLine(tmp___56, y2, xs2, xe2, bce);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 475
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  cv = cv->c_lnext;
  return;
}
}
#line 496 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LClearArea(struct layer *l , int xs , int ys , int xe , int ye , int bce , int uself ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int xs2 ;
  int ys2 ;
  int xe2 ;
  int ye2 ;
  int __cil_tmp15 ;
  int y ;

  {
#line 508
  if (ys < 0) {
#line 509
    return;
  } else
#line 508
  if (ye < ys) {
#line 509
    return;
  }
#line 512
  if (xs >= l->l_width) {
#line 513
    xs = l->l_width - 1;
  }
#line 514
  if (xe >= l->l_width) {
#line 515
    xe = l->l_width - 1;
  }
#line 516
  if (l->l_pause.d) {
    {
#line 517
    LayPauseUpdateRegion(l, xs, xe, ys, ye);
    }
  }
#line 519
  cv = l->l_cvlist;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if (! cv) {
#line 519
      goto while_break;
    }
#line 519
    if (l->l_pause.d) {
#line 519
      if (cv->c_slorient) {
#line 519
        goto while_continue;
      }
    }
#line 519
    display = cv->c_display;
#line 519
    if (display->d_blocked) {
#line 519
      goto while_continue;
    }
#line 519
    vp = cv->c_vplist;
    {
#line 519
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 519
      if (! vp) {
#line 519
        goto while_break___0;
      }
#line 519
      xs2 = xs + vp->v_xoff;
#line 519
      xe2 = xe + vp->v_xoff;
#line 519
      ys2 = ys + vp->v_yoff;
#line 519
      ye2 = ye + vp->v_yoff;
#line 519
      if (xs2 < vp->v_xs) {
#line 519
        xs2 = vp->v_xs;
      }
#line 519
      if (xe2 > vp->v_xe) {
#line 519
        xe2 = vp->v_xe;
      }
#line 519
      if (xs2 > vp->v_xe) {
#line 519
        ys2 ++;
      }
#line 519
      if (xe2 < vp->v_xs) {
#line 519
        __cil_tmp15 = ye2;
#line 519
        ye2 --;
      }
#line 519
      if (ys2 < vp->v_ys) {
#line 519
        ys2 = vp->v_ys;
      }
#line 519
      if (ye2 > vp->v_ye) {
#line 519
        ye2 = vp->v_ye;
      }
#line 519
      if (ys2 > ye2) {
#line 519
        goto while_continue___0;
      }
#line 519
      if (xs == 0) {
#line 519
        xs2 = vp->v_xs;
      } else
#line 519
      if (ys2 != ys + vp->v_yoff) {
#line 519
        xs2 = vp->v_xs;
      }
#line 519
      if (xe == l->l_width - 1) {
#line 519
        xe2 = vp->v_xe;
      } else
#line 519
      if (ye2 != ye + vp->v_yoff) {
#line 519
        xe2 = vp->v_xe;
      }
      {
#line 519
      display = cv->c_display;
#line 519
      ClearArea(xs2, ys2, vp->v_xs, vp->v_xe, xe2, ye2, bce, uself);
      }
#line 519
      if (xe == l->l_width - 1) {
#line 519
        if (xe2 > vp->v_xoff + xe) {
          {
#line 519
          SetRendition(& mchar_blank);
#line 519
          y = ys2;
          }
          {
#line 519
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 519
            if (! (y <= ye2)) {
#line 519
              goto while_break___1;
            }
            {
#line 519
            GotoPos((xe + vp->v_xoff) + 1, y);
#line 519
            PUTCHARLP('|');
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 519
          y ++;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 519
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  cv = cv->c_lnext;
  return;
}
}
#line 583 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LCDisplayLine(struct layer *l , struct mline *ml , int y , int xs , int xe ,
                   int isblank ) 
{ 
  struct canvas *cv ;
  struct viewport *vp ;
  int xs2 ;
  int xe2 ;
  int y2 ;
  struct mline *tmp ;
  struct mline *__cil_tmp13 ;
  struct mline *tmp___57 ;
  struct mline *__cil_tmp15 ;

  {
#line 596
  if (l->l_pause.d) {
    {
#line 597
    LayPauseUpdateRegion(l, xs, xe, y, y);
    }
  }
#line 599
  cv = l->l_cvlist;
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 599
    if (! cv) {
#line 599
      goto while_break;
    }
#line 599
    if (l->l_pause.d) {
#line 599
      if (cv->c_slorient) {
#line 599
        goto while_continue;
      }
    }
#line 599
    display = cv->c_display;
#line 599
    if (display->d_blocked) {
#line 599
      goto while_continue;
    }
#line 599
    vp = cv->c_vplist;
    {
#line 599
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 599
      if (! vp) {
#line 599
        goto while_break___0;
      }
#line 599
      xs2 = xs + vp->v_xoff;
#line 599
      xe2 = xe + vp->v_xoff;
#line 599
      y2 = y + vp->v_yoff;
#line 599
      if (y2 < vp->v_ys) {
#line 599
        goto while_continue___0;
      } else
#line 599
      if (y2 > vp->v_ye) {
#line 599
        goto while_continue___0;
      }
#line 599
      if (xs2 < vp->v_xs) {
#line 599
        xs2 = vp->v_xs;
      }
#line 599
      if (xe2 > vp->v_xe) {
#line 599
        xe2 = vp->v_xe;
      }
#line 599
      if (xs2 > xe2) {
#line 599
        goto while_continue___0;
      }
#line 599
      display = cv->c_display;
      {
#line 599
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 599
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 599
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 599
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 599
      if (isblank) {
#line 599
        tmp = & mline_blank;
      } else {
#line 599
        tmp = & mline_null;
      }
#line 599
      if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
        {
#line 599
        __cil_tmp13 = recode_mline(ml, l->l_width, l->l_encoding, display->d_encoding);
#line 599
        tmp___57 = __cil_tmp13;
        }
      } else {
#line 599
        tmp___57 = ml;
      }
      {
#line 599
      __cil_tmp15 = mloff(tmp___57, - vp->v_xoff);
#line 599
      DisplayLine(tmp, __cil_tmp15, y2, xs2, xe2);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 599
    vp = vp->v_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 599
  cv = cv->c_lnext;
  return;
}
}
#line 626 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LCDisplayLineWrap(struct layer *l , struct mline *ml , int y , int from , int to ,
                       int isblank ) 
{ 
  struct mchar nc ;
  int tmp ;

  {
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 629
    nc.image = *(ml->image + 0);
#line 629
    nc.attr = *(ml->attr + 0);
#line 629
    nc.font = *(ml->font + 0);
#line 629
    nc.fontx = *(ml->fontx + 0);
#line 629
    nc.color = *(ml->color + 0);
#line 629
    nc.mbcs = (unsigned char )0;
#line 629
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if (l->l_encoding == 8) {
#line 632
    tmp = (int )*(ml->font + 1) == 255 && (int )*(ml->image + 1) == 255;
  } else {
#line 632
    tmp = ((int )*(ml->font + 0) & 31) != 0 && ((int )*(ml->font + 0) & 224) == 0;
  }
#line 632
  if (tmp) {
#line 633
    nc.mbcs = *(ml->image + 1);
#line 634
    from ++;
  }
  {
#line 638
  LWrapChar(l, & nc, y - 1, - 1, - 1, 0);
#line 639
  from ++;
  }
#line 640
  if (from <= to) {
    {
#line 641
    LCDisplayLine(l, ml, y, from, to, isblank);
    }
  }
  return;
}
}
#line 645 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LSetRendition(struct layer *l , struct mchar *r ) 
{ 
  struct canvas *cv ;

  {
#line 649
  cv = l->l_cvlist;
  {
#line 649
  while (1) {
    while_continue: /* CIL Label */ ;
#line 649
    if (! cv) {
#line 649
      goto while_break;
    }
#line 650
    display = cv->c_display;
#line 651
    if (display->d_blocked) {
#line 652
      goto while_continue;
    }
    {
#line 653
    SetRendition(r);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  cv = cv->c_lnext;
  return;
}
}
#line 658 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LWrapChar(struct layer *l , struct mchar *c , int y , int top , int bot , int ins ) 
{ 
  struct canvas *cv ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  struct viewport *vp ;
  struct viewport *evp ;
  struct viewport **vpp ;
  int yy ;
  int y2 ;
  int yy2 ;
  int top2 ;
  int bot2 ;
  int bce ;
  int tmp ;
  int tmp___58 ;
  struct mchar *__cil_tmp21 ;
  struct mchar *tmp___59 ;
  struct mchar *__cil_tmp23 ;
  struct mchar *tmp___61 ;

  {
#line 665
  if (l->l_pause.d) {
    {
#line 667
    LayPauseUpdateRegion(l, 0, l->l_width - 1, top, bot);
    }
  }
#line 670
  if ((int )c->attr & (1 << 7)) {
#line 670
    tmp = 256;
  } else {
#line 670
    tmp = 0;
  }
#line 670
  bce = (((int )c->color & 240) >> 4) | tmp;
#line 675
  if (y != bot) {
#line 678
    if (y == l->l_height - 1) {
#line 678
      tmp___58 = y;
    } else {
#line 678
      tmp___58 = y + 1;
    }
#line 678
    yy = tmp___58;
#line 680
    cv = l->l_cvlist;
    {
#line 680
    while (1) {
      while_continue: /* CIL Label */ ;
#line 680
      if (! cv) {
#line 680
        goto while_break;
      }
#line 680
      if (l->l_pause.d) {
#line 680
        if (cv->c_slorient) {
#line 680
          goto while_continue;
        }
      }
#line 680
      y2 = 0;
#line 680
      display = cv->c_display;
#line 680
      if (display->d_blocked) {
#line 680
        goto while_continue;
      }
#line 680
      vp = cv->c_vplist;
      {
#line 680
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 680
        if (! vp) {
#line 680
          goto while_break___0;
        }
#line 680
        y2 = y + vp->v_yoff;
#line 680
        yy2 = yy + vp->v_yoff;
#line 680
        if (yy2 >= vp->v_ys) {
#line 680
          if (yy2 <= vp->v_ye) {
#line 680
            if (vp->v_xoff >= vp->v_xs) {
#line 680
              if (vp->v_xoff <= vp->v_xe) {
#line 680
                goto while_break___0;
              }
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 680
      vp = vp->v_next;
#line 680
      if (vp == (struct viewport *)0) {
#line 680
        goto while_continue;
      }
#line 680
      evp = cv->c_vplist;
      {
#line 680
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 680
        if (! evp) {
#line 680
          goto while_break___1;
        }
#line 680
        if (y2 >= evp->v_ys) {
#line 680
          if (y2 <= evp->v_ye) {
#line 680
            if ((evp->v_xoff + l->l_width) - 1 >= evp->v_xs) {
#line 680
              if ((evp->v_xoff + l->l_width) - 1 <= evp->v_xe) {
#line 680
                goto while_break___1;
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 680
      evp = evp->v_next;
#line 680
      if (evp == (struct viewport *)0) {
        _L: /* CIL Label */ 
        {
#line 680
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 680
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 680
        cvlist = l->l_cvlist;
#line 680
        cvlnext = cv->c_lnext;
#line 680
        l->l_cvlist = cv;
#line 680
        cv->c_lnext = (struct canvas *)0;
#line 680
        if (ins) {
          {
#line 680
          LInsChar(l, c, 0, yy, (struct mline *)0);
          }
        } else {
          {
#line 680
          LPutChar(l, c, 0, yy);
          }
        }
#line 680
        l->l_cvlist = cvlist;
#line 680
        cv->c_lnext = cvlnext;
      } else
#line 680
      if (ins) {
#line 680
        if ((vp->v_xoff + l->l_width) - 1 > vp->v_ye) {
#line 680
          goto _L;
        } else {
#line 680
          goto _L___60;
        }
      } else {
        _L___60: /* CIL Label */ 
#line 680
        if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
          {
#line 680
          __cil_tmp21 = recode_mchar(c, l->l_encoding, display->d_encoding);
#line 680
          tmp___59 = __cil_tmp21;
          }
        } else {
#line 680
          tmp___59 = c;
        }
        {
#line 680
        WrapChar(tmp___59, vp->v_xoff + l->l_width, y2, vp->v_xoff, - 1, (vp->v_xoff + l->l_width) - 1,
                 - 1, ins);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 680
    cv = cv->c_lnext;
  } else {
#line 726
    cv = l->l_cvlist;
    {
#line 726
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 726
      if (! cv) {
#line 726
        goto while_break___3;
      }
#line 726
      if (l->l_pause.d) {
#line 726
        if (cv->c_slorient) {
#line 726
          goto while_continue___3;
        }
      }
#line 726
      display = cv->c_display;
#line 726
      if (display->d_blocked) {
#line 726
        goto while_continue___3;
      }
#line 726
      vpp = & cv->c_vplist;
      {
#line 726
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 726
        if (! vp) {
#line 726
          goto while_break___4;
        }
#line 726
        yy2 = bot + vp->v_yoff;
#line 726
        if (yy2 >= vp->v_ys) {
#line 726
          if (yy2 <= vp->v_ye) {
#line 726
            if (vp->v_xoff >= vp->v_xs) {
#line 726
              if ((vp->v_xoff + l->l_width) - 1 <= vp->v_xe) {
#line 726
                goto while_break___4;
              }
            }
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 726
      vpp = & vp->v_next;
#line 726
      if (vp) {
#line 726
        *vpp = vp->v_next;
      }
#line 726
      if (cv->c_vplist) {
        {
#line 726
        cvlist = l->l_cvlist;
#line 726
        cvlnext = cv->c_lnext;
#line 726
        l->l_cvlist = cv;
#line 726
        cv->c_lnext = (struct canvas *)0;
#line 726
        LScrollV(l, 1, top, bot, bce);
        }
#line 726
        if (! vp) {
#line 726
          if (ins) {
            {
#line 726
            LInsChar(l, c, 0, bot, (struct mline *)0);
            }
          } else {
            {
#line 726
            LPutChar(l, c, 0, bot);
            }
          }
        }
#line 726
        l->l_cvlist = cvlist;
#line 726
        cv->c_lnext = cvlnext;
      }
#line 726
      if (vp) {
#line 726
        *vpp = vp;
#line 726
        top2 = top + vp->v_yoff;
#line 726
        bot2 = bot + vp->v_yoff;
#line 726
        if (top2 < vp->v_ys) {
#line 726
          top2 = vp->v_ys;
        }
#line 726
        if ((l->l_encoding == 8) != (display->d_encoding == 8)) {
          {
#line 726
          __cil_tmp23 = recode_mchar(c, l->l_encoding, display->d_encoding);
#line 726
          tmp___61 = __cil_tmp23;
          }
        } else {
#line 726
          tmp___61 = c;
        }
        {
#line 726
        WrapChar(tmp___61, vp->v_xoff + l->l_width, bot2, vp->v_xoff, top2, (vp->v_xoff + l->l_width) - 1,
                 bot2, ins);
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 726
    cv = cv->c_lnext;
  }
  return;
}
}
#line 776 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LCursorVisibility(struct layer *l , int vis ) 
{ 
  struct canvas *cv ;

  {
#line 779
  cv = l->l_cvlist;
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (! cv) {
#line 779
      goto while_break;
    }
#line 780
    display = cv->c_display;
#line 781
    if (display->d_blocked) {
#line 782
      goto while_continue;
    }
#line 783
    if (cv != display->d_forecv) {
#line 784
      goto while_continue;
    }
    {
#line 785
    CursorVisibility(vis);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 779
  cv = cv->c_lnext;
  return;
}
}
#line 790 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LSetFlow(struct layer *l , int flow ) 
{ 
  struct canvas *cv ;

  {
#line 793
  cv = l->l_cvlist;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! cv) {
#line 793
      goto while_break;
    }
#line 794
    display = cv->c_display;
#line 795
    if (cv != display->d_forecv) {
#line 796
      goto while_continue;
    }
    {
#line 797
    SetFlow(flow);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 793
  cv = cv->c_lnext;
  return;
}
}
#line 802 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LKeypadMode(struct layer *l , int on ) 
{ 
  struct canvas *cv ;

  {
#line 805
  cv = l->l_cvlist;
  {
#line 805
  while (1) {
    while_continue: /* CIL Label */ ;
#line 805
    if (! cv) {
#line 805
      goto while_break;
    }
#line 806
    display = cv->c_display;
#line 807
    if (display->d_blocked) {
#line 808
      goto while_continue;
    }
#line 809
    if (cv != display->d_forecv) {
#line 810
      goto while_continue;
    }
    {
#line 811
    KeypadMode(on);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 805
  cv = cv->c_lnext;
  return;
}
}
#line 816 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LCursorkeysMode(struct layer *l , int on ) 
{ 
  struct canvas *cv ;

  {
#line 819
  cv = l->l_cvlist;
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    if (! cv) {
#line 819
      goto while_break;
    }
#line 820
    display = cv->c_display;
#line 821
    if (display->d_blocked) {
#line 822
      goto while_continue;
    }
#line 823
    if (cv != display->d_forecv) {
#line 824
      goto while_continue;
    }
    {
#line 825
    CursorkeysMode(on);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 819
  cv = cv->c_lnext;
  return;
}
}
#line 830 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LMouseMode(struct layer *l , int on ) 
{ 
  struct canvas *cv ;

  {
#line 833
  cv = l->l_cvlist;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    if (! cv) {
#line 833
      goto while_break;
    }
#line 834
    display = cv->c_display;
#line 835
    if (display->d_blocked) {
#line 836
      goto while_continue;
    }
#line 837
    if (cv != display->d_forecv) {
#line 838
      goto while_continue;
    }
    {
#line 839
    MouseMode(on);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 833
  cv = cv->c_lnext;
  return;
}
}
#line 843 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LClearAll(struct layer *l , int uself ) 
{ 


  {
  {
#line 845
  LClearArea(l, 0, 0, l->l_width - 1, l->l_height - 1, 0, uself);
  }
  return;
}
}
#line 849 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LRefreshAll(struct layer *l , int isblank ) 
{ 
  struct layer *oldflayer ;
  int y ;

  {
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 855
  oldflayer = flayer;
#line 856
  flayer = l;
#line 857
  if (! isblank) {
    {
#line 858
    LClearArea(l, 0, 0, l->l_width - 1, l->l_height - 1, 0, 0);
    }
  }
  {
#line 860
  (*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1, - 1, - 1, 1);
#line 861
  y = 0;
  }
  {
#line 861
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 861
    if (! (y < l->l_height)) {
#line 861
      goto while_break___0;
    }
    {
#line 862
    (*((flayer->l_layfn)->lf_LayRedisplayLine))(y, 0, l->l_width - 1, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 861
  y ++;
#line 863
  flayer = oldflayer;
  return;
}
}
#line 869 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LMsg(int err , char const   *fmt  , ...) 
{ 
  va_list ap ;
  char buf[8192] ;
  char *p ;
  struct canvas *cv ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 879
  p = (char *)buf;
#line 882
  __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 883
  fmt = DoNLS(fmt);
#line 884
  __cil_tmp8 = vsnprintf(p, sizeof(buf) - 100UL, fmt, (__builtin_va_list *)ap);
#line 885
  __builtin_va_end((__builtin_va_list *)ap);
  }
#line 887
  if (err) {
    {
#line 888
    __cil_tmp9 = strlen((char const   *)p);
    }
    {
#line 888
    p += __cil_tmp9;
#line 889
    __cil_tmp10 = p;
#line 889
    p ++;
#line 889
    *__cil_tmp10 = (char )':';
#line 890
    __cil_tmp11 = p;
#line 890
    p ++;
#line 890
    *__cil_tmp11 = (char )' ';
#line 891
    __cil_tmp12 = strerror(err);
#line 891
    strncpy(p, (char const   *)__cil_tmp12, (unsigned long )((((char *)buf + sizeof(buf)) - p) - 1L));
#line 892
    buf[sizeof(buf) - 1UL] = (char )0;
    }
  }
  {
#line 895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 895
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 896
  display = displays;
  {
#line 896
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 896
    if (! display) {
#line 896
      goto while_break___0;
    }
#line 897
    cv = display->d_cvlist;
    {
#line 897
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 897
      if (! cv) {
#line 897
        goto while_break___1;
      }
#line 898
      if (cv->c_layer == flayer) {
#line 899
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 897
    cv = cv->c_next;
#line 901
    if (cv == (struct canvas *)0) {
#line 902
      goto while_continue___0;
    }
    {
#line 903
    MakeStatus((char *)buf);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 896
  display = display->d_next;
  return;
}
}
#line 908 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LExtMouseMode(struct layer *l , int on ) 
{ 
  struct canvas *cv ;

  {
#line 913
  cv = l->l_cvlist;
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    if (! cv) {
#line 913
      goto while_break;
    }
#line 915
    display = cv->c_display;
#line 916
    if (display->d_blocked) {
#line 917
      goto while_continue;
    }
#line 918
    if (cv != display->d_forecv) {
#line 919
      goto while_continue;
    }
    {
#line 920
    ExtMouseMode(on);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 913
  cv = cv->c_lnext;
  return;
}
}
#line 932 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void KillLayerChain(struct layer *lay ) 
{ 
  struct canvas *cv ;
  struct canvas *ncv ;
  struct layer *l ;
  struct layer *oldflayer ;

  {
#line 937
  oldflayer = flayer;
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 939
  l = lay;
  {
#line 939
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 939
    if (! l) {
#line 939
      goto while_break___0;
    }
#line 940
    if (l->l_layfn == & WinLf) {
#line 941
      goto while_break___0;
    } else
#line 940
    if (l->l_layfn == & BlankLf) {
#line 941
      goto while_break___0;
    }
    {
#line 942
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 942
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 943
    if (oldflayer == l) {
#line 944
      oldflayer = (struct layer *)0;
    }
#line 945
    cv = l->l_cvlist;
    {
#line 945
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 945
      if (! cv) {
#line 945
        goto while_break___2;
      }
#line 946
      ncv = cv->c_lnext;
#line 947
      cv->c_layer = (struct layer *)0;
#line 948
      cv->c_lnext = (struct canvas *)0;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 945
    cv = ncv;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 939
  l = l->l_next;
#line 951
  flayer = lay;
  {
#line 952
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 952
    if (! (flayer != l)) {
#line 952
      goto while_break___3;
    }
    {
#line 953
    ExitOverlayPage();
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 954
  flayer = oldflayer;
  return;
}
}
#line 959 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
int InitOverlayPage(int datasize , struct LayFuncs *lf , int block ) 
{ 
  char *data ;
  struct layer *newlay ;
  struct canvas *cv ;
  struct canvas *cvp ;
  struct canvas **cvpp ;
  struct win *p ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  struct display *olddisplay ;
  struct display *olddisplay___0 ;
  struct canvas *cv___62 ;

  {
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;
#line 966
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 968
  cv = (struct canvas *)0;
#line 969
  if (display) {
#line 969
    if ((display->d_forecv)->c_layer == flayer) {
#line 970
      cv = display->d_forecv;
    }
  }
  {
#line 972
  __cil_tmp10 = calloc((unsigned long )1, sizeof(struct layer ));
#line 972
  newlay = (struct layer *)__cil_tmp10;
  }
#line 972
  if (newlay == (struct layer *)0) {
    {
#line 973
    Msg(0, (char const   *)((char *)"No memory for layer struct"));
    }
#line 974
    return (- 1);
  }
  {
#line 976
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 976
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 977
  data = (char *)0;
#line 978
  if (datasize) {
    {
#line 979
    __cil_tmp11 = calloc((unsigned long )1, (unsigned long )datasize);
#line 979
    data = (char *)__cil_tmp11;
    }
#line 979
    if (data == (char *)0) {
      {
#line 980
      free((void *)((char *)newlay));
#line 981
      Msg(0, (char const   *)((char *)"No memory for layer data"));
      }
#line 982
      return (- 1);
    }
  }
#line 985
  p = (struct win *)(flayer->l_bottom)->l_data;
#line 987
  if (p) {
#line 987
    if (p->w_savelayer == flayer) {
      _L: /* CIL Label */ 
#line 988
      if (p->w_savelayer) {
#line 988
        if (p->w_savelayer != flayer) {
#line 988
          if ((p->w_savelayer)->l_cvlist == (struct canvas *)0) {
            {
#line 989
            KillLayerChain(p->w_savelayer);
            }
          }
        }
      }
#line 990
      p->w_savelayer = newlay;
    } else
#line 987
    if (block) {
#line 987
      if (flayer->l_next == (struct layer *)0) {
#line 987
        goto _L;
      }
    }
  }
#line 993
  if (cv) {
#line 993
    if (flayer->l_next == (struct layer *)0) {
#line 993
      if (! block) {
        {
#line 994
        olddisplay = display;
#line 995
        display = cv->c_display;
#line 996
        RemoveStatus();
#line 997
        display = olddisplay;
#line 1000
        cvpp = & flayer->l_cvlist;
        }
        {
#line 1000
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1000
          if (! cvp) {
#line 1000
            goto while_break___1;
          }
#line 1001
          if (cvp == cv) {
#line 1002
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1000
        cvpp = & cvp->c_lnext;
        {
#line 1004
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1004
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1005
        *cvpp = cv->c_lnext;
#line 1006
        newlay->l_cvlist = cv;
#line 1007
        cv->c_lnext = (struct canvas *)0;
#line 1008
        cv->c_layer = newlay;
      } else {
#line 993
        goto _L___63;
      }
    } else {
#line 993
      goto _L___63;
    }
  } else {
    _L___63: /* CIL Label */ 
    {
#line 1011
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1011
      olddisplay___0 = display;
#line 1011
      display = displays;
      {
#line 1011
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1011
        if (! display) {
#line 1011
          goto while_break___4;
        }
#line 1011
        cv___62 = display->d_cvlist;
        {
#line 1011
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1011
          if (! cv___62) {
#line 1011
            goto while_break___5;
          }
#line 1011
          if (cv___62->c_layer == flayer) {
#line 1011
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1011
        cv___62 = cv___62->c_next;
#line 1011
        if (cv___62 == (struct canvas *)0) {
#line 1011
          goto while_continue___4;
        }
        {
#line 1011
        RemoveStatus();
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1011
      display = display->d_next;
#line 1011
      display = olddisplay___0;
#line 1011
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1012
    if (block) {
      {
#line 1013
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1013
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1014
    if (block) {
#line 1014
      if (flayer->l_layfn == & WinLf) {
        {
#line 1015
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1015
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1016
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1016
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 1017
        (p->w_blocked) ++;
#line 1018
        newlay->l_blocking = 1;
      }
    }
#line 1022
    newlay->l_cvlist = flayer->l_cvlist;
#line 1024
    cvp = newlay->l_cvlist;
    {
#line 1024
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1024
      if (! cvp) {
#line 1024
        goto while_break___9;
      }
#line 1025
      cvp->c_layer = newlay;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1024
    cvp = cvp->c_lnext;
#line 1026
    flayer->l_cvlist = (struct canvas *)0;
  }
  {
#line 1028
  newlay->l_width = flayer->l_width;
#line 1029
  newlay->l_height = flayer->l_height;
#line 1030
  newlay->l_encoding = 0;
#line 1031
  newlay->l_layfn = lf;
#line 1032
  newlay->l_data = (void *)data;
#line 1033
  newlay->l_next = flayer;
#line 1034
  newlay->l_bottom = flayer->l_bottom;
#line 1035
  flayer = newlay;
#line 1036
  (*((flayer->l_layfn)->lf_LayRestore))();
  }
#line 1037
  return (0);
}
}
#line 1043 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void ExitOverlayPage(void) 
{ 
  struct layer *oldlay ;
  struct win *p ;
  int doredisplay ;
  struct canvas *cv ;
  struct canvas *ocv ;
  struct layout *lay ;
  int __cil_tmp7 ;

  {
#line 1047
  doredisplay = 0;
  {
#line 1051
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1051
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1052
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1052
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1053
  oldlay = flayer;
#line 1054
  if (oldlay->l_data) {
#line 1055
    if ((oldlay->l_layfn)->lf_LayFree) {
      {
#line 1056
      (*((flayer->l_layfn)->lf_LayFree))(oldlay->l_data);
      }
    }
    {
#line 1057
    free(oldlay->l_data);
    }
  }
#line 1059
  p = (struct win *)(flayer->l_bottom)->l_data;
#line 1061
  flayer = oldlay->l_next;
#line 1062
  if (flayer->l_layfn == & WinLf) {
#line 1063
    if (oldlay->l_blocking) {
      {
#line 1064
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1064
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1065
      __cil_tmp7 = p->w_blocked;
#line 1065
      (p->w_blocked) --;
      {
#line 1066
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1066
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1070
    if (p->w_blocked) {
#line 1070
      if (p->w_savelayer) {
#line 1070
        if (p->w_savelayer != flayer) {
#line 1070
          if (oldlay->l_cvlist) {
            {
#line 1071
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1071
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 1073
            flayer = p->w_savelayer;
#line 1074
            doredisplay = 1;
          }
        }
      }
    }
  }
#line 1078
  if (p) {
#line 1078
    if (p->w_savelayer == oldlay) {
#line 1079
      p->w_savelayer = flayer;
    }
  }
#line 1081
  if (p) {
#line 1081
    if (oldlay == p->w_paster.pa_pastelayer) {
#line 1082
      p->w_paster.pa_pastelayer = (struct layer *)0;
    }
  }
#line 1085
  lay = layouts;
  {
#line 1085
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1085
    if (! lay) {
#line 1085
      goto while_break___4;
    }
#line 1086
    cv = lay->lay_cvlist;
    {
#line 1086
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1086
      if (! cv) {
#line 1086
        goto while_break___5;
      }
#line 1087
      if (cv->c_layer == oldlay) {
#line 1088
        cv->c_layer = flayer;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1086
    cv = cv->c_next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1085
  lay = lay->lay_next;
#line 1091
  cv = oldlay->l_cvlist;
#line 1091
  ocv = (struct canvas *)0;
  {
#line 1091
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1091
    if (! cv) {
#line 1091
      goto while_break___6;
    }
#line 1092
    cv->c_layer = flayer;
#line 1093
    ocv = cv;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1091
  cv = cv->c_lnext;
#line 1095
  if (ocv) {
#line 1096
    cv = flayer->l_cvlist;
#line 1097
    ocv->c_lnext = (struct canvas *)0;
#line 1098
    flayer->l_cvlist = oldlay->l_cvlist;
#line 1101
    if (doredisplay) {
      {
#line 1102
      LRefreshAll(flayer, 0);
      }
    }
#line 1103
    ocv->c_lnext = cv;
  }
  {
#line 1105
  oldlay->l_cvlist = (struct canvas *)0;
#line 1106
  LayerCleanupMemory(oldlay);
#line 1107
  free((void *)((char *)oldlay));
#line 1108
  (*((flayer->l_layfn)->lf_LayRestore))();
#line 1109
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
  return;
}
}
#line 1112 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
int LayProcessMouse(struct layer *l , unsigned char ch ) 
{ 
  int len ;
  int __cil_tmp4 ;
  int tmp ;

  {
#line 1116
  if ((unsigned long )l->l_mouseevent.len >= sizeof(l->l_mouseevent.buffer)) {
#line 1117
    return (- 1);
  }
#line 1119
  __cil_tmp4 = l->l_mouseevent.len;
#line 1119
  (l->l_mouseevent.len) ++;
#line 1119
  len = __cil_tmp4;
#line 1120
  if (len > 0) {
#line 1120
    tmp = (int )ch - 33;
  } else {
#line 1120
    tmp = (int )ch;
  }
#line 1120
  l->l_mouseevent.buffer[len] = (unsigned char )tmp;
#line 1121
  return ((unsigned long )l->l_mouseevent.len == sizeof(l->l_mouseevent.buffer));
}
}
#line 1124 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LayProcessMouseSwitch(struct layer *l , int s ) 
{ 


  {
#line 1126
  l->l_mouseevent.start = s;
#line 1126
  if (l->l_mouseevent.start) {
#line 1127
    l->l_mouseevent.len = 0;
  }
  return;
}
}
#line 1131 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LayPause(struct layer *layer , int pause___0 ) 
{ 
  struct canvas *cv ;
  int line ;
  struct win *win ;
  struct viewport *vp ;
  int xs ;
  int xe ;
  struct mline *ml ;
  int tmp ;
  int cx ;
  int cy ;

  {
#line 1136
  pause___0 = ! (! pause___0);
#line 1138
  if (layer->l_pause.d == pause___0) {
#line 1139
    return;
  }
#line 1141
  layer->l_pause.d = pause___0;
#line 1141
  if (layer->l_pause.d) {
#line 1143
    layer->l_pause.bottom = - 1;
#line 1143
    layer->l_pause.top = layer->l_pause.bottom;
#line 1144
    return;
  }
#line 1148
  if (layer->l_pause.top == -1) {
#line 1148
    if (layer->l_pause.bottom == -1) {
#line 1149
      return;
    }
  }
#line 1151
  if (layer->l_layfn == & WinLf) {
#line 1152
    win = (struct win *)layer->l_data;
  } else {
#line 1154
    win = (struct win *)((void *)0);
  }
#line 1156
  cv = layer->l_cvlist;
  {
#line 1156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1156
    if (! cv) {
#line 1156
      goto while_break;
    }
#line 1159
    if (! cv->c_slorient) {
#line 1160
      goto while_continue;
    }
#line 1161
    display = cv->c_display;
#line 1162
    vp = cv->c_vplist;
    {
#line 1162
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1162
      if (! vp) {
#line 1162
        goto while_break___0;
      }
#line 1163
      line = layer->l_pause.top;
      {
#line 1163
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1163
        if (! (line <= layer->l_pause.bottom)) {
#line 1163
          goto while_break___1;
        }
#line 1165
        xe = *(layer->l_pause.right + line);
#line 1165
        xs = *(layer->l_pause.left + line);
#line 1165
        if (line + vp->v_yoff >= vp->v_ys) {
#line 1165
          if (line + vp->v_yoff <= vp->v_ye) {
#line 1165
            if (xs >= 0) {
#line 1165
              if (xe >= 0) {
#line 1168
                xs += vp->v_xoff;
#line 1169
                xe += vp->v_xoff;
#line 1171
                if (xs < vp->v_xs) {
#line 1171
                  xs = vp->v_xs;
                }
#line 1172
                if (xe > vp->v_xe) {
#line 1172
                  xe = vp->v_xe;
                }
#line 1175
                if (layer->l_encoding == 8) {
#line 1175
                  if (xe < vp->v_xe) {
#line 1175
                    if (win) {
#line 1176
                      ml = win->w_mlines + line;
#line 1177
                      tmp = (int )*(ml->font + (xe + 1)) == 255 && (int )*(ml->image + (xe + 1)) == 255;
#line 1177
                      if (tmp) {
#line 1178
                        xe ++;
                      }
                    }
                  }
                }
#line 1182
                if (xs <= xe) {
                  {
#line 1183
                  RefreshLine(line + vp->v_yoff, xs, xe, 0);
                  }
                }
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1163
      line ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1162
    vp = vp->v_next;
#line 1188
    if (cv == display->d_forecv) {
#line 1189
      cx = layer->l_x + cv->c_xoff;
#line 1190
      cy = layer->l_y + cv->c_yoff;
#line 1192
      if (cx < cv->c_xs) {
#line 1192
        cx = cv->c_xs;
      }
#line 1193
      if (cy < cv->c_ys) {
#line 1193
        cy = cv->c_ys;
      }
#line 1194
      if (cx > cv->c_xe) {
#line 1194
        cx = cv->c_xe;
      }
#line 1195
      if (cy > cv->c_ye) {
#line 1195
        cy = cv->c_ye;
      }
      {
#line 1197
      GotoPos(cx, cy);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1156
  cv = cv->c_lnext;
#line 1201
  line = layer->l_pause.top;
  {
#line 1201
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1201
    if (! (line <= layer->l_pause.bottom)) {
#line 1201
      goto while_break___2;
    }
#line 1202
    *(layer->l_pause.right + line) = - 1;
#line 1202
    *(layer->l_pause.left + line) = *(layer->l_pause.right + line);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1201
  line ++;
  return;
}
}
#line 1205 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LayPauseUpdateRegion(struct layer *layer , int xs , int xe , int ys , int ye ) 
{ 
  int o ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
#line 1207
  if (! layer->l_pause.d) {
#line 1208
    return;
  }
#line 1209
  if (ys < 0) {
#line 1210
    ys = 0;
  }
#line 1211
  if (ye >= layer->l_height) {
#line 1212
    ye = layer->l_height - 1;
  }
#line 1213
  if (xe >= layer->l_width) {
#line 1214
    xe = layer->l_width - 1;
  }
#line 1216
  if (layer->l_pause.top == -1) {
#line 1217
    layer->l_pause.top = ys;
  } else
#line 1216
  if (layer->l_pause.top > ys) {
#line 1217
    layer->l_pause.top = ys;
  }
#line 1218
  if (layer->l_pause.bottom < ye) {
#line 1219
    layer->l_pause.bottom = ye;
#line 1221
    if (layer->l_pause.lines <= ye) {
      {
#line 1222
      o = layer->l_pause.lines;
#line 1223
      layer->l_pause.lines = ye + 32;
#line 1224
      __cil_tmp7 = realloc((void *)layer->l_pause.left, sizeof(int ) * (unsigned long )layer->l_pause.lines);
#line 1224
      layer->l_pause.left = (int *)__cil_tmp7;
#line 1225
      __cil_tmp8 = realloc((void *)layer->l_pause.right, sizeof(int ) * (unsigned long )layer->l_pause.lines);
#line 1225
      layer->l_pause.right = (int *)__cil_tmp8;
      }
      {
#line 1226
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1226
        if (! (o < layer->l_pause.lines)) {
#line 1226
          goto while_break;
        }
#line 1227
        *(layer->l_pause.right + o) = - 1;
#line 1227
        *(layer->l_pause.left + o) = *(layer->l_pause.right + o);
#line 1228
        o ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1232
    if (! (ys <= ye)) {
#line 1232
      goto while_break___0;
    }
#line 1233
    if (*(layer->l_pause.left + ys) == -1) {
#line 1234
      *(layer->l_pause.left + ys) = xs;
    } else
#line 1233
    if (*(layer->l_pause.left + ys) > xs) {
#line 1234
      *(layer->l_pause.left + ys) = xs;
    }
#line 1235
    if (*(layer->l_pause.right + ys) < xe) {
#line 1236
      *(layer->l_pause.right + ys) = xe;
    }
#line 1237
    ys ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 1241 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/layer.c"
void LayerCleanupMemory(struct layer *layer ) 
{ 


  {
#line 1243
  if (layer->l_pause.left) {
    {
#line 1244
    free((void *)layer->l_pause.left);
    }
  }
#line 1245
  if (layer->l_pause.right) {
    {
#line 1246
    free((void *)layer->l_pause.right);
    }
  }
  return;
}
}
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 224
__inline extern  __attribute__((__nothrow__)) int stat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 226
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 249
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   *__filename ,
                                                            struct stat64 *__statbuf ,
                                                            int __flag )  __attribute__((__gnu_inline__)) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 272
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 395
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag ) ;
#line 428
extern  __attribute__((__nothrow__)) int __fxstat64(int __ver , int __fildes , struct stat64 *__stat_buf ) ;
#line 430
extern  __attribute__((__nothrow__)) int __xstat64(int __ver , char const   *__filename ,
                                                   struct stat64 *__stat_buf ) ;
#line 432
extern  __attribute__((__nothrow__)) int __lxstat64(int __ver , char const   *__filename ,
                                                    struct stat64 *__stat_buf ) ;
#line 434
extern  __attribute__((__nothrow__)) int __fxstatat64(int __ver , int __fildes , char const   *__filename ,
                                                      struct stat64 *__stat_buf ,
                                                      int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev ) ;
#line 449
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 449 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int stat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 451
  __cil_tmp3 = __xstat(1, __path, __statbuf);
  }
#line 451
  return (__cil_tmp3);
}
}
#line 456
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 456 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int lstat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 458
  __cil_tmp3 = __lxstat(1, __path, __statbuf);
  }
#line 458
  return (__cil_tmp3);
}
}
#line 463
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 463 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 465
  __cil_tmp3 = __fxstat(1, __fd, __statbuf);
  }
#line 465
  return (__cil_tmp3);
}
}
#line 470
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 470 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstatat(int __fd , char const   *__filename , struct stat *__statbuf ,
                            int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 473
  __cil_tmp5 = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
#line 473
  return (__cil_tmp5);
}
}
#line 479
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 479 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 481
  __cil_tmp4 = __xmknod(0, __path, __mode, & __dev);
  }
#line 481
  return (__cil_tmp4);
}
}
#line 487
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 487 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 490
  __cil_tmp5 = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 490
  return (__cil_tmp5);
}
}
#line 498
__inline extern  __attribute__((__nothrow__)) int stat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 498 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int stat64(char const   *__path , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 500
  __cil_tmp3 = __xstat64(1, __path, __statbuf);
  }
#line 500
  return (__cil_tmp3);
}
}
#line 505
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 505 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int lstat64(char const   *__path , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 507
  __cil_tmp3 = __lxstat64(1, __path, __statbuf);
  }
#line 507
  return (__cil_tmp3);
}
}
#line 512
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 512 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstat64(int __fd , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 514
  __cil_tmp3 = __fxstat64(1, __fd, __statbuf);
  }
#line 514
  return (__cil_tmp3);
}
}
#line 519
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   *__filename ,
                                                            struct stat64 *__statbuf ,
                                                            int __flag )  __attribute__((__gnu_inline__)) ;
#line 519 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstatat64(int __fd , char const   *__filename , struct stat64 *__statbuf ,
                              int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 522
  __cil_tmp5 = __fxstatat64(1, __fd, __filename, __statbuf, __flag);
  }
#line 522
  return (__cil_tmp5);
}
}
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 652
extern size_t fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 786
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 47 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.h"
struct logfile *logfopen(char *name , FILE *fp ) ;
#line 54
int islogfile(char *name ) ;
#line 59
int logfclose(struct logfile *l ) ;
#line 60
int logfwrite(struct logfile *l , char *buf , int n ) ;
#line 67
int logfflush(struct logfile *l ) ;
#line 77
void logreopen_register(int (*fn)(char * , int  , struct logfile * ) ) ;
#line 87
int lf_move_fd(int fd , int need_fd ) ;
#line 38 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
static void changed_logfile(struct logfile *l ) ;
#line 39
static struct logfile *lookup_logfile(char *name ) ;
#line 40
static int stolen_logfile(struct logfile *l ) ;
#line 42 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
static struct logfile *logroot  =    (struct logfile *)((void *)0);
#line 44 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
static void changed_logfile(struct logfile *l ) 
{ 
  struct stat o ;
  struct stat *s ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 45
  s = l->st;
#line 47
  __cil_tmp4 = fileno(l->fp);
#line 47
  __cil_tmp5 = fstat(__cil_tmp4, & o);
  }
#line 47
  if (__cil_tmp5 < 0) {
#line 48
    return;
  }
#line 49
  if (o.st_size > s->st_size) {
#line 50
    s->st_size = o.st_size;
#line 51
    s->st_mtim.tv_sec = o.st_mtim.tv_sec;
  }
  return;
}
}
#line 63 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
int lf_move_fd(int fd , int need_fd ) 
{ 
  int r ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 64
  r = - 1;
#line 66
  if (fd == need_fd) {
#line 67
    return (fd);
  }
#line 68
  if (fd >= 0) {
#line 68
    if (fd < need_fd) {
      {
#line 69
      __cil_tmp4 = dup(fd);
#line 69
      __cil_tmp5 = lf_move_fd(__cil_tmp4, need_fd);
#line 69
      r = __cil_tmp5;
      }
    }
  }
  {
#line 70
  close(fd);
  }
#line 71
  return (r);
}
}
#line 74 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
static int logfile_reopen(char *name , int wantfd , struct logfile *l ) 
{ 
  int got_fd ;
  int __cil_tmp6 ;

  {
  {
#line 77
  close(wantfd);
#line 78
  __cil_tmp6 = lf_move_fd(got_fd, wantfd);
  }
  {
#line 78
  got_fd = open((char const   *)name, 1089, 438);
  }
#line 78
  if (got_fd < 0) {
    _L: /* CIL Label */ 
    {
#line 79
    logfclose(l);
    }
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
#line 80
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 81
    return (- 1);
  } else
#line 78
  if (__cil_tmp6 < 0) {
#line 78
    goto _L;
  }
  {
#line 83
  changed_logfile(l);
  }
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  return (0);
}
}
#line 88 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
static int (*lf_reopen_fn)()  =    logfile_reopen;
#line 102 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
void logreopen_register(int (*fn)(char * , int  , struct logfile * ) ) 
{ 
  int (*tmp)(char * , int  , struct logfile * ) ;

  {
#line 105
  if (fn) {
#line 105
    tmp = fn;
  } else {
#line 105
    tmp = (int (*)(char * , int  , struct logfile * ))logfile_reopen;
  }
#line 105
  lf_reopen_fn = (int (*)())((int )tmp);
  return;
}
}
#line 114 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
static int stolen_logfile(struct logfile *l ) 
{ 
  struct stat o ;
  struct stat *s ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 115
  s = l->st;
#line 117
  o = *s;
#line 118
  __cil_tmp4 = fileno(l->fp);
#line 118
  __cil_tmp5 = fstat(__cil_tmp4, s);
  }
#line 118
  if (__cil_tmp5 < 0) {
#line 119
    s->st_dev = (__dev_t )0;
#line 119
    s->st_ino = s->st_dev;
  }
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  if (! o.st_dev) {
#line 122
    if (! o.st_ino) {
#line 123
      return (0);
    }
  }
#line 125
  if (! s->st_dev) {
#line 125
    if (! s->st_ino) {
      _L: /* CIL Label */ 
      {
#line 133
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 133
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 134
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 134
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 135
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 135
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 136
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 136
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 137
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 137
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 138
      return (- 1);
    } else {
#line 125
      goto _L___68;
    }
  } else
  _L___68: /* CIL Label */ 
#line 125
  if (! s->st_nlink) {
#line 125
    goto _L;
  } else
#line 125
  if (s->st_size < o.st_size) {
#line 125
    goto _L;
  } else
#line 125
  if (s->st_mtim.tv_sec != o.st_mtim.tv_sec) {
#line 125
    goto _L;
  } else
#line 125
  if (s->st_ctim.tv_sec != o.st_ctim.tv_sec) {
#line 125
    if (! (s->st_mtim.tv_sec == s->st_ctim.tv_sec && o.st_ctim.tv_sec < s->st_ctim.tv_sec)) {
#line 125
      goto _L;
    }
  }
  {
#line 140
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 140
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 141
  return (0);
}
}
#line 144 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
static struct logfile *lookup_logfile(char *name ) 
{ 
  struct logfile *l ;
  int __cil_tmp3 ;

  {
#line 147
  l = logroot;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! l) {
#line 147
      goto while_break;
    }
    {
#line 148
    __cil_tmp3 = strcmp((char const   *)name, (char const   *)l->name);
    }
#line 148
    if (! __cil_tmp3) {
#line 149
      return (l);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  l = l->next;
#line 150
  return ((struct logfile *)((void *)0));
}
}
#line 153 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
struct logfile *logfopen(char *name , FILE *fp ) 
{ 
  struct logfile *l ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 156
  if (! fp) {
    {
#line 157
    l = lookup_logfile(name);
    }
#line 157
    if (! l) {
#line 158
      return ((struct logfile *)((void *)0));
    }
#line 159
    (l->opencount) ++;
#line 160
    return (l);
  }
  {
#line 163
  __cil_tmp6 = malloc(sizeof(struct logfile ));
#line 163
  l = (struct logfile *)__cil_tmp6;
  }
#line 163
  if (! l) {
#line 164
    return ((struct logfile *)((void *)0));
  }
  {
#line 165
  __cil_tmp7 = malloc(sizeof(struct stat ));
#line 165
  l->st = (struct stat *)__cil_tmp7;
  }
#line 165
  if (! l->st) {
    {
#line 166
    free((void *)((char *)l));
    }
#line 167
    return ((struct logfile *)((void *)0));
  }
  {
#line 170
  l->name = SaveStr((char const   *)name);
  }
#line 170
  if (! l->name) {
    {
#line 171
    free((void *)((char *)l->st));
#line 172
    free((void *)((char *)l));
    }
#line 173
    return ((struct logfile *)((void *)0));
  }
  {
#line 175
  l->fp = fp;
#line 176
  l->opencount = 1;
#line 177
  l->writecount = 0;
#line 178
  l->flushcount = 0;
#line 179
  changed_logfile(l);
#line 181
  l->next = logroot;
#line 182
  logroot = l;
  }
#line 183
  return (l);
}
}
#line 186 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
int islogfile(char *name ) 
{ 
  int tmp ;
  struct logfile *__cil_tmp3 ;
  int tmp___69 ;

  {
#line 187
  if (! name) {
#line 188
    if (logroot) {
#line 188
      tmp = 1;
    } else {
#line 188
      tmp = 0;
    }
#line 188
    return (tmp);
  }
  {
#line 189
  __cil_tmp3 = lookup_logfile(name);
  }
#line 189
  if (__cil_tmp3) {
#line 189
    tmp___69 = 1;
  } else {
#line 189
    tmp___69 = 0;
  }
#line 189
  return (tmp___69);
}
}
#line 192 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
int logfclose(struct logfile *l ) 
{ 
  struct logfile **lp ;

  {
#line 195
  lp = & logroot;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! *lp) {
#line 195
      goto while_break;
    }
#line 196
    if (*lp == l) {
#line 197
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  lp = & (*lp)->next;
#line 199
  if (! *lp) {
#line 200
    return (- 1);
  }
#line 202
  (l->opencount) --;
#line 202
  if (l->opencount > 0) {
#line 203
    return (0);
  }
#line 204
  if (l->opencount < 0) {
    {
#line 205
    abort();
    }
  }
  {
#line 207
  *lp = l->next;
#line 208
  fclose(l->fp);
#line 209
  free((void *)l->name);
#line 210
  free((void *)((char *)l));
  }
#line 211
  return (0);
}
}
#line 219 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
int logfwrite(struct logfile *l , char *buf , int n ) 
{ 
  int r ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
  {
#line 222
  __cil_tmp6 = fileno(l->fp);
#line 222
  __cil_tmp7 = lf_reopen_fn(l->name, __cil_tmp6, l);
  }
  {
#line 222
  __cil_tmp5 = stolen_logfile(l);
  }
#line 222
  if (__cil_tmp5) {
#line 222
    if (__cil_tmp7) {
#line 223
      return (- 1);
    }
  }
  {
#line 224
  __cil_tmp8 = fwrite((void const   *)buf, (unsigned long )n, (unsigned long )1, l->fp);
#line 224
  r = (int )__cil_tmp8;
#line 225
  l->writecount += l->flushcount + 1;
#line 226
  l->flushcount = 0;
#line 227
  changed_logfile(l);
  }
#line 228
  return (r);
}
}
#line 231 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/logfile.c"
int logfflush(struct logfile *l ) 
{ 
  int r ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 232
  r = 0;
#line 234
  if (! l) {
#line 235
    l = logroot;
    {
#line 235
    while (1) {
      while_continue: /* CIL Label */ ;
#line 235
      if (! l) {
#line 235
        goto while_break;
      }
      {
#line 236
      __cil_tmp4 = fileno(l->fp);
#line 236
      __cil_tmp5 = lf_reopen_fn(l->name, __cil_tmp4, l);
      }
      {
#line 236
      __cil_tmp3 = stolen_logfile(l);
      }
#line 236
      if (__cil_tmp3) {
#line 236
        if (__cil_tmp5) {
#line 237
          return (- 1);
        }
      }
      {
#line 238
      __cil_tmp6 = fflush(l->fp);
      }
      {
#line 238
      r |= __cil_tmp6;
#line 239
      (l->flushcount) ++;
#line 240
      changed_logfile(l);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 235
    l = l->next;
  } else {
    {
#line 243
    __cil_tmp9 = fileno(l->fp);
#line 243
    __cil_tmp10 = lf_reopen_fn(l->name, __cil_tmp9, l);
    }
    {
#line 243
    __cil_tmp8 = stolen_logfile(l);
    }
#line 243
    if (__cil_tmp8) {
#line 243
      if (__cil_tmp10) {
#line 244
        return (- 1);
      }
    }
    {
#line 245
    r = fflush(l->fp);
#line 246
    (l->flushcount) ++;
#line 247
    changed_logfile(l);
    }
  }
#line 249
  return (r);
}
}
#line 115 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 86 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
__inline extern void syslog(int __pri , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 200
__inline extern void vsyslog(int __pri , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/syslog.h"
extern void __syslog_chk(int __pri , int __flag , char const   *__fmt  , ...) ;
#line 29
__inline extern void syslog(int __pri , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/syslog.h"
__inline extern void syslog(int __pri , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_va_arg_pack();
#line 31
  __syslog_chk(__pri, 1, __fmt, __cil_tmp3);
  }
  return;
}
}
#line 40
extern void __vsyslog_chk(int __pri , int __flag , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 45
__inline extern void vsyslog(int __pri , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 45 "/usr/include/x86_64-linux-gnu/bits/syslog.h"
__inline extern void vsyslog(int __pri , char const   *__fmt , __gnuc_va_list __ap ) 
{ 


  {
  {
#line 47
  __vsyslog_chk(__pri, 1, __fmt, __ap);
  }
  return;
}
}
#line 1126 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt ) ;
#line 97 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.h"
int DefaultEsc ;
#line 97
int DefaultMetaEsc ;
#line 55 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void Finit(int i ) ;
#line 125
void FreePaster(struct paster *pa ) ;
#line 206
int FindCommnr(char const   *str ) ;
#line 219
int WindowByNoN(char *str ) ;
#line 402
int AclCheckPermCmd(struct acluser *u , int mode , struct comm *c ) ;
#line 403
int AclSetPerm(struct acluser *uu , struct acluser *u , char *mode , char *s ) ;
#line 404
int AclUmask(struct acluser *u , char *str , char **errp ) ;
#line 405
int UsersAcl(struct acluser *uu , int argc , char **argv ) ;
#line 406
void AclWinSwap(int a , int b ) ;
#line 407
int NewWindowAcl(struct win *w , struct acluser *u ) ;
#line 408
void FreeWindowAcl(struct win *w ) ;
#line 409
char *DoSu(struct acluser **up , char *name , char *pw1 , char *pw2 ) ;
#line 410
int AclLinkUser(char *from , char *to ) ;
#line 412
int UserFreeCopyBuffer(struct acluser *u ) ;
#line 413
struct acluser **FindUserPtr(char *name ) ;
#line 414
int UserAdd(char *name , char *pass , struct acluser **up ) ;
#line 415
int UserDel(char *name , struct acluser **up ) ;
#line 57 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
struct comm comms[190] ;
#line 59
char NullStr[] ;
#line 60
char SockPath[5632] ;
#line 62
struct acluser *users ;
#line 65 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int maxusercount  =    0;
#line 68
static AclBits userbits ;
#line 74 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
static char default_w_bit[3]  = {      (char )1,      (char )1,      (char )1};
#line 81 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
static char default_c_bit[1]  = {      (char )0};
#line 93
static int GrowBitfield(AclBits *bfp , int len , int delta , int defaultbit ) ;
#line 94
static struct aclusergroup **FindGroupPtr(struct aclusergroup **gp , struct acluser *u ,
                                          int recursive ) ;
#line 95
static int AclSetPermCmd(struct acluser *u , char *mode , struct comm *cmd ) ;
#line 96
static int AclSetPermWin(struct acluser *uu , struct acluser *u , char *mode , struct win *win ) ;
#line 97
static int UserAcl(struct acluser *uu , struct acluser **u , int argc , char **argv ) ;
#line 98
static int UserAclCopy(struct acluser **to_up , struct acluser **from_up ) ;
#line 102 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
static int GrowBitfield(AclBits *bfp , int len , int delta , int defaultbit ) 
{ 
  AclBits n ;
  AclBits o ;
  int i ;
  void *__cil_tmp8 ;

  {
  {
#line 106
  o = *bfp;
#line 109
  __cil_tmp8 = calloc((unsigned long )1, (unsigned long )(& *((char *)0 + (((len + delta) + 1) >> 3))));
#line 109
  n = (AclBits )__cil_tmp8;
  }
#line 109
  if (! n) {
#line 110
    return (- 1);
  }
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < len + delta)) {
#line 111
      goto while_break;
    }
#line 113
    if (i < len) {
#line 113
      if ((128 >> (i & 7)) & (int )*(o + (i >> 3))) {
#line 115
        *(n + (i >> 3)) |= 128 >> (i & 7);
      } else {
#line 113
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 113
    if (i >= len) {
#line 113
      if (defaultbit) {
#line 115
        *(n + (i >> 3)) |= 128 >> (i & 7);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  i ++;
#line 117
  if (len) {
    {
#line 118
    free((void *)((char *)o));
    }
  }
#line 119
  *bfp = n;
#line 120
  return (0);
}
}
#line 130 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
struct acluser **FindUserPtr(char *name ) 
{ 
  struct acluser **u ;
  int __cil_tmp3 ;

  {
#line 135
  u = & users;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! *u) {
#line 135
      goto while_break;
    }
    {
#line 136
    __cil_tmp3 = strcmp((char const   *)((char *)(*u)->u_name), (char const   *)name);
    }
#line 136
    if (! __cil_tmp3) {
#line 137
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  u = & (*u)->u_next;
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 144
  return (u);
}
}
#line 147 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int DefaultEsc  =    - 1;
#line 148 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int DefaultMetaEsc  =    - 1;
#line 156 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int UserAdd(char *name , char *pass , struct acluser **up ) 
{ 
  int j ;
  int __cil_tmp7 ;
  void *__cil_tmp8 ;
  int j___70 ;
  struct win *w ;
  struct acluser *u ;
  int __cil_tmp14 ;
  int i ;
  int __cil_tmp16 ;
  int __cil_tmp19 ;
  int __cil_tmp21 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
#line 164
  if (! up) {
    {
#line 165
    up = FindUserPtr(name);
    }
  }
#line 166
  if (*up) {
#line 168
    if (pass) {
      {
#line 169
      (*up)->u_password = SaveStr((char const   *)pass);
      }
    }
#line 170
    return (1);
  }
  {
#line 172
  __cil_tmp7 = strcmp((char const   *)((char *)"none"), (char const   *)name);
  }
#line 172
  if (__cil_tmp7) {
    {
#line 173
    __cil_tmp8 = calloc((unsigned long )1, sizeof(struct acluser ));
#line 173
    *up = (struct acluser *)__cil_tmp8;
    }
  }
#line 174
  if (! *up) {
#line 175
    return (- 1);
  }
  {
#line 177
  (*up)->u_plop.buf = (char *)((void *)0);
#line 178
  (*up)->u_plop.len = 0;
#line 180
  (*up)->u_plop.enc = 0;
#line 183
  (*up)->u_Esc = DefaultEsc;
#line 184
  (*up)->u_MetaEsc = DefaultMetaEsc;
#line 185
  strncpy((char *)(*up)->u_name, (char const   *)name, (unsigned long )256);
#line 186
  (*up)->u_password = (char *)((void *)0);
  }
#line 187
  if (pass) {
    {
#line 188
    (*up)->u_password = SaveStr((char const   *)pass);
    }
  }
#line 189
  if (! (*up)->u_password) {
#line 190
    (*up)->u_password = (char *)NullStr;
  }
#line 191
  (*up)->u_detachwin = - 1;
#line 192
  (*up)->u_detachotherwin = - 1;
#line 195
  (*up)->u_group = (struct aclusergroup *)((void *)0);
#line 197
  (*up)->u_id = 0;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! ((*up)->u_id < maxusercount)) {
#line 197
      goto while_break;
    }
#line 198
    if (! ((128 >> ((*up)->u_id & 7)) & (int )*(userbits + ((*up)->u_id >> 3)))) {
#line 199
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  ((*up)->u_id) ++;
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 201
  if ((*up)->u_id == maxusercount) {
    {
#line 207
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 207
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 210
    __cil_tmp14 = GrowBitfield(& userbits, maxusercount, 8, 0);
    }
#line 210
    if (__cil_tmp14) {
      {
#line 212
      free((void *)((char *)*up));
#line 212
      *up = (struct acluser *)((void *)0);
      }
#line 212
      return (- 1);
    }
#line 225
    j___70 = 0;
    {
#line 225
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 225
      if (! (j___70 <= 189)) {
#line 225
        goto while_break___2;
      }
#line 229
      i = 0;
      {
#line 229
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 229
        if (! (i < 1)) {
#line 229
          goto while_break___3;
        }
        {
#line 230
        __cil_tmp16 = GrowBitfield(& comms[j___70].userbits[i], maxusercount, 8, (int )default_c_bit[i]);
        }
#line 230
        if (__cil_tmp16) {
          {
#line 233
          free((void *)((char *)*up));
#line 233
          *up = (struct acluser *)((void *)0);
          }
#line 233
          return (- 1);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 229
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 225
    j___70 ++;
#line 237
    u = users;
    {
#line 237
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 237
      if (! (u != *up)) {
#line 237
        goto while_break___4;
      }
#line 239
      j___70 = 0;
      {
#line 239
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 239
        if (! (j___70 < 3)) {
#line 239
          goto while_break___5;
        }
        {
#line 241
        __cil_tmp19 = GrowBitfield(& u->u_umask_w_bits[j___70], maxusercount, 8, (int )default_w_bit[j___70]);
        }
#line 241
        if (__cil_tmp19) {
          {
#line 244
          free((void *)((char *)*up));
#line 244
          *up = (struct acluser *)((void *)0);
          }
#line 244
          return (- 1);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 239
      j___70 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 237
    u = u->u_next;
#line 251
    w = windows;
    {
#line 251
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 251
      if (! w) {
#line 251
        goto while_break___6;
      }
#line 254
      j___70 = 0;
      {
#line 254
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 254
        if (! (j___70 < 3)) {
#line 254
          goto while_break___7;
        }
        {
#line 255
        __cil_tmp21 = GrowBitfield(& w->w_userbits[j___70], maxusercount, 8, (int )default_w_bit[j___70]);
        }
#line 255
        if (__cil_tmp21) {
          {
#line 258
          free((void *)((char *)*up));
#line 258
          *up = (struct acluser *)((void *)0);
          }
#line 258
          return (- 1);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 254
      j___70 ++;
#line 262
      __cil_tmp24 = GrowBitfield(& w->w_lio_notify, maxusercount, 8, 0);
      }
      {
#line 262
      __cil_tmp23 = GrowBitfield(& w->w_mon_notify, maxusercount, 8, 0);
      }
#line 262
      if (__cil_tmp23) {
        {
        {
#line 265
        free((void *)((char *)*up));
        }
#line 265
        *up = (struct acluser *)((void *)0);
        }
#line 265
        return (- 1);
      } else
#line 262
      if (__cil_tmp24) {
        {
        {
#line 265
        free((void *)((char *)*up));
        }
#line 265
        *up = (struct acluser *)((void *)0);
        }
#line 265
        return (- 1);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 251
    w = w->w_next;
#line 268
    maxusercount += 8;
  }
#line 272
  *(userbits + ((*up)->u_id >> 3)) |= 128 >> ((*up)->u_id & 7);
#line 275
  if ((*up)->u_id == 0) {
    {
#line 276
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+a", (char *)"#?");
    }
  }
  {
#line 279
  __cil_tmp25 = strcmp((char const   *)((char *)(*up)->u_name), (char const   *)((char *)"nobody"));
  }
#line 279
  if (! __cil_tmp25) {
    {
#line 281
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"-rwx", (char *)"#?");
#line 282
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"su");
#line 283
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"detach");
#line 284
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"displays");
#line 285
    AclSetPerm((struct acluser *)((void *)0), *up, (char *)"+x", (char *)"version");
    }
  }
#line 293
  j = 0;
  {
#line 293
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 293
    if (! (j < 3)) {
#line 293
      goto while_break___8;
    }
    {
#line 295
    __cil_tmp26 = GrowBitfield(& (*up)->u_umask_w_bits[j], 0, maxusercount, (int )default_w_bit[j]);
    }
#line 295
    if (__cil_tmp26) {
      {
#line 298
      free((void *)((char *)*up));
#line 298
      *up = (struct acluser *)((void *)0);
      }
#line 298
      return (- 1);
    }
#line 300
    *((*up)->u_umask_w_bits[j] + ((*up)->u_id >> 3)) |= 128 >> ((*up)->u_id & 7);
  }
  while_break___8: /* CIL Label */ ;
  }
#line 293
  j ++;
#line 305
  return (0);
}
}
#line 332 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int UserDel(char *name , struct acluser **up ) 
{ 
  struct acluser *u ;
  int i ;
  struct display *old ;
  struct display *next ;
  struct aclusergroup **g ;
  struct aclusergroup *next___71 ;
  char *tmp ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;

  {
#line 342
  if (! up) {
    {
#line 343
    up = FindUserPtr(name);
    }
  }
#line 344
  u = *up;
#line 344
  if (! u) {
#line 345
    return (- 1);
  }
#line 346
  old = display;
#line 347
  display = displays;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! display) {
#line 347
      goto while_break;
    }
#line 349
    next = display->d_next;
#line 350
    if (display->d_user != u) {
#line 351
      goto while_continue;
    }
#line 352
    if (display == old) {
#line 353
      old = (struct display *)((void *)0);
    }
    {
#line 354
    Detach(2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  display = next;
#line 356
  display = old;
#line 357
  *up = u->u_next;
#line 360
  up = & users;
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 360
    if (! *up) {
#line 360
      goto while_break___0;
    }
#line 363
    g = & (*up)->u_group;
    {
#line 365
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 365
      if (! *g) {
#line 365
        goto while_break___1;
      }
#line 367
      if ((*g)->u == u) {
        {
#line 369
        next___71 = (*g)->next;
#line 371
        free((void *)((char *)*g));
#line 372
        *g = next___71;
        }
      } else {
#line 375
        g = & (*g)->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 360
  up = & (*up)->u_next;
#line 378
  *(userbits + (u->u_id >> 3)) &= ~ (128 >> (u->u_id & 7));
#line 380
  if ((int )default_w_bit[2]) {
#line 380
    tmp = (char *)"+r";
  } else {
#line 380
    tmp = (char *)"-r";
  }
  {
#line 380
  AclSetPerm((struct acluser *)((void *)0), u, tmp, (char *)"#");
  }
#line 381
  if ((int )default_w_bit[1]) {
#line 381
    tmp___72 = (char *)"+w";
  } else {
#line 381
    tmp___72 = (char *)"-w";
  }
  {
#line 381
  AclSetPerm((struct acluser *)((void *)0), u, tmp___72, (char *)"#");
  }
#line 382
  if ((int )default_w_bit[0]) {
#line 382
    tmp___73 = (char *)"+x";
  } else {
#line 382
    tmp___73 = (char *)"-x";
  }
  {
#line 382
  AclSetPerm((struct acluser *)((void *)0), u, tmp___73, (char *)"#");
  }
#line 383
  if ((int )default_c_bit[0]) {
#line 383
    tmp___74 = (char *)"+x";
  } else {
#line 383
    tmp___74 = (char *)"-x";
  }
  {
#line 383
  AclSetPerm((struct acluser *)((void *)0), u, tmp___74, (char *)"?");
#line 384
  i = 0;
  }
  {
#line 384
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 384
    if (! (i < 3)) {
#line 384
      goto while_break___2;
    }
    {
#line 385
    free((void *)((char *)u->u_umask_w_bits[i]));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 384
  i ++;
  {
#line 387
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 387
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 389
  UserFreeCopyBuffer(u);
#line 391
  free((void *)((char *)u));
  }
#line 392
  if (! users) {
    {
#line 394
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 394
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 395
    Finit(0);
    }
  }
#line 397
  return (0);
}
}
#line 408 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int UserFreeCopyBuffer(struct acluser *u ) 
{ 
  struct win *w ;
  struct paster *pa ;

  {
#line 414
  if (! u->u_plop.buf) {
#line 415
    return (1);
  }
#line 416
  w = windows;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! w) {
#line 416
      goto while_break;
    }
#line 418
    pa = & w->w_paster;
#line 419
    if (pa->pa_pasteptr >= u->u_plop.buf) {
#line 419
      if (pa->pa_pasteptr - u->u_plop.buf < (long )u->u_plop.len) {
        {
#line 421
        FreePaster(pa);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 416
  w = w->w_next;
#line 423
  free((void *)u->u_plop.buf);
#line 424
  u->u_plop.len = 0;
#line 425
  u->u_plop.buf = (char *)0;
  }
#line 426
  return (0);
}
}
#line 438 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
static struct aclusergroup **FindGroupPtr(struct aclusergroup **gp , struct acluser *u ,
                                          int recursive ) 
{ 
  struct aclusergroup **g ;

  {
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 446
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 446
    if (! *gp) {
#line 446
      goto while_break___0;
    }
#line 448
    if ((*gp)->u == u) {
#line 449
      return (gp);
    }
    {
#line 450
    g = FindGroupPtr(& ((*gp)->u)->u_group, u, recursive + 1);
    }
#line 450
    if (recursive) {
#line 450
      if (*g) {
#line 452
        return (g);
      }
    }
#line 453
    gp = & (*gp)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 455
  return (gp);
}
}
#line 459 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
static int PasswordMatches(char const   *pw , char const   *password ) 
{ 
  char *buf ;
  char *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 462
  if (! ((char )*password)) {
#line 463
    return (0);
  }
  {
#line 464
  __cil_tmp4 = crypt((char const   *)((char *)pw), (char const   *)((char *)password));
#line 464
  buf = __cil_tmp4;
#line 465
  __cil_tmp5 = strcmp((char const   *)buf, password);
  }
#line 465
  return (buf && ! __cil_tmp5);
}
}
#line 474 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int AclLinkUser(char *from , char *to ) 
{ 
  struct acluser **u1 ;
  struct acluser **u2 ;
  struct aclusergroup **g ;
  int __cil_tmp7 ;
  int __cil_tmp9 ;
  struct aclusergroup **__cil_tmp10 ;
  void *__cil_tmp12 ;

  {
  {
#line 480
  __cil_tmp7 = UserAdd(from, (char *)((void *)0), u1);
  }
  {
#line 480
  u1 = FindUserPtr(from);
  }
#line 480
  if (! *u1) {
#line 480
    if (__cil_tmp7) {
#line 481
      return (- 1);
    }
  }
  {
#line 482
  __cil_tmp9 = UserAdd(to, (char *)((void *)0), u2);
  }
  {
#line 482
  u2 = FindUserPtr(to);
  }
#line 482
  if (! *u2) {
#line 482
    if (__cil_tmp9) {
#line 483
      return (- 1);
    }
  }
  {
#line 485
  __cil_tmp10 = FindGroupPtr(& (*u2)->u_group, *u1, 1);
  }
#line 485
  if (*__cil_tmp10) {
#line 486
    return (1);
  }
  {
#line 487
  g = FindGroupPtr(& (*u1)->u_group, *u2, 0);
  }
#line 487
  if (*g) {
#line 488
    return (2);
  }
  {
#line 490
  __cil_tmp12 = malloc(sizeof(struct aclusergroup ));
#line 490
  *g = (struct aclusergroup *)__cil_tmp12;
  }
#line 490
  if (! *g) {
#line 491
    return (- 1);
  }
#line 492
  (*g)->u = *u2;
#line 493
  (*g)->next = (struct aclusergroup *)((void *)0);
#line 494
  return (0);
}
}
#line 503 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
char *DoSu(struct acluser **up , char *name , char *pw1 , char *pw2 ) 
{ 
  struct acluser *u ;
  int sorry ;
  struct passwd *pp ;
  struct spwd *ss ;
  int t ;
  int c ;
  char *pass ;
  int __cil_tmp19 ;
  int __cil_tmp22 ;
  char *tmp ;

  {
  {
#line 508
  sorry = 0;
#line 510
  u = (struct acluser *)FindUserPtr(name);
  }
#line 510
  if (! u) {
#line 511
    sorry ++;
  } else {
    {
#line 520
    pass = (char *)"";
#line 522
    pp = getpwnam((char const   *)name);
    }
#line 522
    if (! pp) {
      {
#line 524
      while (1) {
        while_continue: /* CIL Label */ ;
#line 524
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 525
      if (! ((pw1 && (int )*pw1) && (int )*pw1 != 4294967295U)) {
        {
#line 527
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 527
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 528
        sorry ++;
      }
    } else {
#line 532
      pass = pp->pw_passwd;
    }
#line 534
    t = 0;
    {
#line 534
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 534
      if (! (t < 13)) {
#line 534
        goto while_break___1;
      }
#line 536
      c = (int )*(pass + t);
#line 537
      if (! ((((c == 46 || c == 47) || (c >= 48 && c <= 57)) || (c >= 97 && c <= 122)) || (c >= 65 && c <= 90))) {
#line 541
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 534
    t ++;
#line 543
    if (t < 13) {
      {
#line 545
      ss = getspnam((char const   *)name);
      }
#line 545
      if (! ss) {
        {
#line 547
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 547
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 548
        sorry ++;
      } else {
#line 551
        pass = ss->sp_pwdp;
      }
    }
#line 555
    if (pw2) {
#line 555
      if ((int )*pw2) {
#line 555
        if ((int )*pw2 != 4294967295U) {
          {
#line 557
          __cil_tmp19 = PasswordMatches((char const   *)pw2, (char const   *)pass);
          }
#line 557
          if (! __cil_tmp19) {
            {
#line 559
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 559
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 560
            sorry ++;
          }
        } else {
#line 555
          goto _L;
        }
      } else {
#line 555
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 564
    if (*pass) {
#line 565
      sorry ++;
    }
#line 567
    if (pw1) {
#line 567
      if ((int )*pw1) {
#line 567
        if ((int )*pw1 != 4294967295U) {
          {
#line 569
          __cil_tmp22 = PasswordMatches((char const   *)pw1, (char const   *)u->u_password);
          }
#line 569
          if (! __cil_tmp22) {
            {
#line 571
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 571
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 572
            sorry ++;
          }
        } else {
#line 567
          goto _L___76;
        }
      } else {
#line 567
        goto _L___76;
      }
    } else
    _L___76: /* CIL Label */ 
#line 576
    if (*(u->u_password)) {
#line 577
      sorry ++;
    }
  }
  {
#line 580
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 580
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 581
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 581
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 586
  openlog((char const   *)((char *)"screen"), 1, 4 << 3);
  }
#line 588
  if (sorry) {
#line 588
    tmp = (char *)"failed";
  } else {
#line 588
    tmp = (char *)"succeeded";
  }
  {
#line 588
  syslog(5, (char const   *)((char *)"%s: \"su %s\" %s for \"%s\""), (char *)SockPath,
         name, tmp, (char *)(*up)->u_name);
#line 590
  closelog();
  }
#line 595
  if (sorry) {
#line 596
    return ((char *)"Sorry.");
  } else {
#line 598
    *up = u;
  }
#line 599
  return ((char *)((void *)0));
}
}
#line 612 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int NewWindowAcl(struct win *w , struct acluser *u ) 
{ 
  int i ;
  int j ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 622
  __cil_tmp6 = GrowBitfield(& w->w_lio_notify, 0, maxusercount, 0);
  }
  {
#line 622
  __cil_tmp5 = GrowBitfield(& w->w_mon_notify, 0, maxusercount, 0);
  }
#line 622
  if (__cil_tmp5) {
#line 624
    return (- 1);
  } else
#line 622
  if (__cil_tmp6) {
#line 624
    return (- 1);
  }
#line 625
  j = 0;
  {
#line 625
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 625
    if (! (j < 3)) {
#line 625
      goto while_break___0;
    }
    {
#line 628
    __cil_tmp7 = GrowBitfield(& w->w_userbits[j], 0, maxusercount, 0);
    }
#line 628
    if (__cil_tmp7) {
      {
#line 630
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 630
        if (! (j >= 0)) {
#line 630
          goto while_break___1;
        }
        {
#line 631
        free((void *)((char *)w->w_userbits[j]));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 632
      free((void *)((char *)w->w_mon_notify));
#line 633
      free((void *)((char *)w->w_lio_notify));
      }
#line 634
      return (- 1);
    }
#line 636
    i = 0;
    {
#line 636
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 636
      if (! (i < maxusercount)) {
#line 636
        goto while_break___2;
      }
#line 637
      if (u) {
#line 637
        tmp = (128 >> (i & 7)) & (int )*(u->u_umask_w_bits[j] + (i >> 3));
      } else {
#line 637
        tmp = (int )default_w_bit[j];
      }
#line 637
      if (tmp) {
#line 639
        *(w->w_userbits[j] + (i >> 3)) |= 128 >> (i & 7);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 636
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 625
  j ++;
#line 641
  return (0);
}
}
#line 645 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
void FreeWindowAcl(struct win *w ) 
{ 
  int i ;

  {
#line 650
  i = 0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (i < 3)) {
#line 650
      goto while_break;
    }
    {
#line 651
    free((void *)((char *)w->w_userbits[i]));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 650
  i ++;
#line 652
  free((void *)((char *)w->w_mon_notify));
#line 653
  free((void *)((char *)w->w_lio_notify));
  }
  return;
}
}
#line 663 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
static int AclSetPermCmd(struct acluser *u , char *mode , struct comm *cmd ) 
{ 
  int neg ;
  char *m ;
  char *__cil_tmp6 ;

  {
#line 668
  neg = 0;
#line 669
  m = mode;
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 671
    if (! *m) {
#line 671
      goto while_break;
    }
#line 673
    __cil_tmp6 = m;
#line 673
    m ++;
    {
#line 675
    if ((int )*__cil_tmp6 == '-') {
#line 675
      goto case_45;
    }
#line 678
    if ((int )*__cil_tmp6 == '+') {
#line 678
      goto case_43;
    }
#line 683
    if ((int )*__cil_tmp6 == 'x') {
#line 683
      goto case_120;
    }
#line 683
    if ((int )*__cil_tmp6 == 'e') {
#line 683
      goto case_120;
    }
#line 683
    if ((int )*__cil_tmp6 == 'a') {
#line 683
      goto case_120;
    }
#line 691
    if ((int )*__cil_tmp6 == 'w') {
#line 691
      goto case_119;
    }
#line 691
    if ((int )*__cil_tmp6 == 'r') {
#line 691
      goto case_119;
    }
#line 693
    goto switch_default;
    case_45: /* CIL Label */ 
#line 676
    neg = 1;
#line 677
    goto while_continue;
    case_43: /* CIL Label */ 
#line 679
    neg = 0;
#line 680
    goto while_continue;
    case_120: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 685
    if (neg) {
#line 686
      *(cmd->userbits[0] + (u->u_id >> 3)) &= ~ (128 >> (u->u_id & 7));
    } else {
#line 688
      *(cmd->userbits[0] + (u->u_id >> 3)) |= 128 >> (u->u_id & 7);
    }
#line 689
    goto switch_break;
    case_119: /* CIL Label */ 
    case_114: /* CIL Label */ 
#line 692
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 694
    return (- 1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  return (0);
}
}
#line 708 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
static int AclSetPermWin(struct acluser *uu , struct acluser *u , char *mode , struct win *win ) 
{ 
  int neg ;
  int bit ;
  int bits ;
  AclBits *bitarray ;
  char *m ;
  char *__cil_tmp10 ;
  int tmp ;
  int tmp___0 ;

  {
#line 713
  neg = 0;
#line 716
  m = mode;
#line 718
  if (uu) {
    {
#line 720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 720
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 721
    bitarray = (AclBits *)uu->u_umask_w_bits;
  } else {
    {
#line 725
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 725
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 726
    bitarray = (AclBits *)win->w_userbits;
    {
#line 727
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 727
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 730
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 730
    if (! *m) {
#line 730
      goto while_break___2;
    }
#line 732
    __cil_tmp10 = m;
#line 732
    m ++;
    {
#line 734
    if ((int )*__cil_tmp10 == '-') {
#line 734
      goto case_45;
    }
#line 737
    if ((int )*__cil_tmp10 == '+') {
#line 737
      goto case_43;
    }
#line 740
    if ((int )*__cil_tmp10 == 'r') {
#line 740
      goto case_114;
    }
#line 743
    if ((int )*__cil_tmp10 == 'w') {
#line 743
      goto case_119;
    }
#line 746
    if ((int )*__cil_tmp10 == 'x') {
#line 746
      goto case_120;
    }
#line 749
    if ((int )*__cil_tmp10 == 'a') {
#line 749
      goto case_97;
    }
#line 752
    goto switch_default;
    case_45: /* CIL Label */ 
#line 735
    neg = 1;
#line 736
    goto while_continue___2;
    case_43: /* CIL Label */ 
#line 738
    neg = 0;
#line 739
    goto while_continue___2;
    case_114: /* CIL Label */ 
#line 741
    bits = 1 << 2;
#line 742
    goto switch_break;
    case_119: /* CIL Label */ 
#line 744
    bits = 1 << 1;
#line 745
    goto switch_break;
    case_120: /* CIL Label */ 
#line 747
    bits = 1;
#line 748
    goto switch_break;
    case_97: /* CIL Label */ 
#line 750
    bits = (1 << 3) - 1;
#line 751
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 753
    return (- 1);
    switch_break: /* CIL Label */ ;
    }
#line 755
    bit = 0;
    {
#line 755
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 755
      if (! (bit < 3)) {
#line 755
        goto while_break___3;
      }
#line 757
      if (! (bits & (1 << bit))) {
#line 758
        goto while_continue___3;
      }
#line 759
      if (neg) {
#line 760
        *(*(bitarray + bit) + (u->u_id >> 3)) &= ~ (128 >> (u->u_id & 7));
      } else {
#line 762
        *(*(bitarray + bit) + (u->u_id >> 3)) |= 128 >> (u->u_id & 7);
      }
#line 763
      if (! uu) {
#line 763
        if (win->w_wlockuser == u) {
#line 763
          if (neg) {
#line 763
            if (bit == 1) {
              {
#line 765
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 765
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 766
              win->w_wlockuser = (struct acluser *)((void *)0);
#line 767
              if (win->w_wlock == 2) {
#line 768
                win->w_wlock = 1;
              }
            }
          }
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 755
    bit ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 772
  if (uu) {
#line 772
    if ((int )u->u_name[0] == 63) {
#line 772
      if ((int )u->u_name[1] == 0) {
#line 778
        if (win) {
          {
#line 780
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 780
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 781
          bit = 0;
          {
#line 781
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 781
            if (! (bit < 3)) {
#line 781
              goto while_break___6;
            }
#line 782
            if ((int )*(*(bitarray + bit) + (u->u_id >> 3)) & (128 >> (u->u_id & 7))) {
#line 782
              tmp = 1;
            } else {
#line 782
              tmp = 0;
            }
#line 782
            default_w_bit[bit] = (char )tmp;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 781
          bit ++;
        } else {
          {
#line 792
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 792
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 793
          bit = 0;
          {
#line 793
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 793
            if (! (bit < 1)) {
#line 793
              goto while_break___8;
            }
#line 794
            if ((int )*(*(bitarray + bit) + (u->u_id >> 3)) & (128 >> (u->u_id & 7))) {
#line 794
              tmp___0 = 1;
            } else {
#line 794
              tmp___0 = 0;
            }
#line 794
            default_c_bit[bit] = (char )tmp___0;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 793
          bit ++;
        }
        {
#line 797
        UserDel((char *)u->u_name, (struct acluser **)((void *)0));
        }
      }
    }
  }
#line 799
  return (0);
}
}
#line 808 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int AclSetPerm(struct acluser *uu , struct acluser *u , char *mode , char *s ) 
{ 
  struct win *w ;
  int i ;
  char *p ;
  char ch ;
  int __cil_tmp9 ;
  char *__cil_tmp14 ;

  {
  {
#line 816
  while (1) {
    while_continue: /* CIL Label */ ;
#line 816
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 818
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 818
    if (! *s) {
#line 818
      goto while_break___0;
    }
    {
#line 822
    if ((int )*s == '*') {
#line 822
      goto case_42;
    }
#line 824
    if ((int )*s == '#') {
#line 824
      goto case_35;
    }
#line 832
    if ((int )*s == '?') {
#line 832
      goto case_63;
    }
#line 840
    goto switch_default;
    case_42: /* CIL Label */ 
    {
#line 823
    __cil_tmp9 = AclSetPerm(uu, u, mode, (char *)"#?");
    }
#line 823
    return (__cil_tmp9);
    case_35: /* CIL Label */ 
#line 825
    if (uu) {
      {
#line 826
      AclSetPermWin(uu, u, mode, (struct win *)1);
      }
    } else {
#line 828
      w = windows;
      {
#line 828
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 828
        if (! w) {
#line 828
          goto while_break___1;
        }
        {
#line 829
        AclSetPermWin((struct acluser *)0, u, mode, w);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 828
      w = w->w_next;
    }
#line 830
    s ++;
#line 831
    goto switch_break;
    case_63: /* CIL Label */ 
#line 833
    if (uu) {
      {
#line 834
      AclSetPermWin(uu, u, mode, (struct win *)0);
      }
    } else {
#line 836
      i = 0;
      {
#line 836
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 836
        if (! (i <= 189)) {
#line 836
          goto while_break___2;
        }
        {
#line 837
        AclSetPermCmd(u, mode, & comms[i]);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 836
      i ++;
    }
#line 838
    s ++;
#line 839
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 841
    p = s;
    {
#line 841
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 841
      if (! ((((int )*p && (int )*p != 32) && (int )*p != 9) && (int )*p != 44)) {
#line 841
        goto while_break___3;
      }

    }
    while_break___3: /* CIL Label */ ;
    }
#line 841
    p ++;
#line 843
    ch = *p;
#line 843
    if (ch) {
#line 844
      __cil_tmp14 = p;
#line 844
      p ++;
#line 844
      *__cil_tmp14 = (char )'\000';
    }
    {
#line 845
    i = FindCommnr((char const   *)s);
    }
#line 845
    if (i != -1) {
      {
#line 846
      AclSetPermCmd(u, mode, & comms[i]);
      }
    } else {
      {
#line 847
      i = WindowByNoN(s);
      }
#line 847
      if (i >= 0) {
#line 847
        if (*(wtab + i)) {
          {
#line 848
          AclSetPermWin((struct acluser *)0, u, mode, *(wtab + i));
          }
        } else {
#line 851
          return (- 1);
        }
      } else {
#line 851
        return (- 1);
      }
    }
#line 852
    if (ch) {
#line 853
      *(p + - 1) = ch;
    }
#line 854
    s = p;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 857
  return (0);
}
}
#line 872 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
static int UserAcl(struct acluser *uu , struct acluser **u , int argc , char **argv ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 877
  __cil_tmp6 = strcmp((char const   *)*(argv + 0), (char const   *)((char *)"nobody"));
  }
  {
#line 877
  __cil_tmp5 = strcmp((char const   *)((char *)(*u)->u_name), (char const   *)((char *)"nobody"));
  }
#line 877
  if (*u) {
#line 877
    if (! __cil_tmp5) {
#line 879
      return (- 1);
    } else {
#line 877
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 877
  if (argc > 1) {
#line 877
    if (! __cil_tmp6) {
#line 879
      return (- 1);
    }
  }
  {
#line 883
  if (argc == 4) {
#line 883
    goto case_4;
  }
#line 887
  if (argc == 3) {
#line 887
    goto case_3;
  }
#line 891
  if (argc == 2) {
#line 891
    goto case_2;
  }
#line 894
  if (argc == 1) {
#line 894
    goto case_1;
  }
#line 898
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 884
  while (1) {
    while_continue: /* CIL Label */ ;
#line 884
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 885
  __cil_tmp8 = AclSetPerm(uu, *u, *(argv + 2), *(argv + 3));
  }
  {
#line 885
  __cil_tmp7 = UserAdd(*(argv + 0), *(argv + 1), u);
  }
#line 885
  return (__cil_tmp7 < 0 || __cil_tmp8);
  case_3: /* CIL Label */ 
  {
#line 888
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 888
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 889
  __cil_tmp10 = AclSetPerm(uu, *u, *(argv + 1), *(argv + 2));
  }
  {
#line 889
  __cil_tmp9 = UserAdd(*(argv + 0), (char *)((void *)0), u);
  }
#line 889
  return (__cil_tmp9 < 0 || __cil_tmp10);
  case_2: /* CIL Label */ 
  {
#line 892
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 892
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 893
  __cil_tmp11 = UserAdd(*(argv + 0), *(argv + 1), u);
  }
#line 893
  return (__cil_tmp11 < 0);
  case_1: /* CIL Label */ 
  {
#line 895
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 895
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 896
  __cil_tmp13 = AclSetPerm(uu, *u, (char *)"+a", (char *)"#?");
  }
  {
#line 896
  __cil_tmp12 = UserAdd(*(argv + 0), (char *)((void *)0), u);
  }
#line 896
  return (__cil_tmp12 < 0 || __cil_tmp13);
  switch_default: /* CIL Label */ 
#line 899
  return (- 1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 904 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
static int UserAclCopy(struct acluser **to_up , struct acluser **from_up ) 
{ 
  struct win *w ;
  int i ;
  int j ;
  int to_id ;
  int from_id ;

  {
#line 910
  if (! *to_up) {
#line 911
    return (- 1);
  } else
#line 910
  if (! *from_up) {
#line 911
    return (- 1);
  }
  {
#line 912
  while (1) {
    while_continue: /* CIL Label */ ;
#line 912
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 914
  from_id = (*from_up)->u_id;
#line 914
  to_id = (*to_up)->u_id;
#line 914
  if (to_id == from_id) {
#line 915
    return (- 1);
  }
#line 916
  w = windows;
  {
#line 916
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 916
    if (! w) {
#line 916
      goto while_break___0;
    }
#line 918
    i = 0;
    {
#line 918
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 918
      if (! (i < 3)) {
#line 918
        goto while_break___1;
      }
#line 920
      if ((int )*(w->w_userbits[i] + (from_id >> 3)) & (128 >> (from_id & 7))) {
#line 921
        *(w->w_userbits[i] + (to_id >> 3)) |= 128 >> (to_id & 7);
      } else {
#line 924
        *(w->w_userbits[i] + (to_id >> 3)) &= ~ (128 >> (to_id & 7));
#line 925
        if (w->w_wlockuser == *to_up) {
#line 925
          if (i == 1) {
            {
#line 927
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 927
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 929
            w->w_wlockuser = (struct acluser *)((void *)0);
#line 930
            if (w->w_wlock == 2) {
#line 931
              w->w_wlock = 1;
            }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 918
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 916
  w = w->w_next;
#line 936
  j = 0;
  {
#line 936
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 936
    if (! (j <= 189)) {
#line 936
      goto while_break___3;
    }
#line 938
    i = 0;
    {
#line 938
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 938
      if (! (i < 1)) {
#line 938
        goto while_break___4;
      }
#line 940
      if ((int )*(comms[j].userbits[i] + (from_id >> 3)) & (128 >> (from_id & 7))) {
#line 941
        *(comms[j].userbits[i] + (to_id >> 3)) |= 128 >> (to_id & 7);
      } else {
#line 943
        *(comms[j].userbits[i] + (to_id >> 3)) &= ~ (128 >> (to_id & 7));
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 938
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 936
  j ++;
#line 947
  return (0);
}
}
#line 959 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int UsersAcl(struct acluser *uu , int argc , char **argv ) 
{ 
  char *s ;
  int r ;
  struct acluser **cf_u ;
  char *p ;
  char *__cil_tmp8 ;
  struct acluser **u ;
  int __cil_tmp11 ;
  int tmp ;
  char *__cil_tmp16 ;
  int tmp___0 ;
  struct acluser **__cil_tmp18 ;
  int __cil_tmp19 ;
  struct acluser **__cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp___78 ;

  {
#line 966
  cf_u = (struct acluser **)((void *)0);
#line 968
  if (argc == 1) {
#line 970
    p = (char *)((void *)0);
#line 972
    s = *(argv + 0);
    {
#line 973
    while (1) {
      while_continue: /* CIL Label */ ;
#line 973
      if (! *s) {
#line 973
        goto while_break;
      }
#line 974
      __cil_tmp8 = s;
#line 974
      s ++;
#line 974
      if ((int )*__cil_tmp8 == 61) {
#line 974
        p = s;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 975
    if (p) {
      {
#line 977
      *(p + - 1) = (char )'\000';
#line 978
      cf_u = FindUserPtr(p);
      }
    }
  }
#line 982
  if ((int )*(*(argv + 0) + 0) == 42) {
#line 982
    if ((int )*(*(argv + 0) + 1) == 0) {
      {
#line 986
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 986
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 987
      u = & users;
      {
#line 987
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 987
        if (! *u) {
#line 987
          goto while_break___1;
        }
#line 988
        if (cf_u) {
          {
#line 988
          r = UserAclCopy(u, cf_u);
#line 988
          tmp = r < 0;
          }
        } else {
          {
#line 988
          r = UserAcl(uu, u, argc, argv);
#line 988
          tmp = r < 0;
          }
        }
        {
#line 988
        __cil_tmp11 = strcmp((char const   *)((char *)"nobody"), (char const   *)((char *)(*u)->u_name));
        }
#line 988
        if (__cil_tmp11) {
#line 988
          if (tmp) {
#line 992
            return (- 1);
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 987
      u = & (*u)->u_next;
#line 993
      return (0);
    }
  }
  {
#line 996
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 998
    s = *(argv + 0);
    {
#line 998
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 998
      if (! (((((int )*s && (int )*s != 32) && (int )*s != 9) && (int )*s != 44) && (int )*s != 61)) {
#line 998
        goto while_break___3;
      }

    }
    while_break___3: /* CIL Label */ ;
    }
#line 998
    s ++;
#line 1000
    if ((int )*s) {
#line 1000
      __cil_tmp16 = s;
#line 1000
      s ++;
#line 1000
      *__cil_tmp16 = (char )'\000';
#line 1000
      tmp___0 = (int )*__cil_tmp16;
    } else {
#line 1000
      *s = (char )'\000';
#line 1000
      tmp___0 = (int )*s;
    }
    {
#line 1001
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1001
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1002
    if (cf_u) {
      {
#line 1002
      __cil_tmp18 = FindUserPtr(*(argv + 0));
#line 1002
      __cil_tmp19 = UserAclCopy(__cil_tmp18, cf_u);
#line 1002
      r = __cil_tmp19;
#line 1002
      tmp___78 = r < 0;
      }
    } else {
      {
#line 1002
      __cil_tmp20 = FindUserPtr(*(argv + 0));
#line 1002
      __cil_tmp21 = UserAcl(uu, __cil_tmp20, argc, argv);
#line 1002
      r = __cil_tmp21;
#line 1002
      tmp___78 = r < 0;
      }
    }
#line 1002
    if (tmp___78) {
#line 1005
      return (- 1);
    }
#line 996
    if (! *(*(argv + 0))) {
#line 996
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1007
  return (0);
}
}
#line 1020 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int AclUmask(struct acluser *u , char *str , char **errp ) 
{ 
  char mode[16] ;
  char *av[3] ;
  char *p ;
  char c ;
  int __cil_tmp9 ;
  char *tmp ;
  int __cil_tmp12 ;

  {
#line 1027
  c = (char )'\000';
#line 1030
  p = str;
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! *p) {
#line 1030
      goto while_break;
    }
#line 1031
    c = *p;
#line 1031
    if ((int )c == 43) {
#line 1032
      goto while_break;
    } else
#line 1031
    if ((int )c == 45) {
#line 1032
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1030
  p ++;
#line 1033
  if (! *p) {
#line 1035
    *errp = (char *)"Bad argument. Should be ``[user[,user...]{+|-}rwxn\'\'.";
#line 1036
    return (- 1);
  }
  {
#line 1038
  strncpy((char *)mode, (char const   *)p, (unsigned long )15);
#line 1039
  mode[15] = (char )'\000';
#line 1040
  *p = (char )'\000';
#line 1043
  __cil_tmp9 = strcmp((char const   *)((char *)"??"), (char const   *)str);
  }
#line 1043
  if (! __cil_tmp9) {
#line 1045
    str ++;
#line 1046
    av[2] = (char *)"?";
  } else {
#line 1049
    av[2] = (char *)"#";
  }
#line 1050
  av[1] = (char *)mode;
#line 1051
  if ((int )*str) {
#line 1051
    tmp = str;
  } else {
#line 1051
    tmp = (char *)"*";
  }
  {
#line 1051
  av[0] = tmp;
#line 1053
  __cil_tmp12 = UsersAcl(u, 3, (char **)av);
  }
#line 1053
  if (__cil_tmp12) {
#line 1055
    *errp = (char *)"UsersAcl failed. Hmmm.";
#line 1056
    *p = c;
#line 1057
    return (- 1);
  }
#line 1059
  *p = c;
#line 1060
  return (0);
}
}
#line 1064 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
void AclWinSwap(int a , int b ) 
{ 


  {
  {
#line 1067
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1067
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1070 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
struct acluser *EffectiveAclUser  =    (struct acluser *)((void *)0);
#line 1073 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int AclCheckPermWin(struct acluser *u , int mode , struct win *w ) 
{ 
  int ok ;
  struct aclusergroup **g ;
  struct acluser *saved_eff ;
  int __cil_tmp7 ;

  {
#line 1080
  if (mode < 0) {
#line 1081
    return (- 1);
  } else
#line 1080
  if (mode >= 3) {
#line 1081
    return (- 1);
  }
#line 1082
  if (EffectiveAclUser) {
    {
#line 1084
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1084
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1085
    u = EffectiveAclUser;
  }
#line 1087
  ok = (int )*(w->w_userbits[mode] + (u->u_id >> 3)) & (128 >> (u->u_id & 7));
  {
#line 1088
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1088
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1090
  if (! ok) {
#line 1092
    g = & u->u_group;
#line 1093
    saved_eff = EffectiveAclUser;
#line 1095
    EffectiveAclUser = (struct acluser *)((void *)0);
    {
#line 1096
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1096
      if (! *g) {
#line 1096
        goto while_break___1;
      }
      {
#line 1098
      __cil_tmp7 = AclCheckPermWin((*g)->u, mode, w);
      }
#line 1098
      if (! __cil_tmp7) {
#line 1099
        goto while_break___1;
      }
#line 1100
      g = & (*g)->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1102
    EffectiveAclUser = saved_eff;
#line 1103
    if (*g) {
#line 1104
      ok = 1;
    }
  }
  {
#line 1106
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1106
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1107
  return (! ok);
}
}
#line 1111 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/acls.c"
int AclCheckPermCmd(struct acluser *u , int mode , struct comm *c ) 
{ 
  int ok ;
  struct aclusergroup **g ;
  struct acluser *saved_eff ;
  int __cil_tmp7 ;

  {
#line 1118
  if (mode < 0) {
#line 1119
    return (- 1);
  } else
#line 1118
  if (mode >= 1) {
#line 1119
    return (- 1);
  }
#line 1120
  if (EffectiveAclUser) {
    {
#line 1122
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1122
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1123
    u = EffectiveAclUser;
  }
#line 1125
  ok = (int )*(c->userbits[mode] + (u->u_id >> 3)) & (128 >> (u->u_id & 7));
  {
#line 1126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1126
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1127
  if (! ok) {
#line 1129
    g = & u->u_group;
#line 1130
    saved_eff = EffectiveAclUser;
#line 1132
    EffectiveAclUser = (struct acluser *)((void *)0);
    {
#line 1133
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1133
      if (! *g) {
#line 1133
        goto while_break___1;
      }
      {
#line 1135
      __cil_tmp7 = AclCheckPermCmd((*g)->u, mode, c);
      }
#line 1135
      if (! __cil_tmp7) {
#line 1136
        goto while_break___1;
      }
#line 1137
      g = & (*g)->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1139
    EffectiveAclUser = saved_eff;
#line 1140
    if (*g) {
#line 1141
      ok = 1;
    }
  }
  {
#line 1143
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1143
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1144
  return (! ok);
}
}
#line 9 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/kmapdef.c"
char *kmapdef[]  = 
#line 9 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/kmapdef.c"
  {      (char *)"\033[M",      (char *)"\033[10~",      (char *)"\033OP",      (char *)"\033OQ", 
        (char *)"\033OR",      (char *)"\033OS",      (char *)"\033[15~",      (char *)"\033[17~", 
        (char *)"\033[18~",      (char *)"\033[19~",      (char *)"\033[20~",      (char *)"\033[21~", 
        (char *)"\033[23~",      (char *)"\033[24~",      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)"\033[1~",      (char *)0,      (char *)"\033[4~",      (char *)"\033[4~", 
        (char *)"\033[6~",      (char *)"\033[5~",      (char *)"\033[2~",      (char *)"\033[3~", 
        (char *)"\033[A",      (char *)"\033[B",      (char *)"\033[C",      (char *)"\033[D", 
        (char *)"0",      (char *)"1",      (char *)"2",      (char *)"3", 
        (char *)"4",      (char *)"5",      (char *)"6",      (char *)"7", 
        (char *)"8",      (char *)"9",      (char *)"+",      (char *)"-", 
        (char *)"*",      (char *)"/",      (char *)"=",      (char *)".", 
        (char *)",",      (char *)"\r"};
#line 94 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/kmapdef.c"
char *kmapadef[]  = 
#line 94
  {      (char *)"\033OA",      (char *)"\033OB",      (char *)"\033OC",      (char *)"\033OD", 
        (char *)"\033Op",      (char *)"\033Oq",      (char *)"\033Or",      (char *)"\033Os", 
        (char *)"\033Ot",      (char *)"\033Ou",      (char *)"\033Ov",      (char *)"\033Ow", 
        (char *)"\033Ox",      (char *)"\033Oy",      (char *)"\033Ok",      (char *)"\033Om", 
        (char *)"\033Oj",      (char *)"\033Oo",      (char *)"\033OX",      (char *)"\033On", 
        (char *)"\033Ol",      (char *)"\033OM"};
#line 119 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/kmapdef.c"
char *kmapmdef[]  = 
#line 119
  {      (char *)"\222",      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)"\004",      (char *)0,      (char *)0, 
        (char *)"\025",      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)0,      (char *)0,      (char *)0,      (char *)0, 
        (char *)"\201",      (char *)0,      (char *)"\205",      (char *)"\205", 
        (char *)"\006",      (char *)"\002",      (char *)0,      (char *)0, 
        (char *)"\220",      (char *)"\216",      (char *)"\206",      (char *)"\202"};
#line 47 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/comm.c"
struct comm comms[190]  = 
#line 47 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/comm.c"
  {      {(char *)"acladd", ((1 | (1 << 2)) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"aclchg", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"acldel", 1, {(AclBits )0}}, 
        {(char *)"aclgrp", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"aclumask", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"activity", 1, {(AclBits )0}}, 
        {(char *)"addacl", ((1 | (1 << 2)) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"allpartial", (1 << 7) | 1, {(AclBits )0}}, 
        {(char *)"altscreen", 1 << 2, {(AclBits )0}}, 
        {(char *)"at", 2 | (1 << 5), {(AclBits )0}}, 
        {(char *)"attrcolor", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"autodetach", 1, {(AclBits )0}}, 
        {(char *)"autonuke", (1 << 7) | 1, {(AclBits )0}}, 
        {(char *)"backtick", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"bce", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"bell", 1 << 2, {(AclBits )0}}, 
        {(char *)"bell_msg", 1 << 2, {(AclBits )0}}, 
        {(char *)"bind", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"bindkey", 1 << 5, {(AclBits )0}}, 
        {(char *)"blanker", 1 << 7, {(AclBits )0}}, 
        {(char *)"blankerprg", 1 << 5, {(AclBits )0}}, 
        {(char *)"break", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"breaktype", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"bufferfile", 1 << 2, {(AclBits )0}}, 
        {(char *)"bumpleft", 1 << 6, {(AclBits )0}}, 
        {(char *)"bumpright", 1 << 6, {(AclBits )0}}, 
        {(char *)"c1", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"caption", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"chacl", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"charset", (1 << 6) | 1, {(AclBits )0}}, 
        {(char *)"chdir", 1 << 2, {(AclBits )0}}, 
        {(char *)"cjkwidth", 1 << 2, {(AclBits )0}}, 
        {(char *)"clear", 1 << 6, {(AclBits )0}}, 
        {(char *)"collapse", 0, {(AclBits )0}}, 
        {(char *)"colon", (1 << 8) | (1 << 2), {(AclBits )0}}, 
        {(char *)"command", (1 << 7) | (1 << 3), {(AclBits )0}}, 
        {(char *)"compacthist", 1 << 2, {(AclBits )0}}, 
        {(char *)"console", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"copy", (1 << 6) | (1 << 7), {(AclBits )0}}, 
        {(char *)"crlf", 1 << 2, {(AclBits )0}}, 
        {(char *)"debug", 1 << 2, {(AclBits )0}}, 
        {(char *)"defautonuke", 1, {(AclBits )0}}, 
        {(char *)"defbce", 1, {(AclBits )0}}, 
        {(char *)"defbreaktype", 1 << 2, {(AclBits )0}}, 
        {(char *)"defc1", 1, {(AclBits )0}}, 
        {(char *)"defcharset", 1 << 2, {(AclBits )0}}, 
        {(char *)"defdynamictitle", 1, {(AclBits )0}}, 
        {(char *)"defencoding", 1, {(AclBits )0}}, 
        {(char *)"defescape", 1, {(AclBits )0}}, 
        {(char *)"defflow", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"defgr", 1, {(AclBits )0}}, 
        {(char *)"defhstatus", 1 << 2, {(AclBits )0}}, 
        {(char *)"defkanji", 1, {(AclBits )0}}, 
        {(char *)"deflog", 1, {(AclBits )0}}, 
        {(char *)"deflogin", 1, {(AclBits )0}}, 
        {(char *)"defmode", 1, {(AclBits )0}}, 
        {(char *)"defmonitor", 1, {(AclBits )0}}, 
        {(char *)"defmousetrack", 1, {(AclBits )0}}, 
        {(char *)"defnonblock", 1, {(AclBits )0}}, 
        {(char *)"defobuflimit", 1, {(AclBits )0}}, 
        {(char *)"defscrollback", 1, {(AclBits )0}}, 
        {(char *)"defshell", 1, {(AclBits )0}}, 
        {(char *)"defsilence", 1, {(AclBits )0}}, 
        {(char *)"defslowpaste", 1, {(AclBits )0}}, 
        {(char *)"defutf8", 1, {(AclBits )0}}, 
        {(char *)"defwrap", 1, {(AclBits )0}}, 
        {(char *)"defwritelock", 1, {(AclBits )0}}, 
        {(char *)"detach", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"digraph", (1 << 8) | ((1 << 2) | (1 << 3)), {(AclBits )0}}, 
        {(char *)"dinfo", 1 << 7, {(AclBits )0}}, 
        {(char *)"displays", 1 << 8, {(AclBits )0}}, 
        {(char *)"dumptermcap", 1 << 6, {(AclBits )0}}, 
        {(char *)"dynamictitle", 1, {(AclBits )0}}, 
        {(char *)"echo", (1 << 9) | (1 | (1 << 2)), {(AclBits )0}}, 
        {(char *)"encoding", 1 | (1 << 2), {(AclBits )0}}, 
        {(char *)"escape", 1, {(AclBits )0}}, 
        {(char *)"eval", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"exec", 1 << 5, {(AclBits )0}}, 
        {(char *)"fit", 1 << 7, {(AclBits )0}}, 
        {(char *)"flow", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"focus", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"focusminsize", 1 << 3, {(AclBits )0}}, 
        {(char *)"gr", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"group", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"hardcopy", (1 << 6) | ((1 << 2) | (1 << 3)), {(AclBits )0}}, 
        {(char *)"hardcopy_append", 1, {(AclBits )0}}, 
        {(char *)"hardcopydir", 1 << 2, {(AclBits )0}}, 
        {(char *)"hardstatus", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"height", ((1 << 2) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"help", (1 << 8) | (1 << 3), {(AclBits )0}}, 
        {(char *)"history", (1 << 7) | (1 << 6), {(AclBits )0}}, 
        {(char *)"hstatus", (1 << 6) | 1, {(AclBits )0}}, 
        {(char *)"idle", 1 << 5, {(AclBits )0}}, 
        {(char *)"ignorecase", 1 << 2, {(AclBits )0}}, 
        {(char *)"info", (1 << 9) | (1 << 8), {(AclBits )0}}, 
        {(char *)"kanji", (1 << 6) | (1 | (1 << 2)), {(AclBits )0}}, 
        {(char *)"kill", 1 << 6, {(AclBits )0}}, 
        {(char *)"lastmsg", (1 << 9) | (1 << 7), {(AclBits )0}}, 
        {(char *)"layout", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"license", 1 << 8, {(AclBits )0}}, 
        {(char *)"lockscreen", 1 << 7, {(AclBits )0}}, 
        {(char *)"log", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"logfile", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"login", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"logtstamp", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"mapdefault", 1 << 7, {(AclBits )0}}, 
        {(char *)"mapnotnext", 1 << 7, {(AclBits )0}}, 
        {(char *)"maptimeout", 1 << 2, {(AclBits )0}}, 
        {(char *)"markkeys", 1, {(AclBits )0}}, 
        {(char *)"maxwin", 1 << 2, {(AclBits )0}}, 
        {(char *)"meta", 1 << 8, {(AclBits )0}}, 
        {(char *)"monitor", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"mousetrack", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"msgminwait", 1, {(AclBits )0}}, 
        {(char *)"msgwait", 1, {(AclBits )0}}, 
        {(char *)"multiuser", 1, {(AclBits )0}}, 
        {(char *)"nethack", 1, {(AclBits )0}}, 
        {(char *)"next", 0, {(AclBits )0}}, 
        {(char *)"nonblock", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"number", ((1 << 9) | (1 << 6)) | (1 << 2), {(AclBits )0}}, 
        {(char *)"obuflimit", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"only", 1 << 7, {(AclBits )0}}, 
        {(char *)"other", 0, {(AclBits )0}}, 
        {(char *)"partial", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"password", 1 << 2, {(AclBits )0}}, 
        {(char *)"paste", (1 << 8) | ((1 << 2) | (1 << 3)), {(AclBits )0}}, 
        {(char *)"pastefont", 1 << 2, {(AclBits )0}}, 
        {(char *)"pow_break", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"pow_detach", 1 << 7, {(AclBits )0}}, 
        {(char *)"pow_detach_msg", 1 << 2, {(AclBits )0}}, 
        {(char *)"prev", 0, {(AclBits )0}}, 
        {(char *)"printcmd", 1 << 2, {(AclBits )0}}, 
        {(char *)"process", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"quit", 0, {(AclBits )0}}, 
        {(char *)"readbuf", ((1 << 2) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"readreg", 1 << 5, {(AclBits )0}}, 
        {(char *)"redisplay", 1 << 7, {(AclBits )0}}, 
        {(char *)"register", 2 | (1 << 3), {(AclBits )0}}, 
        {(char *)"remove", 1 << 7, {(AclBits )0}}, 
        {(char *)"removebuf", 0, {(AclBits )0}}, 
        {(char *)"rendition", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"reset", 1 << 6, {(AclBits )0}}, 
        {(char *)"resize", (1 << 7) | (1 << 5), {(AclBits )0}}, 
        {(char *)"screen", 1 << 5, {(AclBits )0}}, 
        {(char *)"scrollback", (1 << 6) | 1, {(AclBits )0}}, 
        {(char *)"select", (1 << 9) | (1 << 2), {(AclBits )0}}, 
        {(char *)"sessionname", 1 << 2, {(AclBits )0}}, 
        {(char *)"setenv", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"setsid", 1, {(AclBits )0}}, 
        {(char *)"shell", 1, {(AclBits )0}}, 
        {(char *)"shelltitle", 1, {(AclBits )0}}, 
        {(char *)"silence", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"silencewait", 1, {(AclBits )0}}, 
        {(char *)"sleep", 1, {(AclBits )0}}, 
        {(char *)"slowpaste", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"sorendition", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"sort", 0, {(AclBits )0}}, 
        {(char *)"source", 1, {(AclBits )0}}, 
        {(char *)"split", (1 << 7) | (1 << 2), {(AclBits )0}}, 
        {(char *)"startup_message", 1, {(AclBits )0}}, 
        {(char *)"stuff", (1 << 8) | ((1 << 2) | (1 << 3)), {(AclBits )0}}, 
        {(char *)"su", (1 << 7) | ((1 << 2) | (1 << 3)), {(AclBits )0}}, 
        {(char *)"suspend", 1 << 7, {(AclBits )0}}, 
        {(char *)"term", 1, {(AclBits )0}}, 
        {(char *)"termcap", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"termcapinfo", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"terminfo", 2 | (1 << 2), {(AclBits )0}}, 
        {(char *)"time", (1 << 9) | (1 << 2), {(AclBits )0}}, 
        {(char *)"title", ((1 << 9) | (1 << 6)) | (1 << 2), {(AclBits )0}}, 
        {(char *)"umask", 1 | (1 << 5), {(AclBits )0}}, 
        {(char *)"unbindall", 0, {(AclBits )0}}, 
        {(char *)"unsetenv", 1, {(AclBits )0}}, 
        {(char *)"utf8", (1 << 6) | ((1 << 2) | (1 << 3)), {(AclBits )0}}, 
        {(char *)"vbell", 1 << 2, {(AclBits )0}}, 
        {(char *)"vbell_msg", 1 << 2, {(AclBits )0}}, 
        {(char *)"vbellwait", 1, {(AclBits )0}}, 
        {(char *)"verbose", 1 << 2, {(AclBits )0}}, 
        {(char *)"version", 0, {(AclBits )0}}, 
        {(char *)"wall", (1 << 7) | 1, {(AclBits )0}}, 
        {(char *)"width", ((1 << 2) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"windowlist", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"windows", (1 << 9) | (1 << 2), {(AclBits )0}}, 
        {(char *)"wrap", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"writebuf", ((1 << 2) | (1 << 3)) | (1 << 4), {(AclBits )0}}, 
        {(char *)"writelock", (1 << 6) | (1 << 2), {(AclBits )0}}, 
        {(char *)"xoff", 1 << 8, {(AclBits )0}}, 
        {(char *)"xon", 1 << 8, {(AclBits )0}}, 
        {(char *)"zmodem", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"zombie", (1 << 2) | (1 << 3), {(AclBits )0}}, 
        {(char *)"zombie_timeout", 1, {(AclBits )0}}};
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 369 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 447
extern unsigned int sleep(unsigned int __seconds ) ;
#line 593
extern  __attribute__((__nothrow__)) int execvpe(char const   *__file , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 703
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 720
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 759
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 48 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios *__termios_p ) ;
#line 90
extern  __attribute__((__nothrow__)) int tcflush(int __fd , int __queue_selector ) ;
#line 75 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/osdef.h"
extern void tputs(char * , int  , int (*)(int  ) ) ;
#line 76
extern char *tgoto(char * , int  , int  ) ;
#line 68 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/canvas.h"
void SetForeCanvas(struct display *d , struct canvas *cv ) ;
#line 354 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.h"
int OpenDevice(char **args , int lflag , int *typep , char **namep ) ;
#line 42 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void Hangup(void) ;
#line 43
void Kill(int pid , int sig ) ;
#line 94
void RunBlanker(char **cmdv ) ;
#line 101
void SetTTY(int fd , struct mode *mp ) ;
#line 110
int fgtty(int fd ) ;
#line 111
void brktty(int fd ) ;
#line 112
struct baud_values *lookup_baud(int baud ) ;
#line 163
void zmodem_abort(struct win *p , struct display *d ) ;
#line 196
void InitPTY(int f ) ;
#line 200
void ProcessInput(char *ibuf , int ilen ) ;
#line 202
void ProcessInput2(char *ibuf , int ilen ) ;
#line 225
void RefreshXtermOSC(void) ;
#line 233
int StuffKey(int i ) ;
#line 244
void FreeTransTable(void) ;
#line 253
struct display *MakeDisplay(char *uname , char *utty , char *term___0 , int fd , int pid ,
                            struct mode *Mode ) ;
#line 254
void FreeDisplay(void) ;
#line 255
void DefProcess(char **bufp , int *lenp ) ;
#line 256
void DefRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 258
int DefRewrite(int y , int xs , int xe , struct mchar *rend , int doit ) ;
#line 259
int DefResize(int wi , int he ) ;
#line 261
void AddCStr(char *s ) ;
#line 262
void AddCStr2(char *s , int c ) ;
#line 263
void InitTerm(int adapt ) ;
#line 264
void FinitTerm(void) ;
#line 265
void PUTCHAR(int c ) ;
#line 267
void ClearAll(void) ;
#line 270
void RefreshAll(int isblank ) ;
#line 273
void Redisplay(int cur_only ) ;
#line 274
void RedisplayDisplays(int cur_only ) ;
#line 275
void ShowHStatus(char *str ) ;
#line 276
void RefreshHStatus(void) ;
#line 279
int CalcCost(char *s ) ;
#line 285
void ChangeScrollRegion(int newtop , int newbot ) ;
#line 286
void InsertMode(int on ) ;
#line 289
void ReverseVideo(int on ) ;
#line 293
void SetFont(int new ) ;
#line 294
void SetAttr(int new ) ;
#line 295
void SetColor(int f , int b ) ;
#line 297
void SetRenditionMline(struct mline *ml , int x ) ;
#line 300
int ResizeDisplay(int wi , int he ) ;
#line 301
void AddStr(char *str ) ;
#line 302
void AddStrn(char *str , int n ) ;
#line 303
void Flush(int progress ) ;
#line 304
void freetty(void) ;
#line 307
void NukePending(void) ;
#line 310
void ClearAllXtermOSC(void) ;
#line 311
void SetXtermOSC(int i , char *s , char *t ) ;
#line 314
int color256to16(int jj ) ;
#line 319
void ResetIdle(void) ;
#line 320
void KillBlanker(void) ;
#line 321
void DisplaySleep1000(int n , int eat ) ;
#line 325
void ChangeScreenSize(int wi , int he , int change_fore ) ;
#line 326
void CheckScreenSize(int change_flag ) ;
#line 369
void closeallfiles(int except ) ;
#line 374
void (*xsignal(int sig , void (*func)(int  ) ))(int  ) ;
#line 386
void sleep1000(int msec ) ;
#line 49 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static int CountChars(int c ) ;
#line 50
static int DoAddChar(int c ) ;
#line 51
static int BlankResize(int wi , int he ) ;
#line 52
static int CallRewrite(int y , int xs , int xe , int doit ) ;
#line 53
static void disp_readev_fn(struct event *ev , char *data ) ;
#line 54
static void disp_processinput(struct display *display___0 , unsigned char *buf , int size ) ;
#line 55
static void disp_writeev_fn(struct event *ev , char *data ) ;
#line 57
static void disp_writeev_eagain(struct event *ev , char *data ) ;
#line 59
static void disp_status_fn(struct event *ev , char *data ) ;
#line 60
static void disp_hstatus_fn(struct event *ev , char *data ) ;
#line 61
static void disp_blocked_fn(struct event *ev , char *data ) ;
#line 63
static void disp_map_fn(struct event *ev , char *data ) ;
#line 65
static void disp_idle_fn(struct event *ev , char *data ) ;
#line 67
static void disp_blanker_fn(struct event *ev , char *data ) ;
#line 69
static void WriteLP(int x2 , int y2 ) ;
#line 70
static void INSERTCHAR(int c ) ;
#line 71
static void RAW_PUTCHAR(int c ) ;
#line 73
static void SetBackColor(int new ) ;
#line 75
static void RemoveStatusMinWait(void) ;
#line 82
int use_hardstatus ;
#line 83
int MsgWait ;
#line 83
int MsgMinWait ;
#line 84
int const   Z0width ;
#line 84
int const   Z1width ;
#line 86
struct mline mline_old ;
#line 87
struct mchar mchar_null ;
#line 88
struct NewWindow nwin_default ;
#line 89
struct action idleaction ;
#line 92
char *hstatusstring ;
#line 93
char *captionstring ;
#line 95
int pastefont ;
#line 96
int idletimo ;
#line 99
int pty_preopen ;
#line 101
struct winsize glwz ;
#line 103
char **NewEnv ;
#line 104
int real_uid ;
#line 104
int real_gid ;
#line 105
int ServerSocket ;
#line 105
int eff_uid ;
#line 105
int eff_gid ;
#line 114
extern short ospeed ;
#line 119
int attr2color[8][4] ;
#line 120
int nattr2color ;
#line 130 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
int defobuflimit  =    256;
#line 131 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
int defnonblock  =    - 1;
#line 132 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
int defmousetrack  =    0;
#line 134 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
int defautonuke  =    0;
#line 137 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
int hardstatusemu  =    0;
#line 146 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void DefProcess(char **bufp , int *lenp ) 
{ 


  {
#line 150
  *bufp += *lenp;
#line 151
  *lenp = 0;
  return;
}
}
#line 155 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void DefRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 


  {
#line 158
  if (isblank == 0) {
#line 158
    if (y >= 0) {
      {
#line 159
      DefClearLine(y, xs, xe, 0);
      }
    }
  }
  return;
}
}
#line 163 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void DefClearLine(int y , int xs , int xe , int bce ) 
{ 


  {
  {
#line 166
  LClearLine(flayer, y, xs, xe, bce, (struct mline *)0);
  }
  return;
}
}
#line 171 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
int DefRewrite(int y , int xs , int xe , struct mchar *rend , int doit ) 
{ 


  {
#line 175
  return (1000);
}
}
#line 180 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
int DefResize(int wi , int he ) 
{ 


  {
#line 183
  return (- 1);
}
}
#line 187 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void DefRestore(void) 
{ 
  struct display *olddisplay ;
  struct canvas *cv ;

  {
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    olddisplay = display;
#line 189
    display = displays;
    {
#line 189
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 189
      if (! display) {
#line 189
        goto while_break___0;
      }
#line 189
      cv = display->d_cvlist;
      {
#line 189
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 189
        if (! cv) {
#line 189
          goto while_break___1;
        }
#line 189
        if (cv->c_layer == flayer) {
#line 189
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 189
      cv = cv->c_next;
#line 189
      if (cv == (struct canvas *)0) {
#line 189
        goto while_continue___0;
      }
      {
#line 189
      InsertMode(0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 189
    display = display->d_next;
#line 189
    display = olddisplay;
#line 189
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  LKeypadMode(flayer, 0);
#line 192
  LCursorkeysMode(flayer, 0);
#line 193
  LCursorVisibility(flayer, 0);
#line 194
  LMouseMode(flayer, 0);
#line 195
  LSetRendition(flayer, & mchar_null);
#line 196
  LSetFlow(flayer, nwin_default.flowflag & 1);
  }
  return;
}
}
#line 203 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
struct LayFuncs BlankLf  = 
#line 203
     {DefProcess, (void (*)(void))0, DefRedisplayLine, DefClearLine, DefRewrite, BlankResize,
    DefRestore, (void (*)(void * ))0};
#line 217 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static int BlankResize(int wi , int he ) 
{ 


  {
#line 220
  flayer->l_width = wi;
#line 221
  flayer->l_height = he;
#line 222
  return (0);
}
}
#line 233 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
struct display *MakeDisplay(char *uname , char *utty , char *term___0 , int fd , int pid ,
                            struct mode *Mode ) 
{ 
  struct acluser **u ;
  struct baud_values *b ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  speed_t __cil_tmp12 ;
  struct baud_values *__cil_tmp13 ;

  {
  {
#line 241
  __cil_tmp10 = UserAdd(uname, (char *)0, u);
  }
  {
#line 241
  u = FindUserPtr(uname);
  }
#line 241
  if (! *u) {
#line 241
    if (__cil_tmp10) {
#line 242
      return ((struct display *)0);
    }
  }
  {
#line 245
  __cil_tmp11 = calloc((unsigned long )1, sizeof(*display));
#line 245
  display = (struct display *)__cil_tmp11;
  }
#line 245
  if (display == (struct display *)0) {
#line 246
    return ((struct display *)0);
  }
  {
#line 253
  display->d_next = displays;
#line 254
  displays = display;
#line 255
  display->d_flow = 1;
#line 256
  display->d_nonblock = defnonblock;
#line 257
  display->d_userfd = fd;
#line 258
  display->d_writeev.fd = fd;
#line 258
  display->d_readev.fd = display->d_writeev.fd;
#line 259
  display->d_readev.type = 1;
#line 260
  display->d_writeev.type = 2;
#line 261
  display->d_writeev.data = (char *)display;
#line 261
  display->d_readev.data = display->d_writeev.data;
#line 262
  display->d_readev.handler = disp_readev_fn;
#line 263
  display->d_writeev.handler = disp_writeev_fn;
#line 264
  evenq(& display->d_readev);
#line 265
  display->d_writeev.condpos = & display->d_obuflen;
#line 266
  display->d_writeev.condneg = & display->d_obuffree;
#line 267
  evenq(& display->d_writeev);
#line 268
  display->d_statusev.type = 0;
#line 269
  display->d_statusev.data = (char *)display;
#line 270
  display->d_statusev.handler = disp_status_fn;
#line 271
  display->d_hstatusev.type = 0;
#line 272
  display->d_hstatusev.data = (char *)display;
#line 273
  display->d_hstatusev.handler = disp_hstatus_fn;
#line 274
  display->d_blockedev.type = 0;
#line 275
  display->d_blockedev.data = (char *)display;
#line 276
  display->d_blockedev.handler = disp_blocked_fn;
#line 277
  display->d_blockedev.condpos = & display->d_obuffree;
#line 278
  display->d_blockedev.condneg = & display->d_obuflenmax;
#line 279
  display->d_hstatusev.handler = disp_hstatus_fn;
#line 281
  display->d_mapev.type = 0;
#line 282
  display->d_mapev.data = (char *)display;
#line 283
  display->d_mapev.handler = disp_map_fn;
#line 285
  display->d_idleev.type = 0;
#line 286
  display->d_idleev.data = (char *)display;
#line 287
  display->d_idleev.handler = disp_idle_fn;
#line 289
  display->d_blankerev.type = 1;
#line 290
  display->d_blankerev.data = (char *)display;
#line 291
  display->d_blankerev.handler = disp_blanker_fn;
#line 292
  display->d_blankerev.fd = - 1;
#line 294
  display->d_OldMode = *Mode;
#line 295
  display->d_status_obuffree = - 1;
#line 296
  Resize_obuf();
#line 297
  display->d_obufmax = defobuflimit;
#line 298
  display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
#line 300
  display->d_auto_nuke = defautonuke;
#line 302
  display->d_obufp = display->d_obuf;
#line 303
  display->d_printfd = - 1;
#line 304
  display->d_userpid = pid;
#line 307
  __cil_tmp12 = cfgetospeed(& display->d_OldMode.tio);
#line 307
  __cil_tmp13 = lookup_baud((int )__cil_tmp12);
#line 307
  b = __cil_tmp13;
  }
#line 307
  if (b) {
#line 308
    display->d_dospeed = (short )b->idx;
  }
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 319
  strncpy((char *)display->d_usertty, (char const   *)utty, sizeof(display->d_usertty) - 1UL);
#line 320
  display->d_usertty[sizeof(display->d_usertty) - 1UL] = (char )0;
#line 321
  strncpy((char *)display->d_termname, (char const   *)term___0, (unsigned long )32);
#line 322
  display->d_termname[32] = (char )0;
#line 323
  display->d_user = *u;
#line 324
  display->d_processinput = ProcessInput;
#line 325
  display->d_mousetrack = defmousetrack;
  }
#line 326
  return (display);
}
}
#line 331 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void FreeDisplay(void) 
{ 
  struct win *p ;
  struct display *d ;
  struct display **dp ;

  {
  {
#line 339
  FreeTransTable();
#line 342
  KillBlanker();
  }
#line 344
  if (display->d_userfd >= 0) {
    {
#line 346
    Flush(3);
    }
#line 347
    if (! display) {
#line 348
      return;
    }
    {
#line 349
    SetTTY(display->d_userfd, & display->d_OldMode);
#line 350
    fcntl(display->d_userfd, 4, 0);
    }
  }
  {
#line 352
  freetty();
  }
#line 353
  if (display->d_tentry) {
    {
#line 354
    free((void *)display->d_tentry);
    }
  }
#line 355
  display->d_tentry = (char *)0;
#line 356
  if (display->d_processinputdata) {
    {
#line 357
    free((void *)display->d_processinputdata);
    }
  }
  {
#line 358
  display->d_processinputdata = (char *)0;
#line 359
  display->d_tcinited = (char )0;
#line 360
  evdeq(& display->d_hstatusev);
#line 361
  evdeq(& display->d_statusev);
#line 362
  evdeq(& display->d_readev);
#line 363
  evdeq(& display->d_writeev);
#line 364
  evdeq(& display->d_blockedev);
#line 366
  evdeq(& display->d_mapev);
  }
#line 367
  if (display->d_kmaps) {
    {
#line 369
    free((void *)display->d_kmaps);
#line 370
    display->d_kmaps = (unsigned char *)0;
#line 371
    display->d_aseqs = 0;
#line 372
    display->d_nseqs = 0;
#line 373
    display->d_seqp = (unsigned char *)0;
#line 374
    display->d_seql = 0;
#line 375
    display->d_seqh = (unsigned char *)0;
    }
  }
  {
#line 378
  evdeq(& display->d_idleev);
#line 380
  evdeq(& display->d_blankerev);
#line 391
  dp = & displays;
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! d) {
#line 391
      goto while_break;
    }
#line 392
    if (d == display) {
#line 393
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  dp = & d->d_next;
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 394
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 395
  if (display->d_status_lastmsg) {
    {
#line 396
    free((void *)display->d_status_lastmsg);
    }
  }
#line 397
  if (display->d_obuf) {
    {
#line 398
    free((void *)display->d_obuf);
    }
  }
#line 399
  *dp = display->d_next;
  {
#line 406
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 406
    if (! display->d_canvas.c_slperp) {
#line 406
      goto while_break___1;
    }
    {
#line 407
    FreeCanvas(display->d_canvas.c_slperp);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 408
  display->d_cvlist = (struct canvas *)0;
#line 410
  p = windows;
  {
#line 410
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 410
    if (! p) {
#line 410
      goto while_break___2;
    }
#line 412
    if (p->w_pdisplay == display) {
#line 413
      p->w_pdisplay = (struct display *)0;
    }
#line 414
    if (p->w_lastdisp == display) {
#line 415
      p->w_lastdisp = (struct display *)0;
    }
#line 416
    if (p->w_readev.condneg == & display->d_status) {
#line 417
      p->w_readev.condneg = (int *)0;
#line 417
      p->w_readev.condpos = p->w_readev.condneg;
    } else
#line 416
    if (p->w_readev.condneg == & display->d_obuflenmax) {
#line 417
      p->w_readev.condneg = (int *)0;
#line 417
      p->w_readev.condpos = p->w_readev.condneg;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 410
  p = p->w_next;
#line 420
  p = windows;
  {
#line 420
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 420
    if (! p) {
#line 420
      goto while_break___3;
    }
#line 421
    if (p->w_zdisplay == display) {
      {
#line 422
      zmodem_abort(p, (struct display *)0);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 420
  p = p->w_next;
#line 424
  if (display->d_mousetrack) {
    {
#line 426
    display->d_mousetrack = 0;
#line 427
    MouseMode(0);
    }
  }
  {
#line 430
  free((void *)((char *)display));
#line 432
  display = (struct display *)0;
  }
  return;
}
}
#line 440 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void InitTerm(int adapt ) 
{ 
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 444
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 444
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 445
  display->d_bot = - 1;
#line 445
  display->d_top = display->d_bot;
#line 446
  AddCStr(display->d_tcs[39].str);
#line 447
  AddCStr(display->d_tcs[40].str);
#line 449
  __cil_tmp2 = strcmp((char const   *)display->d_tcs[27].str, (char const   *)display->d_tcs[28].str);
  }
#line 449
  if (display->d_tcs[27].str) {
#line 449
    if (__cil_tmp2) {
      {
#line 450
      AddCStr(display->d_tcs[28].str);
      }
    }
  }
  {
#line 451
  display->d_insert = 0;
#line 453
  AddCStr(display->d_tcs[69].str);
#line 454
  AddCStr(display->d_tcs[71].str);
#line 462
  display->d_keypad = 0;
#line 463
  display->d_cursorkeys = 0;
#line 464
  AddCStr(display->d_tcs[55].str);
#line 465
  AddCStr(display->d_tcs[104].str);
#line 466
  AddCStr(display->d_tcs[99].str);
#line 467
  display->d_rend = mchar_null;
#line 468
  display->d_atyp = (char )0;
  }
#line 469
  if (adapt == 0) {
    {
#line 470
    ResizeDisplay(display->d_defwidth, display->d_defheight);
    }
  }
  {
#line 471
  ChangeScrollRegion(0, display->d_height - 1);
#line 472
  display->d_y = 0;
#line 472
  display->d_x = display->d_y;
#line 473
  Flush(3);
#line 474
  ClearAll();
  }
  {
#line 475
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 475
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 478
  if (adapt) {
#line 478
    tmp = 2;
  } else {
#line 478
    tmp = 0;
  }
  {
#line 478
  CheckScreenSize(tmp);
  }
  return;
}
}
#line 482 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void FinitTerm(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 486
  KillBlanker();
  }
#line 488
  if (display->d_tcinited) {
    {
#line 490
    ResizeDisplay(display->d_defwidth, display->d_defheight);
#line 491
    InsertMode(0);
#line 492
    ChangeScrollRegion(0, display->d_height - 1);
#line 493
    KeypadMode(0);
#line 494
    CursorkeysMode(0);
#line 495
    CursorVisibility(0);
    }
#line 496
    if (display->d_mousetrack) {
#line 497
      display->d_mousetrack = 0;
    }
    {
#line 498
    MouseMode(0);
#line 499
    ExtMouseMode(0);
#line 500
    SetRendition(& mchar_null);
#line 501
    SetFlow(1);
#line 503
    AddCStr(display->d_tcs[70].str);
#line 504
    AddCStr(display->d_tcs[72].str);
    }
#line 506
    if (display->d_hstatus) {
      {
#line 507
      ShowHStatus((char *)0);
      }
    }
    {
#line 509
    ClearAllXtermOSC();
#line 511
    display->d_y = - 1;
#line 511
    display->d_x = display->d_y;
#line 512
    GotoPos(0, display->d_height - 1);
    }
    {
#line 513
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 513
      (display->d_obuffree) --;
#line 513
      if (display->d_obuffree <= 0) {
        {
#line 513
        Resize_obuf();
        }
      }
#line 513
      __cil_tmp1 = display->d_obufp;
#line 513
      (display->d_obufp) ++;
#line 513
      *__cil_tmp1 = (char )'\r';
#line 513
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 514
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 514
      (display->d_obuffree) --;
#line 514
      if (display->d_obuffree <= 0) {
        {
#line 514
        Resize_obuf();
        }
      }
#line 514
      __cil_tmp2 = display->d_obufp;
#line 514
      (display->d_obufp) ++;
#line 514
      *__cil_tmp2 = (char )'\n';
#line 514
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 515
    AddCStr(display->d_tcs[41].str);
    }
  }
  {
#line 517
  Flush(3);
  }
  return;
}
}
#line 522 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void INSERTCHAR(int c ) 
{ 


  {
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  if (! display->d_insert) {
#line 526
    if (display->d_x < display->d_width - 1) {
#line 528
      if (display->d_tcs[29].str) {
        _L: /* CIL Label */ 
#line 530
        if (display->d_tcs[29].str) {
          {
#line 531
          AddCStr(display->d_tcs[29].str);
          }
        } else {
          {
#line 533
          AddCStr2(display->d_tcs[30].str, 1);
          }
        }
        {
#line 534
        RAW_PUTCHAR(c);
        }
#line 535
        return;
      } else
#line 528
      if (display->d_tcs[30].str) {
#line 528
        goto _L;
      }
      {
#line 537
      InsertMode(1);
      }
#line 538
      if (! display->d_insert) {
        {
#line 540
        RefreshLine(display->d_y, display->d_x, display->d_width - 1, 0);
        }
#line 541
        return;
      }
    }
  }
  {
#line 544
  RAW_PUTCHAR(c);
  }
  return;
}
}
#line 548 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void PUTCHAR(int c ) 
{ 


  {
  {
#line 551
  while (1) {
    while_continue: /* CIL Label */ ;
#line 551
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 552
  if (display->d_insert) {
#line 552
    if (display->d_x < display->d_width - 1) {
      {
#line 553
      InsertMode(0);
      }
    }
  }
  {
#line 554
  RAW_PUTCHAR(c);
  }
  return;
}
}
#line 558 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void PUTCHARLP(int c ) 
{ 
  int y ;
  int __cil_tmp3 ;

  {
#line 561
  if (display->d_x < display->d_width - 1) {
#line 563
    if (display->d_insert) {
      {
#line 564
      InsertMode(0);
      }
    }
    {
#line 565
    RAW_PUTCHAR(c);
    }
#line 566
    return;
  }
#line 568
  if (display->d_tcs[87].flg) {
    _L: /* CIL Label */ 
    {
#line 570
    y = display->d_y;
#line 571
    RAW_PUTCHAR(c);
    }
#line 572
    if (display->d_tcs[83].flg) {
#line 572
      if (! display->d_tcs[87].flg) {
        {
#line 573
        GotoPos(display->d_width - 1, y);
        }
      }
    }
#line 574
    return;
  } else
#line 568
  if (display->d_y != display->d_bot) {
#line 568
    goto _L;
  }
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  display->d_lp_missing = 1;
#line 578
  display->d_rend.image = (unsigned char )c;
#line 579
  display->d_lpchar = display->d_rend;
#line 582
  if (display->d_mbcs) {
#line 584
    display->d_lpchar.mbcs = (unsigned char )c;
#line 585
    display->d_lpchar.image = (unsigned char )display->d_mbcs;
#line 586
    display->d_mbcs = 0;
#line 587
    __cil_tmp3 = display->d_x;
#line 587
    (display->d_x) --;
  }
  return;
}
}
#line 598 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void RAW_PUTCHAR(int c ) 
{ 
  int tmp ;
  int __cil_tmp3 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  int t ;
  int __cil_tmp9 ;
  int tmp___0 ;
  char *__cil_tmp12 ;
  int tmp___1 ;

  {
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  if (display->d_encoding == 8) {
#line 607
    c = ((c & 255) | ((int )display->d_rend.font << 8)) | ((int )display->d_rend.fontx << 16);
#line 609
    if (display->d_mbcs) {
#line 611
      c = display->d_mbcs;
#line 612
      if (display->d_x == display->d_width) {
#line 613
        if (display->d_tcs[83].flg) {
#line 613
          tmp = 1;
        } else {
#line 613
          tmp = - 1;
        }
#line 613
        display->d_x += tmp;
      }
#line 614
      display->d_mbcs = 0;
    } else {
      {
#line 616
      __cil_tmp3 = utf8_isdouble(c);
      }
#line 616
      if (__cil_tmp3) {
#line 618
        display->d_mbcs = c;
#line 619
        (display->d_x) ++;
#line 620
        return;
      }
    }
#line 623
    if (c < 32) {
      {
#line 625
      AddCStr2(display->d_tcs[98].str, '0');
      }
      {
#line 626
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 626
        (display->d_obuffree) --;
#line 626
        if (display->d_obuffree <= 0) {
          {
#line 626
          Resize_obuf();
          }
        }
#line 626
        __cil_tmp5 = display->d_obufp;
#line 626
        (display->d_obufp) ++;
#line 626
        *__cil_tmp5 = (char )(c + 95);
#line 626
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 627
      AddCStr(display->d_tcs[99].str);
      }
#line 628
      goto addedutf8;
    }
#line 630
    if (c < 128) {
#line 632
      if (display->d_xtable) {
#line 632
        if (*(display->d_xtable + (int )display->d_rend.font)) {
#line 632
          if (*(*(display->d_xtable + (int )display->d_rend.font) + (int )((unsigned char )c))) {
            {
#line 633
            AddStr(*(*(display->d_xtable + (int )display->d_rend.font) + (int )((unsigned char )c)));
            }
          } else {
#line 632
            goto _L;
          }
        } else {
#line 632
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 635
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 635
          (display->d_obuffree) --;
#line 635
          if (display->d_obuffree <= 0) {
            {
#line 635
            Resize_obuf();
            }
          }
#line 635
          __cil_tmp6 = display->d_obufp;
#line 635
          (display->d_obufp) ++;
#line 635
          *__cil_tmp6 = (char )c;
#line 635
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 638
      AddUtf8(c);
      }
    }
#line 639
    goto addedutf8;
  }
#line 643
  if ((int )display->d_rend.font) {
#line 643
    if (((int )display->d_rend.font & 96) == 0) {
#line 645
      t = c;
#line 646
      if (display->d_mbcs == 0) {
#line 648
        display->d_mbcs = c;
#line 649
        (display->d_x) ++;
#line 650
        return;
      }
#line 652
      __cil_tmp9 = display->d_x;
#line 652
      (display->d_x) --;
#line 653
      if (display->d_x == display->d_width - 1) {
#line 654
        if (display->d_tcs[83].flg) {
#line 654
          tmp___0 = 1;
        } else {
#line 654
          tmp___0 = - 1;
        }
#line 654
        display->d_x += tmp___0;
      }
#line 655
      c = display->d_mbcs;
#line 656
      display->d_mbcs = t;
    }
  }
#line 660
  if (display->d_encoding) {
    {
#line 661
    c = PrepareEncodedChar(c);
    }
  }
  kanjiloop: 
#line 666
  if (display->d_xtable) {
#line 666
    if (*(display->d_xtable + (int )display->d_rend.font)) {
#line 666
      if (*(*(display->d_xtable + (int )display->d_rend.font) + (int )((unsigned char )c))) {
        {
#line 667
        AddStr(*(*(display->d_xtable + (int )display->d_rend.font) + (int )((unsigned char )c)));
        }
      } else {
#line 666
        goto _L___80;
      }
    } else {
#line 666
      goto _L___80;
    }
  } else {
    _L___80: /* CIL Label */ 
    {
#line 669
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 669
      (display->d_obuffree) --;
#line 669
      if (display->d_obuffree <= 0) {
        {
#line 669
        Resize_obuf();
        }
      }
#line 669
      if ((int )display->d_rend.font != 48) {
#line 669
        tmp___1 = c;
      } else {
#line 669
        tmp___1 = (int )display->d_c0_tab[(int )((unsigned char )c)];
      }
#line 669
      __cil_tmp12 = display->d_obufp;
#line 669
      (display->d_obufp) ++;
#line 669
      *__cil_tmp12 = (char )tmp___1;
#line 669
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  addedutf8: 
#line 677
  (display->d_x) ++;
#line 677
  if (display->d_x >= display->d_width) {
#line 679
    if (display->d_tcs[83].flg == 0) {
#line 680
      display->d_x = display->d_width - 1;
    } else
#line 681
    if (! display->d_tcs[87].flg) {
      _L___82: /* CIL Label */ 
#line 683
      display->d_x -= display->d_width;
#line 684
      if (display->d_y < display->d_height - 1) {
#line 684
        if (display->d_y != display->d_bot) {
#line 685
          (display->d_y) ++;
        }
      }
    } else
#line 681
    if (display->d_x > display->d_width) {
#line 681
      goto _L___82;
    }
  }
#line 689
  if (display->d_mbcs) {
#line 691
    c = display->d_mbcs;
#line 692
    display->d_mbcs = 0;
#line 693
    goto kanjiloop;
  }
  return;
}
}
#line 699 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static int DoAddChar(int c ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    (display->d_obuffree) --;
#line 703
    if (display->d_obuffree <= 0) {
      {
#line 703
      Resize_obuf();
      }
    }
#line 703
    __cil_tmp2 = display->d_obufp;
#line 703
    (display->d_obufp) ++;
#line 703
    *__cil_tmp2 = (char )c;
#line 703
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  return (c);
}
}
#line 708 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void AddCStr(char *s ) 
{ 


  {
#line 711
  if (display) {
#line 711
    if (s) {
#line 711
      if ((int )*s) {
        {
#line 713
        ospeed = display->d_dospeed;
#line 714
        tputs(s, 1, DoAddChar);
        }
      }
    }
  }
  return;
}
}
#line 719 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void AddCStr2(char *s , int c ) 
{ 
  char *__cil_tmp3 ;

  {
#line 723
  if (display) {
#line 723
    if (s) {
#line 723
      if ((int )*s) {
        {
#line 725
        ospeed = display->d_dospeed;
#line 726
        __cil_tmp3 = tgoto(s, 0, c);
#line 726
        tputs(__cil_tmp3, 1, DoAddChar);
        }
      }
    }
  }
  return;
}
}
#line 734 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void InsertMode(int on ) 
{ 


  {
#line 737
  if (display) {
#line 737
    if (on != display->d_insert) {
#line 737
      if (display->d_tcs[27].str) {
#line 739
        display->d_insert = on;
#line 740
        if (on) {
          {
#line 741
          AddCStr(display->d_tcs[27].str);
          }
        } else {
          {
#line 743
          AddCStr(display->d_tcs[28].str);
          }
        }
      }
    }
  }
  return;
}
}
#line 750 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void KeypadMode(int on ) 
{ 


  {
#line 754
  if (display) {
#line 755
    display->d_keypad = on;
  }
  return;
}
}
#line 769 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void CursorkeysMode(int on ) 
{ 


  {
#line 773
  if (display) {
#line 774
    display->d_cursorkeys = on;
  }
  return;
}
}
#line 788 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ReverseVideo(int on ) 
{ 


  {
#line 791
  if (display) {
#line 791
    if (display->d_revvid != on) {
#line 791
      if (display->d_tcs[93].str) {
#line 793
        display->d_revvid = on;
#line 794
        if (display->d_revvid) {
          {
#line 795
          AddCStr(display->d_tcs[93].str);
          }
        } else {
          {
#line 797
          AddCStr(display->d_tcs[94].str);
          }
        }
      }
    }
  }
  return;
}
}
#line 802 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void CursorVisibility(int v ) 
{ 


  {
#line 805
  if (display) {
#line 805
    if (display->d_curvis != v) {
#line 807
      if (display->d_curvis) {
        {
#line 808
        AddCStr(display->d_tcs[82].str);
        }
      }
#line 809
      display->d_curvis = 0;
#line 810
      if (v == -1) {
#line 810
        if (display->d_tcs[80].str) {
          {
#line 811
          AddCStr(display->d_tcs[80].str);
          }
        } else {
#line 810
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 812
      if (v == 1) {
#line 812
        if (display->d_tcs[81].str) {
          {
#line 813
          AddCStr(display->d_tcs[81].str);
          }
        } else {
#line 815
          return;
        }
      } else {
#line 815
        return;
      }
#line 816
      display->d_curvis = v;
    }
  }
  return;
}
}
#line 821 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void MouseMode(int mode ) 
{ 
  char mousebuf[20] ;

  {
#line 824
  if (! display) {
#line 825
    return;
  }
#line 827
  if (mode < display->d_mousetrack) {
#line 828
    mode = display->d_mousetrack;
  }
#line 830
  if (display->d_mouse != mode) {
#line 833
    if (! display->d_tcs[96].flg) {
#line 834
      return;
    }
#line 835
    if (display->d_mouse) {
      {
#line 837
      sprintf((char *)mousebuf, (char const   *)((char *)"\033[?%dl"), display->d_mouse);
#line 838
      AddStr((char *)mousebuf);
      }
    }
#line 840
    if (mode) {
      {
#line 842
      sprintf((char *)mousebuf, (char const   *)((char *)"\033[?%dh"), mode);
#line 843
      AddStr((char *)mousebuf);
      }
    }
#line 845
    display->d_mouse = mode;
#line 846
    display->d_mouse_parse.state = (char )6;
  }
  return;
}
}
#line 851 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ExtMouseMode(int mode ) 
{ 
  char mousebuf[20] ;

  {
#line 854
  if (display) {
#line 854
    if (display->d_extmouse != mode) {
#line 857
      if (! display->d_tcs[96].flg) {
#line 858
        return;
      }
#line 859
      if (display->d_extmouse) {
        {
#line 861
        sprintf((char *)mousebuf, (char const   *)((char *)"\033[?%dl"), display->d_extmouse);
#line 862
        AddStr((char *)mousebuf);
        }
      }
#line 864
      if (mode) {
        {
#line 866
        sprintf((char *)mousebuf, (char const   *)((char *)"\033[?%dh"), mode);
#line 867
        AddStr((char *)mousebuf);
        }
      }
#line 869
      display->d_extmouse = mode;
#line 870
      display->d_mouse_parse.state = (char )6;
    }
  }
  return;
}
}
#line 874
static int StrCost ;
#line 878 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static int CountChars(int c ) 
{ 


  {
#line 881
  StrCost ++;
#line 882
  return (c);
}
}
#line 886 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
int CalcCost(char *s ) 
{ 


  {
  {
#line 889
  while (1) {
    while_continue: /* CIL Label */ ;
#line 889
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 890
  if (s) {
    {
#line 892
    StrCost = 0;
#line 893
    ospeed = display->d_dospeed;
#line 894
    tputs(s, 1, CountChars);
    }
#line 895
    return (StrCost);
  } else {
#line 898
    return (1000);
  }
}
}
#line 902 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static int CallRewrite(int y , int xs , int xe , int doit ) 
{ 
  struct canvas *cv ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  struct viewport *vp ;
  struct layer *oldflayer ;
  int cost ;

  {
  {
#line 910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 910
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 911
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 911
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 912
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 912
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 914
  vp = (struct viewport *)0;
#line 915
  cv = display->d_cvlist;
  {
#line 915
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 915
    if (! cv) {
#line 915
      goto while_break___2;
    }
#line 917
    if (y < cv->c_ys) {
#line 918
      goto while_continue___2;
    } else
#line 917
    if (y > cv->c_ye) {
#line 918
      goto while_continue___2;
    } else
#line 917
    if (xe < cv->c_xs) {
#line 918
      goto while_continue___2;
    } else
#line 917
    if (xs > cv->c_xe) {
#line 918
      goto while_continue___2;
    }
#line 919
    vp = cv->c_vplist;
    {
#line 919
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 919
      if (! vp) {
#line 919
        goto while_break___3;
      }
#line 920
      if (y >= vp->v_ys) {
#line 920
        if (y <= vp->v_ye) {
#line 920
          if (xe >= vp->v_xs) {
#line 920
            if (xs <= vp->v_xe) {
#line 921
              goto while_break___3;
            }
          }
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 919
    vp = vp->v_next;
#line 922
    if (vp) {
#line 923
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 915
  cv = cv->c_next;
#line 925
  if (doit) {
    {
#line 927
    oldflayer = flayer;
#line 928
    flayer = cv->c_layer;
#line 929
    cvlist = flayer->l_cvlist;
#line 930
    cvlnext = cv->c_lnext;
#line 931
    flayer->l_cvlist = cv;
#line 932
    cv->c_lnext = (struct canvas *)0;
#line 933
    (*((flayer->l_layfn)->lf_LayRewrite))(y - vp->v_yoff, xs - vp->v_xoff, xe - vp->v_xoff,
                                          & display->d_rend, 1);
#line 934
    flayer->l_cvlist = cvlist;
#line 935
    cv->c_lnext = cvlnext;
#line 936
    flayer = oldflayer;
    }
#line 937
    return (0);
  }
#line 939
  if (cv == (struct canvas *)0) {
#line 940
    return (1000);
  } else
#line 939
  if (cv->c_layer == (struct layer *)0) {
#line 940
    return (1000);
  }
#line 941
  if (xs < vp->v_xs) {
#line 942
    return (1000);
  } else
#line 941
  if (xe > vp->v_xe) {
#line 942
    return (1000);
  }
#line 943
  if (y - vp->v_yoff < 0) {
#line 944
    return (1000);
  } else
#line 943
  if (y - vp->v_yoff >= (cv->c_layer)->l_height) {
#line 944
    return (1000);
  }
#line 945
  if (xs - vp->v_xoff < 0) {
#line 946
    return (1000);
  } else
#line 945
  if (xe - vp->v_xoff >= (cv->c_layer)->l_width) {
#line 946
    return (1000);
  }
#line 948
  if (display->d_encoding == 8) {
#line 949
    display->d_rend.font = (unsigned char )0;
  }
#line 951
  oldflayer = flayer;
#line 952
  flayer = cv->c_layer;
  {
#line 953
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 953
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 954
  cost = (*((flayer->l_layfn)->lf_LayRewrite))(y - vp->v_yoff, xs - vp->v_xoff, xe - vp->v_xoff,
                                               & display->d_rend, 0);
#line 955
  flayer = oldflayer;
  }
#line 956
  if (display->d_insert) {
#line 957
    cost += display->d_EIcost + display->d_IMcost;
  }
#line 958
  return (cost);
}
}
#line 963 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void GotoPos(int x2 , int y2 ) 
{ 
  register int dy ;
  register int dx ;
  register int x1 ;
  register int y1 ;
  register int costx ;
  register int costy ;
  register int m ;
  register char *s ;
  int CMcost ;
  enum move_t xm ;
  enum move_t ym ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int tmp ;
  char *__cil_tmp26 ;
  int __cil_tmp27 ;
  int tmp___86 ;
  char *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  char *tmp___87 ;
  int __cil_tmp36 ;

  {
#line 971
  xm = (enum move_t )0;
#line 971
  ym = (enum move_t )0;
#line 973
  if (! display) {
#line 974
    return;
  }
#line 976
  x1 = display->d_x;
#line 977
  y1 = display->d_y;
#line 979
  if (x1 == display->d_width) {
#line 981
    if (display->d_tcs[87].flg) {
#line 981
      if (display->d_tcs[83].flg) {
#line 982
        x1 = - 1;
      } else {
#line 984
        __cil_tmp14 = x1;
#line 984
        x1 --;
      }
    } else {
#line 984
      __cil_tmp14 = x1;
#line 984
      x1 --;
    }
  }
#line 986
  if (x2 == display->d_width) {
#line 987
    __cil_tmp15 = x2;
#line 987
    x2 --;
  }
#line 988
  dx = x2 - x1;
#line 989
  dy = y2 - y1;
#line 990
  if (dy == 0) {
#line 990
    if (dx == 0) {
#line 991
      return;
    }
  }
  {
#line 992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 992
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 993
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 993
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 994
  if (! display->d_tcs[56].flg) {
    {
#line 995
    SetRendition(& mchar_null);
    }
  }
#line 996
  if (y1 < 0) {
    DoCM: 
#line 1001
    if (display->d_tcs[6].str) {
#line 1001
      if (! x2) {
#line 1001
        if (! y2) {
          {
#line 1002
          AddCStr(display->d_tcs[6].str);
          }
        } else {
          {
          {
          {
#line 1004
          __cil_tmp16 = tgoto(display->d_tcs[5].str, x2, y2);
          }
          }
          {
          {
#line 1004
          AddCStr(__cil_tmp16);
          }
          }
          }
        }
      } else {
        {
        {
        {
#line 1004
        __cil_tmp16 = tgoto(display->d_tcs[5].str, x2, y2);
        }
        }
        {
        {
#line 1004
        AddCStr(__cil_tmp16);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 1004
      __cil_tmp16 = tgoto(display->d_tcs[5].str, x2, y2);
      }
      }
      {
      {
#line 1004
      AddCStr(__cil_tmp16);
      }
      }
      }
    }
#line 1005
    display->d_x = x2;
#line 1006
    display->d_y = y2;
#line 1007
    return;
  } else
#line 996
  if (y2 > display->d_bot) {
#line 996
    if (y1 <= display->d_bot) {
#line 996
      goto DoCM;
    } else {
#line 996
      goto _L___84;
    }
  } else
  _L___84: /* CIL Label */ 
#line 996
  if (y2 < display->d_top) {
#line 996
    if (y1 >= display->d_top) {
#line 996
      goto DoCM;
    }
  }
#line 1013
  if (y1 > display->d_bot) {
#line 1013
    if (y2 > y1) {
#line 1014
      goto DoCM;
    } else {
#line 1013
      goto _L___85;
    }
  } else
  _L___85: /* CIL Label */ 
#line 1013
  if (y1 < display->d_top) {
#line 1013
    if (y2 < y1) {
#line 1014
      goto DoCM;
    }
  }
#line 1017
  if (display->d_tcs[6].str) {
#line 1017
    if (! x2) {
#line 1017
      if (! y2) {
#line 1018
        s = display->d_tcs[6].str;
      } else {
        {
        {
        {
#line 1020
        s = tgoto(display->d_tcs[5].str, x2, y2);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 1020
      s = tgoto(display->d_tcs[5].str, x2, y2);
      }
      }
      }
    }
  } else {
    {
    {
    {
#line 1020
    s = tgoto(display->d_tcs[5].str, x2, y2);
    }
    }
    }
  }
  {
#line 1021
  CMcost = CalcCost(s);
#line 1024
  costx = 1000;
  }
#line 1025
  if (x1 >= 0) {
#line 1027
    if (dx > 0) {
#line 1029
      if (display->d_tcs[17].str) {
#line 1029
        if (dx > 1) {
          {
          {
#line 1031
          __cil_tmp19 = tgoto(display->d_tcs[17].str, 0, dx);
          }
          {
#line 1031
          __cil_tmp20 = CalcCost(__cil_tmp19);
          }
#line 1031
          costx = __cil_tmp20;
#line 1032
          xm = (enum move_t )8;
          }
        } else
#line 1029
        if (! display->d_tcs[16].str) {
          {
          {
#line 1031
          __cil_tmp19 = tgoto(display->d_tcs[17].str, 0, dx);
          }
          {
#line 1031
          __cil_tmp20 = CalcCost(__cil_tmp19);
          }
#line 1031
          costx = __cil_tmp20;
#line 1032
          xm = (enum move_t )8;
          }
        }
      }
#line 1034
      m = display->d_NDcost * dx;
#line 1034
      if (m < costx) {
#line 1036
        costx = m;
#line 1037
        xm = (enum move_t )7;
      }
      {
#line 1040
      m = CallRewrite(y1, x1, x2 - 1, 0);
      }
#line 1040
      if (dx < costx) {
#line 1040
        if (m < costx) {
#line 1042
          costx = m;
#line 1043
          xm = (enum move_t )9;
        }
      }
    } else
#line 1046
    if (dx < 0) {
#line 1048
      if (display->d_tcs[15].str) {
#line 1048
        if (dx < -1) {
          {
          {
#line 1050
          __cil_tmp22 = tgoto(display->d_tcs[15].str, 0, - dx);
          }
          {
#line 1050
          __cil_tmp23 = CalcCost(__cil_tmp22);
          }
#line 1050
          costx = __cil_tmp23;
#line 1051
          xm = (enum move_t )6;
          }
        } else
#line 1048
        if (! display->d_tcs[13].str) {
          {
          {
#line 1050
          __cil_tmp22 = tgoto(display->d_tcs[15].str, 0, - dx);
          }
          {
#line 1050
          __cil_tmp23 = CalcCost(__cil_tmp22);
          }
#line 1050
          costx = __cil_tmp23;
#line 1051
          xm = (enum move_t )6;
          }
        }
      }
#line 1053
      m = - dx * display->d_LEcost;
#line 1053
      if (m < costx) {
#line 1055
        costx = m;
#line 1056
        xm = (enum move_t )5;
      }
    } else {
#line 1060
      costx = 0;
    }
  }
#line 1063
  if (x2) {
    {
#line 1063
    __cil_tmp24 = CallRewrite(y1, 0, x2 - 1, 0);
#line 1063
    tmp = __cil_tmp24;
    }
  } else {
#line 1063
    tmp = 0;
  }
#line 1063
  m = tmp + display->d_CRcost;
#line 1063
  if (x2 + display->d_CRcost < costx) {
#line 1063
    if (m < costx) {
#line 1065
      costx = m;
#line 1066
      xm = (enum move_t )10;
    }
  }
#line 1070
  if (costx >= CMcost) {
#line 1071
    goto DoCM;
  }
#line 1074
  costy = 1000;
#line 1075
  if (dy > 0) {
#line 1077
    if (display->d_tcs[11].str) {
#line 1077
      if (dy > 1) {
        {
#line 1079
        __cil_tmp26 = tgoto(display->d_tcs[11].str, 0, dy);
#line 1079
        __cil_tmp27 = CalcCost(__cil_tmp26);
#line 1079
        costy = __cil_tmp27;
#line 1080
        ym = (enum move_t )4;
        }
      }
    }
#line 1082
    if (x2 == 0) {
#line 1082
      tmp___86 = display->d_NLcost;
    } else {
#line 1082
      tmp___86 = display->d_DOcost;
    }
#line 1082
    m = dy * tmp___86;
#line 1082
    if (m < costy) {
#line 1084
      costy = m;
#line 1085
      ym = (enum move_t )3;
    }
  } else
#line 1088
  if (dy < 0) {
#line 1090
    if (display->d_tcs[9].str) {
#line 1090
      if (dy < -1) {
        {
        {
#line 1092
        __cil_tmp29 = tgoto(display->d_tcs[9].str, 0, - dy);
        }
        {
#line 1092
        __cil_tmp30 = CalcCost(__cil_tmp29);
        }
#line 1092
        costy = __cil_tmp30;
#line 1093
        ym = (enum move_t )2;
        }
      } else
#line 1090
      if (! display->d_tcs[8].str) {
        {
        {
#line 1092
        __cil_tmp29 = tgoto(display->d_tcs[9].str, 0, - dy);
        }
        {
#line 1092
        __cil_tmp30 = CalcCost(__cil_tmp29);
        }
#line 1092
        costy = __cil_tmp30;
#line 1093
        ym = (enum move_t )2;
        }
      }
    }
#line 1095
    m = - dy * display->d_UPcost;
#line 1095
    if (m < costy) {
#line 1097
      costy = m;
#line 1098
      ym = (enum move_t )1;
    }
  } else {
#line 1102
    costy = 0;
  }
#line 1105
  if (costx + costy >= CMcost) {
#line 1106
    goto DoCM;
  }
  {
#line 1110
  if ((unsigned int )xm == (unsigned int )5) {
#line 1110
    goto case_5;
  }
#line 1114
  if ((unsigned int )xm == (unsigned int )6) {
#line 1114
    goto case_6;
  }
#line 1117
  if ((unsigned int )xm == (unsigned int )7) {
#line 1117
    goto case_7;
  }
#line 1121
  if ((unsigned int )xm == (unsigned int )8) {
#line 1121
    goto case_8;
  }
#line 1124
  if ((unsigned int )xm == (unsigned int )10) {
#line 1124
    goto case_10;
  }
#line 1129
  if ((unsigned int )xm == (unsigned int )9) {
#line 1129
    goto case_9;
  }
#line 1133
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 1111
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1111
    if (! (__cil_tmp31 < 0)) {
#line 1111
      goto while_break___1;
    }
    {
#line 1112
    AddCStr(display->d_tcs[13].str);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1113
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1115
  AddCStr2(display->d_tcs[15].str, - dx);
  }
#line 1116
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1118
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1118
    if (! (__cil_tmp32 > 0)) {
#line 1118
      goto while_break___2;
    }
    {
#line 1119
    AddCStr(display->d_tcs[16].str);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1120
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1122
  AddCStr2(display->d_tcs[17].str, dx);
  }
#line 1123
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1125
  AddCStr(display->d_tcs[7].str);
  }
#line 1126
  display->d_x = 0;
#line 1127
  x1 = 0;
  case_9: /* CIL Label */ 
#line 1130
  if (x1 < x2) {
    {
#line 1131
    __cil_tmp33 = CallRewrite(y1, x1, x2 - 1, 1);
    }
  }
#line 1132
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1134
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1139
  if ((unsigned int )ym == (unsigned int )1) {
#line 1139
    goto case_1;
  }
#line 1143
  if ((unsigned int )ym == (unsigned int )2) {
#line 1143
    goto case_2;
  }
#line 1146
  if ((unsigned int )ym == (unsigned int )3) {
#line 1146
    goto case_3;
  }
#line 1151
  if ((unsigned int )ym == (unsigned int )4) {
#line 1151
    goto case_4;
  }
#line 1154
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 1140
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1140
    if (! (__cil_tmp34 < 0)) {
#line 1140
      goto while_break___3;
    }
    {
#line 1141
    AddCStr(display->d_tcs[8].str);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1142
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 1144
  AddCStr2(display->d_tcs[9].str, - dy);
  }
#line 1145
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 1147
  if (x2 == 0) {
#line 1147
    tmp___87 = display->d_tcs[19].str;
  } else {
#line 1147
    tmp___87 = display->d_tcs[10].str;
  }
#line 1147
  s = tmp___87;
  {
#line 1148
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1148
    if (! (__cil_tmp36 > 0)) {
#line 1148
      goto while_break___4;
    }
    {
#line 1149
    AddCStr(s);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1150
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 1152
  AddCStr2(display->d_tcs[11].str, dy);
  }
#line 1153
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1155
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1157
  display->d_x = x2;
#line 1158
  display->d_y = y2;
  return;
}
}
#line 1162 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ClearAll(void) 
{ 


  {
  {
#line 1164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1164
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1165
  ClearArea(0, 0, 0, display->d_width - 1, display->d_width - 1, display->d_height - 1,
            0, 0);
  }
  return;
}
}
#line 1169 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ClearArea(int x1 , int y1 , int xs , int xe , int x2 , int y2 , int bce , int uselayfn ) 
{ 
  int y ;
  int xxe ;
  struct canvas *cv ;
  struct viewport *vp ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  struct layer *oldflayer ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  int __cil_tmp18 ;

  {
  {
#line 1176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1176
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1177
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1177
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1178
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1178
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1179
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1179
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1180
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1180
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1181
  if (x1 == display->d_width) {
#line 1182
    __cil_tmp13 = x1;
#line 1182
    x1 --;
  }
#line 1183
  if (x2 == display->d_width) {
#line 1184
    __cil_tmp14 = x2;
#line 1184
    x2 --;
  }
#line 1185
  if (xs == -1) {
#line 1186
    xs = x1;
  }
#line 1187
  if (xe == -1) {
#line 1188
    xe = x2;
  }
#line 1189
  if (display->d_tcs[33].flg) {
    {
#line 1190
    SetRendition(& mchar_null);
    }
  }
#line 1192
  if (display->d_tcs[66].flg) {
    {
#line 1193
    SetBackColor(bce);
    }
  }
#line 1195
  if (display->d_lp_missing) {
#line 1195
    if (y1 <= display->d_bot) {
#line 1195
      if (xe >= display->d_width - 1) {
#line 1197
        if (y2 > display->d_bot) {
#line 1198
          display->d_lp_missing = 0;
        } else
#line 1197
        if (y2 == display->d_bot) {
#line 1197
          if (x2 >= display->d_width - 1) {
#line 1198
            display->d_lp_missing = 0;
          }
        }
      }
    }
  }
#line 1200
  if (x2 == display->d_width - 1) {
#line 1200
    if (xs == 0) {
      _L___88: /* CIL Label */ 
#line 1200
      if (xe == display->d_width - 1) {
#line 1200
        if (y2 == display->d_height - 1) {
#line 1200
          if (! bce) {
            _L: /* CIL Label */ 
#line 1203
            if (x1 == 0) {
#line 1203
              if (y1 == 0) {
#line 1203
                if (display->d_auto_nuke) {
                  {
#line 1204
                  NukePending();
                  }
                }
              }
            }
#line 1206
            if (x1 == 0) {
#line 1206
              if (y1 == 0) {
#line 1206
                if (display->d_tcs[34].str) {
                  {
#line 1208
                  AddCStr(display->d_tcs[34].str);
#line 1209
                  display->d_x = 0;
#line 1209
                  display->d_y = display->d_x;
                  }
#line 1210
                  return;
                }
              }
            }
#line 1216
            if (display->d_tcs[35].str) {
#line 1216
              if (y1 < y2) {
                {
                {
#line 1218
                GotoPos(x1, y1);
                }
                {
#line 1219
                AddCStr(display->d_tcs[35].str);
                }
                }
#line 1220
                return;
              } else
#line 1216
              if (! display->d_tcs[37].str) {
                {
                {
#line 1218
                GotoPos(x1, y1);
                }
                {
#line 1219
                AddCStr(display->d_tcs[35].str);
                }
                }
#line 1220
                return;
              }
            }
          } else
#line 1200
          if (display->d_tcs[66].flg) {
#line 1200
            goto _L;
          }
        }
      }
    } else
#line 1200
    if (y1 == y2) {
#line 1200
      goto _L___88;
    }
  }
#line 1223
  if (x1 == 0) {
#line 1223
    if (xs == 0) {
#line 1223
      if (xe == display->d_width - 1) {
        _L___89: /* CIL Label */ 
#line 1223
        if (y1 == 0) {
#line 1223
          if (display->d_tcs[36].str) {
#line 1223
            if (! bce) {
              {
              {
#line 1225
              GotoPos(x1, y1);
              }
              {
#line 1226
              AddCStr(display->d_tcs[36].str);
              }
              }
#line 1227
              return;
            } else
#line 1223
            if (display->d_tcs[66].flg) {
              {
              {
#line 1225
              GotoPos(x1, y1);
              }
              {
#line 1226
              AddCStr(display->d_tcs[36].str);
              }
              }
#line 1227
              return;
            }
          }
        }
      } else
#line 1223
      if (y1 == y2) {
#line 1223
        goto _L___89;
      }
    }
  }
#line 1229
  xxe = xe;
#line 1230
  y = y1;
  {
#line 1230
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1230
    if (! (y <= y2)) {
#line 1230
      goto while_break___4;
    }
#line 1232
    if (y == y2) {
#line 1233
      xxe = x2;
    }
#line 1234
    if (x1 == 0) {
#line 1234
      if (display->d_tcs[38].str) {
#line 1234
        if (xxe != display->d_width - 1) {
          _L___90: /* CIL Label */ 
#line 1234
          if (! bce) {
            {
            {
#line 1236
            GotoPos(xxe, y);
            }
            {
#line 1237
            AddCStr(display->d_tcs[38].str);
            }
            }
#line 1238
            goto while_continue___4;
          } else
#line 1234
          if (display->d_tcs[66].flg) {
            {
            {
#line 1236
            GotoPos(xxe, y);
            }
            {
#line 1237
            AddCStr(display->d_tcs[38].str);
            }
            }
#line 1238
            goto while_continue___4;
          }
        } else
#line 1234
        if (display->d_x == xxe) {
#line 1234
          if (display->d_y == y) {
#line 1234
            goto _L___90;
          }
        }
      }
    }
#line 1240
    if (xxe == display->d_width - 1) {
#line 1240
      if (display->d_tcs[37].str) {
#line 1240
        if (! bce) {
          {
          {
#line 1242
          GotoPos(x1, y);
          }
          {
#line 1243
          AddCStr(display->d_tcs[37].str);
          }
          }
#line 1244
          goto while_continue___4;
        } else
#line 1240
        if (display->d_tcs[66].flg) {
          {
          {
#line 1242
          GotoPos(x1, y);
          }
          {
#line 1243
          AddCStr(display->d_tcs[37].str);
          }
          }
#line 1244
          goto while_continue___4;
        }
      }
    }
#line 1246
    if (uselayfn) {
#line 1248
      vp = (struct viewport *)0;
#line 1249
      cv = display->d_cvlist;
      {
#line 1249
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1249
        if (! cv) {
#line 1249
          goto while_break___5;
        }
#line 1251
        if (y < cv->c_ys) {
#line 1252
          goto while_continue___5;
        } else
#line 1251
        if (y > cv->c_ye) {
#line 1252
          goto while_continue___5;
        } else
#line 1251
        if (xxe < cv->c_xs) {
#line 1252
          goto while_continue___5;
        } else
#line 1251
        if (x1 > cv->c_xe) {
#line 1252
          goto while_continue___5;
        }
#line 1253
        vp = cv->c_vplist;
        {
#line 1253
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1253
          if (! vp) {
#line 1253
            goto while_break___6;
          }
#line 1254
          if (y >= vp->v_ys) {
#line 1254
            if (y <= vp->v_ye) {
#line 1254
              if (xxe >= vp->v_xs) {
#line 1254
                if (x1 <= vp->v_xe) {
#line 1255
                  goto while_break___6;
                }
              }
            }
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1253
        vp = vp->v_next;
#line 1256
        if (vp) {
#line 1257
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1249
      cv = cv->c_next;
#line 1259
      if (cv) {
#line 1259
        if (cv->c_layer) {
#line 1259
          if (x1 >= vp->v_xs) {
#line 1259
            if (xxe <= vp->v_xe) {
#line 1259
              if (y - vp->v_yoff >= 0) {
#line 1259
                if (y - vp->v_yoff < (cv->c_layer)->l_height) {
#line 1259
                  if (xxe - vp->v_xoff >= 0) {
#line 1259
                    if (x1 - vp->v_xoff < (cv->c_layer)->l_width) {
                      {
#line 1263
                      oldflayer = flayer;
#line 1265
                      flayer = cv->c_layer;
#line 1266
                      cvlist = flayer->l_cvlist;
#line 1267
                      cvlnext = cv->c_lnext;
#line 1268
                      flayer->l_cvlist = cv;
#line 1269
                      cv->c_lnext = (struct canvas *)0;
#line 1270
                      (*((flayer->l_layfn)->lf_LayClearLine))(y - vp->v_yoff, x1 - vp->v_xoff,
                                                              xxe - vp->v_xoff, bce);
#line 1271
                      flayer->l_cvlist = cvlist;
#line 1272
                      cv->c_lnext = cvlnext;
#line 1273
                      flayer = oldflayer;
                      }
#line 1274
                      goto while_continue___4;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 1277
    ClearLine((struct mline *)0, y, x1, xxe, bce);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1230
  x1 = xs;
#line 1230
  __cil_tmp18 = y;
#line 1230
  y ++;
  return;
}
}
#line 1287 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void Redisplay(int cur_only ) 
{ 
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
  {
#line 1290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1290
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1293
  InsertMode(0);
#line 1294
  ChangeScrollRegion(0, display->d_height - 1);
#line 1295
  KeypadMode(0);
#line 1296
  CursorkeysMode(0);
#line 1297
  CursorVisibility(0);
#line 1298
  MouseMode(0);
#line 1299
  ExtMouseMode(0);
#line 1300
  SetRendition(& mchar_null);
#line 1301
  SetFlow(1);
#line 1303
  ClearAll();
#line 1305
  RefreshXtermOSC();
  }
#line 1307
  if (cur_only > 0) {
#line 1307
    if (display->d_fore) {
      {
#line 1308
      RefreshArea(0, (display->d_fore)->w_layer.l_y, display->d_width - 1, (display->d_fore)->w_layer.l_y,
                  1);
      }
    } else {
      {
      {
#line 1310
      RefreshAll(1);
      }
      }
    }
  } else {
    {
    {
#line 1310
    RefreshAll(1);
    }
    }
  }
  {
#line 1311
  RefreshHStatus();
#line 1312
  olddisplay = display;
#line 1312
  oldflayer = flayer;
#line 1312
  l = (display->d_forecv)->c_layer;
#line 1312
  cvlist = l->l_cvlist;
#line 1312
  cvlnext = (display->d_forecv)->c_lnext;
#line 1312
  flayer = l;
#line 1312
  l->l_cvlist = display->d_forecv;
#line 1312
  (display->d_forecv)->c_lnext = (struct canvas *)0;
#line 1312
  (*((flayer->l_layfn)->lf_LayRestore))();
#line 1312
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
#line 1312
  flayer = oldflayer;
#line 1312
  l->l_cvlist = cvlist;
#line 1312
  (display->d_forecv)->c_lnext = cvlnext;
#line 1312
  display = olddisplay;
  }
  return;
}
}
#line 1316 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void RedisplayDisplays(int cur_only ) 
{ 
  struct display *olddisplay ;

  {
#line 1319
  olddisplay = display;
#line 1320
  display = displays;
  {
#line 1320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1320
    if (! display) {
#line 1320
      goto while_break;
    }
    {
#line 1321
    Redisplay(cur_only);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1320
  display = display->d_next;
#line 1322
  display = olddisplay;
  return;
}
}
#line 1328 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ScrollH(int y , int xs , int xe , int n , int bce , struct mline *oml ) 
{ 
  int i ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1334
  if (n == 0) {
#line 1335
    return;
  }
#line 1336
  if (xe != display->d_width - 1) {
    {
#line 1338
    RefreshLine(y, xs, xe, 0);
    }
#line 1340
    return;
  }
  {
#line 1342
  GotoPos(xs, y);
  }
#line 1343
  if (display->d_tcs[33].flg) {
    {
#line 1344
    SetRendition(& mchar_null);
    }
  }
#line 1346
  if (display->d_tcs[66].flg) {
    {
#line 1347
    SetBackColor(bce);
    }
  }
#line 1349
  if (n > 0) {
#line 1351
    if (n >= (xe - xs) + 1) {
#line 1352
      n = (xe - xs) + 1;
    }
#line 1353
    if (display->d_tcs[32].str) {
#line 1353
      if (! (n == 1 && display->d_tcs[31].str)) {
        {
#line 1354
        AddCStr2(display->d_tcs[32].str, n);
        }
      } else {
#line 1353
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1355
    if (display->d_tcs[31].str) {
#line 1357
      i = n;
      {
#line 1357
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1357
        if (! __cil_tmp8) {
#line 1357
          goto while_break;
        }
        {
#line 1358
        AddCStr(display->d_tcs[31].str);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1362
      RefreshLine(y, xs, xe, 0);
      }
#line 1364
      return;
    }
  } else {
#line 1369
    if (- n >= (xe - xs) + 1) {
#line 1370
      n = - ((xe - xs) + 1);
    }
#line 1371
    if (! display->d_insert) {
#line 1373
      if (display->d_tcs[30].str) {
#line 1373
        if (! (n == -1 && display->d_tcs[29].str)) {
          {
#line 1374
          AddCStr2(display->d_tcs[30].str, - n);
          }
        } else {
#line 1373
          goto _L___91;
        }
      } else
      _L___91: /* CIL Label */ 
#line 1375
      if (display->d_tcs[29].str) {
#line 1377
        i = - n;
        {
#line 1377
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1377
          if (! __cil_tmp9) {
#line 1377
            goto while_break___0;
          }
          {
#line 1378
          AddCStr(display->d_tcs[29].str);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 1380
      if (display->d_tcs[27].str) {
        {
#line 1382
        InsertMode(1);
#line 1383
        SetRendition(& mchar_null);
#line 1385
        SetBackColor(bce);
#line 1387
        i = - n;
        }
        {
#line 1387
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1387
          if (! __cil_tmp10) {
#line 1387
            goto while_break___1;
          }
          {
#line 1388
          INSERTCHAR(' ');
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1389
        bce = 0;
      } else {
        {
#line 1394
        RefreshLine(y, xs, xe, 0);
        }
#line 1395
        return;
      }
    } else {
      {
#line 1400
      SetRendition(& mchar_null);
#line 1402
      SetBackColor(bce);
#line 1404
      i = - n;
      }
      {
#line 1404
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1404
        if (! __cil_tmp11) {
#line 1404
          goto while_break___2;
        }
        {
#line 1405
        INSERTCHAR(' ');
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1406
      bce = 0;
    }
  }
#line 1409
  if (bce) {
#line 1409
    if (! display->d_tcs[66].flg) {
#line 1411
      if (n > 0) {
        {
#line 1412
        ClearLine((struct mline *)0, y, (xe - n) + 1, xe, bce);
        }
      } else {
        {
#line 1414
        ClearLine((struct mline *)0, y, xs, (xs - n) - 1, bce);
        }
      }
    }
  }
#line 1416
  if (display->d_lp_missing) {
#line 1416
    if (y == display->d_bot) {
#line 1418
      if (n > 0) {
        {
#line 1419
        WriteLP((display->d_width - 1) - n, y);
        }
      }
#line 1420
      display->d_lp_missing = 0;
    }
  }
  return;
}
}
#line 1425 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ScrollV(int xs , int ys , int xe , int ye , int n , int bce ) 
{ 
  int i ;
  int up ;
  int oldbot ;
  int alok ;
  int dlok ;
  int aldlfaster ;
  int missy ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int __cil_tmp17 ;
  int tmp___0 ;
  int __cil_tmp19 ;

  {
#line 1432
  missy = 0;
  {
#line 1434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1434
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1435
  if (n == 0) {
#line 1436
    return;
  }
#line 1437
  if (n >= (ye - ys) + 1) {
    {
    {
#line 1439
    ClearArea(xs, ys, xs, xe, xe, ye, bce, 0);
    }
    }
#line 1440
    return;
  } else
#line 1437
  if (- n >= (ye - ys) + 1) {
    {
    {
#line 1439
    ClearArea(xs, ys, xs, xe, xe, ye, bce, 0);
    }
    }
#line 1440
    return;
  }
#line 1442
  if (xs > display->d_vpxmin) {
    {
    {
#line 1444
    RefreshArea(xs, ys, xe, ye, 0);
    }
    }
#line 1445
    return;
  } else
#line 1442
  if (xe < display->d_vpxmax) {
    {
    {
#line 1444
    RefreshArea(xs, ys, xe, ye, 0);
    }
    }
#line 1445
    return;
  }
#line 1448
  if (display->d_lp_missing) {
#line 1450
    if (display->d_bot > ye) {
#line 1451
      missy = display->d_bot;
    } else
#line 1450
    if (display->d_bot < ys) {
#line 1451
      missy = display->d_bot;
    } else {
#line 1454
      missy = display->d_bot - n;
#line 1455
      if (missy > ye) {
#line 1456
        display->d_lp_missing = 0;
      } else
#line 1455
      if (missy < ys) {
#line 1456
        display->d_lp_missing = 0;
      }
    }
  }
#line 1460
  up = 1;
#line 1461
  if (n < 0) {
#line 1463
    up = 0;
#line 1464
    n = - n;
  }
#line 1466
  if (n >= (ye - ys) + 1) {
#line 1467
    n = (ye - ys) + 1;
  }
#line 1469
  oldbot = display->d_bot;
#line 1470
  if (ys < display->d_top) {
    {
    {
#line 1471
    ChangeScrollRegion(ys, ye);
    }
    }
  } else
#line 1470
  if (display->d_bot != ye) {
    {
    {
#line 1471
    ChangeScrollRegion(ys, ye);
    }
    }
  }
#line 1472
  alok = (display->d_tcs[22].str || display->d_tcs[23].str) || ((ys >= display->d_top && ye == display->d_bot) && up);
#line 1473
  dlok = (display->d_tcs[24].str || display->d_tcs[25].str) || ((ys >= display->d_top && ye == display->d_bot) && ! up);
#line 1474
  if (display->d_top != ys) {
#line 1474
    if (! (alok && dlok)) {
      {
#line 1475
      ChangeScrollRegion(ys, ye);
      }
    }
  }
#line 1477
  if (display->d_lp_missing) {
#line 1477
    if (oldbot != display->d_bot) {
      _L: /* CIL Label */ 
      {
#line 1481
      WriteLP(display->d_width - 1, oldbot);
      }
#line 1482
      if (oldbot == display->d_bot) {
#line 1484
        n --;
#line 1484
        if (n == 0) {
#line 1489
          if (bce) {
#line 1489
            if (! display->d_tcs[66].flg) {
              {
#line 1490
              ClearLine((struct mline *)0, ye, xs, xe, bce);
              }
            }
          }
#line 1491
          return;
        }
      }
    } else
#line 1477
    if (oldbot == display->d_bot) {
#line 1477
      if (up) {
#line 1477
        if (display->d_top == ys) {
#line 1477
          if (display->d_bot == ye) {
#line 1477
            goto _L;
          }
        }
      }
    }
  }
#line 1496
  if (display->d_tcs[33].flg) {
    {
#line 1497
    SetRendition(& mchar_null);
    }
  }
#line 1499
  if (display->d_tcs[66].flg) {
    {
#line 1500
    SetBackColor(bce);
    }
  }
#line 1503
  aldlfaster = ((n > 1 && ys >= display->d_top) && ye == display->d_bot) && ((up && display->d_tcs[25].str) || (! up && display->d_tcs[23].str));
#line 1505
  if (up) {
    _L___99: /* CIL Label */ 
#line 1505
    if (display->d_top == ys) {
#line 1505
      if (display->d_bot == ye) {
#line 1505
        if (! aldlfaster) {
#line 1507
          if (up) {
            {
#line 1509
            GotoPos(0, ye);
#line 1510
            i = n;
            }
            {
#line 1510
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1510
              if (! (__cil_tmp14 > 0)) {
#line 1510
                goto while_break___0;
              }
              {
#line 1511
              AddCStr(display->d_tcs[19].str);
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
            {
#line 1515
            GotoPos(0, ys);
#line 1516
            i = n;
            }
            {
#line 1516
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1516
              if (! (__cil_tmp15 > 0)) {
#line 1516
                goto while_break___1;
              }
              {
#line 1517
              AddCStr(display->d_tcs[21].str);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        } else {
#line 1505
          goto _L___96;
        }
      } else {
#line 1505
        goto _L___96;
      }
    } else {
#line 1505
      goto _L___96;
    }
  } else
#line 1505
  if (display->d_tcs[21].str) {
#line 1505
    goto _L___99;
  } else
  _L___96: /* CIL Label */ 
#line 1520
  if (alok) {
#line 1520
    if (dlok) {
#line 1522
      if (up) {
        _L___93: /* CIL Label */ 
#line 1524
        if (up) {
#line 1524
          tmp = ys;
        } else {
#line 1524
          tmp = (ye + 1) - n;
        }
        {
#line 1524
        GotoPos(0, tmp);
        }
#line 1525
        if (display->d_tcs[25].str) {
#line 1525
          if (! (n == 1 && display->d_tcs[24].str)) {
            {
#line 1526
            AddCStr2(display->d_tcs[25].str, n);
            }
          } else {
#line 1525
            goto _L___92;
          }
        } else {
          _L___92: /* CIL Label */ 
#line 1528
          i = n;
          {
#line 1528
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1528
            if (! __cil_tmp17) {
#line 1528
              goto while_break___2;
            }
            {
#line 1529
            AddCStr(display->d_tcs[24].str);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      } else
#line 1522
      if (ye != display->d_bot) {
#line 1522
        goto _L___93;
      }
#line 1531
      if (! up) {
        _L___95: /* CIL Label */ 
#line 1533
        if (up) {
#line 1533
          tmp___0 = (ye + 1) - n;
        } else {
#line 1533
          tmp___0 = ys;
        }
        {
#line 1533
        GotoPos(0, tmp___0);
        }
#line 1534
        if (display->d_tcs[23].str) {
#line 1534
          if (! (n == 1 && display->d_tcs[22].str)) {
            {
#line 1535
            AddCStr2(display->d_tcs[23].str, n);
            }
          } else {
#line 1534
            goto _L___94;
          }
        } else {
          _L___94: /* CIL Label */ 
#line 1537
          i = n;
          {
#line 1537
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1537
            if (! __cil_tmp19) {
#line 1537
              goto while_break___3;
            }
            {
#line 1538
            AddCStr(display->d_tcs[22].str);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      } else
#line 1531
      if (ye != display->d_bot) {
#line 1531
        goto _L___95;
      }
    } else {
      {
      {
#line 1543
      RefreshArea(xs, ys, xe, ye, 0);
      }
      }
#line 1544
      return;
    }
  } else {
    {
    {
#line 1543
    RefreshArea(xs, ys, xe, ye, 0);
    }
    }
#line 1544
    return;
  }
#line 1546
  if (bce) {
#line 1546
    if (! display->d_tcs[66].flg) {
#line 1548
      if (up) {
        {
#line 1549
        ClearArea(xs, (ye - n) + 1, xs, xe, xe, ye, bce, 0);
        }
      } else {
        {
#line 1551
        ClearArea(xs, ys, xs, xe, xe, (ys + n) - 1, bce, 0);
        }
      }
    }
  }
#line 1553
  if (display->d_lp_missing) {
#line 1553
    if (missy != display->d_bot) {
      {
#line 1554
      WriteLP(display->d_width - 1, missy);
      }
    }
  }
  return;
}
}
#line 1563 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void SetAttr(int new ) 
{ 
  register int i ;
  register int j ;
  register int old ;
  register int typ ;
  int __cil_tmp6 ;

  {
#line 1568
  old = (int )display->d_rend.attr;
#line 1568
  if (! display) {
#line 1569
    return;
  } else
#line 1568
  if (old == new) {
#line 1569
    return;
  }
#line 1571
  display->d_col16change = (old ^ new) & ((1 << 6) | (1 << 7));
#line 1572
  new ^= display->d_col16change;
#line 1573
  if (old == new) {
#line 1574
    return;
  }
#line 1594
  display->d_rend.attr = (unsigned char )new;
#line 1595
  typ = (int )display->d_atyp;
#line 1596
  if ((new & old) != old) {
#line 1598
    if (typ & (1 << 2)) {
      {
#line 1599
      AddCStr(display->d_tcs[53].str);
      }
    }
#line 1600
    if (typ & (1 << 1)) {
      {
#line 1601
      AddCStr(display->d_tcs[54].str);
      }
    }
#line 1602
    if (typ & 1) {
      {
#line 1604
      AddCStr(display->d_tcs[55].str);
      }
#line 1607
      if (display->d_hascolor) {
#line 1608
        display->d_rend.attr &= ~ ((1 << 7) | (1 << 6));
#line 1608
        display->d_rend.color = (unsigned char )0;
      }
#line 1611
      if (! display->d_tcs[97].flg) {
#line 1614
        display->d_rend.font = (unsigned char )0;
#line 1616
        display->d_realfont = 0;
      }
    }
#line 1621
    old = 0;
#line 1622
    typ = 0;
  }
#line 1624
  old ^= new;
#line 1625
  j = 1;
#line 1625
  i = 0;
  {
#line 1625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if (! (old && i < 6)) {
#line 1625
      goto while_break;
    }
#line 1627
    if ((old & j) == 0) {
#line 1628
      goto while_continue;
    }
#line 1629
    old ^= j;
#line 1630
    if (display->d_attrtab[i]) {
      {
#line 1632
      AddCStr(display->d_attrtab[i]);
#line 1633
      typ |= (int )display->d_attrtyp[i];
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1625
  j <<= 1;
#line 1625
  __cil_tmp6 = i;
#line 1625
  i ++;
#line 1636
  display->d_atyp = (char )typ;
  return;
}
}
#line 1641 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void SetFont(int new ) 
{ 
  int old ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1644
  old = (int )display->d_rend.font;
#line 1645
  if (! display) {
#line 1646
    return;
  } else
#line 1645
  if (old == new) {
#line 1646
    return;
  }
  {
#line 1647
  display->d_rend.font = (unsigned char )new;
#line 1649
  __cil_tmp3 = CanEncodeFont(display->d_encoding, new);
  }
#line 1649
  if (display->d_encoding) {
#line 1649
    if (__cil_tmp3) {
#line 1650
      return;
    }
  }
#line 1651
  if (new == display->d_realfont) {
#line 1652
    return;
  }
#line 1653
  display->d_realfont = new;
#line 1655
  if (display->d_xtable) {
#line 1655
    if (*(display->d_xtable + (int )((unsigned char )new))) {
#line 1655
      if (*(*(display->d_xtable + (int )((unsigned char )new)) + 256)) {
        {
#line 1658
        AddCStr(*(*(display->d_xtable + (int )((unsigned char )new)) + 256));
        }
#line 1659
        return;
      }
    }
  }
#line 1662
  if (! display->d_tcs[97].flg) {
#line 1662
    if (new != 48) {
#line 1664
      new = 0;
#line 1665
      if (old == new) {
#line 1666
        return;
      }
    }
  }
#line 1669
  if (new == 0) {
    {
#line 1670
    AddCStr(display->d_tcs[99].str);
    }
  } else
#line 1672
  if (new < 32) {
    {
#line 1674
    AddStr((char *)"\033$");
    }
#line 1675
    if (new > 2) {
      {
#line 1676
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1676
        (display->d_obuffree) --;
#line 1676
        if (display->d_obuffree <= 0) {
          {
#line 1676
          Resize_obuf();
          }
        }
#line 1676
        __cil_tmp4 = display->d_obufp;
#line 1676
        (display->d_obufp) ++;
#line 1676
        *__cil_tmp4 = (char )'(';
#line 1676
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1677
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1677
      (display->d_obuffree) --;
#line 1677
      if (display->d_obuffree <= 0) {
        {
#line 1677
        Resize_obuf();
        }
      }
#line 1677
      __cil_tmp5 = display->d_obufp;
#line 1677
      (display->d_obufp) ++;
#line 1677
      *__cil_tmp5 = (char )(new + 64);
#line 1677
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1681
    AddCStr2(display->d_tcs[98].str, new);
    }
  }
  return;
}
}
#line 1688 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
int color256to16(int jj ) 
{ 
  int min ;
  int max ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  int tmp___0 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;

  {
#line 1694
  if (jj >= 232) {
#line 1696
    jj = (jj - 232) / 6;
#line 1697
    if (jj & 2) {
#line 1697
      tmp = 7;
    } else {
#line 1697
      tmp = 0;
    }
#line 1697
    jj = ((jj & 1) << 3) | tmp;
  } else
#line 1699
  if (jj >= 16) {
#line 1701
    jj -= 16;
#line 1702
    r = jj / 36;
#line 1703
    g = (jj / 6) % 6;
#line 1704
    b = jj % 6;
#line 1705
    if (r < g) {
#line 1705
      if (r < b) {
#line 1705
        tmp___0 = r;
      } else {
#line 1705
        tmp___0 = b;
      }
#line 1705
      tmp___101 = tmp___0;
    } else {
#line 1705
      if (g < b) {
#line 1705
        tmp___100 = g;
      } else {
#line 1705
        tmp___100 = b;
      }
#line 1705
      tmp___101 = tmp___100;
    }
#line 1705
    min = tmp___101;
#line 1706
    if (r > g) {
#line 1706
      if (r > b) {
#line 1706
        tmp___102 = r;
      } else {
#line 1706
        tmp___102 = b;
      }
#line 1706
      tmp___104 = tmp___102;
    } else {
#line 1706
      if (g > b) {
#line 1706
        tmp___103 = g;
      } else {
#line 1706
        tmp___103 = b;
      }
#line 1706
      tmp___104 = tmp___103;
    }
#line 1706
    max = tmp___104;
#line 1707
    if (min == max) {
#line 1708
      if ((max + 1) & 4) {
#line 1708
        tmp___105 = 7;
      } else {
#line 1708
        tmp___105 = 0;
      }
#line 1708
      jj = (((max + 1) & 2) << 2) | tmp___105;
    } else {
#line 1710
      if (max > 3) {
#line 1710
        tmp___106 = 8;
      } else {
#line 1710
        tmp___106 = 0;
      }
#line 1710
      jj = ((((b - min) / (max - min) << 2) | ((g - min) / (max - min) << 1)) | (r - min) / (max - min)) | tmp___106;
    }
  }
#line 1713
  return (jj);
}
}
#line 1738 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void SetColor(int f , int b ) 
{ 
  int of ;
  int ob ;
  static unsigned char sftrans[8] ;
  int tmp ;
  int tmp___107 ;
  int oattr ;
  char *tmp___108 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;

  {
#line 1742
  sftrans[0] = (unsigned char )0;
#line 1742
  sftrans[1] = (unsigned char )4;
#line 1742
  sftrans[2] = (unsigned char )2;
#line 1742
  sftrans[3] = (unsigned char )6;
#line 1742
  sftrans[4] = (unsigned char )1;
#line 1742
  sftrans[5] = (unsigned char )5;
#line 1742
  sftrans[6] = (unsigned char )3;
#line 1742
  sftrans[7] = (unsigned char )7;
#line 1744
  if (! display) {
#line 1745
    return;
  }
#line 1747
  if ((int )display->d_rend.attr & (1 << 6)) {
#line 1747
    tmp = 256;
  } else {
#line 1747
    tmp = 0;
  }
#line 1747
  of = ((int )display->d_rend.color & 15) | tmp;
#line 1748
  if ((int )display->d_rend.attr & (1 << 7)) {
#line 1748
    tmp___107 = 256;
  } else {
#line 1748
    tmp___107 = 0;
  }
#line 1748
  ob = (((int )display->d_rend.color & 240) >> 4) | tmp___107;
#line 1752
  if (f == 256) {
#line 1753
    f = 0;
  }
#line 1754
  if (b == 256) {
#line 1755
    b = 0;
  }
  {
#line 1757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1757
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1758
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1758
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1759
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1759
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1760
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1760
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1762
  if (! display->d_tcs[67].flg) {
#line 1762
    if (display->d_hascolor) {
#line 1762
      if (f == 0) {
#line 1762
        if (f != of) {
          _L: /* CIL Label */ 
#line 1764
          if (display->d_tcs[64].str) {
            {
#line 1765
            AddCStr(display->d_tcs[64].str);
            }
          } else {
#line 1769
            oattr = (int )display->d_rend.attr;
#line 1770
            if (display->d_tcs[55].str) {
#line 1770
              tmp___108 = display->d_tcs[55].str;
            } else {
#line 1770
              tmp___108 = (char *)"\033[m";
            }
            {
#line 1770
            AddCStr(tmp___108);
            }
#line 1772
            if (display->d_tcs[55].str) {
#line 1772
              if (! display->d_tcs[97].flg) {
#line 1775
                display->d_rend.font = (unsigned char )0;
#line 1777
                display->d_realfont = 0;
              }
            }
            {
#line 1781
            display->d_atyp = (char )0;
#line 1782
            display->d_rend.attr = (unsigned char )0;
#line 1783
            SetAttr(oattr);
            }
          }
#line 1785
          ob = 0;
#line 1785
          of = ob;
        } else {
#line 1762
          goto _L___109;
        }
      } else
      _L___109: /* CIL Label */ 
#line 1762
      if (b == 0) {
#line 1762
        if (b != ob) {
#line 1762
          goto _L;
        }
      }
    }
  }
#line 1787
  if (f & 256) {
#line 1787
    tmp___110 = 0;
  } else {
#line 1787
    tmp___110 = 1 << 6;
  }
#line 1787
  display->d_rend.attr = (unsigned char )(((int )display->d_rend.attr | (1 << 6)) ^ tmp___110);
#line 1787
  display->d_rend.color = (unsigned char )(((int )display->d_rend.color & 240) | (f & 15));
#line 1788
  if (b & 256) {
#line 1788
    tmp___111 = 0;
  } else {
#line 1788
    tmp___111 = 1 << 7;
  }
#line 1788
  display->d_rend.attr = (unsigned char )(((int )display->d_rend.attr | (1 << 7)) ^ tmp___111);
#line 1788
  display->d_rend.color = (unsigned char )(((int )display->d_rend.color & 15) | ((b << 4) & 240));
#line 1790
  display->d_col16change = 0;
#line 1792
  if (! display->d_hascolor) {
#line 1793
    return;
  }
#line 1794
  if (f) {
#line 1794
    if ((f & 504) == 264) {
#line 1794
      tmp___112 = f ^ 264;
    } else {
#line 1794
      tmp___112 = f & 255;
    }
#line 1794
    tmp___113 = tmp___112 ^ 9;
  } else {
#line 1794
    tmp___113 = - 1;
  }
#line 1794
  f = tmp___113;
#line 1795
  if (b) {
#line 1795
    if ((b & 504) == 264) {
#line 1795
      tmp___114 = b ^ 264;
    } else {
#line 1795
      tmp___114 = b & 255;
    }
#line 1795
    tmp___115 = tmp___114 ^ 9;
  } else {
#line 1795
    tmp___115 = - 1;
  }
#line 1795
  b = tmp___115;
#line 1796
  if (of) {
#line 1796
    if ((of & 504) == 264) {
#line 1796
      tmp___116 = of ^ 264;
    } else {
#line 1796
      tmp___116 = of & 255;
    }
#line 1796
    tmp___117 = tmp___116 ^ 9;
  } else {
#line 1796
    tmp___117 = - 1;
  }
#line 1796
  of = tmp___117;
#line 1797
  if (ob) {
#line 1797
    if ((ob & 504) == 264) {
#line 1797
      tmp___118 = ob ^ 264;
    } else {
#line 1797
      tmp___118 = ob & 255;
    }
#line 1797
    tmp___119 = tmp___118 ^ 9;
  } else {
#line 1797
    tmp___119 = - 1;
  }
#line 1797
  ob = tmp___119;
#line 1814
  if (f != of) {
#line 1814
    if (f != (of | 8)) {
#line 1816
      if (f == -1) {
        {
#line 1817
        AddCStr((char *)"\033[39m");
        }
      } else
#line 1818
      if (display->d_tcs[60].str) {
        {
#line 1819
        AddCStr2(display->d_tcs[60].str, f & 7);
        }
      } else
#line 1820
      if (display->d_tcs[62].str) {
        {
#line 1821
        AddCStr2(display->d_tcs[62].str, (int )sftrans[f & 7]);
        }
      }
    }
  }
#line 1823
  if (b != ob) {
#line 1823
    if (b != (ob | 8)) {
#line 1825
      if (b == -1) {
        {
#line 1826
        AddCStr((char *)"\033[49m");
        }
      } else
#line 1827
      if (display->d_tcs[61].str) {
        {
#line 1828
        AddCStr2(display->d_tcs[61].str, b & 7);
        }
      } else
#line 1829
      if (display->d_tcs[63].str) {
        {
#line 1830
        AddCStr2(display->d_tcs[63].str, (int )sftrans[b & 7]);
        }
      }
    }
  }
#line 1833
  if (f != of) {
#line 1833
    if (display->d_tcs[96].flg) {
#line 1833
      if ((f & 8) != 0) {
#line 1833
        if (f != -1) {
          {
#line 1836
          AddCStr2((char *)"\033[9%p1%dm", f & 7);
          }
        }
      }
    }
  }
#line 1841
  if (b != ob) {
#line 1841
    if (display->d_tcs[96].flg) {
#line 1841
      if ((b & 8) != 0) {
#line 1841
        if (b != -1) {
          {
#line 1844
          AddCStr2((char *)"\033[10%p1%dm", b & 7);
          }
        }
      }
    }
  }
  return;
}
}
#line 1853 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void SetBackColor(int new ) 
{ 
  int tmp ;

  {
#line 1856
  if (! display) {
#line 1857
    return;
  }
#line 1858
  if ((int )display->d_rend.attr & (1 << 6)) {
#line 1858
    tmp = 256;
  } else {
#line 1858
    tmp = 0;
  }
  {
#line 1858
  SetColor(((int )display->d_rend.color & 15) | tmp, new);
  }
  return;
}
}
#line 1863 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void SetRendition(struct mchar *mc ) 
{ 
  static struct mchar mmc ;
  int i ;
  int a ;
  int tmp ;
  int tmp___123 ;

  {
#line 1866
  if (! display) {
#line 1867
    return;
  }
#line 1869
  if (nattr2color) {
#line 1869
    if (display->d_hascolor) {
#line 1869
      if (((int )mc->attr & nattr2color) != 0) {
#line 1873
        mmc = *mc;
#line 1874
        i = 0;
        {
#line 1874
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1874
          if (! (i < 8)) {
#line 1874
            goto while_break;
          }
#line 1875
          if ((int *)attr2color[i]) {
#line 1875
            if (((int )mc->attr & (1 << i)) != 0) {
#line 1877
              if ((int )mc->color == 0) {
#line 1877
                if (attr2color[i][3]) {
                  {
#line 1878
                  ApplyAttrColor(attr2color[i][3], & mmc);
                  }
                } else {
#line 1877
                  goto _L___120;
                }
              } else
              _L___120: /* CIL Label */ 
#line 1879
              if (((int )mc->color & 15) == 0) {
#line 1879
                if (attr2color[i][2]) {
                  {
#line 1880
                  ApplyAttrColor(attr2color[i][2], & mmc);
                  }
                } else {
#line 1879
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 1881
              if (((int )mc->color & 240) == 0) {
#line 1881
                if (attr2color[i][1]) {
                  {
#line 1882
                  ApplyAttrColor(attr2color[i][1], & mmc);
                  }
                } else {
                  {
                  {
#line 1884
                  ApplyAttrColor(attr2color[i][0], & mmc);
                  }
                  }
                }
              } else {
                {
                {
#line 1884
                ApplyAttrColor(attr2color[i][0], & mmc);
                }
                }
              }
            }
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 1874
        i ++;
#line 1886
        mc = & mmc;
        {
#line 1887
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1887
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 1890
  if (display->d_hascolor) {
#line 1890
    if (display->d_tcs[68].flg) {
#line 1890
      if ((int )mc->attr & ((1 << 6) | (1 << 7))) {
#line 1892
        a = (int )mc->attr;
#line 1893
        if ((int )mc->attr & (1 << 6)) {
#line 1893
          if (display->d_tcs[49].str) {
#line 1894
            a |= 1 << 2;
          }
        }
#line 1895
        if ((int )mc->attr & (1 << 7)) {
#line 1895
          if (display->d_tcs[52].str) {
#line 1896
            a |= 1 << 5;
          }
        }
#line 1897
        if ((int )display->d_rend.attr != a) {
          {
#line 1898
          SetAttr(a);
          }
        }
      } else {
#line 1890
        goto _L___121;
      }
    } else {
#line 1890
      goto _L___121;
    }
  } else
  _L___121: /* CIL Label */ 
#line 1903
  if ((int )display->d_rend.attr != (int )mc->attr) {
    {
#line 1904
    SetAttr((int )mc->attr);
    }
  }
#line 1907
  if ((int )display->d_rend.color != (int )mc->color) {
    _L___124: /* CIL Label */ 
#line 1915
    if ((int )mc->attr & (1 << 6)) {
#line 1915
      tmp = 256;
    } else {
#line 1915
      tmp = 0;
    }
#line 1915
    if ((int )mc->attr & (1 << 7)) {
#line 1915
      tmp___123 = 256;
    } else {
#line 1915
      tmp___123 = 0;
    }
    {
#line 1915
    SetColor(((int )mc->color & 15) | tmp, (((int )mc->color & 240) >> 4) | tmp___123);
    }
  } else
#line 1907
  if (display->d_col16change) {
#line 1907
    goto _L___124;
  }
#line 1918
  if ((int )display->d_rend.font != (int )mc->font) {
    {
#line 1919
    SetFont((int )mc->font);
    }
  }
#line 1921
  if (display->d_encoding == 8) {
#line 1922
    display->d_rend.fontx = mc->fontx;
  }
  return;
}
}
#line 1928 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void SetRenditionMline(struct mline *ml , int x ) 
{ 
  struct mchar mc ;
  int a ;
  struct mchar mc___0 ;
  int tmp ;
  int tmp___126 ;

  {
#line 1932
  if (! display) {
#line 1933
    return;
  }
#line 1935
  if (nattr2color) {
#line 1935
    if (display->d_hascolor) {
#line 1935
      if (((int )*(ml->attr + x) & nattr2color) != 0) {
        {
#line 1938
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1938
          mc.image = *(ml->image + x);
#line 1938
          mc.attr = *(ml->attr + x);
#line 1938
          mc.font = *(ml->font + x);
#line 1938
          mc.fontx = *(ml->fontx + x);
#line 1938
          mc.color = *(ml->color + x);
#line 1938
          mc.mbcs = (unsigned char )0;
#line 1938
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1939
        SetRendition(& mc);
        }
#line 1940
        return;
      }
    }
  }
#line 1943
  if (display->d_hascolor) {
#line 1943
    if (display->d_tcs[68].flg) {
#line 1943
      if ((int )*(ml->attr + x) & ((1 << 6) | (1 << 7))) {
#line 1945
        a = (int )*(ml->attr + x);
#line 1946
        if ((int )*(ml->attr + x) & (1 << 6)) {
#line 1946
          if (display->d_tcs[49].str) {
#line 1947
            a |= 1 << 2;
          }
        }
#line 1948
        if ((int )*(ml->attr + x) & (1 << 7)) {
#line 1948
          if (display->d_tcs[52].str) {
#line 1949
            a |= 1 << 5;
          }
        }
#line 1950
        if ((int )display->d_rend.attr != a) {
          {
#line 1951
          SetAttr(a);
          }
        }
      } else {
#line 1943
        goto _L;
      }
    } else {
#line 1943
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1956
  if ((int )display->d_rend.attr != (int )*(ml->attr + x)) {
    {
#line 1957
    SetAttr((int )*(ml->attr + x));
    }
  }
#line 1959
  if ((int )display->d_rend.color != (int )*(ml->color + x)) {
    _L___127: /* CIL Label */ 
    {
#line 1969
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1969
      mc___0.image = *(ml->image + x);
#line 1969
      mc___0.attr = *(ml->attr + x);
#line 1969
      mc___0.font = *(ml->font + x);
#line 1969
      mc___0.fontx = *(ml->fontx + x);
#line 1969
      mc___0.color = *(ml->color + x);
#line 1969
      mc___0.mbcs = (unsigned char )0;
#line 1969
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1970
    if ((int )mc___0.attr & (1 << 6)) {
#line 1970
      tmp = 256;
    } else {
#line 1970
      tmp = 0;
    }
#line 1970
    if ((int )mc___0.attr & (1 << 7)) {
#line 1970
      tmp___126 = 256;
    } else {
#line 1970
      tmp___126 = 0;
    }
    {
#line 1970
    SetColor(((int )mc___0.color & 15) | tmp, (((int )mc___0.color & 240) >> 4) | tmp___126);
    }
  } else
#line 1959
  if (display->d_col16change) {
#line 1959
    goto _L___127;
  }
#line 1974
  if ((int )display->d_rend.font != (int )*(ml->font + x)) {
    {
#line 1975
    SetFont((int )*(ml->font + x));
    }
  }
#line 1977
  if (display->d_encoding == 8) {
#line 1978
    display->d_rend.fontx = *(ml->fontx + x);
  }
  return;
}
}
#line 1984 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void MakeStatus(char *msg ) 
{ 
  register char *s ;
  register char *t ;
  register int max ;
  int __cil_tmp5 ;
  int tmp ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *buf ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp13 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *tmp___130 ;

  {
#line 1990
  if (! display) {
#line 1991
    return;
  }
#line 1993
  if (display->d_blocked) {
#line 1994
    return;
  }
#line 1995
  if (! display->d_tcinited) {
    {
#line 1997
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1997
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1998
    if (display->d_processinputdata) {
#line 1999
      return;
    }
    {
#line 2000
    AddStr(msg);
#line 2001
    AddStr((char *)"\r\n");
#line 2002
    Flush(0);
    }
#line 2003
    return;
  }
#line 2005
  if (! use_hardstatus) {
    _L: /* CIL Label */ 
#line 2007
    max = display->d_width;
#line 2008
    if (display->d_tcs[87].flg == 0) {
#line 2009
      __cil_tmp5 = max;
#line 2009
      max --;
    }
  } else
#line 2005
  if (! display->d_tcs[75].flg) {
#line 2005
    goto _L;
  } else {
#line 2012
    if (display->d_tcs[76].num > 0) {
#line 2012
      tmp = display->d_tcs[76].num;
    } else {
#line 2012
      tmp = display->d_width - ! display->d_tcs[87].flg;
    }
#line 2012
    max = tmp;
  }
#line 2013
  if (display->d_status) {
    {
#line 2016
    __cil_tmp7 = strcmp((char const   *)msg, (char const   *)display->d_status_lastmsg);
    }
#line 2016
    if (__cil_tmp7 == 0) {
      {
#line 2018
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2018
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2019
      if (! display->d_status_obufpos) {
        {
#line 2020
        SetTimeout(& display->d_statusev, MsgWait);
        }
      }
#line 2021
      return;
    }
    {
#line 2023
    RemoveStatusMinWait();
    }
  }
#line 2025
  t = msg;
#line 2025
  s = t;
  {
#line 2025
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2025
    if (! ((int )*s && t - msg < (long )max)) {
#line 2025
      goto while_break___1;
    }
#line 2026
    if ((int )*s == 7) {
      {
#line 2027
      AddCStr(display->d_tcs[42].str);
      }
    } else
#line 2028
    if ((int )((unsigned char )*s) >= 32) {
#line 2028
      if ((int )*s != 127) {
#line 2029
        __cil_tmp8 = t;
#line 2029
        t ++;
#line 2029
        *__cil_tmp8 = *s;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2025
  s ++;
#line 2030
  *t = (char )'\000';
#line 2031
  if (t == msg) {
#line 2032
    return;
  }
#line 2033
  if (t - msg >= (long )display->d_status_buflen) {
#line 2036
    if (display->d_status_lastmsg) {
      {
#line 2037
      __cil_tmp10 = realloc((void *)display->d_status_lastmsg, (unsigned long )((t - msg) + 1L));
#line 2037
      buf = (char *)__cil_tmp10;
      }
    } else {
      {
#line 2039
      __cil_tmp11 = malloc((unsigned long )((t - msg) + 1L));
#line 2039
      buf = (char *)__cil_tmp11;
      }
    }
#line 2040
    if (buf) {
#line 2042
      display->d_status_lastmsg = buf;
#line 2043
      display->d_status_buflen = (int )((t - msg) + 1L);
    }
  }
#line 2046
  if (t - msg < (long )display->d_status_buflen) {
    {
#line 2047
    strcpy(display->d_status_lastmsg, (char const   *)msg);
    }
  }
#line 2048
  display->d_status_len = (int )(t - msg);
#line 2049
  display->d_status_lastx = display->d_x;
#line 2050
  display->d_status_lasty = display->d_y;
#line 2051
  if (! use_hardstatus) {
    _L___128: /* CIL Label */ 
#line 2053
    display->d_status = 1;
    {
#line 2054
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2054
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2055
    GotoPos(0, display->d_height - 1);
#line 2056
    SetRendition(& mchar_so);
#line 2057
    InsertMode(0);
#line 2058
    AddStr(msg);
    }
#line 2059
    if (display->d_status_len < max) {
      {
#line 2062
      (display->d_status_len) ++;
#line 2063
      SetRendition(& mchar_null);
      }
      {
#line 2064
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2064
        (display->d_obuffree) --;
#line 2064
        if (display->d_obuffree <= 0) {
          {
#line 2064
          Resize_obuf();
          }
        }
#line 2064
        __cil_tmp13 = display->d_obufp;
#line 2064
        (display->d_obufp) ++;
#line 2064
        *__cil_tmp13 = (char )' ';
#line 2064
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2065
      if (display->d_status_len < max) {
#line 2067
        (display->d_status_len) ++;
        {
#line 2068
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2068
          (display->d_obuffree) --;
#line 2068
          if (display->d_obuffree <= 0) {
            {
#line 2068
            Resize_obuf();
            }
          }
#line 2068
          __cil_tmp15 = display->d_obufp;
#line 2068
          (display->d_obufp) ++;
#line 2068
          *__cil_tmp15 = (char )' ';
#line 2068
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 2069
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2069
          (display->d_obuffree) --;
#line 2069
          if (display->d_obuffree <= 0) {
            {
#line 2069
            Resize_obuf();
            }
          }
#line 2069
          __cil_tmp16 = display->d_obufp;
#line 2069
          (display->d_obufp) ++;
#line 2069
          *__cil_tmp16 = (char )'\b';
#line 2069
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
      {
#line 2071
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2071
        (display->d_obuffree) --;
#line 2071
        if (display->d_obuffree <= 0) {
          {
#line 2071
          Resize_obuf();
          }
        }
#line 2071
        __cil_tmp17 = display->d_obufp;
#line 2071
        (display->d_obufp) ++;
#line 2071
        *__cil_tmp17 = (char )'\b';
#line 2071
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 2073
    display->d_x = - 1;
  } else
#line 2051
  if (display->d_has_hstatus == 0) {
#line 2051
    goto _L___128;
  } else
#line 2051
  if (display->d_has_hstatus == 2) {
#line 2051
    goto _L___128;
  } else {
    {
#line 2077
    display->d_status = 2;
#line 2078
    ShowHStatus(msg);
    }
  }
#line 2081
  display->d_status_obufpos = (int )(display->d_obufp - display->d_obuf);
  {
#line 2082
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2082
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2084
  if (display->d_status == 1) {
    {
#line 2086
    olddisplay = display;
#line 2087
    oldflayer = flayer;
#line 2090
    display->d_status = 0;
#line 2091
    GotoPos(0, display->d_height - 1);
#line 2092
    RefreshLine(display->d_height - 1, 0, display->d_status_len - 1, 0);
#line 2093
    GotoPos(display->d_status_lastx, display->d_status_lasty);
    }
#line 2094
    if (display->d_forecv) {
#line 2094
      tmp___130 = (display->d_forecv)->c_layer;
    } else {
#line 2094
      tmp___130 = (struct layer *)0;
    }
#line 2094
    flayer = tmp___130;
#line 2095
    if (flayer) {
      {
#line 2096
      LGotoPos(flayer, flayer->l_x, flayer->l_y);
      }
    }
#line 2097
    display = olddisplay;
#line 2098
    flayer = oldflayer;
#line 2099
    display->d_status = 1;
  }
  return;
}
}
#line 2104 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void RemoveStatus(void) 
{ 
  struct display *olddisplay ;
  struct layer *oldflayer ;
  int where ;
  struct layer *tmp ;

  {
#line 2110
  if (! display) {
#line 2111
    return;
  }
#line 2112
  where = display->d_status;
#line 2112
  if (! where) {
#line 2113
    return;
  }
  {
#line 2115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2116
  if (display->d_status_obuffree >= 0) {
#line 2118
    display->d_obuflen = display->d_status_obuflen;
#line 2119
    display->d_obuffree = display->d_status_obuffree;
#line 2120
    display->d_status_obuffree = - 1;
  }
  {
#line 2122
  display->d_status = 0;
#line 2123
  display->d_status_obufpos = 0;
#line 2124
  display->d_status_bell = (char )0;
#line 2125
  evdeq(& display->d_statusev);
#line 2126
  olddisplay = display;
#line 2127
  oldflayer = flayer;
  }
#line 2128
  if (where == 1) {
#line 2130
    if (captionalways) {
      {
      {
#line 2132
      GotoPos(0, display->d_height - 1);
      }
      {
#line 2133
      RefreshLine(display->d_height - 1, 0, display->d_status_len - 1, 0);
      }
      {
#line 2134
      GotoPos(display->d_status_lastx, display->d_status_lasty);
      }
      }
    } else
#line 2130
    if (display->d_canvas.c_slperp) {
#line 2130
      if ((display->d_canvas.c_slperp)->c_slnext) {
        {
        {
#line 2132
        GotoPos(0, display->d_height - 1);
        }
        {
#line 2133
        RefreshLine(display->d_height - 1, 0, display->d_status_len - 1, 0);
        }
        {
#line 2134
        GotoPos(display->d_status_lastx, display->d_status_lasty);
        }
        }
      }
    }
  } else {
    {
#line 2138
    RefreshHStatus();
    }
  }
#line 2139
  if (display->d_forecv) {
#line 2139
    tmp = (display->d_forecv)->c_layer;
  } else {
#line 2139
    tmp = (struct layer *)0;
  }
#line 2139
  flayer = tmp;
#line 2140
  if (flayer) {
    {
#line 2141
    LGotoPos(flayer, flayer->l_x, flayer->l_y);
    }
  }
#line 2142
  display = olddisplay;
#line 2143
  flayer = oldflayer;
  return;
}
}
#line 2148 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void RemoveStatusMinWait(void) 
{ 
  struct timeval now ;
  int ti ;

  {
#line 2151
  if (! display->d_status_bell) {
#line 2151
    if (! display->d_status_obufpos) {
      {
#line 2155
      gettimeofday(& now, (struct timezone *)((void *)0));
#line 2156
      ti = (int )((now.tv_sec - display->d_status_time.tv_sec) * 1000L + (now.tv_usec - display->d_status_time.tv_usec) / 1000L);
      }
#line 2157
      if (ti < MsgMinWait) {
        {
#line 2158
        DisplaySleep1000(MsgMinWait - ti, 0);
        }
      }
    }
  }
  {
#line 2160
  RemoveStatus();
  }
  return;
}
}
#line 2165 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static int strlen_onscreen(unsigned char *c , unsigned char *end ) 
{ 
  int len ;
  int v ;
  int dec ;
  unsigned char *__cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 2167
  len = 0;
  {
#line 2168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2168
    if (! ((int )*c && (! end || c < end))) {
#line 2168
      goto while_break;
    }
#line 2170
    dec = 0;
    {
#line 2171
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2173
      __cil_tmp6 = c;
#line 2173
      c ++;
#line 2173
      __cil_tmp7 = FromUtf8((int )*__cil_tmp6, & dec);
#line 2173
      v = __cil_tmp7;
      }
#line 2174
      if (v == -2) {
#line 2175
        __cil_tmp8 = c;
#line 2175
        c --;
      }
#line 2171
      if (! (v < 0 && (! end || c < end))) {
#line 2171
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2178
    __cil_tmp9 = utf8_iscomb(v);
    }
#line 2178
    if (! __cil_tmp9) {
      {
#line 2180
      __cil_tmp10 = utf8_isdouble(v);
      }
#line 2180
      if (__cil_tmp10) {
#line 2181
        len ++;
      }
#line 2182
      len ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2186
  return (len);
}
}
#line 2190 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static int PrePutWinMsg(char *s , int start , int max ) 
{ 
  int chars ;
  int __cil_tmp5 ;

  {
#line 2197
  if (display->d_encoding == 8) {
    {
#line 2199
    __cil_tmp5 = strlen_onscreen((unsigned char *)(s + start), (unsigned char *)(s + max));
#line 2199
    chars = __cil_tmp5;
#line 2200
    display->d_encoding = 0;
#line 2201
    PutWinMsg(s, start, max + ((max - start) - chars));
#line 2202
    display->d_encoding = 8;
#line 2203
    display->d_x -= max - chars;
    }
#line 2206
    return (start + chars);
  } else {
    {
#line 2210
    PutWinMsg(s, start, max);
    }
#line 2211
    return (max);
  }
}
}
#line 2227 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ShowHStatus(char *str ) 
{ 
  int l ;
  int ox ;
  int oy ;
  int max ;
  int tmp ;
  size_t __cil_tmp7 ;
  char *tmp___0 ;
  size_t __cil_tmp9 ;
  struct mchar *tmp___131 ;
  int __cil_tmp12 ;
  int tmp___132 ;
  char *tmp___133 ;
  size_t __cil_tmp15 ;
  struct mchar *tmp___134 ;
  int __cil_tmp18 ;
  int tmp___135 ;

  {
#line 2232
  if (display->d_status == 1) {
#line 2232
    if (display->d_has_hstatus == 1) {
#line 2232
      if (display->d_height - 1 == display->d_height - 1) {
#line 2233
        return;
      }
    }
  }
#line 2234
  if (display->d_blocked) {
#line 2235
    return;
  }
#line 2237
  if (display->d_tcs[75].flg) {
#line 2237
    if (display->d_has_hstatus == 3) {
#line 2239
      if (! display->d_hstatus) {
#line 2239
        if (str == (char *)0) {
#line 2240
          return;
        } else
#line 2239
        if ((int )*str == 0) {
#line 2240
          return;
        }
      }
      {
#line 2241
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2241
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2242
      SetRendition(& mchar_null);
#line 2243
      InsertMode(0);
      }
#line 2244
      if (display->d_hstatus) {
        {
#line 2245
        AddCStr(display->d_tcs[79].str);
        }
      }
#line 2246
      display->d_hstatus = 0;
#line 2247
      if (str == (char *)0) {
#line 2248
        return;
      } else
#line 2247
      if ((int )*str == 0) {
#line 2248
        return;
      }
      {
#line 2249
      AddCStr2(display->d_tcs[77].str, 0);
      }
#line 2250
      if (display->d_tcs[76].num > 0) {
#line 2250
        tmp = display->d_tcs[76].num;
      } else {
#line 2250
        tmp = display->d_width - ! display->d_tcs[87].flg;
      }
      {
#line 2250
      max = tmp;
#line 2251
      __cil_tmp7 = strlen((char const   *)str);
      }
#line 2251
      if ((int )__cil_tmp7 > max) {
        {
#line 2252
        AddStrn(str, max);
        }
      } else {
        {
#line 2254
        AddStr(str);
        }
      }
      {
#line 2255
      AddCStr(display->d_tcs[78].str);
#line 2256
      display->d_hstatus = 1;
      }
    } else {
#line 2237
      goto _L___135;
    }
  } else
  _L___135: /* CIL Label */ 
#line 2258
  if (display->d_has_hstatus == 1) {
    {
#line 2260
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2260
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2261
    ox = display->d_x;
#line 2262
    oy = display->d_y;
#line 2263
    if (str) {
#line 2263
      tmp___0 = str;
    } else {
#line 2263
      tmp___0 = (char *)"";
    }
    {
#line 2263
    str = tmp___0;
#line 2264
    __cil_tmp9 = strlen((char const   *)str);
#line 2264
    l = (int )__cil_tmp9;
    }
#line 2265
    if (l > display->d_width) {
#line 2266
      l = display->d_width;
    }
    {
#line 2267
    GotoPos(0, display->d_height - 1);
    }
#line 2268
    if ((captionalways || display->d_cvlist == (struct canvas *)0) || (display->d_cvlist)->c_next) {
#line 2268
      tmp___131 = & mchar_null;
    } else {
#line 2268
      tmp___131 = & mchar_so;
    }
    {
#line 2268
    SetRendition(tmp___131);
#line 2269
    l = PrePutWinMsg(str, 0, l);
    }
#line 2270
    if (! captionalways) {
#line 2270
      if (display->d_cvlist) {
#line 2270
        if (! (display->d_cvlist)->c_next) {
          {
#line 2271
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 2271
            if (! (__cil_tmp12 < display->d_width)) {
#line 2271
              goto while_break___1;
            }
            {
#line 2272
            PUTCHARLP(' ');
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
#line 2273
    if (l < display->d_width) {
      {
#line 2274
      ClearArea(l, display->d_height - 1, l, display->d_width - 1, display->d_width - 1,
                display->d_height - 1, 0, 0);
      }
    }
#line 2275
    if (ox != -1) {
#line 2275
      if (oy != -1) {
        {
#line 2276
        GotoPos(ox, oy);
        }
      }
    }
#line 2277
    if ((int )*str) {
#line 2277
      tmp___132 = 1;
    } else {
#line 2277
      tmp___132 = 0;
    }
    {
#line 2277
    display->d_hstatus = tmp___132;
#line 2278
    SetRendition(& mchar_null);
    }
  } else
#line 2280
  if (display->d_has_hstatus == 4) {
    {
#line 2282
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2282
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2283
    ox = display->d_x;
#line 2284
    oy = display->d_y;
#line 2285
    if (str) {
#line 2285
      tmp___133 = str;
    } else {
#line 2285
      tmp___133 = (char *)"";
    }
    {
#line 2285
    str = tmp___133;
#line 2286
    __cil_tmp15 = strlen((char const   *)str);
#line 2286
    l = (int )__cil_tmp15;
    }
#line 2287
    if (l > display->d_width) {
#line 2288
      l = display->d_width;
    }
    {
#line 2289
    GotoPos(0, 0);
    }
#line 2290
    if ((captionalways || display->d_cvlist == (struct canvas *)0) || (display->d_cvlist)->c_next) {
#line 2290
      tmp___134 = & mchar_null;
    } else {
#line 2290
      tmp___134 = & mchar_so;
    }
    {
#line 2290
    SetRendition(tmp___134);
#line 2291
    l = PrePutWinMsg(str, 0, l);
    }
#line 2292
    if (! captionalways) {
      _L: /* CIL Label */ 
      {
#line 2293
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2293
        if (! (__cil_tmp18 < display->d_width)) {
#line 2293
          goto while_break___3;
        }
        {
#line 2294
        PUTCHARLP(' ');
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 2292
    if (display->d_cvlist) {
#line 2292
      if (! (display->d_cvlist)->c_next) {
#line 2292
        goto _L;
      }
    }
#line 2295
    if (l < display->d_width) {
      {
#line 2296
      ClearArea(l, 0, l, display->d_width - 1, display->d_width - 1, 0, 0, 0);
      }
    }
#line 2297
    if (ox != -1) {
#line 2297
      if (oy != -1) {
        {
#line 2298
        GotoPos(ox, oy);
        }
      }
    }
#line 2299
    if ((int )*str) {
#line 2299
      tmp___135 = 1;
    } else {
#line 2299
      tmp___135 = 0;
    }
    {
#line 2299
    display->d_hstatus = tmp___135;
#line 2300
    SetRendition(& mchar_null);
    }
  } else
#line 2302
  if (str) {
#line 2302
    if ((int )*str) {
#line 2302
      if (display->d_has_hstatus == 2) {
        {
#line 2304
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2304
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 2305
        Msg(0, (char const   *)((char *)"%s"), str);
        }
      }
    }
  }
  return;
}
}
#line 2314 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void RefreshHStatus(void) 
{ 
  char *buf ;
  int extrabytes ;
  size_t __cil_tmp3 ;
  int __cil_tmp4 ;
  int tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 2318
  __cil_tmp4 = strlen_onscreen((unsigned char *)hstatusstring, (unsigned char *)((void *)0));
  }
  {
#line 2318
  __cil_tmp3 = strlen((char const   *)hstatusstring);
#line 2318
  extrabytes = (int )(__cil_tmp3 - (unsigned long )__cil_tmp4);
#line 2322
  evdeq(& display->d_hstatusev);
  }
#line 2323
  if (display->d_status == 2) {
#line 2324
    return;
  }
#line 2325
  if ((display->d_tcs[75].flg && display->d_has_hstatus == 3) && display->d_tcs[76].num > 0) {
#line 2325
    tmp = display->d_tcs[76].num;
  } else {
#line 2325
    tmp = (display->d_width - ! display->d_tcs[87].flg) + extrabytes;
  }
  {
#line 2325
  __cil_tmp6 = MakeWinMsgEv(hstatusstring, display->d_fore, '%', tmp, & display->d_hstatusev,
                            0);
#line 2325
  buf = __cil_tmp6;
  }
#line 2326
  if (buf) {
#line 2326
    if ((int )*buf) {
      {
#line 2328
      ShowHStatus(buf);
      }
#line 2329
      if (display->d_has_hstatus != 0) {
#line 2329
        if (display->d_hstatusev.timeout.tv_sec) {
          {
#line 2330
          evenq(& display->d_hstatusev);
          }
        }
      }
    } else {
      {
      {
#line 2333
      ShowHStatus((char *)0);
      }
      }
    }
  } else {
    {
    {
#line 2333
    ShowHStatus((char *)0);
    }
    }
  }
  return;
}
}
#line 2342 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void RefreshAll(int isblank ) 
{ 
  struct canvas *cv ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
  {
#line 2347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2347
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2348
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2348
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2349
  cv = display->d_cvlist;
  {
#line 2349
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2349
    if (! cv) {
#line 2349
      goto while_break___1;
    }
    {
#line 2351
    olddisplay = display;
#line 2351
    oldflayer = flayer;
#line 2351
    l = cv->c_layer;
#line 2351
    cvlist = l->l_cvlist;
#line 2351
    cvlnext = cv->c_lnext;
#line 2351
    flayer = l;
#line 2351
    l->l_cvlist = cv;
#line 2351
    cv->c_lnext = (struct canvas *)0;
#line 2351
    (*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1, - 1, - 1, isblank);
#line 2351
    flayer = oldflayer;
#line 2351
    l->l_cvlist = cvlist;
#line 2351
    cv->c_lnext = cvlnext;
#line 2351
    display = olddisplay;
#line 2352
    display = cv->c_display;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2349
  cv = cv->c_next;
#line 2354
  RefreshArea(0, 0, display->d_width - 1, display->d_height - 1, isblank);
  }
  return;
}
}
#line 2358 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void RefreshArea(int xs , int ys , int xe , int ye , int isblank ) 
{ 
  int y ;

  {
  {
#line 2362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2362
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2363
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2363
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2364
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2364
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2365
  if (! isblank) {
#line 2365
    if (xs == 0) {
#line 2365
      if (xe == display->d_width - 1) {
#line 2365
        if (ye == display->d_height - 1) {
#line 2365
          if (ys == 0) {
            {
            {
#line 2367
            ClearArea(xs, ys, xs, xe, xe, ye, 0, 0);
            }
#line 2368
            isblank = 1;
            }
          } else
#line 2365
          if (display->d_tcs[35].str) {
            {
            {
#line 2367
            ClearArea(xs, ys, xs, xe, xe, ye, 0, 0);
            }
#line 2368
            isblank = 1;
            }
          }
        }
      }
    }
  }
#line 2370
  y = ys;
  {
#line 2370
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2370
    if (! (y <= ye)) {
#line 2370
      goto while_break___2;
    }
    {
#line 2371
    RefreshLine(y, xs, xe, isblank);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2370
  y ++;
  return;
}
}
#line 2375 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void RefreshLine(int y , int from , int to , int isblank ) 
{ 
  struct viewport *vp ;
  struct viewport *lvp ;
  struct canvas *cv ;
  struct canvas *lcv ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  struct layer *oldflayer ;
  int xx ;
  int yy ;
  int l ;
  char *buf ;
  struct win *p ;
  int extrabytes ;
  size_t __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  size_t __cil_tmp22 ;
  int tmp___0 ;

  {
  {
#line 2385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2385
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2387
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2388
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2388
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2390
  if (display->d_status == 1) {
#line 2390
    if (y == display->d_height - 1) {
#line 2392
      if (to >= display->d_status_len) {
#line 2393
        display->d_status_len = to + 1;
      }
#line 2394
      return;
    }
  }
#line 2397
  if (isblank == 0) {
#line 2397
    if (display->d_tcs[37].str) {
#line 2397
      if (to == display->d_width - 1) {
#line 2397
        if (from < to) {
#line 2397
          if (display->d_status != 2) {
            {
#line 2399
            GotoPos(from, y);
            }
#line 2400
            if (display->d_tcs[33].flg) {
              {
              {
#line 2401
              SetRendition(& mchar_null);
              }
              }
            } else
#line 2400
            if (display->d_tcs[66].flg) {
              {
              {
#line 2401
              SetRendition(& mchar_null);
              }
              }
            }
            {
#line 2402
            AddCStr(display->d_tcs[37].str);
#line 2403
            isblank = 1;
            }
          }
        }
      }
    }
  }
#line 2406
  if (y == display->d_height - 1) {
#line 2406
    if (display->d_has_hstatus == 1) {
      {
      {
#line 2408
      RefreshHStatus();
      }
      }
#line 2409
      return;
    } else {
#line 2406
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2406
  if (y == 0) {
#line 2406
    if (display->d_has_hstatus == 4) {
      {
      {
#line 2408
      RefreshHStatus();
      }
      }
#line 2409
      return;
    }
  }
  {
#line 2412
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2412
    if (! (from <= to)) {
#line 2412
      goto while_break___2;
    }
#line 2414
    lcv = (struct canvas *)0;
#line 2415
    lvp = (struct viewport *)0;
#line 2416
    cv = display->d_cvlist;
    {
#line 2416
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2416
      if (! cv) {
#line 2416
        goto while_break___3;
      }
#line 2418
      if (y == cv->c_ye + 1) {
#line 2418
        if (from >= cv->c_xs) {
#line 2418
          if (from <= cv->c_xe) {
            {
#line 2421
            __cil_tmp19 = strlen_onscreen((unsigned char *)captionstring, (unsigned char *)((void *)0));
            }
            {
#line 2421
            __cil_tmp18 = strlen((char const   *)captionstring);
#line 2421
            extrabytes = (int )(__cil_tmp18 - (unsigned long )__cil_tmp19);
#line 2425
            p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 2426
            buf = MakeWinMsgEv(captionstring, p, '%', ((cv->c_xe - cv->c_xs) + (cv->c_xe + 1 < display->d_width || display->d_tcs[87].flg)) + extrabytes,
                               & cv->c_captev, 0);
            }
#line 2427
            if (cv->c_captev.timeout.tv_sec) {
              {
#line 2428
              evenq(& cv->c_captev);
              }
            }
#line 2429
            if (to > cv->c_xe) {
#line 2429
              tmp = cv->c_xe;
            } else {
#line 2429
              tmp = to;
            }
            {
#line 2429
            xx = tmp;
#line 2430
            __cil_tmp22 = strlen((char const   *)buf);
#line 2430
            l = (int )__cil_tmp22;
#line 2431
            GotoPos(from, y);
#line 2432
            SetRendition(& mchar_so);
            }
#line 2433
            if (l > (xx - cv->c_xs) + 1) {
#line 2434
              l = (xx - cv->c_xs) + 1;
            }
            {
#line 2435
            l = PrePutWinMsg(buf, from - cv->c_xs, l + extrabytes);
#line 2436
            from = cv->c_xs + l;
            }
            {
#line 2437
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2437
              if (! (from <= xx)) {
#line 2437
                goto while_break___4;
              }
              {
#line 2438
              PUTCHARLP(' ');
              }
            }
            while_break___4: /* CIL Label */ ;
            }
#line 2437
            from ++;
#line 2439
            goto while_break___3;
          }
        }
      }
#line 2441
      if (from == cv->c_xe + 1) {
#line 2441
        if (y >= cv->c_ys) {
#line 2441
          if (y <= cv->c_ye + 1) {
            {
#line 2443
            GotoPos(from, y);
#line 2444
            SetRendition(& mchar_so);
#line 2445
            PUTCHARLP(' ');
#line 2446
            from ++;
            }
#line 2447
            goto while_break___3;
          }
        }
      }
#line 2449
      if (y < cv->c_ys) {
#line 2450
        goto while_continue___3;
      } else
#line 2449
      if (y > cv->c_ye) {
#line 2450
        goto while_continue___3;
      } else
#line 2449
      if (to < cv->c_xs) {
#line 2450
        goto while_continue___3;
      } else
#line 2449
      if (from > cv->c_xe) {
#line 2450
        goto while_continue___3;
      }
      {
#line 2451
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2451
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 2452
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2452
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2453
      vp = cv->c_vplist;
      {
#line 2453
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2453
        if (! vp) {
#line 2453
          goto while_break___7;
        }
        {
#line 2455
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2455
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 2456
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2456
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 2458
        if (y >= vp->v_ys) {
#line 2458
          if (y <= vp->v_ye) {
#line 2458
            if (from <= vp->v_xe) {
#line 2458
              if (to >= vp->v_xs) {
#line 2458
                if (lvp == (struct viewport *)0) {
#line 2460
                  lcv = cv;
#line 2461
                  lvp = vp;
                } else
#line 2458
                if (lvp->v_xs > vp->v_xs) {
#line 2460
                  lcv = cv;
#line 2461
                  lvp = vp;
                }
              }
            }
          }
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 2453
      vp = vp->v_next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2416
    cv = cv->c_next;
#line 2465
    if (cv) {
#line 2466
      goto while_continue___2;
    }
#line 2467
    if (lvp == (struct viewport *)0) {
#line 2468
      goto while_break___2;
    }
#line 2469
    if (from < lvp->v_xs) {
#line 2471
      if (! isblank) {
        {
#line 2472
        DisplayLine(& mline_null, & mline_blank, y, from, lvp->v_xs - 1);
        }
      }
#line 2473
      from = lvp->v_xs;
    }
#line 2477
    yy = y - lvp->v_yoff;
#line 2478
    if (to < lvp->v_xe) {
#line 2478
      tmp___0 = to;
    } else {
#line 2478
      tmp___0 = lvp->v_xe;
    }
#line 2478
    xx = tmp___0;
#line 2480
    if (lcv->c_layer) {
#line 2480
      if (lcv->c_xoff + (lcv->c_layer)->l_width == from) {
        {
#line 2482
        GotoPos(from, y);
#line 2483
        SetRendition(& mchar_blank);
#line 2484
        PUTCHARLP('|');
#line 2485
        from ++;
        }
      }
    }
#line 2487
    if (lcv->c_layer) {
#line 2487
      if (yy == (lcv->c_layer)->l_height) {
        {
#line 2489
        GotoPos(from, y);
#line 2490
        SetRendition(& mchar_blank);
        }
        {
#line 2491
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 2491
          if (! (from <= lvp->v_xe && from - lvp->v_xoff < (lcv->c_layer)->l_width)) {
#line 2491
            goto while_break___10;
          }
          {
#line 2493
          PUTCHARLP('-');
#line 2494
          from ++;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
#line 2496
        if (from >= lvp->v_xe + 1) {
#line 2497
          goto while_continue___2;
        }
      }
    }
#line 2499
    if (lcv->c_layer == (struct layer *)0) {
      _L___136: /* CIL Label */ 
#line 2501
      if (! isblank) {
        {
#line 2502
        DisplayLine(& mline_null, & mline_blank, y, from, lvp->v_xe);
        }
      }
#line 2503
      from = lvp->v_xe + 1;
#line 2504
      goto while_continue___2;
    } else
#line 2499
    if (yy >= (lcv->c_layer)->l_height) {
#line 2499
      goto _L___136;
    } else
#line 2499
    if (from - lvp->v_xoff >= (lcv->c_layer)->l_width) {
#line 2499
      goto _L___136;
    }
#line 2507
    if (xx - lvp->v_xoff >= (lcv->c_layer)->l_width) {
#line 2508
      xx = ((lcv->c_layer)->l_width + lvp->v_xoff) - 1;
    }
    {
#line 2509
    oldflayer = flayer;
#line 2510
    flayer = lcv->c_layer;
#line 2511
    cvlist = flayer->l_cvlist;
#line 2512
    cvlnext = lcv->c_lnext;
#line 2513
    flayer->l_cvlist = lcv;
#line 2514
    lcv->c_lnext = (struct canvas *)0;
#line 2515
    (*((flayer->l_layfn)->lf_LayRedisplayLine))(yy, from - lvp->v_xoff, xx - lvp->v_xoff,
                                                isblank);
#line 2516
    flayer->l_cvlist = cvlist;
#line 2517
    lcv->c_lnext = cvlnext;
#line 2518
    flayer = oldflayer;
#line 2520
    from = xx + 1;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2522
  if (! isblank) {
#line 2522
    if (from <= to) {
      {
#line 2523
      DisplayLine(& mline_null, & mline_blank, y, from, to);
      }
    }
  }
  return;
}
}
#line 2532 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void WriteLP(int x2 , int y2 ) 
{ 
  struct mchar oldrend ;
  int __cil_tmp4 ;

  {
  {
#line 2537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2537
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2538
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2539
  oldrend = display->d_rend;
  {
#line 2540
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2540
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2542
  if (display->d_lpchar.mbcs) {
#line 2544
    if (x2 > 0) {
#line 2545
      __cil_tmp4 = x2;
#line 2545
      x2 --;
    } else {
#line 2547
      display->d_lpchar = mchar_blank;
    }
  }
  {
#line 2551
  GotoPos(x2, y2);
#line 2552
  SetRendition(& display->d_lpchar);
#line 2553
  PUTCHAR((int )display->d_lpchar.image);
  }
#line 2555
  if (display->d_lpchar.mbcs) {
    {
#line 2556
    PUTCHAR((int )display->d_lpchar.mbcs);
    }
  }
  {
#line 2558
  display->d_lp_missing = 0;
#line 2559
  SetRendition(& oldrend);
  }
  return;
}
}
#line 2563 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ClearLine(struct mline *oml , int y , int from , int to , int bce ) 
{ 
  int x ;
  struct mchar bcechar ;
  int tmp ;

  {
  {
#line 2572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2572
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2573
  if (display->d_tcs[33].flg) {
    {
#line 2574
    SetRendition(& mchar_null);
    }
  }
#line 2576
  if (display->d_tcs[66].flg) {
    {
#line 2577
    SetBackColor(bce);
    }
  }
#line 2579
  if (from == 0) {
#line 2579
    if (display->d_tcs[38].str) {
#line 2579
      if (to != display->d_width - 1) {
        _L: /* CIL Label */ 
#line 2579
        if (! bce) {
          {
          {
#line 2581
          GotoPos(to, y);
          }
          {
#line 2582
          AddCStr(display->d_tcs[38].str);
          }
          }
#line 2583
          return;
        } else
#line 2579
        if (display->d_tcs[66].flg) {
          {
          {
#line 2581
          GotoPos(to, y);
          }
          {
#line 2582
          AddCStr(display->d_tcs[38].str);
          }
          }
#line 2583
          return;
        }
      } else
#line 2579
      if (display->d_x == to) {
#line 2579
        if (display->d_y == y) {
#line 2579
          goto _L;
        }
      }
    }
  }
#line 2585
  if (to == display->d_width - 1) {
#line 2585
    if (display->d_tcs[37].str) {
#line 2585
      if (! bce) {
        {
        {
#line 2587
        GotoPos(from, y);
        }
        {
#line 2588
        AddCStr(display->d_tcs[37].str);
        }
        }
#line 2589
        return;
      } else
#line 2585
      if (display->d_tcs[66].flg) {
        {
        {
#line 2587
        GotoPos(from, y);
        }
        {
#line 2588
        AddCStr(display->d_tcs[37].str);
        }
        }
#line 2589
        return;
      }
    }
  }
#line 2591
  if (oml == (struct mline *)0) {
#line 2592
    oml = & mline_null;
  }
#line 2594
  if (! bce) {
    {
#line 2596
    DisplayLine(oml, & mline_blank, y, from, to);
    }
#line 2597
    return;
  }
#line 2599
  bcechar = mchar_null;
#line 2600
  if (bce & 256) {
#line 2600
    tmp = 0;
  } else {
#line 2600
    tmp = 1 << 7;
  }
#line 2600
  bcechar.attr = (unsigned char )(((int )bcechar.attr | (1 << 7)) ^ tmp);
#line 2600
  bcechar.color = (unsigned char )(((int )bcechar.color & 15) | ((bce << 4) & 240));
#line 2601
  x = from;
  {
#line 2601
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2601
    if (! (x <= to)) {
#line 2601
      goto while_break___0;
    }
    {
#line 2602
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2602
      *(mline_old.image + x) = bcechar.image;
#line 2602
      *(mline_old.attr + x) = bcechar.attr;
#line 2602
      *(mline_old.font + x) = bcechar.font;
#line 2602
      *(mline_old.fontx + x) = bcechar.fontx;
#line 2602
      *(mline_old.color + x) = bcechar.color;
#line 2602
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2601
  x ++;
#line 2603
  DisplayLine(oml, & mline_old, y, from, to);
  }
  return;
}
}
#line 2610 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void DisplayLine(struct mline *oml , struct mline *ml , int y , int from , int to ) 
{ 
  register int x ;
  int last2flag ;
  int delete_lp ;
  int tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp14 ;
  int tmp___143 ;
  int tmp___144 ;

  {
#line 2615
  last2flag = 0;
#line 2615
  delete_lp = 0;
  {
#line 2617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2617
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2618
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2618
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2619
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2619
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2620
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2620
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2621
  if (! display->d_tcs[87].flg) {
#line 2621
    if (y == display->d_bot) {
#line 2621
      if (to == display->d_width - 1) {
#line 2623
        if (display->d_lp_missing) {
          _L___140: /* CIL Label */ 
#line 2626
          if (display->d_encoding == 8) {
#line 2626
            tmp = (int )*(ml->font + (to + 1)) == 255 && (int )*(ml->image + (to + 1)) == 255;
          } else {
#line 2626
            tmp = ((int )*(ml->font + to) & 31) != 0 && ((int )*(ml->font + to) & 224) == 0;
          }
#line 2626
          if (display->d_tcs[29].str) {
            _L___139: /* CIL Label */ 
#line 2626
            if (from < to) {
#line 2626
              if (! tmp) {
#line 2631
                last2flag = 1;
#line 2632
                display->d_lp_missing = 0;
#line 2633
                __cil_tmp10 = to;
#line 2633
                to --;
              } else {
#line 2626
                goto _L;
              }
            } else {
#line 2626
              goto _L;
            }
          } else
#line 2626
          if (display->d_tcs[27].str) {
#line 2626
            goto _L___139;
          } else {
            _L: /* CIL Label */ 
#line 2637
            delete_lp = ! (((((int )mchar_blank.image == (int )*(oml->image + to) && (int )mchar_blank.attr == (int )*(oml->attr + to)) && (int )mchar_blank.font == (int )*(oml->font + to)) && (int )mchar_blank.fontx == (int )*(oml->fontx + to)) && (int )mchar_blank.color == (int )*(oml->color + to)) && ((display->d_tcs[37].str || display->d_tcs[31].str) || display->d_tcs[32].str);
#line 2638
            display->d_lp_missing = ! (((((int )mchar_blank.image == (int )*(ml->image + to) && (int )mchar_blank.attr == (int )*(ml->attr + to)) && (int )mchar_blank.font == (int )*(ml->font + to)) && (int )mchar_blank.fontx == (int )*(ml->fontx + to)) && (int )mchar_blank.color == (int )*(ml->color + to));
            {
#line 2639
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2639
              display->d_lpchar.image = *(ml->image + to);
#line 2639
              display->d_lpchar.attr = *(ml->attr + to);
#line 2639
              display->d_lpchar.font = *(ml->font + to);
#line 2639
              display->d_lpchar.fontx = *(ml->fontx + to);
#line 2639
              display->d_lpchar.color = *(ml->color + to);
#line 2639
              display->d_lpchar.mbcs = (unsigned char )0;
#line 2639
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        } else
#line 2623
        if (! (((((int )*(oml->image + to) == (int )*(ml->image + to) && (int )*(oml->attr + to) == (int )*(ml->attr + to)) && (int )*(oml->font + to) == (int )*(ml->font + to)) && (int )*(oml->fontx + to) == (int )*(ml->fontx + to)) && (int )*(oml->color + to) == (int )*(ml->color + to))) {
#line 2623
          goto _L___140;
        }
#line 2642
        __cil_tmp11 = to;
#line 2642
        to --;
      }
    }
  }
#line 2645
  if (display->d_mbcs) {
    {
#line 2648
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2648
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2649
    SetRenditionMline(ml, from);
#line 2650
    PUTCHAR((int )*(ml->image + from));
#line 2651
    from ++;
    }
  }
#line 2654
  x = from;
  {
#line 2654
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2654
    if (! (x <= to)) {
#line 2654
      goto while_break___5;
    }
#line 2660
    if (ml != (struct mline *)((void *)0)) {
#line 2660
      if (x < to) {
        _L___141: /* CIL Label */ 
#line 2661
        if ((int )*(oml->image + x) == (int )*(ml->image + x)) {
#line 2661
          if ((int )*(oml->attr + x) == (int )*(ml->attr + x)) {
#line 2661
            if ((int )*(oml->font + x) == (int )*(ml->font + x)) {
#line 2661
              if ((int )*(oml->fontx + x) == (int )*(ml->fontx + x)) {
#line 2661
                if ((int )*(oml->color + x) == (int )*(ml->color + x)) {
#line 2662
                  goto while_continue___5;
                }
              }
            }
          }
        }
      } else
#line 2660
      if (x != display->d_width - 1) {
#line 2660
        goto _L___141;
      } else
#line 2660
      if ((int )*(ml->image + (x + 1))) {
#line 2660
        goto _L___141;
      }
    }
    {
#line 2663
    GotoPos(x, y);
    }
#line 2666
    if (display->d_encoding == 8) {
#line 2666
      tmp___0 = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
    } else {
#line 2666
      tmp___0 = ((int )*(ml->font + x) & 224) == 128;
    }
#line 2666
    if (tmp___0) {
#line 2668
      __cil_tmp14 = x;
#line 2668
      x --;
      {
#line 2669
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2669
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 2670
      GotoPos(x, y);
      }
    }
#line 2672
    if (display->d_encoding == 8) {
#line 2672
      tmp___143 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
    } else {
#line 2672
      tmp___143 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
    }
#line 2672
    if (x == to) {
#line 2672
      if (tmp___143) {
#line 2673
        goto while_break___5;
      }
    }
    {
#line 2675
    SetRenditionMline(ml, x);
#line 2676
    PUTCHAR((int )*(ml->image + x));
    }
#line 2678
    if (display->d_encoding == 8) {
#line 2678
      tmp___144 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
    } else {
#line 2678
      tmp___144 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
    }
#line 2678
    if (tmp___144) {
      {
#line 2679
      x ++;
#line 2679
      PUTCHAR((int )*(ml->image + x));
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2654
  x ++;
#line 2687
  if (last2flag) {
    {
#line 2689
    GotoPos(x, y);
#line 2690
    SetRenditionMline(ml, x + 1);
#line 2691
    PUTCHAR((int )*(ml->image + (x + 1)));
#line 2692
    GotoPos(x, y);
#line 2693
    SetRenditionMline(ml, x);
#line 2694
    INSERTCHAR((int )*(ml->image + x));
    }
  } else
#line 2696
  if (delete_lp) {
#line 2698
    if (display->d_tcs[33].flg) {
      {
#line 2699
      SetRendition(& mchar_null);
      }
    }
#line 2700
    if (display->d_tcs[31].str) {
      {
#line 2701
      AddCStr(display->d_tcs[31].str);
      }
    } else
#line 2702
    if (display->d_tcs[32].str) {
      {
#line 2703
      AddCStr2(display->d_tcs[32].str, 1);
      }
    } else
#line 2704
    if (display->d_tcs[37].str) {
      {
#line 2705
      AddCStr(display->d_tcs[37].str);
      }
    }
  }
  return;
}
}
#line 2710 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void PutChar(struct mchar *c , int x , int y ) 
{ 


  {
  {
#line 2714
  GotoPos(x, y);
#line 2715
  SetRendition(c);
#line 2716
  PUTCHARLP((int )c->image);
  }
#line 2718
  if (c->mbcs) {
#line 2721
    if (display->d_encoding == 8) {
#line 2722
      display->d_rend.font = (unsigned char )0;
    }
    {
#line 2724
    PUTCHARLP((int )c->mbcs);
    }
  }
  return;
}
}
#line 2730 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void InsChar(struct mchar *c , int x , int xe , int y , struct mline *oml ) 
{ 
  int tmp ;

  {
  {
#line 2735
  GotoPos(x, y);
  }
#line 2736
  if (y == display->d_bot) {
#line 2736
    if (! display->d_tcs[87].flg) {
#line 2738
      if (x == display->d_width - 1) {
#line 2740
        display->d_lp_missing = 1;
#line 2741
        display->d_lpchar = *c;
#line 2742
        return;
      }
#line 2744
      if (xe == display->d_width - 1) {
#line 2745
        display->d_lp_missing = 0;
      }
    }
  }
#line 2747
  if (x == xe) {
    {
#line 2749
    SetRendition(c);
#line 2750
    PUTCHARLP((int )c->image);
    }
#line 2751
    return;
  }
#line 2753
  if (! ((display->d_tcs[29].str || display->d_tcs[30].str) || display->d_tcs[27].str)) {
    {
    {
#line 2755
    RefreshLine(y, x, xe, 0);
    }
    {
#line 2756
    GotoPos(x + 1, y);
    }
    }
#line 2758
    return;
  } else
#line 2753
  if (xe != display->d_width - 1) {
    {
    {
#line 2755
    RefreshLine(y, x, xe, 0);
    }
    {
#line 2756
    GotoPos(x + 1, y);
    }
    }
#line 2758
    return;
  }
  {
#line 2760
  InsertMode(1);
  }
#line 2761
  if (! display->d_insert) {
#line 2764
    if ((int )c->mbcs) {
#line 2764
      if (display->d_tcs[29].str) {
        {
#line 2765
        AddCStr(display->d_tcs[29].str);
        }
      }
    }
#line 2766
    if (display->d_tcs[29].str) {
      {
#line 2767
      AddCStr(display->d_tcs[29].str);
      }
    } else {
#line 2769
      if ((int )c->mbcs) {
#line 2769
        tmp = 2;
      } else {
#line 2769
        tmp = 1;
      }
      {
#line 2769
      AddCStr2(display->d_tcs[30].str, tmp);
      }
    }
  }
  {
#line 2777
  SetRendition(c);
#line 2778
  RAW_PUTCHAR((int )c->image);
  }
#line 2780
  if (c->mbcs) {
#line 2783
    if (display->d_encoding == 8) {
#line 2784
      display->d_rend.font = (unsigned char )0;
    }
#line 2786
    if (display->d_x == display->d_width - 1) {
      {
#line 2787
      PUTCHARLP((int )c->mbcs);
      }
    } else {
      {
#line 2789
      RAW_PUTCHAR((int )c->mbcs);
      }
    }
  }
  return;
}
}
#line 2795 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void WrapChar(struct mchar *c , int x , int y , int xs , int ys , int xe , int ye ,
              int ins ) 
{ 
  int bce ;
  int tmp ;
  int __cil_tmp12 ;
  int tmp___148 ;

  {
#line 2804
  if ((int )c->attr & (1 << 7)) {
#line 2804
    tmp = 256;
  } else {
#line 2804
    tmp = 0;
  }
#line 2804
  bce = (((int )c->color & 240) >> 4) | tmp;
  {
#line 2808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2808
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2809
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2809
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2810
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2810
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2811
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2811
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2812
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2812
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2813
  if (xs != 0) {
    _L: /* CIL Label */ 
#line 2815
    if (y == ye) {
      {
#line 2816
      ScrollV(xs, ys, xe, ye, 1, bce);
      }
    } else
#line 2817
    if (y < display->d_height - 1) {
#line 2818
      y ++;
    }
#line 2819
    if (ins) {
      {
#line 2820
      InsChar(c, xs, xe, y, (struct mline *)0);
      }
    } else {
      {
#line 2822
      PutChar(c, xs, y);
      }
    }
#line 2823
    return;
  } else
#line 2813
  if (x != display->d_width) {
#line 2813
    goto _L;
  } else
#line 2813
  if (! display->d_tcs[83].flg) {
#line 2813
    goto _L;
  }
#line 2825
  if (y == ye) {
    {
#line 2827
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2827
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 2828
    ChangeScrollRegion(ys, ye);
    }
#line 2829
    if (display->d_bot != y) {
      _L___146: /* CIL Label */ 
      {
#line 2831
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2831
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 2832
      ScrollV(xs, ys, xe, ye, 1, bce);
#line 2833
      __cil_tmp12 = y;
#line 2833
      y --;
      }
    } else
#line 2829
    if (display->d_x != display->d_width) {
#line 2829
      goto _L___146;
    } else
#line 2829
    if (! bce) {
#line 2829
      if (! display->d_tcs[66].flg) {
#line 2829
        goto _L___146;
      }
    }
  } else
#line 2836
  if (y == display->d_bot) {
    {
#line 2837
    ChangeScrollRegion(0, display->d_height - 1);
    }
  }
#line 2838
  if (display->d_x != display->d_width) {
    _L___150: /* CIL Label */ 
#line 2840
    if (display->d_tcs[87].flg) {
#line 2840
      if (y >= 0) {
        {
#line 2841
        RefreshLine(y, display->d_width - 1, display->d_width - 1, 0);
        }
      }
    }
    {
#line 2842
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2842
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2843
    if (display->d_x != display->d_width) {
      _L___149: /* CIL Label */ 
#line 2845
      if (y == ye) {
        {
#line 2846
        ScrollV(xs, ys, xe, ye, 1, bce);
        }
      }
#line 2847
      if (y == ye || y == display->d_height - 1) {
#line 2847
        tmp___148 = y;
      } else {
#line 2847
        tmp___148 = y + 1;
      }
      {
#line 2847
      GotoPos(xs, tmp___148);
      }
    } else
#line 2843
    if (display->d_y != y) {
#line 2843
      goto _L___149;
    }
  } else
#line 2838
  if (display->d_y != y) {
#line 2838
    goto _L___150;
  }
  {
#line 2850
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2850
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2851
  if (y != ye) {
#line 2851
    if (y < display->d_height - 1) {
#line 2852
      y ++;
    }
  }
#line 2853
  if (ins != display->d_insert) {
    {
#line 2854
    InsertMode(ins);
    }
  }
#line 2855
  if (ins) {
#line 2855
    if (! display->d_insert) {
      {
#line 2857
      InsChar(c, 0, xe, y, (struct mline *)0);
      }
      {
#line 2858
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2858
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2859
      return;
    }
  }
  {
#line 2861
  display->d_y = y;
#line 2862
  display->d_x = 0;
#line 2863
  SetRendition(c);
#line 2864
  RAW_PUTCHAR((int )c->image);
  }
#line 2866
  if (c->mbcs) {
#line 2869
    if (display->d_encoding == 8) {
#line 2870
      display->d_rend.font = (unsigned char )0;
    }
    {
#line 2872
    RAW_PUTCHAR((int )c->mbcs);
    }
  }
  {
#line 2875
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2875
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  return;
}
}
#line 2879 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
int ResizeDisplay(int wi , int he ) 
{ 
  char *tmp ;
  int tmp___151 ;
  char *__cil_tmp5 ;

  {
  {
#line 2882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2882
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2883
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2883
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2884
  if (display->d_width == wi) {
#line 2884
    if (display->d_height == he) {
      {
#line 2886
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2886
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2887
      return (0);
    }
  }
#line 2889
  if (display->d_width != wi) {
#line 2889
    if (display->d_height == he) {
      _L___152: /* CIL Label */ 
#line 2889
      if (display->d_tcs[45].str) {
#line 2889
        if (wi == (int )Z0width) {
          _L: /* CIL Label */ 
          {
#line 2891
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2891
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2892
          if (wi == (int )Z0width) {
#line 2892
            tmp = display->d_tcs[45].str;
          } else {
#line 2892
            tmp = display->d_tcs[46].str;
          }
          {
#line 2892
          AddCStr(tmp);
#line 2893
          ChangeScreenSize(wi, display->d_height, 0);
          }
#line 2894
          if (he == display->d_height) {
#line 2894
            tmp___151 = 0;
          } else {
#line 2894
            tmp___151 = - 1;
          }
#line 2894
          return (tmp___151);
        } else
#line 2889
        if (wi == (int )Z1width) {
#line 2889
          goto _L;
        }
      }
    } else
#line 2889
    if (! display->d_tcs[44].str) {
#line 2889
      goto _L___152;
    }
  }
#line 2896
  if (display->d_tcs[44].str) {
    {
#line 2898
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2898
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2899
    __cil_tmp5 = tgoto(display->d_tcs[44].str, wi, he);
#line 2899
    AddCStr(__cil_tmp5);
#line 2900
    ChangeScreenSize(wi, he, 0);
    }
#line 2901
    return (0);
  }
#line 2903
  return (- 1);
}
}
#line 2907 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ChangeScrollRegion(int newtop , int newbot ) 
{ 
  char *__cil_tmp3 ;

  {
#line 2910
  if (display == (struct display *)0) {
#line 2911
    return;
  }
#line 2912
  if (newtop == newbot) {
#line 2913
    return;
  }
#line 2914
  if (newtop == -1) {
#line 2915
    newtop = 0;
  }
#line 2916
  if (newbot == -1) {
#line 2917
    newbot = display->d_height - 1;
  }
#line 2918
  if (display->d_tcs[18].str == (char *)0) {
#line 2920
    display->d_top = 0;
#line 2921
    display->d_bot = display->d_height - 1;
#line 2922
    return;
  }
#line 2924
  if (display->d_top == newtop) {
#line 2924
    if (display->d_bot == newbot) {
#line 2925
      return;
    }
  }
  {
#line 2926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2926
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2927
  __cil_tmp3 = tgoto(display->d_tcs[18].str, newbot, newtop);
#line 2927
  AddCStr(__cil_tmp3);
#line 2928
  display->d_top = newtop;
#line 2929
  display->d_bot = newbot;
#line 2930
  display->d_x = - 1;
#line 2930
  display->d_y = display->d_x;
  }
  return;
}
}
#line 2937 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void SetXtermOSC(int i , char *s , char *t ) 
{ 
  static char *oscs[][2] ;

  {
  {
#line 2950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2950
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2951
  if (! display->d_tcs[96].flg) {
#line 2952
    return;
  }
#line 2953
  if (! s) {
#line 2954
    s = (char *)"";
  }
#line 2955
  if (! display->d_xtermosc[i]) {
#line 2955
    if (! *s) {
#line 2956
      return;
    }
  }
#line 2957
  if (i == 0) {
#line 2957
    if (! display->d_xtermosc[0]) {
      {
#line 2958
      AddStr((char *)"\033[22;2t");
      }
    }
  }
#line 2959
  if (! *s) {
#line 2960
    s = oscs[i][1];
  }
  {
#line 2961
  display->d_xtermosc[i] = 1;
#line 2962
  AddStr((char *)"\033]");
#line 2963
  AddStr(oscs[i][0]);
#line 2964
  AddStr(s);
#line 2965
  AddStr(t);
  }
  return;
}
}
#line 2969 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ClearAllXtermOSC(void) 
{ 
  int i ;
  int __cil_tmp2 ;

  {
#line 2972
  i = 4;
  {
#line 2972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2972
    if (! (i >= 0)) {
#line 2972
      goto while_break;
    }
    {
#line 2973
    SetXtermOSC(i, (char *)0, (char *)"\a");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2972
  __cil_tmp2 = i;
#line 2972
  i --;
#line 2974
  if (display->d_xtermosc[0]) {
    {
#line 2975
    AddStr((char *)"\033[23;2t");
    }
  }
  return;
}
}
#line 2985 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void AddStr(char *str ) 
{ 
  register char c ;
  char *__cil_tmp5 ;

  {
  {
#line 2990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2990
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2993
  if (display->d_encoding == 8) {
    {
#line 2995
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2995
      if (! c) {
#line 2995
        goto while_break___0;
      }
      {
#line 2996
      AddUtf8((int )((unsigned char )c));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2997
    return;
  }
  {
#line 3000
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3000
    if (! c) {
#line 3000
      goto while_break___1;
    }
    {
#line 3001
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3001
      (display->d_obuffree) --;
#line 3001
      if (display->d_obuffree <= 0) {
        {
#line 3001
        Resize_obuf();
        }
      }
#line 3001
      __cil_tmp5 = display->d_obufp;
#line 3001
      (display->d_obufp) ++;
#line 3001
      *__cil_tmp5 = c;
#line 3001
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 3005 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void AddStrn(char *str , int n ) 
{ 
  register char c ;
  int __cil_tmp5 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 3011
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3011
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3013
  if (display->d_encoding == 8) {
    {
#line 3015
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3015
      if (! ((int )c && __cil_tmp5 > 0)) {
#line 3015
        goto while_break___0;
      }
      {
#line 3016
      AddUtf8((int )((unsigned char )c));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 3020
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3020
      if (! ((int )c && __cil_tmp7 > 0)) {
#line 3020
        goto while_break___1;
      }
      {
#line 3021
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3021
        (display->d_obuffree) --;
#line 3021
        if (display->d_obuffree <= 0) {
          {
#line 3021
          Resize_obuf();
          }
        }
#line 3021
        __cil_tmp8 = display->d_obufp;
#line 3021
        (display->d_obufp) ++;
#line 3021
        *__cil_tmp8 = c;
#line 3021
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 3022
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3022
    if (! (__cil_tmp9 > 0)) {
#line 3022
      goto while_break___3;
    }
    {
#line 3023
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3023
      (display->d_obuffree) --;
#line 3023
      if (display->d_obuffree <= 0) {
        {
#line 3023
        Resize_obuf();
        }
      }
#line 3023
      __cil_tmp10 = display->d_obufp;
#line 3023
      (display->d_obufp) ++;
#line 3023
      *__cil_tmp10 = (char )' ';
#line 3023
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  return;
}
}
#line 3027 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void Flush(int progress ) 
{ 
  register int l ;
  int wr ;
  register char *p ;
  int __cil_tmp5 ;
  fd_set w ;
  struct timeval t ;
  int *__cil_tmp11 ;
  ssize_t __cil_tmp12 ;
  int *__cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 3034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3034
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3035
  l = (int )(display->d_obufp - display->d_obuf);
  {
#line 3036
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3036
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3037
  if (l == 0) {
#line 3038
    return;
  }
  {
#line 3039
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3039
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3040
  if (display->d_userfd < 0) {
#line 3042
    display->d_obuffree += l;
#line 3043
    display->d_obufp = display->d_obuf;
#line 3044
    return;
  }
#line 3046
  p = display->d_obuf;
#line 3047
  if (! progress) {
    {
#line 3049
    __cil_tmp5 = fcntl(display->d_userfd, 4, 0);
    }
#line 3049
    if (__cil_tmp5) {
      {
#line 3050
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3050
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 3052
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3052
    if (! l) {
#line 3052
      goto while_break___3;
    }
#line 3054
    if (progress) {
      {
#line 3057
      while (1) {
        while_continue___4: /* CIL Label */ ;
        __asm__  ("cld; rep; stosq":);
#line 3057
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 3058
      w.fds_bits[0] |= (__fd_mask )(1UL << display->d_userfd % (8 * (int )sizeof(__fd_mask )));
#line 3060
      t.tv_sec = (__time_t )progress;
#line 3061
      t.tv_usec = (__suseconds_t )0;
#line 3062
      wr = select(1024, (fd_set *)0, & w, (fd_set *)0, & t);
      }
#line 3063
      if (wr == -1) {
        {
#line 3065
        __cil_tmp11 = __errno_location();
        }
#line 3065
        if (*__cil_tmp11 == 4) {
#line 3066
          goto while_continue___3;
        }
        {
#line 3067
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 3067
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 3068
        goto while_break___3;
      }
#line 3070
      if (wr == 0) {
        {
#line 3073
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 3073
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 3074
        goto while_break___3;
      }
    }
    {
#line 3077
    __cil_tmp12 = write(display->d_userfd, (void const   *)p, (size_t )l);
#line 3077
    wr = (int )__cil_tmp12;
    }
#line 3078
    if (wr <= 0) {
      {
#line 3080
      __cil_tmp13 = __errno_location();
      }
#line 3080
      if (*__cil_tmp13 == 4) {
#line 3081
        goto while_continue___3;
      }
      {
#line 3082
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 3082
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 3083
      goto while_break___3;
    }
#line 3085
    display->d_obuffree += wr;
#line 3086
    p += wr;
#line 3087
    l -= wr;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3089
  if (l) {
    {
#line 3090
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 3090
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 3091
  display->d_obuffree += l;
#line 3092
  display->d_obufp = display->d_obuf;
#line 3093
  if (! progress) {
    {
#line 3095
    __cil_tmp14 = fcntl(display->d_userfd, 4, 2048);
    }
#line 3095
    if (__cil_tmp14) {
      {
#line 3096
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 3096
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
  }
#line 3098
  if (display->d_blocked == 1) {
#line 3099
    display->d_blocked = 0;
  }
#line 3100
  display->d_blocked_fuzz = 0;
  return;
}
}
#line 3104 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void freetty(void) 
{ 


  {
#line 3106
  if (display->d_userfd >= 0) {
    {
#line 3107
    close(display->d_userfd);
    }
  }
  {
#line 3108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3108
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3109
  display->d_userfd = - 1;
#line 3110
  display->d_obufp = (char *)0;
#line 3111
  display->d_obuffree = 0;
#line 3112
  if (display->d_obuf) {
    {
#line 3113
    free((void *)display->d_obuf);
    }
  }
#line 3114
  display->d_obuf = (char *)0;
#line 3115
  display->d_obuflen = 0;
#line 3116
  display->d_obuflenmax = - display->d_obufmax;
#line 3117
  display->d_blocked = 0;
#line 3118
  display->d_blocked_fuzz = 0;
  return;
}
}
#line 3127 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void Resize_obuf(void) 
{ 
  register int ind ;
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 3131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3131
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3132
  if (display->d_status_obuffree >= 0) {
    {
#line 3134
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3134
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3135
    RemoveStatusMinWait();
#line 3136
    (display->d_obuffree) --;
    }
#line 3136
    if (display->d_obuffree > 0) {
#line 3137
      return;
    }
  }
#line 3139
  if (display->d_obuflen) {
#line 3139
    if (display->d_obuf) {
      {
#line 3141
      ind = (int )(display->d_obufp - display->d_obuf);
#line 3142
      display->d_obuflen += 4096;
#line 3143
      display->d_obuffree += 4096;
#line 3144
      __cil_tmp2 = realloc((void *)display->d_obuf, (unsigned long )display->d_obuflen);
#line 3144
      display->d_obuf = (char *)__cil_tmp2;
      }
    } else {
      {
#line 3148
      ind = 0;
#line 3149
      display->d_obuflen = 4096;
#line 3150
      display->d_obuffree = 4096;
      {
#line 3151
      __cil_tmp3 = malloc((unsigned long )display->d_obuflen);
      }
#line 3151
      display->d_obuf = (char *)__cil_tmp3;
      }
    }
  } else {
    {
#line 3148
    ind = 0;
#line 3149
    display->d_obuflen = 4096;
#line 3150
    display->d_obuffree = 4096;
    {
#line 3151
    __cil_tmp3 = malloc((unsigned long )display->d_obuflen);
    }
#line 3151
    display->d_obuf = (char *)__cil_tmp3;
    }
  }
#line 3153
  if (! display->d_obuf) {
    {
#line 3154
    Panic(0, (char const   *)((char *)"Out of memory"));
    }
  }
#line 3155
  display->d_obufp = display->d_obuf + ind;
#line 3156
  display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
  {
#line 3157
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3157
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 3161 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void DisplaySleep1000(int n , int eat ) 
{ 
  char buf ;
  fd_set r ;
  struct timeval t ;
  int __cil_tmp8 ;

  {
#line 3169
  if (n <= 0) {
#line 3170
    return;
  }
#line 3171
  if (! display) {
    {
#line 3173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3173
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3174
    sleep1000(n);
    }
#line 3175
    return;
  }
#line 3177
  t.tv_usec = (__suseconds_t )((n % 1000) * 1000);
#line 3178
  t.tv_sec = (__time_t )(n / 1000);
  {
#line 3179
  while (1) {
    while_continue___0: /* CIL Label */ ;
    __asm__  ("cld; rep; stosq":);
#line 3179
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3180
  r.fds_bits[0] |= (__fd_mask )(1UL << display->d_userfd % (8 * (int )sizeof(__fd_mask )));
#line 3181
  __cil_tmp8 = select(1024, & r, (fd_set *)0, (fd_set *)0, & t);
  }
#line 3181
  if (__cil_tmp8 > 0) {
    {
#line 3183
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3183
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3184
    if (eat) {
      {
#line 3185
      read(display->d_userfd, (void *)(& buf), (size_t )1);
      }
    }
  }
  {
#line 3187
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3187
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  return;
}
}
#line 3192 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void NukePending(void) 
{ 
  register int len ;
  int oldtop ;
  int oldbot ;
  struct mchar oldrend ;
  int oldkeypad ;
  int oldcursorkeys ;
  int oldcurvis ;
  int oldmouse ;
  int oldextmouse ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *tmp ;

  {
#line 3195
  oldtop = display->d_top;
#line 3195
  oldbot = display->d_bot;
#line 3197
  oldkeypad = display->d_keypad;
#line 3197
  oldcursorkeys = display->d_cursorkeys;
#line 3198
  oldcurvis = display->d_curvis;
#line 3199
  oldmouse = display->d_mouse;
#line 3200
  oldextmouse = display->d_extmouse;
#line 3202
  oldrend = display->d_rend;
#line 3203
  len = (int )(display->d_obufp - display->d_obuf);
  {
#line 3204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3204
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3208
  tcflush(display->d_userfd, 1);
#line 3215
  display->d_obufp = display->d_obuf;
#line 3216
  display->d_obuffree += len;
#line 3217
  display->d_bot = - 1;
#line 3217
  display->d_top = display->d_bot;
#line 3218
  AddCStr(display->d_tcs[39].str);
#line 3219
  AddCStr(display->d_tcs[40].str);
  }
#line 3221
  if (display->d_tcs[55].str) {
    {
#line 3222
    AddCStr(display->d_tcs[55].str);
    }
  } else {
#line 3226
    if (display->d_hascolor) {
      {
#line 3227
      AddStr((char *)"\033[m");
      }
    }
    {
#line 3229
    AddCStr(display->d_tcs[54].str);
#line 3230
    AddCStr(display->d_tcs[53].str);
    }
  }
  {
#line 3233
  __cil_tmp10 = strcmp((char const   *)display->d_tcs[27].str, (char const   *)display->d_tcs[28].str);
  }
#line 3233
  if (display->d_tcs[27].str) {
#line 3233
    if (__cil_tmp10) {
      {
#line 3234
      AddCStr(display->d_tcs[28].str);
      }
    }
  }
  {
#line 3235
  display->d_insert = 0;
#line 3238
  __cil_tmp11 = strcmp((char const   *)display->d_tcs[69].str, (char const   *)display->d_tcs[70].str);
  }
#line 3238
  if (display->d_tcs[69].str) {
#line 3238
    if (__cil_tmp11) {
      {
#line 3239
      AddCStr(display->d_tcs[69].str);
      }
    }
  }
  {
#line 3240
  __cil_tmp12 = strcmp((char const   *)display->d_tcs[71].str, (char const   *)display->d_tcs[72].str);
  }
#line 3240
  if (display->d_tcs[71].str) {
#line 3240
    if (__cil_tmp12) {
      {
#line 3241
      AddCStr(display->d_tcs[71].str);
      }
    }
  }
  {
#line 3250
  AddCStr(display->d_tcs[99].str);
#line 3251
  display->d_rend = mchar_null;
#line 3252
  display->d_atyp = (char )0;
#line 3253
  AddCStr(display->d_tcs[79].str);
#line 3254
  display->d_hstatus = 0;
#line 3255
  AddCStr(display->d_tcs[82].str);
#line 3256
  display->d_curvis = 0;
#line 3257
  ChangeScrollRegion(oldtop, oldbot);
#line 3258
  SetRendition(& oldrend);
#line 3259
  KeypadMode(oldkeypad);
#line 3260
  CursorkeysMode(oldcursorkeys);
#line 3261
  CursorVisibility(oldcurvis);
#line 3262
  MouseMode(oldmouse);
#line 3263
  ExtMouseMode(oldextmouse);
  }
#line 3264
  if (display->d_tcs[44].str) {
    {
#line 3266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3266
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3267
    __cil_tmp13 = tgoto(display->d_tcs[44].str, display->d_width, display->d_height);
#line 3267
    AddCStr(__cil_tmp13);
    }
  } else
#line 3269
  if (display->d_tcs[45].str) {
#line 3269
    if (display->d_width == (int )Z0width) {
      _L: /* CIL Label */ 
      {
#line 3271
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3271
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3272
      if (display->d_width == (int )Z0width) {
#line 3272
        tmp = display->d_tcs[45].str;
      } else {
#line 3272
        tmp = display->d_tcs[46].str;
      }
      {
#line 3272
      AddCStr(tmp);
      }
    } else
#line 3269
    if (display->d_width == (int )Z1width) {
#line 3269
      goto _L;
    }
  }
  return;
}
}
#line 3282 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void disp_writeev_eagain(struct event *ev , char *data ) 
{ 


  {
  {
#line 3286
  display = (struct display *)data;
#line 3287
  evdeq(& display->d_writeev);
#line 3288
  display->d_writeev.type = 2;
#line 3289
  display->d_writeev.handler = disp_writeev_fn;
#line 3290
  evenq(& display->d_writeev);
  }
  return;
}
}
#line 3295 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void disp_writeev_fn(struct event *ev , char *data ) 
{ 
  int len ;
  int size ;
  ssize_t __cil_tmp5 ;
  int tmp ;
  int *__cil_tmp7 ;
  int *__cil_tmp8 ;
  int *__cil_tmp9 ;
  int *__cil_tmp10 ;

  {
#line 3299
  size = 256;
#line 3301
  display = (struct display *)data;
#line 3302
  len = (int )(display->d_obufp - display->d_obuf);
#line 3303
  if (len < size) {
#line 3304
    size = len;
  }
#line 3305
  if (display->d_status_obufpos) {
#line 3305
    if (size > display->d_status_obufpos) {
#line 3306
      size = display->d_status_obufpos;
    }
  }
  {
#line 3307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3307
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3308
  __cil_tmp5 = write(display->d_userfd, (void const   *)display->d_obuf, (size_t )size);
#line 3308
  size = (int )__cil_tmp5;
  }
#line 3309
  if (size >= 0) {
#line 3311
    len -= size;
#line 3312
    if (len) {
      {
#line 3314
      bcopy((void const   *)(display->d_obuf + size), (void *)display->d_obuf, (size_t )len);
      }
      {
#line 3315
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3315
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 3317
    display->d_obufp -= size;
#line 3318
    display->d_obuffree += size;
#line 3319
    if (display->d_status_obufpos) {
#line 3321
      display->d_status_obufpos -= size;
#line 3322
      if (! display->d_status_obufpos) {
        {
#line 3324
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3324
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3326
        if (display->d_status == 1) {
#line 3329
          display->d_status_obuflen = display->d_obuflen;
#line 3330
          display->d_status_obuffree = display->d_obuffree;
#line 3333
          display->d_obuflen = 0;
#line 3333
          display->d_obuffree = display->d_obuflen;
        }
        {
#line 3335
        gettimeofday(& display->d_status_time, (struct timezone *)((void *)0));
#line 3336
        SetTimeout(& display->d_statusev, MsgWait);
#line 3337
        evenq(& display->d_statusev);
        }
      }
    }
#line 3343
    if (display->d_blocked_fuzz) {
#line 3345
      display->d_blocked_fuzz -= size;
#line 3346
      if (display->d_blocked_fuzz < 0) {
#line 3347
        display->d_blocked_fuzz = 0;
      }
    }
#line 3349
    if (display->d_blockedev.queued) {
#line 3351
      if (display->d_obufp - display->d_obuf > (long )(display->d_obufmax / 2)) {
        {
#line 3353
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3353
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 3354
        SetTimeout(& display->d_blockedev, display->d_nonblock);
        }
      } else {
        {
#line 3358
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3358
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 3359
        evdeq(& display->d_blockedev);
        }
      }
    }
#line 3362
    if (display->d_blocked == 1) {
#line 3362
      if (display->d_obuf == display->d_obufp) {
        {
#line 3365
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3365
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 3366
        display->d_blocked = 0;
#line 3367
        if (display->d_fore) {
#line 3367
          tmp = (int )(display->d_fore)->w_norefresh;
        } else {
#line 3367
          tmp = 0;
        }
        {
#line 3367
        Activate(tmp);
#line 3368
        display->d_blocked_fuzz = (int )(display->d_obufp - display->d_obuf);
        }
      }
    }
  } else {
    {
#line 3375
    __cil_tmp7 = __errno_location();
    }
#line 3375
    if (*__cil_tmp7 == 11) {
      {
#line 3377
      evdeq(& display->d_writeev);
#line 3378
      display->d_writeev.type = 0;
#line 3379
      display->d_writeev.handler = disp_writeev_eagain;
#line 3380
      SetTimeout(& display->d_writeev, 100);
#line 3381
      evenq(& display->d_writeev);
      }
    }
    {
#line 3384
    __cil_tmp9 = __errno_location();
    }
    {
#line 3384
    __cil_tmp8 = __errno_location();
    }
#line 3384
    if (*__cil_tmp8 != 4) {
#line 3384
      if (*__cil_tmp9 != 11) {
        {
#line 3388
        __cil_tmp10 = __errno_location();
#line 3388
        Msg(*__cil_tmp10, (char const   *)((char *)"Error writing output to display"));
        }
      }
    }
  }
  return;
}
}
#line 3396 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void disp_readev_fn(struct event *ev , char *data ) 
{ 
  int size ;
  char bufspace[4132] ;
  unsigned char *buf ;
  struct canvas *cv ;
  ssize_t __cil_tmp7 ;
  int *__cil_tmp8 ;
  int *__cil_tmp9 ;
  int tmp ;
  char *bufp ;
  struct win *p ;
  unsigned char *bp ;
  unsigned char *end ;
  unsigned char *mark ;
  unsigned char c ;
  unsigned char *__cil_tmp17 ;
  char __cil_tmp19 ;
  int x ;
  int y ;
  int bias ;
  int tmp___0 ;
  char tmp___153[37] ;
  int n ;
  int focus ;
  struct canvas *cv___156 ;
  struct canvas *__cil_tmp30 ;
  long tmp___154 ;

  {
#line 3408
  buf = (unsigned char *)((char *)bufspace + 36);
#line 3412
  display = (struct display *)data;
#line 3415
  if (display->d_forecv) {
#line 3416
    cv = ((display->d_forecv)->c_layer)->l_cvlist;
    {
#line 3416
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3416
      if (! cv) {
#line 3416
        goto while_break;
      }
#line 3418
      display = cv->c_display;
#line 3419
      if (display->d_status == 1) {
        {
#line 3420
        RemoveStatus();
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3416
    cv = cv->c_lnext;
  }
#line 3423
  display = (struct display *)data;
#line 3424
  if (display->d_fore == (struct win *)0) {
#line 3425
    size = 4096;
  } else
#line 3429
  if ((display->d_fore)->w_pwin) {
#line 3429
    if (((display->d_fore)->w_pwin)->p_fdpat & 4096) {
#line 3430
      size = (int )(sizeof(((display->d_fore)->w_pwin)->p_inbuf) - (unsigned long )((display->d_fore)->w_pwin)->p_inlen);
    } else {
#line 3433
      size = (int )(sizeof((display->d_fore)->w_inbuf) - (unsigned long )(display->d_fore)->w_inlen);
    }
  } else {
#line 3433
    size = (int )(sizeof((display->d_fore)->w_inbuf) - (unsigned long )(display->d_fore)->w_inlen);
  }
#line 3436
  if (size > 4096) {
#line 3437
    size = 4096;
  }
#line 3438
  if (size <= 0) {
#line 3439
    size = 1;
  }
  {
#line 3441
  __cil_tmp7 = read(display->d_userfd, (void *)buf, (size_t )size);
#line 3441
  size = (int )__cil_tmp7;
  }
#line 3442
  if (size < 0) {
    {
#line 3444
    __cil_tmp9 = __errno_location();
    }
    {
#line 3444
    __cil_tmp8 = __errno_location();
    }
#line 3444
    if (*__cil_tmp8 == 4) {
#line 3445
      return;
    } else
#line 3444
    if (*__cil_tmp9 == 11) {
#line 3445
      return;
    }
    {
#line 3450
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3450
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3451
    Hangup();
#line 3452
    sleep((unsigned int )1);
    }
#line 3453
    return;
  } else
#line 3455
  if (size == 0) {
    {
#line 3457
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3457
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3458
    Hangup();
#line 3459
    sleep((unsigned int )1);
    }
#line 3460
    return;
  }
#line 3462
  if (display->d_blocked == 4) {
    {
#line 3464
    display->d_blocked = 0;
#line 3466
    KillBlanker();
    }
#line 3468
    if (display->d_fore) {
#line 3468
      tmp = (int )(display->d_fore)->w_norefresh;
    } else {
#line 3468
      tmp = 0;
    }
    {
#line 3468
    Activate(tmp);
#line 3469
    ResetIdle();
    }
#line 3470
    return;
  }
#line 3473
  if (display->d_blocked > 1) {
#line 3478
    flayer = (struct layer *)0;
#line 3479
    p = windows;
    {
#line 3479
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3479
      if (! p) {
#line 3479
        goto while_break___2;
      }
#line 3480
      if (p->w_zdisplay == display) {
#line 3482
        flayer = & p->w_layer;
#line 3483
        bufp = (char *)buf;
        {
#line 3484
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3484
          if (! (size > 0)) {
#line 3484
            goto while_break___3;
          }
          {
#line 3485
          (*((flayer->l_layfn)->lf_LayProcess))(& bufp, & size);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3486
        return;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3479
    p = p->w_next;
    {
#line 3488
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3488
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 3489
    zmodem_abort((struct win *)0, display);
    }
  }
#line 3492
  if (idletimo > 0) {
    {
#line 3493
    ResetIdle();
    }
  }
#line 3494
  if (display->d_fore) {
#line 3495
    (display->d_fore)->w_lastdisp = display;
  }
#line 3497
  if (display->d_mouse) {
#line 3497
    if (display->d_forecv) {
#line 3499
      bp = buf;
#line 3500
      end = bp + size;
#line 3501
      mark = (unsigned char *)((void *)0);
      {
#line 3527
      if ((int )display->d_mouse_parse.state == 0) {
#line 3527
        goto case_0;
      }
#line 3527
      if ((int )display->d_mouse_parse.state == 1) {
#line 3527
        goto case_0;
      }
#line 3527
      if ((int )display->d_mouse_parse.state == 2) {
#line 3527
        goto case_0;
      }
#line 3534
      if ((int )display->d_mouse_parse.state == 5) {
#line 3534
        goto case_5;
      }
#line 3542
      if ((int )display->d_mouse_parse.state == 4) {
#line 3542
        goto case_4;
      }
#line 3550
      goto switch_default;
      case_0: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 3532
      goto switch_break;
      case_5: /* CIL Label */ 
#line 3538
      buf --;
#line 3538
      *buf = (unsigned char )'[';
#line 3539
      size ++;
      case_4: /* CIL Label */ 
#line 3546
      buf --;
#line 3546
      *buf = (unsigned char )'\033';
#line 3547
      size ++;
#line 3548
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 3551
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }

      {
#line 3554
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3554
        if (! (bp != end)) {
#line 3554
          goto while_break___5;
        }
#line 3556
        __cil_tmp17 = bp;
#line 3556
        bp ++;
#line 3556
        c = *__cil_tmp17;
        {
#line 3560
        if ((int )display->d_mouse_parse.state == 6) {
#line 3560
          goto case_6;
        }
#line 3569
        if ((int )display->d_mouse_parse.state == 4) {
#line 3569
          goto case_4___0;
        }
#line 3579
        if ((int )display->d_mouse_parse.state == 5) {
#line 3579
          goto case_5___0;
        }
#line 3599
        if ((int )display->d_mouse_parse.state == 2) {
#line 3599
          goto case_2___0;
        }
#line 3599
        if ((int )display->d_mouse_parse.state == 1) {
#line 3599
          goto case_2___0;
        }
#line 3599
        if ((int )display->d_mouse_parse.state == 0) {
#line 3599
          goto case_2___0;
        }
#line 3630
        goto switch_default___0;
        case_6: /* CIL Label */ 
#line 3561
        if ((int )c == 27) {
#line 3564
          mark = bp - 1;
#line 3565
          display->d_mouse_parse.state = (char )4;
        }
#line 3567
        goto switch_break___0;
        case_4___0: /* CIL Label */ 
#line 3570
        if ((int )c == 91) {
#line 3573
          display->d_mouse_parse.state = (char )5;
        } else {
#line 3576
          display->d_mouse_parse.state = (char )6;
        }
#line 3577
        goto switch_break___0;
        case_5___0: /* CIL Label */ 
#line 3580
        if ((int )c == 77) {
#line 3583
          display->d_mouse_parse.state = (char )0;
#line 3584
          display->d_mouse_parse.sgrmode = (char )0;
        } else
#line 3586
        if ((int )c == 60) {
#line 3589
          display->d_mouse_parse.state = (char )0;
#line 3590
          display->d_mouse_parse.params[display->d_mouse_parse.state] = 0;
#line 3591
          display->d_mouse_parse.sgrmode = (char )1;
        } else {
#line 3594
          display->d_mouse_parse.state = (char )6;
        }
#line 3595
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
        case_1___0: /* CIL Label */ 
        case_0___0: /* CIL Label */ 
#line 3600
        if (display->d_mouse_parse.sgrmode) {
#line 3603
          if (48 <= (int )c) {
#line 3603
            if ((int )c <= 57) {
#line 3605
              display->d_mouse_parse.params[display->d_mouse_parse.state] *= 10;
#line 3606
              display->d_mouse_parse.params[display->d_mouse_parse.state] += (int )c - 48;
            } else {
#line 3603
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 3608
          if ((int )display->d_mouse_parse.state == 2) {
#line 3610
            if ((int )c == 77) {
#line 3611
              display->d_mouse_parse.state = (char )3;
            } else
#line 3610
            if ((int )c == 109) {
#line 3611
              display->d_mouse_parse.state = (char )3;
            } else {
#line 3613
              display->d_mouse_parse.state = (char )7;
            }
          } else
#line 3615
          if ((int )c == 59) {
#line 3617
            (display->d_mouse_parse.state) ++;
#line 3618
            display->d_mouse_parse.params[display->d_mouse_parse.state] = 0;
          } else {
#line 3621
            display->d_mouse_parse.state = (char )7;
          }
        } else {
#line 3626
          __cil_tmp19 = display->d_mouse_parse.state;
#line 3626
          (display->d_mouse_parse.state) ++;
#line 3626
          display->d_mouse_parse.params[__cil_tmp19] = (int )c;
        }
#line 3628
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 3631
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 3634
        if ((int )display->d_mouse_parse.state == 7) {
#line 3637
          if (buf < mark) {
            {
#line 3638
            disp_processinput(display, buf, (int )(mark - buf));
            }
          }
#line 3640
          buf = bp;
#line 3641
          size = (int )(end - bp);
#line 3642
          display->d_mouse_parse.state = (char )6;
        } else
#line 3644
        if ((int )display->d_mouse_parse.state == 3) {
#line 3647
          if (buf < mark) {
            {
#line 3648
            disp_processinput(display, buf, (int )(mark - buf));
            }
          }
#line 3650
          buf = bp;
#line 3651
          size = (int )(end - bp);
#line 3653
          x = display->d_mouse_parse.params[1];
#line 3654
          y = display->d_mouse_parse.params[2];
#line 3655
          if ((int )display->d_mouse_parse.sgrmode) {
#line 3655
            tmp___0 = 1;
          } else {
#line 3655
            tmp___0 = 33;
          }
#line 3655
          bias = tmp___0;
#line 3657
          x -= bias;
#line 3658
          y -= bias;
#line 3660
          if (x >= (display->d_forecv)->c_xs) {
#line 3660
            if (x <= (display->d_forecv)->c_xe) {
#line 3660
              if (y >= (display->d_forecv)->c_ys) {
#line 3660
                if (y <= (display->d_forecv)->c_ye) {
#line 3662
                  if (display->d_fore) {
#line 3662
                    if ((display->d_fore)->w_mouse) {
                      _L___154: /* CIL Label */ 
#line 3665
                      x -= (display->d_forecv)->c_xoff;
#line 3666
                      y -= (display->d_forecv)->c_yoff;
#line 3668
                      if (x >= 0) {
#line 3668
                        if (x < ((display->d_forecv)->c_layer)->l_width) {
#line 3668
                          if (y >= 0) {
#line 3668
                            if (y < ((display->d_forecv)->c_layer)->l_height) {
#line 3673
                              x += bias;
#line 3674
                              y += bias;
#line 3676
                              if (display->d_mouse_parse.sgrmode) {
                                {
#line 3678
                                n = snprintf((char *)tmp___153, (unsigned long )36,
                                             (char const   *)((char *)"\033[<%d;%d;%d%c"),
                                             display->d_mouse_parse.params[0], x,
                                             y, (int )c);
                                }
                              } else {
                                {
#line 3684
                                n = snprintf((char *)tmp___153, (unsigned long )36,
                                             (char const   *)((char *)"\033[M%c%c%c"),
                                             display->d_mouse_parse.params[0], x,
                                             y);
                                }
                              }
#line 3689
                              if (n > 36) {
#line 3690
                                n = 36;
                              }
                              {
#line 3693
                              buf -= n;
#line 3694
                              size += n;
#line 3695
                              memcpy((void *)buf, (void const   *)((char *)tmp___153),
                                     (unsigned long )n);
                              }
                            }
                          }
                        }
                      }
                    } else {
#line 3662
                      goto _L___155;
                    }
                  } else
                  _L___155: /* CIL Label */ 
#line 3662
                  if (display->d_mousetrack) {
#line 3662
                    if (((display->d_forecv)->c_layer)->l_mode == 1) {
#line 3662
                      goto _L___154;
                    }
                  }
                } else {
#line 3660
                  goto _L___157;
                }
              } else {
#line 3660
                goto _L___157;
              }
            } else {
#line 3660
              goto _L___157;
            }
          } else
          _L___157: /* CIL Label */ 
#line 3699
          if (display->d_mousetrack) {
#line 3702
            focus = 0;
#line 3703
            if (display->d_mouse_parse.sgrmode) {
#line 3704
              focus = (int )c == 109;
            } else {
#line 3706
              focus = display->d_mouse_parse.params[0] == 35;
            }
            {
#line 3708
            __cil_tmp30 = FindCanvas(x, y);
#line 3708
            cv___156 = __cil_tmp30;
            }
#line 3709
            if (focus) {
#line 3709
              if (cv___156) {
                {
#line 3711
                SetForeCanvas(display, cv___156);
                }
              }
            }
          }
#line 3716
          display->d_mouse_parse.state = (char )6;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3720
      if ((int )display->d_mouse_parse.state != 6) {
#line 3723
        if (mark) {
#line 3723
          tmp___154 = mark - buf;
        } else {
#line 3723
          tmp___154 = (long )0;
        }
#line 3723
        size = (int )tmp___154;
      }
    }
  }
#line 3727
  if (size > 0) {
    {
#line 3728
    disp_processinput(display, buf, size);
    }
  }
  return;
}
}
#line 3732 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void disp_processinput(struct display *display___0 , unsigned char *buf , int size ) 
{ 
  int tmp ;
  int i ;
  int j ;
  int c ;
  int enc ;
  char buf2[8202] ;
  int tmp___160 ;
  int __cil_tmp12 ;
  int font ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 3738
  if (display___0->d_forecv) {
#line 3738
    tmp = ((display___0->d_forecv)->c_layer)->l_encoding;
  } else {
#line 3738
    tmp = 0;
  }
#line 3738
  if (display___0->d_encoding != tmp) {
#line 3742
    if (display___0->d_forecv) {
#line 3742
      tmp___160 = ((display___0->d_forecv)->c_layer)->l_encoding;
    } else {
#line 3742
      tmp___160 = 0;
    }
#line 3742
    enc = tmp___160;
#line 3743
    j = 0;
#line 3743
    i = j;
    {
#line 3743
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3743
      if (! (i < size)) {
#line 3743
        goto while_break;
      }
      {
#line 3745
      c = (int )*(buf + i);
#line 3746
      c = DecodeChar(c, display___0->d_encoding, & display___0->d_decodestate);
      }
#line 3747
      if (c == -2) {
#line 3748
        __cil_tmp12 = i;
#line 3748
        i --;
      }
#line 3749
      if (c < 0) {
#line 3750
        goto while_continue;
      }
#line 3751
      if (pastefont) {
        {
#line 3753
        font = 0;
#line 3754
        __cil_tmp14 = EncodeChar((char *)buf2 + j, c, enc, & font);
        }
        {
#line 3754
        j += __cil_tmp14;
#line 3755
        __cil_tmp15 = EncodeChar((char *)buf2 + j, - 1, enc, & font);
        }
#line 3755
        j += __cil_tmp15;
      } else {
        {
#line 3758
        __cil_tmp16 = EncodeChar((char *)buf2 + j, c, enc, (int *)0);
        }
#line 3758
        j += __cil_tmp16;
      }
#line 3759
      if (j > (int )sizeof(buf2) - 10) {
#line 3760
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3743
    i ++;
#line 3762
    (*(display___0->d_processinput))((char *)buf2, j);
    }
#line 3763
    return;
  }
  {
#line 3766
  (*(display___0->d_processinput))((char *)buf, size);
  }
  return;
}
}
#line 3770 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void disp_status_fn(struct event *ev , char *data ) 
{ 


  {
#line 3774
  display = (struct display *)data;
  {
#line 3775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3775
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3776
  if (display->d_status) {
    {
#line 3777
    RemoveStatus();
    }
  }
  return;
}
}
#line 3781 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void disp_hstatus_fn(struct event *ev , char *data ) 
{ 


  {
#line 3785
  display = (struct display *)data;
#line 3786
  if (display->d_status == 2) {
    {
#line 3788
    SetTimeout(ev, 1);
#line 3789
    evenq(ev);
    }
#line 3790
    return;
  }
  {
#line 3792
  RefreshHStatus();
  }
  return;
}
}
#line 3796 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void disp_blocked_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;

  {
#line 3802
  display = (struct display *)data;
  {
#line 3803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3803
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3804
  if (display->d_obufp - display->d_obuf > (long )(display->d_obufmax + display->d_blocked_fuzz)) {
    {
#line 3806
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3806
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3807
    display->d_blocked = 1;
#line 3809
    p = windows;
    {
#line 3809
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3809
      if (! p) {
#line 3809
        goto while_break___1;
      }
#line 3810
      if (p->w_readev.condneg == & display->d_obuflenmax) {
        {
#line 3812
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3812
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3813
        p->w_readev.condneg = (int *)0;
#line 3813
        p->w_readev.condpos = p->w_readev.condneg;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3809
    p = p->w_next;
  }
  return;
}
}
#line 3820 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void disp_map_fn(struct event *ev , char *data ) 
{ 
  char *p ;
  int l ;
  int i ;
  unsigned char *q ;
  int __cil_tmp7 ;

  {
#line 3827
  display = (struct display *)data;
  {
#line 3828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3828
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3829
  l = display->d_seql;
#line 3829
  if (! l) {
#line 3830
    return;
  }
#line 3831
  p = (char *)display->d_seqp - l;
#line 3832
  display->d_seqp = display->d_kmaps + 3;
#line 3833
  display->d_seql = 0;
#line 3834
  q = display->d_seqh;
#line 3834
  if (q != (unsigned char *)0) {
#line 3836
    display->d_seqh = (unsigned char *)0;
#line 3837
    i = ((int )*(q + 0) << 8) | (int )*(q + 1);
#line 3838
    i &= ~ 16384;
    {
#line 3839
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3839
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3840
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3840
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3841
    __cil_tmp7 = StuffKey(i);
    }
#line 3841
    if (__cil_tmp7) {
      {
#line 3842
      ProcessInput2((char *)q + 3, (int )*(q + 2));
      }
    }
#line 3843
    if (display == (struct display *)0) {
#line 3844
      return;
    }
#line 3845
    l -= (int )*(q + 2);
#line 3846
    p += (int )*(q + 2);
  } else {
#line 3849
    display->d_dontmap = 1;
  }
  {
#line 3850
  ProcessInput(p, l);
  }
  return;
}
}
#line 3855 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void disp_idle_fn(struct event *ev , char *data ) 
{ 
  struct display *olddisplay ;

  {
#line 3860
  display = (struct display *)data;
  {
#line 3861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3861
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3862
  if (idletimo <= 0) {
#line 3863
    return;
  } else
#line 3862
  if (idleaction.nr == -1) {
#line 3863
    return;
  }
  {
#line 3864
  olddisplay = display;
#line 3865
  flayer = (display->d_forecv)->c_layer;
#line 3866
  fore = display->d_fore;
#line 3867
  DoAction(& idleaction, - 1);
  }
#line 3868
  if (idleaction.nr == 19) {
#line 3869
    return;
  }
#line 3870
  display = displays;
  {
#line 3870
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3870
    if (! display) {
#line 3870
      goto while_break___0;
    }
#line 3871
    if (olddisplay == display) {
#line 3872
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3870
  display = display->d_next;
#line 3873
  if (display) {
    {
#line 3874
    ResetIdle();
    }
  }
  return;
}
}
#line 3878 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void ResetIdle(void) 
{ 


  {
#line 3880
  if (idletimo > 0) {
    {
#line 3882
    SetTimeout(& display->d_idleev, idletimo);
    }
#line 3883
    if (! display->d_idleev.queued) {
      {
#line 3884
      evenq(& display->d_idleev);
      }
    }
  } else {
    {
#line 3887
    evdeq(& display->d_idleev);
    }
  }
  return;
}
}
#line 3894 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
static void disp_blanker_fn(struct event *ev , char *data ) 
{ 
  char buf[4096] ;
  char *b ;
  int size ;
  ssize_t __cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 3901
  display = (struct display *)data;
#line 3902
  __cil_tmp6 = read(display->d_blankerev.fd, (void *)((char *)buf), (size_t )4096);
#line 3902
  size = (int )__cil_tmp6;
  }
#line 3903
  if (size <= 0) {
    {
#line 3905
    evdeq(& display->d_blankerev);
#line 3906
    close(display->d_blankerev.fd);
#line 3907
    display->d_blankerev.fd = - 1;
    }
#line 3908
    return;
  }
#line 3910
  b = (char *)buf;
  {
#line 3910
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3910
    if (! size) {
#line 3910
      goto while_break;
    }
    {
#line 3911
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3911
      (display->d_obuffree) --;
#line 3911
      if (display->d_obuffree <= 0) {
        {
#line 3911
        Resize_obuf();
        }
      }
#line 3911
      __cil_tmp8 = b;
#line 3911
      b ++;
#line 3911
      __cil_tmp7 = display->d_obufp;
#line 3911
      (display->d_obufp) ++;
#line 3911
      *__cil_tmp7 = *__cil_tmp8;
#line 3911
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3910
  __cil_tmp9 = size;
#line 3910
  size --;
  return;
}
}
#line 3915 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void KillBlanker(void) 
{ 
  int oldtop ;
  int oldbot ;
  struct mchar oldrend ;

  {
#line 3917
  oldtop = display->d_top;
#line 3917
  oldbot = display->d_bot;
#line 3920
  if (display->d_blankerev.fd == -1) {
#line 3921
    return;
  }
#line 3922
  if (display->d_blocked == 4) {
#line 3923
    display->d_blocked = 0;
  }
  {
#line 3924
  evdeq(& display->d_blankerev);
#line 3925
  close(display->d_blankerev.fd);
#line 3926
  display->d_blankerev.fd = - 1;
#line 3927
  Kill(display->d_blankerpid, 1);
#line 3928
  display->d_bot = - 1;
#line 3928
  display->d_top = display->d_bot;
#line 3929
  oldrend = display->d_rend;
  }
#line 3930
  if (display->d_tcs[55].str) {
    {
#line 3932
    AddCStr(display->d_tcs[55].str);
#line 3933
    AddCStr(display->d_tcs[55].str);
    }
  } else {
#line 3938
    if (display->d_hascolor) {
      {
#line 3939
      AddStr((char *)"\033[m\033[m");
      }
    }
    {
#line 3941
    AddCStr(display->d_tcs[54].str);
#line 3942
    AddCStr(display->d_tcs[53].str);
    }
  }
  {
#line 3944
  AddCStr(display->d_tcs[82].str);
#line 3945
  AddCStr(display->d_tcs[99].str);
#line 3946
  display->d_rend = mchar_null;
#line 3947
  display->d_atyp = (char )0;
#line 3948
  display->d_curvis = 0;
#line 3949
  display->d_y = - 1;
#line 3949
  display->d_x = display->d_y;
#line 3950
  ChangeScrollRegion(oldtop, oldbot);
#line 3951
  SetRendition(& oldrend);
#line 3952
  ClearAll();
  }
  return;
}
}
#line 3956 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/display.c"
void RunBlanker(char **cmdv ) 
{ 
  char *m ;
  int pid ;
  int slave ;
  int ptype ;
  char termname[38] ;
  char **np ;
  int *__cil_tmp10 ;
  int *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int *__cil_tmp15 ;
  int __cil_tmp17 ;
  int *__cil_tmp18 ;
  char **__cil_tmp19 ;
  char **__cil_tmp20 ;
  int __cil_tmp21 ;
  int *__cil_tmp22 ;

  {
  {
#line 3961
  slave = - 1;
#line 3962
  ptype = 0;
#line 3969
  strcpy((char *)termname, (char const   *)((char *)"TERM="));
#line 3970
  strncpy((char *)termname + 5, (char const   *)((char *)display->d_termname), (unsigned long )26);
#line 3971
  termname[sizeof(termname) - 1UL] = (char )0;
#line 3972
  KillBlanker();
#line 3973
  display->d_blankerpid = - 1;
#line 3974
  display->d_blankerev.fd = OpenDevice(cmdv, 0, & ptype, & m);
  }
#line 3974
  if (display->d_blankerev.fd == -1) {
    {
#line 3976
    Msg(0, (char const   *)((char *)"OpenDevice failed"));
    }
#line 3977
    return;
  }
#line 3980
  if (pty_preopen) {
    {
#line 3982
    slave = open((char const   *)m, 258);
    }
#line 3982
    if (slave == -1) {
      {
#line 3984
      __cil_tmp10 = __errno_location();
#line 3984
      Msg(*__cil_tmp10, (char const   *)((char *)"%s"), m);
#line 3985
      close(display->d_blankerev.fd);
#line 3986
      display->d_blankerev.fd = - 1;
      }
#line 3987
      return;
    }
  }
  {
#line 3991
  pid = fork();
  }
  {
#line 3993
  if (pid == - 1) {
#line 3993
    goto case_exp;
  }
#line 3999
  if (pid == 0) {
#line 3999
    goto case_0;
  }
#line 4070
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 3994
  __cil_tmp12 = __errno_location();
#line 3994
  Msg(*__cil_tmp12, (char const   *)((char *)"fork"));
  }
  {
#line 3995
  close(display->d_blankerev.fd);
#line 3996
  display->d_blankerev.fd = - 1;
#line 3997
  close(slave);
  }
#line 3998
  return;
  case_0: /* CIL Label */ 
#line 4000
  displays = (struct display *)0;
  {
#line 4001
  ServerSocket = - 1;
#line 4003
  xsignal(13, (__sighandler_t )0);
#line 4005
  __cil_tmp14 = setuid((__uid_t )real_uid);
  }
  {
#line 4005
  __cil_tmp13 = setgid((__gid_t )real_gid);
  }
#line 4005
  if (__cil_tmp13) {
    {
    {
#line 4006
    __cil_tmp15 = __errno_location();
    }
    {
#line 4006
    Panic(*__cil_tmp15, (char const   *)((char *)"setuid/setgid"));
    }
    }
  } else
#line 4005
  if (__cil_tmp14) {
    {
    {
#line 4006
    __cil_tmp15 = __errno_location();
    }
    {
#line 4006
    Panic(*__cil_tmp15, (char const   *)((char *)"setuid/setgid"));
    }
    }
  }
  {
#line 4007
  eff_uid = real_uid;
#line 4008
  eff_gid = real_gid;
#line 4009
  brktty(display->d_userfd);
#line 4010
  freetty();
  }
#line 4015
  if (slave != -1) {
    {
#line 4017
    close(0);
#line 4018
    dup(slave);
#line 4019
    close(slave);
#line 4020
    closeallfiles(display->d_blankerev.fd);
#line 4021
    slave = dup(0);
    }
  } else {
    {
#line 4024
    closeallfiles(display->d_blankerev.fd);
    }
  }
  {
#line 4038
  close(0);
#line 4039
  close(1);
#line 4040
  close(2);
#line 4041
  __cil_tmp17 = open((char const   *)m, 2);
  }
#line 4041
  if (__cil_tmp17) {
    {
#line 4042
    __cil_tmp18 = __errno_location();
#line 4042
    Panic(*__cil_tmp18, (char const   *)((char *)"Cannot open %s"), m);
    }
  }
  {
#line 4043
  dup(0);
#line 4044
  dup(0);
#line 4045
  close(display->d_blankerev.fd);
  }
#line 4046
  if (slave != -1) {
    {
#line 4047
    close(slave);
    }
  }
  {
#line 4048
  InitPTY(0);
#line 4049
  fgtty(0);
#line 4050
  SetTTY(0, & display->d_OldMode);
#line 4051
  np = NewEnv + 3;
#line 4052
  __cil_tmp19 = np;
#line 4052
  np ++;
#line 4052
  *__cil_tmp19 = *(NewEnv + 0);
#line 4053
  __cil_tmp20 = np;
#line 4053
  np ++;
#line 4053
  *__cil_tmp20 = (char *)termname;
#line 4055
  glwz.ws_col = (unsigned short )display->d_width;
#line 4056
  glwz.ws_row = (unsigned short )display->d_height;
#line 4057
  __cil_tmp21 = ioctl(0, (unsigned long )21524, (char *)(& glwz));
  }
  {
#line 4066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4066
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4067
  execvpe((char const   *)*cmdv, (char * const  [])cmdv, (char * const  [])(NewEnv + 3));
  }
  {
#line 4068
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4068
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4069
  __cil_tmp22 = __errno_location();
#line 4069
  Panic(*__cil_tmp22, (char const   *)((char *)"Cannot exec \'%s\'"), *cmdv);
  }
  switch_default: /* CIL Label */ 
#line 4071
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 4073
  display->d_blankerpid = pid;
#line 4074
  evenq(& display->d_blankerev);
#line 4075
  display->d_blocked = 4;
#line 4076
  ClearAll();
#line 4077
  close(slave);
  }
  return;
}
}
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 146 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 500
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 654
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 225
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 282 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.h"
char strnomem[] ;
#line 47 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void QueryMsg(int err , char const   *fmt  , ...) ;
#line 48
void Dummy(int err , char const   *fmt  , ...) ;
#line 56
void MakeNewEnv(void) ;
#line 57
char *MakeWinMsg(char *s , struct win *win , int esc ) ;
#line 59
int AddWinMsgRend(char const   *str , int r ) ;
#line 66
void setbacktick(int num , int lifespan , int tick , char **cmdv ) ;
#line 69
void ResetAnsiState(struct win *p ) ;
#line 71
void ResetCharsets(struct win *p ) ;
#line 72
void WriteString(struct win *wp , char *buf , int len ) ;
#line 73
void ChangeAKA(struct win *p , char *s , int l ) ;
#line 75
int GetAnsiStatus(struct win *w , char *buf ) ;
#line 77
void WBell(struct win *p , int visual ) ;
#line 86
void RcLine(char *ubuf , int ubufl ) ;
#line 89
void WriteFile(struct acluser *user , char *fn , int dump ) ;
#line 90
char *ReadFile(char *fn , int *lenp ) ;
#line 91
void KillBuffers(void) ;
#line 95
void do_source(char *rcfilename ) ;
#line 104
void SendBreak(struct win *wp , int n , int closeopen ) ;
#line 105
int TtyGrabConsole(int fd , int on , char *rc_name___0 ) ;
#line 106
char *TtyGetModemStatus(int fd , char *buf ) ;
#line 119
int GetHistory(void) ;
#line 120
void MarkRoutine(void) ;
#line 124
void MakePaster(struct paster *pa , char *buf , int len , int bufiscopy ) ;
#line 132
void inp_setprompt(char *p , char *s ) ;
#line 138
void display_help(char *class , struct action *ktabp ) ;
#line 139
void display_copyright(void) ;
#line 141
void display_bindkey(char *title , struct action *tab ) ;
#line 150
int MakeWindow(struct NewWindow *newwin ) ;
#line 152
void FreeWindow(struct win *wp ) ;
#line 154
int winexec(char **av ) ;
#line 155
void FreePseudowin(struct win *w ) ;
#line 158
int DoStartLog(struct win *w , char *buf , int bufsize ) ;
#line 177
void SlotToggle(int how ) ;
#line 199
void InitKeytab(void) ;
#line 204
void DoProcess(struct win *p , char **bufp , int *lenp , struct paster *pa ) ;
#line 207
void DoCommand(char **argv , int *argl ) ;
#line 209
void KillWindow(struct win *wi ) ;
#line 211
int Parse(char *buf , int bufl , char **args , int *argl ) ;
#line 212
void SetEscape(struct acluser *u , int e , int me ) ;
#line 213
void DoScreen(char *fn , char **av ) ;
#line 214
int IsNumColon(char *s , int base , char *p , int psize ) ;
#line 215
void ShowWindows(int where ) ;
#line 216
char *AddWindows(char *buf , int len , int flags , int where ) ;
#line 217
char *AddWindowFlags(char *buf , int len , struct win *p ) ;
#line 218
char *AddOtherUsers(char *buf , int len , struct win *p ) ;
#line 220
struct win *FindNiceWindow(struct win *wi , char *presel ) ;
#line 222
int CompileKeys(char *s , int sl , unsigned char *array ) ;
#line 227
int ParseSaveStr(struct action *act , char **var ) ;
#line 228
int ParseNum(struct action *act , int *var ) ;
#line 229
int ParseSwitch(struct action *act , int *var ) ;
#line 230
int ParseAttrColor(char *s1 , char *s2 , int msgok ) ;
#line 237
char *MakeTermcap(int aflag ) ;
#line 238
char *gettermcapstring(char *s ) ;
#line 240
int remap(int n , int map ) ;
#line 241
void CheckEscape(void) ;
#line 324
int ChangeWindowSize(struct win *p , int wi , int he , int hi ) ;
#line 327
char *xrealloc(char *mem , int len ) ;
#line 329
void ResizeLayer(struct layer *l , int wi , int he , struct display *norefdisp ) ;
#line 330
int MayResizeLayer(struct layer *l ) ;
#line 346
int chsock(void) ;
#line 356
char *SaveStrn(char const   *str , int n ) ;
#line 363
char *Filename(char *s ) ;
#line 384
int AddXChars(char *buf , int len , char *str ) ;
#line 385
void xsetenv(char *var , char *value ) ;
#line 60 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
char *rc_name ;
#line 61
char *home ;
#line 62
char *BellString ;
#line 62
char *ActivityString ;
#line 62
char *ShellProg ;
#line 62
char *ShellArgs[2] ;
#line 63
char *timestring ;
#line 66
int queryflag ;
#line 67
char *hardcopydir ;
#line 67
char *screenlogfile ;
#line 67
char *logtstamp_string ;
#line 68
int log_flush ;
#line 68
int logtstamp_on ;
#line 68
int logtstamp_after ;
#line 69
char *VisualBellString ;
#line 70
int VBellWait ;
#line 70
int SilenceWait ;
#line 71
char *SockName ;
#line 72
int TtyMode ;
#line 72
int auto_detach ;
#line 72
int use_altscreen ;
#line 73
int iflag ;
#line 75
int visual_bell ;
#line 81
char *printcmd ;
#line 82
int default_startup ;
#line 86
int ZombieKey_destroy ;
#line 87
extern int ZombieKey_resurrect ;
#line 88
int ZombieKey_onerror ;
#line 92
int separate_sids ;
#line 93
struct NewWindow nwin_undef ;
#line 95
int join_with_cr ;
#line 96
int compacthist ;
#line 97
int search_ic ;
#line 101
unsigned char mark_key_tab[256] ;
#line 102
char *BufferFile ;
#line 105
char *PowDetachString ;
#line 110
extern struct term term[] ;
#line 118
int VerboseCreate ;
#line 126
static int CheckArgNum(int nr , char **args ) ;
#line 127
static void ClearAction(struct action *act ) ;
#line 128
static void SaveAction(struct action *act , int nr , char **args , int *argl ) ;
#line 129
static int NextWindow(void) ;
#line 130
static int PreviousWindow(void) ;
#line 131
static int MoreWindows(void) ;
#line 132
void CollapseWindowlist(void) ;
#line 133
static void LogToggle(int on ) ;
#line 134
static void ShowInfo(void) ;
#line 135
static void ShowDInfo(void) ;
#line 136
static struct win *WindowByName(char *s ) ;
#line 137
static int WindowByNumber(char *str ) ;
#line 138
static int ParseOnOff(struct action *act , int *var ) ;
#line 139
static int ParseWinNum(struct action *act , int *var ) ;
#line 140
static int ParseBase(struct action *act , char *p , int *var , int base , char *bname ) ;
#line 141
static int ParseNum1000(struct action *act , int *var ) ;
#line 142
static char **SaveArgs(char **args ) ;
#line 143
static int IsNum(char *s , int base ) ;
#line 144
static void Colonfin(char *buf , int len , char *data ) ;
#line 145
static void InputSelect(void) ;
#line 146
static void InputSetenv(char *arg ) ;
#line 147
static void InputAKA(void) ;
#line 149
static int InputSu(struct win *w , struct acluser **up , char *name ) ;
#line 150
static void su_fin(char *buf , int len , char *data ) ;
#line 152
static void AKAfin(char *buf , int len , char *data ) ;
#line 154
static void copy_reg_fn(char *buf , int len , char *data ) ;
#line 155
static void ins_reg_fn(char *buf , int len , char *data ) ;
#line 157
static void process_fn(char *buf , int len , char *data ) ;
#line 159
static void pass1(char *buf , int len , char *data ) ;
#line 160
static void pass2(char *buf , int len , char *data ) ;
#line 163
static void pow_detach_fn(char *buf , int len , char *data ) ;
#line 165
static void digraph_fn(char *buf , int len , char *data ) ;
#line 166
static int digraph_find(char const   *buf ) ;
#line 167
static void confirm_fn(char *buf , int len , char *data ) ;
#line 168
static int IsOnDisplay(struct win *wi ) ;
#line 169
static void ResizeRegions(char *arg , int flags ) ;
#line 170
static void ResizeFin(char *buf , int len , char *data ) ;
#line 171
static struct action *FindKtab(char *class , int create ) ;
#line 172
static void SelectFin(char *buf , int len , char *data ) ;
#line 173
static void SelectLayoutFin(char *buf , int len , char *data ) ;
#line 174
static void ShowWindowsX(char *str ) ;
#line 179
struct win *console_window ;
#line 184
char screenterm[33] ;
#line 184
char HostName[768] ;
#line 184
char version[60] ;
#line 186
struct LayFuncs MarkLf ;
#line 199
char *multi ;
#line 202 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
char NullStr[]  =    "";
#line 204
struct plop plop_tab[256] ;
#line 210 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int TtyMode  =    400;
#line 211 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int hardcopy_append  =    0;
#line 212 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int all_norefresh  =    0;
#line 214 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int zmodem_mode  =    0;
#line 215
char *zmodem_sendcmd ;
#line 216
char *zmodem_recvcmd ;
#line 217 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static char *zmodes[4]  = {      (char *)"off",      (char *)"auto",      (char *)"catch",      (char *)"pass"};
#line 223
char **blankerprg ;
#line 226
struct action ktab[338] ;
#line 232
struct kclass *kclasses ;
#line 235
struct action umtab[104] ;
#line 236
struct action dmtab[104] ;
#line 237
struct action mmtab[104] ;
#line 238
struct kmap_ext *kmap_exts ;
#line 239
int kmap_extn ;
#line 240 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int maptimeout  =    300;
#line 254 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static struct digraph digraphs[513]  = 
#line 254
  {      {{(unsigned char )' ', (unsigned char )' '}, 160}, 
        {{(unsigned char )'N', (unsigned char )'S'}, 160}, 
        {{(unsigned char )'~', (unsigned char )'!'}, 161}, 
        {{(unsigned char )'!', (unsigned char )'!'}, 161}, 
        {{(unsigned char )'!', (unsigned char )'I'}, 161}, 
        {{(unsigned char )'c', (unsigned char )'|'}, 162}, 
        {{(unsigned char )'c', (unsigned char )'t'}, 162}, 
        {{(unsigned char )'$', (unsigned char )'$'}, 163}, 
        {{(unsigned char )'P', (unsigned char )'d'}, 163}, 
        {{(unsigned char )'o', (unsigned char )'x'}, 164}, 
        {{(unsigned char )'C', (unsigned char )'u'}, 164}, 
        {{(unsigned char )'C', (unsigned char )'u'}, 164}, 
        {{(unsigned char )'E', (unsigned char )'u'}, 164}, 
        {{(unsigned char )'Y', (unsigned char )'-'}, 165}, 
        {{(unsigned char )'Y', (unsigned char )'e'}, 165}, 
        {{(unsigned char )'|', (unsigned char )'|'}, 166}, 
        {{(unsigned char )'B', (unsigned char )'B'}, 166}, 
        {{(unsigned char )'p', (unsigned char )'a'}, 167}, 
        {{(unsigned char )'S', (unsigned char )'E'}, 167}, 
        {{(unsigned char )'\"', (unsigned char )'\"'}, 168}, 
        {{(unsigned char )'\'', (unsigned char )':'}, 168}, 
        {{(unsigned char )'c', (unsigned char )'O'}, 169}, 
        {{(unsigned char )'C', (unsigned char )'o'}, 169}, 
        {{(unsigned char )'a', (unsigned char )'-'}, 170}, 
        {{(unsigned char )'<', (unsigned char )'<'}, 171}, 
        {{(unsigned char )'-', (unsigned char )','}, 172}, 
        {{(unsigned char )'N', (unsigned char )'O'}, 172}, 
        {{(unsigned char )'-', (unsigned char )'-'}, 173}, 
        {{(unsigned char )'r', (unsigned char )'O'}, 174}, 
        {{(unsigned char )'R', (unsigned char )'g'}, 174}, 
        {{(unsigned char )'-', (unsigned char )'='}, 175}, 
        {{(unsigned char )'\'', (unsigned char )'m'}, 175}, 
        {{(unsigned char )'~', (unsigned char )'o'}, 176}, 
        {{(unsigned char )'D', (unsigned char )'G'}, 176}, 
        {{(unsigned char )'+', (unsigned char )'-'}, 177}, 
        {{(unsigned char )'2', (unsigned char )'2'}, 178}, 
        {{(unsigned char )'2', (unsigned char )'S'}, 178}, 
        {{(unsigned char )'3', (unsigned char )'3'}, 179}, 
        {{(unsigned char )'3', (unsigned char )'S'}, 179}, 
        {{(unsigned char )'\'', (unsigned char )'\''}, 180}, 
        {{(unsigned char )'j', (unsigned char )'u'}, 181}, 
        {{(unsigned char )'M', (unsigned char )'y'}, 181}, 
        {{(unsigned char )'p', (unsigned char )'p'}, 182}, 
        {{(unsigned char )'P', (unsigned char )'I'}, 182}, 
        {{(unsigned char )'~', (unsigned char )'.'}, 183}, 
        {{(unsigned char )'.', (unsigned char )'M'}, 183}, 
        {{(unsigned char )',', (unsigned char )','}, 184}, 
        {{(unsigned char )'\'', (unsigned char )','}, 184}, 
        {{(unsigned char )'1', (unsigned char )'1'}, 185}, 
        {{(unsigned char )'1', (unsigned char )'S'}, 185}, 
        {{(unsigned char )'o', (unsigned char )'-'}, 186}, 
        {{(unsigned char )'>', (unsigned char )'>'}, 187}, 
        {{(unsigned char )'1', (unsigned char )'4'}, 188}, 
        {{(unsigned char )'1', (unsigned char )'2'}, 189}, 
        {{(unsigned char )'3', (unsigned char )'4'}, 190}, 
        {{(unsigned char )'~', (unsigned char )'?'}, 191}, 
        {{(unsigned char )'?', (unsigned char )'?'}, 191}, 
        {{(unsigned char )'?', (unsigned char )'I'}, 191}, 
        {{(unsigned char )'A', (unsigned char )'`'}, 192}, 
        {{(unsigned char )'A', (unsigned char )'!'}, 192}, 
        {{(unsigned char )'A', (unsigned char )'\''}, 193}, 
        {{(unsigned char )'A', (unsigned char )'^'}, 194}, 
        {{(unsigned char )'A', (unsigned char )'>'}, 194}, 
        {{(unsigned char )'A', (unsigned char )'~'}, 195}, 
        {{(unsigned char )'A', (unsigned char )'?'}, 195}, 
        {{(unsigned char )'A', (unsigned char )'\"'}, 196}, 
        {{(unsigned char )'A', (unsigned char )':'}, 196}, 
        {{(unsigned char )'A', (unsigned char )'@'}, 197}, 
        {{(unsigned char )'A', (unsigned char )'A'}, 197}, 
        {{(unsigned char )'A', (unsigned char )'E'}, 198}, 
        {{(unsigned char )'C', (unsigned char )','}, 199}, 
        {{(unsigned char )'E', (unsigned char )'`'}, 200}, 
        {{(unsigned char )'E', (unsigned char )'!'}, 200}, 
        {{(unsigned char )'E', (unsigned char )'\''}, 201}, 
        {{(unsigned char )'E', (unsigned char )'^'}, 202}, 
        {{(unsigned char )'E', (unsigned char )'>'}, 202}, 
        {{(unsigned char )'E', (unsigned char )'\"'}, 203}, 
        {{(unsigned char )'E', (unsigned char )':'}, 203}, 
        {{(unsigned char )'I', (unsigned char )'`'}, 204}, 
        {{(unsigned char )'I', (unsigned char )'!'}, 204}, 
        {{(unsigned char )'I', (unsigned char )'\''}, 205}, 
        {{(unsigned char )'I', (unsigned char )'^'}, 206}, 
        {{(unsigned char )'I', (unsigned char )'>'}, 206}, 
        {{(unsigned char )'I', (unsigned char )'\"'}, 207}, 
        {{(unsigned char )'I', (unsigned char )':'}, 207}, 
        {{(unsigned char )'D', (unsigned char )'-'}, 208}, 
        {{(unsigned char )'N', (unsigned char )'~'}, 209}, 
        {{(unsigned char )'N', (unsigned char )'?'}, 209}, 
        {{(unsigned char )'O', (unsigned char )'`'}, 210}, 
        {{(unsigned char )'O', (unsigned char )'!'}, 210}, 
        {{(unsigned char )'O', (unsigned char )'\''}, 211}, 
        {{(unsigned char )'O', (unsigned char )'^'}, 212}, 
        {{(unsigned char )'O', (unsigned char )'>'}, 212}, 
        {{(unsigned char )'O', (unsigned char )'~'}, 213}, 
        {{(unsigned char )'O', (unsigned char )'?'}, 213}, 
        {{(unsigned char )'O', (unsigned char )'\"'}, 214}, 
        {{(unsigned char )'O', (unsigned char )':'}, 214}, 
        {{(unsigned char )'/', (unsigned char )'\\'}, 215}, 
        {{(unsigned char )'*', (unsigned char )'x'}, 215}, 
        {{(unsigned char )'O', (unsigned char )'/'}, 216}, 
        {{(unsigned char )'U', (unsigned char )'`'}, 217}, 
        {{(unsigned char )'U', (unsigned char )'!'}, 217}, 
        {{(unsigned char )'U', (unsigned char )'\''}, 218}, 
        {{(unsigned char )'U', (unsigned char )'^'}, 219}, 
        {{(unsigned char )'U', (unsigned char )'>'}, 219}, 
        {{(unsigned char )'U', (unsigned char )'\"'}, 220}, 
        {{(unsigned char )'U', (unsigned char )':'}, 220}, 
        {{(unsigned char )'Y', (unsigned char )'\''}, 221}, 
        {{(unsigned char )'I', (unsigned char )'p'}, 222}, 
        {{(unsigned char )'T', (unsigned char )'H'}, 222}, 
        {{(unsigned char )'s', (unsigned char )'s'}, 223}, 
        {{(unsigned char )'s', (unsigned char )'\"'}, 223}, 
        {{(unsigned char )'a', (unsigned char )'`'}, 224}, 
        {{(unsigned char )'a', (unsigned char )'!'}, 224}, 
        {{(unsigned char )'a', (unsigned char )'\''}, 225}, 
        {{(unsigned char )'a', (unsigned char )'^'}, 226}, 
        {{(unsigned char )'a', (unsigned char )'>'}, 226}, 
        {{(unsigned char )'a', (unsigned char )'~'}, 227}, 
        {{(unsigned char )'a', (unsigned char )'?'}, 227}, 
        {{(unsigned char )'a', (unsigned char )'\"'}, 228}, 
        {{(unsigned char )'a', (unsigned char )':'}, 228}, 
        {{(unsigned char )'a', (unsigned char )'a'}, 229}, 
        {{(unsigned char )'a', (unsigned char )'e'}, 230}, 
        {{(unsigned char )'c', (unsigned char )','}, 231}, 
        {{(unsigned char )'e', (unsigned char )'`'}, 232}, 
        {{(unsigned char )'e', (unsigned char )'!'}, 232}, 
        {{(unsigned char )'e', (unsigned char )'\''}, 233}, 
        {{(unsigned char )'e', (unsigned char )'^'}, 234}, 
        {{(unsigned char )'e', (unsigned char )'>'}, 234}, 
        {{(unsigned char )'e', (unsigned char )'\"'}, 235}, 
        {{(unsigned char )'e', (unsigned char )':'}, 235}, 
        {{(unsigned char )'i', (unsigned char )'`'}, 236}, 
        {{(unsigned char )'i', (unsigned char )'!'}, 236}, 
        {{(unsigned char )'i', (unsigned char )'\''}, 237}, 
        {{(unsigned char )'i', (unsigned char )'^'}, 238}, 
        {{(unsigned char )'i', (unsigned char )'>'}, 238}, 
        {{(unsigned char )'i', (unsigned char )'\"'}, 239}, 
        {{(unsigned char )'i', (unsigned char )':'}, 239}, 
        {{(unsigned char )'d', (unsigned char )'-'}, 240}, 
        {{(unsigned char )'n', (unsigned char )'~'}, 241}, 
        {{(unsigned char )'n', (unsigned char )'?'}, 241}, 
        {{(unsigned char )'o', (unsigned char )'`'}, 242}, 
        {{(unsigned char )'o', (unsigned char )'!'}, 242}, 
        {{(unsigned char )'o', (unsigned char )'\''}, 243}, 
        {{(unsigned char )'o', (unsigned char )'^'}, 244}, 
        {{(unsigned char )'o', (unsigned char )'>'}, 244}, 
        {{(unsigned char )'o', (unsigned char )'~'}, 245}, 
        {{(unsigned char )'o', (unsigned char )'?'}, 245}, 
        {{(unsigned char )'o', (unsigned char )'\"'}, 246}, 
        {{(unsigned char )'o', (unsigned char )':'}, 246}, 
        {{(unsigned char )':', (unsigned char )'-'}, 247}, 
        {{(unsigned char )'o', (unsigned char )'/'}, 248}, 
        {{(unsigned char )'u', (unsigned char )'`'}, 249}, 
        {{(unsigned char )'u', (unsigned char )'!'}, 249}, 
        {{(unsigned char )'u', (unsigned char )'\''}, 250}, 
        {{(unsigned char )'u', (unsigned char )'^'}, 251}, 
        {{(unsigned char )'u', (unsigned char )'>'}, 251}, 
        {{(unsigned char )'u', (unsigned char )'\"'}, 252}, 
        {{(unsigned char )'u', (unsigned char )':'}, 252}, 
        {{(unsigned char )'y', (unsigned char )'\''}, 253}, 
        {{(unsigned char )'i', (unsigned char )'p'}, 254}, 
        {{(unsigned char )'t', (unsigned char )'h'}, 254}, 
        {{(unsigned char )'y', (unsigned char )'\"'}, 255}, 
        {{(unsigned char )'y', (unsigned char )':'}, 255}, 
        {{(unsigned char )'\"', (unsigned char )'['}, 196}, 
        {{(unsigned char )'\"', (unsigned char )'\\'}, 214}, 
        {{(unsigned char )'\"', (unsigned char )']'}, 220}, 
        {{(unsigned char )'\"', (unsigned char )'{'}, 228}, 
        {{(unsigned char )'\"', (unsigned char )'|'}, 246}, 
        {{(unsigned char )'\"', (unsigned char )'}'}, 252}, 
        {{(unsigned char )'\"', (unsigned char )'~'}, 223}};
#line 432 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static char *resizeprompts[]  = 
#line 432
  {      (char *)"resize # lines: ",      (char *)"resize -h # lines: ",      (char *)"resize -v # lines: ",      (char *)"resize -b # lines: ", 
        (char *)"resize -l # lines: ",      (char *)"resize -l -h # lines: ",      (char *)"resize -l -v # lines: ",      (char *)"resize -l -b # lines: "};
#line 445 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int parse_input_int(char const   *buf , int len , int *val ) 
{ 
  int x ;
  int i ;

  {
#line 450
  x = 0;
#line 451
  if (len >= 1) {
#line 451
    if ((int )((char )*buf) == 85) {
#line 451
      if ((int )((char )*(buf + 1)) == 43) {
        _L___163: /* CIL Label */ 
#line 453
        x = 0;
#line 454
        i = 2;
        {
#line 454
        while (1) {
          while_continue: /* CIL Label */ ;
#line 454
          if (! (i < len)) {
#line 454
            goto while_break;
          }
#line 456
          if ((int )((char )*(buf + i)) >= 48) {
#line 456
            if ((int )((char )*(buf + i)) <= 57) {
#line 457
              x = x * 16 | ((int )((char )*(buf + i)) - 48);
            } else {
#line 456
              goto _L___161;
            }
          } else
          _L___161: /* CIL Label */ 
#line 458
          if ((int )((char )*(buf + i)) >= 97) {
#line 458
            if ((int )((char )*(buf + i)) <= 102) {
#line 459
              x = x * 16 | ((int )((char )*(buf + i)) - 87);
            } else {
#line 458
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 460
          if ((int )((char )*(buf + i)) >= 65) {
#line 460
            if ((int )((char )*(buf + i)) <= 70) {
#line 461
              x = x * 16 | ((int )((char )*(buf + i)) - 55);
            } else {
#line 463
              return (0);
            }
          } else {
#line 463
            return (0);
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 454
        i ++;
      } else {
#line 451
        goto _L___164;
      }
    } else
    _L___164: /* CIL Label */ 
#line 451
    if ((int )((char )*buf) == 48) {
#line 451
      if ((int )((char )*(buf + 1)) == 120) {
#line 451
        goto _L___163;
      } else
#line 451
      if ((int )((char )*(buf + 1)) == 88) {
#line 451
        goto _L___163;
      } else {
#line 451
        goto _L___162;
      }
    } else {
#line 451
      goto _L___162;
    }
  } else
  _L___162: /* CIL Label */ 
#line 466
  if ((int )((char )*(buf + 0)) == 48) {
#line 468
    x = 0;
#line 469
    i = 1;
    {
#line 469
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 469
      if (! (i < len)) {
#line 469
        goto while_break___0;
      }
#line 471
      if ((int )((char )*(buf + i)) < 48) {
#line 472
        return (0);
      } else
#line 471
      if ((int )((char )*(buf + i)) > 55) {
#line 472
        return (0);
      }
#line 473
      x = x * 8 | ((int )((char )*(buf + i)) - 48);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 469
    i ++;
  } else {
#line 477
    return (0);
  }
#line 478
  *val = x;
#line 479
  return (1);
}
}
#line 484 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int enter_window_name_mode  =    0;
#line 487 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void InitKeytab(void) 
{ 
  register unsigned int i ;
  char *argarr[2] ;
  char *args[2] ;
  int tmp ;
  char *args___0[2] ;
  char arg1[10] ;
  char *args___1[2] ;
  char *args___2[2] ;
  char *args___3[2] ;
  char *args___4[2] ;

  {
#line 494
  i = (unsigned int )0;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! ((unsigned long )i < sizeof(ktab) / sizeof(*((struct action *)ktab)))) {
#line 494
      goto while_break;
    }
#line 496
    ktab[i].nr = - 1;
#line 497
    ktab[i].args = (char **)noargs;
#line 498
    ktab[i].argl = (int *)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  i ++;
#line 501
  i = (unsigned int )0;
  {
#line 501
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 501
    if (! (i < 104U)) {
#line 501
      goto while_break___0;
    }
#line 503
    umtab[i].nr = - 1;
#line 504
    umtab[i].args = (char **)noargs;
#line 505
    umtab[i].argl = (int *)0;
#line 506
    dmtab[i].nr = - 1;
#line 507
    dmtab[i].args = (char **)noargs;
#line 508
    dmtab[i].argl = (int *)0;
#line 509
    mmtab[i].nr = - 1;
#line 510
    mmtab[i].args = (char **)noargs;
#line 511
    mmtab[i].argl = (int *)0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 501
  i ++;
#line 513
  argarr[1] = (char *)0;
#line 514
  i = (unsigned int )0;
  {
#line 514
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 514
    if (! (i < 82U)) {
#line 514
      goto while_break___1;
    }
#line 516
    if (i + 106U < 106U) {
#line 517
      goto while_continue___1;
    }
#line 518
    if (i + 106U >= 188U) {
#line 519
      goto while_continue___1;
    }
#line 520
    if (kmapdef[i] == (char *)0) {
#line 521
      goto while_continue___1;
    }
    {
#line 522
    argarr[0] = kmapdef[i];
#line 523
    SaveAction(((struct action *)dmtab + i) + 0, 160, (char **)argarr, (int *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 514
  i ++;
#line 525
  i = (unsigned int )0;
  {
#line 525
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 525
    if (! (i < 22U)) {
#line 525
      goto while_break___2;
    }
#line 527
    if (i + 166U < 166U) {
#line 528
      goto while_continue___2;
    }
#line 529
    if (i + 166U >= 188U) {
#line 530
      goto while_continue___2;
    }
#line 531
    if (kmapadef[i] == (char *)0) {
#line 532
      goto while_continue___2;
    }
    {
#line 533
    argarr[0] = kmapadef[i];
#line 534
    SaveAction(((struct action *)dmtab + i) + 82, 160, (char **)argarr, (int *)0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 525
  i ++;
#line 536
  i = (unsigned int )0;
  {
#line 536
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 536
    if (! (i < 64U)) {
#line 536
      goto while_break___3;
    }
#line 538
    if (i + 106U < 106U) {
#line 539
      goto while_continue___3;
    }
#line 540
    if (i + 106U >= 188U) {
#line 541
      goto while_continue___3;
    }
#line 542
    if (kmapmdef[i] == (char *)0) {
#line 543
      goto while_continue___3;
    }
    {
#line 544
    argarr[0] = kmapmdef[i];
#line 545
    argarr[1] = (char *)0;
#line 546
    SaveAction(((struct action *)mmtab + i) + 0, 160, (char **)argarr, (int *)0);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 536
  i ++;
#line 550
  ktab['h'].nr = 84;
#line 552
  ktab[26].nr = 162;
#line 552
  ktab['z'].nr = ktab[26].nr;
#line 554
  ktab[3].nr = 143;
#line 554
  ktab['c'].nr = ktab[3].nr;
#line 555
  ktab[14].nr = 117;
#line 555
  ktab['n'].nr = ktab[14].nr;
#line 555
  ktab[0].nr = ktab['n'].nr;
#line 555
  ktab[' '].nr = ktab[0].nr;
#line 557
  ktab['N'].nr = 119;
#line 558
  ktab[16].nr = 130;
#line 558
  ktab['p'].nr = ktab[16].nr;
#line 558
  ktab[127].nr = ktab['p'].nr;
#line 558
  ktab[8].nr = ktab[127].nr;
#line 559
  ktab[11].nr = 96;
#line 559
  ktab['k'].nr = ktab[11].nr;
#line 560
  ktab[12].nr = 136;
#line 560
  ktab['l'].nr = ktab[12].nr;
#line 561
  ktab[23].nr = 181;
#line 561
  ktab['w'].nr = ktab[23].nr;
#line 562
  ktab['v'].nr = 177;
#line 563
  ktab[22].nr = 68;
#line 564
  ktab[17].nr = 186;
#line 564
  ktab['q'].nr = ktab[17].nr;
#line 565
  ktab[19].nr = 185;
#line 565
  ktab['s'].nr = ktab[19].nr;
#line 566
  ktab[20].nr = 167;
#line 566
  ktab['t'].nr = ktab[20].nr;
#line 567
  ktab[9].nr = 94;
#line 567
  ktab['i'].nr = ktab[9].nr;
#line 568
  ktab[13].nr = 97;
#line 568
  ktab['m'].nr = ktab[13].nr;
#line 569
  ktab['A'].nr = 168;
#line 571
  ktab['L'].nr = 103;
#line 573
  ktab[','].nr = 99;
#line 574
  ktab['W'].nr = 179;
#line 575
  ktab['.'].nr = 71;
#line 576
  ktab[28].nr = 133;
#line 578
  ktab[4].nr = 67;
#line 578
  ktab['d'].nr = ktab[4].nr;
#line 580
  ktab['D'].nr = 128;
#line 583
  ktab[18].nr = 182;
#line 583
  ktab['r'].nr = ktab[18].nr;
#line 584
  ktab[6].nr = 79;
#line 584
  ktab['f'].nr = ktab[6].nr;
#line 585
  ktab['C'].nr = 32;
#line 586
  ktab['Z'].nr = 141;
#line 587
  ktab['H'].nr = 101;
#line 588
  ktab['M'].nr = 111;
#line 589
  ktab['?'].nr = 89;
#line 591
  ktab['*'].nr = 70;
#line 595
  args[0] = (char *)"-";
#line 596
  args[1] = (char *)((void *)0);
#line 597
  SaveAction((struct action *)ktab + 45, 145, (char **)args, (int *)0);
#line 599
  i = (unsigned int )0;
  }
  {
#line 599
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 599
    if (! (i < (unsigned int )tmp)) {
#line 599
      goto while_break___4;
    }
    {
#line 602
    args___0[0] = (char *)arg1;
#line 603
    args___0[1] = (char *)0;
#line 604
    sprintf((char *)arg1, (char const   *)((char *)"%d"), i);
#line 605
    SaveAction(((struct action *)ktab + 48) + i, 145, (char **)args___0, (int *)0);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 599
  i ++;
#line 607
  ktab['\''].nr = 145;
#line 610
  args___1[0] = (char *)"-b";
#line 611
  args___1[1] = (char *)0;
#line 612
  SaveAction((struct action *)ktab + 34, 180, (char **)args___1, (int *)0);
#line 614
  ktab[7].nr = 173;
#line 615
  ktab[':'].nr = 34;
#line 617
  ktab[27].nr = 38;
#line 617
  ktab['['].nr = ktab[27].nr;
#line 620
  args___2[0] = (char *)".";
#line 621
  args___2[1] = (char *)0;
#line 622
  SaveAction((struct action *)ktab + 93, 125, (char **)args___2, (int *)0);
#line 623
  SaveAction((struct action *)ktab + 29, 125, (char **)args___2, (int *)0);
#line 625
  ktab['{'].nr = 90;
#line 626
  ktab['}'].nr = 90;
#line 627
  ktab['>'].nr = 183;
#line 628
  ktab['<'].nr = 134;
#line 629
  ktab['='].nr = 139;
#line 632
  ktab['D'].nr = 128;
#line 635
  ktab[24].nr = 100;
#line 635
  ktab['x'].nr = ktab[24].nr;
#line 637
  ktab[2].nr = 21;
#line 637
  ktab['b'].nr = ktab[2].nr;
#line 638
  ktab['B'].nr = 127;
#line 639
  ktab['_'].nr = 151;
#line 640
  ktab['S'].nr = 158;
#line 641
  ktab['Q'].nr = 121;
#line 642
  ktab['X'].nr = 138;
#line 643
  ktab['F'].nr = 78;
#line 644
  ktab['\t'].nr = 80;
#line 647
  args___3[0] = (char *)"prev";
#line 648
  args___3[1] = (char *)0;
#line 649
  SaveAction((((struct action *)ktab + 140) - 106) + 256, 80, (char **)args___3, (int *)0);
#line 653
  args___4[0] = (char *)"-v";
#line 654
  args___4[1] = (char *)0;
#line 655
  SaveAction((struct action *)ktab + 124, 158, (char **)args___4, (int *)0);
  }
#line 658
  if (DefaultEsc >= 0) {
    {
#line 660
    ClearAction(& ktab[DefaultEsc]);
#line 661
    ktab[DefaultEsc].nr = 122;
    }
  }
#line 663
  if (DefaultMetaEsc >= 0) {
    {
#line 665
    ClearAction(& ktab[DefaultMetaEsc]);
#line 666
    ktab[DefaultMetaEsc].nr = 110;
    }
  }
#line 669
  idleaction.nr = 19;
#line 670
  idleaction.args = (char **)noargs;
#line 671
  idleaction.argl = (int *)0;
  return;
}
}
#line 675 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static struct action *FindKtab(char *class , int create ) 
{ 
  struct kclass *kp ;
  struct kclass **kpp ;
  int i ;
  int __cil_tmp6 ;
  size_t __cil_tmp7 ;
  void *__cil_tmp8 ;

  {
#line 682
  if (class == (char *)0) {
#line 683
    return ((struct action *)ktab);
  }
#line 684
  kpp = & kclasses;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! (kp != (struct kclass *)0)) {
#line 684
      goto while_break;
    }
    {
#line 685
    __cil_tmp6 = strcmp((char const   *)kp->name, (char const   *)class);
    }
#line 685
    if (! __cil_tmp6) {
#line 686
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 684
  kpp = & kp->next;
#line 687
  if (kp == (struct kclass *)0) {
#line 689
    if (! create) {
#line 690
      return ((struct action *)0);
    }
    {
#line 691
    __cil_tmp7 = strlen((char const   *)class);
    }
#line 691
    if (__cil_tmp7 > 80UL) {
      {
#line 693
      Msg(0, (char const   *)((char *)"Command class name too long."));
      }
#line 694
      return ((struct action *)0);
    }
    {
#line 696
    __cil_tmp8 = malloc(sizeof(*kp));
#line 696
    kp = (struct kclass *)__cil_tmp8;
    }
#line 697
    if (kp == (struct kclass *)0) {
      {
#line 699
      Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
      }
#line 700
      return ((struct action *)0);
    }
    {
#line 702
    kp->name = SaveStr((char const   *)class);
#line 703
    i = 0;
    }
    {
#line 703
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 703
      if (! (i < (int )(sizeof(kp->ktab) / sizeof(*((struct action *)kp->ktab))))) {
#line 703
        goto while_break___0;
      }
#line 705
      kp->ktab[i].nr = - 1;
#line 706
      kp->ktab[i].args = (char **)noargs;
#line 707
      kp->ktab[i].argl = (int *)0;
#line 708
      kp->ktab[i].quiet = 0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 703
    i ++;
#line 710
    kp->next = (struct kclass *)0;
#line 711
    *kpp = kp;
  }
#line 713
  return ((struct action *)kp->ktab);
}
}
#line 717 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void ClearAction(struct action *act ) 
{ 
  char **p ;

  {
#line 722
  if (act->nr == -1) {
#line 723
    return;
  }
#line 724
  act->nr = - 1;
#line 725
  if (act->args == (char **)noargs) {
#line 726
    return;
  }
#line 727
  p = act->args;
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 727
    if (! *p) {
#line 727
      goto while_break;
    }
    {
#line 728
    free((void *)*p);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 727
  p ++;
#line 729
  free((void *)((char *)act->args));
#line 730
  act->args = (char **)noargs;
#line 731
  act->argl = (int *)0;
  }
  return;
}
}
#line 747 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void ProcessInput(char *ibuf , int ilen ) 
{ 
  int ch ;
  int slen ;
  unsigned char *s ;
  unsigned char *q ;
  int i ;
  int l ;
  char *p ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 756
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 757
  if (display == (struct display *)0) {
#line 758
    return;
  } else
#line 757
  if (ilen == 0) {
#line 758
    return;
  }
#line 759
  if (display->d_seql) {
    {
#line 760
    evdeq(& display->d_mapev);
    }
  }
#line 761
  slen = ilen;
#line 762
  s = (unsigned char *)ibuf;
  {
#line 763
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 763
    if (! (__cil_tmp10 > 0)) {
#line 763
      goto while_break___0;
    }
#line 765
    __cil_tmp11 = s;
#line 765
    s ++;
#line 765
    ch = (int )*__cil_tmp11;
#line 766
    if (display->d_dontmap) {
#line 768
      display->d_dontmap = 0;
#line 769
      goto while_continue___0;
    } else
#line 766
    if (! display->d_nseqs) {
#line 768
      display->d_dontmap = 0;
#line 769
      goto while_continue___0;
    }
    {
#line 771
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 771
      if (! 1) {
#line 771
        goto while_break___1;
      }
      {
#line 773
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 773
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 774
      if ((int )*(display->d_seqp) != ch) {
#line 776
        l = (int )*(display->d_seqp + ((int )*(display->d_seqp + (- display->d_seql - 1)) + 1));
#line 777
        if (l) {
#line 779
          display->d_seqp += l * 2 + 4;
          {
#line 780
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 780
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 781
          goto while_continue___1;
        }
        {
#line 783
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 783
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 784
        display->d_mapdefault = 0;
#line 785
        l = display->d_seql;
#line 786
        p = (char *)display->d_seqp - l;
#line 787
        display->d_seql = 0;
#line 788
        display->d_seqp = display->d_kmaps + 3;
#line 789
        if (l == 0) {
#line 790
          goto while_break___1;
        }
#line 791
        q = display->d_seqh;
#line 791
        if (q != (unsigned char *)0) {
#line 793
          display->d_seqh = (unsigned char *)0;
#line 794
          i = ((int )*(q + 0) << 8) | (int )*(q + 1);
#line 795
          i &= ~ 16384;
          {
#line 796
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 796
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 797
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 797
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 798
          __cil_tmp12 = StuffKey(i);
          }
#line 798
          if (__cil_tmp12) {
            {
#line 799
            ProcessInput2((char *)q + 3, (int )*(q + 2));
            }
          }
#line 800
          if (display == (struct display *)0) {
#line 801
            return;
          }
#line 802
          l -= (int )*(q + 2);
#line 803
          p += (int )*(q + 2);
        } else {
#line 806
          display->d_dontmap = 1;
        }
        {
#line 807
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 807
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 808
        ProcessInput(p, l);
        }
#line 809
        if (display == (struct display *)0) {
#line 810
          return;
        }
        {
#line 811
        evdeq(& display->d_mapev);
        }
#line 812
        goto while_continue___1;
      }
#line 814
      __cil_tmp13 = display->d_seql;
#line 814
      (display->d_seql) ++;
#line 814
      if (__cil_tmp13 == 0) {
#line 817
        slen -= ilen + 1;
        {
#line 818
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 818
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 819
        if (slen) {
          {
#line 820
          ProcessInput2(ibuf, slen);
          }
        }
#line 821
        if (display == (struct display *)0) {
#line 822
          return;
        }
#line 823
        display->d_seqh = (unsigned char *)0;
      }
#line 825
      ibuf = (char *)s;
#line 826
      slen = ilen;
#line 827
      (display->d_seqp) ++;
#line 828
      l = display->d_seql;
      {
#line 829
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 829
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 830
      if (l == (int )*(display->d_seqp + (- l - 1))) {
#line 832
        if ((int )*(display->d_seqp + l) != l) {
          {
#line 834
          q = (display->d_seqp + 1) + l;
#line 835
          __cil_tmp15 = bcmp((void const   *)(display->d_seqp - l), (void const   *)(q + 3),
                             (unsigned long )l);
          }
#line 835
          if (display->d_kmaps + display->d_nseqs > q) {
#line 835
            if ((int )*(q + 2) > l) {
#line 835
              if (! __cil_tmp15) {
                {
#line 837
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 837
                  goto while_break___10;
                }
                while_break___10: /* CIL Label */ ;
                }
#line 838
                display->d_seqh = (display->d_seqp - 3) - l;
#line 839
                display->d_seqp = (q + 3) + l;
#line 840
                goto while_break___1;
              }
            }
          }
        }
#line 843
        i = ((int )*(display->d_seqp + (- l - 3)) << 8) | (int )*(display->d_seqp + (- l - 2));
#line 844
        i &= ~ 16384;
        {
#line 845
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 845
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 846
        p = (char *)display->d_seqp - l;
        {
#line 847
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 847
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 848
        display->d_seql = 0;
#line 849
        display->d_seqp = display->d_kmaps + 3;
#line 850
        display->d_seqh = (unsigned char *)0;
#line 851
        __cil_tmp16 = StuffKey(i);
        }
#line 851
        if (__cil_tmp16) {
          {
#line 852
          ProcessInput2(p, l);
          }
        }
#line 853
        if (display == (struct display *)0) {
#line 854
          return;
        }
      }
#line 856
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 859
  if (display->d_seql) {
    {
#line 861
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 861
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 862
    l = display->d_seql;
#line 863
    s = display->d_seqp;
    {
#line 863
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 863
      if (! 1) {
#line 863
        goto while_break___14;
      }
#line 865
      if ((int )*(s + (- l - 3)) & (16384 >> 8)) {
#line 866
        goto while_break___14;
      }
#line 867
      i = (int )*(s + ((int )*(s + (- l - 1)) + 1));
#line 867
      if (i == 0) {
        {
#line 869
        SetTimeout(& display->d_mapev, maptimeout);
#line 870
        evenq(& display->d_mapev);
        }
#line 871
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 863
    s += i * 2 + 4;
  }
  {
#line 875
  ProcessInput2(ibuf, slen);
  }
  return;
}
}
#line 888 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void ProcessInput2(char *ibuf , int ilen ) 
{ 
  char *s ;
  int ch ;
  int slen ;
  struct action *ktabp ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  struct action *tmp ;
  int __cil_tmp10 ;

  {
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 896
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 897
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 897
    if (! (ilen && display)) {
#line 897
      goto while_break___0;
    }
    {
#line 899
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 899
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 900
    flayer = (display->d_forecv)->c_layer;
#line 901
    fore = display->d_fore;
#line 902
    slen = ilen;
#line 903
    s = ibuf;
#line 904
    if (! display->d_ESCseen) {
      {
#line 906
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 906
        if (! (ilen > 0)) {
#line 906
          goto while_break___2;
        }
#line 908
        __cil_tmp7 = s;
#line 908
        s ++;
#line 908
        if ((int )((unsigned char )*__cil_tmp7) == (display->d_user)->u_Esc) {
#line 909
          goto while_break___2;
        }
#line 910
        __cil_tmp8 = ilen;
#line 910
        ilen --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 912
      slen -= ilen;
#line 913
      if (slen) {
        {
#line 914
        DoProcess(fore, & ibuf, & slen, (struct paster *)0);
        }
      }
#line 915
      ilen --;
#line 915
      if (ilen == 0) {
        {
#line 917
        display->d_ESCseen = (struct action *)ktab;
#line 918
        WindowChanged(fore, 'E');
        }
      }
    }
#line 921
    if (ilen <= 0) {
#line 922
      return;
    }
#line 923
    if (display->d_ESCseen) {
#line 923
      tmp = display->d_ESCseen;
    } else {
#line 923
      tmp = (struct action *)ktab;
    }
#line 923
    ktabp = tmp;
#line 924
    if (display->d_ESCseen) {
      {
#line 926
      display->d_ESCseen = (struct action *)0;
#line 927
      WindowChanged(fore, 'E');
      }
    }
#line 929
    ch = (int )((unsigned char )*s);
#line 937
    if (ch == (display->d_user)->u_Esc) {
#line 938
      ch = DefaultEsc;
    } else
#line 939
    if (ch == (display->d_user)->u_MetaEsc) {
#line 940
      ch = DefaultMetaEsc;
    }
#line 942
    if (ch >= 0) {
      {
#line 943
      DoAction(& *(ktabp + ch), ch);
      }
    }
#line 944
    ibuf = s + 1;
#line 945
    __cil_tmp10 = ilen;
#line 945
    ilen --;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 950 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void DoProcess(struct win *p , char **bufp , int *lenp , struct paster *pa ) 
{ 
  int oldlen ;
  struct display *d ;

  {
#line 957
  d = display;
#line 961
  if (pa) {
#line 961
    if (*lenp > 1) {
#line 961
      if (p) {
#line 961
        if (p->w_slowpaste) {
          {
#line 964
          SetTimeout(& p->w_paster.pa_slowev, p->w_slowpaste);
#line 965
          evenq(& p->w_paster.pa_slowev);
          }
#line 966
          return;
        }
      }
    }
  }
  {
#line 969
  while (1) {
    while_continue: /* CIL Label */ ;
#line 969
    if (! (flayer && *lenp)) {
#line 969
      goto while_break;
    }
#line 972
    if (! pa) {
#line 972
      if (p) {
#line 972
        if (p->w_paster.pa_pastelen) {
#line 972
          if (flayer == p->w_paster.pa_pastelayer) {
            {
#line 974
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 974
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 975
            WBell(p, visual_bell);
#line 976
            *bufp += *lenp;
#line 977
            *lenp = 0;
#line 978
            display = d;
            }
#line 979
            return;
          }
        }
      }
    }
    {
#line 982
    oldlen = *lenp;
#line 983
    (*((flayer->l_layfn)->lf_LayProcess))(bufp, lenp);
    }
#line 985
    if (pa) {
#line 985
      if (! pa->pa_pastelayer) {
#line 986
        goto while_break;
      }
    }
#line 988
    if (*lenp == oldlen) {
#line 990
      if (pa) {
#line 992
        display = d;
#line 993
        return;
      }
      {
#line 996
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 996
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 997
      WBell(p, visual_bell);
      }
#line 998
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1001
  *bufp += *lenp;
#line 1002
  *lenp = 0;
#line 1003
  display = d;
#line 1005
  if (pa) {
#line 1005
    if (pa->pa_pastelen == 0) {
      {
#line 1006
      FreePaster(pa);
      }
    }
  }
  return;
}
}
#line 1011 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int FindCommnr(char const   *str ) 
{ 
  int x ;
  int m ;
  int l ;
  int r ;

  {
#line 1014
  l = 0;
#line 1014
  r = 189;
  {
#line 1015
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1015
    if (! (l <= r)) {
#line 1015
      goto while_break;
    }
    {
#line 1017
    m = (l + r) / 2;
#line 1018
    x = strcmp(str, (char const   *)comms[m].name);
    }
#line 1019
    if (x > 0) {
#line 1020
      l = m + 1;
    } else
#line 1021
    if (x < 0) {
#line 1022
      r = m - 1;
    } else {
#line 1024
      return (m);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1026
  return (- 1);
}
}
#line 1030 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int CheckArgNum(int nr , char **args ) 
{ 
  int i ;
  int n ;
  static char *argss[] ;
  static char *orformat[] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1044
  n = comms[nr].flags & 3;
#line 1045
  i = 0;
  {
#line 1045
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1045
    if (! *(args + i)) {
#line 1045
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 1045
  i ++;
#line 1047
  if (comms[nr].flags & (1 << 5)) {
#line 1049
    if (i < n) {
#line 1051
      if (n != 1) {
#line 1051
        tmp = (char *)"s";
      } else {
#line 1051
        tmp = (char *)"";
      }
      {
#line 1051
      Msg(0, (char const   *)((char *)"%s: %s: at least %s argument%s required"),
          rc_name, comms[nr].name, argss[n], tmp);
      }
#line 1053
      return (- 1);
    }
  } else
#line 1056
  if (comms[nr].flags & (1 << 2)) {
#line 1056
    if (comms[nr].flags & (1 << 3)) {
#line 1056
      if (comms[nr].flags & (1 << 4)) {
#line 1060
        if (i != n) {
#line 1060
          if (i != n + 1) {
#line 1060
            if (i != n + 2) {
#line 1060
              if (i != n + 3) {
                {
#line 1062
                Msg(0, (char const   *)orformat[3], rc_name, comms[nr].name, argss[n],
                    argss[n + 1], argss[n + 2], argss[n + 3], (char *)"");
                }
#line 1064
                return (- 1);
              }
            }
          }
        }
      } else {
#line 1056
        goto _L___167;
      }
    } else {
#line 1056
      goto _L___167;
    }
  } else
  _L___167: /* CIL Label */ 
#line 1067
  if (comms[nr].flags & (1 << 2)) {
#line 1067
    if (comms[nr].flags & (1 << 3)) {
#line 1070
      if (i != n) {
#line 1070
        if (i != n + 1) {
#line 1070
          if (i != n + 2) {
            {
#line 1072
            Msg(0, (char const   *)orformat[2], rc_name, comms[nr].name, argss[n],
                argss[n + 1], argss[n + 2], (char *)"");
            }
#line 1074
            return (- 1);
          }
        }
      }
    } else {
#line 1067
      goto _L___166;
    }
  } else
  _L___166: /* CIL Label */ 
#line 1077
  if (comms[nr].flags & (1 << 2)) {
#line 1077
    if (comms[nr].flags & (1 << 4)) {
#line 1080
      if (i != n) {
#line 1080
        if (i != n + 1) {
#line 1080
          if (i != n + 3) {
            {
#line 1082
            Msg(0, (char const   *)orformat[2], rc_name, comms[nr].name, argss[n],
                argss[n + 1], argss[n + 3], (char *)"");
            }
#line 1084
            return (- 1);
          }
        }
      }
    } else {
#line 1077
      goto _L___165;
    }
  } else
  _L___165: /* CIL Label */ 
#line 1087
  if (comms[nr].flags & (1 << 3)) {
#line 1087
    if (comms[nr].flags & (1 << 4)) {
#line 1090
      if (i != n) {
#line 1090
        if (i != n + 2) {
#line 1090
          if (i != n + 3) {
            {
#line 1092
            Msg(0, (char const   *)orformat[2], rc_name, comms[nr].name, argss[n],
                argss[n + 2], argss[n + 3], (char *)"");
            }
#line 1094
            return (- 1);
          }
        }
      }
    } else {
#line 1087
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1097
  if (comms[nr].flags & (1 << 2)) {
#line 1099
    if (i != n) {
#line 1099
      if (i != n + 1) {
#line 1101
        if (n != 0) {
#line 1101
          tmp___0 = (char *)"s";
        } else {
#line 1101
          tmp___0 = (char *)"";
        }
        {
#line 1101
        Msg(0, (char const   *)orformat[1], rc_name, comms[nr].name, argss[n], argss[n + 1],
            tmp___0);
        }
#line 1103
        return (- 1);
      }
    }
  } else
#line 1106
  if (comms[nr].flags & (1 << 3)) {
#line 1108
    if (i != n) {
#line 1108
      if (i != n + 2) {
        {
#line 1110
        Msg(0, (char const   *)orformat[1], rc_name, comms[nr].name, argss[n], argss[n + 2],
            (char *)"s");
        }
#line 1112
        return (- 1);
      }
    }
  } else
#line 1115
  if (comms[nr].flags & (1 << 4)) {
#line 1117
    if (i != n) {
#line 1117
      if (i != n + 3) {
        {
#line 1119
        Msg(0, (char const   *)orformat[1], rc_name, comms[nr].name, argss[n], argss[n + 3],
            (char *)"");
        }
#line 1121
        return (- 1);
      }
    }
  } else
#line 1124
  if (i != n) {
#line 1126
    if (n != 1) {
#line 1126
      tmp___1 = (char *)"s";
    } else {
#line 1126
      tmp___1 = (char *)"";
    }
    {
#line 1126
    Msg(0, (char const   *)orformat[0], rc_name, comms[nr].name, argss[n], tmp___1);
    }
#line 1127
    return (- 1);
  }
#line 1129
  return (i);
}
}
#line 1133 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void StuffFin(char *buf , int len , char *data ) 
{ 


  {
#line 1138
  if (! flayer) {
#line 1139
    return;
  }
  {
#line 1140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1140
    if (! len) {
#line 1140
      goto while_break;
    }
    {
#line 1141
    (*((flayer->l_layfn)->lf_LayProcess))(& buf, & len);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1156 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void DoAction(struct action *act , int key ) 
{ 
  int nr ;
  char **args ;
  int *argl ;
  struct win *p ;
  int argc ;
  int i ;
  int n ;
  int msgok ;
  char *s ;
  char ch ;
  struct display *odisplay ;
  struct acluser *user ;
  struct acluser *tmp ;
  void tmp___169(int  , char const   *  , ...) ;
  void tmp___170(int  , char const   *  , ...) ;
  void tmp___171(int  , char const   *  , ...) ;
  void tmp___172(int  , char const   *  , ...) ;
  void tmp___173(int  , char const   *  , ...) ;
  void tmp___174(int  , char const   *  , ...) ;
  void tmp___175(int  , char const   *  , ...) ;
  void tmp___176(int  , char const   *  , ...) ;
  int __cil_tmp25 ;
  void tmp___177(int  , char const   *  , ...) ;
  void tmp___178(int  , char const   *  , ...) ;
  struct acluser *tmp___179 ;
  void tmp___180(int  , char const   *  , ...) ;
  void tmp___181(int  , char const   *  , ...) ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  void tmp___183(int  , char const   *  , ...) ;
  void tmp___184(int  , char const   *  , ...) ;
  char *tmp___185 ;
  int __cil_tmp36 ;
  void tmp___186(int  , char const   *  , ...) ;
  void tmp___187(int  , char const   *  , ...) ;
  char *tmp___188 ;
  int __cil_tmp40 ;
  void tmp___189(int  , char const   *  , ...) ;
  void tmp___190(int  , char const   *  , ...) ;
  void tmp___191(int  , char const   *  , ...) ;
  void tmp___192(int  , char const   *  , ...) ;
  int __cil_tmp45 ;
  void tmp___193(int  , char const   *  , ...) ;
  void tmp___194(int  , char const   *  , ...) ;
  int mode ;
  char *file ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  void tmp___195(int  , char const   *  , ...) ;
  void tmp___196(int  , char const   *  , ...) ;
  int __cil_tmp54 ;
  int tmp___197 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  char *name ;
  char *tmp___198 ;
  void tmp___199(int  , char const   *  , ...) ;
  void tmp___200(int  , char const   *  , ...) ;
  void tmp___201(int  , char const   *  , ...) ;
  void tmp___202(int  , char const   *  , ...) ;
  int __cil_tmp67 ;
  static char buf[2] ;
  int __cil_tmp69 ;
  void tmp___203(int  , char const   *  , ...) ;
  void tmp___204(int  , char const   *  , ...) ;
  int __cil_tmp72 ;
  void tmp___206(int  , char const   *  , ...) ;
  void tmp___207(int  , char const   *  , ...) ;
  int __cil_tmp76 ;
  void tmp___208(int  , char const   *  , ...) ;
  void tmp___209(int  , char const   *  , ...) ;
  int __cil_tmp80 ;
  int __cil_tmp82 ;
  void tmp___210(int  , char const   *  , ...) ;
  void tmp___211(int  , char const   *  , ...) ;
  void tmp___212(int  , char const   *  , ...) ;
  void tmp___213(int  , char const   *  , ...) ;
  register unsigned int i___214 ;
  void tmp___215(int  , char const   *  , ...) ;
  void tmp___216(int  , char const   *  , ...) ;
  void tmp___217(int  , char const   *  , ...) ;
  void tmp___218(int  , char const   *  , ...) ;
  int __cil_tmp93 ;
  void tmp___220(int  , char const   *  , ...) ;
  void tmp___221(int  , char const   *  , ...) ;
  int tmp___222 ;
  struct display *olddisplay ;
  void tmp___223(int  , char const   *  , ...) ;
  void tmp___224(int  , char const   *  , ...) ;
  size_t __cil_tmp101 ;
  int __cil_tmp102 ;
  struct display *nd ;
  struct acluser *u ;
  int __cil_tmp105 ;
  void tmp___225(int  , char const   *  , ...) ;
  void tmp___226(int  , char const   *  , ...) ;
  void tmp___227(int  , char const   *  , ...) ;
  void tmp___228(int  , char const   *  , ...) ;
  char *tmp___229 ;
  struct display *nd___0 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  void tmp___231(int  , char const   *  , ...) ;
  void tmp___232(int  , char const   *  , ...) ;
  char *tmp___233 ;
  int __cil_tmp120 ;
  struct win *nw ;
  int ch___234 ;
  int __cil_tmp125 ;
  struct layer *tmp___235 ;
  void tmp___236(int  , char const   *  , ...) ;
  void tmp___237(int  , char const   *  , ...) ;
  char *tmp___238 ;
  void tmp___239(int  , char const   *  , ...) ;
  void tmp___240(int  , char const   *  , ...) ;
  struct layer *tmp___241 ;
  void tmp___242(int  , char const   *  , ...) ;
  void tmp___243(int  , char const   *  , ...) ;
  char *tmp___244 ;
  void tmp___245(int  , char const   *  , ...) ;
  void tmp___246(int  , char const   *  , ...) ;
  int tmp___249 ;
  int tmp___250 ;
  int __cil_tmp140 ;
  void tmp___251(int  , char const   *  , ...) ;
  void tmp___252(int  , char const   *  , ...) ;
  void tmp___253(int  , char const   *  , ...) ;
  void tmp___254(int  , char const   *  , ...) ;
  void tmp___255(int  , char const   *  , ...) ;
  void tmp___256(int  , char const   *  , ...) ;
  struct plop *pp ;
  int tmp___257 ;
  int tmp___258 ;
  int __cil_tmp152 ;
  void tmp___259(int  , char const   *  , ...) ;
  void tmp___260(int  , char const   *  , ...) ;
  void tmp___261(int  , char const   *  , ...) ;
  void tmp___262(int  , char const   *  , ...) ;
  void tmp___263(int  , char const   *  , ...) ;
  void tmp___264(int  , char const   *  , ...) ;
  struct plop *plp ;
  void tmp___265(int  , char const   *  , ...) ;
  void tmp___266(int  , char const   *  , ...) ;
  int __cil_tmp165 ;
  void tmp___267(int  , char const   *  , ...) ;
  void tmp___268(int  , char const   *  , ...) ;
  int __cil_tmp168 ;
  void tmp___269(int  , char const   *  , ...) ;
  void tmp___270(int  , char const   *  , ...) ;
  int __cil_tmp172 ;
  char *tmp___271 ;
  size_t __cil_tmp174 ;
  void tmp___272(int  , char const   *  , ...) ;
  void tmp___273(int  , char const   *  , ...) ;
  void tmp___274(int  , char const   *  , ...) ;
  void tmp___275(int  , char const   *  , ...) ;
  char *__cil_tmp180 ;
  struct action *ktabp ;
  int __cil_tmp182 ;
  void tmp___276(int  , char const   *  , ...) ;
  void tmp___277(int  , char const   *  , ...) ;
  int __cil_tmp186 ;
  int __cil_tmp187 ;
  int tmp___279 ;
  static char *types[] ;
  extern int breaktype___0 ;
  int __cil_tmp191 ;
  void tmp___280(int  , char const   *  , ...) ;
  void tmp___281(int  , char const   *  , ...) ;
  void tmp___282(int  , char const   *  , ...) ;
  void tmp___283(int  , char const   *  , ...) ;
  void tmp___285(int  , char const   *  , ...) ;
  void tmp___286(int  , char const   *  , ...) ;
  int __cil_tmp200 ;
  int w ;
  int h ;
  int what ;
  int __cil_tmp204 ;
  int __cil_tmp205 ;
  void tmp___288(int  , char const   *  , ...) ;
  void tmp___289(int  , char const   *  , ...) ;
  void tmp___290(int  , char const   *  , ...) ;
  void tmp___291(int  , char const   *  , ...) ;
  void tmp___292(int  , char const   *  , ...) ;
  void tmp___293(int  , char const   *  , ...) ;
  void tmp___294(int  , char const   *  , ...) ;
  void tmp___295(int  , char const   *  , ...) ;
  void tmp___296(int  , char const   *  , ...) ;
  void tmp___297(int  , char const   *  , ...) ;
  void tmp___298(int  , char const   *  , ...) ;
  void tmp___299(int  , char const   *  , ...) ;
  int __cil_tmp223 ;
  int tmp___300 ;
  void tmp___301(int  , char const   *  , ...) ;
  void tmp___302(int  , char const   *  , ...) ;
  void tmp___303(int  , char const   *  , ...) ;
  void tmp___304(int  , char const   *  , ...) ;
  void tmp___305(int  , char const   *  , ...) ;
  void tmp___306(int  , char const   *  , ...) ;
  int __cil_tmp231 ;
  int __cil_tmp232 ;
  void tmp___307(int  , char const   *  , ...) ;
  void tmp___308(int  , char const   *  , ...) ;
  size_t __cil_tmp235 ;
  size_t __cil_tmp236 ;
  void tmp___309(int  , char const   *  , ...) ;
  void tmp___310(int  , char const   *  , ...) ;
  int __cil_tmp239 ;
  void tmp___311(int  , char const   *  , ...) ;
  void tmp___312(int  , char const   *  , ...) ;
  int tmp___313 ;
  int tmp___314 ;
  int __cil_tmp244 ;
  int tmp___315 ;
  void tmp___316(int  , char const   *  , ...) ;
  void tmp___317(int  , char const   *  , ...) ;
  int tmp___318 ;
  char *tmp___319 ;
  int __cil_tmp250 ;
  int tmp___320 ;
  int __cil_tmp252 ;
  int tmp___321 ;
  int __cil_tmp254 ;
  void tmp___322(int  , char const   *  , ...) ;
  void tmp___323(int  , char const   *  , ...) ;
  char *tmp___324 ;
  char *tmp___325 ;
  int __cil_tmp259 ;
  void tmp___326(int  , char const   *  , ...) ;
  void tmp___327(int  , char const   *  , ...) ;
  int __cil_tmp264 ;
  void tmp___328(int  , char const   *  , ...) ;
  void tmp___329(int  , char const   *  , ...) ;
  int __cil_tmp267 ;
  void tmp___330(int  , char const   *  , ...) ;
  void tmp___331(int  , char const   *  , ...) ;
  int __cil_tmp271 ;
  void tmp___332(int  , char const   *  , ...) ;
  void tmp___333(int  , char const   *  , ...) ;
  int flag ;
  int blank___0 ;
  int __cil_tmp277 ;
  int __cil_tmp278 ;
  int __cil_tmp279 ;
  void tmp___334(int  , char const   *  , ...) ;
  void tmp___335(int  , char const   *  , ...) ;
  int __cil_tmp283 ;
  struct action *ktabp___0 ;
  void tmp___336(int  , char const   *  , ...) ;
  void tmp___337(int  , char const   *  , ...) ;
  void tmp___338(int  , char const   *  , ...) ;
  void tmp___339(int  , char const   *  , ...) ;
  static char *pasteargs[] ;
  static int pasteargl[] ;
  void tmp___340(int  , char const   *  , ...) ;
  void tmp___341(int  , char const   *  , ...) ;
  int __cil_tmp294 ;
  char *ss ;
  char *dbuf ;
  char dch ;
  int l ;
  int enc ;
  void tmp___342(int  , char const   *  , ...) ;
  void tmp___343(int  , char const   *  , ...) ;
  int __cil_tmp302 ;
  int __cil_tmp303 ;
  void tmp___345(int  , char const   *  , ...) ;
  void tmp___346(int  , char const   *  , ...) ;
  int tmp___347 ;
  char *tmp___348 ;
  void *__cil_tmp309 ;
  void tmp___349(int  , char const   *  , ...) ;
  void tmp___350(int  , char const   *  , ...) ;
  struct plop *pp___0 ;
  struct plop *tmp___351 ;
  int __cil_tmp314 ;
  struct plop *pp___1 ;
  void tmp___352(int  , char const   *  , ...) ;
  void tmp___353(int  , char const   *  , ...) ;
  struct plop oldplop ;
  int __cil_tmp320 ;
  int enc___0 ;
  int l___0 ;
  char *newbuf ;
  void tmp___354(int  , char const   *  , ...) ;
  void tmp___355(int  , char const   *  , ...) ;
  void *__cil_tmp328 ;
  void tmp___356(int  , char const   *  , ...) ;
  void tmp___357(int  , char const   *  , ...) ;
  void tmp___358(int  , char const   *  , ...) ;
  void tmp___359(int  , char const   *  , ...) ;
  int tmp___360 ;
  int tmp___361 ;
  int __cil_tmp336 ;
  void tmp___362(int  , char const   *  , ...) ;
  void tmp___363(int  , char const   *  , ...) ;
  void tmp___364(int  , char const   *  , ...) ;
  void tmp___365(int  , char const   *  , ...) ;
  char *tmp___366 ;
  char *__cil_tmp343 ;
  int __cil_tmp344 ;
  void tmp___367(int  , char const   *  , ...) ;
  void tmp___368(int  , char const   *  , ...) ;
  char *tmp___369 ;
  void tmp___370(int  , char const   *  , ...) ;
  void tmp___371(int  , char const   *  , ...) ;
  void tmp___372(int  , char const   *  , ...) ;
  void tmp___373(int  , char const   *  , ...) ;
  char *tmp___374 ;
  int __cil_tmp353 ;
  void tmp___375(int  , char const   *  , ...) ;
  void tmp___376(int  , char const   *  , ...) ;
  int *__cil_tmp356 ;
  int __cil_tmp357 ;
  int __cil_tmp358 ;
  void tmp___377(int  , char const   *  , ...) ;
  void tmp___378(int  , char const   *  , ...) ;
  char *tmp___379 ;
  char buf___0[1024] ;
  int __cil_tmp363 ;
  void tmp___380(int  , char const   *  , ...) ;
  void tmp___381(int  , char const   *  , ...) ;
  int __cil_tmp367 ;
  int __cil_tmp368 ;
  void tmp___382(int  , char const   *  , ...) ;
  void tmp___383(int  , char const   *  , ...) ;
  void tmp___384(int  , char const   *  , ...) ;
  void tmp___385(int  , char const   *  , ...) ;
  int __cil_tmp373 ;
  int __cil_tmp374 ;
  int __cil_tmp375 ;
  void tmp___386(int  , char const   *  , ...) ;
  void tmp___387(int  , char const   *  , ...) ;
  char *tmp___388 ;
  int __cil_tmp379 ;
  void tmp___389(int  , char const   *  , ...) ;
  void tmp___390(int  , char const   *  , ...) ;
  int __cil_tmp383 ;
  void tmp___391(int  , char const   *  , ...) ;
  void tmp___392(int  , char const   *  , ...) ;
  void tmp___393(int  , char const   *  , ...) ;
  void tmp___394(int  , char const   *  , ...) ;
  int __cil_tmp389 ;
  void tmp___397(int  , char const   *  , ...) ;
  void tmp___398(int  , char const   *  , ...) ;
  int __cil_tmp392 ;
  size_t __cil_tmp393 ;
  void tmp___400(int  , char const   *  , ...) ;
  void tmp___401(int  , char const   *  , ...) ;
  int __cil_tmp396 ;
  int __cil_tmp397 ;
  int __cil_tmp399 ;
  int __cil_tmp400 ;
  int __cil_tmp402 ;
  void tmp___402(int  , char const   *  , ...) ;
  void tmp___403(int  , char const   *  , ...) ;
  void tmp___404(int  , char const   *  , ...) ;
  void tmp___405(int  , char const   *  , ...) ;
  char buf___1[256] ;
  void tmp___406(int  , char const   *  , ...) ;
  void tmp___407(int  , char const   *  , ...) ;
  int __cil_tmp411 ;
  int __cil_tmp413 ;
  void tmp___408(int  , char const   *  , ...) ;
  void tmp___409(int  , char const   *  , ...) ;
  int __cil_tmp416 ;
  char buf___2[256] ;
  void tmp___410(int  , char const   *  , ...) ;
  void tmp___411(int  , char const   *  , ...) ;
  int __cil_tmp420 ;
  int __cil_tmp421 ;
  int __cil_tmp422 ;
  int __cil_tmp423 ;
  int __cil_tmp424 ;
  int __cil_tmp425 ;
  int __cil_tmp426 ;
  int __cil_tmp427 ;
  int __cil_tmp428 ;
  int __cil_tmp429 ;
  int __cil_tmp430 ;
  int __cil_tmp431 ;
  int __cil_tmp432 ;
  int tmp___412 ;
  int __cil_tmp434 ;
  int tmp___413 ;
  void tmp___414(int  , char const   *  , ...) ;
  void tmp___415(int  , char const   *  , ...) ;
  char *tmp___416 ;
  int __cil_tmp439 ;
  int tmp___417 ;
  int __cil_tmp441 ;
  int tmp___418 ;
  void tmp___419(int  , char const   *  , ...) ;
  void tmp___420(int  , char const   *  , ...) ;
  char *tmp___421 ;
  int __cil_tmp446 ;
  void tmp___422(int  , char const   *  , ...) ;
  void tmp___423(int  , char const   *  , ...) ;
  int __cil_tmp449 ;
  int __cil_tmp450 ;
  struct display *olddisplay___0 ;
  int old_use ;
  int new_use ;
  int __cil_tmp454 ;
  int __cil_tmp455 ;
  int __cil_tmp456 ;
  int __cil_tmp457 ;
  int __cil_tmp458 ;
  int __cil_tmp459 ;
  char buf___3[256] ;
  void tmp___424(int  , char const   *  , ...) ;
  void tmp___425(int  , char const   *  , ...) ;
  void tmp___426(int  , char const   *  , ...) ;
  void tmp___427(int  , char const   *  , ...) ;
  int tmp___428 ;
  int __cil_tmp467 ;
  void tmp___431(int  , char const   *  , ...) ;
  void tmp___432(int  , char const   *  , ...) ;
  char *tmp___433 ;
  int __cil_tmp471 ;
  int __cil_tmp472 ;
  struct display *olddisplay___1 ;
  int __cil_tmp474 ;
  char buf___4[256] ;
  void tmp___434(int  , char const   *  , ...) ;
  void tmp___435(int  , char const   *  , ...) ;
  void tmp___436(int  , char const   *  , ...) ;
  void tmp___437(int  , char const   *  , ...) ;
  int __cil_tmp481 ;
  int __cil_tmp482 ;
  void tmp___439(int  , char const   *  , ...) ;
  void tmp___440(int  , char const   *  , ...) ;
  void tmp___441(int  , char const   *  , ...) ;
  void tmp___442(int  , char const   *  , ...) ;
  void tmp___443(int  , char const   *  , ...) ;
  void tmp___444(int  , char const   *  , ...) ;
  struct win *tmp___445 ;
  int __cil_tmp490 ;
  void tmp___446(int  , char const   *  , ...) ;
  void tmp___447(int  , char const   *  , ...) ;
  char *tmp___448 ;
  int __cil_tmp494 ;
  int __cil_tmp495 ;
  void tmp___449(int  , char const   *  , ...) ;
  void tmp___450(int  , char const   *  , ...) ;
  void tmp___451(int  , char const   *  , ...) ;
  void tmp___452(int  , char const   *  , ...) ;
  int __cil_tmp500 ;
  void tmp___453(int  , char const   *  , ...) ;
  void tmp___454(int  , char const   *  , ...) ;
  int __cil_tmp503 ;
  void tmp___455(int  , char const   *  , ...) ;
  void tmp___456(int  , char const   *  , ...) ;
  int __cil_tmp506 ;
  void tmp___457(int  , char const   *  , ...) ;
  void tmp___458(int  , char const   *  , ...) ;
  int __cil_tmp509 ;
  void tmp___459(int  , char const   *  , ...) ;
  void tmp___460(int  , char const   *  , ...) ;
  int __cil_tmp512 ;
  int __cil_tmp513 ;
  int __cil_tmp514 ;
  int __cil_tmp515 ;
  void tmp___461(int  , char const   *  , ...) ;
  void tmp___462(int  , char const   *  , ...) ;
  char *tmp___463 ;
  int old ;
  int rel ;
  int parse ;
  int __cil_tmp523 ;
  int __cil_tmp525 ;
  int __cil_tmp528 ;
  int __cil_tmp529 ;
  void tmp___466(int  , char const   *  , ...) ;
  void tmp___467(int  , char const   *  , ...) ;
  int __cil_tmp534 ;
  void tmp___468(int  , char const   *  , ...) ;
  void tmp___469(int  , char const   *  , ...) ;
  int __cil_tmp537 ;
  void tmp___470(int  , char const   *  , ...) ;
  void tmp___471(int  , char const   *  , ...) ;
  int __cil_tmp540 ;
  void tmp___472(int  , char const   *  , ...) ;
  void tmp___473(int  , char const   *  , ...) ;
  void tmp___474(int  , char const   *  , ...) ;
  void tmp___475(int  , char const   *  , ...) ;
  char buf___5[4096] ;
  int __cil_tmp546 ;
  size_t __cil_tmp547 ;
  char *__cil_tmp548 ;
  void tmp___476(int  , char const   *  , ...) ;
  void tmp___477(int  , char const   *  , ...) ;
  __pid_t __cil_tmp551 ;
  int __cil_tmp552 ;
  int *__cil_tmp553 ;
  void tmp___480(int  , char const   *  , ...) ;
  void tmp___481(int  , char const   *  , ...) ;
  int __cil_tmp556 ;
  void tmp___483(int  , char const   *  , ...) ;
  void tmp___484(int  , char const   *  , ...) ;
  int *__cil_tmp559 ;
  int __cil_tmp560 ;
  void tmp___486(int  , char const   *  , ...) ;
  void tmp___487(int  , char const   *  , ...) ;
  char *tmp___488 ;
  int __cil_tmp564 ;
  void tmp___489(int  , char const   *  , ...) ;
  void tmp___490(int  , char const   *  , ...) ;
  char *tmp___491 ;
  int __cil_tmp568 ;
  void tmp___492(int  , char const   *  , ...) ;
  void tmp___493(int  , char const   *  , ...) ;
  int __cil_tmp571 ;
  void tmp___494(int  , char const   *  , ...) ;
  void tmp___495(int  , char const   *  , ...) ;
  char *tmp___496 ;
  int __cil_tmp575 ;
  int __cil_tmp576 ;
  void tmp___497(int  , char const   *  , ...) ;
  void tmp___498(int  , char const   *  , ...) ;
  char *tmp___499 ;
  int __cil_tmp580 ;
  int __cil_tmp581 ;
  char buf___6[256] ;
  void tmp___500(int  , char const   *  , ...) ;
  void tmp___501(int  , char const   *  , ...) ;
  int __cil_tmp585 ;
  int __cil_tmp586 ;
  void tmp___502(int  , char const   *  , ...) ;
  void tmp___503(int  , char const   *  , ...) ;
  void tmp___505(int  , char const   *  , ...) ;
  void tmp___506(int  , char const   *  , ...) ;
  int __cil_tmp591 ;
  int __cil_tmp592 ;
  int tmp___507 ;
  int __cil_tmp595 ;
  void tmp___508(int  , char const   *  , ...) ;
  void tmp___509(int  , char const   *  , ...) ;
  void tmp___510(int  , char const   *  , ...) ;
  void tmp___511(int  , char const   *  , ...) ;
  char *tmp___512 ;
  struct action *ktabp___1 ;
  int kflag ;
  int __cil_tmp603 ;
  int __cil_tmp605 ;
  int __cil_tmp608 ;
  int __cil_tmp609 ;
  void tmp___514(int  , char const   *  , ...) ;
  void tmp___515(int  , char const   *  , ...) ;
  void tmp___516(int  , char const   *  , ...) ;
  void tmp___517(int  , char const   *  , ...) ;
  void tmp___518(int  , char const   *  , ...) ;
  void tmp___519(int  , char const   *  , ...) ;
  int __cil_tmp618 ;
  struct action *newact ;
  int newnr ;
  int fl ;
  int kf ;
  int af ;
  int df ;
  int mf ;
  struct display *odisp ;
  int used ;
  struct kmap_ext *kme ;
  int __cil_tmp629 ;
  int __cil_tmp630 ;
  int __cil_tmp631 ;
  int __cil_tmp632 ;
  int __cil_tmp633 ;
  int __cil_tmp634 ;
  void tmp___520(int  , char const   *  , ...) ;
  void tmp___521(int  , char const   *  , ...) ;
  char **__cil_tmp639 ;
  int *__cil_tmp640 ;
  void tmp___522(int  , char const   *  , ...) ;
  void tmp___523(int  , char const   *  , ...) ;
  void tmp___524(int  , char const   *  , ...) ;
  void tmp___525(int  , char const   *  , ...) ;
  void tmp___526(int  , char const   *  , ...) ;
  void tmp___527(int  , char const   *  , ...) ;
  int __cil_tmp647 ;
  int __cil_tmp648 ;
  struct kmap_ext *__cil_tmp649 ;
  void tmp___528(int  , char const   *  , ...) ;
  void tmp___529(int  , char const   *  , ...) ;
  char *__cil_tmp652 ;
  int __cil_tmp653 ;
  struct kmap_ext *__cil_tmp654 ;
  struct action *tmp___531 ;
  struct action *tmp___532 ;
  int __cil_tmp657 ;
  void tmp___533(int  , char const   *  , ...) ;
  void tmp___534(int  , char const   *  , ...) ;
  struct action *tmp___535 ;
  struct action *tmp___536 ;
  void tmp___537(int  , char const   *  , ...) ;
  void tmp___538(int  , char const   *  , ...) ;
  int __cil_tmp666 ;
  int tmp___539 ;
  int __cil_tmp669 ;
  void tmp___540(int  , char const   *  , ...) ;
  void tmp___541(int  , char const   *  , ...) ;
  void tmp___542(int  , char const   *  , ...) ;
  void tmp___543(int  , char const   *  , ...) ;
  int __cil_tmp674 ;
  void tmp___545(int  , char const   *  , ...) ;
  void tmp___546(int  , char const   *  , ...) ;
  int __cil_tmp677 ;
  int __cil_tmp678 ;
  void tmp___547(int  , char const   *  , ...) ;
  void tmp___548(int  , char const   *  , ...) ;
  struct acluser *u___0 ;
  struct aclusergroup *g ;
  char buf___7[256] ;
  char *p___549 ;
  int ngroups ;
  struct acluser *u___1 ;
  struct aclusergroup *g___0 ;
  void tmp___550(int  , char const   *  , ...) ;
  void tmp___551(int  , char const   *  , ...) ;
  size_t __cil_tmp693 ;
  void tmp___552(int  , char const   *  , ...) ;
  void tmp___553(int  , char const   *  , ...) ;
  char *tmp___554 ;
  char *tmp___555 ;
  char *err ;
  struct acluser *tmp___556 ;
  int __cil_tmp701 ;
  void tmp___557(int  , char const   *  , ...) ;
  void tmp___558(int  , char const   *  , ...) ;
  int __cil_tmp704 ;
  char *tmp___559 ;
  void tmp___560(int  , char const   *  , ...) ;
  void tmp___561(int  , char const   *  , ...) ;
  char *tmp___562 ;
  int __cil_tmp709 ;
  int __cil_tmp710 ;
  int tmp___563 ;
  void tmp___567(int  , char const   *  , ...) ;
  void tmp___568(int  , char const   *  , ...) ;
  void tmp___569(int  , char const   *  , ...) ;
  void tmp___570(int  , char const   *  , ...) ;
  void tmp___571(int  , char const   *  , ...) ;
  void tmp___572(int  , char const   *  , ...) ;
  int __cil_tmp718 ;
  int __cil_tmp719 ;
  int tmp___575 ;
  int __cil_tmp721 ;
  void tmp___579(int  , char const   *  , ...) ;
  void tmp___580(int  , char const   *  , ...) ;
  char *tmp___581 ;
  int __cil_tmp725 ;
  void tmp___582(int  , char const   *  , ...) ;
  void tmp___583(int  , char const   *  , ...) ;
  char *tmp___584 ;
  int __cil_tmp729 ;
  void tmp___585(int  , char const   *  , ...) ;
  void tmp___586(int  , char const   *  , ...) ;
  char *tmp___587 ;
  int __cil_tmp733 ;
  void tmp___588(int  , char const   *  , ...) ;
  void tmp___589(int  , char const   *  , ...) ;
  char *tmp___590 ;
  int __cil_tmp738 ;
  void tmp___591(int  , char const   *  , ...) ;
  void tmp___592(int  , char const   *  , ...) ;
  int __cil_tmp741 ;
  void tmp___593(int  , char const   *  , ...) ;
  void tmp___594(int  , char const   *  , ...) ;
  void tmp___595(int  , char const   *  , ...) ;
  void tmp___596(int  , char const   *  , ...) ;
  int __cil_tmp746 ;
  void tmp___597(int  , char const   *  , ...) ;
  void tmp___598(int  , char const   *  , ...) ;
  void tmp___600(int  , char const   *  , ...) ;
  void tmp___601(int  , char const   *  , ...) ;
  int __cil_tmp754 ;
  int tmp___602 ;
  void tmp___603(int  , char const   *  , ...) ;
  void tmp___604(int  , char const   *  , ...) ;
  char *tmp___605 ;
  int __cil_tmp759 ;
  int __cil_tmp760 ;
  void tmp___606(int  , char const   *  , ...) ;
  void tmp___607(int  , char const   *  , ...) ;
  int tmp___608 ;
  void tmp___609(int  , char const   *  , ...) ;
  void tmp___610(int  , char const   *  , ...) ;
  char *tmp___611 ;
  int tmp___612 ;
  void tmp___613(int  , char const   *  , ...) ;
  void tmp___614(int  , char const   *  , ...) ;
  void tmp___615(int  , char const   *  , ...) ;
  void tmp___616(int  , char const   *  , ...) ;
  void tmp___618(int  , char const   *  , ...) ;
  void tmp___619(int  , char const   *  , ...) ;
  int __cil_tmp777 ;
  int t ;
  unsigned char *s___620 ;
  unsigned char *__cil_tmp781 ;
  int __cil_tmp782 ;
  size_t __cil_tmp783 ;
  char buf___8[256] ;
  void tmp___621(int  , char const   *  , ...) ;
  void tmp___622(int  , char const   *  , ...) ;
  int __cil_tmp787 ;
  int __cil_tmp788 ;
  char buf___9[256] ;
  void tmp___623(int  , char const   *  , ...) ;
  void tmp___624(int  , char const   *  , ...) ;
  size_t __cil_tmp792 ;
  void tmp___625(int  , char const   *  , ...) ;
  void tmp___626(int  , char const   *  , ...) ;
  void tmp___628(int  , char const   *  , ...) ;
  void tmp___629(int  , char const   *  , ...) ;
  char *__cil_tmp800 ;
  void tmp___638(int  , char const   *  , ...) ;
  void tmp___639(int  , char const   *  , ...) ;
  int __cil_tmp805 ;
  int __cil_tmp806 ;
  int __cil_tmp807 ;
  int __cil_tmp808 ;
  void tmp___642(int  , char const   *  , ...) ;
  void tmp___643(int  , char const   *  , ...) ;
  void tmp___644(int  , char const   *  , ...) ;
  void tmp___645(int  , char const   *  , ...) ;
  void tmp___646(int  , char const   *  , ...) ;
  void tmp___647(int  , char const   *  , ...) ;
  void tmp___648(int  , char const   *  , ...) ;
  void tmp___649(int  , char const   *  , ...) ;
  int __cil_tmp821 ;
  struct canvas *cv ;
  int __cil_tmp823 ;
  struct canvas *tmp___650 ;
  int __cil_tmp825 ;
  int __cil_tmp826 ;
  int __cil_tmp827 ;
  int __cil_tmp828 ;
  int __cil_tmp830 ;
  int __cil_tmp832 ;
  int __cil_tmp834 ;
  void tmp___651(int  , char const   *  , ...) ;
  void tmp___652(int  , char const   *  , ...) ;
  void tmp___654(int  , char const   *  , ...) ;
  void tmp___655(int  , char const   *  , ...) ;
  int __cil_tmp840 ;
  int __cil_tmp841 ;
  int __cil_tmp842 ;
  int __cil_tmp843 ;
  int tmp___656 ;
  int __cil_tmp845 ;
  void tmp___657(int  , char const   *  , ...) ;
  void tmp___658(int  , char const   *  , ...) ;
  int __cil_tmp849 ;
  size_t __cil_tmp851 ;
  int __cil_tmp853 ;
  void tmp___659(int  , char const   *  , ...) ;
  void tmp___660(int  , char const   *  , ...) ;
  char *tmp___661 ;
  void tmp___662(int  , char const   *  , ...) ;
  void tmp___663(int  , char const   *  , ...) ;
  int __cil_tmp859 ;
  void tmp___664(int  , char const   *  , ...) ;
  void tmp___665(int  , char const   *  , ...) ;
  void tmp___666(int  , char const   *  , ...) ;
  void tmp___667(int  , char const   *  , ...) ;
  void tmp___668(int  , char const   *  , ...) ;
  void tmp___669(int  , char const   *  , ...) ;
  void *__cil_tmp866 ;
  int __cil_tmp867 ;
  int lifespan ;
  int tick ;
  void tmp___671(int  , char const   *  , ...) ;
  void tmp___672(int  , char const   *  , ...) ;
  int __cil_tmp872 ;
  int __cil_tmp873 ;
  char **__cil_tmp874 ;
  char path[4096] ;
  char *p___673 ;
  char **pp___2 ;
  int __cil_tmp878 ;
  void tmp___674(int  , char const   *  , ...) ;
  void tmp___675(int  , char const   *  , ...) ;
  void tmp___676(int  , char const   *  , ...) ;
  void tmp___677(int  , char const   *  , ...) ;
  char **pp___3 ;
  struct display *olddisplay___2 ;
  int __cil_tmp888 ;
  int __cil_tmp889 ;
  void tmp___678(int  , char const   *  , ...) ;
  void tmp___679(int  , char const   *  , ...) ;
  int __cil_tmp893 ;
  void tmp___680(int  , char const   *  , ...) ;
  void tmp___681(int  , char const   *  , ...) ;
  void tmp___682(int  , char const   *  , ...) ;
  void tmp___683(int  , char const   *  , ...) ;
  int __cil_tmp898 ;
  int __cil_tmp899 ;
  char b[2][20] ;
  int tmp___684 ;
  void tmp___685(int  , char const   *  , ...) ;
  void tmp___686(int  , char const   *  , ...) ;
  void tmp___687(int  , char const   *  , ...) ;
  void tmp___688(int  , char const   *  , ...) ;
  void tmp___689(int  , char const   *  , ...) ;
  void tmp___690(int  , char const   *  , ...) ;
  int __cil_tmp912 ;
  void tmp___691(int  , char const   *  , ...) ;
  void tmp___692(int  , char const   *  , ...) ;
  void tmp___693(int  , char const   *  , ...) ;
  void tmp___694(int  , char const   *  , ...) ;
  int __cil_tmp918 ;
  int __cil_tmp919 ;
  void tmp___695(int  , char const   *  , ...) ;
  void tmp___696(int  , char const   *  , ...) ;
  void tmp___697(int  , char const   *  , ...) ;
  void tmp___698(int  , char const   *  , ...) ;
  int __cil_tmp924 ;
  int __cil_tmp925 ;
  int __cil_tmp926 ;
  int __cil_tmp927 ;
  void tmp___699(int  , char const   *  , ...) ;
  void tmp___700(int  , char const   *  , ...) ;
  int __cil_tmp930 ;
  int __cil_tmp931 ;
  void tmp___701(int  , char const   *  , ...) ;
  void tmp___702(int  , char const   *  , ...) ;
  void tmp___703(int  , char const   *  , ...) ;
  void tmp___704(int  , char const   *  , ...) ;
  char *tmp___705 ;
  int __cil_tmp937 ;
  char *t___0 ;
  int __cil_tmp942 ;
  void tmp___707(int  , char const   *  , ...) ;
  void tmp___708(int  , char const   *  , ...) ;
  int __cil_tmp945 ;
  size_t __cil_tmp947 ;
  int __cil_tmp948 ;
  struct layout *tmp___709 ;
  struct layout *lay ;
  struct layout *tmp___710 ;
  void tmp___711(int  , char const   *  , ...) ;
  void tmp___712(int  , char const   *  , ...) ;
  int __cil_tmp954 ;
  struct layout *lay___0 ;
  struct layout *tmp___713 ;
  struct layout *target ;
  void tmp___714(int  , char const   *  , ...) ;
  void tmp___715(int  , char const   *  , ...) ;
  int __cil_tmp960 ;
  void tmp___716(int  , char const   *  , ...) ;
  void tmp___717(int  , char const   *  , ...) ;
  void tmp___718(int  , char const   *  , ...) ;
  void tmp___719(int  , char const   *  , ...) ;
  void tmp___720(int  , char const   *  , ...) ;
  void tmp___721(int  , char const   *  , ...) ;
  int __cil_tmp967 ;
  struct layout *lay___1 ;
  void tmp___722(int  , char const   *  , ...) ;
  void tmp___723(int  , char const   *  , ...) ;
  int __cil_tmp972 ;
  int __cil_tmp973 ;
  struct layout *lay___2 ;
  struct layout *tmp___724 ;
  struct layout *__cil_tmp976 ;
  struct layout *tmp___725 ;
  void tmp___726(int  , char const   *  , ...) ;
  void tmp___727(int  , char const   *  , ...) ;
  int __cil_tmp980 ;
  void tmp___728(int  , char const   *  , ...) ;
  void tmp___729(int  , char const   *  , ...) ;
  char *tmp___730 ;
  int __cil_tmp984 ;
  void tmp___731(int  , char const   *  , ...) ;
  void tmp___732(int  , char const   *  , ...) ;
  int *__cil_tmp987 ;
  void tmp___733(int  , char const   *  , ...) ;
  void tmp___734(int  , char const   *  , ...) ;
  char *tmp___735 ;
  void tmp___736(int  , char const   *  , ...) ;
  void tmp___737(int  , char const   *  , ...) ;
  int __cil_tmp993 ;
  void tmp___738(int  , char const   *  , ...) ;
  void tmp___739(int  , char const   *  , ...) ;
  char *tmp___740 ;

  {
#line 1160
  nr = act->nr;
#line 1161
  args = act->args;
#line 1162
  argl = act->argl;
#line 1167
  odisplay = display;
#line 1170
  if (display) {
#line 1170
    tmp = display->d_user;
  } else {
#line 1170
    tmp = users;
  }
#line 1170
  user = tmp;
#line 1171
  if (nr == -1) {
    {
#line 1173
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1173
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1174
    return;
  }
#line 1176
  n = comms[nr].flags;
#line 1183
  if (! (n & (1 << 9))) {
#line 1183
    if (queryflag >= 0) {
#line 1186
      if (! act->quiet) {
#line 1186
        tmp___170 = Msg;
      } else {
#line 1186
        if (queryflag >= 0) {
#line 1186
          tmp___169 = QueryMsg;
        } else {
#line 1186
          tmp___169 = Dummy;
        }
#line 1186
        tmp___170 = tmp___169;
      }
      {
#line 1186
      tmp___170(0, (char const   *)((char *)"%s command cannot be queried."), comms[nr].name);
#line 1187
      queryflag = - 1;
      }
#line 1188
      return;
    }
  }
#line 1190
  if (n & (1 << 7)) {
#line 1190
    if (display == (struct display *)0) {
#line 1192
      if (! act->quiet) {
#line 1192
        tmp___172 = Msg;
      } else {
#line 1192
        if (queryflag >= 0) {
#line 1192
          tmp___171 = QueryMsg;
        } else {
#line 1192
          tmp___171 = Dummy;
        }
#line 1192
        tmp___172 = tmp___171;
      }
      {
#line 1192
      tmp___172(0, (char const   *)((char *)"%s: %s: display required"), rc_name,
                comms[nr].name);
#line 1193
      queryflag = - 1;
      }
#line 1194
      return;
    }
  }
#line 1196
  if (n & (1 << 6)) {
#line 1196
    if (fore == (struct win *)0) {
#line 1198
      if (! act->quiet) {
#line 1198
        tmp___174 = Msg;
      } else {
#line 1198
        if (queryflag >= 0) {
#line 1198
          tmp___173 = QueryMsg;
        } else {
#line 1198
          tmp___173 = Dummy;
        }
#line 1198
        tmp___174 = tmp___173;
      }
      {
#line 1198
      tmp___174(0, (char const   *)((char *)"%s: %s: window required"), rc_name, comms[nr].name);
#line 1199
      queryflag = - 1;
      }
#line 1200
      return;
    }
  }
#line 1202
  if (n & (1 << 8)) {
#line 1202
    if (flayer == (struct layer *)0) {
#line 1204
      if (! act->quiet) {
#line 1204
        tmp___176 = Msg;
      } else {
#line 1204
        if (queryflag >= 0) {
#line 1204
          tmp___175 = QueryMsg;
        } else {
#line 1204
          tmp___175 = Dummy;
        }
#line 1204
        tmp___176 = tmp___175;
      }
      {
#line 1204
      tmp___176(0, (char const   *)((char *)"%s: %s: display or window required"),
                rc_name, comms[nr].name);
#line 1205
      queryflag = - 1;
      }
#line 1206
      return;
    }
  }
  {
#line 1208
  argc = CheckArgNum(nr, args);
  }
#line 1208
  if (argc < 0) {
#line 1209
    return;
  }
#line 1211
  if (display) {
    {
#line 1213
    __cil_tmp25 = AclCheckPermCmd(display->d_user, 0, & comms[nr]);
    }
#line 1213
    if (__cil_tmp25) {
#line 1215
      if (! act->quiet) {
#line 1215
        tmp___178 = Msg;
      } else {
#line 1215
        if (queryflag >= 0) {
#line 1215
          tmp___177 = QueryMsg;
        } else {
#line 1215
          tmp___177 = Dummy;
        }
#line 1215
        tmp___178 = tmp___177;
      }
      {
#line 1215
      tmp___178(0, (char const   *)((char *)"%s: %s: permission denied (user %s)"),
                rc_name, comms[nr].name, (char *)tmp___179->u_name);
#line 1217
      queryflag = - 1;
      }
#line 1218
      return;
    }
  }
#line 1223
  msgok = display && ! *rc_name;
  {
#line 1226
  if (nr == 145) {
#line 1226
    goto case_145;
  }
#line 1253
  if (nr == 41) {
#line 1253
    goto case_41;
  }
#line 1259
  if (nr == 12) {
#line 1259
    goto case_12;
  }
#line 1264
  if (nr == 59) {
#line 1264
    goto case_59;
  }
#line 1273
  if (nr == 120) {
#line 1273
    goto case_120;
  }
#line 1280
  if (nr == 71) {
#line 1280
    goto case_71;
  }
#line 1283
  if (nr == 84) {
#line 1283
    goto case_84;
  }
#line 1309
  if (nr == 53) {
#line 1309
    goto case_53;
  }
#line 1312
  if (nr == 101) {
#line 1312
    goto case_101;
  }
#line 1318
  if (nr == 162) {
#line 1318
    goto case_162;
  }
#line 1322
  if (nr == 117) {
#line 1322
    goto case_117;
  }
#line 1326
  if (nr == 130) {
#line 1326
    goto case_130;
  }
#line 1330
  if (nr == 96) {
#line 1330
    goto case_96;
  }
#line 1359
  if (nr == 133) {
#line 1359
    goto case_133;
  }
#line 1368
  if (nr == 67) {
#line 1368
    goto case_67;
  }
#line 1375
  if (nr == 128) {
#line 1375
    goto case_128;
  }
#line 1388
  if (nr == 40) {
#line 1388
    goto case_40;
  }
#line 1417
  if (nr == 187) {
#line 1417
    goto case_187;
  }
#line 1458
  if (nr == 170) {
#line 1458
    goto case_170;
  }
#line 1467
  if (nr == 188) {
#line 1467
    goto case_188;
  }
#line 1494
  if (nr == 178) {
#line 1494
    goto case_178;
  }
#line 1507
  if (nr == 9) {
#line 1507
    goto case_9;
  }
#line 1527
  if (nr == '*') {
#line 1527
    goto case_42;
  }
#line 1570
  if (nr == '%') {
#line 1570
    goto case_37;
  }
#line 1599
  if (nr == '#') {
#line 1599
    goto case_35;
  }
#line 1675
  if (nr == 135) {
#line 1675
    goto case_135;
  }
#line 1738
  if (nr == 137) {
#line 1738
    goto case_137;
  }
#line 1792
  if (nr == 132) {
#line 1792
    goto case_132;
  }
#line 1806
  if (nr == 160) {
#line 1806
    goto case_160;
  }
#line 1842
  if (nr == 136) {
#line 1842
    goto case_136;
  }
#line 1845
  if (nr == 181) {
#line 1845
    goto case_181;
  }
#line 1852
  if (nr == 177) {
#line 1852
    goto case_177;
  }
#line 1855
  if (nr == 167) {
#line 1855
    goto case_167;
  }
#line 1863
  if (nr == 94) {
#line 1863
    goto case_94;
  }
#line 1866
  if (nr == 69) {
#line 1866
    goto case_69;
  }
#line 1869
  if (nr == 35) {
#line 1869
    goto case_35___0;
  }
#line 1896
  if (nr == 122) {
#line 1896
    goto case_122;
  }
#line 1900
  if (nr == 110) {
#line 1900
    goto case_110;
  }
#line 1908
  if (nr == 186) {
#line 1908
    goto case_186;
  }
#line 1914
  if (nr == 185) {
#line 1914
    goto case_185;
  }
#line 1921
  if (nr == 22) {
#line 1921
    goto case_22;
  }
#line 1921
  if (nr == 43) {
#line 1921
    goto case_22;
  }
#line 1955
  if (nr == 21) {
#line 1955
    goto case_21;
  }
#line 1955
  if (nr == 127) {
#line 1955
    goto case_21;
  }
#line 1962
  if (nr == 100) {
#line 1962
    goto case_100;
  }
#line 1967
  if (nr == 88) {
#line 1967
    goto case_88;
  }
#line 1967
  if (nr == 179) {
#line 1967
    goto case_88;
  }
#line 2094
  if (nr == 46) {
#line 2094
    goto case_46;
  }
#line 2097
  if (nr == 72) {
#line 2097
    goto case_72;
  }
#line 2100
  if (nr == 168) {
#line 2100
    goto case_168;
  }
#line 2114
  if (nr == 34) {
#line 2114
    goto case_34;
  }
#line 2123
  if (nr == 97) {
#line 2123
    goto case_97;
  }
#line 2127
  if (nr == 143) {
#line 2127
    goto case_143;
  }
#line 2130
  if (nr == 182) {
#line 2130
    goto case_182;
  }
#line 2134
  if (nr == 79) {
#line 2134
    goto case_79;
  }
#line 2163
  if (nr == 66) {
#line 2163
    goto case_66;
  }
#line 2173
  if (nr == 184) {
#line 2173
    goto case_184;
  }
#line 2197
  if (nr == 32) {
#line 2197
    goto case_32;
  }
#line 2201
  if (nr == 141) {
#line 2201
    goto case_141;
  }
#line 2209
  if (nr == 111) {
#line 2209
    goto case_111;
  }
#line 2249
  if (nr == 70) {
#line 2249
    goto case_70;
  }
#line 2253
  if (nr == 180) {
#line 2253
    goto case_180;
  }
#line 2300
  if (nr == 89) {
#line 2300
    goto case_89;
  }
#line 2314
  if (nr == 99) {
#line 2314
    goto case_99;
  }
#line 2318
  if (nr == 38) {
#line 2318
    goto case_38;
  }
#line 2327
  if (nr == 90) {
#line 2327
    goto case_90;
  }
#line 2345
  if (nr == 125) {
#line 2345
    goto case_125;
  }
#line 2488
  if (nr == 183) {
#line 2488
    goto case_183;
  }
#line 2537
  if (nr == 134) {
#line 2537
    goto case_134;
  }
#line 2567
  if (nr == 139) {
#line 2567
    goto case_139;
  }
#line 2570
  if (nr == 93) {
#line 2570
    goto case_93;
  }
#line 2576
  if (nr == 75) {
#line 2576
    goto case_75;
  }
#line 2592
  if (nr == 48) {
#line 2592
    goto case_48;
  }
#line 2606
  if (nr == 30) {
#line 2606
    goto case_30;
  }
#line 2612
  if (nr == 61) {
#line 2612
    goto case_61;
  }
#line 2612
  if (nr == 149) {
#line 2612
    goto case_61;
  }
#line 2616
  if (nr == 86) {
#line 2616
    goto case_86;
  }
#line 2622
  if (nr == 102) {
#line 2622
    goto case_102;
  }
#line 2643
  if (nr == 104) {
#line 2643
    goto case_104;
  }
#line 2673
  if (nr == 150) {
#line 2673
    goto case_150;
  }
#line 2678
  if (nr == 166) {
#line 2678
    goto case_166;
  }
#line 2678
  if (nr == 165) {
#line 2678
    goto case_166;
  }
#line 2678
  if (nr == 164) {
#line 2678
    goto case_166;
  }
#line 2682
  if (nr == 153) {
#line 2682
    goto case_153;
  }
#line 2684
  if (nr == 163) {
#line 2684
    goto case_163;
  }
#line 2701
  if (nr == 73) {
#line 2701
    goto case_73;
  }
#line 2731
  if (nr == 16) {
#line 2731
    goto case_16;
  }
#line 2731
  if (nr == 15) {
#line 2731
    goto case_16;
  }
#line 2742
  if (nr == 23) {
#line 2742
    goto case_23;
  }
#line 2751
  if (nr == 5) {
#line 2751
    goto case_5;
  }
#line 2755
  if (nr == 129) {
#line 2755
    goto case_129;
  }
#line 2767
  if (nr == 103) {
#line 2767
    goto case_103;
  }
#line 2786
  if (nr == 54) {
#line 2786
    goto case_54;
  }
#line 2795
  if (nr == 49) {
#line 2795
    goto case_49;
  }
#line 2817
  if (nr == 65) {
#line 2817
    goto case_65;
  }
#line 2820
  if (nr == 44) {
#line 2820
    goto case_44;
  }
#line 2824
  if (nr == 42) {
#line 2824
    goto case_42___0;
  }
#line 2828
  if (nr == 50) {
#line 2828
    goto case_50;
  }
#line 2831
  if (nr == 56) {
#line 2831
    goto case_56;
  }
#line 2835
  if (nr == 57) {
#line 2835
    goto case_57;
  }
#line 2839
  if (nr == 112) {
#line 2839
    goto case_112;
  }
#line 2851
  if (nr == 62) {
#line 2851
    goto case_62;
  }
#line 2855
  if (nr == 176) {
#line 2855
    goto case_176;
  }
#line 2862
  if (nr == 87) {
#line 2862
    goto case_87;
  }
#line 2933
  if (nr == 27) {
#line 2933
    goto case_27;
  }
#line 2965
  if (nr == 37) {
#line 2965
    goto case_37___0;
  }
#line 2980
  if (nr == 7) {
#line 2980
    goto case_7;
  }
#line 2989
  if (nr == 123) {
#line 2989
    goto case_123;
  }
#line 2993
  if (nr == 173) {
#line 2993
    goto case_173;
  }
#line 3001
  if (nr == 175) {
#line 3001
    goto case_175;
  }
#line 3005
  if (nr == 114) {
#line 3005
    goto case_114;
  }
#line 3009
  if (nr == 113) {
#line 3009
    goto case_113;
  }
#line 3013
  if (nr == 152) {
#line 3013
    goto case_152;
  }
#line 3023
  if (nr == 25) {
#line 3023
    goto case_25;
  }
#line 3027
  if (nr == 24) {
#line 3027
    goto case_24;
  }
#line 3031
  if (nr == 33) {
#line 3031
    goto case_33;
  }
#line 3034
  if (nr == 119) {
#line 3034
    goto case_119;
  }
#line 3065
  if (nr == 189) {
#line 3065
    goto case_189;
  }
#line 3077
  if (nr == 156) {
#line 3077
    goto case_156;
  }
#line 3120
  if (nr == 151) {
#line 3120
    goto case_151;
  }
#line 3173
  if (nr == 60) {
#line 3173
    goto case_60;
  }
#line 3176
  if (nr == 144) {
#line 3176
    goto case_144;
  }
#line 3188
  if (nr == 146) {
#line 3188
    goto case_146;
  }
#line 3223
  if (nr == 147) {
#line 3223
    goto case_147;
  }
#line 3235
  if (nr == 171) {
#line 3235
    goto case_171;
  }
#line 3240
  if (nr == 63) {
#line 3240
    goto case_63;
  }
#line 3243
  if (nr == 154) {
#line 3243
    goto case_154;
  }
#line 3255
  if (nr == 108) {
#line 3255
    goto case_108;
  }
#line 3264
  if (nr == 126) {
#line 3264
    goto case_126;
  }
#line 3269
  if (nr == 39) {
#line 3269
    goto case_39;
  }
#line 3272
  if (nr == 36) {
#line 3272
    goto case_36;
  }
#line 3278
  if (nr == 116) {
#line 3278
    goto case_116;
  }
#line 3286
  if (nr == 85) {
#line 3286
    goto case_85;
  }
#line 3289
  if (nr == 174) {
#line 3289
    goto case_174;
  }
#line 3300
  if (nr == 55) {
#line 3300
    goto case_55;
  }
#line 3312
  if (nr == 11) {
#line 3312
    goto case_11;
  }
#line 3315
  if (nr == 159) {
#line 3315
    goto case_159;
  }
#line 3319
  if (nr == 124) {
#line 3319
    goto case_124;
  }
#line 3344
  if (nr == 17) {
#line 3344
    goto case_17;
  }
#line 3410
  if (nr == 18) {
#line 3410
    goto case_18;
  }
#line 3559
  if (nr == 107) {
#line 3559
    goto case_107;
  }
#line 3574
  if (nr == 106) {
#line 3574
    goto case_106;
  }
#line 3577
  if (nr == 105) {
#line 3577
    goto case_105;
  }
#line 3585
  if (nr == 28) {
#line 3585
    goto case_28;
  }
#line 3585
  if (nr == 6) {
#line 3585
    goto case_28;
  }
#line 3585
  if (nr == 0) {
#line 3585
    goto case_28;
  }
#line 3585
  if (nr == 1) {
#line 3585
    goto case_28;
  }
#line 3588
  if (nr == 2) {
#line 3588
    goto case_2;
  }
#line 3594
  if (nr == 3) {
#line 3594
    goto case_3;
  }
#line 3653
  if (nr == 169) {
#line 3653
    goto case_169;
  }
#line 3653
  if (nr == 4) {
#line 3653
    goto case_169;
  }
#line 3662
  if (nr == 115) {
#line 3662
    goto case_115;
  }
#line 3672
  if (nr == 77) {
#line 3672
    goto case_77;
  }
#line 3677
  if (nr == 118) {
#line 3677
    goto case_118;
  }
#line 3698
  if (nr == 58) {
#line 3698
    goto case_58;
  }
#line 3716
  if (nr == 82) {
#line 3716
    goto case_82;
  }
#line 3728
  if (nr == 26) {
#line 3728
    goto case_26;
  }
#line 3733
  if (nr == 14) {
#line 3733
    goto case_14;
  }
#line 3740
  if (nr == 74) {
#line 3740
    goto case_74;
  }
#line 3740
  if (nr == 95) {
#line 3740
    goto case_74;
  }
#line 3793
  if (nr == 47) {
#line 3793
    goto case_47;
  }
#line 3793
  if (nr == 52) {
#line 3793
    goto case_47;
  }
#line 3805
  if (nr == 64) {
#line 3805
    goto case_64;
  }
#line 3814
  if (nr == 172) {
#line 3814
    goto case_172;
  }
#line 3844
  if (nr == 131) {
#line 3844
    goto case_131;
  }
#line 3863
  if (nr == 68) {
#line 3863
    goto case_68;
  }
#line 3912
  if (nr == 51) {
#line 3912
    goto case_51;
  }
#line 3929
  if (nr == 91) {
#line 3929
    goto case_91;
  }
#line 3941
  if (nr == 29) {
#line 3941
    goto case_29;
  }
#line 3941
  if (nr == 45) {
#line 3941
    goto case_29;
  }
#line 3975
  if (nr == 10) {
#line 3975
    goto case_10;
  }
#line 4015
  if (nr == 140) {
#line 4015
    goto case_140;
  }
#line 4049
  if (nr == 155) {
#line 4049
    goto case_155;
  }
#line 4068
  if (nr == 157) {
#line 4068
    goto case_157;
  }
#line 4073
  if (nr == 161) {
#line 4073
    goto case_161;
  }
#line 4090
  if (nr == 158) {
#line 4090
    goto case_158;
  }
#line 4098
  if (nr == 138) {
#line 4098
    goto case_138;
  }
#line 4102
  if (nr == 121) {
#line 4102
    goto case_121;
  }
#line 4106
  if (nr == 78) {
#line 4106
    goto case_78;
  }
#line 4114
  if (nr == 80) {
#line 4114
    goto case_80;
  }
#line 4147
  if (nr == 142) {
#line 4147
    goto case_142;
  }
#line 4179
  if (nr == 148) {
#line 4179
    goto case_148;
  }
#line 4182
  if (nr == 76) {
#line 4182
    goto case_76;
  }
#line 4192
  if (nr == 8) {
#line 4192
    goto case_8;
  }
#line 4197
  if (nr == 109) {
#line 4197
    goto case_109;
  }
#line 4221
  if (nr == 13) {
#line 4221
    goto case_13;
  }
#line 4242
  if (nr == 19) {
#line 4242
    goto case_19;
  }
#line 4255
  if (nr == 20) {
#line 4255
    goto case_20;
  }
#line 4283
  if (nr == 92) {
#line 4283
    goto case_92;
  }
#line 4315
  if (nr == 81) {
#line 4315
    goto case_81;
  }
#line 4341
  if (nr == 83) {
#line 4341
    goto case_83;
  }
#line 4363
  if (nr == 98) {
#line 4363
    goto case_98;
  }
#line 4606
  if (nr == 31) {
#line 4606
    goto case_31;
  }
#line 4614
  goto switch_default___0;
  case_145: /* CIL Label */ 
#line 1227
  if (! *args) {
    {
#line 1228
    InputSelect();
    }
  } else
#line 1229
  if ((int )*(*(args + 0) + 0) == 45) {
#line 1229
    if (! *(*(args + 0) + 1)) {
      {
#line 1231
      SetForeWindow((struct win *)0);
#line 1232
      Activate(0);
      }
    } else {
#line 1229
      goto _L___182;
    }
  } else
  _L___182: /* CIL Label */ 
#line 1234
  if ((int )*(*(args + 0) + 0) == 46) {
#line 1234
    if (! *(*(args + 0) + 1)) {
#line 1236
      if (! fore) {
#line 1238
        if (! act->quiet) {
#line 1238
          tmp___181 = Msg;
        } else {
#line 1238
          if (queryflag >= 0) {
#line 1238
            tmp___180 = QueryMsg;
          } else {
#line 1238
            tmp___180 = Dummy;
          }
#line 1238
          tmp___181 = tmp___180;
        }
        {
#line 1238
        tmp___181(0, (char const   *)((char *)"select . needs a window"));
#line 1239
        queryflag = - 1;
        }
      } else {
        {
#line 1243
        SetForeWindow(fore);
#line 1244
        Activate(0);
        }
      }
    } else {
#line 1234
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1247
    __cil_tmp31 = ParseWinNum(act, & n);
    }
#line 1247
    if (__cil_tmp31 == 0) {
      {
#line 1248
      SwitchWindow(n);
      }
    } else
#line 1249
    if (queryflag >= 0) {
#line 1250
      queryflag = - 1;
    }
  }
#line 1251
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 1254
  __cil_tmp32 = ParseOnOff(act, & defautonuke);
  }
#line 1254
  if (__cil_tmp32 == 0) {
#line 1254
    if (msgok) {
#line 1255
      if (! act->quiet) {
#line 1255
        tmp___184 = Msg;
      } else {
#line 1255
        if (queryflag >= 0) {
#line 1255
          tmp___183 = QueryMsg;
        } else {
#line 1255
          tmp___183 = Dummy;
        }
#line 1255
        tmp___184 = tmp___183;
      }
#line 1255
      if (defautonuke) {
#line 1255
        tmp___185 = (char *)"on";
      } else {
#line 1255
        tmp___185 = (char *)"off";
      }
      {
#line 1255
      tmp___184(0, (char const   *)((char *)"Default autonuke turned %s"), tmp___185);
      }
    }
  }
#line 1256
  if (display) {
#line 1256
    if ((int )*rc_name) {
#line 1257
      display->d_auto_nuke = defautonuke;
    }
  }
#line 1258
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1260
  __cil_tmp36 = ParseOnOff(act, & display->d_auto_nuke);
  }
#line 1260
  if (__cil_tmp36 == 0) {
#line 1260
    if (msgok) {
#line 1261
      if (! act->quiet) {
#line 1261
        tmp___187 = Msg;
      } else {
#line 1261
        if (queryflag >= 0) {
#line 1261
          tmp___186 = QueryMsg;
        } else {
#line 1261
          tmp___186 = Dummy;
        }
#line 1261
        tmp___187 = tmp___186;
      }
#line 1261
      if (display->d_auto_nuke) {
#line 1261
        tmp___188 = (char *)"on";
      } else {
#line 1261
        tmp___188 = (char *)"off";
      }
      {
#line 1261
      tmp___187(0, (char const   *)((char *)"Autonuke turned %s"), tmp___188);
      }
    }
  }
#line 1262
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 1265
  __cil_tmp40 = ParseNum(act, & defobuflimit);
  }
#line 1265
  if (__cil_tmp40 == 0) {
#line 1265
    if (msgok) {
#line 1266
      if (! act->quiet) {
#line 1266
        tmp___190 = Msg;
      } else {
#line 1266
        if (queryflag >= 0) {
#line 1266
          tmp___189 = QueryMsg;
        } else {
#line 1266
          tmp___189 = Dummy;
        }
#line 1266
        tmp___190 = tmp___189;
      }
      {
#line 1266
      tmp___190(0, (char const   *)((char *)"Default limit set to %d"), defobuflimit);
      }
    }
  }
#line 1267
  if (display) {
#line 1267
    if ((int )*rc_name) {
#line 1269
      display->d_obufmax = defobuflimit;
#line 1270
      display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
    }
  }
#line 1272
  goto switch_break;
  case_120: /* CIL Label */ 
#line 1274
  if (*args == (char *)0) {
#line 1275
    if (! act->quiet) {
#line 1275
      tmp___192 = Msg;
    } else {
#line 1275
      if (queryflag >= 0) {
#line 1275
        tmp___191 = QueryMsg;
      } else {
#line 1275
        tmp___191 = Dummy;
      }
#line 1275
      tmp___192 = tmp___191;
    }
    {
#line 1275
    tmp___192(0, (char const   *)((char *)"Limit is %d, current buffer size is %d"),
              display->d_obufmax, display->d_obuflen);
    }
  } else {
    {
#line 1276
    __cil_tmp45 = ParseNum(act, & display->d_obufmax);
    }
#line 1276
    if (__cil_tmp45 == 0) {
#line 1276
      if (msgok) {
#line 1277
        if (! act->quiet) {
#line 1277
          tmp___194 = Msg;
        } else {
#line 1277
          if (queryflag >= 0) {
#line 1277
            tmp___193 = QueryMsg;
          } else {
#line 1277
            tmp___193 = Dummy;
          }
#line 1277
          tmp___194 = tmp___193;
        }
        {
#line 1277
        tmp___194(0, (char const   *)((char *)"Limit set to %d"), display->d_obufmax);
        }
      }
    }
  }
#line 1278
  display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
#line 1279
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 1281
  WriteFile(user, (char *)0, 0);
  }
#line 1282
  goto switch_break;
  case_84: /* CIL Label */ 
#line 1285
  mode = 1;
#line 1286
  file = (char *)((void *)0);
#line 1288
  if (*(args + 0)) {
    {
#line 1290
    __cil_tmp50 = strcmp((char const   *)*args, (char const   *)((char *)"-h"));
    }
#line 1290
    if (! __cil_tmp50) {
#line 1292
      mode = 3;
#line 1293
      file = *(args + 1);
    } else {
      {
#line 1295
      __cil_tmp51 = strcmp((char const   *)*args, (char const   *)((char *)"--"));
      }
#line 1295
      if (! __cil_tmp51) {
#line 1295
        if (*(args + 1)) {
#line 1296
          file = *(args + 1);
        } else {
#line 1298
          file = *(args + 0);
        }
      } else {
#line 1298
        file = *(args + 0);
      }
    }
  }
#line 1301
  if (*(args + 0)) {
#line 1301
    if (file == *(args + 0)) {
#line 1301
      if (*(args + 1)) {
#line 1303
        if (! act->quiet) {
#line 1303
          tmp___196 = Msg;
        } else {
#line 1303
          if (queryflag >= 0) {
#line 1303
            tmp___195 = QueryMsg;
          } else {
#line 1303
            tmp___195 = Dummy;
          }
#line 1303
          tmp___196 = tmp___195;
        }
        {
#line 1303
        tmp___196(0, (char const   *)((char *)"%s: hardcopy: too many arguments"),
                  rc_name);
        }
#line 1304
        goto switch_break;
      }
    }
  }
  {
#line 1306
  WriteFile(user, file, mode);
  }
#line 1308
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 1310
  __cil_tmp54 = ParseOnOff(act, & nwin_default.Lflag);
  }
#line 1311
  goto switch_break;
  case_101: /* CIL Label */ 
#line 1313
  if (fore->w_log) {
#line 1313
    tmp___197 = 1;
  } else {
#line 1313
    tmp___197 = 0;
  }
  {
#line 1313
  n = tmp___197;
#line 1314
  ParseSwitch(act, & n);
#line 1315
  LogToggle(n);
  }
#line 1316
  goto switch_break;
  case_162: /* CIL Label */ 
  {
#line 1319
  Detach(1);
  }
#line 1320
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 1323
  __cil_tmp56 = MoreWindows();
  }
#line 1323
  if (__cil_tmp56) {
    {
#line 1324
    __cil_tmp57 = NextWindow();
#line 1324
    SwitchWindow(__cil_tmp57);
    }
  }
#line 1325
  goto switch_break;
  case_130: /* CIL Label */ 
  {
#line 1327
  __cil_tmp58 = MoreWindows();
  }
#line 1327
  if (__cil_tmp58) {
    {
#line 1328
    __cil_tmp59 = PreviousWindow();
#line 1328
    SwitchWindow(__cil_tmp59);
    }
  }
#line 1329
  goto switch_break;
  case_96: /* CIL Label */ 
#line 1334
  if (key >= 0) {
#line 1337
    if (fore->w_pwin) {
#line 1337
      tmp___198 = (char *)"Really kill this filter [y/n]";
    } else {
#line 1337
      tmp___198 = (char *)"Really kill this window [y/n]";
    }
    {
#line 1337
    Input(tmp___198, 1, 2, confirm_fn, (char *)((void *)0), 96);
    }
#line 1341
    goto switch_break;
  }
#line 1343
  n = fore->w_number;
#line 1345
  if (fore->w_pwin) {
    {
#line 1347
    FreePseudowin(fore);
    }
#line 1348
    if (! act->quiet) {
#line 1348
      tmp___200 = Msg;
    } else {
#line 1348
      if (queryflag >= 0) {
#line 1348
        tmp___199 = QueryMsg;
      } else {
#line 1348
        tmp___199 = Dummy;
      }
#line 1348
      tmp___200 = tmp___199;
    }
    {
#line 1348
    tmp___200(0, (char const   *)((char *)"Filter removed."));
    }
#line 1349
    goto switch_break;
  }
  {
#line 1352
  name = SaveStr((char const   *)fore->w_title);
#line 1353
  KillWindow(fore);
  }
#line 1354
  if (! act->quiet) {
#line 1354
    tmp___202 = Msg;
  } else {
#line 1354
    if (queryflag >= 0) {
#line 1354
      tmp___201 = QueryMsg;
    } else {
#line 1354
      tmp___201 = Dummy;
    }
#line 1354
    tmp___202 = tmp___201;
  }
  {
#line 1354
  tmp___202(0, (char const   *)((char *)"Window %d (%s) killed."), n, name);
  }
#line 1355
  if (name) {
    {
#line 1356
    free((void *)name);
    }
  }
#line 1357
  goto switch_break;
  case_133: /* CIL Label */ 
#line 1360
  if (key >= 0) {
    {
#line 1362
    Input((char *)"Really quit and kill all your windows [y/n]", 1, 2, confirm_fn,
          (char *)((void *)0), 133);
    }
#line 1363
    goto switch_break;
  }
  {
#line 1365
  Finit(0);
  }
  case_67: /* CIL Label */ 
  {
#line 1369
  __cil_tmp67 = strcmp((char const   *)*args, (char const   *)((char *)"-h"));
  }
#line 1369
  if (*args) {
#line 1369
    if (! __cil_tmp67) {
      {
#line 1370
      Hangup();
      }
    } else {
      {
      {
#line 1372
      Detach(0);
      }
      }
    }
  } else {
    {
    {
#line 1372
    Detach(0);
    }
    }
  }
#line 1373
  goto switch_break;
  case_128: /* CIL Label */ 
#line 1376
  if (key >= 0) {
    {
#line 1380
    buf[0] = (char )key;
#line 1381
    Input((char *)buf, 1, 2, pow_detach_fn, (char *)((void *)0), 0);
    }
  } else {
    {
#line 1384
    Detach(3);
    }
  }
#line 1385
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 1412
  __cil_tmp69 = strcmp((char const   *)((char *)"off"), (char const   *)*args);
  }
#line 1412
  if (*args == (char *)0) {
    _L___205: /* CIL Label */ 
#line 1413
    if (! act->quiet) {
#line 1413
      tmp___204 = Msg;
    } else {
#line 1413
      if (queryflag >= 0) {
#line 1413
        tmp___203 = QueryMsg;
      } else {
#line 1413
        tmp___203 = Dummy;
      }
#line 1413
      tmp___204 = tmp___203;
    }
    {
#line 1413
    tmp___204(0, (char const   *)((char *)"Sorry, screen was compiled without -DDEBUG option."));
    }
  } else
#line 1412
  if (__cil_tmp69) {
#line 1412
    goto _L___205;
  }
#line 1415
  goto switch_break;
  case_187: /* CIL Label */ 
  {
#line 1418
  __cil_tmp72 = strcmp((char const   *)*args, (char const   *)((char *)"sendcmd"));
  }
#line 1418
  if (*args) {
#line 1418
    if (! __cil_tmp72) {
#line 1420
      if (*(args + 1)) {
        {
#line 1422
        free((void *)zmodem_sendcmd);
#line 1423
        zmodem_sendcmd = SaveStr((char const   *)*(args + 1));
        }
      }
#line 1425
      if (msgok) {
#line 1426
        if (! act->quiet) {
#line 1426
          tmp___207 = Msg;
        } else {
#line 1426
          if (queryflag >= 0) {
#line 1426
            tmp___206 = QueryMsg;
          } else {
#line 1426
            tmp___206 = Dummy;
          }
#line 1426
          tmp___207 = tmp___206;
        }
        {
#line 1426
        tmp___207(0, (char const   *)((char *)"zmodem sendcmd: %s"), zmodem_sendcmd);
        }
      }
#line 1427
      goto switch_break;
    }
  }
  {
#line 1429
  __cil_tmp76 = strcmp((char const   *)*args, (char const   *)((char *)"recvcmd"));
  }
#line 1429
  if (*args) {
#line 1429
    if (! __cil_tmp76) {
#line 1431
      if (*(args + 1)) {
        {
#line 1433
        free((void *)zmodem_recvcmd);
#line 1434
        zmodem_recvcmd = SaveStr((char const   *)*(args + 1));
        }
      }
#line 1436
      if (msgok) {
#line 1437
        if (! act->quiet) {
#line 1437
          tmp___209 = Msg;
        } else {
#line 1437
          if (queryflag >= 0) {
#line 1437
            tmp___208 = QueryMsg;
          } else {
#line 1437
            tmp___208 = Dummy;
          }
#line 1437
          tmp___209 = tmp___208;
        }
        {
#line 1437
        tmp___209(0, (char const   *)((char *)"zmodem recvcmd: %s"), zmodem_recvcmd);
        }
      }
#line 1438
      goto switch_break;
    }
  }
#line 1440
  if (*args) {
#line 1442
    i = 0;
    {
#line 1442
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1442
      if (! (i < 4)) {
#line 1442
        goto while_break___0;
      }
      {
#line 1443
      __cil_tmp80 = strcmp((char const   *)zmodes[i], (char const   *)*args);
      }
#line 1443
      if (! __cil_tmp80) {
#line 1444
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1442
    i ++;
#line 1445
    __cil_tmp82 = strcmp((char const   *)*args, (char const   *)((char *)"on"));
    }
#line 1445
    if (i == 4) {
#line 1445
      if (! __cil_tmp82) {
#line 1446
        i = 1;
      }
    }
#line 1447
    if (i == 4) {
#line 1449
      if (! act->quiet) {
#line 1449
        tmp___211 = Msg;
      } else {
#line 1449
        if (queryflag >= 0) {
#line 1449
          tmp___210 = QueryMsg;
        } else {
#line 1449
          tmp___210 = Dummy;
        }
#line 1449
        tmp___211 = tmp___210;
      }
      {
#line 1449
      tmp___211(0, (char const   *)((char *)"usage: zmodem off|auto|catch|pass"));
      }
#line 1450
      goto switch_break;
    }
#line 1452
    zmodem_mode = i;
  }
#line 1454
  if (msgok) {
#line 1455
    if (! act->quiet) {
#line 1455
      tmp___213 = Msg;
    } else {
#line 1455
      if (queryflag >= 0) {
#line 1455
        tmp___212 = QueryMsg;
      } else {
#line 1455
        tmp___212 = Dummy;
      }
#line 1455
      tmp___213 = tmp___212;
    }
    {
#line 1455
    tmp___213(0, (char const   *)((char *)"zmodem mode is %s"), zmodes[zmodem_mode]);
    }
  }
#line 1456
  goto switch_break;
  case_170: /* CIL Label */ 
#line 1462
  i___214 = (unsigned int )0;
  {
#line 1462
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1462
    if (! ((unsigned long )i___214 < sizeof(ktab) / sizeof(*((struct action *)ktab)))) {
#line 1462
      goto while_break___1;
    }
    {
#line 1463
    ClearAction(& ktab[i___214]);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1462
  i___214 ++;
#line 1464
  if (! act->quiet) {
#line 1464
    tmp___216 = Msg;
  } else {
#line 1464
    if (queryflag >= 0) {
#line 1464
      tmp___215 = QueryMsg;
    } else {
#line 1464
      tmp___215 = Dummy;
    }
#line 1464
    tmp___216 = tmp___215;
  }
  {
#line 1464
  tmp___216(0, (char const   *)((char *)"Unbound all keys."));
  }
#line 1465
  goto switch_break;
  case_188: /* CIL Label */ 
#line 1469
  s = *args;
#line 1469
  if (! s) {
#line 1471
    ZombieKey_destroy = 0;
#line 1472
    goto switch_break;
  }
#line 1474
  if (*argl == 0) {
    _L___219: /* CIL Label */ 
#line 1476
    if (! act->quiet) {
#line 1476
      tmp___218 = Msg;
    } else {
#line 1476
      if (queryflag >= 0) {
#line 1476
        tmp___217 = QueryMsg;
      } else {
#line 1476
        tmp___217 = Dummy;
      }
#line 1476
      tmp___218 = tmp___217;
    }
    {
#line 1476
    tmp___218(0, (char const   *)((char *)"%s:zombie: one or two characters expected."),
              rc_name);
    }
#line 1477
    goto switch_break;
  } else
#line 1474
  if (*argl > 2) {
#line 1474
    goto _L___219;
  }
#line 1479
  if (*(args + 1)) {
    {
#line 1481
    __cil_tmp93 = strcmp((char const   *)*(args + 1), (char const   *)((char *)"onerror"));
    }
#line 1481
    if (! __cil_tmp93) {
#line 1483
      ZombieKey_onerror = 1;
    } else {
#line 1485
      if (! act->quiet) {
#line 1485
        tmp___221 = Msg;
      } else {
#line 1485
        if (queryflag >= 0) {
#line 1485
          tmp___220 = QueryMsg;
        } else {
#line 1485
          tmp___220 = Dummy;
        }
#line 1485
        tmp___221 = tmp___220;
      }
      {
#line 1485
      tmp___221(0, (char const   *)((char *)"usage: zombie [keys [onerror]]"));
      }
#line 1486
      goto switch_break;
    }
  } else {
#line 1489
    ZombieKey_onerror = 0;
  }
#line 1490
  ZombieKey_destroy = (int )*(*(args + 0) + 0);
#line 1491
  if (*argl == 2) {
#line 1491
    tmp___222 = (int )*(*(args + 0) + 1);
  } else {
#line 1491
    tmp___222 = 0;
  }
#line 1491
  ZombieKey_resurrect = tmp___222;
#line 1493
  goto switch_break;
  case_178: /* CIL Label */ 
#line 1496
  s = (char *)(display->d_user)->u_name;
#line 1501
  olddisplay = display;
#line 1502
  display = (struct display *)0;
#line 1503
  if (! act->quiet) {
#line 1503
    tmp___224 = Msg;
  } else {
#line 1503
    if (queryflag >= 0) {
#line 1503
      tmp___223 = QueryMsg;
    } else {
#line 1503
      tmp___223 = Dummy;
    }
#line 1503
    tmp___224 = tmp___223;
  }
  {
#line 1503
  tmp___224(0, (char const   *)((char *)"%s: %s"), s, *args);
#line 1504
  display = olddisplay;
  }
#line 1506
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1509
  if (! user) {
#line 1510
    goto switch_break;
  }
  {
#line 1512
  s = SaveStr((char const   *)((char *)user->u_name));
#line 1514
  EffectiveAclUser = user;
#line 1518
  __cil_tmp101 = strlen((char const   *)*(args + 0));
#line 1518
  n = (int )__cil_tmp101;
  }
#line 1519
  if (n) {
#line 1519
    __cil_tmp102 = n;
#line 1519
    n --;
  }
  {
#line 1527
  if ((int )*(*(args + 0) + n) == '*') {
#line 1527
    goto case_42;
  }
#line 1570
  if ((int )*(*(args + 0) + n) == '%') {
#line 1570
    goto case_37;
  }
#line 1599
  if ((int )*(*(args + 0) + n) == '#') {
#line 1599
    goto case_35;
  }
#line 1602
  goto switch_default;
  case_42: /* CIL Label */ 
#line 1532
  if (! n) {
#line 1533
    u = user;
  } else {
#line 1536
    u = users;
    {
#line 1536
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1536
      if (! u) {
#line 1536
        goto while_break___2;
      }
      {
#line 1538
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1538
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1539
      __cil_tmp105 = strncmp((char const   *)*args, (char const   *)((char *)u->u_name),
                             (unsigned long )n);
      }
#line 1539
      if (! __cil_tmp105) {
#line 1540
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1536
    u = u->u_next;
#line 1542
    if (! u) {
#line 1544
      *(*(args + 0) + n) = (char )'\000';
#line 1545
      if (! act->quiet) {
#line 1545
        tmp___226 = Msg;
      } else {
#line 1545
        if (queryflag >= 0) {
#line 1545
          tmp___225 = QueryMsg;
        } else {
#line 1545
          tmp___225 = Dummy;
        }
#line 1545
        tmp___226 = tmp___225;
      }
      {
#line 1545
      tmp___226(0, (char const   *)((char *)"Did not find any user matching \'%s\'"),
                *(args + 0));
      }
#line 1546
      goto switch_break___0;
    }
  }
  {
#line 1549
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1549
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1550
  display = displays;
  {
#line 1550
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1550
    if (! display) {
#line 1550
      goto while_break___5;
    }
#line 1552
    nd = display->d_next;
#line 1553
    if (display->d_forecv == (struct canvas *)0) {
#line 1554
      goto while_continue___5;
    }
#line 1555
    flayer = (display->d_forecv)->c_layer;
#line 1556
    fore = display->d_fore;
#line 1557
    if (display->d_user != u) {
#line 1558
      goto while_continue___5;
    }
    {
#line 1559
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1559
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 1560
    DoCommand(args + 1, argl + 1);
    }
#line 1561
    if (display) {
#line 1562
      if (! act->quiet) {
#line 1562
        tmp___228 = Msg;
      } else {
#line 1562
        if (queryflag >= 0) {
#line 1562
          tmp___227 = QueryMsg;
        } else {
#line 1562
          tmp___227 = Dummy;
        }
#line 1562
        tmp___228 = tmp___227;
      }
#line 1562
      if (*(args + 2)) {
#line 1562
        tmp___229 = *(args + 2);
      } else {
#line 1562
        tmp___229 = (char *)"";
      }
      {
#line 1562
      tmp___228(0, (char const   *)((char *)"command from %s: %s %s"), s, *(args + 1),
                tmp___229);
      }
    }
#line 1564
    display = (struct display *)((void *)0);
#line 1565
    flayer = (struct layer *)0;
#line 1566
    fore = (struct win *)((void *)0);
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1550
  display = nd;
#line 1568
  goto switch_break___0;
  case_37: /* CIL Label */ 
  {
#line 1574
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1574
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1575
  display = displays;
  {
#line 1575
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1575
    if (! display) {
#line 1575
      goto while_break___8;
    }
#line 1577
    nd___0 = display->d_next;
#line 1578
    if (display->d_forecv == (struct canvas *)0) {
#line 1579
      goto while_continue___8;
    }
    {
#line 1580
    fore = display->d_fore;
#line 1581
    flayer = (display->d_forecv)->c_layer;
#line 1582
    __cil_tmp116 = strncmp((char const   *)*(args + 0), (char const   *)((char *)display->d_usertty + 8),
                           (unsigned long )n);
    }
    {
#line 1582
    __cil_tmp115 = strncmp((char const   *)((char *)"/dev/tty"), (char const   *)((char *)display->d_usertty),
                           (unsigned long )8);
    }
    {
#line 1582
    __cil_tmp114 = strncmp((char const   *)*(args + 0), (char const   *)((char *)display->d_usertty + 5),
                           (unsigned long )n);
    }
    {
#line 1582
    __cil_tmp113 = strncmp((char const   *)((char *)"/dev/"), (char const   *)((char *)display->d_usertty),
                           (unsigned long )5);
    }
    {
#line 1582
    __cil_tmp112 = strncmp((char const   *)*(args + 0), (char const   *)((char *)display->d_usertty),
                           (unsigned long )n);
    }
#line 1582
    if (__cil_tmp112) {
#line 1582
      if (__cil_tmp113) {
        _L___230: /* CIL Label */ 
#line 1582
        if (__cil_tmp115) {
#line 1587
          goto while_continue___8;
        } else
#line 1582
        if (__cil_tmp116) {
#line 1587
          goto while_continue___8;
        }
      } else
#line 1582
      if (__cil_tmp114) {
#line 1582
        goto _L___230;
      }
    }
    {
#line 1588
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1588
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 1589
    DoCommand(args + 1, argl + 1);
    }
#line 1590
    if (display) {
#line 1591
      if (! act->quiet) {
#line 1591
        tmp___232 = Msg;
      } else {
#line 1591
        if (queryflag >= 0) {
#line 1591
          tmp___231 = QueryMsg;
        } else {
#line 1591
          tmp___231 = Dummy;
        }
#line 1591
        tmp___232 = tmp___231;
      }
#line 1591
      if (*(args + 2)) {
#line 1591
        tmp___233 = *(args + 2);
      } else {
#line 1591
        tmp___233 = (char *)"";
      }
      {
#line 1591
      tmp___232(0, (char const   *)((char *)"command from %s: %s %s"), s, *(args + 1),
                tmp___233);
      }
    }
#line 1593
    display = (struct display *)((void *)0);
#line 1594
    fore = (struct win *)((void *)0);
#line 1595
    flayer = (struct layer *)0;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1575
  display = nd___0;
#line 1597
  goto switch_break___0;
  case_35: /* CIL Label */ 
#line 1600
  __cil_tmp120 = n;
#line 1600
  n --;
  switch_default: /* CIL Label */ 
  {
#line 1607
  n ++;
#line 1608
  ch___234 = (int )*(*(args + 0) + n);
#line 1609
  *(*(args + 0) + n) = (char )'\000';
#line 1610
  i = WindowByNumber(*(args + 0));
  }
#line 1610
  if (! *(*(args + 0))) {
    _L___248: /* CIL Label */ 
#line 1612
    *(*(args + 0) + n) = (char )ch___234;
#line 1614
    fore = windows;
    {
#line 1614
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1614
      if (! fore) {
#line 1614
        goto while_break___10;
      }
      {
#line 1616
      nw = fore->w_next;
#line 1617
      __cil_tmp125 = strncmp((char const   *)*(args + 0), (char const   *)fore->w_title,
                             (unsigned long )n);
      }
#line 1617
      if (__cil_tmp125) {
#line 1618
        goto while_continue___10;
      }
      {
#line 1619
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1619
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1627
      i = 0;
#line 1629
      if (fore->w_layer.l_cvlist) {
#line 1630
        display = (fore->w_layer.l_cvlist)->c_display;
      }
#line 1631
      if (fore->w_savelayer) {
#line 1631
        tmp___235 = fore->w_savelayer;
      } else {
#line 1631
        tmp___235 = & fore->w_layer;
      }
      {
#line 1631
      flayer = tmp___235;
#line 1632
      DoCommand(args + 1, argl + 1);
      }
#line 1633
      if (fore) {
#line 1633
        if (fore->w_layer.l_cvlist) {
#line 1635
          display = (fore->w_layer.l_cvlist)->c_display;
#line 1636
          if (! act->quiet) {
#line 1636
            tmp___237 = Msg;
          } else {
#line 1636
            if (queryflag >= 0) {
#line 1636
              tmp___236 = QueryMsg;
            } else {
#line 1636
              tmp___236 = Dummy;
            }
#line 1636
            tmp___237 = tmp___236;
          }
#line 1636
          if (*(args + 2)) {
#line 1636
            tmp___238 = *(args + 2);
          } else {
#line 1636
            tmp___238 = (char *)"";
          }
          {
#line 1636
          tmp___237(0, (char const   *)((char *)"command from %s: %s %s"), s, *(args + 1),
                    tmp___238);
          }
        }
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1614
    fore = nw;
#line 1640
    display = (struct display *)((void *)0);
#line 1641
    fore = (struct win *)((void *)0);
#line 1642
    if (i < 0) {
#line 1643
      if (! act->quiet) {
#line 1643
        tmp___240 = Msg;
      } else {
#line 1643
        if (queryflag >= 0) {
#line 1643
          tmp___239 = QueryMsg;
        } else {
#line 1643
          tmp___239 = Dummy;
        }
#line 1643
        tmp___240 = tmp___239;
      }
      {
#line 1643
      tmp___240(0, (char const   *)((char *)"%s: at \'%s\': no such window.\n"), rc_name,
                *(args + 0));
      }
    }
#line 1644
    goto switch_break___0;
  } else
#line 1610
  if (i < 0) {
#line 1610
    goto _L___248;
  } else {
#line 1646
    fore = *(wtab + i);
#line 1646
    if (i < maxwin) {
#line 1646
      if (fore) {
#line 1648
        *(*(args + 0) + n) = (char )ch___234;
        {
#line 1649
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1649
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1650
        if (fore->w_layer.l_cvlist) {
#line 1651
          display = (fore->w_layer.l_cvlist)->c_display;
        }
#line 1652
        if (fore->w_savelayer) {
#line 1652
          tmp___241 = fore->w_savelayer;
        } else {
#line 1652
          tmp___241 = & fore->w_layer;
        }
        {
#line 1652
        flayer = tmp___241;
#line 1653
        DoCommand(args + 1, argl + 1);
        }
#line 1654
        if (fore) {
#line 1654
          if (fore->w_layer.l_cvlist) {
#line 1656
            display = (fore->w_layer.l_cvlist)->c_display;
#line 1657
            if (! act->quiet) {
#line 1657
              tmp___243 = Msg;
            } else {
#line 1657
              if (queryflag >= 0) {
#line 1657
                tmp___242 = QueryMsg;
              } else {
#line 1657
                tmp___242 = Dummy;
              }
#line 1657
              tmp___243 = tmp___242;
            }
#line 1657
            if (*(args + 2)) {
#line 1657
              tmp___244 = *(args + 2);
            } else {
#line 1657
              tmp___244 = (char *)"";
            }
            {
#line 1657
            tmp___243(0, (char const   *)((char *)"command from %s: %s %s"), s, *(args + 1),
                      tmp___244);
            }
          }
        }
#line 1660
        display = (struct display *)((void *)0);
#line 1661
        fore = (struct win *)((void *)0);
      } else {
#line 1646
        goto _L___247;
      }
    } else {
      _L___247: /* CIL Label */ 
#line 1664
      if (! act->quiet) {
#line 1664
        tmp___246 = Msg;
      } else {
#line 1664
        if (queryflag >= 0) {
#line 1664
          tmp___245 = QueryMsg;
        } else {
#line 1664
          tmp___245 = Dummy;
        }
#line 1664
        tmp___246 = tmp___245;
      }
      {
#line 1664
      tmp___246(0, (char const   *)((char *)"%s: at [identifier][%%|*|#] command [args]"),
                rc_name);
      }
    }
  }
#line 1665
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1668
  free((void *)s);
#line 1670
  EffectiveAclUser = (struct acluser *)((void *)0);
  }
#line 1672
  goto switch_break;
  case_135: /* CIL Label */ 
#line 1677
  if (fore) {
#line 1677
    tmp___250 = fore->w_layer.l_encoding;
  } else {
#line 1677
    if (display) {
#line 1677
      tmp___249 = display->d_encoding;
    } else {
#line 1677
      tmp___249 = 0;
    }
#line 1677
    tmp___250 = tmp___249;
  }
  {
#line 1677
  i = tmp___250;
#line 1678
  __cil_tmp140 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-e"));
  }
#line 1678
  if (*(args + 0)) {
#line 1678
    if (*(args + 1)) {
#line 1678
      if (! __cil_tmp140) {
        {
#line 1680
        i = FindEncoding(*(args + 1));
        }
#line 1681
        if (i == -1) {
#line 1683
          if (! act->quiet) {
#line 1683
            tmp___252 = Msg;
          } else {
#line 1683
            if (queryflag >= 0) {
#line 1683
              tmp___251 = QueryMsg;
            } else {
#line 1683
              tmp___251 = Dummy;
            }
#line 1683
            tmp___252 = tmp___251;
          }
          {
#line 1683
          tmp___252(0, (char const   *)((char *)"%s: readreg: unknown encoding"),
                    rc_name);
          }
#line 1684
          goto switch_break;
        }
#line 1686
        args += 2;
      }
    }
  }
#line 1695
  s = *args;
#line 1695
  if (s == (char *)((void *)0)) {
    {
#line 1697
    Input((char *)"Copy to register:", 1, 2, copy_reg_fn, (char *)((void *)0), 0);
    }
#line 1698
    goto switch_break;
  }
#line 1700
  if (*argl != 1) {
#line 1702
    if (! act->quiet) {
#line 1702
      tmp___254 = Msg;
    } else {
#line 1702
      if (queryflag >= 0) {
#line 1702
        tmp___253 = QueryMsg;
      } else {
#line 1702
        tmp___253 = Dummy;
      }
#line 1702
      tmp___254 = tmp___253;
    }
    {
#line 1702
    tmp___254(0, (char const   *)((char *)"%s: copyreg: character, ^x, or (octal) \\032 expected."),
              rc_name);
    }
#line 1703
    goto switch_break;
  }
#line 1705
  ch = *(*(args + 0) + 0);
#line 1709
  if (*(args + 1)) {
#line 1711
    if (*(args + 2)) {
#line 1713
      if (! act->quiet) {
#line 1713
        tmp___256 = Msg;
      } else {
#line 1713
        if (queryflag >= 0) {
#line 1713
          tmp___255 = QueryMsg;
        } else {
#line 1713
          tmp___255 = Dummy;
        }
#line 1713
        tmp___256 = tmp___255;
      }
      {
#line 1713
      tmp___256(0, (char const   *)((char *)"%s: readreg: too many arguments"), rc_name);
      }
#line 1714
      goto switch_break;
    }
    {
#line 1716
    s = ReadFile(*(args + 1), & n);
    }
#line 1716
    if (s) {
#line 1718
      pp = (struct plop *)plop_tab + (int )((unsigned char )ch);
#line 1720
      if (pp->buf) {
        {
#line 1721
        free((void *)pp->buf);
        }
      }
#line 1722
      pp->buf = s;
#line 1723
      pp->len = n;
#line 1725
      pp->enc = i;
    }
  } else {
    {
#line 1735
    copy_reg_fn(& ch, 0, (char *)((void *)0));
    }
  }
#line 1736
  goto switch_break;
  case_137: /* CIL Label */ 
#line 1740
  if (fore) {
#line 1740
    tmp___258 = fore->w_layer.l_encoding;
  } else {
#line 1740
    if (display) {
#line 1740
      tmp___257 = display->d_encoding;
    } else {
#line 1740
      tmp___257 = 0;
    }
#line 1740
    tmp___258 = tmp___257;
  }
  {
#line 1740
  i = tmp___258;
#line 1741
  __cil_tmp152 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-e"));
  }
#line 1741
  if (*(args + 0)) {
#line 1741
    if (*(args + 1)) {
#line 1741
      if (! __cil_tmp152) {
        {
#line 1743
        i = FindEncoding(*(args + 1));
        }
#line 1744
        if (i == -1) {
#line 1746
          if (! act->quiet) {
#line 1746
            tmp___260 = Msg;
          } else {
#line 1746
            if (queryflag >= 0) {
#line 1746
              tmp___259 = QueryMsg;
            } else {
#line 1746
              tmp___259 = Dummy;
            }
#line 1746
            tmp___260 = tmp___259;
          }
          {
#line 1746
          tmp___260(0, (char const   *)((char *)"%s: register: unknown encoding"),
                    rc_name);
          }
#line 1747
          goto switch_break;
        }
#line 1749
        args += 2;
#line 1750
        argc -= 2;
      }
    }
  }
#line 1753
  if (argc != 2) {
#line 1755
    if (! act->quiet) {
#line 1755
      tmp___262 = Msg;
    } else {
#line 1755
      if (queryflag >= 0) {
#line 1755
        tmp___261 = QueryMsg;
      } else {
#line 1755
        tmp___261 = Dummy;
      }
#line 1755
      tmp___262 = tmp___261;
    }
    {
#line 1755
    tmp___262(0, (char const   *)((char *)"%s: register: illegal number of arguments."),
              rc_name);
    }
#line 1756
    goto switch_break;
  }
#line 1758
  if (*argl != 1) {
#line 1760
    if (! act->quiet) {
#line 1760
      tmp___264 = Msg;
    } else {
#line 1760
      if (queryflag >= 0) {
#line 1760
        tmp___263 = QueryMsg;
      } else {
#line 1760
        tmp___263 = Dummy;
      }
#line 1760
      tmp___264 = tmp___263;
    }
    {
#line 1760
    tmp___264(0, (char const   *)((char *)"%s: register: character, ^x, or (octal) \\032 expected."),
              rc_name);
    }
#line 1761
    goto switch_break;
  }
#line 1763
  ch = *(*(args + 0) + 0);
#line 1765
  if ((int )ch == 46) {
#line 1767
    if (user->u_plop.buf != (char *)((void *)0)) {
      {
#line 1768
      UserFreeCopyBuffer(user);
      }
    }
#line 1769
    if (*(args + 1)) {
#line 1769
      if ((int )*(*(args + 1) + 0)) {
        {
#line 1771
        user->u_plop.buf = SaveStrn((char const   *)*(args + 1), *(argl + 1));
#line 1772
        user->u_plop.len = *(argl + 1);
#line 1774
        user->u_plop.enc = i;
        }
      }
    }
  } else {
#line 1781
    plp = (struct plop *)plop_tab + (int )((unsigned char )ch);
#line 1783
    if (plp->buf) {
      {
#line 1784
      free((void *)plp->buf);
      }
    }
    {
#line 1785
    plp->buf = SaveStrn((char const   *)*(args + 1), *(argl + 1));
#line 1786
    plp->len = *(argl + 1);
#line 1788
    plp->enc = i;
    }
  }
#line 1791
  goto switch_break;
  case_132: /* CIL Label */ 
#line 1793
  s = *args;
#line 1793
  if (s == (char *)((void *)0)) {
    {
#line 1795
    Input((char *)"Process register:", 1, 2, process_fn, (char *)((void *)0), 0);
    }
#line 1796
    goto switch_break;
  }
#line 1798
  if (*argl != 1) {
#line 1800
    if (! act->quiet) {
#line 1800
      tmp___266 = Msg;
    } else {
#line 1800
      if (queryflag >= 0) {
#line 1800
        tmp___265 = QueryMsg;
      } else {
#line 1800
        tmp___265 = Dummy;
      }
#line 1800
      tmp___266 = tmp___265;
    }
    {
#line 1800
    tmp___266(0, (char const   *)((char *)"%s: process: character, ^x, or (octal) \\032 expected."),
              rc_name);
    }
#line 1801
    goto switch_break;
  }
  {
#line 1803
  ch = *(*(args + 0) + 0);
#line 1804
  process_fn(& ch, 0, (char *)((void *)0));
  }
#line 1805
  goto switch_break;
  case_160: /* CIL Label */ 
#line 1807
  s = *args;
#line 1808
  if (! *(args + 0)) {
    {
#line 1810
    Input((char *)"Stuff:", 100, 0, StuffFin, (char *)((void *)0), 0);
    }
#line 1811
    goto switch_break;
  }
#line 1813
  n = *argl;
#line 1814
  if (*(args + 1)) {
    {
#line 1816
    __cil_tmp165 = strcmp((char const   *)s, (char const   *)((char *)"-k"));
    }
#line 1816
    if (__cil_tmp165) {
#line 1818
      if (! act->quiet) {
#line 1818
        tmp___268 = Msg;
      } else {
#line 1818
        if (queryflag >= 0) {
#line 1818
          tmp___267 = QueryMsg;
        } else {
#line 1818
          tmp___267 = Dummy;
        }
#line 1818
        tmp___268 = tmp___267;
      }
      {
#line 1818
      tmp___268(0, (char const   *)((char *)"%s: stuff: invalid option %s"), rc_name,
                s);
      }
#line 1819
      goto switch_break;
    }
#line 1821
    s = *(args + 1);
#line 1822
    i = 106;
    {
#line 1822
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1822
      if (! (i < 188)) {
#line 1822
        goto while_break___13;
      }
      {
#line 1823
      __cil_tmp168 = strcmp((char const   *)term[i].tcname, (char const   *)s);
      }
#line 1823
      if (__cil_tmp168 == 0) {
#line 1824
        goto while_break___13;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1822
    i ++;
#line 1825
    if (i == 188) {
#line 1827
      if (! act->quiet) {
#line 1827
        tmp___270 = Msg;
      } else {
#line 1827
        if (queryflag >= 0) {
#line 1827
          tmp___269 = QueryMsg;
        } else {
#line 1827
          tmp___269 = Dummy;
        }
#line 1827
        tmp___270 = tmp___269;
      }
      {
#line 1827
      tmp___270(0, (char const   *)((char *)"%s: stuff: unknown key \'%s\'"), rc_name,
                s);
      }
#line 1828
      goto switch_break;
    }
    {
#line 1831
    __cil_tmp172 = StuffKey(i - 106);
    }
#line 1831
    if (__cil_tmp172 == 0) {
#line 1832
      goto switch_break;
    }
#line 1834
    if (display) {
#line 1834
      tmp___271 = display->d_tcs[i].str;
    } else {
#line 1834
      tmp___271 = (char *)0;
    }
#line 1834
    s = tmp___271;
#line 1835
    if (s == (char *)0) {
#line 1836
      goto switch_break;
    }
    {
#line 1837
    __cil_tmp174 = strlen((char const   *)s);
#line 1837
    n = (int )__cil_tmp174;
    }
  }
  {
#line 1839
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 1839
    if (! n) {
#line 1839
      goto while_break___14;
    }
    {
#line 1840
    (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 1841
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 1843
  Activate(- 1);
  }
#line 1844
  goto switch_break;
  case_181: /* CIL Label */ 
#line 1846
  if (*(args + 0)) {
    {
#line 1847
    ShowWindowsX(*(args + 0));
    }
#line 1848
    goto switch_break;
  }
  {
#line 1850
  ShowWindows(- 1);
  }
#line 1851
  goto switch_break;
  case_177: /* CIL Label */ 
#line 1853
  if (! act->quiet) {
#line 1853
    tmp___273 = Msg;
  } else {
#line 1853
    if (queryflag >= 0) {
#line 1853
      tmp___272 = QueryMsg;
    } else {
#line 1853
      tmp___272 = Dummy;
    }
#line 1853
    tmp___273 = tmp___272;
  }
  {
#line 1853
  tmp___273(0, (char const   *)((char *)"screen %s"), (char *)version);
  }
#line 1854
  goto switch_break;
  case_167: /* CIL Label */ 
#line 1856
  if (*args) {
    {
#line 1858
    timestring = SaveStr((char const   *)*args);
    }
#line 1859
    goto switch_break;
  }
#line 1861
  if (! act->quiet) {
#line 1861
    tmp___275 = Msg;
  } else {
#line 1861
    if (queryflag >= 0) {
#line 1861
      tmp___274 = QueryMsg;
    } else {
#line 1861
      tmp___274 = Dummy;
    }
#line 1861
    tmp___275 = tmp___274;
  }
  {
#line 1861
  __cil_tmp180 = MakeWinMsg(timestring, fore, '%');
#line 1861
  tmp___275(0, (char const   *)((char *)"%s"), __cil_tmp180);
  }
#line 1862
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 1864
  ShowInfo();
  }
#line 1865
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 1867
  ShowDInfo();
  }
#line 1868
  goto switch_break;
  case_35___0: /* CIL Label */ 
  {
#line 1871
  ktabp = (struct action *)ktab;
#line 1872
  __cil_tmp182 = strcmp((char const   *)*args, (char const   *)((char *)"-c"));
  }
#line 1872
  if (argc == 2) {
#line 1872
    if (! __cil_tmp182) {
      {
#line 1874
      ktabp = FindKtab(*(args + 1), 0);
      }
#line 1874
      if (ktabp == (struct action *)0) {
#line 1876
        if (! act->quiet) {
#line 1876
          tmp___277 = Msg;
        } else {
#line 1876
          if (queryflag >= 0) {
#line 1876
            tmp___276 = QueryMsg;
          } else {
#line 1876
            tmp___276 = Dummy;
          }
#line 1876
          tmp___277 = tmp___276;
        }
        {
#line 1876
        tmp___277(0, (char const   *)((char *)"Unknown command class \'%s\'"), *(args + 1));
        }
#line 1877
        goto switch_break;
      }
    }
  }
#line 1880
  if (display->d_ESCseen != (struct action *)ktab) {
    _L___278: /* CIL Label */ 
#line 1882
    if (display->d_ESCseen != ktabp) {
      {
#line 1884
      display->d_ESCseen = ktabp;
#line 1885
      WindowChanged(fore, 'E');
      }
    }
#line 1887
    goto switch_break;
  } else
#line 1880
  if (ktabp != (struct action *)ktab) {
#line 1880
    goto _L___278;
  }
#line 1889
  if (display->d_ESCseen) {
    {
#line 1891
    display->d_ESCseen = (struct action *)0;
#line 1892
    WindowChanged(fore, 'E');
    }
  }
  case_122: /* CIL Label */ 
  {
#line 1897
  __cil_tmp186 = MoreWindows();
  }
#line 1897
  if (__cil_tmp186) {
#line 1898
    if (display && display->d_other) {
#line 1898
      tmp___279 = (display->d_other)->w_number;
    } else {
      {
#line 1898
      __cil_tmp187 = NextWindow();
#line 1898
      tmp___279 = __cil_tmp187;
      }
    }
    {
#line 1898
    SwitchWindow(tmp___279);
    }
  }
#line 1899
  goto switch_break;
  case_110: /* CIL Label */ 
#line 1901
  if (user->u_Esc == -1) {
#line 1902
    goto switch_break;
  }
  {
#line 1903
  ch = (char )user->u_Esc;
#line 1904
  s = & ch;
#line 1905
  n = 1;
#line 1906
  (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
#line 1907
  goto switch_break;
  case_186: /* CIL Label */ 
#line 1909
  ch = (char )17;
  {
#line 1910
  s = & ch;
#line 1911
  n = 1;
#line 1912
  (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
#line 1913
  goto switch_break;
  case_185: /* CIL Label */ 
#line 1915
  ch = (char )19;
  {
#line 1916
  s = & ch;
#line 1917
  n = 1;
#line 1918
  (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
#line 1919
  goto switch_break;
  case_22: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 1926
  if (*args) {
    {
#line 1928
    __cil_tmp191 = ParseNum(act, & n);
    }
#line 1928
    if (__cil_tmp191) {
#line 1929
      n = 0;
      {
#line 1929
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1929
        if (! (n < (int )(sizeof(types) / sizeof(*((char **)types))))) {
#line 1929
          goto while_break___15;
        }
#line 1931
        i = 0;
        {
#line 1931
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 1931
          if (! (i < 4)) {
#line 1931
            goto while_break___16;
          }
#line 1933
          ch = *(*(args + 0) + i);
#line 1934
          if ((int )ch >= 97) {
#line 1934
            if ((int )ch <= 122) {
#line 1935
              ch -= 32;
            }
          }
#line 1936
          if ((int )ch != (int )*(types[n] + i)) {
#line 1936
            if ((int )ch + 32 != (int )*(types[n] + i)) {
#line 1937
              goto while_break___16;
            }
          }
        }
        while_break___16: /* CIL Label */ ;
        }
#line 1931
        i ++;
#line 1939
        if (i == 4) {
#line 1940
          goto while_break___15;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
#line 1929
      n ++;
    }
#line 1942
    if (n < 0) {
      _L___284: /* CIL Label */ 
#line 1943
      if (! act->quiet) {
#line 1943
        tmp___281 = Msg;
      } else {
#line 1943
        if (queryflag >= 0) {
#line 1943
          tmp___280 = QueryMsg;
        } else {
#line 1943
          tmp___280 = Dummy;
        }
#line 1943
        tmp___281 = tmp___280;
      }
      {
#line 1943
      tmp___281(0, (char const   *)((char *)"%s invalid, chose one of %s, %s or %s"),
                *args, types[0], types[1], types[2]);
      }
    } else
#line 1942
    if (n >= (int )(sizeof(types) / sizeof(*((char **)types)))) {
#line 1942
      goto _L___284;
    } else {
#line 1946
      breaktype___0 = n;
#line 1947
      if (! act->quiet) {
#line 1947
        tmp___283 = Msg;
      } else {
#line 1947
        if (queryflag >= 0) {
#line 1947
          tmp___282 = QueryMsg;
        } else {
#line 1947
          tmp___282 = Dummy;
        }
#line 1947
        tmp___283 = tmp___282;
      }
      {
#line 1947
      tmp___283(0, (char const   *)((char *)"breaktype set to (%d) %s"), n, types[n]);
      }
    }
  } else {
#line 1951
    if (! act->quiet) {
#line 1951
      tmp___286 = Msg;
    } else {
#line 1951
      if (queryflag >= 0) {
#line 1951
        tmp___285 = QueryMsg;
      } else {
#line 1951
        tmp___285 = Dummy;
      }
#line 1951
      tmp___286 = tmp___285;
    }
    {
#line 1951
    tmp___286(0, (char const   *)((char *)"breaktype is (%d) %s"), breaktype___0,
              types[breaktype___0]);
    }
  }
#line 1953
  goto switch_break;
  case_21: /* CIL Label */ 
  case_127: /* CIL Label */ 
#line 1956
  n = 0;
  {
#line 1957
  __cil_tmp200 = ParseNum(act, & n);
  }
#line 1957
  if (*args) {
#line 1957
    if (__cil_tmp200) {
#line 1958
      goto switch_break;
    }
  }
  {
#line 1959
  SendBreak(fore, n, nr == 127);
  }
#line 1960
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 1963
  Detach(5);
  }
#line 1964
  goto switch_break;
  case_88: /* CIL Label */ 
  case_179: /* CIL Label */ 
  {
#line 1970
  what = 0;
#line 1972
  i = 1;
#line 1973
  __cil_tmp204 = strcmp((char const   *)*args, (char const   *)((char *)"-w"));
  }
#line 1973
  if (*args) {
#line 1973
    if (! __cil_tmp204) {
#line 1974
      what = 1;
    } else {
#line 1973
      goto _L___287;
    }
  } else {
    _L___287: /* CIL Label */ 
    {
#line 1975
    __cil_tmp205 = strcmp((char const   *)*args, (char const   *)((char *)"-d"));
    }
#line 1975
    if (*args) {
#line 1975
      if (! __cil_tmp205) {
#line 1976
        what = 2;
      }
    }
  }
#line 1977
  if (what) {
#line 1978
    args ++;
  }
#line 1979
  if (what == 0) {
#line 1979
    if (flayer) {
#line 1979
      if (! display) {
#line 1980
        what = 1;
      }
    }
  }
#line 1981
  if (what == 1) {
#line 1983
    if (! flayer) {
#line 1985
      if (! act->quiet) {
#line 1985
        tmp___289 = Msg;
      } else {
#line 1985
        if (queryflag >= 0) {
#line 1985
          tmp___288 = QueryMsg;
        } else {
#line 1985
          tmp___288 = Dummy;
        }
#line 1985
        tmp___289 = tmp___288;
      }
      {
#line 1985
      tmp___289(0, (char const   *)((char *)"%s: %s: window required"), rc_name, comms[nr].name);
      }
#line 1986
      goto switch_break;
    }
#line 1988
    w = flayer->l_width;
#line 1989
    h = flayer->l_height;
  } else {
#line 1993
    if (! display) {
#line 1995
      if (! act->quiet) {
#line 1995
        tmp___291 = Msg;
      } else {
#line 1995
        if (queryflag >= 0) {
#line 1995
          tmp___290 = QueryMsg;
        } else {
#line 1995
          tmp___290 = Dummy;
        }
#line 1995
        tmp___291 = tmp___290;
      }
      {
#line 1995
      tmp___291(0, (char const   *)((char *)"%s: %s: display required"), rc_name,
                comms[nr].name);
      }
#line 1996
      goto switch_break;
    }
#line 1998
    w = display->d_width;
#line 1999
    h = display->d_height;
  }
#line 2001
  if (*args) {
#line 2001
    if ((int )*(*(args + 0) + 0) == 45) {
#line 2003
      if (! act->quiet) {
#line 2003
        tmp___293 = Msg;
      } else {
#line 2003
        if (queryflag >= 0) {
#line 2003
          tmp___292 = QueryMsg;
        } else {
#line 2003
          tmp___292 = Dummy;
        }
#line 2003
        tmp___293 = tmp___292;
      }
      {
#line 2003
      tmp___293(0, (char const   *)((char *)"%s: %s: unknown option %s"), rc_name,
                comms[nr].name, *args);
      }
#line 2004
      goto switch_break;
    }
  }
#line 2006
  if (nr == 88) {
#line 2008
    if (! *args) {
#line 2012
      if (h == 42) {
#line 2013
        h = 24;
      } else
#line 2014
      if (h == 24) {
#line 2015
        h = 42;
      } else
#line 2016
      if (h > 33) {
#line 2017
        h = 42;
      } else {
#line 2019
        h = 24;
      }
    } else {
      {
#line 2023
      h = atoi((char const   *)*args);
      }
#line 2024
      if (*(args + 1)) {
        {
#line 2025
        w = atoi((char const   *)*(args + 1));
        }
      }
    }
  } else
#line 2030
  if (! *args) {
#line 2032
    if (w == (int )Z0width) {
#line 2033
      w = (int )Z1width;
    } else
#line 2034
    if (w == (int )Z1width) {
#line 2035
      w = (int )Z0width;
    } else
#line 2036
    if (w > ((int )Z0width + (int )Z1width) / 2) {
#line 2037
      w = (int )Z0width;
    } else {
#line 2039
      w = (int )Z1width;
    }
  } else {
    {
#line 2043
    w = atoi((char const   *)*args);
    }
#line 2044
    if (*(args + 1)) {
      {
#line 2045
      h = atoi((char const   *)*(args + 1));
      }
    }
  }
#line 2048
  if (*args) {
#line 2048
    if (*(args + 1)) {
#line 2048
      if (*(args + 2)) {
#line 2050
        if (! act->quiet) {
#line 2050
          tmp___295 = Msg;
        } else {
#line 2050
          if (queryflag >= 0) {
#line 2050
            tmp___294 = QueryMsg;
          } else {
#line 2050
            tmp___294 = Dummy;
          }
#line 2050
          tmp___295 = tmp___294;
        }
        {
#line 2050
        tmp___295(0, (char const   *)((char *)"%s: %s: too many arguments"), rc_name,
                  comms[nr].name);
        }
#line 2051
        goto switch_break;
      }
    }
  }
#line 2053
  if (w <= 0) {
#line 2055
    if (! act->quiet) {
#line 2055
      tmp___297 = Msg;
    } else {
#line 2055
      if (queryflag >= 0) {
#line 2055
        tmp___296 = QueryMsg;
      } else {
#line 2055
        tmp___296 = Dummy;
      }
#line 2055
      tmp___297 = tmp___296;
    }
    {
#line 2055
    tmp___297(0, (char const   *)((char *)"Illegal width"));
    }
#line 2056
    goto switch_break;
  }
#line 2058
  if (h <= 0) {
#line 2060
    if (! act->quiet) {
#line 2060
      tmp___299 = Msg;
    } else {
#line 2060
      if (queryflag >= 0) {
#line 2060
        tmp___298 = QueryMsg;
      } else {
#line 2060
        tmp___298 = Dummy;
      }
#line 2060
      tmp___299 = tmp___298;
    }
    {
#line 2060
    tmp___299(0, (char const   *)((char *)"Illegal height"));
    }
#line 2061
    goto switch_break;
  }
#line 2063
  if (what == 1) {
#line 2065
    if (flayer->l_width == w) {
#line 2065
      if (flayer->l_height == h) {
#line 2066
        goto switch_break;
      }
    }
    {
#line 2067
    ResizeLayer(flayer, w, h, (struct display *)0);
    }
#line 2068
    goto switch_break;
  }
#line 2070
  if (display->d_width == w) {
#line 2070
    if (display->d_height == h) {
#line 2071
      goto switch_break;
    }
  }
#line 2072
  if (what == 2) {
    {
#line 2074
    ChangeScreenSize(w, h, 1);
    }
  } else {
    {
#line 2078
    __cil_tmp223 = ResizeDisplay(w, h);
    }
#line 2078
    if (__cil_tmp223 == 0) {
#line 2080
      if (display->d_fore) {
#line 2080
        tmp___300 = (int )(display->d_fore)->w_norefresh;
      } else {
#line 2080
        tmp___300 = 0;
      }
      {
#line 2080
      Activate(tmp___300);
#line 2082
      ResizeLayer((display->d_forecv)->c_layer, ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1,
                  ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1, (struct display *)0);
      }
#line 2083
      goto switch_break;
    }
#line 2085
    if (h == display->d_height) {
#line 2086
      if (! act->quiet) {
#line 2086
        tmp___302 = Msg;
      } else {
#line 2086
        if (queryflag >= 0) {
#line 2086
          tmp___301 = QueryMsg;
        } else {
#line 2086
          tmp___301 = Dummy;
        }
#line 2086
        tmp___302 = tmp___301;
      }
      {
#line 2086
      tmp___302(0, (char const   *)((char *)"Your termcap does not specify how to change the terminal\'s width to %d."),
                w);
      }
    } else
#line 2087
    if (w == display->d_width) {
#line 2088
      if (! act->quiet) {
#line 2088
        tmp___304 = Msg;
      } else {
#line 2088
        if (queryflag >= 0) {
#line 2088
          tmp___303 = QueryMsg;
        } else {
#line 2088
          tmp___303 = Dummy;
        }
#line 2088
        tmp___304 = tmp___303;
      }
      {
#line 2088
      tmp___304(0, (char const   *)((char *)"Your termcap does not specify how to change the terminal\'s height to %d."),
                h);
      }
    } else {
#line 2090
      if (! act->quiet) {
#line 2090
        tmp___306 = Msg;
      } else {
#line 2090
        if (queryflag >= 0) {
#line 2090
          tmp___305 = QueryMsg;
        } else {
#line 2090
          tmp___305 = Dummy;
        }
#line 2090
        tmp___306 = tmp___305;
      }
      {
#line 2090
      tmp___306(0, (char const   *)((char *)"Your termcap does not specify how to change the terminal\'s resolution to %dx%d."),
                w, h);
      }
    }
  }
#line 2093
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 2095
  __cil_tmp231 = ParseOnOff(act, & nwin_default.dynamicaka);
  }
#line 2096
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 2098
  __cil_tmp232 = ParseOnOff(act, & fore->w_dynamicaka);
  }
#line 2099
  goto switch_break;
  case_168: /* CIL Label */ 
#line 2101
  if (queryflag >= 0) {
#line 2103
    if (fore) {
#line 2104
      if (! act->quiet) {
#line 2104
        tmp___308 = Msg;
      } else {
#line 2104
        if (queryflag >= 0) {
#line 2104
          tmp___307 = QueryMsg;
        } else {
#line 2104
          tmp___307 = Dummy;
        }
#line 2104
        tmp___308 = tmp___307;
      }
      {
#line 2104
      tmp___308(0, (char const   *)((char *)"%s"), fore->w_title);
      }
    } else {
#line 2106
      queryflag = - 1;
    }
#line 2107
    goto switch_break;
  }
#line 2109
  if (*args == (char *)0) {
    {
#line 2110
    InputAKA();
    }
  } else {
    {
#line 2112
    __cil_tmp235 = strlen((char const   *)*args);
#line 2112
    ChangeAKA(fore, *args, (int )__cil_tmp235);
    }
  }
#line 2113
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 2115
  Input((char *)":", 768, 4, Colonfin, (char *)((void *)0), 0);
  }
#line 2116
  if (*args) {
#line 2116
    if ((int )*(*args)) {
      {
#line 2118
      s = *args;
#line 2119
      __cil_tmp236 = strlen((char const   *)s);
#line 2119
      n = (int )__cil_tmp236;
#line 2120
      (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
      }
    }
  }
#line 2122
  goto switch_break;
  case_97: /* CIL Label */ 
#line 2124
  if (display->d_status_lastmsg) {
#line 2125
    if (! act->quiet) {
#line 2125
      tmp___310 = Msg;
    } else {
#line 2125
      if (queryflag >= 0) {
#line 2125
        tmp___309 = QueryMsg;
      } else {
#line 2125
        tmp___309 = Dummy;
      }
#line 2125
      tmp___310 = tmp___309;
    }
    {
#line 2125
    tmp___310(0, (char const   *)((char *)"%s"), display->d_status_lastmsg);
    }
  }
#line 2126
  goto switch_break;
  case_143: /* CIL Label */ 
  {
#line 2128
  DoScreen((char *)"key", args);
  }
#line 2129
  goto switch_break;
  case_182: /* CIL Label */ 
  {
#line 2131
  __cil_tmp239 = ParseSwitch(act, & fore->w_wrap);
  }
#line 2131
  if (__cil_tmp239 == 0) {
#line 2131
    if (msgok) {
#line 2132
      if (! act->quiet) {
#line 2132
        tmp___312 = Msg;
      } else {
#line 2132
        if (queryflag >= 0) {
#line 2132
          tmp___311 = QueryMsg;
        } else {
#line 2132
          tmp___311 = Dummy;
        }
#line 2132
        tmp___312 = tmp___311;
      }
#line 2132
      if (fore->w_wrap) {
#line 2132
        tmp___313 = '+';
      } else {
#line 2132
        tmp___313 = '-';
      }
      {
#line 2132
      tmp___312(0, (char const   *)((char *)"%cwrap"), tmp___313);
      }
    }
  }
#line 2133
  goto switch_break;
  case_79: /* CIL Label */ 
#line 2135
  if (*args) {
#line 2137
    if ((int )*(*(args + 0) + 0) == 97) {
#line 2139
      if (fore->w_flow & (1 << 1)) {
#line 2139
        tmp___314 = ((1 << 2) | (1 << 1)) | 1;
      } else {
#line 2139
        tmp___314 = 1 << 2;
      }
#line 2139
      fore->w_flow = tmp___314;
    } else {
      {
#line 2143
      __cil_tmp244 = ParseOnOff(act, & n);
      }
#line 2143
      if (__cil_tmp244) {
#line 2144
        goto switch_break;
      }
#line 2145
      fore->w_flow = (fore->w_flow & (1 << 1)) | n;
    }
  } else
#line 2150
  if (fore->w_flow & (1 << 2)) {
#line 2151
    fore->w_flow = (fore->w_flow & (1 << 1)) | 1;
  } else
#line 2152
  if (fore->w_flow & 1) {
#line 2153
    fore->w_flow &= ~ 1;
  } else {
#line 2155
    if (fore->w_flow) {
#line 2155
      tmp___315 = ((1 << 2) | (1 << 1)) | 1;
    } else {
#line 2155
      tmp___315 = 1 << 2;
    }
#line 2155
    fore->w_flow = tmp___315;
  }
  {
#line 2157
  SetFlow(fore->w_flow & 1);
  }
#line 2158
  if (msgok) {
#line 2159
    if (! act->quiet) {
#line 2159
      tmp___317 = Msg;
    } else {
#line 2159
      if (queryflag >= 0) {
#line 2159
        tmp___316 = QueryMsg;
      } else {
#line 2159
        tmp___316 = Dummy;
      }
#line 2159
      tmp___317 = tmp___316;
    }
#line 2159
    if (fore->w_flow & 1) {
#line 2159
      tmp___318 = '+';
    } else {
#line 2159
      tmp___318 = '-';
    }
#line 2159
    if (fore->w_flow & (1 << 2)) {
#line 2159
      tmp___319 = (char *)"(auto)";
    } else {
#line 2159
      tmp___319 = (char *)"";
    }
    {
#line 2159
    tmp___317(0, (char const   *)((char *)"%cflow%s"), tmp___318, tmp___319);
    }
  }
#line 2161
  goto switch_break;
  case_66: /* CIL Label */ 
#line 2164
  if ((int )*(*(args + 0) + 0) == 97) {
#line 2165
    nwin_default.wlock = 1;
  } else {
    {
#line 2168
    __cil_tmp250 = ParseOnOff(act, & n);
    }
#line 2168
    if (__cil_tmp250) {
#line 2169
      goto switch_break;
    }
#line 2170
    if (n) {
#line 2170
      tmp___320 = 2;
    } else {
#line 2170
      tmp___320 = 0;
    }
#line 2170
    nwin_default.wlock = tmp___320;
  }
#line 2172
  goto switch_break;
  case_184: /* CIL Label */ 
#line 2174
  if (*args) {
#line 2176
    if ((int )*(*(args + 0) + 0) == 97) {
#line 2178
      fore->w_wlock = 1;
    } else {
      {
#line 2182
      __cil_tmp252 = ParseOnOff(act, & n);
      }
#line 2182
      if (__cil_tmp252) {
#line 2183
        goto switch_break;
      }
#line 2184
      if (n) {
#line 2184
        tmp___321 = 2;
      } else {
#line 2184
        tmp___321 = 0;
      }
#line 2184
      fore->w_wlock = tmp___321;
    }
    {
#line 2190
    __cil_tmp254 = AclCheckPermWin(display->d_user, 1, fore);
    }
#line 2190
    if (! __cil_tmp254) {
#line 2191
      fore->w_wlockuser = display->d_user;
    }
  }
#line 2193
  if (! act->quiet) {
#line 2193
    tmp___323 = Msg;
  } else {
#line 2193
    if (queryflag >= 0) {
#line 2193
      tmp___322 = QueryMsg;
    } else {
#line 2193
      tmp___322 = Dummy;
    }
#line 2193
    tmp___323 = tmp___322;
  }
#line 2193
  if (fore->w_wlock == 1) {
#line 2193
    tmp___325 = (char *)"auto";
  } else {
#line 2193
    if (fore->w_wlock == 0) {
#line 2193
      tmp___324 = (char *)"off";
    } else {
#line 2193
      tmp___324 = (char *)"on";
    }
#line 2193
    tmp___325 = tmp___324;
  }
  {
#line 2193
  tmp___323(0, (char const   *)((char *)"writelock %s"), tmp___325);
  }
#line 2195
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 2198
  ResetAnsiState(fore);
  }
  {
#line 2199
  WriteString(fore, (char *)"\033[H\033[J", 6);
  }
#line 2200
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 2202
  ResetAnsiState(fore);
  }
#line 2204
  if (fore->w_zdisplay) {
    {
#line 2205
    zmodem_abort(fore, fore->w_zdisplay);
    }
  }
  {
#line 2207
  WriteString(fore, (char *)"\033c", 2);
  }
#line 2208
  goto switch_break;
  case_111: /* CIL Label */ 
#line 2210
  n = fore->w_monitor != 0;
#line 2212
  if (display) {
#line 2213
    n = n && (int )*(fore->w_mon_notify + ((display->d_user)->u_id >> 3)) & (128 >> ((display->d_user)->u_id & 7));
  }
  {
#line 2215
  __cil_tmp259 = ParseSwitch(act, & n);
  }
#line 2215
  if (__cil_tmp259) {
#line 2216
    goto switch_break;
  }
#line 2217
  if (n) {
#line 2220
    if (display) {
#line 2221
      *(fore->w_mon_notify + ((display->d_user)->u_id >> 3)) |= 128 >> ((display->d_user)->u_id & 7);
    } else {
#line 2223
      i = 0;
      {
#line 2223
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 2223
        if (! (i < maxusercount)) {
#line 2223
          goto while_break___17;
        }
#line 2224
        *(fore->w_mon_notify + (i >> 3)) |= 128 >> (i & 7);
      }
      while_break___17: /* CIL Label */ ;
      }
#line 2223
      i ++;
    }
#line 2226
    if (fore->w_monitor == 0) {
#line 2227
      fore->w_monitor = 1;
    }
#line 2228
    if (! act->quiet) {
#line 2228
      tmp___327 = Msg;
    } else {
#line 2228
      if (queryflag >= 0) {
#line 2228
        tmp___326 = QueryMsg;
      } else {
#line 2228
        tmp___326 = Dummy;
      }
#line 2228
      tmp___327 = tmp___326;
    }
    {
#line 2228
    tmp___327(0, (char const   *)((char *)"Window %d (%s) is now being monitored for all activity."),
              fore->w_number, fore->w_title);
    }
  } else {
#line 2233
    if (display) {
#line 2234
      *(fore->w_mon_notify + ((display->d_user)->u_id >> 3)) &= ~ (128 >> ((display->d_user)->u_id & 7));
    } else {
#line 2237
      i = 0;
      {
#line 2237
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 2237
        if (! (i < maxusercount)) {
#line 2237
          goto while_break___18;
        }
#line 2238
        *(fore->w_mon_notify + (i >> 3)) &= ~ (128 >> (i & 7));
      }
      while_break___18: /* CIL Label */ ;
      }
#line 2237
      i ++;
    }
#line 2239
    i = maxusercount - 1;
    {
#line 2239
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 2239
      if (! (i >= 0)) {
#line 2239
        goto while_break___19;
      }
#line 2240
      if (*(fore->w_mon_notify + (i >> 3))) {
#line 2241
        goto while_break___19;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
#line 2239
    __cil_tmp264 = i;
#line 2239
    i --;
#line 2242
    if (i < 0) {
#line 2244
      fore->w_monitor = 0;
    }
#line 2245
    if (! act->quiet) {
#line 2245
      tmp___329 = Msg;
    } else {
#line 2245
      if (queryflag >= 0) {
#line 2245
        tmp___328 = QueryMsg;
      } else {
#line 2245
        tmp___328 = Dummy;
      }
#line 2245
      tmp___329 = tmp___328;
    }
    {
#line 2245
    tmp___329(0, (char const   *)((char *)"Window %d (%s) is no longer being monitored for activity."),
              fore->w_number, fore->w_title);
    }
  }
#line 2247
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 2250
  display_displays();
  }
#line 2251
  goto switch_break;
  case_180: /* CIL Label */ 
#line 2254
  if (! *args) {
    {
#line 2255
    display_windows(0, 0, (struct win *)0);
    }
  } else {
    {
#line 2256
    __cil_tmp267 = strcmp((char const   *)*args, (char const   *)((char *)"string"));
    }
#line 2256
    if (! __cil_tmp267) {
#line 2258
      if (*(args + 1)) {
#line 2260
        if (wliststr) {
          {
#line 2261
          free((void *)wliststr);
          }
        }
        {
#line 2262
        wliststr = SaveStr((char const   *)*(args + 1));
        }
      }
#line 2264
      if (msgok) {
#line 2265
        if (! act->quiet) {
#line 2265
          tmp___331 = Msg;
        } else {
#line 2265
          if (queryflag >= 0) {
#line 2265
            tmp___330 = QueryMsg;
          } else {
#line 2265
            tmp___330 = Dummy;
          }
#line 2265
          tmp___331 = tmp___330;
        }
        {
#line 2265
        tmp___331(0, (char const   *)((char *)"windowlist string is \'%s\'"), wliststr);
        }
      }
    } else {
      {
#line 2267
      __cil_tmp271 = strcmp((char const   *)*args, (char const   *)((char *)"title"));
      }
#line 2267
      if (! __cil_tmp271) {
#line 2269
        if (*(args + 1)) {
#line 2271
          if (wlisttit) {
            {
#line 2272
            free((void *)wlisttit);
            }
          }
          {
#line 2273
          wlisttit = SaveStr((char const   *)*(args + 1));
          }
        }
#line 2275
        if (msgok) {
#line 2276
          if (! act->quiet) {
#line 2276
            tmp___333 = Msg;
          } else {
#line 2276
            if (queryflag >= 0) {
#line 2276
              tmp___332 = QueryMsg;
            } else {
#line 2276
              tmp___332 = Dummy;
            }
#line 2276
            tmp___333 = tmp___332;
          }
          {
#line 2276
          tmp___333(0, (char const   *)((char *)"windowlist title is \'%s\'"), wlisttit);
          }
        }
      } else {
#line 2280
        flag = 0;
#line 2281
        blank___0 = 0;
#line 2282
        i = 0;
        {
#line 2282
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 2282
          if (! (i < argc)) {
#line 2282
            goto while_break___20;
          }
#line 2283
          if (! *(args + i)) {
#line 2284
            goto while_continue___20;
          } else {
            {
#line 2285
            __cil_tmp277 = strcmp((char const   *)*(args + i), (char const   *)((char *)"-m"));
            }
#line 2285
            if (! __cil_tmp277) {
#line 2286
              flag |= 1;
            } else {
              {
#line 2287
              __cil_tmp278 = strcmp((char const   *)*(args + i), (char const   *)((char *)"-b"));
              }
#line 2287
              if (! __cil_tmp278) {
#line 2288
                blank___0 = 1;
              } else {
                {
#line 2289
                __cil_tmp279 = strcmp((char const   *)*(args + i), (char const   *)((char *)"-g"));
                }
#line 2289
                if (! __cil_tmp279) {
#line 2290
                  flag |= 2;
                } else {
#line 2293
                  if (! act->quiet) {
#line 2293
                    tmp___335 = Msg;
                  } else {
#line 2293
                    if (queryflag >= 0) {
#line 2293
                      tmp___334 = QueryMsg;
                    } else {
#line 2293
                      tmp___334 = Dummy;
                    }
#line 2293
                    tmp___335 = tmp___334;
                  }
                  {
#line 2293
                  tmp___335(0, (char const   *)((char *)"usage: windowlist [-b] [-g] [-m] [string [string] | title [title]]"));
                  }
#line 2294
                  goto while_break___20;
                }
              }
            }
          }
        }
        while_break___20: /* CIL Label */ ;
        }
#line 2282
        i ++;
#line 2296
        if (i == argc) {
          {
#line 2297
          display_windows(blank___0, flag, (struct win *)0);
          }
        }
      }
    }
  }
#line 2299
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 2301
  __cil_tmp283 = strcmp((char const   *)*args, (char const   *)((char *)"-c"));
  }
#line 2301
  if (argc == 2) {
#line 2301
    if (! __cil_tmp283) {
      {
#line 2304
      ktabp___0 = FindKtab(*(args + 1), 0);
      }
#line 2304
      if (ktabp___0 == (struct action *)0) {
#line 2306
        if (! act->quiet) {
#line 2306
          tmp___337 = Msg;
        } else {
#line 2306
          if (queryflag >= 0) {
#line 2306
            tmp___336 = QueryMsg;
          } else {
#line 2306
            tmp___336 = Dummy;
          }
#line 2306
          tmp___337 = tmp___336;
        }
        {
#line 2306
        tmp___337(0, (char const   *)((char *)"Unknown command class \'%s\'"), *(args + 1));
        }
#line 2307
        goto switch_break;
      }
      {
#line 2309
      display_help(*(args + 1), ktabp___0);
      }
    } else {
      {
      {
#line 2312
      display_help((char *)0, (struct action *)ktab);
      }
      }
    }
  } else {
    {
    {
#line 2312
    display_help((char *)0, (struct action *)ktab);
    }
    }
  }
#line 2313
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 2315
  display_copyright();
  }
#line 2316
  goto switch_break;
  case_38: /* CIL Label */ 
#line 2319
  if (flayer->l_layfn != & WinLf) {
#line 2321
    if (! act->quiet) {
#line 2321
      tmp___339 = Msg;
    } else {
#line 2321
      if (queryflag >= 0) {
#line 2321
        tmp___338 = QueryMsg;
      } else {
#line 2321
        tmp___338 = Dummy;
      }
#line 2321
      tmp___339 = tmp___338;
    }
    {
#line 2321
    tmp___339(0, (char const   *)((char *)"Must be on a window layer"));
    }
#line 2322
    goto switch_break;
  }
  {
#line 2324
  MarkRoutine();
#line 2325
  WindowChanged(fore, 'P');
  }
#line 2326
  goto switch_break;
  case_90: /* CIL Label */ 
#line 2332
  if (flayer->l_layfn != & WinLf) {
#line 2334
    if (! act->quiet) {
#line 2334
      tmp___341 = Msg;
    } else {
#line 2334
      if (queryflag >= 0) {
#line 2334
        tmp___340 = QueryMsg;
      } else {
#line 2334
        tmp___340 = Dummy;
      }
#line 2334
      tmp___341 = tmp___340;
    }
    {
#line 2334
    tmp___341(0, (char const   *)((char *)"Must be on a window layer"));
    }
#line 2335
    goto switch_break;
  }
  {
#line 2337
  __cil_tmp294 = GetHistory();
  }
#line 2337
  if (__cil_tmp294 == 0) {
#line 2338
    goto switch_break;
  }
#line 2339
  if (user->u_plop.buf == (char *)((void *)0)) {
#line 2340
    goto switch_break;
  }
#line 2341
  args = (char **)pasteargs;
#line 2342
  argl = (int *)pasteargl;
  case_125: /* CIL Label */ 
#line 2348
  l = 0;
#line 2350
  enc = - 1;
#line 2356
  s = *args;
#line 2356
  if (s == (char *)((void *)0)) {
    {
#line 2358
    Input((char *)"Paste from register:", 1, 2, ins_reg_fn, (char *)((void *)0), 0);
    }
#line 2359
    goto switch_break;
  }
#line 2361
  if (*(args + 1) == (char *)0) {
#line 2361
    if (! fore) {
#line 2362
      goto switch_break;
    }
  }
#line 2367
  if (*(args + 1)) {
#line 2367
    if (*(argl + 1) != 1) {
#line 2369
      if (! act->quiet) {
#line 2369
        tmp___343 = Msg;
      } else {
#line 2369
        if (queryflag >= 0) {
#line 2369
          tmp___342 = QueryMsg;
        } else {
#line 2369
          tmp___342 = Dummy;
        }
#line 2369
        tmp___343 = tmp___342;
      }
      {
#line 2369
      tmp___343(0, (char const   *)((char *)"%s: paste destination: character, ^x, or (octal) \\032 expected."),
                rc_name);
      }
#line 2371
      goto switch_break;
    } else {
#line 2367
      goto _L___344;
    }
  } else
  _L___344: /* CIL Label */ 
#line 2374
  if (fore) {
#line 2375
    enc = fore->w_layer.l_encoding;
  }
#line 2381
  s = *args;
#line 2381
  ss = s;
  {
#line 2381
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 2381
    if (! ch) {
#line 2381
      goto while_break___21;
    }
#line 2383
    if ((int )ch == 46) {
#line 2386
      if (enc == -1) {
#line 2387
        enc = user->u_plop.enc;
      }
#line 2388
      if (enc != user->u_plop.enc) {
        {
#line 2389
        __cil_tmp302 = RecodeBuf((unsigned char *)user->u_plop.buf, user->u_plop.len,
                                 user->u_plop.enc, enc, (unsigned char *)0);
        }
#line 2389
        l += __cil_tmp302;
      } else {
#line 2392
        l += user->u_plop.len;
      }
    } else {
#line 2397
      if (enc == -1) {
#line 2398
        enc = plop_tab[(int )((unsigned char )ch)].enc;
      }
#line 2399
      if (enc != plop_tab[(int )((unsigned char )ch)].enc) {
        {
#line 2400
        __cil_tmp303 = RecodeBuf((unsigned char *)plop_tab[(int )((unsigned char )ch)].buf,
                                 plop_tab[(int )((unsigned char )ch)].len, plop_tab[(int )((unsigned char )ch)].enc,
                                 enc, (unsigned char *)0);
        }
#line 2400
        l += __cil_tmp303;
      } else {
#line 2403
        l += plop_tab[(int )((unsigned char )ch)].len;
      }
    }
  }
  while_break___21: /* CIL Label */ ;
  }
#line 2381
  ss ++;
#line 2406
  if (l == 0) {
#line 2408
    if (! act->quiet) {
#line 2408
      tmp___346 = Msg;
    } else {
#line 2408
      if (queryflag >= 0) {
#line 2408
        tmp___345 = QueryMsg;
      } else {
#line 2408
        tmp___345 = Dummy;
      }
#line 2408
      tmp___346 = tmp___345;
    }
    {
#line 2408
    tmp___346(0, (char const   *)((char *)"empty buffer"));
    }
#line 2409
    goto switch_break;
  }
#line 2416
  if ((int )*(s + 1) == 0) {
#line 2416
    if (*(args + 1) == (char *)0) {
#line 2418
      if ((int )*s == 46) {
#line 2418
        tmp___347 = user->u_plop.enc;
      } else {
#line 2418
        tmp___347 = plop_tab[(int )((unsigned char )*s)].enc;
      }
#line 2418
      if (enc == tmp___347) {
#line 2421
        if ((int )*s == 46) {
#line 2421
          tmp___348 = user->u_plop.buf;
        } else {
#line 2421
          tmp___348 = plop_tab[(int )((unsigned char )*s)].buf;
        }
        {
#line 2421
        MakePaster(& fore->w_paster, tmp___348, l, 0);
        }
#line 2422
        goto switch_break;
      }
    }
  }
  {
#line 2427
  __cil_tmp309 = malloc((unsigned long )l);
#line 2427
  dbuf = (char *)__cil_tmp309;
  }
#line 2427
  if (dbuf == (char *)0) {
#line 2429
    if (! act->quiet) {
#line 2429
      tmp___350 = Msg;
    } else {
#line 2429
      if (queryflag >= 0) {
#line 2429
        tmp___349 = QueryMsg;
      } else {
#line 2429
        tmp___349 = Dummy;
      }
#line 2429
      tmp___350 = tmp___349;
    }
    {
#line 2429
    tmp___350(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
#line 2430
    goto switch_break;
  }
#line 2432
  l = 0;
#line 2437
  ss = s;
  {
#line 2437
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 2437
    if (! ch) {
#line 2437
      goto while_break___22;
    }
#line 2439
    if ((int )ch == 46) {
#line 2439
      tmp___351 = & user->u_plop;
    } else {
#line 2439
      tmp___351 = & plop_tab[(int )((unsigned char )ch)];
    }
#line 2439
    pp___0 = tmp___351;
#line 2441
    if (pp___0->enc != enc) {
      {
#line 2443
      __cil_tmp314 = RecodeBuf((unsigned char *)pp___0->buf, pp___0->len, pp___0->enc,
                               enc, (unsigned char *)dbuf + l);
      }
#line 2443
      l += __cil_tmp314;
#line 2444
      goto while_continue___22;
    }
    {
#line 2447
    bcopy((void const   *)pp___0->buf, (void *)(dbuf + l), (size_t )pp___0->len);
#line 2448
    l += pp___0->len;
    }
  }
  while_break___22: /* CIL Label */ ;
  }
#line 2437
  ss ++;
#line 2453
  if (*(args + 1) == (char *)0) {
    {
#line 2455
    MakePaster(& fore->w_paster, dbuf, l, 1);
    }
  } else {
#line 2463
    dch = *(*(args + 1) + 0);
#line 2464
    if ((int )dch == 46) {
#line 2466
      if (user->u_plop.buf != (char *)((void *)0)) {
        {
#line 2467
        UserFreeCopyBuffer(user);
        }
      }
#line 2468
      user->u_plop.buf = dbuf;
#line 2469
      user->u_plop.len = l;
#line 2471
      user->u_plop.enc = enc;
    } else {
#line 2476
      pp___1 = (struct plop *)plop_tab + (int )((unsigned char )dch);
#line 2477
      if (pp___1->buf) {
        {
#line 2478
        free((void *)pp___1->buf);
        }
      }
#line 2479
      pp___1->buf = dbuf;
#line 2480
      pp___1->len = l;
#line 2482
      pp___1->enc = enc;
    }
  }
#line 2486
  goto switch_break;
  case_183: /* CIL Label */ 
#line 2489
  if (! user->u_plop.buf) {
#line 2491
    if (! act->quiet) {
#line 2491
      tmp___353 = Msg;
    } else {
#line 2491
      if (queryflag >= 0) {
#line 2491
        tmp___352 = QueryMsg;
      } else {
#line 2491
        tmp___352 = Dummy;
      }
#line 2491
      tmp___353 = tmp___352;
    }
    {
#line 2491
    tmp___353(0, (char const   *)((char *)"empty buffer"));
    }
#line 2492
    goto switch_break;
  }
  {
#line 2498
  oldplop = user->u_plop;
#line 2499
  __cil_tmp320 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-e"));
  }
#line 2499
  if (*(args + 0)) {
#line 2499
    if (*(args + 1)) {
#line 2499
      if (! __cil_tmp320) {
        {
#line 2504
        enc___0 = FindEncoding(*(args + 1));
        }
#line 2505
        if (enc___0 == -1) {
#line 2507
          if (! act->quiet) {
#line 2507
            tmp___355 = Msg;
          } else {
#line 2507
            if (queryflag >= 0) {
#line 2507
              tmp___354 = QueryMsg;
            } else {
#line 2507
              tmp___354 = Dummy;
            }
#line 2507
            tmp___355 = tmp___354;
          }
          {
#line 2507
          tmp___355(0, (char const   *)((char *)"%s: writebuf: unknown encoding"),
                    rc_name);
          }
#line 2508
          goto switch_break;
        }
#line 2510
        if (enc___0 != oldplop.enc) {
          {
#line 2512
          l___0 = RecodeBuf((unsigned char *)oldplop.buf, oldplop.len, oldplop.enc,
                            enc___0, (unsigned char *)0);
#line 2513
          __cil_tmp328 = malloc((unsigned long )(l___0 + 1));
#line 2513
          newbuf = (char *)__cil_tmp328;
          }
#line 2514
          if (! newbuf) {
#line 2516
            if (! act->quiet) {
#line 2516
              tmp___357 = Msg;
            } else {
#line 2516
              if (queryflag >= 0) {
#line 2516
                tmp___356 = QueryMsg;
              } else {
#line 2516
                tmp___356 = Dummy;
              }
#line 2516
              tmp___357 = tmp___356;
            }
            {
#line 2516
            tmp___357(0, (char const   *)((char *)"%s"), (char *)strnomem);
            }
#line 2517
            goto switch_break;
          }
          {
#line 2519
          user->u_plop.len = RecodeBuf((unsigned char *)oldplop.buf, oldplop.len,
                                       oldplop.enc, enc___0, (unsigned char *)newbuf);
#line 2520
          user->u_plop.buf = newbuf;
#line 2521
          user->u_plop.enc = enc___0;
          }
        }
#line 2523
        args += 2;
      }
    }
  }
#line 2526
  if (*(args + 0)) {
#line 2526
    if (*(args + 1)) {
#line 2527
      if (! act->quiet) {
#line 2527
        tmp___359 = Msg;
      } else {
#line 2527
        if (queryflag >= 0) {
#line 2527
          tmp___358 = QueryMsg;
        } else {
#line 2527
          tmp___358 = Dummy;
        }
#line 2527
        tmp___359 = tmp___358;
      }
      {
#line 2527
      tmp___359(0, (char const   *)((char *)"%s: writebuf: too many arguments"), rc_name);
      }
    } else {
      {
      {
#line 2529
      WriteFile(user, *(args + 0), 2);
      }
      }
    }
  } else {
    {
    {
#line 2529
    WriteFile(user, *(args + 0), 2);
    }
    }
  }
#line 2531
  if (user->u_plop.buf != oldplop.buf) {
    {
#line 2532
    free((void *)user->u_plop.buf);
    }
  }
#line 2533
  user->u_plop = oldplop;
#line 2536
  goto switch_break;
  case_134: /* CIL Label */ 
#line 2539
  if (fore) {
#line 2539
    tmp___361 = fore->w_layer.l_encoding;
  } else {
#line 2539
    if (display) {
#line 2539
      tmp___360 = display->d_encoding;
    } else {
#line 2539
      tmp___360 = 0;
    }
#line 2539
    tmp___361 = tmp___360;
  }
  {
#line 2539
  i = tmp___361;
#line 2540
  __cil_tmp336 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-e"));
  }
#line 2540
  if (*(args + 0)) {
#line 2540
    if (*(args + 1)) {
#line 2540
      if (! __cil_tmp336) {
        {
#line 2542
        i = FindEncoding(*(args + 1));
        }
#line 2543
        if (i == -1) {
#line 2545
          if (! act->quiet) {
#line 2545
            tmp___363 = Msg;
          } else {
#line 2545
            if (queryflag >= 0) {
#line 2545
              tmp___362 = QueryMsg;
            } else {
#line 2545
              tmp___362 = Dummy;
            }
#line 2545
            tmp___363 = tmp___362;
          }
          {
#line 2545
          tmp___363(0, (char const   *)((char *)"%s: readbuf: unknown encoding"),
                    rc_name);
          }
#line 2546
          goto switch_break;
        }
#line 2548
        args += 2;
      }
    }
  }
#line 2551
  if (*(args + 0)) {
#line 2551
    if (*(args + 1)) {
#line 2553
      if (! act->quiet) {
#line 2553
        tmp___365 = Msg;
      } else {
#line 2553
        if (queryflag >= 0) {
#line 2553
          tmp___364 = QueryMsg;
        } else {
#line 2553
          tmp___364 = Dummy;
        }
#line 2553
        tmp___365 = tmp___364;
      }
      {
#line 2553
      tmp___365(0, (char const   *)((char *)"%s: readbuf: too many arguments"), rc_name);
      }
#line 2554
      goto switch_break;
    }
  }
#line 2556
  if (*(args + 0)) {
#line 2556
    tmp___366 = *(args + 0);
  } else {
#line 2556
    tmp___366 = BufferFile;
  }
  {
#line 2556
  __cil_tmp343 = ReadFile(tmp___366, & n);
#line 2556
  s = __cil_tmp343;
  }
#line 2556
  if (s) {
#line 2558
    if (user->u_plop.buf) {
      {
#line 2559
      UserFreeCopyBuffer(user);
      }
    }
#line 2560
    user->u_plop.len = n;
#line 2561
    user->u_plop.buf = s;
#line 2563
    user->u_plop.enc = i;
  }
#line 2566
  goto switch_break;
  case_139: /* CIL Label */ 
  {
#line 2568
  KillBuffers();
  }
#line 2569
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 2571
  __cil_tmp344 = ParseSwitch(act, & search_ic);
  }
#line 2572
  if (msgok) {
#line 2573
    if (! act->quiet) {
#line 2573
      tmp___368 = Msg;
    } else {
#line 2573
      if (queryflag >= 0) {
#line 2573
        tmp___367 = QueryMsg;
      } else {
#line 2573
        tmp___367 = Dummy;
      }
#line 2573
      tmp___368 = tmp___367;
    }
#line 2573
    if (search_ic) {
#line 2573
      tmp___369 = (char *)"";
    } else {
#line 2573
      tmp___369 = (char *)"not ";
    }
    {
#line 2573
    tmp___368(0, (char const   *)((char *)"Will %signore case in searches"), tmp___369);
    }
  }
#line 2574
  goto switch_break;
  case_75: /* CIL Label */ 
#line 2577
  if (*argl == 0) {
    {
#line 2578
    SetEscape(user, - 1, - 1);
    }
  } else
#line 2579
  if (*argl == 2) {
    {
#line 2580
    SetEscape(user, (int )((unsigned char )*(*(args + 0) + 0)), (int )((unsigned char )*(*(args + 0) + 1)));
    }
  } else {
#line 2583
    if (! act->quiet) {
#line 2583
      tmp___371 = Msg;
    } else {
#line 2583
      if (queryflag >= 0) {
#line 2583
        tmp___370 = QueryMsg;
      } else {
#line 2583
        tmp___370 = Dummy;
      }
#line 2583
      tmp___371 = tmp___370;
    }
    {
#line 2583
    tmp___371(0, (char const   *)((char *)"%s: two characters required after escape."),
              rc_name);
    }
#line 2584
    goto switch_break;
  }
#line 2589
  if (display) {
#line 2589
    if (user != users) {
#line 2590
      goto switch_break;
    }
  }
  case_48: /* CIL Label */ 
#line 2593
  if (*argl == 0) {
    {
#line 2594
    SetEscape((struct acluser *)((void *)0), - 1, - 1);
    }
  } else
#line 2595
  if (*argl == 2) {
    {
#line 2596
    SetEscape((struct acluser *)((void *)0), (int )((unsigned char )*(*(args + 0) + 0)),
              (int )((unsigned char )*(*(args + 0) + 1)));
    }
  } else {
#line 2599
    if (! act->quiet) {
#line 2599
      tmp___373 = Msg;
    } else {
#line 2599
      if (queryflag >= 0) {
#line 2599
        tmp___372 = QueryMsg;
      } else {
#line 2599
        tmp___372 = Dummy;
      }
#line 2599
      tmp___373 = tmp___372;
    }
    {
#line 2599
    tmp___373(0, (char const   *)((char *)"%s: two characters required after defescape."),
              rc_name);
    }
#line 2600
    goto switch_break;
  }
  {
#line 2603
  CheckEscape();
  }
#line 2605
  goto switch_break;
  case_30: /* CIL Label */ 
#line 2607
  if (*args) {
#line 2607
    tmp___374 = *args;
  } else {
#line 2607
    tmp___374 = home;
  }
  {
#line 2607
  s = tmp___374;
#line 2608
  __cil_tmp353 = chdir((char const   *)s);
  }
#line 2608
  if (__cil_tmp353 == -1) {
#line 2609
    if (! act->quiet) {
#line 2609
      tmp___376 = Msg;
    } else {
#line 2609
      if (queryflag >= 0) {
#line 2609
        tmp___375 = QueryMsg;
      } else {
#line 2609
        tmp___375 = Dummy;
      }
#line 2609
      tmp___376 = tmp___375;
    }
    {
#line 2609
    __cil_tmp356 = __errno_location();
#line 2609
    tmp___376(*__cil_tmp356, (char const   *)((char *)"%s"), s);
    }
  }
#line 2610
  goto switch_break;
  case_61: /* CIL Label */ 
  case_149: /* CIL Label */ 
  {
#line 2613
  __cil_tmp357 = ParseSaveStr(act, & ShellProg);
  }
#line 2613
  if (__cil_tmp357 == 0) {
#line 2614
    ShellArgs[0] = ShellProg;
  }
#line 2615
  goto switch_break;
  case_86: /* CIL Label */ 
#line 2617
  if (*args) {
    {
#line 2618
    __cil_tmp358 = ParseSaveStr(act, & hardcopydir);
    }
  }
#line 2619
  if (msgok) {
#line 2620
    if (! act->quiet) {
#line 2620
      tmp___378 = Msg;
    } else {
#line 2620
      if (queryflag >= 0) {
#line 2620
        tmp___377 = QueryMsg;
      } else {
#line 2620
        tmp___377 = Dummy;
      }
#line 2620
      tmp___378 = tmp___377;
    }
#line 2620
    if (hardcopydir && (int )*hardcopydir) {
#line 2620
      tmp___379 = hardcopydir;
    } else {
#line 2620
      tmp___379 = (char *)"<cwd>";
    }
    {
#line 2620
    tmp___378(0, (char const   *)((char *)"hardcopydir is %s\n"), tmp___379);
    }
  }
#line 2621
  goto switch_break;
  case_102: /* CIL Label */ 
#line 2623
  if (*args) {
    {
#line 2626
    __cil_tmp363 = strcmp((char const   *)*args, (char const   *)((char *)"flush"));
    }
#line 2626
    if (*(args + 1)) {
#line 2626
      if (! __cil_tmp363) {
        {
#line 2628
        log_flush = atoi((char const   *)*(args + 1));
        }
#line 2629
        if (msgok) {
#line 2630
          if (! act->quiet) {
#line 2630
            tmp___381 = Msg;
          } else {
#line 2630
            if (queryflag >= 0) {
#line 2630
              tmp___380 = QueryMsg;
            } else {
#line 2630
              tmp___380 = Dummy;
            }
#line 2630
            tmp___381 = tmp___380;
          }
          {
#line 2630
          tmp___381(0, (char const   *)((char *)"log flush timeout set to %ds\n"),
                    log_flush);
          }
        }
#line 2631
        goto switch_break;
      }
    }
    {
#line 2633
    __cil_tmp367 = ParseSaveStr(act, & screenlogfile);
    }
#line 2633
    if (__cil_tmp367) {
#line 2634
      goto switch_break;
    }
#line 2635
    if (fore) {
#line 2635
      if (fore->w_log) {
        {
#line 2636
        __cil_tmp368 = DoStartLog(fore, (char *)buf___0, (int )sizeof(buf___0));
        }
#line 2636
        if (__cil_tmp368) {
#line 2637
          if (! act->quiet) {
#line 2637
            tmp___383 = Msg;
          } else {
#line 2637
            if (queryflag >= 0) {
#line 2637
              tmp___382 = QueryMsg;
            } else {
#line 2637
              tmp___382 = Dummy;
            }
#line 2637
            tmp___383 = tmp___382;
          }
          {
#line 2637
          tmp___383(0, (char const   *)((char *)"Error opening logfile \"%s\""), (char *)buf___0);
          }
        }
      }
    }
#line 2638
    if (! msgok) {
#line 2639
      goto switch_break;
    }
  }
#line 2641
  if (! act->quiet) {
#line 2641
    tmp___385 = Msg;
  } else {
#line 2641
    if (queryflag >= 0) {
#line 2641
      tmp___384 = QueryMsg;
    } else {
#line 2641
      tmp___384 = Dummy;
    }
#line 2641
    tmp___385 = tmp___384;
  }
  {
#line 2641
  tmp___385(0, (char const   *)((char *)"logfile is \'%s\'"), screenlogfile);
  }
#line 2642
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 2644
  __cil_tmp374 = strcmp((char const   *)*args, (char const   *)((char *)"off"));
  }
  {
#line 2644
  __cil_tmp373 = strcmp((char const   *)*args, (char const   *)((char *)"on"));
  }
#line 2644
  if (! *args) {
    _L___395: /* CIL Label */ 
    {
#line 2646
    __cil_tmp375 = ParseSwitch(act, & logtstamp_on);
    }
#line 2646
    if (__cil_tmp375 == 0) {
#line 2646
      if (msgok) {
#line 2647
        if (! act->quiet) {
#line 2647
          tmp___387 = Msg;
        } else {
#line 2647
          if (queryflag >= 0) {
#line 2647
            tmp___386 = QueryMsg;
          } else {
#line 2647
            tmp___386 = Dummy;
          }
#line 2647
          tmp___387 = tmp___386;
        }
#line 2647
        if (logtstamp_on) {
#line 2647
          tmp___388 = (char *)"on";
        } else {
#line 2647
          tmp___388 = (char *)"off";
        }
        {
#line 2647
        tmp___387(0, (char const   *)((char *)"timestamps turned %s"), tmp___388);
        }
      }
    }
  } else
#line 2644
  if (! __cil_tmp373) {
#line 2644
    goto _L___395;
  } else
#line 2644
  if (! __cil_tmp374) {
#line 2644
    goto _L___395;
  } else {
    {
#line 2649
    __cil_tmp379 = strcmp((char const   *)*args, (char const   *)((char *)"string"));
    }
#line 2649
    if (! __cil_tmp379) {
#line 2651
      if (*(args + 1)) {
#line 2653
        if (logtstamp_string) {
          {
#line 2654
          free((void *)logtstamp_string);
          }
        }
        {
#line 2655
        logtstamp_string = SaveStr((char const   *)*(args + 1));
        }
      }
#line 2657
      if (msgok) {
#line 2658
        if (! act->quiet) {
#line 2658
          tmp___390 = Msg;
        } else {
#line 2658
          if (queryflag >= 0) {
#line 2658
            tmp___389 = QueryMsg;
          } else {
#line 2658
            tmp___389 = Dummy;
          }
#line 2658
          tmp___390 = tmp___389;
        }
        {
#line 2658
        tmp___390(0, (char const   *)((char *)"logfile timestamp is \'%s\'"), logtstamp_string);
        }
      }
    } else {
      {
#line 2660
      __cil_tmp383 = strcmp((char const   *)*args, (char const   *)((char *)"after"));
      }
#line 2660
      if (! __cil_tmp383) {
#line 2662
        if (*(args + 1)) {
          {
#line 2664
          logtstamp_after = atoi((char const   *)*(args + 1));
          }
#line 2665
          if (! msgok) {
#line 2666
            goto switch_break;
          }
        }
#line 2668
        if (! act->quiet) {
#line 2668
          tmp___392 = Msg;
        } else {
#line 2668
          if (queryflag >= 0) {
#line 2668
            tmp___391 = QueryMsg;
          } else {
#line 2668
            tmp___391 = Dummy;
          }
#line 2668
          tmp___392 = tmp___391;
        }
        {
#line 2668
        tmp___392(0, (char const   *)((char *)"timestamp printed after %ds\n"), logtstamp_after);
        }
      } else {
#line 2671
        if (! act->quiet) {
#line 2671
          tmp___394 = Msg;
        } else {
#line 2671
          if (queryflag >= 0) {
#line 2671
            tmp___393 = QueryMsg;
          } else {
#line 2671
            tmp___393 = Dummy;
          }
#line 2671
          tmp___394 = tmp___393;
        }
        {
#line 2671
        tmp___394(0, (char const   *)((char *)"usage: logtstamp [after [n]|string [str]|on|off]"));
        }
      }
    }
  }
#line 2672
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 2674
  __cil_tmp389 = ParseSaveStr(act, & nwin_default.aka);
  }
#line 2675
  goto switch_break;
  case_166: /* CIL Label */ 
  case_165: /* CIL Label */ 
  case_164: /* CIL Label */ 
#line 2679
  if (! rc_name) {
    _L___399: /* CIL Label */ 
#line 2680
    if (! act->quiet) {
#line 2680
      tmp___398 = Msg;
    } else {
#line 2680
      if (queryflag >= 0) {
#line 2680
        tmp___397 = QueryMsg;
      } else {
#line 2680
        tmp___397 = Dummy;
      }
#line 2680
      tmp___398 = tmp___397;
    }
    {
#line 2680
    tmp___398(0, (char const   *)((char *)"Sorry, too late now. Place that in your .screenrc file."));
    }
  } else
#line 2679
  if (! *rc_name) {
#line 2679
    goto _L___399;
  }
#line 2681
  goto switch_break;
  case_153: /* CIL Label */ 
#line 2683
  goto switch_break;
  case_163: /* CIL Label */ 
#line 2685
  s = (char *)((void *)0);
  {
#line 2686
  __cil_tmp392 = ParseSaveStr(act, & s);
  }
#line 2686
  if (__cil_tmp392) {
#line 2687
    goto switch_break;
  }
  {
#line 2688
  __cil_tmp393 = strlen((char const   *)s);
  }
#line 2688
  if (__cil_tmp393 > 32UL) {
#line 2690
    if (! act->quiet) {
#line 2690
      tmp___401 = Msg;
    } else {
#line 2690
      if (queryflag >= 0) {
#line 2690
        tmp___400 = QueryMsg;
      } else {
#line 2690
        tmp___400 = Dummy;
      }
#line 2690
      tmp___401 = tmp___400;
    }
    {
#line 2690
    tmp___401(0, (char const   *)((char *)"%s: term: argument too long ( < %d)"),
              rc_name, 32);
#line 2691
    free((void *)s);
    }
#line 2692
    goto switch_break;
  }
  {
#line 2694
  strncpy((char *)screenterm, (char const   *)s, (unsigned long )32);
#line 2695
  screenterm[32] = (char )'\000';
#line 2696
  free((void *)s);
  }
  {
#line 2697
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 2697
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 2698
  MakeTermcap(display == (struct display *)0);
  }
  {
#line 2699
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 2699
    goto while_break___24;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 2700
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 2702
  __cil_tmp396 = strcmp((char const   *)rc_name, (char const   *)((char *)"-X"));
  }
#line 2702
  if (! msgok) {
#line 2702
    if (! rc_name) {
#line 2703
      goto switch_break;
    } else
#line 2702
    if (__cil_tmp396) {
#line 2703
      goto switch_break;
    }
  }
  {
#line 2708
  __cil_tmp397 = strcmp((char const   *)*args, (char const   *)((char *)"-n"));
  }
#line 2708
  if (argc > 1) {
#line 2708
    if (! __cil_tmp397) {
#line 2710
      args ++;
#line 2711
      __cil_tmp399 = argc;
#line 2711
      argc --;
    }
  }
  {
#line 2713
  s = *args;
#line 2714
  __cil_tmp400 = strcmp((char const   *)*args, (char const   *)((char *)"-p"));
  }
#line 2714
  if (argc > 1) {
#line 2714
    if (! __cil_tmp400) {
#line 2716
      args ++;
#line 2717
      __cil_tmp402 = argc;
#line 2717
      argc --;
#line 2718
      s = *args;
#line 2719
      if (s) {
        {
#line 2720
        s = MakeWinMsg(s, fore, '%');
        }
      }
    }
  }
#line 2722
  if (s) {
#line 2723
    if (! act->quiet) {
#line 2723
      tmp___403 = Msg;
    } else {
#line 2723
      if (queryflag >= 0) {
#line 2723
        tmp___402 = QueryMsg;
      } else {
#line 2723
        tmp___402 = Dummy;
      }
#line 2723
      tmp___403 = tmp___402;
    }
    {
#line 2723
    tmp___403(0, (char const   *)((char *)"%s"), s);
    }
  } else {
#line 2726
    if (! act->quiet) {
#line 2726
      tmp___405 = Msg;
    } else {
#line 2726
      if (queryflag >= 0) {
#line 2726
        tmp___404 = QueryMsg;
      } else {
#line 2726
        tmp___404 = Dummy;
      }
#line 2726
      tmp___405 = tmp___404;
    }
    {
#line 2726
    tmp___405(0, (char const   *)((char *)"%s: \'echo [-n] [-p] \"string\"\' expected."),
              rc_name);
#line 2727
    queryflag = - 1;
    }
  }
#line 2729
  goto switch_break;
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
#line 2732
  if (*args == (char *)0) {
    {
#line 2735
    AddXChars((char *)buf___1, (int )sizeof(buf___1), BellString);
    }
#line 2736
    if (! act->quiet) {
#line 2736
      tmp___407 = Msg;
    } else {
#line 2736
      if (queryflag >= 0) {
#line 2736
        tmp___406 = QueryMsg;
      } else {
#line 2736
        tmp___406 = Dummy;
      }
#line 2736
      tmp___407 = tmp___406;
    }
    {
#line 2736
    tmp___407(0, (char const   *)((char *)"bell_msg is \'%s\'"), (char *)buf___1);
    }
#line 2737
    goto switch_break;
  }
  {
#line 2739
  __cil_tmp411 = ParseSaveStr(act, & BellString);
  }
#line 2740
  goto switch_break;
  case_23: /* CIL Label */ 
#line 2743
  if (*args == (char *)0) {
    {
#line 2744
    BufferFile = SaveStr((char const   *)((char *)"/tmp/screen-exchange"));
    }
  } else {
    {
#line 2745
    __cil_tmp413 = ParseSaveStr(act, & BufferFile);
    }
#line 2745
    if (__cil_tmp413) {
#line 2746
      goto switch_break;
    }
  }
#line 2747
  if (msgok) {
#line 2748
    if (! act->quiet) {
#line 2748
      tmp___409 = Msg;
    } else {
#line 2748
      if (queryflag >= 0) {
#line 2748
        tmp___408 = QueryMsg;
      } else {
#line 2748
        tmp___408 = Dummy;
      }
#line 2748
      tmp___409 = tmp___408;
    }
    {
#line 2748
    tmp___409(0, (char const   *)((char *)"Bufferfile is now \'%s\'"), BufferFile);
    }
  }
#line 2749
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2752
  __cil_tmp416 = ParseSaveStr(act, & ActivityString);
  }
#line 2753
  goto switch_break;
  case_129: /* CIL Label */ 
#line 2756
  if (*args == (char *)0) {
    {
#line 2759
    AddXChars((char *)buf___2, (int )sizeof(buf___2), PowDetachString);
    }
#line 2760
    if (! act->quiet) {
#line 2760
      tmp___411 = Msg;
    } else {
#line 2760
      if (queryflag >= 0) {
#line 2760
        tmp___410 = QueryMsg;
      } else {
#line 2760
        tmp___410 = Dummy;
      }
#line 2760
      tmp___411 = tmp___410;
    }
    {
#line 2760
    tmp___411(0, (char const   *)((char *)"pow_detach_msg is \'%s\'"), (char *)buf___2);
    }
#line 2761
    goto switch_break;
  }
  {
#line 2763
  __cil_tmp420 = ParseSaveStr(act, & PowDetachString);
  }
#line 2764
  goto switch_break;
  case_103: /* CIL Label */ 
#line 2768
  n = fore->w_slot != (slot_t )-1;
  {
#line 2769
  __cil_tmp421 = strcmp((char const   *)*args, (char const   *)((char *)"always"));
  }
#line 2769
  if (*args) {
#line 2769
    if (! __cil_tmp421) {
#line 2771
      fore->w_lflag = 3;
#line 2772
      if (! displays) {
#line 2772
        if (n) {
          {
#line 2773
          SlotToggle(n);
          }
        }
      }
#line 2774
      goto switch_break;
    }
  }
  {
#line 2776
  __cil_tmp422 = strcmp((char const   *)*args, (char const   *)((char *)"attached"));
  }
#line 2776
  if (*args) {
#line 2776
    if (! __cil_tmp422) {
#line 2778
      fore->w_lflag = 1;
#line 2779
      if (! displays) {
#line 2779
        if (n) {
          {
#line 2780
          SlotToggle(0);
          }
        }
      }
#line 2781
      goto switch_break;
    }
  }
  {
#line 2783
  __cil_tmp423 = ParseSwitch(act, & n);
  }
#line 2783
  if (__cil_tmp423 == 0) {
    {
#line 2784
    SlotToggle(n);
    }
  }
#line 2785
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 2787
  __cil_tmp424 = strcmp((char const   *)*args, (char const   *)((char *)"always"));
  }
#line 2787
  if (! __cil_tmp424) {
#line 2788
    nwin_default.lflag |= 2;
  } else {
    {
#line 2789
    __cil_tmp425 = strcmp((char const   *)*args, (char const   *)((char *)"attached"));
    }
#line 2789
    if (! __cil_tmp425) {
#line 2790
      nwin_default.lflag &= ~ 2;
    } else {
      {
#line 2792
      __cil_tmp426 = ParseOnOff(act, & nwin_default.lflag);
      }
    }
  }
#line 2793
  goto switch_break;
  case_49: /* CIL Label */ 
#line 2796
  if (*(args + 0)) {
#line 2796
    if (*(args + 1)) {
#line 2796
      if ((int )*(*(args + 1) + 0) == 105) {
#line 2798
        iflag = 1;
#line 2799
        display = displays;
        {
#line 2799
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 2799
          if (! display) {
#line 2799
            goto while_break___25;
          }
#line 2801
          if (! display->d_flow) {
#line 2802
            goto while_continue___25;
          }
          {
#line 2804
          display->d_NewMode.tio.c_cc[0] = display->d_OldMode.tio.c_cc[0];
#line 2805
          display->d_NewMode.tio.c_lflag |= (unsigned int )1;
#line 2809
          SetTTY(display->d_userfd, & display->d_NewMode);
          }
        }
        while_break___25: /* CIL Label */ ;
        }
#line 2799
        display = display->d_next;
      }
    }
  }
#line 2812
  if (*(args + 0)) {
#line 2812
    if ((int )*(*(args + 0) + 0) == 97) {
#line 2813
      nwin_default.flowflag = 1 << 2;
    } else {
      {
      {
#line 2815
      __cil_tmp427 = ParseOnOff(act, & nwin_default.flowflag);
      }
      }
    }
  } else {
    {
    {
#line 2815
    __cil_tmp427 = ParseOnOff(act, & nwin_default.flowflag);
    }
    }
  }
#line 2816
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 2818
  __cil_tmp428 = ParseOnOff(act, & nwin_default.wrap);
  }
#line 2819
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 2821
  __cil_tmp429 = ParseOnOff(act, & nwin_default.c1);
  }
#line 2822
  goto switch_break;
  case_42___0: /* CIL Label */ 
  {
#line 2825
  __cil_tmp430 = ParseOnOff(act, & nwin_default.bce);
  }
#line 2826
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 2829
  __cil_tmp431 = ParseOnOff(act, & nwin_default.gr);
  }
#line 2830
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 2832
  __cil_tmp432 = ParseOnOff(act, & n);
  }
#line 2832
  if (__cil_tmp432 == 0) {
#line 2833
    if (n == 0) {
#line 2833
      tmp___412 = 0;
    } else {
#line 2833
      tmp___412 = 1;
    }
#line 2833
    nwin_default.monitor = tmp___412;
  }
#line 2834
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 2836
  __cil_tmp434 = ParseOnOff(act, & n);
  }
#line 2836
  if (__cil_tmp434 == 0) {
#line 2837
    if (n == 0) {
#line 2837
      tmp___413 = 0;
    } else {
#line 2837
      tmp___413 = 1000;
    }
#line 2837
    defmousetrack = tmp___413;
  }
#line 2838
  goto switch_break;
  case_112: /* CIL Label */ 
#line 2840
  if (! *(args + 0)) {
#line 2842
    if (! act->quiet) {
#line 2842
      tmp___415 = Msg;
    } else {
#line 2842
      if (queryflag >= 0) {
#line 2842
        tmp___414 = QueryMsg;
      } else {
#line 2842
        tmp___414 = Dummy;
      }
#line 2842
      tmp___415 = tmp___414;
    }
#line 2842
    if (display->d_mousetrack) {
#line 2842
      tmp___416 = (char *)"on";
    } else {
#line 2842
      tmp___416 = (char *)"off";
    }
    {
#line 2842
    tmp___415(0, (char const   *)((char *)"Mouse tracking for this display is turned %s"),
              tmp___416);
    }
  } else {
    {
#line 2844
    __cil_tmp439 = ParseOnOff(act, & n);
    }
#line 2844
    if (__cil_tmp439 == 0) {
#line 2846
      if (n == 0) {
#line 2846
        tmp___417 = 0;
      } else {
#line 2846
        tmp___417 = 1000;
      }
#line 2846
      display->d_mousetrack = tmp___417;
#line 2847
      if (display->d_fore) {
        {
#line 2848
        MouseMode((display->d_fore)->w_mouse);
        }
      }
    }
  }
#line 2850
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 2852
  __cil_tmp441 = ParseOnOff(act, & n);
  }
#line 2852
  if (__cil_tmp441 == 0) {
#line 2853
    if (n == 0) {
#line 2853
      tmp___418 = 0;
    } else {
#line 2853
      tmp___418 = 1;
    }
#line 2853
    nwin_default.silence = tmp___418;
  }
#line 2854
  goto switch_break;
  case_176: /* CIL Label */ 
#line 2856
  if (! *args) {
#line 2857
    if (! act->quiet) {
#line 2857
      tmp___420 = Msg;
    } else {
#line 2857
      if (queryflag >= 0) {
#line 2857
        tmp___419 = QueryMsg;
      } else {
#line 2857
        tmp___419 = Dummy;
      }
#line 2857
      tmp___420 = tmp___419;
    }
#line 2857
    if (VerboseCreate) {
#line 2857
      tmp___421 = (char *)"ill";
    } else {
#line 2857
      tmp___421 = (char *)"on\'t";
    }
    {
#line 2857
    tmp___420(0, (char const   *)((char *)"W%s echo command when creating windows."),
              tmp___421);
    }
  } else {
    {
#line 2859
    __cil_tmp446 = ParseOnOff(act, & n);
    }
#line 2859
    if (__cil_tmp446 == 0) {
#line 2860
      VerboseCreate = n;
    }
  }
#line 2861
  goto switch_break;
  case_87: /* CIL Label */ 
#line 2863
  if (display) {
#line 2865
    if (! act->quiet) {
#line 2865
      tmp___423 = Msg;
    } else {
#line 2865
      if (queryflag >= 0) {
#line 2865
        tmp___422 = QueryMsg;
      } else {
#line 2865
        tmp___422 = Dummy;
      }
#line 2865
      tmp___423 = tmp___422;
    }
    {
#line 2865
    tmp___423(0, (char const   *)((char *)"%s"), (char *)"");
#line 2866
    RemoveStatus();
    }
  }
  {
#line 2868
  __cil_tmp450 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"off"));
  }
  {
#line 2868
  __cil_tmp449 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"on"));
  }
#line 2868
  if (*(args + 0)) {
#line 2868
    if (__cil_tmp449) {
#line 2868
      if (__cil_tmp450) {
        {
#line 2870
        olddisplay___0 = display;
#line 2871
        new_use = - 1;
#line 2873
        s = *(args + 0);
#line 2874
        __cil_tmp454 = strncmp((char const   *)s, (char const   *)((char *)"always"),
                               (unsigned long )6);
        }
#line 2874
        if (! __cil_tmp454) {
#line 2875
          s += 6;
        }
        {
#line 2876
        __cil_tmp455 = strcmp((char const   *)s, (char const   *)((char *)"firstline"));
        }
#line 2876
        if (! __cil_tmp455) {
#line 2877
          new_use = 4;
        } else {
          {
#line 2878
          __cil_tmp456 = strcmp((char const   *)s, (char const   *)((char *)"lastline"));
          }
#line 2878
          if (! __cil_tmp456) {
#line 2879
            new_use = 1;
          } else {
            {
#line 2880
            __cil_tmp457 = strcmp((char const   *)s, (char const   *)((char *)"ignore"));
            }
#line 2880
            if (! __cil_tmp457) {
#line 2881
              new_use = 0;
            } else {
              {
#line 2882
              __cil_tmp458 = strcmp((char const   *)s, (char const   *)((char *)"message"));
              }
#line 2882
              if (! __cil_tmp458) {
#line 2883
                new_use = 2;
              } else {
                {
#line 2884
                __cil_tmp459 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"string"));
                }
#line 2884
                if (! __cil_tmp459) {
#line 2886
                  if (! *(args + 1)) {
                    {
#line 2889
                    AddXChars((char *)buf___3, (int )sizeof(buf___3), hstatusstring);
                    }
#line 2890
                    if (! act->quiet) {
#line 2890
                      tmp___425 = Msg;
                    } else {
#line 2890
                      if (queryflag >= 0) {
#line 2890
                        tmp___424 = QueryMsg;
                      } else {
#line 2890
                        tmp___424 = Dummy;
                      }
#line 2890
                      tmp___425 = tmp___424;
                    }
                    {
#line 2890
                    tmp___425(0, (char const   *)((char *)"hardstatus string is \'%s\'"),
                              (char *)buf___3);
                    }
#line 2891
                    goto switch_break;
                  }
                } else {
#line 2896
                  if (! act->quiet) {
#line 2896
                    tmp___427 = Msg;
                  } else {
#line 2896
                    if (queryflag >= 0) {
#line 2896
                      tmp___426 = QueryMsg;
                    } else {
#line 2896
                      tmp___426 = Dummy;
                    }
#line 2896
                    tmp___427 = tmp___426;
                  }
                  {
#line 2896
                  tmp___427(0, (char const   *)((char *)"%s: usage: hardstatus [always]lastline|ignore|message|string [string]"),
                            rc_name);
                  }
#line 2897
                  goto switch_break;
                }
              }
            }
          }
        }
#line 2899
        if (new_use != -1) {
#line 2901
          if (s == *(args + 0)) {
#line 2901
            tmp___428 = 0;
          } else {
#line 2901
            tmp___428 = 1 << 3;
          }
#line 2901
          hardstatusemu = new_use | tmp___428;
#line 2902
          display = displays;
          {
#line 2902
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 2902
            if (! display) {
#line 2902
              goto while_break___26;
            }
            {
#line 2904
            RemoveStatus();
#line 2905
            new_use = hardstatusemu & ~ (1 << 3);
            }
#line 2906
            if (display->d_tcs[75].flg) {
#line 2906
              if (s == *(args + 0)) {
#line 2907
                new_use = 3;
              }
            }
            {
#line 2908
            ShowHStatus((char *)0);
#line 2909
            old_use = display->d_has_hstatus;
#line 2910
            display->d_has_hstatus = new_use;
            }
#line 2911
            if (new_use == 1) {
#line 2911
              if (old_use != 1) {
                {
                {
#line 2912
                ChangeScreenSize(display->d_width, display->d_height, 1);
                }
                }
              } else {
#line 2911
                goto _L___429;
              }
            } else
            _L___429: /* CIL Label */ 
#line 2911
            if (new_use != 1) {
#line 2911
              if (old_use == 1) {
                {
                {
#line 2912
                ChangeScreenSize(display->d_width, display->d_height, 1);
                }
                }
              }
            }
#line 2913
            if (new_use == 4) {
#line 2913
              if (old_use != 4) {
                {
                {
#line 2914
                ChangeScreenSize(display->d_width, display->d_height, 1);
                }
                }
              } else {
#line 2913
                goto _L___430;
              }
            } else
            _L___430: /* CIL Label */ 
#line 2913
            if (new_use != 4) {
#line 2913
              if (old_use == 4) {
                {
                {
#line 2914
                ChangeScreenSize(display->d_width, display->d_height, 1);
                }
                }
              }
            }
            {
#line 2915
            RefreshHStatus();
            }
          }
          while_break___26: /* CIL Label */ ;
          }
#line 2902
          display = display->d_next;
        }
#line 2918
        if (*(args + 1)) {
#line 2920
          if (hstatusstring) {
            {
#line 2921
            free((void *)hstatusstring);
            }
          }
          {
#line 2922
          hstatusstring = SaveStr((char const   *)*(args + 1));
#line 2923
          display = displays;
          }
          {
#line 2923
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 2923
            if (! display) {
#line 2923
              goto while_break___27;
            }
            {
#line 2924
            RefreshHStatus();
            }
          }
          while_break___27: /* CIL Label */ ;
          }
#line 2923
          display = display->d_next;
        }
#line 2926
        display = olddisplay___0;
#line 2927
        goto switch_break;
      }
    }
  }
  {
#line 2929
  __cil_tmp467 = ParseSwitch(act, & use_hardstatus);
  }
#line 2930
  if (msgok) {
#line 2931
    if (! act->quiet) {
#line 2931
      tmp___432 = Msg;
    } else {
#line 2931
      if (queryflag >= 0) {
#line 2931
        tmp___431 = QueryMsg;
      } else {
#line 2931
        tmp___431 = Dummy;
      }
#line 2931
      tmp___432 = tmp___431;
    }
#line 2931
    if (use_hardstatus) {
#line 2931
      tmp___433 = (char *)"hardstatus line";
    } else {
#line 2931
      tmp___433 = (char *)"window";
    }
    {
#line 2931
    tmp___432(0, (char const   *)((char *)"messages displayed on %s"), tmp___433);
    }
  }
#line 2932
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 2934
  __cil_tmp472 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"splitonly"));
  }
  {
#line 2934
  __cil_tmp471 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"always"));
  }
#line 2934
  if (__cil_tmp471 == 0) {
    _L___438: /* CIL Label */ 
#line 2936
    olddisplay___1 = display;
#line 2938
    captionalways = (int )*(*(args + 0) + 0) == 97;
#line 2939
    display = displays;
    {
#line 2939
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 2939
      if (! display) {
#line 2939
        goto while_break___28;
      }
      {
#line 2940
      ChangeScreenSize(display->d_width, display->d_height, 1);
      }
    }
    while_break___28: /* CIL Label */ ;
    }
#line 2939
    display = display->d_next;
#line 2941
    display = olddisplay___1;
  } else
#line 2934
  if (__cil_tmp472 == 0) {
#line 2934
    goto _L___438;
  } else {
    {
#line 2943
    __cil_tmp474 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"string"));
    }
#line 2943
    if (__cil_tmp474 == 0) {
#line 2945
      if (! *(args + 1)) {
        {
#line 2948
        AddXChars((char *)buf___4, (int )sizeof(buf___4), captionstring);
        }
#line 2949
        if (! act->quiet) {
#line 2949
          tmp___435 = Msg;
        } else {
#line 2949
          if (queryflag >= 0) {
#line 2949
            tmp___434 = QueryMsg;
          } else {
#line 2949
            tmp___434 = Dummy;
          }
#line 2949
          tmp___435 = tmp___434;
        }
        {
#line 2949
        tmp___435(0, (char const   *)((char *)"caption string is \'%s\'"), (char *)buf___4);
        }
#line 2950
        goto switch_break;
      }
    } else {
#line 2955
      if (! act->quiet) {
#line 2955
        tmp___437 = Msg;
      } else {
#line 2955
        if (queryflag >= 0) {
#line 2955
          tmp___436 = QueryMsg;
        } else {
#line 2955
          tmp___436 = Dummy;
        }
#line 2955
        tmp___437 = tmp___436;
      }
      {
#line 2955
      tmp___437(0, (char const   *)((char *)"%s: usage: caption always|splitonly|string <string>"),
                rc_name);
      }
#line 2956
      goto switch_break;
    }
  }
#line 2958
  if (! *(args + 1)) {
#line 2959
    goto switch_break;
  }
#line 2960
  if (captionstring) {
    {
#line 2961
    free((void *)captionstring);
    }
  }
  {
#line 2962
  captionstring = SaveStr((char const   *)*(args + 1));
#line 2963
  RedisplayDisplays(0);
  }
#line 2964
  goto switch_break;
  case_37___0: /* CIL Label */ 
#line 2966
  n = console_window != (struct win *)0;
  {
#line 2967
  __cil_tmp481 = ParseSwitch(act, & n);
  }
#line 2967
  if (__cil_tmp481) {
#line 2968
    goto switch_break;
  }
  {
#line 2969
  __cil_tmp482 = TtyGrabConsole(fore->w_ptyfd, n, rc_name);
  }
#line 2969
  if (__cil_tmp482) {
#line 2970
    goto switch_break;
  }
#line 2971
  if (n == 0) {
#line 2972
    if (! act->quiet) {
#line 2972
      tmp___440 = Msg;
    } else {
#line 2972
      if (queryflag >= 0) {
#line 2972
        tmp___439 = QueryMsg;
      } else {
#line 2972
        tmp___439 = Dummy;
      }
#line 2972
      tmp___440 = tmp___439;
    }
    {
#line 2972
    tmp___440(0, (char const   *)((char *)"%s: releasing console %s"), rc_name, (char *)HostName);
    }
  } else
#line 2973
  if (console_window) {
#line 2974
    if (! act->quiet) {
#line 2974
      tmp___442 = Msg;
    } else {
#line 2974
      if (queryflag >= 0) {
#line 2974
        tmp___441 = QueryMsg;
      } else {
#line 2974
        tmp___441 = Dummy;
      }
#line 2974
      tmp___442 = tmp___441;
    }
    {
#line 2974
    tmp___442(0, (char const   *)((char *)"%s: stealing console %s from window %d (%s)"),
              rc_name, (char *)HostName, console_window->w_number, console_window->w_title);
    }
  } else {
#line 2977
    if (! act->quiet) {
#line 2977
      tmp___444 = Msg;
    } else {
#line 2977
      if (queryflag >= 0) {
#line 2977
        tmp___443 = QueryMsg;
      } else {
#line 2977
        tmp___443 = Dummy;
      }
#line 2977
      tmp___444 = tmp___443;
    }
    {
#line 2977
    tmp___444(0, (char const   *)((char *)"%s: grabbing console %s"), rc_name, (char *)HostName);
    }
  }
#line 2978
  if (n) {
#line 2978
    tmp___445 = fore;
  } else {
#line 2978
    tmp___445 = (struct win *)0;
  }
#line 2978
  console_window = tmp___445;
#line 2979
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2981
  __cil_tmp490 = ParseOnOff(act, & all_norefresh);
  }
#line 2981
  if (__cil_tmp490) {
#line 2982
    goto switch_break;
  }
#line 2983
  if (! all_norefresh) {
#line 2983
    if (fore) {
      {
#line 2984
      Activate(- 1);
      }
    }
  }
#line 2985
  if (msgok) {
#line 2986
    if (! act->quiet) {
#line 2986
      tmp___447 = Msg;
    } else {
#line 2986
      if (queryflag >= 0) {
#line 2986
        tmp___446 = QueryMsg;
      } else {
#line 2986
        tmp___446 = Dummy;
      }
#line 2986
      tmp___447 = tmp___446;
    }
#line 2986
    if (all_norefresh) {
#line 2986
      tmp___448 = (char *)"No refresh on window change!\n";
    } else {
#line 2986
      tmp___448 = (char *)"Window specific refresh\n";
    }
    {
#line 2986
    tmp___447(0, (char const   *)tmp___448);
    }
  }
#line 2988
  goto switch_break;
  case_123: /* CIL Label */ 
  {
#line 2990
  __cil_tmp494 = ParseSwitch(act, & n);
  }
#line 2991
  fore->w_norefresh = (char )n;
#line 2992
  goto switch_break;
  case_173: /* CIL Label */ 
  {
#line 2994
  __cil_tmp495 = ParseSwitch(act, & visual_bell);
  }
#line 2994
  if (__cil_tmp495) {
#line 2995
    goto switch_break;
  } else
#line 2994
  if (! msgok) {
#line 2995
    goto switch_break;
  }
#line 2996
  if (visual_bell == 0) {
#line 2997
    if (! act->quiet) {
#line 2997
      tmp___450 = Msg;
    } else {
#line 2997
      if (queryflag >= 0) {
#line 2997
        tmp___449 = QueryMsg;
      } else {
#line 2997
        tmp___449 = Dummy;
      }
#line 2997
      tmp___450 = tmp___449;
    }
    {
#line 2997
    tmp___450(0, (char const   *)((char *)"switched to audible bell."));
    }
  } else {
#line 2999
    if (! act->quiet) {
#line 2999
      tmp___452 = Msg;
    } else {
#line 2999
      if (queryflag >= 0) {
#line 2999
        tmp___451 = QueryMsg;
      } else {
#line 2999
        tmp___451 = Dummy;
      }
#line 2999
      tmp___452 = tmp___451;
    }
    {
#line 2999
    tmp___452(0, (char const   *)((char *)"switched to visual bell."));
    }
  }
#line 3000
  goto switch_break;
  case_175: /* CIL Label */ 
  {
#line 3002
  __cil_tmp500 = ParseNum1000(act, & VBellWait);
  }
#line 3002
  if (__cil_tmp500 == 0) {
#line 3002
    if (msgok) {
#line 3003
      if (! act->quiet) {
#line 3003
        tmp___454 = Msg;
      } else {
#line 3003
        if (queryflag >= 0) {
#line 3003
          tmp___453 = QueryMsg;
        } else {
#line 3003
          tmp___453 = Dummy;
        }
#line 3003
        tmp___454 = tmp___453;
      }
      {
#line 3003
      tmp___454(0, (char const   *)((char *)"vbellwait set to %.10g seconds"), (double )VBellWait / 1000.);
      }
    }
  }
#line 3004
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 3006
  __cil_tmp503 = ParseNum1000(act, & MsgWait);
  }
#line 3006
  if (__cil_tmp503 == 0) {
#line 3006
    if (msgok) {
#line 3007
      if (! act->quiet) {
#line 3007
        tmp___456 = Msg;
      } else {
#line 3007
        if (queryflag >= 0) {
#line 3007
          tmp___455 = QueryMsg;
        } else {
#line 3007
          tmp___455 = Dummy;
        }
#line 3007
        tmp___456 = tmp___455;
      }
      {
#line 3007
      tmp___456(0, (char const   *)((char *)"msgwait set to %.10g seconds"), (double )MsgWait / 1000.);
      }
    }
  }
#line 3008
  goto switch_break;
  case_113: /* CIL Label */ 
  {
#line 3010
  __cil_tmp506 = ParseNum1000(act, & MsgMinWait);
  }
#line 3010
  if (__cil_tmp506 == 0) {
#line 3010
    if (msgok) {
#line 3011
      if (! act->quiet) {
#line 3011
        tmp___458 = Msg;
      } else {
#line 3011
        if (queryflag >= 0) {
#line 3011
          tmp___457 = QueryMsg;
        } else {
#line 3011
          tmp___457 = Dummy;
        }
#line 3011
        tmp___458 = tmp___457;
      }
      {
#line 3011
      tmp___458(0, (char const   *)((char *)"msgminwait set to %.10g seconds"), (double )MsgMinWait / 1000.);
      }
    }
  }
#line 3012
  goto switch_break;
  case_152: /* CIL Label */ 
  {
#line 3014
  __cil_tmp509 = ParseNum(act, & SilenceWait);
  }
#line 3014
  if (__cil_tmp509) {
#line 3015
    goto switch_break;
  }
#line 3016
  if (SilenceWait < 1) {
#line 3017
    SilenceWait = 1;
  }
#line 3018
  p = windows;
  {
#line 3018
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 3018
    if (! p) {
#line 3018
      goto while_break___29;
    }
#line 3019
    p->w_silencewait = SilenceWait;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 3018
  p = p->w_next;
#line 3020
  if (msgok) {
#line 3021
    if (! act->quiet) {
#line 3021
      tmp___460 = Msg;
    } else {
#line 3021
      if (queryflag >= 0) {
#line 3021
        tmp___459 = QueryMsg;
      } else {
#line 3021
        tmp___459 = Dummy;
      }
#line 3021
      tmp___460 = tmp___459;
    }
    {
#line 3021
    tmp___460(0, (char const   *)((char *)"silencewait set to %d seconds"), SilenceWait);
    }
  }
#line 3022
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 3024
  __cil_tmp512 = NextWindow();
  }
#line 3024
  if (fore->w_number < __cil_tmp512) {
    {
#line 3025
    __cil_tmp513 = NextWindow();
#line 3025
    WindowChangeNumber(fore->w_number, __cil_tmp513);
    }
  }
#line 3026
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 3028
  __cil_tmp514 = PreviousWindow();
  }
#line 3028
  if (fore->w_number > __cil_tmp514) {
    {
#line 3029
    __cil_tmp515 = PreviousWindow();
#line 3029
    WindowChangeNumber(fore->w_number, __cil_tmp515);
    }
  }
#line 3030
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 3032
  CollapseWindowlist();
  }
#line 3033
  goto switch_break;
  case_119: /* CIL Label */ 
#line 3035
  if (*args == (char *)0) {
#line 3036
    if (! act->quiet) {
#line 3036
      tmp___462 = Msg;
    } else {
#line 3036
      if (queryflag >= 0) {
#line 3036
        tmp___461 = QueryMsg;
      } else {
#line 3036
        tmp___461 = Dummy;
      }
#line 3036
      tmp___462 = tmp___461;
    }
#line 3036
    if (queryflag >= 0) {
#line 3036
      tmp___463 = (char *)"%d (%s)";
    } else {
#line 3036
      tmp___463 = (char *)"This is window %d (%s).";
    }
    {
#line 3036
    tmp___462(0, (char const   *)tmp___463, fore->w_number, fore->w_title);
    }
  } else {
#line 3039
    old = fore->w_number;
#line 3040
    rel = 0;
#line 3041
    if ((int )*(*(args + 0) + 0) == 43) {
#line 3042
      rel = 1;
    } else
#line 3043
    if ((int )*(*(args + 0) + 0) == 45) {
#line 3044
      rel = - 1;
    }
#line 3045
    if (rel) {
#line 3046
      (*(act->args + 0)) ++;
    }
    {
#line 3047
    parse = ParseNum(act, & n);
    }
#line 3048
    if (rel) {
#line 3049
      (*(act->args + 0)) --;
    }
#line 3050
    if (parse) {
#line 3051
      goto switch_break;
    }
#line 3052
    if (rel > 0) {
#line 3053
      n += old;
    } else
#line 3054
    if (rel < 0) {
#line 3055
      n = old - n;
    }
    {
#line 3056
    __cil_tmp523 = WindowChangeNumber(old, n);
    }
#line 3056
    if (! __cil_tmp523) {
#line 3059
      queryflag = - 1;
#line 3060
      return;
    }
  }
#line 3063
  goto switch_break;
  case_189: /* CIL Label */ 
#line 3066
  if (argc != 1) {
    {
#line 3067
    Msg(0, (char const   *)((char *)"Setting zombie polling needs a timeout arg\n"));
    }
#line 3068
    goto switch_break;
  }
  {
#line 3071
  nwin_default.poll_zombie_timeout = atoi((char const   *)*(args + 0));
  }
#line 3072
  if (fore) {
#line 3073
    fore->w_poll_zombie_timeout = nwin_default.poll_zombie_timeout;
  }
  {
#line 3074
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 3074
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
#line 3075
  goto switch_break;
  case_156: /* CIL Label */ 
#line 3078
  if (fore) {
    {
#line 3083
    Msg(0, (char const   *)((char *)"Sorting inside a window is not allowed. Push CTRL-a \" and try again\n"));
    }
#line 3085
    goto switch_break;
  }
#line 3091
  i = 0;
  {
#line 3091
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 3091
    if (! (i < maxwin)) {
#line 3091
      goto while_break___31;
    }
#line 3092
    if (*(wtab + i) == (struct win *)((void *)0)) {
#line 3093
      goto while_continue___31;
    }
#line 3094
    n = i;
#line 3096
    nr = i + 1;
    {
#line 3096
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 3096
      if (! (nr < maxwin)) {
#line 3096
        goto while_break___32;
      }
#line 3097
      if (*(wtab + nr) == (struct win *)((void *)0)) {
#line 3098
        goto while_continue___32;
      }
      {
#line 3099
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 3099
        goto while_break___33;
      }
      while_break___33: /* CIL Label */ ;
      }
      {
#line 3100
      __cil_tmp525 = strcmp((char const   *)(*(wtab + nr))->w_title, (char const   *)(*(wtab + n))->w_title);
      }
#line 3100
      if (__cil_tmp525 < 0) {
#line 3101
        n = nr;
      }
    }
    while_break___32: /* CIL Label */ ;
    }
#line 3096
    nr ++;
#line 3104
    if (n != i) {
      {
#line 3105
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 3105
        goto while_break___34;
      }
      while_break___34: /* CIL Label */ ;
      }
      {
#line 3106
      p = *(wtab + n);
#line 3107
      *(wtab + n) = *(wtab + i);
#line 3108
      *(wtab + i) = p;
#line 3109
      (*(wtab + n))->w_number = n;
#line 3110
      (*(wtab + i))->w_number = i;
#line 3113
      AclWinSwap(i, n);
      }
    }
  }
  while_break___31: /* CIL Label */ ;
  }
  {
#line 3091
  i ++;
#line 3117
  WindowChanged((struct win *)0, 0);
  }
#line 3118
  goto switch_break;
  case_151: /* CIL Label */ 
#line 3121
  n = fore->w_silence != 0;
#line 3122
  i = fore->w_silencewait;
#line 3123
  if (*(args + 0)) {
#line 3123
    if ((int )*(*(args + 0) + 0) == 45) {
      _L___465: /* CIL Label */ 
      {
#line 3125
      __cil_tmp528 = ParseNum(act, & i);
      }
#line 3125
      if (__cil_tmp528) {
#line 3126
        goto switch_break;
      }
#line 3127
      n = i > 0;
    } else
#line 3123
    if ((int )*(*(args + 0) + 0) >= 48) {
#line 3123
      if ((int )*(*(args + 0) + 0) <= 57) {
#line 3123
        goto _L___465;
      } else {
#line 3123
        goto _L___464;
      }
    } else {
#line 3123
      goto _L___464;
    }
  } else {
    _L___464: /* CIL Label */ 
    {
#line 3129
    __cil_tmp529 = ParseSwitch(act, & n);
    }
#line 3129
    if (__cil_tmp529) {
#line 3130
      goto switch_break;
    }
  }
#line 3131
  if (n) {
#line 3134
    if (display) {
#line 3135
      *(fore->w_lio_notify + ((display->d_user)->u_id >> 3)) |= 128 >> ((display->d_user)->u_id & 7);
    } else {
#line 3137
      n = 0;
      {
#line 3137
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 3137
        if (! (n < maxusercount)) {
#line 3137
          goto while_break___35;
        }
#line 3138
        *(fore->w_lio_notify + (n >> 3)) |= 128 >> (n & 7);
      }
      while_break___35: /* CIL Label */ ;
      }
#line 3137
      n ++;
    }
    {
#line 3140
    fore->w_silencewait = i;
#line 3141
    fore->w_silence = 1;
#line 3142
    SetTimeout(& fore->w_silenceev, fore->w_silencewait * 1000);
#line 3143
    evenq(& fore->w_silenceev);
    }
#line 3145
    if (! msgok) {
#line 3146
      goto switch_break;
    }
#line 3147
    if (! act->quiet) {
#line 3147
      tmp___467 = Msg;
    } else {
#line 3147
      if (queryflag >= 0) {
#line 3147
        tmp___466 = QueryMsg;
      } else {
#line 3147
        tmp___466 = Dummy;
      }
#line 3147
      tmp___467 = tmp___466;
    }
    {
#line 3147
    tmp___467(0, (char const   *)((char *)"The window is now being monitored for %d sec. silence."),
              fore->w_silencewait);
    }
  } else {
#line 3152
    if (display) {
#line 3153
      *(fore->w_lio_notify + ((display->d_user)->u_id >> 3)) &= ~ (128 >> ((display->d_user)->u_id & 7));
    } else {
#line 3156
      n = 0;
      {
#line 3156
      while (1) {
        while_continue___36: /* CIL Label */ ;
#line 3156
        if (! (n < maxusercount)) {
#line 3156
          goto while_break___36;
        }
#line 3157
        *(fore->w_lio_notify + (n >> 3)) &= ~ (128 >> (n & 7));
      }
      while_break___36: /* CIL Label */ ;
      }
#line 3156
      n ++;
    }
#line 3158
    i = maxusercount - 1;
    {
#line 3158
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 3158
      if (! (i >= 0)) {
#line 3158
        goto while_break___37;
      }
#line 3159
      if (*(fore->w_lio_notify + (i >> 3))) {
#line 3160
        goto while_break___37;
      }
    }
    while_break___37: /* CIL Label */ ;
    }
#line 3158
    __cil_tmp534 = i;
#line 3158
    i --;
#line 3161
    if (i < 0) {
      {
#line 3164
      fore->w_silence = 0;
#line 3165
      evdeq(& fore->w_silenceev);
      }
    }
#line 3167
    if (! msgok) {
#line 3168
      goto switch_break;
    }
#line 3169
    if (! act->quiet) {
#line 3169
      tmp___469 = Msg;
    } else {
#line 3169
      if (queryflag >= 0) {
#line 3169
        tmp___468 = QueryMsg;
      } else {
#line 3169
        tmp___468 = Dummy;
      }
#line 3169
      tmp___469 = tmp___468;
    }
    {
#line 3169
    tmp___469(0, (char const   *)((char *)"The window is no longer being monitored for silence."));
    }
  }
#line 3171
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 3174
  __cil_tmp537 = ParseNum(act, & nwin_default.histheight);
  }
#line 3175
  goto switch_break;
  case_144: /* CIL Label */ 
#line 3177
  if (flayer->l_layfn == & MarkLf) {
#line 3179
    if (! act->quiet) {
#line 3179
      tmp___471 = Msg;
    } else {
#line 3179
      if (queryflag >= 0) {
#line 3179
        tmp___470 = QueryMsg;
      } else {
#line 3179
        tmp___470 = Dummy;
      }
#line 3179
      tmp___471 = tmp___470;
    }
    {
#line 3179
    tmp___471(0, (char const   *)((char *)"Cannot resize scrollback buffer in copy/scrollback mode."));
    }
#line 3180
    goto switch_break;
  }
  {
#line 3182
  __cil_tmp540 = ParseNum(act, & n);
#line 3183
  ChangeWindowSize(fore, fore->w_layer.l_width, fore->w_layer.l_height, n);
  }
#line 3184
  if (msgok) {
#line 3185
    if (! act->quiet) {
#line 3185
      tmp___473 = Msg;
    } else {
#line 3185
      if (queryflag >= 0) {
#line 3185
        tmp___472 = QueryMsg;
      } else {
#line 3185
        tmp___472 = Dummy;
      }
#line 3185
      tmp___473 = tmp___472;
    }
    {
#line 3185
    tmp___473(0, (char const   *)((char *)"scrollback set to %d"), fore->w_histheight);
    }
  }
#line 3186
  goto switch_break;
  case_146: /* CIL Label */ 
#line 3189
  if (*args == (char *)0) {
#line 3190
    if (! act->quiet) {
#line 3190
      tmp___475 = Msg;
    } else {
#line 3190
      if (queryflag >= 0) {
#line 3190
        tmp___474 = QueryMsg;
      } else {
#line 3190
        tmp___474 = Dummy;
      }
#line 3190
      tmp___475 = tmp___474;
    }
    {
#line 3190
    tmp___475(0, (char const   *)((char *)"This session is named \'%s\'\n"), SockName);
    }
  } else {
    {
#line 3195
    s = (char *)0;
#line 3196
    __cil_tmp546 = ParseSaveStr(act, & s);
    }
#line 3196
    if (__cil_tmp546) {
#line 3197
      goto switch_break;
    }
    {
#line 3198
    __cil_tmp548 = index((char const   *)s, '/');
    }
    {
#line 3198
    __cil_tmp547 = strlen((char const   *)s);
    }
#line 3198
    if (! *s) {
      _L___478: /* CIL Label */ 
#line 3200
      if (! act->quiet) {
#line 3200
        tmp___477 = Msg;
      } else {
#line 3200
        if (queryflag >= 0) {
#line 3200
          tmp___476 = QueryMsg;
        } else {
#line 3200
          tmp___476 = Dummy;
        }
#line 3200
        tmp___477 = tmp___476;
      }
      {
#line 3200
      tmp___477(0, (char const   *)((char *)"%s: bad session name \'%s\'\n"), rc_name,
                s);
#line 3201
      free((void *)s);
      }
#line 3202
      goto switch_break;
    } else
#line 3198
    if (__cil_tmp547 + (unsigned long )(SockName - (char *)SockPath) > 4083UL) {
#line 3198
      goto _L___478;
    } else
#line 3198
    if (__cil_tmp548) {
#line 3198
      goto _L___478;
    }
    {
#line 3204
    strncpy((char *)buf___5, (char const   *)((char *)SockPath), (unsigned long )(SockName - (char *)SockPath));
#line 3205
    __cil_tmp551 = getpid();
#line 3205
    sprintf((char *)buf___5 + (SockName - (char *)SockPath), (char const   *)((char *)"%d.%s"),
            __cil_tmp551, s);
#line 3206
    free((void *)s);
#line 3207
    __cil_tmp553 = __errno_location();
    }
    {
#line 3207
    __cil_tmp552 = access((char const   *)((char *)buf___5), 0);
    }
#line 3207
    if (__cil_tmp552 == 0) {
      _L___482: /* CIL Label */ 
#line 3209
      if (! act->quiet) {
#line 3209
        tmp___481 = Msg;
      } else {
#line 3209
        if (queryflag >= 0) {
#line 3209
          tmp___480 = QueryMsg;
        } else {
#line 3209
          tmp___480 = Dummy;
        }
#line 3209
        tmp___481 = tmp___480;
      }
      {
#line 3209
      tmp___481(0, (char const   *)((char *)"%s: inappropriate path: \'%s\'."), rc_name,
                (char *)buf___5);
      }
#line 3210
      goto switch_break;
    } else
#line 3207
    if (*__cil_tmp553 != 2) {
#line 3207
      goto _L___482;
    }
    {
#line 3212
    __cil_tmp556 = rename((char const   *)((char *)SockPath), (char const   *)((char *)buf___5));
    }
#line 3212
    if (__cil_tmp556) {
#line 3214
      if (! act->quiet) {
#line 3214
        tmp___484 = Msg;
      } else {
#line 3214
        if (queryflag >= 0) {
#line 3214
          tmp___483 = QueryMsg;
        } else {
#line 3214
          tmp___483 = Dummy;
        }
#line 3214
        tmp___484 = tmp___483;
      }
      {
#line 3214
      __cil_tmp559 = __errno_location();
#line 3214
      tmp___484(*__cil_tmp559, (char const   *)((char *)"%s: failed to rename(%s, %s)"),
                rc_name, (char *)SockPath, (char *)buf___5);
      }
#line 3215
      goto switch_break;
    }
    {
#line 3217
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 3217
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 3218
    strcpy((char *)SockPath, (char const   *)((char *)buf___5));
#line 3219
    MakeNewEnv();
#line 3220
    WindowChanged((struct win *)0, 'S');
    }
  }
#line 3222
  goto switch_break;
  case_147: /* CIL Label */ 
#line 3224
  if (! *(args + 0)) {
    _L___485: /* CIL Label */ 
    {
#line 3226
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 3226
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 3227
    InputSetenv(*(args + 0));
    }
  } else
#line 3224
  if (! *(args + 1)) {
#line 3224
    goto _L___485;
  } else {
    {
#line 3231
    xsetenv(*(args + 0), *(args + 1));
#line 3232
    MakeNewEnv();
    }
  }
#line 3234
  goto switch_break;
  case_171: /* CIL Label */ 
  {
#line 3236
  unsetenv((char const   *)*args);
  }
  {
#line 3237
  MakeNewEnv();
  }
#line 3238
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 3241
  __cil_tmp560 = ParseNum(act, & nwin_default.slow);
  }
#line 3242
  goto switch_break;
  case_154: /* CIL Label */ 
#line 3244
  if (*args == (char *)0) {
#line 3245
    if (! act->quiet) {
#line 3245
      tmp___487 = Msg;
    } else {
#line 3245
      if (queryflag >= 0) {
#line 3245
        tmp___486 = QueryMsg;
      } else {
#line 3245
        tmp___486 = Dummy;
      }
#line 3245
      tmp___487 = tmp___486;
    }
#line 3245
    if (fore->w_slowpaste) {
#line 3245
      tmp___488 = (char *)"Slowpaste in window %d is %d milliseconds.";
    } else {
#line 3245
      tmp___488 = (char *)"Slowpaste in window %d is unset.";
    }
    {
#line 3245
    tmp___487(0, (char const   *)tmp___488, fore->w_number, fore->w_slowpaste);
    }
  } else {
    {
#line 3249
    __cil_tmp564 = ParseNum(act, & fore->w_slowpaste);
    }
#line 3249
    if (__cil_tmp564 == 0) {
#line 3249
      if (msgok) {
#line 3250
        if (! act->quiet) {
#line 3250
          tmp___490 = Msg;
        } else {
#line 3250
          if (queryflag >= 0) {
#line 3250
            tmp___489 = QueryMsg;
          } else {
#line 3250
            tmp___489 = Dummy;
          }
#line 3250
          tmp___490 = tmp___489;
        }
#line 3250
        if (fore->w_slowpaste) {
#line 3250
          tmp___491 = (char *)"Slowpaste in window %d set to %d milliseconds.";
        } else {
#line 3250
          tmp___491 = (char *)"Slowpaste in window %d now unset.";
        }
        {
#line 3250
        tmp___490(0, (char const   *)tmp___491, fore->w_number, fore->w_slowpaste);
        }
      }
    }
  }
#line 3254
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 3256
  __cil_tmp568 = CompileKeys(*args, *argl, (unsigned char *)mark_key_tab);
  }
#line 3256
  if (__cil_tmp568) {
#line 3258
    if (! act->quiet) {
#line 3258
      tmp___493 = Msg;
    } else {
#line 3258
      if (queryflag >= 0) {
#line 3258
        tmp___492 = QueryMsg;
      } else {
#line 3258
        tmp___492 = Dummy;
      }
#line 3258
      tmp___493 = tmp___492;
    }
    {
#line 3258
    tmp___493(0, (char const   *)((char *)"%s: markkeys: syntax error."), rc_name);
    }
#line 3259
    goto switch_break;
  }
  {
#line 3261
  while (1) {
    while_continue___40: /* CIL Label */ ;
#line 3261
    goto while_break___40;
  }
  while_break___40: /* CIL Label */ ;
  }
#line 3262
  goto switch_break;
  case_126: /* CIL Label */ 
  {
#line 3265
  __cil_tmp571 = ParseSwitch(act, & pastefont);
  }
#line 3265
  if (__cil_tmp571 == 0) {
#line 3265
    if (msgok) {
#line 3266
      if (! act->quiet) {
#line 3266
        tmp___495 = Msg;
      } else {
#line 3266
        if (queryflag >= 0) {
#line 3266
          tmp___494 = QueryMsg;
        } else {
#line 3266
          tmp___494 = Dummy;
        }
#line 3266
        tmp___495 = tmp___494;
      }
#line 3266
      if (pastefont) {
#line 3266
        tmp___496 = (char *)"";
      } else {
#line 3266
        tmp___496 = (char *)"not ";
      }
      {
#line 3266
      tmp___495(0, (char const   *)((char *)"Will %spaste font settings"), tmp___496);
      }
    }
  }
#line 3267
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 3270
  __cil_tmp575 = ParseSwitch(act, & join_with_cr);
  }
#line 3271
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 3273
  __cil_tmp576 = ParseSwitch(act, & compacthist);
  }
#line 3273
  if (__cil_tmp576 == 0) {
#line 3273
    if (msgok) {
#line 3274
      if (! act->quiet) {
#line 3274
        tmp___498 = Msg;
      } else {
#line 3274
        if (queryflag >= 0) {
#line 3274
          tmp___497 = QueryMsg;
        } else {
#line 3274
          tmp___497 = Dummy;
        }
#line 3274
        tmp___498 = tmp___497;
      }
#line 3274
      if (compacthist) {
#line 3274
        tmp___499 = (char *)"";
      } else {
#line 3274
        tmp___499 = (char *)"not ";
      }
      {
#line 3274
      tmp___498(0, (char const   *)((char *)"%scompacting history lines"), tmp___499);
      }
    }
  }
#line 3275
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 3279
  __cil_tmp580 = ParseOnOff(act, & nethackflag);
  }
#line 3280
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 3287
  __cil_tmp581 = ParseOnOff(act, & hardcopy_append);
  }
#line 3288
  goto switch_break;
  case_174: /* CIL Label */ 
#line 3290
  if (*args == (char *)0) {
    {
#line 3293
    AddXChars((char *)buf___6, (int )sizeof(buf___6), VisualBellString);
    }
#line 3294
    if (! act->quiet) {
#line 3294
      tmp___501 = Msg;
    } else {
#line 3294
      if (queryflag >= 0) {
#line 3294
        tmp___500 = QueryMsg;
      } else {
#line 3294
        tmp___500 = Dummy;
      }
#line 3294
      tmp___501 = tmp___500;
    }
    {
#line 3294
    tmp___501(0, (char const   *)((char *)"vbell_msg is \'%s\'"), (char *)buf___6);
    }
#line 3295
    goto switch_break;
  }
  {
#line 3297
  __cil_tmp585 = ParseSaveStr(act, & VisualBellString);
  }
  {
#line 3298
  while (1) {
    while_continue___41: /* CIL Label */ ;
#line 3298
    goto while_break___41;
  }
  while_break___41: /* CIL Label */ ;
  }
#line 3299
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 3301
  __cil_tmp586 = ParseBase(act, *args, & n, 8, (char *)"octal");
  }
#line 3301
  if (__cil_tmp586) {
#line 3302
    goto switch_break;
  }
#line 3303
  if (n < 0) {
    _L___504: /* CIL Label */ 
#line 3305
    if (! act->quiet) {
#line 3305
      tmp___503 = Msg;
    } else {
#line 3305
      if (queryflag >= 0) {
#line 3305
        tmp___502 = QueryMsg;
      } else {
#line 3305
        tmp___502 = Dummy;
      }
#line 3305
      tmp___503 = tmp___502;
    }
    {
#line 3305
    tmp___503(0, (char const   *)((char *)"%s: mode: Invalid tty mode %o"), rc_name,
              n);
    }
#line 3306
    goto switch_break;
  } else
#line 3303
  if (n > 511) {
#line 3303
    goto _L___504;
  }
#line 3308
  TtyMode = n;
#line 3309
  if (msgok) {
#line 3310
    if (! act->quiet) {
#line 3310
      tmp___506 = Msg;
    } else {
#line 3310
      if (queryflag >= 0) {
#line 3310
        tmp___505 = QueryMsg;
      } else {
#line 3310
        tmp___505 = Dummy;
      }
#line 3310
      tmp___506 = tmp___505;
    }
    {
#line 3310
    tmp___506(0, (char const   *)((char *)"Ttymode set to %03o"), TtyMode);
    }
  }
#line 3311
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 3313
  __cil_tmp591 = ParseOnOff(act, & auto_detach);
  }
#line 3314
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 3316
  __cil_tmp592 = ParseOnOff(act, & default_startup);
  }
#line 3317
  goto switch_break;
  case_124: /* CIL Label */ 
#line 3320
  if (*args) {
#line 3322
    if ((int )*(user->u_password)) {
#line 3322
      tmp___507 = 1;
    } else {
#line 3322
      tmp___507 = 0;
    }
#line 3322
    n = tmp___507;
#line 3323
    if (user->u_password != (char *)NullStr) {
      {
#line 3323
      free((void *)user->u_password);
      }
    }
    {
#line 3324
    user->u_password = SaveStr((char const   *)*args);
#line 3325
    __cil_tmp595 = strcmp((char const   *)user->u_password, (char const   *)((char *)"none"));
    }
#line 3325
    if (! __cil_tmp595) {
#line 3327
      if (n) {
#line 3328
        if (! act->quiet) {
#line 3328
          tmp___509 = Msg;
        } else {
#line 3328
          if (queryflag >= 0) {
#line 3328
            tmp___508 = QueryMsg;
          } else {
#line 3328
            tmp___508 = Dummy;
          }
#line 3328
          tmp___509 = tmp___508;
        }
        {
#line 3328
        tmp___509(0, (char const   *)((char *)"Password checking disabled"));
        }
      }
      {
#line 3329
      free((void *)user->u_password);
#line 3330
      user->u_password = (char *)NullStr;
      }
    }
  } else {
#line 3335
    if (! fore) {
#line 3337
      if (! act->quiet) {
#line 3337
        tmp___511 = Msg;
      } else {
#line 3337
        if (queryflag >= 0) {
#line 3337
          tmp___510 = QueryMsg;
        } else {
#line 3337
          tmp___510 = Dummy;
        }
#line 3337
        tmp___511 = tmp___510;
      }
      {
#line 3337
      tmp___511(0, (char const   *)((char *)"%s: password: window required"), rc_name);
      }
#line 3338
      goto switch_break;
    }
#line 3340
    if (display) {
#line 3340
      tmp___512 = (char *)display->d_user;
    } else {
#line 3340
      tmp___512 = (char *)users;
    }
    {
#line 3340
    Input((char *)"New screen password:", 100, 1, pass1, tmp___512, 0);
    }
  }
#line 3342
  goto switch_break;
  case_17: /* CIL Label */ 
#line 3346
  ktabp___1 = (struct action *)ktab;
#line 3347
  kflag = 0;
  {
#line 3349
  while (1) {
    while_continue___42: /* CIL Label */ ;
#line 3349
    if (! 1) {
#line 3349
      goto while_break___42;
    }
    {
#line 3351
    __cil_tmp603 = strcmp((char const   *)*args, (char const   *)((char *)"-c"));
    }
#line 3351
    if (argc > 2) {
#line 3351
      if (! __cil_tmp603) {
        {
#line 3353
        ktabp___1 = FindKtab(*(args + 1), 1);
        }
#line 3354
        if (ktabp___1 == (struct action *)0) {
#line 3355
          goto while_break___42;
        }
#line 3356
        args += 2;
#line 3357
        argl += 2;
#line 3358
        argc -= 2;
      } else {
#line 3351
        goto _L___513;
      }
    } else {
      _L___513: /* CIL Label */ 
      {
#line 3360
      __cil_tmp605 = strcmp((char const   *)*args, (char const   *)((char *)"-k"));
      }
#line 3360
      if (argc > 1) {
#line 3360
        if (! __cil_tmp605) {
#line 3362
          kflag = 1;
#line 3363
          args ++;
#line 3364
          argl ++;
#line 3365
          __cil_tmp608 = argc;
#line 3365
          argc --;
        } else {
#line 3368
          goto while_break___42;
        }
      } else {
#line 3368
        goto while_break___42;
      }
    }
  }
  while_break___42: /* CIL Label */ ;
  }
#line 3371
  if (kflag) {
#line 3373
    n = 0;
    {
#line 3373
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 3373
      if (! (n < 82)) {
#line 3373
        goto while_break___43;
      }
      {
#line 3374
      __cil_tmp609 = strcmp((char const   *)term[n + 106].tcname, (char const   *)*args);
      }
#line 3374
      if (__cil_tmp609 == 0) {
#line 3375
        goto while_break___43;
      }
    }
    while_break___43: /* CIL Label */ ;
    }
#line 3373
    n ++;
#line 3376
    if (n == 82) {
#line 3378
      if (! act->quiet) {
#line 3378
        tmp___515 = Msg;
      } else {
#line 3378
        if (queryflag >= 0) {
#line 3378
          tmp___514 = QueryMsg;
        } else {
#line 3378
          tmp___514 = Dummy;
        }
#line 3378
        tmp___515 = tmp___514;
      }
      {
#line 3378
      tmp___515(0, (char const   *)((char *)"%s: bind: unknown key \'%s\'"), rc_name,
                *args);
      }
#line 3379
      goto switch_break;
    }
#line 3381
    n += 256;
  } else
#line 3385
  if (*argl != 1) {
#line 3387
    if (! act->quiet) {
#line 3387
      tmp___517 = Msg;
    } else {
#line 3387
      if (queryflag >= 0) {
#line 3387
        tmp___516 = QueryMsg;
      } else {
#line 3387
        tmp___516 = Dummy;
      }
#line 3387
      tmp___517 = tmp___516;
    }
    {
#line 3387
    tmp___517(0, (char const   *)((char *)"%s: bind: character, ^x, or (octal) \\032 expected."),
              rc_name);
    }
#line 3388
    goto switch_break;
  } else {
#line 3391
    n = (int )((unsigned char )*(*(args + 0) + 0));
  }
#line 3393
  if (*(args + 1)) {
    {
#line 3395
    i = FindCommnr((char const   *)*(args + 1));
    }
#line 3395
    if (i == -1) {
#line 3397
      if (! act->quiet) {
#line 3397
        tmp___519 = Msg;
      } else {
#line 3397
        if (queryflag >= 0) {
#line 3397
          tmp___518 = QueryMsg;
        } else {
#line 3397
          tmp___518 = Dummy;
        }
#line 3397
        tmp___519 = tmp___518;
      }
      {
#line 3397
      tmp___519(0, (char const   *)((char *)"%s: bind: unknown command \'%s\'"), rc_name,
                *(args + 1));
      }
#line 3398
      goto switch_break;
    }
    {
#line 3400
    __cil_tmp618 = CheckArgNum(i, args + 2);
    }
#line 3400
    if (__cil_tmp618 < 0) {
#line 3401
      goto switch_break;
    }
    {
#line 3402
    ClearAction(& *(ktabp___1 + n));
#line 3403
    SaveAction(ktabp___1 + n, i, args + 2, argl + 2);
    }
  } else {
    {
#line 3406
    ClearAction(& *(ktabp___1 + n));
    }
  }
#line 3408
  goto switch_break;
  case_18: /* CIL Label */ 
#line 3413
  fl = 0;
#line 3413
  kf = 0;
#line 3413
  af = 0;
#line 3413
  df = 0;
#line 3413
  mf = 0;
#line 3414
  odisp = display;
#line 3415
  used = 0;
#line 3416
  kme = (struct kmap_ext *)((void *)0);
  {
#line 3418
  while (1) {
    while_continue___44: /* CIL Label */ ;
#line 3418
    if (! (*args && (int )*(*args) == 45)) {
#line 3418
      goto while_break___44;
    }
    {
#line 3420
    __cil_tmp629 = strcmp((char const   *)*args, (char const   *)((char *)"-t"));
    }
#line 3420
    if (__cil_tmp629 == 0) {
#line 3421
      fl = 16384;
    } else {
      {
#line 3422
      __cil_tmp630 = strcmp((char const   *)*args, (char const   *)((char *)"-k"));
      }
#line 3422
      if (__cil_tmp630 == 0) {
#line 3423
        kf = 1;
      } else {
        {
#line 3424
        __cil_tmp631 = strcmp((char const   *)*args, (char const   *)((char *)"-a"));
        }
#line 3424
        if (__cil_tmp631 == 0) {
#line 3425
          af = 1;
        } else {
          {
#line 3426
          __cil_tmp632 = strcmp((char const   *)*args, (char const   *)((char *)"-d"));
          }
#line 3426
          if (__cil_tmp632 == 0) {
#line 3427
            df = 1;
          } else {
            {
#line 3428
            __cil_tmp633 = strcmp((char const   *)*args, (char const   *)((char *)"-m"));
            }
#line 3428
            if (__cil_tmp633 == 0) {
#line 3429
              mf = 1;
            } else {
              {
#line 3430
              __cil_tmp634 = strcmp((char const   *)*args, (char const   *)((char *)"--"));
              }
#line 3430
              if (__cil_tmp634 == 0) {
#line 3432
                args ++;
#line 3433
                argl ++;
#line 3434
                goto while_break___44;
              } else {
#line 3438
                if (! act->quiet) {
#line 3438
                  tmp___521 = Msg;
                } else {
#line 3438
                  if (queryflag >= 0) {
#line 3438
                    tmp___520 = QueryMsg;
                  } else {
#line 3438
                    tmp___520 = Dummy;
                  }
#line 3438
                  tmp___521 = tmp___520;
                }
                {
#line 3438
                tmp___521(0, (char const   *)((char *)"%s: bindkey: invalid option %s"),
                          rc_name, *args);
                }
#line 3439
                return;
              }
            }
          }
        }
      }
    }
  }
  while_break___44: /* CIL Label */ ;
  }
#line 3418
  __cil_tmp640 = argl;
#line 3418
  argl ++;
#line 3418
  __cil_tmp639 = args;
#line 3418
  args ++;
#line 3442
  if (df) {
#line 3442
    if (mf) {
#line 3444
      if (! act->quiet) {
#line 3444
        tmp___523 = Msg;
      } else {
#line 3444
        if (queryflag >= 0) {
#line 3444
          tmp___522 = QueryMsg;
        } else {
#line 3444
          tmp___522 = Dummy;
        }
#line 3444
        tmp___523 = tmp___522;
      }
      {
#line 3444
      tmp___523(0, (char const   *)((char *)"%s: bindkey: -d does not work with -m"),
                rc_name);
      }
#line 3445
      goto switch_break;
    }
  }
#line 3447
  if (*args == (char *)0) {
#line 3449
    if (mf) {
      {
#line 3450
      display_bindkey((char *)"Edit mode", (struct action *)mmtab);
      }
    } else
#line 3451
    if (df) {
      {
#line 3452
      display_bindkey((char *)"Default", (struct action *)dmtab);
      }
    } else {
      {
#line 3454
      display_bindkey((char *)"User", (struct action *)umtab);
      }
    }
#line 3455
    goto switch_break;
  }
#line 3457
  if (kf == 0) {
#line 3459
    if (af) {
#line 3461
      if (! act->quiet) {
#line 3461
        tmp___525 = Msg;
      } else {
#line 3461
        if (queryflag >= 0) {
#line 3461
          tmp___524 = QueryMsg;
        } else {
#line 3461
          tmp___524 = Dummy;
        }
#line 3461
        tmp___525 = tmp___524;
      }
      {
#line 3461
      tmp___525(0, (char const   *)((char *)"%s: bindkey: -a only works with -k"),
                rc_name);
      }
#line 3462
      goto switch_break;
    }
#line 3464
    if (*argl == 0) {
#line 3466
      if (! act->quiet) {
#line 3466
        tmp___527 = Msg;
      } else {
#line 3466
        if (queryflag >= 0) {
#line 3466
          tmp___526 = QueryMsg;
        } else {
#line 3466
          tmp___526 = Dummy;
        }
#line 3466
        tmp___527 = tmp___526;
      }
      {
#line 3466
      tmp___527(0, (char const   *)((char *)"%s: bindkey: empty string makes no sense"),
                rc_name);
      }
#line 3467
      goto switch_break;
    }
#line 3469
    kme = kmap_exts;
#line 3469
    i = 0;
    {
#line 3469
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 3469
      if (! (i < kmap_extn)) {
#line 3469
        goto while_break___45;
      }
#line 3470
      if (kme->str == (char *)0) {
#line 3472
        if (*(args + 1)) {
#line 3473
          goto while_break___45;
        }
      } else {
        {
#line 3476
        __cil_tmp647 = bcmp((void const   *)kme->str, (void const   *)*args, (unsigned long )*argl);
        }
#line 3476
        if (*argl == (kme->fl & -16385)) {
#line 3476
          if (__cil_tmp647 == 0) {
#line 3477
            goto while_break___45;
          }
        }
      }
    }
    while_break___45: /* CIL Label */ ;
    }
#line 3469
    __cil_tmp649 = kme;
#line 3469
    kme ++;
#line 3469
    __cil_tmp648 = i;
#line 3469
    i ++;
#line 3478
    if (i == kmap_extn) {
#line 3480
      if (! *(args + 1)) {
#line 3482
        if (! act->quiet) {
#line 3482
          tmp___529 = Msg;
        } else {
#line 3482
          if (queryflag >= 0) {
#line 3482
            tmp___528 = QueryMsg;
          } else {
#line 3482
            tmp___528 = Dummy;
          }
#line 3482
          tmp___529 = tmp___528;
        }
        {
#line 3482
        tmp___529(0, (char const   *)((char *)"%s: bindkey: keybinding not found"),
                  rc_name);
        }
#line 3483
        goto switch_break;
      }
      {
#line 3485
      kmap_extn += 8;
#line 3486
      __cil_tmp652 = xrealloc((char *)kmap_exts, (int )((unsigned long )kmap_extn * sizeof(*kmap_exts)));
#line 3486
      kmap_exts = (struct kmap_ext *)__cil_tmp652;
#line 3487
      kme = kmap_exts + i;
#line 3488
      bzero((void *)((char *)kme), 8UL * sizeof(*kmap_exts));
      }
      {
#line 3489
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 3489
        if (! (i < kmap_extn)) {
#line 3489
          goto while_break___46;
        }
#line 3491
        kme->str = (char *)0;
#line 3492
        kme->um.nr = - 1;
#line 3492
        kme->mm.nr = kme->um.nr;
#line 3492
        kme->dm.nr = kme->mm.nr;
#line 3493
        kme->um.args = (char **)noargs;
#line 3493
        kme->mm.args = kme->um.args;
#line 3493
        kme->dm.args = kme->mm.args;
#line 3494
        kme->um.argl = (int *)0;
#line 3494
        kme->mm.argl = kme->um.argl;
#line 3494
        kme->dm.argl = kme->mm.argl;
      }
      while_break___46: /* CIL Label */ ;
      }
#line 3489
      __cil_tmp654 = kme;
#line 3489
      kme ++;
#line 3489
      __cil_tmp653 = i;
#line 3489
      i ++;
#line 3496
      i -= 8;
#line 3497
      kme -= 8;
    }
#line 3499
    if (df == 0) {
#line 3499
      if (kme->dm.nr != -1) {
#line 3500
        used = 1;
      }
    }
#line 3501
    if (mf == 0) {
#line 3501
      if (kme->mm.nr != -1) {
#line 3502
        used = 1;
      }
    }
#line 3503
    if (df) {
      _L___530: /* CIL Label */ 
#line 3503
      if (kme->um.nr != -1) {
#line 3504
        used = 1;
      }
    } else
#line 3503
    if (mf) {
#line 3503
      goto _L___530;
    }
#line 3505
    i += 104;
#line 3506
    if (df) {
#line 3506
      tmp___532 = & kme->dm;
    } else {
#line 3506
      if (mf) {
#line 3506
        tmp___531 = & kme->mm;
      } else {
#line 3506
        tmp___531 = & kme->um;
      }
#line 3506
      tmp___532 = tmp___531;
    }
#line 3506
    newact = tmp___532;
  } else {
#line 3510
    i = 106;
    {
#line 3510
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 3510
      if (! (i < 188)) {
#line 3510
        goto while_break___47;
      }
      {
#line 3511
      __cil_tmp657 = strcmp((char const   *)term[i].tcname, (char const   *)*args);
      }
#line 3511
      if (__cil_tmp657 == 0) {
#line 3512
        goto while_break___47;
      }
    }
    while_break___47: /* CIL Label */ ;
    }
#line 3510
    i ++;
#line 3513
    if (i == 188) {
#line 3515
      if (! act->quiet) {
#line 3515
        tmp___534 = Msg;
      } else {
#line 3515
        if (queryflag >= 0) {
#line 3515
          tmp___533 = QueryMsg;
        } else {
#line 3515
          tmp___533 = Dummy;
        }
#line 3515
        tmp___534 = tmp___533;
      }
      {
#line 3515
      tmp___534(0, (char const   *)((char *)"%s: bindkey: unknown key \'%s\'"), rc_name,
                *args);
      }
#line 3516
      goto switch_break;
    }
#line 3518
    if (af) {
#line 3518
      if (i >= 166) {
#line 3518
        if (i < 188) {
#line 3519
          i -= 84;
        } else {
#line 3521
          i -= 106;
        }
      } else {
#line 3521
        i -= 106;
      }
    } else {
#line 3521
      i -= 106;
    }
#line 3522
    if (df) {
#line 3522
      tmp___536 = & dmtab[i];
    } else {
#line 3522
      if (mf) {
#line 3522
        tmp___535 = & mmtab[i];
      } else {
#line 3522
        tmp___535 = & umtab[i];
      }
#line 3522
      tmp___536 = tmp___535;
    }
#line 3522
    newact = tmp___536;
  }
#line 3524
  if (*(args + 1)) {
    {
#line 3526
    newnr = FindCommnr((char const   *)*(args + 1));
    }
#line 3526
    if (newnr == -1) {
#line 3528
      if (! act->quiet) {
#line 3528
        tmp___538 = Msg;
      } else {
#line 3528
        if (queryflag >= 0) {
#line 3528
          tmp___537 = QueryMsg;
        } else {
#line 3528
          tmp___537 = Dummy;
        }
#line 3528
        tmp___538 = tmp___537;
      }
      {
#line 3528
      tmp___538(0, (char const   *)((char *)"%s: bindkey: unknown command \'%s\'"),
                rc_name, *(args + 1));
      }
#line 3529
      goto switch_break;
    }
    {
#line 3531
    __cil_tmp666 = CheckArgNum(newnr, args + 2);
    }
#line 3531
    if (__cil_tmp666 < 0) {
#line 3532
      goto switch_break;
    }
    {
#line 3533
    ClearAction(newact);
#line 3534
    SaveAction(newact, newnr, args + 2, argl + 2);
    }
#line 3535
    if (kf == 0) {
#line 3535
      if (*(args + 1)) {
#line 3537
        if (kme->str) {
          {
#line 3538
          free((void *)kme->str);
          }
        }
        {
#line 3539
        kme->str = SaveStrn((char const   *)*args, *argl);
#line 3540
        kme->fl = fl | *argl;
        }
      }
    }
  } else {
    {
#line 3544
    ClearAction(newact);
    }
  }
#line 3545
  display = displays;
  {
#line 3545
  while (1) {
    while_continue___48: /* CIL Label */ ;
#line 3545
    if (! display) {
#line 3545
      goto while_break___48;
    }
#line 3546
    if (*(args + 1)) {
#line 3546
      tmp___539 = 1;
    } else {
#line 3546
      tmp___539 = 0;
    }
    {
#line 3546
    remap(i, tmp___539);
    }
  }
  while_break___48: /* CIL Label */ ;
  }
#line 3545
  display = display->d_next;
#line 3547
  if (kf == 0) {
#line 3547
    if (! *(args + 1)) {
#line 3549
      if (! used) {
#line 3549
        if (kme->str) {
          {
#line 3551
          free((void *)kme->str);
#line 3552
          kme->str = (char *)0;
#line 3553
          kme->fl = 0;
          }
        }
      }
    }
  }
#line 3556
  display = odisp;
#line 3558
  goto switch_break;
  case_107: /* CIL Label */ 
#line 3560
  if (*args) {
    {
#line 3562
    __cil_tmp669 = ParseNum(act, & n);
    }
#line 3562
    if (__cil_tmp669) {
#line 3563
      goto switch_break;
    }
#line 3564
    if (n < 0) {
#line 3566
      if (! act->quiet) {
#line 3566
        tmp___541 = Msg;
      } else {
#line 3566
        if (queryflag >= 0) {
#line 3566
          tmp___540 = QueryMsg;
        } else {
#line 3566
          tmp___540 = Dummy;
        }
#line 3566
        tmp___541 = tmp___540;
      }
      {
#line 3566
      tmp___541(0, (char const   *)((char *)"%s: maptimeout: illegal time %d"), rc_name,
                n);
      }
#line 3567
      goto switch_break;
    }
#line 3569
    maptimeout = n;
  }
#line 3571
  if (*args == (char *)0) {
    _L___544: /* CIL Label */ 
#line 3572
    if (! act->quiet) {
#line 3572
      tmp___543 = Msg;
    } else {
#line 3572
      if (queryflag >= 0) {
#line 3572
        tmp___542 = QueryMsg;
      } else {
#line 3572
        tmp___542 = Dummy;
      }
#line 3572
      tmp___543 = tmp___542;
    }
    {
#line 3572
    tmp___543(0, (char const   *)((char *)"maptimeout is %dms"), maptimeout);
    }
  } else
#line 3571
  if (msgok) {
#line 3571
    goto _L___544;
  }
#line 3573
  goto switch_break;
  case_106: /* CIL Label */ 
#line 3575
  display->d_dontmap = 1;
#line 3576
  goto switch_break;
  case_105: /* CIL Label */ 
#line 3578
  display->d_mapdefault = 1;
#line 3579
  goto switch_break;
  case_28: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 3586
  UsersAcl((struct acluser *)((void *)0), argc, args);
  }
#line 3587
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 3589
  __cil_tmp674 = UserDel(*(args + 0), (struct acluser **)((void *)0));
  }
#line 3589
  if (__cil_tmp674) {
#line 3590
    goto switch_break;
  }
#line 3591
  if (msgok) {
#line 3592
    if (! act->quiet) {
#line 3592
      tmp___546 = Msg;
    } else {
#line 3592
      if (queryflag >= 0) {
#line 3592
        tmp___545 = QueryMsg;
      } else {
#line 3592
        tmp___545 = Dummy;
      }
#line 3592
      tmp___546 = tmp___545;
    }
    {
#line 3592
    tmp___546(0, (char const   *)((char *)"%s removed from acl database"), *(args + 0));
    }
  }
#line 3593
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3600
  if (*(args + 1)) {
    {
#line 3602
    __cil_tmp677 = strcmp((char const   *)*(args + 1), (char const   *)((char *)"none"));
    }
#line 3602
    if (__cil_tmp677) {
      {
#line 3604
      __cil_tmp678 = AclLinkUser(*(args + 0), *(args + 1));
      }
#line 3604
      if (__cil_tmp678) {
#line 3605
        goto switch_break;
      }
#line 3606
      if (msgok) {
#line 3607
        if (! act->quiet) {
#line 3607
          tmp___548 = Msg;
        } else {
#line 3607
          if (queryflag >= 0) {
#line 3607
            tmp___547 = QueryMsg;
          } else {
#line 3607
            tmp___547 = Dummy;
          }
#line 3607
          tmp___548 = tmp___547;
        }
        {
#line 3607
        tmp___548(0, (char const   *)((char *)"User %s joined acl-group %s"), *(args + 0),
                  *(args + 1));
        }
      }
    } else {
      {
#line 3614
      u___0 = (struct acluser *)FindUserPtr(*(args + 0));
      }
#line 3614
      if (! u___0) {
#line 3615
        goto switch_break;
      }
      {
#line 3616
      while (1) {
        while_continue___49: /* CIL Label */ ;
#line 3616
        if (! g) {
#line 3616
          goto while_break___49;
        }
        {
#line 3618
        u___0->u_group = g->next;
#line 3619
        free((void *)((char *)g));
        }
      }
      while_break___49: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 3625
    p___549 = (char *)buf___7;
#line 3626
    ngroups = 0;
#line 3630
    u___1 = (struct acluser *)FindUserPtr(*(args + 0));
    }
#line 3630
    if (! u___1) {
#line 3632
      if (msgok) {
#line 3633
        if (! act->quiet) {
#line 3633
          tmp___551 = Msg;
        } else {
#line 3633
          if (queryflag >= 0) {
#line 3633
            tmp___550 = QueryMsg;
          } else {
#line 3633
            tmp___550 = Dummy;
          }
#line 3633
          tmp___551 = tmp___550;
        }
        {
#line 3633
        tmp___551(0, (char const   *)((char *)"User %s does not exist."), *(args + 0));
        }
      }
#line 3634
      goto switch_break;
    }
#line 3636
    g___0 = u___1->u_group;
    {
#line 3637
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 3637
      if (! g___0) {
#line 3637
        goto while_break___50;
      }
      {
#line 3639
      ngroups ++;
#line 3640
      sprintf(p___549, (char const   *)((char *)"%s "), (char *)(g___0->u)->u_name);
#line 3641
      __cil_tmp693 = strlen((char const   *)p___549);
      }
#line 3641
      p___549 += __cil_tmp693;
#line 3642
      if (p___549 > (char *)buf___7 + 200) {
#line 3643
        goto while_break___50;
      }
#line 3644
      g___0 = g___0->next;
    }
    while_break___50: /* CIL Label */ ;
    }
#line 3646
    if (ngroups) {
#line 3647
      p___549 --;
#line 3647
      *p___549 = (char )'\000';
    }
#line 3648
    if (! act->quiet) {
#line 3648
      tmp___553 = Msg;
    } else {
#line 3648
      if (queryflag >= 0) {
#line 3648
        tmp___552 = QueryMsg;
      } else {
#line 3648
        tmp___552 = Dummy;
      }
#line 3648
      tmp___553 = tmp___552;
    }
#line 3648
    if (ngroups == 1) {
#line 3648
      tmp___554 = (char *)"";
    } else {
#line 3648
      tmp___554 = (char *)"s";
    }
#line 3648
    if (ngroups == 0) {
#line 3648
      tmp___555 = (char *)"none";
    } else {
#line 3648
      tmp___555 = (char *)buf___7;
    }
    {
#line 3648
    tmp___553(0, (char const   *)((char *)"%s\'s group%s: %s."), *(args + 0), tmp___554,
              tmp___555);
    }
  }
#line 3651
  goto switch_break;
  case_169: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 3654
  while (1) {
    while_continue___51: /* CIL Label */ ;
#line 3654
    if (! s) {
#line 3654
      goto while_break___51;
    }
#line 3656
    err = (char *)0;
#line 3658
    if (display) {
#line 3658
      tmp___556 = display->d_user;
    } else {
#line 3658
      tmp___556 = users;
    }
    {
#line 3658
    __cil_tmp701 = AclUmask(tmp___556, s, & err);
    }
#line 3658
    if (__cil_tmp701) {
#line 3659
      if (! act->quiet) {
#line 3659
        tmp___558 = Msg;
      } else {
#line 3659
        if (queryflag >= 0) {
#line 3659
          tmp___557 = QueryMsg;
        } else {
#line 3659
          tmp___557 = Dummy;
        }
#line 3659
        tmp___558 = tmp___557;
      }
      {
#line 3659
      tmp___558(0, (char const   *)((char *)"umask: %s\n"), err);
      }
    }
  }
  while_break___51: /* CIL Label */ ;
  }
#line 3661
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 3663
  __cil_tmp704 = ParseOnOff(act, & n);
  }
#line 3663
  if (__cil_tmp704) {
#line 3664
    goto switch_break;
  }
#line 3665
  if (n) {
#line 3665
    tmp___559 = (char *)"";
  } else {
#line 3665
    tmp___559 = (char *)0;
  }
  {
#line 3665
  multi = tmp___559;
#line 3666
  chsock();
  }
#line 3667
  if (msgok) {
#line 3668
    if (! act->quiet) {
#line 3668
      tmp___561 = Msg;
    } else {
#line 3668
      if (queryflag >= 0) {
#line 3668
        tmp___560 = QueryMsg;
      } else {
#line 3668
        tmp___560 = Dummy;
      }
#line 3668
      tmp___561 = tmp___560;
    }
#line 3668
    if (multi) {
#line 3668
      tmp___562 = (char *)"enabled";
    } else {
#line 3668
      tmp___562 = (char *)"disabled";
    }
    {
#line 3668
    tmp___561(0, (char const   *)((char *)"Multiuser mode %s"), tmp___562);
    }
  }
#line 3669
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 3673
  winexec(args);
  }
#line 3674
  goto switch_break;
  case_118: /* CIL Label */ 
#line 3678
  i = display->d_nonblock >= 0;
#line 3679
  if (*args) {
#line 3679
    if ((int )*(*(args + 0) + 0) >= 48) {
#line 3679
      if ((int )*(*(args + 0) + 0) <= 57) {
        _L___565: /* CIL Label */ 
        {
#line 3681
        __cil_tmp709 = ParseNum1000(act, & i);
        }
#line 3681
        if (__cil_tmp709) {
#line 3682
          goto switch_break;
        }
      } else {
#line 3679
        goto _L___566;
      }
    } else
    _L___566: /* CIL Label */ 
#line 3679
    if ((int )*(*(args + 0) + 0) == 46) {
#line 3679
      goto _L___565;
    } else {
#line 3679
      goto _L___564;
    }
  } else {
    _L___564: /* CIL Label */ 
    {
#line 3684
    __cil_tmp710 = ParseSwitch(act, & i);
    }
#line 3684
    if (! __cil_tmp710) {
#line 3685
      if (i == 0) {
#line 3685
        tmp___563 = - 1;
      } else {
#line 3685
        tmp___563 = 1000;
      }
#line 3685
      i = tmp___563;
    } else {
#line 3687
      goto switch_break;
    }
  }
#line 3688
  if (msgok) {
#line 3688
    if (i == -1) {
#line 3689
      if (! act->quiet) {
#line 3689
        tmp___568 = Msg;
      } else {
#line 3689
        if (queryflag >= 0) {
#line 3689
          tmp___567 = QueryMsg;
        } else {
#line 3689
          tmp___567 = Dummy;
        }
#line 3689
        tmp___568 = tmp___567;
      }
      {
#line 3689
      tmp___568(0, (char const   *)((char *)"display set to blocking mode"));
      }
    } else {
#line 3688
      goto _L___574;
    }
  } else
  _L___574: /* CIL Label */ 
#line 3690
  if (msgok) {
#line 3690
    if (i == 0) {
#line 3691
      if (! act->quiet) {
#line 3691
        tmp___570 = Msg;
      } else {
#line 3691
        if (queryflag >= 0) {
#line 3691
          tmp___569 = QueryMsg;
        } else {
#line 3691
          tmp___569 = Dummy;
        }
#line 3691
        tmp___570 = tmp___569;
      }
      {
#line 3691
      tmp___570(0, (char const   *)((char *)"display set to nonblocking mode, no timeout"));
      }
    } else {
#line 3690
      goto _L___573;
    }
  } else
  _L___573: /* CIL Label */ 
#line 3692
  if (msgok) {
#line 3693
    if (! act->quiet) {
#line 3693
      tmp___572 = Msg;
    } else {
#line 3693
      if (queryflag >= 0) {
#line 3693
        tmp___571 = QueryMsg;
      } else {
#line 3693
        tmp___571 = Dummy;
      }
#line 3693
      tmp___572 = tmp___571;
    }
    {
#line 3693
    tmp___572(0, (char const   *)((char *)"display set to nonblocking mode, %.10gs timeout"),
              (double )i / 1000.);
    }
  }
#line 3694
  display->d_nonblock = i;
#line 3695
  if (display->d_nonblock <= 0) {
    {
#line 3696
    evdeq(& display->d_blockedev);
    }
  }
#line 3697
  goto switch_break;
  case_58: /* CIL Label */ 
#line 3699
  if (*args) {
#line 3699
    if ((int )*(*(args + 0) + 0) >= 48) {
#line 3699
      if ((int )*(*(args + 0) + 0) <= 57) {
        _L___577: /* CIL Label */ 
        {
#line 3701
        __cil_tmp718 = ParseNum1000(act, & defnonblock);
        }
#line 3701
        if (__cil_tmp718) {
#line 3702
          goto switch_break;
        }
      } else {
#line 3699
        goto _L___578;
      }
    } else
    _L___578: /* CIL Label */ 
#line 3699
    if ((int )*(*(args + 0) + 0) == 46) {
#line 3699
      goto _L___577;
    } else {
#line 3699
      goto _L___576;
    }
  } else {
    _L___576: /* CIL Label */ 
    {
#line 3704
    __cil_tmp719 = ParseOnOff(act, & defnonblock);
    }
#line 3704
    if (! __cil_tmp719) {
#line 3705
      if (defnonblock == 0) {
#line 3705
        tmp___575 = - 1;
      } else {
#line 3705
        tmp___575 = 1000;
      }
#line 3705
      defnonblock = tmp___575;
    } else {
#line 3707
      goto switch_break;
    }
  }
#line 3708
  if (display) {
#line 3708
    if ((int )*rc_name) {
#line 3710
      display->d_nonblock = defnonblock;
#line 3711
      if (display->d_nonblock <= 0) {
        {
#line 3712
        evdeq(& display->d_blockedev);
        }
      }
    }
  }
#line 3714
  goto switch_break;
  case_82: /* CIL Label */ 
#line 3718
  if (fore->w_gr == 2) {
#line 3719
    fore->w_gr = 0;
  }
  {
#line 3721
  __cil_tmp721 = ParseSwitch(act, & fore->w_gr);
  }
#line 3721
  if (__cil_tmp721 == 0) {
#line 3721
    if (msgok) {
#line 3722
      if (! act->quiet) {
#line 3722
        tmp___580 = Msg;
      } else {
#line 3722
        if (queryflag >= 0) {
#line 3722
          tmp___579 = QueryMsg;
        } else {
#line 3722
          tmp___579 = Dummy;
        }
#line 3722
        tmp___580 = tmp___579;
      }
#line 3722
      if (fore->w_gr) {
#line 3722
        tmp___581 = (char *)"";
      } else {
#line 3722
        tmp___581 = (char *)"not ";
      }
      {
#line 3722
      tmp___580(0, (char const   *)((char *)"Will %suse GR"), tmp___581);
      }
    }
  }
#line 3724
  if (fore->w_gr == 0) {
#line 3724
    if ((int )fore->w_FontE) {
#line 3725
      fore->w_gr = 2;
    }
  }
#line 3727
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 3729
  __cil_tmp725 = ParseSwitch(act, & fore->w_c1);
  }
#line 3729
  if (__cil_tmp725 == 0) {
#line 3729
    if (msgok) {
#line 3730
      if (! act->quiet) {
#line 3730
        tmp___583 = Msg;
      } else {
#line 3730
        if (queryflag >= 0) {
#line 3730
          tmp___582 = QueryMsg;
        } else {
#line 3730
          tmp___582 = Dummy;
        }
#line 3730
        tmp___583 = tmp___582;
      }
#line 3730
      if (fore->w_c1) {
#line 3730
        tmp___584 = (char *)"";
      } else {
#line 3730
        tmp___584 = (char *)"not ";
      }
      {
#line 3730
      tmp___583(0, (char const   *)((char *)"Will %suse C1"), tmp___584);
      }
    }
  }
#line 3731
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 3734
  __cil_tmp729 = ParseSwitch(act, & fore->w_bce);
  }
#line 3734
  if (__cil_tmp729 == 0) {
#line 3734
    if (msgok) {
#line 3735
      if (! act->quiet) {
#line 3735
        tmp___586 = Msg;
      } else {
#line 3735
        if (queryflag >= 0) {
#line 3735
          tmp___585 = QueryMsg;
        } else {
#line 3735
          tmp___585 = Dummy;
        }
#line 3735
        tmp___586 = tmp___585;
      }
#line 3735
      if (fore->w_bce) {
#line 3735
        tmp___587 = (char *)"";
      } else {
#line 3735
        tmp___587 = (char *)"not ";
      }
      {
#line 3735
      tmp___586(0, (char const   *)((char *)"Will %serase with background color"),
                tmp___587);
      }
    }
  }
#line 3736
  goto switch_break;
  case_74: /* CIL Label */ 
  case_95: /* CIL Label */ 
  {
#line 3742
  __cil_tmp733 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-d"));
  }
#line 3742
  if (*args) {
#line 3742
    if (! __cil_tmp733) {
#line 3744
      if (! *(args + 1)) {
#line 3745
        if (! act->quiet) {
#line 3745
          tmp___589 = Msg;
        } else {
#line 3745
          if (queryflag >= 0) {
#line 3745
            tmp___588 = QueryMsg;
          } else {
#line 3745
            tmp___588 = Dummy;
          }
#line 3745
          tmp___589 = tmp___588;
        }
#line 3745
        if (screenencodings) {
#line 3745
          tmp___590 = screenencodings;
        } else {
#line 3745
          tmp___590 = (char *)"<unset>";
        }
        {
#line 3745
        tmp___589(0, (char const   *)((char *)"encodings directory is %s"), tmp___590);
        }
      } else {
        {
#line 3748
        free((void *)screenencodings);
#line 3749
        screenencodings = SaveStr((char const   *)*(args + 1));
        }
      }
#line 3751
      goto switch_break;
    }
  }
  {
#line 3753
  __cil_tmp738 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"-l"));
  }
#line 3753
  if (*args) {
#line 3753
    if (! __cil_tmp738) {
#line 3755
      if (! *(args + 1)) {
#line 3756
        if (! act->quiet) {
#line 3756
          tmp___592 = Msg;
        } else {
#line 3756
          if (queryflag >= 0) {
#line 3756
            tmp___591 = QueryMsg;
          } else {
#line 3756
            tmp___591 = Dummy;
          }
#line 3756
          tmp___592 = tmp___591;
        }
        {
#line 3756
        tmp___592(0, (char const   *)((char *)"encoding: -l: argument required"));
        }
      } else {
        {
#line 3757
        __cil_tmp741 = LoadFontTranslation(- 1, *(args + 1));
        }
#line 3757
        if (__cil_tmp741) {
#line 3758
          if (! act->quiet) {
#line 3758
            tmp___594 = Msg;
          } else {
#line 3758
            if (queryflag >= 0) {
#line 3758
              tmp___593 = QueryMsg;
            } else {
#line 3758
              tmp___593 = Dummy;
            }
#line 3758
            tmp___594 = tmp___593;
          }
          {
#line 3758
          tmp___594(0, (char const   *)((char *)"encoding: could not load utf8 encoding file"));
          }
        } else
#line 3759
        if (msgok) {
#line 3760
          if (! act->quiet) {
#line 3760
            tmp___596 = Msg;
          } else {
#line 3760
            if (queryflag >= 0) {
#line 3760
              tmp___595 = QueryMsg;
            } else {
#line 3760
              tmp___595 = Dummy;
            }
#line 3760
            tmp___596 = tmp___595;
          }
          {
#line 3760
          tmp___596(0, (char const   *)((char *)"encoding: utf8 encoding file loaded"));
          }
        }
      }
#line 3761
      goto switch_break;
    }
  }
#line 3771
  i = 0;
  {
#line 3771
  while (1) {
    while_continue___52: /* CIL Label */ ;
#line 3771
    if (! (i < 2)) {
#line 3771
      goto while_break___52;
    }
#line 3773
    if (*(args + i) == (char *)0) {
#line 3774
      goto while_break___52;
    }
    {
#line 3775
    __cil_tmp746 = strcmp((char const   *)*(args + i), (char const   *)((char *)"."));
    }
#line 3775
    if (! __cil_tmp746) {
#line 3776
      goto while_continue___52;
    }
    {
#line 3777
    n = FindEncoding(*(args + i));
    }
#line 3778
    if (n == -1) {
#line 3780
      if (! act->quiet) {
#line 3780
        tmp___598 = Msg;
      } else {
#line 3780
        if (queryflag >= 0) {
#line 3780
          tmp___597 = QueryMsg;
        } else {
#line 3780
          tmp___597 = Dummy;
        }
#line 3780
        tmp___598 = tmp___597;
      }
      {
#line 3780
      tmp___598(0, (char const   *)((char *)"encoding: unknown encoding \'%s\'"),
                *(args + i));
      }
#line 3781
      goto while_break___52;
    }
#line 3783
    if (i == 0) {
#line 3783
      if (fore) {
        {
#line 3785
        WinSwitchEncoding(fore, n);
#line 3786
        ResetCharsets(fore);
        }
      } else {
#line 3783
        goto _L___599;
      }
    } else
    _L___599: /* CIL Label */ 
#line 3788
    if (i) {
#line 3788
      if (display) {
#line 3789
        display->d_encoding = n;
      }
    }
  }
  while_break___52: /* CIL Label */ ;
  }
#line 3771
  i ++;
#line 3791
  goto switch_break;
  case_47: /* CIL Label */ 
  case_52: /* CIL Label */ 
  {
#line 3794
  n = FindEncoding(*args);
  }
#line 3795
  if (n == -1) {
#line 3797
    if (! act->quiet) {
#line 3797
      tmp___601 = Msg;
    } else {
#line 3797
      if (queryflag >= 0) {
#line 3797
        tmp___600 = QueryMsg;
      } else {
#line 3797
        tmp___600 = Dummy;
      }
#line 3797
      tmp___601 = tmp___600;
    }
    {
#line 3797
    tmp___601(0, (char const   *)((char *)"defencoding: unknown encoding \'%s\'"),
              *args);
    }
#line 3798
    goto switch_break;
  }
#line 3800
  nwin_default.encoding = n;
#line 3801
  goto switch_break;
  case_64: /* CIL Label */ 
#line 3806
  n = nwin_default.encoding == 8;
  {
#line 3807
  __cil_tmp754 = ParseSwitch(act, & n);
  }
#line 3807
  if (__cil_tmp754 == 0) {
#line 3809
    if (n) {
#line 3809
      tmp___602 = 8;
    } else {
#line 3809
      tmp___602 = 0;
    }
#line 3809
    nwin_default.encoding = tmp___602;
#line 3810
    if (msgok) {
#line 3811
      if (! act->quiet) {
#line 3811
        tmp___604 = Msg;
      } else {
#line 3811
        if (queryflag >= 0) {
#line 3811
          tmp___603 = QueryMsg;
        } else {
#line 3811
          tmp___603 = Dummy;
        }
#line 3811
        tmp___604 = tmp___603;
      }
#line 3811
      if (n) {
#line 3811
        tmp___605 = (char *)"";
      } else {
#line 3811
        tmp___605 = (char *)"not ";
      }
      {
#line 3811
      tmp___604(0, (char const   *)((char *)"Will %suse UTF-8 encoding for new windows"),
                tmp___605);
      }
    }
  }
#line 3813
  goto switch_break;
  case_172: /* CIL Label */ 
#line 3815
  i = 0;
  {
#line 3815
  while (1) {
    while_continue___53: /* CIL Label */ ;
#line 3815
    if (! (i < 2)) {
#line 3815
      goto while_break___53;
    }
#line 3817
    if (i) {
#line 3817
      if (*(args + i) == (char *)0) {
#line 3818
        goto while_break___53;
      }
    }
#line 3819
    if (*(args + i) == (char *)0) {
#line 3820
      n = fore->w_layer.l_encoding != 8;
    } else {
      {
#line 3821
      __cil_tmp759 = strcmp((char const   *)*(args + i), (char const   *)((char *)"off"));
      }
#line 3821
      if (__cil_tmp759 == 0) {
#line 3822
        n = 0;
      } else {
        {
#line 3823
        __cil_tmp760 = strcmp((char const   *)*(args + i), (char const   *)((char *)"on"));
        }
#line 3823
        if (__cil_tmp760 == 0) {
#line 3824
          n = 1;
        } else {
#line 3827
          if (! act->quiet) {
#line 3827
            tmp___607 = Msg;
          } else {
#line 3827
            if (queryflag >= 0) {
#line 3827
              tmp___606 = QueryMsg;
            } else {
#line 3827
              tmp___606 = Dummy;
            }
#line 3827
            tmp___607 = tmp___606;
          }
          {
#line 3827
          tmp___607(0, (char const   *)((char *)"utf8: illegal argument (%s)"), *(args + i));
          }
#line 3828
          goto while_break___53;
        }
      }
    }
#line 3830
    if (i == 0) {
#line 3832
      if (n) {
#line 3832
        tmp___608 = 8;
      } else {
#line 3832
        tmp___608 = 0;
      }
      {
#line 3832
      WinSwitchEncoding(fore, tmp___608);
      }
#line 3833
      if (msgok) {
#line 3834
        if (! act->quiet) {
#line 3834
          tmp___610 = Msg;
        } else {
#line 3834
          if (queryflag >= 0) {
#line 3834
            tmp___609 = QueryMsg;
          } else {
#line 3834
            tmp___609 = Dummy;
          }
#line 3834
          tmp___610 = tmp___609;
        }
#line 3834
        if (n) {
#line 3834
          tmp___611 = (char *)"";
        } else {
#line 3834
          tmp___611 = (char *)"not ";
        }
        {
#line 3834
        tmp___610(0, (char const   *)((char *)"Will %suse UTF-8 encoding"), tmp___611);
        }
      }
    } else
#line 3836
    if (display) {
#line 3837
      if (n) {
#line 3837
        tmp___612 = 8;
      } else {
#line 3837
        tmp___612 = 0;
      }
#line 3837
      display->d_encoding = tmp___612;
    }
#line 3838
    if (*(args + i) == (char *)0) {
#line 3839
      goto while_break___53;
    }
  }
  while_break___53: /* CIL Label */ ;
  }
#line 3815
  i ++;
#line 3841
  goto switch_break;
  case_131: /* CIL Label */ 
#line 3845
  if (*args) {
#line 3847
    if (printcmd) {
      {
#line 3848
      free((void *)printcmd);
      }
    }
#line 3849
    printcmd = (char *)0;
#line 3850
    if (*(*args)) {
      {
#line 3851
      printcmd = SaveStr((char const   *)*args);
      }
    }
  }
#line 3853
  if (*args == (char *)0) {
    _L___617: /* CIL Label */ 
#line 3855
    if (printcmd) {
#line 3856
      if (! act->quiet) {
#line 3856
        tmp___614 = Msg;
      } else {
#line 3856
        if (queryflag >= 0) {
#line 3856
          tmp___613 = QueryMsg;
        } else {
#line 3856
          tmp___613 = Dummy;
        }
#line 3856
        tmp___614 = tmp___613;
      }
      {
#line 3856
      tmp___614(0, (char const   *)((char *)"using \'%s\' as print command"), printcmd);
      }
    } else {
#line 3858
      if (! act->quiet) {
#line 3858
        tmp___616 = Msg;
      } else {
#line 3858
        if (queryflag >= 0) {
#line 3858
          tmp___615 = QueryMsg;
        } else {
#line 3858
          tmp___615 = Dummy;
        }
#line 3858
        tmp___616 = tmp___615;
      }
      {
#line 3858
      tmp___616(0, (char const   *)((char *)"using termcap entries for printing"));
      }
    }
#line 3859
    goto switch_break;
  } else
#line 3853
  if (msgok) {
#line 3853
    goto _L___617;
  }
#line 3861
  goto switch_break;
  case_68: /* CIL Label */ 
#line 3864
  if (argl) {
#line 3864
    if (*(argl + 0) > 0) {
#line 3864
      if (*(args + 1)) {
#line 3864
        if (*(argl + 1) > 0) {
#line 3866
          if (*(argl + 0) != 2) {
#line 3868
            if (! act->quiet) {
#line 3868
              tmp___619 = Msg;
            } else {
#line 3868
              if (queryflag >= 0) {
#line 3868
                tmp___618 = QueryMsg;
              } else {
#line 3868
                tmp___618 = Dummy;
              }
#line 3868
              tmp___619 = tmp___618;
            }
            {
#line 3868
            tmp___619(0, (char const   *)((char *)"Two characters expected to define a digraph"));
            }
#line 3869
            goto switch_break;
          }
          {
#line 3871
          i = digraph_find((char const   *)*(args + 0));
#line 3872
          digraphs[i].d[0] = (unsigned char )*(*(args + 0) + 0);
#line 3873
          digraphs[i].d[1] = (unsigned char )*(*(args + 0) + 1);
#line 3874
          __cil_tmp777 = parse_input_int((char const   *)*(args + 1), *(argl + 1),
                                         & digraphs[i].value);
          }
#line 3874
          if (! __cil_tmp777) {
            {
#line 3876
            digraphs[i].value = atoi((char const   *)*(args + 1));
            }
#line 3876
            if (! digraphs[i].value) {
#line 3878
              if (! *(*(args + 1) + 1)) {
#line 3879
                digraphs[i].value = (int )*(*(args + 1) + 0);
              } else {
#line 3884
                s___620 = (unsigned char *)*(args + 1);
#line 3885
                digraphs[i].value = 0;
                {
#line 3886
                while (1) {
                  while_continue___54: /* CIL Label */ ;
#line 3886
                  if (! *s___620) {
#line 3886
                    goto while_break___54;
                  }
                  {
#line 3888
                  __cil_tmp781 = s___620;
#line 3888
                  s___620 ++;
#line 3888
                  __cil_tmp782 = FromUtf8((int )*__cil_tmp781, & digraphs[i].value);
#line 3888
                  t = __cil_tmp782;
                  }
#line 3889
                  if (t == -1) {
#line 3890
                    goto while_continue___54;
                  }
#line 3891
                  if (t == -2) {
#line 3892
                    digraphs[i].value = 0;
                  } else {
#line 3894
                    digraphs[i].value = t;
                  }
#line 3895
                  goto while_break___54;
                }
                while_break___54: /* CIL Label */ ;
                }
              }
            }
          }
#line 3901
          goto switch_break;
        }
      }
    }
  }
  {
#line 3903
  Input((char *)"Enter digraph: ", 10, 4, digraph_fn, (char *)((void *)0), 0);
  }
#line 3904
  if (*args) {
#line 3904
    if ((int )*(*args)) {
      {
#line 3906
      s = *args;
#line 3907
      __cil_tmp783 = strlen((char const   *)s);
#line 3907
      n = (int )__cil_tmp783;
#line 3908
      (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
      }
    }
  }
#line 3910
  goto switch_break;
  case_51: /* CIL Label */ 
#line 3913
  if (*args == (char *)0) {
#line 3916
    *((char *)buf___8) = (char )0;
#line 3917
    if (nwin_default.hstatus) {
      {
#line 3918
      AddXChars((char *)buf___8, (int )sizeof(buf___8), nwin_default.hstatus);
      }
    }
#line 3919
    if (! act->quiet) {
#line 3919
      tmp___622 = Msg;
    } else {
#line 3919
      if (queryflag >= 0) {
#line 3919
        tmp___621 = QueryMsg;
      } else {
#line 3919
        tmp___621 = Dummy;
      }
#line 3919
      tmp___622 = tmp___621;
    }
    {
#line 3919
    tmp___622(0, (char const   *)((char *)"default hstatus is \'%s\'"), (char *)buf___8);
    }
#line 3920
    goto switch_break;
  }
  {
#line 3922
  __cil_tmp787 = ParseSaveStr(act, & nwin_default.hstatus);
  }
#line 3923
  if ((int )*(nwin_default.hstatus) == 0) {
    {
#line 3925
    free((void *)nwin_default.hstatus);
#line 3926
    nwin_default.hstatus = (char *)0;
    }
  }
#line 3928
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 3930
  __cil_tmp788 = ParseSaveStr(act, & fore->w_hstatus);
  }
#line 3931
  if ((int )*(fore->w_hstatus) == 0) {
    {
#line 3933
    free((void *)fore->w_hstatus);
#line 3934
    fore->w_hstatus = (char *)0;
    }
  }
  {
#line 3936
  WindowChanged(fore, 'h');
  }
#line 3937
  goto switch_break;
  case_29: /* CIL Label */ 
  case_45: /* CIL Label */ 
#line 3942
  if (*args == (char *)0) {
#line 3945
    *((char *)buf___9) = (char )0;
#line 3946
    if (nwin_default.charset) {
      {
#line 3947
      AddXChars((char *)buf___9, (int )sizeof(buf___9), nwin_default.charset);
      }
    }
#line 3948
    if (! act->quiet) {
#line 3948
      tmp___624 = Msg;
    } else {
#line 3948
      if (queryflag >= 0) {
#line 3948
        tmp___623 = QueryMsg;
      } else {
#line 3948
        tmp___623 = Dummy;
      }
#line 3948
      tmp___624 = tmp___623;
    }
    {
#line 3948
    tmp___624(0, (char const   *)((char *)"default charset is \'%s\'"), (char *)buf___9);
    }
#line 3949
    goto switch_break;
  }
  {
#line 3951
  __cil_tmp792 = strlen((char const   *)*args);
#line 3951
  n = (int )__cil_tmp792;
  }
#line 3952
  if (n == 0) {
    _L___627: /* CIL Label */ 
#line 3954
    if (! act->quiet) {
#line 3954
      tmp___626 = Msg;
    } else {
#line 3954
      if (queryflag >= 0) {
#line 3954
        tmp___625 = QueryMsg;
      } else {
#line 3954
        tmp___625 = Dummy;
      }
#line 3954
      tmp___626 = tmp___625;
    }
    {
#line 3954
    tmp___626(0, (char const   *)((char *)"%s: %s: string has illegal size."), rc_name,
              comms[nr].name);
    }
#line 3955
    goto switch_break;
  } else
#line 3952
  if (n > 6) {
#line 3952
    goto _L___627;
  }
#line 3957
  if (n > 4) {
#line 3957
    if ((int )*(*(args + 0) + 4) < 48) {
      _L___633: /* CIL Label */ 
#line 3957
      if ((int )*(*(args + 0) + 4) != 46) {
        _L___630: /* CIL Label */ 
#line 3961
        if (! act->quiet) {
#line 3961
          tmp___629 = Msg;
        } else {
#line 3961
          if (queryflag >= 0) {
#line 3961
            tmp___628 = QueryMsg;
          } else {
#line 3961
            tmp___628 = Dummy;
          }
#line 3961
          tmp___629 = tmp___628;
        }
        {
#line 3961
        tmp___629(0, (char const   *)((char *)"%s: %s: illegal mapping number."),
                  rc_name, comms[nr].name);
        }
#line 3962
        goto switch_break;
      } else {
#line 3957
        goto _L___632;
      }
    } else
#line 3957
    if ((int )*(*(args + 0) + 4) > 51) {
#line 3957
      goto _L___633;
    } else
    _L___632: /* CIL Label */ 
#line 3957
    if ((int )*(*(args + 0) + 5) < 48) {
      _L___631: /* CIL Label */ 
#line 3957
      if ((int )*(*(args + 0) + 5)) {
#line 3957
        if ((int )*(*(args + 0) + 5) != 46) {
#line 3957
          goto _L___630;
        }
      }
    } else
#line 3957
    if ((int )*(*(args + 0) + 5) > 51) {
#line 3957
      goto _L___631;
    }
  }
#line 3964
  if (nr == 29) {
    {
#line 3966
    SetCharsets(fore, *args);
    }
#line 3967
    goto switch_break;
  }
#line 3969
  if (nwin_default.charset) {
    {
#line 3970
    free((void *)nwin_default.charset);
    }
  }
  {
#line 3971
  nwin_default.charset = SaveStr((char const   *)*args);
  }
#line 3972
  goto switch_break;
  case_10: /* CIL Label */ 
#line 3976
  s = *(args + 0);
#line 3977
  if ((int )*s >= 48) {
#line 3977
    if ((int )*s <= 57) {
#line 3978
      i = (int )*s - 48;
    } else {
#line 3977
      goto _L___634;
    }
  } else {
    _L___634: /* CIL Label */ 
#line 3980
    i = 0;
    {
#line 3980
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 3980
      if (! (i < 8)) {
#line 3980
        goto while_break___55;
      }
#line 3981
      if ((int )*s == (int )*((char *)"dubrsBiI" + i)) {
#line 3982
        goto while_break___55;
      }
    }
    while_break___55: /* CIL Label */ ;
    }
#line 3980
    i ++;
  }
#line 3983
  s ++;
#line 3984
  nr = 0;
#line 3985
  if ((int )*s) {
#line 3985
    if ((int )*(s + 1)) {
#line 3985
      if (! *(s + 2)) {
#line 3987
        if ((int )*s == 100) {
#line 3987
          if ((int )*(s + 1) == 100) {
#line 3988
            nr = 3;
          } else {
#line 3987
            goto _L___637;
          }
        } else
        _L___637: /* CIL Label */ 
#line 3989
        if ((int )*s == 46) {
#line 3989
          if ((int )*(s + 1) == 100) {
#line 3990
            nr = 2;
          } else {
#line 3989
            goto _L___636;
          }
        } else
        _L___636: /* CIL Label */ 
#line 3991
        if ((int )*s == 100) {
#line 3991
          if ((int )*(s + 1) == 46) {
#line 3992
            nr = 1;
          } else {
#line 3991
            goto _L___635;
          }
        } else
        _L___635: /* CIL Label */ 
#line 3993
        if ((int )*s != 46) {
#line 3994
          __cil_tmp800 = s;
#line 3994
          s --;
        } else
#line 3993
        if ((int )*(s + 1) != 46) {
#line 3994
          __cil_tmp800 = s;
#line 3994
          s --;
        }
#line 3995
        s += 2;
      }
    }
  }
#line 3997
  if ((int )*s) {
    _L___640: /* CIL Label */ 
#line 3999
    if (! act->quiet) {
#line 3999
      tmp___639 = Msg;
    } else {
#line 3999
      if (queryflag >= 0) {
#line 3999
        tmp___638 = QueryMsg;
      } else {
#line 3999
        tmp___638 = Dummy;
      }
#line 3999
      tmp___639 = tmp___638;
    }
    {
#line 3999
    tmp___639(0, (char const   *)((char *)"%s: attrcolor: unknown attribute \'%s\'."),
              rc_name, *(args + 0));
    }
#line 4000
    goto switch_break;
  } else
#line 3997
  if (i < 0) {
#line 3997
    goto _L___640;
  } else
#line 3997
  if (i >= 8) {
#line 3997
    goto _L___640;
  }
#line 4002
  n = 0;
#line 4003
  if (*(args + 1)) {
    {
#line 4004
    n = ParseAttrColor(*(args + 1), *(args + 2), 1);
    }
  }
#line 4005
  if (n == -1) {
#line 4006
    goto switch_break;
  }
#line 4007
  attr2color[i][nr] = n;
#line 4008
  n = 0;
#line 4009
  i = 0;
  {
#line 4009
  while (1) {
    while_continue___56: /* CIL Label */ ;
#line 4009
    if (! (i < 8)) {
#line 4009
      goto while_break___56;
    }
#line 4010
    if (attr2color[i][0]) {
#line 4011
      n |= 1 << i;
    } else
#line 4010
    if (attr2color[i][1]) {
#line 4011
      n |= 1 << i;
    } else
#line 4010
    if (attr2color[i][2]) {
#line 4011
      n |= 1 << i;
    } else
#line 4010
    if (attr2color[i][3]) {
#line 4011
      n |= 1 << i;
    }
  }
  while_break___56: /* CIL Label */ ;
  }
#line 4009
  i ++;
#line 4012
  nattr2color = n;
#line 4013
  goto switch_break;
  case_140: /* CIL Label */ 
#line 4016
  i = - 1;
  {
#line 4017
  __cil_tmp805 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"bell"));
  }
#line 4017
  if (__cil_tmp805 == 0) {
#line 4019
    i = 0;
  } else {
    {
#line 4021
    __cil_tmp806 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"monitor"));
    }
#line 4021
    if (__cil_tmp806 == 0) {
#line 4023
      i = 1;
    } else {
      {
#line 4025
      __cil_tmp807 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"silence"));
      }
#line 4025
      if (__cil_tmp807 == 0) {
#line 4027
        i = 2;
      } else {
        {
#line 4029
        __cil_tmp808 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"so"));
        }
#line 4029
        if (__cil_tmp808 != 0) {
#line 4031
          if (! act->quiet) {
#line 4031
            tmp___643 = Msg;
          } else {
#line 4031
            if (queryflag >= 0) {
#line 4031
              tmp___642 = QueryMsg;
            } else {
#line 4031
              tmp___642 = Dummy;
            }
#line 4031
            tmp___643 = tmp___642;
          }
          {
#line 4031
          tmp___643(0, (char const   *)((char *)"Invalid option \'%s\' for rendition"),
                    *(args + 0));
          }
#line 4032
          goto switch_break;
        }
      }
    }
  }
#line 4035
  args ++;
#line 4036
  argl ++;
#line 4038
  if (i != -1) {
    {
#line 4040
    renditions[i] = ParseAttrColor(*(args + 0), *(args + 1), 1);
#line 4041
    WindowChanged((struct win *)0, 'w');
#line 4042
    WindowChanged((struct win *)0, 'W');
#line 4043
    WindowChanged((struct win *)0, 0);
    }
#line 4044
    goto switch_break;
  }
  case_155: /* CIL Label */ 
#line 4050
  i = 0;
#line 4051
  if (*args) {
    {
#line 4053
    i = ParseAttrColor(*args, *(args + 1), 1);
    }
#line 4054
    if (i == -1) {
#line 4055
      goto switch_break;
    }
    {
#line 4056
    ApplyAttrColor(i, & mchar_so);
#line 4057
    WindowChanged((struct win *)0, 0);
    }
    {
#line 4058
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 4058
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
  }
#line 4060
  if (msgok) {
#line 4062
    if (! act->quiet) {
#line 4062
      tmp___645 = Msg;
    } else {
#line 4062
      if (queryflag >= 0) {
#line 4062
        tmp___644 = QueryMsg;
      } else {
#line 4062
        tmp___644 = Dummy;
      }
#line 4062
      tmp___645 = tmp___644;
    }
    {
#line 4062
    tmp___645(0, (char const   *)((char *)"Standout attributes 0x%02x  color 0x%02x"),
              (int )mchar_so.attr, 153 ^ (int )mchar_so.color);
    }
  }
#line 4066
  goto switch_break;
  case_157: /* CIL Label */ 
  {
#line 4069
  do_source(*args);
  }
#line 4070
  goto switch_break;
  case_161: /* CIL Label */ 
#line 4074
  s = (char *)((void *)0);
#line 4075
  if (! *args) {
#line 4077
    if (! act->quiet) {
#line 4077
      tmp___647 = Msg;
    } else {
#line 4077
      if (queryflag >= 0) {
#line 4077
        tmp___646 = QueryMsg;
      } else {
#line 4077
        tmp___646 = Dummy;
      }
#line 4077
      tmp___647 = tmp___646;
    }
    {
#line 4077
    tmp___647(0, (char const   *)((char *)"%s:%s screen login"), (char *)HostName,
              (char *)SockPath);
#line 4078
    InputSu(display->d_fore, & display->d_user, (char *)((void *)0));
    }
  } else
#line 4080
  if (! *(args + 1)) {
    {
#line 4081
    InputSu(display->d_fore, & display->d_user, *(args + 0));
    }
  } else
#line 4082
  if (! *(args + 2)) {
    {
#line 4083
    s = DoSu(& display->d_user, *(args + 0), *(args + 1), (char *)"\377");
    }
  } else {
    {
#line 4085
    s = DoSu(& display->d_user, *(args + 0), *(args + 1), *(args + 2));
    }
  }
#line 4086
  if (s) {
#line 4087
    if (! act->quiet) {
#line 4087
      tmp___649 = Msg;
    } else {
#line 4087
      if (queryflag >= 0) {
#line 4087
        tmp___648 = QueryMsg;
      } else {
#line 4087
        tmp___648 = Dummy;
      }
#line 4087
      tmp___649 = tmp___648;
    }
    {
#line 4087
    tmp___649(0, (char const   *)((char *)"%s"), s);
    }
  }
#line 4088
  goto switch_break;
  case_158: /* CIL Label */ 
#line 4091
  s = *(args + 0);
  {
#line 4092
  __cil_tmp821 = strcmp((char const   *)s, (char const   *)((char *)"-v"));
  }
#line 4092
  if (s) {
#line 4092
    if (! __cil_tmp821) {
      {
#line 4093
      AddCanvas(1 << 1);
      }
    } else {
      {
      {
#line 4095
      AddCanvas(1);
      }
      }
    }
  } else {
    {
    {
#line 4095
    AddCanvas(1);
    }
    }
  }
  {
#line 4096
  Activate(- 1);
  }
#line 4097
  goto switch_break;
  case_138: /* CIL Label */ 
  {
#line 4099
  RemCanvas();
  }
  {
#line 4100
  Activate(- 1);
  }
#line 4101
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 4103
  OneCanvas();
  }
  {
#line 4104
  Activate(- 1);
  }
#line 4105
  goto switch_break;
  case_78: /* CIL Label */ 
#line 4107
  (display->d_forecv)->c_xoff = (display->d_forecv)->c_xs;
  {
#line 4108
  (display->d_forecv)->c_yoff = (display->d_forecv)->c_ys;
#line 4109
  RethinkViewportOffsets(display->d_forecv);
#line 4110
  ResizeLayer((display->d_forecv)->c_layer, ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1,
              ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1, (struct display *)0);
#line 4111
  flayer = (display->d_forecv)->c_layer;
#line 4112
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 4113
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 4116
  cv = (struct canvas *)0;
#line 4117
  __cil_tmp823 = strcmp((char const   *)*args, (char const   *)((char *)"next"));
  }
#line 4117
  if (! *args) {
    _L___653: /* CIL Label */ 
#line 4118
    if ((display->d_forecv)->c_next) {
#line 4118
      tmp___650 = (display->d_forecv)->c_next;
    } else {
#line 4118
      tmp___650 = display->d_cvlist;
    }
#line 4118
    cv = tmp___650;
  } else
#line 4117
  if (! __cil_tmp823) {
#line 4117
    goto _L___653;
  } else {
    {
#line 4119
    __cil_tmp825 = strcmp((char const   *)*args, (char const   *)((char *)"prev"));
    }
#line 4119
    if (! __cil_tmp825) {
#line 4121
      cv = display->d_cvlist;
      {
#line 4121
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 4121
        if (! (cv->c_next && cv->c_next != display->d_forecv)) {
#line 4121
          goto while_break___58;
        }

      }
      while_break___58: /* CIL Label */ ;
      }
#line 4121
      cv = cv->c_next;
    } else {
      {
#line 4124
      __cil_tmp826 = strcmp((char const   *)*args, (char const   *)((char *)"top"));
      }
#line 4124
      if (! __cil_tmp826) {
#line 4125
        cv = display->d_cvlist;
      } else {
        {
#line 4126
        __cil_tmp827 = strcmp((char const   *)*args, (char const   *)((char *)"bottom"));
        }
#line 4126
        if (! __cil_tmp827) {
#line 4128
          cv = display->d_cvlist;
          {
#line 4128
          while (1) {
            while_continue___59: /* CIL Label */ ;
#line 4128
            if (! cv->c_next) {
#line 4128
              goto while_break___59;
            }

          }
          while_break___59: /* CIL Label */ ;
          }
#line 4128
          cv = cv->c_next;
        } else {
          {
#line 4131
          __cil_tmp828 = strcmp((char const   *)*args, (char const   *)((char *)"up"));
          }
#line 4131
          if (! __cil_tmp828) {
            {
#line 4132
            cv = FindCanvas((display->d_forecv)->c_xs, (display->d_forecv)->c_ys - 1);
            }
          } else {
            {
#line 4133
            __cil_tmp830 = strcmp((char const   *)*args, (char const   *)((char *)"down"));
            }
#line 4133
            if (! __cil_tmp830) {
              {
#line 4134
              cv = FindCanvas((display->d_forecv)->c_xs, (display->d_forecv)->c_ye + 2);
              }
            } else {
              {
#line 4135
              __cil_tmp832 = strcmp((char const   *)*args, (char const   *)((char *)"left"));
              }
#line 4135
              if (! __cil_tmp832) {
                {
#line 4136
                cv = FindCanvas((display->d_forecv)->c_xs - 1, (display->d_forecv)->c_ys);
                }
              } else {
                {
#line 4137
                __cil_tmp834 = strcmp((char const   *)*args, (char const   *)((char *)"right"));
                }
#line 4137
                if (! __cil_tmp834) {
                  {
#line 4138
                  cv = FindCanvas((display->d_forecv)->c_xe + 1, (display->d_forecv)->c_ys);
                  }
                } else {
#line 4141
                  if (! act->quiet) {
#line 4141
                    tmp___652 = Msg;
                  } else {
#line 4141
                    if (queryflag >= 0) {
#line 4141
                      tmp___651 = QueryMsg;
                    } else {
#line 4141
                      tmp___651 = Dummy;
                    }
#line 4141
                    tmp___652 = tmp___651;
                  }
                  {
#line 4141
                  tmp___652(0, (char const   *)((char *)"%s: usage: focus [next|prev|up|down|left|right|top|bottom]"),
                            rc_name);
                  }
#line 4142
                  goto switch_break;
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 4144
  SetForeCanvas(display, cv);
  }
#line 4146
  goto switch_break;
  case_142: /* CIL Label */ 
#line 4148
  i = 0;
#line 4149
  if ((display->d_forecv)->c_slorient == 0) {
#line 4151
    if (! act->quiet) {
#line 4151
      tmp___655 = Msg;
    } else {
#line 4151
      if (queryflag >= 0) {
#line 4151
        tmp___654 = QueryMsg;
      } else {
#line 4151
        tmp___654 = Dummy;
      }
#line 4151
      tmp___655 = tmp___654;
    }
    {
#line 4151
    tmp___655(0, (char const   *)((char *)"resize: need more than one region"));
    }
#line 4152
    goto switch_break;
  }
  {
#line 4154
  while (1) {
    while_continue___60: /* CIL Label */ ;
#line 4154
    if (! *args) {
#line 4154
      goto while_break___60;
    }
    {
#line 4156
    __cil_tmp840 = strcmp((char const   *)*args, (char const   *)((char *)"-h"));
    }
#line 4156
    if (! __cil_tmp840) {
#line 4157
      i |= 1;
    } else {
      {
#line 4158
      __cil_tmp841 = strcmp((char const   *)*args, (char const   *)((char *)"-v"));
      }
#line 4158
      if (! __cil_tmp841) {
#line 4159
        i |= 2;
      } else {
        {
#line 4160
        __cil_tmp842 = strcmp((char const   *)*args, (char const   *)((char *)"-b"));
        }
#line 4160
        if (! __cil_tmp842) {
#line 4161
          i |= 3;
        } else {
          {
#line 4162
          __cil_tmp843 = strcmp((char const   *)*args, (char const   *)((char *)"-p"));
          }
#line 4162
          if (! __cil_tmp843) {
#line 4163
            if ((display->d_forecv)->c_slorient == 1) {
#line 4163
              tmp___656 = 1;
            } else {
#line 4163
              tmp___656 = 2;
            }
#line 4163
            i |= tmp___656;
          } else {
            {
#line 4164
            __cil_tmp845 = strcmp((char const   *)*args, (char const   *)((char *)"-l"));
            }
#line 4164
            if (! __cil_tmp845) {
#line 4165
              i |= 4;
            } else {
#line 4167
              goto while_break___60;
            }
          }
        }
      }
    }
  }
  while_break___60: /* CIL Label */ ;
  }
#line 4154
  args ++;
#line 4169
  if (*args) {
#line 4169
    if (*(args + 1)) {
#line 4171
      if (! act->quiet) {
#line 4171
        tmp___658 = Msg;
      } else {
#line 4171
        if (queryflag >= 0) {
#line 4171
          tmp___657 = QueryMsg;
        } else {
#line 4171
          tmp___657 = Dummy;
        }
#line 4171
        tmp___658 = tmp___657;
      }
      {
#line 4171
      tmp___658(0, (char const   *)((char *)"%s: usage: resize [-h] [-v] [-l] [num]\n"),
                rc_name);
      }
#line 4172
      goto switch_break;
    }
  }
#line 4174
  if (*args) {
    {
#line 4175
    ResizeRegions(*args, i);
    }
  } else {
    {
#line 4177
    Input(resizeprompts[i], 20, 4, ResizeFin, (char *)0, i);
    }
  }
#line 4178
  goto switch_break;
  case_148: /* CIL Label */ 
  {
#line 4180
  __cil_tmp849 = ParseSwitch(act, & separate_sids);
  }
#line 4181
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 4183
  args = SaveArgs(args);
  }
#line 4184
  i = 0;
  {
#line 4184
  while (1) {
    while_continue___61: /* CIL Label */ ;
#line 4184
    if (! *(args + i)) {
#line 4184
      goto while_break___61;
    }
#line 4186
    if (*(*(args + i) + 0)) {
      {
#line 4187
      __cil_tmp851 = strlen((char const   *)*(args + i));
#line 4187
      Colonfin(*(args + i), (int )__cil_tmp851, (char *)0);
      }
    }
    {
#line 4188
    free((void *)*(args + i));
    }
  }
  while_break___61: /* CIL Label */ ;
  }
  {
#line 4184
  i ++;
#line 4190
  free((void *)args);
  }
#line 4191
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 4193
  __cil_tmp853 = ParseSwitch(act, & use_altscreen);
  }
#line 4194
  if (msgok) {
#line 4195
    if (! act->quiet) {
#line 4195
      tmp___660 = Msg;
    } else {
#line 4195
      if (queryflag >= 0) {
#line 4195
        tmp___659 = QueryMsg;
      } else {
#line 4195
        tmp___659 = Dummy;
      }
#line 4195
      tmp___660 = tmp___659;
    }
#line 4195
    if (use_altscreen) {
#line 4195
      tmp___661 = (char *)"";
    } else {
#line 4195
      tmp___661 = (char *)"not ";
    }
    {
#line 4195
    tmp___660(0, (char const   *)((char *)"Will %sdo alternate screen switching"),
              tmp___661);
    }
  }
#line 4196
  goto switch_break;
  case_109: /* CIL Label */ 
#line 4198
  if (! *(args + 0)) {
#line 4200
    if (! act->quiet) {
#line 4200
      tmp___663 = Msg;
    } else {
#line 4200
      if (queryflag >= 0) {
#line 4200
        tmp___662 = QueryMsg;
      } else {
#line 4200
        tmp___662 = Dummy;
      }
#line 4200
      tmp___663 = tmp___662;
    }
    {
#line 4200
    tmp___663(0, (char const   *)((char *)"maximum windows allowed: %d"), maxwin);
    }
#line 4201
    goto switch_break;
  }
  {
#line 4203
  __cil_tmp859 = ParseNum(act, & n);
  }
#line 4203
  if (__cil_tmp859) {
#line 4204
    goto switch_break;
  }
#line 4205
  if (n < 1) {
#line 4206
    if (! act->quiet) {
#line 4206
      tmp___665 = Msg;
    } else {
#line 4206
      if (queryflag >= 0) {
#line 4206
        tmp___664 = QueryMsg;
      } else {
#line 4206
        tmp___664 = Dummy;
      }
#line 4206
      tmp___665 = tmp___664;
    }
    {
#line 4206
    tmp___665(0, (char const   *)((char *)"illegal maxwin number specified"));
    }
  } else
#line 4207
  if (n > 2048) {
#line 4208
    if (! act->quiet) {
#line 4208
      tmp___667 = Msg;
    } else {
#line 4208
      if (queryflag >= 0) {
#line 4208
        tmp___666 = QueryMsg;
      } else {
#line 4208
        tmp___666 = Dummy;
      }
#line 4208
      tmp___667 = tmp___666;
    }
    {
#line 4208
    tmp___667(0, (char const   *)((char *)"maximum 2048 windows allowed"));
    }
  } else
#line 4209
  if (n > maxwin) {
#line 4209
    if (windows) {
#line 4210
      if (! act->quiet) {
#line 4210
        tmp___669 = Msg;
      } else {
#line 4210
        if (queryflag >= 0) {
#line 4210
          tmp___668 = QueryMsg;
        } else {
#line 4210
          tmp___668 = Dummy;
        }
#line 4210
        tmp___669 = tmp___668;
      }
      {
#line 4210
      tmp___669(0, (char const   *)((char *)"may increase maxwin only when there\'s no window"));
      }
    } else {
#line 4209
      goto _L___670;
    }
  } else {
    _L___670: /* CIL Label */ 
#line 4213
    if (! windows) {
      {
#line 4215
      __cil_tmp866 = realloc((void *)wtab, (unsigned long )n * sizeof(struct win *));
#line 4215
      wtab = (struct win **)__cil_tmp866;
#line 4216
      bzero((void *)wtab, (unsigned long )n * sizeof(struct win *));
      }
    }
#line 4218
    maxwin = n;
  }
#line 4220
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 4222
  __cil_tmp867 = ParseBase(act, *args, & n, 10, (char *)"decimal");
  }
#line 4222
  if (__cil_tmp867) {
#line 4223
    goto switch_break;
  }
#line 4224
  if (! *(args + 1)) {
    {
#line 4225
    setbacktick(n, 0, 0, (char **)0);
    }
  } else {
#line 4229
    if (argc < 4) {
#line 4231
      if (! act->quiet) {
#line 4231
        tmp___672 = Msg;
      } else {
#line 4231
        if (queryflag >= 0) {
#line 4231
          tmp___671 = QueryMsg;
        } else {
#line 4231
          tmp___671 = Dummy;
        }
#line 4231
        tmp___672 = tmp___671;
      }
      {
#line 4231
      tmp___672(0, (char const   *)((char *)"%s: usage: backtick num [lifespan tick cmd args...]"),
                rc_name);
      }
#line 4232
      goto switch_break;
    }
    {
#line 4234
    __cil_tmp872 = ParseBase(act, *(args + 1), & lifespan, 10, (char *)"decimal");
    }
#line 4234
    if (__cil_tmp872) {
#line 4235
      goto switch_break;
    }
    {
#line 4236
    __cil_tmp873 = ParseBase(act, *(args + 2), & tick, 10, (char *)"decimal");
    }
#line 4236
    if (__cil_tmp873) {
#line 4237
      goto switch_break;
    }
    {
#line 4238
    __cil_tmp874 = SaveArgs(args + 3);
#line 4238
    setbacktick(n, lifespan, tick, __cil_tmp874);
    }
  }
  {
#line 4240
  WindowChanged((struct win *)0, '`');
  }
#line 4241
  goto switch_break;
  case_19: /* CIL Label */ 
#line 4244
  if (blankerprg) {
    {
#line 4246
    RunBlanker(blankerprg);
    }
#line 4247
    goto switch_break;
  }
  {
#line 4250
  ClearAll();
#line 4251
  CursorVisibility(- 1);
#line 4252
  display->d_blocked = 4;
  }
#line 4253
  goto switch_break;
  case_20: /* CIL Label */ 
#line 4256
  if (! *(args + 0)) {
#line 4258
    if (blankerprg) {
#line 4261
      p___673 = (char *)path;
#line 4262
      pp___2 = blankerprg;
      {
#line 4262
      while (1) {
        while_continue___62: /* CIL Label */ ;
#line 4262
        if (! *pp___2) {
#line 4262
          goto while_break___62;
        }
        {
#line 4263
        __cil_tmp878 = snprintf(p___673, (sizeof(path) - (unsigned long )(p___673 - (char *)path)) - 1UL,
                                (char const   *)((char *)"%s "), *pp___2);
        }
#line 4263
        p___673 += __cil_tmp878;
      }
      while_break___62: /* CIL Label */ ;
      }
#line 4262
      pp___2 ++;
#line 4264
      *(p___673 - 1) = (char )'\000';
#line 4265
      if (! act->quiet) {
#line 4265
        tmp___675 = Msg;
      } else {
#line 4265
        if (queryflag >= 0) {
#line 4265
          tmp___674 = QueryMsg;
        } else {
#line 4265
          tmp___674 = Dummy;
        }
#line 4265
        tmp___675 = tmp___674;
      }
      {
#line 4265
      tmp___675(0, (char const   *)((char *)"blankerprg: %s"), (char *)path);
      }
    } else {
#line 4268
      if (! act->quiet) {
#line 4268
        tmp___677 = Msg;
      } else {
#line 4268
        if (queryflag >= 0) {
#line 4268
          tmp___676 = QueryMsg;
        } else {
#line 4268
          tmp___676 = Dummy;
        }
#line 4268
        tmp___677 = tmp___676;
      }
      {
#line 4268
      tmp___677(0, (char const   *)((char *)"No blankerprg set."));
      }
    }
#line 4269
    goto switch_break;
  }
#line 4271
  if (blankerprg) {
#line 4274
    pp___3 = blankerprg;
    {
#line 4274
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 4274
      if (! *pp___3) {
#line 4274
        goto while_break___63;
      }
      {
#line 4275
      free((void *)*pp___3);
      }
    }
    while_break___63: /* CIL Label */ ;
    }
    {
#line 4274
    pp___3 ++;
#line 4276
    free((void *)blankerprg);
#line 4277
    blankerprg = (char **)0;
    }
  }
#line 4279
  if (*(*(args + 0) + 0)) {
    {
#line 4280
    blankerprg = SaveArgs(args);
    }
  }
#line 4281
  goto switch_break;
  case_92: /* CIL Label */ 
#line 4284
  if (*args) {
    {
#line 4286
    olddisplay___2 = display;
#line 4287
    __cil_tmp888 = strcmp((char const   *)*args, (char const   *)((char *)"off"));
    }
#line 4287
    if (! __cil_tmp888) {
#line 4288
      idletimo = 0;
    } else
#line 4289
    if (*(*(args + 0) + 0)) {
      {
#line 4290
      __cil_tmp889 = atoi((char const   *)*args);
#line 4290
      idletimo = __cil_tmp889 * 1000;
      }
    }
#line 4291
    if (argc > 1) {
      {
#line 4293
      i = FindCommnr((char const   *)*(args + 1));
      }
#line 4293
      if (i == -1) {
#line 4295
        if (! act->quiet) {
#line 4295
          tmp___679 = Msg;
        } else {
#line 4295
          if (queryflag >= 0) {
#line 4295
            tmp___678 = QueryMsg;
          } else {
#line 4295
            tmp___678 = Dummy;
          }
#line 4295
          tmp___679 = tmp___678;
        }
        {
#line 4295
        tmp___679(0, (char const   *)((char *)"%s: idle: unknown command \'%s\'"),
                  rc_name, *(args + 1));
        }
#line 4296
        goto switch_break;
      }
      {
#line 4298
      __cil_tmp893 = CheckArgNum(i, args + 2);
      }
#line 4298
      if (__cil_tmp893 < 0) {
#line 4299
        goto switch_break;
      }
      {
#line 4300
      ClearAction(& idleaction);
#line 4301
      SaveAction(& idleaction, i, args + 2, argl + 2);
      }
    }
#line 4303
    display = displays;
    {
#line 4303
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 4303
      if (! display) {
#line 4303
        goto while_break___64;
      }
      {
#line 4304
      ResetIdle();
      }
    }
    while_break___64: /* CIL Label */ ;
    }
#line 4303
    display = display->d_next;
#line 4305
    display = olddisplay___2;
  }
#line 4307
  if (msgok) {
#line 4309
    if (idletimo) {
#line 4310
      if (! act->quiet) {
#line 4310
        tmp___681 = Msg;
      } else {
#line 4310
        if (queryflag >= 0) {
#line 4310
          tmp___680 = QueryMsg;
        } else {
#line 4310
          tmp___680 = Dummy;
        }
#line 4310
        tmp___681 = tmp___680;
      }
      {
#line 4310
      tmp___681(0, (char const   *)((char *)"idle timeout %ds, %s"), idletimo / 1000,
                comms[idleaction.nr].name);
      }
    } else {
#line 4312
      if (! act->quiet) {
#line 4312
        tmp___683 = Msg;
      } else {
#line 4312
        if (queryflag >= 0) {
#line 4312
          tmp___682 = QueryMsg;
        } else {
#line 4312
          tmp___682 = Dummy;
        }
#line 4312
        tmp___683 = tmp___682;
      }
      {
#line 4312
      tmp___683(0, (char const   *)((char *)"idle off"));
      }
    }
  }
#line 4314
  goto switch_break;
  case_81: /* CIL Label */ 
#line 4316
  i = 0;
  {
#line 4316
  while (1) {
    while_continue___65: /* CIL Label */ ;
#line 4316
    if (! (i < 2 && *(args + i))) {
#line 4316
      goto while_break___65;
    }
    {
#line 4318
    __cil_tmp899 = strcmp((char const   *)*(args + i), (char const   *)((char *)"_"));
    }
    {
#line 4318
    __cil_tmp898 = strcmp((char const   *)*(args + i), (char const   *)((char *)"max"));
    }
#line 4318
    if (! __cil_tmp898) {
#line 4319
      n = - 1;
    } else
#line 4318
    if (! __cil_tmp899) {
#line 4319
      n = - 1;
    } else {
      {
#line 4321
      n = atoi((char const   *)*(args + i));
      }
    }
#line 4322
    if (i == 0) {
#line 4323
      focusminwidth = n;
    } else {
#line 4325
      focusminheight = n;
    }
  }
  while_break___65: /* CIL Label */ ;
  }
#line 4316
  i ++;
#line 4327
  if (msgok) {
#line 4330
    i = 0;
    {
#line 4330
    while (1) {
      while_continue___66: /* CIL Label */ ;
#line 4330
      if (! (i < 2)) {
#line 4330
        goto while_break___66;
      }
#line 4332
      if (i == 0) {
#line 4332
        tmp___684 = focusminwidth;
      } else {
#line 4332
        tmp___684 = focusminheight;
      }
#line 4332
      n = tmp___684;
#line 4333
      if (n == -1) {
        {
#line 4334
        strcpy((char *)b[i], (char const   *)((char *)"max"));
        }
      } else {
        {
#line 4336
        sprintf((char *)b[i], (char const   *)((char *)"%d"), n);
        }
      }
    }
    while_break___66: /* CIL Label */ ;
    }
#line 4330
    i ++;
#line 4338
    if (! act->quiet) {
#line 4338
      tmp___686 = Msg;
    } else {
#line 4338
      if (queryflag >= 0) {
#line 4338
        tmp___685 = QueryMsg;
      } else {
#line 4338
        tmp___685 = Dummy;
      }
#line 4338
      tmp___686 = tmp___685;
    }
    {
#line 4338
    tmp___686(0, (char const   *)((char *)"focus min size is %s %s\n"), (char *)b[0],
              (char *)b[1]);
    }
  }
#line 4340
  goto switch_break;
  case_83: /* CIL Label */ 
#line 4342
  if (*args) {
#line 4344
    fore->w_group = (struct win *)0;
#line 4345
    if (*(*(args + 0) + 0)) {
      {
#line 4347
      fore->w_group = WindowByName(*args);
      }
#line 4348
      if (fore->w_group == fore) {
#line 4349
        fore->w_group = (struct win *)0;
      } else
#line 4348
      if (fore->w_group) {
#line 4348
        if ((fore->w_group)->w_type != 3) {
#line 4349
          fore->w_group = (struct win *)0;
        }
      }
    }
    {
#line 4351
    WindowChanged((struct win *)0, 'w');
#line 4352
    WindowChanged((struct win *)0, 'W');
#line 4353
    WindowChanged((struct win *)0, 0);
    }
  }
#line 4355
  if (msgok) {
#line 4357
    if (fore->w_group) {
#line 4358
      if (! act->quiet) {
#line 4358
        tmp___688 = Msg;
      } else {
#line 4358
        if (queryflag >= 0) {
#line 4358
          tmp___687 = QueryMsg;
        } else {
#line 4358
          tmp___687 = Dummy;
        }
#line 4358
        tmp___688 = tmp___687;
      }
      {
#line 4358
      tmp___688(0, (char const   *)((char *)"window group is %d (%s)\n"), (fore->w_group)->w_number,
                (fore->w_group)->w_title);
      }
    } else {
#line 4360
      if (! act->quiet) {
#line 4360
        tmp___690 = Msg;
      } else {
#line 4360
        if (queryflag >= 0) {
#line 4360
          tmp___689 = QueryMsg;
        } else {
#line 4360
          tmp___689 = Dummy;
        }
#line 4360
        tmp___690 = tmp___689;
      }
      {
#line 4360
      tmp___690(0, (char const   *)((char *)"window belongs to no group"));
      }
    }
  }
#line 4362
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 4367
  __cil_tmp912 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"title"));
  }
#line 4367
  if (! __cil_tmp912) {
#line 4369
    if (! display) {
#line 4371
      if (! *(args + 1)) {
#line 4372
        goto switch_break;
      }
#line 4373
      if (! layout_attach) {
        {
        {
#line 4374
        layout_attach = CreateLayout(*(args + 1), 0);
        }
        }
      } else
#line 4373
      if (layout_attach == & layout_last_marker) {
        {
        {
#line 4374
        layout_attach = CreateLayout(*(args + 1), 0);
        }
        }
      } else {
        {
#line 4376
        RenameLayout(layout_attach, (char const   *)*(args + 1));
        }
      }
#line 4377
      goto switch_break;
    }
#line 4380
    if (! display->d_layout) {
#line 4382
      if (! act->quiet) {
#line 4382
        tmp___692 = Msg;
      } else {
#line 4382
        if (queryflag >= 0) {
#line 4382
          tmp___691 = QueryMsg;
        } else {
#line 4382
          tmp___691 = Dummy;
        }
#line 4382
        tmp___692 = tmp___691;
      }
      {
#line 4382
      tmp___692(0, (char const   *)((char *)"not on a layout"));
      }
#line 4383
      goto switch_break;
    }
#line 4385
    if (! *(args + 1)) {
#line 4387
      if (! act->quiet) {
#line 4387
        tmp___694 = Msg;
      } else {
#line 4387
        if (queryflag >= 0) {
#line 4387
          tmp___693 = QueryMsg;
        } else {
#line 4387
          tmp___693 = Dummy;
        }
#line 4387
        tmp___694 = tmp___693;
      }
      {
#line 4387
      tmp___694(0, (char const   *)((char *)"current layout is %d (%s)"), (display->d_layout)->lay_number,
                (display->d_layout)->lay_title);
      }
#line 4388
      goto switch_break;
    }
    {
#line 4390
    RenameLayout(display->d_layout, (char const   *)*(args + 1));
    }
  } else {
    {
#line 4392
    __cil_tmp918 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"number"));
    }
#line 4392
    if (! __cil_tmp918) {
#line 4394
      if (! display) {
#line 4396
        if (*(args + 1)) {
#line 4396
          if (layout_attach) {
#line 4396
            if (layout_attach != & layout_last_marker) {
              {
#line 4397
              __cil_tmp919 = atoi((char const   *)*(args + 1));
#line 4397
              RenumberLayout(layout_attach, __cil_tmp919);
              }
            }
          }
        }
#line 4398
        goto switch_break;
      }
#line 4401
      if (! display->d_layout) {
#line 4403
        if (! act->quiet) {
#line 4403
          tmp___696 = Msg;
        } else {
#line 4403
          if (queryflag >= 0) {
#line 4403
            tmp___695 = QueryMsg;
          } else {
#line 4403
            tmp___695 = Dummy;
          }
#line 4403
          tmp___696 = tmp___695;
        }
        {
#line 4403
        tmp___696(0, (char const   *)((char *)"not on a layout"));
        }
#line 4404
        goto switch_break;
      }
#line 4406
      if (! *(args + 1)) {
#line 4408
        if (! act->quiet) {
#line 4408
          tmp___698 = Msg;
        } else {
#line 4408
          if (queryflag >= 0) {
#line 4408
            tmp___697 = QueryMsg;
          } else {
#line 4408
            tmp___697 = Dummy;
          }
#line 4408
          tmp___698 = tmp___697;
        }
        {
#line 4408
        tmp___698(0, (char const   *)((char *)"This is layout %d (%s).\n"), (display->d_layout)->lay_number,
                  (display->d_layout)->lay_title);
        }
#line 4409
        goto switch_break;
      }
      {
#line 4411
      __cil_tmp924 = atoi((char const   *)*(args + 1));
#line 4411
      RenumberLayout(display->d_layout, __cil_tmp924);
      }
#line 4412
      goto switch_break;
    } else {
      {
#line 4414
      __cil_tmp925 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"autosave"));
      }
#line 4414
      if (! __cil_tmp925) {
#line 4416
        if (! display) {
#line 4418
          if (*(args + 1)) {
#line 4418
            if (layout_attach) {
#line 4418
              if (layout_attach != & layout_last_marker) {
                {
#line 4420
                __cil_tmp926 = strcmp((char const   *)*(args + 1), (char const   *)((char *)"on"));
                }
#line 4420
                if (! __cil_tmp926) {
#line 4421
                  layout_attach->lay_autosave = 1;
                } else {
                  {
#line 4422
                  __cil_tmp927 = strcmp((char const   *)*(args + 1), (char const   *)((char *)"off"));
                  }
#line 4422
                  if (! __cil_tmp927) {
#line 4423
                    layout_attach->lay_autosave = 0;
                  }
                }
              }
            }
          }
#line 4425
          goto switch_break;
        }
#line 4428
        if (! display->d_layout) {
#line 4430
          if (! act->quiet) {
#line 4430
            tmp___700 = Msg;
          } else {
#line 4430
            if (queryflag >= 0) {
#line 4430
              tmp___699 = QueryMsg;
            } else {
#line 4430
              tmp___699 = Dummy;
            }
#line 4430
            tmp___700 = tmp___699;
          }
          {
#line 4430
          tmp___700(0, (char const   *)((char *)"not on a layout"));
          }
#line 4431
          goto switch_break;
        }
#line 4433
        if (*(args + 1)) {
          {
#line 4435
          __cil_tmp930 = strcmp((char const   *)*(args + 1), (char const   *)((char *)"on"));
          }
#line 4435
          if (! __cil_tmp930) {
#line 4436
            (display->d_layout)->lay_autosave = 1;
          } else {
            {
#line 4437
            __cil_tmp931 = strcmp((char const   *)*(args + 1), (char const   *)((char *)"off"));
            }
#line 4437
            if (! __cil_tmp931) {
#line 4438
              (display->d_layout)->lay_autosave = 0;
            } else {
#line 4441
              if (! act->quiet) {
#line 4441
                tmp___702 = Msg;
              } else {
#line 4441
                if (queryflag >= 0) {
#line 4441
                  tmp___701 = QueryMsg;
                } else {
#line 4441
                  tmp___701 = Dummy;
                }
#line 4441
                tmp___702 = tmp___701;
              }
              {
#line 4441
              tmp___702(0, (char const   *)((char *)"invalid argument. Give \'on\' or \'off"));
              }
#line 4442
              goto switch_break;
            }
          }
        }
#line 4445
        if (msgok) {
#line 4446
          if (! act->quiet) {
#line 4446
            tmp___704 = Msg;
          } else {
#line 4446
            if (queryflag >= 0) {
#line 4446
              tmp___703 = QueryMsg;
            } else {
#line 4446
              tmp___703 = Dummy;
            }
#line 4446
            tmp___704 = tmp___703;
          }
#line 4446
          if ((display->d_layout)->lay_autosave) {
#line 4446
            tmp___705 = (char *)"on";
          } else {
#line 4446
            tmp___705 = (char *)"off";
          }
          {
#line 4446
          tmp___704(0, (char const   *)((char *)"autosave is %s"), tmp___705);
          }
        }
      } else {
        {
#line 4448
        __cil_tmp937 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"new"));
        }
#line 4448
        if (! __cil_tmp937) {
#line 4450
          t___0 = *(args + 1);
#line 4451
          n = 0;
#line 4452
          if (t___0) {
            {
#line 4454
            while (1) {
              while_continue___67: /* CIL Label */ ;
#line 4454
              if (! ((int )*t___0 >= 48 && (int )*t___0 <= 57)) {
#line 4454
                goto while_break___67;
              }
#line 4455
              t___0 ++;
            }
            while_break___67: /* CIL Label */ ;
            }
#line 4456
            if (t___0 != *(args + 1)) {
#line 4456
              if (! *t___0) {
                _L___706: /* CIL Label */ 
                {
#line 4458
                n = atoi((char const   *)*(args + 1));
                }
#line 4459
                if (*t___0) {
#line 4460
                  t___0 ++;
                }
              } else
#line 4456
              if ((int )*t___0 == 58) {
#line 4456
                goto _L___706;
              } else {
#line 4463
                t___0 = *(args + 1);
              }
            } else {
#line 4463
              t___0 = *(args + 1);
            }
          }
#line 4465
          if (! t___0) {
#line 4466
            t___0 = (char *)"layout";
          } else
#line 4465
          if (! *t___0) {
#line 4466
            t___0 = (char *)"layout";
          }
          {
#line 4467
          NewLayout(t___0, n);
#line 4468
          Activate(- 1);
          }
        } else {
          {
#line 4470
          __cil_tmp942 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"save"));
          }
#line 4470
          if (! __cil_tmp942) {
#line 4472
            if (! *(args + 1)) {
#line 4474
              if (! act->quiet) {
#line 4474
                tmp___708 = Msg;
              } else {
#line 4474
                if (queryflag >= 0) {
#line 4474
                  tmp___707 = QueryMsg;
                } else {
#line 4474
                  tmp___707 = Dummy;
                }
#line 4474
                tmp___708 = tmp___707;
              }
              {
#line 4474
              tmp___708(0, (char const   *)((char *)"usage: layout save <name>"));
              }
#line 4475
              goto switch_break;
            }
#line 4477
            if (display) {
              {
#line 4478
              SaveLayout(*(args + 1), & display->d_canvas);
              }
            }
          } else {
            {
#line 4480
            __cil_tmp945 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"select"));
            }
#line 4480
            if (! __cil_tmp945) {
#line 4482
              if (! display) {
#line 4484
                if (*(args + 1)) {
                  {
#line 4485
                  layout_attach = FindLayout(*(args + 1));
                  }
                }
#line 4486
                goto switch_break;
              }
#line 4488
              if (! *(args + 1)) {
                {
#line 4490
                Input((char *)"Switch to layout: ", 20, 0, SelectLayoutFin, (char *)((void *)0),
                      0);
                }
#line 4491
                goto switch_break;
              }
              {
#line 4493
              __cil_tmp947 = strlen((char const   *)*(args + 1));
#line 4493
              SelectLayoutFin(*(args + 1), (int )__cil_tmp947, (char *)0);
              }
            } else {
              {
#line 4495
              __cil_tmp948 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"next"));
              }
#line 4495
              if (! __cil_tmp948) {
#line 4497
                if (! display) {
#line 4499
                  if (layout_attach) {
#line 4499
                    if (layout_attach != & layout_last_marker) {
#line 4500
                      if (layout_attach->lay_next) {
#line 4500
                        tmp___709 = layout_attach->lay_next;
                      } else {
#line 4500
                        tmp___709 = layouts;
                      }
#line 4500
                      layout_attach = tmp___709;
                    }
                  }

#line 4501
                  goto switch_break;
                }
#line 4503
                lay = display->d_layout;
#line 4504
                if (lay) {
#line 4505
                  if (lay->lay_next) {
#line 4505
                    tmp___710 = lay->lay_next;
                  } else {
#line 4505
                    tmp___710 = layouts;
                  }
#line 4505
                  lay = tmp___710;
                } else {
#line 4507
                  lay = layouts;
                }
#line 4508
                if (! lay) {
#line 4510
                  if (! act->quiet) {
#line 4510
                    tmp___712 = Msg;
                  } else {
#line 4510
                    if (queryflag >= 0) {
#line 4510
                      tmp___711 = QueryMsg;
                    } else {
#line 4510
                      tmp___711 = Dummy;
                    }
#line 4510
                    tmp___712 = tmp___711;
                  }
                  {
#line 4510
                  tmp___712(0, (char const   *)((char *)"no layout defined"));
                  }
#line 4511
                  goto switch_break;
                }
#line 4513
                if (lay == display->d_layout) {
#line 4514
                  goto switch_break;
                }
                {
#line 4515
                LoadLayout(lay, & display->d_canvas);
#line 4516
                Activate(- 1);
                }
              } else {
                {
#line 4518
                __cil_tmp954 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"prev"));
                }
#line 4518
                if (! __cil_tmp954) {
#line 4520
                  if (display) {
#line 4520
                    tmp___713 = display->d_layout;
                  } else {
#line 4520
                    tmp___713 = layout_attach;
                  }
#line 4520
                  lay___0 = tmp___713;
#line 4521
                  target = lay___0;
#line 4522
                  if (lay___0) {
#line 4524
                    lay___0 = layouts;
                    {
#line 4524
                    while (1) {
                      while_continue___68: /* CIL Label */ ;
#line 4524
                      if (! (lay___0->lay_next && lay___0->lay_next != target)) {
#line 4524
                        goto while_break___68;
                      }

                    }
                    while_break___68: /* CIL Label */ ;
                    }
#line 4524
                    lay___0 = lay___0->lay_next;
                  } else {
#line 4528
                    lay___0 = layouts;
                  }
#line 4530
                  if (! display) {
#line 4532
                    layout_attach = lay___0;
#line 4533
                    goto switch_break;
                  }
#line 4536
                  if (! lay___0) {
#line 4538
                    if (! act->quiet) {
#line 4538
                      tmp___715 = Msg;
                    } else {
#line 4538
                      if (queryflag >= 0) {
#line 4538
                        tmp___714 = QueryMsg;
                      } else {
#line 4538
                        tmp___714 = Dummy;
                      }
#line 4538
                      tmp___715 = tmp___714;
                    }
                    {
#line 4538
                    tmp___715(0, (char const   *)((char *)"no layout defined"));
                    }
#line 4539
                    goto switch_break;
                  }
#line 4541
                  if (lay___0 == display->d_layout) {
#line 4542
                    goto switch_break;
                  }
                  {
#line 4543
                  LoadLayout(lay___0, & display->d_canvas);
#line 4544
                  Activate(- 1);
                  }
                } else {
                  {
#line 4546
                  __cil_tmp960 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"attach"));
                  }
#line 4546
                  if (! __cil_tmp960) {
#line 4548
                    if (! *(args + 1)) {
#line 4550
                      if (! layout_attach) {
#line 4551
                        if (! act->quiet) {
#line 4551
                          tmp___717 = Msg;
                        } else {
#line 4551
                          if (queryflag >= 0) {
#line 4551
                            tmp___716 = QueryMsg;
                          } else {
#line 4551
                            tmp___716 = Dummy;
                          }
#line 4551
                          tmp___717 = tmp___716;
                        }
                        {
#line 4551
                        tmp___717(0, (char const   *)((char *)"no attach layout set"));
                        }
                      } else
#line 4552
                      if (layout_attach == & layout_last_marker) {
#line 4553
                        if (! act->quiet) {
#line 4553
                          tmp___719 = Msg;
                        } else {
#line 4553
                          if (queryflag >= 0) {
#line 4553
                            tmp___718 = QueryMsg;
                          } else {
#line 4553
                            tmp___718 = Dummy;
                          }
#line 4553
                          tmp___719 = tmp___718;
                        }
                        {
#line 4553
                        tmp___719(0, (char const   *)((char *)"will attach to last layout"));
                        }
                      } else {
#line 4555
                        if (! act->quiet) {
#line 4555
                          tmp___721 = Msg;
                        } else {
#line 4555
                          if (queryflag >= 0) {
#line 4555
                            tmp___720 = QueryMsg;
                          } else {
#line 4555
                            tmp___720 = Dummy;
                          }
#line 4555
                          tmp___721 = tmp___720;
                        }
                        {
#line 4555
                        tmp___721(0, (char const   *)((char *)"will attach to layout %d (%s)"),
                                  layout_attach->lay_number, layout_attach->lay_title);
                        }
                      }
#line 4556
                      goto switch_break;
                    }
                    {
#line 4558
                    __cil_tmp967 = strcmp((char const   *)*(args + 1), (char const   *)((char *)":last"));
                    }
#line 4558
                    if (! __cil_tmp967) {
#line 4559
                      layout_attach = & layout_last_marker;
                    } else
#line 4560
                    if (! *(*(args + 1) + 0)) {
#line 4561
                      layout_attach = (struct layout *)0;
                    } else {
                      {
#line 4565
                      lay___1 = FindLayout(*(args + 1));
                      }
#line 4566
                      if (! lay___1) {
#line 4568
                        if (! act->quiet) {
#line 4568
                          tmp___723 = Msg;
                        } else {
#line 4568
                          if (queryflag >= 0) {
#line 4568
                            tmp___722 = QueryMsg;
                          } else {
#line 4568
                            tmp___722 = Dummy;
                          }
#line 4568
                          tmp___723 = tmp___722;
                        }
                        {
#line 4568
                        tmp___723(0, (char const   *)((char *)"unknown layout \'%s\'"),
                                  *(args + 1));
                        }
#line 4569
                        goto switch_break;
                      }
#line 4571
                      layout_attach = lay___1;
                    }
                  } else {
                    {
#line 4574
                    __cil_tmp972 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"show"));
                    }
#line 4574
                    if (! __cil_tmp972) {
                      {
#line 4576
                      ShowLayouts(- 1);
                      }
                    } else {
                      {
#line 4578
                      __cil_tmp973 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"remove"));
                      }
#line 4578
                      if (! __cil_tmp973) {
#line 4580
                        if (display) {
#line 4580
                          tmp___724 = display->d_layout;
                        } else {
#line 4580
                          tmp___724 = layouts;
                        }
#line 4580
                        lay___2 = tmp___724;
#line 4581
                        if (*(args + 1)) {
#line 4583
                          if (layouts) {
                            {
#line 4583
                            __cil_tmp976 = FindLayout(*(args + 1));
#line 4583
                            tmp___725 = __cil_tmp976;
                            }
                          } else {
#line 4583
                            tmp___725 = (struct layout *)0;
                          }
#line 4583
                          lay___2 = tmp___725;
#line 4584
                          if (! lay___2) {
#line 4586
                            if (! act->quiet) {
#line 4586
                              tmp___727 = Msg;
                            } else {
#line 4586
                              if (queryflag >= 0) {
#line 4586
                                tmp___726 = QueryMsg;
                              } else {
#line 4586
                                tmp___726 = Dummy;
                              }
#line 4586
                              tmp___727 = tmp___726;
                            }
                            {
#line 4586
                            tmp___727(0, (char const   *)((char *)"unknown layout \'%s\'"),
                                      *(args + 1));
                            }
#line 4587
                            goto switch_break;
                          }
                        }
#line 4590
                        if (lay___2) {
                          {
#line 4591
                          RemoveLayout(lay___2);
                          }
                        }
                      } else {
                        {
#line 4593
                        __cil_tmp980 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"dump"));
                        }
#line 4593
                        if (! __cil_tmp980) {
#line 4595
                          if (! display) {
#line 4596
                            if (! act->quiet) {
#line 4596
                              tmp___729 = Msg;
                            } else {
#line 4596
                              if (queryflag >= 0) {
#line 4596
                                tmp___728 = QueryMsg;
                              } else {
#line 4596
                                tmp___728 = Dummy;
                              }
#line 4596
                              tmp___729 = tmp___728;
                            }
                            {
#line 4596
                            tmp___729(0, (char const   *)((char *)"Must have a display for \'layout dump\'."));
                            }
                          } else {
#line 4597
                            if (*(args + 1)) {
#line 4597
                              tmp___730 = *(args + 1);
                            } else {
#line 4597
                              tmp___730 = (char *)"layout-dump";
                            }
                            {
#line 4597
                            __cil_tmp984 = LayoutDumpCanvas(& display->d_canvas, tmp___730);
                            }
#line 4597
                            if (! __cil_tmp984) {
#line 4598
                              if (! act->quiet) {
#line 4598
                                tmp___732 = Msg;
                              } else {
#line 4598
                                if (queryflag >= 0) {
#line 4598
                                  tmp___731 = QueryMsg;
                                } else {
#line 4598
                                  tmp___731 = Dummy;
                                }
#line 4598
                                tmp___732 = tmp___731;
                              }
                              {
#line 4598
                              __cil_tmp987 = __errno_location();
#line 4598
                              tmp___732(*__cil_tmp987, (char const   *)((char *)"Error dumping layout."));
                              }
                            } else {
#line 4600
                              if (! act->quiet) {
#line 4600
                                tmp___734 = Msg;
                              } else {
#line 4600
                                if (queryflag >= 0) {
#line 4600
                                  tmp___733 = QueryMsg;
                                } else {
#line 4600
                                  tmp___733 = Dummy;
                                }
#line 4600
                                tmp___734 = tmp___733;
                              }
#line 4600
                              if (*(args + 1)) {
#line 4600
                                tmp___735 = *(args + 1);
                              } else {
#line 4600
                                tmp___735 = (char *)"layout-dump";
                              }
                              {
#line 4600
                              tmp___734(0, (char const   *)((char *)"Layout dumped to \"%s\""),
                                        tmp___735);
                              }
                            }
                          }
                        } else {
#line 4603
                          if (! act->quiet) {
#line 4603
                            tmp___737 = Msg;
                          } else {
#line 4603
                            if (queryflag >= 0) {
#line 4603
                              tmp___736 = QueryMsg;
                            } else {
#line 4603
                              tmp___736 = Dummy;
                            }
#line 4603
                            tmp___737 = tmp___736;
                          }
                          {
#line 4603
                          tmp___737(0, (char const   *)((char *)"unknown layout subcommand"));
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 4604
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 4607
  __cil_tmp993 = ParseSwitch(act, & cjkwidth);
  }
#line 4607
  if (__cil_tmp993 == 0) {
#line 4609
    if (msgok) {
#line 4610
      if (! act->quiet) {
#line 4610
        tmp___739 = Msg;
      } else {
#line 4610
        if (queryflag >= 0) {
#line 4610
          tmp___738 = QueryMsg;
        } else {
#line 4610
          tmp___738 = Dummy;
        }
#line 4610
        tmp___739 = tmp___738;
      }
#line 4610
      if (cjkwidth) {
#line 4610
        tmp___740 = (char *)"full";
      } else {
#line 4610
        tmp___740 = (char *)"half";
      }
      {
#line 4610
      tmp___739(0, (char const   *)((char *)"Treat ambiguous width characters as %s width"),
                tmp___740);
      }
    }
  }
#line 4612
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 4619
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4621
  if (display != odisplay) {
#line 4623
    display = displays;
    {
#line 4623
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 4623
      if (! display) {
#line 4623
        goto while_break___69;
      }
#line 4624
      if (display == odisplay) {
#line 4625
        goto while_break___69;
      }
    }
    while_break___69: /* CIL Label */ ;
    }
#line 4623
    display = display->d_next;
  }
  return;
}
}
#line 4631 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void CollapseWindowlist(void) 
{ 
  int pos ;
  int moveto ;

  {
#line 4634
  moveto = 0;
#line 4636
  pos = 1;
  {
#line 4636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4636
    if (! (pos < 100)) {
#line 4636
      goto while_break;
    }
#line 4637
    if (*(wtab + pos)) {
      {
#line 4638
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4638
        if (! (moveto < pos)) {
#line 4638
          goto while_break___0;
        }
#line 4639
        if (! *(wtab + moveto)) {
          {
#line 4641
          WindowChangeNumber(pos, moveto);
          }
#line 4642
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4638
      moveto ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4636
  pos ++;
  return;
}
}
#line 4647 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void DoCommand(char **argv , int *argl ) 
{ 
  struct action act ;
  char const   *cmd ;

  {
#line 4652
  cmd = (char const   *)*argv;
#line 4654
  act.quiet = 0;
#line 4658
  if ((int )((char )*cmd) == 64) {
#line 4660
    act.quiet |= 1;
#line 4661
    cmd ++;
  }
#line 4663
  if ((int )((char )*cmd) == 45) {
#line 4665
    act.quiet |= 2;
#line 4666
    cmd ++;
  }
  {
#line 4669
  act.nr = FindCommnr(cmd);
  }
#line 4669
  if (act.nr == -1) {
    {
#line 4671
    Msg(0, (char const   *)((char *)"%s: unknown command \'%s\'"), rc_name, cmd);
    }
#line 4672
    return;
  }
  {
#line 4674
  act.args = argv + 1;
#line 4675
  act.argl = argl + 1;
#line 4676
  DoAction(& act, - 1);
  }
  return;
}
}
#line 4680 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void SaveAction(struct action *act , int nr , char **args , int *argl ) 
{ 
  register int argc ;
  char **pp ;
  int *lp ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;
  size_t __cil_tmp13 ;
  int tmp ;
  char **__cil_tmp15 ;
  char **__cil_tmp16 ;
  int *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 4686
  argc = 0;
#line 4690
  if (args) {
    {
#line 4691
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4691
      if (! *(args + argc)) {
#line 4691
        goto while_break;
      }
#line 4692
      argc ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 4693
  if (argc == 0) {
#line 4695
    act->nr = nr;
#line 4696
    act->args = (char **)noargs;
#line 4697
    act->argl = (int *)0;
#line 4698
    return;
  }
  {
#line 4700
  __cil_tmp9 = malloc((unsigned long )((unsigned int )(argc + 1)) * sizeof(char *));
#line 4700
  pp = (char **)__cil_tmp9;
  }
#line 4700
  if (pp == (char **)0) {
    {
#line 4701
    Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
  }
  {
#line 4702
  __cil_tmp10 = malloc((unsigned long )((unsigned int )argc) * sizeof(int ));
#line 4702
  lp = (int *)__cil_tmp10;
  }
#line 4702
  if (lp == (int *)0) {
    {
#line 4703
    Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
  }
#line 4704
  act->nr = nr;
#line 4705
  act->args = pp;
#line 4706
  act->argl = lp;
  {
#line 4707
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4707
    if (! __cil_tmp11) {
#line 4707
      goto while_break___0;
    }
#line 4709
    if (argl) {
#line 4709
      argl ++;
#line 4709
      tmp = *argl;
    } else {
      {
#line 4709
      __cil_tmp13 = strlen((char const   *)*args);
#line 4709
      tmp = (int )__cil_tmp13;
      }
    }
#line 4709
    *lp = tmp;
#line 4710
    __cil_tmp16 = args;
#line 4710
    args ++;
    {
#line 4710
    __cil_tmp17 = lp;
#line 4710
    lp ++;
#line 4710
    __cil_tmp18 = SaveStrn((char const   *)*__cil_tmp16, *__cil_tmp17);
    }
#line 4710
    __cil_tmp15 = pp;
#line 4710
    pp ++;
#line 4710
    *__cil_tmp15 = __cil_tmp18;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4712
  *pp = (char *)0;
  return;
}
}
#line 4716 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static char **SaveArgs(char **args ) 
{ 
  register char **ap ;
  register char **pp ;
  register int argc ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;
  char **__cil_tmp8 ;
  char **__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 4720
  argc = 0;
  {
#line 4722
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4722
    if (! *(args + argc)) {
#line 4722
      goto while_break;
    }
#line 4723
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4724
  __cil_tmp6 = malloc((unsigned long )((unsigned int )(argc + 1)) * sizeof(char **));
#line 4724
  ap = (char **)__cil_tmp6;
#line 4724
  pp = ap;
  }
#line 4724
  if (pp == (char **)0) {
    {
#line 4725
    Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
  }
  {
#line 4726
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4726
    if (! __cil_tmp7) {
#line 4726
      goto while_break___0;
    }
    {
#line 4727
    __cil_tmp9 = args;
#line 4727
    args ++;
#line 4727
    __cil_tmp10 = SaveStr((char const   *)*__cil_tmp9);
    }
#line 4727
    __cil_tmp8 = pp;
#line 4727
    pp ++;
#line 4727
    *__cil_tmp8 = __cil_tmp10;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4728
  *pp = (char *)0;
#line 4729
  return (ap);
}
}
#line 4743 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int Parse(char *buf , int bufl , char **args , int *argl ) 
{ 
  register char *p ;
  register char **ap ;
  register char *pp ;
  register int delim ;
  register int argc ;
  int *lp ;
  char **__cil_tmp11 ;
  int *__cil_tmp12 ;
  char **__cil_tmp16 ;
  char *ps ;
  char *pe ;
  char op ;
  char *v ;
  char xbuf[11] ;
  char path[4096] ;
  int vl ;
  int __cil_tmp34 ;
  char *tmp ;
  int __cil_tmp36 ;
  int tmp___747 ;
  int __cil_tmp38 ;
  int tmp___748 ;
  int __cil_tmp40 ;
  __pid_t __cil_tmp41 ;
  int __cil_tmp42 ;
  char *__cil_tmp43 ;
  int __cil_tmp44 ;
  size_t __cil_tmp48 ;
  size_t tmp___749 ;
  int right ;
  size_t __cil_tmp51 ;
  size_t __cil_tmp52 ;
  char *__cil_tmp54 ;
  int tmp___750 ;
  char *__cil_tmp56 ;
  int *__cil_tmp59 ;

  {
#line 4747
  p = buf;
#line 4747
  ap = args;
#line 4749
  lp = argl;
  {
#line 4751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4751
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 4752
  argc = 0;
#line 4753
  pp = buf;
#line 4754
  delim = 0;
  {
#line 4755
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4755
    if (! 1) {
#line 4755
      goto while_break___0;
    }
#line 4757
    *lp = 0;
    {
#line 4758
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4758
      if (! ((int )*p && ((int )*p == 32 || (int )*p == 9))) {
#line 4758
        goto while_break___1;
      }
#line 4759
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4761
    if (argc == 0) {
#line 4761
      if ((int )*p == 33) {
#line 4763
        __cil_tmp11 = ap;
#line 4763
        ap ++;
#line 4763
        *__cil_tmp11 = (char *)"exec";
#line 4764
        __cil_tmp12 = lp;
#line 4764
        lp ++;
#line 4764
        *__cil_tmp12 = 4;
#line 4765
        p ++;
#line 4766
        argc ++;
#line 4767
        goto while_continue___0;
      }
    }
#line 4770
    if ((int )*p == 0) {
      _L: /* CIL Label */ 
#line 4772
      *p = (char )'\000';
#line 4773
      delim = 0;
      {
#line 4773
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 4773
        if (! (delim < argc)) {
#line 4773
          goto while_break___2;
        }
        {
#line 4774
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4774
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 4773
      delim ++;
#line 4775
      *(args + argc) = (char *)0;
#line 4776
      return (argc);
    } else
#line 4770
    if ((int )*p == 35) {
#line 4770
      goto _L;
    } else
#line 4770
    if ((int )*p == 10) {
#line 4770
      goto _L;
    }
#line 4778
    argc ++;
#line 4778
    if (argc >= 64) {
      {
#line 4780
      Msg(0, (char const   *)((char *)"%s: too many tokens."), rc_name);
      }
#line 4781
      return (0);
    }
#line 4783
    __cil_tmp16 = ap;
#line 4783
    ap ++;
#line 4783
    *__cil_tmp16 = pp;
    {
#line 4785
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 4785
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 4786
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 4786
      if (! *p) {
#line 4786
        goto while_break___5;
      }
#line 4788
      if ((int )*p == delim) {
#line 4789
        delim = 0;
      } else
#line 4790
      if (delim != 39) {
#line 4790
        if ((int )*p == 92) {
#line 4790
          if ((int )*(p + 1) == 110) {
            _L___763: /* CIL Label */ 
#line 4792
            p ++;
#line 4793
            if ((int )*p >= 48) {
#line 4793
              if ((int )*p <= 55) {
#line 4795
                *pp = (char )((int )*p - 48);
#line 4796
                if ((int )*(p + 1) >= 48) {
#line 4796
                  if ((int )*(p + 1) <= 55) {
#line 4798
                    p ++;
#line 4799
                    *pp = (char )(((int )*pp << 3) | ((int )*p - 48));
#line 4800
                    if ((int )*(p + 1) >= 48) {
#line 4800
                      if ((int )*(p + 1) <= 55) {
#line 4802
                        p ++;
#line 4803
                        *pp = (char )(((int )*pp << 3) | ((int )*p - 48));
                      }
                    }
                  }
                }
#line 4806
                pp ++;
              } else {
#line 4793
                goto _L___742;
              }
            } else {
              _L___742: /* CIL Label */ 
              {
#line 4812
              if ((int )*p == 'n') {
#line 4812
                goto case_110;
              }
#line 4813
              if ((int )*p == 'r') {
#line 4813
                goto case_114;
              }
#line 4814
              if ((int )*p == 't') {
#line 4814
                goto case_116;
              }
#line 4815
              goto switch_default;
              case_110: /* CIL Label */ 
#line 4812
              *pp = (char )'\n';
#line 4812
              goto switch_break;
              case_114: /* CIL Label */ 
#line 4813
              *pp = (char )'\r';
#line 4813
              goto switch_break;
              case_116: /* CIL Label */ 
#line 4814
              *pp = (char )'\t';
#line 4814
              goto switch_break;
              switch_default: /* CIL Label */ 
#line 4815
              *pp = *p;
#line 4815
              goto switch_break;
              switch_break: /* CIL Label */ ;
              }
#line 4817
              pp ++;
            }
          } else
#line 4790
          if ((int )*(p + 1) == 114) {
#line 4790
            goto _L___763;
          } else
#line 4790
          if ((int )*(p + 1) == 116) {
#line 4790
            goto _L___763;
          } else
#line 4790
          if ((int )*(p + 1) == 39) {
#line 4790
            goto _L___763;
          } else
#line 4790
          if ((int )*(p + 1) == 34) {
#line 4790
            goto _L___763;
          } else
#line 4790
          if ((int )*(p + 1) == 92) {
#line 4790
            goto _L___763;
          } else
#line 4790
          if ((int )*(p + 1) == 36) {
#line 4790
            goto _L___763;
          } else
#line 4790
          if ((int )*(p + 1) == 35) {
#line 4790
            goto _L___763;
          } else
#line 4790
          if ((int )*(p + 1) == 94) {
#line 4790
            goto _L___763;
          } else
#line 4790
          if ((int )*(p + 1) >= 48) {
#line 4790
            if ((int )*(p + 1) <= 55) {
#line 4790
              goto _L___763;
            } else {
#line 4790
              goto _L___762;
            }
          } else {
#line 4790
            goto _L___762;
          }
        } else {
#line 4790
          goto _L___762;
        }
      } else
      _L___762: /* CIL Label */ 
#line 4820
      if (delim != 39) {
#line 4820
        if ((int )*p == 36) {
#line 4820
          if ((int )*(p + 1) == 123) {
            _L___753: /* CIL Label */ 
#line 4826
            p ++;
#line 4826
            ps = p;
            {
#line 4827
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 4827
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 4828
            p ++;
            {
#line 4829
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 4829
              if (! *p) {
#line 4829
                goto while_break___7;
              }
#line 4831
              if ((int )*ps == 123) {
#line 4831
                if ((int )*p == 125) {
#line 4832
                  goto while_break___7;
                }
              }
#line 4833
              if ((int )*ps == 58) {
#line 4833
                if ((int )*p == 58) {
#line 4834
                  goto while_break___7;
                }
              }
#line 4835
              if ((int )*ps != 123) {
#line 4835
                if ((int )*ps != 58) {
#line 4835
                  if ((int )*p < 97) {
                    _L___745: /* CIL Label */ 
#line 4835
                    if ((int )*p < 65) {
                      _L___744: /* CIL Label */ 
#line 4835
                      if ((int )*p < 48) {
                        _L___743: /* CIL Label */ 
#line 4835
                        if ((int )*p != 95) {
#line 4836
                          goto while_break___7;
                        }
                      } else
#line 4835
                      if ((int )*p > 57) {
#line 4835
                        goto _L___743;
                      }
                    } else
#line 4835
                    if ((int )*p > 90) {
#line 4835
                      goto _L___744;
                    }
                  } else
#line 4835
                  if ((int )*p > 122) {
#line 4835
                    goto _L___745;
                  }
                }
              }
#line 4837
              p ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 4839
            pe = p;
#line 4840
            if ((int )*ps == 123) {
              _L___746: /* CIL Label */ 
#line 4842
              if (! *p) {
                {
#line 4844
                Msg(0, (char const   *)((char *)"%s: bad variable name."), rc_name);
                }
#line 4845
                return (0);
              }
#line 4847
              p ++;
            } else
#line 4840
            if ((int )*ps == 58) {
#line 4840
              goto _L___746;
            }
#line 4849
            op = *pe;
#line 4850
            *pe = (char )0;
            {
#line 4851
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 4851
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 4852
            if ((int )*ps == 58) {
              {
#line 4853
              v = gettermcapstring(ps + 1);
              }
            } else {
#line 4856
              if ((int )*ps == 123) {
#line 4857
                ps ++;
              }
              {
#line 4858
              v = (char *)xbuf;
#line 4859
              __cil_tmp34 = strcmp((char const   *)ps, (char const   *)((char *)"TERM"));
              }
#line 4859
              if (! __cil_tmp34) {
#line 4860
                if (display) {
#line 4860
                  tmp = (char *)display->d_termname;
                } else {
#line 4860
                  tmp = (char *)"unknown";
                }
#line 4860
                v = tmp;
              } else {
                {
#line 4861
                __cil_tmp36 = strcmp((char const   *)ps, (char const   *)((char *)"COLUMNS"));
                }
#line 4861
                if (! __cil_tmp36) {
#line 4862
                  if (display) {
#line 4862
                    tmp___747 = display->d_width;
                  } else {
#line 4862
                    tmp___747 = - 1;
                  }
                  {
#line 4862
                  sprintf((char *)xbuf, (char const   *)((char *)"%d"), tmp___747);
                  }
                } else {
                  {
#line 4863
                  __cil_tmp38 = strcmp((char const   *)ps, (char const   *)((char *)"LINES"));
                  }
#line 4863
                  if (! __cil_tmp38) {
#line 4864
                    if (display) {
#line 4864
                      tmp___748 = display->d_height;
                    } else {
#line 4864
                      tmp___748 = - 1;
                    }
                    {
#line 4864
                    sprintf((char *)xbuf, (char const   *)((char *)"%d"), tmp___748);
                    }
                  } else {
                    {
#line 4865
                    __cil_tmp40 = strcmp((char const   *)ps, (char const   *)((char *)"PID"));
                    }
#line 4865
                    if (! __cil_tmp40) {
                      {
#line 4866
                      __cil_tmp41 = getpid();
#line 4866
                      sprintf((char *)xbuf, (char const   *)((char *)"%d"), __cil_tmp41);
                      }
                    } else {
                      {
#line 4867
                      __cil_tmp42 = strcmp((char const   *)ps, (char const   *)((char *)"PWD"));
                      }
#line 4867
                      if (! __cil_tmp42) {
                        {
#line 4869
                        __cil_tmp43 = getcwd((char *)path, sizeof(path) - 1UL);
                        }
#line 4869
                        if (__cil_tmp43 == (char *)0) {
#line 4870
                          v = (char *)"?";
                        } else {
#line 4872
                          v = (char *)path;
                        }
                      } else {
                        {
#line 4874
                        __cil_tmp44 = strcmp((char const   *)ps, (char const   *)((char *)"STY"));
                        }
#line 4874
                        if (! __cil_tmp44) {
                          {
#line 4876
                          v = strchr((char const   *)SockName, '.');
                          }
#line 4876
                          if (v) {
#line 4877
                            v ++;
                          } else {
#line 4879
                            v = SockName;
                          }
                        } else {
                          {
#line 4882
                          v = getenv((char const   *)ps);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
#line 4884
            *pe = op;
#line 4885
            if (v) {
              {
#line 4885
              __cil_tmp48 = strlen((char const   *)v);
#line 4885
              tmp___749 = __cil_tmp48;
              }
            } else {
#line 4885
              tmp___749 = (unsigned long )0;
            }
#line 4885
            vl = (int )tmp___749;
#line 4886
            if (vl) {
              {
#line 4888
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 4888
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 4889
              if (p - pp < (long )vl) {
                {
#line 4891
                __cil_tmp51 = strlen((char const   *)p);
#line 4891
                right = (int )((buf + bufl) - ((p + __cil_tmp51) + 1));
                }
#line 4892
                if (right > 0) {
                  {
#line 4894
                  __cil_tmp52 = strlen((char const   *)p);
#line 4894
                  bcopy((void const   *)p, (void *)(p + right), __cil_tmp52 + 1UL);
#line 4895
                  p += right;
                  }
                }
              }
#line 4898
              if (p - pp < (long )vl) {
                {
#line 4900
                Msg(0, (char const   *)((char *)"%s: no space left for variable expansion."),
                    rc_name);
                }
#line 4901
                return (0);
              }
              {
#line 4903
              bcopy((void const   *)v, (void *)pp, (size_t )vl);
#line 4904
              pp += vl;
              }
            }
#line 4906
            goto while_continue___5;
          } else
#line 4820
          if ((int )*(p + 1) == 58) {
#line 4820
            goto _L___753;
          } else
#line 4820
          if ((int )*(p + 1) >= 97) {
#line 4820
            if ((int )*(p + 1) <= 122) {
#line 4820
              goto _L___753;
            } else {
#line 4820
              goto _L___759;
            }
          } else
          _L___759: /* CIL Label */ 
#line 4820
          if ((int )*(p + 1) >= 65) {
#line 4820
            if ((int )*(p + 1) <= 90) {
#line 4820
              goto _L___753;
            } else {
#line 4820
              goto _L___757;
            }
          } else
          _L___757: /* CIL Label */ 
#line 4820
          if ((int )*(p + 1) >= 48) {
#line 4820
            if ((int )*(p + 1) <= 57) {
#line 4820
              goto _L___753;
            } else {
#line 4820
              goto _L___755;
            }
          } else
          _L___755: /* CIL Label */ 
#line 4820
          if ((int )*(p + 1) == 95) {
#line 4820
            goto _L___753;
          } else {
#line 4820
            goto _L___752;
          }
        } else {
#line 4820
          goto _L___752;
        }
      } else
      _L___752: /* CIL Label */ 
#line 4908
      if (delim != 39) {
#line 4908
        if ((int )*p == 94) {
#line 4908
          if ((int )*(p + 1)) {
#line 4910
            p ++;
#line 4911
            if ((int )*p == 63) {
#line 4911
              tmp___750 = '\177';
            } else {
#line 4911
              tmp___750 = (int )*p & 31;
            }
#line 4911
            __cil_tmp54 = pp;
#line 4911
            pp ++;
#line 4911
            *__cil_tmp54 = (char )tmp___750;
          } else {
#line 4908
            goto _L___750;
          }
        } else {
#line 4908
          goto _L___750;
        }
      } else
      _L___750: /* CIL Label */ 
#line 4913
      if (delim == 0) {
#line 4913
        if ((int )*p == 39) {
#line 4914
          delim = (int )*p;
        } else
#line 4913
        if ((int )*p == 34) {
#line 4914
          delim = (int )*p;
        } else {
#line 4913
          goto _L___749;
        }
      } else
      _L___749: /* CIL Label */ 
#line 4915
      if (delim == 0) {
#line 4915
        if ((int )*p == 32) {
#line 4916
          goto while_break___5;
        } else
#line 4915
        if ((int )*p == 9) {
#line 4916
          goto while_break___5;
        } else
#line 4915
        if ((int )*p == 10) {
#line 4916
          goto while_break___5;
        } else {
#line 4918
          __cil_tmp56 = pp;
#line 4918
          pp ++;
#line 4918
          *__cil_tmp56 = *p;
        }
      } else {
#line 4918
        __cil_tmp56 = pp;
#line 4918
        pp ++;
#line 4918
        *__cil_tmp56 = *p;
      }
#line 4919
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 4921
    if (delim) {
      {
#line 4923
      Msg(0, (char const   *)((char *)"%s: Missing %c quote."), rc_name, delim);
      }
#line 4924
      return (0);
    }
#line 4926
    if (*p) {
#line 4927
      p ++;
    }
#line 4928
    *pp = (char )0;
    {
#line 4929
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 4929
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 4930
    __cil_tmp59 = lp;
#line 4930
    lp ++;
#line 4930
    *__cil_tmp59 = (int )(pp - *(ap + -1));
#line 4931
    pp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return (0);
}
}
#line 4936 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void SetEscape(struct acluser *u , int e , int me ) 
{ 


  {
#line 4940
  if (u) {
#line 4942
    u->u_Esc = e;
#line 4943
    u->u_MetaEsc = me;
  } else {
#line 4947
    if (users) {
#line 4949
      if (DefaultEsc >= 0) {
        {
#line 4950
        ClearAction(& ktab[DefaultEsc]);
        }
      }
#line 4951
      if (DefaultMetaEsc >= 0) {
        {
#line 4952
        ClearAction(& ktab[DefaultMetaEsc]);
        }
      }
    }
#line 4954
    DefaultEsc = e;
#line 4955
    DefaultMetaEsc = me;
#line 4956
    if (users) {
#line 4958
      if (DefaultEsc >= 0) {
        {
#line 4960
        ClearAction(& ktab[DefaultEsc]);
#line 4961
        ktab[DefaultEsc].nr = 122;
        }
      }
#line 4963
      if (DefaultMetaEsc >= 0) {
        {
#line 4965
        ClearAction(& ktab[DefaultMetaEsc]);
#line 4966
        ktab[DefaultMetaEsc].nr = 110;
        }
      }
    }
  }
  return;
}
}
#line 4973 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int ParseSwitch(struct action *act , int *var ) 
{ 
  int __cil_tmp3 ;

  {
#line 4977
  if (*(act->args) == (char *)0) {
#line 4979
    *var ^= 1;
#line 4980
    return (0);
  }
  {
#line 4982
  __cil_tmp3 = ParseOnOff(act, var);
  }
#line 4982
  return (__cil_tmp3);
}
}
#line 4986 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int ParseOnOff(struct action *act , int *var ) 
{ 
  register int num ;
  char **args ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 4990
  num = - 1;
#line 4991
  args = act->args;
#line 4993
  if (*(args + 1) == (char *)0) {
    {
#line 4995
    __cil_tmp5 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"on"));
    }
#line 4995
    if (__cil_tmp5 == 0) {
#line 4996
      num = 1;
    } else {
      {
#line 4997
      __cil_tmp6 = strcmp((char const   *)*(args + 0), (char const   *)((char *)"off"));
      }
#line 4997
      if (__cil_tmp6 == 0) {
#line 4998
        num = 0;
      }
    }
  }
#line 5000
  if (num < 0) {
    {
#line 5002
    Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give \'on\' or \'off\'"),
        rc_name, comms[act->nr].name);
    }
#line 5003
    return (- 1);
  }
#line 5005
  *var = num;
#line 5006
  return (0);
}
}
#line 5010 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int ParseSaveStr(struct action *act , char **var ) 
{ 
  char **args ;

  {
#line 5014
  args = act->args;
#line 5015
  if (*args == (char *)0) {
    {
    {
#line 5017
    Msg(0, (char const   *)((char *)"%s: %s: one argument required."), rc_name, comms[act->nr].name);
    }
    }
#line 5018
    return (- 1);
  } else
#line 5015
  if (*(args + 1)) {
    {
    {
#line 5017
    Msg(0, (char const   *)((char *)"%s: %s: one argument required."), rc_name, comms[act->nr].name);
    }
    }
#line 5018
    return (- 1);
  }
#line 5020
  if (*var) {
    {
#line 5021
    free((void *)*var);
    }
  }
  {
#line 5022
  *var = SaveStr((char const   *)*args);
  }
#line 5023
  return (0);
}
}
#line 5027 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int ParseNum(struct action *act , int *var ) 
{ 
  int i ;
  char *p ;
  char **args ;

  {
#line 5032
  args = act->args;
#line 5034
  p = *args;
#line 5035
  if (p == (char *)0) {
    {
    {
    {
#line 5037
    Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give one argument."),
        rc_name, comms[act->nr].name);
    }
    }
    }
#line 5039
    return (- 1);
  } else
#line 5035
  if ((int )*p == 0) {
    {
    {
    {
#line 5037
    Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give one argument."),
        rc_name, comms[act->nr].name);
    }
    }
    }
#line 5039
    return (- 1);
  } else
#line 5035
  if (*(args + 1)) {
    {
    {
    {
#line 5037
    Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give one argument."),
        rc_name, comms[act->nr].name);
    }
    }
    }
#line 5039
    return (- 1);
  }
#line 5041
  i = 0;
  {
#line 5042
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5042
    if (! *p) {
#line 5042
      goto while_break;
    }
#line 5044
    if ((int )*p >= 48) {
#line 5044
      if ((int )*p <= 57) {
#line 5045
        i = 10 * i + ((int )*p - 48);
      } else {
        {
        {
#line 5048
        Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give numeric argument."),
            rc_name, comms[act->nr].name);
        }
        }
#line 5050
        return (- 1);
      }
    } else {
      {
      {
#line 5048
      Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give numeric argument."),
          rc_name, comms[act->nr].name);
      }
      }
#line 5050
      return (- 1);
    }
#line 5052
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5054
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5054
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5055
  *var = i;
#line 5056
  return (0);
}
}
#line 5060 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int ParseNum1000(struct action *act , int *var ) 
{ 
  int i ;
  char *p ;
  char **args ;
  int dig ;
  int __cil_tmp11 ;

  {
#line 5065
  args = act->args;
#line 5066
  dig = 0;
#line 5068
  p = *args;
#line 5069
  if (p == (char *)0) {
    {
    {
    {
#line 5071
    Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give one argument."),
        rc_name, comms[act->nr].name);
    }
    }
    }
#line 5073
    return (- 1);
  } else
#line 5069
  if ((int )*p == 0) {
    {
    {
    {
#line 5071
    Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give one argument."),
        rc_name, comms[act->nr].name);
    }
    }
    }
#line 5073
    return (- 1);
  } else
#line 5069
  if (*(args + 1)) {
    {
    {
    {
#line 5071
    Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give one argument."),
        rc_name, comms[act->nr].name);
    }
    }
    }
#line 5073
    return (- 1);
  }
#line 5075
  i = 0;
  {
#line 5076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5076
    if (! *p) {
#line 5076
      goto while_break;
    }
#line 5078
    if ((int )*p >= 48) {
#line 5078
      if ((int )*p <= 57) {
#line 5080
        if (dig < 4) {
#line 5081
          i = 10 * i + ((int )*p - 48);
        } else
#line 5082
        if (dig == 4) {
#line 5082
          if ((int )*p >= 53) {
#line 5083
            i ++;
          }
        }
#line 5084
        if (dig) {
#line 5085
          dig ++;
        }
      } else {
#line 5078
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 5087
    if ((int )*p == 46) {
#line 5087
      if (! dig) {
#line 5088
        dig ++;
      } else {
        {
        {
#line 5091
        Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give floating point argument."),
            rc_name, comms[act->nr].name);
        }
        }
#line 5093
        return (- 1);
      }
    } else {
      {
      {
#line 5091
      Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give floating point argument."),
          rc_name, comms[act->nr].name);
      }
      }
#line 5093
      return (- 1);
    }
#line 5095
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5097
  if (dig == 0) {
#line 5098
    i *= 1000;
  } else {
    {
#line 5100
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5100
      if (! (__cil_tmp11 < 4)) {
#line 5100
        goto while_break___0;
      }
#line 5101
      i *= 10;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 5102
  if (i < 0) {
#line 5103
    i = (int )(4294967295U >> 1);
  }
  {
#line 5104
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5104
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 5105
  *var = i;
#line 5106
  return (0);
}
}
#line 5110 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static struct win *WindowByName(char *s ) 
{ 
  struct win *p ;
  int __cil_tmp3 ;
  size_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 5115
  p = windows;
  {
#line 5115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5115
    if (! p) {
#line 5115
      goto while_break;
    }
    {
#line 5116
    __cil_tmp3 = strcmp((char const   *)p->w_title, (char const   *)s);
    }
#line 5116
    if (! __cil_tmp3) {
#line 5117
      return (p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5115
  p = p->w_next;
#line 5118
  p = windows;
  {
#line 5118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5118
    if (! p) {
#line 5118
      goto while_break___0;
    }
    {
#line 5119
    __cil_tmp4 = strlen((char const   *)s);
#line 5119
    __cil_tmp5 = strncmp((char const   *)p->w_title, (char const   *)s, __cil_tmp4);
    }
#line 5119
    if (! __cil_tmp5) {
#line 5120
      return (p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5118
  p = p->w_next;
#line 5121
  return ((struct win *)0);
}
}
#line 5125 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int WindowByNumber(char *str ) 
{ 
  int i ;
  char *s ;
  int tmp ;

  {
#line 5131
  s = str;
#line 5131
  i = 0;
  {
#line 5131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5131
    if (! *s) {
#line 5131
      goto while_break;
    }
#line 5133
    if ((int )*s < 48) {
#line 5134
      goto while_break;
    } else
#line 5133
    if ((int )*s > 57) {
#line 5134
      goto while_break;
    }
#line 5135
    i = i * 10 + ((int )*s - 48);
  }
  while_break: /* CIL Label */ ;
  }
#line 5131
  s ++;
#line 5137
  if ((int )*s) {
#line 5137
    tmp = - 1;
  } else {
#line 5137
    tmp = i;
  }
#line 5137
  return (tmp);
}
}
#line 5146 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int WindowByNoN(char *str ) 
{ 
  int i ;
  struct win *p ;

  {
  {
#line 5152
  i = WindowByNumber(str);
  }
#line 5152
  if (i < 0) {
    _L: /* CIL Label */ 
    {
#line 5154
    p = WindowByName(str);
    }
#line 5154
    if (p) {
#line 5155
      return (p->w_number);
    }
#line 5156
    return (- 1);
  } else
#line 5152
  if (i >= maxwin) {
#line 5152
    goto _L;
  }
#line 5158
  return (i);
}
}
#line 5162 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int ParseWinNum(struct action *act , int *var ) 
{ 
  char **args ;
  int i ;

  {
#line 5166
  args = act->args;
#line 5167
  i = 0;
#line 5169
  if (*args == (char *)0) {
    {
    {
#line 5171
    Msg(0, (char const   *)((char *)"%s: %s: one argument required."), rc_name, comms[act->nr].name);
    }
    }
#line 5172
    return (- 1);
  } else
#line 5169
  if (*(args + 1)) {
    {
    {
#line 5171
    Msg(0, (char const   *)((char *)"%s: %s: one argument required."), rc_name, comms[act->nr].name);
    }
    }
#line 5172
    return (- 1);
  }
  {
#line 5175
  i = WindowByNoN(*args);
  }
#line 5176
  if (i < 0) {
    {
#line 5178
    Msg(0, (char const   *)((char *)"%s: %s: invalid argument. Give window number or name."),
        rc_name, comms[act->nr].name);
    }
#line 5180
    return (- 1);
  }
  {
#line 5182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5182
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5183
  *var = i;
#line 5184
  return (0);
}
}
#line 5188 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int ParseBase(struct action *act , char *p , int *var , int base , char *bname ) 
{ 
  int i ;
  int c ;

  {
#line 5195
  i = 0;
#line 5198
  if ((int )*p == 0) {
    {
#line 5200
    Msg(0, (char const   *)((char *)"%s: %s: empty argument."), rc_name, comms[act->nr].name);
    }
#line 5201
    return (- 1);
  }
  {
#line 5203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5203
    if (! c) {
#line 5203
      goto while_break;
    }
#line 5205
    if (c >= 97) {
#line 5205
      if (c <= 122) {
#line 5206
        c -= 32;
      }
    }
#line 5207
    if (c >= 65) {
#line 5207
      if (c <= 90) {
#line 5208
        c -= 7;
      }
    }
#line 5209
    c -= '0';
#line 5210
    if (c < 0) {
      {
      {
#line 5212
      Msg(0, (char const   *)((char *)"%s: %s: argument is not %s."), rc_name, comms[act->nr].name,
          bname);
      }
      }
#line 5213
      return (- 1);
    } else
#line 5210
    if (c >= base) {
      {
      {
#line 5212
      Msg(0, (char const   *)((char *)"%s: %s: argument is not %s."), rc_name, comms[act->nr].name,
          bname);
      }
      }
#line 5213
      return (- 1);
    }
#line 5215
    i = base * i + c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5217
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5218
  *var = i;
#line 5219
  return (0);
}
}
#line 5223 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int IsNum(char *s , int base ) 
{ 


  {
#line 5227
  base += '0';
  {
#line 5227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5227
    if (! *s) {
#line 5227
      goto while_break;
    }
#line 5228
    if ((int )*s < 48) {
#line 5229
      return (0);
    } else
#line 5228
    if ((int )*s > base) {
#line 5229
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5227
  s ++;
#line 5230
  return (1);
}
}
#line 5234 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int IsNumColon(char *s , int base , char *p , int psize ) 
{ 
  char *q ;
  int __cil_tmp7 ;

  {
  {
#line 5239
  q = rindex((char const   *)s, ':');
  }
#line 5239
  if (q != (char *)0) {
    {
#line 5241
    strncpy(p, (char const   *)(q + 1), (unsigned long )(psize - 1));
#line 5242
    *(p + (psize - 1)) = (char )'\000';
#line 5243
    *q = (char )'\000';
    }
  } else {
#line 5246
    *p = (char )'\000';
  }
  {
#line 5247
  __cil_tmp7 = IsNum(s, base);
  }
#line 5247
  return (__cil_tmp7);
}
}
#line 5251 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void SwitchWindow(int n ) 
{ 
  struct win *p ;
  int __cil_tmp3 ;

  {
  {
#line 5256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5256
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5257
  if (n < 0) {
    {
    {
#line 5259
    ShowWindows(- 1);
    }
    }
#line 5260
    return;
  } else
#line 5257
  if (n >= maxwin) {
    {
    {
#line 5259
    ShowWindows(- 1);
    }
    }
#line 5260
    return;
  }
#line 5262
  p = *(wtab + n);
#line 5262
  if (p == (struct win *)0) {
    {
#line 5264
    ShowWindows(n);
    }
#line 5265
    return;
  }
#line 5267
  if (display == (struct display *)0) {
#line 5269
    fore = p;
#line 5270
    return;
  }
#line 5272
  if (p == display->d_fore) {
    {
#line 5274
    Msg(0, (char const   *)((char *)"This IS window %d (%s)."), n, p->w_title);
    }
#line 5275
    return;
  }
  {
#line 5278
  __cil_tmp3 = AclCheckPermWin(display->d_user, 2, p);
  }
#line 5278
  if (__cil_tmp3) {
    {
#line 5280
    Msg(0, (char const   *)((char *)"Access to window %d denied."), p->w_number);
    }
#line 5281
    return;
  }
  {
#line 5284
  SetForeWindow(p);
#line 5285
  Activate((int )fore->w_norefresh);
  }
  return;
}
}
#line 5293 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void SetForeWindow(struct win *wi ) 
{ 
  struct win *p ;

  {
#line 5297
  if (display == (struct display *)0) {
#line 5299
    fore = wi;
#line 5300
    return;
  }
  {
#line 5302
  p = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
#line 5303
  SetCanvasWindow(display->d_forecv, wi);
  }
#line 5304
  if (p) {
    {
#line 5305
    WindowChanged(p, 'u');
    }
  }
#line 5306
  if (wi) {
    {
#line 5307
    WindowChanged(wi, 'u');
    }
  }
#line 5308
  flayer = (display->d_forecv)->c_layer;
  return;
}
}
#line 5320 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void Activate(int norefresh ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 5323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5323
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5324
  if (display == (struct display *)0) {
#line 5325
    return;
  }
#line 5326
  if (display->d_status) {
    {
#line 5328
    Msg(0, (char const   *)((char *)"%s"), (char *)"");
#line 5329
    RemoveStatus();
    }
  }
  {
#line 5332
  __cil_tmp2 = MayResizeLayer((display->d_forecv)->c_layer);
  }
#line 5332
  if (__cil_tmp2) {
    {
#line 5333
    ResizeLayer((display->d_forecv)->c_layer, ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1,
                ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1, display);
    }
  }
#line 5335
  fore = display->d_fore;
#line 5336
  if (fore) {
#line 5339
    if (fore->w_monitor != 0) {
#line 5340
      fore->w_monitor = 1;
    }
    {
#line 5341
    fore->w_bell = 0;
#line 5342
    WindowChanged(fore, 'f');
    }
  }
  {
#line 5353
  Redisplay(norefresh + all_norefresh);
  }
  return;
}
}
#line 5358 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int NextWindow(void) 
{ 
  register struct win **pp ;
  int n ;
  int tmp ;
  struct win *group ;
  struct win *tmp___773 ;
  struct win **tmp___774 ;

  {
#line 5361
  if (fore) {
#line 5361
    tmp = fore->w_number;
  } else {
#line 5361
    tmp = maxwin;
  }
#line 5361
  n = tmp;
#line 5362
  if (fore) {
#line 5362
    tmp___773 = fore->w_group;
  } else {
#line 5362
    tmp___773 = (struct win *)0;
  }
#line 5362
  group = tmp___773;
#line 5364
  if (fore) {
#line 5364
    tmp___774 = (wtab + n) + 1;
  } else {
#line 5364
    tmp___774 = wtab;
  }
#line 5364
  pp = tmp___774;
  {
#line 5364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5364
    if (! (pp != wtab + n)) {
#line 5364
      goto while_break;
    }
#line 5366
    if (pp == wtab + maxwin) {
#line 5367
      pp = wtab;
    }
#line 5368
    if (*pp) {
#line 5370
      if (! fore) {
#line 5371
        goto while_break;
      } else
#line 5370
      if (group == (*pp)->w_group) {
#line 5371
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5364
  pp ++;
#line 5374
  if (pp == wtab + n) {
#line 5375
    return (- 1);
  }
#line 5376
  return ((int )(pp - wtab));
}
}
#line 5380 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int PreviousWindow(void) 
{ 
  register struct win **pp ;
  int n ;
  int tmp ;
  struct win *group ;
  struct win *tmp___775 ;
  struct win **__cil_tmp6 ;

  {
#line 5383
  if (fore) {
#line 5383
    tmp = fore->w_number;
  } else {
#line 5383
    tmp = - 1;
  }
#line 5383
  n = tmp;
#line 5384
  if (fore) {
#line 5384
    tmp___775 = fore->w_group;
  } else {
#line 5384
    tmp___775 = (struct win *)0;
  }
#line 5384
  group = tmp___775;
#line 5386
  pp = (wtab + n) - 1;
  {
#line 5386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5386
    if (! (pp != wtab + n)) {
#line 5386
      goto while_break;
    }
#line 5388
    if (pp == wtab - 1) {
#line 5389
      pp = (wtab + maxwin) - 1;
    }
#line 5390
    if (*pp) {
#line 5392
      if (! fore) {
#line 5393
        goto while_break;
      } else
#line 5392
      if (group == (*pp)->w_group) {
#line 5393
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5386
  __cil_tmp6 = pp;
#line 5386
  pp --;
#line 5396
  if (pp == wtab + n) {
#line 5397
    return (- 1);
  }
#line 5398
  return ((int )(pp - wtab));
}
}
#line 5402 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int MoreWindows(void) 
{ 
  char *m ;

  {
#line 5404
  m = (char *)"No other window.";
#line 5405
  if (windows) {
#line 5405
    if (fore == (struct win *)0) {
#line 5406
      return (1);
    } else
#line 5405
    if (windows->w_next) {
#line 5406
      return (1);
    }
  }
#line 5407
  if (fore == (struct win *)0) {
    {
#line 5409
    Msg(0, (char const   *)((char *)"No window available"));
    }
#line 5410
    return (0);
  }
  {
#line 5412
  Msg(0, (char const   *)m, fore->w_number);
  }
#line 5413
  return (0);
}
}
#line 5417 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void KillWindow(struct win *wi ) 
{ 
  struct win **pp ;
  struct win *p ;
  struct canvas *cv ;
  int gotone ;
  struct layout *lay ;
  struct win *__cil_tmp7 ;

  {
#line 5428
  pp = & windows;
  {
#line 5428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5428
    if (! p) {
#line 5428
      goto while_break;
    }
#line 5429
    if (p == wi) {
#line 5430
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5428
  pp = & p->w_next;
  {
#line 5431
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5431
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5432
  *pp = p->w_next;
#line 5433
  wi->w_inlen = 0;
#line 5434
  *(wtab + wi->w_number) = (struct win *)0;
#line 5436
  if (windows == (struct win *)0) {
    {
#line 5438
    FreeWindow(wi);
#line 5439
    Finit(0);
    }
  }
#line 5445
  display = displays;
  {
#line 5445
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5445
    if (! display) {
#line 5445
      goto while_break___1;
    }
#line 5447
    gotone = 0;
#line 5448
    cv = display->d_cvlist;
    {
#line 5448
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5448
      if (! cv) {
#line 5448
        goto while_break___2;
      }
#line 5450
      if ((struct win *)((cv->c_layer)->l_bottom)->l_data != wi) {
#line 5451
        goto while_continue___2;
      }
      {
#line 5453
      __cil_tmp7 = FindNiceWindow(display->d_other, (char *)0);
#line 5453
      SetCanvasWindow(cv, __cil_tmp7);
#line 5454
      gotone = 1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 5448
    cv = cv->c_next;
#line 5456
    if (gotone) {
#line 5459
      if (wi->w_zdisplay == display) {
#line 5461
        display->d_blocked = 0;
#line 5462
        display->d_readev.condneg = (int *)0;
#line 5462
        display->d_readev.condpos = display->d_readev.condneg;
      }
      {
#line 5465
      Activate(- 1);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 5445
  display = display->d_next;
#line 5470
  lay = layouts;
  {
#line 5470
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5470
    if (! lay) {
#line 5470
      goto while_break___3;
    }
    {
#line 5471
    UpdateLayoutCanvas(& lay->lay_canvas, wi);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 5470
  lay = lay->lay_next;
#line 5473
  FreeWindow(wi);
#line 5474
  WindowChanged((struct win *)0, 'w');
#line 5475
  WindowChanged((struct win *)0, 'W');
#line 5476
  WindowChanged((struct win *)0, 0);
  }
  return;
}
}
#line 5480 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void LogToggle(int on ) 
{ 
  char buf[1024] ;
  char *tmp ;
  int __cil_tmp4 ;
  int *__cil_tmp5 ;
  long __cil_tmp6 ;

  {
#line 5485
  if ((fore->w_log != (struct logfile *)0) == on) {
#line 5487
    if (display) {
#line 5487
      if (! *rc_name) {
#line 5488
        if (on) {
#line 5488
          tmp = (char *)"already";
        } else {
#line 5488
          tmp = (char *)"not";
        }
        {
#line 5488
        Msg(0, (char const   *)((char *)"You are %s logging."), tmp);
        }
      }
    }
#line 5489
    return;
  }
#line 5491
  if (fore->w_log != (struct logfile *)0) {
    {
#line 5493
    Msg(0, (char const   *)((char *)"Logfile \"%s\" closed."), (fore->w_log)->name);
#line 5494
    logfclose(fore->w_log);
#line 5495
    fore->w_log = (struct logfile *)0;
#line 5496
    WindowChanged(fore, 'f');
    }
#line 5497
    return;
  }
  {
#line 5499
  __cil_tmp4 = DoStartLog(fore, (char *)buf, (int )sizeof(buf));
  }
#line 5499
  if (__cil_tmp4) {
    {
#line 5501
    __cil_tmp5 = __errno_location();
#line 5501
    Msg(*__cil_tmp5, (char const   *)((char *)"Error opening logfile \"%s\""), (char *)buf);
    }
#line 5502
    return;
  }
  {
#line 5504
  __cil_tmp6 = ftell((fore->w_log)->fp);
  }
#line 5504
  if (__cil_tmp6 == 0L) {
    {
#line 5505
    Msg(0, (char const   *)((char *)"Creating logfile \"%s\"."), (fore->w_log)->name);
    }
  } else {
    {
#line 5507
    Msg(0, (char const   *)((char *)"Appending to logfile \"%s\"."), (fore->w_log)->name);
    }
  }
  {
#line 5508
  WindowChanged(fore, 'f');
  }
  return;
}
}
#line 5512 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
char *AddWindows(char *buf , int len , int flags , int where ) 
{ 
  register char *s ;
  register char *ss ;
  register struct win **pp ;
  register struct win *p ;
  register char *cmd ;
  int l ;
  struct win **tmp ;
  int rend ;
  size_t __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp20 ;

  {
#line 5523
  ss = buf;
#line 5523
  s = ss;
#line 5524
  if (flags & 8) {
#line 5524
    if (where < 0) {
#line 5526
      *s = (char )0;
#line 5527
      return (ss);
    }
  }
#line 5529
  if (flags & 4 && where >= 0) {
#line 5529
    tmp = (wtab + where) + 1;
  } else {
#line 5529
    tmp = wtab;
  }
#line 5529
  pp = tmp;
  {
#line 5529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5529
    if (! (pp < wtab + maxwin)) {
#line 5529
      goto while_break;
    }
#line 5531
    rend = - 1;
#line 5532
    if (pp - wtab == (long )where) {
#line 5532
      if (ss == buf) {
#line 5533
        ss = s;
      }
    }
#line 5534
    p = *pp;
#line 5534
    if (p == (struct win *)0) {
#line 5535
      goto while_continue;
    }
#line 5536
    if (flags & 1) {
#line 5536
      if (display) {
#line 5536
        if (p == display->d_fore) {
#line 5537
          goto while_continue;
        }
      }
    }
#line 5538
    if (display) {
#line 5538
      if (display->d_fore) {
#line 5538
        if ((display->d_fore)->w_group != p->w_group) {
#line 5539
          goto while_continue;
        }
      }
    }
    {
#line 5541
    cmd = p->w_title;
#line 5542
    __cil_tmp13 = strlen((char const   *)cmd);
#line 5542
    l = (int )__cil_tmp13;
    }
#line 5543
    if (l > 20) {
#line 5544
      l = 20;
    }
#line 5545
    if ((s - buf) + (long )l > (long )(len - 24)) {
#line 5546
      goto while_break;
    }
#line 5547
    if (s > buf) {
      _L: /* CIL Label */ 
#line 5549
      __cil_tmp14 = s;
#line 5549
      s ++;
#line 5549
      *__cil_tmp14 = (char )' ';
#line 5550
      __cil_tmp15 = s;
#line 5550
      s ++;
#line 5550
      *__cil_tmp15 = (char )' ';
    } else
#line 5547
    if (flags & 4) {
#line 5547
      goto _L;
    }
#line 5552
    if (p->w_number == where) {
#line 5554
      ss = s;
#line 5555
      if (flags & 8) {
#line 5556
        goto while_break;
      }
    }
#line 5558
    if (! (flags & 4)) {
      _L___780: /* CIL Label */ 
#line 5560
      if (p->w_monitor == 3) {
#line 5560
        if (renditions[1] != -1) {
#line 5561
          rend = renditions[1];
        } else {
#line 5560
          goto _L___779;
        }
      } else
      _L___779: /* CIL Label */ 
#line 5562
      if (p->w_bell == 2) {
        _L___778: /* CIL Label */ 
#line 5562
        if (renditions[0] != -1) {
#line 5563
          rend = renditions[0];
        } else {
#line 5562
          goto _L___777;
        }
      } else
#line 5562
      if (p->w_bell == 1) {
#line 5562
        goto _L___778;
      } else
      _L___777: /* CIL Label */ 
#line 5564
      if (p->w_silence == 2) {
        _L___776: /* CIL Label */ 
#line 5564
        if (renditions[2] != -1) {
#line 5565
          rend = renditions[2];
        }
      } else
#line 5564
      if (p->w_silence == 3) {
#line 5564
        goto _L___776;
      }
    } else
#line 5558
    if (where < 0) {
#line 5558
      goto _L___780;
    } else
#line 5558
    if (flags & 4) {
#line 5558
      if (where < p->w_number) {
#line 5558
        goto _L___780;
      }
    }
#line 5567
    if (rend != -1) {
      {
#line 5568
      AddWinMsgRend((char const   *)s, rend);
      }
    }
    {
#line 5569
    sprintf(s, (char const   *)((char *)"%d"), p->w_number);
#line 5570
    __cil_tmp16 = strlen((char const   *)s);
    }
#line 5570
    s += __cil_tmp16;
#line 5571
    if (display) {
#line 5571
      if (p == display->d_fore) {
#line 5572
        __cil_tmp17 = s;
#line 5572
        s ++;
#line 5572
        *__cil_tmp17 = (char )'*';
      }
    }
#line 5573
    if (! (flags & 2)) {
#line 5575
      if (display) {
#line 5575
        if (p == display->d_other) {
#line 5576
          __cil_tmp18 = s;
#line 5576
          s ++;
#line 5576
          *__cil_tmp18 = (char )'-';
        }
      }
      {
#line 5577
      s = AddWindowFlags(s, len, p);
      }
    }
    {
#line 5579
    __cil_tmp20 = s;
#line 5579
    s ++;
#line 5579
    *__cil_tmp20 = (char )' ';
#line 5580
    strncpy(s, (char const   *)cmd, (unsigned long )l);
#line 5581
    s += l;
    }
#line 5582
    if (rend != -1) {
      {
#line 5583
      AddWinMsgRend((char const   *)s, - 1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5529
  pp ++;
#line 5585
  *s = (char )0;
#line 5586
  return (ss);
}
}
#line 5590 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
char *AddWindowFlags(char *buf , int len , struct win *p ) 
{ 
  char *s ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 5595
  s = buf;
#line 5596
  if (p == (struct win *)0) {
#line 5598
    *s = (char )0;
#line 5599
    return (s);
  } else
#line 5596
  if (len < 12) {
#line 5598
    *s = (char )0;
#line 5599
    return (s);
  }
#line 5607
  if (p->w_layer.l_cvlist) {
#line 5607
    if ((p->w_layer.l_cvlist)->c_lnext) {
#line 5608
      __cil_tmp5 = s;
#line 5608
      s ++;
#line 5608
      *__cil_tmp5 = (char )'&';
    }
  }
#line 5609
  if (p->w_monitor == 3) {
#line 5609
    if (display) {
#line 5609
      if ((int )*(p->w_mon_notify + ((display->d_user)->u_id >> 3)) & (128 >> ((display->d_user)->u_id & 7))) {
#line 5614
        __cil_tmp6 = s;
#line 5614
        s ++;
#line 5614
        *__cil_tmp6 = (char )'@';
      }
    }
  }
#line 5615
  if (p->w_bell == 2) {
#line 5616
    __cil_tmp7 = s;
#line 5616
    s ++;
#line 5616
    *__cil_tmp7 = (char )'!';
  }
#line 5618
  if (p->w_slot != (slot_t )0) {
#line 5618
    if (p->w_slot != (slot_t )-1) {
#line 5619
      __cil_tmp8 = s;
#line 5619
      s ++;
#line 5619
      *__cil_tmp8 = (char )'$';
    }
  }
#line 5621
  if (p->w_log != (struct logfile *)0) {
    {
#line 5623
    strcpy(s, (char const   *)((char *)"(L)"));
#line 5624
    s += 3;
    }
  }
#line 5626
  if (p->w_ptyfd < 0) {
#line 5626
    if (p->w_type != 3) {
#line 5627
      __cil_tmp9 = s;
#line 5627
      s ++;
#line 5627
      *__cil_tmp9 = (char )'Z';
    }
  }
#line 5628
  *s = (char )0;
#line 5629
  return (s);
}
}
#line 5633 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
char *AddOtherUsers(char *buf , int len , struct win *p ) 
{ 
  struct display *d ;
  struct display *olddisplay ;
  struct canvas *cv ;
  char *s ;
  int l ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 5638
  olddisplay = display;
#line 5643
  s = buf;
#line 5644
  display = displays;
  {
#line 5644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5644
    if (! display) {
#line 5644
      goto while_break;
    }
#line 5646
    if (olddisplay) {
#line 5646
      if (display->d_user == olddisplay->d_user) {
#line 5647
        goto while_continue;
      }
    }
#line 5648
    cv = display->d_cvlist;
    {
#line 5648
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5648
      if (! cv) {
#line 5648
        goto while_break___0;
      }
#line 5649
      if ((struct win *)((cv->c_layer)->l_bottom)->l_data == p) {
#line 5650
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5648
    cv = cv->c_next;
#line 5651
    if (! cv) {
#line 5652
      goto while_continue;
    }
#line 5653
    d = displays;
    {
#line 5653
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5653
      if (! (d && d != display)) {
#line 5653
        goto while_break___1;
      }
#line 5654
      if (display->d_user == d->d_user) {
#line 5655
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5653
    d = d->d_next;
#line 5656
    if (d) {
#line 5656
      if (d != display) {
#line 5657
        goto while_continue;
      }
    }
#line 5658
    if (len > 1) {
#line 5658
      if (s != buf) {
#line 5660
        __cil_tmp9 = s;
#line 5660
        s ++;
#line 5660
        *__cil_tmp9 = (char )',';
#line 5661
        __cil_tmp10 = len;
#line 5661
        len --;
      }
    }
    {
#line 5663
    __cil_tmp11 = strlen((char const   *)((char *)(display->d_user)->u_name));
#line 5663
    l = (int )__cil_tmp11;
    }
#line 5664
    if (l + 1 > len) {
#line 5665
      goto while_break;
    }
    {
#line 5666
    strcpy(s, (char const   *)((char *)(display->d_user)->u_name));
#line 5667
    s += l;
#line 5668
    len -= l;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5644
  display = display->d_next;
#line 5670
  *s = (char )0;
#line 5671
  display = olddisplay;
#line 5672
  return (s);
}
}
#line 5676 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void ShowWindows(int where ) 
{ 
  char buf[1024] ;
  char *s ;
  char *ss ;
  size_t __cil_tmp6 ;

  {
#line 5682
  if (display) {
#line 5682
    if (where == -1) {
#line 5682
      if (display->d_fore) {
#line 5683
        where = (display->d_fore)->w_number;
      }
    }
  }
  {
#line 5684
  ss = AddWindows((char *)buf, (int )sizeof(buf), 0, where);
#line 5685
  __cil_tmp6 = strlen((char const   *)((char *)buf));
#line 5685
  s = (char *)buf + __cil_tmp6;
  }
#line 5686
  if (display) {
#line 5686
    if (ss - (char *)buf > (long )(display->d_width / 2)) {
#line 5688
      ss -= display->d_width / 2;
#line 5689
      if (s - ss < (long )display->d_width) {
#line 5691
        ss = s - display->d_width;
#line 5692
        if (ss < (char *)buf) {
#line 5693
          ss = (char *)buf;
        }
      }
    } else {
#line 5697
      ss = (char *)buf;
    }
  } else {
#line 5697
    ss = (char *)buf;
  }
  {
#line 5698
  Msg(0, (char const   *)((char *)"%s"), ss);
  }
  return;
}
}
#line 5706 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void ShowWindowsX(char *str ) 
{ 
  int i ;
  char *__cil_tmp3 ;

  {
  {
#line 5710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5710
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5711
  i = 0;
  {
#line 5711
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5711
    if (! (i < maxwin)) {
#line 5711
      goto while_break___0;
    }
#line 5712
    if (! *(wtab + i)) {
#line 5713
      goto while_continue___0;
    }
    {
#line 5714
    __cil_tmp3 = MakeWinMsg(str, *(wtab + i), '%');
#line 5714
    Msg(0, (char const   *)((char *)"%s"), __cil_tmp3);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5711
  i ++;
  return;
}
}
#line 5720 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void ShowInfo(void) 
{ 
  char buf[512] ;
  char *p ;
  register struct win *wp ;
  register int i ;
  int __cil_tmp5 ;
  char *__cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int tmp ;
  char *tmp___782 ;
  char *tmp___783 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t __cil_tmp17 ;
  size_t __cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;
  size_t __cil_tmp21 ;
  size_t __cil_tmp22 ;
  int __cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  size_t __cil_tmp26 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 5723
  wp = fore;
#line 5726
  if (wp == (struct win *)0) {
    {
#line 5728
    Msg(0, (char const   *)((char *)"(%d,%d)/(%d,%d) no window"), display->d_x + 1,
        display->d_y + 1, display->d_width, display->d_height);
    }
#line 5729
    return;
  }
  {
#line 5731
  p = (char *)buf;
#line 5732
  __cil_tmp5 = GetAnsiStatus(wp, p);
  }
#line 5732
  p += __cil_tmp5;
#line 5732
  if ((char *)buf < p) {
#line 5733
    __cil_tmp6 = p;
#line 5733
    p ++;
#line 5733
    *__cil_tmp6 = (char )' ';
  }
  {
#line 5734
  sprintf(p, (char const   *)((char *)"(%d,%d)/(%d,%d)"), wp->w_layer.l_x + 1, wp->w_layer.l_y + 1,
          wp->w_layer.l_width, wp->w_layer.l_height);
#line 5737
  __cil_tmp7 = strlen((char const   *)p);
  }
  {
#line 5737
  p += __cil_tmp7;
#line 5737
  sprintf(p, (char const   *)((char *)"+%d"), wp->w_histheight);
#line 5739
  __cil_tmp8 = strlen((char const   *)p);
  }
#line 5739
  p += __cil_tmp8;
#line 5739
  if (wp->w_flow & 1) {
#line 5739
    tmp = '+';
  } else {
#line 5739
    tmp = '-';
  }
#line 5739
  if (wp->w_flow & (1 << 2)) {
#line 5739
    tmp___783 = (char *)"";
  } else {
#line 5739
    if (wp->w_flow & (1 << 1)) {
#line 5739
      tmp___782 = (char *)"(+)";
    } else {
#line 5739
      tmp___782 = (char *)"(-)";
    }
#line 5739
    tmp___783 = tmp___782;
  }
  {
#line 5739
  sprintf(p, (char const   *)((char *)" %c%sflow"), tmp, tmp___783);
  }
#line 5743
  if (! wp->w_wrap) {
    {
#line 5743
    __cil_tmp12 = strlen((char const   *)p);
    }
    {
#line 5743
    p += __cil_tmp12;
#line 5743
    sprintf(p, (char const   *)((char *)" -wrap"));
    }
  }
#line 5744
  if (wp->w_insert) {
    {
#line 5744
    __cil_tmp13 = strlen((char const   *)p);
    }
    {
#line 5744
    p += __cil_tmp13;
#line 5744
    sprintf(p, (char const   *)((char *)" ins"));
    }
  }
#line 5745
  if (wp->w_origin) {
    {
#line 5745
    __cil_tmp14 = strlen((char const   *)p);
    }
    {
#line 5745
    p += __cil_tmp14;
#line 5745
    sprintf(p, (char const   *)((char *)" org"));
    }
  }
#line 5746
  if (wp->w_keypad) {
    {
#line 5746
    __cil_tmp15 = strlen((char const   *)p);
    }
    {
#line 5746
    p += __cil_tmp15;
#line 5746
    sprintf(p, (char const   *)((char *)" app"));
    }
  }
#line 5747
  if (wp->w_log) {
    {
#line 5747
    __cil_tmp16 = strlen((char const   *)p);
    }
    {
#line 5747
    p += __cil_tmp16;
#line 5747
    sprintf(p, (char const   *)((char *)" log"));
    }
  }
#line 5748
  if (wp->w_monitor != 0) {
#line 5748
    if ((int )*(wp->w_mon_notify + ((display->d_user)->u_id >> 3)) & (128 >> ((display->d_user)->u_id & 7))) {
      {
#line 5753
      __cil_tmp17 = strlen((char const   *)p);
      }
      {
#line 5753
      p += __cil_tmp17;
#line 5753
      sprintf(p, (char const   *)((char *)" mon"));
      }
    }
  }
#line 5754
  if (wp->w_mouse) {
    {
#line 5754
    __cil_tmp18 = strlen((char const   *)p);
    }
    {
#line 5754
    p += __cil_tmp18;
#line 5754
    sprintf(p, (char const   *)((char *)" mouse"));
    }
  }
#line 5756
  if (wp->w_bce) {
    {
#line 5756
    __cil_tmp19 = strlen((char const   *)p);
    }
    {
#line 5756
    p += __cil_tmp19;
#line 5756
    sprintf(p, (char const   *)((char *)" bce"));
    }
  }
#line 5758
  if (! wp->w_c1) {
    {
#line 5758
    __cil_tmp20 = strlen((char const   *)p);
    }
    {
#line 5758
    p += __cil_tmp20;
#line 5758
    sprintf(p, (char const   *)((char *)" -c1"));
    }
  }
#line 5759
  if (wp->w_norefresh) {
    {
#line 5759
    __cil_tmp21 = strlen((char const   *)p);
    }
    {
#line 5759
    p += __cil_tmp21;
#line 5759
    sprintf(p, (char const   *)((char *)" nored"));
    }
  }
  {
#line 5761
  __cil_tmp22 = strlen((char const   *)p);
  }
  {
#line 5761
  p += __cil_tmp22;
#line 5764
  __cil_tmp23 = EncodingDefFont(wp->w_layer.l_encoding);
  }
#line 5764
  if (wp->w_layer.l_encoding) {
#line 5764
    if (display == (struct display *)0) {
      _L: /* CIL Label */ 
      {
#line 5766
      __cil_tmp24 = p;
#line 5766
      p ++;
#line 5766
      *__cil_tmp24 = (char )' ';
#line 5767
      __cil_tmp25 = EncodingName(wp->w_layer.l_encoding);
#line 5767
      strcpy(p, (char const   *)__cil_tmp25);
#line 5768
      __cil_tmp26 = strlen((char const   *)p);
      }
#line 5768
      p += __cil_tmp26;
    } else
#line 5764
    if (display->d_encoding != wp->w_layer.l_encoding) {
#line 5764
      goto _L;
    } else
#line 5764
    if (__cil_tmp23 <= 0) {
#line 5764
      goto _L;
    }
  }
#line 5771
  if (wp->w_layer.l_encoding != 8) {
#line 5774
    if (display) {
#line 5774
      if (display->d_tcs[100].str) {
        _L___785: /* CIL Label */ 
#line 5776
        if (wp->w_gr == 2) {
          {
#line 5778
          sprintf(p, (char const   *)((char *)" G%c"), wp->w_Charset + 48);
          }
#line 5779
          if ((int )wp->w_FontE >= 32) {
#line 5780
            *(p + 3) = wp->w_FontE;
          } else {
#line 5783
            *(p + 3) = (char )'^';
#line 5784
            *(p + 4) = (char )((int )wp->w_FontE ^ 64);
#line 5785
            p ++;
          }
#line 5787
          *(p + 4) = (char )'[';
#line 5788
          p ++;
        } else
#line 5790
        if (wp->w_gr) {
          {
#line 5791
          __cil_tmp29 = p;
#line 5791
          p ++;
#line 5791
          sprintf(__cil_tmp29, (char const   *)((char *)" G%c%c["), wp->w_Charset + 48,
                  wp->w_CharsetR + 48);
          }
        } else {
          {
#line 5793
          sprintf(p, (char const   *)((char *)" G%c["), wp->w_Charset + 48);
          }
        }
#line 5794
        p += 4;
#line 5795
        i = 0;
        {
#line 5795
        while (1) {
          while_continue: /* CIL Label */ ;
#line 5795
          if (! (i < 4)) {
#line 5795
            goto while_break;
          }
#line 5797
          if (wp->w_charsets[i] == 0) {
#line 5798
            __cil_tmp30 = p;
#line 5798
            p ++;
#line 5798
            *__cil_tmp30 = (char )'B';
          } else
#line 5799
          if (wp->w_charsets[i] >= 32) {
#line 5800
            __cil_tmp31 = p;
#line 5800
            p ++;
#line 5800
            *__cil_tmp31 = (char )wp->w_charsets[i];
          } else {
#line 5803
            __cil_tmp32 = p;
#line 5803
            p ++;
#line 5803
            *__cil_tmp32 = (char )'^';
#line 5804
            __cil_tmp33 = p;
#line 5804
            p ++;
#line 5804
            *__cil_tmp33 = (char )(wp->w_charsets[i] ^ 64);
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 5795
        i ++;
#line 5807
        __cil_tmp35 = p;
#line 5807
        p ++;
#line 5807
        *__cil_tmp35 = (char )']';
#line 5808
        *p = (char )0;
      } else
#line 5774
      if (display->d_tcs[98].str) {
#line 5774
        if ((int )*(display->d_tcs[98].str)) {
#line 5774
          goto _L___785;
        }
      }
    }
  }
#line 5812
  if (wp->w_type == 1) {
    {
#line 5815
    __cil_tmp36 = p;
#line 5815
    p ++;
#line 5815
    *__cil_tmp36 = (char )' ';
#line 5816
    TtyGetModemStatus(wp->w_ptyfd, p);
    }
  }
  {
#line 5825
  Msg(0, (char const   *)((char *)"%s %d(%s)"), (char *)buf, wp->w_number, wp->w_title);
  }
  return;
}
}
#line 5829 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void ShowDInfo(void) 
{ 
  char buf[512] ;
  char *p ;
  int __cil_tmp3 ;
  size_t __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 5832
  if (display == (struct display *)0) {
#line 5833
    return;
  }
  {
#line 5834
  p = (char *)buf;
#line 5835
  __cil_tmp4 = strlen((char const   *)p);
  }
#line 5835
  p += __cil_tmp4;
  {
#line 5835
  __cil_tmp3 = sprintf(p, (char const   *)((char *)"(%d,%d)"), display->d_width, display->d_height);
  }
#line 5838
  if (display->d_encoding) {
    {
#line 5840
    __cil_tmp5 = p;
#line 5840
    p ++;
#line 5840
    *__cil_tmp5 = (char )' ';
#line 5841
    __cil_tmp6 = EncodingName(display->d_encoding);
#line 5841
    strcpy(p, (char const   *)__cil_tmp6);
#line 5842
    __cil_tmp7 = strlen((char const   *)p);
    }
#line 5842
    p += __cil_tmp7;
  }
#line 5845
  if (display->d_tcs[96].flg) {
    {
#line 5847
    strcpy(p, (char const   *)((char *)" xterm"));
#line 5848
    __cil_tmp8 = strlen((char const   *)p);
    }
#line 5848
    p += __cil_tmp8;
  }
#line 5851
  if (display->d_hascolor) {
    {
#line 5853
    strcpy(p, (char const   *)((char *)" color"));
#line 5854
    __cil_tmp9 = strlen((char const   *)p);
    }
#line 5854
    p += __cil_tmp9;
  }
#line 5858
  if (display->d_tcs[97].flg) {
    {
#line 5860
    strcpy(p, (char const   *)((char *)" iso2022"));
#line 5861
    __cil_tmp10 = strlen((char const   *)p);
    }
#line 5861
    p += __cil_tmp10;
  } else
#line 5863
  if (display->d_tcs[98].str) {
#line 5863
    if ((int )*(display->d_tcs[98].str)) {
      {
#line 5865
      strcpy(p, (char const   *)((char *)" altchar"));
#line 5866
      __cil_tmp11 = strlen((char const   *)p);
      }
#line 5866
      p += __cil_tmp11;
    }
  }
  {
#line 5869
  Msg(0, (char const   *)((char *)"%s"), (char *)buf);
  }
  return;
}
}
#line 5873 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void AKAfin(char *buf , int len , char *data ) 
{ 
  size_t __cil_tmp4 ;

  {
  {
#line 5878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5878
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5879
  if (len) {
#line 5879
    if (fore) {
      {
#line 5880
      __cil_tmp4 = strlen((char const   *)buf);
#line 5880
      ChangeAKA(fore, buf, (int )__cil_tmp4);
      }
    }
  }
#line 5882
  enter_window_name_mode = 0;
  return;
}
}
#line 5886 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void InputAKA(void) 
{ 
  char *s ;
  char *ss ;
  int n ;

  {
#line 5891
  if (enter_window_name_mode == 1) {
#line 5891
    return;
  }
  {
#line 5893
  enter_window_name_mode = 1;
#line 5895
  Input((char *)"Set window\'s title to: ", (int )(sizeof(fore->w_akabuf) - 1UL),
        0, AKAfin, (char *)((void *)0), 0);
#line 5896
  s = fore->w_title;
  }
#line 5897
  if (! s) {
#line 5898
    return;
  }
  {
#line 5899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5899
    if (! *s) {
#line 5899
      goto while_break;
    }
#line 5901
    if (((int )*((unsigned char *)s) & 127) < 32) {
#line 5902
      goto while_continue;
    } else
#line 5901
    if ((int )*s == 127) {
#line 5902
      goto while_continue;
    }
    {
#line 5903
    ss = s;
#line 5904
    n = 1;
#line 5905
    (*((flayer->l_layfn)->lf_LayProcess))(& ss, & n);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5899
  s ++;
  return;
}
}
#line 5910 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void Colonfin(char *buf , int len , char *data ) 
{ 
  char mbuf[256] ;
  int m ;
  int x ;
  int l ;
  int r ;
  int showmessage ;
  char *s ;
  char *__cil_tmp11 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  size_t __cil_tmp19 ;

  {
  {
#line 5917
  RemoveStatus();
  }
#line 5918
  if ((int )*(buf + len) == 9) {
#line 5921
    l = 0;
#line 5921
    r = 189;
#line 5922
    showmessage = 0;
#line 5923
    s = buf;
    {
#line 5925
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5925
      if (! ((int )*s && s - buf < (long )len)) {
#line 5925
        goto while_break;
      }
#line 5926
      __cil_tmp11 = s;
#line 5926
      s ++;
#line 5926
      if ((int )*__cil_tmp11 == 32) {
#line 5927
        return;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 5930
    if (display) {
#line 5930
      if (captionalways) {
#line 5932
        showmessage = 1;
      } else
#line 5930
      if (display->d_has_hstatus == 1) {
#line 5932
        showmessage = 1;
      } else
#line 5930
      if (display->d_canvas.c_slperp) {
#line 5930
        if ((display->d_canvas.c_slperp)->c_slnext) {
#line 5932
          showmessage = 1;
        }
      }
    }
    {
#line 5934
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5934
      if (! (l <= r)) {
#line 5934
        goto while_break___0;
      }
      {
#line 5936
      m = (l + r) / 2;
#line 5937
      x = strncmp((char const   *)buf, (char const   *)comms[m].name, (unsigned long )len);
      }
#line 5938
      if (x > 0) {
#line 5939
        l = m + 1;
      } else
#line 5940
      if (x < 0) {
#line 5941
        r = m - 1;
      } else {
#line 5944
        s = (char *)mbuf;
#line 5945
        l = m - 1;
        {
#line 5945
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 5945
          if (! (l >= 0 && __cil_tmp13 == 0)) {
#line 5945
            goto while_break___1;
          }

        }
        while_break___1: /* CIL Label */ ;
        }
#line 5945
        __cil_tmp14 = l;
#line 5945
        l --;
#line 5947
        l ++;
#line 5947
        m = l;
        {
#line 5947
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 5947
          if (! ((m <= r && __cil_tmp15 == 0) && (unsigned long )(s - (char *)mbuf) < sizeof(mbuf))) {
#line 5947
            goto while_break___2;
          }
          {
#line 5948
          __cil_tmp16 = snprintf(s, sizeof(mbuf) - (unsigned long )(s - (char *)mbuf),
                                 (char const   *)((char *)" %s"), comms[m].name);
          }
#line 5948
          s += __cil_tmp16;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 5947
        m ++;
#line 5949
        if (l < m - 1) {
#line 5951
          if (showmessage) {
            {
#line 5952
            Msg(0, (char const   *)((char *)"Possible commands:%s"), (char *)mbuf);
            }
          }
        } else {
          {
#line 5956
          s = (char *)mbuf;
#line 5957
          len = snprintf((char *)mbuf, sizeof(mbuf), (char const   *)((char *)"%s \t"),
                         comms[l].name + len);
          }
#line 5958
          if (len > 0) {
#line 5958
            if ((unsigned long )len < sizeof(mbuf)) {
              {
#line 5959
              (*((flayer->l_layfn)->lf_LayProcess))(& s, & len);
              }
            }
          }
        }
#line 5961
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5964
    if (l > r) {
#line 5964
      if (showmessage) {
        {
#line 5965
        Msg(0, (char const   *)((char *)"No commands matching \'%*s\'"), len, buf);
        }
      }
    }
#line 5966
    return;
  }
#line 5969
  if (! len) {
#line 5970
    return;
  } else
#line 5969
  if ((int )*(buf + len)) {
#line 5970
    return;
  }
  {
#line 5972
  __cil_tmp19 = strlen((char const   *)buf);
#line 5972
  len = (int )(__cil_tmp19 + 1UL);
  }
#line 5973
  if (len > (int )sizeof(mbuf)) {
    {
#line 5974
    RcLine(buf, len);
    }
  } else {
    {
#line 5977
    bcopy((void const   *)buf, (void *)((char *)mbuf), (size_t )len);
#line 5978
    RcLine((char *)mbuf, (int )sizeof(mbuf));
    }
  }
  return;
}
}
#line 5983 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void SelectFin(char *buf , int len , char *data ) 
{ 
  int n ;

  {
#line 5990
  if (! len) {
#line 5991
    return;
  } else
#line 5990
  if (! display) {
#line 5991
    return;
  }
#line 5992
  if (len == 1) {
#line 5992
    if ((int )*buf == 45) {
      {
#line 5994
      SetForeWindow((struct win *)0);
#line 5995
      Activate(0);
      }
#line 5996
      return;
    }
  }
  {
#line 5998
  n = WindowByNoN(buf);
  }
#line 5998
  if (n < 0) {
#line 5999
    return;
  }
  {
#line 6000
  SwitchWindow(n);
  }
  return;
}
}
#line 6004 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void SelectLayoutFin(char *buf , int len , char *data ) 
{ 
  struct layout *lay ;

  {
#line 6011
  if (! len) {
#line 6012
    return;
  } else
#line 6011
  if (! display) {
#line 6012
    return;
  }
#line 6013
  if (len == 1) {
#line 6013
    if ((int )*buf == 45) {
      {
#line 6015
      LoadLayout((struct layout *)0, (struct canvas *)0);
#line 6016
      Activate(0);
      }
#line 6017
      return;
    }
  }
  {
#line 6019
  lay = FindLayout(buf);
  }
#line 6020
  if (! lay) {
    {
#line 6021
    Msg(0, (char const   *)((char *)"No such layout\n"));
    }
  } else
#line 6022
  if (lay == display->d_layout) {
    {
#line 6023
    Msg(0, (char const   *)((char *)"This IS layout %d (%s).\n"), lay->lay_number,
        lay->lay_title);
    }
  } else {
    {
#line 6026
    LoadLayout(lay, & display->d_canvas);
#line 6027
    Activate(0);
    }
  }
  return;
}
}
#line 6033 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void InputSelect(void) 
{ 


  {
  {
#line 6035
  Input((char *)"Switch to window: ", 20, 0, SelectFin, (char *)((void *)0), 0);
  }
  return;
}
}
#line 6038
static char setenv_var[31] ;
#line 6042 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void SetenvFin1(char *buf , int len , char *data ) 
{ 


  {
#line 6047
  if (! len) {
#line 6048
    return;
  } else
#line 6047
  if (! display) {
#line 6048
    return;
  }
  {
#line 6049
  InputSetenv(buf);
  }
  return;
}
}
#line 6053 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void SetenvFin2(char *buf , int len , char *data ) 
{ 


  {
#line 6058
  if (! len) {
#line 6059
    return;
  } else
#line 6058
  if (! display) {
#line 6059
    return;
  }
  {
#line 6060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6060
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6061
  xsetenv((char *)setenv_var, buf);
#line 6062
  MakeNewEnv();
  }
  return;
}
}
#line 6066 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void InputSetenv(char *arg ) 
{ 
  static char setenv_buf[81] ;

  {
#line 6071
  if (arg) {
    {
#line 6073
    strncpy((char *)setenv_var, (char const   *)arg, sizeof(setenv_var) - 1UL);
#line 6074
    sprintf((char *)setenv_buf, (char const   *)((char *)"Enter value for %s: "),
            (char *)setenv_var);
#line 6075
    Input((char *)setenv_buf, 30, 0, SetenvFin2, (char *)((void *)0), 0);
    }
  } else {
    {
#line 6078
    Input((char *)"Setenv: Enter variable name: ", 30, 0, SetenvFin1, (char *)((void *)0),
          0);
    }
  }
  return;
}
}
#line 6089 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void DoScreen(char *fn , char **av ) 
{ 
  struct NewWindow nwin ;
  register int num ;
  char buf[20] ;
  int __cil_tmp9 ;

  {
#line 6096
  nwin = nwin_undef;
  {
#line 6097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6097
    if (! ((av && *av) && (int )*(*(av + 0) + 0) == 45)) {
#line 6097
      goto while_break;
    }
#line 6099
    if ((int )*(*(av + 0) + 1) == 45) {
#line 6101
      av ++;
#line 6102
      goto while_break;
    }
    {
#line 6106
    if ((int )*(*(av + 0) + 1) == 'f') {
#line 6106
      goto case_102;
    }
#line 6110
    if ((int )*(*(av + 0) + 1) == '0') {
#line 6110
      goto case_48;
    }
#line 6110
    if ((int )*(*(av + 0) + 1) == 'n') {
#line 6110
      goto case_48;
    }
#line 6115
    if ((int )*(*(av + 0) + 1) == '\000') {
#line 6115
      goto case_0;
    }
#line 6115
    if ((int )*(*(av + 0) + 1) == '1') {
#line 6115
      goto case_0;
    }
#line 6115
    if ((int )*(*(av + 0) + 1) == 'y') {
#line 6115
      goto case_0;
    }
#line 6118
    if ((int )*(*(av + 0) + 1) == 'a') {
#line 6118
      goto case_97;
    }
#line 6125
    if ((int )*(*(av + 0) + 1) == 't') {
#line 6125
      goto case_116;
    }
#line 6133
    if ((int )*(*(av + 0) + 1) == 'T') {
#line 6133
      goto case_84;
    }
#line 6141
    if ((int )*(*(av + 0) + 1) == 'h') {
#line 6141
      goto case_104;
    }
#line 6150
    if ((int )*(*(av + 0) + 1) == 'l') {
#line 6150
      goto case_108;
    }
#line 6154
    if ((int )*(*(av + 0) + 1) == '0') {
#line 6154
      goto case_48___0;
    }
#line 6154
    if ((int )*(*(av + 0) + 1) == 'n') {
#line 6154
      goto case_48___0;
    }
#line 6159
    if ((int )*(*(av + 0) + 1) == '\000') {
#line 6159
      goto case_0___0;
    }
#line 6159
    if ((int )*(*(av + 0) + 1) == '1') {
#line 6159
      goto case_0___0;
    }
#line 6159
    if ((int )*(*(av + 0) + 1) == 'y') {
#line 6159
      goto case_0___0;
    }
#line 6162
    if ((int )*(*(av + 0) + 1) == 'a') {
#line 6162
      goto case_97___0;
    }
#line 6170
    if ((int )*(*(av + 0) + 1) == 'a') {
#line 6170
      goto case_97___1;
    }
#line 6173
    if ((int )*(*(av + 0) + 1) == 'M') {
#line 6173
      goto case_77;
    }
#line 6176
    if ((int )*(*(av + 0) + 1) == 'L') {
#line 6176
      goto case_76;
    }
#line 6179
    goto switch_default___1;
    case_102: /* CIL Label */ 
    {
#line 6110
    if ((int )*(*(av + 0) + 2) == '0') {
#line 6110
      goto case_48;
    }
#line 6110
    if ((int )*(*(av + 0) + 2) == 'n') {
#line 6110
      goto case_48;
    }
#line 6115
    if ((int )*(*(av + 0) + 2) == '\000') {
#line 6115
      goto case_0;
    }
#line 6115
    if ((int )*(*(av + 0) + 2) == '1') {
#line 6115
      goto case_0;
    }
#line 6115
    if ((int )*(*(av + 0) + 2) == 'y') {
#line 6115
      goto case_0;
    }
#line 6118
    if ((int )*(*(av + 0) + 2) == 'a') {
#line 6118
      goto case_97;
    }
#line 6121
    goto switch_default;
    case_48: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 6111
    nwin.flowflag = 0;
#line 6112
    goto switch_break___0;
    case_0: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 6116
    nwin.flowflag = 1;
#line 6117
    goto switch_break___0;
    case_97: /* CIL Label */ 
#line 6119
    nwin.flowflag = 1 << 2;
#line 6120
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 6122
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 6124
    goto switch_break;
    case_116: /* CIL Label */ 
#line 6126
    if (*(*(av + 0) + 2)) {
#line 6127
      nwin.aka = & *(*(av + 0) + 2);
    } else {
#line 6128
      av ++;
#line 6128
      if (*av) {
#line 6129
        nwin.aka = *av;
      } else {
#line 6131
        av --;
      }
    }
#line 6132
    goto switch_break;
    case_84: /* CIL Label */ 
#line 6134
    if (*(*(av + 0) + 2)) {
#line 6135
      nwin.term = & *(*(av + 0) + 2);
    } else {
#line 6136
      av ++;
#line 6136
      if (*av) {
#line 6137
        nwin.term = *av;
      } else {
#line 6139
        av --;
      }
    }
#line 6140
    goto switch_break;
    case_104: /* CIL Label */ 
#line 6142
    if (*(*(av + 0) + 2)) {
      {
#line 6143
      nwin.histheight = atoi((char const   *)(*(av + 0) + 2));
      }
    } else {
#line 6144
      av ++;
#line 6144
      if (*av) {
        {
#line 6145
        nwin.histheight = atoi((char const   *)*av);
        }
      } else {
#line 6147
        av --;
      }
    }
#line 6148
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 6154
    if ((int )*(*(av + 0) + 2) == '0') {
#line 6154
      goto case_48___0;
    }
#line 6154
    if ((int )*(*(av + 0) + 2) == 'n') {
#line 6154
      goto case_48___0;
    }
#line 6159
    if ((int )*(*(av + 0) + 2) == '\000') {
#line 6159
      goto case_0___0;
    }
#line 6159
    if ((int )*(*(av + 0) + 2) == '1') {
#line 6159
      goto case_0___0;
    }
#line 6159
    if ((int )*(*(av + 0) + 2) == 'y') {
#line 6159
      goto case_0___0;
    }
#line 6162
    if ((int )*(*(av + 0) + 2) == 'a') {
#line 6162
      goto case_97___0;
    }
#line 6165
    goto switch_default___0;
    case_48___0: /* CIL Label */ 
    case_110___0: /* CIL Label */ 
#line 6155
    nwin.lflag = 0;
#line 6156
    goto switch_break___1;
    case_0___0: /* CIL Label */ 
    case_49___0: /* CIL Label */ 
    case_121___0: /* CIL Label */ 
#line 6160
    nwin.lflag = 1;
#line 6161
    goto switch_break___1;
    case_97___0: /* CIL Label */ 
#line 6163
    nwin.lflag = 3;
#line 6164
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 6166
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 6168
    goto switch_break;
    case_97___1: /* CIL Label */ 
#line 6171
    nwin.aflag = 1;
#line 6172
    goto switch_break;
    case_77: /* CIL Label */ 
#line 6174
    nwin.monitor = 1;
#line 6175
    goto switch_break;
    case_76: /* CIL Label */ 
#line 6177
    nwin.Lflag = 1;
#line 6178
    goto switch_break;
    switch_default___1: /* CIL Label */ 
    {
#line 6180
    Msg(0, (char const   *)((char *)"%s: screen: invalid option -%c."), fn, (int )*(*(av + 0) + 1));
    }
#line 6181
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 6183
    av ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6185
  __cil_tmp9 = IsNumColon(*av, 10, (char *)buf, (int )sizeof(buf));
  }
#line 6185
  if (av) {
#line 6185
    if (*av) {
#line 6185
      if (__cil_tmp9) {
#line 6187
        if ((int )*((char *)buf) != 0) {
#line 6188
          nwin.aka = (char *)buf;
        }
        {
#line 6189
        num = atoi((char const   *)*av);
        }
#line 6190
        if (num < 0) {
          {
          {
          {
#line 6192
          Msg(0, (char const   *)((char *)"%s: illegal screen number %d."), fn, num);
          }
          }
#line 6193
          num = 0;
          }
        } else
#line 6190
        if (maxwin) {
#line 6190
          if (num > maxwin - 1) {
            {
            {
            {
#line 6192
            Msg(0, (char const   *)((char *)"%s: illegal screen number %d."), fn,
                num);
            }
            }
#line 6193
            num = 0;
            }
          } else {
#line 6190
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 6190
        if (! maxwin) {
#line 6190
          if (num > 99) {
            {
            {
            {
#line 6192
            Msg(0, (char const   *)((char *)"%s: illegal screen number %d."), fn,
                num);
            }
            }
#line 6193
            num = 0;
            }
          }
        }
#line 6195
        nwin.StartAt = num;
#line 6196
        av ++;
      }
    }
  }
#line 6198
  if (av) {
#line 6198
    if (*av) {
#line 6200
      nwin.args = av;
#line 6201
      if (! nwin.aka) {
        {
#line 6202
        nwin.aka = Filename(*av);
        }
      }
    }
  }
  {
#line 6204
  MakeWindow(& nwin);
  }
  return;
}
}
#line 6218 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int CompileKeys(char *s , int sl , unsigned char *array ) 
{ 
  int i ;
  unsigned char key ;
  unsigned char value ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 6226
  if (sl == 0) {
#line 6228
    i = 0;
    {
#line 6228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6228
      if (! (i < 256)) {
#line 6228
        goto while_break;
      }
#line 6229
      *(array + i) = (unsigned char )i;
    }
    while_break: /* CIL Label */ ;
    }
#line 6228
    i ++;
#line 6230
    return (0);
  }
  {
#line 6232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6232
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 6233
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6233
    if (! sl) {
#line 6233
      goto while_break___1;
    }
#line 6235
    __cil_tmp8 = s;
#line 6235
    s ++;
#line 6235
    key = *((unsigned char *)__cil_tmp8);
#line 6236
    if ((int )*s != 61) {
#line 6237
      return (- 1);
    } else
#line 6236
    if (sl < 3) {
#line 6237
      return (- 1);
    }
#line 6238
    __cil_tmp9 = sl;
#line 6238
    sl --;
    {
#line 6239
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6241
      s ++;
#line 6242
      sl -= 2;
#line 6243
      __cil_tmp11 = s;
#line 6243
      s ++;
#line 6243
      value = *((unsigned char *)__cil_tmp11);
#line 6244
      *(array + value) = key;
#line 6239
      if (! ((int )*s == 61 && sl >= 2)) {
#line 6239
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 6247
    if (sl == 0) {
#line 6248
      goto while_break___1;
    }
#line 6249
    __cil_tmp12 = s;
#line 6249
    s ++;
#line 6249
    if ((int )*__cil_tmp12 != 58) {
#line 6250
      return (- 1);
    }
#line 6251
    __cil_tmp13 = sl;
#line 6251
    sl --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6253
  return (0);
}
}
#line 6263 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void pow_detach_fn(char *buf , int len , char *data ) 
{ 


  {
  {
#line 6268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6268
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 6269
  if (len) {
    {
#line 6271
    memset((void *)buf, 0, (unsigned long )len);
    }
#line 6272
    return;
  }
#line 6274
  if (ktab[(int )((unsigned char )*buf)].nr != 128) {
#line 6276
    if (display) {
      {
#line 6277
      write(display->d_userfd, (void const   *)((char *)"\a"), (size_t )1);
      }
    }
    {
#line 6278
    Msg(0, (char const   *)((char *)"Detach aborted."));
    }
  } else {
    {
#line 6281
    Detach(3);
    }
  }
  return;
}
}
#line 6287 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void copy_reg_fn(char *buf , int len , char *data ) 
{ 
  struct plop *pp ;
  void *__cil_tmp5 ;

  {
#line 6292
  pp = (struct plop *)plop_tab + (int )((unsigned char )*buf);
#line 6294
  if (len) {
    {
#line 6296
    memset((void *)buf, 0, (unsigned long )len);
    }
#line 6297
    return;
  }
#line 6299
  if (pp->buf) {
    {
#line 6300
    free((void *)pp->buf);
    }
  }
#line 6301
  pp->buf = (char *)0;
#line 6302
  pp->len = 0;
#line 6303
  if ((display->d_user)->u_plop.len) {
    {
#line 6305
    __cil_tmp5 = malloc((unsigned long )(display->d_user)->u_plop.len);
#line 6305
    pp->buf = (char *)__cil_tmp5;
    }
#line 6305
    if (pp->buf == (char *)((void *)0)) {
      {
#line 6307
      Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
      }
#line 6308
      return;
    }
    {
#line 6310
    bcopy((void const   *)(display->d_user)->u_plop.buf, (void *)pp->buf, (size_t )(display->d_user)->u_plop.len);
    }
  }
  {
#line 6312
  pp->len = (display->d_user)->u_plop.len;
#line 6314
  pp->enc = (display->d_user)->u_plop.enc;
#line 6316
  Msg(0, (char const   *)((char *)"Copied %d characters into register %c"), (display->d_user)->u_plop.len,
      (int )*buf);
  }
  return;
}
}
#line 6320 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void ins_reg_fn(char *buf , int len , char *data ) 
{ 
  struct plop *pp ;

  {
#line 6325
  pp = (struct plop *)plop_tab + (int )((unsigned char )*buf);
#line 6327
  if (len) {
    {
#line 6329
    memset((void *)buf, 0, (unsigned long )len);
    }
#line 6330
    return;
  }
#line 6332
  if (! fore) {
#line 6333
    return;
  }
#line 6334
  if ((int )*buf == 46) {
    {
#line 6335
    Msg(0, (char const   *)((char *)"ins_reg_fn: Warning: pasting real register \'.\'!"));
    }
  }
#line 6336
  if (pp->buf) {
    {
#line 6338
    MakePaster(& fore->w_paster, pp->buf, pp->len, 0);
    }
#line 6339
    return;
  }
  {
#line 6341
  Msg(0, (char const   *)((char *)"Empty register."));
  }
  return;
}
}
#line 6346 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void process_fn(char *buf , int len , char *data ) 
{ 
  struct plop *pp ;

  {
#line 6351
  pp = (struct plop *)plop_tab + (int )((unsigned char )*buf);
#line 6353
  if (len) {
    {
#line 6355
    memset((void *)buf, 0, (unsigned long )len);
    }
#line 6356
    return;
  }
#line 6358
  if (pp->buf) {
    {
#line 6360
    ProcessInput(pp->buf, pp->len);
    }
#line 6361
    return;
  }
  {
#line 6363
  Msg(0, (char const   *)((char *)"Empty register."));
  }
  return;
}
}
#line 6367 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void confirm_fn(char *buf , int len , char *data ) 
{ 
  struct action act ;

  {
#line 6374
  if (len) {
    {
    {
#line 6376
    memset((void *)buf, 0, (unsigned long )len);
    }
    }
#line 6377
    return;
  } else
#line 6374
  if ((int )*buf != 121) {
#line 6374
    if ((int )*buf != 89) {
      {
      {
#line 6376
      memset((void *)buf, 0, (unsigned long )len);
      }
      }
#line 6377
      return;
    }
  }
  {
#line 6379
  act.nr = *((int *)data);
#line 6380
  act.args = (char **)noargs;
#line 6381
  act.argl = (int *)0;
#line 6382
  act.quiet = 0;
#line 6383
  DoAction(& act, - 1);
  }
  return;
}
}
#line 6396 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void su_fin(char *buf , int len , char *data ) 
{ 
  struct inputsu *i ;
  char *p ;
  int l ;
  int tmp ;

  {
#line 6401
  i = (struct inputsu *)data;
#line 6405
  if (! *((char *)i->name)) {
#line 6406
    p = (char *)i->name;
#line 6406
    l = (int )(sizeof(i->name) - 1UL);
  } else
#line 6407
  if (! *((char *)i->pw1)) {
    {
#line 6408
    p = (char *)i->pw1;
#line 6408
    strcpy(p, (char const   *)((char *)"\377"));
#line 6408
    l = (int )(sizeof(i->pw1) - 1UL);
    }
  } else {
    {
#line 6410
    p = (char *)i->pw2;
#line 6410
    strcpy(p, (char const   *)((char *)"\377"));
#line 6410
    l = (int )(sizeof(i->pw2) - 1UL);
    }
  }
#line 6411
  if (buf) {
#line 6411
    if (len) {
#line 6412
      if (l < len) {
#line 6412
        tmp = l;
      } else {
#line 6412
        tmp = len;
      }
      {
#line 6412
      strncpy(p, (char const   *)buf, (unsigned long )(1 + tmp));
      }
    }
  }
#line 6413
  if (! *((char *)i->name)) {
    {
#line 6414
    Input((char *)"Screen User: ", (int )(sizeof(i->name) - 1UL), 0, su_fin, (char *)i,
          0);
    }
  } else
#line 6415
  if (! *((char *)i->pw1)) {
    {
#line 6416
    Input((char *)"User\'s UNIX Password: ", (int )(sizeof(i->pw1) - 1UL), 1, su_fin,
          (char *)i, 0);
    }
  } else
#line 6417
  if (! *((char *)i->pw2)) {
    {
#line 6418
    Input((char *)"User\'s Screen Password: ", (int )(sizeof(i->pw2) - 1UL), 1, su_fin,
          (char *)i, 0);
    }
  } else {
    {
#line 6421
    p = DoSu(i->up, (char *)i->name, (char *)i->pw2, (char *)i->pw1);
    }
#line 6421
    if (p) {
      {
#line 6422
      Msg(0, (char const   *)((char *)"%s"), p);
      }
    }
    {
#line 6423
    free((void *)((char *)i));
    }
  }
  return;
}
}
#line 6428 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int InputSu(struct win *w , struct acluser **up , char *name ) 
{ 
  struct inputsu *i ;
  void *__cil_tmp5 ;
  size_t __cil_tmp6 ;

  {
  {
#line 6435
  __cil_tmp5 = calloc((unsigned long )1, sizeof(struct inputsu ));
#line 6435
  i = (struct inputsu *)__cil_tmp5;
  }
#line 6435
  if (! i) {
#line 6436
    return (- 1);
  }
#line 6438
  i->up = up;
#line 6439
  if (name) {
#line 6439
    if ((int )*name) {
      {
#line 6440
      __cil_tmp6 = strlen((char const   *)name);
#line 6440
      su_fin(name, (int )__cil_tmp6, (char *)i);
      }
    } else {
      {
      {
#line 6442
      su_fin((char *)0, 0, (char *)i);
      }
      }
    }
  } else {
    {
    {
#line 6442
    su_fin((char *)0, 0, (char *)i);
    }
    }
  }
#line 6443
  return (0);
}
}
#line 6450 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void pass1(char *buf , int len , char *data ) 
{ 
  struct acluser *u ;
  size_t __cil_tmp6 ;

  {
#line 6455
  u = (struct acluser *)data;
#line 6457
  if (! *buf) {
#line 6458
    return;
  }
  {
#line 6459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6459
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 6460
  if (u->u_password != (char *)NullStr) {
    {
#line 6461
    free((void *)u->u_password);
    }
  }
  {
#line 6462
  u->u_password = SaveStr((char const   *)buf);
#line 6463
  __cil_tmp6 = strlen((char const   *)buf);
#line 6463
  bzero((void *)buf, __cil_tmp6);
#line 6464
  Input((char *)"Retype new password:", 100, 1, pass2, data, 0);
  }
  return;
}
}
#line 6468 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void pass2(char *buf , int len , char *data ) 
{ 
  int st ;
  char salt[3] ;
  struct acluser *u ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  time_t __cil_tmp10 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;

  {
#line 6475
  u = (struct acluser *)data;
  {
#line 6477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6477
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6478
  __cil_tmp7 = strcmp((char const   *)u->u_password, (char const   *)buf);
  }
#line 6478
  if (! buf) {
    _L: /* CIL Label */ 
    {
#line 6480
    Msg(0, (char const   *)((char *)"[ Passwords don\'t match - checking turned off ]"));
    }
#line 6481
    if (u->u_password != (char *)NullStr) {
      {
#line 6483
      __cil_tmp8 = strlen((char const   *)u->u_password);
#line 6483
      bzero((void *)u->u_password, __cil_tmp8);
#line 6484
      free((void *)u->u_password);
      }
    }
#line 6486
    u->u_password = (char *)NullStr;
  } else
#line 6478
  if (__cil_tmp7) {
#line 6478
    goto _L;
  } else
#line 6488
  if ((int )*(u->u_password + 0) == 0) {
    {
#line 6490
    Msg(0, (char const   *)((char *)"[ No password - no secure ]"));
    }
#line 6491
    if (buf) {
      {
#line 6492
      __cil_tmp9 = strlen((char const   *)buf);
#line 6492
      bzero((void *)buf, __cil_tmp9);
      }
    }
  }
#line 6495
  if (u->u_password != (char *)NullStr) {
#line 6497
    st = 0;
    {
#line 6497
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6497
      if (! (st < 2)) {
#line 6497
        goto while_break___0;
      }
      {
#line 6498
      __cil_tmp10 = time((time_t *)0);
#line 6498
      salt[st] = (char )(65 + (int )((__cil_tmp10 >> 6 * st) % 26L));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 6497
    st ++;
#line 6499
    salt[2] = (char )0;
#line 6500
    buf = crypt((char const   *)u->u_password, (char const   *)((char *)salt));
#line 6501
    __cil_tmp13 = strlen((char const   *)u->u_password);
#line 6501
    bzero((void *)u->u_password, __cil_tmp13);
#line 6502
    free((void *)u->u_password);
    }
#line 6503
    if (! buf) {
      {
#line 6505
      Msg(0, (char const   *)((char *)"[ crypt() error - no secure ]"));
#line 6506
      u->u_password = (char *)NullStr;
      }
#line 6507
      return;
    }
    {
#line 6509
    u->u_password = SaveStr((char const   *)buf);
#line 6510
    __cil_tmp15 = strlen((char const   *)buf);
#line 6510
    bzero((void *)buf, __cil_tmp15);
    }
#line 6512
    if (u->u_plop.buf) {
      {
#line 6513
      UserFreeCopyBuffer(u);
      }
    }
    {
#line 6514
    __cil_tmp16 = strlen((char const   *)u->u_password);
#line 6514
    u->u_plop.len = (int )__cil_tmp16;
#line 6516
    u->u_plop.enc = 0;
#line 6518
    u->u_plop.buf = SaveStr((char const   *)u->u_password);
    }
#line 6518
    if (! u->u_plop.buf) {
      {
#line 6520
      Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
#line 6521
      (display->d_user)->u_plop.len = 0;
      }
    } else {
      {
#line 6524
      Msg(0, (char const   *)((char *)"[ Password moved into copybuffer ]"));
      }
    }
  }
  return;
}
}
#line 6533 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int digraph_find(char const   *buf ) 
{ 
  int i ;

  {
#line 6537
  i = 0;
  {
#line 6537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6537
    if (! (i < 512 && (int )digraphs[i].d[0])) {
#line 6537
      goto while_break;
    }
#line 6538
    if ((int )digraphs[i].d[0] == (int )((unsigned char )((char )*(buf + 0)))) {
#line 6538
      if ((int )digraphs[i].d[1] == (int )((unsigned char )((char )*(buf + 1)))) {
#line 6540
        goto while_break;
      } else {
#line 6538
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 6538
    if ((int )digraphs[i].d[0] == (int )((unsigned char )((char )*(buf + 1)))) {
#line 6538
      if ((int )digraphs[i].d[1] == (int )((unsigned char )((char )*(buf + 0)))) {
#line 6540
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6537
  i ++;
#line 6541
  return (i);
}
}
#line 6545 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void digraph_fn(char *buf , int len , char *data ) 
{ 
  int ch ;
  int i ;
  int x ;
  int tmp ;
  int __cil_tmp9 ;

  {
#line 6552
  ch = (int )*(buf + len);
#line 6553
  if (ch) {
#line 6555
    *(buf + (len + 1)) = (char )ch;
#line 6556
    if (ch < 32) {
#line 6557
      return;
    } else
#line 6556
    if (ch == 127) {
#line 6557
      return;
    }
#line 6558
    if (len >= 1) {
#line 6558
      if ((int )*buf == 85) {
#line 6558
        if ((int )*(buf + 1) == 43) {
          _L___787: /* CIL Label */ 
#line 6560
          if (len == 1) {
#line 6561
            return;
          }
#line 6562
          if (ch < 48) {
            _L___786: /* CIL Label */ 
#line 6562
            if (ch < 97) {
              _L: /* CIL Label */ 
#line 6562
              if (ch < 65) {
#line 6564
                *(buf + len) = (char )'\034';
#line 6565
                return;
              } else
#line 6562
              if (ch > 70) {
#line 6564
                *(buf + len) = (char )'\034';
#line 6565
                return;
              }
            } else
#line 6562
            if (ch > 102) {
#line 6562
              goto _L;
            }
          } else
#line 6562
          if (ch > 57) {
#line 6562
            goto _L___786;
          }
#line 6567
          if ((int )*buf == 85) {
#line 6567
            tmp = 5;
          } else {
#line 6567
            tmp = 3;
          }
#line 6567
          if (len == tmp) {
#line 6568
            *(buf + len) = (char )'\n';
          }
#line 6569
          return;
        } else {
#line 6558
          goto _L___788;
        }
      } else
      _L___788: /* CIL Label */ 
#line 6558
      if ((int )*buf == 48) {
#line 6558
        if ((int )*(buf + 1) == 120) {
#line 6558
          goto _L___787;
        } else
#line 6558
        if ((int )*(buf + 1) == 88) {
#line 6558
          goto _L___787;
        }
      }
    }
#line 6571
    if (len) {
#line 6571
      if ((int )*buf == 48) {
#line 6573
        if (ch < 48) {
#line 6575
          *(buf + len) = (char )'\034';
#line 6576
          return;
        } else
#line 6573
        if (ch > 55) {
#line 6575
          *(buf + len) = (char )'\034';
#line 6576
          return;
        }
#line 6578
        if (len == 3) {
#line 6579
          *(buf + len) = (char )'\n';
        }
#line 6580
        return;
      }
    }
#line 6582
    if (len == 1) {
#line 6583
      *(buf + len) = (char )'\n';
    }
#line 6584
    return;
  }
#line 6586
  if (len < 1) {
#line 6587
    return;
  }
#line 6588
  if (*(buf + (len + 1))) {
#line 6590
    *(buf + len) = *(buf + (len + 1));
#line 6591
    len ++;
  }
#line 6593
  if (len < 2) {
#line 6594
    return;
  }
  {
#line 6595
  __cil_tmp9 = parse_input_int((char const   *)buf, len, & x);
  }
#line 6595
  if (! __cil_tmp9) {
    {
#line 6597
    i = digraph_find((char const   *)buf);
#line 6598
    x = digraphs[i].value;
    }
#line 6598
    if (x <= 0) {
      {
#line 6600
      Msg(0, (char const   *)((char *)"Unknown digraph"));
      }
#line 6601
      return;
    }
  }
#line 6604
  i = 1;
#line 6605
  *buf = (char )x;
#line 6607
  if (flayer->l_encoding == 8) {
    {
#line 6608
    i = ToUtf8(buf, x);
    }
  }
  {
#line 6610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6610
    if (! i) {
#line 6610
      goto while_break;
    }
    {
#line 6611
    (*((flayer->l_layfn)->lf_LayProcess))(& buf, & i);
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 6616 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int StuffKey(int i ) 
{ 
  struct action *act ;
  int discard ;
  int keyno ;
  struct action *act___789 ;
  struct action *tmp ;
  struct action *tmp___791 ;
  struct action *tmp___793 ;
  size_t __cil_tmp9 ;

  {
#line 6620
  discard = 0;
#line 6621
  keyno = i;
  {
#line 6623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6623
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 6629
  if (i < 82) {
#line 6629
    if (display->d_ESCseen) {
#line 6631
      act___789 = & *(display->d_ESCseen + (i + 256));
#line 6632
      if (act___789->nr != -1) {
        {
#line 6634
        display->d_ESCseen = (struct action *)0;
#line 6635
        WindowChanged(fore, 'E');
#line 6636
        DoAction(act___789, i + 256);
        }
#line 6637
        return (0);
      }
#line 6639
      discard = 1;
    }
  }
#line 6642
  if (i >= 60) {
#line 6642
    if (i < 64) {
#line 6642
      if (display->d_cursorkeys) {
#line 6643
        i += 22;
      } else {
#line 6642
        goto _L;
      }
    } else {
#line 6642
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 6644
  if (i >= 64) {
#line 6644
    if (i < 82) {
#line 6644
      if (display->d_keypad) {
#line 6645
        i += 22;
      }
    }
  }
  {
#line 6646
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6646
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6647
  flayer = (display->d_forecv)->c_layer;
#line 6648
  fore = display->d_fore;
#line 6649
  act = (struct action *)0;
#line 6651
  if (flayer) {
#line 6651
    if (flayer->l_mode == 1) {
#line 6652
      if (i < 104) {
#line 6652
        tmp = & mmtab[i];
      } else {
#line 6652
        tmp = & (kmap_exts + (i - 104))->mm;
      }
#line 6652
      act = tmp;
    }
  }
#line 6654
  if (! act) {
    _L___792: /* CIL Label */ 
#line 6654
    if (! display->d_mapdefault) {
#line 6655
      if (i < 104) {
#line 6655
        tmp___791 = & umtab[i];
      } else {
#line 6655
        tmp___791 = & (kmap_exts + (i - 104))->um;
      }
#line 6655
      act = tmp___791;
    }
  } else
#line 6654
  if (act->nr == -1) {
#line 6654
    goto _L___792;
  }
#line 6656
  if (! act) {
    _L___794: /* CIL Label */ 
#line 6657
    if (i < 104) {
#line 6657
      tmp___793 = & dmtab[i];
    } else {
#line 6657
      tmp___793 = & (kmap_exts + (i - 104))->dm;
    }
#line 6657
    act = tmp___793;
  } else
#line 6656
  if (act->nr == -1) {
#line 6656
    goto _L___794;
  }
#line 6659
  if (discard) {
#line 6659
    if (! act) {
      _L___795: /* CIL Label */ 
      {
#line 6662
      __cil_tmp9 = strlen((char const   *)display->d_tcs[keyno + 106].str);
      }
#line 6662
      if (display->d_tcs[keyno + 106].str) {
#line 6662
        if (__cil_tmp9 == 1UL) {
#line 6663
          return (- 1);
        }
      }
#line 6664
      if (display->d_ESCseen) {
        {
#line 6666
        display->d_ESCseen = (struct action *)0;
#line 6667
        WindowChanged(fore, 'E');
        }
      }
#line 6669
      return (0);
    } else
#line 6659
    if (act->nr != 35) {
#line 6659
      goto _L___795;
    }
  }
#line 6671
  display->d_mapdefault = 0;
#line 6673
  if (act == (struct action *)0) {
#line 6674
    return (- 1);
  } else
#line 6673
  if (act->nr == -1) {
#line 6674
    return (- 1);
  }
  {
#line 6675
  DoAction(act, 0);
  }
#line 6676
  return (0);
}
}
#line 6682 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int IsOnDisplay(struct win *wi ) 
{ 
  struct canvas *cv ;

  {
  {
#line 6686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6686
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 6687
  cv = display->d_cvlist;
  {
#line 6687
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6687
    if (! cv) {
#line 6687
      goto while_break___0;
    }
#line 6688
    if ((struct win *)((cv->c_layer)->l_bottom)->l_data == wi) {
#line 6689
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6687
  cv = cv->c_next;
#line 6690
  return (0);
}
}
#line 6694 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
struct win *FindNiceWindow(struct win *wi , char *presel ) 
{ 
  int i ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 6700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6700
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 6701
  if (presel) {
    {
#line 6703
    i = WindowByNoN(presel);
    }
#line 6704
    if (i >= 0) {
#line 6705
      wi = *(wtab + i);
    }
  }
#line 6707
  if (! display) {
#line 6708
    return (wi);
  }
  {
#line 6710
  __cil_tmp5 = AclCheckPermWin(display->d_user, 2, wi);
  }
#line 6710
  if (wi) {
#line 6710
    if (__cil_tmp5) {
#line 6711
      wi = (struct win *)0;
    }
  }
  {
#line 6713
  __cil_tmp6 = IsOnDisplay(wi);
  }
#line 6713
  if (! wi) {
    _L: /* CIL Label */ 
#line 6716
    wi = (struct win *)0;
#line 6718
    wi = windows;
    {
#line 6718
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6718
      if (! wi) {
#line 6718
        goto while_break___0;
      }
      {
#line 6719
      __cil_tmp7 = AclCheckPermWin(display->d_user, 1, wi);
      }
#line 6719
      if (! wi->w_layer.l_cvlist) {
#line 6719
        if (! __cil_tmp7) {
#line 6720
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6718
    wi = wi->w_next;
#line 6721
    if (! wi) {
#line 6722
      wi = windows;
      {
#line 6722
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 6722
        if (! wi) {
#line 6722
          goto while_break___1;
        }
        {
#line 6723
        __cil_tmp9 = AclCheckPermWin(display->d_user, 1, wi);
        }
        {
#line 6723
        __cil_tmp8 = IsOnDisplay(wi);
        }
#line 6723
        if (wi->w_layer.l_cvlist) {
#line 6723
          if (! __cil_tmp8) {
#line 6723
            if (! __cil_tmp9) {
#line 6724
              goto while_break___1;
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 6722
      wi = wi->w_next;
    }
#line 6725
    if (! wi) {
#line 6726
      wi = windows;
      {
#line 6726
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 6726
        if (! wi) {
#line 6726
          goto while_break___2;
        }
        {
#line 6727
        __cil_tmp10 = AclCheckPermWin(display->d_user, 2, wi);
        }
#line 6727
        if (! wi->w_layer.l_cvlist) {
#line 6727
          if (! __cil_tmp10) {
#line 6728
            goto while_break___2;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 6726
      wi = wi->w_next;
    }
#line 6729
    if (! wi) {
#line 6730
      wi = windows;
      {
#line 6730
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 6730
        if (! wi) {
#line 6730
          goto while_break___3;
        }
        {
#line 6731
        __cil_tmp12 = AclCheckPermWin(display->d_user, 2, wi);
        }
        {
#line 6731
        __cil_tmp11 = IsOnDisplay(wi);
        }
#line 6731
        if (wi->w_layer.l_cvlist) {
#line 6731
          if (! __cil_tmp11) {
#line 6731
            if (! __cil_tmp12) {
#line 6732
              goto while_break___3;
            }
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 6730
      wi = wi->w_next;
    }
#line 6734
    if (! wi) {
#line 6735
      wi = windows;
      {
#line 6735
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 6735
        if (! wi) {
#line 6735
          goto while_break___4;
        }
#line 6736
        if (! wi->w_layer.l_cvlist) {
#line 6737
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 6735
      wi = wi->w_next;
    }
#line 6738
    if (! wi) {
#line 6739
      wi = windows;
      {
#line 6739
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 6739
        if (! wi) {
#line 6739
          goto while_break___5;
        }
        {
#line 6740
        __cil_tmp13 = IsOnDisplay(wi);
        }
#line 6740
        if (wi->w_layer.l_cvlist) {
#line 6740
          if (! __cil_tmp13) {
#line 6741
            goto while_break___5;
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 6739
      wi = wi->w_next;
    }
  } else
#line 6713
  if (__cil_tmp6) {
#line 6713
    if (! presel) {
#line 6713
      goto _L;
    }
  }
  {
#line 6744
  __cil_tmp14 = AclCheckPermWin(display->d_user, 2, wi);
  }
#line 6744
  if (wi) {
#line 6744
    if (__cil_tmp14) {
#line 6745
      wi = (struct win *)0;
    }
  }
#line 6747
  return (wi);
}
}
#line 6813 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int CalcSlicePercent(struct canvas *cv , int percent ) 
{ 
  int w ;
  int wsum ;
  int up ;

  {
#line 6818
  if (! cv) {
#line 6819
    return (percent);
  } else
#line 6818
  if (! cv->c_slback) {
#line 6819
    return (percent);
  }
  {
#line 6820
  up = CalcSlicePercent((cv->c_slback)->c_slback, percent);
#line 6821
  w = cv->c_slweight;
#line 6822
  wsum = 0;
  }
#line 6822
  cv = (cv->c_slback)->c_slperp;
  {
#line 6822
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6822
    if (! cv) {
#line 6822
      goto while_break;
    }
#line 6823
    wsum += cv->c_slweight;
  }
  while_break: /* CIL Label */ ;
  }
#line 6822
  cv = cv->c_slnext;
#line 6824
  if (wsum == 0) {
#line 6825
    return (0);
  }
#line 6826
  return ((up * w) / wsum);
}
}
#line 6830 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static int ChangeCanvasSize(struct canvas *fcv , int abs , int diff , int gflag ,
                            int percent ) 
{ 
  struct canvas *cv ;
  int done ;
  int have ;
  int m ;
  int dir ;
  int wsum ;
  int up ;
  int __cil_tmp13 ;
  int tmp ;
  int scale ;
  int tmp___796 ;
  int tmp___797 ;
  int tmp___798 ;
  struct canvas *tmp___799 ;
  int __cil_tmp20 ;
  int tmp___800 ;
  struct canvas *tmp___801 ;
  int __cil_tmp23 ;

  {
  {
#line 6840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6840
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 6841
  if (abs == 0) {
#line 6841
    if (diff == 0) {
#line 6842
      return (0);
    }
  }
#line 6843
  if (abs == 2) {
#line 6845
    if (diff == 0) {
#line 6846
      fcv->c_slweight = 0;
    } else {
#line 6849
      cv = (fcv->c_slback)->c_slperp;
      {
#line 6849
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 6849
        if (! cv) {
#line 6849
          goto while_break___0;
        }
#line 6850
        cv->c_slweight = 0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 6849
      cv = cv->c_slnext;
#line 6851
      fcv->c_slweight = 1;
#line 6852
      cv = (fcv->c_slback)->c_slback;
#line 6853
      if (gflag) {
#line 6853
        if (cv) {
#line 6853
          if (cv->c_slback) {
            {
#line 6854
            ChangeCanvasSize(cv, abs, diff, gflag, percent);
            }
          }
        }
      }
    }
#line 6856
    return (diff);
  }
#line 6858
  if (abs) {
#line 6860
    if (diff < 0) {
#line 6861
      diff = 0;
    }
#line 6862
    if (percent) {
#line 6862
      if (diff > percent) {
#line 6863
        diff = percent;
      }
    }
  }
#line 6865
  if (percent) {
#line 6868
    wsum = 0;
#line 6868
    cv = (fcv->c_slback)->c_slperp;
    {
#line 6868
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 6868
      if (! cv) {
#line 6868
        goto while_break___1;
      }
#line 6869
      wsum += cv->c_slweight;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 6868
    cv = cv->c_slnext;
#line 6870
    if (wsum) {
#line 6872
      if (gflag) {
        {
#line 6872
        __cil_tmp13 = CalcSlicePercent((fcv->c_slback)->c_slback, percent);
#line 6872
        tmp = __cil_tmp13;
        }
      } else {
#line 6872
        tmp = percent;
      }
#line 6872
      up = tmp;
      {
#line 6873
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 6873
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 6874
      if (wsum < 1000) {
#line 6876
        if (wsum < 10) {
#line 6876
          tmp___796 = 1000;
        } else {
#line 6876
          tmp___796 = 100;
        }
#line 6876
        scale = tmp___796;
#line 6877
        cv = (fcv->c_slback)->c_slperp;
        {
#line 6877
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 6877
          if (! cv) {
#line 6877
            goto while_break___3;
          }
#line 6878
          cv->c_slweight *= scale;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 6877
        cv = cv->c_slnext;
#line 6879
        wsum *= scale;
        {
#line 6880
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 6880
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 6882
      cv = (fcv->c_slback)->c_slperp;
      {
#line 6882
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 6882
        if (! cv) {
#line 6882
          goto while_break___5;
        }
#line 6884
        if (cv->c_slweight) {
#line 6886
          cv->c_slweight = (cv->c_slweight * up) / percent;
#line 6887
          if (cv->c_slweight == 0) {
#line 6888
            cv->c_slweight = 1;
          }
        }
        {
#line 6890
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 6890
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 6882
      cv = cv->c_slnext;
#line 6892
      diff = (diff * wsum) / percent;
#line 6893
      percent = wsum;
    }
  } else {
#line 6898
    if (fcv->c_slorient == 1) {
#line 6898
      tmp___797 = (fcv->c_ye - fcv->c_ys) + 2;
    } else {
#line 6898
      tmp___797 = (fcv->c_xe - fcv->c_xs) + 2;
    }
#line 6898
    if (abs) {
#line 6898
      if (diff == tmp___797) {
#line 6899
        return (0);
      }
    }
#line 6901
    cv = (fcv->c_slback)->c_slperp;
    {
#line 6901
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 6901
      if (! cv) {
#line 6901
        goto while_break___7;
      }
#line 6903
      if (cv->c_slorient == 1) {
#line 6903
        tmp___798 = (cv->c_ye - cv->c_ys) + 2;
      } else {
#line 6903
        tmp___798 = (cv->c_xe - cv->c_xs) + 2;
      }
#line 6903
      cv->c_slweight = tmp___798;
      {
#line 6904
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 6904
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 6901
    cv = cv->c_slnext;
  }
#line 6907
  if (abs) {
#line 6908
    diff -= fcv->c_slweight;
  }
  {
#line 6909
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 6909
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 6910
  if (diff == 0) {
#line 6911
    return (0);
  }
#line 6912
  if (diff < 0) {
#line 6914
    if (fcv->c_slnext) {
#line 6914
      tmp___799 = fcv->c_slnext;
    } else {
#line 6914
      tmp___799 = fcv->c_slprev;
    }
#line 6914
    cv = tmp___799;
#line 6915
    fcv->c_slweight += diff;
#line 6916
    cv->c_slweight -= diff;
#line 6917
    return (diff);
  }
#line 6919
  done = 0;
#line 6920
  dir = 1;
#line 6921
  cv = fcv->c_slnext;
  {
#line 6921
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 6921
    if (! (diff > 0)) {
#line 6921
      goto while_break___10;
    }
#line 6923
    if (! cv) {
      {
#line 6925
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 6925
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 6926
      if (dir == -1) {
#line 6927
        goto while_break___10;
      }
#line 6928
      dir = - 1;
#line 6929
      cv = fcv;
#line 6930
      goto while_continue___10;
    }
#line 6932
    if (percent) {
#line 6933
      m = 1;
    } else {
#line 6935
      if (cv->c_slperp) {
        {
#line 6935
        __cil_tmp20 = CountCanvasPerp(cv);
#line 6935
        tmp___800 = __cil_tmp20 * 2;
        }
      } else {
#line 6935
        tmp___800 = 2;
      }
#line 6935
      m = tmp___800;
    }
    {
#line 6936
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 6936
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 6937
    if (cv->c_slweight > m) {
#line 6939
      have = cv->c_slweight - m;
#line 6940
      if (have > diff) {
#line 6941
        have = diff;
      }
      {
#line 6942
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 6942
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 6943
      cv->c_slweight -= have;
#line 6944
      done += have;
#line 6945
      diff -= have;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
#line 6921
  if (dir > 0) {
#line 6921
    tmp___801 = cv->c_slnext;
  } else {
#line 6921
    tmp___801 = cv->c_slprev;
  }
#line 6921
  cv = tmp___801;
#line 6948
  if (diff) {
#line 6948
    if (gflag) {
#line 6951
      cv = (fcv->c_slback)->c_slback;
#line 6952
      if (cv) {
#line 6952
        if (cv->c_slback) {
          {
#line 6953
          __cil_tmp23 = ChangeCanvasSize((fcv->c_slback)->c_slback, 0, diff, gflag,
                                         percent);
          }
#line 6953
          done += __cil_tmp23;
        }
      }
    }
  }
#line 6955
  fcv->c_slweight += done;
  {
#line 6956
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 6956
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 6957
  return (done);
}
}
#line 6961 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void ResizeRegions(char *arg , int flags ) 
{ 
  struct canvas *cv ;
  int diff ;
  int l ;
  int gflag ;
  int abs___798 ;
  int percent ;
  int orient ;
  int tmp ;
  int tmp___799 ;
  int tmp___800 ;
  size_t __cil_tmp13 ;
  struct canvas *cv___801 ;
  struct canvas *tmp___802 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp21 ;
  int tmp___803 ;

  {
#line 6967
  gflag = 0;
#line 6967
  abs___798 = 0;
#line 6967
  percent = 0;
#line 6968
  orient = 0;
  {
#line 6970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6970
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 6971
  if (! *arg) {
#line 6972
    return;
  }
#line 6973
  if ((display->d_forecv)->c_slorient == 0) {
    {
#line 6975
    Msg(0, (char const   *)((char *)"resize: need more than one region"));
    }
#line 6976
    return;
  }
#line 6978
  if (flags & 4) {
#line 6978
    tmp = 0;
  } else {
#line 6978
    tmp = 1;
  }
#line 6978
  gflag = tmp;
#line 6979
  if (flags & 1) {
#line 6979
    tmp___799 = 1 << 1;
  } else {
#line 6979
    tmp___799 = 0;
  }
#line 6979
  orient |= tmp___799;
#line 6980
  if (flags & 2) {
#line 6980
    tmp___800 = 1;
  } else {
#line 6980
    tmp___800 = 0;
  }
#line 6980
  orient |= tmp___800;
#line 6981
  if (orient == 0) {
#line 6982
    orient = (display->d_forecv)->c_slorient;
  }
  {
#line 6983
  __cil_tmp13 = strlen((char const   *)arg);
#line 6983
  l = (int )__cil_tmp13;
  }
#line 6984
  if ((int )*arg == 61) {
#line 6987
    if (gflag) {
#line 6987
      tmp___802 = & display->d_canvas;
    } else {
#line 6987
      tmp___802 = (display->d_forecv)->c_slback;
    }
#line 6987
    cv___801 = tmp___802;
#line 6988
    if ((cv___801->c_slperp)->c_slorient & orient) {
      {
#line 6989
      EqualizeCanvas(cv___801->c_slperp, gflag);
      }
    }
#line 6991
    if (((cv___801->c_slperp)->c_slorient ^ ((1 << 1) ^ 1)) & orient) {
#line 6993
      if (cv___801->c_slback) {
        {
#line 6995
        cv___801 = cv___801->c_slback;
#line 6996
        EqualizeCanvas(cv___801->c_slperp, gflag);
        }
      } else {
        {
#line 6999
        EqualizeCanvas(cv___801, gflag);
        }
      }
    }
    {
#line 7001
    ResizeCanvas(cv___801);
#line 7002
    RecreateCanvasChain();
#line 7003
    RethinkDisplayViewports();
#line 7004
    ResizeLayersToCanvases();
    }
#line 7005
    return;
  }
  {
#line 7007
  __cil_tmp17 = strcmp((char const   *)arg, (char const   *)((char *)"0"));
  }
  {
#line 7007
  __cil_tmp16 = strcmp((char const   *)arg, (char const   *)((char *)"min"));
  }
#line 7007
  if (! __cil_tmp16) {
#line 7009
    abs___798 = 2;
#line 7010
    diff = 0;
  } else
#line 7007
  if (! __cil_tmp17) {
#line 7009
    abs___798 = 2;
#line 7010
    diff = 0;
  } else {
    {
#line 7012
    __cil_tmp19 = strcmp((char const   *)arg, (char const   *)((char *)"_"));
    }
    {
#line 7012
    __cil_tmp18 = strcmp((char const   *)arg, (char const   *)((char *)"max"));
    }
#line 7012
    if (! __cil_tmp18) {
#line 7014
      abs___798 = 2;
#line 7015
      diff = 1;
    } else
#line 7012
    if (! __cil_tmp19) {
#line 7014
      abs___798 = 2;
#line 7015
      diff = 1;
    } else {
#line 7019
      if (l > 0) {
#line 7019
        if ((int )*(arg + (l - 1)) == 37) {
#line 7020
          percent = 1000;
        }
      }
#line 7021
      if ((int )*arg == 43) {
        {
#line 7022
        diff = atoi((char const   *)(arg + 1));
        }
      } else
#line 7023
      if ((int )*arg == 45) {
        {
#line 7024
        __cil_tmp21 = atoi((char const   *)(arg + 1));
#line 7024
        diff = - __cil_tmp21;
        }
      } else {
        {
#line 7027
        diff = atoi((char const   *)arg);
        }
#line 7028
        if (diff < 0) {
#line 7029
          diff = 0;
        }
#line 7030
        if (diff == 0) {
#line 7030
          tmp___803 = 2;
        } else {
#line 7030
          tmp___803 = 1;
        }
#line 7030
        abs___798 = tmp___803;
      }
    }
  }
#line 7033
  if (! abs___798) {
#line 7033
    if (! diff) {
#line 7034
      return;
    }
  }
#line 7035
  if (percent) {
#line 7036
    diff = (diff * percent) / 100;
  }
#line 7037
  cv = display->d_forecv;
#line 7038
  if (cv->c_slorient & orient) {
    {
#line 7039
    ChangeCanvasSize(cv, abs___798, diff, gflag, percent);
    }
  }
#line 7040
  if ((cv->c_slback)->c_slorient & orient) {
    {
#line 7041
    ChangeCanvasSize(cv->c_slback, abs___798, diff, gflag, percent);
    }
  }
  {
#line 7043
  ResizeCanvas(& display->d_canvas);
#line 7044
  RecreateCanvasChain();
#line 7045
  RethinkDisplayViewports();
#line 7046
  ResizeLayersToCanvases();
  }
#line 7047
  return;
}
}
#line 7112 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
static void ResizeFin(char *buf , int len , char *data ) 
{ 
  int ch ;
  int flags ;
  int tmp ;

  {
#line 7118
  flags = *((int *)data);
#line 7119
  ch = (int )*((unsigned char *)buf + len);
#line 7120
  if (ch == 0) {
    {
#line 7122
    ResizeRegions(buf, flags);
    }
#line 7123
    return;
  }
#line 7125
  if (ch == 104) {
#line 7126
    flags ^= 1;
  } else
#line 7127
  if (ch == 118) {
#line 7128
    flags ^= 2;
  } else
#line 7129
  if (ch == 98) {
#line 7130
    flags |= 3;
  } else
#line 7131
  if (ch == 112) {
#line 7132
    if ((display->d_forecv)->c_slorient == 1) {
#line 7132
      tmp = 1;
    } else {
#line 7132
      tmp = 2;
    }
#line 7132
    flags ^= tmp;
  } else
#line 7133
  if (ch == 108) {
#line 7134
    flags ^= 4;
  } else {
#line 7136
    return;
  }
  {
#line 7137
  inp_setprompt(resizeprompts[flags], (char *)((void *)0));
#line 7138
  *((int *)data) = flags;
#line 7139
  *(buf + len) = (char )'\034';
  }
  return;
}
}
#line 7143 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void SetForeCanvas(struct display *d , struct canvas *cv ) 
{ 
  struct display *odisplay ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
#line 7147
  odisplay = display;
#line 7148
  if (d->d_forecv == cv) {
#line 7149
    return;
  }
#line 7151
  display = d;
#line 7152
  display->d_forecv = cv;
#line 7153
  if (focusminwidth) {
#line 7153
    if (focusminwidth < 0) {
      {
      {
      {
      {
#line 7156
      ResizeCanvas(& display->d_canvas);
      }
      }
      }
      {
      {
      {
#line 7157
      RecreateCanvasChain();
      }
      }
      }
      {
      {
      {
#line 7158
      RethinkDisplayViewports();
      }
      }
      }
      {
      {
      {
#line 7159
      ResizeLayersToCanvases();
      }
      }
      }
      }
    } else
#line 7153
    if (((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1 < focusminwidth) {
      {
      {
      {
      {
#line 7156
      ResizeCanvas(& display->d_canvas);
      }
      }
      }
      {
      {
      {
#line 7157
      RecreateCanvasChain();
      }
      }
      }
      {
      {
      {
#line 7158
      RethinkDisplayViewports();
      }
      }
      }
      {
      {
      {
#line 7159
      ResizeLayersToCanvases();
      }
      }
      }
      }
    } else {
#line 7153
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 7153
  if (focusminheight) {
#line 7153
    if (focusminheight < 0) {
      {
      {
      {
      {
#line 7156
      ResizeCanvas(& display->d_canvas);
      }
      }
      }
      {
      {
      {
#line 7157
      RecreateCanvasChain();
      }
      }
      }
      {
      {
      {
#line 7158
      RethinkDisplayViewports();
      }
      }
      }
      {
      {
      {
#line 7159
      ResizeLayersToCanvases();
      }
      }
      }
      }
    } else
#line 7153
    if (((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1 < focusminheight) {
      {
      {
      {
      {
#line 7156
      ResizeCanvas(& display->d_canvas);
      }
      }
      }
      {
      {
      {
#line 7157
      RecreateCanvasChain();
      }
      }
      }
      {
      {
      {
#line 7158
      RethinkDisplayViewports();
      }
      }
      }
      {
      {
      {
#line 7159
      ResizeLayersToCanvases();
      }
      }
      }
      }
    }
  }
#line 7161
  display->d_fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
#line 7161
  fore = display->d_fore;
#line 7162
  if (display->d_other == fore) {
#line 7163
    display->d_other = (struct win *)0;
  }
#line 7164
  flayer = (display->d_forecv)->c_layer;
#line 7166
  if (display->d_xtermosc[2]) {
    {
    {
#line 7168
    Activate(- 1);
    }
    }
  } else
#line 7166
  if (display->d_xtermosc[3]) {
    {
    {
#line 7168
    Activate(- 1);
    }
    }
  } else {
    {
#line 7173
    RefreshHStatus();
#line 7175
    RefreshXtermOSC();
#line 7177
    flayer = (display->d_forecv)->c_layer;
#line 7178
    olddisplay = display;
#line 7178
    oldflayer = flayer;
#line 7178
    l = (display->d_forecv)->c_layer;
#line 7178
    cvlist = l->l_cvlist;
#line 7178
    cvlnext = (display->d_forecv)->c_lnext;
#line 7178
    flayer = l;
#line 7178
    l->l_cvlist = display->d_forecv;
#line 7178
    (display->d_forecv)->c_lnext = (struct canvas *)0;
#line 7178
    (*((flayer->l_layfn)->lf_LayRestore))();
#line 7178
    LGotoPos(flayer, flayer->l_x, flayer->l_y);
#line 7178
    flayer = oldflayer;
#line 7178
    l->l_cvlist = cvlist;
#line 7178
    (display->d_forecv)->c_lnext = cvlnext;
#line 7178
    display = olddisplay;
#line 7179
    WindowChanged((struct win *)0, 'F');
    }
  }
#line 7182
  display = odisplay;
  return;
}
}
#line 7187 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void RefreshXtermOSC(void) 
{ 
  int i ;
  struct win *p ;
  char *tmp ;
  int __cil_tmp4 ;

  {
#line 7192
  p = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
#line 7193
  i = 4;
  {
#line 7193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7193
    if (! (i >= 0)) {
#line 7193
      goto while_break;
    }
#line 7194
    if (p) {
#line 7194
      tmp = (char *)p->w_xtermosc[i];
    } else {
#line 7194
      tmp = (char *)0;
    }
    {
#line 7194
    SetXtermOSC(i, tmp, (char *)"\a");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7193
  __cil_tmp4 = i;
#line 7193
  i --;
  return;
}
}
#line 7199 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
int ParseAttrColor(char *s1 , char *s2 , int msgok ) 
{ 
  int i ;
  int n ;
  char *s ;
  char *ss ;
  int r ;
  int mode ;
  int n___804 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  static char costr[] ;
  int numco ;
  int j ;

  {
#line 7205
  r = 0;
#line 7207
  s = s1;
  {
#line 7208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7208
    if (! ((int )*s == 32)) {
#line 7208
      goto while_break;
    }
#line 7209
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7210
  ss = s;
  {
#line 7211
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7211
    if (! ((int )*ss && (int )*ss != 32)) {
#line 7211
      goto while_break___0;
    }
#line 7212
    ss ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7213
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 7213
    if (! ((int )*ss == 32)) {
#line 7213
      goto while_break___1;
    }
#line 7214
    ss ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 7215
  if ((int )*s) {
#line 7215
    if (s2) {
      _L___808: /* CIL Label */ 
#line 7217
      mode = 0;
#line 7217
      n___804 = 0;
#line 7218
      if ((int )*s == 43) {
#line 7220
        mode = 1;
#line 7221
        s ++;
      } else
#line 7223
      if ((int )*s == 45) {
#line 7225
        mode = - 1;
#line 7226
        s ++;
      } else
#line 7228
      if ((int )*s == 33) {
#line 7230
        mode = 2;
#line 7231
        s ++;
      } else
#line 7233
      if ((int )*s == 61) {
#line 7234
        s ++;
      }
#line 7235
      if ((int )*s >= 48) {
#line 7235
        if ((int )*s <= 57) {
#line 7237
          __cil_tmp18 = s;
#line 7237
          s ++;
#line 7237
          n___804 = (int )*__cil_tmp18 - 48;
#line 7238
          if ((int )*s >= 48) {
#line 7238
            if ((int )*s <= 57) {
#line 7239
              __cil_tmp19 = s;
#line 7239
              s ++;
#line 7239
              n___804 = n___804 * 16 + ((int )*__cil_tmp19 - 48);
            } else {
#line 7238
              goto _L___806;
            }
          } else
          _L___806: /* CIL Label */ 
#line 7240
          if ((int )*s >= 97) {
#line 7240
            if ((int )*s <= 102) {
#line 7241
              __cil_tmp20 = s;
#line 7241
              s ++;
#line 7241
              n___804 = n___804 * 16 + ((int )*__cil_tmp20 - 87);
            } else {
#line 7240
              goto _L___805;
            }
          } else
          _L___805: /* CIL Label */ 
#line 7242
          if ((int )*s >= 65) {
#line 7242
            if ((int )*s <= 70) {
#line 7243
              __cil_tmp21 = s;
#line 7243
              s ++;
#line 7243
              n___804 = n___804 * 16 + ((int )*__cil_tmp21 - 55);
            } else {
#line 7242
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 7244
          if ((int )*s) {
#line 7244
            if ((int )*s != 32) {
#line 7246
              if (msgok) {
                {
#line 7247
                Msg(0, (char const   *)((char *)"Illegal attribute hexchar \'%c\'"),
                    (int )*s);
                }
              }
#line 7248
              return (- 1);
            }
          }
        } else {
#line 7235
          goto _L___807;
        }
      } else {
        _L___807: /* CIL Label */ 
        {
#line 7253
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 7253
          if (! ((int )*s && (int )*s != 32)) {
#line 7253
            goto while_break___2;
          }
#line 7255
          if ((int )*s == 100) {
#line 7256
            n___804 |= 1;
          } else
#line 7257
          if ((int )*s == 117) {
#line 7258
            n___804 |= 1 << 1;
          } else
#line 7259
          if ((int )*s == 98) {
#line 7260
            n___804 |= 1 << 2;
          } else
#line 7261
          if ((int )*s == 114) {
#line 7262
            n___804 |= 1 << 3;
          } else
#line 7263
          if ((int )*s == 115) {
#line 7264
            n___804 |= 1 << 4;
          } else
#line 7265
          if ((int )*s == 66) {
#line 7266
            n___804 |= 1 << 5;
          } else {
#line 7269
            if (msgok) {
              {
#line 7270
              Msg(0, (char const   *)((char *)"Illegal attribute specifier \'%c\'"),
                  (int )*s);
              }
            }
#line 7271
            return (- 1);
          }
#line 7273
          s ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 7276
      if ((int )*s) {
#line 7276
        if ((int )*s != 32) {
#line 7278
          if (msgok) {
            {
#line 7279
            Msg(0, (char const   *)((char *)"junk after attribute description: \'%c\'"),
                (int )*s);
            }
          }
#line 7280
          return (- 1);
        }
      }
#line 7282
      if (mode == -1) {
#line 7283
        r = (n___804 << 8) | n___804;
      } else
#line 7284
      if (mode == 1) {
#line 7285
        r = n___804 << 8;
      } else
#line 7286
      if (mode == 2) {
#line 7287
        r = n___804;
      } else
#line 7288
      if (mode == 0) {
#line 7289
        r = 65535 ^ n___804;
      }
    } else
#line 7215
    if ((int )*ss) {
#line 7215
      goto _L___808;
    } else
#line 7215
    if (! ((((int )*s >= 97 && (int )*s <= 122) || ((int )*s >= 65 && (int )*s <= 90)) || (int )*s == 46)) {
#line 7215
      goto _L___808;
    }
  }
  {
#line 7291
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 7291
    if (! ((int )*s && (int )*s == 32)) {
#line 7291
      goto while_break___3;
    }
#line 7292
    s ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 7294
  if (s2) {
#line 7296
    if (*s) {
#line 7298
      if (msgok) {
        {
#line 7299
        Msg(0, (char const   *)((char *)"junk after description: \'%c\'"), (int )*s);
        }
      }
#line 7300
      return (- 1);
    }
#line 7302
    s = s2;
    {
#line 7303
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 7303
      if (! ((int )*s && (int )*s == 32)) {
#line 7303
        goto while_break___4;
      }
#line 7304
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 7308
  if (*s) {
#line 7310
    costr = "krgybmcw d    i.01234567 9     f               FKRGYBMCW      I ";
#line 7311
    numco = 0;
#line 7313
    n = 0;
#line 7314
    if ((int )*s == 46) {
#line 7316
      numco ++;
#line 7317
      n = 15;
#line 7318
      s ++;
    }
#line 7320
    j = 0;
    {
#line 7320
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 7320
      if (! ((j < 2 && (int )*s) && (int )*s != 32)) {
#line 7320
        goto while_break___5;
      }
#line 7322
      i = 0;
      {
#line 7322
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 7322
        if (! costr[i]) {
#line 7322
          goto while_break___6;
        }
#line 7323
        if ((int )*s == (int )costr[i]) {
#line 7324
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 7322
      i ++;
#line 7325
      if (! costr[i]) {
#line 7327
        if (msgok) {
          {
#line 7328
          Msg(0, (char const   *)((char *)"illegal color descriptor: \'%c\'"), (int )*s);
          }
        }
#line 7329
        return (- 1);
      }
#line 7331
      numco ++;
#line 7332
      n = (n << 4) | (i & 15);
#line 7334
      if (i >= 48) {
#line 7335
        n = (n & 8447) | 512;
      }
#line 7337
      s ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 7320
    j ++;
#line 7339
    if ((n & 3840) == 3840) {
#line 7340
      n ^= 3840;
    }
#line 7342
    if (n & 8192) {
#line 7343
      n ^= 9216;
    }
#line 7345
    if (numco == 1) {
#line 7346
      n |= 240;
    }
#line 7347
    if (numco != 2) {
#line 7347
      if (n != 255) {
#line 7348
        n |= 256;
      }
    }
#line 7349
    if ((int )*s) {
#line 7349
      if ((int )*s != 32) {
#line 7351
        if (msgok) {
          {
#line 7352
          Msg(0, (char const   *)((char *)"junk after color description: \'%c\'"),
              (int )*s);
          }
        }
#line 7353
        return (- 1);
      }
    }
#line 7355
    n ^= 255;
#line 7356
    r |= n << 16;
  }
  {
#line 7360
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 7360
    if (! ((int )*s && (int )*s == 32)) {
#line 7360
      goto while_break___7;
    }
#line 7361
    s ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 7362
  if (*s) {
#line 7364
    if (msgok) {
      {
#line 7365
      Msg(0, (char const   *)((char *)"junk after description: \'%c\'"), (int )*s);
      }
    }
#line 7366
    return (- 1);
  }
  {
#line 7368
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 7368
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 7369
  return (r);
}
}
#line 7381 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/process.c"
void ApplyAttrColor(int i , struct mchar *mc ) 
{ 


  {
  {
#line 7385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7385
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 7386
  mc->attr |= (i >> 8) & 255;
#line 7387
  mc->attr ^= i & 255;
#line 7389
  i = (i >> 16) ^ 255;
#line 7390
  if ((i & 256) != 0) {
#line 7392
    i &= 3839;
#line 7393
    if ((int )mc->attr & ((1 << 4) | (1 << 3))) {
#line 7395
      i = ((((i & 15) << 4) | ((i & 240) >> 4)) | ((i & 512) << 1)) | ((i & 1024) >> 1);
    }
  }
#line 7401
  if ((i & 15) != 15) {
#line 7402
    mc->attr = (unsigned char )(((int )mc->attr & 191) | ((i >> 3) & 64));
  }
#line 7403
  if ((i & 240) != 240) {
#line 7404
    mc->attr = (unsigned char )(((int )mc->attr & 127) | ((i >> 3) & 128));
  }
#line 7406
  mc->color = (unsigned char )(153 ^ (int )mc->color);
#line 7407
  if ((i & 14) == 14) {
#line 7408
    i = (i & 240) | ((int )mc->color & 15);
  }
#line 7409
  if ((i & 224) == 224) {
#line 7410
    i = (i & 15) | ((int )mc->color & 240);
  }
#line 7411
  mc->color = (unsigned char )(153 ^ i);
  {
#line 7412
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7412
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 773 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 979 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int grantpt(int __fd ) ;
#line 983
extern  __attribute__((__nothrow__)) int unlockpt(int __fd ) ;
#line 988
extern  __attribute__((__nothrow__)) char *ptsname(int __fd ) ;
#line 999
extern int getpt(void) ;
#line 116 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
char *GetPtsPathOrSymlink(int fd ) ;
#line 195
 __attribute__((__nothrow__)) int OpenPTY(char **ttyn ) ;
#line 80 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/pty.c"
static char PtyName[32] ;
#line 80
static char TtyName[32] ;
#line 97
static void initmaster(int f ) ;
#line 104 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/pty.c"
int pty_preopen  =    0;
#line 118 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/pty.c"
static void initmaster(int f ) 
{ 


  {
  {
#line 122
  tcflush(f, 2);
  }
  return;
}
}
#line 134 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/pty.c"
void InitPTY(int f ) 
{ 


  {
#line 137
  if (f < 0) {
#line 138
    return;
  }
  return;
}
}
#line 251
 __attribute__((__nothrow__)) int OpenPTY(char **ttyn ) ;
#line 251 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/pty.c"
int OpenPTY(char **ttyn ) 
{ 
  register int f ;
  char *m ;
  void (*sigcld)(int  ) ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  size_t __cil_tmp10 ;

  {
  {
#line 262
  strcpy((char *)PtyName, (char const   *)((char *)"/dev/ptmx"));
#line 264
  f = getpt();
  }
#line 264
  if (f == -1) {
#line 268
    return (- 1);
  }
  {
#line 274
  sigcld = xsignal(17, (__sighandler_t )0);
#line 275
  __cil_tmp9 = unlockpt(f);
  }
  {
#line 275
  __cil_tmp8 = grantpt(f);
  }
  {
#line 275
  m = ptsname(f);
  }
#line 275
  if (m == (char *)((void *)0)) {
    {
    {
    {
#line 277
    xsignal(17, sigcld);
    }
    }
    {
    {
#line 278
    close(f);
    }
    }
    }
#line 279
    return (- 1);
  } else
#line 275
  if (__cil_tmp8) {
    {
    {
    {
#line 277
    xsignal(17, sigcld);
    }
    }
    {
    {
#line 278
    close(f);
    }
    }
    }
#line 279
    return (- 1);
  } else
#line 275
  if (__cil_tmp9) {
    {
    {
    {
#line 277
    xsignal(17, sigcld);
    }
    }
    {
    {
#line 278
    close(f);
    }
    }
    }
#line 279
    return (- 1);
  }
  {
#line 281
  xsignal(17, sigcld);
#line 282
  __cil_tmp10 = strlen((char const   *)m);
  }
#line 282
  if (__cil_tmp10 < sizeof(TtyName)) {
    {
#line 283
    strcpy((char *)TtyName, (char const   *)m);
    }
  } else {
    {
#line 286
    close(f);
    }
#line 287
    return (- 1);
  }
  {
#line 289
  initmaster(f);
#line 290
  *ttyn = (char *)TtyName;
  }
#line 291
  return (f);
}
}
#line 401 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/pty.c"
char *GetPtsPathOrSymlink(int fd ) 
{ 
  int ret ;
  char *tty_name ;
  static char tty_symlink[35] ;
  int *__cil_tmp5 ;
  int *__cil_tmp7 ;
  int *__cil_tmp9 ;

  {
  {
#line 407
  __cil_tmp5 = __errno_location();
#line 407
  *__cil_tmp5 = 0;
#line 408
  tty_name = ttyname(fd);
#line 409
  __cil_tmp7 = __errno_location();
  }
#line 409
  if (! tty_name) {
#line 409
    if (*__cil_tmp7 == 19) {
      {
#line 410
      ret = snprintf((char *)tty_symlink, (unsigned long )35, (char const   *)((char *)"/proc/self/fd/%d"),
                     fd);
      }
#line 411
      if (ret < 0) {
#line 412
        return ((char *)((void *)0));
      } else
#line 411
      if (ret >= 35) {
#line 412
        return ((char *)((void *)0));
      }
      {
#line 416
      __cil_tmp9 = __errno_location();
#line 416
      *__cil_tmp9 = 19;
      }
#line 417
      return ((char *)tty_symlink);
    }
  }
#line 420
  return (tty_name);
}
}
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 112 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 137 "/usr/include/stdio.h"
extern _IO_FILE *stderr ;
#line 435 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 472
extern int pause(void) ;
#line 576
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 746
extern  __attribute__((__nothrow__)) int setresuid(__uid_t __ruid , __uid_t __euid ,
                                                   __uid_t __suid ) ;
#line 828
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 949
extern char *getpass(char const   *__prompt ) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 40 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void eexit(int e ) ;
#line 247
int Attach(int how ) ;
#line 248
void Attacher(void) ;
#line 249
void AttacherFinit(int sigsig ) ;
#line 250
void SendCmdMessage(char *sty , char *match , char **av , int query ) ;
#line 342
int FindSocket(int *fdp , int *nfoundp , int *notherp , char *match , int *is_sock ) ;
#line 343
int MakeClientSocket(int err , int socket___0 ) ;
#line 344
int MakeServerSocket(int socket___0 ) ;
#line 350
int SendAttachMsg(int s , struct msg *m , int fd ) ;
#line 351
void ReceiveRaw(int s ) ;
#line 352
int IsSocket(char const   *path ) ;
#line 380
void xseteuid(int euid ) ;
#line 41 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static int WriteMessage(int s , struct msg *m ) ;
#line 42
static void AttacherSigInt(int sigsig ) ;
#line 44
static void AttacherWinch(int sigsig ) ;
#line 47
static void DoLock(int sigsig ) ;
#line 48
static void LockTerminal(void) ;
#line 49
static void LockHup(int sigsig ) ;
#line 50
static void screen_builtin_lck(void) ;
#line 55
static void AttachSigCont(int sigsig ) ;
#line 60
char *SockMatch ;
#line 62
struct passwd *ppp ;
#line 63
char *attach_tty ;
#line 63
char *attach_term ;
#line 63
char *LoginName ;
#line 63
char *preselect ;
#line 65
int attach_tty_is_in_new_ns ;
#line 67
char attach_tty_name_in_ns[4096] ;
#line 68
int xflag ;
#line 68
int dflag ;
#line 68
int rflag ;
#line 68
int quietflag ;
#line 68
int adaptflag ;
#line 69
struct mode attach_Mode ;
#line 70
extern struct NewWindow nwin_options ;
#line 71
int MasterPid ;
#line 71
int attach_fd ;
#line 75
int multiattach ;
#line 75
int multi_uid ;
#line 75
int own_uid ;
#line 76
int tty_mode ;
#line 76
int tty_oldmode ;
#line 83
static int ContinuePlease ;
#line 86 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void AttachSigCont(int sigsig ) 
{ 


  {
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  ContinuePlease = 1;
  return;
}
}
#line 93
static int QueryResult ;
#line 96 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void QueryResultSuccess(int sigsig ) 
{ 


  {
#line 98
  QueryResult = 1;
  return;
}
}
#line 103 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void QueryResultFail(int sigsig ) 
{ 


  {
#line 105
  QueryResult = 2;
  return;
}
}
#line 120 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static int WriteMessage(int s , struct msg *m ) 
{ 
  int r ;
  int l ;
  int is_socket ;
  int __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int *__cil_tmp9 ;

  {
  {
#line 124
  l = (int )sizeof(*m);
#line 127
  is_socket = IsSocket((char const   *)((char *)SockPath));
  }
#line 128
  if (is_socket) {
#line 128
    if (m->type == 2) {
      {
#line 129
      __cil_tmp7 = SendAttachMsg(s, m, attach_fd);
      }
#line 129
      return (__cil_tmp7);
    }
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (l > 0)) {
#line 131
      goto while_break;
    }
    {
#line 133
    __cil_tmp8 = write(s, (void const   *)((char *)m + (sizeof(*m) - (unsigned long )l)),
                       (size_t )l);
#line 133
    r = (int )__cil_tmp8;
#line 134
    __cil_tmp9 = __errno_location();
    }
#line 134
    if (r == -1) {
#line 134
      if (*__cil_tmp9 == 4) {
#line 135
        goto while_continue;
      }
    }
#line 136
    if (r == -1) {
#line 137
      return (- 1);
    } else
#line 136
    if (r == 0) {
#line 137
      return (- 1);
    }
#line 138
    l -= r;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  return (0);
}
}
#line 145 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
int Attach(int how ) 
{ 
  int n ;
  int lasts ;
  struct msg m ;
  struct stat st ;
  char *s ;
  int is_socket ;
  int __cil_tmp8 ;
  int *__cil_tmp9 ;
  int __cil_tmp10 ;
  int *__cil_tmp11 ;
  char *tmp ;
  char *tmp___810 ;
  char *tmp___811 ;
  char *tmp___812 ;
  char *tmp___813 ;
  int __cil_tmp21 ;
  int *__cil_tmp22 ;
  int __cil_tmp23 ;
  int *__cil_tmp24 ;
  int __cil_tmp26 ;
  int *__cil_tmp27 ;
  int tmp___816 ;
  char *tmp___817 ;
  int __cil_tmp31 ;
  int *__cil_tmp32 ;
  char *tmp___820 ;
  int tmp___821 ;
  int __cil_tmp41 ;
  int *__cil_tmp42 ;
  int __cil_tmp43 ;
  int *__cil_tmp44 ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  if (how == 2) {
    _L: /* CIL Label */ 
#line 216
    if (multiattach) {
      {
#line 218
      real_uid = multi_uid;
#line 219
      eff_uid = own_uid;
#line 221
      __cil_tmp8 = setresuid((__uid_t )multi_uid, (__uid_t )own_uid, (__uid_t )multi_uid);
      }
#line 221
      if (__cil_tmp8) {
        {
#line 222
        __cil_tmp9 = __errno_location();
#line 222
        Panic(*__cil_tmp9, (char const   *)((char *)"setresuid"));
        }
      }
      {
#line 227
      __cil_tmp10 = chmod((char const   *)attach_tty, (__mode_t )438);
      }
#line 227
      if (__cil_tmp10) {
        {
#line 228
        __cil_tmp11 = __errno_location();
#line 228
        Panic(*__cil_tmp11, (char const   *)((char *)"chmod %s"), attach_tty);
        }
      }
#line 229
      tty_oldmode = tty_mode;
    }
  } else
#line 216
  if (how == 3) {
#line 216
    goto _L;
  }
  {
#line 234
  bzero((void *)((char *)(& m)), sizeof(m));
#line 235
  m.type = how;
#line 236
  m.protocol_revision = (((109 << 24) | (115 << 16)) | (103 << 8)) | 5;
  }
#line 237
  if (attach_tty_is_in_new_ns) {
#line 237
    tmp = (char *)attach_tty_name_in_ns;
  } else {
#line 237
    tmp = attach_tty;
  }
  {
#line 237
  strncpy((char *)m.m_tty, (char const   *)tmp, sizeof(m.m_tty) - 1UL);
#line 238
  m.m_tty[sizeof(m.m_tty) - 1UL] = (char )0;
#line 240
  is_socket = IsSocket((char const   *)((char *)SockPath));
  }
#line 241
  if (how == 6) {
    {
#line 243
    lasts = MakeClientSocket(0, is_socket);
    }
#line 243
    if (lasts >= 0) {
      {
#line 245
      WriteMessage(lasts, & m);
#line 246
      close(lasts);
      }
    }
#line 248
    return (0);
  }
#line 251
  if (how == 3) {
    {
#line 253
    lasts = MakeClientSocket(0, is_socket);
    }
#line 253
    if (lasts < 0) {
      {
#line 255
      Panic(0, (char const   *)((char *)"Sorry, cannot contact session \"%s\" again.\r\n"),
            SockName);
      }
    }
  } else {
    {
#line 261
    n = FindSocket(& lasts, (int *)0, (int *)0, SockMatch, & is_socket);
    }
    {
#line 264
    if (n == 0) {
#line 264
      goto case_0;
    }
#line 281
    if (n == 1) {
#line 281
      goto case_1;
    }
#line 283
    goto switch_default;
    case_0: /* CIL Label */ 
#line 265
    if (rflag) {
#line 265
      if ((rflag & 1) == 0) {
#line 266
        return (0);
      }
    }
#line 267
    if (quietflag) {
      {
#line 268
      eexit(10);
      }
    }
#line 269
    if (SockMatch) {
#line 269
      if ((int )*SockMatch) {
#line 270
        if (xflag) {
#line 270
          tmp___811 = (char *)"attach";
        } else {
#line 270
          if (dflag) {
#line 270
            tmp___810 = (char *)"detach";
          } else {
#line 270
            tmp___810 = (char *)"resum";
          }
#line 270
          tmp___811 = tmp___810;
        }
        {
#line 270
        Panic(0, (char const   *)((char *)"There is no screen to be %sed matching %s."),
              tmp___811, SockMatch);
        }
      } else {
#line 269
        goto _L___814;
      }
    } else {
      _L___814: /* CIL Label */ 
#line 275
      if (xflag) {
#line 275
        tmp___813 = (char *)"attach";
      } else {
#line 275
        if (dflag) {
#line 275
          tmp___812 = (char *)"detach";
        } else {
#line 275
          tmp___812 = (char *)"resum";
        }
#line 275
        tmp___813 = tmp___812;
      }
      {
#line 275
      Panic(0, (char const   *)((char *)"There is no screen to be %sed."), tmp___813);
      }
    }
    case_1: /* CIL Label */ 
#line 282
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 284
    if (rflag < 3) {
#line 286
      if (quietflag) {
        {
#line 287
        eexit(10 + n);
        }
      }
      {
#line 288
      Panic(0, (char const   *)((char *)"Type \"screen [-d] -r [pid.]tty.host\" to resume one of them."));
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 299
  if (! multiattach) {
    {
#line 302
    __cil_tmp21 = setuid((__uid_t )real_uid);
    }
#line 302
    if (__cil_tmp21) {
      {
#line 303
      __cil_tmp22 = __errno_location();
#line 303
      Panic(*__cil_tmp22, (char const   *)((char *)"setuid"));
      }
    }
  } else {
    {
#line 309
    xseteuid(real_uid);
    }
  }
  {
#line 312
  eff_uid = real_uid;
#line 313
  __cil_tmp23 = setgid((__gid_t )real_gid);
  }
#line 313
  if (__cil_tmp23) {
    {
#line 314
    __cil_tmp24 = __errno_location();
#line 314
    Panic(*__cil_tmp24, (char const   *)((char *)"setgid"));
    }
  }
#line 315
  eff_gid = real_gid;
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 317
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 318
  MasterPid = 0;
#line 319
  s = SockName;
  {
#line 319
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 319
    if (! *s) {
#line 319
      goto while_break___1;
    }
#line 321
    if ((int )*s > 57) {
#line 322
      goto while_break___1;
    } else
#line 321
    if ((int )*s < 48) {
#line 322
      goto while_break___1;
    }
#line 323
    MasterPid = 10 * MasterPid + ((int )*s - 48);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 319
  s ++;
  {
#line 325
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 325
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 326
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 326
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 327
  __cil_tmp26 = stat((char const   *)((char *)SockPath), & st);
  }
#line 327
  if (__cil_tmp26 == -1) {
    {
#line 328
    __cil_tmp27 = __errno_location();
#line 328
    Panic(*__cil_tmp27, (char const   *)((char *)"stat %s"), (char *)SockPath);
    }
  }
#line 329
  if ((st.st_mode & 384U) != 384U) {
    {
#line 330
    Panic(0, (char const   *)((char *)"Socket is in wrong mode (%03o)"), (int )st.st_mode);
    }
  }
#line 335
  if (xflag) {
    _L___815: /* CIL Label */ 
#line 335
    if (dflag) {
#line 335
      if ((st.st_mode & 448U) == 384U) {
#line 336
        dflag = 0;
      }
    }
  } else
#line 335
  if (rflag) {
#line 335
    goto _L___815;
  }
#line 342
  if (dflag) {
#line 342
    tmp___816 = 448;
  } else {
#line 342
    tmp___816 = 384;
  }
#line 342
  if (dflag) {
    _L___818: /* CIL Label */ 
#line 342
    if ((st.st_mode & 448U) != (unsigned int )tmp___816) {
#line 343
      if (dflag) {
#line 343
        tmp___817 = (char *)"already ";
      } else {
#line 343
        tmp___817 = (char *)"not ";
      }
      {
#line 343
      Panic(0, (char const   *)((char *)"That screen is %sdetached."), tmp___817);
      }
    }
  } else
#line 342
  if (! xflag) {
#line 342
    goto _L___818;
  }
#line 345
  if (dflag) {
#line 345
    if (how == 4) {
      _L___819: /* CIL Label */ 
      {
#line 348
      m.m.detach.dpid = getpid();
#line 349
      strncpy((char *)m.m.detach.duser, (char const   *)LoginName, sizeof(m.m.detach.duser) - 1UL);
#line 350
      m.m.detach.duser[sizeof(m.m.detach.duser) - 1UL] = (char )0;
      }
#line 352
      if (dflag == 2) {
#line 353
        m.type = 5;
      } else {
#line 356
        m.type = 4;
      }
      {
#line 359
      xsignal(18, AttachSigCont);
#line 360
      __cil_tmp31 = WriteMessage(lasts, & m);
      }
#line 360
      if (__cil_tmp31) {
        {
#line 361
        __cil_tmp32 = __errno_location();
#line 361
        Panic(*__cil_tmp32, (char const   *)((char *)"WriteMessage"));
        }
      }
      {
#line 362
      close(lasts);
      }
      {
#line 363
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 363
        if (! (! ContinuePlease)) {
#line 363
          goto while_break___4;
        }
        {
#line 364
        pause();
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 365
      xsignal(18, (__sighandler_t )0);
#line 366
      ContinuePlease = 0;
      }
#line 367
      if (how != 2) {
#line 368
        return (0);
      }
      {
#line 369
      sleep((unsigned int )1);
#line 370
      lasts = MakeClientSocket(0, is_socket);
      }
#line 370
      if (lasts == -1) {
        {
#line 371
        Panic(0, (char const   *)((char *)"Cannot contact screen again. Sigh."));
        }
      }
#line 372
      m.type = how;
    } else
#line 345
    if (how == 5) {
#line 345
      goto _L___819;
    }
  }
  {
#line 375
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 375
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 376
  strncpy((char *)m.m.attach.envterm, (char const   *)attach_term, (unsigned long )32);
#line 377
  m.m.attach.envterm[32] = (char )0;
  }
  {
#line 378
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 378
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 380
  strncpy((char *)m.m.attach.auser, (char const   *)LoginName, sizeof(m.m.attach.auser) - 1UL);
#line 381
  m.m.attach.auser[sizeof(m.m.attach.auser) - 1UL] = (char )0;
#line 382
  m.m.attach.esc = DefaultEsc;
#line 383
  m.m.attach.meta_esc = DefaultMetaEsc;
  }
#line 384
  if (preselect) {
#line 384
    tmp___820 = preselect;
  } else {
#line 384
    tmp___820 = (char *)"";
  }
  {
#line 384
  strncpy((char *)m.m.attach.preselect, (char const   *)tmp___820, sizeof(m.m.attach.preselect) - 1UL);
#line 385
  m.m.attach.preselect[sizeof(m.m.attach.preselect) - 1UL] = (char )0;
#line 386
  m.m.attach.apid = getpid();
#line 387
  m.m.attach.adaptflag = adaptflag;
#line 388
  m.m.attach.columns = 0;
#line 388
  m.m.attach.lines = m.m.attach.columns;
#line 389
  s = getenv((char const   *)((char *)"LINES"));
  }
#line 389
  if (s) {
    {
#line 390
    m.m.attach.lines = atoi((char const   *)s);
    }
  }
  {
#line 391
  s = getenv((char const   *)((char *)"COLUMNS"));
  }
#line 391
  if (s) {
    {
#line 392
    m.m.attach.columns = atoi((char const   *)s);
    }
  }
#line 393
  if (nwin_options.encoding > 0) {
#line 393
    tmp___821 = nwin_options.encoding + 1;
  } else {
#line 393
    tmp___821 = 0;
  }
#line 393
  m.m.attach.encoding = tmp___821;
#line 397
  if (dflag == 2) {
#line 398
    m.m.attach.detachfirst = 5;
  } else
#line 401
  if (dflag) {
#line 402
    m.m.attach.detachfirst = 4;
  } else {
#line 405
    m.m.attach.detachfirst = 2;
  }
#line 409
  if (multi) {
#line 409
    if (how == 2) {
      {
      {
#line 410
      xsignal(18, AttachSigCont);
      }
      }
    } else
#line 409
    if (how == 3) {
      {
      {
#line 410
      xsignal(18, AttachSigCont);
      }
      }
    }
  }
  {
#line 413
  __cil_tmp41 = WriteMessage(lasts, & m);
  }
#line 413
  if (__cil_tmp41) {
    {
#line 414
    __cil_tmp42 = __errno_location();
#line 414
    Panic(*__cil_tmp42, (char const   *)((char *)"WriteMessage"));
    }
  }
  {
#line 415
  close(lasts);
  }
  {
#line 416
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 416
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 418
  if (multi) {
#line 418
    if (how == 2) {
      _L___822: /* CIL Label */ 
      {
#line 420
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 420
        if (! (! ContinuePlease)) {
#line 420
          goto while_break___8;
        }
        {
#line 421
        pause();
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 422
      xsignal(18, (__sighandler_t )0);
#line 423
      ContinuePlease = 0;
#line 427
      xseteuid(own_uid);
      }
#line 428
      if (tty_oldmode >= 0) {
        {
#line 429
        __cil_tmp43 = chmod((char const   *)attach_tty, (__mode_t )tty_oldmode);
        }
#line 429
        if (__cil_tmp43) {
          {
#line 430
          __cil_tmp44 = __errno_location();
#line 430
          Panic(*__cil_tmp44, (char const   *)((char *)"chmod %s"), attach_tty);
          }
        }
      }
      {
#line 431
      tty_oldmode = - 1;
#line 432
      xseteuid(real_uid);
      }
    } else
#line 418
    if (how == 3) {
#line 418
      goto _L___822;
    }
  }
#line 436
  rflag = 0;
#line 437
  return (1);
}
}
#line 441 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static int AttacherPanic  =    0;
#line 453 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void AttacherSigAlarm(int sigsig ) 
{ 


  {

  return;
}
}
#line 468 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void AttacherSigInt(int sigsig ) 
{ 


  {
  {
#line 470
  xsignal(2, AttacherSigInt);
#line 471
  Kill(MasterPid, 2);
  }
  return;
}
}
#line 481 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
void AttacherFinit(int sigsig ) 
{ 
  struct stat statb ;
  struct msg m ;
  int s ;
  int is_socket ;
  int __cil_tmp6 ;
  char *tmp ;
  int __cil_tmp11 ;
  int *__cil_tmp12 ;

  {
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 489
  xsignal(1, (__sighandler_t )1);
#line 491
  __cil_tmp6 = stat((char const   *)((char *)SockPath), & statb);
  }
#line 491
  if (__cil_tmp6 == 0) {
#line 491
    if ((statb.st_mode & 511U) != 384U) {
      {
#line 493
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 493
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 494
      bzero((void *)((char *)(& m)), sizeof(m));
      }
#line 495
      if (attach_tty_is_in_new_ns) {
#line 495
        tmp = (char *)attach_tty_name_in_ns;
      } else {
#line 495
        tmp = attach_tty;
      }
      {
#line 495
      strncpy((char *)m.m_tty, (char const   *)tmp, sizeof(m.m_tty) - 1UL);
#line 496
      m.m_tty[sizeof(m.m_tty) - 1UL] = (char )0;
      }
      {
#line 497
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 497
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 498
      m.m.detach.dpid = getpid();
#line 499
      m.type = 7;
#line 500
      m.protocol_revision = (((109 << 24) | (115 << 16)) | (103 << 8)) | 5;
#line 501
      is_socket = IsSocket((char const   *)((char *)SockPath));
#line 502
      s = MakeClientSocket(0, is_socket);
      }
#line 502
      if (s >= 0) {
        {
#line 504
        WriteMessage(s, & m);
#line 505
        close(s);
        }
      }
    }
  }
#line 509
  if (tty_oldmode >= 0) {
    {
#line 511
    __cil_tmp11 = setuid((__uid_t )own_uid);
    }
#line 511
    if (__cil_tmp11) {
      {
#line 512
      __cil_tmp12 = __errno_location();
#line 512
      Panic(*__cil_tmp12, (char const   *)((char *)"setuid"));
      }
    }
    {
#line 513
    chmod((char const   *)attach_tty, (__mode_t )tty_oldmode);
    }
  }
  {
#line 516
  exit(0);
  }
}
}
#line 522 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void AttacherFinitBye(int sigsig ) 
{ 
  int ppid ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;
  int __cil_tmp5 ;
  int *__cil_tmp6 ;

  {
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 530
  __cil_tmp3 = setgid((__gid_t )real_gid);
  }
#line 530
  if (__cil_tmp3) {
    {
#line 531
    __cil_tmp4 = __errno_location();
#line 531
    Panic(*__cil_tmp4, (char const   *)((char *)"setgid"));
    }
  }
  {
#line 533
  __cil_tmp5 = setuid((__uid_t )own_uid);
  }
#line 533
  if (__cil_tmp5) {
    {
#line 534
    __cil_tmp6 = __errno_location();
#line 534
    Panic(*__cil_tmp6, (char const   *)((char *)"setuid"));
    }
  }
  {
#line 540
  ppid = getppid();
  }
#line 540
  if (ppid > 1) {
    {
#line 541
    Kill(ppid, 1);
    }
  }
  {
#line 542
  exit(0);
  }
}
}
#line 564
static int SuspendPlease ;
#line 567 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void SigStop(int sigsig ) 
{ 


  {
  {
#line 569
  while (1) {
    while_continue: /* CIL Label */ ;
#line 569
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  SuspendPlease = 1;
  return;
}
}
#line 575
static int LockPlease ;
#line 578 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void DoLock(int sigsig ) 
{ 


  {
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 584
  LockPlease = 1;
  return;
}
}
#line 590
static int SigWinchPlease ;
#line 593 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void AttacherWinch(int sigsig ) 
{ 


  {
  {
#line 595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 595
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 596
  SigWinchPlease = 1;
  return;
}
}
#line 607 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
void Attacher(void) 
{ 
  int __cil_tmp1 ;
  int *__cil_tmp2 ;
  __pid_t __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 609
  xsignal(1, AttacherFinit);
#line 610
  xsignal(1, AttacherFinit);
#line 612
  xsignal(10, AttacherFinitBye);
#line 618
  xsignal(12, DoLock);
#line 620
  xsignal(2, AttacherSigInt);
#line 622
  xsignal(20, SigStop);
#line 625
  xsignal(28, AttacherWinch);
  }
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  dflag = 0;
#line 633
  xflag = 1;
  {
#line 635
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 635
    if (! 1) {
#line 635
      goto while_break___0;
    }
    {
#line 637
    xsignal(14, AttacherSigAlarm);
#line 638
    alarm((unsigned int )15);
#line 639
    pause();
#line 640
    alarm((unsigned int )0);
#line 641
    __cil_tmp2 = __errno_location();
    }
    {
#line 641
    __cil_tmp1 = kill(MasterPid, 0);
    }
#line 641
    if (__cil_tmp1 < 0) {
#line 641
      if (*__cil_tmp2 != 1) {
        {
#line 643
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 643
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 644
        AttacherPanic ++;
      }
    }
#line 646
    if (AttacherPanic) {
      {
#line 648
      fcntl(0, 4, 0);
#line 649
      SetTTY(0, & attach_Mode);
#line 650
      printf((char const   *)((char *)"\nError: Cannot find master process to attach to!\n"));
#line 651
      eexit(1);
      }
    }
#line 654
    if (SuspendPlease) {
      {
#line 656
      SuspendPlease = 0;
#line 661
      xsignal(20, (__sighandler_t )0);
      }
      {
#line 662
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 662
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 663
      __cil_tmp4 = getpid();
#line 663
      kill(__cil_tmp4, 20);
      }
      {
#line 664
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 664
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 665
      xsignal(20, SigStop);
#line 666
      __cil_tmp5 = Attach(3);
      }
    }
#line 670
    if (LockPlease) {
      {
#line 672
      LockPlease = 0;
#line 677
      LockTerminal();
#line 681
      __cil_tmp6 = Attach(3);
      }
    }
#line 685
    if (SigWinchPlease) {
      {
#line 687
      SigWinchPlease = 0;
#line 691
      __cil_tmp7 = Attach(6);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 702 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static char LockEnd[]  =    "Welcome back to screen !!\n";
#line 705 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void LockHup(int sigsig ) 
{ 
  int ppid ;
  __pid_t __cil_tmp3 ;
  int __cil_tmp4 ;
  int *__cil_tmp5 ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;

  {
  {
#line 707
  __cil_tmp3 = getppid();
#line 707
  ppid = __cil_tmp3;
#line 708
  __cil_tmp4 = setgid((__gid_t )real_gid);
  }
#line 708
  if (__cil_tmp4) {
    {
#line 709
    __cil_tmp5 = __errno_location();
#line 709
    Panic(*__cil_tmp5, (char const   *)((char *)"setgid"));
    }
  }
  {
#line 711
  __cil_tmp6 = setuid((__uid_t )own_uid);
  }
#line 711
  if (__cil_tmp6) {
    {
#line 712
    __cil_tmp7 = __errno_location();
#line 712
    Panic(*__cil_tmp7, (char const   *)((char *)"setuid"));
    }
  }
#line 717
  if (ppid > 1) {
    {
#line 718
    Kill(ppid, 1);
    }
  }
  {
#line 719
  exit(0);
  }
}
}
#line 723 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void LockTerminal(void) 
{ 
  char *prg ;
  int sig ;
  int pid ;
  void (*sigs[65])(int  ) ;
  __sighandler_t tmp ;
  void (*__cil_tmp6)(int  ) ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp12 ;
  int *__cil_tmp13 ;
  int __cil_tmp14 ;
  int *__cil_tmp15 ;
  int *__cil_tmp16 ;
  int *__cil_tmp17 ;
  int wstat ;
  int wret ;
  int *__cil_tmp20 ;
  int *__cil_tmp22 ;
  int *__cil_tmp23 ;
  int *__cil_tmp24 ;
  int *__cil_tmp25 ;
  char *tmp___0 ;

  {
#line 729
  sig = 1;
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 729
    if (! (sig < 65)) {
#line 729
      goto while_break;
    }
#line 730
    if (sig == 17) {
#line 730
      tmp = (__sighandler_t )0;
    } else {
#line 730
      tmp = (__sighandler_t )1;
    }
    {
#line 730
    __cil_tmp6 = xsignal(sig, tmp);
#line 730
    sigs[sig] = __cil_tmp6;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 729
  sig ++;
#line 731
  xsignal(1, LockHup);
#line 732
  printf((char const   *)((char *)"\n"));
#line 734
  prg = getenv((char const   *)((char *)"LOCKPRG"));
#line 735
  __cil_tmp10 = access((char const   *)prg, 1);
  }
  {
#line 735
  __cil_tmp9 = strcmp((char const   *)prg, (char const   *)((char *)"builtin"));
  }
#line 735
  if (prg) {
#line 735
    if (__cil_tmp9) {
#line 735
      if (! __cil_tmp10) {
        {
#line 737
        xsignal(17, (__sighandler_t )0);
        }
        {
#line 738
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 738
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 739
        pid = fork();
        }
#line 739
        if (pid == 0) {
          {
#line 742
          displays = (struct display *)0;
#line 743
          ServerSocket = - 1;
#line 744
          __cil_tmp12 = setgid((__gid_t )real_gid);
          }
#line 744
          if (__cil_tmp12) {
            {
#line 745
            __cil_tmp13 = __errno_location();
#line 745
            Panic(*__cil_tmp13, (char const   *)((char *)"setgid"));
            }
          }
          {
#line 747
          __cil_tmp14 = setuid((__uid_t )own_uid);
          }
#line 747
          if (__cil_tmp14) {
            {
#line 748
            __cil_tmp15 = __errno_location();
#line 748
            Panic(*__cil_tmp15, (char const   *)((char *)"setuid"));
            }
          }
          {
#line 753
          closeallfiles(0);
#line 754
          execl((char const   *)prg, (char const   *)((char *)"SCREEN-LOCK"), (void *)0);
#line 755
          __cil_tmp16 = __errno_location();
#line 755
          exit(*__cil_tmp16);
          }
        }
#line 757
        if (pid == -1) {
          {
#line 758
          __cil_tmp17 = __errno_location();
#line 758
          Msg(*__cil_tmp17, (char const   *)((char *)"Cannot lock terminal - fork failed"));
          }
        } else {
          {
#line 771
          __cil_tmp20 = __errno_location();
#line 771
          *__cil_tmp20 = 0;
          }
          {
#line 772
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 772
            if (! (wret != pid || (wret == -1 && *__cil_tmp22 == 4))) {
#line 772
              goto while_break___1;
            }
            {
#line 775
            __cil_tmp23 = __errno_location();
#line 775
            *__cil_tmp23 = 0;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 777
          __cil_tmp24 = __errno_location();
          }
#line 777
          if (*__cil_tmp24) {
            {
#line 779
            __cil_tmp25 = __errno_location();
#line 779
            Msg(*__cil_tmp25, (char const   *)((char *)"Lock"));
#line 780
            sleep((unsigned int )2);
            }
          } else
#line 782
          if ((wstat & 127) != 0) {
#line 784
            if (wstat & 128) {
#line 784
              tmp___0 = (char *)" (Core dumped)";
            } else {
#line 784
              tmp___0 = (char *)"";
            }
            {
#line 784
            fprintf(stderr, (char const   *)((char *)"Lock: %s: Killed by signal: %d%s\n"),
                    prg, wstat & 127, tmp___0);
#line 786
            sleep((unsigned int )2);
            }
          } else
#line 788
          if ((wstat & 65280) >> 8) {
            {
#line 790
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 790
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
          } else {
            {
#line 793
            printf((char const   *)((char *)"%s"), (char *)LockEnd);
            }
          }
        }
      } else {
#line 735
        goto _L;
      }
    } else {
#line 735
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 798
    if (prg) {
      {
#line 800
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 800
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 804
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 804
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 806
    screen_builtin_lck();
    }
  }
#line 809
  sig = 1;
  {
#line 809
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 809
    if (! (sig < 65)) {
#line 809
      goto while_break___5;
    }
#line 811
    if (sigs[sig] != (void (*)(int  ))-1) {
      {
#line 812
      xsignal(sig, sigs[sig]);
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 809
  sig ++;
  return;
}
}
#line 878 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
static void screen_builtin_lck(void) 
{ 
  char fullname[100] ;
  char *cp1 ;
  char message[200] ;
  char *pass ;
  char mypass[17] ;
  char salt[3] ;
  int using_pam ;
  int __cil_tmp10 ;
  time_t __cil_tmp11 ;
  time_t __cil_tmp12 ;
  char *tmp ;
  int *__cil_tmp18 ;
  char *buf ;
  char *__cil_tmp21 ;
  size_t __cil_tmp22 ;
  int __cil_tmp23 ;
  size_t __cil_tmp24 ;
  size_t __cil_tmp25 ;

  {
#line 886
  pass = (char *)0;
#line 887
  using_pam = 1;
#line 893
  using_pam = 0;
#line 894
  pass = ppp->pw_passwd;
#line 895
  if (pass == (char *)0) {
    _L: /* CIL Label */ 
    {
#line 897
    pass = getpass((char const   *)((char *)"Key:   "));
    }
#line 897
    if (pass) {
      {
#line 899
      strncpy((char *)mypass, (char const   *)pass, sizeof(mypass) - 1UL);
#line 900
      mypass[sizeof(mypass) - 1UL] = (char )0;
      }
#line 901
      if ((int )*((char *)mypass) == 0) {
#line 902
        return;
      }
      {
#line 903
      pass = getpass((char const   *)((char *)"Again: "));
      }
#line 903
      if (pass) {
        {
#line 905
        __cil_tmp10 = strcmp((char const   *)((char *)mypass), (char const   *)pass);
        }
#line 905
        if (__cil_tmp10) {
          {
#line 907
          fprintf(stderr, (char const   *)((char *)"Passwords don\'t match.\a\n"));
#line 908
          sleep((unsigned int )2);
          }
#line 909
          return;
        }
      }
    }
#line 913
    if (pass == (char *)0) {
      {
#line 915
      fprintf(stderr, (char const   *)((char *)"Getpass error.\a\n"));
#line 916
      sleep((unsigned int )2);
      }
#line 917
      return;
    }
    {
#line 920
    __cil_tmp11 = time((time_t *)0);
#line 920
    salt[0] = (char )(65 + (int )(__cil_tmp11 % 26L));
#line 921
    __cil_tmp12 = time((time_t *)0);
#line 921
    salt[1] = (char )(65 + (int )((__cil_tmp12 >> 6) % 26L));
#line 922
    salt[2] = (char )0;
#line 923
    pass = crypt((char const   *)((char *)mypass), (char const   *)((char *)salt));
    }
#line 924
    if (! pass) {
      {
#line 926
      fprintf(stderr, (char const   *)((char *)"crypt() error.\a\n"));
#line 927
      sleep((unsigned int )2);
      }
#line 928
      return;
    }
    {
#line 930
    pass = SaveStr((char const   *)pass);
    }
  } else
#line 895
  if ((int )*pass == 0) {
#line 895
    goto _L;
  }
  {
#line 936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 936
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 937
  strncpy((char *)fullname, (char const   *)ppp->pw_gecos, sizeof(fullname) - 9UL);
#line 938
  fullname[sizeof(fullname) - 9UL] = (char )0;
#line 940
  cp1 = index((char const   *)((char *)fullname), ',');
  }
#line 940
  if (cp1 != (char *)((void *)0)) {
#line 941
    *cp1 = (char )'\000';
  }
  {
#line 942
  cp1 = index((char const   *)((char *)fullname), '&');
  }
#line 942
  if (cp1 != (char *)((void *)0)) {
    {
#line 944
    strncpy(cp1, (char const   *)ppp->pw_name, (unsigned long )8);
#line 945
    *(cp1 + 8) = (char )0;
    }
#line 946
    if ((int )*cp1 >= 97) {
#line 946
      if ((int )*cp1 <= 122) {
#line 947
        *cp1 -= 32;
      }
    }
  }
#line 950
  if ((int )fullname[0]) {
#line 950
    tmp = (char *)" ";
  } else {
#line 950
    tmp = (char *)"";
  }
  {
#line 950
  sprintf((char *)message, (char const   *)((char *)"Screen used by %s%s<%s> on %s.\nPassword:\a"),
          (char *)fullname, tmp, ppp->pw_name, (char *)HostName);
  }
  {
#line 954
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 954
    if (! 1) {
#line 954
      goto while_break___0;
    }
    {
#line 956
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 956
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 957
    __cil_tmp18 = __errno_location();
#line 957
    *__cil_tmp18 = 0;
#line 958
    cp1 = getpass((char const   *)((char *)message));
    }
#line 958
    if (cp1 == (char *)((void *)0)) {
      {
#line 960
      AttacherFinit(0);
      }
    }
#line 963
    if (! using_pam) {
      {
#line 988
      __cil_tmp21 = crypt((char const   *)cp1, (char const   *)pass);
#line 988
      buf = __cil_tmp21;
#line 989
      __cil_tmp22 = strlen((char const   *)pass);
#line 989
      __cil_tmp23 = strncmp((char const   *)buf, (char const   *)pass, __cil_tmp22);
      }
#line 989
      if (buf) {
#line 989
        if (! __cil_tmp23) {
#line 990
          goto while_break___0;
        }
      }
    }
    {
#line 992
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 992
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 993
    __cil_tmp24 = strlen((char const   *)cp1);
#line 993
    bzero((void *)cp1, __cil_tmp24);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 995
  __cil_tmp25 = strlen((char const   *)cp1);
#line 995
  bzero((void *)cp1, __cil_tmp25);
  }
  {
#line 996
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 996
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  return;
}
}
#line 1003 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/attacher.c"
void SendCmdMessage(char *sty , char *match , char **av , int query ) 
{ 
  int i ;
  int s ;
  struct msg m ;
  char *p ;
  int len ;
  int n ;
  int is_socket ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  int tmp ;
  char *tmp___824 ;
  size_t __cil_tmp20 ;
  char *tmp___825 ;
  char *sp ;
  size_t __cil_tmp24 ;
  char query___826[] ;
  char c ;
  int r ;
  int __cil_tmp32 ;
  int *__cil_tmp33 ;
  int __cil_tmp34 ;
  int *__cil_tmp35 ;

  {
#line 1015
  if (sty == (char *)0) {
    {
#line 1017
    i = FindSocket(& s, (int *)0, (int *)0, match, & is_socket);
    }
#line 1018
    if (i == 0) {
      {
#line 1019
      Panic(0, (char const   *)((char *)"No screen session found."));
      }
    }
#line 1020
    if (i != 1) {
      {
#line 1021
      Panic(0, (char const   *)((char *)"Use -S to specify a session."));
      }
    }
  } else {
    {
#line 1026
    __cil_tmp13 = strlen((char const   *)sty);
    }
#line 1026
    if (__cil_tmp13 > 255UL) {
#line 1027
      *(sty + 255) = (char )0;
    }
    {
#line 1029
    __cil_tmp14 = strlen((char const   *)sty);
    }
#line 1029
    if (__cil_tmp14 > 1535UL) {
#line 1030
      *(sty + 1535) = (char )0;
    }
    {
#line 1031
    __cil_tmp15 = strlen((char const   *)((char *)SockPath));
#line 1031
    sprintf((char *)SockPath + __cil_tmp15, (char const   *)((char *)"/%s"), sty);
#line 1032
    is_socket = IsSocket((char const   *)((char *)SockPath));
#line 1033
    s = MakeClientSocket(1, is_socket);
    }
#line 1033
    if (s == -1) {
      {
#line 1034
      exit(1);
      }
    }
  }
  {
#line 1036
  bzero((void *)((char *)(& m)), sizeof(m));
  }
#line 1037
  if (query) {
#line 1037
    tmp = 9;
  } else {
#line 1037
    tmp = 8;
  }
#line 1037
  m.type = tmp;
#line 1038
  if (attach_tty) {
#line 1040
    if (attach_tty_is_in_new_ns) {
#line 1040
      tmp___824 = (char *)attach_tty_name_in_ns;
    } else {
#line 1040
      tmp___824 = attach_tty;
    }
    {
#line 1040
    strncpy((char *)m.m_tty, (char const   *)tmp___824, sizeof(m.m_tty) - 1UL);
#line 1041
    m.m_tty[sizeof(m.m_tty) - 1UL] = (char )0;
    }
  }
#line 1043
  p = (char *)m.m.command.cmd;
#line 1044
  n = 0;
  {
#line 1045
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1045
    if (! (*av && n < 63)) {
#line 1045
      goto while_break;
    }
    {
#line 1047
    __cil_tmp20 = strlen((char const   *)*av);
#line 1047
    len = (int )(__cil_tmp20 + 1UL);
    }
#line 1048
    if (p + len >= ((char *)m.m.command.cmd + sizeof(m.m.command.cmd)) - 1) {
#line 1049
      goto while_break;
    }
    {
#line 1050
    strcpy(p, (char const   *)*av);
#line 1051
    p += len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1045
  n ++;
  {
#line 1045
  av ++;
#line 1053
  *p = (char )0;
#line 1054
  m.m.command.nargs = n;
#line 1055
  strncpy((char *)m.m.attach.auser, (char const   *)LoginName, sizeof(m.m.attach.auser) - 1UL);
#line 1056
  m.m.command.auser[sizeof(m.m.command.auser) - 1UL] = (char )0;
#line 1057
  m.protocol_revision = (((109 << 24) | (115 << 16)) | (103 << 8)) | 5;
  }
#line 1058
  if (preselect) {
#line 1058
    tmp___825 = preselect;
  } else {
#line 1058
    tmp___825 = (char *)"";
  }
  {
#line 1058
  strncpy((char *)m.m.command.preselect, (char const   *)tmp___825, sizeof(m.m.command.preselect) - 1UL);
#line 1059
  m.m.command.preselect[sizeof(m.m.command.preselect) - 1UL] = (char )0;
#line 1060
  m.m.command.apid = getpid();
  }
  {
#line 1061
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1061
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1062
  if (query) {
    {
#line 1065
    __cil_tmp24 = strlen((char const   *)((char *)SockPath));
#line 1065
    sp = (char *)SockPath + __cil_tmp24;
#line 1066
    query___826 = "-queryX";
#line 1068
    r = - 1;
#line 1069
    c = (char )'A';
    }
    {
#line 1069
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1069
      if (! ((int )c <= 90)) {
#line 1069
        goto while_break___1;
      }
      {
#line 1071
      query___826[6] = c;
#line 1072
      strcpy(sp, (char const   *)((char *)query___826));
#line 1073
      r = MakeServerSocket(is_socket);
      }
#line 1073
      if (r >= 0) {
#line 1074
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1069
    c ++;
#line 1076
    if (r < 0) {
#line 1078
      c = (char )'0';
      {
#line 1078
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1078
        if (! ((int )c <= 57)) {
#line 1078
          goto while_break___2;
        }
        {
#line 1080
        query___826[6] = c;
#line 1081
        strcpy(sp, (char const   *)((char *)query___826));
#line 1082
        r = MakeServerSocket(is_socket);
        }
#line 1082
        if (r >= 0) {
#line 1083
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1078
      c ++;
    }
#line 1087
    if (r < 0) {
      {
#line 1088
      Panic(0, (char const   *)((char *)"Could not create a listening socket to read the results."));
      }
    }
    {
#line 1090
    strncpy((char *)m.m.command.writeback, (char const   *)((char *)SockPath), sizeof(m.m.command.writeback) - 1UL);
#line 1091
    m.m.command.writeback[sizeof(m.m.command.writeback) - 1UL] = (char )'\000';
#line 1094
    xsignal(18, QueryResultSuccess);
#line 1095
    xsignal(1, QueryResultFail);
#line 1096
    __cil_tmp32 = WriteMessage(s, & m);
    }
#line 1096
    if (__cil_tmp32) {
      {
#line 1097
      __cil_tmp33 = __errno_location();
#line 1097
      Msg(*__cil_tmp33, (char const   *)((char *)"write"));
      }
    }
    {
#line 1098
    close(s);
    }
    {
#line 1099
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1099
      if (! (! QueryResult)) {
#line 1099
        goto while_break___3;
      }
      {
#line 1100
      pause();
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1101
    xsignal(18, (__sighandler_t )0);
#line 1102
    xsignal(1, (__sighandler_t )0);
#line 1105
    ReceiveRaw(r);
#line 1106
    unlink((char const   *)((char *)SockPath));
    }
#line 1107
    if (QueryResult == 2) {
      {
#line 1108
      exit(1);
      }
    }
  } else {
    {
#line 1112
    __cil_tmp34 = WriteMessage(s, & m);
    }
#line 1112
    if (__cil_tmp34) {
      {
#line 1113
      __cil_tmp35 = __errno_location();
#line 1113
      Msg(*__cil_tmp35, (char const   *)((char *)"write"));
      }
    }
    {
#line 1114
    close(s);
    }
  }
  return;
}
}
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 36 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/input.c"
static void InpProcess(char **ppbuf , int *plen ) ;
#line 37
static void InpAbort(void) ;
#line 38
static void InpRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 56
static struct inpline inphist ;
#line 71 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/input.c"
static struct LayFuncs InpLf  = 
#line 71
     {InpProcess, InpAbort, InpRedisplayLine, DefClearLine, DefRewrite, DefResize, DefRestore,
    (void (*)(void * ))0};
#line 89 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/input.c"
void inp_setprompt(char *p , char *s ) 
{ 
  struct inpdata *inpdata ;
  size_t __cil_tmp4 ;
  size_t __cil_tmp5 ;
  int tmp ;

  {
#line 94
  inpdata = (struct inpdata *)flayer->l_data;
#line 95
  if (p) {
    {
#line 97
    __cil_tmp4 = strlen((char const   *)p);
#line 97
    inpdata->inpstringlen = (int )__cil_tmp4;
#line 98
    inpdata->inpstring = p;
    }
  }
#line 100
  if (s) {
#line 102
    if (s != (char *)inpdata->inp.buf) {
      {
#line 103
      strncpy((char *)inpdata->inp.buf, (char const   *)s, sizeof(inpdata->inp.buf) - 1UL);
      }
    }
    {
#line 104
    inpdata->inp.buf[sizeof(inpdata->inp.buf) - 1UL] = (char )0;
#line 105
    __cil_tmp5 = strlen((char const   *)((char *)inpdata->inp.buf));
#line 105
    inpdata->inp.len = (int )__cil_tmp5;
#line 105
    inpdata->inp.pos = inpdata->inp.len;
    }
  }
  {
#line 107
  InpRedisplayLine(flayer->l_height - 1, 0, flayer->l_width - 1, 0);
  }
#line 108
  if (inpdata->inpmode & 1) {
#line 108
    tmp = 0;
  } else {
#line 108
    tmp = inpdata->inp.pos;
  }
#line 108
  flayer->l_x = inpdata->inpstringlen + tmp;
#line 109
  flayer->l_y = flayer->l_height - 1;
  return;
}
}
#line 123 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/input.c"
void Input(char *istr , int len , int mode , void (*finfunc)(char *buf , int len ,
                                                             char *priv ) , char *priv ,
           int data ) 
{ 
  int maxlen ;
  struct inpdata *inpdata ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 134
  if (! flayer) {
#line 135
    return;
  }
#line 137
  if (len > 768) {
#line 138
    len = 768;
  }
#line 139
  if (! (mode & 1)) {
    {
#line 141
    __cil_tmp9 = strlen((char const   *)istr);
#line 141
    maxlen = (int )((unsigned long )(flayer->l_width - 1) - __cil_tmp9);
    }
#line 142
    if (len > maxlen) {
#line 143
      len = maxlen;
    }
  }
#line 145
  if (len < 0) {
    {
#line 147
    LMsg(0, (char const   *)((char *)"Width %d chars too small"), - len);
    }
#line 148
    return;
  }
  {
#line 150
  __cil_tmp10 = InitOverlayPage((int )sizeof(*inpdata), & InpLf, 1);
  }
#line 150
  if (__cil_tmp10) {
#line 151
    return;
  }
#line 152
  flayer->l_mode = 1;
#line 153
  inpdata = (struct inpdata *)flayer->l_data;
#line 154
  inpdata->inpmaxlen = len;
#line 155
  inpdata->inpfinfunc = finfunc;
#line 156
  inpdata->inp.len = 0;
#line 156
  inpdata->inp.pos = inpdata->inp.len;
#line 157
  inpdata->inp.prev = inphist.prev;
#line 158
  inpdata->inpmode = mode;
#line 159
  inpdata->privdata = data;
#line 160
  if (! priv) {
#line 161
    priv = (char *)(& inpdata->privdata);
  }
#line 162
  inpdata->priv = priv;
#line 163
  inpdata->inpstringlen = 0;
#line 164
  inpdata->inpstring = (char *)((void *)0);
#line 165
  inpdata->search = (char *)((void *)0);
#line 166
  if (istr) {
    {
#line 167
    inp_setprompt(istr, (char *)((void *)0));
    }
  }
  return;
}
}
#line 171 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/input.c"
static void erase_chars(struct inpdata *inpdata , char *from , char *to , int x ,
                        int mv ) 
{ 
  int chng ;
  struct mchar mc ;
  char *s ;
  char *tmp ;
  char *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  if ((long )inpdata->inp.len > to - (char *)inpdata->inp.buf) {
    {
#line 181
    bcopy((void const   *)to, (void *)from, (size_t )((long )inpdata->inp.len - (to - (char *)inpdata->inp.buf)));
    }
  }
#line 182
  chng = (int )(to - from);
#line 183
  if (mv) {
#line 185
    x -= chng;
#line 186
    inpdata->inp.pos -= chng;
  }
#line 188
  inpdata->inp.len -= chng;
#line 189
  if (! (inpdata->inpmode & 1)) {
#line 192
    if (from < to) {
#line 192
      tmp = from;
    } else {
#line 192
      tmp = to;
    }
#line 192
    s = tmp;
#line 193
    mc = mchar_so;
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (! (s < (char *)inpdata->inp.buf + inpdata->inp.len)) {
#line 194
        goto while_break___0;
      }
      {
#line 196
      __cil_tmp10 = s;
#line 196
      s ++;
#line 196
      mc.image = (unsigned char )*__cil_tmp10;
#line 197
      __cil_tmp11 = x;
#line 197
      x ++;
#line 197
      LPutChar(flayer, & mc, __cil_tmp11, flayer->l_height - 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 199
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 199
      if (! __cil_tmp12) {
#line 199
        goto while_break___1;
      }
      {
#line 200
      __cil_tmp13 = x;
#line 200
      x ++;
#line 200
      LPutChar(flayer, & mchar_blank, __cil_tmp13, flayer->l_height - 1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 201
    x = inpdata->inpstringlen + inpdata->inp.pos;
#line 202
    LGotoPos(flayer, x, flayer->l_height - 1);
    }
  }
  return;
}
}
#line 207 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/input.c"
static void InpProcess(char **ppbuf , int *plen ) 
{ 
  int len___827 ;
  int x ;
  char *pbuf ;
  char ch ;
  struct inpdata *inpdata ;
  struct display *inpdisplay ;
  int prev ;
  int next ;
  int search ;
  int tmp ;
  char *p ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  struct mchar mc ;
  char *__cil_tmp19 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *oldp ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  int __cil_tmp27 ;
  struct mchar mc___0 ;
  struct inpline *sel ;
  int pos ;
  char *f ;
  char *__cil_tmp35 ;
  int __cil_tmp36 ;
  struct inpline *store ;
  int __cil_tmp38 ;
  void *__cil_tmp39 ;
  int tmp___845 ;

  {
#line 216
  search = 0;
#line 218
  inpdata = (struct inpdata *)flayer->l_data;
#line 219
  inpdisplay = display;
#line 223
  if (inpdata->inpmode & 1) {
#line 223
    tmp = 0;
  } else {
#line 223
    tmp = inpdata->inp.pos;
  }
  {
#line 223
  LGotoPos(flayer, inpdata->inpstringlen + tmp, flayer->l_height - 1);
  }
#line 224
  if (ppbuf == (char **)0) {
    {
#line 226
    InpAbort();
    }
#line 227
    return;
  }
#line 229
  x = inpdata->inpstringlen + inpdata->inp.pos;
#line 230
  len___827 = *plen;
#line 231
  pbuf = *ppbuf;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! len___827) {
#line 232
      goto while_break;
    }
#line 234
    p = (char *)inpdata->inp.buf + inpdata->inp.pos;
#line 236
    __cil_tmp14 = pbuf;
#line 236
    pbuf ++;
#line 236
    ch = *__cil_tmp14;
#line 237
    __cil_tmp15 = len___827;
#line 237
    len___827 --;
#line 238
    if (inpdata->inpmode & 4) {
#line 240
      inpdata->inp.buf[inpdata->inp.len] = ch;
#line 241
      if (ch) {
        {
#line 243
        display = inpdisplay;
#line 244
        (*(inpdata->inpfinfunc))((char *)inpdata->inp.buf, inpdata->inp.len, inpdata->priv);
#line 245
        ch = inpdata->inp.buf[inpdata->inp.len];
        }
      }
    } else
#line 248
    if (inpdata->inpmode & 2) {
      {
#line 250
      display = inpdisplay;
#line 251
      (*(inpdata->inpfinfunc))(& ch, 1, inpdata->priv);
      }
#line 252
      if (ch) {
#line 253
        goto while_continue;
      }
    }
#line 255
    if (((int )((unsigned char )ch) & 127) >= 32) {
#line 255
      if ((int )ch != 127) {
#line 255
        if (inpdata->inp.len < inpdata->inpmaxlen) {
#line 257
          if (inpdata->inp.len > inpdata->inp.pos) {
            {
#line 258
            bcopy((void const   *)p, (void *)(p + 1), (size_t )(inpdata->inp.len - inpdata->inp.pos));
            }
          }
#line 259
          __cil_tmp16 = inpdata->inp.pos;
#line 259
          (inpdata->inp.pos) ++;
#line 259
          inpdata->inp.buf[__cil_tmp16] = ch;
#line 260
          (inpdata->inp.len) ++;
#line 262
          if (! (inpdata->inpmode & 1)) {
            {
#line 265
            mc = mchar_so;
#line 266
            __cil_tmp19 = p;
#line 266
            p ++;
#line 266
            mc.image = (unsigned char )*__cil_tmp19;
#line 267
            LPutChar(flayer, & mc, x, flayer->l_height - 1);
#line 268
            x ++;
            }
#line 269
            if (p < (char *)inpdata->inp.buf + inpdata->inp.len) {
              {
#line 271
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 271
                if (! (p < (char *)inpdata->inp.buf + inpdata->inp.len)) {
#line 271
                  goto while_break___0;
                }
                {
#line 273
                __cil_tmp21 = p;
#line 273
                p ++;
#line 273
                mc.image = (unsigned char )*__cil_tmp21;
#line 274
                __cil_tmp22 = x;
#line 274
                x ++;
#line 274
                LPutChar(flayer, & mc, __cil_tmp22, flayer->l_height - 1);
                }
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 276
              x = inpdata->inpstringlen + inpdata->inp.pos;
#line 277
              LGotoPos(flayer, x, flayer->l_height - 1);
              }
            }
          }
          {
#line 280
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 280
            if (inpdata->search) {
#line 280
              if (inpdata->search == (char *)0) {
                {
#line 280
                abort();
                }
              } else {
                {
#line 280
                free((void *)inpdata->search);
                }
              }
#line 280
              inpdata->search = (char *)0;
            }

#line 280
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 255
          goto _L___843;
        }
      } else {
#line 255
        goto _L___843;
      }
    } else
    _L___843: /* CIL Label */ 
#line 282
    if ((int )ch == 8) {
      _L___842: /* CIL Label */ 
#line 282
      if (inpdata->inp.pos > 0) {
        {
#line 284
        erase_chars(inpdata, p - 1, p, x, 1);
        }
        {
#line 285
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 285
          if (inpdata->search) {
#line 285
            if (inpdata->search == (char *)0) {
              {
#line 285
              abort();
              }
            } else {
              {
#line 285
              free((void *)inpdata->search);
              }
            }
#line 285
            inpdata->search = (char *)0;
          }

#line 285
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 282
        goto _L___841;
      }
    } else
#line 282
    if ((int )ch == 127) {
#line 282
      goto _L___842;
    } else
    _L___841: /* CIL Label */ 
#line 287
    if ((int )ch == 21) {
#line 289
      x = inpdata->inpstringlen;
#line 290
      if (inpdata->inp.len) {
#line 290
        if (! (inpdata->inpmode & 1)) {
          {
#line 292
          LClearArea(flayer, x, flayer->l_height - 1, (x + inpdata->inp.len) - 1,
                     flayer->l_height - 1, 0, 0);
#line 293
          LGotoPos(flayer, x, flayer->l_height - 1);
          }
        }
      }
#line 295
      inpdata->inp.pos = 0;
#line 295
      inpdata->inp.len = inpdata->inp.pos;
    } else
#line 297
    if ((int )ch == 11) {
#line 299
      x = inpdata->inpstringlen + inpdata->inp.pos;
#line 300
      if (inpdata->inp.len > inpdata->inp.pos) {
#line 300
        if (! (inpdata->inpmode & 1)) {
          {
#line 302
          LClearArea(flayer, x, flayer->l_height - 1, ((x + inpdata->inp.len) - inpdata->inp.pos) - 1,
                     flayer->l_height - 1, 0, 0);
#line 303
          LGotoPos(flayer, x, flayer->l_height - 1);
          }
        }
      }
#line 305
      inpdata->inp.len = inpdata->inp.pos;
    } else
#line 307
    if ((int )ch == 23) {
#line 307
      if (inpdata->inp.pos > 0) {
#line 309
        __cil_tmp24 = p;
#line 309
        p --;
#line 309
        oldp = __cil_tmp24;
        {
#line 310
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 310
          if (! (p > (char *)inpdata->inp.buf && (int )*p == 32)) {
#line 310
            goto while_break___3;
          }
#line 311
          __cil_tmp25 = p;
#line 311
          p --;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 312
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 312
          if (! (p > (char *)inpdata->inp.buf && (int )*(p - 1) != 32)) {
#line 312
            goto while_break___4;
          }
#line 313
          __cil_tmp26 = p;
#line 313
          p --;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 314
        erase_chars(inpdata, p, oldp, x, 1);
        }
        {
#line 315
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 315
          if (inpdata->search) {
#line 315
            if (inpdata->search == (char *)0) {
              {
#line 315
              abort();
              }
            } else {
              {
#line 315
              free((void *)inpdata->search);
              }
            }
#line 315
            inpdata->search = (char *)0;
          }

#line 315
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 307
        goto _L___840;
      }
    } else
    _L___840: /* CIL Label */ 
#line 317
    if ((int )ch == 4) {
#line 317
      if (inpdata->inp.pos < inpdata->inp.len) {
        {
#line 319
        erase_chars(inpdata, p, p + 1, x, 0);
        }
        {
#line 320
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 320
          if (inpdata->search) {
#line 320
            if (inpdata->search == (char *)0) {
              {
#line 320
              abort();
              }
            } else {
              {
#line 320
              free((void *)inpdata->search);
              }
            }
#line 320
            inpdata->search = (char *)0;
          }

#line 320
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else {
#line 317
        goto _L___839;
      }
    } else
    _L___839: /* CIL Label */ 
#line 322
    if ((int )ch == 1) {
      {
#line 324
      x -= inpdata->inp.pos;
      {
#line 324
      LGotoPos(flayer, x, flayer->l_height - 1);
      }
#line 325
      inpdata->inp.pos = 0;
      }
    } else
#line 322
    if ((int )((unsigned char )ch) == 129) {
      {
#line 324
      x -= inpdata->inp.pos;
      {
#line 324
      LGotoPos(flayer, x, flayer->l_height - 1);
      }
#line 325
      inpdata->inp.pos = 0;
      }
    } else
#line 327
    if ((int )ch == 2) {
      _L___838: /* CIL Label */ 
#line 327
      if (inpdata->inp.pos > 0) {
        {
#line 329
        x --;
#line 329
        LGotoPos(flayer, x, flayer->l_height - 1);
#line 330
        __cil_tmp27 = inpdata->inp.pos;
#line 330
        (inpdata->inp.pos) --;
        }
      } else {
#line 327
        goto _L___837;
      }
    } else
#line 327
    if ((int )((unsigned char )ch) == 130) {
#line 327
      goto _L___838;
    } else
    _L___837: /* CIL Label */ 
#line 332
    if ((int )ch == 5) {
      {
#line 334
      x += inpdata->inp.len - inpdata->inp.pos;
      {
#line 334
      LGotoPos(flayer, x, flayer->l_height - 1);
      }
#line 335
      inpdata->inp.pos = inpdata->inp.len;
      }
    } else
#line 332
    if ((int )((unsigned char )ch) == 133) {
      {
#line 334
      x += inpdata->inp.len - inpdata->inp.pos;
      {
#line 334
      LGotoPos(flayer, x, flayer->l_height - 1);
      }
#line 335
      inpdata->inp.pos = inpdata->inp.len;
      }
    } else
#line 337
    if ((int )ch == 6) {
      _L___836: /* CIL Label */ 
#line 337
      if (inpdata->inp.pos < inpdata->inp.len) {
        {
#line 339
        x ++;
#line 339
        LGotoPos(flayer, x, flayer->l_height - 1);
#line 340
        (inpdata->inp.pos) ++;
        }
      } else {
#line 337
        goto _L___835;
      }
    } else
#line 337
    if ((int )((unsigned char )ch) == 134) {
#line 337
      goto _L___836;
    } else {
      _L___835: /* CIL Label */ 
#line 342
      search = ((int )ch == 18 || (int )((unsigned char )ch) == 146) && inpdata->inp.prev;
#line 342
      next = ((int )ch == 14 || (int )((unsigned char )ch) == 142) && inpdata->inp.next;
#line 342
      prev = ((int )ch == 16 || (int )((unsigned char )ch) == 144) && inpdata->inp.prev;
#line 342
      if (prev) {
        _L___833: /* CIL Label */ 
#line 350
        pos = - 1;
#line 352
        mc___0 = mchar_so;
#line 354
        if (prev) {
#line 355
          sel = inpdata->inp.prev;
        } else
#line 356
        if (next) {
#line 357
          sel = inpdata->inp.next;
        } else {
#line 361
          inpdata->inp.buf[inpdata->inp.len] = (char )0;
#line 362
          if (! inpdata->search) {
            {
#line 363
            inpdata->search = SaveStr((char const   *)((char *)inpdata->inp.buf));
            }
          }
#line 364
          sel = inpdata->inp.prev;
          {
#line 364
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 364
            if (! sel) {
#line 364
              goto while_break___7;
            }
            {
#line 367
            f = strstr((char const   *)((char *)sel->buf), (char const   *)inpdata->search);
            }
#line 367
            if (f) {
#line 369
              pos = (int )(f - (char *)sel->buf);
#line 370
              goto while_break___7;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 364
          sel = sel->prev;
#line 373
          if (! sel) {
#line 374
            goto while_continue;
          }
        }
#line 377
        if (inpdata->inp.len) {
#line 377
          if (! (inpdata->inpmode & 1)) {
            {
#line 378
            LClearArea(flayer, inpdata->inpstringlen, flayer->l_height - 1, (inpdata->inpstringlen + inpdata->inp.len) - 1,
                       flayer->l_height - 1, 0, 0);
            }
          }
        }
#line 380
        if (prev) {
          _L: /* CIL Label */ 
#line 380
          if (! inpdata->inp.next) {
#line 381
            inphist = inpdata->inp;
          }
        } else
#line 380
        if (search) {
#line 380
          goto _L;
        }
        {
#line 382
        memcpy((void *)(& inpdata->inp), (void const   *)sel, sizeof(struct inpline ));
        }
#line 383
        if (pos != -1) {
#line 384
          inpdata->inp.pos = pos;
        }
#line 385
        if (inpdata->inp.len > inpdata->inpmaxlen) {
#line 386
          inpdata->inp.len = inpdata->inpmaxlen;
        }
#line 387
        if (inpdata->inp.pos > inpdata->inp.len) {
#line 388
          inpdata->inp.pos = inpdata->inp.len;
        }
#line 390
        x = inpdata->inpstringlen;
#line 391
        p = (char *)inpdata->inp.buf;
#line 393
        if (! (inpdata->inpmode & 1)) {
          {
#line 395
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 395
            if (! (p < (char *)inpdata->inp.buf + inpdata->inp.len)) {
#line 395
              goto while_break___8;
            }
            {
#line 397
            __cil_tmp35 = p;
#line 397
            p ++;
#line 397
            mc___0.image = (unsigned char )*__cil_tmp35;
#line 398
            __cil_tmp36 = x;
#line 398
            x ++;
#line 398
            LPutChar(flayer, & mc___0, __cil_tmp36, flayer->l_height - 1);
            }
          }
          while_break___8: /* CIL Label */ ;
          }
        }
        {
#line 401
        x = inpdata->inpstringlen + inpdata->inp.pos;
#line 402
        LGotoPos(flayer, x, flayer->l_height - 1);
        }
      } else
#line 342
      if (next) {
#line 342
        goto _L___833;
      } else
#line 342
      if (search) {
#line 342
        goto _L___833;
      } else
#line 405
      if ((int )ch == 3) {
        _L___828: /* CIL Label */ 
#line 408
        if ((int )ch != 10) {
#line 408
          if ((int )ch != 13) {
#line 409
            inpdata->inp.len = 0;
          }
        }
#line 410
        inpdata->inp.buf[inpdata->inp.len] = (char )0;
#line 412
        if (inpdata->inp.len) {
#line 412
          if (! (inpdata->inpmode & 3)) {
#line 417
            store = inphist.prev;
            {
#line 417
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 417
              if (! store) {
#line 417
                goto while_break___9;
              }
              {
#line 419
              __cil_tmp38 = strcmp((char const   *)((char *)store->buf), (char const   *)((char *)inpdata->inp.buf));
              }
#line 419
              if (__cil_tmp38 == 0) {
#line 421
                if (store->next) {
#line 422
                  (store->next)->prev = store->prev;
                }
#line 423
                if (store->prev) {
#line 424
                  (store->prev)->next = store->next;
                }
#line 425
                store->pos = inpdata->inp.pos;
#line 426
                goto while_break___9;
              }
            }
            while_break___9: /* CIL Label */ ;
            }
#line 417
            store = store->prev;
#line 430
            if (! store) {
              {
#line 432
              __cil_tmp39 = malloc(sizeof(struct inpline ));
#line 432
              store = (struct inpline *)__cil_tmp39;
#line 433
              memcpy((void *)store, (void const   *)(& inpdata->inp), sizeof(struct inpline ));
              }
            }
#line 435
            store->next = & inphist;
#line 436
            store->prev = inphist.prev;
#line 437
            if (inphist.prev) {
#line 438
              (inphist.prev)->next = store;
            }
#line 439
            inphist.prev = store;
          }
        }
        {
#line 442
        flayer->l_data = (void *)0;
#line 443
        InpAbort();
#line 444
        *ppbuf = pbuf;
#line 445
        *plen = len___827;
#line 446
        display = inpdisplay;
        }
#line 447
        if ((inpdata->inpmode & 2) == 0) {
          {
#line 448
          (*(inpdata->inpfinfunc))((char *)inpdata->inp.buf, inpdata->inp.len, inpdata->priv);
          }
        } else {
          {
#line 450
          (*(inpdata->inpfinfunc))(pbuf - 1, 0, inpdata->priv);
          }
        }
#line 451
        if (inpdata->search) {
          {
#line 452
          free((void *)inpdata->search);
          }
        }
        {
#line 453
        free((void *)inpdata);
        }
#line 454
        return;
      } else
#line 405
      if ((int )ch == 7) {
#line 405
        goto _L___828;
      } else
#line 405
      if ((int )ch == 27) {
#line 405
        goto _L___828;
      } else
#line 405
      if ((int )ch == 0) {
#line 405
        goto _L___828;
      } else
#line 405
      if ((int )ch == 10) {
#line 405
        goto _L___828;
      } else
#line 405
      if ((int )ch == 13) {
#line 405
        goto _L___828;
      } else {
        {
#line 460
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 460
          if (inpdata->search) {
#line 460
            if (inpdata->search == (char *)0) {
              {
#line 460
              abort();
              }
            } else {
              {
#line 460
              free((void *)inpdata->search);
              }
            }
#line 460
            inpdata->search = (char *)0;
          }

#line 460
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  if (! (inpdata->inpmode & 2)) {
#line 465
    if (inpdata->inpmode & 1) {
#line 465
      tmp___845 = 0;
    } else {
#line 465
      tmp___845 = inpdata->inp.pos;
    }
#line 465
    flayer->l_x = inpdata->inpstringlen + tmp___845;
#line 466
    flayer->l_y = flayer->l_height - 1;
  }
#line 468
  *ppbuf = pbuf;
#line 469
  *plen = len___827;
  return;
}
}
#line 473 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/input.c"
static void InpAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    oldlay = flayer;
    {
#line 475
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 475
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 475
    flayer = flayer->l_next;
#line 475
    oldcvlist = flayer->l_cvlist;
    {
#line 475
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 475
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 475
    flayer->l_cvlist = oldlay->l_cvlist;
#line 475
    cv = flayer->l_cvlist;
    {
#line 475
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 475
      if (! cv) {
#line 475
        goto while_break___2;
      }
#line 475
      cv->c_layer = flayer;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 475
    cv = cv->c_lnext;
#line 475
    (*((flayer->l_layfn)->lf_LayRedisplayLine))(flayer->l_height - 1, 0, flayer->l_width - 1,
                                                0);
#line 475
    flayer = oldlay;
#line 475
    cv = flayer->l_cvlist;
    }
    {
#line 475
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 475
      if (! cv) {
#line 475
        goto while_break___3;
      }
#line 475
      cv->c_layer = flayer;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 475
    cv = cv->c_lnext;
#line 475
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 475
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 476
  ExitOverlayPage();
  }
  return;
}
}
#line 480 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/input.c"
static void InpRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  int q ;
  int r ;
  int s ;
  int l ;
  int v ;
  struct inpdata *inpdata ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
#line 486
  inpdata = (struct inpdata *)flayer->l_data;
#line 487
  if (y != flayer->l_height - 1) {
    {
#line 489
    while (1) {
      while_continue: /* CIL Label */ ;
#line 489
      oldlay = flayer;
      {
#line 489
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 489
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 489
      flayer = flayer->l_next;
#line 489
      oldcvlist = flayer->l_cvlist;
      {
#line 489
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 489
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 489
      flayer->l_cvlist = oldlay->l_cvlist;
#line 489
      cv = flayer->l_cvlist;
      {
#line 489
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 489
        if (! cv) {
#line 489
          goto while_break___2;
        }
#line 489
        cv->c_layer = flayer;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 489
      cv = cv->c_lnext;
#line 489
      (*((flayer->l_layfn)->lf_LayRedisplayLine))(y, xs, xe, isblank);
#line 489
      flayer = oldlay;
#line 489
      cv = flayer->l_cvlist;
      }
      {
#line 489
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 489
        if (! cv) {
#line 489
          goto while_break___3;
        }
#line 489
        cv->c_layer = flayer;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 489
      cv = cv->c_lnext;
#line 489
      (flayer->l_next)->l_cvlist = oldcvlist;
#line 489
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 490
    return;
  }
#line 492
  inpdata->inp.buf[inpdata->inp.len] = (char )0;
#line 493
  q = xs;
#line 494
  v = (xe - xs) + 1;
#line 495
  s = 0;
#line 496
  r = inpdata->inpstringlen;
#line 497
  if (v > 0) {
#line 497
    if (q < r) {
#line 499
      l = v;
#line 500
      if (l > r - q) {
#line 501
        l = r - q;
      }
      {
#line 502
      LPutStr(flayer, (inpdata->inpstring + q) - s, l, & mchar_so, q, y);
#line 503
      q += l;
#line 504
      v -= l;
      }
    }
  }
#line 506
  s = r;
#line 507
  r += inpdata->inp.len;
#line 508
  if (! (inpdata->inpmode & 1)) {
#line 508
    if (v > 0) {
#line 508
      if (q < r) {
#line 510
        l = v;
#line 511
        if (l > r - q) {
#line 512
          l = r - q;
        }
        {
#line 513
        LPutStr(flayer, ((char *)inpdata->inp.buf + q) - s, l, & mchar_so, q, y);
#line 514
        q += l;
#line 515
        v -= l;
        }
      }
    }
  }
#line 517
  s = r;
#line 518
  r = flayer->l_width;
#line 519
  if (! isblank) {
#line 519
    if (v > 0) {
#line 519
      if (q < r) {
#line 521
        l = v;
#line 522
        if (l > r - q) {
#line 523
          l = r - q;
        }
        {
#line 524
        LClearArea(flayer, q, y, (q + l) - 1, y, 0, 0);
#line 525
        q += l;
        }
      }
    }
  }
  return;
}
}
#line 71 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/osdef.h"
extern int tgetent(char * , char * ) ;
#line 72
extern char *tgetstr(char * , char ** ) ;
#line 73
extern int tgetnum(char * ) ;
#line 74
extern int tgetflag(char * ) ;
#line 236 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
int InitTermcap(int wi , int he ) ;
#line 243
int CreateTransTable(char *s ) ;
#line 381
void xsetegid(int egid ) ;
#line 38 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
int force_vt ;
#line 51
static void AddCap(char *s ) ;
#line 52
static void MakeString(char *cap , char *buf , int buflen , char *s ) ;
#line 53
static char *findcap(char *cap , char **tepp , int n ) ;
#line 54
static int copyarg(char **pp , char *s ) ;
#line 55
static int e_tgetent(char *bp , char *name ) ;
#line 56
static char *e_tgetstr(char *cap , char **tepp ) ;
#line 57
static int e_tgetflag(char *cap ) ;
#line 58
static int e_tgetnum(char *cap ) ;
#line 60
static int findseq_ge(char *seq , int k , unsigned char **sp ) ;
#line 61
static void setseqoff(unsigned char *p , int i , int o ) ;
#line 62
static int addmapseq(char *seq , int k , int nr ) ;
#line 63
static int remmapseq(char *seq , int k ) ;
#line 70
char Termcap[2056] ;
#line 71
static int Termcaplen ;
#line 72
static int tcLineLen ;
#line 73
char Term[773] ;
#line 76
char *extra_incap ;
#line 76
char *extra_outcap ;
#line 78 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static char const   TermcapConst[]  =    "\\\n\t:DO=\\E[%dB:LE=\\E[%dD:RI=\\E[%dC:UP=\\E[%dA:bs:bt=\\E[Z:\\\n\t:cd=\\E[J:ce=\\E[K:cl=\\E[H\\E[J:cm=\\E[%i%d;%dH:ct=\\E[3g:\\\n\t:do=^J:nd=\\E[C:pt:rc=\\E8:rs=\\Ec:sc=\\E7:st=\\EH:up=\\EM:\\\n\t:le=^H:bl=^G:cr=^M:it#8:ho=\\E[H:nw=\\EE:ta=^I:is=\\E)0:";
#line 85 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
char *gettermcapstring(char *s ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 90
  if (display == (struct display *)0) {
#line 91
    return ((char *)0);
  } else
#line 90
  if (s == (char *)0) {
#line 91
    return ((char *)0);
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i < 201)) {
#line 92
      goto while_break;
    }
#line 94
    if (term[i].type != 2) {
#line 95
      goto while_continue;
    }
    {
#line 96
    __cil_tmp3 = strcmp((char const   *)term[i].tcname, (char const   *)s);
    }
#line 96
    if (__cil_tmp3 == 0) {
#line 97
      return (display->d_tcs[i].str);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i ++;
#line 99
  return ((char *)0);
}
}
#line 108 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
int InitTermcap(int wi , int he ) 
{ 
  register char *s ;
  int i ;
  char tbuf[2048] ;
  char *tp ;
  int t ;
  int xue ;
  int xse ;
  int xme ;
  int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  unsigned long tmp ;
  void *__cil_tmp14 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  int tmp___846 ;
  int tmp___847 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int tmp___851 ;
  int tmp___852 ;
  int __cil_tmp45 ;
  char *tmp___853 ;
  char *tmp___854 ;
  size_t __cil_tmp49 ;
  size_t __cil_tmp50 ;
  int __cil_tmp51 ;
  int enc ;
  int __cil_tmp53 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;

  {
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  bzero((void *)((char *)tbuf), sizeof(tbuf));
  }
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 119
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 120
  __cil_tmp11 = e_tgetent((char *)tbuf, (char *)display->d_termname);
  }
#line 120
  if ((int )*((char *)display->d_termname) == 0) {
    {
    {
#line 123
    Msg(0, (char const   *)((char *)"Cannot find terminfo entry for \'%s\'."), (char *)display->d_termname);
    }
    }
#line 127
    return (- 1);
  } else
#line 120
  if (__cil_tmp11 != 1) {
    {
    {
#line 123
    Msg(0, (char const   *)((char *)"Cannot find terminfo entry for \'%s\'."), (char *)display->d_termname);
    }
    }
#line 127
    return (- 1);
  }
  {
#line 129
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 129
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 137
  if (extra_incap) {
    {
#line 137
    __cil_tmp12 = strlen((char const   *)extra_incap);
#line 137
    tmp = __cil_tmp12 + 1UL;
    }
  } else {
#line 137
    tmp = (unsigned long )0;
  }
  {
#line 137
  __cil_tmp14 = malloc(2048UL + tmp);
#line 137
  display->d_tentry = (char *)__cil_tmp14;
  }
#line 137
  if (display->d_tentry == (char *)0) {
    {
#line 139
    Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
#line 140
    return (- 1);
  }
#line 146
  tp = display->d_tentry;
#line 147
  i = 0;
  {
#line 147
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 147
    if (! (i < 201)) {
#line 147
      goto while_break___2;
    }
    {
#line 151
    if (term[i].type == 0) {
#line 151
      goto case_0;
    }
#line 154
    if (term[i].type == 1) {
#line 154
      goto case_1;
    }
#line 157
    if (term[i].type == 2) {
#line 157
      goto case_2;
    }
#line 163
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 152
    display->d_tcs[i].flg = e_tgetflag(term[i].tcname);
    }
#line 153
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 155
    display->d_tcs[i].num = e_tgetnum(term[i].tcname);
    }
#line 156
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 158
    display->d_tcs[i].str = e_tgetstr(term[i].tcname, & tp);
    }
#line 160
    if (display->d_tcs[i].str) {
#line 160
      if ((int )*(display->d_tcs[i].str) == 0) {
#line 161
        display->d_tcs[i].str = (char *)0;
      }
    }
#line 162
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 164
    Panic(0, (char const   *)((char *)"Illegal tc type in entry #%d"), i);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 147
  i ++;
#line 172
  if (display->d_tcs[2].flg) {
    {
#line 174
    Msg(0, (char const   *)((char *)"You can\'t run screen on a hardcopy terminal."));
    }
#line 175
    return (- 1);
  }
#line 177
  if (display->d_tcs[3].flg) {
    {
#line 179
    Msg(0, (char const   *)((char *)"You can\'t run screen on a terminal that overstrikes."));
    }
#line 180
    return (- 1);
  }
#line 182
  if (! display->d_tcs[34].str) {
    {
#line 184
    Msg(0, (char const   *)((char *)"Clear screen capability required."));
    }
#line 185
    return (- 1);
  }
#line 187
  if (! display->d_tcs[5].str) {
    {
#line 189
    Msg(0, (char const   *)((char *)"Addressable cursor capability required."));
    }
#line 190
    return (- 1);
  }
  {
#line 192
  i = atoi((char const   *)s);
  }
  {
#line 192
  s = getenv((char const   *)((char *)"COLUMNS"));
  }
#line 192
  if (s) {
#line 192
    if (i > 0) {
#line 193
      display->d_tcs[1].num = i;
    }
  }
  {
#line 194
  i = atoi((char const   *)s);
  }
  {
#line 194
  s = getenv((char const   *)((char *)"LINES"));
  }
#line 194
  if (s) {
#line 194
    if (i > 0) {
#line 195
      display->d_tcs[0].num = i;
    }
  }
#line 196
  if (wi) {
#line 197
    display->d_tcs[1].num = wi;
  }
#line 198
  if (he) {
#line 199
    display->d_tcs[0].num = he;
  }
#line 200
  if (display->d_tcs[1].num <= 0) {
#line 201
    display->d_tcs[1].num = 80;
  }
#line 202
  if (display->d_tcs[0].num <= 0) {
#line 203
    display->d_tcs[0].num = 24;
  }
#line 205
  if (display->d_tcs[95].flg) {
    {
#line 209
    __cil_tmp24 = InStr(display->d_tcs[55].str, (char const   *)((char *)"\033[0m"));
    }
    {
#line 209
    __cil_tmp23 = InStr(display->d_tcs[55].str, (char const   *)((char *)"\033[m"));
    }
#line 209
    if (! display->d_tcs[60].str) {
#line 209
      if (display->d_tcs[55].str) {
#line 209
        if (__cil_tmp23) {
#line 212
          display->d_tcs[60].str = (char *)"\033[3%p1%dm";
#line 213
          display->d_tcs[61].str = (char *)"\033[4%p1%dm";
        } else
#line 209
        if (__cil_tmp24) {
#line 212
          display->d_tcs[60].str = (char *)"\033[3%p1%dm";
#line 213
          display->d_tcs[61].str = (char *)"\033[4%p1%dm";
        }
      }
    }
    {
#line 219
    __cil_tmp25 = InStr(display->d_tcs[64].str, (char const   *)((char *)"\033[39;49m"));
    }
#line 219
    if (display->d_tcs[64].str) {
#line 219
      if (__cil_tmp25) {
#line 220
        display->d_tcs[67].flg = 1;
      }
    }
    {
#line 221
    __cil_tmp27 = InStr(display->d_tcs[64].str, (char const   *)((char *)"\033[0m"));
    }
    {
#line 221
    __cil_tmp26 = InStr(display->d_tcs[64].str, (char const   *)((char *)"\033[m"));
    }
#line 221
    if (display->d_tcs[64].str) {
#line 221
      if (__cil_tmp26) {
#line 222
        display->d_tcs[64].str = (char *)0;
      } else
#line 221
      if (__cil_tmp27) {
#line 222
        display->d_tcs[64].str = (char *)0;
      }
    }
    {
#line 224
    __cil_tmp29 = InStr(display->d_tcs[101].str, (char const   *)((char *)"\033(0"));
    }
    {
#line 224
    __cil_tmp28 = InStr(display->d_tcs[104].str, (char const   *)((char *)"\033(B"));
    }
#line 224
    if (display->d_tcs[104].str) {
#line 224
      if (__cil_tmp28) {
#line 225
        display->d_tcs[97].flg = 1;
      } else {
#line 224
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 224
    if (display->d_tcs[101].str) {
#line 224
      if (__cil_tmp29) {
#line 225
        display->d_tcs[97].flg = 1;
      }
    }
    {
#line 226
    __cil_tmp33 = InStr(display->d_tcs[106].str, (char const   *)((char *)"\033[<"));
    }
    {
#line 226
    __cil_tmp32 = InStr(display->d_tcs[106].str, (char const   *)((char *)"\033[M"));
    }
    {
#line 226
    __cil_tmp31 = InStr((char *)display->d_termname, (char const   *)((char *)"rxvt"));
    }
    {
#line 226
    __cil_tmp30 = InStr((char *)display->d_termname, (char const   *)((char *)"xterm"));
    }
#line 226
    if (__cil_tmp30) {
      {
#line 229
      display->d_tcs[96].flg = 1;
      {
      {
      {
#line 230
      kmapdef[0] = SaveStr((char const   *)display->d_tcs[106].str);
      }
      }
      }
      }
    } else
#line 226
    if (__cil_tmp31) {
      {
#line 229
      display->d_tcs[96].flg = 1;
      {
      {
      {
#line 230
      kmapdef[0] = SaveStr((char const   *)display->d_tcs[106].str);
      }
      }
      }
      }
    } else
#line 226
    if (display->d_tcs[106].str) {
#line 226
      if (__cil_tmp32) {
        {
#line 229
        display->d_tcs[96].flg = 1;
        {
        {
        {
#line 230
        kmapdef[0] = SaveStr((char const   *)display->d_tcs[106].str);
        }
        }
        }
        }
      } else
#line 226
      if (__cil_tmp33) {
        {
#line 229
        display->d_tcs[96].flg = 1;
        {
        {
        {
#line 230
        kmapdef[0] = SaveStr((char const   *)display->d_tcs[106].str);
        }
        }
        }
        }
      }
    }
#line 233
    if (display->d_tcs[96].flg) {
#line 234
      display->d_tcs[66].flg = 1;
    }
  }
#line 236
  if (nwin_options.flowflag == nwin_undef.flowflag) {
#line 237
    if (display->d_tcs[88].flg) {
#line 237
      tmp___847 = 0;
    } else {
#line 237
      if (display->d_tcs[89].flg) {
#line 237
        tmp___846 = 1;
      } else {
#line 237
        tmp___846 = 1 << 2;
      }
#line 237
      tmp___847 = tmp___846;
    }
#line 237
    nwin_default.flowflag = tmp___847;
  }
#line 240
  display->d_tcs[87].flg |= (! display->d_tcs[83].flg || display->d_tcs[84].flg) || display->d_tcs[85].flg;
#line 241
  if (! display->d_tcs[42].str) {
#line 242
    display->d_tcs[42].str = (char *)"\a";
  }
#line 243
  if (! display->d_tcs[13].str) {
#line 245
    if (display->d_tcs[12].flg) {
#line 246
      display->d_tcs[13].str = (char *)"\b";
    } else {
#line 248
      display->d_tcs[13].str = display->d_tcs[14].str;
    }
  }
#line 250
  if (! display->d_tcs[7].str) {
#line 251
    display->d_tcs[7].str = (char *)"\r";
  }
#line 252
  if (! display->d_tcs[19].str) {
#line 253
    display->d_tcs[19].str = (char *)"\n";
  }
#line 261
  if (display->d_tcs[58].num > 0) {
#line 262
    display->d_tcs[53].str = (char *)0;
#line 262
    display->d_tcs[48].str = display->d_tcs[53].str;
  }
#line 263
  if (display->d_tcs[57].num > 0) {
#line 264
    display->d_tcs[54].str = (char *)0;
#line 264
    display->d_tcs[51].str = display->d_tcs[54].str;
  }
#line 268
  if (display->d_tcs[58].num > 0) {
#line 268
    if (display->d_tcs[57].num > 0) {
#line 269
      display->d_tcs[55].str = (char *)0;
#line 269
      display->d_tcs[52].str = display->d_tcs[55].str;
#line 269
      display->d_tcs[50].str = display->d_tcs[52].str;
#line 269
      display->d_tcs[49].str = display->d_tcs[50].str;
#line 269
      display->d_tcs[47].str = display->d_tcs[49].str;
    }
  }
#line 271
  xue = 1 << 2;
#line 272
  xse = 1 << 1;
#line 273
  xme = 1;
#line 275
  if (display->d_tcs[51].str) {
#line 275
    if (display->d_tcs[54].str == (char *)0) {
      {
#line 277
      Msg(0, (char const   *)((char *)"Warning: \'so\' but no \'se\' capability."));
      }
#line 278
      if (display->d_tcs[55].str) {
#line 279
        xse = xme;
      } else {
#line 281
        display->d_tcs[51].str = (char *)0;
      }
    }
  }
#line 283
  if (display->d_tcs[48].str) {
#line 283
    if (display->d_tcs[53].str == (char *)0) {
      {
#line 285
      Msg(0, (char const   *)((char *)"Warning: \'us\' but no \'ue\' capability."));
      }
#line 286
      if (display->d_tcs[55].str) {
#line 287
        xue = xme;
      } else {
#line 289
        display->d_tcs[48].str = (char *)0;
      }
    }
  }
#line 291
  if (display->d_tcs[47].str) {
    _L___848: /* CIL Label */ 
#line 291
    if (display->d_tcs[55].str == (char *)0) {
      {
#line 293
      Msg(0, (char const   *)((char *)"Warning: \'m?\' but no \'me\' capability."));
#line 294
      display->d_tcs[52].str = (char *)0;
#line 294
      display->d_tcs[50].str = display->d_tcs[52].str;
#line 294
      display->d_tcs[49].str = display->d_tcs[50].str;
#line 294
      display->d_tcs[47].str = display->d_tcs[49].str;
      }
    }
  } else
#line 291
  if (display->d_tcs[49].str) {
#line 291
    goto _L___848;
  } else
#line 291
  if (display->d_tcs[50].str) {
#line 291
    goto _L___848;
  } else
#line 291
  if (display->d_tcs[52].str) {
#line 291
    goto _L___848;
  }
  {
#line 301
  __cil_tmp37 = strcmp((char const   *)display->d_tcs[54].str, (char const   *)display->d_tcs[53].str);
  }
#line 301
  if (display->d_tcs[53].str) {
#line 301
    if (display->d_tcs[54].str) {
#line 301
      if (__cil_tmp37 == 0) {
#line 302
        xse = xue;
      }
    }
  }
  {
#line 303
  __cil_tmp38 = strcmp((char const   *)display->d_tcs[55].str, (char const   *)display->d_tcs[54].str);
  }
#line 303
  if (display->d_tcs[54].str) {
#line 303
    if (display->d_tcs[55].str) {
#line 303
      if (__cil_tmp38 == 0) {
#line 304
        xse = xme;
      }
    }
  }
  {
#line 305
  __cil_tmp39 = strcmp((char const   *)display->d_tcs[55].str, (char const   *)display->d_tcs[53].str);
  }
#line 305
  if (display->d_tcs[53].str) {
#line 305
    if (display->d_tcs[55].str) {
#line 305
      if (__cil_tmp39 == 0) {
#line 306
        xue = xme;
      }
    }
  }
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 308
    if (! (i < 6)) {
#line 308
      goto while_break___3;
    }
#line 310
    display->d_attrtab[i] = display->d_tcs[47 + i].str;
#line 311
    if (i == 4) {
#line 311
      tmp___852 = xse;
    } else {
#line 311
      if (i == 1) {
#line 311
        tmp___851 = xue;
      } else {
#line 311
        tmp___851 = xme;
      }
#line 311
      tmp___852 = tmp___851;
    }
#line 311
    display->d_attrtyp[i] = (char )tmp___852;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 308
  i ++;
#line 315
  s = (char *)0;
#line 316
  t = 0;
#line 317
  i = 0;
  {
#line 317
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 317
    if (! (i < 6)) {
#line 317
      goto while_break___4;
    }
#line 318
    s = display->d_attrtab[i];
#line 318
    if (s) {
#line 320
      t = (int )display->d_attrtyp[i];
#line 321
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 317
  i ++;
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 323
    if (! (i < 6)) {
#line 323
      goto while_break___5;
    }
#line 325
    if (display->d_attrtab[i] == (char *)0) {
#line 327
      display->d_attrtab[i] = s;
#line 328
      display->d_attrtyp[i] = (char )t;
    } else {
#line 332
      s = display->d_attrtab[i];
#line 333
      t = (int )display->d_attrtyp[i];
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 323
  i ++;
#line 336
  if (display->d_tcs[60].str) {
#line 337
    display->d_hascolor = 1;
  } else
#line 336
  if (display->d_tcs[61].str) {
#line 337
    display->d_hascolor = 1;
  } else
#line 336
  if (display->d_tcs[62].str) {
#line 337
    display->d_hascolor = 1;
  } else
#line 336
  if (display->d_tcs[63].str) {
#line 337
    display->d_hascolor = 1;
  }
#line 338
  if (display->d_tcs[33].flg) {
#line 339
    display->d_tcs[66].flg = 1;
  }
#line 341
  if (! display->d_tcs[10].str) {
#line 342
    display->d_tcs[10].str = display->d_tcs[19].str;
  }
#line 343
  if (! display->d_tcs[20].str) {
#line 344
    display->d_tcs[20].str = display->d_tcs[19].str;
  }
#line 345
  if (display->d_tcs[26].flg) {
#line 346
    display->d_tcs[27].str = (char *)0;
#line 346
    display->d_tcs[29].str = display->d_tcs[27].str;
  }
#line 347
  if (display->d_tcs[28].str == (char *)0) {
#line 348
    display->d_tcs[27].str = (char *)0;
  }
  {
#line 350
  __cil_tmp45 = strcmp((char const   *)display->d_tcs[29].str, (char const   *)display->d_tcs[27].str);
  }
#line 350
  if (display->d_tcs[29].str) {
#line 350
    if (display->d_tcs[27].str) {
#line 350
      if (__cil_tmp45 == 0) {
#line 351
        display->d_tcs[29].str = (char *)0;
      }
    }
  }
#line 352
  if (display->d_tcs[70].str == (char *)0) {
#line 353
    display->d_tcs[69].str = (char *)0;
  }
#line 354
  if (display->d_tcs[94].str == (char *)0) {
#line 355
    display->d_tcs[93].str = (char *)0;
  }
#line 356
  if (display->d_tcs[82].str == (char *)0) {
#line 357
    display->d_tcs[81].str = (char *)0;
#line 357
    display->d_tcs[80].str = display->d_tcs[81].str;
  }
#line 358
  if (display->d_tcs[72].str == (char *)0) {
#line 359
    display->d_tcs[71].str = (char *)0;
  }
#line 362
  if (display->d_tcs[97].flg) {
#line 364
    if (display->d_tcs[98].str == (char *)0) {
#line 366
      display->d_tcs[98].str = (char *)"\033(%p1%c";
    }
#line 370
    if (display->d_tcs[99].str == (char *)0) {
#line 371
      display->d_tcs[99].str = (char *)"\033(B";
    }
#line 372
    display->d_tcs[103].str = (char *)0;
#line 373
    display->d_tcs[104].str = (char *)0;
  } else
#line 375
  if (display->d_tcs[103].str) {
    _L___855: /* CIL Label */ 
#line 377
    if (display->d_tcs[101].str && display->d_tcs[102].str) {
#line 377
      tmp___853 = display->d_tcs[101].str;
    } else {
#line 377
      tmp___853 = (char *)"";
    }
#line 377
    display->d_tcs[98].str = tmp___853;
#line 378
    if (display->d_tcs[101].str && display->d_tcs[102].str) {
#line 378
      tmp___854 = display->d_tcs[102].str;
    } else {
#line 378
      tmp___854 = (char *)"";
    }
#line 378
    display->d_tcs[99].str = tmp___854;
#line 379
    display->d_tcs[100].str = display->d_tcs[103].str;
  } else
#line 375
  if (display->d_tcs[101].str) {
#line 375
    if (display->d_tcs[102].str) {
#line 375
      goto _L___855;
    } else {
#line 383
      display->d_tcs[99].str = (char *)"";
#line 383
      display->d_tcs[98].str = display->d_tcs[99].str;
#line 384
      display->d_tcs[100].str = (char *)0;
#line 385
      display->d_tcs[103].str = (char *)"";
    }
  } else {
#line 383
    display->d_tcs[99].str = (char *)"";
#line 383
    display->d_tcs[98].str = display->d_tcs[99].str;
#line 384
    display->d_tcs[100].str = (char *)0;
#line 385
    display->d_tcs[103].str = (char *)"";
  }
#line 388
  i = 0;
  {
#line 388
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 388
    if (! (i < 256)) {
#line 388
      goto while_break___6;
    }
#line 389
    display->d_c0_tab[i] = (char )i;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 388
  i ++;
#line 390
  if (display->d_tcs[103].str) {
    {
#line 393
    s = (char *)"l+m+k+j+u+t+v+w+q-x|n+o~s_p\"r#`+a:f\'g#~o.v-^+<,>h#I#0#y<z>";
#line 394
    __cil_tmp49 = strlen((char const   *)s);
#line 394
    i = (int )((__cil_tmp49 - 2UL) & 0xfffffffffffffffeUL);
    }
    {
#line 394
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 394
      if (! (i >= 0)) {
#line 394
        goto while_break___7;
      }
#line 395
      display->d_c0_tab[(int )((unsigned char )*(s + i))] = *(s + (i + 1));
    }
    while_break___7: /* CIL Label */ ;
    }
#line 394
    i -= 2;
  }
#line 397
  if (display->d_tcs[100].str) {
    {
#line 398
    __cil_tmp50 = strlen((char const   *)display->d_tcs[100].str);
#line 398
    i = (int )((__cil_tmp50 - 2UL) & 0xfffffffffffffffeUL);
    }
    {
#line 398
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 398
      if (! (i >= 0)) {
#line 398
        goto while_break___8;
      }
#line 399
      display->d_c0_tab[(int )((unsigned char )*(display->d_tcs[100].str + i))] = *(display->d_tcs[100].str + (i + 1));
    }
    while_break___8: /* CIL Label */ ;
    }
#line 398
    i -= 2;
  }
  {
#line 400
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 400
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 402
  if (display->d_tcs[74].str == (char *)0) {
#line 403
    display->d_tcs[73].str = (char *)0;
  }
  {
#line 404
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 404
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 407
  if (display->d_tcs[105].str) {
    {
#line 408
    __cil_tmp51 = CreateTransTable(display->d_tcs[105].str);
    }
#line 408
    if (__cil_tmp51) {
#line 409
      return (- 1);
    }
  }
#line 413
  if (display->d_tcs[46].str == (char *)0) {
#line 414
    display->d_tcs[45].str = (char *)0;
  }
  {
#line 416
  CheckScreenSize(0);
  }
#line 418
  if (display->d_tcs[77].str == (char *)0) {
#line 419
    display->d_tcs[75].flg = 0;
  } else
#line 418
  if (display->d_tcs[78].str == (char *)0) {
#line 419
    display->d_tcs[75].flg = 0;
  } else
#line 418
  if (display->d_tcs[79].str == (char *)0) {
#line 419
    display->d_tcs[75].flg = 0;
  }
#line 420
  if (display->d_tcs[75].flg) {
    {
#line 422
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 422
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 423
    if (display->d_tcs[76].num < 0) {
#line 424
      display->d_tcs[76].num = 0;
    }
  }
#line 426
  display->d_has_hstatus = hardstatusemu & ~ (1 << 3);
#line 427
  if (display->d_tcs[75].flg) {
#line 427
    if (! (hardstatusemu & (1 << 3))) {
#line 428
      display->d_has_hstatus = 3;
    }
  }
#line 431
  if (display->d_tcs[92].str) {
    {
#line 433
    __cil_tmp53 = FindEncoding(display->d_tcs[92].str);
#line 433
    enc = __cil_tmp53;
    }
#line 434
    if (enc != -1) {
#line 435
      display->d_encoding = enc;
    }
  }
#line 438
  if (! display->d_tcs[158].str) {
#line 438
    if (display->d_tcs[159].str) {
#line 439
      display->d_tcs[158].str = display->d_tcs[159].str;
    }
  }
#line 440
  if (! display->d_tcs[160].str) {
#line 440
    if (display->d_tcs[161].str) {
#line 441
      display->d_tcs[160].str = display->d_tcs[161].str;
    }
  }
  {
#line 443
  display->d_UPcost = CalcCost(display->d_tcs[8].str);
#line 444
  display->d_DOcost = CalcCost(display->d_tcs[10].str);
#line 445
  display->d_NLcost = CalcCost(display->d_tcs[19].str);
#line 446
  display->d_LEcost = CalcCost(display->d_tcs[13].str);
#line 447
  display->d_NDcost = CalcCost(display->d_tcs[16].str);
#line 448
  display->d_CRcost = CalcCost(display->d_tcs[7].str);
#line 449
  display->d_IMcost = CalcCost(display->d_tcs[27].str);
#line 450
  display->d_EIcost = CalcCost(display->d_tcs[28].str);
  }
#line 453
  if (display->d_tcs[90].flg) {
    {
#line 455
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 455
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 456
    display->d_auto_nuke = 1;
  }
#line 459
  if (display->d_tcs[91].num > 0) {
    {
#line 461
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 461
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 462
    display->d_obufmax = display->d_tcs[91].num;
#line 463
    display->d_obuflenmax = display->d_obuflen - display->d_obufmax;
  }
  {
#line 467
  __cil_tmp62 = strcmp((char const   *)display->d_tcs[106].str, (char const   *)display->d_tcs[116].str);
  }
#line 467
  if (display->d_tcs[106].str) {
#line 467
    if (display->d_tcs[116].str) {
#line 467
      if (! __cil_tmp62) {
#line 468
        display->d_tcs[106].str = (char *)0;
      }
    }
  }
  {
#line 470
  __cil_tmp63 = strcmp((char const   *)display->d_tcs[165].str, (char const   *)((char *)"\0177"));
  }
#line 470
  if (display->d_tcs[165].str) {
#line 470
    if (! __cil_tmp63) {
#line 471
      display->d_tcs[165].str = (char *)0;
    }
  }
  {
#line 473
  __cil_tmp64 = strcmp((char const   *)display->d_tcs[169].str, (char const   *)((char *)""));
  }
#line 473
  if (display->d_tcs[169].str) {
#line 473
    if (! __cil_tmp64) {
#line 474
      display->d_tcs[169].str = (char *)0;
    }
  }
#line 477
  display->d_nseqs = 0;
#line 478
  i = 0;
  {
#line 478
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 478
    if (! (i < 82)) {
#line 478
      goto while_break___14;
    }
    {
#line 479
    remap(i, 1);
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 478
  i ++;
#line 480
  i = 0;
  {
#line 480
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 480
    if (! (i < kmap_extn)) {
#line 480
      goto while_break___15;
    }
    {
#line 481
    remap(i + 104, 1);
    }
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 480
  i ++;
#line 482
  display->d_seqp = display->d_kmaps + 3;
#line 483
  display->d_seql = 0;
#line 484
  display->d_seqh = (unsigned char *)0;
#line 487
  display->d_tcinited = (char )1;
#line 488
  MakeTermcap(0);
#line 490
  e_tgetent((char *)tbuf, (char *)display->d_termname);
#line 492
  CheckEscape();
  }
#line 494
  return (0);
}
}
#line 500 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
int remap(int n , int map ) 
{ 
  char *s ;
  int fl ;
  int domap ;
  struct action *a1 ;
  struct action *a2 ;
  struct action *tab ;
  int l ;
  struct kmap_ext *kme ;
  size_t __cil_tmp11 ;
  size_t tmp ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  struct action *tmp___0 ;
  struct action *tmp___1 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 504
  s = (char *)0;
#line 505
  fl = 0;
#line 505
  domap = 0;
#line 507
  l = 0;
#line 508
  kme = (struct kmap_ext *)0;
#line 510
  a1 = (struct action *)0;
#line 511
  if (n >= 104) {
#line 513
    kme = kmap_exts + (n - 104);
#line 514
    s = kme->str;
#line 515
    l = kme->fl & -16385;
#line 516
    fl = kme->fl & 16384;
#line 517
    a1 = & kme->um;
  }
#line 519
  tab = (struct action *)umtab;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! 1) {
#line 520
      goto while_break;
    }
#line 522
    a2 = (struct action *)0;
#line 523
    if (n < 104) {
#line 525
      a1 = & *(tab + n);
#line 526
      if (n >= 82) {
#line 527
        n -= 22;
      }
#line 528
      s = display->d_tcs[n + 106].str;
#line 529
      if (s) {
        {
#line 529
        __cil_tmp11 = strlen((char const   *)s);
#line 529
        tmp = __cil_tmp11;
        }
      } else {
#line 529
        tmp = (unsigned long )0;
      }
#line 529
      l = (int )tmp;
#line 530
      if (n >= 60) {
#line 531
        a2 = & *(tab + (n + 22));
      }
    }
#line 533
    if (s == (char *)0) {
#line 534
      return (0);
    } else
#line 533
    if (l == 0) {
#line 534
      return (0);
    }
#line 535
    if (a1) {
#line 535
      if (a1->nr == -1) {
#line 536
        a1 = (struct action *)0;
      }
    }
#line 537
    if (a2) {
#line 537
      if (a2->nr == -1) {
#line 538
        a2 = (struct action *)0;
      }
    }
    {
#line 539
    __cil_tmp13 = strcmp((char const   *)*(a1->args + 0), (char const   *)s);
    }
#line 539
    if (a1) {
#line 539
      if (a1->nr == 160) {
#line 539
        if (*(a1->args + 0)) {
#line 539
          if (__cil_tmp13 == 0) {
#line 540
            a1 = (struct action *)0;
          }
        }
      }
    }
    {
#line 541
    __cil_tmp14 = strcmp((char const   *)*(a2->args + 0), (char const   *)s);
    }
#line 541
    if (a2) {
#line 541
      if (a2->nr == 160) {
#line 541
        if (*(a2->args + 0)) {
#line 541
          if (__cil_tmp14 == 0) {
#line 542
            a2 = (struct action *)0;
          }
        }
      }
    }
#line 543
    domap |= a1 || a2;
#line 544
    if (tab == (struct action *)umtab) {
#line 546
      tab = (struct action *)dmtab;
#line 547
      if (kme) {
#line 547
        tmp___0 = & kme->dm;
      } else {
#line 547
        tmp___0 = (struct action *)0;
      }
#line 547
      a1 = tmp___0;
    } else
#line 549
    if (tab == (struct action *)dmtab) {
#line 551
      tab = (struct action *)mmtab;
#line 552
      if (kme) {
#line 552
        tmp___1 = & kme->mm;
      } else {
#line 552
        tmp___1 = (struct action *)0;
      }
#line 552
      a1 = tmp___1;
    } else {
#line 555
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  if (n < 82) {
#line 558
    domap = 1;
  }
#line 559
  if (map == 0) {
#line 559
    if (domap) {
#line 560
      return (0);
    }
  }
#line 561
  if (map) {
#line 561
    if (! domap) {
#line 562
      return (0);
    }
  }
  {
#line 563
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 563
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 564
  if (map) {
    {
#line 565
    __cil_tmp17 = addmapseq(s, l, n | fl);
    }
#line 565
    return (__cil_tmp17);
  } else {
    {
#line 567
    __cil_tmp18 = remmapseq(s, l);
    }
#line 567
    return (__cil_tmp18);
  }
}
}
#line 571 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
void CheckEscape(void) 
{ 
  struct display *odisplay ;
  int i ;
  int nr ;
  struct kmap_ext *kme ;

  {
#line 576
  if (DefaultEsc >= 0) {
#line 577
    return;
  }
#line 579
  odisplay = display;
#line 580
  display = displays;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! display) {
#line 580
      goto while_break;
    }
#line 582
    i = 0;
    {
#line 582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 582
      if (! (i < display->d_nseqs)) {
#line 582
        goto while_break___0;
      }
#line 584
      nr = (((int )*(display->d_kmaps + i) << 8) | (int )*(display->d_kmaps + (i + 1))) & -16385;
#line 585
      if (nr < 104) {
#line 587
        if (umtab[nr].nr == 35) {
#line 588
          goto while_break___0;
        }
#line 589
        if (umtab[nr].nr == -1) {
#line 589
          if (dmtab[nr].nr == 35) {
#line 590
            goto while_break___0;
          }
        }
      } else {
#line 594
        kme = (kmap_exts + nr) - 104;
#line 595
        if (kme->um.nr == 35) {
#line 596
          goto while_break___0;
        }
#line 597
        if (kme->um.nr == -1) {
#line 597
          if (kme->dm.nr == 35) {
#line 598
            goto while_break___0;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 582
    i += (int )*(display->d_kmaps + (i + 2)) * 2 + 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  display = display->d_next;
#line 602
  if (display == (struct display *)0) {
#line 604
    display = odisplay;
#line 605
    return;
  }
  {
#line 607
  SetEscape((struct acluser *)0, 1, 'a');
  }
#line 608
  if ((odisplay->d_user)->u_Esc == -1) {
#line 609
    (odisplay->d_user)->u_Esc = DefaultEsc;
  }
#line 610
  if ((odisplay->d_user)->u_MetaEsc == -1) {
#line 611
    (odisplay->d_user)->u_MetaEsc = DefaultMetaEsc;
  }
  {
#line 612
  display = (struct display *)0;
#line 613
  Msg(0, (char const   *)((char *)"Warning: escape char set back to ^A"));
#line 614
  display = odisplay;
  }
  return;
}
}
#line 618 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static int findseq_ge(char *seq , int k , unsigned char **sp ) 
{ 
  unsigned char *p ;
  int j ;
  int l ;

  {
#line 626
  p = display->d_kmaps;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! (p - display->d_kmaps < (long )display->d_nseqs)) {
#line 627
      goto while_break;
    }
#line 629
    l = (int )*(p + 2);
#line 630
    p += 3;
#line 631
    j = 0;
    {
#line 631
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 631
      if (! 1) {
#line 631
        goto while_break___0;
      }
#line 633
      if (j == k) {
#line 634
        j = l - k;
      } else
#line 633
      if (j == l) {
#line 634
        j = l - k;
      } else
#line 635
      if ((int )*(p + j) != (int )*((unsigned char *)seq + j)) {
#line 636
        j = (int )*(p + j) - (int )*((unsigned char *)seq + j);
      } else {
#line 638
        goto while_continue___0;
      }
#line 639
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 631
    j ++;
#line 641
    if (j >= 0) {
#line 643
      *sp = p - 3;
#line 644
      return (j);
    }
#line 646
    p += 2 * l + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 648
  *sp = p;
#line 649
  return (- 1);
}
}
#line 653 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static void setseqoff(unsigned char *p , int i , int o ) 
{ 
  unsigned char *q ;
  int l ;
  int k ;

  {
#line 661
  k = (int )*(p + 2);
#line 662
  if (o < 256) {
#line 664
    *(p + ((k + 4) + i)) = (unsigned char )o;
#line 665
    return;
  }
#line 668
  q = (p + k * 2) + 4;
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    if (! 1) {
#line 668
      goto while_break;
    }
#line 670
    l = (int )*(q + 2);
#line 671
    if (((q + l * 2) - p) / 2L >= 256L) {
#line 673
      *(p + ((k + 4) + i)) = (unsigned char )(((q - p) - 4L) / 2L);
#line 674
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 668
  q += l * 2 + 4;
  return;
}
}
#line 680 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static int addmapseq(char *seq , int k , int nr ) 
{ 
  int i ;
  int j ;
  int l ;
  int mo ;
  int m ;
  unsigned char *p ;
  unsigned char *q ;
  char *__cil_tmp12 ;
  int tmp ;

  {
#line 688
  if (k >= 254) {
#line 689
    return (- 1);
  }
  {
#line 690
  j = findseq_ge(seq, k, & p);
  }
#line 691
  if (j == 0) {
#line 693
    *(p + 0) = (unsigned char )(nr >> 8);
#line 694
    *(p + 1) = (unsigned char )nr;
#line 695
    return (0);
  }
#line 697
  i = (int )(p - display->d_kmaps);
#line 698
  if ((display->d_nseqs + 2 * k) + 4 >= display->d_aseqs) {
    {
#line 700
    __cil_tmp12 = xrealloc((char *)display->d_kmaps, display->d_aseqs + 256);
#line 700
    display->d_kmaps = (unsigned char *)__cil_tmp12;
#line 701
    display->d_aseqs += 256;
#line 702
    p = display->d_kmaps + i;
    }
  }
  {
#line 704
  display->d_seqp = display->d_kmaps + 3;
#line 705
  display->d_seql = 0;
#line 706
  display->d_seqh = (unsigned char *)0;
#line 707
  evdeq(& display->d_mapev);
  }
#line 708
  if (j > 0) {
    {
#line 709
    bcopy((void const   *)((char *)p), (void *)(((char *)p + 2 * k) + 4), (size_t )(display->d_nseqs - i));
    }
  }
  {
#line 710
  *(p + 0) = (unsigned char )(nr >> 8);
#line 711
  *(p + 1) = (unsigned char )nr;
#line 712
  *(p + 2) = (unsigned char )k;
#line 713
  bcopy((void const   *)seq, (void *)((char *)p + 3), (size_t )k);
#line 714
  bzero((void *)((p + k) + 3), (unsigned long )(k + 1));
#line 715
  display->d_nseqs += 2 * k + 4;
  }
#line 716
  if (j > 0) {
#line 718
    q = (p + 2 * k) + 4;
#line 719
    l = (int )*(q + 2);
#line 720
    i = 0;
    {
#line 720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 720
      if (! (i < k)) {
#line 720
        goto while_break;
      }
#line 722
      if ((int )*(p + (3 + i)) != (int )*(q + (3 + i))) {
#line 724
        *(p + ((k + 4) + i)) = (unsigned char )k;
#line 725
        goto while_break;
      }
#line 727
      if ((int )*(q + ((l + 4) + i))) {
#line 727
        tmp = ((int )*(q + ((l + 4) + i)) + k) + 2;
      } else {
#line 727
        tmp = 0;
      }
      {
#line 727
      setseqoff(p, i, tmp);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 720
    i ++;
  }
#line 730
  q = display->d_kmaps;
  {
#line 730
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 730
    if (! (q < p)) {
#line 730
      goto while_break___0;
    }
#line 732
    l = (int )*(q + 2);
#line 733
    j = 0;
#line 733
    m = j;
    {
#line 733
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 733
      if (! (j < l)) {
#line 733
        goto while_break___1;
      }
#line 735
      mo = m;
#line 736
      if (! m) {
#line 736
        if ((int )*(q + (3 + j)) != (int )*(seq + j)) {
#line 737
          m = 1;
        }
      }
#line 738
      if ((int )*(q + ((l + 4) + j)) == 0) {
#line 740
        if (! mo) {
#line 740
          if (m) {
            {
#line 741
            setseqoff(q, j, (int )(((p - q) - 4L) / 2L));
            }
          }
        }
      } else
#line 743
      if ((q + (int )*(q + ((l + 4) + j)) * 2) + 4 > p) {
        {
        {
#line 744
        setseqoff(q, j, ((int )*(q + ((l + 4) + j)) + k) + 2);
        }
        }
      } else
#line 743
      if ((q + (int )*(q + ((l + 4) + j)) * 2) + 4 == p) {
#line 743
        if (! m) {
          {
          {
#line 744
          setseqoff(q, j, ((int )*(q + ((l + 4) + j)) + k) + 2);
          }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 733
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 730
  q += 2 * l + 4;
#line 750
  return (0);
}
}
#line 754 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static int remmapseq(char *seq , int k ) 
{ 
  int j ;
  int l ;
  unsigned char *p ;
  unsigned char *q ;
  int tmp ;

  {
  {
#line 761
  j = findseq_ge(seq, k, & p);
  }
#line 761
  if (k >= 254) {
#line 762
    return (- 1);
  } else
#line 761
  if (j != 0) {
#line 762
    return (- 1);
  }
#line 763
  q = display->d_kmaps;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (! (q < p)) {
#line 763
      goto while_break;
    }
#line 765
    l = (int )*(q + 2);
#line 766
    j = 0;
    {
#line 766
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 766
      if (! (j < l)) {
#line 766
        goto while_break___0;
      }
#line 768
      if ((q + (int )*(q + ((l + 4) + j)) * 2) + 4 == p) {
#line 769
        if ((int )*(p + ((k + 4) + j))) {
#line 769
          tmp = ((int )*(q + ((l + 4) + j)) + (int )*(p + ((k + 4) + j))) - k;
        } else {
#line 769
          tmp = 0;
        }
        {
#line 769
        setseqoff(q, j, tmp);
        }
      } else
#line 770
      if ((q + (int )*(q + ((l + 4) + j)) * 2) + 4 > p) {
#line 771
        *(q + ((l + 4) + j)) -= k + 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 766
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 763
  q += 2 * l + 4;
#line 774
  if (display->d_kmaps + display->d_nseqs > (p + 2 * k) + 4) {
    {
#line 775
    bcopy((void const   *)(((char *)p + 2 * k) + 4), (void *)((char *)p), (size_t )((display->d_kmaps + display->d_nseqs) - ((p + 2 * k) + 4)));
    }
  }
  {
#line 776
  display->d_nseqs -= 2 * k + 4;
#line 777
  display->d_seqp = display->d_kmaps + 3;
#line 778
  display->d_seql = 0;
#line 779
  display->d_seqh = (unsigned char *)0;
#line 780
  evdeq(& display->d_mapev);
  }
#line 784
  return (0);
}
}
#line 826 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static void AddCap(char *s ) 
{ 
  register int n ;
  size_t __cil_tmp3 ;

  {
  {
#line 831
  __cil_tmp3 = strlen((char const   *)s);
#line 831
  n = (int )__cil_tmp3;
  }
#line 831
  if (tcLineLen + n > 55) {
#line 831
    if (Termcaplen < 2043) {
      {
#line 833
      strcpy((char *)Termcap + Termcaplen, (char const   *)((char *)"\\\n\t:"));
#line 834
      Termcaplen += 4;
#line 835
      tcLineLen = 0;
      }
    }
  }
#line 837
  if (Termcaplen + n < 2047) {
    {
#line 839
    strcpy((char *)Termcap + Termcaplen, (char const   *)s);
#line 840
    Termcaplen += n;
#line 841
    tcLineLen += n;
    }
  } else {
    {
#line 844
    Panic(0, (char const   *)((char *)"TERMCAP overflow - sorry."));
    }
  }
  return;
}
}
#line 852 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
char *MakeTermcap(int aflag ) 
{ 
  char buf[2048] ;
  register char *p ;
  register char *cp ;
  register char *s ;
  register char ch ;
  register char *tname ;
  int i ;
  int wi ;
  int he ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;
  size_t __cil_tmp22 ;
  size_t __cil_tmp23 ;
  struct action *act ;

  {
#line 862
  if (display) {
#line 864
    wi = display->d_width;
#line 865
    he = display->d_height;
#line 866
    tname = (char *)display->d_termname;
  } else {
#line 870
    wi = 80;
#line 871
    he = 24;
#line 872
    tname = (char *)"vt100";
  }
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 874
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 875
  __cil_tmp12 = strlen((char const   *)s);
  }
  {
#line 875
  s = getenv((char const   *)((char *)"SCREENCAP"));
  }
#line 875
  if (s) {
#line 875
    if (__cil_tmp12 < 2048UL) {
      {
#line 877
      sprintf((char *)Termcap, (char const   *)((char *)"TERMCAP=%s"), s);
#line 878
      strcpy((char *)Term, (char const   *)((char *)"TERM=screen"));
      }
      {
#line 879
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 879
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 880
      return ((char *)Termcap);
    }
  }
#line 882
  Termcaplen = 0;
  {
#line 883
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 883
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 884
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 884
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 885
  __cil_tmp13 = strlen((char const   *)((char *)screenterm));
  }
#line 885
  if ((int )*((char *)screenterm) == 0) {
    _L: /* CIL Label */ 
    {
#line 887
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 887
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 888
    strncpy((char *)screenterm, (char const   *)((char *)"screen"), (unsigned long )32);
#line 889
    screenterm[32] = (char )'\000';
    }
  } else
#line 885
  if (__cil_tmp13 > 765UL) {
#line 885
    goto _L;
  }
  {
#line 894
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 896
    strcpy((char *)Term, (char const   *)((char *)"TERM="));
#line 897
    p = (char *)Term + 5;
#line 898
    __cil_tmp15 = strlen((char const   *)tname);
    }
    {
#line 898
    __cil_tmp14 = strlen((char const   *)((char *)screenterm));
    }
#line 898
    if (! aflag) {
#line 898
      if (__cil_tmp14 + __cil_tmp15 < 767UL) {
        {
#line 900
        sprintf(p, (char const   *)((char *)"%s.%s"), (char *)screenterm, tname);
#line 901
        __cil_tmp16 = e_tgetent((char *)buf, p);
        }
#line 901
        if (__cil_tmp16 == 1) {
#line 902
          goto while_break___4;
        }
      }
    }
#line 905
    if (nwin_default.bce) {
      {
#line 907
      sprintf(p, (char const   *)((char *)"%s-bce"), (char *)screenterm);
#line 908
      __cil_tmp17 = e_tgetent((char *)buf, p);
      }
#line 908
      if (__cil_tmp17 == 1) {
#line 909
        goto while_break___4;
      }
    }
    {
#line 920
    strcpy(p, (char const   *)((char *)screenterm));
#line 921
    __cil_tmp18 = e_tgetent((char *)buf, p);
    }
#line 921
    if (__cil_tmp18 == 1) {
#line 922
      goto while_break___4;
    }
    {
#line 923
    strcpy(p, (char const   *)((char *)"vt100"));
    }
#line 894
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 944
  tcLineLen = 100;
#line 945
  __cil_tmp19 = strlen((char const   *)((char *)Term));
  }
#line 945
  if (__cil_tmp19 > 2008UL) {
    {
#line 946
    strcpy((char *)Term, (char const   *)((char *)"too_long"));
    }
  }
  {
#line 947
  sprintf((char *)Termcap, (char const   *)((char *)"TERMCAP=SC|%s|VT 100/ANSI X3.64 virtual terminal:"),
          (char *)Term + 5);
#line 948
  __cil_tmp20 = strlen((char const   *)((char *)Termcap));
#line 948
  Termcaplen = (int )__cil_tmp20;
  }
  {
#line 949
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 949
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 950
  if (extra_outcap) {
#line 950
    if ((int )*extra_outcap) {
#line 952
      cp = extra_outcap;
      {
#line 952
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 952
        if (! p) {
#line 952
          goto while_break___6;
        }
        {
#line 954
        p ++;
#line 954
        ch = *p;
#line 955
        *p = (char )'\000';
#line 956
        AddCap(cp);
#line 957
        *p = ch;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 952
      cp = p;
#line 959
      tcLineLen = 100;
    }
  }
  {
#line 961
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 961
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 962
  __cil_tmp22 = strlen((char const   *)TermcapConst);
  }
#line 962
  if ((unsigned long )Termcaplen + __cil_tmp22 < 2048UL) {
    {
#line 964
    strcpy((char *)Termcap + Termcaplen, (char const   *)((char *)((char const   *)TermcapConst)));
#line 965
    __cil_tmp23 = strlen((char const   *)TermcapConst);
    }
#line 965
    Termcaplen += __cil_tmp23;
  }
  {
#line 967
  sprintf((char *)buf, (char const   *)((char *)"li#%d:co#%d:"), he, wi);
#line 968
  AddCap((char *)buf);
#line 969
  AddCap((char *)"am:");
  }
#line 970
  if (aflag) {
    {
    {
    {
    {
#line 972
    AddCap((char *)"xn:");
    }
    }
    }
    {
    {
    {
#line 973
    AddCap((char *)"xv:");
    }
    }
    }
    {
    {
    {
#line 974
    AddCap((char *)"LP:");
    }
    }
    }
    }
  } else
#line 970
  if (force_vt) {
#line 970
    if (! display->d_tcs[86].flg) {
      {
      {
      {
      {
#line 972
      AddCap((char *)"xn:");
      }
      }
      }
      {
      {
      {
#line 973
      AddCap((char *)"xv:");
      }
      }
      }
      {
      {
      {
#line 974
      AddCap((char *)"LP:");
      }
      }
      }
      }
    } else {
#line 970
      goto _L___856;
    }
  } else
  _L___856: /* CIL Label */ 
#line 970
  if (display->d_tcs[87].flg) {
    {
    {
    {
    {
#line 972
    AddCap((char *)"xn:");
    }
    }
    }
    {
    {
    {
#line 973
    AddCap((char *)"xv:");
    }
    }
    }
    {
    {
    {
#line 974
    AddCap((char *)"LP:");
    }
    }
    }
    }
  } else
#line 970
  if (! display->d_tcs[83].flg) {
    {
    {
    {
    {
#line 972
    AddCap((char *)"xn:");
    }
    }
    }
    {
    {
    {
#line 973
    AddCap((char *)"xv:");
    }
    }
    }
    {
    {
    {
#line 974
    AddCap((char *)"LP:");
    }
    }
    }
    }
  }
#line 976
  if (aflag) {
    {
    {
    {
    {
#line 978
    AddCap((char *)"sr=\\EM:");
    }
    }
    }
    {
    {
    {
#line 979
    AddCap((char *)"al=\\E[L:");
    }
    }
    }
    {
    {
    {
#line 980
    AddCap((char *)"AL=\\E[%dL:");
    }
    }
    }
    }
  } else
#line 976
  if (display->d_tcs[18].str) {
#line 976
    if (display->d_tcs[21].str) {
      {
      {
      {
      {
#line 978
      AddCap((char *)"sr=\\EM:");
      }
      }
      }
      {
      {
      {
#line 979
      AddCap((char *)"al=\\E[L:");
      }
      }
      }
      {
      {
      {
#line 980
      AddCap((char *)"AL=\\E[%dL:");
      }
      }
      }
      }
    } else {
#line 976
      goto _L___857;
    }
  } else
  _L___857: /* CIL Label */ 
#line 976
  if (display->d_tcs[22].str) {
    {
    {
    {
    {
#line 978
    AddCap((char *)"sr=\\EM:");
    }
    }
    }
    {
    {
    {
#line 979
    AddCap((char *)"al=\\E[L:");
    }
    }
    }
    {
    {
    {
#line 980
    AddCap((char *)"AL=\\E[%dL:");
    }
    }
    }
    }
  } else
#line 976
  if (display->d_tcs[23].str) {
    {
    {
    {
    {
#line 978
    AddCap((char *)"sr=\\EM:");
    }
    }
    }
    {
    {
    {
#line 979
    AddCap((char *)"al=\\E[L:");
    }
    }
    }
    {
    {
    {
#line 980
    AddCap((char *)"AL=\\E[%dL:");
    }
    }
    }
    }
  } else
#line 982
  if (display->d_tcs[21].str) {
    {
#line 983
    AddCap((char *)"sr=\\EM:");
    }
  }
#line 984
  if (aflag) {
    {
    {
#line 985
    AddCap((char *)"cs=\\E[%i%d;%dr:");
    }
    }
  } else
#line 984
  if (display->d_tcs[18].str) {
    {
    {
#line 985
    AddCap((char *)"cs=\\E[%i%d;%dr:");
    }
    }
  }
#line 986
  if (aflag) {
    {
    {
    {
    {
#line 988
    AddCap((char *)"dl=\\E[M:");
    }
    }
    }
    {
    {
    {
#line 989
    AddCap((char *)"DL=\\E[%dM:");
    }
    }
    }
    }
  } else
#line 986
  if (display->d_tcs[18].str) {
    {
    {
    {
    {
#line 988
    AddCap((char *)"dl=\\E[M:");
    }
    }
    }
    {
    {
    {
#line 989
    AddCap((char *)"DL=\\E[%dM:");
    }
    }
    }
    }
  } else
#line 986
  if (display->d_tcs[24].str) {
    {
    {
    {
    {
#line 988
    AddCap((char *)"dl=\\E[M:");
    }
    }
    }
    {
    {
    {
#line 989
    AddCap((char *)"DL=\\E[%dM:");
    }
    }
    }
    }
  } else
#line 986
  if (display->d_tcs[25].str) {
    {
    {
    {
    {
#line 988
    AddCap((char *)"dl=\\E[M:");
    }
    }
    }
    {
    {
    {
#line 989
    AddCap((char *)"DL=\\E[%dM:");
    }
    }
    }
    }
  }
#line 991
  if (aflag) {
    {
    {
    {
#line 993
    AddCap((char *)"dc=\\E[P:");
    }
    }
    {
    {
#line 994
    AddCap((char *)"DC=\\E[%dP:");
    }
    }
    }
  } else
#line 991
  if (display->d_tcs[31].str) {
    {
    {
    {
#line 993
    AddCap((char *)"dc=\\E[P:");
    }
    }
    {
    {
#line 994
    AddCap((char *)"DC=\\E[%dP:");
    }
    }
    }
  } else
#line 991
  if (display->d_tcs[32].str) {
    {
    {
    {
#line 993
    AddCap((char *)"dc=\\E[P:");
    }
    }
    {
    {
#line 994
    AddCap((char *)"DC=\\E[%dP:");
    }
    }
    }
  }
#line 996
  if (aflag) {
    {
    {
    {
    {
#line 998
    AddCap((char *)"im=\\E[4h:");
    }
    }
    }
    {
    {
    {
#line 999
    AddCap((char *)"ei=\\E[4l:");
    }
    }
    }
    {
    {
    {
#line 1000
    AddCap((char *)"mi:");
    }
    }
    }
    {
    {
    {
#line 1001
    AddCap((char *)"IC=\\E[%d@:");
    }
    }
    }
    }
  } else
#line 996
  if (display->d_tcs[30].str) {
    {
    {
    {
    {
#line 998
    AddCap((char *)"im=\\E[4h:");
    }
    }
    }
    {
    {
    {
#line 999
    AddCap((char *)"ei=\\E[4l:");
    }
    }
    }
    {
    {
    {
#line 1000
    AddCap((char *)"mi:");
    }
    }
    }
    {
    {
    {
#line 1001
    AddCap((char *)"IC=\\E[%d@:");
    }
    }
    }
    }
  } else
#line 996
  if (display->d_tcs[29].str) {
    {
    {
    {
    {
#line 998
    AddCap((char *)"im=\\E[4h:");
    }
    }
    }
    {
    {
    {
#line 999
    AddCap((char *)"ei=\\E[4l:");
    }
    }
    }
    {
    {
    {
#line 1000
    AddCap((char *)"mi:");
    }
    }
    }
    {
    {
    {
#line 1001
    AddCap((char *)"IC=\\E[%d@:");
    }
    }
    }
    }
  } else
#line 996
  if (display->d_tcs[27].str) {
    {
    {
    {
    {
#line 998
    AddCap((char *)"im=\\E[4h:");
    }
    }
    }
    {
    {
    {
#line 999
    AddCap((char *)"ei=\\E[4l:");
    }
    }
    }
    {
    {
    {
#line 1000
    AddCap((char *)"mi:");
    }
    }
    }
    {
    {
    {
#line 1001
    AddCap((char *)"IC=\\E[%d@:");
    }
    }
    }
    }
  }
  {
#line 1004
  AddCap((char *)"ks=\\E[?1h\\E=:");
#line 1005
  AddCap((char *)"ke=\\E[?1l\\E>:");
#line 1007
  AddCap((char *)"vi=\\E[?25l:");
#line 1008
  AddCap((char *)"ve=\\E[34h\\E[?25h:");
#line 1009
  AddCap((char *)"vs=\\E[34l:");
#line 1010
  AddCap((char *)"ti=\\E[?1049h:");
#line 1011
  AddCap((char *)"te=\\E[?1049l:");
  }
#line 1012
  if (display) {
#line 1014
    if (display->d_tcs[48].str) {
      {
#line 1016
      AddCap((char *)"us=\\E[4m:");
#line 1017
      AddCap((char *)"ue=\\E[24m:");
      }
    }
#line 1019
    if (display->d_tcs[51].str) {
      {
#line 1021
      AddCap((char *)"so=\\E[3m:");
#line 1022
      AddCap((char *)"se=\\E[23m:");
      }
    }
#line 1024
    if (display->d_tcs[52].str) {
      {
#line 1025
      AddCap((char *)"mb=\\E[5m:");
      }
    }
#line 1026
    if (display->d_tcs[49].str) {
      {
#line 1027
      AddCap((char *)"md=\\E[1m:");
      }
    }
#line 1028
    if (display->d_tcs[47].str) {
      {
#line 1029
      AddCap((char *)"mh=\\E[2m:");
      }
    }
#line 1030
    if (display->d_tcs[50].str) {
      {
#line 1031
      AddCap((char *)"mr=\\E[7m:");
      }
    }
#line 1032
    if (display->d_tcs[52].str) {
      {
      {
      {
      {
#line 1033
      AddCap((char *)"me=\\E[m:ms:");
      }
      }
      }
      }
    } else
#line 1032
    if (display->d_tcs[49].str) {
      {
      {
      {
      {
#line 1033
      AddCap((char *)"me=\\E[m:ms:");
      }
      }
      }
      }
    } else
#line 1032
    if (display->d_tcs[47].str) {
      {
      {
      {
      {
#line 1033
      AddCap((char *)"me=\\E[m:ms:");
      }
      }
      }
      }
    } else
#line 1032
    if (display->d_tcs[50].str) {
      {
      {
      {
      {
#line 1033
      AddCap((char *)"me=\\E[m:ms:");
      }
      }
      }
      }
    }
#line 1034
    if (display->d_hascolor) {
      {
#line 1035
      AddCap((char *)"Co#8:pa#64:AF=\\E[3%dm:AB=\\E[4%dm:op=\\E[39;49m:AX:");
      }
    }
#line 1036
    if (display->d_tcs[43].str) {
      {
#line 1037
      AddCap((char *)"vb=\\Eg:");
      }
    }
#line 1050
    if (display->d_tcs[97].flg) {
      {
#line 1051
      AddCap((char *)"G0:");
      }
    }
#line 1052
    if (display->d_tcs[100].str) {
      {
      {
#line 1054
      AddCap((char *)"as=\\E(0:");
      }
      {
#line 1055
      AddCap((char *)"ae=\\E(B:");
      }
      {
#line 1057
      AddCap((char *)"ac=\\140\\140aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~..--++,,hhII00:");
      }
      }
    } else
#line 1052
    if (display->d_tcs[98].str) {
#line 1052
      if ((int )*(display->d_tcs[98].str)) {
        {
        {
#line 1054
        AddCap((char *)"as=\\E(0:");
        }
        {
#line 1055
        AddCap((char *)"ae=\\E(B:");
        }
        {
#line 1057
        AddCap((char *)"ac=\\140\\140aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~..--++,,hhII00:");
        }
        }
      }
    }
#line 1059
    if (display->d_tcs[73].str) {
      {
#line 1061
      AddCap((char *)"po=\\E[5i:");
#line 1062
      AddCap((char *)"pf=\\E[4i:");
      }
    }
#line 1064
    if (display->d_tcs[45].str) {
      {
#line 1066
      AddCap((char *)"Z0=\\E[?3h:");
#line 1067
      AddCap((char *)"Z1=\\E[?3l:");
      }
    }
#line 1069
    if (display->d_tcs[44].str) {
      {
#line 1070
      AddCap((char *)"WS=\\E[8;%d;%dt:");
      }
    }
  }
#line 1072
  i = 106;
  {
#line 1072
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1072
    if (! (i < 201)) {
#line 1072
      goto while_break___8;
    }
#line 1076
    if (i < 188) {
#line 1078
      if (i >= 170) {
#line 1079
        goto while_continue___8;
      }
#line 1080
      if (i >= 166) {
#line 1080
        if (i < 188) {
#line 1082
          act = & umtab[i - 84];
#line 1083
          if (act->nr == -1) {
#line 1084
            act = & dmtab[i - 84];
          }
        } else {
#line 1080
          goto _L___858;
        }
      } else {
        _L___858: /* CIL Label */ 
#line 1088
        act = & umtab[i - 106];
#line 1089
        if (act->nr == -1) {
#line 1090
          act = & dmtab[i - 106];
        }
      }
#line 1092
      if (act->nr == -1) {
#line 1092
        if (i == 159) {
          _L___859: /* CIL Label */ 
#line 1095
          act = & umtab[(i - 106) - 1];
#line 1096
          if (act->nr == -1) {
#line 1097
            act = & dmtab[(i - 106) - 1];
          }
        } else
#line 1092
        if (i == 161) {
#line 1092
          goto _L___859;
        }
      }
#line 1099
      if (act->nr != -1) {
#line 1101
        if (act->nr == 160) {
          {
#line 1103
          MakeString(term[i].tcname, (char *)buf, (int )sizeof(buf), *(act->args + 0));
#line 1104
          AddCap((char *)buf);
          }
        }
#line 1106
        goto while_continue___8;
      }
    }
#line 1110
    if (display == (struct display *)0) {
#line 1111
      goto while_continue___8;
    }
    {
#line 1114
    if (term[i].type == 2) {
#line 1114
      goto case_2;
    }
#line 1120
    if (term[i].type == 0) {
#line 1120
      goto case_0;
    }
#line 1126
    goto switch_default;
    case_2: /* CIL Label */ 
#line 1115
    if (display->d_tcs[i].str == (char *)0) {
#line 1116
      goto switch_break;
    }
    {
#line 1117
    MakeString(term[i].tcname, (char *)buf, (int )sizeof(buf), display->d_tcs[i].str);
#line 1118
    AddCap((char *)buf);
    }
#line 1119
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1121
    if (display->d_tcs[i].flg == 0) {
#line 1122
      goto switch_break;
    }
    {
#line 1123
    sprintf((char *)buf, (char const   *)((char *)"%s:"), term[i].tcname);
#line 1124
    AddCap((char *)buf);
    }
#line 1125
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1127
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1072
  i ++;
  {
#line 1130
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1130
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1131
  return ((char *)Termcap);
}
}
#line 1135 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static void MakeString(char *cap , char *buf , int buflen , char *s ) 
{ 
  register char *p ;
  register char *pmax ;
  register unsigned int c ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1143
  p = buf;
#line 1144
  pmax = (p + buflen) - 9;
#line 1145
  __cil_tmp9 = cap;
#line 1145
  cap ++;
#line 1145
  __cil_tmp8 = p;
#line 1145
  p ++;
#line 1145
  *__cil_tmp8 = *__cil_tmp9;
#line 1146
  __cil_tmp10 = p;
#line 1146
  p ++;
#line 1146
  *__cil_tmp10 = *cap;
#line 1147
  __cil_tmp11 = p;
#line 1147
  p ++;
#line 1147
  *__cil_tmp11 = (char )'=';
  {
#line 1148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1148
    if (! (c && p < pmax)) {
#line 1148
      goto while_break;
    }
    {
#line 1152
    if (c == (unsigned int )'\033') {
#line 1152
      goto case_27;
    }
#line 1156
    if (c == (unsigned int )':') {
#line 1156
      goto case_58;
    }
#line 1161
    if (c == (unsigned int )'\\') {
#line 1161
      goto case_92;
    }
#line 1161
    if (c == (unsigned int )'^') {
#line 1161
      goto case_92;
    }
#line 1165
    goto switch_default;
    case_27: /* CIL Label */ 
#line 1153
    __cil_tmp13 = p;
#line 1153
    p ++;
#line 1153
    *__cil_tmp13 = (char )'\\';
#line 1154
    __cil_tmp14 = p;
#line 1154
    p ++;
#line 1154
    *__cil_tmp14 = (char )'E';
#line 1155
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 1157
    strcpy(p, (char const   *)((char *)"\\072"));
    }
#line 1158
    p += 4;
#line 1159
    goto switch_break;
    case_92: /* CIL Label */ 
    case_94: /* CIL Label */ 
#line 1162
    __cil_tmp15 = p;
#line 1162
    p ++;
#line 1162
    *__cil_tmp15 = (char )'\\';
#line 1163
    __cil_tmp16 = p;
#line 1163
    p ++;
#line 1163
    *__cil_tmp16 = (char )c;
#line 1164
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1166
    if (c >= 200U) {
      {
#line 1168
      sprintf(p, (char const   *)((char *)"\\%03o"), c & 255U);
#line 1169
      p += 4;
      }
    } else
#line 1171
    if (c < 32U) {
#line 1173
      __cil_tmp17 = p;
#line 1173
      p ++;
#line 1173
      *__cil_tmp17 = (char )'^';
#line 1174
      __cil_tmp18 = p;
#line 1174
      p ++;
#line 1174
      *__cil_tmp18 = (char )(c + 64U);
    } else {
#line 1177
      __cil_tmp19 = p;
#line 1177
      p ++;
#line 1177
      *__cil_tmp19 = (char )c;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1180
  __cil_tmp20 = p;
#line 1180
  p ++;
#line 1180
  *__cil_tmp20 = (char )':';
#line 1181
  *p = (char )'\000';
  return;
}
}
#line 1191 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
int CreateTransTable(char *s ) 
{ 
  int curchar ;
  char *templ ;
  char *arg ;
  int templlen ;
  int templnsub ;
  char *p ;
  char *sx ;
  char **ctable ;
  int l ;
  int c ;
  void *__cil_tmp12 ;
  char *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  void *__cil_tmp24 ;
  char *tmp ;
  int __cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 1202
  __cil_tmp12 = calloc((unsigned long )256, sizeof(char **));
#line 1202
  display->d_xtable = (char ***)__cil_tmp12;
  }
#line 1202
  if (display->d_xtable == (char ***)0) {
    {
#line 1204
    Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
#line 1205
    return (- 1);
  }
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1208
    if (! *s) {
#line 1208
      goto while_break;
    }
#line 1210
    if ((int )*s == 92) {
#line 1210
      if ((int )*(s + 1) == 92) {
#line 1211
        s ++;
      } else
#line 1210
      if ((int )*(s + 1) == 44) {
#line 1211
        s ++;
      } else
#line 1210
      if ((int )*(s + 1) == 37) {
#line 1211
        s ++;
      }
    }
#line 1212
    __cil_tmp14 = s;
#line 1212
    s ++;
#line 1212
    curchar = (int )((unsigned char )*__cil_tmp14);
#line 1213
    if (curchar == 66) {
#line 1214
      curchar = 0;
    }
#line 1215
    templ = s;
#line 1216
    templlen = 0;
#line 1217
    templnsub = 0;
#line 1218
    if (*(display->d_xtable + curchar) == (char **)0) {
      {
#line 1220
      __cil_tmp15 = calloc((unsigned long )257, sizeof(char *));
#line 1220
      *(display->d_xtable + curchar) = (char **)__cil_tmp15;
      }
#line 1220
      if (*(display->d_xtable + curchar) == (char **)0) {
        {
#line 1222
        Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
#line 1223
        FreeTransTable();
        }
#line 1224
        return (- 1);
      }
    }
#line 1227
    ctable = *(display->d_xtable + curchar);
    {
#line 1228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1228
      if (! ((int )*s && (int )*s != 44)) {
#line 1228
        goto while_break___0;
      }
#line 1230
      if ((int )*s == 92) {
#line 1230
        if ((int )*(s + 1) == 92) {
#line 1231
          s ++;
        } else
#line 1230
        if ((int )*(s + 1) == 44) {
#line 1231
          s ++;
        } else
#line 1230
        if ((int )*(s + 1) == 37) {
#line 1231
          s ++;
        } else {
#line 1230
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1232
      if ((int )*s == 37) {
#line 1234
        templnsub ++;
#line 1235
        goto while_continue___0;
      }
#line 1237
      templlen ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1228
    s ++;
#line 1239
    __cil_tmp20 = s;
#line 1239
    s ++;
#line 1239
    if ((int )*__cil_tmp20 == 0) {
#line 1240
      goto while_break;
    }
    {
#line 1241
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1241
      if (! ((int )*s && (int )*s != 44)) {
#line 1241
        goto while_break___1;
      }
#line 1243
      __cil_tmp21 = s;
#line 1243
      s ++;
#line 1243
      c = (int )((unsigned char )*__cil_tmp21);
#line 1244
      if ((int )*(s - 1) == 92) {
#line 1244
        if ((int )*((s - 1) + 1) == 92) {
#line 1245
          __cil_tmp22 = s;
#line 1245
          s ++;
#line 1245
          c = (int )((unsigned char )*__cil_tmp22);
        } else
#line 1244
        if ((int )*((s - 1) + 1) == 44) {
#line 1245
          __cil_tmp22 = s;
#line 1245
          s ++;
#line 1245
          c = (int )((unsigned char )*__cil_tmp22);
        } else
#line 1244
        if ((int )*((s - 1) + 1) == 37) {
#line 1245
          __cil_tmp22 = s;
#line 1245
          s ++;
#line 1245
          c = (int )((unsigned char )*__cil_tmp22);
        } else {
#line 1244
          goto _L___860;
        }
      } else
      _L___860: /* CIL Label */ 
#line 1246
      if (c == 37) {
#line 1247
        c = 256;
      }
#line 1248
      if (*(ctable + c)) {
        {
#line 1249
        free((void *)*(ctable + c));
        }
      }
      {
#line 1250
      arg = s;
#line 1251
      l = copyarg(& s, (char *)0);
      }
#line 1252
      if (c != 256) {
#line 1253
        l = l * templnsub + templlen;
      }
      {
#line 1254
      __cil_tmp24 = malloc((unsigned long )(l + 1));
#line 1254
      *(ctable + c) = (char *)__cil_tmp24;
      }
#line 1254
      if (*(ctable + c) == (char *)0) {
        {
#line 1256
        Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
#line 1257
        FreeTransTable();
        }
#line 1258
        return (- 1);
      }
#line 1260
      sx = *(ctable + c);
#line 1261
      if (c == 256) {
#line 1261
        tmp = (char *)"%";
      } else {
#line 1261
        tmp = templ;
      }
#line 1261
      p = tmp;
      {
#line 1261
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1261
        if (! ((int )*p && (int )*p != 44)) {
#line 1261
          goto while_break___2;
        }
#line 1263
        if ((int )*p == 92) {
#line 1263
          if ((int )*(p + 1) == 92) {
#line 1264
            p ++;
          } else
#line 1263
          if ((int )*(p + 1) == 44) {
#line 1264
            p ++;
          } else
#line 1263
          if ((int )*(p + 1) == 37) {
#line 1264
            p ++;
          } else {
#line 1263
            goto _L___861;
          }
        } else
        _L___861: /* CIL Label */ 
#line 1265
        if ((int )*p == 37) {
          {
#line 1267
          s = arg;
#line 1268
          __cil_tmp27 = copyarg(& s, sx);
          }
#line 1268
          sx += __cil_tmp27;
#line 1269
          goto while_continue___2;
        }
#line 1271
        __cil_tmp28 = sx;
#line 1271
        sx ++;
#line 1271
        *__cil_tmp28 = *p;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1261
      p ++;
#line 1273
      *sx = (char )0;
      {
#line 1274
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1274
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1275
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1275
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1277
    if ((int )*s == 44) {
#line 1278
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1280
  return (0);
}
}
#line 1284 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
void FreeTransTable(void) 
{ 
  char ***p ;
  char **q ;
  int i ;
  int j ;
  int __cil_tmp5 ;
  char **__cil_tmp6 ;
  int __cil_tmp7 ;
  char ***__cil_tmp8 ;

  {
#line 1289
  p = display->d_xtable;
#line 1289
  if (p == (char ***)0) {
#line 1290
    return;
  }
#line 1291
  i = 0;
  {
#line 1291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1291
    if (! (i < 256)) {
#line 1291
      goto while_break;
    }
#line 1293
    if (*p == (char **)0) {
#line 1294
      goto while_continue;
    }
#line 1295
    q = *p;
#line 1296
    j = 0;
    {
#line 1296
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1296
      if (! (j < 257)) {
#line 1296
        goto while_break___0;
      }
#line 1297
      if (*q) {
        {
#line 1298
        free((void *)*q);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1296
    __cil_tmp6 = q;
#line 1296
    q ++;
    {
#line 1296
    __cil_tmp5 = j;
#line 1296
    j ++;
#line 1299
    free((void *)*p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1291
  __cil_tmp8 = p;
#line 1291
  p ++;
  {
#line 1291
  __cil_tmp7 = i;
#line 1291
  i ++;
#line 1301
  free((void *)display->d_xtable);
#line 1302
  display->d_xtable = (char ***)((void *)0);
  }
  return;
}
}
#line 1307 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static int copyarg(char **pp , char *s ) 
{ 
  int l ;
  char *p ;
  char *__cil_tmp6 ;

  {
#line 1313
  p = *pp;
#line 1313
  l = 0;
  {
#line 1313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1313
    if (! ((int )*p && (int )*p != 44)) {
#line 1313
      goto while_break;
    }
#line 1315
    if ((int )*p == 92) {
#line 1315
      if ((int )*(p + 1) == 92) {
#line 1316
        p ++;
      } else
#line 1315
      if ((int )*(p + 1) == 44) {
#line 1316
        p ++;
      } else
#line 1315
      if ((int )*(p + 1) == 37) {
#line 1316
        p ++;
      }
    }
#line 1317
    if (s) {
#line 1318
      __cil_tmp6 = s;
#line 1318
      s ++;
#line 1318
      *__cil_tmp6 = *p;
    }
#line 1319
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1313
  p ++;
#line 1321
  if ((int )*p == 44) {
#line 1322
    p ++;
  }
#line 1323
  *pp = p;
#line 1324
  return (l);
}
}
#line 1335 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static int e_tgetent(char *bp , char *name ) 
{ 
  int r ;

  {
  {
#line 1341
  xseteuid(real_uid);
#line 1342
  xsetegid(real_gid);
#line 1344
  r = tgetent(bp, name);
#line 1346
  xseteuid(eff_uid);
#line 1347
  xsetegid(eff_gid);
  }
#line 1349
  return (r);
}
}
#line 1360 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static char *findcap(char *cap , char **tepp , int n ) 
{ 
  char *tep ;
  char c ;
  char *p ;
  char *cp ;
  int mode ;
  int num ;
  int capl ;
  size_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1368
  num = 0;
#line 1370
  if (! extra_incap) {
#line 1371
    return ((char *)0);
  }
  {
#line 1372
  tep = *tepp;
#line 1373
  __cil_tmp11 = strlen((char const   *)cap);
#line 1373
  capl = (int )__cil_tmp11;
#line 1374
  cp = (char *)0;
#line 1375
  mode = 0;
#line 1376
  p = extra_incap;
  }
  {
#line 1376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1376
    if (! *p) {
#line 1376
      goto while_break;
    }
    {
#line 1378
    __cil_tmp12 = strncmp((char const   *)p, (char const   *)cap, (unsigned long )capl);
    }
#line 1378
    if (__cil_tmp12 == 0) {
#line 1380
      p += capl;
#line 1381
      c = *p;
#line 1382
      if ((int )c) {
#line 1382
        if ((int )c != 58) {
#line 1382
          if ((int )c != 64) {
#line 1383
            p ++;
          }
        }
      }
#line 1384
      if ((int )c == 0) {
#line 1385
        cp = tep;
      } else
#line 1384
      if ((int )c == 64) {
#line 1385
        cp = tep;
      } else
#line 1384
      if ((int )c == 61) {
#line 1385
        cp = tep;
      } else
#line 1384
      if ((int )c == 58) {
#line 1385
        cp = tep;
      } else
#line 1384
      if ((int )c == 35) {
#line 1385
        cp = tep;
      }
    }
    {
#line 1387
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1387
      if (! c) {
#line 1387
        goto while_break___0;
      }
#line 1389
      p ++;
#line 1390
      if (mode == 0) {
#line 1392
        if ((int )c == 58) {
#line 1393
          goto while_break___0;
        }
#line 1394
        if ((int )c == 94) {
#line 1395
          mode = 1;
        }
#line 1396
        if ((int )c == 92) {
#line 1397
          mode = 2;
        }
      } else
#line 1399
      if (mode == 1) {
#line 1401
        mode = 0;
#line 1402
        c = (char )((int )c & 31);
      } else
#line 1404
      if (mode == 2) {
#line 1406
        mode = 0;
        {
#line 1418
        if ((int )c == '9') {
#line 1418
          goto case_57;
        }
#line 1418
        if ((int )c == '8') {
#line 1418
          goto case_57;
        }
#line 1418
        if ((int )c == '7') {
#line 1418
          goto case_57;
        }
#line 1418
        if ((int )c == '6') {
#line 1418
          goto case_57;
        }
#line 1418
        if ((int )c == '5') {
#line 1418
          goto case_57;
        }
#line 1418
        if ((int )c == '4') {
#line 1418
          goto case_57;
        }
#line 1418
        if ((int )c == '3') {
#line 1418
          goto case_57;
        }
#line 1418
        if ((int )c == '2') {
#line 1418
          goto case_57;
        }
#line 1418
        if ((int )c == '1') {
#line 1418
          goto case_57;
        }
#line 1418
        if ((int )c == '0') {
#line 1418
          goto case_57;
        }
#line 1422
        if ((int )c == 'E') {
#line 1422
          goto case_69;
        }
#line 1425
        if ((int )c == 'n') {
#line 1425
          goto case_110;
        }
#line 1428
        if ((int )c == 'r') {
#line 1428
          goto case_114;
        }
#line 1431
        if ((int )c == 't') {
#line 1431
          goto case_116;
        }
#line 1434
        if ((int )c == 'b') {
#line 1434
          goto case_98;
        }
#line 1437
        if ((int )c == 'f') {
#line 1437
          goto case_102;
        }
#line 1407
        goto switch_break;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 1419
        mode = 3;
#line 1420
        num = 0;
#line 1421
        goto switch_break;
        case_69: /* CIL Label */ 
#line 1423
        c = (char )27;
#line 1424
        goto switch_break;
        case_110: /* CIL Label */ 
#line 1426
        c = (char )'\n';
#line 1427
        goto switch_break;
        case_114: /* CIL Label */ 
#line 1429
        c = (char )'\r';
#line 1430
        goto switch_break;
        case_116: /* CIL Label */ 
#line 1432
        c = (char )'\t';
#line 1433
        goto switch_break;
        case_98: /* CIL Label */ 
#line 1435
        c = (char )'\b';
#line 1436
        goto switch_break;
        case_102: /* CIL Label */ 
#line 1438
        c = (char )'\f';
#line 1439
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 1442
      if (mode > 2) {
#line 1444
        num = num * 8 + ((int )c - 48);
#line 1445
        __cil_tmp15 = mode;
#line 1445
        mode ++;
#line 1445
        if (__cil_tmp15 == 5) {
#line 1447
          c = (char )num;
#line 1448
          mode = 0;
        } else
#line 1445
        if ((int )*p < 48) {
#line 1447
          c = (char )num;
#line 1448
          mode = 0;
        } else
#line 1445
        if ((int )*p > 57) {
#line 1447
          c = (char )num;
#line 1448
          mode = 0;
        }
      }
#line 1451
      if (mode) {
#line 1452
        goto while_continue___0;
      }
#line 1454
      if (cp) {
#line 1454
        if (n != 1) {
#line 1456
          __cil_tmp16 = cp;
#line 1456
          cp ++;
#line 1456
          *__cil_tmp16 = c;
#line 1457
          __cil_tmp17 = n;
#line 1457
          n --;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1460
    if (cp) {
#line 1462
      __cil_tmp18 = cp;
#line 1462
      cp ++;
#line 1462
      *__cil_tmp18 = (char )0;
#line 1463
      *tepp = cp;
      {
#line 1464
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1464
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1465
      return (tep);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1468
  return ((char *)0);
}
}
#line 1472 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static char *e_tgetstr(char *cap , char **tepp ) 
{ 
  char *tep ;
  char *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 1477
  tep = findcap(cap, tepp, 0);
  }
#line 1477
  if (tep) {
#line 1478
    if ((int )*tep == 64) {
#line 1478
      tmp = (char *)0;
    } else {
#line 1478
      tmp = tep;
    }
#line 1478
    return (tmp);
  }
  {
#line 1479
  __cil_tmp6 = tgetstr(cap, tepp);
  }
#line 1479
  return (__cil_tmp6);
}
}
#line 1483 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static int e_tgetflag(char *cap ) 
{ 
  char buf[2] ;
  char *bufp ;
  char *tep ;
  int tmp ;
  int __cil_tmp7 ;

  {
  {
#line 1488
  bufp = (char *)buf;
#line 1489
  tep = findcap(cap, & bufp, 2);
  }
#line 1489
  if (tep) {
#line 1490
    if ((int )*tep == 64) {
#line 1490
      tmp = 0;
    } else {
#line 1490
      tmp = 1;
    }
#line 1490
    return (tmp);
  }
  {
#line 1491
  __cil_tmp7 = tgetflag(cap);
  }
#line 1491
  return (__cil_tmp7 > 0);
}
}
#line 1495 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/termcap.c"
static int e_tgetnum(char *cap ) 
{ 
  char buf[20] ;
  char *bufp ;
  char *tep ;
  char c ;
  int res ;
  int base ;
  int __cil_tmp10 ;

  {
  {
#line 1500
  base = 10;
#line 1502
  bufp = (char *)buf;
#line 1503
  tep = findcap(cap, & bufp, 20);
  }
#line 1503
  if (tep) {
#line 1505
    c = *tep;
#line 1506
    if ((int )c == 64) {
#line 1507
      return (- 1);
    }
#line 1508
    if ((int )c == 48) {
#line 1509
      base = 8;
    }
#line 1510
    res = 0;
    {
#line 1511
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1511
      if (! ((int )c >= 48 && (int )c <= 57)) {
#line 1511
        goto while_break;
      }
#line 1512
      res = res * base + ((int )c - 48);
    }
    while_break: /* CIL Label */ ;
    }
#line 1513
    return (res);
  }
  {
#line 1515
  __cil_tmp10 = tgetnum(cap);
  }
#line 1515
  return (__cil_tmp10);
}
}
#line 137 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void exit_with_usage(char *myname , char *message , char *arg ) ;
#line 146
void ZmodemPage(void) ;
#line 383
int AddXChar(char *buf , int ch ) ;
#line 48 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
unsigned char *blank ;
#line 56
static void PadStr(char *str , int n , int x , int y ) ;
#line 61 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
void exit_with_usage(char *myname , char *message , char *arg ) 
{ 


  {
  {
#line 63
  printf((char const   *)((char *)"Use: %s [-opts] [cmd [args]]\n"), myname);
#line 64
  printf((char const   *)((char *)" or: %s -r [host.tty]\n\nOptions:\n"), myname);
#line 69
  printf((char const   *)((char *)"-a            Force all capabilities into each window\'s termcap.\n"));
#line 70
  printf((char const   *)((char *)"-A -[r|R]     Adapt all windows to the new display width & height.\n"));
#line 71
  printf((char const   *)((char *)"-c file       Read configuration file instead of \'.screenrc\'.\n"));
#line 73
  printf((char const   *)((char *)"-d (-r)       Detach the elsewhere running screen (and reattach here).\n"));
#line 74
  printf((char const   *)((char *)"-dmS name     Start as daemon: Screen session in detached mode.\n"));
#line 75
  printf((char const   *)((char *)"-D (-r)       Detach and logout remote (and reattach here).\n"));
#line 76
  printf((char const   *)((char *)"-D -RR        Do whatever is needed to get a screen session.\n"));
#line 78
  printf((char const   *)((char *)"-e xy         Change command characters.\n"));
#line 79
  printf((char const   *)((char *)"-f            Flow control on, -fn = off, -fa = auto.\n"));
#line 80
  printf((char const   *)((char *)"-h lines      Set the size of the scrollback history buffer.\n"));
#line 81
  printf((char const   *)((char *)"-i            Interrupt output sooner when flow control is on.\n"));
#line 83
  printf((char const   *)((char *)"-l            Login mode on (update %s), -ln = off.\n"),
         (char *)"/var/run/utmp");
#line 85
  printf((char const   *)((char *)"-ls [match]   or\n"));
#line 86
  printf((char const   *)((char *)"-list         Do nothing, just list our SockDir [on possible matches].\n"));
#line 87
  printf((char const   *)((char *)"-L            Turn on output logging.\n"));
#line 88
  printf((char const   *)((char *)"-Logfile file Set logfile name.\n"));
#line 89
  printf((char const   *)((char *)"-m            ignore $STY variable, do create a new screen session.\n"));
#line 90
  printf((char const   *)((char *)"-O            Choose optimal output rather than exact vt100 emulation.\n"));
#line 91
  printf((char const   *)((char *)"-p window     Preselect the named window if it exists.\n"));
#line 92
  printf((char const   *)((char *)"-q            Quiet startup. Exits with non-zero return code if unsuccessful.\n"));
#line 93
  printf((char const   *)((char *)"-Q            Commands will send the response to the stdout of the querying process.\n"));
#line 94
  printf((char const   *)((char *)"-r [session]  Reattach to a detached screen process.\n"));
#line 95
  printf((char const   *)((char *)"-R            Reattach if possible, otherwise start a new session.\n"));
#line 96
  printf((char const   *)((char *)"-s shell      Shell to execute rather than $SHELL.\n"));
#line 97
  printf((char const   *)((char *)"-S sockname   Name this session <pid>.sockname instead of <pid>.<tty>.<host>.\n"));
#line 98
  printf((char const   *)((char *)"-t title      Set title. (window\'s name).\n"));
#line 99
  printf((char const   *)((char *)"-T term       Use term as $TERM for windows, rather than \"screen\".\n"));
#line 101
  printf((char const   *)((char *)"-U            Tell screen to use UTF-8 encoding.\n"));
#line 103
  printf((char const   *)((char *)"-v            Print \"Screen version %s\".\n"),
         (char *)version);
#line 104
  printf((char const   *)((char *)"-wipe [match] Do nothing, just clean up SockDir [on possible matches].\n"));
#line 106
  printf((char const   *)((char *)"-x            Attach to a not detached screen. (Multi display mode).\n"));
#line 108
  printf((char const   *)((char *)"-X            Execute <cmd> as a screen command in the specified session.\n"));
  }
#line 110
  if (message) {
#line 110
    if ((int )*message) {
      {
#line 111
      printf((char const   *)((char *)"\nError: "));
#line 112
      printf((char const   *)message, arg);
#line 113
      printf((char const   *)((char *)"\n"));
      }
    }
  }
  {
#line 115
  exit(1);
  }
}
}
#line 123
static void HelpProcess(char **ppbuf , int *plen ) ;
#line 124
static void HelpAbort(void) ;
#line 125
static void HelpRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 126
static void add_key_to_buf(char *buf , int key ) ;
#line 127
static void AddAction(struct action *act , int x , int y ) ;
#line 128
static int helppage(void) ;
#line 143 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static struct LayFuncs HelpLf  = 
#line 143
     {HelpProcess, HelpAbort, HelpRedisplayLine, DefClearLine, DefRewrite, DefResize,
    DefRestore, (void (*)(void * ))0};
#line 156 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
void display_help(char *class , struct action *ktabp ) 
{ 
  int i ;
  int n ;
  int key ;
  int mcom ;
  int mkey ;
  int l ;
  int used[190] ;
  struct helpdata *helpdata ;
  int __cil_tmp11 ;
  int tmp ;
  int tmp___862 ;
  size_t __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 160
  if (flayer->l_height < 6) {
    {
#line 161
    LMsg(0, (char const   *)((char *)"Window height too small for help page"));
    }
#line 162
    return;
  }
  {
#line 164
  __cil_tmp11 = InitOverlayPage((int )sizeof(*helpdata), & HelpLf, 0);
  }
#line 164
  if (__cil_tmp11) {
#line 165
    return;
  }
#line 167
  helpdata = (struct helpdata *)flayer->l_data;
#line 168
  helpdata->class = class;
#line 169
  helpdata->ktabp = ktabp;
#line 170
  helpdata->command_bindings = 0;
#line 170
  helpdata->num_names = helpdata->command_bindings;
#line 171
  helpdata->command_search = 0;
#line 172
  n = 0;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! (n <= 189)) {
#line 172
      goto while_break;
    }
#line 173
    used[n] = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  n ++;
#line 174
  mcom = 0;
#line 175
  mkey = 0;
#line 176
  key = 0;
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 176
    if (! (key < 338)) {
#line 176
      goto while_break___0;
    }
#line 177
    n = (ktabp + key)->nr;
#line 178
    if (n == -1) {
#line 179
      goto while_continue___0;
    }
#line 180
    if ((ktabp + key)->args == (char **)noargs) {
#line 181
      if (key <= 32 || key == 127) {
#line 181
        tmp___862 = 3;
      } else {
#line 181
        if (key > 127) {
#line 181
          tmp = 5;
        } else {
#line 181
          tmp = 2;
        }
#line 181
        tmp___862 = tmp;
      }
#line 181
      used[n] += tmp___862;
    } else {
#line 184
      (helpdata->command_bindings) ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 176
  key ++;
#line 186
  i = 0;
#line 186
  n = i;
  {
#line 186
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 186
    if (! (n <= 189)) {
#line 186
      goto while_break___1;
    }
#line 187
    if (used[n]) {
      {
#line 188
      __cil_tmp17 = strlen((char const   *)comms[n].name);
#line 188
      l = (int )__cil_tmp17;
      }
#line 189
      if (l > mcom) {
#line 190
        mcom = l;
      }
#line 191
      if (used[n] > mkey) {
#line 192
        mkey = used[n];
      }
#line 193
      __cil_tmp18 = i;
#line 193
      i ++;
#line 193
      helpdata->nact[__cil_tmp18] = n;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 186
  n ++;
  {
#line 196
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 196
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 197
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 197
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 198
  helpdata->num_names = i;
#line 200
  if (mkey > 256) {
#line 201
    mkey = 256;
  }
#line 202
  helpdata->numcols = flayer->l_width / ((mcom + mkey) + 1);
#line 203
  if (helpdata->numcols == 0) {
    {
#line 204
    HelpAbort();
#line 205
    LMsg(0, (char const   *)((char *)"Width too small"));
    }
#line 206
    return;
  }
#line 209
  helpdata->inter = (flayer->l_width - (mcom + mkey) * helpdata->numcols) / (helpdata->numcols + 1);
#line 210
  if (helpdata->inter <= 0) {
#line 211
    helpdata->inter = 1;
  }
  {
#line 212
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 212
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 213
  helpdata->mcom = mcom;
#line 214
  helpdata->mkey = mkey;
#line 215
  helpdata->numrows = ((helpdata->num_names + helpdata->numcols) - 1) / helpdata->numcols;
  {
#line 216
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 216
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 217
  helpdata->numskip = (flayer->l_height - 5) - (2 + helpdata->numrows);
  {
#line 219
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 219
    if (! (helpdata->numskip < 0)) {
#line 219
      goto while_break___6;
    }
#line 220
    helpdata->numskip += flayer->l_height - 5;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 221
  helpdata->numskip %= flayer->l_height - 5;
  {
#line 222
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 222
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 224
  if (helpdata->numskip > flayer->l_height / 3) {
#line 225
    helpdata->numskip = 1;
  } else
#line 224
  if (helpdata->numskip > helpdata->command_bindings) {
#line 225
    helpdata->numskip = 1;
  }
  {
#line 226
  helpdata->maxrow = ((2 + helpdata->numrows) + helpdata->numskip) + helpdata->command_bindings;
#line 227
  helpdata->grow = 0;
#line 229
  helpdata->numpages = ((helpdata->maxrow + flayer->l_height) - 6) / (flayer->l_height - 5);
#line 230
  flayer->l_x = 0;
#line 231
  flayer->l_y = flayer->l_height - 1;
#line 232
  helppage();
  }
  return;
}
}
#line 235 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void HelpProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  int __cil_tmp4 ;

  {
#line 236
  done = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (! done && *plen > 0)) {
#line 238
      goto while_break;
    }
    {
#line 240
    if ((int )*(*ppbuf) == ' ') {
#line 240
      goto case_32;
    }
#line 245
    if ((int )*(*ppbuf) == '\n') {
#line 245
      goto case_10;
    }
#line 245
    if ((int )*(*ppbuf) == '\r') {
#line 245
      goto case_10;
    }
#line 248
    goto switch_default;
    case_32: /* CIL Label */ 
    {
#line 241
    __cil_tmp4 = helppage();
    }
#line 241
    if (__cil_tmp4 == 0) {
#line 242
      goto switch_break;
    }
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 246
    done = 1;
#line 247
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 249
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 251
    (*ppbuf) ++;
#line 252
    (*plen) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  if (done) {
    {
#line 255
    HelpAbort();
    }
  }
  return;
}
}
#line 258 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void HelpAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    oldlay = flayer;
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 259
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 259
    flayer = flayer->l_next;
#line 259
    oldcvlist = flayer->l_cvlist;
    {
#line 259
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 259
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 259
    flayer->l_cvlist = oldlay->l_cvlist;
#line 259
    cv = flayer->l_cvlist;
    {
#line 259
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 259
      if (! cv) {
#line 259
        goto while_break___2;
      }
#line 259
      cv->c_layer = flayer;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 259
    cv = cv->c_lnext;
#line 259
    LRefreshAll(flayer, 0);
#line 259
    flayer = oldlay;
#line 259
    cv = flayer->l_cvlist;
    }
    {
#line 259
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 259
      if (! cv) {
#line 259
        goto while_break___3;
      }
#line 259
      cv->c_layer = flayer;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 259
    cv = cv->c_lnext;
#line 259
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 259
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 260
  ExitOverlayPage();
  }
  return;
}
}
#line 263 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static int helppage(void) 
{ 
  struct helpdata *helpdata ;
  int col ;
  int crow ;
  int n ;
  int key ;
  int x ;
  char buf[256] ;
  char Esc_buf[5] ;
  char cbuf[256] ;
  struct action *ktabp ;
  size_t __cil_tmp12 ;
  int __cil_tmp16 ;
  char *tmp ;

  {
#line 269
  helpdata = (struct helpdata *)flayer->l_data;
#line 271
  ktabp = helpdata->ktabp;
#line 272
  if (helpdata->grow >= helpdata->maxrow) {
#line 273
    return (- 1);
  }
  {
#line 274
  helpdata->refgrow = helpdata->grow;
#line 275
  helpdata->refcommand_search = helpdata->command_search;
#line 278
  LClearAll(flayer, 0);
#line 280
  sprintf((char *)cbuf, (char const   *)((char *)"Screen key bindings, page %d of %d."),
          helpdata->grow / (flayer->l_height - 5) + 1, helpdata->numpages);
#line 281
  centerline((char *)cbuf, 0);
#line 282
  crow = 2;
#line 284
  *((char *)Esc_buf) = (char )'\000';
#line 285
  *((char *)buf) = (char )'\000';
  }
#line 287
  if (flayer->l_cvlist) {
#line 287
    if ((flayer->l_cvlist)->c_display) {
      {
#line 288
      add_key_to_buf((char *)buf, (((flayer->l_cvlist)->c_display)->d_user)->u_MetaEsc);
#line 289
      add_key_to_buf((char *)Esc_buf, (((flayer->l_cvlist)->c_display)->d_user)->u_Esc);
      }
    } else {
      {
      {
#line 292
      strcpy((char *)Esc_buf, (char const   *)((char *)"??"));
      }
      {
#line 293
      strcpy((char *)buf, (char const   *)((char *)"??"));
      }
      }
    }
  } else {
    {
    {
#line 292
    strcpy((char *)Esc_buf, (char const   *)((char *)"??"));
    }
    {
#line 293
    strcpy((char *)buf, (char const   *)((char *)"??"));
    }
    }
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (crow < flayer->l_height - 3)) {
#line 296
      goto while_break;
    }
#line 297
    if (helpdata->grow < 1) {
#line 298
      if (ktabp == (struct action *)ktab) {
        {
#line 299
        sprintf((char *)cbuf, (char const   *)((char *)"Command key:  %s   Literal %s:  %s"),
                (char *)Esc_buf, (char *)Esc_buf, (char *)buf);
        }
      } else {
        {
#line 301
        sprintf((char *)cbuf, (char const   *)((char *)"Command class: \'%.80s\'"),
                helpdata->class);
        }
      }
      {
#line 303
      centerline((char *)cbuf, crow);
#line 304
      (helpdata->grow) ++;
      }
    } else
#line 307
    if (helpdata->grow >= 2) {
#line 307
      if (helpdata->grow - 2 < helpdata->numrows) {
#line 308
        x = 0;
#line 309
        col = 0;
        {
#line 309
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 309
          if (! (col < helpdata->numcols && n < helpdata->num_names)) {
#line 309
            goto while_break___0;
          }
#line 310
          x += helpdata->inter - ! col;
#line 311
          n = helpdata->nact[n];
#line 312
          buf[0] = (char )'\000';
#line 313
          key = 0;
          {
#line 313
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 313
            if (! (key < 338)) {
#line 313
              goto while_break___1;
            }
            {
#line 314
            __cil_tmp12 = strlen((char const   *)((char *)buf));
            }
#line 314
            if ((ktabp + key)->nr == n) {
#line 314
              if ((ktabp + key)->args == (char **)noargs) {
#line 314
                if (__cil_tmp12 < sizeof(buf) - 7UL) {
                  {
#line 315
                  strcat((char *)buf, (char const   *)((char *)" "));
#line 316
                  add_key_to_buf((char *)buf, key);
                  }
                }
              }
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 313
          key ++;
#line 319
          PadStr(comms[n].name, helpdata->mcom, x, crow);
#line 320
          x += helpdata->mcom;
#line 321
          PadStr((char *)buf, helpdata->mkey, x, crow);
#line 322
          x += helpdata->mkey;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 309
        col ++;
#line 324
        (helpdata->grow) ++;
      } else {
#line 307
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 327
    if ((helpdata->grow - 2) - helpdata->numrows >= helpdata->numskip) {
#line 327
      if (((helpdata->grow - 2) - helpdata->numrows) - helpdata->numskip < helpdata->command_bindings) {
        {
#line 329
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 329
          if (! (n == -1 || (ktabp + helpdata->command_search)->args == (char **)noargs)) {
#line 329
            goto while_break___2;
          }
#line 330
          (helpdata->command_search) ++;
#line 330
          if (helpdata->command_search >= 338) {
#line 331
            return (- 1);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 334
        buf[0] = (char )'\000';
#line 335
        add_key_to_buf((char *)buf, helpdata->command_search);
#line 336
        PadStr((char *)buf, 5, 0, crow);
#line 337
        __cil_tmp16 = helpdata->command_search;
#line 337
        (helpdata->command_search) ++;
#line 337
        AddAction(& *(ktabp + __cil_tmp16), 5, crow);
#line 338
        (helpdata->grow) ++;
        }
      } else {
#line 342
        (helpdata->grow) ++;
      }
    } else {
#line 342
      (helpdata->grow) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  crow ++;
#line 344
  if (helpdata->grow < helpdata->maxrow) {
#line 344
    tmp = (char *)"for next page;";
  } else {
#line 344
    tmp = (char *)"or";
  }
  {
#line 344
  sprintf((char *)cbuf, (char const   *)((char *)"[Press Space %s Return to end.]"),
          tmp);
#line 345
  centerline((char *)cbuf, flayer->l_height - 2);
#line 346
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 347
  return (0);
}
}
#line 350 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void AddAction(struct action *act , int x , int y ) 
{ 
  char buf[256] ;
  int del ;
  int l ;
  int fr ;
  char *bp ;
  char *cp ;
  char **pp ;
  int *lp ;
  int ll ;
  struct mchar mchar_dol ;
  size_t __cil_tmp14 ;
  struct mchar *tmp ;
  int __cil_tmp16 ;
  int *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp25 ;
  size_t __cil_tmp26 ;
  size_t __cil_tmp27 ;
  struct mchar *tmp___863 ;
  int __cil_tmp30 ;

  {
#line 357
  mchar_dol = mchar_blank;
#line 358
  mchar_dol.image = (unsigned char )'$';
#line 360
  fr = (flayer->l_width - 1) - x;
#line 361
  if (fr <= 0) {
#line 362
    return;
  }
  {
#line 363
  __cil_tmp14 = strlen((char const   *)comms[act->nr].name);
#line 363
  l = (int )__cil_tmp14;
  }
#line 365
  if (l + 1 > fr) {
#line 366
    l = fr - 1;
  }
  {
#line 367
  PadStr(comms[act->nr].name, l, x, y);
#line 368
  x += l;
#line 369
  fr -= l + 1;
  }
#line 370
  if (fr) {
#line 370
    tmp = & mchar_blank;
  } else {
#line 370
    tmp = & mchar_dol;
  }
  {
#line 370
  __cil_tmp16 = x;
#line 370
  x ++;
#line 370
  LPutChar(flayer, tmp, __cil_tmp16, y);
#line 372
  pp = act->args;
#line 373
  lp = act->argl;
  }
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (pp && cp != (char *)((void *)0))) {
#line 374
      goto while_break;
    }
    {
#line 375
    del = 0;
#line 376
    bp = (char *)buf;
#line 377
    __cil_tmp17 = lp;
#line 377
    lp ++;
#line 377
    ll = *__cil_tmp17;
#line 378
    __cil_tmp18 = index((char const   *)cp, ' ');
    }
#line 378
    if (! ll) {
      _L: /* CIL Label */ 
      {
#line 379
      __cil_tmp19 = index((char const   *)cp, '\'');
      }
#line 379
      if (__cil_tmp19 != (char *)((void *)0)) {
#line 380
        del = '\"';
#line 380
        __cil_tmp20 = bp;
#line 380
        bp ++;
#line 380
        *__cil_tmp20 = (char )del;
      } else {
#line 382
        del = '\'';
#line 382
        __cil_tmp21 = bp;
#line 382
        bp ++;
#line 382
        *__cil_tmp21 = (char )del;
      }
    } else
#line 378
    if (__cil_tmp18 != (char *)((void *)0)) {
#line 378
      goto _L;
    }
    {
#line 385
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 385
      if (! (__cil_tmp22 && bp < (char *)buf + 250)) {
#line 385
        goto while_break___0;
      }
      {
#line 386
      __cil_tmp23 = cp;
#line 386
      cp ++;
#line 386
      __cil_tmp24 = AddXChar(bp, (int )*((unsigned char *)__cil_tmp23));
      }
#line 386
      bp += __cil_tmp24;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 387
    if (del) {
#line 388
      __cil_tmp25 = bp;
#line 388
      bp ++;
#line 388
      *__cil_tmp25 = (char )del;
    }
#line 389
    *bp = (char )0;
#line 390
    fr -= (bp - (char *)buf) + 1L;
#line 390
    if (fr < 0) {
#line 391
      fr += bp - (char *)buf;
#line 392
      if (fr > 0) {
        {
#line 393
        PadStr((char *)buf, fr, x, y);
        }
      }
#line 394
      if (fr == 0) {
        {
#line 395
        LPutChar(flayer, & mchar_dol, x, y);
        }
      }
#line 396
      return;
    }
    {
#line 399
    __cil_tmp26 = strlen((char const   *)((char *)buf));
#line 399
    PadStr((char *)buf, (int )__cil_tmp26, x, y);
#line 400
    __cil_tmp27 = strlen((char const   *)((char *)buf));
    }
#line 400
    x += __cil_tmp27;
#line 401
    pp ++;
#line 402
    if (*pp) {
#line 403
      if (fr) {
#line 403
        tmp___863 = & mchar_blank;
      } else {
#line 403
        tmp___863 = & mchar_dol;
      }
      {
#line 403
      __cil_tmp30 = x;
#line 403
      x ++;
#line 403
      LPutChar(flayer, tmp___863, __cil_tmp30, y);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 407 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void add_key_to_buf(char *buf , int key ) 
{ 
  size_t __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 408
  __cil_tmp3 = strlen((char const   *)buf);
  }
#line 408
  buf += __cil_tmp3;
#line 409
  if (key < 0) {
    {
#line 410
    strcpy(buf, (char const   *)((char *)"unset"));
    }
  } else
#line 411
  if (key == 32) {
    {
#line 412
    strcpy(buf, (char const   *)((char *)"sp"));
    }
  } else
#line 414
  if (key >= 256) {
#line 415
    key = (key - 256) + 106;
#line 416
    *(buf + 0) = (char )':';
#line 417
    *(buf + 1) = *(term[key].tcname + 0);
#line 418
    *(buf + 2) = *(term[key].tcname + 1);
#line 419
    *(buf + 3) = (char )':';
#line 420
    *(buf + 4) = (char )0;
  } else {
    {
#line 424
    __cil_tmp4 = AddXChar(buf, key);
#line 424
    *(buf + __cil_tmp4) = (char )0;
    }
  }
  return;
}
}
#line 427 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void HelpRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  struct helpdata *helpdata ;

  {
#line 428
  if (y < 0) {
    {
#line 431
    helpdata = (struct helpdata *)flayer->l_data;
#line 432
    helpdata->grow = helpdata->refgrow;
#line 433
    helpdata->command_search = helpdata->refcommand_search;
#line 434
    helppage();
    }
#line 435
    return;
  }
#line 437
  if (y != 0) {
#line 437
    if (y != flayer->l_height - 1) {
#line 438
      return;
    }
  }
#line 439
  if (! isblank) {
    {
#line 440
    LClearArea(flayer, xs, y, xe, y, 0, 0);
    }
  }
  return;
}
}
#line 446
static void CopyrightProcess(char **ppbuf , int *plen ) ;
#line 447
static void CopyrightRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 448
static void CopyrightAbort(void) ;
#line 449
static void copypage(void) ;
#line 456 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static struct LayFuncs CopyrightLf  = 
#line 456
     {CopyrightProcess, CopyrightAbort, CopyrightRedisplayLine, DefClearLine, DefRewrite,
    DefResize, DefRestore, (void (*)(void * ))0};
#line 467 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static char const   cpmsg[]  =    "\nGNU Screen version %v\n\nCopyright (c) 2018-2019 Alexander Naumov, Amadeusz Slawinski\nCopyright (c) 2015-2017 Juergen Weigert, Alexander Naumov, Amadeusz Slawinski\nCopyright (c) 2010-2014 Juergen Weigert, Sadrul Habib Chowdhury\nCopyright (c) 2008-2009 Juergen Weigert, Michael Schroeder, Micah Cowan, Sadrul Habib Chowdhury\nCopyright (c) 1993-2007 Juergen Weigert, Michael Schroeder\nCopyright (c) 1987 Oliver Laumann\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program (see the file COPYING); if not, see http://www.gnu.org/licenses/, or contact Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA.\n\nSend bugreports, fixes, enhancements, t-shirts, money, beer & pizza to screen-devel@gnu.org\n\n\nCapabilities:\n+copy +remote-detach +power-detach +multi-attach +multi-user +font +color-16 +utf8 +rxvt -builtin-telnet ";
#line 563 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void CopyrightProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  struct copydata *copydata ;

  {
#line 564
  done = 0;
#line 567
  copydata = (struct copydata *)flayer->l_data;
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 568
    if (! (! done && *plen > 0)) {
#line 568
      goto while_break;
    }
    {
#line 570
    if ((int )*(*ppbuf) == ' ') {
#line 570
      goto case_32;
    }
#line 577
    if ((int )*(*ppbuf) == '\n') {
#line 577
      goto case_10;
    }
#line 577
    if ((int )*(*ppbuf) == '\r') {
#line 577
      goto case_10;
    }
#line 581
    goto switch_default;
    case_32: /* CIL Label */ 
#line 571
    if (*(copydata->cps)) {
      {
#line 572
      copypage();
      }
#line 573
      goto switch_break;
    }
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 578
    CopyrightAbort();
    }
#line 579
    done = 1;
#line 580
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 582
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 584
    (*ppbuf) ++;
#line 585
    (*plen) --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 589 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void CopyrightAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    oldlay = flayer;
    {
#line 590
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 590
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 590
    flayer = flayer->l_next;
#line 590
    oldcvlist = flayer->l_cvlist;
    {
#line 590
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 590
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 590
    flayer->l_cvlist = oldlay->l_cvlist;
#line 590
    cv = flayer->l_cvlist;
    {
#line 590
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 590
      if (! cv) {
#line 590
        goto while_break___2;
      }
#line 590
      cv->c_layer = flayer;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 590
    cv = cv->c_lnext;
#line 590
    LRefreshAll(flayer, 0);
#line 590
    flayer = oldlay;
#line 590
    cv = flayer->l_cvlist;
    }
    {
#line 590
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 590
      if (! cv) {
#line 590
        goto while_break___3;
      }
#line 590
      cv->c_layer = flayer;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 590
    cv = cv->c_lnext;
#line 590
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 590
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 591
  ExitOverlayPage();
  }
  return;
}
}
#line 594 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
void display_copyright(void) 
{ 
  struct copydata *copydata ;
  int __cil_tmp2 ;

  {
#line 597
  if (flayer->l_width < 10) {
    {
    {
#line 598
    LMsg(0, (char const   *)((char *)"Window size too small for copyright page"));
    }
    }
#line 599
    return;
  } else
#line 597
  if (flayer->l_height < 5) {
    {
    {
#line 598
    LMsg(0, (char const   *)((char *)"Window size too small for copyright page"));
    }
    }
#line 599
    return;
  }
  {
#line 601
  __cil_tmp2 = InitOverlayPage((int )sizeof(*copydata), & CopyrightLf, 0);
  }
#line 601
  if (__cil_tmp2) {
#line 602
    return;
  }
  {
#line 603
  copydata = (struct copydata *)flayer->l_data;
#line 604
  copydata->cps = (char *)((char const   *)cpmsg);
#line 605
  copydata->savedcps = (char *)0;
#line 606
  flayer->l_x = 0;
#line 607
  flayer->l_y = flayer->l_height - 1;
#line 608
  copypage();
  }
  return;
}
}
#line 611 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void copypage(void) 
{ 
  register char *cps ;
  char *ws ;
  int x ;
  int y ;
  int l ;
  char cbuf[80] ;
  struct copydata *copydata ;
  int __cil_tmp9 ;
  char *tmp ;

  {
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 619
  copydata = (struct copydata *)flayer->l_data;
#line 621
  LClearAll(flayer, 0);
#line 622
  y = 0;
#line 622
  x = y;
#line 623
  cps = copydata->cps;
#line 624
  copydata->refcps = cps;
#line 625
  copydata->refsavedcps = copydata->savedcps;
  }
  {
#line 626
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 626
    if (! ((int )*cps && y < flayer->l_height - 3)) {
#line 626
      goto while_break___0;
    }
#line 627
    ws = cps;
    {
#line 628
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 628
      if (! ((int )*cps == 32)) {
#line 628
        goto while_break___1;
      }
#line 629
      cps ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 630
    __cil_tmp9 = strncmp((char const   *)cps, (char const   *)((char *)"%v"), (unsigned long )2);
    }
#line 630
    if (__cil_tmp9 == 0) {
#line 631
      copydata->savedcps = cps + 2;
#line 632
      cps = (char *)version;
#line 633
      goto while_continue___0;
    }
    {
#line 635
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 635
      if (! (((int )*cps && (int )*cps != 32) && (int )*cps != 10)) {
#line 635
        goto while_break___2;
      }
#line 636
      cps ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 638
    l = (int )(cps - ws);
#line 639
    cps = ws;
#line 640
    if (l > flayer->l_width - 1) {
#line 641
      l = flayer->l_width - 1;
    }
#line 643
    if (x) {
#line 643
      if (x + l >= flayer->l_width - 2) {
#line 644
        x = 0;
#line 645
        y ++;
#line 646
        goto while_continue___0;
      }
    }
#line 649
    if (x) {
      {
#line 650
      LPutChar(flayer, & mchar_blank, x, y);
#line 651
      x ++;
      }
    }
#line 654
    if (l) {
      {
#line 655
      LPutStr(flayer, ws, l, & mchar_blank, x, y);
      }
    }
#line 656
    x += l;
#line 657
    cps += l;
#line 658
    if ((int )*cps == 0) {
#line 658
      if (copydata->savedcps) {
#line 659
        cps = copydata->savedcps;
#line 660
        copydata->savedcps = (char *)0;
      }
    }
#line 663
    if ((int )*cps == 10) {
#line 664
      x = 0;
#line 665
      y ++;
    }
#line 668
    if ((int )*cps == 32) {
#line 669
      cps ++;
    } else
#line 668
    if ((int )*cps == 10) {
#line 669
      cps ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 671
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 671
    if (! ((int )*cps == 10)) {
#line 671
      goto while_break___3;
    }
#line 672
    cps ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 673
  if ((int )*cps) {
#line 673
    tmp = (char *)"for next page;";
  } else {
#line 673
    tmp = (char *)"or";
  }
  {
#line 673
  sprintf((char *)cbuf, (char const   *)((char *)"[Press Space %s Return to end.]"),
          tmp);
#line 674
  centerline((char *)cbuf, flayer->l_height - 2);
#line 675
  copydata->cps = cps;
#line 676
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
  return;
}
}
#line 679 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void CopyrightRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  struct copydata *copydata ;

  {
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 681
  if (y < 0) {
    {
#line 684
    copydata = (struct copydata *)flayer->l_data;
#line 685
    copydata->cps = copydata->refcps;
#line 686
    copydata->savedcps = copydata->refsavedcps;
#line 687
    copypage();
    }
#line 688
    return;
  }
#line 690
  if (y != 0) {
#line 690
    if (y != flayer->l_height - 1) {
#line 691
      return;
    }
  }
#line 692
  if (isblank) {
#line 693
    return;
  }
  {
#line 694
  LClearArea(flayer, xs, y, xe, y, 0, 0);
  }
  return;
}
}
#line 706
static void BindkeyProcess(char **ppbuf , int *plen ) ;
#line 707
static void BindkeyAbort(void) ;
#line 708
static void BindkeyRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 709
static void bindkeypage(void) ;
#line 720 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static struct LayFuncs BindkeyLf  = 
#line 720
     {BindkeyProcess, BindkeyAbort, BindkeyRedisplayLine, DefClearLine, DefRewrite,
    DefResize, DefRestore, (void (*)(void * ))0};
#line 732 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
void display_bindkey(char *title , struct action *tab ) 
{ 
  struct bindkeydata *bindkeydata ;
  int i ;
  int n ;
  int __cil_tmp6 ;

  {
#line 736
  if (flayer->l_height < 6) {
    {
#line 737
    LMsg(0, (char const   *)((char *)"Window height too small for bindkey page"));
    }
#line 738
    return;
  }
  {
#line 740
  __cil_tmp6 = InitOverlayPage((int )sizeof(*bindkeydata), & BindkeyLf, 0);
  }
#line 740
  if (__cil_tmp6) {
#line 741
    return;
  }
#line 743
  bindkeydata = (struct bindkeydata *)flayer->l_data;
#line 744
  bindkeydata->title = title;
#line 745
  bindkeydata->tab = tab;
#line 747
  n = 0;
#line 748
  i = 0;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    if (! (i < 104 + kmap_extn)) {
#line 748
      goto while_break;
    }
#line 749
    if ((tab + i)->nr != -1) {
#line 750
      n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  i ++;
#line 752
  bindkeydata->pos = 0;
#line 753
  bindkeydata->page = 1;
#line 754
  bindkeydata->pages = ((n + flayer->l_height) - 6) / (flayer->l_height - 5);
#line 755
  if (bindkeydata->pages == 0) {
#line 756
    bindkeydata->pages = 1;
  }
  {
#line 757
  flayer->l_x = 0;
#line 758
  flayer->l_y = flayer->l_height - 1;
#line 759
  bindkeypage();
  }
  return;
}
}
#line 762 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void BindkeyAbort(void) 
{ 
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    oldlay = flayer;
    {
#line 763
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 763
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 763
    flayer = flayer->l_next;
#line 763
    oldcvlist = flayer->l_cvlist;
    {
#line 763
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 763
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 763
    flayer->l_cvlist = oldlay->l_cvlist;
#line 763
    cv = flayer->l_cvlist;
    {
#line 763
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 763
      if (! cv) {
#line 763
        goto while_break___2;
      }
#line 763
      cv->c_layer = flayer;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 763
    cv = cv->c_lnext;
#line 763
    LRefreshAll(flayer, 0);
#line 763
    flayer = oldlay;
#line 763
    cv = flayer->l_cvlist;
    }
    {
#line 763
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 763
      if (! cv) {
#line 763
        goto while_break___3;
      }
#line 763
      cv->c_layer = flayer;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 763
    cv = cv->c_lnext;
#line 763
    (flayer->l_next)->l_cvlist = oldcvlist;
#line 763
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 764
  ExitOverlayPage();
  }
  return;
}
}
#line 767 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void bindkeypage(void) 
{ 
  struct bindkeydata *bindkeydata ;
  struct kmap_ext *kme ;
  char tbuf[256] ;
  int del ;
  int i ;
  int y ;
  int sl ;
  struct action *act ;
  char *xch ;
  char *s ;
  char *p ;
  char *__cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t tmp ;
  char *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp___0 ;
  struct action *tmp___1 ;
  struct action *tmp___864 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  size_t __cil_tmp26 ;
  size_t __cil_tmp27 ;
  char *tmp___865 ;

  {
  {
#line 775
  bindkeydata = (struct bindkeydata *)flayer->l_data;
#line 776
  LClearAll(flayer, 0);
#line 778
  sprintf((char *)tbuf, (char const   *)((char *)"%s key bindings, page %d of %d."),
          bindkeydata->title, bindkeydata->page, bindkeydata->pages);
#line 779
  centerline((char *)tbuf, 0);
#line 780
  y = 2;
#line 781
  i = bindkeydata->pos;
  }
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    if (! (i < 104 + kmap_extn && y < flayer->l_height - 3)) {
#line 781
      goto while_break;
    }
#line 782
    p = (char *)tbuf;
#line 783
    xch = (char *)"   ";
#line 784
    if (i < 82) {
#line 785
      act = & *(bindkeydata->tab + i);
#line 786
      if (act->nr == -1) {
#line 787
        goto while_continue;
      }
#line 788
      __cil_tmp12 = p;
#line 788
      p ++;
#line 788
      *__cil_tmp12 = (char )':';
#line 788
      del = (int )*__cil_tmp12;
#line 789
      s = term[i + 106].tcname;
#line 790
      if (s) {
        {
#line 790
        __cil_tmp13 = strlen((char const   *)s);
#line 790
        tmp = __cil_tmp13;
        }
      } else {
#line 790
        tmp = (unsigned long )0;
      }
#line 790
      sl = (int )tmp;
    } else
#line 793
    if (i < 104) {
#line 794
      act = & *(bindkeydata->tab + i);
#line 795
      if (act->nr == -1) {
#line 796
        goto while_continue;
      }
#line 797
      __cil_tmp15 = p;
#line 797
      p ++;
#line 797
      *__cil_tmp15 = (char )':';
#line 797
      del = (int )*__cil_tmp15;
#line 798
      s = term[i + 84].tcname;
#line 799
      if (s) {
        {
#line 799
        __cil_tmp16 = strlen((char const   *)s);
#line 799
        tmp___0 = __cil_tmp16;
        }
      } else {
#line 799
        tmp___0 = (unsigned long )0;
      }
#line 799
      sl = (int )tmp___0;
#line 800
      xch = (char *)"[A]";
    } else {
#line 804
      kme = kmap_exts + (i - 104);
#line 805
      del = 0;
#line 806
      s = kme->str;
#line 807
      sl = kme->fl & -16385;
#line 808
      if ((kme->fl & 16384) != 0) {
#line 809
        xch = (char *)"[T]";
      }
#line 810
      if (bindkeydata->tab == (struct action *)dmtab) {
#line 810
        tmp___864 = & kme->dm;
      } else {
#line 810
        if (bindkeydata->tab == (struct action *)mmtab) {
#line 810
          tmp___1 = & kme->mm;
        } else {
#line 810
          tmp___1 = & kme->um;
        }
#line 810
        tmp___864 = tmp___1;
      }
#line 810
      act = tmp___864;
#line 811
      if (act->nr == -1) {
#line 812
        goto while_continue;
      }
    }
    {
#line 815
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 815
      if (! (__cil_tmp20 > 0)) {
#line 815
        goto while_break___0;
      }
      {
#line 816
      __cil_tmp21 = s;
#line 816
      s ++;
#line 816
      __cil_tmp22 = AddXChar(p, (int )*((unsigned char *)__cil_tmp21));
      }
#line 816
      p += __cil_tmp22;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 818
    if (del) {
#line 819
      __cil_tmp23 = p;
#line 819
      p ++;
#line 819
      *__cil_tmp23 = (char )del;
    }
#line 821
    __cil_tmp24 = p;
#line 821
    p ++;
#line 821
    *__cil_tmp24 = (char )' ';
    {
#line 822
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 822
      if (! (p < (char *)tbuf + 15)) {
#line 822
        goto while_break___1;
      }
#line 823
      __cil_tmp25 = p;
#line 823
      p ++;
#line 823
      *__cil_tmp25 = (char )' ';
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 824
    sprintf(p, (char const   *)((char *)"%s -> "), xch);
#line 825
    p += 7;
    }
#line 826
    if (p - (char *)tbuf > (long )(flayer->l_width - 1)) {
#line 827
      tbuf[flayer->l_width - 2] = (char )'$';
#line 828
      tbuf[flayer->l_width - 1] = (char )0;
    }
    {
#line 831
    __cil_tmp26 = strlen((char const   *)((char *)tbuf));
#line 831
    PadStr((char *)tbuf, (int )__cil_tmp26, 0, y);
#line 832
    __cil_tmp27 = strlen((char const   *)((char *)tbuf));
#line 832
    AddAction(act, (int )__cil_tmp27, y);
#line 833
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 781
  i ++;
#line 835
  y ++;
#line 836
  bindkeydata->last = i;
#line 837
  if (bindkeydata->page < bindkeydata->pages) {
#line 837
    tmp___865 = (char *)"for next page;";
  } else {
#line 837
    tmp___865 = (char *)"or";
  }
  {
#line 837
  sprintf((char *)tbuf, (char const   *)((char *)"[Press Space %s Return to end.]"),
          tmp___865);
#line 838
  centerline((char *)tbuf, flayer->l_height - 2);
#line 839
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
  return;
}
}
#line 842 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void BindkeyProcess(char **ppbuf , int *plen ) 
{ 
  int done ;
  struct bindkeydata *bindkeydata ;

  {
#line 843
  done = 0;
#line 846
  bindkeydata = (struct bindkeydata *)flayer->l_data;
  {
#line 847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    if (! (! done && *plen > 0)) {
#line 847
      goto while_break;
    }
    {
#line 849
    if ((int )*(*ppbuf) == ' ') {
#line 849
      goto case_32;
    }
#line 858
    if ((int )*(*ppbuf) == '\n') {
#line 858
      goto case_10;
    }
#line 858
    if ((int )*(*ppbuf) == '\r') {
#line 858
      goto case_10;
    }
#line 861
    goto switch_default;
    case_32: /* CIL Label */ 
#line 850
    if (bindkeydata->page < bindkeydata->pages) {
      {
#line 851
      bindkeydata->pos = bindkeydata->last;
#line 852
      (bindkeydata->page) ++;
#line 853
      bindkeypage();
      }
#line 854
      goto switch_break;
    }
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 859
    done = 1;
#line 860
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 862
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 864
    (*ppbuf) ++;
#line 865
    (*plen) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 867
  if (done) {
    {
#line 868
    BindkeyAbort();
    }
  }
  return;
}
}
#line 871 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void BindkeyRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 


  {
#line 872
  if (y < 0) {
    {
#line 873
    bindkeypage();
    }
#line 874
    return;
  }
#line 876
  if (y != 0) {
#line 876
    if (y != flayer->l_height - 1) {
#line 877
      return;
    }
  }
#line 878
  if (! isblank) {
    {
#line 879
    LClearArea(flayer, xs, y, xe, y, 0, 0);
    }
  }
  return;
}
}
#line 888
static void ZmodemRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 889
static int ZmodemResize(int wi , int he ) ;
#line 891 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static struct LayFuncs ZmodemLf  = 
#line 891
     {DefProcess, (void (*)(void))0, ZmodemRedisplayLine, DefClearLine, DefRewrite,
    ZmodemResize, DefRestore, (void (*)(void * ))0};
#line 903 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static int ZmodemResize(int wi , int he ) 
{ 
  int tmp ;

  {
#line 904
  flayer->l_width = wi;
#line 905
  flayer->l_height = he;
#line 906
  if (flayer->l_width > 32) {
#line 906
    tmp = 32;
  } else {
#line 906
    tmp = 0;
  }
#line 906
  flayer->l_x = tmp;
#line 907
  return (0);
}
}
#line 910 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void ZmodemRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  int tmp ;

  {
  {
#line 911
  DefRedisplayLine(y, xs, xe, isblank);
  }
#line 912
  if (y == 0) {
#line 912
    if (xs == 0) {
#line 913
      if (flayer->l_width > 32) {
#line 913
        tmp = 32;
      } else {
#line 913
        tmp = flayer->l_width;
      }
      {
#line 913
      LPutStr(flayer, (char *)"Zmodem active on another display", tmp, & mchar_blank,
              0, 0);
      }
    }
  }
  return;
}
}
#line 916 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
void ZmodemPage(void) 
{ 
  int __cil_tmp1 ;
  int tmp ;

  {
  {
#line 917
  __cil_tmp1 = InitOverlayPage(1, & ZmodemLf, 1);
  }
#line 917
  if (__cil_tmp1) {
#line 918
    return;
  }
  {
#line 919
  LRefreshAll(flayer, 0);
  }
#line 920
  if (flayer->l_width > 32) {
#line 920
    tmp = 32;
  } else {
#line 920
    tmp = 0;
  }
#line 920
  flayer->l_x = tmp;
#line 921
  flayer->l_y = 0;
  return;
}
}
#line 926 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/help.c"
static void PadStr(char *str , int n , int x , int y ) 
{ 
  int l ;
  size_t __cil_tmp6 ;

  {
  {
#line 929
  __cil_tmp6 = strlen((char const   *)str);
#line 929
  l = (int )__cil_tmp6;
  }
#line 930
  if (l > n) {
#line 931
    l = n;
  }
  {
#line 932
  LPutStr(flayer, str, l, & mchar_blank, x, y);
  }
#line 933
  if (l < n) {
    {
#line 934
    LPutStr(flayer, (char *)blank, n - l, & mchar_blank, x + l, y);
    }
  }
  return;
}
}
#line 190 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void InitLoadav(void) ;
#line 191
void AddLoadav(char *p ) ;
#line 57 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/loadav.c"
static int GetLoadav(void) ;
#line 59
static double loadav[3] ;
#line 60
static int loadok ;
#line 73 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/loadav.c"
void InitLoadav(void) 
{ 


  {
#line 75
  loadok = 1;
  return;
}
}
#line 79 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/loadav.c"
static int GetLoadav(void) 
{ 
  FILE *fp ;
  char buf[128] ;
  char *s ;
  int i ;
  double d ;
  double e ;
  int tmp ;
  double tmp___865 ;

  {
  {
#line 86
  fp = secfopen((char *)"/proc/loadavg", (char *)"r");
  }
#line 86
  if (fp == (FILE *)((void *)0)) {
#line 87
    return (0);
  }
  {
#line 88
  *((char *)buf) = (char )0;
#line 89
  fgets((char *)buf, (int )sizeof(buf), fp);
#line 90
  fclose(fp);
#line 94
  s = (char *)buf;
#line 95
  i = 0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < tmp)) {
#line 95
      goto while_break;
    }
#line 97
    e = (double )0;
#line 97
    d = e;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! ((int )*s == 32)) {
#line 98
        goto while_break___0;
      }
#line 99
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 100
    if ((int )*s == 0) {
#line 101
      goto while_break;
    }
    {
#line 102
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 102
      if (! 1) {
#line 102
        goto while_break___1;
      }
#line 104
      if ((int )*s == 46) {
#line 105
        e = (double )1;
      } else
#line 106
      if ((int )*s >= 48) {
#line 106
        if ((int )*s <= 57) {
#line 108
          d = d * (double )10 + (double )((int )*s - 48);
#line 109
          if (e) {
#line 110
            e *= (double )10;
          }
        } else {
#line 113
          goto while_break___1;
        }
      } else {
#line 113
        goto while_break___1;
      }
#line 114
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 116
    if (e) {
#line 116
      tmp___865 = d / e;
    } else {
#line 116
      tmp___865 = d;
    }
#line 116
    loadav[i] = tmp___865;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  i ++;
#line 118
  return (i);
}
}
#line 382 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/loadav.c"
void AddLoadav(char *p ) 
{ 
  int i ;
  int j ;
  size_t __cil_tmp5 ;

  {
#line 386
  if (loadok == 0) {
#line 387
    return;
  }
  {
#line 388
  j = GetLoadav();
#line 389
  i = 0;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (i < j)) {
#line 389
      goto while_break;
    }
    {
#line 391
    sprintf(p, (char const   *)((char *)" %2.2f" + ! i), loadav[i] / (double )1);
#line 392
    __cil_tmp5 = strlen((char const   *)p);
    }
#line 392
    p += __cil_tmp5;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  i ++;
  return;
}
}
#line 65 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void setutent(void) ;
#line 76
extern  __attribute__((__nothrow__)) struct utmp *getutline(struct utmp * ) ;
#line 79
extern  __attribute__((__nothrow__)) struct utmp *pututline(struct utmp *__utmp_ptr ) ;
#line 115 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
int CheckTtyname(char *tty ) ;
#line 171
void InitUtmp(void) ;
#line 172
void RemoveLoginSlot(void) ;
#line 173
void RestoreLoginSlot(void) ;
#line 174
int SetUtmp(struct win *wi ) ;
#line 175
int RemoveUtmp(struct win *wi ) ;
#line 364
char *stripdev(char *nam ) ;
#line 86 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
static slot_t TtyNameSlot(char *nam ) ;
#line 87
static void makeuser(struct utmp *u , char *line , char *user , int pid ) ;
#line 88
static void makedead(struct utmp *u ) ;
#line 89
static int pututslot(slot_t slot , struct utmp *u , char *host , struct win *wi ) ;
#line 90
static struct utmp *getutslot(slot_t slot ) ;
#line 98
struct utmp *xpututline(struct utmp *u ) ;
#line 103
static int utmpok ;
#line 104 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
static char UtmpName[]  =    "/var/run/utmp";
#line 106 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
static int utmpfd  =    - 1;
#line 177 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
void SlotToggle(int how ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  if (fore->w_type != 0) {
    {
#line 183
    Msg(0, (char const   *)((char *)"Can only work with normal windows.\n"));
    }
#line 184
    return;
  }
#line 186
  if (how) {
    {
#line 188
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 188
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 189
    if (fore->w_slot == (slot_t )-1) {
      _L: /* CIL Label */ 
      {
#line 198
      __cil_tmp2 = SetUtmp(fore);
      }
#line 198
      if (__cil_tmp2 == 0) {
        {
#line 199
        Msg(0, (char const   *)((char *)"This window is now logged in."));
        }
      } else {
        {
#line 201
        Msg(0, (char const   *)((char *)"This window should now be logged in."));
        }
      }
      {
#line 202
      WindowChanged(fore, 'f');
      }
    } else
#line 189
    if (fore->w_slot == (slot_t )0) {
#line 189
      goto _L;
    } else {
      {
#line 205
      Msg(0, (char const   *)((char *)"This window is already logged in."));
      }
    }
  } else {
    {
#line 209
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 209
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 210
    if (fore->w_slot == (slot_t )-1) {
      {
#line 211
      Msg(0, (char const   *)((char *)"This window is already logged out\n"));
      }
    } else
#line 212
    if (fore->w_slot == (slot_t )0) {
      {
#line 214
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 214
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 215
      Msg(0, (char const   *)((char *)"This window is not logged in."));
#line 216
      fore->w_slot = (slot_t )(- 1);
      }
    } else {
      {
#line 220
      RemoveUtmp(fore);
      }
#line 221
      if (fore->w_slot != (slot_t )-1) {
        {
#line 222
        Msg(0, (char const   *)((char *)"What? Cannot remove Utmp slot?"));
        }
      } else {
        {
#line 224
        Msg(0, (char const   *)((char *)"This window is no longer logged in."));
        }
      }
      {
#line 228
      WindowChanged(fore, 'f');
      }
    }
  }
  return;
}
}
#line 264 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
void InitUtmp(void) 
{ 
  int *__cil_tmp2 ;
  int *__cil_tmp3 ;

  {
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 268
  utmpfd = open((char const   *)((char *)UtmpName), 2);
  }
#line 268
  if (utmpfd == -1) {
    {
#line 270
    __cil_tmp2 = __errno_location();
    }
#line 270
    if (*__cil_tmp2 != 13) {
      {
#line 271
      __cil_tmp3 = __errno_location();
#line 271
      Msg(*__cil_tmp3, (char const   *)((char *)"%s"), (char *)UtmpName);
      }
    }
    {
#line 272
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 272
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 273
    utmpok = 0;
#line 274
    return;
  }
  {
#line 277
  close(utmpfd);
#line 278
  utmpfd = - 1;
#line 281
  utmpok = 1;
  }
  return;
}
}
#line 312 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
void RemoveLoginSlot(void) 
{ 
  struct utmp u ;
  struct utmp *uu ;
  int __cil_tmp5 ;
  struct stat stb ;
  char *tty ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 317
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  display->d_loginslot = TtyNameSlot((char *)display->d_usertty);
  }
#line 319
  if (display->d_loginslot == (slot_t )0) {
#line 320
    return;
  } else
#line 319
  if (display->d_loginslot == (slot_t )-1) {
#line 320
    return;
  }
#line 324
  if (! utmpok) {
#line 327
    display->d_loginslot = (slot_t )0;
    {
#line 328
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 328
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 341
    uu = getutslot(display->d_loginslot);
    }
#line 341
    if (uu == (struct utmp *)0) {
      {
#line 343
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 343
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 344
      display->d_loginslot = (slot_t )0;
    } else {
      {
#line 348
      display->d_utmp_logintty = *uu;
#line 349
      u = *uu;
#line 350
      makedead(& u);
#line 351
      __cil_tmp5 = pututslot(display->d_loginslot, & u, (char *)0, (struct win *)0);
      }
#line 351
      if (__cil_tmp5 == 0) {
#line 352
        display->d_loginslot = (slot_t )0;
      }
    }

  }
  {
#line 356
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 356
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 357
  if (display->d_loginslot == (slot_t )0) {
    {
#line 362
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 362
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 363
    display->d_loginttymode = 0;
#line 364
    __cil_tmp10 = CheckTtyname(tty);
    }
    {
#line 364
    __cil_tmp9 = stat((char const   *)tty, & stb);
    }
    {
#line 364
    tty = GetPtsPathOrSymlink(display->d_userfd);
    }
#line 364
    if (tty) {
#line 364
      if (__cil_tmp9 == 0) {
#line 364
        if ((int )stb.st_uid == real_uid) {
#line 364
          if (! __cil_tmp10) {
#line 364
            if (((int )stb.st_mode & 511) != 438) {
              {
#line 366
              display->d_loginttymode = (int )stb.st_mode & 511;
#line 367
              chmod((char const   *)((char *)display->d_usertty), stb.st_mode & 384U);
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
#line 376 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
void RestoreLoginSlot(void) 
{ 
  char *tty ;
  int __cil_tmp2 ;
  int *__cil_tmp3 ;
  int __cil_tmp5 ;

  {
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 381
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 381
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 382
  if (utmpok) {
#line 382
    if (display->d_loginslot != (slot_t )0) {
#line 382
      if (display->d_loginslot != (slot_t )-1) {
        {
#line 384
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 384
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 385
        __cil_tmp2 = pututslot(display->d_loginslot, & display->d_utmp_logintty, (char *)display->d_utmp_logintty.ut_host,
                               (struct win *)0);
        }
#line 385
        if (__cil_tmp2 == 0) {
          {
#line 386
          __cil_tmp3 = __errno_location();
#line 386
          Msg(*__cil_tmp3, (char const   *)((char *)"Could not write %s"), (char *)UtmpName);
          }
        }
      }
    }
  }
  {
#line 389
  display->d_loginslot = (slot_t )0;
#line 390
  __cil_tmp5 = CheckTtyname(tty);
  }
  {
#line 390
  tty = GetPtsPathOrSymlink(display->d_userfd);
  }
#line 390
  if (display->d_loginttymode) {
#line 390
    if (tty) {
#line 390
      if (! __cil_tmp5) {
        {
#line 391
        chmod((char const   *)tty, (__mode_t )display->d_loginttymode);
        }
      }
    }
  }
  return;
}
}
#line 406 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
int SetUtmp(struct win *wi ) 
{ 
  register slot_t slot ;
  struct utmp u ;
  int saved_ut ;
  char *p ;
  char host[271] ;
  char *__cil_tmp9 ;
  char *__cil_tmp12 ;
  size_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int *__cil_tmp15 ;

  {
#line 419
  wi->w_slot = (slot_t )0;
#line 420
  if (! utmpok) {
#line 421
    return (- 1);
  } else
#line 420
  if (wi->w_type != 0) {
#line 421
    return (- 1);
  }
  {
#line 422
  slot = TtyNameSlot((char *)wi->w_tty);
  }
#line 422
  if (slot == (slot_t )0) {
    {
#line 424
    while (1) {
      while_continue: /* CIL Label */ ;
#line 424
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 425
    return (- 1);
  }
  {
#line 427
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 427
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 429
  bzero((void *)((char *)(& u)), sizeof(u));
#line 430
  saved_ut = bcmp((void const   *)((char *)(& wi->w_savut)), (void const   *)((char *)(& u)),
                  sizeof(u));
  }
#line 430
  if (saved_ut) {
    {
#line 432
    bcopy((void const   *)((char *)(& wi->w_savut)), (void *)((char *)(& u)), sizeof(u));
    }
  }
#line 434
  if (! saved_ut) {
    {
#line 435
    __cil_tmp9 = stripdev((char *)wi->w_tty);
#line 435
    makeuser(& u, __cil_tmp9, LoginName, wi->w_pid);
    }
  }
#line 438
  host[sizeof(host) - 15UL] = (char )'\000';
#line 439
  if (display) {
    {
#line 441
    strncpy((char *)host, (char const   *)((char *)display->d_utmp_logintty.ut_host),
            sizeof(host) - 15UL);
    }
#line 442
    if (display->d_loginslot != (slot_t )0) {
#line 442
      if (display->d_loginslot != (slot_t )-1) {
#line 442
        if ((int )host[0] != 0) {
#line 452
          p = (char *)host;
          {
#line 452
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 452
            if (! *p) {
#line 452
              goto while_break___1;
            }
#line 453
            if ((int )*p < 48) {
              _L: /* CIL Label */ 
#line 453
              if ((int )*p != 46) {
#line 454
                goto while_break___1;
              }
            } else
#line 453
            if ((int )*p > 57) {
#line 453
              goto _L;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 452
          p ++;
#line 455
          if (*p) {
#line 457
            p = (char *)host;
            {
#line 457
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 457
              if (! *p) {
#line 457
                goto while_break___2;
              }
#line 458
              if ((int )*p == 46) {
#line 460
                *p = (char )'\000';
#line 461
                goto while_break___2;
              } else
#line 458
              if ((int )*p == 58) {
#line 458
                if (p != (char *)host) {
#line 460
                  *p = (char )'\000';
#line 461
                  goto while_break___2;
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 457
            p ++;
          }
        } else {
          {
          {
          {
#line 467
          __cil_tmp12 = stripdev((char *)display->d_usertty);
          }
          }
          {
          {
#line 467
          strncpy((char *)host + 1, (char const   *)__cil_tmp12, (sizeof(host) - 15UL) - 1UL);
          }
          }
#line 468
          host[0] = (char )':';
          }
        }
      } else {
        {
        {
        {
#line 467
        __cil_tmp12 = stripdev((char *)display->d_usertty);
        }
        }
        {
        {
#line 467
        strncpy((char *)host + 1, (char const   *)__cil_tmp12, (sizeof(host) - 15UL) - 1UL);
        }
        }
#line 468
        host[0] = (char )':';
        }
      }
    } else {
      {
      {
      {
#line 467
      __cil_tmp12 = stripdev((char *)display->d_usertty);
      }
      }
      {
      {
#line 467
      strncpy((char *)host + 1, (char const   *)__cil_tmp12, (sizeof(host) - 15UL) - 1UL);
      }
      }
#line 468
      host[0] = (char )':';
      }
    }
  } else {
    {
#line 472
    strncpy((char *)host, (char const   *)((char *)"local"), sizeof(host) - 15UL);
    }
  }
  {
#line 474
  __cil_tmp13 = strlen((char const   *)((char *)host));
#line 474
  sprintf((char *)host + __cil_tmp13, (char const   *)((char *)":S.%d"), wi->w_number);
  }
  {
#line 475
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 475
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 478
  strncpy((char *)u.ut_host, (char const   *)((char *)host), sizeof(u.ut_host));
#line 482
  __cil_tmp14 = pututslot(slot, & u, (char *)host, wi);
  }
#line 482
  if (__cil_tmp14 == 0) {
    {
#line 484
    __cil_tmp15 = __errno_location();
#line 484
    Msg(*__cil_tmp15, (char const   *)((char *)"Could not write %s"), (char *)UtmpName);
    }
#line 486
    return (- 1);
  }
  {
#line 488
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 488
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 489
  wi->w_slot = slot;
#line 490
  bcopy((void const   *)((char *)(& u)), (void *)((char *)(& wi->w_savut)), sizeof(u));
  }
#line 492
  return (0);
}
}
#line 501 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
int RemoveUtmp(struct win *wi ) 
{ 
  struct utmp u ;
  struct utmp *uu ;
  slot_t slot ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;

  {
#line 507
  slot = wi->w_slot;
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  if (! utmpok) {
#line 510
    return (- 1);
  }
#line 511
  if (slot == (slot_t )0) {
#line 513
    wi->w_slot = (slot_t )(- 1);
#line 514
    return (0);
  } else
#line 511
  if (slot == (slot_t )-1) {
#line 513
    wi->w_slot = (slot_t )(- 1);
#line 514
    return (0);
  }
  {
#line 516
  bzero((void *)((char *)(& u)), sizeof(u));
#line 521
  uu = getutslot(slot);
  }
#line 521
  if (uu == (struct utmp *)0) {
    {
#line 523
    Msg(0, (char const   *)((char *)"Utmp slot not found -> not removed"));
    }
#line 524
    return (- 1);
  }
  {
#line 526
  bcopy((void const   *)((char *)uu), (void *)((char *)(& wi->w_savut)), sizeof(wi->w_savut));
#line 528
  u = *uu;
#line 529
  makedead(& u);
#line 530
  __cil_tmp6 = pututslot(slot, & u, (char *)0, wi);
  }
#line 530
  if (__cil_tmp6 == 0) {
    {
#line 532
    __cil_tmp7 = __errno_location();
#line 532
    Msg(*__cil_tmp7, (char const   *)((char *)"Could not write %s"), (char *)UtmpName);
    }
#line 534
    return (- 1);
  }
  {
#line 536
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 536
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 537
  wi->w_slot = (slot_t )(- 1);
#line 539
  return (0);
}
}
#line 554 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
static struct utmp *getutslot(slot_t slot ) 
{ 
  struct utmp u ;
  struct utmp *__cil_tmp3 ;

  {
  {
#line 558
  bzero((void *)((char *)(& u)), sizeof(u));
#line 559
  strncpy((char *)u.ut_line, (char const   *)slot, sizeof(u.ut_line));
#line 560
  setutent();
#line 561
  __cil_tmp3 = getutline(& u);
  }
#line 561
  return (__cil_tmp3);
}
}
#line 565 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
static int pututslot(slot_t slot , struct utmp *u , char *host , struct win *wi ) 
{ 
  struct utmp *__cil_tmp5 ;

  {
  {
#line 588
  setutent();
#line 590
  __cil_tmp5 = xpututline(u);
  }
#line 590
  return (__cil_tmp5 != (struct utmp *)0);
}
}
#line 597 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
static void makedead(struct utmp *u ) 
{ 


  {
#line 600
  u->ut_type = (short )8;
#line 602
  u->ut_exit.e_termination = (short )0;
#line 603
  u->ut_exit.e_exit = (short )0;
#line 606
  u->ut_user[0] = (char )0;
  return;
}
}
#line 611 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
static void makeuser(struct utmp *u , char *line , char *user , int pid ) 
{ 
  time_t now ;
  time_t __cil_tmp6 ;

  {
  {
#line 617
  u->ut_type = (short )7;
#line 618
  strncpy((char *)u->ut_user, (char const   *)user, sizeof(u->ut_user));
#line 621
  strncpy((char *)u->ut_id, (char const   *)(line + 3), sizeof(u->ut_id));
#line 629
  strncpy((char *)u->ut_line, (char const   *)line, sizeof(u->ut_line));
#line 630
  u->ut_pid = pid;
#line 633
  __cil_tmp6 = time(& now);
#line 634
  u->ut_tv.tv_sec = (int32_t )now;
  }
  return;
}
}
#line 638 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
static slot_t TtyNameSlot(char *nam ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 641
  __cil_tmp2 = stripdev(nam);
  }
#line 641
  return (__cil_tmp2);
}
}
#line 881 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/utmp.c"
struct utmp *xpututline(struct utmp *u ) 
{ 
  struct utmp *u2 ;
  struct utmp *tmp ;
  struct utmp *tmp___866 ;

  {
  {
#line 885
  pututline(u);
#line 886
  setutent();
#line 887
  u2 = getutline(u);
  }
#line 888
  if (u2 == (struct utmp *)0) {
#line 889
    if ((int )u->ut_type == 8) {
#line 889
      tmp = u;
    } else {
#line 889
      tmp = (struct utmp *)0;
    }
#line 889
    return (tmp);
  }
#line 890
  if ((int )u->ut_type == (int )u2->ut_type) {
#line 890
    tmp___866 = u;
  } else {
#line 890
    tmp___866 = (struct utmp *)0;
  }
#line 890
  return (tmp___866);
}
}
#line 476 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 64 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void WindowDied(struct win *p , int wstat , int wstat_valid ) ;
#line 70
void ResetWindow(struct win *p ) ;
#line 76
void WNewAutoFlow(struct win *win , int on ) ;
#line 98
int OpenTTY(char *line , char *opt ) ;
#line 99
void InitTTY(struct mode *m , int ttyflag ) ;
#line 151
int RemakeWindow(struct win *p ) ;
#line 157
void nwin_compose(struct NewWindow *def , struct NewWindow *new , struct NewWindow *res ) ;
#line 161
void CloseDevice(struct win *wp ) ;
#line 60 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
struct event logflushev ;
#line 81
static void WinProcess(char **bufpp , int *lenp ) ;
#line 82
static void WinRedisplayLine(int y , int from , int to , int isblank ) ;
#line 83
static void WinClearLine(int y , int xs , int xe , int bce ) ;
#line 84
static int WinRewrite(int y , int x1 , int x2 , struct mchar *rend , int doit ) ;
#line 85
static int WinResize(int wi , int he ) ;
#line 86
static void WinRestore(void) ;
#line 87
static int DoAutolf(char *buf , int *lenp , int fr ) ;
#line 88
static void ZombieProcess(char **bufpp , int *lenp ) ;
#line 89
static void win_readev_fn(struct event *ev , char *data ) ;
#line 90
static void win_writeev_fn(struct event *ev , char *data ) ;
#line 91
static void win_resurrect_zombie_fn(struct event *ev , char *data ) ;
#line 92
static int muchpending(struct win *p , struct event *ev ) ;
#line 94
static void paste_slowev_fn(struct event *ev , char *data ) ;
#line 97
static void pseu_readev_fn(struct event *ev , char *data ) ;
#line 98
static void pseu_writeev_fn(struct event *ev , char *data ) ;
#line 100
static void win_silenceev_fn(struct event *ev , char *data ) ;
#line 101
static void win_destroyev_fn(struct event *ev , char *data ) ;
#line 103
static int ForkWindow(struct win *win , char **args , char *ttyn ) ;
#line 105
static void zmodem_found(struct win *p , int send , char *bp , int len ) ;
#line 106
static void zmodem_fin(char *buf , int len , char *data ) ;
#line 107
static int zmodem_parse(struct win *p , char *bp , int len ) ;
#line 113 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
int VerboseCreate  =    0;
#line 115 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
char DefaultShell[]  =    "/bin/sh";
#line 121 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
struct NewWindow nwin_undef  = 
#line 121
     {- 1, (char *)0, (char **)0, (char *)0, (char *)0, - 1, - 1, - 1, - 1, - 1, - 1,
    - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1, (char *)0, (char *)0, 0};
#line 148 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
struct NewWindow nwin_default  = 
#line 148
     {0, (char *)0, (char **)ShellArgs, (char *)0, (char *)screenterm, 0, 1, 1, 1, 100,
    0, 0, 0, 1, 0, 0, 0, 1, 0, 0, (char *)0, (char *)0, 0};
#line 176 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static int const_IOSIZE  =    4096;
#line 177 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static int const_one  =    1;
#line 180 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
void nwin_compose(struct NewWindow *def , struct NewWindow *new , struct NewWindow *res ) 
{ 
  int tmp ;
  char *tmp___867 ;
  char **tmp___868 ;
  char *tmp___869 ;
  char *tmp___870 ;
  int tmp___871 ;
  int tmp___872 ;
  int tmp___873 ;
  int tmp___874 ;
  int tmp___875 ;
  int tmp___876 ;
  int tmp___877 ;
  int tmp___878 ;
  int tmp___879 ;
  int tmp___880 ;
  int tmp___881 ;
  int tmp___882 ;
  int tmp___883 ;
  int tmp___884 ;
  int tmp___885 ;
  char *tmp___886 ;
  char *tmp___887 ;
  int tmp___888 ;

  {
#line 184
  if (new->StartAt != nwin_undef.StartAt) {
#line 184
    tmp = new->StartAt;
  } else {
#line 184
    tmp = def->StartAt;
  }
#line 184
  res->StartAt = tmp;
#line 185
  if (new->aka != nwin_undef.aka) {
#line 185
    tmp___867 = new->aka;
  } else {
#line 185
    tmp___867 = def->aka;
  }
#line 185
  res->aka = tmp___867;
#line 186
  if (new->args != nwin_undef.args) {
#line 186
    tmp___868 = new->args;
  } else {
#line 186
    tmp___868 = def->args;
  }
#line 186
  res->args = tmp___868;
#line 187
  if (new->dir != nwin_undef.dir) {
#line 187
    tmp___869 = new->dir;
  } else {
#line 187
    tmp___869 = def->dir;
  }
#line 187
  res->dir = tmp___869;
#line 188
  if (new->term != nwin_undef.term) {
#line 188
    tmp___870 = new->term;
  } else {
#line 188
    tmp___870 = def->term;
  }
#line 188
  res->term = tmp___870;
#line 189
  if (new->aflag != nwin_undef.aflag) {
#line 189
    tmp___871 = new->aflag;
  } else {
#line 189
    tmp___871 = def->aflag;
  }
#line 189
  res->aflag = tmp___871;
#line 190
  if (new->dynamicaka != nwin_undef.dynamicaka) {
#line 190
    tmp___872 = new->dynamicaka;
  } else {
#line 190
    tmp___872 = def->dynamicaka;
  }
#line 190
  res->dynamicaka = tmp___872;
#line 191
  if (new->flowflag != nwin_undef.flowflag) {
#line 191
    tmp___873 = new->flowflag;
  } else {
#line 191
    tmp___873 = def->flowflag;
  }
#line 191
  res->flowflag = tmp___873;
#line 192
  if (new->lflag != nwin_undef.lflag) {
#line 192
    tmp___874 = new->lflag;
  } else {
#line 192
    tmp___874 = def->lflag;
  }
#line 192
  res->lflag = tmp___874;
#line 193
  if (new->histheight != nwin_undef.histheight) {
#line 193
    tmp___875 = new->histheight;
  } else {
#line 193
    tmp___875 = def->histheight;
  }
#line 193
  res->histheight = tmp___875;
#line 194
  if (new->monitor != nwin_undef.monitor) {
#line 194
    tmp___876 = new->monitor;
  } else {
#line 194
    tmp___876 = def->monitor;
  }
#line 194
  res->monitor = tmp___876;
#line 195
  if (new->wlock != nwin_undef.wlock) {
#line 195
    tmp___877 = new->wlock;
  } else {
#line 195
    tmp___877 = def->wlock;
  }
#line 195
  res->wlock = tmp___877;
#line 196
  if (new->silence != nwin_undef.silence) {
#line 196
    tmp___878 = new->silence;
  } else {
#line 196
    tmp___878 = def->silence;
  }
#line 196
  res->silence = tmp___878;
#line 197
  if (new->wrap != nwin_undef.wrap) {
#line 197
    tmp___879 = new->wrap;
  } else {
#line 197
    tmp___879 = def->wrap;
  }
#line 197
  res->wrap = tmp___879;
#line 198
  if (new->Lflag != nwin_undef.Lflag) {
#line 198
    tmp___880 = new->Lflag;
  } else {
#line 198
    tmp___880 = def->Lflag;
  }
#line 198
  res->Lflag = tmp___880;
#line 199
  if (new->slow != nwin_undef.slow) {
#line 199
    tmp___881 = new->slow;
  } else {
#line 199
    tmp___881 = def->slow;
  }
#line 199
  res->slow = tmp___881;
#line 200
  if (new->gr != nwin_undef.gr) {
#line 200
    tmp___882 = new->gr;
  } else {
#line 200
    tmp___882 = def->gr;
  }
#line 200
  res->gr = tmp___882;
#line 201
  if (new->c1 != nwin_undef.c1) {
#line 201
    tmp___883 = new->c1;
  } else {
#line 201
    tmp___883 = def->c1;
  }
#line 201
  res->c1 = tmp___883;
#line 202
  if (new->bce != nwin_undef.bce) {
#line 202
    tmp___884 = new->bce;
  } else {
#line 202
    tmp___884 = def->bce;
  }
#line 202
  res->bce = tmp___884;
#line 203
  if (new->encoding != nwin_undef.encoding) {
#line 203
    tmp___885 = new->encoding;
  } else {
#line 203
    tmp___885 = def->encoding;
  }
#line 203
  res->encoding = tmp___885;
#line 204
  if (new->hstatus != nwin_undef.hstatus) {
#line 204
    tmp___886 = new->hstatus;
  } else {
#line 204
    tmp___886 = def->hstatus;
  }
#line 204
  res->hstatus = tmp___886;
#line 205
  if (new->charset != nwin_undef.charset) {
#line 205
    tmp___887 = new->charset;
  } else {
#line 205
    tmp___887 = def->charset;
  }
#line 205
  res->charset = tmp___887;
#line 206
  if (new->poll_zombie_timeout != nwin_undef.poll_zombie_timeout) {
#line 206
    tmp___888 = new->poll_zombie_timeout;
  } else {
#line 206
    tmp___888 = def->poll_zombie_timeout;
  }
#line 206
  res->poll_zombie_timeout = tmp___888;
  return;
}
}
#line 215 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
struct LayFuncs WinLf  = 
#line 215
     {WinProcess, (void (*)(void))0, WinRedisplayLine, WinClearLine, WinRewrite, WinResize,
    WinRestore, (void (*)(void * ))0};
#line 228 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static int DoAutolf(char *buf , int *lenp , int fr ) 
{ 
  char *p ;
  int len ;
  int trunc ;
  int __cil_tmp7 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 234
  len = *lenp;
#line 235
  trunc = 0;
#line 237
  p = buf;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (len > 0)) {
#line 237
      goto while_break;
    }
#line 239
    if ((int )*p != 13) {
#line 240
      goto while_continue;
    }
#line 241
    __cil_tmp7 = fr;
#line 241
    fr --;
#line 241
    if (__cil_tmp7 <= 0) {
#line 243
      trunc ++;
#line 244
      __cil_tmp9 = len;
#line 244
      len --;
    }
#line 246
    if (len == 0) {
#line 247
      goto while_break;
    }
    {
#line 248
    __cil_tmp10 = len;
#line 248
    len ++;
#line 248
    bcopy((void const   *)p, (void *)(p + 1), (size_t )__cil_tmp10);
#line 249
    *(p + 1) = (char )'\n';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  __cil_tmp12 = len;
#line 237
  len --;
#line 237
  __cil_tmp11 = p;
#line 237
  p ++;
#line 251
  *lenp = (int )(p - buf);
#line 252
  return (trunc);
}
}
#line 256 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void WinProcess(char **bufpp , int *lenp ) 
{ 
  int l2 ;
  int f ;
  int *ilen ;
  int l ;
  int trunc ;
  char *ibuf ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int tmp ;

  {
#line 260
  l2 = 0;
#line 260
  l = *lenp;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  fore = (struct win *)flayer->l_data;
#line 266
  if (fore->w_type == 3) {
#line 268
    *bufpp += *lenp;
#line 269
    *lenp = 0;
#line 270
    return;
  }
#line 272
  if (fore->w_ptyfd < 0) {
    {
#line 274
    ZombieProcess(bufpp, lenp);
    }
#line 275
    return;
  }
  {
#line 282
  __cil_tmp9 = AclCheckPermWin(display->d_user, 1, fore);
  }
#line 282
  if (display) {
#line 282
    if (fore->w_wlock == 1) {
#line 282
      if (! fore->w_wlockuser) {
#line 282
        if (! __cil_tmp9) {
#line 285
          fore->w_wlockuser = display->d_user;
          {
#line 286
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 286
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 290
  if (fore->w_wlock == 0) {
    {
#line 290
    __cil_tmp10 = AclCheckPermWin(display->d_user, 1, fore);
#line 290
    tmp = __cil_tmp10;
    }
  } else {
#line 290
    tmp = display->d_user != fore->w_wlockuser;
  }
#line 290
  if (display) {
#line 290
    if (tmp) {
      {
#line 294
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 294
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 295
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 295
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 297
      Msg(0, (char const   *)((char *)"write: permission denied (user %s)"), (char *)(display->d_user)->u_name);
#line 298
      *bufpp += *lenp;
#line 299
      *lenp = 0;
      }
#line 300
      return;
    }
  }
#line 313
  if (fore->w_pwin) {
#line 313
    if ((fore->w_pwin)->p_fdpat & 4096) {
#line 316
      ibuf = (char *)(fore->w_pwin)->p_inbuf;
#line 316
      ilen = & (fore->w_pwin)->p_inlen;
#line 317
      f = (int )(sizeof((fore->w_pwin)->p_inbuf) - (unsigned long )*ilen);
    } else {
#line 323
      ibuf = (char *)fore->w_inbuf;
#line 323
      ilen = & fore->w_inlen;
#line 324
      f = (int )(sizeof(fore->w_inbuf) - (unsigned long )*ilen);
    }
  } else {
#line 323
    ibuf = (char *)fore->w_inbuf;
#line 323
    ilen = & fore->w_inlen;
#line 324
    f = (int )(sizeof(fore->w_inbuf) - (unsigned long )*ilen);
  }
#line 327
  if (l > f) {
#line 328
    l = f;
  }
#line 332
  if (l > 0) {
    {
#line 335
    l2 = l;
#line 336
    bcopy((void const   *)*bufpp, (void *)(ibuf + *ilen), (size_t )l2);
#line 337
    trunc = DoAutolf(ibuf + *ilen, & l2, f - l2);
    }
#line 337
    if (fore->w_autolf) {
#line 337
      if (trunc) {
#line 338
        l -= trunc;
      }
    }
#line 347
    *ilen += l2;
#line 348
    *bufpp += l;
#line 349
    *lenp -= l;
#line 350
    return;
  }
  return;
}
}
#line 355 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void ZombieProcess(char **bufpp , int *lenp ) 
{ 
  int l ;
  char *buf ;
  char b1[10] ;
  char b2[10] ;
  int __cil_tmp7 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 359
  l = *lenp;
#line 360
  buf = *bufpp;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  fore = (struct win *)flayer->l_data;
  {
#line 365
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 365
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 366
  *bufpp += *lenp;
#line 367
  *lenp = 0;
  {
#line 368
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 368
    if (! (__cil_tmp7 > 0)) {
#line 368
      goto while_break___1;
    }
#line 370
    if ((int )*((unsigned char *)buf) == ZombieKey_destroy) {
      {
#line 372
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 372
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 373
      KillWindow(fore);
      }
#line 374
      return;
    }
#line 376
    if ((int )*((unsigned char *)buf) == ZombieKey_resurrect) {
      {
#line 378
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 378
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 379
      WriteString(fore, (char *)"\r\n", 2);
#line 380
      RemakeWindow(fore);
      }
#line 381
      return;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 368
  buf ++;
#line 384
  __cil_tmp9 = AddXChar((char *)b1, ZombieKey_destroy);
#line 384
  b1[__cil_tmp9] = (char )'\000';
#line 385
  __cil_tmp10 = AddXChar((char *)b2, ZombieKey_resurrect);
#line 385
  b2[__cil_tmp10] = (char )'\000';
#line 386
  Msg(0, (char const   *)((char *)"Press %s to destroy or %s to resurrect window"),
      (char *)b1, (char *)b2);
  }
  return;
}
}
#line 390 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void WinRedisplayLine(int y , int from , int to , int isblank ) 
{ 


  {
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  if (y < 0) {
#line 395
    return;
  }
#line 396
  fore = (struct win *)flayer->l_data;
#line 397
  if (from == 0) {
#line 397
    if (y > 0) {
#line 397
      if ((int )*((fore->w_mlines + (y - 1))->image + fore->w_layer.l_width) == 0) {
        {
#line 398
        LCDisplayLineWrap(& fore->w_layer, & *(fore->w_mlines + y), y, from, to, isblank);
        }
      } else {
        {
        {
        {
#line 400
        LCDisplayLine(& fore->w_layer, & *(fore->w_mlines + y), y, from, to, isblank);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 400
      LCDisplayLine(& fore->w_layer, & *(fore->w_mlines + y), y, from, to, isblank);
      }
      }
      }
    }
  } else {
    {
    {
    {
#line 400
    LCDisplayLine(& fore->w_layer, & *(fore->w_mlines + y), y, from, to, isblank);
    }
    }
    }
  }
  return;
}
}
#line 404 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static int WinRewrite(int y , int x1 , int x2 , struct mchar *rend , int doit ) 
{ 
  register int cost ;
  register int dx ;
  register unsigned char *p ;
  register unsigned char *i ;
  register unsigned char *f ;
  register unsigned char *fx ;
  register unsigned char *c ;
  int __cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  unsigned char *__cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  unsigned char *__cil_tmp20 ;

  {
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  fore = (struct win *)flayer->l_data;
#line 423
  dx = (x2 - x1) + 1;
#line 424
  if (doit) {
#line 426
    i = (fore->w_mlines + y)->image + x1;
    {
#line 427
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 427
      if (! (__cil_tmp13 > 0)) {
#line 427
        goto while_break___0;
      }
      {
#line 428
      __cil_tmp14 = i;
#line 428
      i ++;
#line 428
      PUTCHAR((int )*__cil_tmp14);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 429
    return (0);
  }
#line 431
  p = (fore->w_mlines + y)->attr + x1;
#line 433
  f = (fore->w_mlines + y)->font + x1;
#line 434
  fx = (fore->w_mlines + y)->fontx + x1;
#line 436
  if ((int )rend->font) {
#line 436
    if (((int )rend->font & 96) == 0) {
#line 437
      return (1000);
    }
  }
  {
#line 440
  __cil_tmp15 = ContainsSpecialDeffont(fore->w_mlines + y, x1, x2, fore->w_layer.l_encoding);
  }
#line 440
  if (fore->w_layer.l_encoding) {
#line 440
    if (fore->w_layer.l_encoding != 8) {
#line 440
      if (display->d_encoding == 8) {
#line 440
        if (__cil_tmp15) {
#line 441
          return (1000);
        }
      }
    }
  }
#line 445
  c = (fore->w_mlines + y)->color + x1;
#line 451
  dx = (x2 - x1) + 1;
#line 451
  cost = dx;
  {
#line 452
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 452
    if (! (__cil_tmp16 > 0)) {
#line 452
      goto while_break___1;
    }
#line 454
    __cil_tmp17 = p;
#line 454
    p ++;
#line 454
    if ((int )*__cil_tmp17 != (int )rend->attr) {
#line 455
      return (1000);
    }
#line 457
    __cil_tmp18 = f;
#line 457
    f ++;
#line 457
    if ((int )*__cil_tmp18 != (int )rend->font) {
#line 458
      return (1000);
    }
#line 459
    __cil_tmp19 = fx;
#line 459
    fx ++;
#line 459
    if ((int )*__cil_tmp19 != (int )rend->fontx) {
#line 460
      return (1000);
    }
#line 463
    __cil_tmp20 = c;
#line 463
    c ++;
#line 463
    if ((int )*__cil_tmp20 != (int )rend->color) {
#line 464
      return (1000);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 471
  return (cost);
}
}
#line 475 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void WinClearLine(int y , int xs , int xe , int bce ) 
{ 


  {
#line 478
  fore = (struct win *)flayer->l_data;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 480
  LClearLine(flayer, y, xs, xe, bce, & *(fore->w_mlines + y));
  }
  return;
}
}
#line 484 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static int WinResize(int wi , int he ) 
{ 


  {
  {
#line 487
  fore = (struct win *)flayer->l_data;
#line 488
  ChangeWindowSize(fore, wi, he, fore->w_histheight);
  }
#line 489
  return (0);
}
}
#line 493 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void WinRestore(void) 
{ 
  struct canvas *cv ;
  int tmp ;

  {
#line 496
  fore = (struct win *)flayer->l_data;
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  cv = flayer->l_cvlist;
  {
#line 498
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 498
    if (! cv) {
#line 498
      goto while_break___0;
    }
#line 500
    display = cv->c_display;
#line 501
    if (cv != display->d_forecv) {
#line 502
      goto while_continue___0;
    }
    {
#line 504
    KeypadMode(fore->w_keypad);
#line 505
    CursorkeysMode(fore->w_cursorkeys);
#line 506
    SetFlow(fore->w_flow & 1);
#line 507
    InsertMode(fore->w_insert);
#line 508
    ReverseVideo(fore->w_revvid);
    }
#line 509
    if (fore->w_curinv) {
#line 509
      tmp = - 1;
    } else {
#line 509
      tmp = fore->w_curvvis;
    }
    {
#line 509
    CursorVisibility(tmp);
#line 510
    MouseMode(fore->w_mouse);
#line 511
    ExtMouseMode(fore->w_extmouse);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 498
  cv = cv->c_next;
  return;
}
}
#line 525 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
int DoStartLog(struct win *w , char *buf , int bufsize ) 
{ 
  int n ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;
  FILE *__cil_tmp7 ;
  FILE *tmp ;
  struct logfile *__cil_tmp9 ;
  int tmp___889 ;

  {
#line 531
  if (! w) {
#line 532
    return (- 1);
  } else
#line 531
  if (! buf) {
#line 532
    return (- 1);
  }
  {
#line 534
  __cil_tmp5 = MakeWinMsg(screenlogfile, w, '%');
#line 534
  strncpy(buf, (char const   *)__cil_tmp5, (unsigned long )(bufsize - 1));
#line 535
  *(buf + (bufsize - 1)) = (char )0;
  }
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  if (w->w_log != (struct logfile *)((void *)0)) {
    {
#line 540
    logfclose(w->w_log);
    }
  }
  {
#line 542
  __cil_tmp6 = islogfile(buf);
  }
#line 542
  if (__cil_tmp6) {
#line 542
    tmp = (FILE *)((void *)0);
  } else {
    {
#line 542
    __cil_tmp7 = secfopen(buf, (char *)"a");
#line 542
    tmp = __cil_tmp7;
    }
  }
  {
#line 542
  __cil_tmp9 = logfopen(buf, tmp);
#line 542
  w->w_log = __cil_tmp9;
  }
#line 542
  if (w->w_log == (struct logfile *)((void *)0)) {
#line 543
    return (- 2);
  }
#line 544
  if (! logflushev.queued) {
#line 546
    if (log_flush) {
#line 546
      tmp___889 = log_flush;
    } else {
#line 546
      tmp___889 = (logtstamp_after + 4) / 5;
    }
#line 546
    n = tmp___889;
#line 547
    if (n) {
      {
#line 549
      SetTimeout(& logflushev, n * 1000);
#line 550
      evenq(& logflushev);
      }
    }
  }
#line 553
  return (0);
}
}
#line 561 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
int MakeWindow(struct NewWindow *newwin ) 
{ 
  register struct win **pp ;
  register struct win *p ;
  register int n ;
  register int i ;
  int f ;
  struct NewWindow nwin ;
  int type ;
  int startat ;
  char *TtyName___0 ;
  extern struct acluser *users___0 ;
  void *__cil_tmp12 ;
  int tmp ;
  void *__cil_tmp15 ;
  struct acluser *tmp___890 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int tmp___891 ;
  char *__cil_tmp26 ;
  size_t __cil_tmp27 ;
  int tmp___892 ;
  int tmp___893 ;
  int __cil_tmp33 ;
  struct display *d ;
  size_t __cil_tmp35 ;
  size_t __cil_tmp36 ;
  char buf[1024] ;

  {
#line 566
  f = - 1;
#line 574
  if (! wtab) {
#line 576
    if (! maxwin) {
#line 577
      maxwin = 100;
    }
    {
#line 578
    __cil_tmp12 = calloc((unsigned long )maxwin, sizeof(struct win *));
#line 578
    wtab = (struct win **)__cil_tmp12;
    }
  }
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 581
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 582
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 582
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 583
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 584
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 584
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 586
  nwin_compose(& nwin_default, newwin, & nwin);
  }
  {
#line 587
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 587
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 588
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 588
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 589
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 589
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 591
  if (nwin.StartAt < maxwin) {
#line 591
    tmp = nwin.StartAt;
  } else {
#line 591
    tmp = 0;
  }
#line 591
  startat = tmp;
#line 592
  pp = wtab + startat;
  {
#line 594
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 596
    if (*pp == (struct win *)0) {
#line 597
      goto while_break___6;
    }
#line 598
    pp ++;
#line 598
    if (pp == wtab + maxwin) {
#line 599
      pp = wtab;
    }
#line 594
    if (! (pp != wtab + startat)) {
#line 594
      goto while_break___6;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 602
  if (*pp) {
    {
#line 604
    Msg(0, (char const   *)((char *)"No more windows."));
    }
#line 605
    return (- 1);
  }
#line 618
  n = (int )(pp - wtab);
  {
#line 619
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 619
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 628
  f = OpenDevice(nwin.args, nwin.lflag, & type, & TtyName___0);
  }
#line 628
  if (f < 0) {
#line 629
    return (- 1);
  }
#line 630
  if (type == 3) {
#line 631
    f = - 1;
  }
  {
#line 633
  __cil_tmp15 = calloc((unsigned long )1, sizeof(struct win ));
#line 633
  p = (struct win *)__cil_tmp15;
  }
#line 633
  if (p == (struct win *)0) {
    {
#line 635
    close(f);
#line 636
    Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
#line 637
    return (- 1);
  }
#line 641
  if (type != 0) {
#line 642
    nwin.lflag = 0;
  }
#line 645
  p->w_type = type;
#line 648
  i = 0;
  {
#line 648
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 648
    if (! (*(nwin.args + i) && i < 63)) {
#line 648
      goto while_break___8;
    }
    {
#line 649
    p->w_cmdargs[i] = SaveStr((char const   *)*(nwin.args + i));
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 648
  i ++;
#line 650
  p->w_cmdargs[i] = (char *)0;
#line 651
  if (nwin.dir) {
    {
#line 652
    p->w_dir = SaveStr((char const   *)nwin.dir);
    }
  }
#line 653
  if (nwin.term) {
    {
#line 654
    p->w_term = SaveStr((char const   *)nwin.term);
    }
  }
#line 656
  p->w_number = n;
#line 657
  p->w_group = (struct win *)0;
#line 658
  if (fore) {
#line 658
    if (fore->w_type == 3) {
#line 659
      p->w_group = fore;
    } else {
#line 658
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 660
  if (fore) {
#line 660
    if (fore->w_group) {
#line 661
      p->w_group = fore->w_group;
    }
  }
#line 668
  if (display) {
#line 668
    tmp___890 = display->d_user;
  } else {
#line 668
    tmp___890 = users___0;
  }
  {
#line 668
  __cil_tmp21 = NewWindowAcl(p, tmp___890);
  }
#line 668
  if (__cil_tmp21) {
    {
#line 670
    free((void *)((char *)p));
#line 671
    close(f);
#line 672
    Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
#line 673
    return (- 1);
  }
  {
#line 676
  p->w_layer.l_next = (struct layer *)0;
#line 677
  p->w_layer.l_bottom = & p->w_layer;
#line 678
  p->w_layer.l_layfn = & WinLf;
#line 679
  p->w_layer.l_data = (void *)((char *)p);
#line 680
  p->w_savelayer = & p->w_layer;
#line 681
  p->w_pdisplay = (struct display *)0;
#line 682
  p->w_lastdisp = (struct display *)0;
#line 685
  __cil_tmp22 = AclCheckPermWin(display->d_user, 1, p);
  }
#line 685
  if (display) {
#line 685
    if (! __cil_tmp22) {
#line 686
      p->w_wlockuser = display->d_user;
    }
  }
#line 687
  p->w_wlock = nwin.wlock;
#line 689
  p->w_ptyfd = f;
#line 690
  p->w_aflag = nwin.aflag;
#line 691
  p->w_dynamicaka = nwin.dynamicaka;
#line 692
  if (nwin.flowflag & (1 << 2)) {
#line 692
    tmp___891 = (1 << 1) | 1;
  } else {
#line 692
    tmp___891 = 1 << 1;
  }
#line 692
  p->w_flow = nwin.flowflag | tmp___891;
#line 693
  if (! nwin.aka) {
    {
#line 694
    nwin.aka = Filename(*(nwin.args + 0));
    }
  }
  {
#line 695
  strncpy((char *)p->w_akabuf, (char const   *)nwin.aka, sizeof(p->w_akabuf) - 1UL);
#line 696
  nwin.aka = rindex((char const   *)((char *)p->w_akabuf), '|');
  }
#line 696
  if (nwin.aka != (char *)((void *)0)) {
    {
#line 698
    p->w_autoaka = 0;
#line 699
    __cil_tmp26 = nwin.aka;
#line 699
    (nwin.aka) ++;
#line 699
    *__cil_tmp26 = (char )0;
#line 700
    p->w_title = nwin.aka;
#line 701
    __cil_tmp27 = strlen((char const   *)nwin.aka);
#line 701
    p->w_akachange = nwin.aka + __cil_tmp27;
    }
  } else {
#line 704
    p->w_akachange = (char *)p->w_akabuf;
#line 704
    p->w_title = p->w_akachange;
  }
#line 705
  if (nwin.hstatus) {
    {
#line 706
    p->w_hstatus = SaveStr((char const   *)nwin.hstatus);
    }
  }
#line 707
  p->w_monitor = nwin.monitor;
#line 709
  if (p->w_monitor == 1) {
#line 712
    i = 0;
    {
#line 712
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 712
      if (! (i < maxusercount)) {
#line 712
        goto while_break___9;
      }
#line 713
      *(p->w_mon_notify + (i >> 3)) |= 128 >> (i & 7);
    }
    while_break___9: /* CIL Label */ ;
    }
#line 712
    i ++;
  }
#line 719
  p->w_silence = nwin.silence;
#line 720
  p->w_silencewait = SilenceWait;
#line 722
  if (p->w_silence == 1) {
#line 725
    i = 0;
    {
#line 725
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 725
      if (! (i < maxusercount)) {
#line 725
        goto while_break___10;
      }
#line 726
      *(p->w_lio_notify + (i >> 3)) |= 128 >> (i & 7);
    }
    while_break___10: /* CIL Label */ ;
    }
#line 725
    i ++;
  }
  {
#line 730
  p->w_slowpaste = nwin.slow;
#line 735
  p->w_norefresh = (char )0;
#line 736
  strncpy((char *)p->w_tty, (char const   *)TtyName___0, (unsigned long )767);
  }
#line 748
  if (display) {
#line 748
    tmp___892 = ((display->d_forecv)->c_xe - (display->d_forecv)->c_xs) + 1;
  } else {
#line 748
    tmp___892 = 80;
  }
#line 748
  if (display) {
#line 748
    tmp___893 = ((display->d_forecv)->c_ye - (display->d_forecv)->c_ys) + 1;
  } else {
#line 748
    tmp___893 = 24;
  }
  {
#line 748
  __cil_tmp33 = ChangeWindowSize(p, tmp___892, tmp___893, nwin.histheight);
  }
#line 748
  if (__cil_tmp33) {
    {
#line 752
    FreeWindow(p);
    }
#line 753
    return (- 1);
  }
  {
#line 757
  p->w_layer.l_encoding = nwin.encoding;
#line 758
  ResetWindow(p);
  }
#line 761
  if (nwin.charset) {
    {
#line 762
    SetCharsets(p, nwin.charset);
    }
  }
#line 765
  if (VerboseCreate) {
#line 765
    if (type != 3) {
      {
#line 767
      d = display;
#line 769
      WriteString(p, (char *)":screen (", 9);
#line 770
      __cil_tmp35 = strlen((char const   *)p->w_title);
#line 770
      WriteString(p, p->w_title, (int )__cil_tmp35);
#line 771
      WriteString(p, (char *)"):", 2);
#line 772
      f = 0;
      }
      {
#line 772
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 772
        if (! p->w_cmdargs[f]) {
#line 772
          goto while_break___11;
        }
        {
#line 774
        WriteString(p, (char *)" ", 1);
#line 775
        __cil_tmp36 = strlen((char const   *)p->w_cmdargs[f]);
#line 775
        WriteString(p, p->w_cmdargs[f], (int )__cil_tmp36);
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 772
      f ++;
#line 777
      WriteString(p, (char *)"\r\n", 2);
#line 778
      display = d;
      }
    }
  }
#line 781
  p->w_deadpid = 0;
#line 782
  p->w_pid = 0;
#line 784
  p->w_pwin = (struct pseudowin *)0;
#line 798
  if (type == 0) {
    {
#line 800
    p->w_pid = ForkWindow(p, nwin.args, TtyName___0);
    }
#line 801
    if (p->w_pid < 0) {
      {
#line 803
      FreeWindow(p);
      }
#line 804
      return (- 1);
    }
  }
#line 811
  if (display) {
#line 811
    if (display->d_fore) {
#line 812
      display->d_other = display->d_fore;
    }
  }
#line 813
  *pp = p;
#line 814
  p->w_next = windows;
#line 815
  windows = p;
#line 817
  if (type == 3) {
    {
#line 819
    SetForeWindow(p);
#line 820
    Activate((int )p->w_norefresh);
#line 821
    WindowChanged((struct win *)0, 'w');
#line 822
    WindowChanged((struct win *)0, 'W');
#line 823
    WindowChanged((struct win *)0, 0);
    }
#line 824
    return (n);
  }
#line 827
  p->w_lflag = nwin.lflag;
#line 829
  p->w_slot = (slot_t )(- 1);
  {
#line 831
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 831
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 832
  if (nwin.lflag & 1) {
#line 838
    p->w_slot = (slot_t )0;
#line 839
    if (display) {
      {
      {
#line 840
      SetUtmp(p);
      }
      }
    } else
#line 839
    if (p->w_lflag & 2) {
      {
      {
#line 840
      SetUtmp(p);
      }
      }
    }
  }
#line 847
  if (nwin.Lflag) {
    {
#line 850
    DoStartLog(p, (char *)buf, (int )sizeof(buf));
    }
  }
#line 854
  if (nwin.poll_zombie_timeout) {
#line 855
    p->w_poll_zombie_timeout = nwin.poll_zombie_timeout;
  }
  {
#line 857
  p->w_zombieev.type = 0;
#line 858
  p->w_zombieev.data = (char *)p;
#line 859
  p->w_zombieev.handler = win_resurrect_zombie_fn;
#line 861
  p->w_writeev.fd = p->w_ptyfd;
#line 861
  p->w_readev.fd = p->w_writeev.fd;
#line 862
  p->w_readev.type = 1;
#line 863
  p->w_writeev.type = 2;
#line 864
  p->w_writeev.data = (char *)p;
#line 864
  p->w_readev.data = p->w_writeev.data;
#line 865
  p->w_readev.handler = win_readev_fn;
#line 866
  p->w_writeev.handler = win_writeev_fn;
#line 867
  p->w_writeev.condpos = & p->w_inlen;
#line 868
  evenq(& p->w_readev);
#line 869
  evenq(& p->w_writeev);
#line 871
  p->w_paster.pa_slowev.type = 0;
#line 872
  p->w_paster.pa_slowev.data = (char *)(& p->w_paster);
#line 873
  p->w_paster.pa_slowev.handler = paste_slowev_fn;
#line 875
  p->w_silenceev.type = 0;
#line 876
  p->w_silenceev.data = (char *)p;
#line 877
  p->w_silenceev.handler = win_silenceev_fn;
  }
#line 878
  if (p->w_silence > 0) {
    {
#line 880
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 880
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 881
    SetTimeout(& p->w_silenceev, p->w_silencewait * 1000);
#line 882
    evenq(& p->w_silenceev);
    }
  }
  {
#line 884
  p->w_destroyev.type = 0;
#line 885
  p->w_destroyev.data = (char *)0;
#line 886
  p->w_destroyev.handler = win_destroyev_fn;
#line 888
  SetForeWindow(p);
#line 889
  Activate((int )p->w_norefresh);
#line 890
  WindowChanged((struct win *)0, 'w');
#line 891
  WindowChanged((struct win *)0, 'W');
#line 892
  WindowChanged((struct win *)0, 0);
  }
#line 893
  return (n);
}
}
#line 903 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
int RemakeWindow(struct win *p ) 
{ 
  char *TtyName___0 ;
  int lflag ;
  int f ;
  char *tmp ;
  struct display *d ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;

  {
  {
#line 909
  lflag = nwin_default.lflag;
#line 917
  f = OpenDevice((char **)p->w_cmdargs, lflag, & p->w_type, & TtyName___0);
  }
#line 917
  if (f < 0) {
#line 918
    return (- 1);
  }
  {
#line 920
  evdeq(& p->w_destroyev);
  }
#line 922
  if ((int )*TtyName___0) {
#line 922
    tmp = TtyName___0;
  } else {
#line 922
    tmp = p->w_title;
  }
  {
#line 922
  strncpy((char *)p->w_tty, (char const   *)tmp, (unsigned long )767);
#line 923
  p->w_ptyfd = f;
#line 924
  p->w_readev.fd = f;
#line 925
  p->w_writeev.fd = f;
#line 926
  evenq(& p->w_readev);
#line 927
  evenq(& p->w_writeev);
  }
#line 929
  if (VerboseCreate) {
    {
#line 931
    d = display;
#line 933
    WriteString(p, (char *)":screen (", 9);
#line 934
    __cil_tmp8 = strlen((char const   *)p->w_title);
#line 934
    WriteString(p, p->w_title, (int )__cil_tmp8);
#line 935
    WriteString(p, (char *)"):", 2);
#line 936
    f = 0;
    }
    {
#line 936
    while (1) {
      while_continue: /* CIL Label */ ;
#line 936
      if (! p->w_cmdargs[f]) {
#line 936
        goto while_break;
      }
      {
#line 938
      WriteString(p, (char *)" ", 1);
#line 939
      __cil_tmp9 = strlen((char const   *)p->w_cmdargs[f]);
#line 939
      WriteString(p, p->w_cmdargs[f], (int )__cil_tmp9);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 936
    f ++;
#line 941
    WriteString(p, (char *)"\r\n", 2);
#line 942
    display = d;
    }
  }
#line 945
  p->w_deadpid = 0;
#line 946
  p->w_pid = 0;
#line 955
  if (p->w_type == 0) {
    {
#line 957
    p->w_pid = ForkWindow(p, (char **)p->w_cmdargs, TtyName___0);
    }
#line 958
    if (p->w_pid < 0) {
#line 959
      return (- 1);
    }
  }
#line 963
  if (p->w_slot == (slot_t )0) {
#line 963
    if (display) {
      {
      {
#line 964
      SetUtmp(p);
      }
      }
    } else
#line 963
    if (p->w_lflag & 2) {
      {
      {
#line 964
      SetUtmp(p);
      }
      }
    }
  }
  {
#line 969
  WindowChanged(p, 'f');
  }
#line 970
  return (p->w_number);
}
}
#line 974 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
void CloseDevice(struct win *wp ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 977
  if (wp->w_ptyfd < 0) {
#line 978
    return;
  }
#line 979
  if (wp->w_type == 0) {
    {
#line 982
    __cil_tmp2 = chmod((char const   *)((char *)wp->w_tty), (__mode_t )438);
#line 983
    __cil_tmp3 = chown((char const   *)((char *)wp->w_tty), (__uid_t )0, (__gid_t )0);
    }
  }
  {
#line 985
  close(wp->w_ptyfd);
#line 986
  wp->w_ptyfd = - 1;
#line 987
  wp->w_tty[0] = (char )0;
#line 988
  evdeq(& wp->w_readev);
#line 989
  evdeq(& wp->w_writeev);
#line 993
  wp->w_writeev.fd = - 1;
#line 993
  wp->w_readev.fd = wp->w_writeev.fd;
  }
  return;
}
}
#line 997 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
void FreeWindow(struct win *wp ) 
{ 
  struct display *d ;
  int i ;
  struct canvas *cv ;
  struct canvas *ncv ;
  struct layer *l ;
  struct win *win ;
  struct win *tmp ;

  {
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1005
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1007
  if (wp->w_pwin) {
    {
#line 1008
    FreePseudowin(wp);
    }
  }
  {
#line 1011
  RemoveUtmp(wp);
#line 1013
  CloseDevice(wp);
  }
#line 1015
  if (wp == console_window) {
    {
#line 1017
    TtyGrabConsole(- 1, - 1, (char *)"free");
#line 1018
    console_window = (struct win *)0;
    }
  }
#line 1020
  if (wp->w_log != (struct logfile *)((void *)0)) {
    {
#line 1021
    logfclose(wp->w_log);
    }
  }
  {
#line 1022
  ChangeWindowSize(wp, 0, 0, 0);
  }
#line 1024
  if (wp->w_type == 3) {
#line 1027
    win = windows;
    {
#line 1027
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1027
      if (! win) {
#line 1027
        goto while_break___0;
      }
#line 1028
      if (win->w_group == wp) {
#line 1029
        win->w_group = wp->w_group;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1027
    win = win->w_next;
  }
#line 1032
  if (wp->w_hstatus) {
    {
#line 1033
    free((void *)wp->w_hstatus);
    }
  }
#line 1034
  i = 0;
  {
#line 1034
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1034
    if (! wp->w_cmdargs[i]) {
#line 1034
      goto while_break___1;
    }
    {
#line 1035
    free((void *)wp->w_cmdargs[i]);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1034
  i ++;
#line 1036
  if (wp->w_dir) {
    {
#line 1037
    free((void *)wp->w_dir);
    }
  }
#line 1038
  if (wp->w_term) {
    {
#line 1039
    free((void *)wp->w_term);
    }
  }
#line 1040
  d = displays;
  {
#line 1040
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1040
    if (! d) {
#line 1040
      goto while_break___2;
    }
#line 1042
    if (d->d_other == wp) {
#line 1043
      if (d->d_fore && (d->d_fore)->w_next != wp) {
#line 1043
        tmp = (d->d_fore)->w_next;
      } else {
#line 1043
        tmp = wp->w_next;
      }
#line 1043
      d->d_other = tmp;
    }
#line 1044
    if (d->d_fore == wp) {
#line 1045
      d->d_fore = (struct win *)((void *)0);
    }
#line 1046
    cv = d->d_cvlist;
    {
#line 1046
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1046
      if (! cv) {
#line 1046
        goto while_break___3;
      }
#line 1048
      l = cv->c_layer;
      {
#line 1048
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1048
        if (! l) {
#line 1048
          goto while_break___4;
        }
#line 1049
        if (l->l_layfn == & WinLf) {
#line 1050
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1048
      l = l->l_next;
#line 1051
      if (! l) {
#line 1052
        goto while_continue___3;
      }
#line 1053
      if ((struct win *)l->l_data != wp) {
#line 1054
        goto while_continue___3;
      }
#line 1055
      if (cv->c_layer == wp->w_savelayer) {
#line 1056
        wp->w_savelayer = (struct layer *)0;
      }
      {
#line 1057
      KillLayerChain(cv->c_layer);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1046
    cv = cv->c_next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1040
  d = d->d_next;
#line 1060
  if (wp->w_savelayer) {
    {
#line 1061
    KillLayerChain(wp->w_savelayer);
    }
  }
#line 1062
  cv = wp->w_layer.l_cvlist;
  {
#line 1062
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1062
    if (! cv) {
#line 1062
      goto while_break___5;
    }
    {
#line 1064
    ncv = cv->c_lnext;
#line 1065
    cv->c_layer = & cv->c_blank;
#line 1066
    cv->c_blank.l_cvlist = cv;
#line 1067
    cv->c_lnext = (struct canvas *)0;
#line 1068
    cv->c_xoff = cv->c_xs;
#line 1069
    cv->c_yoff = cv->c_ys;
#line 1070
    RethinkViewportOffsets(cv);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1062
  cv = ncv;
#line 1072
  wp->w_layer.l_cvlist = (struct canvas *)0;
#line 1073
  if (flayer == & wp->w_layer) {
#line 1074
    flayer = (struct layer *)0;
  }
  {
#line 1075
  LayerCleanupMemory(& wp->w_layer);
#line 1078
  FreeWindowAcl(wp);
#line 1080
  evdeq(& wp->w_readev);
#line 1081
  evdeq(& wp->w_writeev);
#line 1082
  evdeq(& wp->w_silenceev);
#line 1083
  evdeq(& wp->w_zombieev);
#line 1084
  evdeq(& wp->w_destroyev);
#line 1086
  FreePaster(& wp->w_paster);
#line 1088
  free((void *)((char *)wp));
  }
  return;
}
}
#line 1092 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
int OpenDevice(char **args , int lflag , int *typep , char **namep ) 
{ 
  char *arg ;
  struct stat st ;
  int f ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int *__cil_tmp12 ;
  int flag ;
  int __cil_tmp16 ;
  int *__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int *__cil_tmp20 ;
  int tmp ;
  int __cil_tmp22 ;
  int *__cil_tmp23 ;

  {
#line 1098
  arg = *(args + 0);
#line 1102
  if (! arg) {
#line 1103
    return (- 1);
  }
  {
#line 1104
  __cil_tmp8 = strcmp((char const   *)arg, (char const   *)((char *)"//group"));
  }
#line 1104
  if (__cil_tmp8 == 0) {
#line 1106
    *typep = 3;
#line 1107
    *namep = (char *)"telnet";
#line 1108
    return (0);
  }
  {
#line 1110
  __cil_tmp9 = strncmp((char const   *)arg, (char const   *)((char *)"//"), (unsigned long )2);
  }
#line 1110
  if (__cil_tmp9 == 0) {
    {
#line 1112
    Msg(0, (char const   *)((char *)"Invalid argument \'%s\'"), arg);
    }
#line 1113
    return (- 1);
  } else {
    {
#line 1115
    __cil_tmp10 = stat((char const   *)arg, & st);
    }
#line 1115
    if (__cil_tmp10 == 0) {
#line 1115
      if ((st.st_mode & 61440U) == 8192U) {
        {
#line 1117
        __cil_tmp11 = access((char const   *)arg, 6);
        }
#line 1117
        if (__cil_tmp11 == -1) {
          {
#line 1119
          __cil_tmp12 = __errno_location();
#line 1119
          Msg(*__cil_tmp12, (char const   *)((char *)"Cannot access line \'%s\' for R/W"),
              arg);
          }
#line 1120
          return (- 1);
        }
        {
#line 1122
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1122
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1123
        f = OpenTTY(arg, *(args + 1));
        }
#line 1123
        if (f < 0) {
#line 1124
          return (- 1);
        }
#line 1125
        lflag = 0;
#line 1126
        *typep = 1;
#line 1127
        *namep = arg;
      } else {
#line 1115
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1131
      *typep = 0;
#line 1132
      f = OpenPTY(namep);
      }
#line 1133
      if (f == -1) {
        {
#line 1135
        Msg(0, (char const   *)((char *)"No more PTYs."));
        }
#line 1136
        return (- 1);
      }
      {
#line 1140
      flag = 1;
#line 1141
      __cil_tmp16 = ioctl(f, (unsigned long )21536, (char *)(& flag));
      }
#line 1141
      if (__cil_tmp16) {
        {
#line 1143
        __cil_tmp17 = __errno_location();
#line 1143
        Msg(*__cil_tmp17, (char const   *)((char *)"TIOCPKT ioctl"));
#line 1144
        close(f);
        }
#line 1145
        return (- 1);
      }
    }
  }
  {
#line 1150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1150
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1151
  __cil_tmp18 = fcntl(f, 4, 2048);
  }
#line 1169
  if (*typep == 0) {
    {
    {
#line 1170
    tcflush(f, 2);
    }
    }
  } else
#line 1169
  if (*typep == 1) {
    {
    {
#line 1170
    tcflush(f, 2);
    }
    }
  }
#line 1173
  if (*typep != 0) {
#line 1174
    return (f);
  }
  {
#line 1178
  __cil_tmp19 = chown((char const   *)*namep, (__uid_t )real_uid, (__gid_t )5);
  }
#line 1178
  if (__cil_tmp19) {
#line 1178
    if (! eff_uid) {
      {
#line 1183
      __cil_tmp20 = __errno_location();
#line 1183
      Msg(*__cil_tmp20, (char const   *)((char *)"chown tty"));
#line 1184
      close(f);
      }
#line 1185
      return (- 1);
    }
  }
#line 1188
  if (lflag) {
#line 1188
    tmp = TtyMode;
  } else {
#line 1188
    tmp = TtyMode & -19;
  }
  {
#line 1188
  __cil_tmp22 = chmod((char const   *)*namep, (__mode_t )tmp);
  }
#line 1188
  if (__cil_tmp22) {
#line 1188
    if (! eff_uid) {
      {
#line 1193
      __cil_tmp23 = __errno_location();
#line 1193
      Msg(*__cil_tmp23, (char const   *)((char *)"chmod tty"));
#line 1194
      close(f);
      }
#line 1195
      return (- 1);
    }
  }
#line 1198
  return (f);
}
}
#line 1209 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static int ForkWindow(struct win *win , char **args , char *ttyn ) 
{ 
  int pid ;
  char tebuf[38] ;
  char ebuf[20] ;
  char shellbuf[4103] ;
  char *proc ;
  int newfd ;
  int w ;
  int h ;
  int i ;
  int pat ;
  int wfdused ;
  struct pseudowin *pwin ;
  int slave ;
  int *__cil_tmp18 ;
  int *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int *__cil_tmp23 ;
  int __cil_tmp24 ;
  int *__cil_tmp25 ;
  int tmp ;
  int *__cil_tmp30 ;
  int __cil_tmp32 ;
  int *__cil_tmp33 ;
  struct mode fakemode ;
  struct mode *modep ;
  int __cil_tmp36 ;
  int *__cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp41 ;
  size_t __cil_tmp42 ;
  char *s1 ;
  char *s2 ;
  char tl ;
  size_t __cil_tmp46 ;
  char *__cil_tmp48 ;
  size_t __cil_tmp49 ;
  size_t __cil_tmp50 ;
  int *__cil_tmp52 ;

  {
#line 1222
  w = win->w_layer.l_width;
#line 1223
  h = win->w_layer.l_height;
#line 1226
  pwin = win->w_pwin;
#line 1228
  slave = - 1;
#line 1231
  if (pty_preopen) {
    {
#line 1233
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1233
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1234
    slave = open((char const   *)ttyn, 258);
    }
#line 1234
    if (slave == -1) {
      {
#line 1236
      __cil_tmp18 = __errno_location();
#line 1236
      Msg(*__cil_tmp18, (char const   *)((char *)"ttyn"));
      }
#line 1237
      return (- 1);
    }
  }
  {
#line 1241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1241
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1242
  proc = *args;
#line 1243
  if (proc == (char *)0) {
#line 1245
    args = (char **)ShellArgs;
#line 1246
    proc = *args;
  }
  {
#line 1248
  fflush(stdout);
#line 1249
  fflush(stderr);
#line 1250
  pid = fork();
  }
  {
#line 1252
  if (pid == - 1) {
#line 1252
    goto case_exp;
  }
#line 1255
  if (pid == 0) {
#line 1255
    goto case_0;
  }
#line 1478
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 1253
  __cil_tmp20 = __errno_location();
#line 1253
  Msg(*__cil_tmp20, (char const   *)((char *)"fork"));
  }
#line 1254
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1256
  xsignal(1, (__sighandler_t )0);
  }
  {
#line 1257
  xsignal(2, (__sighandler_t )0);
#line 1258
  xsignal(3, (__sighandler_t )0);
#line 1259
  xsignal(15, (__sighandler_t )0);
#line 1261
  xsignal(21, (__sighandler_t )0);
#line 1262
  xsignal(22, (__sighandler_t )0);
#line 1265
  xsignal(13, (__sighandler_t )0);
#line 1268
  xsignal(25, (__sighandler_t )0);
#line 1271
  displays = (struct display *)0;
#line 1272
  ServerSocket = - 1;
#line 1273
  __cil_tmp22 = setuid((__uid_t )real_uid);
  }
  {
#line 1273
  __cil_tmp21 = setgid((__gid_t )real_gid);
  }
#line 1273
  if (__cil_tmp21) {
    {
    {
#line 1274
    __cil_tmp23 = __errno_location();
    }
    {
#line 1274
    Panic(*__cil_tmp23, (char const   *)((char *)"Setuid/gid"));
    }
    }
  } else
#line 1273
  if (__cil_tmp22) {
    {
    {
#line 1274
    __cil_tmp23 = __errno_location();
    }
    {
#line 1274
    Panic(*__cil_tmp23, (char const   *)((char *)"Setuid/gid"));
    }
    }
  }
#line 1275
  eff_uid = real_uid;
#line 1276
  eff_gid = real_gid;
#line 1278
  if (! pwin) {
    {
#line 1280
    __cil_tmp24 = chdir((char const   *)win->w_dir);
    }
#line 1280
    if (win->w_dir) {
#line 1280
      if ((int )*(win->w_dir)) {
#line 1280
        if (__cil_tmp24) {
          {
#line 1281
          __cil_tmp25 = __errno_location();
#line 1281
          Panic(*__cil_tmp25, (char const   *)((char *)"Cannot chdir to %s"), win->w_dir);
          }
        }
      }
    }
  }
#line 1283
  if (display) {
    {
#line 1285
    brktty(display->d_userfd);
#line 1286
    freetty();
    }
  } else {
    {
#line 1289
    brktty(- 1);
    }
  }
#line 1294
  if (slave != -1) {
    {
#line 1296
    close(0);
#line 1297
    dup(slave);
#line 1298
    close(slave);
#line 1299
    closeallfiles(win->w_ptyfd);
#line 1300
    slave = dup(0);
    }
  } else {
    {
#line 1303
    closeallfiles(win->w_ptyfd);
    }
  }
  {
#line 1318
  close(0);
#line 1319
  close(1);
#line 1320
  close(2);
#line 1321
  newfd = - 1;
  }
#line 1326
  if (pwin) {
#line 1326
    tmp = pwin->p_fdpat;
  } else {
#line 1326
    tmp = ((1 << 4) | (1 << 2)) | 1;
  }
#line 1326
  pat = tmp;
  {
#line 1328
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1328
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1329
  wfdused = 0;
#line 1330
  i = 0;
  {
#line 1330
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1330
    if (! (i < 3)) {
#line 1330
      goto while_break___2;
    }
#line 1332
    if (pat & (1 << 2 * i)) {
#line 1334
      if (newfd < 0) {
#line 1337
        if (separate_sids) {
          {
#line 1338
          newfd = open((char const   *)ttyn, 2);
          }
        } else {
          {
#line 1340
          newfd = open((char const   *)ttyn, 258);
          }
        }
#line 1344
        if (newfd < 0) {
          {
#line 1345
          __cil_tmp30 = __errno_location();
#line 1345
          Panic(*__cil_tmp30, (char const   *)((char *)"Cannot open %s"), ttyn);
          }
        }
      } else {
        {
#line 1348
        dup(newfd);
        }
      }
    } else {
      {
#line 1352
      dup(win->w_ptyfd);
#line 1353
      wfdused = 1;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1330
  i ++;
#line 1356
  if (wfdused) {
    {
#line 1362
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1362
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1363
    __cil_tmp32 = fcntl(win->w_ptyfd, 4, 0);
    }
#line 1363
    if (__cil_tmp32) {
      {
#line 1364
      __cil_tmp33 = __errno_location();
#line 1364
      Msg(*__cil_tmp33, (char const   *)((char *)"Warning: clear NBLOCK fcntl failed"));
      }
    }
  }
  {
#line 1380
  close(win->w_ptyfd);
  }
#line 1381
  if (slave != -1) {
    {
#line 1382
    close(slave);
    }
  }
#line 1383
  if (newfd >= 0) {
    {
#line 1386
    InitPTY(newfd);
#line 1387
    __cil_tmp36 = fgtty(newfd);
    }
#line 1387
    if (__cil_tmp36) {
      {
#line 1388
      __cil_tmp37 = __errno_location();
#line 1388
      Msg(*__cil_tmp37, (char const   *)((char *)"fgtty"));
      }
    }
#line 1389
    if (display) {
      {
#line 1391
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1391
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1392
      modep = & display->d_OldMode;
    } else {
      {
#line 1396
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1396
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 1397
      modep = & fakemode;
#line 1398
      InitTTY(modep, 0);
      }
    }
#line 1407
    if (pwin) {
#line 1407
      if (! (pat & 4096)) {
        _L: /* CIL Label */ 
        {
#line 1409
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1409
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1411
        modep->tio.c_lflag &= (unsigned int )(~ 8);
#line 1412
        modep->tio.c_iflag &= (unsigned int )(~ 256);
      } else
#line 1407
      if (pat & (2 << 2)) {
#line 1407
        goto _L;
      }
    }
    {
#line 1418
    SetTTY(newfd, modep);
#line 1420
    glwz.ws_col = (unsigned short )w;
#line 1421
    glwz.ws_row = (unsigned short )h;
#line 1422
    __cil_tmp38 = ioctl(newfd, (unsigned long )21524, (char *)(& glwz));
#line 1425
    __cil_tmp39 = fcntl(newfd, 4, 0);
    }
  }
  {
#line 1434
  *(NewEnv + 2) = MakeTermcap(display == (struct display *)0 || win->w_aflag);
#line 1441
  strcpy((char *)shellbuf, (char const   *)((char *)"SHELL="));
#line 1442
  strncpy((char *)shellbuf + 6, (char const   *)(ShellProg + ((int )*ShellProg == 45)),
          sizeof(shellbuf) - 7UL);
#line 1443
  shellbuf[sizeof(shellbuf) - 1UL] = (char )0;
#line 1444
  *(NewEnv + 4) = (char *)shellbuf;
  }
  {
#line 1445
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1445
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1446
  __cil_tmp42 = strlen((char const   *)win->w_term);
  }
  {
#line 1446
  __cil_tmp41 = strcmp((char const   *)((char *)screenterm), (char const   *)win->w_term);
  }
#line 1446
  if (win->w_term) {
#line 1446
    if ((int )*(win->w_term)) {
#line 1446
      if (__cil_tmp41) {
#line 1446
        if (__cil_tmp42 < 32UL) {
          {
#line 1451
          snprintf((char *)tebuf, sizeof(tebuf), (char const   *)((char *)"TERM=%s"),
                   win->w_term);
          }
          {
#line 1452
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 1452
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 1453
          __cil_tmp46 = strlen((char const   *)win->w_term);
#line 1453
          tl = (char )__cil_tmp46;
#line 1454
          *(NewEnv + 1) = (char *)tebuf;
#line 1455
          s1 = index((char const   *)*(NewEnv + 2), '|');
          }
#line 1455
          if (s1) {
            {
#line 1457
            s1 ++;
#line 1457
            __cil_tmp48 = index((char const   *)s1, '|');
#line 1457
            s2 = __cil_tmp48;
            }
#line 1457
            if (s2) {
              {
#line 1459
              __cil_tmp49 = strlen((char const   *)*(NewEnv + 2));
              }
#line 1459
              if ((__cil_tmp49 - (unsigned long )(s2 - s1)) + (unsigned long )tl < 1024UL) {
                {
#line 1461
                __cil_tmp50 = strlen((char const   *)s2);
#line 1461
                bcopy((void const   *)s2, (void *)(s1 + (int )tl), __cil_tmp50 + 1UL);
#line 1462
                bcopy((void const   *)win->w_term, (void *)s1, (size_t )tl);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 1467
  snprintf((char *)ebuf, sizeof(ebuf), (char const   *)((char *)"WINDOW=%d"), win->w_number);
#line 1468
  *(NewEnv + 3) = (char *)ebuf;
  }
#line 1470
  if ((int )*proc == 45) {
#line 1471
    proc ++;
  }
#line 1472
  if (! *proc) {
#line 1473
    proc = (char *)DefaultShell;
  }
  {
#line 1474
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1474
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 1475
  execvpe((char const   *)proc, (char * const  [])args, (char * const  [])NewEnv);
  }
  {
#line 1476
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1476
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 1477
  __cil_tmp52 = __errno_location();
#line 1477
  Panic(*__cil_tmp52, (char const   *)((char *)"Cannot exec \'%s\'"), proc);
  }
  switch_default: /* CIL Label */ 
#line 1479
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1481
  if (slave != -1) {
    {
#line 1482
    close(slave);
    }
  }
#line 1483
  return (pid);
}
}
#line 1537 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
int winexec(char **av ) 
{ 
  char **pp ;
  char *p ;
  char *s ;
  char *t ;
  int i ;
  int r ;
  int l ;
  struct win *w ;
  extern struct display *display___894 ;
  extern struct win *windows___895 ;
  struct pseudowin *pwin ;
  int type ;
  struct win *tmp ;
  char *tmp___896 ;
  void *__cil_tmp16 ;
  char *__cil_tmp19 ;
  int tmp___897 ;
  char *__cil_tmp24 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  int __cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  int flag ;
  int __cil_tmp35 ;
  int *__cil_tmp36 ;
  int __cil_tmp37 ;
  int *__cil_tmp38 ;

  {
#line 1542
  r = 0;
#line 1542
  l = 0;
#line 1549
  if (display___894) {
#line 1549
    tmp = fore;
  } else {
#line 1549
    tmp = windows___895;
  }
#line 1549
  w = tmp;
#line 1549
  if (w == (struct win *)((void *)0)) {
#line 1550
    return (- 1);
  }
#line 1551
  if (! *av) {
    _L: /* CIL Label */ 
#line 1553
    if (w->w_pwin) {
#line 1553
      tmp___896 = (char *)(w->w_pwin)->p_cmd;
    } else {
#line 1553
      tmp___896 = (char *)"(none)";
    }
    {
#line 1553
    Msg(0, (char const   *)((char *)"Filter running: %s"), tmp___896);
    }
#line 1554
    return (- 1);
  } else
#line 1551
  if (w->w_pwin) {
#line 1551
    goto _L;
  }
#line 1556
  if (w->w_ptyfd < 0) {
    {
#line 1558
    Msg(0, (char const   *)((char *)"You feel dead inside."));
    }
#line 1559
    return (- 1);
  }
  {
#line 1561
  __cil_tmp16 = calloc((unsigned long )1, sizeof(struct pseudowin ));
#line 1561
  pwin = (struct pseudowin *)__cil_tmp16;
  }
#line 1561
  if (! pwin) {
    {
#line 1563
    Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
#line 1564
    return (- 1);
  }
#line 1568
  s = *av;
  {
#line 1568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1568
    if (! ((int )*s == 32)) {
#line 1568
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 1568
  s ++;
#line 1570
  p = s;
  {
#line 1570
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1570
    if (! (((int )*p == 58 || (int )*p == 46) || (int )*p == 33)) {
#line 1570
      goto while_break___0;
    }

  }
  while_break___0: /* CIL Label */ ;
  }
#line 1570
  p ++;
#line 1572
  if ((int )*p != 124) {
    {
#line 1573
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1573
      if (! (((int )*p && p > s) && (int )*(p + -1) == 46)) {
#line 1573
        goto while_break___1;
      }
#line 1574
      __cil_tmp19 = p;
#line 1574
      p --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1575
  if ((int )*p == 124) {
#line 1577
    l = 4096;
#line 1578
    p ++;
  }
#line 1580
  if (*p) {
#line 1581
    *(av + 0) = p;
  } else {
#line 1583
    av ++;
  }
#line 1585
  t = (char *)pwin->p_cmd;
#line 1586
  i = 0;
  {
#line 1586
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1586
    if (! (i < 3)) {
#line 1586
      goto while_break___2;
    }
#line 1588
    if (s < p) {
#line 1588
      s ++;
#line 1588
      tmp___897 = (int )*s;
    } else {
#line 1588
      tmp___897 = '.';
    }
#line 1588
    *t = (char )tmp___897;
#line 1589
    __cil_tmp24 = t;
#line 1589
    t ++;
    {
#line 1592
    if ((int )*__cil_tmp24 == '|') {
#line 1592
      goto case_124;
    }
#line 1592
    if ((int )*__cil_tmp24 == '.') {
#line 1592
      goto case_124;
    }
#line 1595
    if ((int )*__cil_tmp24 == '!') {
#line 1595
      goto case_33;
    }
#line 1598
    if ((int )*__cil_tmp24 == ':') {
#line 1598
      goto case_58;
    }
#line 1589
    goto switch_break;
    case_124: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 1593
    l |= 1 << i * 2;
#line 1594
    goto switch_break;
    case_33: /* CIL Label */ 
#line 1596
    l |= 2 << i * 2;
#line 1597
    goto switch_break;
    case_58: /* CIL Label */ 
#line 1599
    l |= 3 << i * 2;
#line 1600
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1586
  i ++;
#line 1604
  if (l & 4096) {
#line 1606
    __cil_tmp26 = t;
#line 1606
    t ++;
#line 1606
    *__cil_tmp26 = (char )'|';
#line 1607
    if ((l & 3) == 1) {
#line 1609
      *((char *)pwin->p_cmd) = (char )'!';
#line 1610
      l ^= 3;
    }
  }
#line 1613
  if (! (l & 2)) {
#line 1614
    l |= 4096;
  }
#line 1615
  __cil_tmp27 = t;
#line 1615
  t ++;
#line 1615
  *__cil_tmp27 = (char )' ';
#line 1616
  pwin->p_fdpat = l;
  {
#line 1617
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1617
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1619
  l = 764;
#line 1620
  pp = av;
  {
#line 1620
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1620
    if (! *pp) {
#line 1620
      goto while_break___4;
    }
#line 1622
    p = *pp;
    {
#line 1623
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1623
      if (! ((int )*p && __cil_tmp28 > 0)) {
#line 1623
        goto while_break___5;
      }
#line 1624
      __cil_tmp30 = p;
#line 1624
      p ++;
#line 1624
      __cil_tmp29 = t;
#line 1624
      t ++;
#line 1624
      *__cil_tmp29 = *__cil_tmp30;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1625
    if (l <= 0) {
#line 1626
      goto while_break___4;
    }
#line 1627
    __cil_tmp31 = t;
#line 1627
    t ++;
#line 1627
    *__cil_tmp31 = (char )' ';
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1620
  pp ++;
#line 1629
  t --;
#line 1629
  *t = (char )'\000';
  {
#line 1630
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1630
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1632
  pwin->p_ptyfd = OpenDevice(av, 0, & type, & t);
  }
#line 1632
  if (pwin->p_ptyfd < 0) {
    {
#line 1634
    free((void *)((char *)pwin));
    }
#line 1635
    return (- 1);
  }
  {
#line 1637
  strncpy((char *)pwin->p_tty, (char const   *)t, (unsigned long )767);
#line 1638
  w->w_pwin = pwin;
  }
#line 1639
  if (type != 0) {
    {
#line 1641
    FreePseudowin(w);
#line 1642
    Msg(0, (char const   *)((char *)"Cannot only use commands as pseudo win."));
    }
#line 1643
    return (- 1);
  }
#line 1645
  if (! (pwin->p_fdpat & 1)) {
    {
#line 1646
    evdeq(& w->w_readev);
    }
  }
  {
#line 1649
  flag = 0;
#line 1651
  __cil_tmp35 = ioctl(pwin->p_ptyfd, (unsigned long )21536, (char *)(& flag));
  }
#line 1651
  if (__cil_tmp35) {
    {
#line 1653
    __cil_tmp36 = __errno_location();
#line 1653
    Msg(*__cil_tmp36, (char const   *)((char *)"TIOCPKT pwin ioctl"));
#line 1654
    FreePseudowin(w);
    }
#line 1655
    return (- 1);
  }
#line 1657
  if (w->w_type == 0) {
#line 1657
    if (! (pwin->p_fdpat & 1)) {
      {
#line 1659
      __cil_tmp37 = ioctl(w->w_ptyfd, (unsigned long )21536, (char *)(& flag));
      }
#line 1659
      if (__cil_tmp37) {
        {
#line 1661
        __cil_tmp38 = __errno_location();
#line 1661
        Msg(*__cil_tmp38, (char const   *)((char *)"TIOCPKT win ioctl"));
#line 1662
        FreePseudowin(w);
        }
#line 1663
        return (- 1);
      }
    }
  }
#line 1669
  pwin->p_writeev.fd = pwin->p_ptyfd;
#line 1669
  pwin->p_readev.fd = pwin->p_writeev.fd;
#line 1670
  pwin->p_readev.type = 1;
#line 1671
  pwin->p_writeev.type = 2;
#line 1672
  pwin->p_writeev.data = (char *)w;
#line 1672
  pwin->p_readev.data = pwin->p_writeev.data;
#line 1673
  pwin->p_readev.handler = pseu_readev_fn;
#line 1674
  pwin->p_writeev.handler = pseu_writeev_fn;
#line 1675
  pwin->p_writeev.condpos = & pwin->p_inlen;
#line 1676
  if (pwin->p_fdpat & ((1 << 4) | (1 << 2))) {
    {
#line 1677
    evenq(& pwin->p_readev);
    }
  }
  {
#line 1678
  evenq(& pwin->p_writeev);
#line 1679
  r = ForkWindow(w, av, t);
  }
#line 1680
  if (r < 0) {
    {
#line 1681
    FreePseudowin(w);
    }
  }
#line 1682
  return (r);
}
}
#line 1686 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
void FreePseudowin(struct win *w ) 
{ 
  struct pseudowin *pwin ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;
  int flag ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 1689
  pwin = w->w_pwin;
  {
#line 1691
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1691
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1692
  __cil_tmp3 = fcntl(w->w_ptyfd, 4, 2048);
  }
#line 1692
  if (__cil_tmp3) {
    {
#line 1693
    __cil_tmp4 = __errno_location();
#line 1693
    Msg(*__cil_tmp4, (char const   *)((char *)"Warning: FreePseudowin: NBLOCK fcntl failed"));
    }
  }
#line 1695
  if (w->w_type == 0) {
#line 1695
    if (! (pwin->p_fdpat & 1)) {
      {
#line 1697
      flag = 1;
#line 1698
      __cil_tmp6 = ioctl(w->w_ptyfd, (unsigned long )21536, (char *)(& flag));
      }
#line 1698
      if (__cil_tmp6) {
        {
#line 1699
        __cil_tmp7 = __errno_location();
#line 1699
        Msg(*__cil_tmp7, (char const   *)((char *)"Warning: FreePseudowin: TIOCPKT win ioctl"));
        }
      }
    }
  }
  {
#line 1703
  __cil_tmp8 = chmod((char const   *)((char *)pwin->p_tty), (__mode_t )438);
#line 1704
  __cil_tmp9 = chown((char const   *)((char *)pwin->p_tty), (__uid_t )0, (__gid_t )0);
  }
#line 1705
  if (pwin->p_ptyfd >= 0) {
    {
#line 1706
    close(pwin->p_ptyfd);
    }
  }
  {
#line 1707
  evdeq(& pwin->p_readev);
#line 1708
  evdeq(& pwin->p_writeev);
  }
#line 1709
  if (w->w_readev.condneg == & pwin->p_inlen) {
#line 1710
    w->w_readev.condneg = (int *)0;
#line 1710
    w->w_readev.condpos = w->w_readev.condneg;
  }
  {
#line 1711
  evenq(& w->w_readev);
#line 1712
  free((void *)((char *)pwin));
#line 1713
  w->w_pwin = (struct pseudowin *)((void *)0);
  }
  return;
}
}
#line 1724 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
int ReleaseAutoWritelock(struct display *dis , struct win *w ) 
{ 
  struct display *d ;

  {
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1728
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1732
  if (w->w_wlock == 1) {
#line 1732
    if (w->w_wlockuser == dis->d_user) {
#line 1736
      d = displays;
      {
#line 1736
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1736
        if (! d) {
#line 1736
          goto while_break___0;
        }
#line 1737
        if (d != dis) {
#line 1737
          if (d->d_fore == w) {
#line 1737
            if (d->d_user == dis->d_user) {
#line 1738
              goto while_break___0;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1736
      d = d->d_next;
      {
#line 1739
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1739
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1741
      if (! d) {
#line 1743
        w->w_wlockuser = (struct acluser *)((void *)0);
#line 1744
        return (0);
      }
    }
  }
#line 1747
  return (1);
}
}
#line 1754 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
int ObtainAutoWritelock(struct display *d , struct win *w ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 1758
  __cil_tmp3 = AclCheckPermWin(d->d_user, 1, w);
  }
#line 1758
  if (w->w_wlock == 1) {
#line 1758
    if (! __cil_tmp3) {
#line 1758
      if (! w->w_wlockuser) {
        {
#line 1762
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1762
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 1764
        w->w_wlockuser = d->d_user;
#line 1765
        return (0);
      }
    }
  }
#line 1767
  return (1);
}
}
#line 1778 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void paste_slowev_fn(struct event *ev , char *data ) 
{ 
  struct paster *pa ;
  struct win *p ;
  int l ;

  {
#line 1782
  pa = (struct paster *)data;
#line 1785
  l = 1;
#line 1786
  flayer = pa->pa_pastelayer;
#line 1787
  if (! flayer) {
#line 1788
    pa->pa_pastelen = 0;
  }
#line 1789
  if (! pa->pa_pastelen) {
#line 1790
    return;
  }
  {
#line 1791
  p = (struct win *)(flayer->l_bottom)->l_data;
#line 1792
  DoProcess(p, & pa->pa_pasteptr, & l, pa);
#line 1793
  pa->pa_pastelen -= 1 - l;
  }
#line 1794
  if (pa->pa_pastelen > 0) {
    {
#line 1796
    SetTimeout(& pa->pa_slowev, p->w_slowpaste);
#line 1797
    evenq(& pa->pa_slowev);
    }
  }
  return;
}
}
#line 1804 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static int muchpending(struct win *p , struct event *ev ) 
{ 
  struct canvas *cv ;

  {
#line 1809
  cv = p->w_layer.l_cvlist;
  {
#line 1809
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1809
    if (! cv) {
#line 1809
      goto while_break;
    }
#line 1811
    display = cv->c_display;
#line 1812
    if (display->d_status == 1) {
#line 1812
      if (! display->d_status_bell) {
        {
#line 1815
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1815
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1816
        ev->condpos = & const_one;
#line 1817
        ev->condneg = & display->d_status;
#line 1818
        return (1);
      }
    }
    {
#line 1820
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1820
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1821
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1821
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1822
    if (display->d_blocked) {
#line 1823
      goto while_continue;
    }
#line 1824
    if (display->d_obufp - display->d_obuf > (long )(display->d_obufmax + display->d_blocked_fuzz)) {
#line 1826
      if (display->d_nonblock == 0) {
        {
#line 1828
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1828
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1829
        display->d_blocked = 1;
#line 1830
        goto while_continue;
      }
      {
#line 1832
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1832
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1833
      ev->condpos = & display->d_obuffree;
#line 1834
      ev->condneg = & display->d_obuflenmax;
#line 1835
      if (display->d_nonblock > 0) {
#line 1835
        if (! display->d_blockedev.queued) {
          {
#line 1837
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1837
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 1838
          SetTimeout(& display->d_blockedev, display->d_nonblock);
#line 1839
          evenq(& display->d_blockedev);
          }
        }
      }
#line 1841
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1809
  cv = cv->c_lnext;
#line 1844
  return (0);
}
}
#line 1848 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void win_readev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char buf[4096] ;
  char *bp ;
  int size ;
  int len ;
  int wtop ;
  int __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  int *__cil_tmp11 ;
  int *__cil_tmp12 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 1852
  p = (struct win *)data;
#line 1859
  bp = (char *)buf;
#line 1860
  size = 4096;
#line 1863
  wtop = p->w_pwin && ((p->w_pwin)->p_fdpat & 3) == 3;
#line 1864
  if (wtop) {
    {
#line 1866
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1866
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1867
    size = 4096 - (p->w_pwin)->p_inlen;
#line 1868
    if (size <= 0) {
#line 1870
      ev->condpos = & const_IOSIZE;
#line 1871
      ev->condneg = & (p->w_pwin)->p_inlen;
#line 1872
      return;
    }
  }
  {
#line 1876
  __cil_tmp9 = muchpending(p, ev);
  }
#line 1876
  if (p->w_layer.l_cvlist) {
#line 1876
    if (__cil_tmp9) {
#line 1877
      return;
    }
  }
#line 1879
  if (! p->w_zdisplay) {
#line 1881
    if (p->w_blocked) {
#line 1883
      ev->condpos = & const_one;
#line 1884
      ev->condneg = & p->w_blocked;
#line 1885
      return;
    }
  }
#line 1887
  if (ev->condpos) {
#line 1888
    ev->condneg = (int *)0;
#line 1888
    ev->condpos = ev->condneg;
  }
#line 1890
  len = p->w_outlen;
#line 1890
  if (len) {
    {
#line 1892
    p->w_outlen = 0;
#line 1893
    WriteString(p, (char *)p->w_outbuf, len);
    }
#line 1894
    return;
  }
  {
#line 1897
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1897
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1898
  __cil_tmp10 = read(ev->fd, (void *)((char *)buf), (size_t )size);
#line 1898
  len = (int )__cil_tmp10;
  }
#line 1898
  if (len < 0) {
    {
#line 1900
    __cil_tmp12 = __errno_location();
    }
    {
#line 1900
    __cil_tmp11 = __errno_location();
    }
#line 1900
    if (*__cil_tmp11 == 4) {
#line 1901
      return;
    } else
#line 1900
    if (*__cil_tmp12 == 11) {
#line 1901
      return;
    }
    {
#line 1906
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1906
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1910
    WindowDied(p, 0, 0);
    }
#line 1912
    return;
  }
#line 1914
  if (len == 0) {
    {
#line 1916
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1916
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1920
    WindowDied(p, 0, 0);
    }
#line 1922
    return;
  }
  {
#line 1924
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1924
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1926
  if (p->w_type == 0) {
#line 1928
    if (buf[0]) {
      {
#line 1930
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1930
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1931
      if ((int )buf[0] & 16) {
        {
#line 1932
        WNewAutoFlow(p, 0);
        }
      }
#line 1933
      if ((int )buf[0] & 32) {
        {
#line 1934
        WNewAutoFlow(p, 1);
        }
      }
    }
#line 1936
    bp ++;
#line 1937
    __cil_tmp14 = len;
#line 1937
    len --;
  }
#line 1944
  if (len == 0) {
#line 1945
    return;
  }
  {
#line 1947
  __cil_tmp15 = zmodem_parse(p, bp, len);
  }
#line 1947
  if (zmodem_mode) {
#line 1947
    if (__cil_tmp15) {
#line 1948
      return;
    }
  }
#line 1951
  if (wtop) {
    {
#line 1953
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1953
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1954
    bcopy((void const   *)bp, (void *)((char *)(p->w_pwin)->p_inbuf + (p->w_pwin)->p_inlen),
          (size_t )len);
#line 1955
    (p->w_pwin)->p_inlen += len;
    }
  }
  {
#line 1959
  LayPause(& p->w_layer, 1);
#line 1960
  WriteString(p, bp, len);
#line 1961
  LayPause(& p->w_layer, 0);
  }
#line 1963
  return;
}
}
#line 1967 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void win_resurrect_zombie_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;

  {
#line 1971
  p = (struct win *)data;
  {
#line 1972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1972
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1975
  if (p->w_deadpid != p->w_pid) {
#line 1976
    return;
  }
  {
#line 1977
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1977
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1978
  WriteString(p, (char *)"\r\n", 2);
#line 1979
  RemakeWindow(p);
  }
  return;
}
}
#line 1983 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void win_writeev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  int len ;
  ssize_t __cil_tmp5 ;
  struct paster *pa ;

  {
#line 1987
  p = (struct win *)data;
#line 1989
  if (p->w_inlen) {
    {
#line 1991
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1991
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1992
    __cil_tmp5 = write(ev->fd, (void const   *)((char *)p->w_inbuf), (size_t )p->w_inlen);
#line 1992
    len = (int )__cil_tmp5;
    }
#line 1992
    if (len <= 0) {
#line 1993
      len = p->w_inlen;
    }
#line 1994
    p->w_inlen -= len;
#line 1994
    if (p->w_inlen) {
      {
#line 1995
      bcopy((void const   *)((char *)p->w_inbuf + len), (void *)((char *)p->w_inbuf),
            (size_t )p->w_inlen);
      }
    }
  }
#line 1998
  if (p->w_paster.pa_pastelen) {
#line 1998
    if (! p->w_slowpaste) {
#line 2000
      pa = & p->w_paster;
#line 2001
      flayer = pa->pa_pastelayer;
#line 2002
      if (flayer) {
        {
#line 2003
        DoProcess(p, & pa->pa_pasteptr, & pa->pa_pastelen, pa);
        }
      }
    }
  }
#line 2006
  return;
}
}
#line 2014 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void pseu_readev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char buf[4096] ;
  int size ;
  int ptow ;
  int len ;
  int __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
#line 2018
  p = (struct win *)data;
#line 2022
  size = 4096;
#line 2024
  ptow = ((p->w_pwin)->p_fdpat & (3 << 2)) == 3 << 2 || ((p->w_pwin)->p_fdpat & (3 << 4)) == 3 << 4;
#line 2025
  if (ptow) {
    {
#line 2027
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2027
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 2028
    size = 4096 - p->w_inlen;
#line 2029
    if (size <= 0) {
#line 2031
      ev->condpos = & const_IOSIZE;
#line 2032
      ev->condneg = & p->w_inlen;
#line 2033
      return;
    }
  }
  {
#line 2036
  __cil_tmp8 = muchpending(p, ev);
  }
#line 2036
  if (p->w_layer.l_cvlist) {
#line 2036
    if (__cil_tmp8) {
#line 2037
      return;
    }
  }
#line 2038
  if (p->w_blocked) {
#line 2040
    ev->condpos = & const_one;
#line 2041
    ev->condneg = & p->w_blocked;
#line 2042
    return;
  }
#line 2044
  if (ev->condpos) {
#line 2045
    ev->condneg = (int *)0;
#line 2045
    ev->condpos = ev->condneg;
  }
#line 2047
  len = p->w_outlen;
#line 2047
  if (len) {
    {
#line 2049
    p->w_outlen = 0;
#line 2050
    WriteString(p, (char *)p->w_outbuf, len);
    }
#line 2051
    return;
  }
  {
#line 2054
  __cil_tmp9 = read(ev->fd, (void *)((char *)buf), (size_t )size);
#line 2054
  len = (int )__cil_tmp9;
  }
#line 2054
  if (len <= 0) {
    {
#line 2056
    __cil_tmp11 = __errno_location();
    }
    {
#line 2056
    __cil_tmp10 = __errno_location();
    }
#line 2056
    if (*__cil_tmp10 == 4) {
#line 2057
      return;
    } else
#line 2056
    if (*__cil_tmp11 == 11) {
#line 2057
      return;
    }
    {
#line 2062
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2062
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2063
    FreePseudowin(p);
    }
#line 2064
    return;
  }
#line 2067
  if (ptow) {
    {
#line 2069
    bcopy((void const   *)((char *)buf), (void *)((char *)p->w_inbuf + p->w_inlen),
          (size_t )len);
#line 2070
    p->w_inlen += len;
    }
  }
  {
#line 2072
  WriteString(p, (char *)buf, len);
  }
#line 2073
  return;
}
}
#line 2077 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void pseu_writeev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  struct pseudowin *pw ;
  int len ;
  ssize_t __cil_tmp6 ;

  {
#line 2081
  p = (struct win *)data;
#line 2082
  pw = p->w_pwin;
  {
#line 2085
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2085
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2086
  if (pw->p_inlen == 0) {
#line 2087
    return;
  }
  {
#line 2088
  __cil_tmp6 = write(ev->fd, (void const   *)((char *)pw->p_inbuf), (size_t )pw->p_inlen);
#line 2088
  len = (int )__cil_tmp6;
  }
#line 2088
  if (len <= 0) {
#line 2089
    len = pw->p_inlen;
  }
#line 2090
  (p->w_pwin)->p_inlen -= len;
#line 2090
  if ((p->w_pwin)->p_inlen) {
    {
#line 2091
    bcopy((void const   *)((char *)(p->w_pwin)->p_inbuf + len), (void *)((char *)(p->w_pwin)->p_inbuf),
          (size_t )(p->w_pwin)->p_inlen);
    }
  }
  return;
}
}
#line 2098 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void win_silenceev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  struct canvas *cv ;

  {
#line 2102
  p = (struct win *)data;
  {
#line 2104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2105
  display = displays;
  {
#line 2105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2105
    if (! display) {
#line 2105
      goto while_break___0;
    }
#line 2107
    cv = display->d_cvlist;
    {
#line 2107
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2107
      if (! cv) {
#line 2107
        goto while_break___1;
      }
#line 2108
      if ((cv->c_layer)->l_bottom == & p->w_layer) {
#line 2109
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2107
    cv = cv->c_next;
#line 2110
    if (cv) {
#line 2111
      goto while_continue___0;
    }
#line 2113
    if (! ((int )*(p->w_lio_notify + ((display->d_user)->u_id >> 3)) & (128 >> ((display->d_user)->u_id & 7)))) {
#line 2114
      goto while_continue___0;
    }
    {
#line 2116
    Msg(0, (char const   *)((char *)"Window %d: silence for %d seconds"), p->w_number,
        p->w_silencewait);
#line 2117
    p->w_silence = 2;
#line 2118
    WindowChanged(p, 'f');
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2105
  display = display->d_next;
  return;
}
}
#line 2123 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void win_destroyev_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;

  {
  {
#line 2127
  p = (struct win *)ev->data;
#line 2128
  WindowDied(p, p->w_exitstatus, 1);
  }
  return;
}
}
#line 2134 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static int zmodem_parse(struct win *p , char *bp , int len ) 
{ 
  int i ;
  char *b2 ;
  int __cil_tmp6 ;
  char *__cil_tmp7 ;
  int se ;
  int tmp ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int tmp___898 ;
  int tmp___899 ;
  int tmp___900 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int tmp___901 ;
  int __cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 2140
  b2 = bp;
#line 2141
  i = 0;
  {
#line 2141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2141
    if (! (i < len)) {
#line 2141
      goto while_break;
    }
#line 2143
    if (p->w_zauto == 0) {
      {
#line 2145
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2145
        if (! (i < len)) {
#line 2145
          goto while_break___0;
        }
#line 2146
        if ((int )*b2 == 24) {
#line 2147
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2145
      __cil_tmp7 = b2;
#line 2145
      b2 ++;
#line 2145
      __cil_tmp6 = i;
#line 2145
      i ++;
#line 2148
      if (i == len) {
#line 2149
        goto while_break;
      }
#line 2150
      if (i > 1) {
#line 2150
        if ((int )*(b2 + -1) == 42) {
#line 2150
          if ((int )*(b2 + -2) == 42) {
#line 2151
            p->w_zauto = 3;
          }
        }
      }
#line 2152
      goto while_continue;
    }
#line 2154
    if (p->w_zauto > 5) {
      _L___900: /* CIL Label */ 
#line 2156
      (p->w_zauto) ++;
#line 2156
      if (p->w_zauto < 6) {
#line 2157
        goto while_continue;
      }
#line 2158
      if (p->w_zauto == 6) {
#line 2159
        p->w_zauto = 0;
      }
#line 2160
      if (! p->w_zdisplay) {
#line 2162
        if (i > 6) {
          {
#line 2163
          WriteString(p, bp, (i + 1) - 6);
          }
        }
        {
#line 2164
        WriteString(p, (char *)"\r\n", 2);
#line 2165
        zmodem_found(p, (int )*b2 == 49, b2 + 1, (len - i) - 1);
        }
#line 2166
        return (1);
      } else
#line 2168
      if (p->w_zauto == 7) {
        _L: /* CIL Label */ 
#line 2170
        if ((p->w_zdisplay)->d_blocked == 2) {
#line 2170
          tmp = 'O';
        } else {
#line 2170
          tmp = (int )4294967178U;
        }
#line 2170
        se = (int )tmp;
        {
#line 2171
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2171
          if (! (i < len)) {
#line 2171
            goto while_break___1;
          }
#line 2172
          if ((int )*b2 == se) {
#line 2173
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2171
        __cil_tmp11 = b2;
#line 2171
        b2 ++;
#line 2171
        __cil_tmp10 = i;
#line 2171
        i ++;
#line 2174
        if (i < len) {
          {
#line 2176
          zmodem_abort(p, (struct display *)0);
#line 2177
          display->d_blocked = 0;
#line 2178
          display->d_readev.condneg = (int *)0;
#line 2178
          display->d_readev.condpos = display->d_readev.condneg;
          }
          {
#line 2179
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2179
            if (! (__cil_tmp12 > 0)) {
#line 2179
              goto while_break___2;
            }
            {
#line 2180
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2180
              (display->d_obuffree) --;
#line 2180
              if (display->d_obuffree <= 0) {
                {
#line 2180
                Resize_obuf();
                }
              }
#line 2180
              __cil_tmp14 = bp;
#line 2180
              bp ++;
#line 2180
              __cil_tmp13 = display->d_obufp;
#line 2180
              (display->d_obufp) ++;
#line 2180
              *__cil_tmp13 = *__cil_tmp14;
#line 2180
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 2181
          Flush(0);
          }
#line 2182
          if (display->d_fore) {
#line 2182
            tmp___898 = (int )(display->d_fore)->w_norefresh;
          } else {
#line 2182
            tmp___898 = 0;
          }
          {
#line 2182
          Activate(tmp___898);
          }
#line 2183
          return (1);
        }
#line 2185
        p->w_zauto = 6;
      } else
#line 2168
      if ((int )*b2 == 56) {
#line 2168
        goto _L;
      }
    } else
#line 2154
    if ((int )*b2 == (int )*((char *)"**\030B00" + p->w_zauto)) {
#line 2154
      goto _L___900;
    } else
#line 2154
    if (p->w_zauto == 5) {
#line 2154
      if ((int )*b2 == 49) {
#line 2154
        goto _L___900;
      } else {
#line 2154
        goto _L___904;
      }
    } else
    _L___904: /* CIL Label */ 
#line 2154
    if (p->w_zauto == 5) {
#line 2154
      if (p->w_zdisplay) {
#line 2154
        if ((int )*b2 == 56) {
#line 2154
          goto _L___900;
        } else {
#line 2154
          goto _L___901;
        }
      } else {
#line 2154
        goto _L___901;
      }
    } else {
      _L___901: /* CIL Label */ 
#line 2189
      if ((int )*b2 == 42) {
#line 2189
        if (p->w_zauto == 2) {
#line 2189
          tmp___899 = 2;
        } else {
#line 2189
          tmp___899 = 1;
        }
#line 2189
        tmp___900 = tmp___899;
      } else {
#line 2189
        tmp___900 = 0;
      }
#line 2189
      p->w_zauto = tmp___900;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2141
  __cil_tmp19 = b2;
#line 2141
  b2 ++;
#line 2141
  __cil_tmp18 = i;
#line 2141
  i ++;
#line 2191
  if (p->w_zauto == 0) {
#line 2191
    if ((int )*(bp + (len - 1)) == 42) {
#line 2192
      if (len > 1 && (int )*(bp + (len - 2)) == 42) {
#line 2192
        tmp___901 = 2;
      } else {
#line 2192
        tmp___901 = 1;
      }
#line 2192
      p->w_zauto = tmp___901;
    }
  }
#line 2193
  if (p->w_zdisplay) {
#line 2195
    display = p->w_zdisplay;
    {
#line 2196
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2196
      if (! (__cil_tmp21 > 0)) {
#line 2196
        goto while_break___4;
      }
      {
#line 2197
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2197
        (display->d_obuffree) --;
#line 2197
        if (display->d_obuffree <= 0) {
          {
#line 2197
          Resize_obuf();
          }
        }
#line 2197
        __cil_tmp23 = bp;
#line 2197
        bp ++;
#line 2197
        __cil_tmp22 = display->d_obufp;
#line 2197
        (display->d_obufp) ++;
#line 2197
        *__cil_tmp22 = *__cil_tmp23;
#line 2197
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2198
    return (1);
  }
#line 2200
  return (0);
}
}
#line 2204 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void zmodem_fin(char *buf , int len , char *data ) 
{ 
  char *s ;
  int n ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;

  {
#line 2212
  if (len) {
    {
#line 2213
    __cil_tmp6 = strlen((char const   *)buf);
#line 2213
    RcLine(buf, (int )(__cil_tmp6 + 1UL));
    }
  } else {
    {
#line 2216
    s = (char *)"\030\030\030\030\030\030\030\030\030\030";
#line 2217
    __cil_tmp7 = strlen((char const   *)s);
#line 2217
    n = (int )__cil_tmp7;
#line 2218
    (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
    }
  }
  return;
}
}
#line 2223 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
static void zmodem_found(struct win *p , int send , char *bp , int len ) 
{ 
  char *s ;
  int i ;
  int n ;
  extern int zmodem_mode___906 ;
  struct display *d ;
  struct display *olddisplay ;
  char *tmp ;
  int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *tmp___0 ;
  size_t __cil_tmp17 ;

  {
#line 2234
  n = 0;
#line 2235
  i = 0;
  {
#line 2235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2235
    if (! (i < len)) {
#line 2235
      goto while_break;
    }
#line 2236
    if ((int )*(bp + i) != 24) {
#line 2237
      n = 0;
    } else {
#line 2238
      n ++;
#line 2238
      if (n > 4) {
#line 2239
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2235
  i ++;
#line 2240
  if (zmodem_mode___906 == 3) {
    _L___907: /* CIL Label */ 
#line 2244
    olddisplay = display;
#line 2245
    d = p->w_lastdisp;
#line 2246
    if (! d) {
      _L: /* CIL Label */ 
#line 2247
      d = displays;
      {
#line 2247
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2247
        if (! d) {
#line 2247
          goto while_break___0;
        }
#line 2248
        if (d->d_fore == p) {
#line 2249
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2247
      d = d->d_next;
    } else
#line 2246
    if (d->d_fore != p) {
#line 2246
      goto _L;
    }
#line 2250
    if (! d) {
#line 2250
      if (p->w_layer.l_cvlist) {
#line 2251
        d = (p->w_layer.l_cvlist)->c_display;
      }
    }
#line 2252
    if (! d) {
#line 2253
      d = displays;
    }
#line 2254
    if (! d) {
#line 2255
      return;
    }
    {
#line 2256
    display = d;
#line 2257
    RemoveStatus();
#line 2258
    p->w_zdisplay = display;
#line 2259
    display->d_blocked = 2 + send;
#line 2260
    flayer = & p->w_layer;
#line 2261
    ZmodemPage();
#line 2262
    display = d;
#line 2263
    evdeq(& display->d_blockedev);
#line 2264
    display->d_readev.condpos = & const_IOSIZE;
#line 2265
    display->d_readev.condneg = & p->w_inlen;
#line 2266
    ClearAll();
#line 2267
    GotoPos(0, 0);
#line 2268
    SetRendition(& mchar_blank);
#line 2269
    AddStr((char *)"Zmodem active\r\n\r\n");
    }
#line 2270
    if (send) {
#line 2270
      tmp = (char *)"**\030B01";
    } else {
#line 2270
      tmp = (char *)"**\030B00";
    }
    {
#line 2270
    AddStr(tmp);
    }
    {
#line 2271
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2271
      if (! (__cil_tmp13 > 0)) {
#line 2271
        goto while_break___1;
      }
      {
#line 2272
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2272
        (display->d_obuffree) --;
#line 2272
        if (display->d_obuffree <= 0) {
          {
#line 2272
          Resize_obuf();
          }
        }
#line 2272
        __cil_tmp15 = bp;
#line 2272
        bp ++;
#line 2272
        __cil_tmp14 = display->d_obufp;
#line 2272
        (display->d_obufp) ++;
#line 2272
        *__cil_tmp14 = *__cil_tmp15;
#line 2272
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2273
    display = olddisplay;
#line 2274
    return;
  } else
#line 2240
  if (zmodem_mode___906 == 1) {
#line 2240
    if (p->w_type != 1) {
#line 2240
      goto _L___907;
    }
  }
  {
#line 2276
  flayer = & p->w_layer;
#line 2277
  Input((char *)":", 768, 0, zmodem_fin, (char *)((void *)0), 0);
  }
#line 2278
  if (send) {
#line 2278
    tmp___0 = zmodem_sendcmd;
  } else {
#line 2278
    tmp___0 = zmodem_recvcmd;
  }
  {
#line 2278
  s = tmp___0;
#line 2279
  __cil_tmp17 = strlen((char const   *)s);
#line 2279
  n = (int )__cil_tmp17;
#line 2280
  (*((flayer->l_layfn)->lf_LayProcess))(& s, & n);
  }
  return;
}
}
#line 2284 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
void zmodem_abort(struct win *p , struct display *d ) 
{ 
  struct display *olddisplay ;
  struct layer *oldflayer ;
  int tmp ;

  {
#line 2288
  olddisplay = display;
#line 2289
  oldflayer = flayer;
#line 2290
  if (p) {
#line 2292
    if (p->w_savelayer) {
#line 2292
      if ((p->w_savelayer)->l_next) {
#line 2294
        if (oldflayer == p->w_savelayer) {
#line 2295
          oldflayer = flayer->l_next;
        }
        {
#line 2296
        flayer = p->w_savelayer;
#line 2297
        ExitOverlayPage();
        }
      }
    }
    {
#line 2299
    p->w_zdisplay = (struct display *)0;
#line 2300
    p->w_zauto = 0;
#line 2301
    LRefreshAll(& p->w_layer, 0);
    }
  }
#line 2303
  if (d) {
#line 2305
    display = d;
#line 2306
    display->d_blocked = 0;
#line 2307
    display->d_readev.condneg = (int *)0;
#line 2307
    display->d_readev.condpos = display->d_readev.condneg;
#line 2308
    if (display->d_fore) {
#line 2308
      tmp = (int )(display->d_fore)->w_norefresh;
    } else {
#line 2308
      tmp = 0;
    }
    {
#line 2308
    Activate(tmp);
    }
  }
#line 2310
  display = olddisplay;
#line 2311
  flayer = oldflayer;
  return;
}
}
#line 2317 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/window.c"
int WindowChangeNumber(int old , int dest ) 
{ 
  struct win *p ;
  struct win *win_old ;
  struct display *tmp ;

  {
#line 2321
  if (dest < 0) {
    {
    {
#line 2323
    Msg(0, (char const   *)((char *)"Given window position is invalid."));
    }
    }
#line 2324
    return (0);
  } else
#line 2321
  if (dest >= maxwin) {
    {
    {
#line 2323
    Msg(0, (char const   *)((char *)"Given window position is invalid."));
    }
    }
#line 2324
    return (0);
  }
#line 2327
  win_old = *(wtab + old);
#line 2328
  p = *(wtab + dest);
#line 2329
  *(wtab + dest) = win_old;
#line 2330
  win_old->w_number = dest;
#line 2331
  *(wtab + old) = p;
#line 2332
  if (p) {
#line 2333
    p->w_number = old;
  }
  {
#line 2336
  AclWinSwap(old, dest);
  }
#line 2340
  if (win_old->w_slot != (slot_t )-1) {
#line 2340
    if (win_old->w_slot != (slot_t )0) {
      {
#line 2342
      RemoveUtmp(win_old);
#line 2343
      SetUtmp(win_old);
      }
    }
  }
#line 2345
  if (p) {
#line 2345
    if (p->w_slot != (slot_t )-1) {
#line 2345
      if (p->w_slot != (slot_t )0) {
#line 2347
        if (win_old->w_layer.l_cvlist) {
#line 2347
          tmp = (win_old->w_layer.l_cvlist)->c_display;
        } else {
#line 2347
          tmp = (struct display *)0;
        }
        {
#line 2347
        display = tmp;
#line 2348
        RemoveUtmp(p);
#line 2349
        SetUtmp(p);
        }
      }
    }
  }
  {
#line 2353
  WindowChanged(win_old, 'n');
#line 2354
  WindowChanged((struct win *)0, 'w');
#line 2355
  WindowChanged((struct win *)0, 'W');
#line 2356
  WindowChanged((struct win *)0, 0);
  }
#line 2357
  return (1);
}
}
#line 670 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 782
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 844
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 54 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios *__termios_p ) ;
#line 80
extern  __attribute__((__nothrow__)) int tcsendbreak(int __fd , int __duration ) ;
#line 94
extern  __attribute__((__nothrow__)) int tcflow(int __fd , int __action ) ;
#line 88 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
int secopen(char *name , int flags , int mode ) ;
#line 100
void GetTTY(int fd , struct mode *mp ) ;
#line 102
void SetMode(struct mode *op , struct mode *np , int flow , int interrupt ) ;
#line 113
int SetBaud(struct mode *m , int ibaud , int obaud ) ;
#line 114
int SttyMode(struct mode *m , char *opt ) ;
#line 370
int UserContext(void) ;
#line 371
void UserReturn(int val ) ;
#line 372
int UserStatus(void) ;
#line 75 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
static void consredir_readev_fn(struct event *ev , char *data ) ;
#line 78 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
int separate_sids  =    1;
#line 80
static void DoSendBreak(int fd , int n , int type ) ;
#line 81
static void SigAlrmDummy(int sigsig ) ;
#line 108 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
static void SigAlrmDummy(int sigsig ) 
{ 


  {
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 120 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
int OpenTTY(char *line , char *opt ) 
{ 
  int f ;
  struct mode Mode ;
  void (*sigalrm)(int  ) ;
  int *__cil_tmp8 ;
  int *__cil_tmp9 ;
  int __cil_tmp10 ;
  int *__cil_tmp11 ;
  int __cil_tmp12 ;
  int *__cil_tmp13 ;
  int mcs ;

  {
  {
#line 127
  sigalrm = xsignal(14, SigAlrmDummy);
#line 128
  alarm((unsigned int )2);
#line 131
  f = secopen(line, 2306, 0);
  }
#line 131
  if (f == -1) {
    {
#line 133
    __cil_tmp8 = __errno_location();
    }
#line 133
    if (*__cil_tmp8 == 4) {
      {
#line 134
      Msg(0, (char const   *)((char *)"Cannot open line \'%s\' for R/W: open() blocked, aborted."),
          line);
      }
    } else {
      {
#line 136
      __cil_tmp9 = __errno_location();
#line 136
      Msg(*__cil_tmp9, (char const   *)((char *)"Cannot open line \'%s\' for R/W"),
          line);
      }
    }
    {
#line 137
    alarm((unsigned int )0);
#line 138
    xsignal(14, sigalrm);
    }
#line 139
    return (- 1);
  }
  {
#line 141
  __cil_tmp10 = isatty(f);
  }
#line 141
  if (! __cil_tmp10) {
    {
#line 143
    Msg(0, (char const   *)((char *)"\'%s\' is not a tty"), line);
#line 144
    alarm((unsigned int )0);
#line 145
    xsignal(14, sigalrm);
#line 146
    close(f);
    }
#line 147
    return (- 1);
  }
  {
#line 160
  __cil_tmp11 = __errno_location();
#line 160
  *__cil_tmp11 = 0;
#line 161
  __cil_tmp12 = ioctl(f, (unsigned long )21516, (char *)0);
  }
#line 161
  if (__cil_tmp12 < 0) {
    {
#line 162
    __cil_tmp13 = __errno_location();
#line 162
    Msg(*__cil_tmp13, (char const   *)((char *)"%s: ioctl TIOCEXCL failed"), line);
    }
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 177
  InitTTY(& Mode, 1);
#line 179
  SttyMode(& Mode, opt);
#line 183
  SetTTY(f, & Mode);
#line 187
  mcs = 0;
#line 188
  ioctl(f, (unsigned long )21525, & mcs);
#line 189
  mcs |= 4;
#line 190
  ioctl(f, (unsigned long )21528, & mcs);
#line 194
  brktty(f);
#line 195
  alarm((unsigned int )0);
#line 196
  xsignal(14, sigalrm);
  }
  {
#line 197
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 197
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 198
  return (f);
}
}
#line 207 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
void InitTTY(struct mode *m , int ttyflag ) 
{ 


  {
  {
#line 211
  bzero((void *)((char *)m), sizeof(*m));
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  m->tio.c_iflag |= (unsigned int )2;
#line 221
  m->tio.c_iflag |= (unsigned int )4;
#line 225
  m->tio.c_iflag |= (unsigned int )1024;
#line 229
  if (! ttyflag) {
#line 232
    m->tio.c_iflag |= (unsigned int )256;
#line 235
    m->tio.c_oflag |= (unsigned int )4;
#line 238
    m->tio.c_oflag |= (unsigned int )6144;
#line 245
    m->tio.c_oflag |= (unsigned int )1;
  }
  {
#line 261
  cfsetospeed(& m->tio, (speed_t )13);
#line 264
  cfsetispeed(& m->tio, (speed_t )13);
#line 268
  m->tio.c_cflag |= (unsigned int )48;
#line 271
  m->tio.c_cflag |= (unsigned int )128;
#line 274
  m->tio.c_cflag |= (unsigned int )2048;
#line 278
  m->tio.c_lflag |= (unsigned int )512;
#line 281
  m->tio.c_lflag |= (unsigned int )2048;
  }
#line 284
  if (! ttyflag) {
#line 287
    m->tio.c_lflag |= (unsigned int )1;
#line 290
    m->tio.c_lflag |= (unsigned int )2;
#line 293
    m->tio.c_lflag |= (unsigned int )8;
  }
#line 297
  m->tio.c_lflag |= (unsigned int )16;
#line 300
  m->tio.c_lflag |= (unsigned int )32;
#line 303
  m->tio.c_lflag |= (unsigned int )32768;
#line 308
  m->tio.c_cc[0] = (cc_t )3;
#line 313
  m->tio.c_cc[1] = (cc_t )28;
#line 318
  m->tio.c_cc[2] = (cc_t )127;
#line 323
  m->tio.c_cc[3] = (cc_t )21;
#line 328
  m->tio.c_cc[4] = (cc_t )4;
#line 333
  m->tio.c_cc[11] = (cc_t )'\000';
#line 338
  m->tio.c_cc[16] = (cc_t )'\000';
#line 348
  m->tio.c_cc[8] = (cc_t )17;
#line 353
  m->tio.c_cc[9] = (cc_t )19;
#line 358
  m->tio.c_cc[10] = (cc_t )26;
#line 368
  m->tio.c_cc[12] = (cc_t )18;
#line 373
  m->tio.c_cc[13] = (cc_t )15;
#line 378
  m->tio.c_cc[14] = (cc_t )23;
#line 383
  m->tio.c_cc[15] = (cc_t )22;
#line 392
  if (ttyflag) {
#line 394
    m->tio.c_cc[6] = (cc_t )100;
#line 395
    m->tio.c_cc[5] = (cc_t )2;
  }
  return;
}
}
#line 589 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
void SetTTY(int fd , struct mode *mp ) 
{ 
  int *__cil_tmp3 ;
  int *__cil_tmp4 ;
  int *__cil_tmp5 ;

  {
  {
#line 593
  __cil_tmp3 = __errno_location();
#line 593
  *__cil_tmp3 = 0;
#line 595
  tcsetattr(fd, 1, & mp->tio);
#line 623
  __cil_tmp4 = __errno_location();
  }
#line 623
  if (*__cil_tmp4) {
    {
#line 624
    __cil_tmp5 = __errno_location();
#line 624
    Msg(*__cil_tmp5, (char const   *)((char *)"SetTTY (fd %d): ioctl failed"), fd);
    }
  }
  return;
}
}
#line 628 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
void GetTTY(int fd , struct mode *mp ) 
{ 
  int *__cil_tmp3 ;
  int *__cil_tmp4 ;
  int *__cil_tmp5 ;

  {
  {
#line 632
  __cil_tmp3 = __errno_location();
#line 632
  *__cil_tmp3 = 0;
#line 634
  tcgetattr(fd, & mp->tio);
#line 667
  __cil_tmp4 = __errno_location();
  }
#line 667
  if (*__cil_tmp4) {
    {
#line 668
    __cil_tmp5 = __errno_location();
#line 668
    Msg(*__cil_tmp5, (char const   *)((char *)"GetTTY (fd %d): ioctl failed"), fd);
    }
  }
  return;
}
}
#line 675 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
void SetMode(struct mode *op , struct mode *np , int flow , int interrupt ) 
{ 


  {
#line 679
  *np = *op;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 681
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 689
  np->tio.c_iflag &= (unsigned int )(~ 256);
#line 692
  np->tio.c_iflag &= (unsigned int )(~ 32);
#line 695
  np->tio.c_oflag &= (unsigned int )(~ 4);
#line 697
  np->tio.c_lflag &= (unsigned int )(~ 10);
#line 703
  np->tio.c_lflag &= (unsigned int )(~ 32768);
#line 715
  if (interrupt) {
#line 716
    np->tio.c_lflag |= (unsigned int )1;
  } else {
#line 718
    np->tio.c_lflag &= (unsigned int )(~ 1);
  }
#line 727
  np->tio.c_cc[6] = (cc_t )1;
#line 728
  np->tio.c_cc[5] = (cc_t )0;
#line 729
  if (! interrupt) {
#line 730
    np->tio.c_cc[0] = (cc_t )'\000';
  } else
#line 729
  if (! flow) {
#line 730
    np->tio.c_cc[0] = (cc_t )'\000';
  }
#line 731
  np->tio.c_cc[1] = (cc_t )'\000';
#line 732
  if (flow == 0) {
#line 736
    np->tio.c_cc[8] = (cc_t )'\000';
#line 741
    np->tio.c_cc[9] = (cc_t )'\000';
#line 744
    np->tio.c_iflag &= (unsigned int )(~ 1024);
  }
#line 748
  np->tio.c_cc[13] = (cc_t )'\000';
#line 753
  np->tio.c_cc[15] = (cc_t )'\000';
#line 763
  np->tio.c_cc[10] = (cc_t )'\000';
#line 770
  np->tio.c_cc[2] = (cc_t )127;
#line 775
  np->tio.c_cc[3] = (cc_t )'\000';
#line 793
  np->tio.c_cc[12] = (cc_t )'\000';
#line 798
  np->tio.c_cc[14] = (cc_t )'\000';
  return;
}
}
#line 826 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
void SetFlow(int on ) 
{ 
  int tmp ;
  int __cil_tmp3 ;

  {
  {
#line 829
  while (1) {
    while_continue: /* CIL Label */ ;
#line 829
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  if (display->d_flow == on) {
#line 831
    return;
  }
#line 833
  if (on) {
#line 835
    if (iflag) {
#line 835
      tmp = (int )display->d_OldMode.tio.c_cc[0];
    } else {
#line 835
      tmp = '\000';
    }
#line 835
    display->d_NewMode.tio.c_cc[0] = (cc_t )tmp;
#line 838
    display->d_NewMode.tio.c_cc[8] = display->d_OldMode.tio.c_cc[8];
#line 843
    display->d_NewMode.tio.c_cc[9] = display->d_OldMode.tio.c_cc[9];
#line 846
    display->d_NewMode.tio.c_iflag |= display->d_OldMode.tio.c_iflag & 1024U;
  } else {
#line 850
    display->d_NewMode.tio.c_cc[0] = (cc_t )'\000';
#line 853
    display->d_NewMode.tio.c_cc[8] = (cc_t )'\000';
#line 858
    display->d_NewMode.tio.c_cc[9] = (cc_t )'\000';
#line 861
    display->d_NewMode.tio.c_iflag &= (unsigned int )(~ 1024);
  }
#line 865
  if (! on) {
    {
#line 866
    tcflow(display->d_userfd, 1);
    }
  }
  {
#line 868
  __cil_tmp3 = tcsetattr(display->d_userfd, 0, & display->d_NewMode.tio);
  }
#line 868
  if (__cil_tmp3) {
    {
#line 872
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 872
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 889
  display->d_flow = on;
  return;
}
}
#line 894 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
int SttyMode(struct mode *m , char *opt ) 
{ 
  static char const   sep[] ;
  char *__cil_tmp4 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 898
  sep = " \t:;,";
#line 900
  if (! opt) {
#line 901
    return (0);
  }
  {
#line 903
  while (1) {
    while_continue: /* CIL Label */ ;
#line 903
    if (! *opt) {
#line 903
      goto while_break;
    }
    {
#line 905
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 905
      if (! __cil_tmp4) {
#line 905
        goto while_break___0;
      }
#line 905
      opt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 906
    if ((int )*opt >= 48) {
#line 906
      if ((int )*opt <= 57) {
        {
#line 908
        __cil_tmp6 = atoi((char const   *)opt);
        }
        {
#line 908
        __cil_tmp7 = atoi((char const   *)opt);
#line 908
        __cil_tmp8 = SetBaud(m, __cil_tmp6, __cil_tmp7);
        }
#line 908
        if (__cil_tmp8) {
#line 909
          return (- 1);
        }
      } else {
#line 906
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 911
      __cil_tmp9 = strncmp((char const   *)((char *)"cs7"), (char const   *)opt, (unsigned long )3);
      }
#line 911
      if (! __cil_tmp9) {
#line 914
        m->tio.c_cflag &= (unsigned int )(~ 48);
#line 915
        m->tio.c_cflag |= (unsigned int )32;
      } else {
        {
#line 920
        __cil_tmp10 = strncmp((char const   *)((char *)"cs8"), (char const   *)opt,
                              (unsigned long )3);
        }
#line 920
        if (! __cil_tmp10) {
#line 923
          m->tio.c_cflag &= (unsigned int )(~ 48);
#line 924
          m->tio.c_cflag |= (unsigned int )48;
        } else {
          {
#line 929
          __cil_tmp11 = strncmp((char const   *)((char *)"istrip"), (char const   *)opt,
                                (unsigned long )6);
          }
#line 929
          if (! __cil_tmp11) {
#line 932
            m->tio.c_iflag |= (unsigned int )32;
          } else {
            {
#line 937
            __cil_tmp12 = strncmp((char const   *)((char *)"-istrip"), (char const   *)opt,
                                  (unsigned long )7);
            }
#line 937
            if (! __cil_tmp12) {
#line 940
              m->tio.c_iflag &= (unsigned int )(~ 32);
            } else {
              {
#line 945
              __cil_tmp13 = strncmp((char const   *)((char *)"ixon"), (char const   *)opt,
                                    (unsigned long )4);
              }
#line 945
              if (! __cil_tmp13) {
#line 948
                m->tio.c_iflag |= (unsigned int )1024;
              } else {
                {
#line 953
                __cil_tmp14 = strncmp((char const   *)((char *)"-ixon"), (char const   *)opt,
                                      (unsigned long )5);
                }
#line 953
                if (! __cil_tmp14) {
#line 956
                  m->tio.c_iflag &= (unsigned int )(~ 1024);
                } else {
                  {
#line 961
                  __cil_tmp15 = strncmp((char const   *)((char *)"ixoff"), (char const   *)opt,
                                        (unsigned long )5);
                  }
#line 961
                  if (! __cil_tmp15) {
#line 964
                    m->tio.c_iflag |= (unsigned int )4096;
                  } else {
                    {
#line 969
                    __cil_tmp16 = strncmp((char const   *)((char *)"-ixoff"), (char const   *)opt,
                                          (unsigned long )6);
                    }
#line 969
                    if (! __cil_tmp16) {
#line 972
                      m->tio.c_iflag &= (unsigned int )(~ 4096);
                    } else {
                      {
#line 977
                      __cil_tmp17 = strncmp((char const   *)((char *)"crtscts"), (char const   *)opt,
                                            (unsigned long )7);
                      }
#line 977
                      if (! __cil_tmp17) {
#line 980
                        m->tio.c_cflag |= 2147483648U;
                      } else {
                        {
#line 983
                        __cil_tmp18 = strncmp((char const   *)((char *)"-crtscts"),
                                              (char const   *)opt, (unsigned long )8);
                        }
#line 983
                        if (! __cil_tmp18) {
#line 986
                          m->tio.c_cflag &= ~ 2147483648U;
                        } else {
#line 990
                          return (- 1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 991
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 991
      if (! ((int )*opt && ! __cil_tmp19)) {
#line 991
        goto while_break___1;
      }
#line 991
      opt ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 993
  return (0);
}
}
#line 1005 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
void brktty(int fd ) 
{ 


  {
#line 1009
  if (separate_sids) {
    {
#line 1010
    setsid();
    }
  }
  return;
}
}
#line 1035 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
int fgtty(int fd ) 
{ 
  int mypid ;
  int __cil_tmp4 ;

  {
  {
#line 1041
  mypid = getpid();
  }
#line 1051
  if (separate_sids) {
    {
#line 1052
    __cil_tmp4 = tcsetpgrp(fd, mypid);
    }
#line 1052
    if (__cil_tmp4) {
      {
#line 1054
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1054
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1055
      return (- 1);
    }
  }
#line 1067
  return (0);
}
}
#line 1076 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
int breaktype  =    2;
#line 1097 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
static void DoSendBreak(int fd , int n , int type ) 
{ 
  int i ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;
  int i___0 ;
  int __cil_tmp11 ;
  int *__cil_tmp12 ;
  int __cil_tmp14 ;
  int *__cil_tmp15 ;
  int tmp ;
  int __cil_tmp17 ;
  int *__cil_tmp18 ;

  {
  {
#line 1102
  if (type == 2) {
#line 1102
    goto case_2;
  }
#line 1144
  if (type == 1) {
#line 1144
    goto case_1;
  }
#line 1168
  if (type == 0) {
#line 1168
    goto case_0;
  }
#line 1191
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1125
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1129
  if (! n) {
#line 1130
    n ++;
  }
#line 1131
  i = 0;
  {
#line 1131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1131
    if (! (i < n)) {
#line 1131
      goto while_break___0;
    }
    {
#line 1132
    __cil_tmp6 = tcsendbreak(fd, 0);
    }
#line 1132
    if (__cil_tmp6 < 0) {
      {
#line 1134
      __cil_tmp7 = __errno_location();
#line 1134
      Msg(*__cil_tmp7, (char const   *)((char *)"cannot send BREAK (tcsendbreak SVR4)"));
      }
#line 1135
      return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1131
  i ++;
#line 1142
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1146
  if (! n) {
#line 1147
    n ++;
  }
  {
#line 1152
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1152
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1156
  i___0 = 0;
  {
#line 1156
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1156
    if (! (i___0 < n)) {
#line 1156
      goto while_break___2;
    }
    {
#line 1157
    __cil_tmp11 = ioctl(fd, (unsigned long )21513, (char *)0);
    }
#line 1157
    if (__cil_tmp11 < 0) {
      {
#line 1159
      __cil_tmp12 = __errno_location();
#line 1159
      Msg(*__cil_tmp12, (char const   *)((char *)"Cannot send BREAK (TCSBRK)"));
      }
#line 1160
      return;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1156
  i___0 ++;
#line 1166
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1174
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1174
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1175
  __cil_tmp14 = ioctl(fd, (unsigned long )21543, (char *)0);
  }
#line 1175
  if (__cil_tmp14 < 0) {
    {
#line 1177
    __cil_tmp15 = __errno_location();
#line 1177
    Msg(*__cil_tmp15, (char const   *)((char *)"Can\'t send BREAK (TIOCSBRK)"));
    }
#line 1178
    return;
  }
#line 1180
  if (n) {
#line 1180
    tmp = n * 250;
  } else {
#line 1180
    tmp = 250;
  }
  {
#line 1180
  sleep1000(tmp);
#line 1181
  __cil_tmp17 = ioctl(fd, (unsigned long )21544, (char *)0);
  }
#line 1181
  if (__cil_tmp17 < 0) {
    {
#line 1183
    __cil_tmp18 = __errno_location();
#line 1183
    Msg(*__cil_tmp18, (char const   *)((char *)"BREAK stuck!!! -- HELP! (TIOCCBRK)"));
    }
#line 1184
    return;
  }
#line 1189
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1192
  Msg(0, (char const   *)((char *)"Internal SendBreak error: method %d unknown"),
      type);
  }
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1202 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
void SendBreak(struct win *wp , int n , int closeopen ) 
{ 
  void (*sigalrm)(int  ) ;
  int __cil_tmp5 ;
  int tmp ;
  int __cil_tmp8 ;

  {
#line 1215
  if (wp->w_type != 1) {
#line 1216
    return;
  }
  {
#line 1218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1221
  __cil_tmp5 = tcflush(wp->w_ptyfd, 2);
  }
#line 1228
  if (closeopen) {
    {
#line 1230
    close(wp->w_ptyfd);
    }
#line 1231
    if (n) {
#line 1231
      tmp = n * 250;
    } else {
#line 1231
      tmp = 250;
    }
    {
#line 1231
    sleep1000(tmp);
#line 1232
    wp->w_ptyfd = OpenTTY((char *)wp->w_tty, wp->w_cmdargs[1]);
    }
#line 1232
    if (wp->w_ptyfd < 1) {
      {
#line 1234
      Msg(0, (char const   *)((char *)"Ouch, cannot reopen line %s, please try harder"),
          (char *)wp->w_tty);
      }
#line 1235
      return;
    }
    {
#line 1237
    __cil_tmp8 = fcntl(wp->w_ptyfd, 4, 2048);
    }
  } else {
    {
#line 1241
    sigalrm = xsignal(14, SigAlrmDummy);
#line 1242
    alarm((unsigned int )15);
#line 1244
    DoSendBreak(wp->w_ptyfd, n, breaktype);
#line 1246
    alarm((unsigned int )0);
#line 1247
    xsignal(14, sigalrm);
    }
  }
  {
#line 1249
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1249
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 1258
static struct event consredir_ev ;
#line 1259 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
static int consredirfd[2]  = {      - 1,      - 1};
#line 1262 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
static void consredir_readev_fn(struct event *ev , char *data ) 
{ 
  char *p ;
  char *n ;
  char buf[256] ;
  int l ;
  ssize_t __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1269
  __cil_tmp7 = read(consredirfd[0], (void *)((char *)buf), sizeof(buf));
#line 1269
  l = (int )__cil_tmp7;
  }
#line 1269
  if (! console_window) {
    {
    {
#line 1271
    close(consredirfd[0]);
    }
    {
#line 1272
    close(consredirfd[1]);
    }
#line 1273
    consredirfd[1] = - 1;
#line 1273
    consredirfd[0] = consredirfd[1];
    {
#line 1274
    evdeq(ev);
    }
    }
#line 1275
    return;
  } else
#line 1269
  if (l <= 0) {
    {
    {
#line 1271
    close(consredirfd[0]);
    }
    {
#line 1272
    close(consredirfd[1]);
    }
#line 1273
    consredirfd[1] = - 1;
#line 1273
    consredirfd[0] = consredirfd[1];
    {
#line 1274
    evdeq(ev);
    }
    }
#line 1275
    return;
  }
#line 1277
  n = (char *)buf;
#line 1277
  p = n;
  {
#line 1277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1277
    if (! (l > 0)) {
#line 1277
      goto while_break;
    }
#line 1278
    if ((int )*n == 10) {
#line 1280
      if (n > p) {
        {
#line 1281
        WriteString(console_window, p, (int )(n - p));
        }
      }
      {
#line 1282
      WriteString(console_window, (char *)"\r\n", 2);
#line 1283
      p = n + 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1277
  __cil_tmp9 = l;
#line 1277
  l --;
#line 1277
  __cil_tmp8 = n;
#line 1277
  n ++;
#line 1285
  if (n > p) {
    {
#line 1286
    WriteString(console_window, p, (int )(n - p));
    }
  }
  return;
}
}
#line 1293 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
int TtyGrabConsole(int fd , int on , char *rc_name___0 ) 
{ 
  struct display *d ;
  struct mode new1 ;
  struct mode new2 ;
  char *slave ;
  int __cil_tmp8 ;
  int *__cil_tmp10 ;
  int *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int *__cil_tmp16 ;

  {
#line 1358
  if (on > 0) {
#line 1360
    if (displays == (struct display *)0) {
      {
#line 1362
      Msg(0, (char const   *)((char *)"I need a display"));
      }
#line 1363
      return (- 1);
    }
#line 1365
    d = displays;
    {
#line 1365
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1365
      if (! d) {
#line 1365
        goto while_break;
      }
      {
#line 1366
      __cil_tmp8 = strcmp((char const   *)((char *)d->d_usertty), (char const   *)((char *)"/dev/console"));
      }
#line 1366
      if (__cil_tmp8 == 0) {
#line 1367
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1365
    d = d->d_next;
#line 1368
    if (d) {
      {
#line 1370
      Msg(0, (char const   *)((char *)"too dangerous - screen is running on /dev/console"));
      }
#line 1371
      return (- 1);
    }
  }
#line 1374
  if (consredirfd[0] >= 0) {
    {
#line 1376
    evdeq(& consredir_ev);
#line 1377
    close(consredirfd[0]);
#line 1378
    close(consredirfd[1]);
#line 1379
    consredirfd[1] = - 1;
#line 1379
    consredirfd[0] = consredirfd[1];
    }
  }
#line 1381
  if (on <= 0) {
#line 1382
    return (0);
  }
  {
#line 1408
  consredirfd[0] = OpenPTY(& slave);
  }
#line 1408
  if (consredirfd[0] < 0) {
    {
#line 1410
    __cil_tmp10 = __errno_location();
#line 1410
    Msg(*__cil_tmp10, (char const   *)((char *)"%s: could not open detach pty master"),
        rc_name___0);
    }
#line 1411
    return (- 1);
  }
  {
#line 1413
  consredirfd[1] = open((char const   *)slave, 258);
  }
#line 1413
  if (consredirfd[1] < 0) {
    {
#line 1415
    __cil_tmp12 = __errno_location();
#line 1415
    Msg(*__cil_tmp12, (char const   *)((char *)"%s: could not open detach pty slave"),
        rc_name___0);
#line 1416
    close(consredirfd[0]);
    }
#line 1417
    return (- 1);
  }
  {
#line 1419
  InitTTY(& new1, 0);
#line 1420
  SetMode(& new1, & new2, 0, 0);
#line 1421
  SetTTY(consredirfd[1], & new2);
#line 1422
  __cil_tmp13 = UserContext();
  }
#line 1422
  if (__cil_tmp13 == 1) {
    {
#line 1423
    __cil_tmp14 = ioctl(consredirfd[1], (unsigned long )21533, (char *)(& on));
#line 1423
    UserReturn(__cil_tmp14);
    }
  }
  {
#line 1424
  __cil_tmp15 = UserStatus();
  }
#line 1424
  if (__cil_tmp15) {
    {
#line 1426
    __cil_tmp16 = __errno_location();
#line 1426
    Msg(*__cil_tmp16, (char const   *)((char *)"%s: ioctl TIOCCONS failed"), rc_name___0);
#line 1427
    close(consredirfd[0]);
#line 1428
    close(consredirfd[1]);
    }
#line 1429
    return (- 1);
  }
  {
#line 1432
  consredir_ev.fd = consredirfd[0];
#line 1433
  consredir_ev.type = 1;
#line 1434
  consredir_ev.handler = consredir_readev_fn;
#line 1435
  evenq(& consredir_ev);
  }
#line 1436
  return (0);
}
}
#line 1452 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
char *TtyGetModemStatus(int fd , char *buf ) 
{ 
  char *p ;
  unsigned int softcar ;
  unsigned int mflags ;
  struct mode mtio ;
  int rtscts ;
  int clocal ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  char *tmp ;
  size_t __cil_tmp13 ;
  char *s ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 1456
  p = buf;
#line 1495
  GetTTY(fd, & mtio);
#line 1497
  clocal = 0;
  }
#line 1499
  if (mtio.tio.c_cflag & 2048U) {
#line 1501
    clocal = 1;
#line 1502
    __cil_tmp9 = p;
#line 1502
    p ++;
#line 1502
    *__cil_tmp9 = (char )'{';
  }
#line 1508
  if (! (mtio.tio.c_cflag & 2147483648U)) {
#line 1509
    rtscts = 0;
  } else {
#line 1512
    rtscts = 1;
  }
  {
#line 1516
  __cil_tmp10 = ioctl(fd, (unsigned long )21529, (char *)(& softcar));
  }
#line 1516
  if (__cil_tmp10 < 0) {
#line 1517
    softcar = (unsigned int )0;
  }
  {
#line 1522
  __cil_tmp11 = ioctl(fd, (unsigned long )21525, (char *)(& mflags));
  }
#line 1522
  if (__cil_tmp11 < 0) {
#line 1532
    if (softcar) {
#line 1532
      tmp = (char *)"(CD)";
    } else {
#line 1532
      tmp = (char *)"CD";
    }
    {
#line 1532
    sprintf(p, (char const   *)((char *)"NO-TTY? %s"), tmp);
#line 1536
    __cil_tmp13 = strlen((char const   *)p);
    }
#line 1536
    p += __cil_tmp13;
  } else {
#line 1549
    s = (char *)"!RTS ";
#line 1549
    if (mflags & 4U) {
#line 1549
      s ++;
    }
    {
#line 1550
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1550
      if (! *s) {
#line 1550
        goto while_break;
      }
#line 1550
      __cil_tmp17 = s;
#line 1550
      s ++;
#line 1550
      __cil_tmp16 = p;
#line 1550
      p ++;
#line 1550
      *__cil_tmp16 = *__cil_tmp17;
    }
    while_break: /* CIL Label */ ;
    }
#line 1553
    s = (char *)"!CTS ";
#line 1554
    if (! rtscts) {
#line 1556
      __cil_tmp18 = p;
#line 1556
      p ++;
#line 1556
      *__cil_tmp18 = (char )'(';
#line 1557
      s = (char *)"!CTS) ";
    }
#line 1559
    if (mflags & 32U) {
#line 1559
      s ++;
    }
    {
#line 1560
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1560
      if (! *s) {
#line 1560
        goto while_break___0;
      }
#line 1560
      __cil_tmp21 = s;
#line 1560
      s ++;
#line 1560
      __cil_tmp20 = p;
#line 1560
      p ++;
#line 1560
      *__cil_tmp20 = *__cil_tmp21;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1564
    s = (char *)"!DTR ";
#line 1564
    if (mflags & 2U) {
#line 1564
      s ++;
    }
    {
#line 1565
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1565
      if (! *s) {
#line 1565
        goto while_break___1;
      }
#line 1565
      __cil_tmp24 = s;
#line 1565
      s ++;
#line 1565
      __cil_tmp23 = p;
#line 1565
      p ++;
#line 1565
      *__cil_tmp23 = *__cil_tmp24;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1568
    s = (char *)"!DSR ";
#line 1568
    if (mflags & 256U) {
#line 1568
      s ++;
    }
    {
#line 1569
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1569
      if (! *s) {
#line 1569
        goto while_break___2;
      }
#line 1569
      __cil_tmp27 = s;
#line 1569
      s ++;
#line 1569
      __cil_tmp26 = p;
#line 1569
      p ++;
#line 1569
      *__cil_tmp26 = *__cil_tmp27;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1572
    s = (char *)"!CD ";
#line 1574
    if (softcar) {
#line 1576
      __cil_tmp28 = p;
#line 1576
      p ++;
#line 1576
      *__cil_tmp28 = (char )'(';
#line 1577
      s = (char *)"!CD) ";
    }
#line 1581
    if (mflags & 64U) {
#line 1581
      s ++;
    }
    {
#line 1585
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1585
      if (! *s) {
#line 1585
        goto while_break___3;
      }
#line 1585
      __cil_tmp31 = s;
#line 1585
      s ++;
#line 1585
      __cil_tmp30 = p;
#line 1585
      p ++;
#line 1585
      *__cil_tmp30 = *__cil_tmp31;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1589
    if (mflags & 128U) {
#line 1593
      s = (char *)"RI ";
      {
#line 1593
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1593
        if (! *s) {
#line 1593
          goto while_break___4;
        }

      }
      while_break___4: /* CIL Label */ ;
      }
#line 1593
      __cil_tmp33 = s;
#line 1593
      s ++;
#line 1593
      __cil_tmp32 = p;
#line 1593
      p ++;
#line 1593
      *__cil_tmp32 = *__cil_tmp33;
    }
#line 1605
    if (p > buf) {
#line 1605
      if ((int )*(p + -1) == 32) {
#line 1606
        __cil_tmp34 = p;
#line 1606
        p --;
      }
    }
#line 1607
    *p = (char )'\000';
  }
#line 1615
  if (clocal) {
#line 1616
    __cil_tmp35 = p;
#line 1616
    p ++;
#line 1616
    *__cil_tmp35 = (char )'}';
  }
#line 1617
  *p = (char )'\000';
#line 1618
  return (buf);
}
}
#line 1687 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
static struct baud_values btable[]  = 
#line 1687
  {      {33, 4000000, 4111}, 
        {32, 3500000, 4110}, 
        {31, 3000000, 4109}, 
        {30, 2500000, 4108}, 
        {29, 2000000, 4107}, 
        {28, 1500000, 4106}, 
        {27, 1152000, 4105}, 
        {26, 1000000, 4104}, 
        {25, 921600, 4103}, 
        {24, 576000, 4102}, 
        {23, 500000, 4101}, 
        {22, 460800, 4100}, 
        {21, 230400, 4099}, 
        {20, 115200, 4098}, 
        {19, 57600, 4097}, 
        {18, 38400, 15}, 
        {18, 38400, 15}, 
        {17, 19200, 14}, 
        {17, 19200, 14}, 
        {16, 9600, 13}, 
        {14, 4800, 12}, 
        {12, 2400, 11}, 
        {11, 1800, 10}, 
        {10, 1200, 9}, 
        {8, 600, 8}, 
        {7, 300, 7}, 
        {6, 200, 6}, 
        {5, 150, 5}, 
        {4, 134, 4}, 
        {3, 110, 3}, 
        {2, 75, 2}, 
        {1, 50, 1}, 
        {0, 0, 0}, 
        {- 1, - 1, - 1}};
#line 1805 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
struct baud_values *lookup_baud(int baud ) 
{ 
  struct baud_values *p ;

  {
#line 1810
  p = (struct baud_values *)btable;
  {
#line 1810
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1810
    if (! (p->idx >= 0)) {
#line 1810
      goto while_break;
    }
#line 1811
    if (baud == p->bps) {
#line 1812
      return (p);
    } else
#line 1811
    if (baud == p->sym) {
#line 1812
      return (p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1810
  p ++;
#line 1813
  return ((struct baud_values *)((void *)0));
}
}
#line 1823 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
int SetBaud(struct mode *m , int ibaud , int obaud ) 
{ 
  struct baud_values *ip ;
  struct baud_values *op ;

  {
  {
#line 1829
  op = lookup_baud(obaud);
  }
  {
#line 1829
  ip = lookup_baud(ibaud);
  }
#line 1829
  if (! ip) {
#line 1829
    if (ibaud != -1) {
#line 1831
      return (- 1);
    } else {
#line 1829
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1829
  if (! op) {
#line 1829
    if (obaud != -1) {
#line 1831
      return (- 1);
    }
  }
#line 1834
  if (ip) {
    {
#line 1834
    cfsetispeed(& m->tio, (speed_t )ip->sym);
    }
  }
#line 1835
  if (op) {
    {
#line 1835
    cfsetospeed(& m->tio, (speed_t )op->sym);
    }
  }
#line 1858
  return (0);
}
}
#line 1863 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/tty.c"
int CheckTtyname(char *tty ) 
{ 
  struct stat st ;
  char realbuf[4096] ;
  char const   *real ;
  int rc ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 1871
  __cil_tmp6 = realpath((char const   *)tty, (char *)realbuf);
#line 1871
  real = (char const   *)__cil_tmp6;
  }
#line 1872
  if (! real) {
#line 1873
    return (- 1);
  }
  {
#line 1874
  realbuf[sizeof(realbuf) - 1UL] = (char )'\000';
#line 1876
  __cil_tmp8 = strncmp(real, (char const   *)((char *)"/dev"), (unsigned long )4);
  }
  {
#line 1876
  __cil_tmp7 = lstat(real, & st);
  }
#line 1876
  if (__cil_tmp7) {
#line 1878
    rc = - 1;
  } else
#line 1876
  if (! ((st.st_mode & 61440U) == 8192U)) {
#line 1878
    rc = - 1;
  } else
#line 1876
  if (st.st_nlink > 1UL) {
#line 1876
    if (__cil_tmp8) {
#line 1878
      rc = - 1;
    } else {
#line 1880
      rc = 0;
    }
  } else {
#line 1880
    rc = 0;
  }
#line 1882
  return (rc);
}
}
#line 121 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void revto_line(int tx , int ty , int line ) ;
#line 122
void revto(int tx , int ty ) ;
#line 128
void Search(int dir ) ;
#line 129
void ISearch(int dir ) ;
#line 49 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/search.c"
static int matchword(char *pattern , int y , int sx , int ex ) ;
#line 50
static void searchend(char *buf , int len , char *data ) ;
#line 51
static void backsearchend(char *buf , int len , char *data ) ;
#line 54 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/search.c"
void Search(int dir ) 
{ 
  struct markdata *markdata___0 ;
  char *tmp ;
  void tmp___908(char * , int  , char * ) ;

  {
#line 58
  if (dir == 0) {
#line 60
    markdata___0 = (struct markdata *)flayer->l_data;
#line 61
    if (markdata___0->isdir > 0) {
      {
#line 62
      searchend((char *)0, 0, (char *)((void *)0));
      }
    } else
#line 63
    if (markdata___0->isdir < 0) {
      {
#line 64
      backsearchend((char *)0, 0, (char *)((void *)0));
      }
    } else {
      {
#line 66
      LMsg(0, (char const   *)((char *)"No previous pattern"));
      }
    }
  } else {
#line 69
    if (dir > 0) {
#line 69
      tmp = (char *)"/";
    } else {
#line 69
      tmp = (char *)"?";
    }
#line 69
    if (dir > 0) {
#line 69
      tmp___908 = searchend;
    } else {
#line 69
      tmp___908 = backsearchend;
    }
    {
#line 69
    Input(tmp, (int )(sizeof(markdata___0->isstr) - 1UL), 0, tmp___908, (char *)((void *)0),
          0);
    }
  }
  return;
}
}
#line 74 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/search.c"
static void searchend(char *buf , int len , char *data ) 
{ 
  int x ;
  int sx ;
  int ex ;
  int y ;
  struct markdata *markdata___0 ;
  struct win *p ;
  int __cil_tmp11 ;

  {
#line 79
  x = 0;
#line 83
  markdata___0 = (struct markdata *)flayer->l_data;
#line 84
  p = markdata___0->md_window;
#line 85
  markdata___0->isdir = 1;
#line 86
  if (len) {
    {
#line 87
    strcpy((char *)markdata___0->isstr, (char const   *)buf);
    }
  }
#line 88
  sx = markdata___0->cx + 1;
#line 89
  ex = flayer->l_width - 1;
#line 90
  y = markdata___0->cy;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (y < p->w_histheight + flayer->l_height)) {
#line 90
      goto while_break;
    }
    {
#line 92
    x = matchword((char *)markdata___0->isstr, y, sx, ex);
    }
#line 92
    if (x >= 0) {
#line 93
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  sx = 0;
#line 90
  __cil_tmp11 = y;
#line 90
  y ++;
#line 95
  if (y >= p->w_histheight + flayer->l_height) {
    {
#line 97
    LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
#line 98
    LMsg(0, (char const   *)((char *)"Pattern not found"));
    }
  } else {
    {
#line 101
    revto(x, y);
    }
  }
  return;
}
}
#line 105 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/search.c"
static void backsearchend(char *buf , int len , char *data ) 
{ 
  int sx ;
  int ex ;
  int x ;
  int y ;
  struct markdata *markdata___0 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 110
  x = - 1;
#line 113
  markdata___0 = (struct markdata *)flayer->l_data;
#line 114
  markdata___0->isdir = - 1;
#line 115
  if (len) {
    {
#line 116
    strcpy((char *)markdata___0->isstr, (char const   *)buf);
    }
  }
#line 117
  ex = markdata___0->cx - 1;
#line 118
  y = markdata___0->cy;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (y >= 0)) {
#line 118
      goto while_break;
    }
#line 120
    sx = 0;
    {
#line 121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 121
      if (! (sx >= 0)) {
#line 121
        goto while_break___0;
      }
#line 122
      __cil_tmp10 = sx;
#line 122
      sx ++;
#line 122
      x = __cil_tmp10;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 123
    if (x >= 0) {
#line 124
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  ex = flayer->l_width - 1;
#line 118
  __cil_tmp11 = y;
#line 118
  y --;
#line 126
  if (y < 0) {
    {
#line 128
    LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
#line 129
    LMsg(0, (char const   *)((char *)"Pattern not found"));
    }
  } else {
    {
#line 132
    revto(x, y);
    }
  }
  return;
}
}
#line 144 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/search.c"
static int matchword(char *pattern , int y , int sx , int ex ) 
{ 
  unsigned char *cp ;
  unsigned char *pp ;
  unsigned char *cpe ;
  int cy ;
  struct mline *tmp ;
  struct mline *tmp___909 ;
  struct mline *tmp___910 ;
  struct mline *tmp___911 ;

  {
#line 151
  fore = ((struct markdata *)flayer->l_data)->md_window;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (sx <= ex)) {
#line 153
      goto while_break;
    }
#line 155
    cy = y;
#line 156
    cp = tmp->image + sx;
#line 157
    cpe = tmp___909->image + flayer->l_width;
#line 158
    pp = (unsigned char *)pattern;
    {
#line 159
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 159
      if (! 1) {
#line 159
        goto while_break___0;
      }
#line 161
      if ((int )*cp != (int )*pp) {
#line 162
        if (! search_ic) {
#line 163
          goto while_break___0;
        } else
#line 162
        if (((int )*cp ^ (int )*pp) & 223) {
#line 163
          goto while_break___0;
        } else
#line 162
        if (((int )*cp | 32) < 97) {
#line 163
          goto while_break___0;
        } else
#line 162
        if (((int )*cp | 32) > 122) {
#line 163
          goto while_break___0;
        }
      }
#line 164
      cp ++;
#line 165
      pp ++;
#line 166
      if ((int )*pp == 0) {
#line 167
        return (sx);
      }
#line 168
      if (cp == cpe) {
#line 174
        if ((int )*cp == 32) {
#line 175
          goto while_break___0;
        } else
#line 174
        if (cy >= (fore->w_histheight + flayer->l_height) - 1) {
#line 175
          goto while_break___0;
        }
#line 181
        cy ++;
#line 182
        cp = tmp___910->image;
#line 183
        cpe = tmp___911->image + flayer->l_width;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  sx ++;
#line 187
  return (- 1);
}
}
#line 195 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/search.c"
static char *isprompts[]  = {      (char *)"I-search backward: ",      (char *)"failing I-search backward: ",      (char *)"I-search: ",      (char *)"failing I-search: "};
#line 201
static int is_redo(struct markdata *markdata___0 ) ;
#line 202
static void is_process(char *p , int n , char *data ) ;
#line 203
static int is_bm(char *str , int l , int p , int end , int dir ) ;
#line 207 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/search.c"
static int is_bm(char *str , int l , int p , int end , int dir ) 
{ 
  int tab[256] ;
  int i ;
  int q ;
  unsigned char *s ;
  unsigned char c ;
  int w ;
  int __cil_tmp13 ;
  struct mline *tmp ;
  int tmp___912 ;

  {
#line 214
  w = flayer->l_width;
#line 217
  fore = ((struct markdata *)(flayer->l_next)->l_data)->md_window;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 219
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 220
  if (p < 0) {
#line 221
    return (- 1);
  } else
#line 220
  if (p + l > end) {
#line 221
    return (- 1);
  }
#line 222
  if (l == 0) {
#line 223
    return (p);
  }
#line 224
  if (dir < 0) {
#line 225
    str += l - 1;
  }
#line 226
  i = 0;
  {
#line 226
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 226
    if (! (i < 256)) {
#line 226
      goto while_break___1;
    }
#line 227
    tab[i] = l * dir;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 226
  i ++;
#line 228
  i = 0;
  {
#line 228
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 228
    if (! (i < l - 1)) {
#line 228
      goto while_break___2;
    }
#line 230
    q = (int )*((unsigned char *)str);
#line 231
    tab[q] = ((l - 1) - i) * dir;
#line 232
    if (search_ic) {
#line 232
      if ((q | 32) >= 97) {
#line 232
        if ((q | 32) <= 122) {
#line 233
          tab[q ^ 32] = ((l - 1) - i) * dir;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 228
  str += dir;
#line 228
  __cil_tmp13 = i;
#line 228
  i ++;
#line 235
  if (dir > 0) {
#line 236
    p += l - 1;
  }
  {
#line 237
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 237
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 238
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 238
    if (! (p >= 0 && p < end)) {
#line 238
      goto while_break___4;
    }
#line 240
    q = p;
#line 241
    s = (unsigned char *)str;
#line 242
    i = 0;
    {
#line 242
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 242
      if (! 1) {
#line 242
        goto while_break___5;
      }
#line 244
      c = *(tmp->image + q % w);
#line 245
      if (i == 0) {
#line 246
        p += tab[(int )c];
      }
#line 247
      if ((int )c != (int )*s) {
#line 248
        if (! search_ic) {
#line 249
          goto while_break___5;
        } else
#line 248
        if (((int )c ^ (int )*s) & 223) {
#line 249
          goto while_break___5;
        } else
#line 248
        if (((int )c | 32) < 97) {
#line 249
          goto while_break___5;
        } else
#line 248
        if (((int )c | 32) > 122) {
#line 249
          goto while_break___5;
        }
      }
#line 250
      q -= dir;
#line 251
      s -= dir;
#line 252
      i ++;
#line 252
      if (i == l) {
#line 253
        if (dir > 0) {
#line 253
          tmp___912 = 1;
        } else {
#line 253
          tmp___912 = - l;
        }
#line 253
        return (q + tmp___912);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 256
  return (- 1);
}
}
#line 262 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/search.c"
static void is_process(char *p , int n , char *data ) 
{ 
  int pos ;
  int x ;
  int y ;
  int dir ;
  struct markdata *markdata___0 ;
  int __cil_tmp9 ;
  int tmp ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 270
  if (n == 0) {
#line 271
    return;
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 273
  markdata___0 = (struct markdata *)(flayer->l_next)->l_data;
#line 275
  pos = markdata___0->cx + markdata___0->cy * flayer->l_width;
#line 276
  LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
  }
  {
#line 280
  if ((int )*p == '\a') {
#line 280
    goto case_7;
  }
#line 283
  if ((int )*p == '\033') {
#line 283
    goto case_27;
  }
#line 287
  if ((int )*p == '\027') {
#line 287
    goto case_23;
  }
#line 287
  if ((int )*p == '\v') {
#line 287
    goto case_23;
  }
#line 291
  if ((int )*p == '\177') {
#line 291
    goto case_127;
  }
#line 291
  if ((int )*p == '\b') {
#line 291
    goto case_127;
  }
#line 299
  if ((int )*p == '\022') {
#line 299
    goto case_18;
  }
#line 299
  if ((int )*p == '\023') {
#line 299
    goto case_18;
  }
#line 313
  goto switch_default;
  case_7: /* CIL Label */ 
#line 281
  pos = markdata___0->isstartpos;
  case_27: /* CIL Label */ 
#line 284
  *p = (char )0;
#line 285
  goto switch_break;
  case_23: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 288
  markdata___0->isistrl = 1;
  case_127: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 292
  if (markdata___0->isistrl == 0) {
#line 293
    return;
  }
  {
#line 294
  __cil_tmp9 = markdata___0->isistrl;
#line 294
  (markdata___0->isistrl) --;
#line 295
  pos = is_redo(markdata___0);
#line 296
  *p = (char )'\b';
  }
#line 297
  goto switch_break;
  case_18: /* CIL Label */ 
  case_19: /* CIL Label */ 
#line 300
  if (markdata___0->isistrl >= (int )sizeof(markdata___0->isistr)) {
#line 301
    return;
  }
#line 302
  if ((int )*p == 19) {
#line 302
    tmp = 1;
  } else {
#line 302
    tmp = - 1;
  }
#line 302
  dir = tmp;
#line 303
  pos += dir;
#line 304
  if (markdata___0->isdir == dir) {
#line 304
    if (markdata___0->isistrl == 0) {
      {
#line 306
      strcpy((char *)markdata___0->isistr, (char const   *)((char *)markdata___0->isstr));
#line 307
      __cil_tmp12 = strlen((char const   *)((char *)markdata___0->isstr));
#line 307
      markdata___0->isstrl = (int )__cil_tmp12;
#line 307
      markdata___0->isistrl = markdata___0->isstrl;
      }
#line 308
      goto switch_break;
    }
  }
#line 310
  markdata___0->isdir = dir;
#line 311
  __cil_tmp13 = markdata___0->isistrl;
#line 311
  (markdata___0->isistrl) ++;
#line 311
  markdata___0->isistr[__cil_tmp13] = *p;
#line 312
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 314
  if ((int )*p < 32) {
#line 316
    return;
  } else
#line 314
  if (markdata___0->isistrl >= (int )sizeof(markdata___0->isistr)) {
#line 316
    return;
  } else
#line 314
  if (markdata___0->isstrl >= (int )sizeof(markdata___0->isstr) - 1) {
#line 316
    return;
  }
#line 317
  __cil_tmp14 = markdata___0->isstrl;
#line 317
  (markdata___0->isstrl) ++;
#line 317
  markdata___0->isstr[__cil_tmp14] = *p;
#line 318
  __cil_tmp15 = markdata___0->isistrl;
#line 318
  (markdata___0->isistrl) ++;
#line 318
  markdata___0->isistr[__cil_tmp15] = *p;
#line 319
  markdata___0->isstr[markdata___0->isstrl] = (char )0;
  {
#line 320
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 320
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 322
  if ((int )*p) {
#line 322
    if ((int )*p != 8) {
      {
#line 323
      pos = is_bm((char *)markdata___0->isstr, markdata___0->isstrl, pos, flayer->l_width * ((markdata___0->md_window)->w_histheight + flayer->l_height),
                  markdata___0->isdir);
      }
    }
  }
#line 324
  if (pos >= 0) {
#line 326
    x = pos % flayer->l_width;
#line 327
    y = pos / flayer->l_width;
    {
#line 328
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 328
      oldlay = flayer;
      {
#line 328
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 328
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 328
      flayer = flayer->l_next;
#line 328
      oldcvlist = flayer->l_cvlist;
      {
#line 328
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 328
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 328
      flayer->l_cvlist = oldlay->l_cvlist;
#line 328
      cv = flayer->l_cvlist;
      {
#line 328
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 328
        if (! cv) {
#line 328
          goto while_break___4;
        }
#line 328
        cv->c_layer = flayer;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 328
      cv = cv->c_lnext;
#line 328
      (*((flayer->l_layfn)->lf_LayRedisplayLine))(flayer->l_height - 1, 0, flayer->l_width - 1,
                                                  0);
#line 328
      revto(x, y);
      }
#line 328
      if (markdata___0->cy - markdata___0->hist_offset == flayer->l_height - 1) {
#line 328
        if (flayer->l_height - 1 > 0) {
#line 328
          tmp___0 = (flayer->l_height - 1) - 1;
        } else {
#line 328
          tmp___0 = 1;
        }
        {
#line 328
        revto_line(markdata___0->cx, markdata___0->cy, tmp___0);
        }
      }
#line 328
      flayer = oldlay;
#line 328
      cv = flayer->l_cvlist;
      {
#line 328
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 328
        if (! cv) {
#line 328
          goto while_break___5;
        }
#line 328
        cv->c_layer = flayer;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 328
      cv = cv->c_lnext;
#line 328
      (flayer->l_next)->l_cvlist = oldcvlist;
#line 328
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 336
  if (*p) {
#line 337
    if (markdata___0->isstrl) {
#line 337
      tmp___1 = (char *)markdata___0->isstr;
    } else {
#line 337
      tmp___1 = (char *)"";
    }
    {
#line 337
    inp_setprompt(isprompts[(markdata___0->isdir + (pos < 0)) + 1], tmp___1);
    }
  }
  {
#line 338
  flayer->l_x = markdata___0->cx;
#line 339
  flayer->l_y = markdata___0->cy - markdata___0->hist_offset;
#line 340
  LGotoPos(flayer, flayer->l_x, flayer->l_y);
  }
#line 341
  if (! *p) {
#line 344
    (flayer->l_next)->l_x = markdata___0->cx;
#line 345
    (flayer->l_next)->l_y = markdata___0->cy - markdata___0->hist_offset;
  }
  return;
}
}
#line 350 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/search.c"
static int is_redo(struct markdata *markdata___0 ) 
{ 
  int i ;
  int pos ;
  int npos ;
  int dir ;
  char c ;
  int __cil_tmp7 ;

  {
#line 356
  pos = markdata___0->isstartpos;
#line 356
  npos = pos;
#line 357
  dir = markdata___0->isstartdir;
#line 358
  markdata___0->isstrl = 0;
#line 359
  i = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < markdata___0->isistrl)) {
#line 359
      goto while_break;
    }
#line 361
    c = markdata___0->isistr[i];
#line 362
    if ((int )c == 18) {
#line 363
      dir = - 1;
#line 363
      pos += dir;
    } else
#line 364
    if ((int )c == 19) {
#line 365
      dir = 1;
#line 365
      pos += dir;
    } else {
#line 367
      __cil_tmp7 = markdata___0->isstrl;
#line 367
      (markdata___0->isstrl) ++;
#line 367
      markdata___0->isstr[__cil_tmp7] = c;
    }
#line 368
    if (pos >= 0) {
      {
#line 370
      npos = is_bm((char *)markdata___0->isstr, markdata___0->isstrl, pos, flayer->l_width * ((markdata___0->md_window)->w_histheight + flayer->l_height),
                   dir);
      }
#line 371
      if (npos >= 0) {
#line 372
        pos = npos;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  i ++;
#line 375
  markdata___0->isstr[markdata___0->isstrl] = (char )0;
#line 376
  markdata___0->isdir = dir;
#line 377
  return (npos);
}
}
#line 381 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/search.c"
void ISearch(int dir ) 
{ 
  struct markdata *markdata___0 ;
  int tmp ;

  {
#line 386
  markdata___0 = (struct markdata *)flayer->l_data;
#line 387
  markdata___0->isstartdir = dir;
#line 387
  markdata___0->isdir = markdata___0->isstartdir;
#line 388
  markdata___0->isstartpos = markdata___0->cx + markdata___0->cy * flayer->l_width;
#line 389
  markdata___0->isstrl = 0;
#line 389
  markdata___0->isistrl = markdata___0->isstrl;
#line 390
  if (markdata___0->cy - markdata___0->hist_offset == flayer->l_height - 1) {
#line 391
    if (flayer->l_height - 1 > 0) {
#line 391
      tmp = (flayer->l_height - 1) - 1;
    } else {
#line 391
      tmp = 1;
    }
    {
#line 391
    revto_line(markdata___0->cx, markdata___0->cy, tmp);
    }
  }
  {
#line 392
  Input(isprompts[dir + 1], (int )(sizeof(markdata___0->isstr) - 1UL), 2, is_process,
        (char *)((void *)0), 0);
#line 394
  LGotoPos(flayer, markdata___0->cx, markdata___0->cy - markdata___0->hist_offset);
#line 395
  flayer->l_x = markdata___0->cx;
#line 396
  flayer->l_y = markdata___0->cy - markdata___0->hist_offset;
  }
  return;
}
}
#line 681 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 346 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 112
extern  __attribute__((__nothrow__)) int bind(int __fd , __CONST_SOCKADDR_ARG __addr ,
                                              socklen_t __len ) ;
#line 126
extern int connect(int __fd , __CONST_SOCKADDR_ARG __addr , socklen_t __len ) ;
#line 173
extern ssize_t sendmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 191
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 222
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 232
extern int accept(int __fd , __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 135 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 39 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void SigHup(int sigsig ) ;
#line 84
int StartRc(char *rcfilename , int nopanic ) ;
#line 345
int RecoverSocket(void) ;
#line 347
void ReceiveMsg(void) ;
#line 348
void SendCreateMsg(char *sty , struct NewWindow *nwin ) ;
#line 349
int SendErrorMsg(char *tty , char *buf ) ;
#line 65 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static int CheckPid(int pid ) ;
#line 66
static void ExecCreate(struct msg *mp ) ;
#line 67
static void DoCommandMsg(struct msg *mp ) ;
#line 72
static void FinishAttach(struct msg *m ) ;
#line 73
static void FinishDetach(struct msg *m ) ;
#line 74
static void AskPassword(struct msg *m ) ;
#line 77
char *RcFileName ;
#line 79
int lsflag ;
#line 79
int wipeflag ;
#line 85
extern struct layout *layout_last ;
#line 95
struct event serv_read ;
#line 127 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
int FindSocket(int *fdp , int *nfoundp , int *notherp , char *match , int *is_sock ) 
{ 
  DIR *dirp ;
  struct dirent *dp ;
  struct stat st ;
  int mode ;
  int sdirlen ;
  int matchlen ;
  char *name ;
  char *n ;
  int firsts ;
  int sockfd ;
  char *firstn ;
  int nfound ;
  int ngood ;
  int ndead ;
  int nwipe ;
  int npriv ;
  int nperfect ;
  struct sent *slist ;
  struct sent **slisttail ;
  struct sent *sent ;
  struct sent *nsent ;
  size_t __cil_tmp27 ;
  size_t __cil_tmp28 ;
  int *__cil_tmp30 ;
  int cmatch ;
  size_t __cil_tmp33 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp41 ;
  int *__cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  void *__cil_tmp45 ;
  int __cil_tmp50 ;
  int __cil_tmp55 ;
  char *tmp ;
  char *tmp___925 ;
  char *m ;
  char *tmp___926 ;
  char *tmp___927 ;
  char *tmp___928 ;

  {
#line 138
  matchlen = 0;
#line 140
  firsts = - 1;
#line 141
  firstn = (char *)((void *)0);
#line 142
  nfound = 0;
#line 142
  ngood = 0;
#line 142
  ndead = 0;
#line 142
  nwipe = 0;
#line 142
  npriv = 0;
#line 143
  nperfect = 0;
#line 151
  if (match) {
    {
#line 153
    __cil_tmp27 = strlen((char const   *)match);
#line 153
    matchlen = (int )__cil_tmp27;
    }
#line 155
    if (matchlen > 255) {
#line 156
      matchlen = 255;
    }
  }
  {
#line 165
  __cil_tmp28 = strlen((char const   *)((char *)SockPath));
#line 165
  sdirlen = (int )__cil_tmp28;
#line 168
  xseteuid(real_uid);
#line 169
  xsetegid(real_gid);
#line 172
  dirp = opendir((char const   *)((char *)SockPath));
  }
#line 172
  if (dirp == (DIR *)0) {
    {
#line 173
    __cil_tmp30 = __errno_location();
#line 173
    Panic(*__cil_tmp30, (char const   *)((char *)"Cannot opendir %s"), (char *)SockPath);
    }
  }
#line 175
  slist = (struct sent *)0;
#line 176
  slisttail = & slist;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! dp) {
#line 177
      goto while_break;
    }
#line 179
    cmatch = 0;
#line 180
    name = (char *)dp->d_name;
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 182
    __cil_tmp33 = strlen((char const   *)name);
    }
#line 182
    if ((int )*name == 0) {
#line 183
      goto while_continue;
    } else
#line 182
    if ((int )*name == 46) {
#line 183
      goto while_continue;
    } else
#line 182
    if (__cil_tmp33 > 1536UL) {
#line 183
      goto while_continue;
    }
#line 184
    if (matchlen) {
#line 186
      n = name;
#line 188
      if ((int )*match <= 48) {
        _L: /* CIL Label */ 
#line 188
        if ((int )*n > 48) {
#line 188
          if ((int )*n <= 57) {
            {
#line 190
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 190
              if (! ((int )*n >= 48 && (int )*n <= 57)) {
#line 190
                goto while_break___1;
              }
#line 191
              n ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 192
            if ((int )*n == 46) {
#line 193
              n ++;
            }
          }
        }
      } else
#line 188
      if ((int )*match > 57) {
#line 188
        goto _L;
      }
      {
#line 196
      __cil_tmp37 = strncmp((char const   *)n, (char const   *)((char *)"tty"), (unsigned long )3);
      }
      {
#line 196
      __cil_tmp36 = strncmp((char const   *)match, (char const   *)((char *)"tty"),
                            (unsigned long )3);
      }
#line 196
      if (__cil_tmp36) {
#line 196
        if (__cil_tmp37 == 0) {
#line 197
          n += 3;
        }
      }
      {
#line 198
      __cil_tmp38 = strncmp((char const   *)match, (char const   *)n, (unsigned long )matchlen);
      }
#line 198
      if (__cil_tmp38) {
#line 200
        if (n == name) {
#line 200
          if ((int )*match > 48) {
#line 200
            if ((int )*match <= 57) {
              {
#line 202
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 202
                if (! ((int )*n >= 48 && (int )*n <= 57)) {
#line 202
                  goto while_break___2;
                }
#line 203
                n ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 204
              if ((int )*n == 46) {
#line 205
                n ++;
              }
              {
#line 206
              __cil_tmp41 = strncmp((char const   *)match, (char const   *)n, (unsigned long )matchlen);
              }
#line 206
              if (__cil_tmp41) {
#line 207
                goto while_continue;
              }
            } else {
#line 210
              goto while_continue;
            }
          } else {
#line 210
            goto while_continue;
          }
        } else {
#line 210
          goto while_continue;
        }
      } else {
#line 213
        cmatch = (int )*(n + matchlen) == 0;
      }
      {
#line 214
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 214
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 216
    sprintf((char *)SockPath + sdirlen, (char const   *)((char *)"/%s"), name);
    }
    {
#line 218
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 218
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 219
    __cil_tmp42 = __errno_location();
#line 219
    *__cil_tmp42 = 0;
    }
    {
#line 220
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 220
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 221
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 221
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 222
    __cil_tmp43 = stat((char const   *)((char *)SockPath), & st);
    }
#line 222
    if (__cil_tmp43) {
      {
#line 224
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 224
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 225
      goto while_continue;
    }
#line 228
    *is_sock = (st.st_mode & 61440U) == 49152U;
#line 229
    if (! *is_sock) {
#line 229
      if (! ((st.st_mode & 61440U) == 4096U)) {
#line 230
        goto while_continue;
      }
    }
    {
#line 232
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 232
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 235
    if ((int )st.st_uid != real_uid) {
#line 236
      goto while_continue;
    }
#line 238
    mode = (int )st.st_mode & 511;
    {
#line 239
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 239
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 241
    if (multi) {
#line 241
      if ((mode & 447) != 385) {
        {
#line 243
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 243
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 244
        __cil_tmp44 = strcmp((char const   *)multi, (char const   *)LoginName);
        }
#line 244
        if (__cil_tmp44) {
          {
#line 246
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 246
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 247
          mode = - 4;
        } else {
          {
#line 251
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 251
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 255
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 255
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 256
    __cil_tmp45 = malloc(sizeof(struct sent ));
#line 256
    sent = (struct sent *)__cil_tmp45;
    }
#line 256
    if (sent == (struct sent *)0) {
#line 257
      goto while_continue;
    }
    {
#line 258
    sent->next = (struct sent *)0;
#line 259
    sent->name = SaveStr((char const   *)name);
#line 260
    sent->mode = mode;
#line 261
    *slisttail = sent;
#line 262
    slisttail = & sent->next;
#line 263
    nfound ++;
#line 264
    sockfd = MakeClientSocket(0, *is_sock);
#line 267
    xseteuid(real_uid);
#line 268
    xsetegid(real_gid);
    }
#line 270
    if (sockfd == -1) {
      {
#line 272
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 272
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 274
      sent->mode = - 3;
#line 288
      ndead ++;
#line 289
      sent->mode = - 1;
#line 290
      if (wipeflag) {
        {
#line 292
        __cil_tmp50 = unlink((char const   *)((char *)SockPath));
        }
#line 292
        if (__cil_tmp50 == 0) {
#line 294
          sent->mode = - 2;
#line 295
          nwipe ++;
        }
      }
#line 298
      goto while_continue;
    }
#line 301
    mode &= 510;
    {
#line 303
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 303
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 304
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 304
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 316
    if (mode != 448) {
#line 316
      if (mode != 384) {
        _L___913: /* CIL Label */ 
        {
#line 321
        close(sockfd);
        }
        {
#line 322
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 322
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 323
        npriv ++;
#line 324
        goto while_continue;
      } else {
#line 316
        goto _L___922;
      }
    } else
    _L___922: /* CIL Label */ 
#line 316
    if (dflag) {
#line 316
      if (! rflag) {
#line 316
        if (! xflag) {
#line 316
          if (mode == 384) {
#line 316
            goto _L___913;
          } else {
#line 316
            goto _L___919;
          }
        } else {
#line 316
          goto _L___919;
        }
      } else {
#line 316
        goto _L___919;
      }
    } else
    _L___919: /* CIL Label */ 
#line 316
    if (! dflag) {
#line 316
      if (rflag) {
#line 316
        if (mode == 448) {
#line 316
          if (! xflag) {
#line 316
            goto _L___913;
          } else {
#line 316
            goto _L___915;
          }
        } else {
#line 316
          goto _L___915;
        }
      } else {
#line 316
        goto _L___915;
      }
    } else
    _L___915: /* CIL Label */ 
#line 316
    if (! dflag) {
#line 316
      if (! rflag) {
#line 316
        if (! xflag) {
#line 316
          goto _L___913;
        }
      }
    }
#line 326
    ngood ++;
#line 327
    if (cmatch) {
#line 328
      nperfect ++;
    }
#line 329
    if (fdp) {
#line 329
      if (firsts == -1) {
        _L___924: /* CIL Label */ 
#line 331
        if (firsts != -1) {
          {
#line 332
          close(firsts);
          }
        }
#line 333
        firsts = sockfd;
#line 334
        firstn = sent->name;
        {
#line 335
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 335
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      } else
#line 329
      if (cmatch) {
#line 329
        if (nperfect == 1) {
#line 329
          goto _L___924;
        } else {
#line 329
          goto _L___923;
        }
      } else {
#line 329
        goto _L___923;
      }
    } else {
      _L___923: /* CIL Label */ 
      {
#line 339
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 339
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
      {
#line 340
      close(sockfd);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 343
  __cil_tmp55 = closedir(dirp);
  }
#line 344
  if (! lsflag) {
#line 344
    if (nperfect == 1) {
#line 345
      ngood = nperfect;
    }
  }
#line 346
  if (nfound) {
#line 346
    if (lsflag) {
      _L___926: /* CIL Label */ 
#line 346
      if (! quietflag) {
        {
#line 350
        if (ngood == 0) {
#line 350
          goto case_0;
        }
#line 353
        if (ngood == 1) {
#line 353
          goto case_1;
        }
#line 356
        goto switch_default;
        case_0: /* CIL Label */ 
#line 351
        if (nfound > 1) {
#line 351
          tmp = (char *)"There are screens on:";
        } else {
#line 351
          tmp = (char *)"There is a screen on:";
        }
        {
#line 351
        Msg(0, (char const   *)tmp);
        }
#line 352
        goto switch_break;
        case_1: /* CIL Label */ 
#line 354
        if (nfound > 1) {
#line 354
          tmp___925 = (char *)"There are several screens on:";
        } else {
#line 354
          tmp___925 = (char *)"There is a suitable screen on:";
        }
        {
#line 354
        Msg(0, (char const   *)tmp___925);
        }
#line 355
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 357
        Msg(0, (char const   *)((char *)"There are several suitable screens on:"));
        }
#line 358
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 360
        sent = slist;
        {
#line 360
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 360
          if (! sent) {
#line 360
            goto while_break___20;
          }
          {
#line 364
          if (sent->mode == 448) {
#line 364
            goto case_448;
          }
#line 367
          if (sent->mode == 384) {
#line 367
            goto case_384;
          }
#line 371
          if (sent->mode == 449) {
#line 371
            goto case_449;
          }
#line 374
          if (sent->mode == 385) {
#line 374
            goto case_385;
          }
#line 378
          if (sent->mode == - 1) {
#line 378
            goto case_exp;
          }
#line 382
          if (sent->mode == - 2) {
#line 382
            goto case_exp___0;
          }
#line 385
          if (sent->mode == - 3) {
#line 385
            goto case_exp___1;
          }
#line 388
          if (sent->mode == - 4) {
#line 388
            goto case_exp___2;
          }
#line 362
          goto switch_break___0;
          case_448: /* CIL Label */ 
          {
#line 365
          printf((char const   *)((char *)"\t%s\t(Attached)\n"), sent->name);
          }
#line 366
          goto switch_break___0;
          case_384: /* CIL Label */ 
          {
#line 368
          printf((char const   *)((char *)"\t%s\t(Detached)\n"), sent->name);
          }
#line 369
          goto switch_break___0;
          case_449: /* CIL Label */ 
          {
#line 372
          printf((char const   *)((char *)"\t%s\t(Multi, attached)\n"), sent->name);
          }
#line 373
          goto switch_break___0;
          case_385: /* CIL Label */ 
          {
#line 375
          printf((char const   *)((char *)"\t%s\t(Multi, detached)\n"), sent->name);
          }
#line 376
          goto switch_break___0;
          case_exp: /* CIL Label */ 
          {
#line 380
          printf((char const   *)((char *)"\t%s\t(Dead ?%c?)\n"), sent->name, '?');
          }
#line 381
          goto switch_break___0;
          case_exp___0: /* CIL Label */ 
          {
#line 383
          printf((char const   *)((char *)"\t%s\t(Removed)\n"), sent->name);
          }
#line 384
          goto switch_break___0;
          case_exp___1: /* CIL Label */ 
          {
#line 386
          printf((char const   *)((char *)"\t%s\t(Remote or dead)\n"), sent->name);
          }
#line 387
          goto switch_break___0;
          case_exp___2: /* CIL Label */ 
          {
#line 389
          printf((char const   *)((char *)"\t%s\t(Private)\n"), sent->name);
          }
#line 390
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
        while_break___20: /* CIL Label */ ;
        }
#line 360
        sent = sent->next;
      }
    } else
#line 346
    if (ngood != 1) {
#line 346
      goto _L___926;
    }
  }
#line 394
  if (ndead) {
#line 394
    if (! quietflag) {
#line 396
      m = (char *)"Remove dead screens with \'screen -wipe\'.";
#line 397
      if (wipeflag) {
#line 398
        if (nwipe > 1) {
#line 398
          tmp___926 = (char *)"s";
        } else {
#line 398
          tmp___926 = (char *)"";
        }
        {
#line 398
        Msg(0, (char const   *)((char *)"%d socket%s wiped out."), nwipe, tmp___926);
        }
      } else {
#line 400
        if (ndead > 1) {
#line 400
          tmp___927 = (char *)"s";
        } else {
#line 400
          tmp___927 = (char *)"";
        }
#line 400
        if (ndead > 1) {
#line 400
          tmp___928 = (char *)"";
        } else {
#line 400
          tmp___928 = (char *)"es";
        }
        {
#line 400
        Msg(0, (char const   *)m, tmp___927, tmp___928);
        }
      }
    }
  }
#line 402
  if (firsts != -1) {
    {
#line 404
    sprintf((char *)SockPath + sdirlen, (char const   *)((char *)"/%s"), firstn);
#line 405
    *fdp = firsts;
    }
  } else {
#line 408
    SockPath[sdirlen] = (char )0;
  }
#line 409
  sent = slist;
  {
#line 409
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 409
    if (! sent) {
#line 409
      goto while_break___21;
    }
    {
#line 411
    nsent = sent->next;
#line 412
    free((void *)sent->name);
#line 413
    free((void *)((char *)sent));
    }
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 409
  sent = nsent;
#line 416
  xseteuid(eff_uid);
#line 417
  xsetegid(eff_gid);
  }
#line 419
  if (notherp) {
#line 420
    *notherp = npriv;
  }
#line 421
  if (nfoundp) {
#line 422
    *nfoundp = nfound - nwipe;
  }
#line 423
  return (ngood);
}
}
#line 428 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static int MakeServerFifo(void) 
{ 
  register int s ;
  struct stat st ;
  char *__cil_tmp4 ;
  int __cil_tmp5 ;
  int *__cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;
  int tmp___929 ;
  int __cil_tmp10 ;
  int *__cil_tmp12 ;

  {
  {
#line 434
  xseteuid(real_uid);
#line 435
  xsetegid(real_gid);
#line 437
  s = open((char const   *)((char *)SockPath), 2049);
  }
#line 438
  if (s >= 0) {
    {
#line 440
    while (1) {
      while_continue: /* CIL Label */ ;
#line 440
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 441
    if (quietflag) {
      {
#line 443
      Kill(display->d_userpid, 1);
#line 444
      eexit(11);
      }
    }
    {
#line 447
    __cil_tmp4 = Filename((char *)SockPath);
#line 447
    Msg(0, (char const   *)((char *)"There is already a screen running on %s."), __cil_tmp4);
#line 449
    __cil_tmp5 = stat((char const   *)((char *)SockPath), & st);
    }
#line 449
    if (__cil_tmp5 < 0) {
      {
#line 450
      __cil_tmp6 = __errno_location();
#line 450
      Panic(*__cil_tmp6, (char const   *)((char *)"stat"));
      }
    }
#line 454
    if ((int )st.st_uid != real_uid) {
      {
#line 455
      Panic(0, (char const   *)((char *)"Unfortunately you are not its owner."));
      }
    }
#line 457
    if ((st.st_mode & 448U) == 384U) {
      {
#line 458
      Panic(0, (char const   *)((char *)"To resume it, use \"screen -r\""));
      }
    } else {
      {
#line 460
      Panic(0, (char const   *)((char *)"It is not detached."));
      }
    }
  }
  {
#line 464
  __cil_tmp7 = unlink((char const   *)((char *)SockPath));
  }
#line 465
  if (multi) {
#line 465
    tmp___929 = 1;
  } else {
#line 465
    tmp___929 = 0;
  }
#line 465
  if (displays) {
#line 465
    tmp = 64;
  } else {
#line 465
    tmp = 0;
  }
  {
#line 465
  __cil_tmp10 = mkfifo((char const   *)((char *)SockPath), (__mode_t )((384 | tmp) | tmp___929));
  }
#line 465
  if (__cil_tmp10 < 0) {
    {
#line 466
    Panic(0, (char const   *)((char *)"mkfifo %s failed"), (char *)SockPath);
    }
  }
  {
#line 470
  s = open((char const   *)((char *)SockPath), 2048, 0);
  }
#line 472
  if (s < 0) {
    {
#line 473
    __cil_tmp12 = __errno_location();
#line 473
    Panic(*__cil_tmp12, (char const   *)((char *)"open fifo %s"), (char *)SockPath);
    }
  }
  {
#line 475
  xseteuid(eff_uid);
#line 476
  xsetegid(eff_gid);
  }
#line 478
  return (s);
}
}
#line 501 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static int MakeClientFifo(int err ) 
{ 
  register int s ;
  int __cil_tmp4 ;
  int *__cil_tmp5 ;

  {
  {
#line 504
  s = 0;
#line 506
  s = secopen((char *)SockPath, 2049, 0);
  }
#line 507
  if (s >= 0) {
    {
#line 509
    __cil_tmp4 = fcntl(s, 4, 0);
    }
#line 510
    return (s);
  }
#line 513
  if (err) {
    {
#line 514
    __cil_tmp5 = __errno_location();
#line 514
    Msg(*__cil_tmp5, (char const   *)((char *)"%s"), (char *)SockPath);
    }
  }
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return (- 1);
}
}
#line 522 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static int MakeServerUnixSocket(void) 
{ 
  register int s ;
  struct sockaddr_un a ;
  struct stat st ;
  int *__cil_tmp5 ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int *__cil_tmp10 ;
  int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int *__cil_tmp14 ;
  int tmp ;
  int tmp___930 ;
  int __cil_tmp17 ;
  int *__cil_tmp18 ;
  __pid_t __cil_tmp19 ;

  {
  {
#line 528
  s = socket(1, 1, 0);
  }
#line 529
  if (s < 0) {
    {
#line 530
    __cil_tmp5 = __errno_location();
#line 530
    Panic(*__cil_tmp5, (char const   *)((char *)"socket"));
    }
  }
  {
#line 532
  a.sun_family = (sa_family_t )1;
#line 533
  strncpy((char *)a.sun_path, (char const   *)((char *)SockPath), sizeof(a.sun_path));
#line 534
  a.sun_path[sizeof(a.sun_path) - 1UL] = (char )0;
#line 537
  xseteuid(real_uid);
#line 538
  xsetegid(real_gid);
#line 540
  __cil_tmp6 = strlen((char const   *)((char *)SockPath));
#line 540
  __cil_tmp7 = connect(s, 0, (socklen_t )(__cil_tmp6 + 2UL));
  }
#line 540
  if (__cil_tmp7 != -1) {
    {
#line 542
    while (1) {
      while_continue: /* CIL Label */ ;
#line 542
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 543
    if (quietflag) {
      {
#line 545
      Kill(display->d_userpid, 1);
#line 550
      eexit(11);
      }
    }
    {
#line 552
    __cil_tmp8 = Filename((char *)SockPath);
#line 552
    Msg(0, (char const   *)((char *)"There is already a screen running on %s."), __cil_tmp8);
#line 554
    __cil_tmp9 = stat((char const   *)((char *)SockPath), & st);
    }
#line 554
    if (__cil_tmp9 < 0) {
      {
#line 555
      __cil_tmp10 = __errno_location();
#line 555
      Panic(*__cil_tmp10, (char const   *)((char *)"stat"));
      }
    }
#line 559
    if (st.st_uid != (unsigned int )real_uid) {
      {
#line 560
      Panic(0, (char const   *)((char *)"Unfortunately you are not its owner."));
      }
    }
#line 562
    if ((st.st_mode & 448U) == 384U) {
      {
#line 563
      Panic(0, (char const   *)((char *)"To resume it, use \"screen -r\""));
      }
    } else {
      {
#line 565
      Panic(0, (char const   *)((char *)"It is not detached."));
      }
    }
  }
  {
#line 575
  __cil_tmp11 = unlink((char const   *)((char *)SockPath));
#line 576
  __cil_tmp12 = strlen((char const   *)((char *)SockPath));
#line 576
  __cil_tmp13 = bind(s, 0, (socklen_t )(__cil_tmp12 + 2UL));
  }
#line 576
  if (__cil_tmp13 == -1) {
    {
#line 577
    __cil_tmp14 = __errno_location();
#line 577
    Panic(*__cil_tmp14, (char const   *)((char *)"bind (%s)"), (char *)SockPath);
    }
  }
#line 586
  if (multi) {
#line 586
    tmp___930 = 1;
  } else {
#line 586
    tmp___930 = 0;
  }
#line 586
  if (displays) {
#line 586
    tmp = 64;
  } else {
#line 586
    tmp = 0;
  }
  {
#line 586
  chmod((char const   *)((char *)SockPath), (__mode_t )((384 | tmp) | tmp___930));
#line 591
  __cil_tmp17 = listen(s, 5);
  }
#line 591
  if (__cil_tmp17 == -1) {
    {
#line 592
    __cil_tmp18 = __errno_location();
#line 592
    Panic(*__cil_tmp18, (char const   *)((char *)"listen"));
    }
  }
  {
#line 594
  __cil_tmp19 = getpid();
#line 594
  fcntl(s, 8, __cil_tmp19);
  }
  {
#line 595
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 595
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 598
  xseteuid(eff_uid);
#line 599
  xsetegid(eff_gid);
  }
#line 601
  return (s);
}
}
#line 605 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static int MakeClientUnixSocket(int err ) 
{ 
  register int s ;
  struct sockaddr_un a ;
  int *__cil_tmp5 ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  int *__cil_tmp8 ;

  {
  {
#line 611
  s = socket(1, 1, 0);
  }
#line 612
  if (s < 0) {
    {
#line 613
    __cil_tmp5 = __errno_location();
#line 613
    Panic(*__cil_tmp5, (char const   *)((char *)"socket"));
    }
  }
  {
#line 615
  a.sun_family = (sa_family_t )1;
#line 616
  strncpy((char *)a.sun_path, (char const   *)((char *)SockPath), sizeof(a.sun_path));
#line 617
  a.sun_path[sizeof(a.sun_path) - 1UL] = (char )0;
#line 619
  xseteuid(real_uid);
#line 620
  xsetegid(real_gid);
#line 631
  __cil_tmp6 = strlen((char const   *)((char *)SockPath));
#line 631
  __cil_tmp7 = connect(s, 0, (socklen_t )(__cil_tmp6 + 2UL));
  }
#line 631
  if (__cil_tmp7 == -1) {
#line 633
    if (err) {
      {
#line 634
      __cil_tmp8 = __errno_location();
#line 634
      Msg(*__cil_tmp8, (char const   *)((char *)"%s: connect"), (char *)SockPath);
      }
    }
    {
#line 635
    while (1) {
      while_continue: /* CIL Label */ ;
#line 635
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 636
    close(s);
#line 637
    s = - 1;
    }
  }
  {
#line 640
  xseteuid(eff_uid);
#line 641
  xsetegid(eff_gid);
  }
#line 643
  return (s);
}
}
#line 647 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
int MakeServerSocket(int socket___0 ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 650
  if (socket___0) {
    {
#line 651
    __cil_tmp2 = MakeServerUnixSocket();
    }
#line 651
    return (__cil_tmp2);
  }
  {
#line 653
  __cil_tmp3 = MakeServerFifo();
  }
#line 653
  return (__cil_tmp3);
}
}
#line 657 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
int MakeClientSocket(int err , int socket___0 ) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 661
  if (socket___0) {
    {
#line 662
    __cil_tmp3 = MakeClientUnixSocket(err);
    }
#line 662
    return (__cil_tmp3);
  }
  {
#line 664
  __cil_tmp4 = MakeClientFifo(err);
  }
#line 664
  return (__cil_tmp4);
}
}
#line 674 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
void SendCreateMsg(char *sty , struct NewWindow *nwin ) 
{ 
  int s ;
  struct msg m ;
  register char *p ;
  register int len___931 ;
  register int n ;
  char **av ;
  int is_socket ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  char *__cil_tmp17 ;
  int *__cil_tmp18 ;
  ssize_t __cil_tmp19 ;
  int *__cil_tmp20 ;

  {
  {
#line 686
  __cil_tmp10 = strlen((char const   *)sty);
  }
#line 686
  if (__cil_tmp10 > 255UL) {
#line 687
    *(sty + 255) = (char )0;
  }
  {
#line 689
  __cil_tmp11 = strlen((char const   *)sty);
  }
#line 689
  if (__cil_tmp11 > 1535UL) {
#line 690
    *(sty + 1535) = (char )0;
  }
  {
#line 691
  __cil_tmp12 = strlen((char const   *)((char *)SockPath));
#line 691
  sprintf((char *)SockPath + __cil_tmp12, (char const   *)((char *)"/%s"), sty);
#line 692
  is_socket = IsSocket((char const   *)((char *)SockPath));
#line 693
  s = MakeClientSocket(1, is_socket);
  }
#line 693
  if (s == -1) {
    {
#line 694
    exit(1);
    }
  }
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 696
  bzero((void *)((char *)(& m)), sizeof(m));
#line 697
  m.type = 0;
#line 698
  strncpy((char *)m.m_tty, (char const   *)attach_tty, sizeof(m.m_tty) - 1UL);
#line 699
  m.m_tty[sizeof(m.m_tty) - 1UL] = (char )0;
#line 700
  p = (char *)m.m.create.line;
#line 701
  n = 0;
  }
#line 702
  if (nwin->args != nwin_undef.args) {
#line 703
    av = nwin->args;
    {
#line 703
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 703
      if (! (*av && n < 63)) {
#line 703
        goto while_break___0;
      }
      {
#line 705
      __cil_tmp15 = strlen((char const   *)*av);
#line 705
      len___931 = (int )(__cil_tmp15 + 1UL);
      }
#line 706
      if (p + len___931 >= ((char *)m.m.create.line + sizeof(m.m.create.line)) - 1) {
#line 707
        goto while_break___0;
      }
      {
#line 708
      strcpy(p, (char const   *)*av);
#line 709
      p += len___931;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 703
    n ++;
#line 703
    av ++;
  }
  {
#line 711
  __cil_tmp16 = strlen((char const   *)nwin->aka);
  }
#line 711
  if (nwin->aka != nwin_undef.aka) {
#line 711
    if ((p + __cil_tmp16) + 1 < (char *)m.m.create.line + sizeof(m.m.create.line)) {
      {
#line 712
      strcpy(p, (char const   *)nwin->aka);
      }
    } else {
#line 714
      *p = (char )'\000';
    }
  } else {
#line 714
    *p = (char )'\000';
  }
  {
#line 715
  m.m.create.nargs = n;
#line 716
  m.m.create.aflag = nwin->aflag;
#line 717
  m.m.create.flowflag = nwin->flowflag;
#line 718
  m.m.create.lflag = nwin->lflag;
#line 719
  m.m.create.hheight = nwin->histheight;
#line 720
  __cil_tmp17 = getcwd((char *)m.m.create.dir, sizeof(m.m.create.dir));
  }
#line 720
  if (__cil_tmp17 == (char *)0) {
    {
#line 722
    __cil_tmp18 = __errno_location();
#line 722
    Msg(*__cil_tmp18, (char const   *)((char *)"getcwd"));
    }
#line 723
    goto end;
  }
#line 725
  if (nwin->term != nwin_undef.term) {
    {
#line 726
    strncpy((char *)m.m.create.screenterm, (char const   *)nwin->term, (unsigned long )32);
    }
  }
#line 727
  m.m.create.screenterm[32] = (char )'\000';
#line 728
  m.protocol_revision = (((109 << 24) | (115 << 16)) | (103 << 8)) | 5;
  {
#line 729
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 729
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 730
  __cil_tmp19 = write(s, (void const   *)((char *)(& m)), sizeof(m));
  }
#line 730
  if ((unsigned long )__cil_tmp19 != sizeof(m)) {
    {
#line 731
    __cil_tmp20 = __errno_location();
#line 731
    Msg(*__cil_tmp20, (char const   *)((char *)"write"));
    }
  }
  end: 
  {
#line 734
  close(s);
  }
  return;
}
}
#line 738 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
int SendErrorMsg(char *tty , char *buf ) 
{ 
  int s ;
  struct msg m ;
  int is_socket ;
  ssize_t __cil_tmp8 ;

  {
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 746
  strncpy((char *)m.m.message, (char const   *)buf, sizeof(m.m.message) - 1UL);
#line 747
  m.m.message[sizeof(m.m.message) - 1UL] = (char )0;
#line 748
  is_socket = IsSocket((char const   *)((char *)SockPath));
#line 749
  s = MakeClientSocket(0, is_socket);
  }
#line 750
  if (s < 0) {
#line 751
    return (- 1);
  }
  {
#line 752
  m.type = 1;
#line 753
  strncpy((char *)m.m_tty, (char const   *)tty, sizeof(m.m_tty) - 1UL);
#line 754
  m.m_tty[sizeof(m.m_tty) - 1UL] = (char )0;
#line 755
  m.protocol_revision = (((109 << 24) | (115 << 16)) | (103 << 8)) | 5;
  }
  {
#line 756
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 756
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 757
  __cil_tmp8 = write(s, (void const   *)((char *)(& m)), sizeof(m));
#line 758
  close(s);
  }
#line 759
  return (0);
}
}
#line 763 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static void ExecCreate(struct msg *mp ) 
{ 
  struct NewWindow nwin ;
  char *args[64] ;
  register int n ;
  register char **pp ;
  register char *p ;
  char buf[20] ;
  int l ;
  int num ;
  size_t __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp13 ;
  char **__cil_tmp14 ;
  size_t __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 769
  pp = (char **)args;
#line 769
  p = (char *)mp->m.create.line;
#line 772
  nwin = nwin_undef;
#line 773
  n = mp->m.create.nargs;
#line 774
  if (n > 63) {
#line 775
    n = 63;
  }
#line 777
  if (n) {
    {
#line 781
    __cil_tmp10 = strlen((char const   *)p);
#line 781
    l = (int )__cil_tmp10;
#line 782
    __cil_tmp11 = IsNumColon(p, 10, (char *)buf, (int )sizeof(buf));
    }
#line 782
    if (__cil_tmp11) {
#line 784
      if (*((char *)buf)) {
#line 785
        nwin.aka = (char *)buf;
      }
      {
#line 786
      num = atoi((char const   *)p);
      }
#line 787
      if (num < 0) {
#line 788
        num = 0;
      } else
#line 787
      if (num > maxwin - 1) {
#line 788
        num = 0;
      }
#line 789
      nwin.StartAt = num;
#line 790
      p += l + 1;
#line 791
      __cil_tmp13 = n;
#line 791
      n --;
    }
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
#line 794
    if (! (n > 0)) {
#line 794
      goto while_break;
    }
    {
#line 796
    __cil_tmp14 = pp;
#line 796
    pp ++;
#line 796
    *__cil_tmp14 = p;
#line 797
    __cil_tmp15 = strlen((char const   *)p);
    }
#line 797
    p += __cil_tmp15 + 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 794
  __cil_tmp16 = n;
#line 794
  n --;
#line 799
  *pp = (char *)0;
#line 800
  if (*p) {
#line 801
    nwin.aka = p;
  }
#line 802
  if (*((char **)args)) {
#line 803
    nwin.args = (char **)args;
  }
#line 804
  nwin.aflag = mp->m.create.aflag;
#line 805
  nwin.flowflag = mp->m.create.flowflag;
#line 806
  if (*((char *)mp->m.create.dir)) {
#line 807
    nwin.dir = (char *)mp->m.create.dir;
  }
#line 808
  nwin.lflag = mp->m.create.lflag;
#line 809
  nwin.histheight = mp->m.create.hheight;
#line 810
  if (*((char *)mp->m.create.screenterm)) {
#line 811
    nwin.term = (char *)mp->m.create.screenterm;
  }
  {
#line 812
  MakeWindow(& nwin);
  }
  return;
}
}
#line 816 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static int CheckPid(int pid ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 820
  if (pid < 2) {
#line 821
    return (- 1);
  }
#line 822
  if (eff_uid == real_uid) {
    {
#line 823
    __cil_tmp2 = kill(pid, 0);
    }
#line 823
    return (__cil_tmp2);
  }
  {
#line 824
  __cil_tmp3 = UserContext();
  }
#line 824
  if (__cil_tmp3 > 0) {
    {
#line 825
    __cil_tmp4 = kill(pid, 0);
#line 825
    UserReturn(__cil_tmp4);
    }
  }
  {
#line 826
  __cil_tmp5 = UserStatus();
  }
#line 826
  return (__cil_tmp5);
}
}
#line 857 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static int CreateTempDisplay(struct msg *m , int recvfd , struct win *wi ) 
{ 
  int pid ;
  int attach ;
  char *user ;
  int i ;
  struct mode Mode ;
  struct display *olddisplays ;
  int __cil_tmp10 ;
  int ret ;
  char ttyname_in_ns[4096] ;
  char *myttyname ;
  int *__cil_tmp14 ;
  int *__cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  int *__cil_tmp18 ;
  int __cil_tmp19 ;
  int *__cil_tmp20 ;
  char *tmp ;
  int __cil_tmp22 ;
  int *__cil_tmp23 ;
  char *tmp___0 ;
  int *__cil_tmp26 ;
  int __cil_tmp27 ;
  struct acluser **__cil_tmp28 ;
  char *tmp___1 ;
  struct display *__cil_tmp30 ;
  int tmp___933 ;
  int tmp___934 ;
  char *__cil_tmp33 ;
  int __cil_tmp34 ;
  int *__cil_tmp35 ;

  {
#line 867
  olddisplays = displays;
  {
#line 872
  if (m->type == 2) {
#line 872
    goto case_2;
  }
#line 872
  if (m->type == 3) {
#line 872
    goto case_2;
  }
#line 880
  if (m->type == 5) {
#line 880
    goto case_5;
  }
#line 880
  if (m->type == 4) {
#line 880
    goto case_5;
  }
#line 887
  goto switch_default;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 873
  pid = m->m.attach.apid;
#line 874
  user = (char *)m->m.attach.auser;
#line 875
  attach = 1;
#line 876
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 882
  pid = m->m.detach.dpid;
#line 883
  user = (char *)m->m.detach.duser;
#line 884
  attach = 0;
#line 885
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 888
  return (- 1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 891
  __cil_tmp10 = CheckPid(pid);
  }
#line 891
  if (__cil_tmp10) {
    {
#line 893
    Msg(0, (char const   *)((char *)"Attach attempt with bad pid(%d)!"), pid);
    }
#line 894
    return (- 1);
  }
#line 896
  if (recvfd != -1) {
    {
#line 902
    i = recvfd;
#line 903
    recvfd = - 1;
#line 904
    memset((void *)(& ttyname_in_ns), 0, sizeof(ttyname_in_ns));
#line 905
    __cil_tmp14 = __errno_location();
#line 905
    *__cil_tmp14 = 0;
#line 906
    myttyname = GetPtsPathOrSymlink(i);
#line 907
    __cil_tmp16 = __errno_location();
    }
#line 907
    if (myttyname) {
#line 907
      if (*__cil_tmp16 == 19) {
        {
#line 909
        __cil_tmp17 = readlink((char const   *)myttyname, (char *)ttyname_in_ns, sizeof(ttyname_in_ns));
#line 909
        ret = (int )__cil_tmp17;
        }
#line 910
        if (ret < 0) {
          {
          {
#line 912
          __cil_tmp18 = __errno_location();
          }
          {
#line 912
          Msg(*__cil_tmp18, (char const   *)((char *)"Could not perform necessary sanity checks on pts device."));
          }
          {
#line 913
          close(i);
          }
          {
#line 914
          Kill(pid, 1);
          }
          }
#line 915
          return (- 1);
        } else
#line 910
        if ((size_t )ret >= sizeof(ttyname_in_ns)) {
          {
          {
#line 912
          __cil_tmp18 = __errno_location();
          }
          {
#line 912
          Msg(*__cil_tmp18, (char const   *)((char *)"Could not perform necessary sanity checks on pts device."));
          }
          {
#line 913
          close(i);
          }
          {
#line 914
          Kill(pid, 1);
          }
          }
#line 915
          return (- 1);
        }
        {
#line 917
        __cil_tmp19 = strcmp((char const   *)((char *)ttyname_in_ns), (char const   *)((char *)m->m_tty));
        }
#line 917
        if (__cil_tmp19) {
          {
#line 919
          __cil_tmp20 = __errno_location();
          }
#line 919
          if ((int )m->m_tty[0] != 0) {
#line 919
            tmp = (char *)m->m_tty;
          } else {
#line 919
            tmp = (char *)"(null)";
          }
          {
#line 919
          Msg(*__cil_tmp20, (char const   *)((char *)"Attach: passed fd does not match tty: %s - %s!"),
              (char *)ttyname_in_ns, tmp);
#line 920
          close(i);
#line 921
          Kill(pid, 1);
          }
#line 922
          return (- 1);
        }
        {
#line 931
        strncpy((char *)m->m_tty, (char const   *)myttyname, sizeof(m->m_tty) - 1UL);
#line 932
        m->m_tty[sizeof(m->m_tty) - 1UL] = (char )0;
        }
      } else {
#line 907
        goto _L___932;
      }
    } else {
      _L___932: /* CIL Label */ 
      {
#line 934
      __cil_tmp22 = strcmp((char const   *)myttyname, (char const   *)((char *)m->m_tty));
      }
#line 934
      if (myttyname == (char *)0) {
        _L: /* CIL Label */ 
        {
#line 936
        __cil_tmp23 = __errno_location();
        }
#line 936
        if (myttyname) {
#line 936
          tmp___0 = myttyname;
        } else {
#line 936
          tmp___0 = (char *)"NULL";
        }
        {
#line 936
        Msg(*__cil_tmp23, (char const   *)((char *)"Attach: passed fd does not match tty: %s - %s!"),
            (char *)m->m_tty, tmp___0);
#line 937
        close(i);
#line 938
        Kill(pid, 1);
        }
#line 939
        return (- 1);
      } else
#line 934
      if (__cil_tmp22) {
#line 934
        goto _L;
      }
    }
  } else {
    {
#line 942
    i = secopen((char *)m->m_tty, 2050, 0);
    }
#line 942
    if (i < 0) {
      {
#line 944
      __cil_tmp26 = __errno_location();
#line 944
      Msg(*__cil_tmp26, (char const   *)((char *)"Attach: Could not open %s!"), (char *)m->m_tty);
#line 945
      Kill(pid, 1);
      }
#line 946
      return (- 1);
    }
  }
#line 949
  if (attach) {
    {
#line 950
    Kill(pid, 18);
    }
  }
#line 957
  if (attach) {
#line 959
    if (display) {
      {
      {
#line 961
      write(i, (void const   *)((char *)"Attaching from inside of screen?\n"), (size_t )33);
      }
      {
#line 962
      close(i);
      }
      {
#line 963
      Kill(pid, 1);
      }
      {
#line 964
      Msg(0, (char const   *)((char *)"Attach msg ignored: coming from inside."));
      }
      }
#line 965
      return (- 1);
    } else
#line 959
    if (wi) {
      {
      {
#line 961
      write(i, (void const   *)((char *)"Attaching from inside of screen?\n"), (size_t )33);
      }
      {
#line 962
      close(i);
      }
      {
#line 963
      Kill(pid, 1);
      }
      {
#line 964
      Msg(0, (char const   *)((char *)"Attach msg ignored: coming from inside."));
      }
      }
#line 965
      return (- 1);
    }
    {
#line 969
    __cil_tmp27 = strcmp((char const   *)user, (char const   *)LoginName);
    }
#line 969
    if (__cil_tmp27) {
      {
#line 970
      __cil_tmp28 = FindUserPtr(user);
      }
#line 970
      if (*__cil_tmp28 == (struct acluser *)0) {
        {
#line 972
        write(i, (void const   *)((char *)"Access to session denied.\n"), (size_t )26);
#line 973
        close(i);
#line 974
        Kill(pid, 1);
#line 975
        Msg(0, (char const   *)((char *)"Attach: access denied for user %s."), user);
        }
#line 976
        return (- 1);
      }
    }
    {
#line 980
    while (1) {
      while_continue: /* CIL Label */ ;
#line 980
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 993
  GetTTY(i, & Mode);
  }
#line 994
  if (attach) {
#line 994
    tmp___1 = (char *)m->m.attach.envterm;
  } else {
#line 994
    tmp___1 = (char *)"";
  }
  {
#line 994
  __cil_tmp30 = MakeDisplay(user, (char *)m->m_tty, tmp___1, i, pid, & Mode);
  }
#line 994
  if (__cil_tmp30 == (struct display *)0) {
    {
#line 996
    write(i, (void const   *)((char *)"Could not make display.\n"), (size_t )24);
#line 997
    close(i);
#line 998
    Msg(0, (char const   *)((char *)"Attach: could not make display for user %s"),
        user);
#line 999
    Kill(pid, 1);
    }
#line 1000
    return (- 1);
  }
#line 1003
  if (attach) {
#line 1006
    if (m->m.attach.encoding == 1) {
#line 1006
      tmp___934 = 8;
    } else {
#line 1006
      if (m->m.attach.encoding) {
#line 1006
        tmp___933 = m->m.attach.encoding - 1;
      } else {
#line 1006
        tmp___933 = 0;
      }
#line 1006
      tmp___934 = tmp___933;
    }
    {
#line 1006
    display->d_encoding = tmp___934;
#line 1010
    __cil_tmp33 = EncodingName(display->d_encoding);
    }
#line 1010
    if (display->d_encoding < 0) {
#line 1011
      display->d_encoding = 0;
    } else
#line 1010
    if (! __cil_tmp33) {
#line 1011
      display->d_encoding = 0;
    }
  }
#line 1015
  if (iflag) {
#line 1015
    if (olddisplays) {
      {
#line 1017
      iflag = 0;
#line 1019
      olddisplays->d_NewMode.tio.c_cc[0] = (cc_t )'\000';
#line 1020
      olddisplays->d_NewMode.tio.c_lflag &= (unsigned int )(~ 1);
#line 1024
      SetTTY(olddisplays->d_userfd, & olddisplays->d_NewMode);
      }
    }
  }
  {
#line 1026
  SetMode(& display->d_OldMode, & display->d_NewMode, display->d_flow, iflag);
#line 1027
  SetTTY(display->d_userfd, & display->d_NewMode);
#line 1028
  __cil_tmp34 = fcntl(display->d_userfd, 4, 2048);
  }
#line 1028
  if (__cil_tmp34) {
    {
#line 1029
    __cil_tmp35 = __errno_location();
#line 1029
    Msg(*__cil_tmp35, (char const   *)((char *)"Warning: NBLOCK fcntl failed"));
    }
  }
#line 1030
  return (0);
}
}
#line 1034 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
void ReceiveMsg(void) 
{ 
  int left ;
  int len___935 ;
  static struct msg m ;
  char *p ;
  int ns ;
  struct win *wi ;
  int recvfd ;
  struct acluser *user ;
  int is_socket ;
  struct sockaddr_un a ;
  struct msghdr msg ;
  struct iovec iov ;
  char control[1024] ;
  int __cil_tmp15 ;
  int *__cil_tmp16 ;
  int *__cil_tmp18 ;
  ssize_t __cil_tmp19 ;
  int *__cil_tmp20 ;
  int *__cil_tmp21 ;
  struct cmsghdr *cmsg ;
  struct cmsghdr *tmp ;
  int cl ;
  char *cp ;
  int passedfd ;
  ssize_t __cil_tmp28 ;
  int *__cil_tmp29 ;
  int *__cil_tmp31 ;
  int *__cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  struct display *tmp___0 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int blocked ;
  int __cil_tmp40 ;
  char *oldSockPath ;
  char *__cil_tmp42 ;
  int is_socket___936 ;
  int __cil_tmp44 ;
  int s ;
  int __cil_tmp46 ;
  int tmp___1 ;

  {
  {
#line 1039
  ns = ServerSocket;
#line 1041
  recvfd = - 1;
#line 1051
  is_socket = IsSocket((char const   *)((char *)SockPath));
  }
#line 1052
  if (! is_socket) {
    {
#line 1054
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1054
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1055
    __cil_tmp15 = fcntl(ServerSocket, 4, 0);
    }
#line 1055
    if (__cil_tmp15 == -1) {
      {
#line 1056
      __cil_tmp16 = __errno_location();
#line 1056
      Panic(*__cil_tmp16, (char const   *)((char *)"BLOCK fcntl"));
      }
    }
#line 1057
    p = (char *)(& m);
#line 1058
    left = (int )sizeof(m);
  } else {
#line 1062
    len___935 = (int )sizeof(a);
    {
#line 1063
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1063
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1064
    ns = accept(ns, 0, (socklen_t *)((void *)(& len___935)));
    }
#line 1064
    if (ns < 0) {
      {
#line 1066
      __cil_tmp18 = __errno_location();
#line 1066
      Msg(*__cil_tmp18, (char const   *)((char *)"accept"));
      }
#line 1067
      return;
    }
    {
#line 1070
    p = (char *)(& m);
#line 1071
    left = (int )sizeof(m);
#line 1072
    bzero((void *)(& msg), sizeof(msg));
#line 1073
    iov.iov_base = (void *)(& m);
#line 1074
    iov.iov_len = (size_t )left;
#line 1075
    msg.msg_iov = & iov;
#line 1076
    msg.msg_iovlen = (size_t )1;
#line 1077
    msg.msg_controllen = sizeof(control);
#line 1078
    msg.msg_control = (void *)(& control);
    }
    {
#line 1079
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1079
      if (! (left > 0)) {
#line 1079
        goto while_break___1;
      }
      {
#line 1081
      __cil_tmp19 = recvmsg(ns, & msg, 0);
#line 1081
      len___935 = (int )__cil_tmp19;
#line 1082
      __cil_tmp20 = __errno_location();
      }
#line 1082
      if (len___935 < 0) {
#line 1082
        if (*__cil_tmp20 == 4) {
#line 1083
          goto while_continue___1;
        }
      }
#line 1084
      if (len___935 < 0) {
        {
#line 1086
        close(ns);
#line 1087
        __cil_tmp21 = __errno_location();
#line 1087
        Msg(*__cil_tmp21, (char const   *)((char *)"read"));
        }
#line 1088
        return;
      }
#line 1090
      if (msg.msg_controllen) {
#line 1093
        if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 1093
          tmp = (struct cmsghdr *)msg.msg_control;
        } else {
#line 1093
          tmp = (struct cmsghdr *)0;
        }
#line 1093
        cmsg = tmp;
        {
#line 1093
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1093
          if (! cmsg) {
#line 1093
            goto while_break___2;
          }
#line 1098
          if (cmsg->cmsg_level != 1) {
#line 1100
            goto while_continue___2;
          } else
#line 1098
          if (cmsg->cmsg_type != 1) {
#line 1100
            goto while_continue___2;
          }
#line 1101
          cp = (char *)((unsigned char *)cmsg->__cmsg_data);
#line 1102
          cl = (int )cmsg->cmsg_len;
          {
#line 1103
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1103
            if (! ((unsigned long )cl >= (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(int ))) {
#line 1103
              goto while_break___3;
            }
            {
#line 1106
            bcopy((void const   *)cp, (void *)(& passedfd), sizeof(int ));
            }
#line 1107
            if (recvfd >= 0) {
#line 1107
              if (passedfd != recvfd) {
                {
#line 1108
                close(recvfd);
                }
              }
            }
#line 1109
            recvfd = passedfd;
#line 1110
            cl -= (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(int );
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1094
        cmsg = __cmsg_nxthdr(& msg, cmsg);
        }
      }
#line 1114
      p += len___935;
#line 1115
      left -= len___935;
#line 1116
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1120
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1120
    if (! (left > 0)) {
#line 1120
      goto while_break___4;
    }
    {
#line 1122
    __cil_tmp28 = read(ns, (void *)p, (size_t )left);
#line 1122
    len___935 = (int )__cil_tmp28;
#line 1123
    __cil_tmp29 = __errno_location();
    }
#line 1123
    if (len___935 < 0) {
#line 1123
      if (*__cil_tmp29 == 4) {
#line 1124
        goto while_continue___4;
      }
    }
#line 1125
    if (len___935 <= 0) {
#line 1126
      goto while_break___4;
    }
#line 1127
    p += len___935;
#line 1128
    left -= len___935;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1131
  if (! is_socket) {
    {
#line 1135
    close(ServerSocket);
#line 1136
    ServerSocket = secopen((char *)SockPath, 2048, 0);
    }
#line 1136
    if (ServerSocket < 0) {
      {
#line 1137
      __cil_tmp31 = __errno_location();
#line 1137
      Panic(*__cil_tmp31, (char const   *)((char *)"reopen fifo %s"), (char *)SockPath);
      }
    }
    {
#line 1138
    evdeq(& serv_read);
#line 1139
    serv_read.fd = ServerSocket;
#line 1140
    evenq(& serv_read);
    }
  } else {
    {
#line 1145
    close(ns);
    }
  }
#line 1148
  if (len___935 < 0) {
    {
#line 1150
    __cil_tmp32 = __errno_location();
#line 1150
    Msg(*__cil_tmp32, (char const   *)((char *)"read"));
    }
#line 1151
    if (recvfd != -1) {
      {
#line 1152
      close(recvfd);
      }
    }
#line 1153
    return;
  }
#line 1155
  if (left > 0) {
#line 1157
    if ((unsigned long )left != sizeof(m)) {
      {
#line 1158
      Msg(0, (char const   *)((char *)"Message %d of %d bytes too small"), left, (int )sizeof(m));
      }
    } else {
      {
#line 1160
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1160
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1161
    return;
  }
#line 1163
  if (m.protocol_revision != ((((109 << 24) | (115 << 16)) | (103 << 8)) | 5)) {
#line 1165
    if (recvfd != -1) {
      {
#line 1166
      close(recvfd);
      }
    }
    {
#line 1167
    Msg(0, (char const   *)((char *)"Invalid message (magic 0x%08x)."), m.protocol_revision);
    }
#line 1168
    return;
  }
  {
#line 1171
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1171
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1172
  if (m.type != 2) {
#line 1172
    if (recvfd != -1) {
      {
#line 1174
      close(recvfd);
#line 1175
      recvfd = - 1;
      }
    }
  }
#line 1178
  display = displays;
  {
#line 1178
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1178
    if (! display) {
#line 1178
      goto while_break___7;
    }
    {
#line 1179
    __cil_tmp33 = strcmp((char const   *)((char *)display->d_usertty), (char const   *)((char *)m.m_tty));
    }
#line 1179
    if (__cil_tmp33 == 0) {
#line 1180
      goto while_break___7;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1178
  display = display->d_next;
  {
#line 1181
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1181
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1182
  wi = (struct win *)0;
#line 1183
  if (! display) {
#line 1185
    wi = windows;
    {
#line 1185
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1185
      if (! wi) {
#line 1185
        goto while_break___9;
      }
      {
#line 1186
      __cil_tmp34 = strcmp((char const   *)((char *)m.m_tty), (char const   *)((char *)wi->w_tty));
      }
#line 1186
      if (! __cil_tmp34) {
#line 1189
        if (wi->w_layer.l_cvlist) {
#line 1189
          tmp___0 = (wi->w_layer.l_cvlist)->c_display;
        } else {
#line 1189
          tmp___0 = (struct display *)0;
        }
#line 1189
        display = tmp___0;
        {
#line 1191
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1191
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1193
        goto while_break___9;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1185
    wi = wi->w_next;
  }
#line 1198
  if (display) {
#line 1198
    if (display->d_status) {
      {
#line 1199
      RemoveStatus();
      }
    }
  }
#line 1201
  if (display) {
#line 1201
    if (! display->d_tcinited) {
#line 1201
      if (m.type != 7) {
#line 1203
        if (recvfd != -1) {
          {
#line 1204
          close(recvfd);
          }
        }
#line 1205
        return;
      }
    }
  }
  {
#line 1210
  if (m.type == 6) {
#line 1210
    goto case_6;
  }
#line 1214
  if (m.type == 0) {
#line 1214
    goto case_0;
  }
#line 1223
  if (m.type == 3) {
#line 1223
    goto case_3;
  }
#line 1230
  if (m.type == 2) {
#line 1230
    goto case_2;
  }
#line 1240
  if (m.type == 1) {
#line 1240
    goto case_1;
  }
#line 1249
  if (m.type == 7) {
#line 1249
    goto case_7;
  }
#line 1256
  if (m.type == 5) {
#line 1256
    goto case_5;
  }
#line 1256
  if (m.type == 4) {
#line 1256
    goto case_5;
  }
#line 1271
  if (m.type == 9) {
#line 1271
    goto case_9;
  }
#line 1295
  if (m.type == 8) {
#line 1295
    goto case_8;
  }
#line 1298
  goto switch_default;
  case_6: /* CIL Label */ 
#line 1211
  if (display) {
    {
#line 1212
    CheckScreenSize(1);
    }
  }
#line 1213
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1221
  ExecCreate(& m);
  }
#line 1222
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1224
  __cil_tmp36 = kill(display->d_userpid, 0);
  }
#line 1224
  if (display) {
#line 1224
    if (display->d_userpid != 0) {
#line 1224
      if (__cil_tmp36 == 0) {
#line 1225
        goto switch_break;
      }
    }
  }
  {
#line 1226
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1226
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  case_2: /* CIL Label */ 
  {
#line 1231
  __cil_tmp37 = CreateTempDisplay(& m, recvfd, wi);
  }
#line 1231
  if (__cil_tmp37) {
#line 1232
    goto switch_break;
  }
#line 1234
  if ((display->d_user)->u_password) {
#line 1234
    if ((int )*((display->d_user)->u_password)) {
      {
#line 1235
      AskPassword(& m);
      }
    } else {
      {
      {
#line 1238
      FinishAttach(& m);
      }
      }
    }
  } else {
    {
    {
#line 1238
    FinishAttach(& m);
    }
    }
  }
#line 1239
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1242
  blocked = display->d_blocked;
#line 1243
  if (display->d_blocked == 4) {
#line 1244
    display->d_blocked = 0;
  }
  {
#line 1245
  Msg(0, (char const   *)((char *)"%s"), (char *)m.m.message);
#line 1246
  display->d_blocked = blocked;
  }
#line 1248
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1250
  if (! wi) {
    {
#line 1251
    Hangup();
    }
  }
#line 1252
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 1259
  user = (struct acluser *)FindUserPtr((char *)m.m.detach.duser);
  }
#line 1260
  if (user) {
#line 1260
    if (user->u_password) {
#line 1260
      if ((int )*(user->u_password)) {
        {
#line 1262
        __cil_tmp40 = CreateTempDisplay(& m, recvfd, (struct win *)0);
        }
#line 1262
        if (__cil_tmp40) {
#line 1263
          goto switch_break;
        }
        {
#line 1264
        AskPassword(& m);
        }
      } else {
        {
        {
        {
#line 1268
        FinishDetach(& m);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 1268
      FinishDetach(& m);
      }
      }
      }
    }
  } else {
    {
    {
    {
#line 1268
    FinishDetach(& m);
    }
    }
    }
  }
#line 1269
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1273
  __cil_tmp42 = SaveStr((char const   *)((char *)SockPath));
#line 1273
  oldSockPath = __cil_tmp42;
#line 1274
  strcpy((char *)SockPath, (char const   *)((char *)m.m.command.writeback));
#line 1275
  __cil_tmp44 = IsSocket((char const   *)((char *)SockPath));
#line 1275
  is_socket___936 = __cil_tmp44;
#line 1276
  __cil_tmp46 = MakeClientSocket(0, is_socket___936);
#line 1276
  s = __cil_tmp46;
#line 1277
  strcpy((char *)SockPath, (char const   *)oldSockPath);
  }
#line 1278
  if (oldSockPath == (char *)0) {
    {
#line 1278
    abort();
    }
  } else {
    {
#line 1278
    free((void *)oldSockPath);
    }
  }
#line 1278
  oldSockPath = (char *)0;
#line 1279
  if (s >= 0) {
    {
#line 1281
    queryflag = s;
#line 1282
    DoCommandMsg(& m);
#line 1283
    close(s);
    }
  } else {
#line 1286
    queryflag = - 1;
  }
#line 1288
  if (queryflag >= 0) {
#line 1288
    tmp___1 = 18;
  } else {
#line 1288
    tmp___1 = 1;
  }
  {
#line 1288
  Kill(m.m.command.apid, tmp___1);
#line 1292
  queryflag = - 1;
  }
#line 1294
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1296
  DoCommandMsg(& m);
  }
#line 1297
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1299
  Msg(0, (char const   *)((char *)"Invalid message (type %d)."), m.type);
  }
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1304 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
void ReceiveRaw(int s ) 
{ 
  char rd[256] ;
  int len___937 ;
  struct sockaddr_un a ;
  int is_socket ;
  int __cil_tmp7 ;
  int *__cil_tmp8 ;
  int *__cil_tmp10 ;

  {
  {
#line 1308
  len___937 = 0;
#line 1312
  is_socket = IsSocket((char const   *)((char *)SockPath));
  }
#line 1313
  if (! is_socket) {
    {
#line 1315
    __cil_tmp7 = fcntl(s, 4, 0);
    }
#line 1315
    if (__cil_tmp7 < 0) {
      {
#line 1316
      __cil_tmp8 = __errno_location();
#line 1316
      Panic(*__cil_tmp8, (char const   *)((char *)"BLOCK fcntl"));
      }
    }
  } else {
    {
#line 1320
    len___937 = (int )sizeof(a);
#line 1321
    s = accept(s, 0, (socklen_t *)((void *)(& len___937)));
    }
#line 1322
    if (s < 0) {
      {
#line 1324
      __cil_tmp10 = __errno_location();
#line 1324
      Msg(*__cil_tmp10, (char const   *)((char *)"accept"));
      }
#line 1325
      return;
    }
  }
  {
#line 1329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1329
    if (! (len___937 > 0)) {
#line 1329
      goto while_break;
    }
    {
#line 1331
    rd[len___937] = (char )0;
#line 1332
    printf((char const   *)((char *)"%s"), (char *)rd);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1334
  close(s);
  }
  return;
}
}
#line 1366 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
int chsock(void) 
{ 
  int r ;
  int euid ;
  __uid_t __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int tmp ;
  int tmp___938 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 1368
  __cil_tmp3 = geteuid();
#line 1368
  euid = (int )__cil_tmp3;
  }
#line 1369
  if (euid != real_uid) {
    {
#line 1371
    __cil_tmp4 = UserContext();
    }
#line 1371
    if (__cil_tmp4 <= 0) {
      {
#line 1372
      __cil_tmp5 = UserStatus();
      }
#line 1372
      return (__cil_tmp5);
    }
  }
#line 1374
  if (multi) {
#line 1374
    tmp___938 = 1;
  } else {
#line 1374
    tmp___938 = 0;
  }
#line 1374
  if (displays) {
#line 1374
    tmp = 64;
  } else {
#line 1374
    tmp = 0;
  }
  {
#line 1374
  __cil_tmp8 = chmod((char const   *)((char *)SockPath), (__mode_t )((384 | tmp) | tmp___938));
#line 1374
  r = __cil_tmp8;
#line 1380
  __cil_tmp9 = utimes((char const   *)((char *)SockPath), (struct timeval [2])((void *)0));
  }
#line 1382
  if (euid != real_uid) {
    {
#line 1383
    UserReturn(r);
    }
  }
#line 1384
  return (r);
}
}
#line 1391 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
int RecoverSocket(void) 
{ 
  int is_socket ;
  __uid_t __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 1395
  close(ServerSocket);
#line 1396
  __cil_tmp2 = geteuid();
  }
#line 1396
  if ((int )__cil_tmp2 != real_uid) {
    {
#line 1398
    __cil_tmp3 = UserContext();
    }
#line 1398
    if (__cil_tmp3 > 0) {
      {
#line 1399
      __cil_tmp4 = unlink((char const   *)((char *)SockPath));
#line 1399
      UserReturn(__cil_tmp4);
      }
    }
    {
#line 1400
    __cil_tmp5 = UserStatus();
    }
  } else {
    {
#line 1403
    __cil_tmp6 = unlink((char const   *)((char *)SockPath));
    }
  }
  {
#line 1405
  is_socket = IsSocket((char const   *)((char *)SockPath));
#line 1406
  ServerSocket = MakeServerSocket(is_socket);
  }
#line 1406
  if (ServerSocket < 0) {
#line 1407
    return (0);
  }
  {
#line 1408
  evdeq(& serv_read);
#line 1409
  serv_read.fd = ServerSocket;
#line 1410
  evenq(& serv_read);
  }
#line 1411
  return (1);
}
}
#line 1416 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static void FinishAttach(struct msg *m ) 
{ 
  char *p ;
  int pid ;
  int noshowwin ;
  struct win *wi ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  struct layout *lay ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  struct action newscreen ;
  char *na ;
  int __cil_tmp17 ;
  struct display *olddisplay ;
  int __cil_tmp19 ;

  {
  {
#line 1424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1424
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1425
  pid = display->d_userpid;
#line 1428
  if (m->m.attach.detachfirst == 4) {
    {
    {
#line 1433
    FinishDetach(m);
    }
    }
  } else
#line 1428
  if (m->m.attach.detachfirst == 5) {
    {
    {
#line 1433
    FinishDetach(m);
    }
    }
  }
#line 1453
  if (extra_outcap) {
    {
#line 1454
    free((void *)extra_outcap);
    }
  }
#line 1455
  if (extra_incap) {
    {
#line 1456
    free((void *)extra_incap);
    }
  }
#line 1457
  extra_outcap = (char *)0;
#line 1457
  extra_incap = extra_outcap;
  {
#line 1458
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1458
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1461
  p = getenv((char const   *)((char *)"SYSSCREENRC"));
  }
#line 1461
  if (p) {
    {
#line 1462
    StartRc(p, 1);
    }
  } else {
    {
#line 1465
    StartRc((char *)"/usr/etc/screenrc", 1);
    }
  }
  {
#line 1467
  StartRc(RcFileName, 1);
#line 1468
  __cil_tmp7 = InitTermcap(m->m.attach.columns, m->m.attach.lines);
  }
#line 1468
  if (__cil_tmp7) {
    {
#line 1470
    FreeDisplay();
#line 1471
    Kill(pid, 1);
    }
#line 1472
    return;
  }
  {
#line 1474
  MakeDefaultCanvas();
#line 1475
  InitTerm(m->m.attach.adaptflag);
  }
#line 1476
  if (displays->d_next == (struct display *)0) {
    {
#line 1477
    __cil_tmp8 = chsock();
    }
  }
  {
#line 1478
  xsignal(1, SigHup);
  }
#line 1479
  if (m->m.attach.esc != -1) {
#line 1479
    if (m->m.attach.meta_esc != -1) {
#line 1481
      (display->d_user)->u_Esc = m->m.attach.esc;
#line 1482
      (display->d_user)->u_MetaEsc = m->m.attach.meta_esc;
    }
  }
  {
#line 1491
  RemoveLoginSlot();
  }
#line 1492
  if (displays->d_next == (struct display *)0) {
#line 1493
    wi = windows;
    {
#line 1493
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1493
      if (! wi) {
#line 1493
        goto while_break___1;
      }
#line 1494
      if (wi->w_ptyfd >= 0) {
#line 1494
        if (wi->w_slot != (slot_t )-1) {
          {
#line 1495
          SetUtmp(wi);
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1493
    wi = wi->w_next;
  }
#line 1498
  display->d_fore = (struct win *)((void *)0);
#line 1499
  if (layout_attach) {
#line 1501
    lay = layout_attach;
#line 1502
    if (lay == & layout_last_marker) {
#line 1503
      lay = layout_last;
    }
#line 1504
    if (lay) {
      {
#line 1506
      LoadLayout(lay, & display->d_canvas);
#line 1507
      SetCanvasWindow(display->d_forecv, (struct win *)0);
      }
    }
  }
  {
#line 1513
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1513
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1514
  if ((display->d_user)->u_detachwin >= 0) {
#line 1515
    fore = *(wtab + (display->d_user)->u_detachwin);
  } else {
#line 1517
    fore = (struct win *)0;
  }
#line 1520
  if ((display->d_user)->u_detachotherwin >= 0) {
#line 1521
    display->d_other = *(wtab + (display->d_user)->u_detachotherwin);
  }
#line 1523
  noshowwin = 0;
#line 1524
  if (*((char *)m->m.attach.preselect)) {
    {
#line 1526
    __cil_tmp10 = strcmp((char const   *)((char *)m->m.attach.preselect), (char const   *)((char *)"="));
    }
#line 1526
    if (! __cil_tmp10) {
#line 1527
      fore = (struct win *)0;
    } else {
      {
#line 1528
      __cil_tmp11 = strcmp((char const   *)((char *)m->m.attach.preselect), (char const   *)((char *)"-"));
      }
#line 1528
      if (! __cil_tmp11) {
#line 1530
        fore = (struct win *)0;
#line 1531
        noshowwin = 1;
      } else {
        {
#line 1533
        __cil_tmp12 = strcmp((char const   *)((char *)m->m.attach.preselect), (char const   *)((char *)"+"));
        }
#line 1533
        if (! __cil_tmp12) {
          {
#line 1536
          na = (char *)0;
#line 1537
          newscreen.nr = 143;
#line 1538
          newscreen.args = & na;
#line 1539
          newscreen.quiet = 0;
#line 1540
          DoAction(& newscreen, - 1);
          }
        } else {
          {
#line 1543
          fore = FindNiceWindow(fore, (char *)m->m.attach.preselect);
          }
        }
      }
    }
  } else {
    {
#line 1546
    fore = FindNiceWindow(fore, (char *)0);
    }
  }
#line 1547
  if (fore) {
    {
#line 1548
    SetForeWindow(fore);
    }
  } else
#line 1549
  if (! noshowwin) {
    {
#line 1552
    __cil_tmp17 = AclCheckPermCmd(display->d_user, 0, & comms[180]);
    }
#line 1552
    if (! __cil_tmp17) {
      {
#line 1555
      olddisplay = display;
#line 1556
      flayer = (display->d_forecv)->c_layer;
#line 1557
      display_windows(1, 0, (struct win *)0);
#line 1558
      noshowwin = 1;
#line 1559
      display = olddisplay;
      }
    }
  }
  {
#line 1562
  Activate(0);
#line 1563
  ResetIdle();
  }
#line 1564
  if (! display->d_fore) {
#line 1564
    if (! noshowwin) {
      {
#line 1565
      ShowWindows(- 1);
      }
    }
  }
#line 1566
  if (displays->d_next == (struct display *)0) {
#line 1566
    if (console_window) {
      {
#line 1568
      __cil_tmp19 = TtyGrabConsole(console_window->w_ptyfd, 1, (char *)"reattach");
      }
#line 1568
      if (__cil_tmp19 == 0) {
        {
#line 1569
        Msg(0, (char const   *)((char *)"console %s is on window %d"), (char *)HostName,
            console_window->w_number);
        }
      }
    }
  }
  {
#line 1571
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1571
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  return;
}
}
#line 1584 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static void FinishDetach(struct msg *m ) 
{ 
  struct display *next ;
  struct display **d ;
  struct display *det ;
  int pid ;

  {
#line 1590
  if (m->type == 2) {
#line 1591
    pid = display->d_userpid;
  } else {
#line 1593
    pid = m->m.detach.dpid;
  }
#line 1596
  d = & displays;
  {
#line 1596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1596
    if (! det) {
#line 1596
      goto while_break;
    }
#line 1598
    if (det->d_userpid == pid) {
#line 1599
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1596
  d = & det->d_next;
#line 1601
  if (det) {
#line 1603
    *d = det->d_next;
#line 1604
    det->d_next = (struct display *)0;
  }
#line 1607
  display = displays;
  {
#line 1607
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1607
    if (! display) {
#line 1607
      goto while_break___0;
    }
#line 1609
    next = display->d_next;
#line 1611
    if (m->type == 5) {
      {
#line 1612
      Detach(4);
      }
    } else
#line 1615
    if (m->type == 4) {
      {
#line 1616
      Detach(2);
      }
    } else
#line 1617
    if (m->type == 2) {
#line 1620
      if (m->m.attach.detachfirst == 5) {
        {
#line 1621
        Detach(4);
        }
      } else
#line 1624
      if (m->m.attach.detachfirst == 4) {
        {
#line 1625
        Detach(2);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1607
  display = next;
#line 1628
  displays = det;
#line 1628
  display = displays;
#line 1629
  if (m->type != 2) {
#line 1631
    if (display) {
      {
#line 1632
      FreeDisplay();
      }
    }
    {
#line 1633
    Kill(pid, 18);
    }
  }
  return;
}
}
#line 1638
static void PasswordProcessInput(char *ibuf , int ilen ) ;
#line 1647 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static void AskPassword(struct msg *m ) 
{ 
  struct pwdata *pwdata ;
  void *__cil_tmp3 ;

  {
  {
#line 1651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1651
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1652
  __cil_tmp3 = malloc(sizeof(struct pwdata ));
#line 1652
  pwdata = (struct pwdata *)__cil_tmp3;
  }
#line 1653
  if (! pwdata) {
    {
#line 1654
    Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
  }
  {
#line 1655
  pwdata->l = 0;
#line 1656
  pwdata->m = *m;
#line 1657
  display->d_processinputdata = (char *)pwdata;
#line 1658
  display->d_processinput = PasswordProcessInput;
#line 1659
  AddStr((char *)"Screen password: ");
  }
  return;
}
}
#line 1663 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static void PasswordProcessInput(char *ibuf , int ilen ) 
{ 
  struct pwdata *pwdata ;
  int c ;
  int l ;
  char *up ;
  int pid ;
  int __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *buf ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 1670
  pid = display->d_userpid;
#line 1672
  pwdata = (struct pwdata *)display->d_processinputdata;
#line 1673
  l = pwdata->l;
  {
#line 1674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1674
    if (! (__cil_tmp8 > 0)) {
#line 1674
      goto while_break;
    }
#line 1676
    __cil_tmp9 = ibuf;
#line 1676
    ibuf ++;
#line 1676
    c = (int )*((unsigned char *)__cil_tmp9);
#line 1677
    if (c == 13) {
      _L___939: /* CIL Label */ 
      {
#line 1679
      buf = (char *)((void *)0);
#line 1680
      up = (display->d_user)->u_password;
#line 1681
      pwdata->buf[l] = (char )0;
#line 1682
      buf = crypt((char const   *)((char *)pwdata->buf), (char const   *)up);
#line 1683
      __cil_tmp12 = strlen((char const   *)up);
#line 1683
      __cil_tmp13 = strncmp((char const   *)buf, (char const   *)up, __cil_tmp12);
      }
#line 1683
      if (! buf) {
        _L: /* CIL Label */ 
        {
#line 1686
        bzero((void *)((char *)pwdata->buf), sizeof(pwdata->buf));
        }
#line 1687
        if (! buf) {
          {
#line 1688
          AddStr((char *)"\r\ncrypt() failed.\r\n");
          }
        } else {
          {
#line 1690
          AddStr((char *)"\r\nPassword incorrect.\r\n");
          }
        }
        {
#line 1691
        display->d_processinputdata = (char *)0;
#line 1692
        FreeDisplay();
#line 1693
        Msg(0, (char const   *)((char *)"Illegal reattach attempt from terminal %s."),
            (char *)pwdata->m.m_tty);
#line 1694
        free((void *)pwdata);
#line 1695
        Kill(pid, 1);
        }
#line 1696
        return;
      } else
#line 1683
      if (__cil_tmp13) {
#line 1683
        goto _L;
      }
      {
#line 1699
      bzero((void *)((char *)pwdata->buf), sizeof(pwdata->buf));
#line 1700
      AddStr((char *)"\r\n");
#line 1701
      display->d_processinputdata = (char *)0;
#line 1702
      display->d_processinput = ProcessInput;
      }
#line 1704
      if (pwdata->m.type == 4) {
        {
        {
#line 1709
        FinishDetach(& pwdata->m);
        }
        }
      } else
#line 1704
      if (pwdata->m.type == 5) {
        {
        {
#line 1709
        FinishDetach(& pwdata->m);
        }
        }
      } else {
        {
#line 1712
        FinishAttach(& pwdata->m);
        }
      }
      {
#line 1713
      free((void *)pwdata);
      }
#line 1714
      return;
    } else
#line 1677
    if (c == 10) {
#line 1677
      goto _L___939;
    }
#line 1716
    if (c == 3) {
      {
#line 1718
      AddStr((char *)"\r\n");
#line 1719
      FreeDisplay();
#line 1720
      Kill(pid, 1);
      }
#line 1721
      return;
    }
#line 1723
    if (c == 8) {
      _L___940: /* CIL Label */ 
#line 1725
      if (l > 0) {
#line 1726
        __cil_tmp14 = l;
#line 1726
        l --;
      }
#line 1727
      goto while_continue;
    } else
#line 1723
    if (c == 127) {
#line 1723
      goto _L___940;
    }
#line 1729
    if (c == 21) {
#line 1731
      l = 0;
#line 1732
      goto while_continue;
    }
#line 1734
    if (l < (int )sizeof(pwdata->buf) - 1) {
#line 1735
      __cil_tmp15 = l;
#line 1735
      l ++;
#line 1735
      pwdata->buf[__cil_tmp15] = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1737
  pwdata->l = l;
  return;
}
}
#line 1743 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static char *strncpy_escape_quote(char *dst , char const   *src , char const   *end ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char const   *__cil_tmp6 ;

  {
  {
#line 1747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1747
    if (! ((int )((char )*src) && dst < (char *)end)) {
#line 1747
      goto while_break;
    }
#line 1749
    if ((int )((char )*src) == 34) {
#line 1751
      if (dst + 2 < (char *)end) {
#line 1752
        __cil_tmp4 = dst;
#line 1752
        dst ++;
#line 1752
        *__cil_tmp4 = (char )'\\';
      } else {
#line 1754
        return ((char *)((void *)0));
      }
    }
#line 1756
    __cil_tmp6 = src;
#line 1756
    src ++;
#line 1756
    __cil_tmp5 = dst;
#line 1756
    dst ++;
#line 1756
    *__cil_tmp5 = (char )*__cil_tmp6;
  }
  while_break: /* CIL Label */ ;
  }
#line 1758
  if (dst >= (char *)end) {
#line 1759
    return ((char *)((void *)0));
  }
#line 1761
  *dst = (char )'\000';
#line 1762
  return (dst);
}
}
#line 1766 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
static void DoCommandMsg(struct msg *mp ) 
{ 
  char *args[64] ;
  int argl[64] ;
  char fullcmd[768] ;
  register char *fc ;
  int n ;
  register char *p ;
  struct acluser *user ;
  extern struct acluser *EffectiveAclUser___0 ;
  int len___941 ;
  size_t __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp19 ;
  struct display *tmp ;
  int i ;
  int __cil_tmp22 ;
  struct win *tmp___0 ;
  struct win *tmp___1 ;
  char *oldrcname ;
  struct layer *tmp___2 ;

  {
#line 1774
  p = (char *)mp->m.command.cmd;
#line 1782
  n = mp->m.command.nargs;
#line 1783
  if (n > 63) {
#line 1784
    n = 63;
  }
#line 1785
  fc = (char *)fullcmd;
  {
#line 1785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1785
    if (! (n > 0)) {
#line 1785
      goto while_break;
    }
    {
#line 1787
    __cil_tmp11 = strlen((char const   *)p);
#line 1787
    len___941 = (int )__cil_tmp11;
#line 1788
    __cil_tmp12 = fc;
#line 1788
    fc ++;
#line 1788
    *__cil_tmp12 = (char )'\"';
#line 1789
    fc = strncpy_escape_quote(fc, (char const   *)p, (char const   *)(((char *)fullcmd + sizeof(fullcmd)) - 2));
    }
#line 1789
    if (! fc) {
      {
#line 1791
      Msg(0, (char const   *)((char *)"Remote command too long."));
#line 1792
      queryflag = - 1;
      }
#line 1793
      return;
    }
#line 1795
    p += len___941 + 1;
#line 1796
    __cil_tmp14 = fc;
#line 1796
    fc ++;
#line 1796
    *__cil_tmp14 = (char )'\"';
#line 1797
    __cil_tmp15 = fc;
#line 1797
    fc ++;
#line 1797
    *__cil_tmp15 = (char )' ';
  }
  while_break: /* CIL Label */ ;
  }
#line 1785
  __cil_tmp16 = n;
#line 1785
  n --;
#line 1799
  if (fc != (char *)fullcmd) {
#line 1800
    fc --;
#line 1800
    *fc = (char )0;
  }
  {
#line 1801
  __cil_tmp17 = Parse((char *)fullcmd, (int )sizeof(fullcmd), (char **)args, (int *)argl);
  }
#line 1801
  if (__cil_tmp17 <= 0) {
#line 1803
    queryflag = - 1;
#line 1804
    return;
  }
  {
#line 1807
  user = (struct acluser *)FindUserPtr((char *)mp->m.attach.auser);
  }
#line 1808
  if (user == (struct acluser *)0) {
    {
#line 1810
    Msg(0, (char const   *)((char *)"Unknown user %s tried to send a command!"), (char *)mp->m.attach.auser);
#line 1811
    queryflag = - 1;
    }
#line 1812
    return;
  }
#line 1818
  if (user->u_password) {
#line 1818
    if ((int )*(user->u_password)) {
      {
#line 1820
      Msg(0, (char const   *)((char *)"User %s has a password, cannot use remote commands (using -Q or -X option)."),
          (char *)mp->m.attach.auser);
#line 1821
      queryflag = - 1;
      }
#line 1822
      return;
    }
  }
#line 1825
  if (! display) {
#line 1826
    display = displays;
    {
#line 1826
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1826
      if (! display) {
#line 1826
        goto while_break___0;
      }
#line 1827
      if (display->d_user == user) {
#line 1828
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1826
    display = display->d_next;
  }
#line 1829
  fore = windows;
  {
#line 1829
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1829
    if (! fore) {
#line 1829
      goto while_break___1;
    }
    {
#line 1830
    __cil_tmp19 = strcmp((char const   *)((char *)mp->m_tty), (char const   *)((char *)fore->w_tty));
    }
#line 1830
    if (! __cil_tmp19) {
#line 1832
      if (! display) {
#line 1833
        if (fore->w_layer.l_cvlist) {
#line 1833
          tmp = (fore->w_layer.l_cvlist)->c_display;
        } else {
#line 1833
          tmp = (struct display *)0;
        }
#line 1833
        display = tmp;
      }
#line 1839
      if (! fore->w_layer.l_cvlist) {
#line 1840
        fore = (struct win *)((void *)0);
      } else
#line 1839
      if (! (fore->w_layer.l_cvlist)->c_display) {
#line 1840
        fore = (struct win *)((void *)0);
      }
#line 1841
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1829
  fore = fore->w_next;
#line 1843
  if (! display) {
#line 1844
    display = displays;
  }
#line 1845
  if (*((char *)mp->m.command.preselect)) {
    {
#line 1847
    i = - 1;
#line 1848
    __cil_tmp22 = strcmp((char const   *)((char *)mp->m.command.preselect), (char const   *)((char *)"-"));
    }
#line 1848
    if (__cil_tmp22) {
      {
#line 1850
      i = WindowByNoN((char *)mp->m.command.preselect);
      }
#line 1851
      if (i < 0) {
        {
        {
#line 1853
        Msg(0, (char const   *)((char *)"Could not find pre-select window."));
        }
#line 1854
        queryflag = - 1;
        }
#line 1855
        return;
      } else
#line 1851
      if (! *(wtab + i)) {
        {
        {
#line 1853
        Msg(0, (char const   *)((char *)"Could not find pre-select window."));
        }
#line 1854
        queryflag = - 1;
        }
#line 1855
        return;
      }
    }
#line 1858
    if (i >= 0) {
#line 1858
      tmp___0 = *(wtab + i);
    } else {
#line 1858
      tmp___0 = (struct win *)0;
    }
#line 1858
    fore = tmp___0;
  } else
#line 1860
  if (! fore) {
#line 1862
    if (display) {
#line 1862
      if (display->d_user == user) {
#line 1863
        fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
      }
    }
#line 1864
    if (! fore) {
#line 1866
      if (user->u_detachwin >= 0) {
#line 1866
        tmp___1 = *(wtab + user->u_detachwin);
      } else {
#line 1866
        tmp___1 = (struct win *)0;
      }
      {
#line 1866
      fore = tmp___1;
#line 1867
      fore = FindNiceWindow(fore, (char *)0);
      }
    }
  }
#line 1870
  if (! fore) {
#line 1871
    fore = windows;
  }
#line 1873
  EffectiveAclUser___0 = user;
#line 1875
  if (*((char **)args)) {
#line 1877
    oldrcname = rc_name;
#line 1878
    rc_name = (char *)"-X";
    {
#line 1879
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1879
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1880
    if (fore) {
#line 1880
      tmp___2 = & fore->w_layer;
    } else {
#line 1880
      tmp___2 = (struct layer *)0;
    }
#line 1880
    flayer = tmp___2;
#line 1881
    if (fore) {
#line 1881
      if (fore->w_savelayer) {
#line 1881
        if (fore->w_blocked) {
#line 1882
          flayer = fore->w_savelayer;
        } else
#line 1881
        if ((fore->w_savelayer)->l_cvlist == (struct canvas *)0) {
#line 1882
          flayer = fore->w_savelayer;
        }
      }
    }
    {
#line 1883
    DoCommand((char **)args, (int *)argl);
#line 1884
    rc_name = oldrcname;
    }
  }
#line 1887
  EffectiveAclUser___0 = (struct acluser *)0;
  return;
}
}
#line 1892 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
int SendAttachMsg(int s , struct msg *m , int fd ) 
{ 
  int r ;
  struct msghdr msg ;
  struct iovec iov ;
  char buf[24] ;
  struct cmsghdr *cmsg ;
  struct cmsghdr *tmp ;
  ssize_t __cil_tmp10 ;
  int *__cil_tmp11 ;

  {
  {
#line 1903
  iov.iov_base = (void *)((char *)m);
#line 1904
  iov.iov_len = sizeof(*m);
#line 1905
  bzero((void *)(& msg), sizeof(msg));
#line 1906
  msg.msg_name = (void *)0;
#line 1907
  msg.msg_namelen = (socklen_t )0;
#line 1908
  msg.msg_iov = & iov;
#line 1909
  msg.msg_iovlen = (size_t )1;
#line 1910
  msg.msg_control = (void *)((char *)buf);
#line 1911
  msg.msg_controllen = sizeof(buf);
  }
#line 1912
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 1912
    tmp = (struct cmsghdr *)msg.msg_control;
  } else {
#line 1912
    tmp = (struct cmsghdr *)0;
  }
  {
#line 1912
  cmsg = tmp;
#line 1913
  cmsg->cmsg_level = 1;
#line 1914
  cmsg->cmsg_type = 1;
#line 1915
  cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(int );
#line 1916
  bcopy((void const   *)(& fd), (void *)((unsigned char *)cmsg->__cmsg_data), sizeof(int ));
#line 1917
  msg.msg_controllen = cmsg->cmsg_len;
  }
  {
#line 1918
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1920
    __cil_tmp10 = sendmsg(s, & msg, 0);
#line 1920
    r = (int )__cil_tmp10;
#line 1921
    __cil_tmp11 = __errno_location();
    }
#line 1921
    if (r == -1) {
#line 1921
      if (*__cil_tmp11 == 4) {
#line 1922
        goto while_continue;
      }
    }
#line 1923
    if (r == -1) {
#line 1924
      return (- 1);
    }
#line 1925
    return (0);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1930 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/socket.c"
int IsSocket(char const   *path ) 
{ 
  struct stat st ;
  int __cil_tmp3 ;

  {
  {
#line 1935
  __cil_tmp3 = stat(path, & st);
  }
#line 1935
  if (__cil_tmp3 < 0) {
#line 1936
    return (0);
  }
#line 1938
  return ((st.st_mode & 61440U) == 49152U);
}
}
#line 331 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void FreeAltScreen(struct win *p ) ;
#line 332
void EnterAltScreen(struct win *p ) ;
#line 333
void LeaveAltScreen(struct win *p ) ;
#line 48 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
static void CheckMaxSize(int wi ) ;
#line 49
static void FreeMline(struct mline *ml ) ;
#line 50
static int AllocMline(struct mline *ml , int w ) ;
#line 51
static void MakeBlankLine(unsigned char *p , int n ) ;
#line 52
static void kaablamm(void) ;
#line 53
static int BcopyMline(struct mline *mlf , int xf , struct mline *mlt , int xt , int l ,
                      int w ) ;
#line 54
static void SwapAltScreen(struct win *p ) ;
#line 68 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
static struct mline mline_zero  =    {(unsigned char *)0, (unsigned char *)0, (unsigned char *)0, (unsigned char *)0,
    (unsigned char *)0};
#line 92 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
void CheckScreenSize(int change_flag ) 
{ 
  int wi ;
  int he ;
  int __cil_tmp4 ;

  {
#line 97
  if (display == (struct display *)0) {
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;
#line 99
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 100
    return;
  }
  {
#line 103
  __cil_tmp4 = ioctl(display->d_userfd, (unsigned long )21523, (char *)(& glwz));
  }
#line 103
  if (__cil_tmp4 != 0) {
    {
#line 105
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 105
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 106
    wi = display->d_tcs[1].num;
#line 107
    he = display->d_tcs[0].num;
  } else {
#line 111
    wi = (int )glwz.ws_col;
#line 112
    he = (int )glwz.ws_row;
#line 113
    if (wi == 0) {
#line 114
      wi = display->d_tcs[1].num;
    }
#line 115
    if (he == 0) {
#line 116
      he = display->d_tcs[0].num;
    }
  }
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 123
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 134
  if (display->d_width == wi) {
#line 134
    if (display->d_height == he) {
      {
#line 136
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 136
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 137
      return;
    }
  }
  {
#line 140
  KillBlanker();
#line 142
  ResetIdle();
#line 143
  ChangeScreenSize(wi, he, change_flag);
  }
  return;
}
}
#line 152 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
void ChangeScreenSize(int wi , int he , int change_fore ) 
{ 
  struct win *p ;
  struct canvas *cv ;
  int wwi ;

  {
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 163
  cv = & display->d_canvas;
#line 164
  cv->c_xe = wi - 1;
#line 165
  cv->c_ys = display->d_has_hstatus == 4;
#line 166
  cv->c_ye = ((he - 1) - ((cv->c_slperp && (cv->c_slperp)->c_slnext) || captionalways)) - (display->d_has_hstatus == 1);
#line 167
  cv->c_blank.l_height = (cv->c_ye - cv->c_ys) + 1;
#line 168
  if (cv->c_slperp) {
    {
#line 170
    ResizeCanvas(cv);
#line 171
    RecreateCanvasChain();
#line 172
    RethinkDisplayViewports();
    }
  }
#line 174
  if (display->d_forecv == (struct canvas *)0) {
#line 175
    display->d_forecv = display->d_cvlist;
  }
#line 176
  if (display->d_forecv) {
#line 177
    display->d_fore = (struct win *)(((display->d_forecv)->c_layer)->l_bottom)->l_data;
  }
  {
#line 179
  display->d_width = wi;
#line 180
  display->d_height = he;
#line 182
  CheckMaxSize(wi);
  }
#line 183
  if (display->d_tcs[44].str) {
#line 185
    display->d_defwidth = display->d_tcs[1].num;
#line 186
    display->d_defheight = display->d_tcs[0].num;
  } else {
#line 190
    if (display->d_tcs[45].str) {
#line 190
      if (wi == (int )Z0width) {
        _L: /* CIL Label */ 
#line 190
        if (display->d_tcs[1].num == (int )Z0width) {
#line 192
          display->d_defwidth = display->d_tcs[1].num;
        } else
#line 190
        if (display->d_tcs[1].num == (int )Z1width) {
#line 192
          display->d_defwidth = display->d_tcs[1].num;
        } else {
#line 194
          display->d_defwidth = wi;
        }
      } else
#line 190
      if (wi == (int )Z1width) {
#line 190
        goto _L;
      } else {
#line 194
        display->d_defwidth = wi;
      }
    } else {
#line 194
      display->d_defwidth = wi;
    }
#line 195
    display->d_defheight = he;
  }
  {
#line 197
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 197
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 198
  if (change_fore) {
    {
#line 199
    ResizeLayersToCanvases();
    }
  }
#line 200
  if (change_fore == 2) {
#line 200
    if (display->d_tcs[44].str == (char *)((void *)0)) {
#line 200
      if (displays->d_next == (struct display *)0) {
#line 203
        p = windows;
        {
#line 203
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 203
          if (! p) {
#line 203
            goto while_break___2;
          }
          {
#line 205
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 205
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 206
          wwi = wi;
#line 216
          if (p->w_savelayer) {
#line 216
            if ((p->w_savelayer)->l_cvlist == (struct canvas *)0) {
              {
#line 217
              ResizeLayer(p->w_savelayer, wwi, he, (struct display *)0);
              }
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 203
        p = p->w_next;
      }
    }
  }
  return;
}
}
#line 226 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
void ResizeLayersToCanvases(void) 
{ 
  struct canvas *cv ;
  struct layer *l ;
  int lx ;
  int ly ;
  int __cil_tmp5 ;
  int n ;
  int n___0 ;

  {
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  display->d_kaablamm = 0;
#line 234
  cv = display->d_cvlist;
  {
#line 234
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 234
    if (! cv) {
#line 234
      goto while_break___0;
    }
#line 236
    l = cv->c_layer;
#line 237
    if (l == (struct layer *)0) {
#line 238
      goto while_continue___0;
    }
    {
#line 239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 239
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 240
    if (l->l_width == (cv->c_xe - cv->c_xs) + 1) {
#line 240
      if (l->l_height == (cv->c_ye - cv->c_ys) + 1) {
        {
#line 243
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 243
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 244
        goto while_continue___0;
      }
    }
    {
#line 246
    __cil_tmp5 = MayResizeLayer(l);
    }
#line 246
    if (! __cil_tmp5) {
      {
#line 248
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 248
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 252
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 252
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 253
      ResizeLayer(l, (cv->c_xe - cv->c_xs) + 1, (cv->c_ye - cv->c_ys) + 1, display);
      }
    }
#line 257
    lx = (cv->c_layer)->l_x;
#line 258
    ly = (cv->c_layer)->l_y;
#line 259
    if (ly + cv->c_yoff < cv->c_ys) {
      {
#line 261
      cv->c_yoff = cv->c_ys - ly;
#line 262
      RethinkViewportOffsets(cv);
      }
    } else
#line 264
    if (ly + cv->c_yoff > cv->c_ye) {
      {
#line 266
      cv->c_yoff = cv->c_ye - ly;
#line 267
      RethinkViewportOffsets(cv);
      }
    }
#line 269
    if (lx + cv->c_xoff < cv->c_xs) {
#line 271
      n = cv->c_xs - (lx + cv->c_xoff);
#line 272
      if (n < ((cv->c_xe - cv->c_xs) + 1) / 2) {
#line 273
        n = ((cv->c_xe - cv->c_xs) + 1) / 2;
      }
#line 274
      if (cv->c_xoff + n > cv->c_xs) {
#line 275
        n = cv->c_xs - cv->c_xoff;
      }
      {
#line 276
      cv->c_xoff += n;
#line 277
      RethinkViewportOffsets(cv);
      }
    } else
#line 279
    if (lx + cv->c_xoff > cv->c_xe) {
#line 281
      n___0 = (lx + cv->c_xoff) - cv->c_xe;
#line 282
      if (n___0 < ((cv->c_xe - cv->c_xs) + 1) / 2) {
#line 283
        n___0 = ((cv->c_xe - cv->c_xs) + 1) / 2;
      }
#line 284
      if (((cv->c_xoff - n___0) + (cv->c_layer)->l_width) - 1 < cv->c_xe) {
#line 285
        n___0 = ((cv->c_xoff + (cv->c_layer)->l_width) - 1) - cv->c_xe;
      }
      {
#line 286
      cv->c_xoff -= n___0;
#line 287
      RethinkViewportOffsets(cv);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 234
  cv = cv->c_next;
#line 290
  Redisplay(0);
  }
#line 291
  if (display->d_kaablamm) {
    {
#line 293
    kaablamm();
#line 294
    display->d_kaablamm = 0;
    }
  }
  return;
}
}
#line 299 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
int MayResizeLayer(struct layer *l ) 
{ 
  int cvs ;

  {
#line 302
  cvs = 0;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 304
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 304
    if (! l) {
#line 304
      goto while_break___0;
    }
#line 306
    if (l->l_cvlist) {
#line 307
      cvs ++;
#line 307
      if (cvs > 1) {
        _L: /* CIL Label */ 
        {
#line 309
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 309
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 310
        return (0);
      } else
#line 307
      if ((l->l_cvlist)->c_lnext) {
#line 307
        goto _L;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 304
  l = l->l_next;
  {
#line 313
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 313
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 314
  return (1);
}
}
#line 325 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
static void kaablamm(void) 
{ 


  {
  {
#line 327
  Msg(0, (char const   *)((char *)"Aborted because of window size change."));
  }
  return;
}
}
#line 359 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
void ResizeLayer(struct layer *l , int wi , int he , struct display *norefdisp ) 
{ 
  struct win *p ;
  struct canvas *cv ;
  struct layer *oldflayer ;
  struct display *d ;
  struct display *olddisplay ;
  struct layer *_last ;
  int __cil_tmp11 ;
  struct canvas *_cv ;
  struct layer *_last___0 ;
  int __cil_tmp14 ;
  struct canvas *_cv___0 ;
  struct display *olddisplay___942 ;
  struct layer *oldflayer___943 ;
  struct layer *l___944 ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;

  {
#line 366
  oldflayer = flayer;
#line 367
  olddisplay = display;
#line 369
  if (l->l_width == wi) {
#line 369
    if (l->l_height == he) {
#line 370
      return;
    }
  }
#line 371
  p = (struct win *)(l->l_bottom)->l_data;
#line 375
  if (oldflayer) {
#line 375
    if (l == oldflayer) {
#line 376
      oldflayer = (struct layer *)((void *)0);
    } else
#line 375
    if ((struct win *)(oldflayer->l_bottom)->l_data == p) {
#line 376
      oldflayer = (struct layer *)((void *)0);
    }
  }
#line 378
  flayer = l;
#line 380
  if (p) {
#line 383
    d = displays;
    {
#line 383
    while (1) {
      while_continue: /* CIL Label */ ;
#line 383
      if (! d) {
#line 383
        goto while_break;
      }
#line 384
      cv = d->d_cvlist;
      {
#line 384
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 384
        if (! cv) {
#line 384
          goto while_break___0;
        }
#line 386
        if (p == (struct win *)((cv->c_layer)->l_bottom)->l_data) {
          {
#line 390
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 390
            _last = (struct layer *)((void *)0);
#line 390
            flayer = cv->c_layer;
            {
#line 390
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 390
              if (! flayer->l_next) {
#line 390
                goto while_break___2;
              }
              {
#line 390
              __cil_tmp11 = (*((flayer->l_layfn)->lf_LayResize))(wi, he);
              }
#line 390
              if (__cil_tmp11 == 0) {
#line 390
                _last = flayer;
#line 390
                flayer = flayer->l_next;
              } else {
#line 390
                _cv = flayer->l_cvlist;
                {
#line 390
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 390
                  if (! _cv) {
#line 390
                    goto while_break___3;
                  }
#line 390
                  (_cv->c_display)->d_kaablamm = 1;
                }
                while_break___3: /* CIL Label */ ;
                }
                {
#line 390
                _cv = _cv->c_lnext;
#line 390
                ExitOverlayPage();
                }
#line 390
                if (_last) {
#line 390
                  _last->l_next = flayer;
                }
              }
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 390
            (*((flayer->l_layfn)->lf_LayResize))(wi, he);
            }
#line 390
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 384
      cv = cv->c_next;
    }
    while_break: /* CIL Label */ ;
    }
#line 383
    d = d->d_next;
  } else {
    {
#line 397
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 397
      _last___0 = (struct layer *)((void *)0);
#line 397
      flayer = flayer;
      {
#line 397
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 397
        if (! flayer->l_next) {
#line 397
          goto while_break___5;
        }
        {
#line 397
        __cil_tmp14 = (*((flayer->l_layfn)->lf_LayResize))(wi, he);
        }
#line 397
        if (__cil_tmp14 == 0) {
#line 397
          _last___0 = flayer;
#line 397
          flayer = flayer->l_next;
        } else {
#line 397
          _cv___0 = flayer->l_cvlist;
          {
#line 397
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 397
            if (! _cv___0) {
#line 397
              goto while_break___6;
            }
#line 397
            (_cv___0->c_display)->d_kaablamm = 1;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 397
          _cv___0 = _cv___0->c_lnext;
#line 397
          ExitOverlayPage();
          }
#line 397
          if (_last___0) {
#line 397
            _last___0->l_next = flayer;
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 397
      (*((flayer->l_layfn)->lf_LayResize))(wi, he);
      }
#line 397
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 400
  display = displays;
  {
#line 400
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 400
    if (! display) {
#line 400
      goto while_break___7;
    }
#line 402
    if (display == norefdisp) {
#line 403
      goto while_continue___7;
    }
#line 404
    cv = display->d_cvlist;
    {
#line 404
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 404
      if (! cv) {
#line 404
        goto while_break___8;
      }
#line 405
      if ((struct win *)((cv->c_layer)->l_bottom)->l_data == p) {
        {
#line 407
        olddisplay___942 = display;
#line 407
        oldflayer___943 = flayer;
#line 407
        l___944 = cv->c_layer;
#line 407
        cvlist = l___944->l_cvlist;
#line 407
        cvlnext = cv->c_lnext;
#line 407
        flayer = l___944;
#line 407
        l___944->l_cvlist = cv;
#line 407
        cv->c_lnext = (struct canvas *)0;
#line 407
        (*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1, - 1, - 1, 0);
#line 407
        flayer = oldflayer___943;
#line 407
        l___944->l_cvlist = cvlist;
#line 407
        cv->c_lnext = cvlnext;
#line 407
        display = olddisplay___942;
#line 408
        RefreshArea(cv->c_xs, cv->c_ys, cv->c_xe, cv->c_ye, 0);
        }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 404
    cv = cv->c_next;
#line 410
    if (display->d_kaablamm) {
      {
#line 412
      kaablamm();
#line 413
      display->d_kaablamm = 0;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 400
  display = display->d_next;
#line 419
  if (oldflayer) {
#line 420
    flayer = oldflayer;
  }
#line 421
  display = olddisplay;
  return;
}
}
#line 425 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
static void FreeMline(struct mline *ml ) 
{ 


  {
#line 428
  if (ml->image) {
    {
#line 429
    free((void *)ml->image);
    }
  }
#line 430
  if (ml->attr) {
#line 430
    if (ml->attr != null) {
      {
#line 431
      free((void *)ml->attr);
      }
    }
  }
#line 433
  if (ml->font) {
#line 433
    if (ml->font != null) {
      {
#line 434
      free((void *)ml->font);
      }
    }
  }
#line 435
  if (ml->fontx) {
#line 435
    if (ml->fontx != null) {
      {
#line 436
      free((void *)ml->fontx);
      }
    }
  }
#line 439
  if (ml->color) {
#line 439
    if (ml->color != null) {
      {
#line 440
      free((void *)ml->color);
      }
    }
  }
#line 446
  *ml = mline_zero;
  return;
}
}
#line 450 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
static int AllocMline(struct mline *ml , int w ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 454
  __cil_tmp3 = malloc((unsigned long )w);
#line 454
  ml->image = (unsigned char *)__cil_tmp3;
#line 455
  ml->attr = null;
#line 457
  ml->font = null;
#line 458
  ml->fontx = null;
#line 461
  ml->color = null;
  }
#line 466
  if (ml->image == (unsigned char *)0) {
#line 467
    return (- 1);
  }
#line 468
  return (0);
}
}
#line 473 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
static int BcopyMline(struct mline *mlf , int xf , struct mline *mlt , int xt , int l ,
                      int w ) 
{ 
  int r ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
  {
#line 477
  r = 0;
#line 479
  bcopy((void const   *)((char *)mlf->image + xf), (void *)((char *)mlt->image + xt),
        (size_t )l);
  }
#line 480
  if (mlf->attr != null) {
#line 480
    if (mlt->attr == null) {
      {
#line 482
      __cil_tmp8 = calloc((unsigned long )w, (unsigned long )1);
#line 482
      mlt->attr = (unsigned char *)__cil_tmp8;
      }
#line 482
      if (mlt->attr == (unsigned char *)0) {
#line 483
        r = - 1;
#line 483
        mlt->attr = null;
      }
    }
  }
#line 485
  if (mlt->attr != null) {
    {
#line 486
    bcopy((void const   *)((char *)mlf->attr + xf), (void *)((char *)mlt->attr + xt),
          (size_t )l);
    }
  }
#line 488
  if (mlf->font != null) {
#line 488
    if (mlt->font == null) {
      {
#line 490
      __cil_tmp9 = calloc((unsigned long )w, (unsigned long )1);
#line 490
      mlt->font = (unsigned char *)__cil_tmp9;
      }
#line 490
      if (mlt->font == (unsigned char *)0) {
#line 491
        r = - 1;
#line 491
        mlt->font = null;
      }
    }
  }
#line 493
  if (mlt->font != null) {
    {
#line 494
    bcopy((void const   *)((char *)mlf->font + xf), (void *)((char *)mlt->font + xt),
          (size_t )l);
    }
  }
#line 495
  if (mlf->fontx != null) {
#line 495
    if (mlt->fontx == null) {
      {
#line 497
      __cil_tmp10 = calloc((unsigned long )w, (unsigned long )1);
#line 497
      mlt->fontx = (unsigned char *)__cil_tmp10;
      }
#line 497
      if (mlt->fontx == (unsigned char *)0) {
#line 498
        r = - 1;
#line 498
        mlt->fontx = null;
      }
    }
  }
#line 500
  if (mlt->fontx != null) {
    {
#line 501
    bcopy((void const   *)((char *)mlf->fontx + xf), (void *)((char *)mlt->fontx + xt),
          (size_t )l);
    }
  }
#line 504
  if (mlf->color != null) {
#line 504
    if (mlt->color == null) {
      {
#line 506
      __cil_tmp11 = calloc((unsigned long )w, (unsigned long )1);
#line 506
      mlt->color = (unsigned char *)__cil_tmp11;
      }
#line 506
      if (mlt->color == (unsigned char *)0) {
#line 507
        r = - 1;
#line 507
        mlt->color = null;
      }
    }
  }
#line 509
  if (mlt->color != null) {
    {
#line 510
    bcopy((void const   *)((char *)mlf->color + xf), (void *)((char *)mlt->color + xt),
          (size_t )l);
    }
  }
#line 521
  return (r);
}
}
#line 525
static int maxwidth ;
#line 528 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
static void CheckMaxSize(int wi ) 
{ 
  unsigned char *oldnull ;
  unsigned char *oldblank ;
  struct win *p ;
  int i ;
  struct mline *ml ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp14 ;
  struct mline *__cil_tmp15 ;
  int __cil_tmp16 ;
  struct mline *__cil_tmp17 ;
  int __cil_tmp18 ;
  struct mline *__cil_tmp19 ;
  int __cil_tmp20 ;
  struct mline *__cil_tmp21 ;

  {
#line 531
  oldnull = null;
#line 532
  oldblank = blank;
#line 537
  if (wi > 1000) {
#line 538
    wi = 1000;
  }
#line 539
  if (wi <= maxwidth) {
#line 540
    return;
  }
#line 541
  maxwidth = wi + 1;
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 542
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 543
  __cil_tmp7 = xrealloc((char *)blank, maxwidth);
#line 543
  blank = (unsigned char *)__cil_tmp7;
#line 544
  __cil_tmp8 = xrealloc((char *)null, maxwidth);
#line 544
  null = (unsigned char *)__cil_tmp8;
#line 545
  __cil_tmp9 = xrealloc((char *)mline_old.image, maxwidth);
#line 545
  mline_old.image = (unsigned char *)__cil_tmp9;
#line 546
  __cil_tmp10 = xrealloc((char *)mline_old.attr, maxwidth);
#line 546
  mline_old.attr = (unsigned char *)__cil_tmp10;
#line 548
  __cil_tmp11 = xrealloc((char *)mline_old.font, maxwidth);
#line 548
  mline_old.font = (unsigned char *)__cil_tmp11;
#line 549
  __cil_tmp12 = xrealloc((char *)mline_old.fontx, maxwidth);
#line 549
  mline_old.fontx = (unsigned char *)__cil_tmp12;
#line 552
  __cil_tmp13 = xrealloc((char *)mline_old.color, maxwidth);
#line 552
  mline_old.color = (unsigned char *)__cil_tmp13;
  }
#line 557
  if (! ((((((blank && null) && mline_old.image) && mline_old.attr) && mline_old.font) && mline_old.fontx) && mline_old.color)) {
    {
#line 558
    Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
  }
  {
#line 560
  MakeBlankLine(blank, maxwidth);
#line 561
  bzero((void *)((char *)null), (unsigned long )maxwidth);
#line 563
  mline_blank.image = blank;
#line 564
  mline_blank.attr = null;
#line 565
  mline_null.image = null;
#line 566
  mline_null.attr = null;
#line 568
  mline_blank.font = null;
#line 569
  mline_null.font = null;
#line 570
  mline_blank.fontx = null;
#line 571
  mline_null.fontx = null;
#line 574
  mline_blank.color = null;
#line 575
  mline_null.color = null;
#line 601
  p = windows;
  }
  {
#line 601
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 601
    if (! p) {
#line 601
      goto while_break___0;
    }
    {
#line 603
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 603
      ml = p->w_mlines;
#line 603
      i = 0;
      {
#line 603
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 603
        if (! (i < p->w_layer.l_height)) {
#line 603
          goto while_break___2;
        }
        {
#line 603
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 603
          if (ml->image == oldblank) {
#line 603
            ml->image = blank;
          }
#line 603
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 603
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 603
          if (ml->attr == oldnull) {
#line 603
            ml->attr = null;
          }
#line 603
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 603
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 603
          if (ml->font == oldnull) {
#line 603
            ml->font = null;
          }
#line 603
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 603
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 603
          if (ml->fontx == oldnull) {
#line 603
            ml->fontx = null;
          }
#line 603
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 603
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 603
          if (ml->color == oldnull) {
#line 603
            ml->color = null;
          }
#line 603
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }

      }
      while_break___2: /* CIL Label */ ;
      }
#line 603
      __cil_tmp15 = ml;
#line 603
      ml ++;
#line 603
      __cil_tmp14 = i;
#line 603
      i ++;
#line 603
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 606
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 606
      ml = p->w_hlines;
#line 606
      i = 0;
      {
#line 606
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 606
        if (! (i < p->w_histheight)) {
#line 606
          goto while_break___9;
        }
        {
#line 606
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 606
          if (ml->image == oldblank) {
#line 606
            ml->image = blank;
          }
#line 606
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 606
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 606
          if (ml->attr == oldnull) {
#line 606
            ml->attr = null;
          }
#line 606
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 606
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 606
          if (ml->font == oldnull) {
#line 606
            ml->font = null;
          }
#line 606
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 606
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 606
          if (ml->fontx == oldnull) {
#line 606
            ml->fontx = null;
          }
#line 606
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
        {
#line 606
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 606
          if (ml->color == oldnull) {
#line 606
            ml->color = null;
          }
#line 606
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }

      }
      while_break___9: /* CIL Label */ ;
      }
#line 606
      __cil_tmp17 = ml;
#line 606
      ml ++;
#line 606
      __cil_tmp16 = i;
#line 606
      i ++;
#line 606
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 607
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 607
      ml = p->w_alt.hlines;
#line 607
      i = 0;
      {
#line 607
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 607
        if (! (i < p->w_alt.histheight)) {
#line 607
          goto while_break___16;
        }
        {
#line 607
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 607
          if (ml->image == oldblank) {
#line 607
            ml->image = blank;
          }
#line 607
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
        {
#line 607
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 607
          if (ml->attr == oldnull) {
#line 607
            ml->attr = null;
          }
#line 607
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
        {
#line 607
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 607
          if (ml->font == oldnull) {
#line 607
            ml->font = null;
          }
#line 607
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
        {
#line 607
        while (1) {
          while_continue___20: /* CIL Label */ ;
#line 607
          if (ml->fontx == oldnull) {
#line 607
            ml->fontx = null;
          }
#line 607
          goto while_break___20;
        }
        while_break___20: /* CIL Label */ ;
        }
        {
#line 607
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 607
          if (ml->color == oldnull) {
#line 607
            ml->color = null;
          }
#line 607
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }

      }
      while_break___16: /* CIL Label */ ;
      }
#line 607
      __cil_tmp19 = ml;
#line 607
      ml ++;
#line 607
      __cil_tmp18 = i;
#line 607
      i ++;
#line 607
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 610
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 610
      ml = p->w_alt.mlines;
#line 610
      i = 0;
      {
#line 610
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 610
        if (! (i < p->w_alt.height)) {
#line 610
          goto while_break___23;
        }
        {
#line 610
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 610
          if (ml->image == oldblank) {
#line 610
            ml->image = blank;
          }
#line 610
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
        {
#line 610
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 610
          if (ml->attr == oldnull) {
#line 610
            ml->attr = null;
          }
#line 610
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
        {
#line 610
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 610
          if (ml->font == oldnull) {
#line 610
            ml->font = null;
          }
#line 610
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
        {
#line 610
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 610
          if (ml->fontx == oldnull) {
#line 610
            ml->fontx = null;
          }
#line 610
          goto while_break___27;
        }
        while_break___27: /* CIL Label */ ;
        }
        {
#line 610
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 610
          if (ml->color == oldnull) {
#line 610
            ml->color = null;
          }
#line 610
          goto while_break___28;
        }
        while_break___28: /* CIL Label */ ;
        }

      }
      while_break___23: /* CIL Label */ ;
      }
#line 610
      __cil_tmp21 = ml;
#line 610
      ml ++;
#line 610
      __cil_tmp20 = i;
#line 610
      i ++;
#line 610
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 601
  p = p->w_next;
  return;
}
}
#line 616 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
char *xrealloc(char *mem , int len ) 
{ 
  register char *nmem ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
#line 622
  if (mem == (char *)0) {
    {
#line 623
    __cil_tmp4 = malloc((unsigned long )len);
    }
#line 623
    return ((char *)__cil_tmp4);
  }
  {
#line 624
  __cil_tmp5 = realloc((void *)mem, (unsigned long )len);
#line 624
  nmem = (char *)__cil_tmp5;
  }
#line 624
  if (nmem) {
#line 625
    return (nmem);
  }
  {
#line 626
  free((void *)mem);
  }
#line 627
  return ((char *)0);
}
}
#line 631 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
static void MakeBlankLine(unsigned char *p , int n ) 
{ 
  int __cil_tmp3 ;
  unsigned char *__cil_tmp4 ;

  {
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! __cil_tmp3) {
#line 635
      goto while_break;
    }
#line 636
    __cil_tmp4 = p;
#line 636
    p ++;
#line 636
    *__cil_tmp4 = (unsigned char )' ';
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 659 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
int ChangeWindowSize(struct win *p , int wi , int he , int hi ) 
{ 
  struct mline *mlf ;
  struct mline *mlt ;
  struct mline *ml ;
  struct mline *nmlines ;
  struct mline *nhlines ;
  int fy ;
  int ty ;
  int l ;
  int lx ;
  int lf ;
  int lt ;
  int yy ;
  int oty ;
  int addone ;
  int ncx ;
  int ncy ;
  int naka ;
  int t ;
  int y ;
  int shift ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  int __cil_tmp27 ;
  struct mline *tmp ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  struct mline *tmp___0 ;
  int __cil_tmp33 ;
  struct mline *tmp___1 ;
  struct mline *tmp___945 ;
  struct mline *tmp___946 ;
  struct mline *tmp___947 ;
  int __cil_tmp38 ;
  struct mline *tmp___948 ;
  int __cil_tmp41 ;
  int tmp___949 ;
  int __cil_tmp43 ;
  int tmp___950 ;
  int __cil_tmp45 ;
  int tmp___951 ;
  struct mline *tmp___952 ;
  struct mline *tmp___953 ;
  int __cil_tmp49 ;
  struct mline *tmp___954 ;
  int tmp___955 ;
  int tmp___956 ;
  struct mline *tmp___957 ;
  struct mline *tmp___958 ;
  struct mline *tmp___959 ;
  int __cil_tmp56 ;
  struct mline *tmp___960 ;
  int tmp___961 ;
  int tmp___962 ;
  int __cil_tmp62 ;
  struct mline *tmp___964 ;
  int __cil_tmp64 ;

  {
#line 663
  mlf = (struct mline *)0;
#line 663
  mlt = (struct mline *)0;
#line 668
  if (wi <= 0) {
#line 669
    hi = 0;
#line 669
    he = hi;
#line 669
    wi = he;
  } else
#line 668
  if (he <= 0) {
#line 669
    hi = 0;
#line 669
    he = hi;
#line 669
    wi = he;
  }
#line 671
  if (p->w_type == 3) {
#line 672
    return (0);
  }
#line 674
  if (wi > 1000) {
    {
#line 676
    Msg(0, (char const   *)((char *)"Window width too large. Truncated to %d."), 1000);
#line 677
    wi = 1000;
    }
  }
#line 680
  if (he > 1000) {
    {
#line 682
    Msg(0, (char const   *)((char *)"Window height too large. Truncated to %d."),
        1000);
#line 683
    he = 1000;
    }
  }
#line 686
  if (p->w_layer.l_width == wi) {
#line 686
    if (p->w_layer.l_height == he) {
#line 686
      if (p->w_histheight == hi) {
        {
#line 688
        while (1) {
          while_continue: /* CIL Label */ ;
#line 688
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 689
        return (0);
      }
    }
  }
  {
#line 692
  CheckMaxSize(wi);
  }
  {
#line 704
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 704
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 705
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 705
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 706
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 706
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 708
  fy = (p->w_histheight + p->w_layer.l_height) - 1;
#line 709
  ty = (hi + he) - 1;
#line 711
  nhlines = (struct mline *)0;
#line 711
  nmlines = nhlines;
#line 712
  ncx = 0;
#line 713
  ncy = 0;
#line 714
  naka = 0;
#line 716
  if (wi) {
#line 718
    if (wi != p->w_layer.l_width) {
      _L: /* CIL Label */ 
      {
#line 720
      __cil_tmp25 = calloc((unsigned long )he, sizeof(struct mline ));
#line 720
      nmlines = (struct mline *)__cil_tmp25;
      }
#line 720
      if (nmlines == (struct mline *)0) {
        {
#line 722
        KillWindow(p);
#line 723
        Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
        }
#line 724
        return (- 1);
      }
    } else
#line 718
    if (he != p->w_layer.l_height) {
#line 718
      goto _L;
    } else {
      {
#line 729
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 729
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 730
      nmlines = p->w_mlines;
#line 731
      fy -= he;
#line 732
      ty -= he;
#line 733
      ncx = p->w_layer.l_x;
#line 734
      ncy = p->w_layer.l_y;
#line 735
      naka = p->w_autoaka;
    }
  }
#line 739
  if (hi) {
    {
#line 741
    __cil_tmp26 = calloc((unsigned long )hi, sizeof(struct mline ));
#line 741
    nhlines = (struct mline *)__cil_tmp26;
    }
#line 741
    if (nhlines == (struct mline *)0) {
      {
#line 743
      Msg(0, (char const   *)((char *)"No memory for history buffer - turned off"));
#line 744
      hi = 0;
#line 745
      ty = he - 1;
      }
    }
  }
#line 751
  addone = 0;
#line 752
  if (p->w_layer.l_width) {
#line 752
    if (p->w_layer.l_x == p->w_layer.l_width) {
      {
#line 754
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 754
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 755
      addone = 1;
#line 756
      __cil_tmp27 = p->w_layer.l_x;
#line 756
      (p->w_layer.l_x) --;
    }
  }
#line 760
  if (p->w_layer.l_width == wi) {
#line 762
    ncx = p->w_layer.l_x + addone;
#line 763
    ncy = (p->w_layer.l_y + he) - p->w_layer.l_height;
#line 765
    shift = - ncy;
#line 766
    yy = (p->w_layer.l_y + p->w_histheight) - 1;
    {
#line 766
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 766
      if (! (yy >= 0 && ncy + shift < he)) {
#line 766
        goto while_break___5;
      }
#line 768
      if (yy < p->w_histheight) {
#line 768
        tmp = & *(p->w_hlines + (p->w_histidx + yy) % p->w_histheight);
      } else {
#line 768
        tmp = & *(p->w_mlines + (yy - p->w_histheight));
      }
#line 768
      ml = tmp;
#line 769
      if (! ml->image) {
#line 770
        goto while_break___5;
      }
#line 771
      if ((int )*(ml->image + p->w_layer.l_width) == 32) {
#line 772
        goto while_break___5;
      }
#line 773
      shift ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 766
    __cil_tmp30 = yy;
#line 766
    yy --;
#line 775
    if (shift < 0) {
#line 776
      shift = 0;
    } else {
      {
#line 778
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 778
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 779
    ncy += shift;
#line 780
    if (p->w_autoaka > 0) {
#line 782
      naka = ((p->w_autoaka + he) - p->w_layer.l_height) + shift;
#line 783
      if (naka < 1) {
#line 784
        naka = 0;
      } else
#line 783
      if (naka > he) {
#line 784
        naka = 0;
      }
    }
    {
#line 786
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 786
      if (! (__cil_tmp31 > 0)) {
#line 786
        goto while_break___7;
      }
#line 788
      if (fy < p->w_histheight) {
#line 788
        tmp___0 = & *(p->w_hlines + (p->w_histidx + fy) % p->w_histheight);
      } else {
#line 788
        tmp___0 = & *(p->w_mlines + (fy - p->w_histheight));
      }
      {
#line 788
      ml = tmp___0;
#line 789
      FreeMline(ml);
#line 790
      __cil_tmp33 = fy;
#line 790
      fy --;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 793
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 793
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 794
  if (fy >= 0) {
#line 795
    if (fy < p->w_histheight) {
#line 795
      tmp___1 = & *(p->w_hlines + (p->w_histidx + fy) % p->w_histheight);
    } else {
#line 795
      tmp___1 = & *(p->w_mlines + (fy - p->w_histheight));
    }
#line 795
    mlf = tmp___1;
  }
#line 796
  if (ty >= 0) {
#line 797
    if (ty < hi) {
#line 797
      tmp___945 = & *(nhlines + ty);
    } else {
#line 797
      tmp___945 = & *(nmlines + (ty - hi));
    }
#line 797
    mlt = tmp___945;
  }
  {
#line 799
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 799
    if (! (fy >= 0 && ty >= 0)) {
#line 799
      goto while_break___9;
    }
#line 801
    if (p->w_layer.l_width == wi) {
#line 804
      *mlt = *mlf;
#line 805
      *mlf = mline_zero;
#line 806
      fy --;
#line 806
      if (fy >= 0) {
#line 807
        if (fy < p->w_histheight) {
#line 807
          tmp___946 = & *(p->w_hlines + (p->w_histidx + fy) % p->w_histheight);
        } else {
#line 807
          tmp___946 = & *(p->w_mlines + (fy - p->w_histheight));
        }
#line 807
        mlf = tmp___946;
      }
#line 808
      ty --;
#line 808
      if (ty >= 0) {
#line 809
        if (ty < hi) {
#line 809
          tmp___947 = & *(nhlines + ty);
        } else {
#line 809
          tmp___947 = & *(nmlines + (ty - hi));
        }
#line 809
        mlt = tmp___947;
      }
#line 810
      goto while_continue___9;
    }
#line 814
    l = p->w_layer.l_width - 1;
    {
#line 814
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 814
      if (! (l > 0)) {
#line 814
        goto while_break___10;
      }
#line 815
      if ((int )*(mlf->image + l) != 32) {
#line 816
        goto while_break___10;
      } else
#line 815
      if ((int )*(mlf->attr + l)) {
#line 816
        goto while_break___10;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 814
    __cil_tmp38 = l;
#line 814
    l --;
#line 817
    if (fy == p->w_layer.l_y + p->w_histheight) {
#line 817
      if (l < p->w_layer.l_x) {
#line 818
        l = p->w_layer.l_x;
      }
    }
#line 819
    l ++;
#line 820
    lf = l;
#line 823
    yy = fy - 1;
    {
#line 823
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 823
      if (! (yy >= 0)) {
#line 823
        goto while_break___11;
      }
#line 825
      if (yy < p->w_histheight) {
#line 825
        tmp___948 = & *(p->w_hlines + (p->w_histidx + yy) % p->w_histheight);
      } else {
#line 825
        tmp___948 = & *(p->w_mlines + (yy - p->w_histheight));
      }
#line 825
      ml = tmp___948;
#line 826
      if ((int )*(ml->image + p->w_layer.l_width) == 32) {
#line 827
        goto while_break___11;
      }
#line 828
      l += p->w_layer.l_width;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 823
    __cil_tmp41 = yy;
#line 823
    yy --;
#line 832
    lt = (l - 1) % wi + 1;
#line 833
    oty = ty;
    {
#line 834
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 834
      if (! ((l > 0 && fy >= 0) && ty >= 0)) {
#line 834
        goto while_break___12;
      }
#line 836
      if (lt > lf) {
#line 836
        tmp___949 = lf;
      } else {
#line 836
        tmp___949 = lt;
      }
#line 836
      lx = tmp___949;
#line 837
      if (mlt->image == (unsigned char *)0) {
        {
#line 839
        __cil_tmp43 = AllocMline(mlt, wi + 1);
        }
#line 839
        if (__cil_tmp43) {
#line 840
          goto nomem;
        }
        {
#line 841
        MakeBlankLine(mlt->image + lt, wi - lt);
        }
#line 842
        if (oty == ty) {
#line 842
          tmp___950 = ' ';
        } else {
#line 842
          tmp___950 = 0;
        }
#line 842
        *(mlt->image + wi) = (unsigned char )tmp___950;
      }
      {
#line 844
      __cil_tmp45 = BcopyMline(mlf, lf - lx, mlt, lt - lx, lx, wi + 1);
      }
#line 844
      if (__cil_tmp45) {
#line 845
        goto nomem;
      }
#line 848
      if (fy == p->w_layer.l_y + p->w_histheight) {
#line 848
        if (lf - lx <= p->w_layer.l_x) {
#line 848
          if (lf > p->w_layer.l_x) {
#line 850
            ncx = ((p->w_layer.l_x + lt) - lf) + addone;
#line 851
            ncy = ty - hi;
#line 852
            if (wi) {
#line 852
              tmp___951 = - ncy + (l - lx) / wi;
            } else {
#line 852
              tmp___951 = 0;
            }
#line 852
            shift = tmp___951;
#line 853
            if (ty + shift > (hi + he) - 1) {
#line 854
              shift = ((hi + he) - 1) - ty;
            }
#line 855
            if (shift > 0) {
              {
#line 857
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 857
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
#line 858
              y = (hi + he) - 1;
              {
#line 858
              while (1) {
                while_continue___14: /* CIL Label */ ;
#line 858
                if (! (y >= ty)) {
#line 858
                  goto while_break___14;
                }
#line 860
                if (y < hi) {
#line 860
                  tmp___952 = & *(nhlines + y);
                } else {
#line 860
                  tmp___952 = & *(nmlines + (y - hi));
                }
                {
#line 860
                mlt = tmp___952;
#line 861
                FreeMline(mlt);
                }
#line 862
                if (y - shift < ty) {
#line 863
                  goto while_continue___14;
                }
#line 864
                if (y - shift < hi) {
#line 864
                  tmp___953 = & *(nhlines + (y - shift));
                } else {
#line 864
                  tmp___953 = & *(nmlines + ((y - shift) - hi));
                }
#line 864
                ml = tmp___953;
#line 865
                *mlt = *ml;
#line 866
                *ml = mline_zero;
              }
              while_break___14: /* CIL Label */ ;
              }
#line 858
              __cil_tmp49 = y;
#line 858
              y --;
#line 868
              ncy += shift;
#line 869
              ty += shift;
#line 870
              if (ty < hi) {
#line 870
                tmp___954 = & *(nhlines + ty);
              } else {
#line 870
                tmp___954 = & *(nmlines + (ty - hi));
              }
#line 870
              mlt = tmp___954;
#line 871
              if (naka > 0) {
#line 872
                if (naka + shift > he) {
#line 872
                  tmp___955 = 0;
                } else {
#line 872
                  tmp___955 = naka + shift;
                }
#line 872
                naka = tmp___955;
              }
            }
            {
#line 874
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 874
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
          }
        }
      }
#line 877
      if (p->w_autoaka > 0) {
#line 877
        if (fy == (p->w_autoaka - 1) + p->w_histheight) {
#line 877
          if (lf - lx <= 0) {
#line 878
            if (ty - hi >= 0) {
#line 878
              tmp___956 = (1 + ty) - hi;
            } else {
#line 878
              tmp___956 = 0;
            }
#line 878
            naka = tmp___956;
          }
        }
      }
#line 880
      lf -= lx;
#line 881
      lt -= lx;
#line 882
      l -= lx;
#line 883
      if (lf == 0) {
        {
#line 885
        FreeMline(mlf);
#line 886
        lf = p->w_layer.l_width;
#line 887
        fy --;
        }
#line 887
        if (fy >= 0) {
#line 888
          if (fy < p->w_histheight) {
#line 888
            tmp___957 = & *(p->w_hlines + (p->w_histidx + fy) % p->w_histheight);
          } else {
#line 888
            tmp___957 = & *(p->w_mlines + (fy - p->w_histheight));
          }
#line 888
          mlf = tmp___957;
        }
      }
#line 890
      if (lt == 0) {
#line 892
        lt = wi;
#line 893
        ty --;
#line 893
        if (ty >= 0) {
#line 894
          if (ty < hi) {
#line 894
            tmp___958 = & *(nhlines + ty);
          } else {
#line 894
            tmp___958 = & *(nmlines + (ty - hi));
          }
#line 894
          mlt = tmp___958;
        }
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 897
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 897
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 899
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 899
    if (! (fy >= 0)) {
#line 899
      goto while_break___17;
    }
    {
#line 901
    FreeMline(mlf);
#line 902
    fy --;
    }
#line 902
    if (fy >= 0) {
#line 903
      if (fy < p->w_histheight) {
#line 903
        tmp___959 = & *(p->w_hlines + (p->w_histidx + fy) % p->w_histheight);
      } else {
#line 903
        tmp___959 = & *(p->w_mlines + (fy - p->w_histheight));
      }
#line 903
      mlf = tmp___959;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 905
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 905
    if (! (ty >= 0)) {
#line 905
      goto while_break___18;
    }
    {
#line 907
    __cil_tmp56 = AllocMline(mlt, wi + 1);
    }
#line 907
    if (__cil_tmp56) {
#line 908
      goto nomem;
    }
    {
#line 909
    MakeBlankLine(mlt->image, wi + 1);
#line 910
    ty --;
    }
#line 910
    if (ty >= 0) {
#line 911
      if (ty < hi) {
#line 911
        tmp___960 = & *(nhlines + ty);
      } else {
#line 911
        tmp___960 = & *(nmlines + (ty - hi));
      }
#line 911
      mlt = tmp___960;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 923
  if (p->w_mlines) {
#line 923
    if (p->w_mlines != nmlines) {
      {
#line 924
      free((void *)((char *)p->w_mlines));
      }
    }
  }
#line 925
  p->w_mlines = nmlines;
#line 927
  if (p->w_hlines) {
#line 927
    if (p->w_hlines != nhlines) {
      {
#line 928
      free((void *)((char *)p->w_hlines));
      }
    }
  }
#line 929
  p->w_hlines = nhlines;
#line 931
  nhlines = (struct mline *)0;
#line 931
  nmlines = nhlines;
#line 934
  if (p->w_layer.l_width != wi) {
#line 936
    if (wi) {
#line 938
      if (p->w_tabs) {
#line 938
        tmp___961 = p->w_layer.l_width;
      } else {
#line 938
        tmp___961 = 0;
      }
      {
#line 938
      t = tmp___961;
#line 939
      p->w_tabs = xrealloc(p->w_tabs, wi + 1);
      }
#line 940
      if (p->w_tabs == (char *)0) {
#line 941
        goto nomem;
      }
      {
#line 942
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 942
        if (! (t < wi)) {
#line 942
          goto while_break___19;
        }
#line 943
        if (t && ! (t & 7)) {
#line 943
          tmp___962 = 1;
        } else {
#line 943
          tmp___962 = 0;
        }
#line 943
        *(p->w_tabs + t) = (char )tmp___962;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 942
      t ++;
#line 944
      *(p->w_tabs + wi) = (char )0;
    } else {
#line 948
      if (p->w_tabs) {
        {
#line 949
        free((void *)p->w_tabs);
        }
      }
#line 950
      p->w_tabs = (char *)0;
    }
  }
#line 955
  p->w_saved.y += ncy - p->w_layer.l_y;
#line 957
  p->w_layer.l_x = ncx;
#line 958
  p->w_layer.l_y = ncy;
#line 959
  if (p->w_autoaka > 0) {
#line 960
    p->w_autoaka = naka;
  }
#line 963
  if (p->w_layer.l_x > wi) {
#line 964
    p->w_layer.l_x = wi;
  }
#line 965
  if (p->w_layer.l_y >= he) {
#line 966
    p->w_layer.l_y = he - 1;
  }
#line 967
  if (p->w_saved.x > wi) {
#line 968
    p->w_saved.x = wi;
  }
#line 969
  if (p->w_saved.y >= he) {
#line 970
    p->w_saved.y = he - 1;
  }
#line 971
  if (p->w_saved.y < 0) {
#line 972
    p->w_saved.y = 0;
  }
#line 973
  if (p->w_alt.cursor.x > wi) {
#line 974
    p->w_alt.cursor.x = wi;
  }
#line 975
  if (p->w_alt.cursor.y >= he) {
#line 976
    p->w_alt.cursor.y = he - 1;
  }
#line 977
  if (p->w_alt.cursor.y < 0) {
#line 978
    p->w_alt.cursor.y = 0;
  }
#line 981
  p->w_top = 0;
#line 982
  p->w_bot = he - 1;
#line 986
  if (wi) {
#line 986
    if (p->w_layer.l_width != wi) {
      _L___963: /* CIL Label */ 
#line 986
      if (p->w_layer.l_width != 0) {
#line 986
        if (p->w_layer.l_height != 0) {
#line 986
          if (p->w_ptyfd >= 0) {
#line 986
            if (p->w_pid) {
#line 989
              glwz.ws_col = (unsigned short )wi;
#line 990
              glwz.ws_row = (unsigned short )he;
              {
#line 991
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 991
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
              {
#line 992
              __cil_tmp62 = ioctl(p->w_ptyfd, (unsigned long )21524, (char *)(& glwz));
              }
#line 992
              if (__cil_tmp62) {
                {
#line 993
                while (1) {
                  while_continue___21: /* CIL Label */ ;
#line 993
                  goto while_break___21;
                }
                while_break___21: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    } else
#line 986
    if (p->w_layer.l_height != he) {
#line 986
      goto _L___963;
    }
  }
#line 998
  p->w_layer.l_width = wi;
#line 999
  p->w_layer.l_height = he;
#line 1000
  if (p->w_scrollback_height > hi) {
#line 1001
    p->w_scrollback_height = hi;
  }
#line 1003
  p->w_histidx = 0;
#line 1004
  p->w_histheight = hi;
#line 1030
  return (0);
  nomem: 
#line 1033
  if (nmlines) {
    _L___965: /* CIL Label */ 
#line 1035
    ty = (he + hi) - 1;
    {
#line 1035
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1035
      if (! (ty >= 0)) {
#line 1035
        goto while_break___22;
      }
#line 1037
      if (ty < hi) {
#line 1037
        tmp___964 = & *(nhlines + ty);
      } else {
#line 1037
        tmp___964 = & *(nmlines + (ty - hi));
      }
      {
#line 1037
      mlt = tmp___964;
#line 1038
      FreeMline(mlt);
      }
    }
    while_break___22: /* CIL Label */ ;
    }
#line 1035
    __cil_tmp64 = ty;
#line 1035
    ty --;
#line 1040
    if (nmlines) {
#line 1040
      if (p->w_mlines != nmlines) {
        {
#line 1041
        free((void *)((char *)nmlines));
        }
      }
    }
#line 1043
    if (nhlines) {
#line 1043
      if (p->w_hlines != nhlines) {
        {
#line 1044
        free((void *)((char *)nhlines));
        }
      }
    }
  } else
#line 1033
  if (nhlines) {
#line 1033
    goto _L___965;
  }
  {
#line 1047
  KillWindow(p);
#line 1048
  Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
  }
#line 1049
  return (- 1);
}
}
#line 1053 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
void FreeAltScreen(struct win *p ) 
{ 
  int i ;

  {
#line 1058
  if (p->w_alt.mlines) {
#line 1060
    i = 0;
    {
#line 1060
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1060
      if (! (i < p->w_alt.height)) {
#line 1060
        goto while_break;
      }
      {
#line 1061
      FreeMline(p->w_alt.mlines + i);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1060
    i ++;
#line 1062
    free((void *)p->w_alt.mlines);
    }
  }
#line 1064
  p->w_alt.mlines = (struct mline *)0;
#line 1065
  p->w_alt.width = 0;
#line 1066
  p->w_alt.height = 0;
#line 1068
  if (p->w_alt.hlines) {
#line 1070
    i = 0;
    {
#line 1070
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1070
      if (! (i < p->w_alt.histheight)) {
#line 1070
        goto while_break___0;
      }
      {
#line 1071
      FreeMline(p->w_alt.hlines + i);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1070
    i ++;
#line 1072
    free((void *)p->w_alt.hlines);
    }
  }
#line 1074
  p->w_alt.hlines = (struct mline *)0;
#line 1075
  p->w_alt.histidx = 0;
#line 1076
  p->w_alt.histheight = 0;
  return;
}
}
#line 1081 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
static void SwapAltScreen(struct win *p ) 
{ 
  struct mline *ml ;
  int t ;

  {
  {
#line 1089
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1089
    ml = p->w_alt.mlines;
#line 1089
    p->w_alt.mlines = p->w_mlines;
#line 1089
    p->w_mlines = ml;
#line 1089
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1090
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1090
    t = p->w_alt.width;
#line 1090
    p->w_alt.width = p->w_layer.l_width;
#line 1090
    p->w_layer.l_width = t;
#line 1090
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1091
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1091
    t = p->w_alt.height;
#line 1091
    p->w_alt.height = p->w_layer.l_height;
#line 1091
    p->w_layer.l_height = t;
#line 1091
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1094
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1094
    t = p->w_alt.histheight;
#line 1094
    p->w_alt.histheight = p->w_histheight;
#line 1094
    p->w_histheight = t;
#line 1094
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1095
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1095
    ml = p->w_alt.hlines;
#line 1095
    p->w_alt.hlines = p->w_hlines;
#line 1095
    p->w_hlines = ml;
#line 1095
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1096
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1096
    t = p->w_alt.histidx;
#line 1096
    p->w_alt.histidx = p->w_histidx;
#line 1096
    p->w_histidx = t;
#line 1096
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  return;
}
}
#line 1102 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
void EnterAltScreen(struct win *p ) 
{ 


  {
#line 1105
  if (! p->w_alt.on) {
    {
#line 1109
    FreeAltScreen(p);
#line 1110
    SwapAltScreen(p);
    }
  } else {
#line 1116
    p->w_layer.l_height = 0;
#line 1117
    p->w_histheight = 0;
  }
  {
#line 1119
  ChangeWindowSize(p, p->w_alt.width, p->w_alt.height, p->w_alt.histheight);
#line 1120
  p->w_alt.on = 1;
  }
  return;
}
}
#line 1124 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/resize.c"
void LeaveAltScreen(struct win *p ) 
{ 


  {
#line 1127
  if (! p->w_alt.on) {
#line 1128
    return;
  }
  {
#line 1129
  SwapAltScreen(p);
#line 1130
  ChangeWindowSize(p, p->w_alt.width, p->w_alt.height, p->w_alt.histheight);
#line 1131
  FreeAltScreen(p);
#line 1132
  p->w_alt.on = 0;
  }
  return;
}
}
#line 196 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set ) ;
#line 240
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction *__act ,
                                                   struct sigaction *__oact ) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 687
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 708
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 725
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 984
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 650 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 368 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void bclear(char *p , int n ) ;
#line 54 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
char *SaveStr(char const   *str ) 
{ 
  register char *cp ;
  size_t __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 59
  __cil_tmp3 = strlen(str);
#line 59
  __cil_tmp4 = malloc(__cil_tmp3 + 1UL);
#line 59
  cp = (char *)__cil_tmp4;
  }
#line 59
  if (cp == (char *)((void *)0)) {
    {
#line 60
    Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
  } else {
    {
#line 62
    strcpy(cp, str);
    }
  }
#line 63
  return (cp);
}
}
#line 67 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
char *SaveStrn(char const   *str , int n ) 
{ 
  register char *cp ;
  void *__cil_tmp4 ;

  {
  {
#line 73
  __cil_tmp4 = malloc((unsigned long )(n + 1));
#line 73
  cp = (char *)__cil_tmp4;
  }
#line 73
  if (cp == (char *)((void *)0)) {
    {
#line 74
    Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
  } else {
    {
#line 77
    bcopy((void const   *)((char *)str), (void *)cp, (size_t )n);
#line 78
    *(cp + n) = (char )0;
    }
  }
#line 80
  return (cp);
}
}
#line 85 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
char *InStr(char *str , char const   *pat ) 
{ 
  int npat ;
  size_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 89
  __cil_tmp4 = strlen(pat);
#line 89
  npat = (int )__cil_tmp4;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! *str) {
#line 90
      goto while_break;
    }
    {
#line 91
    __cil_tmp5 = strncmp((char const   *)str, pat, (unsigned long )npat);
    }
#line 91
    if (! __cil_tmp5) {
#line 92
      return (str);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  str ++;
#line 93
  return ((char *)0);
}
}
#line 113 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void centerline(char *str , int y ) 
{ 
  int l ;
  int n ;
  size_t __cil_tmp5 ;

  {
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  __cil_tmp5 = strlen((char const   *)str);
#line 120
  n = (int )__cil_tmp5;
  }
#line 121
  if (n > flayer->l_width - 1) {
#line 122
    n = flayer->l_width - 1;
  }
  {
#line 123
  l = ((flayer->l_width - 1) - n) / 2;
#line 124
  LPutStr(flayer, str, n, & mchar_blank, l, y);
  }
  return;
}
}
#line 128 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void leftline(char *str , int y , struct mchar *rend ) 
{ 
  int l ;
  int n ;
  struct mchar mchar_dol ;
  size_t __cil_tmp7 ;
  struct mchar *tmp ;

  {
#line 136
  mchar_dol = mchar_blank;
#line 137
  mchar_dol.image = (unsigned char )'$';
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  __cil_tmp7 = strlen((char const   *)str);
#line 140
  n = (int )__cil_tmp7;
#line 140
  l = n;
  }
#line 141
  if (n > flayer->l_width - 1) {
#line 142
    n = flayer->l_width - 1;
  }
#line 143
  if (rend) {
#line 143
    tmp = rend;
  } else {
#line 143
    tmp = & mchar_blank;
  }
  {
#line 143
  LPutStr(flayer, str, n, tmp, 0, y);
  }
#line 144
  if (n != l) {
    {
#line 145
    LPutChar(flayer, & mchar_dol, n, y);
    }
  }
  return;
}
}
#line 150 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
char *Filename(char *s ) 
{ 
  register char *p ;
  char *__cil_tmp3 ;

  {
#line 153
  p = s;
#line 155
  if (p) {
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      if (! *p) {
#line 156
        goto while_break;
      }
#line 157
      __cil_tmp3 = p;
#line 157
      p ++;
#line 157
      if ((int )*__cil_tmp3 == 47) {
#line 158
        s = p;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 159
  return (s);
}
}
#line 163 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
char *stripdev(char *nam ) 
{ 
  int __cil_tmp2 ;

  {
#line 183
  if (nam == (char *)((void *)0)) {
#line 184
    return ((char *)((void *)0));
  }
  {
#line 185
  __cil_tmp2 = strncmp((char const   *)nam, (char const   *)((char *)"/dev/"), (unsigned long )5);
  }
#line 185
  if (__cil_tmp2 == 0) {
#line 186
    return (nam + 5);
  }
#line 188
  return (nam);
}
}
#line 197 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void (*xsignal(int sig , void (*func)(int  ) ))(int  ) 
{ 
  struct sigaction osa ;
  struct sigaction sa ;
  int __cil_tmp5 ;
  int tmp ;
  int __cil_tmp7 ;

  {
  {
#line 207
  sa.__sigaction_handler.sa_handler = func;
#line 208
  __cil_tmp5 = sigemptyset(& sa.sa_mask);
  }
#line 210
  if (sig == 17) {
#line 210
    tmp = 268435456;
  } else {
#line 210
    tmp = 0;
  }
  {
#line 210
  sa.sa_flags = tmp;
#line 214
  __cil_tmp7 = sigaction(sig, & sa, & osa);
  }
#line 214
  if (__cil_tmp7) {
#line 215
    return ((void (*)(int  ))(- 1));
  }
#line 216
  return (osa.__sigaction_handler.sa_handler);
}
}
#line 271 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void xseteuid(int euid ) 
{ 
  int oeuid ;
  __uid_t __cil_tmp3 ;
  __uid_t __cil_tmp4 ;
  __uid_t __cil_tmp5 ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;

  {
  {
#line 276
  __cil_tmp3 = geteuid();
#line 276
  oeuid = (int )__cil_tmp3;
  }
#line 277
  if (oeuid == euid) {
#line 278
    return;
  }
  {
#line 279
  __cil_tmp4 = getuid();
  }
#line 279
  if ((int )__cil_tmp4 != euid) {
    {
#line 280
    __cil_tmp5 = getuid();
#line 280
    oeuid = (int )__cil_tmp5;
    }
  }
  {
#line 281
  __cil_tmp6 = setreuid((__uid_t )oeuid, (__uid_t )euid);
  }
#line 281
  if (__cil_tmp6) {
    {
#line 282
    __cil_tmp7 = __errno_location();
#line 282
    Panic(*__cil_tmp7, (char const   *)((char *)"setreuid"));
    }
  }
  return;
}
}
#line 286 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void xsetegid(int egid ) 
{ 
  int oegid ;
  __gid_t __cil_tmp3 ;
  __gid_t __cil_tmp4 ;
  __gid_t __cil_tmp5 ;
  int __cil_tmp6 ;
  int *__cil_tmp7 ;

  {
  {
#line 291
  __cil_tmp3 = getegid();
#line 291
  oegid = (int )__cil_tmp3;
  }
#line 292
  if (oegid == egid) {
#line 293
    return;
  }
  {
#line 294
  __cil_tmp4 = getgid();
  }
#line 294
  if ((int )__cil_tmp4 != egid) {
    {
#line 295
    __cil_tmp5 = getgid();
#line 295
    oegid = (int )__cil_tmp5;
    }
  }
  {
#line 296
  __cil_tmp6 = setregid((__gid_t )oegid, (__gid_t )egid);
  }
#line 296
  if (__cil_tmp6) {
    {
#line 297
    __cil_tmp7 = __errno_location();
#line 297
    Panic(*__cil_tmp7, (char const   *)((char *)"setregid"));
    }
  }
  return;
}
}
#line 325 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void bclear(char *p , int n ) 
{ 


  {
  {
#line 329
  bcopy((void const   *)((char *)blank), (void *)p, (size_t )n);
  }
  return;
}
}
#line 334 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void Kill(int pid , int sig ) 
{ 
  int __cil_tmp3 ;

  {
#line 337
  if (pid < 2) {
#line 338
    return;
  }
  {
#line 339
  __cil_tmp3 = kill(pid, sig);
  }
  return;
}
}
#line 369 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void closeallfiles(int except ) 
{ 
  int f ;

  {
  {
#line 383
  f = getdtablesize();
  }
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (f > 2)) {
#line 385
      goto while_break;
    }
#line 386
    if (f != except) {
      {
#line 387
      close(f);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 401
static int UserSTAT ;
#line 404 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
int UserContext(void) 
{ 


  {
  {
#line 432
  xseteuid(real_uid);
#line 433
  xsetegid(real_gid);
  }
#line 434
  return (1);
}
}
#line 439 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void UserReturn(int val ) 
{ 


  {
  {
#line 448
  xseteuid(eff_uid);
#line 449
  xsetegid(eff_gid);
#line 450
  UserSTAT = val;
  }
  return;
}
}
#line 455 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
int UserStatus(void) 
{ 


  {
#line 477
  return (UserSTAT);
}
}
#line 495 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
int AddXChar(char *buf , int ch ) 
{ 
  char *p ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 499
  p = buf;
#line 501
  if (ch < 32) {
    _L: /* CIL Label */ 
#line 503
    __cil_tmp4 = p;
#line 503
    p ++;
#line 503
    *__cil_tmp4 = (char )'^';
#line 504
    __cil_tmp5 = p;
#line 504
    p ++;
#line 504
    *__cil_tmp5 = (char )(ch ^ 64);
  } else
#line 501
  if (ch == 127) {
#line 501
    goto _L;
  } else
#line 506
  if (ch >= 128) {
#line 508
    __cil_tmp6 = p;
#line 508
    p ++;
#line 508
    *__cil_tmp6 = (char )'\\';
#line 509
    __cil_tmp7 = p;
#line 509
    p ++;
#line 509
    *__cil_tmp7 = (char )(((ch >> 6) & 7) + 48);
#line 510
    __cil_tmp8 = p;
#line 510
    p ++;
#line 510
    *__cil_tmp8 = (char )(((ch >> 3) & 7) + 48);
#line 511
    __cil_tmp9 = p;
#line 511
    p ++;
#line 511
    *__cil_tmp9 = (char )((ch & 7) + 48);
  } else {
#line 514
    __cil_tmp10 = p;
#line 514
    p ++;
#line 514
    *__cil_tmp10 = (char )ch;
  }
#line 515
  return ((int )(p - buf));
}
}
#line 519 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
int AddXChars(char *buf , int len , char *str ) 
{ 
  char *p ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 525
  if (str == (char *)0) {
#line 527
    *buf = (char )0;
#line 528
    return (0);
  }
#line 530
  len -= 4;
#line 531
  p = buf;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! (p < buf + len && (int )*str)) {
#line 531
      goto while_break;
    }
#line 533
    if ((int )*str == 32) {
#line 534
      __cil_tmp5 = p;
#line 534
      p ++;
#line 534
      *__cil_tmp5 = *str;
    } else {
      {
#line 536
      __cil_tmp6 = AddXChar(p, (int )*str);
      }
#line 536
      p += __cil_tmp6;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  str ++;
#line 538
  *p = (char )0;
#line 539
  return ((int )(p - buf));
}
}
#line 571 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void sleep1000(int msec ) 
{ 
  struct timeval t ;

  {
  {
#line 577
  t.tv_sec = (long )(msec / 1000);
#line 578
  t.tv_usec = (long )((msec % 1000) * 1000);
#line 579
  select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, & t);
  }
  return;
}
}
#line 588 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
void xsetenv(char *var , char *value ) 
{ 


  {
  {
#line 623
  setenv((char const   *)var, (char const   *)value, 1);
  }
  return;
}
}
#line 636 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/misc.c"
int _delay(int delay , int (*outc)(int  ) ) 
{ 
  int pad ;
  extern short ospeed___0 ;
  static short osp2pad[] ;
  int __cil_tmp6 ;

  {
#line 646
  if ((int )ospeed___0 <= 0) {
#line 647
    return (0);
  } else
#line 646
  if ((int )ospeed___0 >= (int )(sizeof(osp2pad) / sizeof(*((short *)osp2pad)))) {
#line 647
    return (0);
  }
#line 648
  pad = (int )osp2pad[ospeed___0];
#line 649
  delay = (delay + pad / 2) / pad;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (__cil_tmp6 > 0)) {
#line 650
      goto while_break;
    }
    {
#line 651
    (*outc)(0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  return (0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 48 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static int is_letter(char c ) ;
#line 49
static void nextword(int *xp , int *yp , int flags , int num ) ;
#line 50
static int linestart(int y ) ;
#line 51
static int lineend(int y ) ;
#line 52
static int rem(int x1 , int y1 , int x2 , int y2 , int redisplay , char *pt , int yend ) ;
#line 53
static int eq(int a , int b ) ;
#line 54
static int MarkScrollDownDisplay(int n ) ;
#line 55
static int MarkScrollUpDisplay(int n ) ;
#line 57
static void MarkProcess(char **inbufp , int *inlenp ) ;
#line 58
static void MarkAbort(void) ;
#line 59
static void MarkRedisplayLine(int y , int xs , int xe , int isblank ) ;
#line 60
static int MarkRewrite(int ry , int xs , int xe , struct mchar *rend , int doit ) ;
#line 69 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
int pastefont  =    1;
#line 72 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
struct LayFuncs MarkLf  = 
#line 72
     {MarkProcess, MarkAbort, MarkRedisplayLine, DefClearLine, MarkRewrite, DefResize,
    DefRestore, (void (*)(void * ))0};
#line 84 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
int join_with_cr  =    0;
#line 85 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
int compacthist  =    0;
#line 89
static struct markdata *markdata ;
#line 97 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static int is_letter(char c ) 
{ 


  {
#line 100
  if ((int )c >= 97) {
#line 100
    if ((int )c <= 122) {
#line 108
      return (1);
    } else {
#line 100
      goto _L___967;
    }
  } else
  _L___967: /* CIL Label */ 
#line 100
  if ((int )c >= 65) {
#line 100
    if ((int )c <= 90) {
#line 108
      return (1);
    } else {
#line 100
      goto _L___966;
    }
  } else
  _L___966: /* CIL Label */ 
#line 100
  if ((int )c >= 48) {
#line 100
    if ((int )c <= 57) {
#line 108
      return (1);
    } else {
#line 100
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 100
  if ((int )c == 95) {
#line 108
    return (1);
  } else
#line 100
  if ((int )c == 46) {
#line 108
    return (1);
  } else
#line 100
  if ((int )c == 64) {
#line 108
    return (1);
  } else
#line 100
  if ((int )c == 58) {
#line 108
    return (1);
  } else
#line 100
  if ((int )c == 37) {
#line 108
    return (1);
  } else
#line 100
  if ((int )c == 33) {
#line 108
    return (1);
  } else
#line 100
  if ((int )c == 45) {
#line 108
    return (1);
  } else
#line 100
  if ((int )c == 43) {
#line 108
    return (1);
  } else
#line 109
  if ((int )c != 32) {
#line 110
    return (2);
  }
#line 111
  return (0);
}
}
#line 115 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static int linestart(int y ) 
{ 
  register int x ;
  register unsigned char *i ;
  struct mline *tmp ;
  unsigned char *__cil_tmp5 ;

  {
#line 121
  i = tmp->image + x;
#line 121
  x = markdata->left_mar;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (x < fore->w_layer.l_width - 1)) {
#line 121
      goto while_break;
    }
#line 122
    __cil_tmp5 = i;
#line 122
    i ++;
#line 122
    if ((int )*__cil_tmp5 != 32) {
#line 123
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  x ++;
#line 124
  if (x == fore->w_layer.l_width - 1) {
#line 125
    x = markdata->left_mar;
  }
#line 126
  return (x);
}
}
#line 130 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static int lineend(int y ) 
{ 
  register int x ;
  register unsigned char *i ;
  struct mline *tmp ;
  unsigned char *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 136
  i = tmp->image + x;
#line 136
  x = markdata->right_mar;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (x >= 0)) {
#line 136
      goto while_break;
    }
#line 137
    __cil_tmp5 = i;
#line 137
    i --;
#line 137
    if ((int )*__cil_tmp5 != 32) {
#line 138
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  __cil_tmp6 = x;
#line 136
  x --;
#line 139
  if (x < 0) {
#line 140
    x = markdata->left_mar;
  }
#line 141
  return (x);
}
}
#line 150 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static int nextchar(int *xp , int *yp , int direction , char target , int num ) 
{ 
  int width ;
  int x ;
  int step ;
  int adjust ;
  char *displayed_line ;
  struct mline *tmp ;

  {
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  x = *xp;
#line 161
  step = 1;
#line 162
  adjust = 0;
#line 163
  width = fore->w_layer.l_width;
#line 164
  displayed_line = (char *)tmp->image;
  {
#line 167
  if (direction == 't') {
#line 167
    goto case_116;
  }
#line 169
  if (direction == 'f') {
#line 169
    goto case_102;
  }
#line 172
  if (direction == 'T') {
#line 172
    goto case_84;
  }
#line 174
  if (direction == 'F') {
#line 174
    goto case_70;
  }
#line 177
  goto switch_default;
  case_116: /* CIL Label */ 
#line 168
  adjust = - 1;
  case_102: /* CIL Label */ 
#line 170
  step = 1;
#line 171
  goto switch_break;
  case_84: /* CIL Label */ 
#line 173
  adjust = 1;
  case_70: /* CIL Label */ 
#line 175
  step = - 1;
#line 176
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 181
  x += step;
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 184
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 184
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 185
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 185
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 187
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 187
    if (! (x >= 0 && x <= width)) {
#line 187
      goto while_break___4;
    }
#line 188
    if ((int )*(displayed_line + x) == (int )target) {
#line 189
      num --;
#line 189
      if (num == 0) {
#line 190
        *xp = x + adjust;
#line 191
        return (0);
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 187
  x += step;
#line 195
  return (- 1);
}
}
#line 215 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static void nextword(int *xp , int *yp , int flags , int num ) 
{ 
  int xx ;
  int yy ;
  register int sx ;
  register int oq ;
  register int q ;
  register int x ;
  register int y ;
  struct mline *ml ;
  int tmp ;
  struct mline *tmp___968 ;
  struct mline *tmp___970 ;
  struct mline *tmp___971 ;

  {
#line 218
  xx = fore->w_layer.l_width;
#line 218
  yy = fore->w_histheight + fore->w_layer.l_height;
#line 222
  x = *xp;
#line 223
  y = *yp;
#line 224
  if (flags & 1) {
#line 224
    tmp = - 1;
  } else {
#line 224
    tmp = 1;
  }
#line 224
  sx = tmp;
#line 225
  if (flags & (1 << 1)) {
#line 225
    if (flags & (1 << 2)) {
#line 226
      x += sx;
    }
  }
#line 227
  if (y < fore->w_histheight) {
#line 227
    tmp___968 = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
  } else {
#line 227
    tmp___968 = & *(fore->w_mlines + (y - fore->w_histheight));
  }
#line 227
  ml = tmp___968;
#line 228
  oq = - 1;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! 1) {
#line 228
      goto while_break;
    }
#line 230
    if (x >= xx) {
#line 231
      q = 0;
    } else
#line 230
    if (x < 0) {
#line 231
      q = 0;
    } else
#line 232
    if (flags & (1 << 3)) {
#line 233
      q = (int )*(ml->image + x) == 32;
    } else {
      {
#line 235
      q = is_letter((int )*(ml->image + x));
      }
    }
#line 236
    if (oq >= 0) {
#line 236
      if (oq != q) {
#line 238
        if (oq == 0) {
#line 239
          *xp = x;
        } else
#line 238
        if (! (flags & (1 << 1))) {
#line 239
          *xp = x;
        } else {
#line 241
          *xp = x - sx;
        }
#line 242
        *yp = y;
#line 243
        if (! (flags & (1 << 1))) {
#line 243
          if (q) {
            _L: /* CIL Label */ 
#line 246
            num --;
#line 246
            if (num <= 0) {
#line 247
              return;
            }
          } else {
#line 243
            goto _L___969;
          }
        } else
        _L___969: /* CIL Label */ 
#line 243
        if (flags & (1 << 1)) {
#line 243
          if (oq) {
#line 243
            goto _L;
          }
        }
      }
    }
#line 250
    if (x == xx) {
#line 252
      x = - 1;
#line 253
      y ++;
#line 253
      if (y >= yy) {
#line 254
        return;
      }
#line 255
      if (y < fore->w_histheight) {
#line 255
        tmp___970 = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
      } else {
#line 255
        tmp___970 = & *(fore->w_mlines + (y - fore->w_histheight));
      }
#line 255
      ml = tmp___970;
    } else
#line 257
    if (x < 0) {
#line 259
      x = xx;
#line 260
      y --;
#line 260
      if (y < 0) {
#line 261
        return;
      }
#line 262
      if (y < fore->w_histheight) {
#line 262
        tmp___971 = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
      } else {
#line 262
        tmp___971 = & *(fore->w_mlines + (y - fore->w_histheight));
      }
#line 262
      ml = tmp___971;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  oq = q;
#line 228
  x += sx;
  return;
}
}
#line 277 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static int rem(int x1 , int y1 , int x2 , int y2 , int redisplay , char *pt , int yend ) 
{ 
  int i ;
  int j ;
  int from ;
  int to ;
  int ry ;
  int c ;
  int l ;
  unsigned char *im ;
  struct mline *ml ;
  int cf ;
  int cfx ;
  int font ;
  unsigned char *fo ;
  unsigned char *fox ;
  struct mline *tmp ;
  int tmp___972 ;
  unsigned char *__cil_tmp24 ;
  int __cil_tmp25 ;
  int tmp___973 ;
  int __cil_tmp27 ;
  unsigned char *__cil_tmp28 ;
  unsigned char *__cil_tmp29 ;
  unsigned char *__cil_tmp30 ;
  unsigned char *__cil_tmp32 ;
  char *__cil_tmp36 ;
  char *__cil_tmp39 ;
  char *__cil_tmp41 ;
  char *__cil_tmp43 ;
  char *__cil_tmp45 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;

  {
#line 282
  l = 0;
#line 290
  markdata->second = 0;
#line 291
  if (y2 < y1) {
    _L: /* CIL Label */ 
#line 293
    i = y2;
#line 294
    y2 = y1;
#line 295
    y1 = i;
#line 296
    i = x2;
#line 297
    x2 = x1;
#line 298
    x1 = i;
  } else
#line 291
  if (y2 == y1) {
#line 291
    if (x2 < x1) {
#line 291
      goto _L;
    }
  }
#line 300
  ry = y1 - markdata->hist_offset;
#line 302
  i = y1;
#line 303
  if (redisplay != 2) {
#line 303
    if (pt == (char *)0) {
#line 303
      if (ry < 0) {
#line 305
        i -= ry;
#line 306
        ry = 0;
      }
    }
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i <= y2)) {
#line 308
      goto while_break;
    }
#line 310
    if (redisplay != 2) {
#line 310
      if (pt == (char *)0) {
#line 310
        if (ry > yend) {
#line 311
          goto while_break;
        }
      }
    }
#line 312
    if (i < fore->w_histheight) {
#line 312
      tmp = & *(fore->w_hlines + (fore->w_histidx + i) % fore->w_histheight);
    } else {
#line 312
      tmp = & *(fore->w_mlines + (i - fore->w_histheight));
    }
#line 312
    ml = tmp;
#line 313
    if (i == y1) {
#line 313
      tmp___972 = x1;
    } else {
#line 313
      tmp___972 = 0;
    }
#line 313
    from = tmp___972;
#line 314
    if (from < markdata->left_mar) {
#line 315
      from = markdata->left_mar;
    }
#line 316
    im = ml->image + to;
#line 316
    to = fore->w_layer.l_width;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! (to >= 0)) {
#line 316
        goto while_break___0;
      }
#line 317
      __cil_tmp24 = im;
#line 317
      im --;
#line 317
      if ((int )*__cil_tmp24 != 32) {
#line 318
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 316
    __cil_tmp25 = to;
#line 316
    to --;
#line 319
    if (i == y2) {
#line 319
      if (x2 < to) {
#line 320
        to = x2;
      }
    }
#line 321
    if (to > markdata->right_mar) {
#line 322
      to = markdata->right_mar;
    }
#line 323
    if (redisplay == 1) {
#line 323
      if (from <= to) {
#line 323
        if (ry >= 0) {
#line 323
          if (ry <= yend) {
            {
#line 324
            MarkRedisplayLine(ry, from, to, 0);
            }
          }
        }
      }
    }
#line 325
    if (redisplay != 2) {
#line 325
      if (pt == (char *)0) {
#line 326
        goto while_continue;
      }
    }
#line 327
    j = from;
#line 329
    if (fore->w_layer.l_encoding == 8) {
#line 329
      tmp___973 = (int )*(ml->font + j) == 255 && (int )*(ml->image + j) == 255;
    } else {
#line 329
      tmp___973 = ((int )*(ml->font + j) & 224) == 128;
    }
#line 329
    if (tmp___973) {
#line 330
      __cil_tmp27 = j;
#line 330
      j --;
    }
#line 332
    im = ml->image + j;
#line 334
    fo = ml->font + j;
#line 335
    fox = ml->fontx + j;
#line 336
    font = 0;
    {
#line 338
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 338
      if (! (j <= to)) {
#line 338
        goto while_break___1;
      }
#line 340
      __cil_tmp28 = im;
#line 340
      im ++;
#line 340
      c = (int )*__cil_tmp28;
#line 342
      __cil_tmp29 = fo;
#line 342
      fo ++;
#line 342
      cf = (int )*__cil_tmp29;
#line 343
      __cil_tmp30 = fox;
#line 343
      fox ++;
#line 343
      cfx = (int )*__cil_tmp30;
#line 345
      if (fore->w_layer.l_encoding == 8) {
#line 347
        c |= (cf << 8) | (cfx << 16);
#line 348
        if (c == 65535) {
#line 349
          goto while_continue___1;
        }
        {
#line 350
        c = ToUtf8_comb(pt, c);
#line 351
        l += c;
        }
#line 352
        if (pt) {
#line 353
          pt += c;
        }
#line 354
        goto while_continue___1;
      }
#line 358
      if (cf) {
#line 358
        if ((cf & 96) == 0) {
#line 360
          __cil_tmp32 = im;
#line 360
          im ++;
#line 360
          c = (c << 8) | (int )*__cil_tmp32;
#line 361
          fo ++;
#line 362
          j ++;
        }
      }
#line 365
      if (pastefont) {
        {
#line 367
        c = EncodeChar(pt, c | (cf << 16), fore->w_layer.l_encoding, & font);
#line 368
        l += c;
        }
#line 369
        if (pt) {
#line 370
          pt += c;
        }
#line 371
        goto while_continue___1;
      }
#line 374
      if (pt) {
#line 375
        __cil_tmp36 = pt;
#line 375
        pt ++;
#line 375
        *__cil_tmp36 = (char )c;
      }
#line 376
      l ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 338
    j ++;
#line 379
    if (pastefont) {
#line 379
      if (font != 0) {
#line 381
        if (pt) {
          {
#line 383
          strcpy(pt, (char const   *)((char *)"\033(B"));
#line 384
          pt += 3;
          }
        }
#line 386
        l += 3;
      }
    }
#line 389
    if (i != y2) {
#line 389
      if (to != fore->w_layer.l_width - 1) {
        _L___974: /* CIL Label */ 
        {
#line 396
        if (markdata->nonl == 0) {
#line 396
          goto case_0;
        }
#line 407
        if (markdata->nonl == 1) {
#line 407
          goto case_1;
        }
#line 409
        if (markdata->nonl == 2) {
#line 409
          goto case_2;
        }
#line 414
        if (markdata->nonl == 3) {
#line 414
          goto case_3;
        }
#line 394
        goto switch_break;
        case_0: /* CIL Label */ 
#line 397
        if (pt) {
#line 398
          __cil_tmp39 = pt;
#line 398
          pt ++;
#line 398
          *__cil_tmp39 = (char )'\r';
        }
#line 399
        l ++;
#line 400
        if (join_with_cr) {
#line 402
          if (pt) {
#line 403
            __cil_tmp41 = pt;
#line 403
            pt ++;
#line 403
            *__cil_tmp41 = (char )'\n';
          }
#line 404
          l ++;
        }
#line 406
        goto switch_break;
        case_1: /* CIL Label */ 
#line 408
        goto switch_break;
        case_2: /* CIL Label */ 
#line 410
        if (pt) {
#line 411
          __cil_tmp43 = pt;
#line 411
          pt ++;
#line 411
          *__cil_tmp43 = (char )' ';
        }
#line 412
        l ++;
#line 413
        goto switch_break;
        case_3: /* CIL Label */ 
#line 415
        if (pt) {
#line 416
          __cil_tmp45 = pt;
#line 416
          pt ++;
#line 416
          *__cil_tmp45 = (char )',';
        }
#line 417
        l ++;
#line 418
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else
#line 389
      if ((int )*(ml->image + (to + 1)) == 32) {
#line 389
        goto _L___974;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  __cil_tmp48 = ry;
#line 308
  ry ++;
#line 308
  __cil_tmp47 = i;
#line 308
  i ++;
#line 422
  return (l);
}
}
#line 430 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static int eq(int a , int b ) 
{ 


  {
#line 433
  if (a == b) {
#line 434
    return (1);
  }
#line 435
  if (a == 0) {
#line 436
    return (1);
  } else
#line 435
  if (b == 0) {
#line 436
    return (1);
  }
#line 437
  if (a <= 57) {
#line 437
    if (a >= 48) {
#line 437
      if (b <= 57) {
#line 437
        if (b >= 48) {
#line 438
          return (1);
        }
      }
    }
  }
#line 439
  return (0);
}
}
#line 446 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
int GetHistory(void) 
{ 
  int i ;
  int q ;
  int xx ;
  int yy ;
  int x ;
  int y ;
  unsigned char *linep ;
  struct mline *ml ;
  struct mline *tmp ;
  unsigned char *__cil_tmp10 ;
  int __cil_tmp11 ;
  struct mline *tmp___975 ;
  int __cil_tmp13 ;
  unsigned char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 448
  i = 0;
#line 448
  q = 0;
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  x = fore->w_layer.l_x;
#line 454
  if (x >= fore->w_layer.l_width) {
#line 455
    x = fore->w_layer.l_width - 1;
  }
#line 456
  y = fore->w_layer.l_y + fore->w_histheight;
  {
#line 457
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 457
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 458
  if (y < fore->w_histheight) {
#line 458
    tmp = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
  } else {
#line 458
    tmp = & *(fore->w_mlines + (y - fore->w_histheight));
  }
#line 458
  ml = tmp;
#line 459
  linep = ml->image + xx;
#line 459
  xx = x - 1;
  {
#line 459
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 459
    if (! (xx >= 0)) {
#line 459
      goto while_break___1;
    }
#line 460
    __cil_tmp10 = linep;
#line 460
    linep --;
#line 460
    q = (int )*__cil_tmp10;
#line 460
    if (q != 32) {
#line 461
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 459
  __cil_tmp11 = xx;
#line 459
  xx --;
  {
#line 462
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 462
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 463
  yy = y - 1;
  {
#line 463
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 463
    if (! (yy >= 0)) {
#line 463
      goto while_break___3;
    }
#line 465
    if (yy < fore->w_histheight) {
#line 465
      tmp___975 = & *(fore->w_hlines + (fore->w_histidx + yy) % fore->w_histheight);
    } else {
#line 465
      tmp___975 = & *(fore->w_mlines + (yy - fore->w_histheight));
    }
    {
#line 465
    ml = tmp___975;
#line 466
    linep = ml->image;
#line 467
    __cil_tmp13 = eq((int )*(linep + xx), q);
    }
#line 467
    if (xx < 0) {
      _L: /* CIL Label */ 
#line 469
      linep += i;
#line 469
      i = fore->w_layer.l_width - 1;
      {
#line 469
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 469
        if (! (i >= x)) {
#line 469
          goto while_break___4;
        }
#line 470
        __cil_tmp14 = linep;
#line 470
        linep --;
#line 470
        if ((int )*__cil_tmp14 != 32) {
#line 471
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 469
      __cil_tmp15 = i;
#line 469
      i --;
#line 472
      if (i >= x) {
#line 473
        goto while_break___3;
      }
    } else
#line 467
    if (__cil_tmp13) {
#line 467
      goto _L;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 463
  __cil_tmp16 = yy;
#line 463
  yy --;
#line 476
  if (yy < 0) {
#line 477
    return (0);
  }
#line 478
  if ((display->d_user)->u_plop.buf) {
    {
#line 479
    UserFreeCopyBuffer(display->d_user);
    }
  }
  {
#line 480
  __cil_tmp17 = malloc((unsigned long )((unsigned int )((i - x) + 2)));
#line 480
  (display->d_user)->u_plop.buf = (char *)__cil_tmp17;
  }
#line 480
  if ((display->d_user)->u_plop.buf == (char *)((void *)0)) {
    {
#line 482
    LMsg(0, (char const   *)((char *)"Not enough memory... Sorry."));
    }
#line 483
    return (0);
  }
  {
#line 485
  bcopy((void const   *)((((char *)linep - i) + x) + 1), (void *)(display->d_user)->u_plop.buf,
        (size_t )((i - x) + 1));
#line 486
  (display->d_user)->u_plop.len = (i - x) + 1;
#line 488
  (display->d_user)->u_plop.enc = fore->w_layer.l_encoding;
  }
#line 490
  return (1);
}
}
#line 497 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
void MarkRoutine(void) 
{ 
  int x ;
  int y ;
  int __cil_tmp3 ;

  {
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 506
  __cil_tmp3 = InitOverlayPage((int )sizeof(*markdata), & MarkLf, 1);
  }
#line 506
  if (__cil_tmp3) {
#line 507
    return;
  }
#line 508
  flayer->l_encoding = fore->w_layer.l_encoding;
#line 509
  flayer->l_mode = 1;
#line 510
  markdata = (struct markdata *)flayer->l_data;
#line 511
  markdata->md_user = display->d_user;
#line 512
  markdata->md_window = fore;
#line 513
  markdata->second = 0;
#line 514
  markdata->rep_cnt = 0;
#line 515
  markdata->append_mode = 0;
#line 516
  markdata->write_buffer = 0;
#line 517
  markdata->nonl = 0;
#line 518
  markdata->left_mar = 0;
#line 519
  markdata->right_mar = fore->w_layer.l_width - 1;
#line 520
  markdata->hist_offset = fore->w_histheight;
#line 521
  x = fore->w_layer.l_x;
#line 522
  y = fore->w_layer.l_y + markdata->hist_offset;
#line 523
  if (x >= fore->w_layer.l_width) {
#line 524
    x = fore->w_layer.l_width - 1;
  }
  {
#line 526
  LGotoPos(flayer, x, y - markdata->hist_offset);
#line 527
  LMsg(0, (char const   *)((char *)"Copy mode - Column %d Line %d(+%d) (%d,%d)"),
       x + 1, (y + 1) - markdata->hist_offset, fore->w_histheight, fore->w_layer.l_width,
       fore->w_layer.l_height);
#line 529
  markdata->x1 = x;
#line 529
  markdata->cx = markdata->x1;
#line 530
  markdata->y1 = y;
#line 530
  markdata->cy = markdata->y1;
#line 531
  flayer->l_x = x;
#line 532
  flayer->l_y = y - markdata->hist_offset;
  }
  return;
}
}
#line 536 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static void MarkProcess(char **inbufp , int *inlenp ) 
{ 
  char *inbuf ;
  char *pt ;
  int inlen ;
  int cx ;
  int cy ;
  int x2 ;
  int y2 ;
  int j ;
  int yend ;
  int newcopylen ;
  int od ;
  int in_mark ;
  int rep_cnt ;
  struct acluser *md_user ;
  unsigned char ch ;
  char *__cil_tmp18 ;
  int __cil_tmp19 ;
  int r ;
  int __cil_tmp21 ;
  unsigned short const   **__cil_tmp22 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int tmp___976 ;
  int tmp___977 ;
  char *tmp___978 ;
  int __cil_tmp34 ;
  char *tmp___979 ;
  int __cil_tmp36 ;
  int __cil_tmp38 ;
  int append_mode ;
  int write_buffer ;
  int __cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  int __cil_tmp51 ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;
  int button ;

  {
#line 543
  newcopylen = 0;
#line 552
  markdata = (struct markdata *)flayer->l_data;
#line 553
  fore = markdata->md_window;
#line 554
  md_user = markdata->md_user;
#line 555
  if (inbufp == (char **)0) {
    {
#line 557
    MarkAbort();
    }
#line 558
    return;
  }
  {
#line 561
  LGotoPos(flayer, markdata->cx, markdata->cy - markdata->hist_offset);
#line 562
  inbuf = *inbufp;
#line 563
  inlen = *inlenp;
#line 564
  pt = inbuf;
#line 565
  in_mark = 1;
  }
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (in_mark && inlen)) {
#line 566
      goto while_break;
    }
#line 568
    __cil_tmp18 = pt;
#line 568
    pt ++;
#line 568
    ch = (unsigned char )*__cil_tmp18;
#line 569
    __cil_tmp19 = inlen;
#line 569
    inlen --;
#line 570
    if (flayer->l_mouseevent.start) {
      {
#line 572
      __cil_tmp21 = LayProcessMouse(flayer, ch);
#line 572
      r = __cil_tmp21;
      }
#line 573
      if (r == -1) {
        {
#line 574
        LayProcessMouseSwitch(flayer, 0);
        }
      } else
#line 577
      if (r) {
#line 578
        ch = (unsigned char )146;
      } else {
#line 580
        goto while_continue;
      }
    }
#line 583
    od = (int )mark_key_tab[(int )ch];
#line 584
    rep_cnt = markdata->rep_cnt;
#line 585
    if (od >= 48) {
#line 585
      if (od <= 57) {
#line 585
        if (! markdata->f_cmd.flag) {
#line 587
          if (rep_cnt < 1001) {
#line 587
            if (od != 48) {
#line 589
              markdata->rep_cnt = (10 * rep_cnt + od) - 48;
#line 590
              goto while_continue;
            } else
#line 587
            if (rep_cnt != 0) {
#line 589
              markdata->rep_cnt = (10 * rep_cnt + od) - 48;
#line 590
              goto while_continue;
            }
          }
        }
      }
    }
#line 603
    cx = markdata->cx;
#line 604
    cy = markdata->cy;
#line 606
    if (markdata->f_cmd.flag) {
      {
#line 607
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 607
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 608
      markdata->f_cmd.flag = 0;
#line 609
      markdata->rep_cnt = 0;
#line 611
      __cil_tmp22 = __ctype_b_loc();
      }
#line 611
      if ((int )((unsigned short )*(*__cil_tmp22 + od)) & 32768) {
#line 612
        markdata->f_cmd.target = od;
#line 613
        if (rep_cnt) {
#line 613
          tmp = rep_cnt;
        } else {
#line 613
          tmp = 1;
        }
        {
#line 613
        rep_cnt = tmp;
#line 614
        nextchar(& cx, & cy, markdata->f_cmd.direction, (char )od, rep_cnt);
#line 615
        revto(cx, cy);
        }
#line 616
        goto while_continue;
      }
    }
    processchar: 
    {
#line 626
    if (od == 'T') {
#line 626
      goto case_84;
    }
#line 626
    if (od == 't') {
#line 626
      goto case_84;
    }
#line 626
    if (od == 'F') {
#line 626
      goto case_84;
    }
#line 626
    if (od == 'f') {
#line 626
      goto case_84;
    }
#line 640
    if (od == ',') {
#line 640
      goto case_44;
    }
#line 640
    if (od == ';') {
#line 640
      goto case_44;
    }
#line 651
    if (od == 'x') {
#line 651
      goto case_120;
    }
#line 651
    if (od == 'o') {
#line 651
      goto case_120;
    }
#line 660
    if (od == '\f') {
#line 660
      goto case_12;
    }
#line 666
    if (od == 'h') {
#line 666
      goto case_104;
    }
#line 666
    if (od == '\b') {
#line 666
      goto case_104;
    }
#line 666
    if (od == 130) {
#line 666
      goto case_104;
    }
#line 673
    if (od == 'j') {
#line 673
      goto case_106;
    }
#line 673
    if (od == '\016') {
#line 673
      goto case_106;
    }
#line 673
    if (od == 142) {
#line 673
      goto case_106;
    }
#line 678
    if (od == '+') {
#line 678
      goto case_43;
    }
#line 686
    if (od == '-') {
#line 686
      goto case_45;
    }
#line 694
    if (od == '^') {
#line 694
      goto case_94;
    }
#line 697
    if (od == '\n') {
#line 697
      goto case_10;
    }
#line 702
    if (od == 'k') {
#line 702
      goto case_107;
    }
#line 702
    if (od == '\020') {
#line 702
      goto case_107;
    }
#line 702
    if (od == 144) {
#line 702
      goto case_107;
    }
#line 708
    if (od == 'l') {
#line 708
      goto case_108;
    }
#line 708
    if (od == 134) {
#line 708
      goto case_108;
    }
#line 714
    if (od == '0') {
#line 714
      goto case_48;
    }
#line 714
    if (od == '\001') {
#line 714
      goto case_48;
    }
#line 717
    if (od == '\004') {
#line 717
      goto case_4;
    }
#line 722
    if (od == '$') {
#line 722
      goto case_36;
    }
#line 725
    if (od == '\022') {
#line 725
      goto case_18;
    }
#line 729
    if (od == '\023') {
#line 729
      goto case_19;
    }
#line 733
    if (od == '\025') {
#line 733
      goto case_21;
    }
#line 738
    if (od == '\a') {
#line 738
      goto case_7;
    }
#line 746
    if (od == '\002') {
#line 746
      goto case_2;
    }
#line 752
    if (od == '\006') {
#line 752
      goto case_6;
    }
#line 758
    if (od == '\005') {
#line 758
      goto case_5;
    }
#line 767
    if (od == '\031') {
#line 767
      goto case_25;
    }
#line 776
    if (od == '@') {
#line 776
      goto case_64;
    }
#line 779
    if (od == '%') {
#line 779
      goto case_37;
    }
#line 791
    if (od == 'g') {
#line 791
      goto case_103;
    }
#line 791
    if (od == 129) {
#line 791
      goto case_103;
    }
#line 795
    if (od == 'G') {
#line 795
      goto case_71;
    }
#line 795
    if (od == 133) {
#line 795
      goto case_71;
    }
#line 801
    if (od == 'H') {
#line 801
      goto case_72;
    }
#line 804
    if (od == 'M') {
#line 804
      goto case_77;
    }
#line 807
    if (od == 'L') {
#line 807
      goto case_76;
    }
#line 810
    if (od == '|') {
#line 810
      goto case_124;
    }
#line 813
    if (od == 'w') {
#line 813
      goto case_119;
    }
#line 820
    if (od == 'E') {
#line 820
      goto case_69;
    }
#line 820
    if (od == 'e') {
#line 820
      goto case_69;
    }
#line 827
    if (od == 'B') {
#line 827
      goto case_66;
    }
#line 827
    if (od == 'b') {
#line 827
      goto case_66;
    }
#line 833
    if (od == 'a') {
#line 833
      goto case_97;
    }
#line 839
    if (od == 'V') {
#line 839
      goto case_86;
    }
#line 839
    if (od == 'v') {
#line 839
      goto case_86;
    }
#line 847
    if (od == 'C') {
#line 847
      goto case_67;
    }
#line 847
    if (od == 'c') {
#line 847
      goto case_67;
    }
#line 877
    if (od == 'J') {
#line 877
      goto case_74;
    }
#line 882
    if (od == 0) {
#line 882
      goto case_0;
    }
#line 888
    if (od == 1) {
#line 888
      goto case_1___0;
    }
#line 891
    if (od == 2) {
#line 891
      goto case_2___0;
    }
#line 894
    if (od == 3) {
#line 894
      goto case_3;
    }
#line 899
    if (od == '/') {
#line 899
      goto case_47;
    }
#line 903
    if (od == '?') {
#line 903
      goto case_63;
    }
#line 907
    if (od == 'n') {
#line 907
      goto case_110;
    }
#line 910
    if (od == 'N') {
#line 910
      goto case_78;
    }
#line 916
    if (od == 'Y') {
#line 916
      goto case_89;
    }
#line 916
    if (od == 'y') {
#line 916
      goto case_89;
    }
#line 930
    if (od == 'W') {
#line 930
      goto case_87;
    }
#line 949
    if (od == 'A') {
#line 949
      goto case_65;
    }
#line 953
    if (od == '>') {
#line 953
      goto case_62;
    }
#line 958
    if (od == '\r') {
#line 958
      goto case_13;
    }
#line 958
    if (od == ' ') {
#line 958
      goto case_13;
    }
#line 1011
    if (od == 0) {
#line 1011
      goto case_0___0;
    }
#line 1020
    if (od == 1) {
#line 1020
      goto case_1___1;
    }
#line 1022
    if (od == 2) {
#line 1022
      goto case_2___1;
    }
#line 1026
    if (od == 3) {
#line 1026
      goto case_3___0;
    }
#line 1056
    if (od == 146) {
#line 1056
      goto case_146;
    }
#line 1088
    goto switch_default;
    case_84: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_102: /* CIL Label */ 
#line 635
    markdata->f_cmd.flag = 1;
#line 636
    markdata->f_cmd.direction = od;
    {
#line 637
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 637
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 638
    goto while_continue;
    case_44: /* CIL Label */ 
    case_59: /* CIL Label */ 
#line 641
    if (! markdata->f_cmd.target) {
#line 642
      goto switch_break;
    }
#line 643
    if (! rep_cnt) {
#line 644
      rep_cnt = 1;
    }
#line 645
    if (od == 59) {
#line 645
      tmp___0 = markdata->f_cmd.direction;
    } else {
#line 645
      tmp___0 = markdata->f_cmd.direction ^ 32;
    }
    {
#line 645
    nextchar(& cx, & cy, tmp___0, (char )markdata->f_cmd.target, rep_cnt);
#line 648
    revto(cx, cy);
    }
#line 649
    goto switch_break;
    case_120: /* CIL Label */ 
    case_111: /* CIL Label */ 
#line 652
    if (! markdata->second) {
#line 653
      goto switch_break;
    }
    {
#line 654
    markdata->cx = markdata->x1;
#line 655
    markdata->cy = markdata->y1;
#line 656
    markdata->x1 = cx;
#line 657
    markdata->y1 = cy;
#line 658
    revto(markdata->cx, markdata->cy);
    }
#line 659
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 661
    Redisplay(0);
    }
    {
#line 662
    LGotoPos(flayer, cx, cy - markdata->hist_offset);
    }
#line 663
    goto switch_break;
    case_104: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_130: /* CIL Label */ 
#line 667
    if (rep_cnt == 0) {
#line 668
      rep_cnt = 1;
    }
    {
#line 669
    revto(cx - rep_cnt, cy);
    }
#line 670
    goto switch_break;
    case_106: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_142: /* CIL Label */ 
#line 674
    if (rep_cnt == 0) {
#line 675
      rep_cnt = 1;
    }
    {
#line 676
    revto(cx, cy + rep_cnt);
    }
#line 677
    goto switch_break;
    case_43: /* CIL Label */ 
#line 679
    if (rep_cnt == 0) {
#line 680
      rep_cnt = 1;
    }
#line 681
    j = cy + rep_cnt;
#line 682
    if (j > (fore->w_histheight + fore->w_layer.l_height) - 1) {
#line 683
      j = (fore->w_histheight + fore->w_layer.l_height) - 1;
    }
    {
#line 684
    __cil_tmp25 = linestart(j);
#line 684
    revto(__cil_tmp25, j);
    }
#line 685
    goto switch_break;
    case_45: /* CIL Label */ 
#line 687
    if (rep_cnt == 0) {
#line 688
      rep_cnt = 1;
    }
#line 689
    cy -= rep_cnt;
#line 690
    if (cy < 0) {
#line 691
      cy = 0;
    }
    {
#line 692
    __cil_tmp26 = linestart(cy);
#line 692
    revto(__cil_tmp26, cy);
    }
#line 693
    goto switch_break;
    case_94: /* CIL Label */ 
    {
#line 695
    __cil_tmp27 = linestart(cy);
#line 695
    revto(__cil_tmp27, cy);
    }
#line 696
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 698
    revto(markdata->left_mar, cy + 1);
    }
#line 699
    goto switch_break;
    case_107: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_144: /* CIL Label */ 
#line 703
    if (rep_cnt == 0) {
#line 704
      rep_cnt = 1;
    }
    {
#line 705
    revto(cx, cy - rep_cnt);
    }
#line 706
    goto switch_break;
    case_108: /* CIL Label */ 
    case_134: /* CIL Label */ 
#line 709
    if (rep_cnt == 0) {
#line 710
      rep_cnt = 1;
    }
    {
#line 711
    revto(cx + rep_cnt, cy);
    }
#line 712
    goto switch_break;
    case_48: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 715
    revto(markdata->left_mar, cy);
    }
#line 716
    goto switch_break;
    case_4: /* CIL Label */ 
#line 718
    if (rep_cnt == 0) {
#line 719
      rep_cnt = (fore->w_layer.l_height + 1) >> 1;
    }
    {
#line 720
    revto_line(cx, cy + rep_cnt, cy - markdata->hist_offset);
    }
#line 721
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 723
    __cil_tmp28 = lineend(cy);
#line 723
    revto(__cil_tmp28, cy);
    }
#line 724
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 726
    ISearch(- 1);
    }
#line 727
    in_mark = 0;
#line 728
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 730
    ISearch(1);
    }
#line 731
    in_mark = 0;
#line 732
    goto switch_break;
    case_21: /* CIL Label */ 
#line 734
    if (rep_cnt == 0) {
#line 735
      rep_cnt = (fore->w_layer.l_height + 1) >> 1;
    }
    {
#line 736
    revto_line(cx, cy - rep_cnt, cy - markdata->hist_offset);
    }
#line 737
    goto switch_break;
    case_7: /* CIL Label */ 
#line 739
    if (markdata->left_mar == 0) {
#line 739
      if (markdata->right_mar == fore->w_layer.l_width - 1) {
        {
#line 740
        LMsg(0, (char const   *)((char *)"Column %d Line %d(+%d)"), cx + 1, (cy - markdata->hist_offset) + 1,
             markdata->hist_offset);
        }
      } else {
        {
        {
#line 743
        LMsg(0, (char const   *)((char *)"Column %d(%d..%d) Line %d(+%d)"), cx + 1,
             markdata->left_mar + 1, markdata->right_mar + 1, (cy - markdata->hist_offset) + 1,
             markdata->hist_offset);
        }
        }
      }
    } else {
      {
      {
#line 743
      LMsg(0, (char const   *)((char *)"Column %d(%d..%d) Line %d(+%d)"), cx + 1,
           markdata->left_mar + 1, markdata->right_mar + 1, (cy - markdata->hist_offset) + 1,
           markdata->hist_offset);
      }
      }
    }
#line 745
    goto switch_break;
    case_2: /* CIL Label */ 
#line 747
    if (rep_cnt == 0) {
#line 748
      rep_cnt = 1;
    }
    {
#line 749
    rep_cnt *= fore->w_layer.l_height;
#line 750
    revto(cx, cy - rep_cnt);
    }
#line 751
    goto switch_break;
    case_6: /* CIL Label */ 
#line 753
    if (rep_cnt == 0) {
#line 754
      rep_cnt = 1;
    }
    {
#line 755
    rep_cnt *= fore->w_layer.l_height;
#line 756
    revto(cx, cy + rep_cnt);
    }
#line 757
    goto switch_break;
    case_5: /* CIL Label */ 
#line 759
    if (rep_cnt == 0) {
#line 760
      rep_cnt = 1;
    }
    {
#line 761
    rep_cnt = MarkScrollUpDisplay(rep_cnt);
    }
#line 762
    if (cy < markdata->hist_offset) {
      {
#line 763
      revto(cx, markdata->hist_offset);
      }
    } else {
      {
#line 765
      LGotoPos(flayer, cx, cy - markdata->hist_offset);
      }
    }
#line 766
    goto switch_break;
    case_25: /* CIL Label */ 
#line 768
    if (rep_cnt == 0) {
#line 769
      rep_cnt = 1;
    }
    {
#line 770
    rep_cnt = MarkScrollDownDisplay(rep_cnt);
    }
#line 771
    if (cy > (fore->w_layer.l_height - 1) + markdata->hist_offset) {
      {
#line 772
      revto(cx, (fore->w_layer.l_height - 1) + markdata->hist_offset);
      }
    } else {
      {
#line 774
      LGotoPos(flayer, cx, cy - markdata->hist_offset);
      }
    }
#line 775
    goto switch_break;
    case_64: /* CIL Label */ 
#line 778
    goto switch_break;
    case_37: /* CIL Label */ 
#line 781
    if (rep_cnt < 0) {
#line 782
      rep_cnt = 0;
    }
#line 783
    if (rep_cnt > 100) {
#line 784
      rep_cnt = 100;
    }
    {
#line 785
    revto_line(markdata->left_mar, (fore->w_histheight - fore->w_scrollback_height) + (int )((double )(rep_cnt * (fore->w_scrollback_height + fore->w_layer.l_height)) / 100.),
               (fore->w_layer.l_height - 1) / 2);
    }
#line 789
    goto switch_break;
    case_103: /* CIL Label */ 
    case_129: /* CIL Label */ 
#line 792
    rep_cnt = 1;
    case_71: /* CIL Label */ 
    case_133: /* CIL Label */ 
#line 797
    if (rep_cnt == 0) {
#line 798
      rep_cnt = fore->w_histheight + fore->w_layer.l_height;
    }
    {
#line 799
    rep_cnt --;
#line 799
    revto_line(markdata->left_mar, rep_cnt, (fore->w_layer.l_height - 1) / 2);
    }
#line 800
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 802
    revto(markdata->left_mar, markdata->hist_offset);
    }
#line 803
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 805
    revto(markdata->left_mar, (fore->w_layer.l_height - 1) / 2 + markdata->hist_offset);
    }
#line 806
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 808
    revto(markdata->left_mar, (fore->w_layer.l_height - 1) + markdata->hist_offset);
    }
#line 809
    goto switch_break;
    case_124: /* CIL Label */ 
    {
#line 811
    rep_cnt --;
#line 811
    revto(rep_cnt, cy);
    }
#line 812
    goto switch_break;
    case_119: /* CIL Label */ 
#line 814
    if (rep_cnt == 0) {
#line 815
      rep_cnt = 1;
    }
    {
#line 816
    nextword(& cx, & cy, 1 << 2, rep_cnt);
#line 817
    revto(cx, cy);
    }
#line 818
    goto switch_break;
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 821
    if (rep_cnt == 0) {
#line 822
      rep_cnt = 1;
    }
#line 823
    if (od == 69) {
#line 823
      tmp___976 = 1 << 3;
    } else {
#line 823
      tmp___976 = 0;
    }
    {
#line 823
    nextword(& cx, & cy, ((1 << 1) | (1 << 2)) | tmp___976, rep_cnt);
#line 824
    revto(cx, cy);
    }
#line 825
    goto switch_break;
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 828
    if (rep_cnt == 0) {
#line 829
      rep_cnt = 1;
    }
#line 830
    if (od == 66) {
#line 830
      tmp___977 = 1 << 3;
    } else {
#line 830
      tmp___977 = 0;
    }
    {
#line 830
    nextword(& cx, & cy, ((1 | (1 << 1)) | (1 << 2)) | tmp___977, rep_cnt);
#line 831
    revto(cx, cy);
    }
#line 832
    goto switch_break;
    case_97: /* CIL Label */ 
#line 834
    markdata->append_mode = 1 - markdata->append_mode;
    {
#line 835
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 835
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 836
    if (markdata->append_mode) {
#line 836
      tmp___978 = (char *)":set append";
    } else {
#line 836
      tmp___978 = (char *)":set noappend";
    }
    {
#line 836
    LMsg(0, (char const   *)tmp___978);
    }
#line 837
    goto switch_break;
    case_86: /* CIL Label */ 
    case_118: /* CIL Label */ 
#line 841
    if (markdata->left_mar == 8) {
#line 842
      rep_cnt = 1;
    } else {
#line 844
      rep_cnt = 9;
    }
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
#line 849
    if (markdata->second) {
      {
#line 851
      rem(markdata->x1, markdata->y1, cx, cy, 1, (char *)0, fore->w_layer.l_height - 1);
#line 852
      markdata->second = 1;
      }
    }
#line 854
    __cil_tmp34 = rep_cnt;
#line 854
    rep_cnt --;
#line 855
    if (rep_cnt < 0) {
#line 856
      rep_cnt = cx;
    }
#line 857
    if (od != 67) {
#line 859
      markdata->left_mar = rep_cnt;
#line 860
      if (markdata->left_mar > markdata->right_mar) {
#line 861
        markdata->left_mar = markdata->right_mar;
      }
    } else {
#line 865
      markdata->right_mar = rep_cnt;
#line 866
      if (markdata->left_mar > markdata->right_mar) {
#line 867
        markdata->right_mar = markdata->left_mar;
      }
    }
#line 869
    if (markdata->second) {
      {
#line 871
      markdata->cx = markdata->x1;
#line 871
      markdata->cy = markdata->y1;
#line 872
      revto(cx, cy);
      }
    }
#line 874
    if (od == 118) {
      _L: /* CIL Label */ 
#line 875
      if (markdata->left_mar != 8) {
#line 875
        tmp___979 = (char *)":set nonu";
      } else {
#line 875
        tmp___979 = (char *)":set nu";
      }
      {
#line 875
      LMsg(0, (char const   *)tmp___979);
      }
    } else
#line 874
    if (od == 86) {
#line 874
      goto _L;
    }
#line 876
    goto switch_break;
    case_74: /* CIL Label */ 
#line 879
    markdata->nonl = (markdata->nonl + 1) % 4;
    {
#line 882
    if (markdata->nonl == 0) {
#line 882
      goto case_0;
    }
#line 888
    if (markdata->nonl == 1) {
#line 888
      goto case_1___0;
    }
#line 891
    if (markdata->nonl == 2) {
#line 891
      goto case_2___0;
    }
#line 894
    if (markdata->nonl == 3) {
#line 894
      goto case_3;
    }
#line 880
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 883
    if (join_with_cr) {
      {
#line 884
      LMsg(0, (char const   *)((char *)"Multiple lines (CR/LF)"));
      }
    } else {
      {
#line 886
      LMsg(0, (char const   *)((char *)"Multiple lines (LF)"));
      }
    }
#line 887
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 889
    LMsg(0, (char const   *)((char *)"Lines joined"));
    }
#line 890
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 892
    LMsg(0, (char const   *)((char *)"Lines joined with blanks"));
    }
#line 893
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 895
    LMsg(0, (char const   *)((char *)"Lines joined with comma"));
    }
#line 896
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 898
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 900
    Search(1);
    }
#line 901
    in_mark = 0;
#line 902
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 904
    Search(- 1);
    }
#line 905
    in_mark = 0;
#line 906
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 908
    Search(0);
    }
#line 909
    goto switch_break;
    case_78: /* CIL Label */ 
#line 911
    markdata->isdir = - markdata->isdir;
    {
#line 912
    Search(0);
#line 913
    markdata->isdir = - markdata->isdir;
    }
#line 914
    goto switch_break;
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 917
    if (markdata->second == 0) {
      {
#line 919
      __cil_tmp36 = linestart(cy);
#line 919
      revto(__cil_tmp36, cy);
#line 920
      (markdata->second) ++;
#line 921
      markdata->x1 = markdata->cx;
#line 921
      cx = markdata->x1;
#line 922
      markdata->y1 = markdata->cy;
#line 922
      cy = markdata->y1;
      }
    }
#line 924
    rep_cnt --;
#line 924
    if (rep_cnt > 0) {
      {
#line 925
      revto(cx, cy + rep_cnt);
      }
    }
    {
#line 926
    __cil_tmp38 = lineend(markdata->cy);
#line 926
    revto(__cil_tmp38, markdata->cy);
    }
#line 927
    if (od == 121) {
#line 928
      goto switch_break;
    }
    case_87: /* CIL Label */ 
#line 931
    if (od == 87) {
#line 933
      if (rep_cnt == 0) {
#line 934
        rep_cnt = 1;
      }
#line 935
      if (! markdata->second) {
        {
#line 937
        nextword(& cx, & cy, 1 | (1 << 1), 1);
#line 938
        revto(cx, cy);
#line 939
        (markdata->second) ++;
#line 940
        markdata->x1 = markdata->cx;
#line 940
        cx = markdata->x1;
#line 941
        markdata->y1 = markdata->cy;
#line 941
        cy = markdata->y1;
        }
      }
      {
#line 943
      nextword(& cx, & cy, 1 << 1, rep_cnt);
#line 944
      revto(cx, cy);
      }
    }
#line 946
    cx = markdata->cx;
#line 947
    cy = markdata->cy;
    case_65: /* CIL Label */ 
#line 950
    if (od == 65) {
#line 951
      markdata->append_mode = 1;
    }
    case_62: /* CIL Label */ 
#line 954
    if (od == 62) {
#line 955
      markdata->write_buffer = 1;
    }
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 959
    if (! markdata->second) {
      {
#line 961
      (markdata->second) ++;
#line 962
      markdata->x1 = cx;
#line 963
      markdata->y1 = cy;
#line 964
      revto(cx, cy);
#line 965
      LMsg(0, (char const   *)((char *)"First mark set - Column %d Line %d"), cx + 1,
           (cy - markdata->hist_offset) + 1);
      }
#line 966
      goto switch_break;
    } else {
      {
#line 970
      append_mode = markdata->append_mode;
#line 971
      write_buffer = markdata->write_buffer;
#line 973
      x2 = cx;
#line 974
      y2 = cy;
#line 975
      newcopylen = rem(markdata->x1, markdata->y1, x2, y2, 2, (char *)0, 0);
      }
#line 976
      if (md_user->u_plop.buf) {
#line 976
        if (! append_mode) {
          {
#line 977
          UserFreeCopyBuffer(md_user);
          }
        }
      }
#line 978
      yend = fore->w_layer.l_height - 1;
#line 979
      if (fore->w_histheight - markdata->hist_offset < fore->w_layer.l_height) {
        {
#line 981
        markdata->second = 0;
#line 982
        __cil_tmp44 = MarkScrollUpDisplay(fore->w_histheight - markdata->hist_offset);
        }
#line 982
        yend -= __cil_tmp44;
      }
#line 984
      if (newcopylen > 0) {
#line 987
        if (md_user->u_plop.buf) {
          {
#line 988
          __cil_tmp45 = realloc((void *)md_user->u_plop.buf, (unsigned long )((unsigned int )((md_user->u_plop.len + newcopylen) + 3)));
#line 988
          md_user->u_plop.buf = (char *)__cil_tmp45;
          }
        } else {
          {
#line 992
          md_user->u_plop.len = 0;
#line 993
          __cil_tmp46 = malloc((unsigned long )((unsigned int )(newcopylen + 3)));
#line 993
          md_user->u_plop.buf = (char *)__cil_tmp46;
          }
        }
#line 995
        if (! md_user->u_plop.buf) {
          {
#line 997
          MarkAbort();
#line 998
          in_mark = 0;
#line 999
          LMsg(0, (char const   *)((char *)"Not enough memory... Sorry."));
#line 1000
          md_user->u_plop.len = 0;
#line 1001
          md_user->u_plop.buf = (char *)0;
          }
#line 1002
          goto switch_break;
        }
#line 1004
        if (append_mode) {
          {
#line 1011
          if (markdata->nonl == 0) {
#line 1011
            goto case_0___0;
          }
#line 1020
          if (markdata->nonl == 1) {
#line 1020
            goto case_1___1;
          }
#line 1022
          if (markdata->nonl == 2) {
#line 1022
            goto case_2___1;
          }
#line 1026
          if (markdata->nonl == 3) {
#line 1026
            goto case_3___0;
          }
#line 1006
          goto switch_break___1;
          case_0___0: /* CIL Label */ 
#line 1012
          if (join_with_cr) {
#line 1014
            *(md_user->u_plop.buf + md_user->u_plop.len) = (char )'\r';
#line 1015
            (md_user->u_plop.len) ++;
          }
#line 1017
          *(md_user->u_plop.buf + md_user->u_plop.len) = (char )'\n';
#line 1018
          (md_user->u_plop.len) ++;
#line 1019
          goto switch_break___1;
          case_1___1: /* CIL Label */ 
#line 1021
          goto switch_break___1;
          case_2___1: /* CIL Label */ 
#line 1023
          *(md_user->u_plop.buf + md_user->u_plop.len) = (char )' ';
#line 1024
          (md_user->u_plop.len) ++;
#line 1025
          goto switch_break___1;
          case_3___0: /* CIL Label */ 
#line 1027
          *(md_user->u_plop.buf + md_user->u_plop.len) = (char )',';
#line 1028
          (md_user->u_plop.len) ++;
#line 1029
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
        }
        {
#line 1032
        __cil_tmp51 = rem(markdata->x1, markdata->y1, x2, y2, markdata->hist_offset == fore->w_histheight,
                          md_user->u_plop.buf + md_user->u_plop.len, yend);
        }
#line 1032
        md_user->u_plop.len += __cil_tmp51;
#line 1036
        md_user->u_plop.enc = fore->w_layer.l_encoding;
      }
#line 1039
      if (markdata->hist_offset != fore->w_histheight) {
        {
#line 1041
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1041
          oldlay = flayer;
          {
#line 1041
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1041
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1041
          flayer = flayer->l_next;
#line 1041
          oldcvlist = flayer->l_cvlist;
          {
#line 1041
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1041
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1041
          flayer->l_cvlist = oldlay->l_cvlist;
#line 1041
          cv = flayer->l_cvlist;
          {
#line 1041
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1041
            if (! cv) {
#line 1041
              goto while_break___6;
            }
#line 1041
            cv->c_layer = flayer;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 1041
          cv = cv->c_lnext;
#line 1041
          LRefreshAll(flayer, 0);
#line 1041
          flayer = oldlay;
#line 1041
          cv = flayer->l_cvlist;
          }
          {
#line 1041
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 1041
            if (! cv) {
#line 1041
              goto while_break___7;
            }
#line 1041
            cv->c_layer = flayer;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1041
          cv = cv->c_lnext;
#line 1041
          (flayer->l_next)->l_cvlist = oldcvlist;
#line 1041
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 1043
      ExitOverlayPage();
#line 1044
      WindowChanged(fore, 'P');
      }
#line 1045
      if (append_mode) {
        {
#line 1046
        LMsg(0, (char const   *)((char *)"Appended %d characters to buffer"), newcopylen);
        }
      } else {
        {
#line 1049
        LMsg(0, (char const   *)((char *)"Copied %d characters into buffer"), md_user->u_plop.len);
        }
      }
#line 1050
      if (write_buffer) {
        {
#line 1051
        WriteFile(md_user, (char *)0, 2);
        }
      }
#line 1052
      in_mark = 0;
#line 1053
      goto switch_break;
    }
    case_146: /* CIL Label */ 
#line 1057
    if (flayer->l_mouseevent.start) {
#line 1059
      button = (int )flayer->l_mouseevent.buffer[0];
#line 1060
      if (button == 97) {
#line 1063
        od = 'j';
      } else
#line 1065
      if (button == 96) {
#line 1068
        od = 'k';
      } else
#line 1070
      if (button == 32) {
        {
#line 1073
        cx = (int )flayer->l_mouseevent.buffer[1];
#line 1074
        cy = (int )flayer->l_mouseevent.buffer[2] + markdata->hist_offset;
#line 1075
        revto(cx, cy);
#line 1076
        od = ' ';
        }
      } else {
#line 1079
        od = 0;
      }
      {
#line 1080
      LayProcessMouseSwitch(flayer, 0);
      }
#line 1081
      if (od) {
#line 1082
        goto processchar;
      }
    } else {
      {
#line 1085
      LayProcessMouseSwitch(flayer, 1);
      }
    }
#line 1086
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1089
    MarkAbort();
    }
    {
#line 1090
    LMsg(0, (char const   *)((char *)"Copy mode aborted"));
#line 1091
    in_mark = 0;
    }
#line 1092
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1094
    if (in_mark) {
#line 1095
      markdata->rep_cnt = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1097
  if (in_mark) {
#line 1099
    flayer->l_x = markdata->cx;
#line 1100
    flayer->l_y = markdata->cy - markdata->hist_offset;
  }
#line 1102
  *inbufp = pt;
#line 1103
  *inlenp = inlen;
  return;
}
}
#line 1106 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
void revto(int tx , int ty ) 
{ 


  {
  {
#line 1109
  revto_line(tx, ty, - 1);
  }
  return;
}
}
#line 1113 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
void revto_line(int tx , int ty , int line ) 
{ 
  int fx ;
  int fy ;
  int x ;
  int y ;
  int t ;
  int revst ;
  int reven ;
  int qq ;
  int ff ;
  int tt ;
  int st ;
  int en ;
  int ce ;
  int ystart ;
  int yend ;
  int i ;
  int ry ;
  unsigned char *wi ;
  struct mline *ml ;
  struct mchar mc ;
  struct mline *tmp ;
  int tmp___980 ;
  int tmp___981 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp33 ;
  struct mline *tmp___982 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  struct mline *tmp___983 ;
  int __cil_tmp38 ;
  unsigned char *__cil_tmp39 ;
  int tmp___985 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int tmp___987 ;
  int tmp___988 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;

  {
#line 1117
  ce = 0;
#line 1118
  ystart = 0;
#line 1118
  yend = fore->w_layer.l_height - 1;
#line 1124
  if (tx < 0) {
#line 1125
    tx = 0;
  } else
#line 1126
  if (tx > fore->w_layer.l_width - 1) {
#line 1127
    tx = fore->w_layer.l_width - 1;
  }
#line 1128
  if (ty < fore->w_histheight - fore->w_scrollback_height) {
#line 1129
    ty = fore->w_histheight - fore->w_scrollback_height;
  } else
#line 1130
  if (ty > (fore->w_histheight + fore->w_layer.l_height) - 1) {
#line 1131
    ty = (fore->w_histheight + fore->w_layer.l_height) - 1;
  }
#line 1133
  fx = markdata->cx;
#line 1133
  fy = markdata->cy;
#line 1137
  if (ty < fore->w_histheight) {
#line 1137
    tmp = & *(fore->w_hlines + (fore->w_histidx + ty) % fore->w_histheight);
  } else {
#line 1137
    tmp = & *(fore->w_mlines + (ty - fore->w_histheight));
  }
#line 1137
  ml = tmp;
#line 1138
  if (fore->w_layer.l_encoding == 8) {
#line 1138
    tmp___980 = (int )*(ml->font + tx) == 255 && (int )*(ml->image + tx) == 255;
  } else {
#line 1138
    tmp___980 = ((int )*(ml->font + tx) & 224) == 128;
  }
#line 1138
  if (ty == fy) {
#line 1138
    if (fx + 1 == tx) {
#line 1138
      if (tmp___980) {
#line 1138
        if (tx < display->d_width - 1) {
#line 1139
          tx ++;
        }
      }
    }
  }
#line 1140
  if (fore->w_layer.l_encoding == 8) {
#line 1140
    tmp___981 = (int )*(ml->font + fx) == 255 && (int )*(ml->image + fx) == 255;
  } else {
#line 1140
    tmp___981 = ((int )*(ml->font + fx) & 224) == 128;
  }
#line 1140
  if (ty == fy) {
#line 1140
    if (fx - 1 == tx) {
#line 1140
      if (tmp___981) {
#line 1140
        if (tx) {
#line 1141
          __cil_tmp28 = tx;
#line 1141
          tx --;
        }
      }
    }
  }
#line 1144
  markdata->cx = tx;
#line 1144
  markdata->cy = ty;
#line 1150
  i = 0;
#line 1151
  if (line >= 0) {
#line 1151
    if (line < fore->w_layer.l_height) {
#line 1152
      i = (ty - markdata->hist_offset) - line;
    } else {
#line 1151
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1153
  if (ty < markdata->hist_offset) {
#line 1154
    i = ty - markdata->hist_offset;
  } else
#line 1155
  if (ty > markdata->hist_offset + (fore->w_layer.l_height - 1)) {
#line 1156
    i = (ty - markdata->hist_offset) - (fore->w_layer.l_height - 1);
  }
#line 1157
  if (i > 0) {
    {
#line 1158
    __cil_tmp29 = MarkScrollUpDisplay(i);
    }
#line 1158
    yend -= __cil_tmp29;
  } else
#line 1159
  if (i < 0) {
    {
#line 1160
    __cil_tmp30 = MarkScrollDownDisplay(- i);
    }
#line 1160
    ystart += __cil_tmp30;
  }
#line 1162
  if (markdata->second == 0) {
    {
#line 1164
    flayer->l_x = tx;
#line 1165
    flayer->l_y = ty - markdata->hist_offset;
#line 1166
    LGotoPos(flayer, tx, ty - markdata->hist_offset);
    }
#line 1167
    return;
  }
#line 1170
  qq = markdata->x1 + markdata->y1 * fore->w_layer.l_width;
#line 1171
  ff = fx + fy * fore->w_layer.l_width;
#line 1172
  tt = tx + ty * fore->w_layer.l_width;
#line 1174
  if (ff > tt) {
#line 1176
    st = tt;
#line 1176
    en = ff;
#line 1177
    x = tx;
#line 1177
    y = ty;
  } else {
#line 1181
    st = ff;
#line 1181
    en = tt;
#line 1182
    x = fx;
#line 1182
    y = fy;
  }
#line 1184
  if (st > qq) {
#line 1186
    st ++;
#line 1187
    x ++;
  }
#line 1189
  if (en < qq) {
#line 1190
    __cil_tmp33 = en;
#line 1190
    en --;
  }
#line 1191
  if (tt > qq) {
#line 1193
    revst = qq;
#line 1193
    reven = tt;
  } else {
#line 1197
    revst = tt;
#line 1197
    reven = qq;
  }
#line 1199
  ry = y - markdata->hist_offset;
#line 1200
  if (ry < ystart) {
#line 1202
    y += ystart - ry;
#line 1203
    x = 0;
#line 1204
    st = y * fore->w_layer.l_width;
#line 1205
    ry = ystart;
  }
#line 1207
  if (y < fore->w_histheight) {
#line 1207
    tmp___982 = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
  } else {
#line 1207
    tmp___982 = & *(fore->w_mlines + (y - fore->w_histheight));
  }
#line 1207
  ml = tmp___982;
#line 1208
  t = st;
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1208
    if (! (t <= en)) {
#line 1208
      goto while_break;
    }
#line 1210
    if (x >= fore->w_layer.l_width) {
#line 1212
      x = 0;
#line 1213
      __cil_tmp36 = ry;
#line 1213
      ry ++;
#line 1213
      __cil_tmp35 = y;
#line 1213
      y ++;
#line 1214
      if (y < fore->w_histheight) {
#line 1214
        tmp___983 = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
      } else {
#line 1214
        tmp___983 = & *(fore->w_mlines + (y - fore->w_histheight));
      }
#line 1214
      ml = tmp___983;
    }
#line 1216
    if (ry > yend) {
#line 1217
      goto while_break;
    }
#line 1218
    if (t == st) {
      _L___984: /* CIL Label */ 
#line 1220
      wi = ml->image + fore->w_layer.l_width;
#line 1221
      ce = fore->w_layer.l_width;
      {
#line 1221
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1221
        if (! (ce >= 0)) {
#line 1221
          goto while_break___0;
        }
#line 1222
        if ((int )*wi != 32) {
#line 1223
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1221
      __cil_tmp39 = wi;
#line 1221
      wi --;
#line 1221
      __cil_tmp38 = ce;
#line 1221
      ce --;
    } else
#line 1218
    if (x == 0) {
#line 1218
      goto _L___984;
    }
#line 1225
    if (x <= ce) {
#line 1225
      if (x >= markdata->left_mar) {
#line 1225
        if (x <= markdata->right_mar) {
#line 1228
          if (fore->w_layer.l_encoding == 8) {
#line 1228
            tmp___985 = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
          } else {
#line 1228
            tmp___985 = ((int )*(ml->font + x) & 224) == 128;
          }
#line 1228
          if (tmp___985) {
#line 1230
            if (t == revst) {
#line 1231
              __cil_tmp41 = revst;
#line 1231
              revst --;
            }
#line 1232
            __cil_tmp42 = t;
#line 1232
            t --;
#line 1233
            __cil_tmp43 = x;
#line 1233
            x --;
          }
#line 1236
          if (t >= revst) {
#line 1236
            if (t <= reven) {
#line 1238
              mc = mchar_so;
#line 1240
              if (pastefont) {
#line 1242
                mc.font = *(ml->font + x);
#line 1243
                mc.fontx = *(ml->fontx + x);
              }
#line 1246
              mc.image = *(ml->image + x);
            } else {
#line 1236
              goto _L___986;
            }
          } else {
            _L___986: /* CIL Label */ 
            {
#line 1249
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1249
              mc.image = *(ml->image + x);
#line 1249
              mc.attr = *(ml->attr + x);
#line 1249
              mc.font = *(ml->font + x);
#line 1249
              mc.fontx = *(ml->fontx + x);
#line 1249
              mc.color = *(ml->color + x);
#line 1249
              mc.mbcs = (unsigned char )0;
#line 1249
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 1251
          if (fore->w_layer.l_encoding == 8) {
#line 1251
            tmp___987 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
          } else {
#line 1251
            tmp___987 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
          }
#line 1251
          if (tmp___987) {
            {
#line 1253
            mc.mbcs = *(ml->image + (x + 1));
#line 1254
            LPutChar(flayer, & mc, x, y - markdata->hist_offset);
#line 1255
            t ++;
            }
          }
          {
#line 1258
          LPutChar(flayer, & mc, x, y - markdata->hist_offset);
          }
#line 1260
          if (fore->w_layer.l_encoding == 8) {
#line 1260
            tmp___988 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
          } else {
#line 1260
            tmp___988 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
          }
#line 1260
          if (tmp___988) {
#line 1261
            x ++;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1208
  __cil_tmp49 = x;
#line 1208
  x ++;
  {
#line 1208
  __cil_tmp48 = t;
#line 1208
  t ++;
#line 1265
  flayer->l_x = tx;
#line 1266
  flayer->l_y = ty - markdata->hist_offset;
#line 1267
  LGotoPos(flayer, tx, ty - markdata->hist_offset);
  }
  return;
}
}
#line 1271 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static void MarkAbort(void) 
{ 
  int yend ;
  int redisp ;
  int __cil_tmp3 ;
  struct layer *oldlay ;
  struct canvas *oldcvlist ;
  struct canvas *cv ;

  {
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1276
  markdata = (struct markdata *)flayer->l_data;
#line 1277
  fore = markdata->md_window;
#line 1278
  yend = fore->w_layer.l_height - 1;
#line 1279
  redisp = markdata->second;
#line 1280
  if (fore->w_histheight - markdata->hist_offset < fore->w_layer.l_height) {
    {
#line 1282
    markdata->second = 0;
#line 1283
    __cil_tmp3 = MarkScrollUpDisplay(fore->w_histheight - markdata->hist_offset);
    }
#line 1283
    yend -= __cil_tmp3;
  }
#line 1285
  if (markdata->hist_offset != fore->w_histheight) {
    {
#line 1287
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1287
      oldlay = flayer;
      {
#line 1287
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1287
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1287
      flayer = flayer->l_next;
#line 1287
      oldcvlist = flayer->l_cvlist;
      {
#line 1287
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1287
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1287
      flayer->l_cvlist = oldlay->l_cvlist;
#line 1287
      cv = flayer->l_cvlist;
      {
#line 1287
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1287
        if (! cv) {
#line 1287
          goto while_break___3;
        }
#line 1287
        cv->c_layer = flayer;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1287
      cv = cv->c_lnext;
#line 1287
      LRefreshAll(flayer, 0);
#line 1287
      flayer = oldlay;
#line 1287
      cv = flayer->l_cvlist;
      }
      {
#line 1287
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1287
        if (! cv) {
#line 1287
          goto while_break___4;
        }
#line 1287
        cv->c_layer = flayer;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1287
      cv = cv->c_lnext;
#line 1287
      (flayer->l_next)->l_cvlist = oldcvlist;
#line 1287
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1291
    rem(markdata->x1, markdata->y1, markdata->cx, markdata->cy, redisp, (char *)0,
        yend);
    }
  }
  {
#line 1293
  ExitOverlayPage();
#line 1294
  WindowChanged(fore, 'P');
  }
  return;
}
}
#line 1299 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static void MarkRedisplayLine(int y , int xs , int xe , int isblank ) 
{ 
  int wy ;
  int x ;
  int i ;
  int rm ;
  int sta ;
  int sto ;
  int cp ;
  unsigned char *wi ;
  struct mline *ml ;
  struct mchar mchar_marked ;
  struct mline *tmp ;
  int tmp___989 ;
  int __cil_tmp17 ;
  int tmp___990 ;
  struct mline *tmp___991 ;
  int __cil_tmp21 ;
  unsigned char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int tmp___992 ;
  int __cil_tmp26 ;
  int tmp___993 ;
  int tmp___994 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 1310
  if (y < 0) {
#line 1311
    return;
  }
#line 1313
  markdata = (struct markdata *)flayer->l_data;
#line 1314
  fore = markdata->md_window;
#line 1316
  mchar_marked = mchar_so;
#line 1318
  wy = y + markdata->hist_offset;
#line 1319
  if (wy < fore->w_histheight) {
#line 1319
    tmp = & *(fore->w_hlines + (fore->w_histidx + wy) % fore->w_histheight);
  } else {
#line 1319
    tmp = & *(fore->w_mlines + (wy - fore->w_histheight));
  }
#line 1319
  ml = tmp;
#line 1321
  if (markdata->second == 0) {
#line 1323
    if (fore->w_layer.l_encoding == 8) {
#line 1323
      tmp___989 = (int )*(ml->font + xs) == 255 && (int )*(ml->image + xs) == 255;
    } else {
#line 1323
      tmp___989 = ((int )*(ml->font + xs) & 224) == 128;
    }
#line 1323
    if (tmp___989) {
#line 1323
      if (xs > 0) {
#line 1324
        __cil_tmp17 = xs;
#line 1324
        xs --;
      }
    }
#line 1325
    if (fore->w_layer.l_encoding == 8) {
#line 1325
      tmp___990 = (int )*(ml->font + (xe + 1)) == 255 && (int )*(ml->image + (xe + 1)) == 255;
    } else {
#line 1325
      tmp___990 = ((int )*(ml->font + xe) & 31) != 0 && ((int )*(ml->font + xe) & 224) == 0;
    }
#line 1325
    if (tmp___990) {
#line 1325
      if (xe < fore->w_layer.l_width - 1) {
#line 1326
        xe ++;
      }
    }
#line 1327
    if (xs == 0) {
#line 1327
      if (y > 0) {
#line 1327
        if (wy > 0) {
#line 1327
          if ((int )*(tmp___991->image + flayer->l_width) == 0) {
            {
#line 1328
            LCDisplayLineWrap(flayer, ml, y, xs, xe, isblank);
            }
          } else {
            {
            {
            {
            {
#line 1330
            LCDisplayLine(flayer, ml, y, xs, xe, isblank);
            }
            }
            }
            }
          }
        } else {
          {
          {
          {
          {
#line 1330
          LCDisplayLine(flayer, ml, y, xs, xe, isblank);
          }
          }
          }
          }
        }
      } else {
        {
        {
        {
        {
#line 1330
        LCDisplayLine(flayer, ml, y, xs, xe, isblank);
        }
        }
        }
        }
      }
    } else {
      {
      {
      {
      {
#line 1330
      LCDisplayLine(flayer, ml, y, xs, xe, isblank);
      }
      }
      }
      }
    }
#line 1331
    return;
  }
#line 1334
  sta = markdata->y1 * fore->w_layer.l_width + markdata->x1;
#line 1335
  sto = markdata->cy * fore->w_layer.l_width + markdata->cx;
#line 1336
  if (sta > sto) {
#line 1338
    i = sta;
#line 1338
    sta = sto;
#line 1338
    sto = i;
  }
#line 1340
  cp = wy * fore->w_layer.l_width + xs;
#line 1342
  rm = markdata->right_mar;
#line 1343
  wi = ml->image + fore->w_layer.l_width;
#line 1343
  x = fore->w_layer.l_width;
  {
#line 1343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1343
    if (! (x >= 0)) {
#line 1343
      goto while_break;
    }
#line 1344
    if ((int )*wi != 32) {
#line 1345
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1343
  __cil_tmp22 = wi;
#line 1343
  wi --;
#line 1343
  __cil_tmp21 = x;
#line 1343
  x --;
#line 1346
  if (x < rm) {
#line 1347
    rm = x;
  }
#line 1349
  x = xs;
  {
#line 1349
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1349
    if (! (x <= xe)) {
#line 1349
      goto while_break___0;
    }
#line 1350
    if (cp >= sta) {
#line 1350
      if (x >= markdata->left_mar) {
#line 1351
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1349
  __cil_tmp24 = cp;
#line 1349
  cp ++;
#line 1349
  __cil_tmp23 = x;
#line 1349
  x ++;
#line 1353
  if (fore->w_layer.l_encoding == 8) {
#line 1353
    tmp___992 = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
  } else {
#line 1353
    tmp___992 = ((int )*(ml->font + x) & 224) == 128;
  }
#line 1353
  if (tmp___992) {
#line 1354
    __cil_tmp26 = x;
#line 1354
    x --;
  }
#line 1356
  if (x > xs) {
    {
#line 1357
    LCDisplayLine(flayer, ml, y, xs, x - 1, isblank);
    }
  }
  {
#line 1358
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1358
    if (! (x <= xe)) {
#line 1358
      goto while_break___1;
    }
#line 1360
    if (cp > sto) {
#line 1361
      goto while_break___1;
    } else
#line 1360
    if (x > rm) {
#line 1361
      goto while_break___1;
    }
#line 1363
    if (pastefont) {
#line 1365
      mchar_marked.font = *(ml->font + x);
#line 1366
      mchar_marked.fontx = *(ml->fontx + x);
    }
#line 1369
    mchar_marked.image = *(ml->image + x);
#line 1371
    mchar_marked.mbcs = (unsigned char )0;
#line 1372
    if (fore->w_layer.l_encoding == 8) {
#line 1372
      tmp___993 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
    } else {
#line 1372
      tmp___993 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
    }
#line 1372
    if (tmp___993) {
#line 1374
      mchar_marked.mbcs = *(ml->image + (x + 1));
#line 1375
      cp ++;
    }
    {
#line 1378
    LPutChar(flayer, & mchar_marked, x, y);
    }
#line 1380
    if (fore->w_layer.l_encoding == 8) {
#line 1380
      tmp___994 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
    } else {
#line 1380
      tmp___994 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
    }
#line 1380
    if (tmp___994) {
#line 1381
      x ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1358
  __cil_tmp32 = cp;
#line 1358
  cp ++;
#line 1358
  __cil_tmp31 = x;
#line 1358
  x ++;
#line 1384
  if (x <= xe) {
    {
#line 1385
    LCDisplayLine(flayer, ml, y, x, xe, isblank);
    }
  }
  return;
}
}
#line 1393 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static int MarkRewrite(int ry , int xs , int xe , struct mchar *rend , int doit ) 
{ 
  int dx ;
  int x ;
  int y ;
  int st ;
  int en ;
  int t ;
  int rm ;
  unsigned char *i ;
  struct mline *ml ;
  struct mchar mchar_marked ;
  struct mline *tmp ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned char *__cil_tmp19 ;
  unsigned char *__cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;

  {
#line 1402
  mchar_marked = mchar_so;
  {
#line 1404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1404
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1405
  markdata = (struct markdata *)flayer->l_data;
#line 1406
  fore = markdata->md_window;
#line 1407
  y = ry + markdata->hist_offset;
#line 1408
  if (y < fore->w_histheight) {
#line 1408
    tmp = & *(fore->w_hlines + (fore->w_histidx + y) % fore->w_histheight);
  } else {
#line 1408
    tmp = & *(fore->w_mlines + (y - fore->w_histheight));
  }
  {
#line 1408
  ml = tmp;
#line 1410
  __cil_tmp17 = ContainsSpecialDeffont(ml, xs, xe, fore->w_layer.l_encoding);
  }
#line 1410
  if (fore->w_layer.l_encoding) {
#line 1410
    if (fore->w_layer.l_encoding != 8) {
#line 1410
      if (display->d_encoding == 8) {
#line 1410
        if (__cil_tmp17) {
#line 1411
          return (1000);
        }
      }
    }
  }
#line 1413
  dx = (xe - xs) + 1;
#line 1414
  if (doit) {
#line 1416
    i = ml->image + xs;
    {
#line 1417
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1417
      if (! __cil_tmp18) {
#line 1417
        goto while_break___0;
      }
      {
#line 1418
      __cil_tmp19 = i;
#line 1418
      i ++;
#line 1418
      PUTCHAR((int )*__cil_tmp19);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1419
    return (0);
  }
#line 1422
  if (markdata->second == 0) {
#line 1423
    en = - 1;
#line 1423
    st = en;
  } else {
#line 1426
    st = markdata->y1 * fore->w_layer.l_width + markdata->x1;
#line 1427
    en = markdata->cy * fore->w_layer.l_width + markdata->cx;
#line 1428
    if (st > en) {
#line 1430
      t = st;
#line 1430
      st = en;
#line 1430
      en = t;
    }
  }
#line 1433
  t = y * fore->w_layer.l_width + xs;
#line 1434
  i = ml->image + fore->w_layer.l_width;
#line 1434
  rm = fore->w_layer.l_width;
  {
#line 1434
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1434
    if (! (rm >= 0)) {
#line 1434
      goto while_break___1;
    }
#line 1435
    __cil_tmp20 = i;
#line 1435
    i --;
#line 1435
    if ((int )*__cil_tmp20 != 32) {
#line 1436
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1434
  __cil_tmp21 = rm;
#line 1434
  rm --;
#line 1437
  if (rm > markdata->right_mar) {
#line 1438
    rm = markdata->right_mar;
  }
#line 1439
  x = xs;
  {
#line 1440
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1440
    if (! __cil_tmp22) {
#line 1440
      goto while_break___2;
    }
#line 1442
    if (t >= st) {
#line 1442
      if (t <= en) {
#line 1442
        if (x >= markdata->left_mar) {
#line 1442
          if (x <= rm) {
#line 1445
            if (pastefont) {
#line 1447
              mchar_marked.font = *(ml->font + x);
#line 1448
              mchar_marked.fontx = *(ml->fontx + x);
            }
#line 1451
            rend->image = mchar_marked.image;
#line 1452
            if (! (((((int )rend->image == (int )mchar_marked.image && (int )rend->attr == (int )mchar_marked.attr) && (int )rend->font == (int )mchar_marked.font) && (int )rend->fontx == (int )mchar_marked.fontx) && (int )rend->color == (int )mchar_marked.color)) {
#line 1453
              return (1000);
            }
          } else {
#line 1442
            goto _L;
          }
        } else {
#line 1442
          goto _L;
        }
      } else {
#line 1442
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1457
      rend->image = *(ml->image + x);
#line 1458
      if (! (((((int )rend->image == (int )*(ml->image + x) && (int )rend->attr == (int )*(ml->attr + x)) && (int )rend->font == (int )*(ml->font + x)) && (int )rend->fontx == (int )*(ml->fontx + x)) && (int )rend->color == (int )*(ml->color + x))) {
#line 1459
        return (1000);
      }
    }
#line 1461
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1463
  return ((xe - xs) + 1);
}
}
#line 1470 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static int MarkScrollUpDisplay(int n ) 
{ 
  int i ;
  int tmp ;
  int __cil_tmp4 ;

  {
  {
#line 1475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1475
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1476
  if (n <= 0) {
#line 1477
    return (0);
  }
#line 1478
  if (n > fore->w_histheight - markdata->hist_offset) {
#line 1479
    n = fore->w_histheight - markdata->hist_offset;
  }
#line 1480
  markdata->hist_offset += n;
#line 1481
  if (n < flayer->l_height) {
#line 1481
    tmp = n;
  } else {
#line 1481
    tmp = flayer->l_height;
  }
  {
#line 1481
  i = tmp;
#line 1482
  LScrollV(flayer, i, 0, flayer->l_height - 1, 0);
  }
  {
#line 1483
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1483
    if (! (__cil_tmp4 > 0)) {
#line 1483
      goto while_break___0;
    }
    {
#line 1484
    MarkRedisplayLine((flayer->l_height - i) - 1, 0, flayer->l_width - 1, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1485
  return (n);
}
}
#line 1489 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
static int MarkScrollDownDisplay(int n ) 
{ 
  int i ;
  int tmp ;
  int __cil_tmp4 ;

  {
  {
#line 1494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1494
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1495
  if (n <= 0) {
#line 1496
    return (0);
  }
#line 1497
  if (n > markdata->hist_offset) {
#line 1498
    n = markdata->hist_offset;
  }
#line 1499
  markdata->hist_offset -= n;
#line 1500
  if (n < flayer->l_height) {
#line 1500
    tmp = n;
  } else {
#line 1500
    tmp = flayer->l_height;
  }
  {
#line 1500
  i = tmp;
#line 1501
  LScrollV(flayer, - i, 0, fore->w_layer.l_height - 1, 0);
  }
  {
#line 1502
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1502
    if (! (__cil_tmp4 > 0)) {
#line 1502
      goto while_break___0;
    }
    {
#line 1503
    MarkRedisplayLine(i, 0, flayer->l_width - 1, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1504
  return (n);
}
}
#line 1508 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
void MakePaster(struct paster *pa , char *buf , int len , int bufiscopy ) 
{ 


  {
  {
#line 1514
  FreePaster(pa);
#line 1515
  pa->pa_pasteptr = buf;
#line 1516
  pa->pa_pastelen = len;
  }
#line 1517
  if (bufiscopy) {
#line 1518
    pa->pa_pastebuf = buf;
  }
  {
#line 1519
  pa->pa_pastelayer = flayer;
#line 1520
  DoProcess((struct win *)(flayer->l_bottom)->l_data, & pa->pa_pasteptr, & pa->pa_pastelen,
            pa);
  }
  return;
}
}
#line 1524 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/mark.c"
void FreePaster(struct paster *pa ) 
{ 


  {
#line 1527
  if (pa->pa_pastebuf) {
    {
#line 1528
    free((void *)pa->pa_pastebuf);
    }
  }
  {
#line 1529
  pa->pa_pastebuf = (char *)0;
#line 1530
  pa->pa_pasteptr = (char *)0;
#line 1531
  pa->pa_pastelen = 0;
#line 1532
  pa->pa_pastelayer = (struct layer *)0;
#line 1533
  evdeq(& pa->pa_slowev);
  }
  return;
}
}
#line 232 "/usr/include/stdio.h"
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 581
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 1017
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 78 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void WMsg(struct win *p , int err , char *str ) ;
#line 85
void FinishRc(char *rcfilename ) ;
#line 92
int printpipe(struct win *p , char *cmd ) ;
#line 93
int readpipe(char **cmdv ) ;
#line 57 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
static char *CatExtra(char *str1 , char *str2 ) ;
#line 58
static char *findrcfile(char *rcfile ) ;
#line 61 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
char *rc_name  =    (char *)"";
#line 62 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
int rc_recursion  =    0;
#line 64 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
static char *CatExtra(char *str1 , char *str2 ) 
{ 
  register char *cp ;
  register int len1 ;
  register int len2 ;
  register int add_colon ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 68
  __cil_tmp7 = strlen((char const   *)str1);
#line 68
  len1 = (int )__cil_tmp7;
  }
#line 69
  if (len1 == 0) {
#line 70
    return (str2);
  }
#line 71
  add_colon = (int )*(str1 + (len1 - 1)) != 58;
#line 72
  if (str2) {
    {
#line 73
    __cil_tmp8 = strlen((char const   *)str2);
#line 73
    len2 = (int )__cil_tmp8;
#line 74
    __cil_tmp9 = realloc((void *)str2, (unsigned long )((((unsigned int )len1 + (unsigned int )len2) + (unsigned int )add_colon) + 1U));
#line 74
    cp = (char *)__cil_tmp9;
    }
#line 74
    if (cp == (char *)((void *)0)) {
      {
#line 75
      Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
      }
    }
    {
#line 76
    bcopy((void const   *)cp, (void *)((cp + len1) + add_colon), (size_t )(len2 + 1));
    }
  } else {
    {
#line 79
    __cil_tmp10 = malloc((unsigned long )(((unsigned int )len1 + (unsigned int )add_colon) + 1U));
#line 79
    cp = (char *)__cil_tmp10;
    }
#line 79
    if (cp == (char *)((void *)0)) {
      {
#line 80
      Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
      }
    }
#line 81
    *(cp + (len1 + add_colon)) = (char )'\000';
  }
  {
#line 83
  bcopy((void const   *)str1, (void *)cp, (size_t )len1);
  }
#line 84
  if (add_colon) {
#line 85
    *(cp + len1) = (char )':';
  }
#line 86
  return (cp);
}
}
#line 89 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
static char *findrcfile(char *rcfile ) 
{ 
  char buf[256] ;
  char *p ;
  static char rcfilename_tilde_exp[4097] ;
  char *slash_position ;
  char *__cil_tmp6 ;
  char *home___997 ;
  char *__cil_tmp8 ;
  struct passwd *p___998 ;
  char *rcend ;
  char *__cil_tmp12 ;
  size_t __cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp18 ;
  size_t __cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 95
  if (rcfile) {
#line 95
    if ((int )*rcfile == 126) {
      {
#line 97
      __cil_tmp6 = strchr((char const   *)rcfile, '/');
#line 97
      slash_position = __cil_tmp6;
      }
#line 99
      if (slash_position == rcfile + 1) {
        {
#line 100
        __cil_tmp8 = getenv((char const   *)((char *)"HOME"));
#line 100
        home___997 = __cil_tmp8;
        }
#line 101
        if (! home___997) {
          {
#line 102
          Msg(0, (char const   *)((char *)"%s: source: tilde expansion failed"), rc_name);
          }
#line 103
          return ((char *)((void *)0));
        }
        {
#line 105
        snprintf((char *)rcfilename_tilde_exp, (unsigned long )4096, (char const   *)((char *)"%s/%s"),
                 home___997, rcfile + 2);
        }
      } else
#line 107
      if (slash_position) {
        {
#line 109
        *slash_position = (char )0;
#line 110
        p___998 = getpwnam((char const   *)(rcfile + 1));
        }
#line 111
        if (! p___998) {
          {
#line 112
          Msg(0, (char const   *)((char *)"%s: source: tilde expansion failed for user %s"),
              rc_name, rcfile + 1);
          }
#line 113
          return ((char *)((void *)0));
        }
        {
#line 115
        snprintf((char *)rcfilename_tilde_exp, (unsigned long )4096, (char const   *)((char *)"%s/%s"),
                 p___998->pw_dir, slash_position + 1);
        }
      } else {
        {
#line 118
        Msg(0, (char const   *)((char *)"%s: source: illegal tilde expression."),
            rc_name);
        }
#line 119
        return ((char *)((void *)0));
      }
#line 121
      rcfile = (char *)rcfilename_tilde_exp;
    }
  }
#line 124
  if (rcfile) {
    {
#line 125
    __cil_tmp12 = rindex((char const   *)rc_name, '/');
#line 125
    rcend = __cil_tmp12;
#line 126
    __cil_tmp13 = strlen((char const   *)rcfile);
    }
#line 126
    if ((int )*rcfile != 47) {
#line 126
      if (rcend) {
#line 126
        if (((unsigned long )(rcend - rc_name) + __cil_tmp13) + 2UL < sizeof(buf)) {
          {
#line 127
          strncpy((char *)buf, (char const   *)rc_name, (unsigned long )((rcend - rc_name) + 1L));
#line 128
          strcpy(((char *)buf + (rcend - rc_name)) + 1, (char const   *)rcfile);
#line 129
          __cil_tmp14 = access((char const   *)((char *)buf), 4);
          }
#line 129
          if (__cil_tmp14 == 0) {
            {
#line 130
            __cil_tmp15 = SaveStr((char const   *)((char *)buf));
            }
#line 130
            return (__cil_tmp15);
          }
        }
      }
    }
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 133
    __cil_tmp16 = SaveStr((char const   *)rcfile);
    }
#line 133
    return (__cil_tmp16);
  }
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 137
  p = getenv((char const   *)((char *)"SCREENRC"));
  }
#line 137
  if (p != (char *)((void *)0)) {
#line 137
    if ((int )*p != 0) {
      {
#line 138
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 138
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 139
      __cil_tmp18 = SaveStr((char const   *)p);
      }
#line 139
      return (__cil_tmp18);
    } else {
#line 137
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 142
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 142
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 143
    __cil_tmp19 = strlen((char const   *)home);
    }
#line 143
    if (__cil_tmp19 > sizeof(buf) - 12UL) {
      {
#line 144
      Panic(0, (char const   *)((char *)"Rc: home too large"));
      }
    }
    {
#line 145
    sprintf((char *)buf, (char const   *)((char *)"%s/.screenrc"), home);
#line 146
    __cil_tmp20 = SaveStr((char const   *)((char *)buf));
    }
#line 146
    return (__cil_tmp20);
  }
}
}
#line 155 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
int StartRc(char *rcfilename , int nopanic ) 
{ 
  register int argc ;
  register int len ;
  register char *p ;
  register char *cp ;
  char buf[2048] ;
  char *args[64] ;
  int argl[64] ;
  FILE *fp ;
  char *oldrc_name ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char const   *rc_nonnull ;
  char *tmp ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  char *__cil_tmp31 ;
  size_t __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp37 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;

  {
  {
#line 162
  oldrc_name = rc_name;
#line 165
  extra_incap = CatExtra((char *)"TF", extra_incap);
#line 168
  __cil_tmp14 = strncmp((char const   *)((char *)display->d_termname), (char const   *)((char *)"xterm"),
                        (unsigned long )5);
  }
  {
#line 168
  __cil_tmp13 = strncmp((char const   *)((char *)display->d_termname), (char const   *)((char *)"vt"),
                        (unsigned long )2);
  }
#line 168
  if (display) {
#line 168
    if (! __cil_tmp13) {
      {
      {
#line 169
      extra_incap = CatExtra((char *)"xn:f0=\033Op:f1=\033Oq:f2=\033Or:f3=\033Os:f4=\033Ot:f5=\033Ou:f6=\033Ov:f7=\033Ow:f8=\033Ox:f9=\033Oy:f.=\033On:f,=\033Ol:fe=\033OM:f+=\033Ok:f-=\033Om:f*=\033Oj:f/=\033Oo:fq=\033OX",
                             extra_incap);
      }
      }
    } else
#line 168
    if (! __cil_tmp14) {
      {
      {
#line 169
      extra_incap = CatExtra((char *)"xn:f0=\033Op:f1=\033Oq:f2=\033Or:f3=\033Os:f4=\033Ot:f5=\033Ou:f6=\033Ov:f7=\033Ow:f8=\033Ox:f9=\033Oy:f.=\033On:f,=\033Ol:fe=\033OM:f+=\033Ok:f-=\033Om:f*=\033Oj:f/=\033Oo:fq=\033OX",
                             extra_incap);
      }
      }
    }
  }
  {
#line 171
  rc_name = findrcfile(rcfilename);
#line 172
  fp = secfopen(rc_name, (char *)"r");
  }
#line 172
  if (rc_name == (char *)((void *)0)) {
    _L: /* CIL Label */ 
#line 173
    if (rc_name) {
#line 173
      tmp = rc_name;
    } else {
#line 173
      tmp = rcfilename;
    }
    {
#line 173
    rc_nonnull = (char const   *)tmp;
#line 174
    __cil_tmp20 = strcmp((char const   *)RcFileName, rc_nonnull);
    }
#line 174
    if (! rc_recursion) {
#line 174
      if (RcFileName) {
#line 174
        if (! __cil_tmp20) {
          {
#line 180
          while (1) {
            while_continue: /* CIL Label */ ;
#line 180
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
#line 181
          if (! nopanic) {
            {
#line 181
            Panic(0, (char const   *)((char *)"Unable to open \"%s\"."), rc_nonnull);
            }
          }
        }
      }
    }
    {
#line 185
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 185
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 186
    if (rc_name) {
#line 187
      if (rc_name == (char *)0) {
        {
#line 187
        abort();
        }
      } else {
        {
#line 187
        free((void *)rc_name);
        }
      }
#line 187
      rc_name = (char *)0;
    }
#line 188
    rc_name = oldrc_name;
#line 189
    return (1);
  } else
#line 172
  if (fp == (FILE *)((void *)0)) {
#line 172
    goto _L;
  }
  {
#line 191
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 191
    if (! (__cil_tmp21 != (char *)((void *)0))) {
#line 191
      goto while_break___1;
    }
    {
#line 192
    p = rindex((char const   *)((char *)buf), '\n');
    }
#line 192
    if (p != (char *)((void *)0)) {
#line 193
      *p = (char )'\000';
    }
    {
#line 195
    argc = Parse((char *)buf, (int )sizeof(buf), (char **)args, (int *)argl);
    }
#line 195
    if (argc == 0) {
#line 196
      goto while_continue___1;
    }
    {
#line 198
    __cil_tmp24 = strcmp((char const   *)args[0], (char const   *)((char *)"echo"));
    }
#line 198
    if (__cil_tmp24 == 0) {
#line 199
      if (! display) {
#line 200
        goto while_continue___1;
      }
      {
#line 201
      __cil_tmp25 = strcmp((char const   *)args[1], (char const   *)((char *)"-n"));
      }
#line 201
      if (argc < 2) {
        {
        {
        {
#line 202
        Msg(0, (char const   *)((char *)"%s: \'echo [-n] \"string\"\' expected."),
            rc_name);
        }
        }
        }
#line 203
        goto while_continue___1;
      } else
#line 201
      if (argc == 3) {
#line 201
        if (__cil_tmp25) {
          {
          {
          {
#line 202
          Msg(0, (char const   *)((char *)"%s: \'echo [-n] \"string\"\' expected."),
              rc_name);
          }
          }
          }
#line 203
          goto while_continue___1;
        } else {
#line 201
          goto _L___999;
        }
      } else
      _L___999: /* CIL Label */ 
#line 201
      if (argc > 3) {
        {
        {
        {
#line 202
        Msg(0, (char const   *)((char *)"%s: \'echo [-n] \"string\"\' expected."),
            rc_name);
        }
        }
        }
#line 203
        goto while_continue___1;
      }
      {
#line 205
      AddStr(args[argc - 1]);
      }
#line 206
      if (argc != 3) {
        {
#line 207
        AddStr((char *)"\r\n");
#line 208
        Flush(0);
        }
      }
    } else {
      {
#line 212
      __cil_tmp26 = strcmp((char const   *)args[0], (char const   *)((char *)"sleep"));
      }
#line 212
      if (__cil_tmp26 == 0) {
#line 213
        if (! display) {
#line 214
          goto while_continue___1;
        }
        {
#line 215
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 215
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 216
        if (argc != 2) {
          {
#line 217
          Msg(0, (char const   *)((char *)"%s: sleep: one numeric argument expected."),
              rc_name);
          }
#line 218
          goto while_continue___1;
        }
        {
#line 220
        __cil_tmp27 = atoi((char const   *)args[1]);
#line 220
        DisplaySleep1000(1000 * __cil_tmp27, 1);
        }
      } else {
        {
#line 223
        __cil_tmp29 = strcmp((char const   *)args[0], (char const   *)((char *)"terminfo"));
        }
        {
#line 223
        __cil_tmp28 = strcmp((char const   *)args[0], (char const   *)((char *)"termcapinfo"));
        }
#line 223
        if (! __cil_tmp28) {
          _L___1000: /* CIL Label */ 
#line 227
          if (! display) {
#line 228
            goto while_continue___1;
          }
#line 229
          if (argc < 3) {
            {
            {
#line 230
            Msg(0, (char const   *)((char *)"%s: %s: incorrect number of arguments."),
                rc_name, args[0]);
            }
            }
#line 231
            goto while_continue___1;
          } else
#line 229
          if (argc > 4) {
            {
            {
#line 230
            Msg(0, (char const   *)((char *)"%s: %s: incorrect number of arguments."),
                rc_name, args[0]);
            }
            }
#line 231
            goto while_continue___1;
          }
#line 234
          p = args[1];
          {
#line 234
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 234
            if (! (p && (int )*p)) {
#line 234
              goto while_break___3;
            }
            {
#line 235
            cp = index((char const   *)p, '|');
            }
#line 235
            if (cp != (char *)0) {
#line 236
              __cil_tmp31 = cp;
#line 236
              cp ++;
#line 236
              *__cil_tmp31 = (char )'\000';
            }
            {
#line 237
            __cil_tmp32 = strlen((char const   *)p);
#line 237
            len = (int )__cil_tmp32;
            }
#line 238
            if ((int )*(p + (len - 1)) == 42) {
              {
#line 239
              __cil_tmp33 = strncmp((char const   *)p, (char const   *)((char *)display->d_termname),
                                    (unsigned long )(len - 1));
              }
#line 239
              if (! (len - 1)) {
#line 240
                goto while_break___3;
              } else
#line 239
              if (! __cil_tmp33) {
#line 240
                goto while_break___3;
              }
            } else {
              {
#line 242
              __cil_tmp34 = strcmp((char const   *)p, (char const   *)((char *)display->d_termname));
              }
#line 242
              if (! __cil_tmp34) {
#line 243
                goto while_break___3;
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 234
          p = cp;
#line 245
          if (! (p && (int )*p)) {
#line 246
            goto while_continue___1;
          }
          {
#line 247
          extra_incap = CatExtra(args[2], extra_incap);
          }
#line 248
          if (argc == 4) {
            {
#line 249
            extra_outcap = CatExtra(args[3], extra_outcap);
            }
          }
        } else
#line 223
        if (! __cil_tmp29) {
#line 223
          goto _L___1000;
        } else {
          {
#line 251
          __cil_tmp37 = strcmp((char const   *)args[0], (char const   *)((char *)"source"));
          }
#line 251
          if (! __cil_tmp37) {
#line 252
            if (rc_recursion <= 10) {
              {
#line 253
              rc_recursion ++;
#line 254
              __cil_tmp39 = StartRc(args[1], 0);
#line 255
              __cil_tmp40 = rc_recursion;
#line 255
              rc_recursion --;
              }
            }
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 259
  fclose(fp);
  }
#line 260
  if (rc_name == (char *)0) {
    {
#line 260
    abort();
    }
  } else {
    {
#line 260
    free((void *)rc_name);
    }
  }
#line 260
  rc_name = (char *)0;
#line 261
  rc_name = oldrc_name;
#line 262
  return (0);
}
}
#line 265 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
void FinishRc(char *rcfilename ) 
{ 
  char buf[2048] ;
  FILE *fp ;
  char *oldrc_name ;
  char const   *rc_nonnull ;
  char *tmp ;
  int *__cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 268
  oldrc_name = rc_name;
#line 270
  rc_name = findrcfile(rcfilename);
#line 272
  fp = secfopen(rc_name, (char *)"r");
  }
#line 272
  if (rc_name == (char *)((void *)0)) {
    _L: /* CIL Label */ 
#line 273
    if (rc_name) {
#line 273
      tmp = rc_name;
    } else {
#line 273
      tmp = rcfilename;
    }
#line 273
    rc_nonnull = (char const   *)tmp;
#line 274
    if (rc_recursion) {
      {
#line 275
      __cil_tmp9 = __errno_location();
#line 275
      Msg(*__cil_tmp9, (char const   *)((char *)"%s: source %s"), oldrc_name, rc_nonnull);
      }
    } else {
      {
#line 276
      __cil_tmp10 = strcmp((char const   *)RcFileName, rc_nonnull);
      }
#line 276
      if (RcFileName) {
#line 276
        if (! __cil_tmp10) {
          {
#line 282
          while (1) {
            while_continue: /* CIL Label */ ;
#line 282
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 283
          Panic(0, (char const   *)((char *)"Unable to open \"%s\"."), rc_nonnull);
          }
        }
      }
    }
    {
#line 286
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 286
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 287
    if (rc_name) {
#line 288
      if (rc_name == (char *)0) {
        {
#line 288
        abort();
        }
      } else {
        {
#line 288
        free((void *)rc_name);
        }
      }
#line 288
      rc_name = (char *)0;
    }
#line 289
    rc_name = oldrc_name;
#line 290
    return;
  } else
#line 272
  if (fp == (FILE *)((void *)0)) {
#line 272
    goto _L;
  }
  {
#line 293
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 293
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 294
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 294
    if (! (__cil_tmp11 != (char *)((void *)0))) {
#line 294
      goto while_break___2;
    }
    {
#line 295
    RcLine((char *)buf, (int )sizeof(buf));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 296
  __cil_tmp12 = fclose(fp);
  }
#line 297
  if (rc_name == (char *)0) {
    {
#line 297
    abort();
    }
  } else {
    {
#line 297
    free((void *)rc_name);
    }
  }
#line 297
  rc_name = (char *)0;
#line 298
  rc_name = oldrc_name;
  return;
}
}
#line 301 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
void do_source(char *rcfilename ) 
{ 
  int __cil_tmp3 ;

  {
#line 302
  if (rc_recursion > 10) {
    {
#line 303
    Msg(0, (char const   *)((char *)"%s: source: recursion limit reached"), rc_name);
    }
#line 304
    return;
  }
  {
#line 306
  rc_recursion ++;
#line 307
  FinishRc(rcfilename);
#line 308
  __cil_tmp3 = rc_recursion;
#line 308
  rc_recursion --;
  }
  return;
}
}
#line 317 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
void RcLine(char *ubuf , int ubufl ) 
{ 
  char *args[64] ;
  int argl[64] ;
  extern struct acluser *EffectiveAclUser___0 ;
  extern struct acluser *users___0 ;
  struct layer *tmp ;
  int __cil_tmp8 ;

  {
#line 325
  if (display) {
#line 326
    fore = display->d_fore;
#line 327
    flayer = (display->d_forecv)->c_layer;
  } else {
#line 330
    if (fore) {
#line 330
      tmp = fore->w_savelayer;
    } else {
#line 330
      tmp = (struct layer *)0;
    }
#line 330
    flayer = tmp;
  }
  {
#line 331
  __cil_tmp8 = Parse(ubuf, ubufl, (char **)args, (int *)argl);
  }
#line 331
  if (__cil_tmp8 <= 0) {
#line 332
    return;
  }
#line 335
  if (! display) {
#line 337
    EffectiveAclUser___0 = users___0;
    {
#line 338
    while (1) {
      while_continue: /* CIL Label */ ;
#line 338
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 342
  DoCommand((char **)args, (int *)argl);
#line 345
  EffectiveAclUser___0 = (struct acluser *)0;
  }
  return;
}
}
#line 350 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
void WriteFile(struct acluser *user , char *fn , int dump ) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register char *p ;
  register FILE *f ;
  char fnbuf[1024] ;
  char *mode ;
  int public ;
  struct stat stb ;
  struct stat stb2 ;
  int fd ;
  int exists ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp22 ;
  FILE *__cil_tmp24 ;
  FILE *tmp ;
  int __cil_tmp27 ;
  struct mline *tmp___0 ;
  int __cil_tmp29 ;
  int __cil_tmp32 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  char *tmp___1 ;

  {
#line 362
  mode = (char *)"w";
#line 365
  public = 0;
#line 368
  exists = 0;
  {
#line 373
  if (dump == 0) {
#line 373
    goto case_0;
  }
#line 385
  if (dump == 3) {
#line 385
    goto case_3;
  }
#line 385
  if (dump == 1) {
#line 385
    goto case_3;
  }
#line 400
  if (dump == 2) {
#line 400
    goto case_2;
  }
#line 372
  goto switch_break;
  case_0: /* CIL Label */ 
#line 374
  if (fn == (char *)0) {
#line 375
    i = (int )(SockName - (char *)SockPath);
#line 376
    if (i > (int )sizeof(fnbuf) - 9) {
#line 377
      i = 0;
    }
    {
#line 378
    strncpy((char *)fnbuf, (char const   *)((char *)SockPath), (unsigned long )i);
#line 379
    strcpy((char *)fnbuf + i, (char const   *)((char *)".termcap"));
#line 380
    fn = (char *)fnbuf;
    }
  }
#line 382
  goto switch_break;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 386
  if (fn == (char *)0) {
#line 387
    if (fore == (struct win *)0) {
#line 388
      return;
    }
    {
#line 389
    __cil_tmp16 = strlen((char const   *)hardcopydir);
    }
#line 389
    if (hardcopydir) {
#line 389
      if ((int )*hardcopydir) {
#line 389
        if (__cil_tmp16 < sizeof(fnbuf) - 21UL) {
          {
#line 390
          sprintf((char *)fnbuf, (char const   *)((char *)"%s/hardcopy.%d"), hardcopydir,
                  fore->w_number);
          }
        } else {
          {
          {
          {
#line 392
          sprintf((char *)fnbuf, (char const   *)((char *)"hardcopy.%d"), fore->w_number);
          }
          }
          }
        }
      } else {
        {
        {
        {
#line 392
        sprintf((char *)fnbuf, (char const   *)((char *)"hardcopy.%d"), fore->w_number);
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 392
      sprintf((char *)fnbuf, (char const   *)((char *)"hardcopy.%d"), fore->w_number);
      }
      }
      }
    }
#line 393
    fn = (char *)fnbuf;
  }
  {
#line 395
  __cil_tmp17 = access((char const   *)fn, 2);
  }
#line 395
  if (hardcopy_append) {
#line 395
    if (! __cil_tmp17) {
#line 396
      mode = (char *)"a";
    }
  }
#line 397
  goto switch_break;
  case_2: /* CIL Label */ 
#line 401
  if (fn == (char *)0) {
    {
#line 402
    strncpy((char *)fnbuf, (char const   *)BufferFile, sizeof(fnbuf) - 1UL);
#line 403
    fnbuf[sizeof(fnbuf) - 1UL] = (char )0;
#line 404
    fn = (char *)fnbuf;
    }
  }
  {
#line 406
  __cil_tmp18 = strcmp((char const   *)fn, (char const   *)((char *)"/tmp/screen-exchange"));
#line 406
  public = ! __cil_tmp18;
#line 408
  __cil_tmp19 = lstat((char const   *)fn, & stb);
#line 408
  exists = ! __cil_tmp19;
  }
#line 409
  if (public) {
#line 409
    if (exists) {
#line 409
      if ((stb.st_mode & 61440U) == 40960U) {
        {
        {
#line 410
        Msg(0, (char const   *)((char *)"No write to links, please."));
        }
        }
#line 411
        return;
      } else
#line 409
      if (stb.st_nlink > 1UL) {
        {
        {
#line 410
        Msg(0, (char const   *)((char *)"No write to links, please."));
        }
        }
#line 411
        return;
      }
    }
  }
#line 414
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 419
  __cil_tmp20 = UserContext();
  }
#line 419
  if (__cil_tmp20 > 0) {
    {
#line 420
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 420
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 422
    if (dump == 2) {
#line 422
      if (public) {
#line 424
        if (exists) {
          {
#line 425
          fd = open((char const   *)fn, 1, 438);
          }
#line 425
          if (fd >= 0) {
            {
#line 426
            __cil_tmp22 = fstat(fd, & stb2);
            }
#line 426
            if (__cil_tmp22 == 0) {
#line 426
              if (stb.st_dev == stb2.st_dev) {
#line 426
                if (stb.st_ino == stb2.st_ino) {
                  {
#line 427
                  ftruncate(fd, (__off_t )0);
                  }
                } else {
                  {
                  {
                  {
#line 429
                  close(fd);
                  }
                  }
#line 430
                  fd = - 1;
                  }
                }
              } else {
                {
                {
                {
#line 429
                close(fd);
                }
                }
#line 430
                fd = - 1;
                }
              }
            } else {
              {
              {
              {
#line 429
              close(fd);
              }
              }
#line 430
              fd = - 1;
              }
            }
          }
        } else {
          {
#line 435
          fd = open((char const   *)fn, 193, 438);
          }
        }
#line 436
        if (fd >= 0) {
          {
#line 436
          __cil_tmp24 = fdopen(fd, (char const   *)mode);
#line 436
          tmp = __cil_tmp24;
          }
        } else {
#line 436
          tmp = (FILE *)0;
        }
#line 436
        f = tmp;
      } else {
        {
        {
#line 443
        f = fopen((char const   *)fn, (char const   *)mode);
        }
        }
      }
    } else {
      {
      {
#line 443
      f = fopen((char const   *)fn, (char const   *)mode);
      }
      }
    }
#line 444
    if (f == (FILE *)((void *)0)) {
      {
#line 445
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 445
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 446
      UserReturn(0);
      }
    } else {
      {
#line 451
      if (dump == 3) {
#line 451
        goto case_3___0;
      }
#line 451
      if (dump == 1) {
#line 451
        goto case_3___0;
      }
#line 482
      if (dump == 0) {
#line 482
        goto case_0___0;
      }
#line 490
      if (dump == 2) {
#line 490
        goto case_2___0;
      }
#line 449
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
#line 452
      if (! fore) {
#line 453
        goto switch_break___0;
      }
#line 454
      if ((int )*mode == 97) {
        {
#line 455
        _IO_putc('>', f);
#line 456
        j = fore->w_layer.l_width - 2;
        }
        {
#line 456
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 456
          if (! (j > 0)) {
#line 456
            goto while_break___2;
          }
          {
#line 457
          _IO_putc('=', f);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 456
        __cil_tmp27 = j;
#line 456
        j --;
#line 458
        fputs((char const   *)((char *)"<\n"), f);
        }
      }
#line 460
      if (dump == 3) {
#line 462
        i = fore->w_histheight - fore->w_scrollback_height;
        {
#line 462
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 462
          if (! (i < fore->w_histheight)) {
#line 462
            goto while_break___3;
          }
#line 463
          p = (char *)tmp___0->image;
#line 464
          k = fore->w_layer.l_width - 1;
          {
#line 464
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 464
            if (! (k >= 0 && (int )*(p + k) == 32)) {
#line 464
              goto while_break___4;
            }

          }
          while_break___4: /* CIL Label */ ;
          }
#line 464
          __cil_tmp29 = k;
#line 464
          k --;
#line 466
          j = 0;
          {
#line 466
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 466
            if (! (j <= k)) {
#line 466
              goto while_break___5;
            }
            {
#line 467
            _IO_putc((int )*(p + j), f);
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          {
#line 466
          j ++;
#line 468
          _IO_putc('\n', f);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 462
        i ++;
      }
#line 472
      i = 0;
      {
#line 472
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 472
        if (! (i < fore->w_layer.l_height)) {
#line 472
          goto while_break___6;
        }
#line 473
        p = (char *)(fore->w_mlines + i)->image;
#line 474
        k = fore->w_layer.l_width - 1;
        {
#line 474
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 474
          if (! (k >= 0 && (int )*(p + k) == 32)) {
#line 474
            goto while_break___7;
          }

        }
        while_break___7: /* CIL Label */ ;
        }
#line 474
        __cil_tmp32 = k;
#line 474
        k --;
#line 476
        j = 0;
        {
#line 476
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 476
          if (! (j <= k)) {
#line 476
            goto while_break___8;
          }
          {
#line 477
          _IO_putc((int )*(p + j), f);
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 476
        j ++;
#line 478
        _IO_putc('\n', f);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 472
      i ++;
#line 480
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 483
      __cil_tmp35 = MakeTermcap(fore->w_aflag);
#line 483
      __cil_tmp36 = index((char const   *)__cil_tmp35, '=');
#line 483
      p = __cil_tmp36;
      }
#line 483
      if (p != (char *)((void *)0)) {
        {
#line 484
        p ++;
#line 484
        fputs((char const   *)p, f);
#line 485
        _IO_putc('\n', f);
        }
      }
#line 487
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 491
      p = user->u_plop.buf;
#line 492
      i = user->u_plop.len;
      {
#line 492
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 492
        if (! (__cil_tmp37 > 0)) {
#line 492
          goto while_break___9;
        }
#line 493
        if ((int )*p == 13) {
#line 493
          if (i == 0) {
            {
            {
#line 494
            _IO_putc('\n', f);
            }
            }
          } else
#line 493
          if ((int )*(p + 1) != 10) {
            {
            {
#line 494
            _IO_putc('\n', f);
            }
            }
          } else {
            {
            {
#line 496
            _IO_putc((int )*p, f);
            }
            }
          }
        } else {
          {
          {
#line 496
          _IO_putc((int )*p, f);
          }
          }
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 492
      p ++;
#line 497
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 500
      __cil_tmp39 = fclose(f);
#line 501
      UserReturn(1);
      }
    }
  }
  {
#line 504
  __cil_tmp40 = UserStatus();
  }
#line 504
  if (__cil_tmp40 <= 0) {
    {
#line 505
    Msg(0, (char const   *)((char *)"Cannot open \"%s\""), fn);
    }
  } else
#line 506
  if (display) {
#line 506
    if (! *rc_name) {
      {
#line 508
      if (dump == 0) {
#line 508
        goto case_0___1;
      }
#line 512
      if (dump == 3) {
#line 512
        goto case_3___1;
      }
#line 512
      if (dump == 1) {
#line 512
        goto case_3___1;
      }
#line 516
      if (dump == 2) {
#line 516
        goto case_2___1;
      }
#line 507
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
      {
#line 509
      Msg(0, (char const   *)((char *)"Termcap entry written to \"%s\"."), fn);
      }
#line 510
      goto switch_break___1;
      case_3___1: /* CIL Label */ 
      case_1___1: /* CIL Label */ 
#line 513
      if ((int )*mode == 97) {
#line 513
        tmp___1 = (char *)"appended";
      } else {
#line 513
        tmp___1 = (char *)"written";
      }
      {
#line 513
      Msg(0, (char const   *)((char *)"Screen image %s to \"%s\"."), tmp___1, fn);
      }
#line 514
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 517
      Msg(0, (char const   *)((char *)"Copybuffer written to \"%s\"."), fn);
      }
      switch_break___1: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 530 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
char *ReadFile(char *fn , int *lenp ) 
{ 
  int i ;
  int l ;
  int size ;
  char c ;
  char *bp ;
  char *buf ;
  struct stat stb ;
  int *__cil_tmp11 ;
  int __cil_tmp12 ;
  int *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int *__cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  int *__cil_tmp17 ;
  ssize_t __cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 536
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 536
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 538
  i = secopen(fn, 0, 0);
  }
#line 538
  if (i < 0) {
    {
#line 539
    __cil_tmp11 = __errno_location();
#line 539
    Msg(*__cil_tmp11, (char const   *)((char *)"no %s -- no slurp"), fn);
    }
#line 540
    return ((char *)((void *)0));
  }
  {
#line 543
  __cil_tmp12 = fstat(i, & stb);
  }
#line 543
  if (__cil_tmp12) {
    {
#line 544
    __cil_tmp13 = __errno_location();
#line 544
    Msg(*__cil_tmp13, (char const   *)((char *)"no good %s -- no slurp"), fn);
#line 545
    close(i);
    }
#line 546
    return ((char *)((void *)0));
  }
  {
#line 548
  size = (int )stb.st_size;
#line 550
  __cil_tmp14 = malloc((unsigned long )size);
#line 550
  buf = (char *)__cil_tmp14;
  }
#line 550
  if (buf == (char *)((void *)0)) {
    {
#line 551
    close(i);
#line 552
    Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
#line 553
    return ((char *)((void *)0));
  }
  {
#line 555
  __cil_tmp15 = __errno_location();
#line 555
  *__cil_tmp15 = 0;
#line 557
  __cil_tmp16 = read(i, (void *)buf, (size_t )size);
#line 557
  l = (int )__cil_tmp16;
  }
#line 557
  if (l != size) {
#line 558
    if (l < 0) {
#line 559
      l = 0;
    }
    {
#line 560
    __cil_tmp17 = __errno_location();
#line 560
    Msg(*__cil_tmp17, (char const   *)((char *)"Got only %d bytes from %s"), l, fn);
    }
  } else {
    {
#line 563
    __cil_tmp18 = read(i, (void *)(& c), (size_t )1);
    }
#line 563
    if (__cil_tmp18 > 0L) {
      {
#line 564
      Msg(0, (char const   *)((char *)"Slurped only %d characters (of %d) into buffer - try again"),
          l, size);
      }
    } else {
      {
#line 566
      Msg(0, (char const   *)((char *)"Slurped %d characters into buffer"), l);
      }
    }
  }
  {
#line 568
  close(i);
#line 569
  *lenp = l;
#line 570
  bp = buf;
  }
  {
#line 570
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 570
    if (! (__cil_tmp19 > 0)) {
#line 570
      goto while_break___1;
    }
#line 571
    if ((int )*bp == 10) {
#line 571
      if (bp == buf) {
#line 572
        *bp = (char )'\r';
      } else
#line 571
      if ((int )*(bp + -1) != 13) {
#line 572
        *bp = (char )'\r';
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 570
  bp ++;
#line 573
  return (buf);
}
}
#line 576 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
void KillBuffers(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;
  int *__cil_tmp3 ;
  int tmp ;
  int *__cil_tmp5 ;
  int *__cil_tmp7 ;
  int *__cil_tmp8 ;
  char *tmp___1001 ;

  {
  {
#line 577
  __cil_tmp1 = UserContext();
  }
#line 577
  if (__cil_tmp1 > 0) {
    {
#line 578
    __cil_tmp2 = unlink((char const   *)BufferFile);
    }
#line 578
    if (__cil_tmp2) {
      {
#line 578
      __cil_tmp3 = __errno_location();
#line 578
      tmp = *__cil_tmp3;
      }
    } else {
#line 578
      tmp = 0;
    }
    {
#line 578
    UserReturn(tmp);
    }
  }
  {
#line 579
  __cil_tmp5 = __errno_location();
#line 579
  *__cil_tmp5 = UserStatus();
#line 580
  __cil_tmp7 = __errno_location();
  }
  {
#line 580
  __cil_tmp8 = __errno_location();
  }
#line 580
  if (*__cil_tmp8) {
#line 580
    tmp___1001 = (char *)"not ";
  } else {
#line 580
    tmp___1001 = (char *)"";
  }
  {
#line 580
  Msg(*__cil_tmp7, (char const   *)((char *)"%s %sremoved"), BufferFile, tmp___1001);
  }
  return;
}
}
#line 587 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
FILE *secfopen(char *name , char *mode ) 
{ 
  FILE *fi ;

  {
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 595
  xseteuid(real_uid);
#line 596
  xsetegid(real_gid);
#line 597
  fi = fopen((char const   *)name, (char const   *)mode);
#line 598
  xseteuid(eff_uid);
#line 599
  xsetegid(eff_gid);
  }
#line 600
  return (fi);
}
}
#line 628 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
int secopen(char *name , int flags , int mode ) 
{ 
  int fd ;

  {
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 637
  xseteuid(real_uid);
#line 638
  xsetegid(real_gid);
#line 639
  fd = open((char const   *)name, flags, mode);
#line 640
  xseteuid(eff_uid);
#line 641
  xsetegid(eff_gid);
  }
#line 642
  return (fd);
}
}
#line 698 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
int printpipe(struct win *p , char *cmd ) 
{ 
  int pi[2] ;
  int __cil_tmp4 ;
  int *__cil_tmp5 ;
  __pid_t __cil_tmp6 ;
  int *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
  {
#line 700
  __cil_tmp4 = pipe((int *)pi);
  }
#line 700
  if (__cil_tmp4) {
    {
#line 701
    __cil_tmp5 = __errno_location();
#line 701
    WMsg(p, *__cil_tmp5, (char *)"printing pipe");
    }
#line 702
    return (- 1);
  }
  {
#line 704
  __cil_tmp6 = fork();
  }
  {
#line 705
  if (__cil_tmp6 == - 1) {
#line 705
    goto case_exp;
  }
#line 708
  if (__cil_tmp6 == 0) {
#line 708
    goto case_0;
  }
#line 729
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 706
  __cil_tmp7 = __errno_location();
#line 706
  WMsg(p, *__cil_tmp7, (char *)"printing fork");
  }
#line 707
  return (- 1);
  case_0: /* CIL Label */ 
#line 709
  display = p->w_pdisplay;
  {
#line 710
  displays = (struct display *)0;
#line 711
  ServerSocket = - 1;
#line 716
  close(0);
#line 717
  dup(pi[0]);
#line 718
  closeallfiles(0);
#line 719
  __cil_tmp9 = setuid((__uid_t )real_uid);
  }
  {
#line 719
  __cil_tmp8 = setgid((__gid_t )real_gid);
  }
#line 719
  if (__cil_tmp8) {
    {
    {
#line 720
    __cil_tmp10 = __errno_location();
    }
    {
#line 720
    Panic(*__cil_tmp10, (char const   *)((char *)"printpipe setuid"));
    }
    }
  } else
#line 719
  if (__cil_tmp9) {
    {
    {
#line 720
    __cil_tmp10 = __errno_location();
    }
    {
#line 720
    Panic(*__cil_tmp10, (char const   *)((char *)"printpipe setuid"));
    }
    }
  }
  {
#line 721
  eff_uid = real_uid;
#line 722
  eff_gid = real_gid;
#line 725
  xsignal(13, (__sighandler_t )0);
#line 727
  execl((char const   *)((char *)"/bin/sh"), (char const   *)((char *)"sh"), (char *)"-c",
        cmd, (char *)0);
#line 728
  __cil_tmp11 = __errno_location();
#line 728
  Panic(*__cil_tmp11, (char const   *)((char *)"/bin/sh"));
  }
  switch_default: /* CIL Label */ 
#line 730
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 732
  close(pi[0]);
  }
#line 733
  return (pi[1]);
}
}
#line 736 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/fileio.c"
int readpipe(char **cmdv ) 
{ 
  int pi[2] ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;
  __pid_t __cil_tmp5 ;
  int *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int *__cil_tmp10 ;
  int *__cil_tmp11 ;

  {
  {
#line 739
  __cil_tmp3 = pipe((int *)pi);
  }
#line 739
  if (__cil_tmp3) {
    {
#line 740
    __cil_tmp4 = __errno_location();
#line 740
    Msg(*__cil_tmp4, (char const   *)((char *)"pipe"));
    }
#line 741
    return (- 1);
  }
  {
#line 744
  __cil_tmp5 = fork();
  }
  {
#line 745
  if (__cil_tmp5 == - 1) {
#line 745
    goto case_exp;
  }
#line 748
  if (__cil_tmp5 == 0) {
#line 748
    goto case_0;
  }
#line 774
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 746
  __cil_tmp6 = __errno_location();
#line 746
  Msg(*__cil_tmp6, (char const   *)((char *)"fork"));
  }
#line 747
  return (- 1);
  case_0: /* CIL Label */ 
#line 749
  displays = (struct display *)0;
  {
#line 750
  ServerSocket = - 1;
#line 755
  close(1);
#line 756
  __cil_tmp7 = dup(pi[1]);
  }
#line 756
  if (__cil_tmp7 != 1) {
    {
#line 757
    close(pi[1]);
#line 758
    Panic(0, (char const   *)((char *)"dup"));
    }
  }
  {
#line 760
  closeallfiles(1);
#line 762
  __cil_tmp9 = setuid((__uid_t )real_uid);
  }
  {
#line 762
  __cil_tmp8 = setgid((__gid_t )real_gid);
  }
#line 762
  if (__cil_tmp8) {
    {
    {
#line 763
    close(1);
    }
    {
#line 764
    __cil_tmp10 = __errno_location();
    }
    {
#line 764
    Panic(*__cil_tmp10, (char const   *)((char *)"setuid/setgid"));
    }
    }
  } else
#line 762
  if (__cil_tmp9) {
    {
    {
#line 763
    close(1);
    }
    {
#line 764
    __cil_tmp10 = __errno_location();
    }
    {
#line 764
    Panic(*__cil_tmp10, (char const   *)((char *)"setuid/setgid"));
    }
    }
  }
  {
#line 766
  eff_uid = real_uid;
#line 767
  eff_gid = real_gid;
#line 769
  xsignal(13, (__sighandler_t )0);
#line 771
  execvp((char const   *)*cmdv, (char * const  [])cmdv);
#line 772
  close(1);
#line 773
  __cil_tmp11 = __errno_location();
#line 773
  Panic(*__cil_tmp11, (char const   *)((char *)"%s"), *cmdv);
  }
  switch_default: /* CIL Label */ 
#line 775
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 777
  close(pi[1]);
  }
#line 778
  return (pi[0]);
}
}
#line 79 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
void WChangeSize(struct win *p , int w , int h ) ;
#line 81
int MFindUsedLine(struct win *p , int ye , int ys ) ;
#line 46 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
int nversion ;
#line 60 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
int const   Z0width  =    132;
#line 61 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
int const   Z1width  =    80;
#line 64
static struct win *curr ;
#line 65
static int rows ;
#line 65
static int cols ;
#line 67 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
int visual_bell  =    0;
#line 68 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
int use_hardstatus  =    1;
#line 69 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
char *printcmd  =    (char *)0;
#line 70 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
int use_altscreen  =    0;
#line 80 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
struct mchar mchar_blank  =    {(unsigned char )' ', (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0};
#line 81 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
struct mchar mchar_so  =    {(unsigned char )' ', (unsigned char )(1 << 4), (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0};
#line 83 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
int renditions[3]  = {      65529,      65531,      65533};
#line 86 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static char *string_t_string[]  = 
#line 86
  {      (char *)"NONE",      (char *)"DCS",      (char *)"OSC",      (char *)"APC", 
        (char *)"PM",      (char *)"AKA",      (char *)"GM",      (char *)"STATUS"};
#line 100 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static char *state_t_string[]  = 
#line 100
  {      (char *)"LIT",      (char *)"ESC",      (char *)"ASTR",      (char *)"STRESC", 
        (char *)"CSI",      (char *)"PRIN",      (char *)"PRINESC",      (char *)"PRINCSI", 
        (char *)"PRIN4"};
#line 113
static int Special(int c ) ;
#line 114
static void DoESC(int c , int intermediate ) ;
#line 115
static void DoCSI(int c , int intermediate ) ;
#line 116
static void StringStart(enum string_t type ) ;
#line 117
static void StringChar(int c ) ;
#line 118
static int StringEnd(void) ;
#line 119
static void PrintStart(void) ;
#line 120
static void PrintChar(int c ) ;
#line 121
static void PrintFlush(void) ;
#line 123
static void DesignateCharset(int c , int n ) ;
#line 124
static void MapCharset(int n ) ;
#line 125
static void MapCharsetR(int n ) ;
#line 127
static void SaveCursor(struct cursor *cursor ) ;
#line 128
static void RestoreCursor(struct cursor *cursor ) ;
#line 129
static void BackSpace(void) ;
#line 130
static void Return(void) ;
#line 131
static void LineFeed(int out_mode ) ;
#line 132
static void ReverseLineFeed(void) ;
#line 133
static void InsertChar(int n ) ;
#line 134
static void DeleteChar(int n ) ;
#line 135
static void DeleteLine(int n ) ;
#line 136
static void InsertLine(int n ) ;
#line 137
static void Scroll(char *cp , int cnt1 , int cnt2 , char *tmp ) ;
#line 138
static void ForwardTab(void) ;
#line 139
static void BackwardTab(void) ;
#line 140
static void ClearScreen(void) ;
#line 141
static void ClearFromBOS(void) ;
#line 142
static void ClearToEOS(void) ;
#line 143
static void ClearLineRegion(int from , int to ) ;
#line 144
static void CursorRight(int n ) ;
#line 145
static void CursorUp(int n ) ;
#line 146
static void CursorDown(int n ) ;
#line 147
static void CursorLeft(int n ) ;
#line 148
static void ASetMode(int on ) ;
#line 149
static void SelectRendition(void) ;
#line 150
static void RestorePosRendition(void) ;
#line 151
static void FillWithEs(void) ;
#line 152
static void FindAKA(void) ;
#line 153
static void Report(char *fmt , int n1 , int n2 ) ;
#line 154
static void ScrollRegion(int n ) ;
#line 156
static void WAddLineToHist(struct win *wp , struct mline *ml ) ;
#line 158
static void WLogString(struct win *p , char *buf , int len ) ;
#line 159
static void WReverseVideo(struct win *p , int on ) ;
#line 160
static int WindowChangedCheck(char *s , int what , int *hp ) ;
#line 161
static void MFixLine(struct win *p , int y , struct mchar *mc ) ;
#line 162
static void MScrollH(struct win *p , int n , int y , int xs , int xe , int bce ) ;
#line 163
static void MScrollV(struct win *p , int n , int ys , int ye , int bce ) ;
#line 164
static void MClearArea(struct win *p , int xs , int ys , int xe , int ye , int bce ) ;
#line 165
static void MInsChar(struct win *p , struct mchar *c , int x , int y ) ;
#line 166
static void MPutChar(struct win *p , struct mchar *c , int x , int y ) ;
#line 167
static void MPutStr(struct win *p , char *s , int n , struct mchar *r , int x , int y ) ;
#line 168
static void MWrapChar(struct win *p , struct mchar *c , int y , int top , int bot ,
                      int ins ) ;
#line 170
static void MBceLine(struct win *p , int y , int xs , int xe , int bce ) ;
#line 180 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void ResetAnsiState(struct win *p ) 
{ 


  {
#line 183
  p->w_state = (enum state_t )0;
#line 184
  p->w_StringType = (enum string_t )0;
  return;
}
}
#line 188 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void ResetWindow(struct win *p ) 
{ 
  register int i ;

  {
  {
#line 193
  p->w_wrap = nwin_default.wrap;
#line 194
  p->w_origin = 0;
#line 195
  p->w_insert = 0;
#line 196
  p->w_revvid = 0;
#line 197
  p->w_mouse = 0;
#line 198
  p->w_curinv = 0;
#line 199
  p->w_curvvis = 0;
#line 200
  p->w_autolf = 0;
#line 201
  p->w_keypad = 0;
#line 202
  p->w_cursorkeys = 0;
#line 203
  p->w_top = 0;
#line 204
  p->w_bot = p->w_layer.l_height - 1;
#line 205
  p->w_saved.on = 0;
#line 206
  p->w_layer.l_y = 0;
#line 206
  p->w_layer.l_x = p->w_layer.l_y;
#line 207
  p->w_state = (enum state_t )0;
#line 208
  p->w_StringType = (enum string_t )0;
#line 209
  bzero((void *)p->w_tabs, (unsigned long )p->w_layer.l_width);
#line 210
  i = 8;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < p->w_layer.l_width)) {
#line 210
      goto while_break;
    }
#line 211
    *(p->w_tabs + i) = (char )1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  i += 8;
#line 212
  p->w_rend = mchar_null;
#line 214
  ResetCharsets(p);
#line 217
  p->w_bce = nwin_default.bce;
  }
  return;
}
}
#line 223 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
int GetAnsiStatus(struct win *w , char *buf ) 
{ 
  char *p ;
  size_t __cil_tmp4 ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
#line 227
  p = buf;
#line 229
  if ((unsigned int )w->w_state == 0U) {
#line 230
    return (0);
  }
  {
#line 232
  strcpy(p, (char const   *)state_t_string[w->w_state]);
#line 233
  __cil_tmp4 = strlen((char const   *)p);
  }
#line 233
  p += __cil_tmp4;
#line 234
  if (w->w_intermediate) {
#line 236
    __cil_tmp5 = p;
#line 236
    p ++;
#line 236
    *__cil_tmp5 = (char )'-';
#line 237
    if (w->w_intermediate > 255) {
      {
#line 238
      __cil_tmp6 = AddXChar(p, w->w_intermediate >> 8);
      }
#line 238
      p += __cil_tmp6;
    }
    {
#line 239
    __cil_tmp7 = AddXChar(p, w->w_intermediate & 255);
    }
#line 239
    p += __cil_tmp7;
#line 240
    *p = (char )0;
  }
#line 242
  if ((unsigned int )w->w_state == 2U) {
    {
    {
#line 243
    sprintf(p, (char const   *)((char *)"-%s"), string_t_string[w->w_StringType]);
    }
    }
  } else
#line 242
  if ((unsigned int )w->w_state == 3U) {
    {
    {
#line 243
    sprintf(p, (char const   *)((char *)"-%s"), string_t_string[w->w_StringType]);
    }
    }
  }
  {
#line 244
  __cil_tmp8 = strlen((char const   *)p);
  }
#line 244
  p += __cil_tmp8;
#line 245
  return ((int )(p - buf));
}
}
#line 252 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void ResetCharsets(struct win *p ) 
{ 


  {
  {
#line 255
  p->w_gr = nwin_default.gr;
#line 256
  p->w_c1 = nwin_default.c1;
#line 257
  SetCharsets(p, (char *)"BBBB02");
  }
#line 258
  if (nwin_default.charset) {
    {
#line 259
    SetCharsets(p, nwin_default.charset);
    }
  }
  {
#line 261
  ResetEncoding(p);
  }
  return;
}
}
#line 266 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void SetCharsets(struct win *p , char *s ) 
{ 
  int i ;
  int tmp ;
  int __cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 272
  i = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < 4 && (int )*s)) {
#line 272
      goto while_break;
    }
#line 273
    if ((int )*s != 46) {
#line 274
      if ((int )*s == 66) {
#line 274
        tmp = 0;
      } else {
#line 274
        tmp = (int )*s;
      }
#line 274
      p->w_charsets[i] = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  __cil_tmp6 = s;
#line 272
  s ++;
#line 272
  __cil_tmp5 = i;
#line 272
  i ++;
#line 275
  __cil_tmp7 = s;
#line 275
  s ++;
#line 275
  if ((int )*s) {
#line 275
    if ((int )*__cil_tmp7 != 46) {
#line 276
      p->w_Charset = (int )*(s + -1) - 48;
    }
  }
#line 277
  if ((int )*s) {
#line 277
    if ((int )*s != 46) {
#line 278
      p->w_CharsetR = (int )*s - 48;
    }
  }
#line 279
  p->w_ss = 0;
#line 280
  p->w_FontL = (char )p->w_charsets[p->w_Charset];
#line 281
  p->w_FontR = (char )p->w_charsets[p->w_CharsetR];
  return;
}
}
#line 297 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void WriteString(struct win *wp , char *buf , int len ) 
{ 
  register int c ;
  register int font ;
  struct canvas *cv ;
  char *__cil_tmp7 ;
  register int currx ;
  char *imp ;
  char *__cil_tmp11 ;
  char *__cil_tmp13 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp18 ;
  int tmp ;
  struct mchar mc ;
  struct mchar *mcp ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int ox ;
  int oy ;
  struct mchar omc ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int t ;
  int tmp___0 ;
  int __cil_tmp33 ;

  {
#line 308
  if (! len) {
#line 309
    return;
  }
#line 310
  if (wp->w_log) {
    {
#line 311
    WLogString(wp, buf, len);
    }
  }
#line 314
  curr = wp;
#line 315
  cols = curr->w_layer.l_width;
#line 316
  rows = curr->w_layer.l_height;
#line 318
  if (curr->w_silence) {
    {
#line 319
    SetTimeout(& curr->w_silenceev, curr->w_silencewait * 1000);
    }
  }
#line 321
  if (curr->w_monitor == 1) {
    {
#line 323
    while (1) {
      while_continue: /* CIL Label */ ;
#line 323
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 324
    curr->w_monitor = 2;
  }
#line 327
  if (cols > 0) {
#line 327
    if (rows > 0) {
      {
#line 329
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 331
        __cil_tmp7 = buf;
#line 331
        buf ++;
#line 331
        c = (int )((unsigned char )*__cil_tmp7);
#line 334
        if (! curr->w_mbcs) {
#line 336
          curr->w_rend.font = (unsigned char )curr->w_FontL;
        }
#line 340
        if ((unsigned int )curr->w_state == 0U) {
#line 340
          if (curr->w_layer.l_encoding != 8) {
#line 340
            if (! ((int )curr->w_rend.font && ((int )curr->w_rend.font & 96) == 0)) {
#line 340
              if ((int )curr->w_rend.font != 73) {
#line 340
                if (! curr->w_mbcs) {
#line 340
                  if ((int )curr->w_rend.font != 60) {
#line 340
                    if (c >= 32) {
#line 340
                      if (c != 127) {
#line 340
                        if ((c & 128) == 0) {
                          _L___1002: /* CIL Label */ 
#line 340
                          if (! curr->w_ss) {
#line 340
                            if (! curr->w_insert) {
#line 340
                              if (curr->w_layer.l_x < cols - 1) {
#line 357
                                currx = curr->w_layer.l_x;
#line 358
                                imp = buf - 1;
                                {
#line 360
                                while (1) {
                                  while_continue___1: /* CIL Label */ ;
#line 360
                                  if (! (currx < cols - 1)) {
#line 360
                                    goto while_break___1;
                                  }
#line 362
                                  currx ++;
#line 363
                                  len --;
#line 363
                                  if (len == 0) {
#line 364
                                    goto while_break___1;
                                  }
#line 365
                                  __cil_tmp11 = buf;
#line 365
                                  buf ++;
#line 365
                                  c = (int )((unsigned char )*__cil_tmp11);
#line 366
                                  if (c < 32) {
#line 367
                                    goto while_break___1;
                                  } else
#line 366
                                  if (c == 127) {
#line 367
                                    goto while_break___1;
                                  } else
#line 366
                                  if (c & 128) {
#line 366
                                    if (c < 160) {
#line 366
                                      if (curr->w_c1) {
#line 367
                                        goto while_break___1;
                                      } else {
#line 366
                                        goto _L;
                                      }
                                    } else
                                    _L: /* CIL Label */ 
#line 366
                                    if (curr->w_gr) {
#line 367
                                      goto while_break___1;
                                    }
                                  }
                                }
                                while_break___1: /* CIL Label */ ;
                                }
#line 369
                                currx -= curr->w_layer.l_x;
#line 370
                                if (currx > 0) {
                                  {
#line 372
                                  MPutStr(curr, imp, currx, & curr->w_rend, curr->w_layer.l_x,
                                          curr->w_layer.l_y);
#line 373
                                  LPutStr(& curr->w_layer, imp, currx, & curr->w_rend,
                                          curr->w_layer.l_x, curr->w_layer.l_y);
#line 374
                                  curr->w_layer.l_x += currx;
                                  }
                                }
#line 376
                                if (len == 0) {
#line 377
                                  goto while_break___0;
                                }
                              }
                            }
                          }
                        } else
#line 340
                        if (c >= 160) {
                          _L___1003: /* CIL Label */ 
#line 340
                          if (! curr->w_gr) {
#line 340
                            goto _L___1002;
                          }
                        } else
#line 340
                        if (! curr->w_c1) {
#line 340
                          goto _L___1003;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 382
        if (curr->w_layer.l_encoding == 8) {
          {
#line 384
          c = FromUtf8(c, & curr->w_decodestate);
          }
#line 385
          if (c == -1) {
#line 386
            goto while_continue___0;
          }
#line 387
          if (c == -2) {
#line 389
            c = 65533;
#line 391
            __cil_tmp13 = buf;
#line 391
            buf --;
#line 392
            len ++;
          }
#line 394
          if (c > 255) {
            {
#line 395
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 395
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
        tryagain: 
        {
#line 402
        if ((unsigned int )curr->w_state == (unsigned int )5) {
#line 402
          goto case_5;
        }
#line 405
        if ((unsigned int )curr->w_state == '\033') {
#line 405
          goto case_27;
        }
#line 412
        if ((unsigned int )curr->w_state == (unsigned int )6) {
#line 412
          goto case_6;
        }
#line 415
        if ((unsigned int )curr->w_state == '[') {
#line 415
          goto case_91;
        }
#line 424
        if ((unsigned int )curr->w_state == (unsigned int )7) {
#line 424
          goto case_7;
        }
#line 427
        if ((unsigned int )curr->w_state == '4') {
#line 427
          goto case_52;
        }
#line 437
        if ((unsigned int )curr->w_state == (unsigned int )8) {
#line 437
          goto case_8;
        }
#line 440
        if ((unsigned int )curr->w_state == 'i') {
#line 440
          goto case_105;
        }
#line 458
        if ((unsigned int )curr->w_state == (unsigned int )2) {
#line 458
          goto case_2;
        }
#line 476
        if ((unsigned int )curr->w_state == (unsigned int )3) {
#line 476
          goto case_3;
        }
#line 479
        if ((unsigned int )curr->w_state == '\\') {
#line 479
          goto case_92;
        }
#line 498
        if ((unsigned int )curr->w_state == '\033') {
#line 498
          goto case_27___0;
        }
#line 508
        if ((unsigned int )curr->w_state == (unsigned int )1) {
#line 508
          goto case_1;
        }
#line 511
        if ((unsigned int )curr->w_state == '[') {
#line 511
          goto case_91___0;
        }
#line 517
        if ((unsigned int )curr->w_state == ']') {
#line 517
          goto case_93;
        }
#line 520
        if ((unsigned int )curr->w_state == '_') {
#line 520
          goto case_95;
        }
#line 523
        if ((unsigned int )curr->w_state == 'P') {
#line 523
          goto case_80;
        }
#line 526
        if ((unsigned int )curr->w_state == '^') {
#line 526
          goto case_94;
        }
#line 529
        if ((unsigned int )curr->w_state == '!') {
#line 529
          goto case_33;
        }
#line 533
        if ((unsigned int )curr->w_state == 'k') {
#line 533
          goto case_107;
        }
#line 533
        if ((unsigned int )curr->w_state == '\"') {
#line 533
          goto case_107;
        }
#line 568
        if ((unsigned int )curr->w_state == (unsigned int )4) {
#line 568
          goto case_4;
        }
#line 572
        if ((unsigned int )curr->w_state == '9') {
#line 572
          goto case_57;
        }
#line 572
        if ((unsigned int )curr->w_state == '8') {
#line 572
          goto case_57;
        }
#line 572
        if ((unsigned int )curr->w_state == '7') {
#line 572
          goto case_57;
        }
#line 572
        if ((unsigned int )curr->w_state == '6') {
#line 572
          goto case_57;
        }
#line 572
        if ((unsigned int )curr->w_state == '5') {
#line 572
          goto case_57;
        }
#line 572
        if ((unsigned int )curr->w_state == '4') {
#line 572
          goto case_57;
        }
#line 572
        if ((unsigned int )curr->w_state == '3') {
#line 572
          goto case_57;
        }
#line 572
        if ((unsigned int )curr->w_state == '2') {
#line 572
          goto case_57;
        }
#line 572
        if ((unsigned int )curr->w_state == '1') {
#line 572
          goto case_57;
        }
#line 572
        if ((unsigned int )curr->w_state == '0') {
#line 572
          goto case_57;
        }
#line 581
        if ((unsigned int )curr->w_state == ':') {
#line 581
          goto case_58;
        }
#line 581
        if ((unsigned int )curr->w_state == ';') {
#line 581
          goto case_58;
        }
#line 641
        if ((unsigned int )curr->w_state == 143) {
#line 641
          goto case_143;
        }
#line 641
        if ((unsigned int )curr->w_state == 142) {
#line 641
          goto case_143;
        }
#line 641
        if ((unsigned int )curr->w_state == 141) {
#line 641
          goto case_143;
        }
#line 641
        if ((unsigned int )curr->w_state == 136) {
#line 641
          goto case_143;
        }
#line 641
        if ((unsigned int )curr->w_state == 133) {
#line 641
          goto case_143;
        }
#line 641
        if ((unsigned int )curr->w_state == 132) {
#line 641
          goto case_143;
        }
#line 644
        if ((unsigned int )curr->w_state == 155) {
#line 644
          goto case_155;
        }
#line 652
        if ((unsigned int )curr->w_state == 144) {
#line 652
          goto case_144;
        }
#line 655
        goto switch_default___7;
        case_5: /* CIL Label */ 
        {
#line 405
        if (c == '\033') {
#line 405
          goto case_27;
        }
#line 408
        goto switch_default;
        case_27: /* CIL Label */ 
#line 406
        curr->w_state = (enum state_t )6;
#line 407
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 409
        PrintChar(c);
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 411
        goto switch_break;
        case_6: /* CIL Label */ 
        {
#line 415
        if (c == '[') {
#line 415
          goto case_91;
        }
#line 418
        goto switch_default___0;
        case_91: /* CIL Label */ 
#line 416
        curr->w_state = (enum state_t )7;
#line 417
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
        {
#line 419
        PrintChar('\033');
        }
        {
#line 420
        PrintChar(c);
#line 421
        curr->w_state = (enum state_t )5;
        }
        switch_break___1: /* CIL Label */ ;
        }
#line 423
        goto switch_break;
        case_7: /* CIL Label */ 
        {
#line 427
        if (c == '4') {
#line 427
          goto case_52;
        }
#line 430
        goto switch_default___1;
        case_52: /* CIL Label */ 
#line 428
        curr->w_state = (enum state_t )8;
#line 429
        goto switch_break___2;
        switch_default___1: /* CIL Label */ 
        {
#line 431
        PrintChar('\033');
        }
        {
#line 432
        PrintChar('[');
#line 433
        PrintChar(c);
#line 434
        curr->w_state = (enum state_t )5;
        }
        switch_break___2: /* CIL Label */ ;
        }
#line 436
        goto switch_break;
        case_8: /* CIL Label */ 
        {
#line 440
        if (c == 'i') {
#line 440
          goto case_105;
        }
#line 450
        goto switch_default___2;
        case_105: /* CIL Label */ 
#line 441
        curr->w_state = (enum state_t )0;
        {
#line 442
        PrintFlush();
        }
#line 443
        if (curr->w_pdisplay) {
#line 443
          if ((curr->w_pdisplay)->d_printfd >= 0) {
            {
#line 445
            close((curr->w_pdisplay)->d_printfd);
#line 446
            (curr->w_pdisplay)->d_printfd = - 1;
            }
          }
        }
#line 448
        curr->w_pdisplay = (struct display *)0;
#line 449
        goto switch_break___3;
        switch_default___2: /* CIL Label */ 
        {
#line 451
        PrintChar('\033');
        }
        {
#line 452
        PrintChar('[');
#line 453
        PrintChar('4');
#line 454
        PrintChar(c);
#line 455
        curr->w_state = (enum state_t )5;
        }
        switch_break___3: /* CIL Label */ ;
        }
#line 457
        goto switch_break;
        case_2: /* CIL Label */ 
#line 459
        if (c == 0) {
#line 460
          goto switch_break;
        }
#line 461
        if (c == 27) {
#line 463
          curr->w_state = (enum state_t )3;
#line 464
          goto switch_break;
        }
#line 468
        if (! (((unsigned int )curr->w_StringType == 2U && c < 32) && c != 5)) {
#line 469
          if (! curr->w_c1) {
            {
            {
#line 471
            StringChar(c);
            }
            }
#line 472
            goto switch_break;
          } else
#line 469
          if (c != 156) {
            {
            {
#line 471
            StringChar(c);
            }
            }
#line 472
            goto switch_break;
          }
        }
#line 474
        c = '\\';
        case_3: /* CIL Label */ 
        {
#line 479
        if (c == '\\') {
#line 479
          goto case_92;
        }
#line 498
        if (c == '\033') {
#line 498
          goto case_27___0;
        }
#line 501
        goto switch_default___3;
        case_92: /* CIL Label */ 
        {
#line 480
        __cil_tmp15 = StringEnd();
        }
#line 480
        if (__cil_tmp15 == 0) {
#line 481
          goto switch_break___4;
        } else
#line 480
        if (len <= 1) {
#line 481
          goto switch_break___4;
        }
#line 483
        cv = curr->w_layer.l_cvlist;
        {
#line 483
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 483
          if (! cv) {
#line 483
            goto while_break___3;
          }
#line 485
          display = cv->c_display;
#line 486
          if (display->d_status == 1) {
#line 487
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 483
        cv = cv->c_lnext;
#line 489
        if (cv) {
#line 491
          if (len > 4097) {
#line 492
            len = 4097;
          }
          {
#line 493
          curr->w_outlen = len - 1;
#line 494
          bcopy((void const   *)buf, (void *)((char *)curr->w_outbuf), (size_t )(len - 1));
          }
#line 495
          return;
        }
#line 497
        goto switch_break___4;
        case_27___0: /* CIL Label */ 
        {
#line 499
        StringChar('\033');
        }
#line 500
        goto switch_break___4;
        switch_default___3: /* CIL Label */ 
#line 502
        curr->w_state = (enum state_t )2;
        {
#line 503
        StringChar('\033');
#line 504
        StringChar(c);
        }
#line 505
        goto switch_break___4;
        switch_break___4: /* CIL Label */ ;
        }
#line 507
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 511
        if (c == '[') {
#line 511
          goto case_91___0;
        }
#line 517
        if (c == ']') {
#line 517
          goto case_93;
        }
#line 520
        if (c == '_') {
#line 520
          goto case_95;
        }
#line 523
        if (c == 'P') {
#line 523
          goto case_80;
        }
#line 526
        if (c == '^') {
#line 526
          goto case_94;
        }
#line 529
        if (c == '!') {
#line 529
          goto case_33;
        }
#line 533
        if (c == 'k') {
#line 533
          goto case_107;
        }
#line 533
        if (c == '\"') {
#line 533
          goto case_107;
        }
#line 536
        goto switch_default___4;
        case_91___0: /* CIL Label */ 
#line 512
        curr->w_NumArgs = 0;
        {
#line 513
        curr->w_intermediate = 0;
#line 514
        bzero((void *)((char *)((int *)curr->w_args)), 64UL * sizeof(int ));
#line 515
        curr->w_state = (enum state_t )4;
        }
#line 516
        goto switch_break___5;
        case_93: /* CIL Label */ 
        {
#line 518
        StringStart((enum string_t )2);
        }
#line 519
        goto switch_break___5;
        case_95: /* CIL Label */ 
        {
#line 521
        StringStart((enum string_t )3);
        }
#line 522
        goto switch_break___5;
        case_80: /* CIL Label */ 
        {
#line 524
        StringStart((enum string_t )1);
        }
#line 525
        goto switch_break___5;
        case_94: /* CIL Label */ 
        {
#line 527
        StringStart((enum string_t )4);
        }
#line 528
        goto switch_break___5;
        case_33: /* CIL Label */ 
        {
#line 530
        StringStart((enum string_t )6);
        }
#line 531
        goto switch_break___5;
        case_107: /* CIL Label */ 
        case_34: /* CIL Label */ 
        {
#line 534
        StringStart((enum string_t )5);
        }
#line 535
        goto switch_break___5;
        switch_default___4: /* CIL Label */ 
        {
#line 537
        __cil_tmp16 = Special(c);
        }
#line 537
        if (__cil_tmp16) {
#line 539
          curr->w_state = (enum state_t )0;
#line 540
          goto switch_break___5;
        }
        {
#line 542
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 542
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 543
        if (c >= 32) {
#line 543
          if (c <= 47) {
#line 545
            if (curr->w_intermediate) {
#line 548
              if (curr->w_intermediate == 36) {
#line 549
                c |= 36 << 8;
              } else {
#line 552
                c = - 1;
              }
            }
#line 554
            curr->w_intermediate = c;
          } else {
#line 543
            goto _L___1004;
          }
        } else
        _L___1004: /* CIL Label */ 
#line 556
        if (c >= 48) {
#line 556
          if (c <= 126) {
            {
#line 558
            DoESC(c, curr->w_intermediate);
#line 559
            curr->w_state = (enum state_t )0;
            }
          } else {
#line 563
            curr->w_state = (enum state_t )0;
#line 564
            goto tryagain;
          }
        } else {
#line 563
          curr->w_state = (enum state_t )0;
#line 564
          goto tryagain;
        }
        switch_break___5: /* CIL Label */ ;
        }
#line 567
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 572
        if (c == '9') {
#line 572
          goto case_57;
        }
#line 572
        if (c == '8') {
#line 572
          goto case_57;
        }
#line 572
        if (c == '7') {
#line 572
          goto case_57;
        }
#line 572
        if (c == '6') {
#line 572
          goto case_57;
        }
#line 572
        if (c == '5') {
#line 572
          goto case_57;
        }
#line 572
        if (c == '4') {
#line 572
          goto case_57;
        }
#line 572
        if (c == '3') {
#line 572
          goto case_57;
        }
#line 572
        if (c == '2') {
#line 572
          goto case_57;
        }
#line 572
        if (c == '1') {
#line 572
          goto case_57;
        }
#line 572
        if (c == '0') {
#line 572
          goto case_57;
        }
#line 581
        if (c == ':') {
#line 581
          goto case_58;
        }
#line 581
        if (c == ';') {
#line 581
          goto case_58;
        }
#line 585
        goto switch_default___5;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52___0: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 573
        if (curr->w_NumArgs >= 0) {
#line 573
          if (curr->w_NumArgs < 64) {
#line 575
            if (curr->w_args[curr->w_NumArgs] < 100000000) {
#line 576
              curr->w_args[curr->w_NumArgs] = 10 * curr->w_args[curr->w_NumArgs] + (c - 48);
            }
          }
        }
#line 579
        goto switch_break___6;
        case_58: /* CIL Label */ 
        case_59: /* CIL Label */ 
#line 582
        if (curr->w_NumArgs < 64) {
#line 583
          (curr->w_NumArgs) ++;
        }
#line 584
        goto switch_break___6;
        switch_default___5: /* CIL Label */ 
        {
#line 586
        __cil_tmp18 = Special(c);
        }
#line 586
        if (__cil_tmp18) {
#line 587
          goto switch_break___6;
        }
#line 588
        if (c >= 64) {
#line 588
          if (c <= 126) {
#line 590
            if (curr->w_NumArgs < 64) {
#line 591
              (curr->w_NumArgs) ++;
            }
            {
#line 592
            DoCSI(c, curr->w_intermediate);
            }
#line 593
            if ((unsigned int )curr->w_state != 5U) {
#line 594
              curr->w_state = (enum state_t )0;
            }
          } else {
#line 588
            goto _L___1007;
          }
        } else
        _L___1007: /* CIL Label */ 
#line 596
        if (c >= 32) {
#line 596
          if (c <= 47) {
            _L___1005: /* CIL Label */ 
#line 597
            if (curr->w_intermediate) {
#line 597
              tmp = - 1;
            } else {
#line 597
              tmp = c;
            }
#line 597
            curr->w_intermediate = tmp;
          } else {
#line 596
            goto _L___1006;
          }
        } else
        _L___1006: /* CIL Label */ 
#line 596
        if (c >= 60) {
#line 596
          if (c <= 63) {
#line 596
            goto _L___1005;
          } else {
#line 600
            curr->w_state = (enum state_t )0;
#line 601
            goto tryagain;
          }
        } else {
#line 600
          curr->w_state = (enum state_t )0;
#line 601
          goto tryagain;
        }
        switch_break___6: /* CIL Label */ ;
        }
#line 604
        goto switch_break;
        switch_default___6: /* CIL Label */ 
#line 608
        if (curr->w_mbcs) {
#line 609
          if (c <= 32) {
#line 610
            curr->w_mbcs = 0;
          } else
#line 609
          if (c == 127) {
#line 610
            curr->w_mbcs = 0;
          } else
#line 609
          if (c >= 128) {
#line 609
            if (c < 160) {
#line 609
              if (curr->w_c1) {
#line 610
                curr->w_mbcs = 0;
              }
            }
          }
        }
#line 612
        if (c < 32) {
#line 614
          if (c == 27) {
#line 616
            curr->w_intermediate = 0;
#line 617
            curr->w_state = (enum state_t )1;
#line 618
            if (curr->w_autoaka < 0) {
#line 619
              curr->w_autoaka = 0;
            }
          } else {
            {
#line 622
            Special(c);
            }
          }
#line 623
          goto switch_break;
        }
#line 625
        if (c >= 128) {
#line 625
          if (c < 160) {
#line 625
            if (curr->w_c1) {
#line 627
              if (((int )curr->w_FontR & 240) != 32) {
                _L___1008: /* CIL Label */ 
                {
#line 641
                if (c == 143) {
#line 641
                  goto case_143;
                }
#line 641
                if (c == 142) {
#line 641
                  goto case_143;
                }
#line 641
                if (c == 141) {
#line 641
                  goto case_143;
                }
#line 641
                if (c == 136) {
#line 641
                  goto case_143;
                }
#line 641
                if (c == 133) {
#line 641
                  goto case_143;
                }
#line 641
                if (c == 132) {
#line 641
                  goto case_143;
                }
#line 644
                if (c == 155) {
#line 644
                  goto case_155;
                }
#line 652
                if (c == 144) {
#line 652
                  goto case_144;
                }
#line 655
                goto switch_default___7;
                case_143: /* CIL Label */ 
                case_142: /* CIL Label */ 
                case_141: /* CIL Label */ 
                case_136: /* CIL Label */ 
                case_133: /* CIL Label */ 
                case_132: /* CIL Label */ 
                {
#line 642
                DoESC(c ^ 192, 0);
                }
#line 643
                goto switch_break___7;
                case_155: /* CIL Label */ 
#line 645
                if (curr->w_autoaka < 0) {
#line 646
                  curr->w_autoaka = 0;
                }
                {
#line 647
                curr->w_NumArgs = 0;
#line 648
                curr->w_intermediate = 0;
#line 649
                bzero((void *)((char *)((int *)curr->w_args)), 64UL * sizeof(int ));
#line 650
                curr->w_state = (enum state_t )4;
                }
#line 651
                goto switch_break___7;
                case_144: /* CIL Label */ 
                {
#line 653
                StringStart((enum string_t )1);
                }
#line 654
                goto switch_break___7;
                switch_default___7: /* CIL Label */ 
#line 656
                goto switch_break___7;
                switch_break___7: /* CIL Label */ ;
                }
#line 658
                goto switch_break;
              } else
#line 627
              if (curr->w_layer.l_encoding == 8) {
#line 627
                goto _L___1008;
              }
            }
          }
        }
#line 663
        if (! curr->w_mbcs) {
#line 666
          if (c < 128) {
#line 667
            curr->w_rend.font = (unsigned char )curr->w_FontL;
          } else
#line 666
          if (curr->w_gr == 0) {
#line 667
            curr->w_rend.font = (unsigned char )curr->w_FontL;
          } else
#line 669
          if (curr->w_gr == 2) {
#line 669
            if (! curr->w_ss) {
#line 670
              curr->w_rend.font = (unsigned char )curr->w_FontE;
            } else {
#line 673
              curr->w_rend.font = (unsigned char )curr->w_FontR;
            }
          } else {
#line 673
            curr->w_rend.font = (unsigned char )curr->w_FontR;
          }
        }
#line 678
        if (curr->w_layer.l_encoding == 8) {
#line 680
          if ((int )curr->w_rend.font == 48) {
            {
#line 684
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 684
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 685
            mc.image = (unsigned char )c;
#line 686
            mc.mbcs = (unsigned char )0;
#line 687
            mc.font = (unsigned char )'0';
#line 688
            mc.fontx = (unsigned char )0;
#line 689
            mcp = recode_mchar(& mc, 0, 8);
            }
            {
#line 690
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 690
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 691
            c = (int )mcp->image | ((int )mcp->font << 8);
          }
#line 693
          curr->w_rend.font = (unsigned char )0;
        }
        {
#line 696
        __cil_tmp24 = utf8_isdouble(c);
        }
#line 696
        if (curr->w_layer.l_encoding == 8) {
#line 696
          if (__cil_tmp24) {
#line 697
            curr->w_mbcs = 255;
          }
        }
        {
#line 699
        __cil_tmp25 = utf8_iscomb(c);
        }
#line 699
        if (curr->w_layer.l_encoding == 8) {
#line 699
          if (c >= 768) {
#line 699
            if (__cil_tmp25) {
#line 704
              ox = curr->w_layer.l_x - 1;
#line 705
              oy = curr->w_layer.l_y;
#line 706
              if (ox < 0) {
#line 708
                ox = curr->w_layer.l_width - 1;
#line 709
                __cil_tmp29 = oy;
#line 709
                oy --;
              }
#line 711
              if (oy < 0) {
#line 712
                oy = 0;
              }
              {
#line 713
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 713
                omc.image = *((curr->w_mlines + oy)->image + ox);
#line 713
                omc.attr = *((curr->w_mlines + oy)->attr + ox);
#line 713
                omc.font = *((curr->w_mlines + oy)->font + ox);
#line 713
                omc.fontx = *((curr->w_mlines + oy)->fontx + ox);
#line 713
                omc.color = *((curr->w_mlines + oy)->color + ox);
#line 713
                omc.mbcs = (unsigned char )0;
#line 713
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 714
              if ((int )omc.image == 255) {
#line 714
                if ((int )omc.font == 255) {
#line 714
                  if ((int )omc.fontx == 0) {
#line 716
                    __cil_tmp30 = ox;
#line 716
                    ox --;
#line 717
                    if (ox >= 0) {
                      {
#line 719
                      while (1) {
                        while_continue___8: /* CIL Label */ ;
#line 719
                        omc.image = *((curr->w_mlines + oy)->image + ox);
#line 719
                        omc.attr = *((curr->w_mlines + oy)->attr + ox);
#line 719
                        omc.font = *((curr->w_mlines + oy)->font + ox);
#line 719
                        omc.fontx = *((curr->w_mlines + oy)->fontx + ox);
#line 719
                        omc.color = *((curr->w_mlines + oy)->color + ox);
#line 719
                        omc.mbcs = (unsigned char )0;
#line 719
                        goto while_break___8;
                      }
                      while_break___8: /* CIL Label */ ;
                      }
#line 720
                      omc.mbcs = (unsigned char )255;
                    }
                  }
                }
              }
#line 723
              if (ox >= 0) {
                {
#line 725
                utf8_handle_comb(c, & omc);
#line 726
                MFixLine(curr, oy, & omc);
                }
                {
#line 727
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 727
                  *((curr->w_mlines + oy)->image + ox) = omc.image;
#line 727
                  *((curr->w_mlines + oy)->attr + ox) = omc.attr;
#line 727
                  *((curr->w_mlines + oy)->font + ox) = omc.font;
#line 727
                  *((curr->w_mlines + oy)->fontx + ox) = omc.fontx;
#line 727
                  *((curr->w_mlines + oy)->color + ox) = omc.color;
#line 727
                  goto while_break___9;
                }
                while_break___9: /* CIL Label */ ;
                }
                {
#line 728
                LPutChar(& curr->w_layer, & omc, ox, oy);
#line 729
                LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
                }
              }
#line 731
              goto switch_break;
            }
          }
        }
#line 733
        font = (int )curr->w_rend.font;
#line 737
        if (font == 73) {
#line 737
          if (curr->w_layer.l_encoding == 2) {
#line 737
            if (curr->w_mbcs == 0) {
              {
#line 740
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 740
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
#line 741
              if (129 <= c) {
#line 741
                if (c <= 159) {
                  _L___1009: /* CIL Label */ 
                  {
#line 743
                  while (1) {
                    while_continue___11: /* CIL Label */ ;
#line 743
                    goto while_break___11;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
#line 744
                  curr->w_mbcs = c;
#line 745
                  goto switch_break;
                } else {
#line 741
                  goto _L___1010;
                }
              } else
              _L___1010: /* CIL Label */ 
#line 741
              if (224 <= c) {
#line 741
                if (c <= 239) {
#line 741
                  goto _L___1009;
                }
              }
            }
          }
        }
#line 749
        if (font == 25) {
#line 749
          if (c == 128) {
#line 749
            if (! curr->w_mbcs) {
#line 750
              curr->w_rend.font = (unsigned char )0;
#line 750
              font = (int )curr->w_rend.font;
            }
          }
        }
#line 751
        if (font) {
#line 751
          if ((font & 96) == 0) {
#line 751
            if (c == 32) {
#line 752
              curr->w_rend.font = (unsigned char )0;
#line 752
              font = (int )curr->w_rend.font;
            }
          }
        }
#line 753
        if (font) {
#line 753
          if ((font & 96) == 0) {
            _L___1011: /* CIL Label */ 
#line 755
            t = c;
#line 756
            if (curr->w_mbcs == 0) {
#line 758
              curr->w_mbcs = c;
#line 759
              goto switch_break;
            }
#line 761
            if (curr->w_layer.l_x == cols - 1) {
#line 763
              if (curr->w_wrap) {
#line 763
                tmp___0 = 1;
              } else {
#line 763
                tmp___0 = - 1;
              }
#line 763
              curr->w_layer.l_x += tmp___0;
              {
#line 764
              while (1) {
                while_continue___12: /* CIL Label */ ;
#line 764
                goto while_break___12;
              }
              while_break___12: /* CIL Label */ ;
              }
            }
#line 767
            if (curr->w_layer.l_encoding != 8) {
#line 770
              c = curr->w_mbcs;
#line 772
              if (font == 73) {
#line 772
                if (curr->w_layer.l_encoding == 2) {
                  {
#line 774
                  while (1) {
                    while_continue___13: /* CIL Label */ ;
#line 774
                    goto while_break___13;
                  }
                  while_break___13: /* CIL Label */ ;
                  }
#line 785
                  if (64 <= t) {
#line 785
                    if (t <= 252) {
#line 785
                      if (t != 127) {
#line 787
                        if (c <= 159) {
#line 787
                          c = (c - 129) * 2 + 33;
                        } else {
#line 788
                          c = (c - 193) * 2 + 33;
                        }
#line 789
                        if (t <= 126) {
#line 789
                          t -= 31;
                        } else
#line 790
                        if (t <= 158) {
#line 790
                          t -= 32;
                        } else {
#line 791
                          __cil_tmp33 = c;
#line 791
                          c ++;
#line 791
                          t -= 126;
                        }
#line 792
                        curr->w_rend.font = (unsigned char )2;
                      } else {
#line 797
                        c = t;
#line 798
                        t = 0;
                      }
                    } else {
#line 797
                      c = t;
#line 798
                      t = 0;
                    }
                  } else {
#line 797
                    c = t;
#line 798
                    t = 0;
                  }
                  {
#line 800
                  while (1) {
                    while_continue___14: /* CIL Label */ ;
#line 800
                    goto while_break___14;
                  }
                  while_break___14: /* CIL Label */ ;
                  }
                }
              }
#line 803
              if (t) {
#line 803
                if (curr->w_gr) {
#line 803
                  if (font != 24) {
#line 803
                    if (font != 25) {
#line 805
                      t &= 127;
#line 806
                      if (t < 32) {
#line 807
                        goto tryagain;
                      }
                    }
                  }
                }
              }
#line 809
              if (t == 127) {
#line 810
                goto switch_break;
              }
#line 811
              curr->w_mbcs = t;
            }
          } else {
#line 753
            goto _L___1012;
          }
        } else
        _L___1012: /* CIL Label */ 
#line 753
        if (curr->w_mbcs) {
#line 753
          goto _L___1011;
        }
#line 815
        if (font == 60) {
#line 815
          if (c >= 32) {
#line 817
            curr->w_rend.font = (unsigned char )0;
#line 817
            font = (int )curr->w_rend.font;
#line 818
            c |= 128;
          } else {
#line 815
            goto _L___1013;
          }
        } else
        _L___1013: /* CIL Label */ 
#line 821
        if (curr->w_gr) {
#line 821
          if (curr->w_layer.l_encoding != 8) {
#line 827
            if (c == 128) {
#line 827
              if (font == 0) {
#line 827
                if (curr->w_layer.l_encoding == 20) {
#line 828
                  c = 164;
                } else {
#line 830
                  c &= 127;
                }
              } else {
#line 830
                c &= 127;
              }
            } else {
#line 830
              c &= 127;
            }
#line 831
            if (c < 32) {
#line 831
              if (font != 25) {
#line 832
                goto tryagain;
              }
            }
          }
        }
#line 840
        if (c == 127) {
#line 841
          goto switch_break;
        }
#line 842
        curr->w_rend.image = (unsigned char )c;
#line 844
        if (curr->w_layer.l_encoding == 8) {
#line 846
          curr->w_rend.font = (unsigned char )(c >> 8);
#line 847
          curr->w_rend.fontx = (unsigned char )(c >> 16);
        }
#line 851
        curr->w_rend.mbcs = (unsigned char )curr->w_mbcs;
#line 853
        if (curr->w_layer.l_x < cols - 1) {
#line 855
          if (curr->w_insert) {
            {
#line 857
            while (1) {
              while_continue___15: /* CIL Label */ ;
              {
#line 857
              bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->image),
                    (void *)((char *)mline_old.image), (size_t )cols);
#line 857
              bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->attr),
                    (void *)((char *)mline_old.attr), (size_t )cols);
#line 857
              bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->font),
                    (void *)((char *)mline_old.font), (size_t )cols);
#line 857
              bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->fontx),
                    (void *)((char *)mline_old.fontx), (size_t )cols);
#line 857
              bcopy((void const   *)((char *)(curr->w_mlines + curr->w_layer.l_y)->color),
                    (void *)((char *)mline_old.color), (size_t )cols);
              }
#line 857
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
            {
#line 858
            MInsChar(curr, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 859
            LInsChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y,
                     & mline_old);
#line 860
            (curr->w_layer.l_x) ++;
            }
          } else {
            {
#line 864
            MPutChar(curr, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 865
            LPutChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 866
            (curr->w_layer.l_x) ++;
            }
          }
        } else
#line 869
        if (curr->w_layer.l_x == cols - 1) {
          {
#line 871
          MPutChar(curr, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
#line 872
          LPutChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_x, curr->w_layer.l_y);
          }
#line 873
          if (curr->w_wrap) {
#line 874
            (curr->w_layer.l_x) ++;
          }
        } else {
          {
#line 878
          MWrapChar(curr, & curr->w_rend, curr->w_layer.l_y, curr->w_top, curr->w_bot,
                    curr->w_insert);
#line 879
          LWrapChar(& curr->w_layer, & curr->w_rend, curr->w_layer.l_y, curr->w_top,
                    curr->w_bot, curr->w_insert);
          }
#line 880
          if (curr->w_layer.l_y != curr->w_bot) {
#line 880
            if (curr->w_layer.l_y != curr->w_layer.l_height - 1) {
#line 881
              (curr->w_layer.l_y) ++;
            }
          }
#line 882
          curr->w_layer.l_x = 1;
        }
#line 886
        if (curr->w_mbcs) {
#line 888
          curr->w_mbcs = 0;
#line 888
          curr->w_rend.mbcs = (unsigned char )curr->w_mbcs;
#line 889
          (curr->w_layer.l_x) ++;
        }
#line 892
        if (curr->w_ss) {
          {
#line 894
          curr->w_FontL = (char )curr->w_charsets[curr->w_Charset];
#line 895
          curr->w_FontR = (char )curr->w_charsets[curr->w_CharsetR];
#line 896
          curr->w_rend.font = (unsigned char )curr->w_FontL;
#line 897
          LSetRendition(& curr->w_layer, & curr->w_rend);
#line 898
          curr->w_ss = 0;
          }
        }
#line 901
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 329
        if (! len) {
#line 329
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 906
  if (! printcmd) {
#line 906
    if ((unsigned int )curr->w_state == 5U) {
      {
#line 907
      PrintFlush();
      }
    }
  }
  return;
}
}
#line 911 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void WLogString(struct win *p , char *buf , int len ) 
{ 
  char *t ;
  char *__cil_tmp5 ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  int *__cil_tmp8 ;

  {
#line 916
  if (! p->w_log) {
#line 917
    return;
  }
#line 918
  if (logtstamp_on) {
#line 918
    if (p->w_logsilence >= logtstamp_after * 2) {
      {
#line 920
      __cil_tmp5 = MakeWinMsg(logtstamp_string, p, '%');
#line 920
      t = __cil_tmp5;
#line 921
      __cil_tmp6 = strlen((char const   *)t);
#line 921
      logfwrite(p->w_log, t, (int )__cil_tmp6);
      }
    }
  }
  {
#line 923
  p->w_logsilence = 0;
#line 924
  __cil_tmp7 = logfwrite(p->w_log, buf, len);
  }
#line 924
  if (__cil_tmp7 < 1) {
    {
#line 926
    __cil_tmp8 = __errno_location();
#line 926
    WMsg(p, *__cil_tmp8, (char *)"Error writing logfile");
#line 927
    logfclose(p->w_log);
#line 928
    p->w_log = (struct logfile *)0;
    }
  }
#line 930
  if (! log_flush) {
    {
#line 931
    logfflush(p->w_log);
    }
  }
  return;
}
}
#line 935 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static int Special(int c ) 
{ 


  {
  {
#line 940
  if (c == '\b') {
#line 940
    goto case_8;
  }
#line 943
  if (c == '\r') {
#line 943
    goto case_13;
  }
#line 946
  if (c == '\n') {
#line 946
    goto case_10;
  }
#line 949
  if (c == '\v') {
#line 949
    goto case_11;
  }
#line 952
  if (c == '\a') {
#line 952
    goto case_7;
  }
#line 955
  if (c == '\t') {
#line 955
    goto case_9;
  }
#line 959
  if (c == '\017') {
#line 959
    goto case_15;
  }
#line 962
  if (c == '\016') {
#line 962
    goto case_14;
  }
#line 938
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 941
  BackSpace();
  }
#line 942
  return (1);
  case_13: /* CIL Label */ 
  {
#line 944
  Return();
  }
#line 945
  return (1);
  case_10: /* CIL Label */ 
#line 947
  if (curr->w_autoaka) {
    {
#line 948
    FindAKA();
    }
  }
  case_11: /* CIL Label */ 
  {
#line 950
  LineFeed(0);
  }
#line 951
  return (1);
  case_7: /* CIL Label */ 
  {
#line 953
  WBell(curr, visual_bell);
  }
#line 954
  return (1);
  case_9: /* CIL Label */ 
  {
#line 956
  ForwardTab();
  }
#line 957
  return (1);
  case_15: /* CIL Label */ 
  {
#line 960
  MapCharset(0);
  }
#line 961
  return (1);
  case_14: /* CIL Label */ 
  {
#line 963
  MapCharset(1);
  }
#line 964
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 967
  return (0);
}
}
#line 971 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void DoESC(int c , int intermediate ) 
{ 


  {
  {
#line 974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 974
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 977
  if (intermediate == 0) {
#line 977
    goto case_0;
  }
#line 980
  if (intermediate == 'E') {
#line 980
    goto case_69;
  }
#line 983
  if (intermediate == 'D') {
#line 983
    goto case_68;
  }
#line 986
  if (intermediate == 'M') {
#line 986
    goto case_77;
  }
#line 989
  if (intermediate == 'H') {
#line 989
    goto case_72;
  }
#line 992
  if (intermediate == 'Z') {
#line 992
    goto case_90;
  }
#line 995
  if (intermediate == '7') {
#line 995
    goto case_55;
  }
#line 998
  if (intermediate == '8') {
#line 998
    goto case_56;
  }
#line 1001
  if (intermediate == 'c') {
#line 1001
    goto case_99;
  }
#line 1016
  if (intermediate == '=') {
#line 1016
    goto case_61;
  }
#line 1022
  if (intermediate == '>') {
#line 1022
    goto case_62;
  }
#line 1029
  if (intermediate == 'n') {
#line 1029
    goto case_110;
  }
#line 1032
  if (intermediate == 'o') {
#line 1032
    goto case_111;
  }
#line 1035
  if (intermediate == '~') {
#line 1035
    goto case_126;
  }
#line 1039
  if (intermediate == '}') {
#line 1039
    goto case_125;
  }
#line 1042
  if (intermediate == '|') {
#line 1042
    goto case_124;
  }
#line 1045
  if (intermediate == 'N') {
#line 1045
    goto case_78;
  }
#line 1052
  if (intermediate == 'O') {
#line 1052
    goto case_79;
  }
#line 1060
  if (intermediate == 'g') {
#line 1060
    goto case_103;
  }
#line 1065
  if (intermediate == '#') {
#line 1065
    goto case_35;
  }
#line 1068
  if (intermediate == '8') {
#line 1068
    goto case_56___0;
  }
#line 1074
  if (intermediate == '(') {
#line 1074
    goto case_40;
  }
#line 1077
  if (intermediate == ')') {
#line 1077
    goto case_41;
  }
#line 1080
  if (intermediate == '*') {
#line 1080
    goto case_42;
  }
#line 1083
  if (intermediate == '+') {
#line 1083
    goto case_43;
  }
#line 1095
  if (intermediate == ((36 << 8) | 40)) {
#line 1095
    goto case_exp;
  }
#line 1095
  if (intermediate == '$') {
#line 1095
    goto case_exp;
  }
#line 1098
  if (intermediate == ((36 << 8) | 41)) {
#line 1098
    goto case_exp___0;
  }
#line 1101
  if (intermediate == ((36 << 8) | 42)) {
#line 1101
    goto case_exp___1;
  }
#line 1104
  if (intermediate == ((36 << 8) | 43)) {
#line 1104
    goto case_exp___2;
  }
#line 975
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 980
  if (c == 'E') {
#line 980
    goto case_69;
  }
#line 983
  if (c == 'D') {
#line 983
    goto case_68;
  }
#line 986
  if (c == 'M') {
#line 986
    goto case_77;
  }
#line 989
  if (c == 'H') {
#line 989
    goto case_72;
  }
#line 992
  if (c == 'Z') {
#line 992
    goto case_90;
  }
#line 995
  if (c == '7') {
#line 995
    goto case_55;
  }
#line 998
  if (c == '8') {
#line 998
    goto case_56;
  }
#line 1001
  if (c == 'c') {
#line 1001
    goto case_99;
  }
#line 1016
  if (c == '=') {
#line 1016
    goto case_61;
  }
#line 1022
  if (c == '>') {
#line 1022
    goto case_62;
  }
#line 1029
  if (c == 'n') {
#line 1029
    goto case_110;
  }
#line 1032
  if (c == 'o') {
#line 1032
    goto case_111;
  }
#line 1035
  if (c == '~') {
#line 1035
    goto case_126;
  }
#line 1039
  if (c == '}') {
#line 1039
    goto case_125;
  }
#line 1042
  if (c == '|') {
#line 1042
    goto case_124;
  }
#line 1045
  if (c == 'N') {
#line 1045
    goto case_78;
  }
#line 1052
  if (c == 'O') {
#line 1052
    goto case_79;
  }
#line 1060
  if (c == 'g') {
#line 1060
    goto case_103;
  }
#line 978
  goto switch_break___0;
  case_69: /* CIL Label */ 
  {
#line 981
  LineFeed(1);
  }
#line 982
  goto switch_break___0;
  case_68: /* CIL Label */ 
  {
#line 984
  LineFeed(0);
  }
#line 985
  goto switch_break___0;
  case_77: /* CIL Label */ 
  {
#line 987
  ReverseLineFeed();
  }
#line 988
  goto switch_break___0;
  case_72: /* CIL Label */ 
#line 990
  *(curr->w_tabs + curr->w_layer.l_x) = (char )1;
#line 991
  goto switch_break___0;
  case_90: /* CIL Label */ 
  {
#line 993
  Report((char *)"\033[?%d;%dc", 1, 2);
  }
#line 994
  goto switch_break___0;
  case_55: /* CIL Label */ 
  {
#line 996
  SaveCursor(& curr->w_saved);
  }
#line 997
  goto switch_break___0;
  case_56: /* CIL Label */ 
  {
#line 999
  RestoreCursor(& curr->w_saved);
  }
#line 1000
  goto switch_break___0;
  case_99: /* CIL Label */ 
  {
#line 1002
  ClearScreen();
  }
  {
#line 1003
  ResetWindow(curr);
#line 1004
  LKeypadMode(& curr->w_layer, 0);
#line 1005
  LCursorkeysMode(& curr->w_layer, 0);
#line 1014
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1015
  goto switch_break___0;
  case_61: /* CIL Label */ 
  {
#line 1017
  curr->w_keypad = 1;
#line 1017
  LKeypadMode(& curr->w_layer, curr->w_keypad);
  }
#line 1021
  goto switch_break___0;
  case_62: /* CIL Label */ 
  {
#line 1023
  curr->w_keypad = 0;
#line 1023
  LKeypadMode(& curr->w_layer, curr->w_keypad);
  }
#line 1027
  goto switch_break___0;
  case_110: /* CIL Label */ 
  {
#line 1030
  MapCharset(2);
  }
#line 1031
  goto switch_break___0;
  case_111: /* CIL Label */ 
  {
#line 1033
  MapCharset(3);
  }
#line 1034
  goto switch_break___0;
  case_126: /* CIL Label */ 
  {
#line 1036
  MapCharsetR(1);
  }
#line 1037
  goto switch_break___0;
  case_125: /* CIL Label */ 
  {
#line 1040
  MapCharsetR(2);
  }
#line 1041
  goto switch_break___0;
  case_124: /* CIL Label */ 
  {
#line 1043
  MapCharsetR(3);
  }
#line 1044
  goto switch_break___0;
  case_78: /* CIL Label */ 
#line 1046
  if (curr->w_charsets[curr->w_Charset] != curr->w_charsets[2]) {
#line 1048
    curr->w_ss = 2;
#line 1048
    curr->w_FontL = (char )curr->w_charsets[curr->w_ss];
#line 1048
    curr->w_FontR = curr->w_FontL;
  } else
#line 1046
  if (curr->w_charsets[curr->w_CharsetR] != curr->w_charsets[2]) {
#line 1048
    curr->w_ss = 2;
#line 1048
    curr->w_FontL = (char )curr->w_charsets[curr->w_ss];
#line 1048
    curr->w_FontR = curr->w_FontL;
  } else {
#line 1050
    curr->w_ss = 0;
  }
#line 1051
  goto switch_break___0;
  case_79: /* CIL Label */ 
#line 1053
  if (curr->w_charsets[curr->w_Charset] != curr->w_charsets[3]) {
#line 1055
    curr->w_ss = 3;
#line 1055
    curr->w_FontL = (char )curr->w_charsets[curr->w_ss];
#line 1055
    curr->w_FontR = curr->w_FontL;
  } else
#line 1053
  if (curr->w_charsets[curr->w_CharsetR] != curr->w_charsets[3]) {
#line 1055
    curr->w_ss = 3;
#line 1055
    curr->w_FontL = (char )curr->w_charsets[curr->w_ss];
#line 1055
    curr->w_FontR = curr->w_FontL;
  } else {
#line 1057
    curr->w_ss = 0;
  }
#line 1058
  goto switch_break___0;
  case_103: /* CIL Label */ 
  {
#line 1061
  WBell(curr, 1);
  }
#line 1062
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1064
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 1068
  if (c == '8') {
#line 1068
    goto case_56___0;
  }
#line 1066
  goto switch_break___1;
  case_56___0: /* CIL Label */ 
  {
#line 1069
  FillWithEs();
  }
#line 1070
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1072
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 1075
  DesignateCharset(c, 0);
  }
#line 1076
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 1078
  DesignateCharset(c, 1);
  }
#line 1079
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 1081
  DesignateCharset(c, 2);
  }
#line 1082
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 1084
  DesignateCharset(c, 3);
  }
#line 1085
  goto switch_break;
  case_exp: /* CIL Label */ 
  case_36: /* CIL Label */ 
  {
#line 1096
  DesignateCharset(c & 31, 0);
  }
#line 1097
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  {
#line 1099
  DesignateCharset(c & 31, 1);
  }
#line 1100
  goto switch_break;
  case_exp___1: /* CIL Label */ 
  {
#line 1102
  DesignateCharset(c & 31, 2);
  }
#line 1103
  goto switch_break;
  case_exp___2: /* CIL Label */ 
  {
#line 1105
  DesignateCharset(c & 31, 3);
  }
#line 1106
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1113 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void DoCSI(int c , int intermediate ) 
{ 
  register int i ;
  register int a1 ;
  register int a2 ;
  int tmp ;
  int tmp___1014 ;
  int tmp___1015 ;
  int tmp___1016 ;
  int tmp___1017 ;
  int tmp___1018 ;
  int tmp___1019 ;
  int tmp___1020 ;
  int tmp___1021 ;
  int tmp___1022 ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int tmp___1023 ;
  int tmp___1024 ;
  int tmp___1025 ;
  int tmp___1026 ;
  int tmp___1027 ;
  int tmp___1028 ;
  int tmp___1029 ;
  int tmp___1030 ;
  int tmp___1031 ;
  int tmp___1032 ;
  int tmp___1033 ;
  int tmp___1034 ;

  {
#line 1116
  a1 = curr->w_args[0];
#line 1116
  a2 = curr->w_args[1];
#line 1118
  if (curr->w_NumArgs > 64) {
#line 1119
    curr->w_NumArgs = 64;
  }
  {
#line 1122
  if (intermediate == 0) {
#line 1122
    goto case_0;
  }
#line 1126
  if (intermediate == 'f') {
#line 1126
    goto case_102;
  }
#line 1126
  if (intermediate == 'H') {
#line 1126
    goto case_102;
  }
#line 1143
  if (intermediate == 'J') {
#line 1143
    goto case_74;
  }
#line 1148
  if (intermediate == 0) {
#line 1148
    goto case_0___0;
  }
#line 1151
  if (intermediate == 1) {
#line 1151
    goto case_1;
  }
#line 1154
  if (intermediate == 2) {
#line 1154
    goto case_2;
  }
#line 1160
  if (intermediate == 'K') {
#line 1160
    goto case_75;
  }
#line 1165
  if (intermediate == 0) {
#line 1165
    goto case_0___1;
  }
#line 1168
  if (intermediate == 1) {
#line 1168
    goto case_1___0;
  }
#line 1171
  if (intermediate == 2) {
#line 1171
    goto case_2___0;
  }
#line 1176
  if (intermediate == 'X') {
#line 1176
    goto case_88;
  }
#line 1180
  if (intermediate == 'A') {
#line 1180
    goto case_65;
  }
#line 1183
  if (intermediate == 'B') {
#line 1183
    goto case_66;
  }
#line 1186
  if (intermediate == 'C') {
#line 1186
    goto case_67;
  }
#line 1189
  if (intermediate == 'D') {
#line 1189
    goto case_68;
  }
#line 1192
  if (intermediate == 'E') {
#line 1192
    goto case_69;
  }
#line 1196
  if (intermediate == 'F') {
#line 1196
    goto case_70;
  }
#line 1201
  if (intermediate == '`') {
#line 1201
    goto case_96;
  }
#line 1201
  if (intermediate == 'G') {
#line 1201
    goto case_96;
  }
#line 1207
  if (intermediate == 'd') {
#line 1207
    goto case_100;
  }
#line 1213
  if (intermediate == 'm') {
#line 1213
    goto case_109;
  }
#line 1216
  if (intermediate == 'g') {
#line 1216
    goto case_103;
  }
#line 1222
  if (intermediate == 'r') {
#line 1222
    goto case_114;
  }
#line 1241
  if (intermediate == 's') {
#line 1241
    goto case_115;
  }
#line 1244
  if (intermediate == 't') {
#line 1244
    goto case_116;
  }
#line 1247
  if (intermediate == 11) {
#line 1247
    goto case_11;
  }
#line 1253
  if (intermediate == 7) {
#line 1253
    goto case_7;
  }
#line 1256
  if (intermediate == 21) {
#line 1256
    goto case_21;
  }
#line 1266
  if (intermediate == 8) {
#line 1266
    goto case_8;
  }
#line 1282
  if (intermediate == 'u') {
#line 1282
    goto case_117;
  }
#line 1285
  if (intermediate == 'I') {
#line 1285
    goto case_73;
  }
#line 1291
  if (intermediate == 'Z') {
#line 1291
    goto case_90;
  }
#line 1297
  if (intermediate == 'L') {
#line 1297
    goto case_76;
  }
#line 1300
  if (intermediate == 'M') {
#line 1300
    goto case_77;
  }
#line 1303
  if (intermediate == 'P') {
#line 1303
    goto case_80;
  }
#line 1306
  if (intermediate == '@') {
#line 1306
    goto case_64;
  }
#line 1309
  if (intermediate == 'h') {
#line 1309
    goto case_104;
  }
#line 1312
  if (intermediate == 'l') {
#line 1312
    goto case_108;
  }
#line 1315
  if (intermediate == 'i') {
#line 1315
    goto case_105;
  }
#line 1319
  if (intermediate == 'n') {
#line 1319
    goto case_110;
  }
#line 1325
  if (intermediate == 'c') {
#line 1325
    goto case_99;
  }
#line 1329
  if (intermediate == 'x') {
#line 1329
    goto case_120;
  }
#line 1333
  if (intermediate == 'p') {
#line 1333
    goto case_112;
  }
#line 1340
  if (intermediate == 'S') {
#line 1340
    goto case_83;
  }
#line 1344
  if (intermediate == '^') {
#line 1344
    goto case_94;
  }
#line 1344
  if (intermediate == 'T') {
#line 1344
    goto case_94;
  }
#line 1349
  if (intermediate == '?') {
#line 1349
    goto case_63;
  }
#line 1359
  if (intermediate == 1) {
#line 1359
    goto case_1___1;
  }
#line 1365
  if (intermediate == 2) {
#line 1365
    goto case_2___1;
  }
#line 1382
  if (intermediate == 3) {
#line 1382
    goto case_3;
  }
#line 1392
  if (intermediate == 5) {
#line 1392
    goto case_5;
  }
#line 1397
  if (intermediate == 6) {
#line 1397
    goto case_6;
  }
#line 1407
  if (intermediate == 7) {
#line 1407
    goto case_7___0;
  }
#line 1412
  if (intermediate == 9) {
#line 1412
    goto case_9;
  }
#line 1423
  if (intermediate == 25) {
#line 1423
    goto case_25;
  }
#line 1436
  if (intermediate == 1049) {
#line 1436
    goto case_1049;
  }
#line 1436
  if (intermediate == 1047) {
#line 1436
    goto case_1049;
  }
#line 1436
  if (intermediate == 47) {
#line 1436
    goto case_1049;
  }
#line 1459
  if (intermediate == 1048) {
#line 1459
    goto case_1048;
  }
#line 1470
  if (intermediate == 1003) {
#line 1470
    goto case_1003;
  }
#line 1470
  if (intermediate == 1002) {
#line 1470
    goto case_1003;
  }
#line 1470
  if (intermediate == 1001) {
#line 1470
    goto case_1003;
  }
#line 1470
  if (intermediate == 1000) {
#line 1470
    goto case_1003;
  }
#line 1475
  if (intermediate == 1006) {
#line 1475
    goto case_1006;
  }
#line 1483
  if (intermediate == '>') {
#line 1483
    goto case_62;
  }
#line 1486
  if (intermediate == 'c') {
#line 1486
    goto case_99___0;
  }
#line 1278
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1126
  if (c == 'f') {
#line 1126
    goto case_102;
  }
#line 1126
  if (c == 'H') {
#line 1126
    goto case_102;
  }
#line 1143
  if (c == 'J') {
#line 1143
    goto case_74;
  }
#line 1148
  if (c == 0) {
#line 1148
    goto case_0___0;
  }
#line 1151
  if (c == 1) {
#line 1151
    goto case_1;
  }
#line 1154
  if (c == 2) {
#line 1154
    goto case_2;
  }
#line 1160
  if (c == 'K') {
#line 1160
    goto case_75;
  }
#line 1165
  if (c == 0) {
#line 1165
    goto case_0___1;
  }
#line 1168
  if (c == 1) {
#line 1168
    goto case_1___0;
  }
#line 1171
  if (c == 2) {
#line 1171
    goto case_2___0;
  }
#line 1176
  if (c == 'X') {
#line 1176
    goto case_88;
  }
#line 1180
  if (c == 'A') {
#line 1180
    goto case_65;
  }
#line 1183
  if (c == 'B') {
#line 1183
    goto case_66;
  }
#line 1186
  if (c == 'C') {
#line 1186
    goto case_67;
  }
#line 1189
  if (c == 'D') {
#line 1189
    goto case_68;
  }
#line 1192
  if (c == 'E') {
#line 1192
    goto case_69;
  }
#line 1196
  if (c == 'F') {
#line 1196
    goto case_70;
  }
#line 1201
  if (c == '`') {
#line 1201
    goto case_96;
  }
#line 1201
  if (c == 'G') {
#line 1201
    goto case_96;
  }
#line 1207
  if (c == 'd') {
#line 1207
    goto case_100;
  }
#line 1213
  if (c == 'm') {
#line 1213
    goto case_109;
  }
#line 1216
  if (c == 'g') {
#line 1216
    goto case_103;
  }
#line 1222
  if (c == 'r') {
#line 1222
    goto case_114;
  }
#line 1241
  if (c == 's') {
#line 1241
    goto case_115;
  }
#line 1244
  if (c == 't') {
#line 1244
    goto case_116;
  }
#line 1247
  if (c == 11) {
#line 1247
    goto case_11;
  }
#line 1253
  if (c == 7) {
#line 1253
    goto case_7;
  }
#line 1256
  if (c == 21) {
#line 1256
    goto case_21;
  }
#line 1266
  if (c == 8) {
#line 1266
    goto case_8;
  }
#line 1282
  if (c == 'u') {
#line 1282
    goto case_117;
  }
#line 1285
  if (c == 'I') {
#line 1285
    goto case_73;
  }
#line 1291
  if (c == 'Z') {
#line 1291
    goto case_90;
  }
#line 1297
  if (c == 'L') {
#line 1297
    goto case_76;
  }
#line 1300
  if (c == 'M') {
#line 1300
    goto case_77;
  }
#line 1303
  if (c == 'P') {
#line 1303
    goto case_80;
  }
#line 1306
  if (c == '@') {
#line 1306
    goto case_64;
  }
#line 1309
  if (c == 'h') {
#line 1309
    goto case_104;
  }
#line 1312
  if (c == 'l') {
#line 1312
    goto case_108;
  }
#line 1315
  if (c == 'i') {
#line 1315
    goto case_105;
  }
#line 1319
  if (c == 'n') {
#line 1319
    goto case_110;
  }
#line 1325
  if (c == 'c') {
#line 1325
    goto case_99;
  }
#line 1329
  if (c == 'x') {
#line 1329
    goto case_120;
  }
#line 1333
  if (c == 'p') {
#line 1333
    goto case_112;
  }
#line 1340
  if (c == 'S') {
#line 1340
    goto case_83;
  }
#line 1344
  if (c == '^') {
#line 1344
    goto case_94;
  }
#line 1344
  if (c == 'T') {
#line 1344
    goto case_94;
  }
#line 1278
  goto switch_default;
  case_102: /* CIL Label */ 
  case_72: /* CIL Label */ 
#line 1127
  if (a1 < 1) {
#line 1128
    a1 = 1;
  }
#line 1129
  if (curr->w_origin) {
#line 1130
    a1 += curr->w_top;
  }
#line 1131
  if (a1 > rows) {
#line 1132
    a1 = rows;
  }
#line 1133
  if (a2 < 1) {
#line 1134
    a2 = 1;
  }
#line 1135
  if (a2 > cols) {
#line 1136
    a2 = cols;
  }
#line 1137
  a2 --;
  {
#line 1137
  a1 --;
#line 1137
  LGotoPos(& curr->w_layer, a2, a1);
#line 1138
  curr->w_layer.l_x = a2;
#line 1139
  curr->w_layer.l_y = a1;
  }
#line 1140
  if (curr->w_autoaka) {
#line 1141
    curr->w_autoaka = a1 + 1;
  }
#line 1142
  goto switch_break___0;
  case_74: /* CIL Label */ 
#line 1144
  if (a1 < 0) {
#line 1145
    a1 = 0;
  } else
#line 1144
  if (a1 > 2) {
#line 1145
    a1 = 0;
  }
  {
#line 1148
  if (a1 == 0) {
#line 1148
    goto case_0___0;
  }
#line 1151
  if (a1 == 1) {
#line 1151
    goto case_1;
  }
#line 1154
  if (a1 == 2) {
#line 1154
    goto case_2;
  }
#line 1146
  goto switch_break___1;
  case_0___0: /* CIL Label */ 
  {
#line 1149
  ClearToEOS();
  }
#line 1150
  goto switch_break___1;
  case_1: /* CIL Label */ 
  {
#line 1152
  ClearFromBOS();
  }
#line 1153
  goto switch_break___1;
  case_2: /* CIL Label */ 
  {
#line 1155
  ClearScreen();
  }
  {
#line 1156
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1157
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1159
  goto switch_break___0;
  case_75: /* CIL Label */ 
#line 1161
  if (a1 < 0) {
#line 1162
    a1 %= 3;
  } else
#line 1161
  if (a1 > 2) {
#line 1162
    a1 %= 3;
  }
  {
#line 1165
  if (a1 == 0) {
#line 1165
    goto case_0___1;
  }
#line 1168
  if (a1 == 1) {
#line 1168
    goto case_1___0;
  }
#line 1171
  if (a1 == 2) {
#line 1171
    goto case_2___0;
  }
#line 1163
  goto switch_break___2;
  case_0___1: /* CIL Label */ 
  {
#line 1166
  ClearLineRegion(curr->w_layer.l_x, cols - 1);
  }
#line 1167
  goto switch_break___2;
  case_1___0: /* CIL Label */ 
  {
#line 1169
  ClearLineRegion(0, curr->w_layer.l_x);
  }
#line 1170
  goto switch_break___2;
  case_2___0: /* CIL Label */ 
  {
#line 1172
  ClearLineRegion(0, cols - 1);
  }
#line 1173
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 1175
  goto switch_break___0;
  case_88: /* CIL Label */ 
#line 1177
  if (a1) {
#line 1177
    tmp = a1 - 1;
  } else {
#line 1177
    tmp = 0;
  }
#line 1177
  a1 = curr->w_layer.l_x + tmp;
#line 1178
  if (a1 < cols) {
#line 1178
    tmp___1014 = a1;
  } else {
#line 1178
    tmp___1014 = cols - 1;
  }
  {
#line 1178
  ClearLineRegion(curr->w_layer.l_x, tmp___1014);
  }
#line 1179
  goto switch_break___0;
  case_65: /* CIL Label */ 
#line 1181
  if (a1) {
#line 1181
    tmp___1015 = a1;
  } else {
#line 1181
    tmp___1015 = 1;
  }
  {
#line 1181
  CursorUp(tmp___1015);
  }
#line 1182
  goto switch_break___0;
  case_66: /* CIL Label */ 
#line 1184
  if (a1) {
#line 1184
    tmp___1016 = a1;
  } else {
#line 1184
    tmp___1016 = 1;
  }
  {
#line 1184
  CursorDown(tmp___1016);
  }
#line 1185
  goto switch_break___0;
  case_67: /* CIL Label */ 
#line 1187
  if (a1) {
#line 1187
    tmp___1017 = a1;
  } else {
#line 1187
    tmp___1017 = 1;
  }
  {
#line 1187
  CursorRight(tmp___1017);
  }
#line 1188
  goto switch_break___0;
  case_68: /* CIL Label */ 
#line 1190
  if (a1) {
#line 1190
    tmp___1018 = a1;
  } else {
#line 1190
    tmp___1018 = 1;
  }
  {
#line 1190
  CursorLeft(tmp___1018);
  }
#line 1191
  goto switch_break___0;
  case_69: /* CIL Label */ 
#line 1193
  curr->w_layer.l_x = 0;
#line 1194
  if (a1) {
#line 1194
    tmp___1019 = a1;
  } else {
#line 1194
    tmp___1019 = 1;
  }
  {
#line 1194
  CursorDown(tmp___1019);
  }
#line 1195
  goto switch_break___0;
  case_70: /* CIL Label */ 
#line 1197
  curr->w_layer.l_x = 0;
#line 1198
  if (a1) {
#line 1198
    tmp___1020 = a1;
  } else {
#line 1198
    tmp___1020 = 1;
  }
  {
#line 1198
  CursorUp(tmp___1020);
  }
#line 1199
  goto switch_break___0;
  case_96: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 1202
  if (a1) {
#line 1202
    tmp___1021 = a1 - 1;
  } else {
#line 1202
    tmp___1021 = 0;
  }
#line 1202
  curr->w_layer.l_x = tmp___1021;
#line 1203
  if (curr->w_layer.l_x >= cols) {
#line 1204
    curr->w_layer.l_x = cols - 1;
  }
  {
#line 1205
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1206
  goto switch_break___0;
  case_100: /* CIL Label */ 
#line 1208
  if (a1) {
#line 1208
    tmp___1022 = a1 - 1;
  } else {
#line 1208
    tmp___1022 = 0;
  }
#line 1208
  curr->w_layer.l_y = tmp___1022;
#line 1209
  if (curr->w_layer.l_y >= rows) {
#line 1210
    curr->w_layer.l_y = rows - 1;
  }
  {
#line 1211
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1212
  goto switch_break___0;
  case_109: /* CIL Label */ 
  {
#line 1214
  SelectRendition();
  }
#line 1215
  goto switch_break___0;
  case_103: /* CIL Label */ 
#line 1217
  if (a1 == 0) {
#line 1218
    *(curr->w_tabs + curr->w_layer.l_x) = (char )0;
  } else
#line 1219
  if (a1 == 3) {
    {
#line 1220
    bzero((void *)curr->w_tabs, (unsigned long )cols);
    }
  }
#line 1221
  goto switch_break___0;
  case_114: /* CIL Label */ 
#line 1223
  if (! a1) {
#line 1224
    a1 = 1;
  }
#line 1225
  if (! a2) {
#line 1226
    a2 = rows;
  }
#line 1227
  if (a1 < 1) {
#line 1228
    goto switch_break___0;
  } else
#line 1227
  if (a2 > rows) {
#line 1228
    goto switch_break___0;
  } else
#line 1227
  if (a1 >= a2) {
#line 1228
    goto switch_break___0;
  }
#line 1229
  curr->w_top = a1 - 1;
#line 1230
  curr->w_bot = a2 - 1;
#line 1232
  if (curr->w_origin) {
#line 1234
    curr->w_layer.l_y = curr->w_top;
#line 1235
    curr->w_layer.l_x = 0;
  } else {
#line 1238
    curr->w_layer.l_x = 0;
#line 1238
    curr->w_layer.l_y = curr->w_layer.l_x;
  }
  {
#line 1239
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
#line 1240
  goto switch_break___0;
  case_115: /* CIL Label */ 
  {
#line 1242
  SaveCursor(& curr->w_saved);
  }
#line 1243
  goto switch_break___0;
  case_116: /* CIL Label */ 
  {
#line 1247
  if (a1 == 11) {
#line 1247
    goto case_11;
  }
#line 1253
  if (a1 == 7) {
#line 1253
    goto case_7;
  }
#line 1256
  if (a1 == 21) {
#line 1256
    goto case_21;
  }
#line 1266
  if (a1 == 8) {
#line 1266
    goto case_8;
  }
#line 1278
  goto switch_default;
  case_11: /* CIL Label */ 
#line 1248
  if (curr->w_layer.l_cvlist) {
    {
#line 1249
    Report((char *)"\033[1t", 0, 0);
    }
  } else {
    {
#line 1251
    Report((char *)"\033[2t", 0, 0);
    }
  }
#line 1252
  goto switch_break___3;
  case_7: /* CIL Label */ 
  {
#line 1254
  LRefreshAll(& curr->w_layer, 0);
  }
#line 1255
  goto switch_break___3;
  case_21: /* CIL Label */ 
  {
#line 1257
  __cil_tmp16 = strlen((char const   *)curr->w_title);
#line 1257
  a1 = (int )__cil_tmp16;
  }
#line 1258
  if ((unsigned long )((unsigned int )((curr->w_inlen + 5) + a1)) <= sizeof(curr->w_inbuf)) {
    {
#line 1260
    bcopy((void const   *)((char *)"\033]l"), (void *)((char *)curr->w_inbuf + curr->w_inlen),
          (size_t )3);
#line 1261
    bcopy((void const   *)curr->w_title, (void *)(((char *)curr->w_inbuf + curr->w_inlen) + 3),
          (size_t )a1);
#line 1262
    bcopy((void const   *)((char *)"\033\\"), (void *)((((char *)curr->w_inbuf + curr->w_inlen) + 3) + a1),
          (size_t )2);
#line 1263
    curr->w_inlen += 5 + a1;
    }
  }
#line 1265
  goto switch_break___3;
  case_8: /* CIL Label */ 
#line 1267
  a1 = curr->w_args[2];
#line 1268
  if (a1 < 1) {
#line 1269
    a1 = curr->w_layer.l_width;
  }
#line 1270
  if (a2 < 1) {
#line 1271
    a2 = curr->w_layer.l_height;
  }
#line 1272
  if (a1 > 10000) {
#line 1273
    goto switch_break___3;
  } else
#line 1272
  if (a2 > 10000) {
#line 1273
    goto switch_break___3;
  }
  {
#line 1274
  WChangeSize(curr, a1, a2);
#line 1275
  cols = curr->w_layer.l_width;
#line 1276
  rows = curr->w_layer.l_height;
  }
#line 1277
  goto switch_break___3;
  switch_default: /* CIL Label */ 
#line 1279
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 1281
  goto switch_break___0;
  case_117: /* CIL Label */ 
  {
#line 1283
  RestoreCursor(& curr->w_saved);
  }
#line 1284
  goto switch_break___0;
  case_73: /* CIL Label */ 
#line 1286
  if (! a1) {
#line 1287
    a1 = 1;
  }
  {
#line 1288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1288
    if (! __cil_tmp17) {
#line 1288
      goto while_break;
    }
    {
#line 1289
    ForwardTab();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1290
  goto switch_break___0;
  case_90: /* CIL Label */ 
#line 1292
  if (! a1) {
#line 1293
    a1 = 1;
  }
  {
#line 1294
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1294
    if (! __cil_tmp18) {
#line 1294
      goto while_break___0;
    }
    {
#line 1295
    BackwardTab();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1296
  goto switch_break___0;
  case_76: /* CIL Label */ 
#line 1298
  if (a1) {
#line 1298
    tmp___1023 = a1;
  } else {
#line 1298
    tmp___1023 = 1;
  }
  {
#line 1298
  InsertLine(tmp___1023);
  }
#line 1299
  goto switch_break___0;
  case_77: /* CIL Label */ 
#line 1301
  if (a1) {
#line 1301
    tmp___1024 = a1;
  } else {
#line 1301
    tmp___1024 = 1;
  }
  {
#line 1301
  DeleteLine(tmp___1024);
  }
#line 1302
  goto switch_break___0;
  case_80: /* CIL Label */ 
#line 1304
  if (a1) {
#line 1304
    tmp___1025 = a1;
  } else {
#line 1304
    tmp___1025 = 1;
  }
  {
#line 1304
  DeleteChar(tmp___1025);
  }
#line 1305
  goto switch_break___0;
  case_64: /* CIL Label */ 
#line 1307
  if (a1) {
#line 1307
    tmp___1026 = a1;
  } else {
#line 1307
    tmp___1026 = 1;
  }
  {
#line 1307
  InsertChar(tmp___1026);
  }
#line 1308
  goto switch_break___0;
  case_104: /* CIL Label */ 
  {
#line 1310
  ASetMode(1);
  }
#line 1311
  goto switch_break___0;
  case_108: /* CIL Label */ 
  {
#line 1313
  ASetMode(0);
  }
#line 1314
  goto switch_break___0;
  case_105: /* CIL Label */ 
#line 1316
  if (a1 == 5) {
    {
#line 1317
    PrintStart();
    }
  }
#line 1318
  goto switch_break___0;
  case_110: /* CIL Label */ 
#line 1320
  if (a1 == 5) {
    {
#line 1321
    Report((char *)"\033[0n", 0, 0);
    }
  } else
#line 1322
  if (a1 == 6) {
    {
#line 1323
    Report((char *)"\033[%d;%dR", curr->w_layer.l_y + 1, curr->w_layer.l_x + 1);
    }
  }
#line 1324
  goto switch_break___0;
  case_99: /* CIL Label */ 
#line 1326
  if (a1 == 0) {
    {
#line 1327
    Report((char *)"\033[?%d;%dc", 1, 2);
    }
  }
#line 1328
  goto switch_break___0;
  case_120: /* CIL Label */ 
#line 1330
  if (a1 == 0) {
    {
    {
#line 1331
    Report((char *)"\033[%d;1;1;112;112;1;0x", a1 + 2, 0);
    }
    }
  } else
#line 1330
  if (a1 == 1) {
    {
    {
#line 1331
    Report((char *)"\033[%d;1;1;112;112;1;0x", a1 + 2, 0);
    }
    }
  }
#line 1332
  goto switch_break___0;
  case_112: /* CIL Label */ 
#line 1334
  if (a1 == 6) {
    _L: /* CIL Label */ 
#line 1336
    curr->w_curinv = 7 - a1;
#line 1337
    if (curr->w_curinv) {
#line 1337
      tmp___1027 = - 1;
    } else {
#line 1337
      tmp___1027 = curr->w_curvvis;
    }
    {
#line 1337
    LCursorVisibility(& curr->w_layer, tmp___1027);
    }
  } else
#line 1334
  if (a1 == 7) {
#line 1334
    goto _L;
  }
#line 1339
  goto switch_break___0;
  case_83: /* CIL Label */ 
#line 1341
  if (a1) {
#line 1341
    tmp___1028 = a1;
  } else {
#line 1341
    tmp___1028 = 1;
  }
  {
#line 1341
  ScrollRegion(tmp___1028);
  }
#line 1342
  goto switch_break___0;
  case_94: /* CIL Label */ 
  case_84: /* CIL Label */ 
#line 1345
  if (a1) {
#line 1345
    tmp___1029 = - a1;
  } else {
#line 1345
    tmp___1029 = - 1;
  }
  {
#line 1345
  ScrollRegion(tmp___1029);
  }
#line 1346
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1348
  goto switch_break;
  case_63: /* CIL Label */ 
#line 1350
  a2 = 0;
  {
#line 1350
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1350
    if (! (a2 < curr->w_NumArgs)) {
#line 1350
      goto while_break___1;
    }
#line 1352
    a1 = curr->w_args[a2];
    {
#line 1353
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1353
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1354
    if (c != 104) {
#line 1354
      if (c != 108) {
#line 1355
        goto while_break___1;
      }
    }
#line 1356
    i = c == 104;
    {
#line 1359
    if (a1 == 1) {
#line 1359
      goto case_1___1;
    }
#line 1365
    if (a1 == 2) {
#line 1365
      goto case_2___1;
    }
#line 1382
    if (a1 == 3) {
#line 1382
      goto case_3;
    }
#line 1392
    if (a1 == 5) {
#line 1392
      goto case_5;
    }
#line 1397
    if (a1 == 6) {
#line 1397
      goto case_6;
    }
#line 1407
    if (a1 == 7) {
#line 1407
      goto case_7___0;
    }
#line 1412
    if (a1 == 9) {
#line 1412
      goto case_9;
    }
#line 1423
    if (a1 == 25) {
#line 1423
      goto case_25;
    }
#line 1436
    if (a1 == 1049) {
#line 1436
      goto case_1049;
    }
#line 1436
    if (a1 == 1047) {
#line 1436
      goto case_1049;
    }
#line 1436
    if (a1 == 47) {
#line 1436
      goto case_1049;
    }
#line 1459
    if (a1 == 1048) {
#line 1459
      goto case_1048;
    }
#line 1470
    if (a1 == 1003) {
#line 1470
      goto case_1003;
    }
#line 1470
    if (a1 == 1002) {
#line 1470
      goto case_1003;
    }
#line 1470
    if (a1 == 1001) {
#line 1470
      goto case_1003;
    }
#line 1470
    if (a1 == 1000) {
#line 1470
      goto case_1003;
    }
#line 1475
    if (a1 == 1006) {
#line 1475
      goto case_1006;
    }
#line 1357
    goto switch_break___4;
    case_1___1: /* CIL Label */ 
    {
#line 1360
    curr->w_cursorkeys = i;
#line 1360
    LCursorkeysMode(& curr->w_layer, curr->w_cursorkeys);
    }
#line 1364
    goto switch_break___4;
    case_2___1: /* CIL Label */ 
#line 1366
    if (i) {
#line 1370
      if (curr->w_layer.l_encoding) {
#line 1371
        goto switch_break___4;
      }
#line 1373
      curr->w_FontR = (char )0;
#line 1373
      curr->w_FontL = curr->w_FontR;
#line 1373
      curr->w_charsets[3] = (int )curr->w_FontL;
#line 1373
      curr->w_charsets[2] = curr->w_charsets[3];
#line 1373
      curr->w_charsets[1] = curr->w_charsets[2];
#line 1373
      curr->w_charsets[0] = curr->w_charsets[1];
#line 1376
      curr->w_Charset = 0;
#line 1377
      curr->w_CharsetR = 2;
#line 1378
      curr->w_ss = 0;
    }
#line 1381
    goto switch_break___4;
    case_3: /* CIL Label */ 
#line 1383
    if (i) {
#line 1383
      tmp___1030 = (int )Z0width;
    } else {
#line 1383
      tmp___1030 = (int )Z1width;
    }
    {
#line 1383
    i = tmp___1030;
#line 1384
    ClearScreen();
#line 1385
    curr->w_layer.l_x = 0;
#line 1386
    curr->w_layer.l_y = 0;
#line 1387
    WChangeSize(curr, i, curr->w_layer.l_height);
#line 1388
    cols = curr->w_layer.l_width;
#line 1389
    rows = curr->w_layer.l_height;
    }
#line 1390
    goto switch_break___4;
    case_5: /* CIL Label */ 
#line 1393
    if (i != curr->w_revvid) {
      {
#line 1394
      WReverseVideo(curr, i);
      }
    }
#line 1395
    curr->w_revvid = i;
#line 1396
    goto switch_break___4;
    case_6: /* CIL Label */ 
#line 1398
    curr->w_origin = i;
#line 1398
    if (curr->w_origin != 0) {
#line 1400
      curr->w_layer.l_y = curr->w_top;
#line 1401
      curr->w_layer.l_x = 0;
    } else {
#line 1404
      curr->w_layer.l_x = 0;
#line 1404
      curr->w_layer.l_y = curr->w_layer.l_x;
    }
    {
#line 1405
    LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
    }
#line 1406
    goto switch_break___4;
    case_7___0: /* CIL Label */ 
#line 1408
    curr->w_wrap = i;
#line 1409
    goto switch_break___4;
    case_9: /* CIL Label */ 
#line 1413
    if (i) {
#line 1413
      tmp___1031 = 9;
    } else {
#line 1413
      tmp___1031 = 0;
    }
    {
#line 1413
    curr->w_mouse = tmp___1031;
#line 1414
    LMouseMode(& curr->w_layer, curr->w_mouse);
    }
#line 1415
    goto switch_break___4;
    case_25: /* CIL Label */ 
#line 1424
    curr->w_curinv = ! i;
#line 1425
    if (curr->w_curinv) {
#line 1425
      tmp___1032 = - 1;
    } else {
#line 1425
      tmp___1032 = curr->w_curvvis;
    }
    {
#line 1425
    LCursorVisibility(& curr->w_layer, tmp___1032);
    }
#line 1426
    goto switch_break___4;
    case_1049: /* CIL Label */ 
    case_1047: /* CIL Label */ 
    case_47: /* CIL Label */ 
#line 1437
    if (use_altscreen) {
#line 1439
      if (i) {
#line 1441
        if (! curr->w_alt.on) {
          {
#line 1442
          SaveCursor(& curr->w_alt.cursor);
#line 1443
          EnterAltScreen(curr);
          }
        }
      } else
#line 1448
      if (curr->w_alt.on) {
        {
#line 1449
        RestoreCursor(& curr->w_alt.cursor);
#line 1450
        LeaveAltScreen(curr);
        }
      }
#line 1453
      if (a1 == 47) {
#line 1453
        if (! i) {
#line 1454
          curr->w_saved.on = 0;
        }
      }
      {
#line 1455
      LRefreshAll(& curr->w_layer, 0);
#line 1456
      LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
      }
    }
#line 1458
    goto switch_break___4;
    case_1048: /* CIL Label */ 
#line 1460
    if (i) {
      {
#line 1461
      SaveCursor(& curr->w_saved);
      }
    } else {
      {
#line 1463
      RestoreCursor(& curr->w_saved);
      }
    }
#line 1464
    goto switch_break___4;
    case_1003: /* CIL Label */ 
    case_1002: /* CIL Label */ 
    case_1001: /* CIL Label */ 
    case_1000: /* CIL Label */ 
#line 1471
    if (i) {
#line 1471
      tmp___1033 = a1;
    } else {
#line 1471
      tmp___1033 = 0;
    }
    {
#line 1471
    curr->w_mouse = tmp___1033;
#line 1472
    LMouseMode(& curr->w_layer, curr->w_mouse);
    }
#line 1473
    goto switch_break___4;
    case_1006: /* CIL Label */ 
#line 1476
    if (i) {
#line 1476
      tmp___1034 = a1;
    } else {
#line 1476
      tmp___1034 = 0;
    }
    {
#line 1476
    curr->w_extmouse = tmp___1034;
#line 1477
    LExtMouseMode(& curr->w_layer, curr->w_extmouse);
    }
#line 1478
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1350
  a2 ++;
#line 1482
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 1486
  if (c == 'c') {
#line 1486
    goto case_99___0;
  }
#line 1484
  goto switch_break___5;
  case_99___0: /* CIL Label */ 
#line 1487
  if (a1 == 0) {
    {
#line 1488
    Report((char *)"\033[>%d;%d;0c", 83, nversion);
    }
  }
#line 1489
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 1491
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1497 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void StringStart(enum string_t type ) 
{ 


  {
#line 1500
  curr->w_StringType = type;
#line 1501
  curr->w_stringp = (char *)curr->w_string;
#line 1502
  curr->w_state = (enum state_t )2;
  return;
}
}
#line 1506 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void StringChar(int c ) 
{ 
  char *__cil_tmp2 ;

  {
#line 1509
  if (curr->w_stringp >= ((char *)curr->w_string + 768) - 1) {
#line 1510
    curr->w_state = (enum state_t )0;
  } else {
#line 1512
    __cil_tmp2 = curr->w_stringp;
#line 1512
    (curr->w_stringp) ++;
#line 1512
    *__cil_tmp2 = (char )c;
  }
  return;
}
}
#line 1520 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static int StringEnd(void) 
{ 
  struct canvas *cv ;
  char *p ;
  int typ ;
  char *t ;
  char *tmp ;
  char *args[64] ;
  int argl[64] ;
  struct acluser *windowuser ;
  int __cil_tmp13 ;
  struct layer *tmp___1034 ;
  int typ2 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  struct display *olddisplay ;
  struct canvas *cv___1041 ;
  size_t __cil_tmp23 ;

  {
#line 1529
  if ((unsigned int )curr->w_state == 3U) {
#line 1529
    tmp = (char *)"\033\\";
  } else {
#line 1529
    tmp = (char *)"\a";
  }
#line 1529
  t = tmp;
#line 1531
  curr->w_state = (enum state_t )0;
#line 1532
  *(curr->w_stringp) = (char )'\000';
  {
#line 1535
  if ((unsigned int )curr->w_StringType == (unsigned int )2) {
#line 1535
    goto case_2;
  }
#line 1607
  if ((unsigned int )curr->w_StringType == (unsigned int )3) {
#line 1607
    goto case_3;
  }
#line 1620
  if ((unsigned int )curr->w_StringType == (unsigned int )6) {
#line 1620
    goto case_6;
  }
#line 1620
  if ((unsigned int )curr->w_StringType == (unsigned int )4) {
#line 1620
    goto case_6;
  }
#line 1630
  if ((unsigned int )curr->w_StringType == (unsigned int )1) {
#line 1630
    goto case_1;
  }
#line 1633
  if ((unsigned int )curr->w_StringType == (unsigned int )5) {
#line 1633
    goto case_5;
  }
#line 1641
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1536
  p = index((char const   *)((char *)curr->w_string), ';');
  }
#line 1536
  if ((int )curr->w_string[0] == 59) {
#line 1537
    goto switch_break;
  } else
#line 1536
  if (p == (char *)0) {
#line 1537
    goto switch_break;
  }
  {
#line 1538
  typ = atoi((char const   *)((char *)curr->w_string));
#line 1539
  p ++;
  }
#line 1541
  if (typ == 83) {
    {
#line 1548
    windowuser = (struct acluser *)FindUserPtr((char *)":window:");
#line 1549
    __cil_tmp13 = Parse(p, (int )(sizeof(curr->w_string) - (unsigned long )(p - (char *)curr->w_string)),
                        (char **)args, (int *)argl);
    }
#line 1549
    if (windowuser) {
#line 1549
      if (__cil_tmp13) {
#line 1551
        display = displays;
        {
#line 1551
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1551
          if (! display) {
#line 1551
            goto while_break;
          }
#line 1552
          if (((display->d_forecv)->c_layer)->l_bottom == & curr->w_layer) {
#line 1553
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 1551
        display = display->d_next;
#line 1554
        if (display == (struct display *)0) {
#line 1554
          if (curr->w_layer.l_cvlist) {
#line 1555
            display = (curr->w_layer.l_cvlist)->c_display;
          }
        }
#line 1556
        if (display == (struct display *)0) {
#line 1557
          display = displays;
        }
#line 1558
        EffectiveAclUser = windowuser;
#line 1559
        fore = curr;
#line 1560
        if (fore->w_savelayer) {
#line 1560
          tmp___1034 = fore->w_savelayer;
        } else {
#line 1560
          tmp___1034 = & fore->w_layer;
        }
        {
#line 1560
        flayer = tmp___1034;
#line 1561
        DoCommand((char **)args, (int *)argl);
#line 1562
        EffectiveAclUser = (struct acluser *)0;
#line 1563
        fore = (struct win *)0;
#line 1564
        flayer = (struct layer *)0;
        }
      }
    }
#line 1566
    goto switch_break;
  }
#line 1570
  if (typ == 0) {
    _L___1035: /* CIL Label */ 
    {
#line 1573
    typ2 = typ / 10;
#line 1574
    __cil_tmp16 = strcmp((char const   *)((char *)curr->w_xtermosc[typ2]), (char const   *)p);
    }
#line 1574
    if (__cil_tmp16) {
      {
#line 1576
      __cil_tmp17 = strcmp((char const   *)((char *)"?"), (char const   *)p);
      }
#line 1576
      if (typ != 11) {
        {
        {
#line 1578
        strncpy((char *)curr->w_xtermosc[typ2], (char const   *)p, sizeof(curr->w_xtermosc[typ2]) - 1UL);
        }
#line 1579
        curr->w_xtermosc[typ2][sizeof(curr->w_xtermosc[typ2]) - 1UL] = (char )0;
        }
      } else
#line 1576
      if (__cil_tmp17) {
        {
        {
#line 1578
        strncpy((char *)curr->w_xtermosc[typ2], (char const   *)p, sizeof(curr->w_xtermosc[typ2]) - 1UL);
        }
#line 1579
        curr->w_xtermosc[typ2][sizeof(curr->w_xtermosc[typ2]) - 1UL] = (char )0;
        }
      }
#line 1582
      display = displays;
      {
#line 1582
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1582
        if (! display) {
#line 1582
          goto while_break___0;
        }
#line 1584
        if (! display->d_tcs[96].flg) {
#line 1585
          goto while_continue___0;
        }
#line 1586
        if (((display->d_forecv)->c_layer)->l_bottom == & curr->w_layer) {
          {
#line 1587
          SetXtermOSC(typ2, p, t);
          }
        }
#line 1588
        if (typ2 == 3) {
          _L: /* CIL Label */ 
#line 1588
          if (display->d_xtermosc[typ2]) {
            {
#line 1589
            Redisplay(0);
            }
          }
        } else
#line 1588
        if (typ2 == 4) {
#line 1588
          goto _L;
        }
        {
#line 1590
        __cil_tmp18 = strcmp((char const   *)((char *)"?"), (char const   *)p);
        }
#line 1590
        if (typ == 11) {
#line 1590
          if (! __cil_tmp18) {
#line 1591
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1582
      display = display->d_next;
    }
  } else
#line 1570
  if (typ == 1) {
#line 1570
    goto _L___1035;
  } else
#line 1570
  if (typ == 2) {
#line 1570
    goto _L___1035;
  } else
#line 1570
  if (typ == 11) {
#line 1570
    goto _L___1035;
  } else
#line 1570
  if (typ == 20) {
#line 1570
    goto _L___1035;
  } else
#line 1570
  if (typ == 39) {
#line 1570
    goto _L___1035;
  } else
#line 1570
  if (typ == 49) {
#line 1570
    goto _L___1035;
  }
#line 1595
  if (typ != 0) {
#line 1595
    if (typ != 2) {
#line 1596
      goto switch_break;
    }
  }
#line 1602
  curr->w_stringp -= p - (char *)curr->w_string;
#line 1603
  if (curr->w_stringp > (char *)curr->w_string) {
    {
#line 1604
    bcopy((void const   *)p, (void *)((char *)curr->w_string), (size_t )(curr->w_stringp - (char *)curr->w_string));
    }
  }
#line 1605
  *(curr->w_stringp) = (char )'\000';
  case_3: /* CIL Label */ 
#line 1608
  if (curr->w_hstatus) {
    {
#line 1610
    __cil_tmp19 = strcmp((char const   *)curr->w_hstatus, (char const   *)((char *)curr->w_string));
    }
#line 1610
    if (__cil_tmp19 == 0) {
#line 1611
      goto switch_break;
    }
    {
#line 1612
    free((void *)curr->w_hstatus);
#line 1613
    curr->w_hstatus = (char *)0;
    }
  }
#line 1615
  if ((char *)curr->w_string != curr->w_stringp) {
    {
#line 1616
    curr->w_hstatus = SaveStr((char const   *)((char *)curr->w_string));
    }
  }
  {
#line 1617
  WindowChanged(curr, 'h');
  }
#line 1618
  goto switch_break;
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1621
  display = displays;
  {
#line 1621
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1621
    if (! display) {
#line 1621
      goto while_break___1;
    }
#line 1623
    cv = display->d_cvlist;
    {
#line 1623
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1623
      if (! cv) {
#line 1623
        goto while_break___2;
      }
#line 1624
      if ((cv->c_layer)->l_bottom == & curr->w_layer) {
#line 1625
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1623
    cv = cv->c_next;
#line 1626
    if (cv) {
      {
      {
#line 1627
      MakeStatus((char *)curr->w_string);
      }
      }
    } else
#line 1626
    if ((unsigned int )curr->w_StringType == 6U) {
      {
      {
#line 1627
      MakeStatus((char *)curr->w_string);
      }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1621
  display = display->d_next;
#line 1629
  return (- 1);
  case_1: /* CIL Label */ 
  {
#line 1631
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1631
    olddisplay = display;
#line 1631
    display = displays;
    {
#line 1631
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1631
      if (! display) {
#line 1631
        goto while_break___4;
      }
#line 1631
      cv___1041 = display->d_cvlist;
      {
#line 1631
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1631
        if (! cv___1041) {
#line 1631
          goto while_break___5;
        }
#line 1631
        if (cv___1041->c_layer == & curr->w_layer) {
#line 1631
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1631
      cv___1041 = cv___1041->c_next;
#line 1631
      if (cv___1041 == (struct canvas *)0) {
#line 1631
        goto while_continue___4;
      }
      {
#line 1631
      AddStr((char *)curr->w_string);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1631
    display = display->d_next;
#line 1631
    display = olddisplay;
#line 1631
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1632
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1634
  if (curr->w_title == (char *)curr->w_akabuf) {
#line 1634
    if (! *((char *)curr->w_string)) {
#line 1635
      goto switch_break;
    }
  }
#line 1636
  if (curr->w_dynamicaka) {
    {
#line 1637
    __cil_tmp23 = strlen((char const   *)((char *)curr->w_string));
#line 1637
    ChangeAKA(curr, (char *)curr->w_string, (int )__cil_tmp23);
    }
  }
#line 1638
  if (! *((char *)curr->w_string)) {
#line 1639
    curr->w_autoaka = curr->w_layer.l_y + 1;
  }
#line 1640
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1642
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1644
  return (0);
}
}
#line 1648 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void PrintStart(void) 
{ 
  struct canvas *cv ;

  {
#line 1650
  curr->w_pdisplay = (struct display *)0;
#line 1653
  display = curr->w_lastdisp;
#line 1654
  if (! ((display && curr == display->d_fore) && (printcmd || display->d_tcs[73].str))) {
#line 1655
    display = displays;
    {
#line 1655
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1655
      if (! display) {
#line 1655
        goto while_break;
      }
#line 1656
      if (curr == display->d_fore) {
#line 1656
        if (printcmd) {
#line 1657
          goto while_break;
        } else
#line 1656
        if (display->d_tcs[73].str) {
#line 1657
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1655
    display = display->d_next;
  }
#line 1658
  if (! display) {
#line 1661
    cv = curr->w_layer.l_cvlist;
    {
#line 1661
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1661
      if (! cv) {
#line 1661
        goto while_break___0;
      }
#line 1663
      display = cv->c_display;
#line 1664
      if (printcmd) {
#line 1665
        goto while_break___0;
      } else
#line 1664
      if (display->d_tcs[73].str) {
#line 1665
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1661
    cv = cv->c_lnext;
#line 1667
    if (! cv) {
#line 1669
      display = displays;
#line 1670
      if (! display) {
#line 1671
        return;
      } else
#line 1670
      if (display->d_next) {
#line 1671
        return;
      } else
#line 1670
      if (! (printcmd || display->d_tcs[73].str)) {
#line 1671
        return;
      }
    }
  }
#line 1674
  curr->w_pdisplay = display;
#line 1675
  curr->w_stringp = (char *)curr->w_string;
#line 1676
  curr->w_state = (enum state_t )5;
#line 1677
  if (printcmd) {
#line 1677
    if ((curr->w_pdisplay)->d_printfd < 0) {
      {
#line 1678
      (curr->w_pdisplay)->d_printfd = printpipe(curr, printcmd);
      }
    }
  }
  return;
}
}
#line 1682 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void PrintChar(int c ) 
{ 
  char *__cil_tmp2 ;

  {
#line 1685
  if (curr->w_stringp >= ((char *)curr->w_string + 768) - 1) {
    {
#line 1686
    PrintFlush();
    }
  }
#line 1687
  __cil_tmp2 = curr->w_stringp;
#line 1687
  (curr->w_stringp) ++;
#line 1687
  *__cil_tmp2 = (char )c;
  return;
}
}
#line 1691 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void PrintFlush(void) 
{ 
  char *bp ;
  int len ;
  int r ;
  ssize_t __cil_tmp4 ;
  int *__cil_tmp5 ;

  {
#line 1693
  display = curr->w_pdisplay;
#line 1694
  if (display) {
#line 1694
    if (printcmd) {
#line 1696
      bp = (char *)curr->w_string;
#line 1697
      len = (int )(curr->w_stringp - (char *)curr->w_string);
      {
#line 1699
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1699
        if (! (len && display->d_printfd >= 0)) {
#line 1699
          goto while_break;
        }
        {
#line 1701
        __cil_tmp4 = write(display->d_printfd, (void const   *)bp, (size_t )len);
#line 1701
        r = (int )__cil_tmp4;
        }
#line 1702
        if (r <= 0) {
          {
#line 1704
          __cil_tmp5 = __errno_location();
#line 1704
          WMsg(curr, *__cil_tmp5, (char *)"printing aborted");
#line 1705
          close(display->d_printfd);
#line 1706
          display->d_printfd = - 1;
          }
#line 1707
          goto while_break;
        }
#line 1709
        bp += r;
#line 1710
        len -= r;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1694
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1713
  if (display) {
#line 1713
    if (curr->w_stringp > (char *)curr->w_string) {
      {
#line 1715
      AddCStr(display->d_tcs[73].str);
#line 1716
      AddStrn((char *)curr->w_string, (int )(curr->w_stringp - (char *)curr->w_string));
#line 1717
      AddCStr(display->d_tcs[74].str);
#line 1718
      Flush(3);
      }
    }
  }
#line 1720
  curr->w_stringp = (char *)curr->w_string;
  return;
}
}
#line 1725 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void WNewAutoFlow(struct win *win , int on ) 
{ 


  {
  {
#line 1729
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1729
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1730
  if (win->w_flow & (1 << 2)) {
#line 1731
    win->w_flow = (1 << 2) | ((1 << 1) | 1) * on;
  } else {
#line 1733
    win->w_flow = (win->w_flow & ~ (1 << 1)) | (1 << 1) * on;
  }
  {
#line 1734
  LSetFlow(& win->w_layer, win->w_flow & 1);
  }
  return;
}
}
#line 1741 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void DesignateCharset(int c , int n ) 
{ 


  {
#line 1744
  curr->w_ss = 0;
#line 1746
  if (c == 0) {
#line 1747
    c = 2;
  }
#line 1749
  if (c == 66) {
#line 1750
    c = 0;
  }
#line 1751
  if (curr->w_charsets[n] != c) {
#line 1753
    curr->w_charsets[n] = c;
#line 1754
    if (curr->w_Charset == n) {
      {
#line 1756
      curr->w_FontL = (char )c;
#line 1757
      curr->w_rend.font = (unsigned char )curr->w_FontL;
#line 1758
      LSetRendition(& curr->w_layer, & curr->w_rend);
      }
    }
#line 1760
    if (curr->w_CharsetR == n) {
#line 1761
      curr->w_FontR = (char )c;
    }
  }
  return;
}
}
#line 1766 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MapCharset(int n ) 
{ 


  {
#line 1769
  curr->w_ss = 0;
#line 1770
  if (curr->w_Charset != n) {
    {
#line 1772
    curr->w_Charset = n;
#line 1773
    curr->w_FontL = (char )curr->w_charsets[n];
#line 1774
    curr->w_rend.font = (unsigned char )curr->w_FontL;
#line 1775
    LSetRendition(& curr->w_layer, & curr->w_rend);
    }
  }
  return;
}
}
#line 1780 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MapCharsetR(int n ) 
{ 


  {
#line 1783
  curr->w_ss = 0;
#line 1784
  if (curr->w_CharsetR != n) {
#line 1786
    curr->w_CharsetR = n;
#line 1787
    curr->w_FontR = (char )curr->w_charsets[n];
  }
#line 1789
  curr->w_gr = 1;
  return;
}
}
#line 1795 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void SaveCursor(struct cursor *cursor ) 
{ 


  {
  {
#line 1798
  cursor->on = 1;
#line 1799
  cursor->x = curr->w_layer.l_x;
#line 1800
  cursor->y = curr->w_layer.l_y;
#line 1801
  cursor->Rend = curr->w_rend;
#line 1803
  cursor->Charset = curr->w_Charset;
#line 1804
  cursor->CharsetR = curr->w_CharsetR;
#line 1805
  bcopy((void const   *)((char *)((int *)curr->w_charsets)), (void *)((char *)((int *)cursor->Charsets)),
        4UL * sizeof(int ));
  }
  return;
}
}
#line 1811 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void RestoreCursor(struct cursor *cursor ) 
{ 


  {
#line 1814
  if (! cursor->on) {
#line 1815
    return;
  }
  {
#line 1816
  LGotoPos(& curr->w_layer, cursor->x, cursor->y);
#line 1817
  curr->w_layer.l_x = cursor->x;
#line 1818
  curr->w_layer.l_y = cursor->y;
#line 1819
  curr->w_rend = cursor->Rend;
#line 1821
  bcopy((void const   *)((char *)((int *)cursor->Charsets)), (void *)((char *)((int *)curr->w_charsets)),
        4UL * sizeof(int ));
#line 1823
  curr->w_Charset = cursor->Charset;
#line 1824
  curr->w_CharsetR = cursor->CharsetR;
#line 1825
  curr->w_ss = 0;
#line 1826
  curr->w_FontL = (char )curr->w_charsets[curr->w_Charset];
#line 1827
  curr->w_FontR = (char )curr->w_charsets[curr->w_CharsetR];
#line 1829
  LSetRendition(& curr->w_layer, & curr->w_rend);
  }
  return;
}
}
#line 1833 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void BackSpace(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;

  {
#line 1835
  if (curr->w_layer.l_x > 0) {
#line 1837
    __cil_tmp1 = curr->w_layer.l_x;
#line 1837
    (curr->w_layer.l_x) --;
  } else
#line 1839
  if (curr->w_wrap) {
#line 1839
    if (curr->w_layer.l_y > 0) {
#line 1841
      curr->w_layer.l_x = cols - 1;
#line 1842
      __cil_tmp2 = curr->w_layer.l_y;
#line 1842
      (curr->w_layer.l_y) --;
    }
  }
  {
#line 1844
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 1848 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void Return(void) 
{ 


  {
#line 1850
  if (curr->w_layer.l_x == 0) {
#line 1851
    return;
  }
  {
#line 1852
  curr->w_layer.l_x = 0;
#line 1853
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 1857 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void LineFeed(int out_mode ) 
{ 
  int __cil_tmp3 ;
  int tmp ;
  int tmp___1042 ;
  int tmp___1043 ;
  int tmp___1044 ;

  {
#line 1861
  if (out_mode) {
#line 1862
    curr->w_layer.l_x = 0;
  }
#line 1863
  if (curr->w_layer.l_y != curr->w_bot) {
#line 1865
    if (curr->w_layer.l_y < rows - 1) {
#line 1866
      (curr->w_layer.l_y) ++;
    }
    {
#line 1867
    LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
    }
#line 1868
    return;
  }
#line 1870
  if (curr->w_autoaka > 1) {
#line 1871
    __cil_tmp3 = curr->w_autoaka;
#line 1871
    (curr->w_autoaka) --;
  }
#line 1872
  if (curr->w_bce) {
#line 1872
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1872
      tmp = 256;
    } else {
#line 1872
      tmp = 0;
    }
#line 1872
    tmp___1042 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1872
    tmp___1042 = 0;
  }
  {
#line 1872
  MScrollV(curr, 1, curr->w_top, curr->w_bot, tmp___1042);
  }
#line 1873
  if (curr->w_bce) {
#line 1873
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1873
      tmp___1043 = 256;
    } else {
#line 1873
      tmp___1043 = 0;
    }
#line 1873
    tmp___1044 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1043;
  } else {
#line 1873
    tmp___1044 = 0;
  }
  {
#line 1873
  LScrollV(& curr->w_layer, 1, curr->w_top, curr->w_bot, tmp___1044);
#line 1874
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 1878 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void ReverseLineFeed(void) 
{ 
  int tmp ;
  int tmp___1045 ;
  int tmp___1046 ;
  int tmp___1047 ;

  {
#line 1880
  if (curr->w_layer.l_y == curr->w_top) {
#line 1882
    if (curr->w_bce) {
#line 1882
      if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1882
        tmp = 256;
      } else {
#line 1882
        tmp = 0;
      }
#line 1882
      tmp___1045 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
    } else {
#line 1882
      tmp___1045 = 0;
    }
    {
#line 1882
    MScrollV(curr, - 1, curr->w_top, curr->w_bot, tmp___1045);
    }
#line 1883
    if (curr->w_bce) {
#line 1883
      if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1883
        tmp___1046 = 256;
      } else {
#line 1883
        tmp___1046 = 0;
      }
#line 1883
      tmp___1047 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1046;
    } else {
#line 1883
      tmp___1047 = 0;
    }
    {
#line 1883
    LScrollV(& curr->w_layer, - 1, curr->w_top, curr->w_bot, tmp___1047);
#line 1884
    LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
    }
  } else
#line 1886
  if (curr->w_layer.l_y > 0) {
    {
#line 1887
    CursorUp(1);
    }
  }
  return;
}
}
#line 1891 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void InsertChar(int n ) 
{ 
  register int y ;
  register int x ;
  int __cil_tmp4 ;
  int tmp ;
  int tmp___1048 ;
  int tmp___1049 ;
  int tmp___1050 ;

  {
#line 1894
  y = curr->w_layer.l_y;
#line 1894
  x = curr->w_layer.l_x;
#line 1896
  if (n <= 0) {
#line 1897
    return;
  }
#line 1898
  if (x == cols) {
#line 1899
    __cil_tmp4 = x;
#line 1899
    x --;
  }
  {
#line 1900
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1900
    bcopy((void const   *)((char *)(curr->w_mlines + y)->image), (void *)((char *)mline_old.image),
          (size_t )cols);
#line 1900
    bcopy((void const   *)((char *)(curr->w_mlines + y)->attr), (void *)((char *)mline_old.attr),
          (size_t )cols);
#line 1900
    bcopy((void const   *)((char *)(curr->w_mlines + y)->font), (void *)((char *)mline_old.font),
          (size_t )cols);
#line 1900
    bcopy((void const   *)((char *)(curr->w_mlines + y)->fontx), (void *)((char *)mline_old.fontx),
          (size_t )cols);
#line 1900
    bcopy((void const   *)((char *)(curr->w_mlines + y)->color), (void *)((char *)mline_old.color),
          (size_t )cols);
    }
#line 1900
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1901
  if (curr->w_bce) {
#line 1901
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1901
      tmp = 256;
    } else {
#line 1901
      tmp = 0;
    }
#line 1901
    tmp___1048 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1901
    tmp___1048 = 0;
  }
  {
#line 1901
  MScrollH(curr, - n, y, x, curr->w_layer.l_width - 1, tmp___1048);
  }
#line 1902
  if (curr->w_bce) {
#line 1902
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1902
      tmp___1049 = 256;
    } else {
#line 1902
      tmp___1049 = 0;
    }
#line 1902
    tmp___1050 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1049;
  } else {
#line 1902
    tmp___1050 = 0;
  }
  {
#line 1902
  LScrollH(& curr->w_layer, - n, y, x, curr->w_layer.l_width - 1, tmp___1050, & mline_old);
#line 1903
  LGotoPos(& curr->w_layer, x, y);
  }
  return;
}
}
#line 1907 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void DeleteChar(int n ) 
{ 
  register int y ;
  register int x ;
  int __cil_tmp4 ;
  int tmp ;
  int tmp___1051 ;
  int tmp___1052 ;
  int tmp___1053 ;

  {
#line 1910
  y = curr->w_layer.l_y;
#line 1910
  x = curr->w_layer.l_x;
#line 1912
  if (x == cols) {
#line 1913
    __cil_tmp4 = x;
#line 1913
    x --;
  }
  {
#line 1914
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1914
    bcopy((void const   *)((char *)(curr->w_mlines + y)->image), (void *)((char *)mline_old.image),
          (size_t )cols);
#line 1914
    bcopy((void const   *)((char *)(curr->w_mlines + y)->attr), (void *)((char *)mline_old.attr),
          (size_t )cols);
#line 1914
    bcopy((void const   *)((char *)(curr->w_mlines + y)->font), (void *)((char *)mline_old.font),
          (size_t )cols);
#line 1914
    bcopy((void const   *)((char *)(curr->w_mlines + y)->fontx), (void *)((char *)mline_old.fontx),
          (size_t )cols);
#line 1914
    bcopy((void const   *)((char *)(curr->w_mlines + y)->color), (void *)((char *)mline_old.color),
          (size_t )cols);
    }
#line 1914
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1915
  if (curr->w_bce) {
#line 1915
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1915
      tmp = 256;
    } else {
#line 1915
      tmp = 0;
    }
#line 1915
    tmp___1051 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1915
    tmp___1051 = 0;
  }
  {
#line 1915
  MScrollH(curr, n, y, x, curr->w_layer.l_width - 1, tmp___1051);
  }
#line 1916
  if (curr->w_bce) {
#line 1916
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1916
      tmp___1052 = 256;
    } else {
#line 1916
      tmp___1052 = 0;
    }
#line 1916
    tmp___1053 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1052;
  } else {
#line 1916
    tmp___1053 = 0;
  }
  {
#line 1916
  LScrollH(& curr->w_layer, n, y, x, curr->w_layer.l_width - 1, tmp___1053, & mline_old);
#line 1917
  LGotoPos(& curr->w_layer, x, y);
  }
  return;
}
}
#line 1921 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void DeleteLine(int n ) 
{ 
  int tmp ;
  int tmp___1054 ;
  int tmp___1055 ;
  int tmp___1056 ;

  {
#line 1924
  if (curr->w_layer.l_y < curr->w_top) {
#line 1925
    return;
  } else
#line 1924
  if (curr->w_layer.l_y > curr->w_bot) {
#line 1925
    return;
  }
#line 1926
  if (n > (curr->w_bot - curr->w_layer.l_y) + 1) {
#line 1927
    n = (curr->w_bot - curr->w_layer.l_y) + 1;
  }
#line 1928
  if (curr->w_bce) {
#line 1928
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1928
      tmp = 256;
    } else {
#line 1928
      tmp = 0;
    }
#line 1928
    tmp___1054 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1928
    tmp___1054 = 0;
  }
  {
#line 1928
  MScrollV(curr, n, curr->w_layer.l_y, curr->w_bot, tmp___1054);
  }
#line 1929
  if (curr->w_bce) {
#line 1929
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1929
      tmp___1055 = 256;
    } else {
#line 1929
      tmp___1055 = 0;
    }
#line 1929
    tmp___1056 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1055;
  } else {
#line 1929
    tmp___1056 = 0;
  }
  {
#line 1929
  LScrollV(& curr->w_layer, n, curr->w_layer.l_y, curr->w_bot, tmp___1056);
#line 1930
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 1934 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void InsertLine(int n ) 
{ 
  int tmp ;
  int tmp___1057 ;
  int tmp___1058 ;
  int tmp___1059 ;

  {
#line 1937
  if (curr->w_layer.l_y < curr->w_top) {
#line 1938
    return;
  } else
#line 1937
  if (curr->w_layer.l_y > curr->w_bot) {
#line 1938
    return;
  }
#line 1939
  if (n > (curr->w_bot - curr->w_layer.l_y) + 1) {
#line 1940
    n = (curr->w_bot - curr->w_layer.l_y) + 1;
  }
#line 1941
  if (curr->w_bce) {
#line 1941
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1941
      tmp = 256;
    } else {
#line 1941
      tmp = 0;
    }
#line 1941
    tmp___1057 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1941
    tmp___1057 = 0;
  }
  {
#line 1941
  MScrollV(curr, - n, curr->w_layer.l_y, curr->w_bot, tmp___1057);
  }
#line 1942
  if (curr->w_bce) {
#line 1942
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1942
      tmp___1058 = 256;
    } else {
#line 1942
      tmp___1058 = 0;
    }
#line 1942
    tmp___1059 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1058;
  } else {
#line 1942
    tmp___1059 = 0;
  }
  {
#line 1942
  LScrollV(& curr->w_layer, - n, curr->w_layer.l_y, curr->w_bot, tmp___1059);
#line 1943
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 1947 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void ScrollRegion(int n ) 
{ 
  int tmp ;
  int tmp___1060 ;
  int tmp___1061 ;
  int tmp___1062 ;

  {
#line 1950
  if (curr->w_bce) {
#line 1950
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1950
      tmp = 256;
    } else {
#line 1950
      tmp = 0;
    }
#line 1950
    tmp___1060 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1950
    tmp___1060 = 0;
  }
  {
#line 1950
  MScrollV(curr, n, curr->w_top, curr->w_bot, tmp___1060);
  }
#line 1951
  if (curr->w_bce) {
#line 1951
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1951
      tmp___1061 = 256;
    } else {
#line 1951
      tmp___1061 = 0;
    }
#line 1951
    tmp___1062 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1061;
  } else {
#line 1951
    tmp___1062 = 0;
  }
  {
#line 1951
  LScrollV(& curr->w_layer, n, curr->w_top, curr->w_bot, tmp___1062);
#line 1952
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 1957 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void ForwardTab(void) 
{ 
  register int x ;

  {
#line 1959
  x = curr->w_layer.l_x;
#line 1961
  if (x == cols) {
    {
#line 1963
    LineFeed(1);
#line 1964
    x = 0;
    }
  }
#line 1966
  if ((int )*(curr->w_tabs + x)) {
#line 1966
    if (x < cols - 1) {
#line 1967
      x ++;
    }
  }
  {
#line 1968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1968
    if (! (x < cols - 1 && ! *(curr->w_tabs + x))) {
#line 1968
      goto while_break;
    }
#line 1969
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1970
  curr->w_layer.l_x = x;
#line 1971
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 1975 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void BackwardTab(void) 
{ 
  register int x ;
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
#line 1977
  x = curr->w_layer.l_x;
#line 1979
  if ((int )*(curr->w_tabs + x)) {
#line 1979
    if (x > 0) {
#line 1980
      __cil_tmp2 = x;
#line 1980
      x --;
    }
  }
  {
#line 1981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1981
    if (! (x > 0 && ! *(curr->w_tabs + x))) {
#line 1981
      goto while_break;
    }
#line 1982
    __cil_tmp3 = x;
#line 1982
    x --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1983
  curr->w_layer.l_x = x;
#line 1984
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 1988 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void ClearScreen(void) 
{ 
  int tmp ;
  int tmp___1063 ;
  int tmp___1064 ;
  int tmp___1065 ;

  {
#line 1990
  if (curr->w_bce) {
#line 1990
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1990
      tmp = 256;
    } else {
#line 1990
      tmp = 0;
    }
#line 1990
    tmp___1063 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 1990
    tmp___1063 = 0;
  }
  {
#line 1990
  LClearArea(& curr->w_layer, 0, 0, curr->w_layer.l_width - 1, curr->w_layer.l_height - 1,
             tmp___1063, 1);
  }
#line 1992
  if (curr->w_bce) {
#line 1992
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 1992
      tmp___1064 = 256;
    } else {
#line 1992
      tmp___1064 = 0;
    }
#line 1992
    tmp___1065 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1064;
  } else {
#line 1992
    tmp___1065 = 0;
  }
  {
#line 1992
  MScrollV(curr, curr->w_layer.l_height, 0, curr->w_layer.l_height - 1, tmp___1065);
  }
  return;
}
}
#line 1999 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void ClearFromBOS(void) 
{ 
  register int y ;
  register int x ;
  int tmp ;
  int tmp___1066 ;
  int tmp___1067 ;
  int tmp___1068 ;

  {
#line 2001
  y = curr->w_layer.l_y;
#line 2001
  x = curr->w_layer.l_x;
#line 2003
  if (curr->w_bce) {
#line 2003
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 2003
      tmp = 256;
    } else {
#line 2003
      tmp = 0;
    }
#line 2003
    tmp___1066 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 2003
    tmp___1066 = 0;
  }
  {
#line 2003
  LClearArea(& curr->w_layer, 0, 0, x, y, tmp___1066, 1);
  }
#line 2004
  if (curr->w_bce) {
#line 2004
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 2004
      tmp___1067 = 256;
    } else {
#line 2004
      tmp___1067 = 0;
    }
#line 2004
    tmp___1068 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1067;
  } else {
#line 2004
    tmp___1068 = 0;
  }
  {
#line 2004
  MClearArea(curr, 0, 0, x, y, tmp___1068);
#line 2005
  RestorePosRendition();
  }
  return;
}
}
#line 2009 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void ClearToEOS(void) 
{ 
  register int y ;
  register int x ;
  int tmp ;
  int tmp___1069 ;
  int tmp___1070 ;
  int tmp___1071 ;

  {
#line 2011
  y = curr->w_layer.l_y;
#line 2011
  x = curr->w_layer.l_x;
#line 2013
  if (x == 0) {
#line 2013
    if (y == 0) {
      {
#line 2015
      ClearScreen();
#line 2016
      RestorePosRendition();
      }
#line 2017
      return;
    }
  }
#line 2019
  if (curr->w_bce) {
#line 2019
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 2019
      tmp = 256;
    } else {
#line 2019
      tmp = 0;
    }
#line 2019
    tmp___1069 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 2019
    tmp___1069 = 0;
  }
  {
#line 2019
  LClearArea(& curr->w_layer, x, y, cols - 1, rows - 1, tmp___1069, 1);
  }
#line 2020
  if (curr->w_bce) {
#line 2020
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 2020
      tmp___1070 = 256;
    } else {
#line 2020
      tmp___1070 = 0;
    }
#line 2020
    tmp___1071 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1070;
  } else {
#line 2020
    tmp___1071 = 0;
  }
  {
#line 2020
  MClearArea(curr, x, y, cols - 1, rows - 1, tmp___1071);
#line 2021
  RestorePosRendition();
  }
  return;
}
}
#line 2025 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void ClearLineRegion(int from , int to ) 
{ 
  register int y ;
  int tmp ;
  int tmp___1072 ;
  int tmp___1073 ;
  int tmp___1074 ;

  {
#line 2028
  y = curr->w_layer.l_y;
#line 2029
  if (curr->w_bce) {
#line 2029
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 2029
      tmp = 256;
    } else {
#line 2029
      tmp = 0;
    }
#line 2029
    tmp___1072 = (((int )curr->w_rend.color & 240) >> 4) | tmp;
  } else {
#line 2029
    tmp___1072 = 0;
  }
  {
#line 2029
  LClearArea(& curr->w_layer, from, y, to, y, tmp___1072, 1);
  }
#line 2030
  if (curr->w_bce) {
#line 2030
    if ((int )curr->w_rend.attr & (1 << 7)) {
#line 2030
      tmp___1073 = 256;
    } else {
#line 2030
      tmp___1073 = 0;
    }
#line 2030
    tmp___1074 = (((int )curr->w_rend.color & 240) >> 4) | tmp___1073;
  } else {
#line 2030
    tmp___1074 = 0;
  }
  {
#line 2030
  MClearArea(curr, from, y, to, y, tmp___1074);
#line 2031
  RestorePosRendition();
  }
  return;
}
}
#line 2035 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void CursorRight(int n ) 
{ 
  register int x ;

  {
#line 2038
  x = curr->w_layer.l_x;
#line 2040
  if (x == cols) {
    {
#line 2042
    LineFeed(1);
#line 2043
    x = 0;
    }
  }
#line 2045
  curr->w_layer.l_x += n;
#line 2045
  if (curr->w_layer.l_x >= cols) {
#line 2046
    curr->w_layer.l_x = cols - 1;
  }
  {
#line 2047
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 2051 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void CursorUp(int n ) 
{ 


  {
#line 2054
  if (curr->w_layer.l_y < curr->w_top) {
#line 2056
    curr->w_layer.l_y -= n;
#line 2056
    if (curr->w_layer.l_y < 0) {
#line 2057
      curr->w_layer.l_y = 0;
    }
  } else {
#line 2060
    curr->w_layer.l_y -= n;
#line 2060
    if (curr->w_layer.l_y < curr->w_top) {
#line 2061
      curr->w_layer.l_y = curr->w_top;
    }
  }
  {
#line 2062
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 2066 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void CursorDown(int n ) 
{ 


  {
#line 2069
  if (curr->w_layer.l_y > curr->w_bot) {
#line 2071
    curr->w_layer.l_y += n;
#line 2071
    if (curr->w_layer.l_y > rows - 1) {
#line 2072
      curr->w_layer.l_y = rows - 1;
    }
  } else {
#line 2075
    curr->w_layer.l_y += n;
#line 2075
    if (curr->w_layer.l_y > curr->w_bot) {
#line 2076
      curr->w_layer.l_y = curr->w_bot;
    }
  }
  {
#line 2077
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 2081 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void CursorLeft(int n ) 
{ 


  {
#line 2084
  curr->w_layer.l_x -= n;
#line 2084
  if (curr->w_layer.l_x < 0) {
#line 2085
    curr->w_layer.l_x = 0;
  }
  {
#line 2086
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
  }
  return;
}
}
#line 2090 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void ASetMode(int on ) 
{ 
  register int i ;
  struct display *olddisplay ;
  struct canvas *cv ;
  int tmp ;

  {
#line 2095
  i = 0;
  {
#line 2095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2095
    if (! (i < curr->w_NumArgs)) {
#line 2095
      goto while_break;
    }
    {
#line 2100
    if (curr->w_args[i] == 4) {
#line 2100
      goto case_4;
    }
#line 2105
    if (curr->w_args[i] == 20) {
#line 2105
      goto case_20;
    }
#line 2108
    if (curr->w_args[i] == 34) {
#line 2108
      goto case_34;
    }
#line 2112
    goto switch_default;
    case_4: /* CIL Label */ 
#line 2101
    curr->w_insert = on;
    {
#line 2102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2102
      olddisplay = display;
#line 2102
      display = displays;
      {
#line 2102
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2102
        if (! display) {
#line 2102
          goto while_break___1;
        }
#line 2102
        cv = display->d_cvlist;
        {
#line 2102
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2102
          if (! cv) {
#line 2102
            goto while_break___2;
          }
#line 2102
          if (cv->c_layer == & curr->w_layer) {
#line 2102
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2102
        cv = cv->c_next;
#line 2102
        if (cv == (struct canvas *)0) {
#line 2102
          goto while_continue___1;
        }
        {
#line 2102
        InsertMode(on);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2102
      display = display->d_next;
#line 2102
      display = olddisplay;
#line 2102
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2103
    goto switch_break;
    case_20: /* CIL Label */ 
#line 2106
    curr->w_autolf = on;
#line 2107
    goto switch_break;
    case_34: /* CIL Label */ 
#line 2109
    curr->w_curvvis = ! on;
#line 2110
    if (curr->w_curinv) {
#line 2110
      tmp = - 1;
    } else {
#line 2110
      tmp = curr->w_curvvis;
    }
    {
#line 2110
    LCursorVisibility(& curr->w_layer, tmp);
    }
#line 2111
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2113
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2095
  i ++;
  return;
}
}
#line 2118 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static char rendlist[]  = 
#line 2118
  {      (char )(~ ((1 << 6) - 1)),      (char )(1 << 2),      (char )1,      (char )(1 << 4), 
        (char )(1 << 1),      (char )(1 << 5),      (char )0,      (char )(1 << 3), 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )(~ (((1 << 2) | (1 << 4)) | 1)),      (char )(~ (1 << 4)), 
        (char )(~ (1 << 1)),      (char )(~ (1 << 5)),      (char )0,      (char )(~ (1 << 3))};
#line 2126 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void SelectRendition(void) 
{ 
  register int j ;
  register int i ;
  register int a ;
  register int c ;
  int jj ;
  int __cil_tmp6 ;
  int tmp ;

  {
#line 2129
  i = 0;
#line 2129
  a = (int )curr->w_rend.attr;
#line 2129
  c = (int )curr->w_rend.color;
  {
#line 2137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2139
    j = curr->w_args[i];
#line 2141
    if (j == 38) {
      _L: /* CIL Label */ 
#line 2141
      if (i + 2 < curr->w_NumArgs) {
#line 2141
        if (curr->w_args[i + 1] == 5) {
#line 2145
          i += 2;
#line 2146
          jj = curr->w_args[i];
#line 2147
          if (jj < 0) {
#line 2148
            goto while_continue;
          } else
#line 2147
          if (jj > 255) {
#line 2148
            goto while_continue;
          }
          {
#line 2173
          __cil_tmp6 = color256to16(jj);
#line 2173
          jj = __cil_tmp6 + 30;
          }
#line 2174
          if (jj >= 38) {
#line 2175
            jj += 52;
          }
#line 2176
          if (j == 38) {
#line 2176
            tmp = jj;
          } else {
#line 2176
            tmp = jj + 10;
          }
#line 2176
          j = tmp;
        }
      }
    } else
#line 2141
    if (j == 48) {
#line 2141
      goto _L;
    }
#line 2180
    if (j == 0) {
#line 2181
      a &= 191;
    } else
#line 2180
    if (j >= 30) {
#line 2180
      if (j <= 39) {
#line 2180
        if (j != 38) {
#line 2181
          a &= 191;
        }
      }
    }
#line 2182
    if (j == 0) {
#line 2183
      a &= 127;
    } else
#line 2182
    if (j >= 40) {
#line 2182
      if (j <= 49) {
#line 2182
        if (j != 48) {
#line 2183
          a &= 127;
        }
      }
    }
#line 2184
    if (j >= 90) {
#line 2184
      if (j <= 97) {
#line 2185
        a |= 64;
      }
    }
#line 2186
    if (j >= 100) {
#line 2186
      if (j <= 107) {
#line 2187
        a |= 128;
      }
    }
#line 2189
    if (j >= 90) {
#line 2189
      if (j <= 97) {
#line 2190
        j -= 60;
      }
    }
#line 2191
    if (j >= 100) {
#line 2191
      if (j <= 107) {
#line 2192
        j -= 60;
      }
    }
#line 2193
    if (j >= 30) {
#line 2193
      if (j <= 39) {
#line 2193
        if (j != 38) {
#line 2194
          c = (c & 240) | ((j - 30) ^ 9);
        } else {
#line 2193
          goto _L___1075;
        }
      } else {
#line 2193
        goto _L___1075;
      }
    } else
    _L___1075: /* CIL Label */ 
#line 2195
    if (j >= 40) {
#line 2195
      if (j <= 49) {
#line 2195
        if (j != 48) {
#line 2196
          c = (c & 15) | (((j - 40) ^ 9) << 4);
        }
      }
    }
#line 2197
    if (j == 0) {
#line 2198
      c = 0;
    }
#line 2206
    if (j < 0) {
#line 2207
      goto while_continue;
    } else
#line 2206
    if (j >= (int )(sizeof(rendlist) / sizeof(*((char *)rendlist)))) {
#line 2207
      goto while_continue;
    }
#line 2208
    j = (int )rendlist[j];
#line 2209
    if (j & (1 << 6)) {
#line 2210
      a &= j;
    } else {
#line 2212
      a |= j;
    }
#line 2137
    if (! (i < curr->w_NumArgs)) {
#line 2137
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2215
  curr->w_rend.attr = (unsigned char )a;
#line 2217
  curr->w_rend.color = (unsigned char )c;
#line 2222
  LSetRendition(& curr->w_layer, & curr->w_rend);
  }
  return;
}
}
#line 2226 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void FillWithEs(void) 
{ 
  register int i ;
  register unsigned char *p ;
  register unsigned char *ep ;
  unsigned char *__cil_tmp4 ;

  {
  {
#line 2231
  LClearAll(& curr->w_layer, 1);
#line 2232
  curr->w_layer.l_x = 0;
#line 2232
  curr->w_layer.l_y = curr->w_layer.l_x;
#line 2233
  i = 0;
  }
  {
#line 2233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2233
    if (! (i < rows)) {
#line 2233
      goto while_break;
    }
    {
#line 2235
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2235
      bclear((char *)(curr->w_mlines + i)->image + 0, cols + 1);
      }
#line 2235
      if ((curr->w_mlines + i)->attr != null) {
        {
#line 2235
        bzero((void *)((char *)(curr->w_mlines + i)->attr + 0), (unsigned long )(cols + 1));
        }
      }
#line 2235
      if ((curr->w_mlines + i)->font != null) {
        {
#line 2235
        bzero((void *)((char *)(curr->w_mlines + i)->font + 0), (unsigned long )(cols + 1));
        }
      }
#line 2235
      if ((curr->w_mlines + i)->fontx != null) {
        {
#line 2235
        bzero((void *)((char *)(curr->w_mlines + i)->fontx + 0), (unsigned long )(cols + 1));
        }
      }
#line 2235
      if ((curr->w_mlines + i)->color != null) {
        {
#line 2235
        bzero((void *)((char *)(curr->w_mlines + i)->color + 0), (unsigned long )(cols + 1));
        }
      }
#line 2235
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2236
    p = (curr->w_mlines + i)->image;
#line 2237
    ep = p + cols;
    {
#line 2238
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2238
      if (! (p < ep)) {
#line 2238
        goto while_break___1;
      }
#line 2239
      __cil_tmp4 = p;
#line 2239
      p ++;
#line 2239
      *__cil_tmp4 = (unsigned char )'E';
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2233
  i ++;
#line 2241
  LRefreshAll(& curr->w_layer, 1);
  }
  return;
}
}
#line 2252 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void ChangeAKA(struct win *p , char *s , int l ) 
{ 
  int i ;
  int c ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;

  {
#line 2259
  i = 0;
  {
#line 2259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2259
    if (! (l > 0)) {
#line 2259
      goto while_break;
    }
#line 2261
    if (p->w_akachange + i == ((char *)p->w_akabuf + sizeof(p->w_akabuf)) - 1) {
#line 2262
      goto while_break;
    }
#line 2263
    __cil_tmp6 = s;
#line 2263
    s ++;
#line 2263
    c = (int )((unsigned char )*__cil_tmp6);
#line 2264
    if (c == 0) {
#line 2265
      goto while_break;
    }
#line 2266
    if (c < 32) {
#line 2267
      goto while_continue;
    } else
#line 2266
    if (c == 127) {
#line 2267
      goto while_continue;
    } else
#line 2266
    if (c >= 128) {
#line 2266
      if (c < 160) {
#line 2266
        if (p->w_c1) {
#line 2267
          goto while_continue;
        }
      }
    }
#line 2268
    __cil_tmp7 = i;
#line 2268
    i ++;
#line 2268
    *(p->w_akachange + __cil_tmp7) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 2259
  __cil_tmp8 = l;
#line 2259
  l --;
#line 2270
  *(p->w_akachange + i) = (char )0;
#line 2271
  p->w_title = p->w_akachange;
#line 2272
  if (p->w_akachange != (char *)p->w_akabuf) {
#line 2273
    if ((int )*(p->w_akachange + 0) == 0) {
      {
      {
#line 2274
      __cil_tmp9 = strlen((char const   *)((char *)p->w_akabuf));
      }
#line 2274
      p->w_title = ((char *)p->w_akabuf + __cil_tmp9) + 1;
      }
    } else
#line 2273
    if ((int )*(p->w_akachange + -1) == 58) {
      {
      {
#line 2274
      __cil_tmp9 = strlen((char const   *)((char *)p->w_akabuf));
      }
#line 2274
      p->w_title = ((char *)p->w_akabuf + __cil_tmp9) + 1;
      }
    }
  }
  {
#line 2275
  WindowChanged(p, 't');
#line 2276
  WindowChanged((struct win *)0, 'w');
#line 2277
  WindowChanged((struct win *)0, 'W');
  }
  return;
}
}
#line 2281 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void FindAKA(void) 
{ 
  register unsigned char *cp ;
  register unsigned char *line ;
  register struct win *wp ;
  register int len ;
  size_t __cil_tmp5 ;
  int y ;
  int tmp ;
  int __cil_tmp8 ;
  int __cil_tmp10 ;
  unsigned char *__cil_tmp11 ;
  unsigned char *__cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 2284
  wp = curr;
#line 2285
  __cil_tmp5 = strlen((char const   *)((char *)wp->w_akabuf));
#line 2285
  len = (int )__cil_tmp5;
  }
#line 2288
  if (wp->w_autoaka > 0 && wp->w_autoaka <= wp->w_layer.l_height) {
#line 2288
    tmp = wp->w_autoaka - 1;
  } else {
#line 2288
    tmp = wp->w_layer.l_y;
  }
#line 2288
  y = tmp;
#line 2289
  cols = wp->w_layer.l_width;
  try_line: 
#line 2291
  line = (wp->w_mlines + y)->image;
#line 2291
  cp = line;
#line 2292
  if (wp->w_autoaka > 0) {
#line 2292
    if ((int )*((char *)wp->w_akabuf) != 0) {
      {
#line 2294
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2294
        if (! 1) {
#line 2294
          goto while_break;
        }
#line 2296
        if (cp - line >= (long )(cols - len)) {
#line 2298
          y ++;
#line 2298
          if (y == wp->w_autoaka) {
#line 2298
            if (y < rows) {
#line 2299
              goto try_line;
            }
          }
#line 2300
          return;
        }
        {
#line 2302
        __cil_tmp8 = strncmp((char const   *)((char *)cp), (char const   *)((char *)wp->w_akabuf),
                             (unsigned long )len);
        }
#line 2302
        if (__cil_tmp8 == 0) {
#line 2303
          goto while_break;
        }
#line 2304
        cp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2306
      cp += len;
    }
  }
#line 2308
  len = (int )((long )cols - (cp - line));
  {
#line 2308
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2308
    if (! (len && (int )*cp == 32)) {
#line 2308
      goto while_break___0;
    }

  }
  while_break___0: /* CIL Label */ ;
  }
#line 2308
  __cil_tmp11 = cp;
#line 2308
  cp ++;
#line 2308
  __cil_tmp10 = len;
#line 2308
  len --;
#line 2310
  if (len) {
#line 2312
    if (wp->w_autoaka > 0) {
#line 2312
      if ((int )*cp == 33) {
#line 2313
        wp->w_autoaka = - 1;
      } else
#line 2312
      if ((int )*cp == 37) {
#line 2313
        wp->w_autoaka = - 1;
      } else
#line 2312
      if ((int )*cp == 94) {
#line 2313
        wp->w_autoaka = - 1;
      } else {
#line 2315
        wp->w_autoaka = 0;
      }
    } else {
#line 2315
      wp->w_autoaka = 0;
    }
#line 2316
    line = cp;
    {
#line 2317
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2317
      if (! (len && (int )*cp != 32)) {
#line 2317
        goto while_break___1;
      }
#line 2319
      __cil_tmp12 = cp;
#line 2319
      cp ++;
#line 2319
      if ((int )*__cil_tmp12 == 47) {
#line 2320
        line = cp;
      }
#line 2321
      __cil_tmp13 = len;
#line 2321
      len --;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2323
    ChangeAKA(wp, (char *)line, (int )(cp - line));
    }
  } else {
#line 2326
    wp->w_autoaka = 0;
  }
  return;
}
}
#line 2330 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void RestorePosRendition(void) 
{ 


  {
  {
#line 2332
  LGotoPos(& curr->w_layer, curr->w_layer.l_x, curr->w_layer.l_y);
#line 2333
  LSetRendition(& curr->w_layer, & curr->w_rend);
  }
  return;
}
}
#line 2338 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void Report(char *fmt , int n1 , int n2 ) 
{ 
  register int len ;
  char rbuf[40] ;
  size_t __cil_tmp6 ;

  {
  {
#line 2345
  sprintf((char *)rbuf, (char const   *)fmt, n1, n2);
#line 2346
  __cil_tmp6 = strlen((char const   *)((char *)rbuf));
#line 2346
  len = (int )__cil_tmp6;
  }
#line 2349
  if (curr->w_pwin) {
#line 2349
    if ((curr->w_pwin)->p_fdpat & 4096) {
#line 2351
      if ((unsigned long )((unsigned int )((curr->w_pwin)->p_inlen + len)) <= sizeof((curr->w_pwin)->p_inbuf)) {
        {
#line 2353
        bcopy((void const   *)((char *)rbuf), (void *)((char *)(curr->w_pwin)->p_inbuf + (curr->w_pwin)->p_inlen),
              (size_t )len);
#line 2354
        (curr->w_pwin)->p_inlen += len;
        }
      }
    } else {
#line 2349
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2360
  if ((unsigned long )((unsigned int )(curr->w_inlen + len)) <= sizeof(curr->w_inbuf)) {
    {
#line 2362
    bcopy((void const   *)((char *)rbuf), (void *)((char *)curr->w_inbuf + curr->w_inlen),
          (size_t )len);
#line 2363
    curr->w_inlen += len;
    }
  }
  return;
}
}
#line 2382 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MFixLine(struct win *p , int y , struct mchar *mc ) 
{ 
  struct mline *ml ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  int tmp ;
  int tmp___1077 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
#line 2387
  ml = & *(p->w_mlines + y);
#line 2388
  if ((int )mc->attr) {
#line 2388
    if (ml->attr == null) {
      {
#line 2390
      __cil_tmp5 = calloc((unsigned long )(p->w_layer.l_width + 1), (unsigned long )1);
#line 2390
      ml->attr = (unsigned char *)__cil_tmp5;
      }
#line 2390
      if (ml->attr == (unsigned char *)0) {
        {
#line 2392
        ml->attr = null;
#line 2393
        p->w_rend.attr = (unsigned char )0;
#line 2393
        mc->attr = p->w_rend.attr;
#line 2394
        WMsg(p, 0, (char *)"Warning: no space for attr - turned off");
        }
      }
    }
  }
#line 2398
  if ((int )mc->font) {
#line 2398
    if (ml->font == null) {
      {
#line 2400
      __cil_tmp6 = calloc((unsigned long )(p->w_layer.l_width + 1), (unsigned long )1);
#line 2400
      ml->font = (unsigned char *)__cil_tmp6;
      }
#line 2400
      if (ml->font == (unsigned char *)0) {
#line 2402
        ml->font = null;
#line 2403
        if (p->w_ss) {
#line 2403
          tmp = p->w_ss;
        } else {
#line 2403
          tmp = p->w_Charset;
        }
#line 2403
        p->w_charsets[tmp] = 0;
#line 2403
        p->w_FontL = (char )p->w_charsets[tmp];
#line 2404
        if (p->w_ss) {
#line 2404
          tmp___1077 = p->w_ss;
        } else {
#line 2404
          tmp___1077 = p->w_CharsetR;
        }
        {
#line 2404
        p->w_charsets[tmp___1077] = 0;
#line 2404
        p->w_FontR = (char )p->w_charsets[tmp___1077];
#line 2405
        p->w_rend.font = (unsigned char )0;
#line 2405
        mc->fontx = p->w_rend.font;
#line 2405
        mc->font = mc->fontx;
#line 2406
        WMsg(p, 0, (char *)"Warning: no space for font - turned off");
        }
      }
    }
  }
#line 2409
  if ((int )mc->fontx) {
#line 2409
    if (ml->fontx == null) {
      {
#line 2411
      __cil_tmp9 = calloc((unsigned long )(p->w_layer.l_width + 1), (unsigned long )1);
#line 2411
      ml->fontx = (unsigned char *)__cil_tmp9;
      }
#line 2411
      if (ml->fontx == (unsigned char *)0) {
#line 2413
        ml->fontx = null;
#line 2414
        mc->fontx = (unsigned char )0;
      }
    }
  }
#line 2419
  if ((int )mc->color) {
#line 2419
    if (ml->color == null) {
      {
#line 2421
      __cil_tmp10 = calloc((unsigned long )(p->w_layer.l_width + 1), (unsigned long )1);
#line 2421
      ml->color = (unsigned char *)__cil_tmp10;
      }
#line 2421
      if (ml->color == (unsigned char *)0) {
        {
#line 2423
        ml->color = null;
#line 2424
        p->w_rend.color = (unsigned char )0;
#line 2424
        mc->color = p->w_rend.color;
#line 2425
        WMsg(p, 0, (char *)"Warning: no space for color - turned off");
        }
      }
    }
  }
  return;
}
}
#line 2465 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MScrollH(struct win *p , int n , int y , int xs , int xe , int bce ) 
{ 
  struct mline *ml ;
  int tmp ;
  int tmp___1078 ;
  int tmp___1079 ;
  int tmp___1080 ;

  {
#line 2471
  if (n == 0) {
#line 2472
    return;
  }
#line 2473
  ml = & *(p->w_mlines + y);
#line 2474
  if (p->w_layer.l_encoding == 8) {
#line 2474
    tmp = (int )*(ml->font + xs) == 255 && (int )*(ml->image + xs) == 255;
  } else {
#line 2474
    tmp = ((int )*(ml->font + xs) & 224) == 128;
  }
#line 2474
  if (tmp) {
#line 2474
    if (xs > 0) {
      {
#line 2474
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2474
        *(ml->image + (xs - 1)) = mchar_blank.image;
#line 2474
        *(ml->attr + (xs - 1)) = mchar_blank.attr;
#line 2474
        *(ml->font + (xs - 1)) = mchar_blank.font;
#line 2474
        *(ml->fontx + (xs - 1)) = mchar_blank.fontx;
#line 2474
        *(ml->color + (xs - 1)) = mchar_blank.color;
#line 2474
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2474
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2474
      *(ml->image + xs) = mchar_blank.image;
#line 2474
      *(ml->attr + xs) = mchar_blank.attr;
#line 2474
      *(ml->font + xs) = mchar_blank.font;
#line 2474
      *(ml->fontx + xs) = mchar_blank.fontx;
#line 2474
      *(ml->color + xs) = mchar_blank.color;
#line 2474
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }

#line 2475
  if (p->w_layer.l_encoding == 8) {
#line 2475
    tmp___1078 = (int )*(ml->font + (xe + 1)) == 255 && (int )*(ml->image + (xe + 1)) == 255;
  } else {
#line 2475
    tmp___1078 = ((int )*(ml->font + xe) & 31) != 0 && ((int )*(ml->font + xe) & 224) == 0;
  }
#line 2475
  if (tmp___1078) {
    {
#line 2475
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2475
      *(ml->image + xe) = mchar_blank.image;
#line 2475
      *(ml->attr + xe) = mchar_blank.attr;
#line 2475
      *(ml->font + xe) = mchar_blank.font;
#line 2475
      *(ml->fontx + xe) = mchar_blank.fontx;
#line 2475
      *(ml->color + xe) = mchar_blank.color;
#line 2475
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2475
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2475
      *(ml->image + (xe + 1)) = mchar_blank.image;
#line 2475
      *(ml->attr + (xe + 1)) = mchar_blank.attr;
#line 2475
      *(ml->font + (xe + 1)) = mchar_blank.font;
#line 2475
      *(ml->fontx + (xe + 1)) = mchar_blank.fontx;
#line 2475
      *(ml->color + (xe + 1)) = mchar_blank.color;
#line 2475
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }

#line 2476
  if (n > 0) {
#line 2478
    if ((xe - xs) + 1 > n) {
#line 2480
      if (p->w_layer.l_encoding == 8) {
#line 2480
        tmp___1079 = (int )*(ml->font + (xs + n)) == 255 && (int )*(ml->image + (xs + n)) == 255;
      } else {
#line 2480
        tmp___1079 = ((int )*(ml->font + (xs + n)) & 224) == 128;
      }
#line 2480
      if (tmp___1079) {
#line 2480
        if (xs + n > 0) {
          {
#line 2480
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2480
            *(ml->image + ((xs + n) - 1)) = mchar_blank.image;
#line 2480
            *(ml->attr + ((xs + n) - 1)) = mchar_blank.attr;
#line 2480
            *(ml->font + ((xs + n) - 1)) = mchar_blank.font;
#line 2480
            *(ml->fontx + ((xs + n) - 1)) = mchar_blank.fontx;
#line 2480
            *(ml->color + ((xs + n) - 1)) = mchar_blank.color;
#line 2480
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        {
#line 2480
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2480
          *(ml->image + (xs + n)) = mchar_blank.image;
#line 2480
          *(ml->attr + (xs + n)) = mchar_blank.attr;
#line 2480
          *(ml->font + (xs + n)) = mchar_blank.font;
#line 2480
          *(ml->fontx + (xs + n)) = mchar_blank.fontx;
#line 2480
          *(ml->color + (xs + n)) = mchar_blank.color;
#line 2480
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }

      {
#line 2481
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 2481
        bcopy((void const   *)((char *)ml->image + (xs + n)), (void *)((char *)ml->image + xs),
              (size_t )(((xe + 1) - xs) - n));
#line 2481
        bcopy((void const   *)((char *)ml->attr + (xs + n)), (void *)((char *)ml->attr + xs),
              (size_t )(((xe + 1) - xs) - n));
#line 2481
        bcopy((void const   *)((char *)ml->font + (xs + n)), (void *)((char *)ml->font + xs),
              (size_t )(((xe + 1) - xs) - n));
#line 2481
        bcopy((void const   *)((char *)ml->fontx + (xs + n)), (void *)((char *)ml->fontx + xs),
              (size_t )(((xe + 1) - xs) - n));
#line 2481
        bcopy((void const   *)((char *)ml->color + (xs + n)), (void *)((char *)ml->color + xs),
              (size_t )(((xe + 1) - xs) - n));
        }
#line 2481
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
#line 2484
      n = (xe - xs) + 1;
    }
    {
#line 2485
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 2485
      bclear((char *)ml->image + ((xe + 1) - n), n);
      }
#line 2485
      if (ml->attr != null) {
        {
#line 2485
        bzero((void *)((char *)ml->attr + ((xe + 1) - n)), (unsigned long )n);
        }
      }
#line 2485
      if (ml->font != null) {
        {
#line 2485
        bzero((void *)((char *)ml->font + ((xe + 1) - n)), (unsigned long )n);
        }
      }
#line 2485
      if (ml->fontx != null) {
        {
#line 2485
        bzero((void *)((char *)ml->fontx + ((xe + 1) - n)), (unsigned long )n);
        }
      }
#line 2485
      if (ml->color != null) {
        {
#line 2485
        bzero((void *)((char *)ml->color + ((xe + 1) - n)), (unsigned long )n);
        }
      }
#line 2485
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2487
    if (bce) {
      {
#line 2488
      MBceLine(p, y, (xe + 1) - n, n, bce);
      }
    }
  } else {
#line 2493
    n = - n;
#line 2494
    if ((xe - xs) + 1 > n) {
#line 2496
      if (p->w_layer.l_encoding == 8) {
#line 2496
        tmp___1080 = (int )*(ml->font + ((xe - n) + 1)) == 255 && (int )*(ml->image + ((xe - n) + 1)) == 255;
      } else {
#line 2496
        tmp___1080 = ((int )*(ml->font + (xe - n)) & 31) != 0 && ((int )*(ml->font + (xe - n)) & 224) == 0;
      }
#line 2496
      if (tmp___1080) {
        {
#line 2496
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2496
          *(ml->image + (xe - n)) = mchar_blank.image;
#line 2496
          *(ml->attr + (xe - n)) = mchar_blank.attr;
#line 2496
          *(ml->font + (xe - n)) = mchar_blank.font;
#line 2496
          *(ml->fontx + (xe - n)) = mchar_blank.fontx;
#line 2496
          *(ml->color + (xe - n)) = mchar_blank.color;
#line 2496
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 2496
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2496
          *(ml->image + ((xe - n) + 1)) = mchar_blank.image;
#line 2496
          *(ml->attr + ((xe - n) + 1)) = mchar_blank.attr;
#line 2496
          *(ml->font + ((xe - n) + 1)) = mchar_blank.font;
#line 2496
          *(ml->fontx + ((xe - n) + 1)) = mchar_blank.fontx;
#line 2496
          *(ml->color + ((xe - n) + 1)) = mchar_blank.color;
#line 2496
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }

      {
#line 2497
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 2497
        bcopy((void const   *)((char *)ml->image + xs), (void *)((char *)ml->image + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
#line 2497
        bcopy((void const   *)((char *)ml->attr + xs), (void *)((char *)ml->attr + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
#line 2497
        bcopy((void const   *)((char *)ml->font + xs), (void *)((char *)ml->font + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
#line 2497
        bcopy((void const   *)((char *)ml->fontx + xs), (void *)((char *)ml->fontx + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
#line 2497
        bcopy((void const   *)((char *)ml->color + xs), (void *)((char *)ml->color + (xs + n)),
              (size_t )(((xe + 1) - xs) - n));
        }
#line 2497
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    } else {
#line 2500
      n = (xe - xs) + 1;
    }
    {
#line 2501
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 2501
      bclear((char *)ml->image + xs, n);
      }
#line 2501
      if (ml->attr != null) {
        {
#line 2501
        bzero((void *)((char *)ml->attr + xs), (unsigned long )n);
        }
      }
#line 2501
      if (ml->font != null) {
        {
#line 2501
        bzero((void *)((char *)ml->font + xs), (unsigned long )n);
        }
      }
#line 2501
      if (ml->fontx != null) {
        {
#line 2501
        bzero((void *)((char *)ml->fontx + xs), (unsigned long )n);
        }
      }
#line 2501
      if (ml->color != null) {
        {
#line 2501
        bzero((void *)((char *)ml->color + xs), (unsigned long )n);
        }
      }
#line 2501
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 2503
    if (bce) {
      {
#line 2504
      MBceLine(p, y, xs, n, bce);
      }
    }
  }
  return;
}
}
#line 2510 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MScrollV(struct win *p , int n , int ys , int ye , int bce ) 
{ 
  int i ;
  int cnt1 ;
  int cnt2 ;
  struct mline tmp[256] ;
  struct mline *ml ;
  int __cil_tmp12 ;
  struct mline *__cil_tmp13 ;
  int __cil_tmp14 ;
  struct mline *__cil_tmp15 ;

  {
#line 2518
  if (n == 0) {
#line 2519
    return;
  }
#line 2520
  if (n > 0) {
#line 2522
    if ((ye - ys) + 1 < n) {
#line 2523
      n = (ye - ys) + 1;
    }
#line 2524
    if (n > 256) {
      {
#line 2526
      MScrollV(p, n - 256, ys, ye, bce);
#line 2527
      n = 256;
      }
    }
#line 2530
    if (compacthist) {
      {
#line 2532
      ye = MFindUsedLine(p, ye, ys);
      }
#line 2533
      if ((ye - ys) + 1 < n) {
#line 2534
        n = (ye - ys) + 1;
      }
#line 2535
      if (n <= 0) {
#line 2536
        return;
      }
    }
#line 2540
    ml = p->w_mlines + ys;
#line 2541
    i = ys;
    {
#line 2541
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2541
      if (! (i < ys + n)) {
#line 2541
        goto while_break;
      }
#line 2544
      if (ys == p->w_top) {
        {
#line 2545
        WAddLineToHist(p, ml);
        }
      }
#line 2547
      if (ml->attr != null) {
        {
#line 2548
        free((void *)ml->attr);
        }
      }
#line 2549
      ml->attr = null;
#line 2551
      if (ml->font != null) {
        {
#line 2552
        free((void *)ml->font);
        }
      }
#line 2553
      ml->font = null;
#line 2554
      if (ml->fontx != null) {
        {
#line 2555
        free((void *)ml->fontx);
        }
      }
#line 2556
      ml->fontx = null;
#line 2559
      if (ml->color != null) {
        {
#line 2560
        free((void *)ml->color);
        }
      }
      {
#line 2561
      ml->color = null;
#line 2568
      bclear((char *)ml->image, p->w_layer.l_width + 1);
      }
#line 2570
      if (bce) {
        {
#line 2571
        MBceLine(p, i, 0, p->w_layer.l_width, bce);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2541
    __cil_tmp13 = ml;
#line 2541
    ml ++;
#line 2541
    __cil_tmp12 = i;
#line 2541
    i ++;
#line 2575
    cnt1 = (int )((unsigned long )n * sizeof(struct mline ));
#line 2576
    cnt2 = (int )((unsigned long )(((ye - ys) + 1) - n) * sizeof(struct mline ));
#line 2577
    if (cnt1) {
#line 2577
      if (cnt2) {
        {
#line 2578
        Scroll((char *)(p->w_mlines + ys), cnt1, cnt2, (char *)((struct mline *)tmp));
        }
      }
    }
  } else {
#line 2582
    n = - n;
#line 2583
    if ((ye - ys) + 1 < n) {
#line 2584
      n = (ye - ys) + 1;
    }
#line 2585
    if (n > 256) {
      {
#line 2587
      MScrollV(p, - (n - 256), ys, ye, bce);
#line 2588
      n = 256;
      }
    }
#line 2591
    ml = p->w_mlines + ye;
#line 2593
    i = ye;
    {
#line 2593
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2593
      if (! (i > ye - n)) {
#line 2593
        goto while_break___0;
      }
#line 2595
      if (ml->attr != null) {
        {
#line 2596
        free((void *)ml->attr);
        }
      }
#line 2597
      ml->attr = null;
#line 2599
      if (ml->font != null) {
        {
#line 2600
        free((void *)ml->font);
        }
      }
#line 2601
      ml->font = null;
#line 2602
      if (ml->fontx != null) {
        {
#line 2603
        free((void *)ml->fontx);
        }
      }
#line 2604
      ml->fontx = null;
#line 2607
      if (ml->color != null) {
        {
#line 2608
        free((void *)ml->color);
        }
      }
      {
#line 2609
      ml->color = null;
#line 2616
      bclear((char *)ml->image, p->w_layer.l_width + 1);
      }
#line 2618
      if (bce) {
        {
#line 2619
        MBceLine(p, i, 0, p->w_layer.l_width, bce);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2593
    __cil_tmp15 = ml;
#line 2593
    ml --;
#line 2593
    __cil_tmp14 = i;
#line 2593
    i --;
#line 2622
    cnt1 = (int )((unsigned long )n * sizeof(struct mline ));
#line 2623
    cnt2 = (int )((unsigned long )(((ye - ys) + 1) - n) * sizeof(struct mline ));
#line 2624
    if (cnt1) {
#line 2624
      if (cnt2) {
        {
#line 2625
        Scroll((char *)(p->w_mlines + ys), cnt2, cnt1, (char *)((struct mline *)tmp));
        }
      }
    }
  }
  return;
}
}
#line 2630 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void Scroll(char *cp , int cnt1 , int cnt2 , char *tmp ) 
{ 


  {
#line 2634
  if (! cnt1) {
#line 2635
    return;
  } else
#line 2634
  if (! cnt2) {
#line 2635
    return;
  }
#line 2636
  if (cnt1 <= cnt2) {
    {
#line 2638
    bcopy((void const   *)cp, (void *)tmp, (size_t )cnt1);
#line 2639
    bcopy((void const   *)(cp + cnt1), (void *)cp, (size_t )cnt2);
#line 2640
    bcopy((void const   *)tmp, (void *)(cp + cnt2), (size_t )cnt1);
    }
  } else {
    {
#line 2644
    bcopy((void const   *)(cp + cnt1), (void *)tmp, (size_t )cnt2);
#line 2645
    bcopy((void const   *)cp, (void *)(cp + cnt2), (size_t )cnt1);
#line 2646
    bcopy((void const   *)tmp, (void *)cp, (size_t )cnt2);
    }
  }
  return;
}
}
#line 2651 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MClearArea(struct win *p , int xs , int ys , int xe , int ye , int bce ) 
{ 
  int n ;
  int y ;
  int xxe ;
  struct mline *ml ;
  int tmp ;
  int tmp___1081 ;
  int tmp___1082 ;
  int __cil_tmp14 ;
  struct mline *__cil_tmp15 ;

  {
#line 2660
  if (ys < 0) {
#line 2661
    return;
  } else
#line 2660
  if (ye < ys) {
#line 2661
    return;
  }
#line 2664
  if (xs >= p->w_layer.l_width) {
#line 2665
    xs = p->w_layer.l_width - 1;
  }
#line 2666
  if (xe >= p->w_layer.l_width) {
#line 2667
    xe = p->w_layer.l_width - 1;
  }
#line 2669
  if (p->w_layer.l_encoding == 8) {
#line 2669
    tmp = (int )*((p->w_mlines + ys)->font + xs) == 255 && (int )*((p->w_mlines + ys)->image + xs) == 255;
  } else {
#line 2669
    tmp = ((int )*((p->w_mlines + ys)->font + xs) & 224) == 128;
  }
#line 2669
  if (tmp) {
#line 2669
    if (xs > 0) {
      {
#line 2669
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2669
        *((p->w_mlines + ys)->image + (xs - 1)) = mchar_blank.image;
#line 2669
        *((p->w_mlines + ys)->attr + (xs - 1)) = mchar_blank.attr;
#line 2669
        *((p->w_mlines + ys)->font + (xs - 1)) = mchar_blank.font;
#line 2669
        *((p->w_mlines + ys)->fontx + (xs - 1)) = mchar_blank.fontx;
#line 2669
        *((p->w_mlines + ys)->color + (xs - 1)) = mchar_blank.color;
#line 2669
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2669
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2669
      *((p->w_mlines + ys)->image + xs) = mchar_blank.image;
#line 2669
      *((p->w_mlines + ys)->attr + xs) = mchar_blank.attr;
#line 2669
      *((p->w_mlines + ys)->font + xs) = mchar_blank.font;
#line 2669
      *((p->w_mlines + ys)->fontx + xs) = mchar_blank.fontx;
#line 2669
      *((p->w_mlines + ys)->color + xs) = mchar_blank.color;
#line 2669
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }

#line 2670
  if (p->w_layer.l_encoding == 8) {
#line 2670
    tmp___1081 = (int )*((p->w_mlines + ye)->font + (xe + 1)) == 255 && (int )*((p->w_mlines + ye)->image + (xe + 1)) == 255;
  } else {
#line 2670
    tmp___1081 = ((int )*((p->w_mlines + ye)->font + xe) & 31) != 0 && ((int )*((p->w_mlines + ye)->font + xe) & 224) == 0;
  }
#line 2670
  if (tmp___1081) {
    {
#line 2670
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2670
      *((p->w_mlines + ye)->image + xe) = mchar_blank.image;
#line 2670
      *((p->w_mlines + ye)->attr + xe) = mchar_blank.attr;
#line 2670
      *((p->w_mlines + ye)->font + xe) = mchar_blank.font;
#line 2670
      *((p->w_mlines + ye)->fontx + xe) = mchar_blank.fontx;
#line 2670
      *((p->w_mlines + ye)->color + xe) = mchar_blank.color;
#line 2670
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2670
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2670
      *((p->w_mlines + ye)->image + (xe + 1)) = mchar_blank.image;
#line 2670
      *((p->w_mlines + ye)->attr + (xe + 1)) = mchar_blank.attr;
#line 2670
      *((p->w_mlines + ye)->font + (xe + 1)) = mchar_blank.font;
#line 2670
      *((p->w_mlines + ye)->fontx + (xe + 1)) = mchar_blank.fontx;
#line 2670
      *((p->w_mlines + ye)->color + (xe + 1)) = mchar_blank.color;
#line 2670
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2672
  ml = p->w_mlines + ys;
#line 2673
  y = ys;
  {
#line 2673
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2673
    if (! (y <= ye)) {
#line 2673
      goto while_break___3;
    }
#line 2675
    if (y == ye) {
#line 2675
      tmp___1082 = xe;
    } else {
#line 2675
      tmp___1082 = p->w_layer.l_width - 1;
    }
#line 2675
    xxe = tmp___1082;
#line 2676
    n = (xxe - xs) + 1;
#line 2677
    if (n > 0) {
      {
#line 2678
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 2678
        bclear((char *)ml->image + xs, n);
        }
#line 2678
        if (ml->attr != null) {
          {
#line 2678
          bzero((void *)((char *)ml->attr + xs), (unsigned long )n);
          }
        }
#line 2678
        if (ml->font != null) {
          {
#line 2678
          bzero((void *)((char *)ml->font + xs), (unsigned long )n);
          }
        }
#line 2678
        if (ml->fontx != null) {
          {
#line 2678
          bzero((void *)((char *)ml->fontx + xs), (unsigned long )n);
          }
        }
#line 2678
        if (ml->color != null) {
          {
#line 2678
          bzero((void *)((char *)ml->color + xs), (unsigned long )n);
          }
        }
#line 2678
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 2680
    if (n > 0) {
#line 2680
      if (bce) {
        {
#line 2681
        MBceLine(p, y, xs, (xs + n) - 1, bce);
        }
      }
    }
#line 2683
    xs = 0;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2673
  __cil_tmp15 = ml;
#line 2673
  ml ++;
#line 2673
  __cil_tmp14 = y;
#line 2673
  y ++;
  return;
}
}
#line 2688 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MInsChar(struct win *p , struct mchar *c , int x , int y ) 
{ 
  int n ;
  struct mline *ml ;
  int tmp ;
  int tmp___1083 ;
  int tmp___1084 ;

  {
  {
#line 2696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2696
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2697
  MFixLine(p, y, c);
#line 2698
  ml = p->w_mlines + y;
#line 2699
  n = (p->w_layer.l_width - x) - 1;
  }
#line 2700
  if (p->w_layer.l_encoding == 8) {
#line 2700
    tmp = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
  } else {
#line 2700
    tmp = ((int )*(ml->font + x) & 224) == 128;
  }
#line 2700
  if (tmp) {
#line 2700
    if (x > 0) {
      {
#line 2700
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2700
        *(ml->image + (x - 1)) = mchar_blank.image;
#line 2700
        *(ml->attr + (x - 1)) = mchar_blank.attr;
#line 2700
        *(ml->font + (x - 1)) = mchar_blank.font;
#line 2700
        *(ml->fontx + (x - 1)) = mchar_blank.fontx;
#line 2700
        *(ml->color + (x - 1)) = mchar_blank.color;
#line 2700
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 2700
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2700
      *(ml->image + x) = mchar_blank.image;
#line 2700
      *(ml->attr + x) = mchar_blank.attr;
#line 2700
      *(ml->font + x) = mchar_blank.font;
#line 2700
      *(ml->fontx + x) = mchar_blank.fontx;
#line 2700
      *(ml->color + x) = mchar_blank.color;
#line 2700
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }

#line 2701
  if (n > 0) {
#line 2703
    if (p->w_layer.l_encoding == 8) {
#line 2703
      tmp___1083 = (int )*(ml->font + (p->w_layer.l_width - 1)) == 255 && (int )*(ml->image + (p->w_layer.l_width - 1)) == 255;
    } else {
#line 2703
      tmp___1083 = ((int )*(ml->font + (p->w_layer.l_width - 1)) & 224) == 128;
    }
#line 2703
    if (tmp___1083) {
#line 2703
      if (p->w_layer.l_width - 1 > 0) {
        {
#line 2703
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2703
          *(ml->image + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.image;
#line 2703
          *(ml->attr + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.attr;
#line 2703
          *(ml->font + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.font;
#line 2703
          *(ml->fontx + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.fontx;
#line 2703
          *(ml->color + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.color;
#line 2703
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 2703
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2703
        *(ml->image + (p->w_layer.l_width - 1)) = mchar_blank.image;
#line 2703
        *(ml->attr + (p->w_layer.l_width - 1)) = mchar_blank.attr;
#line 2703
        *(ml->font + (p->w_layer.l_width - 1)) = mchar_blank.font;
#line 2703
        *(ml->fontx + (p->w_layer.l_width - 1)) = mchar_blank.fontx;
#line 2703
        *(ml->color + (p->w_layer.l_width - 1)) = mchar_blank.color;
#line 2703
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }

    {
#line 2704
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 2704
      bcopy((void const   *)((char *)ml->image + x), (void *)((char *)ml->image + (x + 1)),
            (size_t )n);
#line 2704
      bcopy((void const   *)((char *)ml->attr + x), (void *)((char *)ml->attr + (x + 1)),
            (size_t )n);
#line 2704
      bcopy((void const   *)((char *)ml->font + x), (void *)((char *)ml->font + (x + 1)),
            (size_t )n);
#line 2704
      bcopy((void const   *)((char *)ml->fontx + x), (void *)((char *)ml->fontx + (x + 1)),
            (size_t )n);
#line 2704
      bcopy((void const   *)((char *)ml->color + x), (void *)((char *)ml->color + (x + 1)),
            (size_t )n);
      }
#line 2704
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 2706
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2706
    *(ml->image + x) = c->image;
#line 2706
    *(ml->attr + x) = c->attr;
#line 2706
    *(ml->font + x) = c->font;
#line 2706
    *(ml->fontx + x) = c->fontx;
#line 2706
    *(ml->color + x) = c->color;
#line 2706
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2708
  if (c->mbcs) {
#line 2710
    n --;
#line 2710
    if (n > 0) {
#line 2712
      if (p->w_layer.l_encoding == 8) {
#line 2712
        tmp___1084 = (int )*(ml->font + (p->w_layer.l_width - 1)) == 255 && (int )*(ml->image + (p->w_layer.l_width - 1)) == 255;
      } else {
#line 2712
        tmp___1084 = ((int )*(ml->font + (p->w_layer.l_width - 1)) & 224) == 128;
      }
#line 2712
      if (tmp___1084) {
#line 2712
        if (p->w_layer.l_width - 1 > 0) {
          {
#line 2712
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 2712
            *(ml->image + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.image;
#line 2712
            *(ml->attr + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.attr;
#line 2712
            *(ml->font + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.font;
#line 2712
            *(ml->fontx + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.fontx;
#line 2712
            *(ml->color + ((p->w_layer.l_width - 1) - 1)) = mchar_blank.color;
#line 2712
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
        {
#line 2712
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2712
          *(ml->image + (p->w_layer.l_width - 1)) = mchar_blank.image;
#line 2712
          *(ml->attr + (p->w_layer.l_width - 1)) = mchar_blank.attr;
#line 2712
          *(ml->font + (p->w_layer.l_width - 1)) = mchar_blank.font;
#line 2712
          *(ml->fontx + (p->w_layer.l_width - 1)) = mchar_blank.fontx;
#line 2712
          *(ml->color + (p->w_layer.l_width - 1)) = mchar_blank.color;
#line 2712
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }

      {
#line 2713
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 2713
        bcopy((void const   *)((char *)ml->image + (x + 1)), (void *)((char *)ml->image + (x + 2)),
              (size_t )n);
#line 2713
        bcopy((void const   *)((char *)ml->attr + (x + 1)), (void *)((char *)ml->attr + (x + 2)),
              (size_t )n);
#line 2713
        bcopy((void const   *)((char *)ml->font + (x + 1)), (void *)((char *)ml->font + (x + 2)),
              (size_t )n);
#line 2713
        bcopy((void const   *)((char *)ml->fontx + (x + 1)), (void *)((char *)ml->fontx + (x + 2)),
              (size_t )n);
#line 2713
        bcopy((void const   *)((char *)ml->color + (x + 1)), (void *)((char *)ml->color + (x + 2)),
              (size_t )n);
        }
#line 2713
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
    {
#line 2715
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2715
      *(ml->image + (x + 1)) = c->image;
#line 2715
      *(ml->attr + (x + 1)) = c->attr;
#line 2715
      *(ml->font + (x + 1)) = c->font;
#line 2715
      *(ml->fontx + (x + 1)) = c->fontx;
#line 2715
      *(ml->color + (x + 1)) = c->color;
#line 2715
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2716
    *(ml->image + (x + 1)) = c->mbcs;
#line 2718
    if (p->w_layer.l_encoding != 8) {
#line 2719
      *(ml->font + (x + 1)) |= 128;
    } else
#line 2720
    if (p->w_layer.l_encoding == 8) {
#line 2720
      if ((int )c->mbcs) {
#line 2722
        *(ml->font + (x + 1)) = c->mbcs;
#line 2723
        *(ml->fontx + (x + 1)) = (unsigned char )0;
      }
    }
  }
  return;
}
}
#line 2733 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MPutChar(struct win *p , struct mchar *c , int x , int y ) 
{ 
  struct mline *ml ;
  int tmp ;
  int tmp___1085 ;
  int tmp___1086 ;

  {
  {
#line 2740
  MFixLine(p, y, c);
#line 2741
  ml = & *(p->w_mlines + y);
  }
#line 2742
  if (p->w_layer.l_encoding == 8) {
#line 2742
    tmp = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
  } else {
#line 2742
    tmp = ((int )*(ml->font + x) & 224) == 128;
  }
#line 2742
  if (tmp) {
#line 2742
    if (x > 0) {
      {
#line 2742
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2742
        *(ml->image + (x - 1)) = mchar_blank.image;
#line 2742
        *(ml->attr + (x - 1)) = mchar_blank.attr;
#line 2742
        *(ml->font + (x - 1)) = mchar_blank.font;
#line 2742
        *(ml->fontx + (x - 1)) = mchar_blank.fontx;
#line 2742
        *(ml->color + (x - 1)) = mchar_blank.color;
#line 2742
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2742
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2742
      *(ml->image + x) = mchar_blank.image;
#line 2742
      *(ml->attr + x) = mchar_blank.attr;
#line 2742
      *(ml->font + x) = mchar_blank.font;
#line 2742
      *(ml->fontx + x) = mchar_blank.fontx;
#line 2742
      *(ml->color + x) = mchar_blank.color;
#line 2742
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }

#line 2743
  if (p->w_layer.l_encoding == 8) {
#line 2743
    tmp___1085 = (int )*(ml->font + (x + 1)) == 255 && (int )*(ml->image + (x + 1)) == 255;
  } else {
#line 2743
    tmp___1085 = ((int )*(ml->font + x) & 31) != 0 && ((int )*(ml->font + x) & 224) == 0;
  }
#line 2743
  if (tmp___1085) {
    {
#line 2743
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2743
      *(ml->image + x) = mchar_blank.image;
#line 2743
      *(ml->attr + x) = mchar_blank.attr;
#line 2743
      *(ml->font + x) = mchar_blank.font;
#line 2743
      *(ml->fontx + x) = mchar_blank.fontx;
#line 2743
      *(ml->color + x) = mchar_blank.color;
#line 2743
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2743
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2743
      *(ml->image + (x + 1)) = mchar_blank.image;
#line 2743
      *(ml->attr + (x + 1)) = mchar_blank.attr;
#line 2743
      *(ml->font + (x + 1)) = mchar_blank.font;
#line 2743
      *(ml->fontx + (x + 1)) = mchar_blank.fontx;
#line 2743
      *(ml->color + (x + 1)) = mchar_blank.color;
#line 2743
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }

  {
#line 2744
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2744
    *(ml->image + x) = c->image;
#line 2744
    *(ml->attr + x) = c->attr;
#line 2744
    *(ml->font + x) = c->font;
#line 2744
    *(ml->fontx + x) = c->fontx;
#line 2744
    *(ml->color + x) = c->color;
#line 2744
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2746
  if (c->mbcs) {
#line 2748
    if (p->w_layer.l_encoding == 8) {
#line 2748
      tmp___1086 = (int )*(ml->font + ((x + 1) + 1)) == 255 && (int )*(ml->image + ((x + 1) + 1)) == 255;
    } else {
#line 2748
      tmp___1086 = ((int )*(ml->font + (x + 1)) & 31) != 0 && ((int )*(ml->font + (x + 1)) & 224) == 0;
    }
#line 2748
    if (tmp___1086) {
      {
#line 2748
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2748
        *(ml->image + (x + 1)) = mchar_blank.image;
#line 2748
        *(ml->attr + (x + 1)) = mchar_blank.attr;
#line 2748
        *(ml->font + (x + 1)) = mchar_blank.font;
#line 2748
        *(ml->fontx + (x + 1)) = mchar_blank.fontx;
#line 2748
        *(ml->color + (x + 1)) = mchar_blank.color;
#line 2748
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2748
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2748
        *(ml->image + ((x + 1) + 1)) = mchar_blank.image;
#line 2748
        *(ml->attr + ((x + 1) + 1)) = mchar_blank.attr;
#line 2748
        *(ml->font + ((x + 1) + 1)) = mchar_blank.font;
#line 2748
        *(ml->fontx + ((x + 1) + 1)) = mchar_blank.fontx;
#line 2748
        *(ml->color + ((x + 1) + 1)) = mchar_blank.color;
#line 2748
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }

    {
#line 2749
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2749
      *(ml->image + (x + 1)) = c->image;
#line 2749
      *(ml->attr + (x + 1)) = c->attr;
#line 2749
      *(ml->font + (x + 1)) = c->font;
#line 2749
      *(ml->fontx + (x + 1)) = c->fontx;
#line 2749
      *(ml->color + (x + 1)) = c->color;
#line 2749
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2750
    *(ml->image + (x + 1)) = c->mbcs;
#line 2752
    if (p->w_layer.l_encoding != 8) {
#line 2753
      *(ml->font + (x + 1)) |= 128;
    } else
#line 2754
    if (p->w_layer.l_encoding == 8) {
#line 2754
      if ((int )c->mbcs) {
#line 2756
        *(ml->font + (x + 1)) = c->mbcs;
#line 2757
        *(ml->fontx + (x + 1)) = (unsigned char )0;
      }
    }
  }
  return;
}
}
#line 2768 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MWrapChar(struct win *p , struct mchar *c , int y , int top , int bot ,
                      int ins ) 
{ 
  struct mline *ml ;
  int bce ;
  int tmp ;

  {
#line 2778
  if ((int )c->attr & (1 << 7)) {
#line 2778
    tmp = 256;
  } else {
#line 2778
    tmp = 0;
  }
  {
#line 2778
  bce = (((int )c->color & 240) >> 4) | tmp;
#line 2782
  MFixLine(p, y, c);
#line 2783
  ml = & *(p->w_mlines + y);
  }
  {
#line 2784
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2784
    *(ml->image + p->w_layer.l_width) = mchar_null.image;
#line 2784
    *(ml->attr + p->w_layer.l_width) = mchar_null.attr;
#line 2784
    *(ml->font + p->w_layer.l_width) = mchar_null.font;
#line 2784
    *(ml->fontx + p->w_layer.l_width) = mchar_null.fontx;
#line 2784
    *(ml->color + p->w_layer.l_width) = mchar_null.color;
#line 2784
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2785
  if (y == bot) {
    {
#line 2786
    MScrollV(p, 1, top, bot, bce);
    }
  } else
#line 2787
  if (y < p->w_layer.l_height - 1) {
#line 2788
    y ++;
  }
#line 2789
  if (ins) {
    {
#line 2790
    MInsChar(p, c, 0, y);
    }
  } else {
    {
#line 2792
    MPutChar(p, c, 0, y);
    }
  }
  return;
}
}
#line 2796 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MPutStr(struct win *p , char *s , int n , struct mchar *r , int x , int y ) 
{ 
  struct mline *ml ;
  int i ;
  unsigned char *b ;
  int tmp ;
  int tmp___1087 ;
  int __cil_tmp12 ;
  unsigned char *__cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char *__cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned char *__cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned char *__cil_tmp19 ;

  {
#line 2807
  if (n <= 0) {
#line 2808
    return;
  }
  {
#line 2809
  MFixLine(p, y, r);
#line 2810
  ml = & *(p->w_mlines + y);
  }
#line 2811
  if (p->w_layer.l_encoding == 8) {
#line 2811
    tmp = (int )*(ml->font + x) == 255 && (int )*(ml->image + x) == 255;
  } else {
#line 2811
    tmp = ((int )*(ml->font + x) & 224) == 128;
  }
#line 2811
  if (tmp) {
#line 2811
    if (x > 0) {
      {
#line 2811
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2811
        *(ml->image + (x - 1)) = mchar_blank.image;
#line 2811
        *(ml->attr + (x - 1)) = mchar_blank.attr;
#line 2811
        *(ml->font + (x - 1)) = mchar_blank.font;
#line 2811
        *(ml->fontx + (x - 1)) = mchar_blank.fontx;
#line 2811
        *(ml->color + (x - 1)) = mchar_blank.color;
#line 2811
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 2811
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2811
      *(ml->image + x) = mchar_blank.image;
#line 2811
      *(ml->attr + x) = mchar_blank.attr;
#line 2811
      *(ml->font + x) = mchar_blank.font;
#line 2811
      *(ml->fontx + x) = mchar_blank.fontx;
#line 2811
      *(ml->color + x) = mchar_blank.color;
#line 2811
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }

#line 2812
  if (p->w_layer.l_encoding == 8) {
#line 2812
    tmp___1087 = (int )*(ml->font + (((x + n) - 1) + 1)) == 255 && (int )*(ml->image + (((x + n) - 1) + 1)) == 255;
  } else {
#line 2812
    tmp___1087 = ((int )*(ml->font + ((x + n) - 1)) & 31) != 0 && ((int )*(ml->font + ((x + n) - 1)) & 224) == 0;
  }
#line 2812
  if (tmp___1087) {
    {
#line 2812
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2812
      *(ml->image + ((x + n) - 1)) = mchar_blank.image;
#line 2812
      *(ml->attr + ((x + n) - 1)) = mchar_blank.attr;
#line 2812
      *(ml->font + ((x + n) - 1)) = mchar_blank.font;
#line 2812
      *(ml->fontx + ((x + n) - 1)) = mchar_blank.fontx;
#line 2812
      *(ml->color + ((x + n) - 1)) = mchar_blank.color;
#line 2812
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2812
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2812
      *(ml->image + (((x + n) - 1) + 1)) = mchar_blank.image;
#line 2812
      *(ml->attr + (((x + n) - 1) + 1)) = mchar_blank.attr;
#line 2812
      *(ml->font + (((x + n) - 1) + 1)) = mchar_blank.font;
#line 2812
      *(ml->fontx + (((x + n) - 1) + 1)) = mchar_blank.fontx;
#line 2812
      *(ml->color + (((x + n) - 1) + 1)) = mchar_blank.color;
#line 2812
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 2813
  bcopy((void const   *)s, (void *)((char *)ml->image + x), (size_t )n);
  }
#line 2814
  if (ml->attr != null) {
#line 2816
    b = ml->attr + x;
#line 2817
    i = n;
    {
#line 2817
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2817
      if (! (__cil_tmp12 > 0)) {
#line 2817
        goto while_break___3;
      }
#line 2818
      __cil_tmp13 = b;
#line 2818
      b ++;
#line 2818
      *__cil_tmp13 = r->attr;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 2821
  if (ml->font != null) {
#line 2823
    b = ml->font + x;
#line 2824
    i = n;
    {
#line 2824
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2824
      if (! (__cil_tmp14 > 0)) {
#line 2824
        goto while_break___4;
      }
#line 2825
      __cil_tmp15 = b;
#line 2825
      b ++;
#line 2825
      *__cil_tmp15 = r->font;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 2827
  if (ml->fontx != null) {
#line 2829
    b = ml->fontx + x;
#line 2830
    i = n;
    {
#line 2830
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2830
      if (! (__cil_tmp16 > 0)) {
#line 2830
        goto while_break___5;
      }
#line 2831
      __cil_tmp17 = b;
#line 2831
      b ++;
#line 2831
      *__cil_tmp17 = r->fontx;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 2835
  if (ml->color != null) {
#line 2837
    b = ml->color + x;
#line 2838
    i = n;
    {
#line 2838
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2838
      if (! (__cil_tmp18 > 0)) {
#line 2838
        goto while_break___6;
      }
#line 2839
      __cil_tmp19 = b;
#line 2839
      b ++;
#line 2839
      *__cil_tmp19 = r->color;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 2854 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void MBceLine(struct win *p , int y , int xs , int xe , int bce ) 
{ 
  struct mchar mc ;
  struct mline *ml ;
  int x ;
  int tmp ;

  {
#line 2862
  mc = mchar_null;
#line 2863
  if (bce & 256) {
#line 2863
    tmp = 0;
  } else {
#line 2863
    tmp = 1 << 7;
  }
#line 2863
  mc.attr = (unsigned char )(((int )mc.attr | (1 << 7)) ^ tmp);
  {
#line 2863
  mc.color = (unsigned char )(((int )mc.color & 15) | ((bce << 4) & 240));
#line 2864
  MFixLine(p, y, & mc);
#line 2865
  ml = p->w_mlines + y;
  }
#line 2867
  if (mc.attr) {
#line 2868
    x = xs;
    {
#line 2868
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2868
      if (! (x <= xe)) {
#line 2868
        goto while_break;
      }
#line 2869
      *(ml->attr + x) = mc.attr;
    }
    while_break: /* CIL Label */ ;
    }
#line 2868
    x ++;
  }
#line 2871
  if (mc.color) {
#line 2872
    x = xs;
    {
#line 2872
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2872
      if (! (x <= xe)) {
#line 2872
        goto while_break___0;
      }
#line 2873
      *(ml->color + x) = mc.color;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2872
    x ++;
  }
  return;
}
}
#line 2885 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void WAddLineToHist(struct win *wp , struct mline *ml ) 
{ 
  register unsigned char *q ;
  register unsigned char *o ;
  struct mline *hml ;

  {
#line 2892
  if (wp->w_histheight == 0) {
#line 2893
    return;
  }
#line 2894
  hml = & *(wp->w_hlines + wp->w_histidx);
#line 2895
  q = ml->image;
#line 2895
  ml->image = hml->image;
#line 2895
  hml->image = q;
#line 2897
  q = ml->attr;
#line 2897
  o = hml->attr;
#line 2897
  hml->attr = q;
#line 2897
  ml->attr = null;
#line 2898
  if (o != null) {
    {
#line 2899
    free((void *)o);
    }
  }
#line 2902
  q = ml->font;
#line 2902
  o = hml->font;
#line 2902
  hml->font = q;
#line 2902
  ml->font = null;
#line 2903
  if (o != null) {
    {
#line 2904
    free((void *)o);
    }
  }
#line 2905
  q = ml->fontx;
#line 2905
  o = hml->fontx;
#line 2905
  hml->fontx = q;
#line 2905
  ml->fontx = null;
#line 2906
  if (o != null) {
    {
#line 2907
    free((void *)o);
    }
  }
#line 2911
  q = ml->color;
#line 2911
  o = hml->color;
#line 2911
  hml->color = q;
#line 2911
  ml->color = null;
#line 2912
  if (o != null) {
    {
#line 2913
    free((void *)o);
    }
  }
#line 2921
  (wp->w_histidx) ++;
#line 2921
  if (wp->w_histidx >= wp->w_histheight) {
#line 2922
    wp->w_histidx = 0;
  }
#line 2923
  if (wp->w_scrollback_height < wp->w_histheight) {
#line 2924
    (wp->w_scrollback_height) ++;
  }
  return;
}
}
#line 2929 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
int MFindUsedLine(struct win *p , int ye , int ys ) 
{ 
  int y ;
  struct mline *ml ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  struct mline *__cil_tmp12 ;

  {
#line 2934
  ml = p->w_mlines + ye;
  {
#line 2936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2936
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2937
  y = ye;
  {
#line 2937
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2937
    if (! (y >= ys)) {
#line 2937
      goto while_break___0;
    }
    {
#line 2939
    __cil_tmp6 = bcmp((void const   *)((char *)ml->image), (void const   *)blank,
                      (unsigned long )p->w_layer.l_width);
    }
#line 2939
    if (__cil_tmp6) {
#line 2940
      goto while_break___0;
    }
    {
#line 2941
    __cil_tmp7 = bcmp((void const   *)((char *)ml->attr), (void const   *)null, (unsigned long )p->w_layer.l_width);
    }
#line 2941
    if (ml->attr != null) {
#line 2941
      if (__cil_tmp7) {
#line 2942
        goto while_break___0;
      }
    }
    {
#line 2944
    __cil_tmp8 = bcmp((void const   *)((char *)ml->color), (void const   *)null, (unsigned long )p->w_layer.l_width);
    }
#line 2944
    if (ml->color != null) {
#line 2944
      if (__cil_tmp8) {
#line 2945
        goto while_break___0;
      }
    }
#line 2952
    if (p->w_layer.l_encoding == 8) {
      {
#line 2954
      __cil_tmp9 = bcmp((void const   *)((char *)ml->font), (void const   *)null,
                        (unsigned long )p->w_layer.l_width);
      }
#line 2954
      if (ml->font != null) {
#line 2954
        if (__cil_tmp9) {
#line 2955
          goto while_break___0;
        }
      }
      {
#line 2956
      __cil_tmp10 = bcmp((void const   *)((char *)ml->fontx), (void const   *)null,
                         (unsigned long )p->w_layer.l_width);
      }
#line 2956
      if (ml->fontx != null) {
#line 2956
        if (__cil_tmp10) {
#line 2957
          goto while_break___0;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2937
  __cil_tmp12 = ml;
#line 2937
  ml --;
#line 2937
  __cil_tmp11 = y;
#line 2937
  y --;
  {
#line 2961
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2961
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2962
  return (y);
}
}
#line 2976 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void WBell(struct win *p , int visual ) 
{ 
  struct canvas *cv ;
  int tmp ;

  {
#line 2981
  if (displays == (struct display *)((void *)0)) {
#line 2982
    p->w_bell = 2;
  }
#line 2983
  display = displays;
  {
#line 2983
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2983
    if (! display) {
#line 2983
      goto while_break;
    }
#line 2985
    cv = display->d_cvlist;
    {
#line 2985
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2985
      if (! cv) {
#line 2985
        goto while_break___0;
      }
#line 2986
      if ((cv->c_layer)->l_bottom == & p->w_layer) {
#line 2987
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2985
    cv = cv->c_next;
#line 2988
    if (cv) {
#line 2988
      if (! visual) {
        {
#line 2989
        AddCStr(display->d_tcs[42].str);
        }
      } else {
#line 2988
        goto _L___1088;
      }
    } else
    _L___1088: /* CIL Label */ 
#line 2990
    if (cv) {
#line 2990
      if (display->d_tcs[43].str) {
        {
#line 2991
        AddCStr(display->d_tcs[43].str);
        }
      } else {
#line 2990
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2993
      if (visual) {
#line 2993
        tmp = 3;
      } else {
#line 2993
        tmp = 1;
      }
#line 2993
      p->w_bell = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2983
  display = display->d_next;
  return;
}
}
#line 3005 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static void WReverseVideo(struct win *p , int on ) 
{ 
  struct canvas *cv ;

  {
#line 3010
  cv = p->w_layer.l_cvlist;
  {
#line 3010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3010
    if (! cv) {
#line 3010
      goto while_break;
    }
#line 3012
    display = cv->c_display;
#line 3013
    if (cv != display->d_forecv) {
#line 3014
      goto while_continue;
    }
    {
#line 3015
    ReverseVideo(on);
    }
#line 3016
    if (! on) {
#line 3016
      if (p->w_revvid) {
#line 3016
        if (! display->d_tcs[93].str) {
#line 3018
          if (display->d_tcs[43].str) {
            {
#line 3019
            AddCStr(display->d_tcs[43].str);
            }
          } else {
#line 3021
            p->w_bell = 3;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3010
  cv = cv->c_lnext;
  return;
}
}
#line 3027 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void WMsg(struct win *p , int err , char *str ) 
{ 
  extern struct layer *flayer___1089 ;
  struct layer *oldflayer ;

  {
  {
#line 3033
  oldflayer = flayer___1089;
#line 3034
  flayer___1089 = & p->w_layer;
#line 3035
  LMsg(err, (char const   *)((char *)"%s"), str);
#line 3036
  flayer___1089 = oldflayer;
  }
  return;
}
}
#line 3040 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void WChangeSize(struct win *p , int w , int h ) 
{ 
  int wok ;
  struct canvas *cv ;

  {
#line 3044
  wok = 0;
#line 3047
  if (p->w_layer.l_cvlist == (struct canvas *)0) {
    {
#line 3050
    ChangeWindowSize(p, w, h, p->w_histheight);
    }
#line 3051
    return;
  }
#line 3053
  cv = p->w_layer.l_cvlist;
  {
#line 3053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3053
    if (! cv) {
#line 3053
      goto while_break;
    }
#line 3055
    display = cv->c_display;
#line 3056
    if (p != display->d_fore) {
#line 3057
      goto while_continue;
    }
#line 3058
    if (display->d_tcs[44].str) {
#line 3059
      goto while_break;
    }
#line 3060
    if (display->d_tcs[45].str) {
#line 3060
      if (w == (int )Z0width) {
#line 3061
        wok = 1;
      } else
#line 3060
      if (w == (int )Z1width) {
#line 3061
        wok = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3053
  cv = cv->c_lnext;
#line 3063
  if (cv == (struct canvas *)0) {
#line 3063
    if (wok == 0) {
#line 3064
      return;
    }
  }
#line 3065
  if (! display->d_tcs[44].str) {
#line 3066
    h = p->w_layer.l_height;
  }
  {
#line 3067
  ChangeWindowSize(p, w, h, p->w_histheight);
#line 3068
  display = displays;
  }
  {
#line 3068
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3068
    if (! display) {
#line 3068
      goto while_break___0;
    }
#line 3070
    if (p == display->d_fore) {
#line 3072
      if (display->d_cvlist) {
#line 3072
        if ((display->d_cvlist)->c_next == (struct canvas *)0) {
          {
#line 3073
          ResizeDisplay(w, h);
          }
        } else {
          {
          {
#line 3075
          ResizeDisplay(w, display->d_height);
          }
          }
        }
      } else {
        {
        {
#line 3075
        ResizeDisplay(w, display->d_height);
        }
        }
      }
      {
#line 3076
      ResizeLayersToCanvases();
      }
#line 3077
      goto while_continue___0;
    }
#line 3079
    cv = display->d_cvlist;
    {
#line 3079
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3079
      if (! cv) {
#line 3079
        goto while_break___1;
      }
#line 3080
      if ((cv->c_layer)->l_bottom == & p->w_layer) {
#line 3081
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3079
    cv = cv->c_next;
#line 3082
    if (cv) {
      {
#line 3083
      Redisplay(0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3068
  display = display->d_next;
  return;
}
}
#line 3088 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
static int WindowChangedCheck(char *s , int what , int *hp ) 
{ 
  int h ;
  int l ;
  char *__cil_tmp6 ;
  int tmp ;
  int tmp___0 ;

  {
#line 3093
  h = 0;
  {
#line 3095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3095
    if (! *s) {
#line 3095
      goto while_break;
    }
#line 3097
    if (hp) {
#line 3097
      tmp = '%';
    } else {
#line 3097
      tmp = '\005';
    }
#line 3097
    __cil_tmp6 = s;
#line 3097
    s ++;
#line 3097
    if ((int )*__cil_tmp6 != tmp) {
#line 3098
      goto while_continue;
    }
#line 3099
    l = 0;
#line 3100
    s += (int )*s == 43;
#line 3101
    s += (int )*s == 45;
    {
#line 3102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3102
      if (! ((int )*s >= 48 && (int )*s <= 57)) {
#line 3102
        goto while_break___0;
      }
#line 3103
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3104
    if ((int )*s == 76) {
#line 3106
      s ++;
#line 3107
      l = 256;
    }
#line 3109
    if ((int )*s == 104) {
#line 3110
      h = 1;
    }
#line 3111
    if ((int )*s == what) {
#line 3112
      goto while_break;
    } else
#line 3111
    if (((int )*s | l) == what) {
#line 3112
      goto while_break;
    } else
#line 3111
    if (what == 100) {
#line 3112
      goto while_break;
    }
#line 3113
    if (*s) {
#line 3114
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3116
  if (hp) {
#line 3117
    *hp = h;
  }
#line 3118
  if ((int )*s) {
#line 3118
    tmp___0 = 1;
  } else {
#line 3118
    tmp___0 = 0;
  }
#line 3118
  return (tmp___0);
}
}
#line 3122 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/ansi.c"
void WindowChanged(struct win *p , int what ) 
{ 
  int inwstr ;
  int inhstr ;
  int inlstr ;
  int inwstrh ;
  int inhstrh ;
  int inlstrh ;
  int got ;
  int ox ;
  int oy ;
  struct display *olddisplay ;
  struct canvas *cv ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 3127
  inwstrh = 0;
#line 3127
  inhstrh = 0;
#line 3127
  inlstrh = 0;
#line 3129
  olddisplay = display;
#line 3132
  inhstr = 0;
#line 3132
  inwstr = inhstr;
#line 3134
  if (what == 102) {
    {
#line 3136
    WindowChanged((struct win *)0, 375);
#line 3137
    WindowChanged((struct win *)0, 343);
    }
  }
#line 3140
  if (what) {
    {
#line 3142
    inwstr = WindowChangedCheck(captionstring, what, & inwstrh);
#line 3143
    inhstr = WindowChangedCheck(hstatusstring, what, & inhstrh);
#line 3144
    inlstr = WindowChangedCheck(wliststr, what, & inlstrh);
    }
  } else {
#line 3148
    inhstr = 0;
#line 3148
    inwstr = inhstr;
#line 3149
    inlstr = 1;
  }
#line 3152
  if (p == (struct win *)0) {
#line 3154
    display = displays;
    {
#line 3154
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3154
      if (! display) {
#line 3154
        goto while_break;
      }
#line 3156
      ox = display->d_x;
#line 3157
      oy = display->d_y;
#line 3158
      cv = display->d_cvlist;
      {
#line 3158
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3158
        if (! cv) {
#line 3158
          goto while_break___0;
        }
        {
#line 3160
        __cil_tmp17 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
        }
#line 3160
        if (inlstr) {
          {
          {
#line 3161
          WListUpdatecv(cv, (struct win *)0);
          }
          }
        } else
#line 3160
        if (inlstrh) {
#line 3160
          if (p) {
#line 3160
            if (p->w_hstatus) {
#line 3160
              if ((int )*(p->w_hstatus)) {
#line 3160
                if (__cil_tmp17) {
                  {
                  {
#line 3161
                  WListUpdatecv(cv, (struct win *)0);
                  }
                  }
                }
              }
            }
          }
        }
        {
#line 3162
        p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 3163
        __cil_tmp18 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
        }
#line 3163
        if (inwstr) {
          _L: /* CIL Label */ 
#line 3164
          if (cv->c_ye + 1 < display->d_height) {
            {
#line 3165
            RefreshLine(cv->c_ye + 1, 0, display->d_width - 1, 0);
            }
          }
        } else
#line 3163
        if (inwstrh) {
#line 3163
          if (p) {
#line 3163
            if (p->w_hstatus) {
#line 3163
              if ((int )*(p->w_hstatus)) {
#line 3163
                if (__cil_tmp18) {
#line 3163
                  goto _L;
                }
              }
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 3158
      cv = cv->c_next;
#line 3167
      p = display->d_fore;
#line 3168
      __cil_tmp19 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
      }
#line 3168
      if (inhstr) {
        {
        {
#line 3169
        RefreshHStatus();
        }
        }
      } else
#line 3168
      if (inhstrh) {
#line 3168
        if (p) {
#line 3168
          if (p->w_hstatus) {
#line 3168
            if ((int )*(p->w_hstatus)) {
#line 3168
              if (__cil_tmp19) {
                {
                {
#line 3169
                RefreshHStatus();
                }
                }
              }
            }
          }
        }
      }
#line 3170
      if (ox != -1) {
#line 3170
        if (oy != -1) {
          {
#line 3171
          GotoPos(ox, oy);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3154
    display = display->d_next;
#line 3173
    display = olddisplay;
#line 3174
    return;
  }
  {
#line 3177
  __cil_tmp20 = WindowChangedCheck(p->w_hstatus, what, (int *)0);
  }
#line 3177
  if (p->w_hstatus) {
#line 3177
    if ((int )*(p->w_hstatus)) {
#line 3177
      if (inwstrh) {
        _L___1090: /* CIL Label */ 
#line 3177
        if (__cil_tmp20) {
#line 3179
          inwstr |= inwstrh;
#line 3180
          inhstr |= inhstrh;
#line 3181
          inlstr |= inlstrh;
        }
      } else
#line 3177
      if (inhstrh) {
#line 3177
        goto _L___1090;
      } else
#line 3177
      if (inlstrh) {
#line 3177
        goto _L___1090;
      }
    }
  }
#line 3183
  if (! inwstr) {
#line 3183
    if (! inhstr) {
#line 3183
      if (! inlstr) {
#line 3184
        return;
      }
    }
  }
#line 3185
  display = displays;
  {
#line 3185
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3185
    if (! display) {
#line 3185
      goto while_break___1;
    }
#line 3187
    got = 0;
#line 3188
    ox = display->d_x;
#line 3189
    oy = display->d_y;
#line 3190
    cv = display->d_cvlist;
    {
#line 3190
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3190
      if (! cv) {
#line 3190
        goto while_break___2;
      }
#line 3192
      if (inlstr) {
        {
#line 3193
        WListUpdatecv(cv, p);
        }
      }
#line 3194
      if ((struct win *)((cv->c_layer)->l_bottom)->l_data != p) {
#line 3195
        goto while_continue___2;
      }
#line 3196
      got = 1;
#line 3197
      if (inwstr) {
#line 3197
        if (cv->c_ye + 1 < display->d_height) {
          {
#line 3198
          RefreshLine(cv->c_ye + 1, 0, display->d_width - 1, 0);
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3190
    cv = cv->c_next;
#line 3200
    if (got) {
#line 3200
      if (inhstr) {
#line 3200
        if (p == display->d_fore) {
          {
#line 3201
          RefreshHStatus();
          }
        }
      }
    }
#line 3202
    if (ox != -1) {
#line 3202
      if (oy != -1) {
        {
#line 3203
        GotoPos(ox, oy);
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3185
  display = display->d_next;
#line 3205
  display = olddisplay;
  return;
}
}
#line 548 "/usr/include/unistd.h"
extern char **environ ;
#line 606
extern void _exit(int __status ) ;
#line 851
extern char *getlogin(void) ;
#line 308 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 317
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode ) ;
#line 119 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 238 "/usr/include/stdio.h"
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 88 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 142
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 100 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 109 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 70 "/usr/include/shadow.h"
extern void endspent(void) ;
#line 127 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int force_vt  =    1;
#line 152
static struct passwd *getpwbyname(char *name , struct passwd *ppp___0 ) ;
#line 153
static void SigChldHandler(void) ;
#line 154
static void SigChld(int sigsig ) ;
#line 155
static void SigInt(int sigsig ) ;
#line 156
static void CoreDump(int sigsig ) ;
#line 157
static void FinitHandler(int sigsig ) ;
#line 158
static void DoWait(void) ;
#line 159
static void serv_read_fn(struct event *ev , char *data ) ;
#line 160
static void serv_select_fn(struct event *ev , char *data ) ;
#line 161
static void logflush_fn(struct event *ev , char *data ) ;
#line 162
static void backtick_filter(struct backtick *bt ) ;
#line 163
static void backtick_fn(struct event *ev , char *data ) ;
#line 164
static char *runbacktick(struct backtick *bt , int *tickp , time_t now ) ;
#line 165
static int IsSymbol(char *e , char *s ) ;
#line 166
static char *ParseChar(char *p , char *cp ) ;
#line 167
static int ParseEscape(char *p ) ;
#line 168
static char *pad_expand(char *buf , char *p , int numpad , int padlen ) ;
#line 169
void SetTtyname(int fatal , struct stat *st ) ;
#line 180 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int attach_tty_is_in_new_ns  =    0;
#line 183 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int attach_fd  =    - 1;
#line 190 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
char *SockMatch  =    (char *)((void *)0);
#line 191 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int ServerSocket  =    - 1;
#line 193
struct event serv_select ;
#line 196 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
char **NewEnv  =    (char **)((void *)0);
#line 198 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
char *RcFileName  =    (char *)((void *)0);
#line 202 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int log_flush  =    10;
#line 203 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int logtstamp_on  =    0;
#line 205 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int logtstamp_after  =    120;
#line 206 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
char *hardcopydir  =    (char *)((void *)0);
#line 221 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int auto_detach  =    1;
#line 223
int cmdflag ;
#line 224 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int queryflag  =    - 1;
#line 229
char *multi_home ;
#line 234 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int tty_oldmode  =    - 1;
#line 238
int PanicPid ;
#line 242 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
char *preselect  =    (char *)((void *)0);
#line 253 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int nethackflag  =    0;
#line 38 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/extern.h"
int main(int ac , char **av ) ;
#line 271 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
char strnomem[]  =    "Out of memory.";
#line 273
static int InterruptPlease ;
#line 274
static int GotSigChld ;
#line 276 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static int lf_secreopen(char *name , int wantfd , struct logfile *l ) 
{ 
  int got_fd ;
  int __cil_tmp6 ;

  {
  {
#line 283
  close(wantfd);
#line 284
  __cil_tmp6 = lf_move_fd(got_fd, wantfd);
  }
  {
#line 284
  got_fd = secopen(name, 1089, 438);
  }
#line 284
  if (got_fd < 0) {
    _L: /* CIL Label */ 
    {
#line 285
    logfclose(l);
    }
    {
#line 286
    while (1) {
      while_continue: /* CIL Label */ ;
#line 286
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 287
    return (- 1);
  } else
#line 284
  if (__cil_tmp6 < 0) {
#line 284
    goto _L;
  }
#line 289
  (l->st)->st_dev = (__dev_t )0;
#line 289
  (l->st)->st_ino = (l->st)->st_dev;
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 291
  return (0);
}
}
#line 298 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static struct passwd *getpwbyname(char *name , struct passwd *ppp___0 ) 
{ 
  int n ;
  struct spwd *sss ;
  static char *spw ;
  int __cil_tmp7 ;
  char c ;
  size_t __cil_tmp12 ;

  {
  {
#line 305
  sss = (struct spwd *)((void *)0);
#line 306
  spw = (char *)((void *)0);
#line 309
  ppp___0 = getpwnam((char const   *)name);
  }
#line 309
  if (! ppp___0) {
#line 309
    if (! ppp___0) {
#line 310
      return ((struct passwd *)((void *)0));
    }
  }
  pw_try_again: 
#line 316
  n = 0;
  {
#line 317
  __cil_tmp7 = strcmp((char const   *)(ppp___0->pw_passwd + 2), (char const   *)ppp___0->pw_name);
  }
#line 317
  if ((int )*(ppp___0->pw_passwd + 0) == 35) {
#line 317
    if ((int )*(ppp___0->pw_passwd + 1) == 35) {
#line 317
      if (__cil_tmp7 == 0) {
#line 318
        n = 13;
      }
    }
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (n < 13)) {
#line 319
      goto while_break;
    }
#line 320
    c = *(ppp___0->pw_passwd + n);
#line 321
    if (! ((((((int )c == 46 || (int )c == 47) || (int )c == 36) || ((int )c >= 48 && (int )c <= 57)) || ((int )c >= 97 && (int )c <= 122)) || ((int )c >= 65 && (int )c <= 90))) {
#line 325
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  n ++;
#line 330
  if (n < 13) {
#line 330
    if (sss == (struct spwd *)0) {
      {
#line 331
      sss = getspnam((char const   *)ppp___0->pw_name);
      }
#line 332
      if (sss) {
#line 333
        if (spw) {
          {
#line 334
          free((void *)spw);
          }
        }
        {
#line 335
        ppp___0->pw_passwd = SaveStr((char const   *)sss->sp_pwdp);
#line 336
        endspent();
        }
#line 337
        goto pw_try_again;
      }
      {
#line 339
      endspent();
      }
    }
  }
#line 342
  if (n < 13) {
#line 343
    ppp___0->pw_passwd = (char *)0;
  }
  {
#line 345
  __cil_tmp12 = strlen((char const   *)ppp___0->pw_passwd);
  }
#line 345
  if (ppp___0->pw_passwd) {
#line 345
    if (__cil_tmp12 == 24UL) {
#line 346
      *(ppp___0->pw_passwd + 13) = (char )0;
    }
  }
#line 349
  return (ppp___0);
}
}
#line 352 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static char *locale_name(void) 
{ 
  static char *s ;

  {
#line 355
  if (! s) {
    {
#line 356
    s = getenv((char const   *)((char *)"LC_ALL"));
    }
#line 357
    if (s == (char *)((void *)0)) {
      {
#line 358
      s = getenv((char const   *)((char *)"LC_CTYPE"));
      }
    }
#line 359
    if (s == (char *)((void *)0)) {
      {
#line 360
      s = getenv((char const   *)((char *)"LANG"));
      }
    }
  }
#line 362
  return (s);
}
}
#line 365 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int main(int ac , char **av ) 
{ 
  register int n ;
  char *ap ;
  char *av0 ;
  char socknamebuf[1536] ;
  int mflag ;
  char *myname ;
  char *tmp ;
  char *SockDir ;
  struct stat st ;
  int oumask ;
  struct NewWindow nwin ;
  int detached ;
  char *sockp ;
  char *sty ;
  int tmp___1092 ;
  __uid_t __cil_tmp32 ;
  __gid_t __cil_tmp33 ;
  __uid_t __cil_tmp34 ;
  __gid_t __cil_tmp35 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  int __cil_tmp45 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  size_t __cil_tmp53 ;
  int __cil_tmp55 ;
  size_t __cil_tmp56 ;
  int __cil_tmp57 ;
  int tmp___1093 ;
  int __cil_tmp59 ;
  char *__cil_tmp60 ;
  int tmp___1094 ;
  char *__cil_tmp62 ;
  int __cil_tmp63 ;
  char *s ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  size_t len ;
  size_t __cil_tmp70 ;
  size_t newsz ;
  char *newbuf ;
  void *__cil_tmp73 ;
  int __cil_tmp74 ;
  size_t __cil_tmp76 ;
  register char *sh ;
  char *tmp___1095 ;
  char *__cil_tmp80 ;
  char *__cil_tmp83 ;
  char nethackrc[4096] ;
  size_t __cil_tmp85 ;
  int __cil_tmp86 ;
  struct passwd *mppp ;
  size_t __cil_tmp91 ;
  size_t __cil_tmp97 ;
  size_t __cil_tmp98 ;
  size_t __cil_tmp99 ;
  int fl ;
  size_t __cil_tmp104 ;
  __mode_t __cil_tmp105 ;
  int *__cil_tmp106 ;
  size_t __cil_tmp108 ;
  char *tmp___1096 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  char *tmp___1097 ;
  int __cil_tmp115 ;
  int tmp___1098 ;
  int tmp___1099 ;
  int __cil_tmp118 ;
  int *__cil_tmp119 ;
  int tmp___1100 ;
  int tmp___1101 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  int *__cil_tmp124 ;
  int *__cil_tmp125 ;
  int __cil_tmp126 ;
  int __cil_tmp127 ;
  int *__cil_tmp128 ;
  char *__cil_tmp129 ;
  size_t __cil_tmp130 ;
  __mode_t __cil_tmp131 ;
  int __cil_tmp132 ;
  int i ;
  int fo ;
  int oth ;
  int sock ;
  int tmp___1102 ;
  char *tmp___1103 ;
  int __cil_tmp141 ;
  char *tmp___1104 ;
  int *__cil_tmp144 ;
  char *__cil_tmp145 ;
  size_t __cil_tmp147 ;
  size_t __cil_tmp148 ;
  size_t __cil_tmp150 ;
  int __cil_tmp151 ;
  char *__cil_tmp152 ;
  int __cil_tmp155 ;
  __pid_t __cil_tmp156 ;
  struct display *__cil_tmp157 ;
  int tmp___1105 ;
  __pid_t __cil_tmp159 ;
  __pid_t __cil_tmp160 ;
  char *__cil_tmp161 ;
  size_t __cil_tmp163 ;
  size_t __cil_tmp164 ;
  int __cil_tmp167 ;
  int __cil_tmp168 ;
  int __cil_tmp169 ;
  int __cil_tmp170 ;
  int __cil_tmp171 ;
  int *__cil_tmp172 ;
  int __cil_tmp174 ;
  fd_set rfd ;
  struct timeval tv ;

  {
#line 371
  mflag = 0;
#line 372
  if (ac == 0) {
#line 372
    tmp = (char *)"screen";
  } else {
#line 372
    tmp = *(av + 0);
  }
  {
#line 372
  myname = tmp;
#line 384
  detached = 0;
#line 388
  sty = (char *)0;
#line 406
  closeallfiles(0);
#line 410
  snprintf((char *)version, (unsigned long )59, (char const   *)((char *)"%d.%.2d.%.2d%s (%s%s) %s"),
           4, 7, 0, (char *)"", (char *)"GNU", (char *)"", (char *)"02-Oct-19");
#line 412
  nversion = 40700;
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 415
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 418
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 418
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 427
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 427
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 430
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 430
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 439
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 439
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 442
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 442
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 445
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 445
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 448
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 448
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 451
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 451
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 454
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 454
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 457
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 457
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 460
  BellString = SaveStr((char const   *)((char *)"Bell in window %n"));
#line 461
  VisualBellString = SaveStr((char const   *)((char *)"   Wuff,  Wuff!!  "));
#line 462
  ActivityString = SaveStr((char const   *)((char *)"Activity in window %n"));
#line 463
  screenlogfile = SaveStr((char const   *)((char *)"screenlog.%n"));
#line 464
  logtstamp_string = SaveStr((char const   *)((char *)"-- %n:%t -- time-stamp -- %M/%d/%y %c:%s --\n"));
#line 465
  hstatusstring = SaveStr((char const   *)((char *)"%h"));
#line 466
  captionstring = SaveStr((char const   *)((char *)"%4n %t"));
#line 467
  timestring = SaveStr((char const   *)((char *)"%c:%s %M %d %H%? %l%?"));
#line 468
  wlisttit = SaveStr((char const   *)((char *)" Num Name%=Flags"));
#line 469
  wliststr = SaveStr((char const   *)((char *)"%4n %t%=%f"));
#line 471
  BufferFile = SaveStr((char const   *)((char *)"/tmp/screen-exchange"));
#line 473
  ShellProg = (char *)((void *)0);
#line 475
  PowDetachString = (char *)0;
  }
#line 477
  if (ac > 1) {
#line 477
    tmp___1092 = 0;
  } else {
#line 477
    tmp___1092 = 1;
  }
  {
#line 477
  default_startup = tmp___1092;
#line 478
  adaptflag = 0;
#line 479
  VBellWait = 1000;
#line 480
  MsgWait = 5000;
#line 481
  MsgMinWait = 1000;
#line 482
  SilenceWait = 30;
#line 487
  zmodem_sendcmd = SaveStr((char const   *)((char *)"!!! sz -vv -b "));
#line 488
  zmodem_recvcmd = SaveStr((char const   *)((char *)"!!! rz -vv -b -E"));
#line 492
  CompileKeys((char *)0, 0, (unsigned char *)mark_key_tab);
#line 495
  InitBuiltinTabs();
#line 496
  screenencodings = SaveStr((char const   *)((char *)"/usr/share/screen/utf8encodings"));
#line 499
  cjkwidth = 0;
#line 501
  nwin = nwin_undef;
#line 502
  nwin_options = nwin_undef;
#line 503
  strncpy((char *)screenterm, (char const   *)((char *)"screen"), (unsigned long )32);
#line 504
  screenterm[32] = (char )'\000';
#line 509
  __cil_tmp32 = getuid();
#line 509
  real_uid = (int )__cil_tmp32;
#line 510
  __cil_tmp33 = getgid();
#line 510
  real_gid = (int )__cil_tmp33;
#line 511
  __cil_tmp34 = geteuid();
#line 511
  eff_uid = (int )__cil_tmp34;
#line 512
  __cil_tmp35 = getegid();
#line 512
  eff_gid = (int )__cil_tmp35;
#line 514
  logreopen_register(lf_secreopen);
#line 516
  av0 = *av;
  }
#line 517
  if ((int )*av0 == 45) {
    {
#line 518
    rflag = 4;
#line 520
    xflag = 1;
#line 524
    ShellProg = SaveStr((char const   *)((char *)DefaultShell));
    }
  }
  {
#line 527
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 527
    if (! (ac > 0)) {
#line 527
      goto while_break___11;
    }
#line 528
    av ++;
#line 528
    ap = *av;
#line 529
    ac --;
#line 529
    if (ac > 0) {
#line 529
      if ((int )*ap == 45) {
#line 530
        if ((int )*(ap + 1) == 45) {
#line 530
          if ((int )*(ap + 2) == 0) {
#line 531
            av ++;
#line 532
            __cil_tmp38 = ac;
#line 532
            ac --;
#line 533
            goto while_break___11;
          }
        }
        {
#line 536
        __cil_tmp39 = strcmp((char const   *)ap, (char const   *)((char *)"--version"));
        }
#line 536
        if ((int )*(ap + 1) == 45) {
#line 536
          if (! __cil_tmp39) {
            {
#line 537
            Panic(0, (char const   *)((char *)"Screen version %s"), (char *)version);
            }
          }
        }
        {
#line 538
        __cil_tmp40 = strcmp((char const   *)ap, (char const   *)((char *)"--help"));
        }
#line 538
        if ((int )*(ap + 1) == 45) {
#line 538
          if (! __cil_tmp40) {
            {
#line 539
            exit_with_usage(myname, (char *)((void *)0), (char *)((void *)0));
            }
          }
        }
        {
#line 541
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 541
          if (! ((ap && (int )*ap) && (int )*ap)) {
#line 541
            goto while_break___12;
          }
          {
#line 554
          if ((int )*ap == 'a') {
#line 554
            goto case_97;
          }
#line 558
          if ((int )*ap == 'A') {
#line 558
            goto case_65;
          }
#line 562
          if ((int )*ap == 'p') {
#line 562
            goto case_112;
          }
#line 579
          if ((int )*ap == 'c') {
#line 579
            goto case_99;
          }
#line 590
          if ((int )*ap == 'e') {
#line 590
            goto case_101;
          }
#line 601
          if ((int )*ap == 'f') {
#line 601
            goto case_102;
          }
#line 605
          if ((int )*ap == '0') {
#line 605
            goto case_48;
          }
#line 605
          if ((int )*ap == 'n') {
#line 605
            goto case_48;
          }
#line 608
          if ((int )*ap == '\000') {
#line 608
            goto case_0;
          }
#line 612
          if ((int )*ap == '1') {
#line 612
            goto case_49;
          }
#line 612
          if ((int )*ap == 'y') {
#line 612
            goto case_49;
          }
#line 615
          if ((int )*ap == 'a') {
#line 615
            goto case_97___0;
          }
#line 623
          if ((int )*ap == 'h') {
#line 623
            goto case_104;
          }
#line 631
          if ((int )*ap == 'i') {
#line 631
            goto case_105;
          }
#line 635
          if ((int )*ap == 't') {
#line 635
            goto case_116;
          }
#line 641
          if ((int )*ap == 'l') {
#line 641
            goto case_108;
          }
#line 645
          if ((int )*ap == '0') {
#line 645
            goto case_48___0;
          }
#line 645
          if ((int )*ap == 'n') {
#line 645
            goto case_48___0;
          }
#line 648
          if ((int )*ap == '\000') {
#line 648
            goto case_0___0;
          }
#line 652
          if ((int )*ap == '1') {
#line 652
            goto case_49___0;
          }
#line 652
          if ((int )*ap == 'y') {
#line 652
            goto case_49___0;
          }
#line 655
          if ((int )*ap == 'a') {
#line 655
            goto case_97___1;
          }
#line 659
          if ((int )*ap == 'i') {
#line 659
            goto case_105___0;
          }
#line 659
          if ((int )*ap == 's') {
#line 659
            goto case_105___0;
          }
#line 672
          if ((int )*ap == 'w') {
#line 672
            goto case_119;
          }
#line 683
          if ((int )*ap == 'L') {
#line 683
            goto case_76;
          }
#line 700
          if ((int )*ap == 'm') {
#line 700
            goto case_109;
          }
#line 704
          if ((int )*ap == 'O') {
#line 704
            goto case_79;
          }
#line 708
          if ((int )*ap == 'T') {
#line 708
            goto case_84;
          }
#line 719
          if ((int )*ap == 'q') {
#line 719
            goto case_113;
          }
#line 723
          if ((int )*ap == 'Q') {
#line 723
            goto case_81;
          }
#line 731
          if ((int )*ap == 'x') {
#line 731
            goto case_120;
          }
#line 731
          if ((int )*ap == 'R') {
#line 731
            goto case_120;
          }
#line 731
          if ((int )*ap == 'r') {
#line 731
            goto case_120;
          }
#line 748
          if ((int )*ap == 'd') {
#line 748
            goto case_100;
          }
#line 752
          if ((int )*ap == 'D') {
#line 752
            goto case_68;
          }
#line 765
          if ((int )*ap == 's') {
#line 765
            goto case_115___0;
          }
#line 774
          if ((int )*ap == 'S') {
#line 774
            goto case_83;
          }
#line 784
          if ((int )*ap == 'X') {
#line 784
            goto case_88;
          }
#line 788
          if ((int )*ap == 'v') {
#line 788
            goto case_118;
          }
#line 793
          if ((int )*ap == 'U') {
#line 793
            goto case_85;
          }
#line 798
          goto switch_default___1;
          case_97: /* CIL Label */ 
#line 555
          nwin_options.aflag = 1;
#line 556
          goto switch_break;
          case_65: /* CIL Label */ 
#line 559
          adaptflag = 1;
#line 560
          goto switch_break;
          case_112: /* CIL Label */ 
#line 563
          ap ++;
#line 563
          if (*ap) {
#line 564
            preselect = ap;
          } else {
#line 566
            ac --;
#line 566
            if (! ac) {
              {
#line 567
              exit_with_usage(myname, (char *)"Specify a window to preselect with -p",
                              (char *)((void *)0));
              }
            }
#line 568
            av ++;
#line 568
            preselect = *av;
          }
#line 570
          ap = (char *)((void *)0);
#line 571
          goto switch_break;
          case_99: /* CIL Label */ 
#line 580
          ap ++;
#line 580
          if (*ap) {
#line 581
            RcFileName = ap;
          } else {
#line 583
            ac --;
#line 583
            if (ac == 0) {
              {
#line 584
              exit_with_usage(myname, (char *)"Specify an alternate rc-filename with -c",
                              (char *)((void *)0));
              }
            }
#line 585
            av ++;
#line 585
            RcFileName = *av;
          }
#line 587
          ap = (char *)((void *)0);
#line 588
          goto switch_break;
          case_101: /* CIL Label */ 
#line 591
          ap ++;
#line 591
          if (! *ap) {
#line 592
            ac --;
#line 592
            if (ac == 0) {
              {
#line 593
              exit_with_usage(myname, (char *)"Specify command characters with -e",
                              (char *)((void *)0));
              }
            }
#line 594
            av ++;
#line 594
            ap = *av;
          }
          {
#line 596
          __cil_tmp41 = ParseEscape(ap);
          }
#line 596
          if (__cil_tmp41) {
            {
#line 597
            Panic(0, (char const   *)((char *)"Two characters are required with -e option, not \'%s\'."),
                  ap);
            }
          }
#line 598
          ap = (char *)((void *)0);
#line 599
          goto switch_break;
          case_102: /* CIL Label */ 
#line 602
          ap ++;
#line 603
          __cil_tmp43 = ap;
#line 603
          ap ++;
          {
#line 605
          if ((int )*__cil_tmp43 == '0') {
#line 605
            goto case_48;
          }
#line 605
          if ((int )*__cil_tmp43 == 'n') {
#line 605
            goto case_48;
          }
#line 608
          if ((int )*__cil_tmp43 == '\000') {
#line 608
            goto case_0;
          }
#line 612
          if ((int )*__cil_tmp43 == '1') {
#line 612
            goto case_49;
          }
#line 612
          if ((int )*__cil_tmp43 == 'y') {
#line 612
            goto case_49;
          }
#line 615
          if ((int )*__cil_tmp43 == 'a') {
#line 615
            goto case_97___0;
          }
#line 618
          goto switch_default;
          case_48: /* CIL Label */ 
          case_110: /* CIL Label */ 
#line 606
          nwin_options.flowflag = 0;
#line 607
          goto switch_break___0;
          case_0: /* CIL Label */ 
#line 609
          __cil_tmp44 = ap;
#line 609
          ap --;
          case_49: /* CIL Label */ 
          case_121: /* CIL Label */ 
#line 613
          nwin_options.flowflag = 1;
#line 614
          goto switch_break___0;
          case_97___0: /* CIL Label */ 
#line 616
          nwin_options.flowflag = 1 << 2;
#line 617
          goto switch_break___0;
          switch_default: /* CIL Label */ 
          {
#line 619
          ap --;
#line 619
          exit_with_usage(myname, (char *)"Unknown flow option -%s", ap);
          }
          switch_break___0: /* CIL Label */ ;
          }
#line 621
          goto switch_break;
          case_104: /* CIL Label */ 
#line 624
          ac --;
#line 624
          if (ac == 0) {
            {
#line 625
            exit_with_usage(myname, (char *)((void *)0), (char *)((void *)0));
            }
          }
          {
#line 626
          av ++;
#line 626
          __cil_tmp45 = atoi((char const   *)*av);
#line 626
          nwin_options.histheight = __cil_tmp45;
          }
#line 627
          if (nwin_options.histheight < 0) {
            {
#line 628
            exit_with_usage(myname, (char *)"-h: %s: negative scrollback size?", *av);
            }
          }
#line 629
          goto switch_break;
          case_105: /* CIL Label */ 
#line 632
          iflag = 1;
#line 633
          goto switch_break;
          case_116: /* CIL Label */ 
#line 636
          ac --;
#line 636
          if (ac == 0) {
            {
#line 637
            exit_with_usage(myname, (char *)"Specify a new window-name with -t", (char *)((void *)0));
            }
          }
#line 638
          av ++;
#line 638
          nwin_options.aka = *av;
#line 639
          goto switch_break;
          case_108: /* CIL Label */ 
#line 642
          ap ++;
#line 643
          __cil_tmp47 = ap;
#line 643
          ap ++;
          {
#line 645
          if ((int )*__cil_tmp47 == '0') {
#line 645
            goto case_48___0;
          }
#line 645
          if ((int )*__cil_tmp47 == 'n') {
#line 645
            goto case_48___0;
          }
#line 648
          if ((int )*__cil_tmp47 == '\000') {
#line 648
            goto case_0___0;
          }
#line 652
          if ((int )*__cil_tmp47 == '1') {
#line 652
            goto case_49___0;
          }
#line 652
          if ((int )*__cil_tmp47 == 'y') {
#line 652
            goto case_49___0;
          }
#line 655
          if ((int )*__cil_tmp47 == 'a') {
#line 655
            goto case_97___1;
          }
#line 659
          if ((int )*__cil_tmp47 == 'i') {
#line 659
            goto case_105___0;
          }
#line 659
          if ((int )*__cil_tmp47 == 's') {
#line 659
            goto case_105___0;
          }
#line 667
          goto switch_default___0;
          case_48___0: /* CIL Label */ 
          case_110___0: /* CIL Label */ 
#line 646
          nwin_options.lflag = 0;
#line 647
          goto switch_break___1;
          case_0___0: /* CIL Label */ 
#line 649
          __cil_tmp48 = ap;
#line 649
          ap --;
          case_49___0: /* CIL Label */ 
          case_121___0: /* CIL Label */ 
#line 653
          nwin_options.lflag = 1;
#line 654
          goto switch_break___1;
          case_97___1: /* CIL Label */ 
#line 656
          nwin_options.lflag = 3;
#line 657
          goto switch_break___1;
          case_105___0: /* CIL Label */ 
          case_115: /* CIL Label */ 
#line 660
          lsflag = 1;
#line 661
          if (ac > 1) {
#line 661
            if (! SockMatch) {
#line 662
              av ++;
#line 662
              SockMatch = *av;
#line 663
              __cil_tmp49 = ac;
#line 663
              ac --;
            }
          }
#line 665
          ap = (char *)((void *)0);
#line 666
          goto switch_break___1;
          switch_default___0: /* CIL Label */ 
          {
#line 668
          ap --;
#line 668
          exit_with_usage(myname, (char *)"%s: Unknown suboption to -l", ap);
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 670
          goto switch_break;
          case_119: /* CIL Label */ 
          {
#line 673
          __cil_tmp50 = strcmp((char const   *)(ap + 1), (char const   *)((char *)"ipe"));
          }
#line 673
          if (__cil_tmp50) {
            {
#line 674
            ap --;
#line 674
            exit_with_usage(myname, (char *)"Unknown option %s", ap);
            }
          }
#line 675
          lsflag = 1;
#line 676
          wipeflag = 1;
#line 677
          if (ac > 1) {
#line 677
            if (! SockMatch) {
#line 678
              av ++;
#line 678
              SockMatch = *av;
#line 679
              __cil_tmp51 = ac;
#line 679
              ac --;
            }
          }
#line 681
          goto switch_break;
          case_76: /* CIL Label */ 
          {
#line 684
          __cil_tmp52 = strcmp((char const   *)(ap + 1), (char const   *)((char *)"ogfile"));
          }
#line 684
          if (! __cil_tmp52) {
#line 685
            ac --;
#line 685
            if (ac == 0) {
              {
#line 686
              exit_with_usage(myname, (char *)"Specify logfile path with -Logfile",
                              (char *)((void *)0));
              }
            }
            {
#line 688
            av ++;
#line 688
            __cil_tmp53 = strlen((char const   *)*av);
            }
#line 688
            if (__cil_tmp53 > 4096UL) {
              {
#line 689
              Panic(1, (char const   *)((char *)"-Logfile name too long. (max. %d char)"),
                    4096);
              }
            }
            {
#line 691
            free((void *)screenlogfile);
#line 692
            screenlogfile = SaveStr((char const   *)*av);
#line 694
            ap = (char *)((void *)0);
            }
          } else {
            {
#line 695
            __cil_tmp55 = strcmp((char const   *)ap, (char const   *)((char *)"L"));
            }
#line 695
            if (! __cil_tmp55) {
#line 696
              nwin_options.Lflag = 1;
            }
          }
#line 698
          goto switch_break;
          case_109: /* CIL Label */ 
#line 701
          mflag = 1;
#line 702
          goto switch_break;
          case_79: /* CIL Label */ 
#line 705
          force_vt = 0;
#line 706
          goto switch_break;
          case_84: /* CIL Label */ 
#line 709
          ac --;
#line 709
          if (ac == 0) {
            {
#line 710
            exit_with_usage(myname, (char *)"Specify terminal-type with -T", (char *)((void *)0));
            }
          }
          {
#line 711
          av ++;
#line 711
          __cil_tmp56 = strlen((char const   *)*av);
          }
#line 711
          if (__cil_tmp56 < 32UL) {
            {
#line 712
            strncpy((char *)screenterm, (char const   *)*av, (unsigned long )32);
#line 713
            screenterm[32] = (char )'\000';
            }
          } else {
            {
#line 715
            Panic(0, (char const   *)((char *)"-T: terminal name too long. (max. %d char)"),
                  32);
            }
          }
#line 716
          nwin_options.term = (char *)screenterm;
#line 717
          goto switch_break;
          case_113: /* CIL Label */ 
#line 720
          quietflag = 1;
#line 721
          goto switch_break;
          case_81: /* CIL Label */ 
#line 724
          queryflag = 1;
#line 725
          cmdflag = 1;
#line 726
          goto switch_break;
          case_120: /* CIL Label */ 
          case_82: /* CIL Label */ 
          case_114: /* CIL Label */ 
#line 733
          if (ac > 1) {
#line 733
            if ((int )*(*(av + 1)) != 45) {
#line 733
              if (! SockMatch) {
#line 734
                av ++;
#line 734
                SockMatch = *av;
#line 735
                __cil_tmp57 = ac;
#line 735
                ac --;
                {
#line 736
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 736
                  goto while_break___13;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
            }
          }
#line 739
          if ((int )*ap == 120) {
#line 740
            xflag = 1;
          }
#line 742
          if (rflag) {
#line 743
            rflag = 2;
          }
#line 744
          if ((int )*ap == 82) {
#line 744
            tmp___1093 = 2;
          } else {
#line 744
            tmp___1093 = 1;
          }
#line 744
          rflag += tmp___1093;
#line 745
          goto switch_break;
          case_100: /* CIL Label */ 
#line 749
          dflag = 1;
          case_68: /* CIL Label */ 
#line 753
          if (! dflag) {
#line 754
            dflag = 2;
          }
#line 755
          if (ac == 2) {
#line 756
            if ((int )*(*(av + 1)) != 45) {
#line 756
              if (! SockMatch) {
#line 757
                av ++;
#line 757
                SockMatch = *av;
#line 758
                __cil_tmp59 = ac;
#line 758
                ac --;
                {
#line 759
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 759
                  goto while_break___14;
                }
                while_break___14: /* CIL Label */ ;
                }
              }
            }
          }
#line 762
          goto switch_break;
          case_115___0: /* CIL Label */ 
#line 766
          ac --;
#line 766
          if (ac == 0) {
            {
#line 767
            exit_with_usage(myname, (char *)"Specify shell with -s", (char *)((void *)0));
            }
          }
#line 768
          if (ShellProg) {
            {
#line 769
            free((void *)ShellProg);
            }
          }
          {
#line 770
          av ++;
#line 770
          __cil_tmp60 = SaveStr((char const   *)*av);
#line 770
          ShellProg = __cil_tmp60;
          }
          {
#line 771
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 771
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 772
          goto switch_break;
          case_83: /* CIL Label */ 
#line 775
          if (! SockMatch) {
#line 776
            ac --;
#line 776
            if (ac == 0) {
              {
#line 777
              exit_with_usage(myname, (char *)"Specify session-name with -S", (char *)((void *)0));
              }
            }
#line 778
            av ++;
#line 778
            SockMatch = *av;
          }
#line 780
          if (! *SockMatch) {
            {
#line 781
            exit_with_usage(myname, (char *)"Empty session-name?", (char *)((void *)0));
            }
          }
#line 782
          goto switch_break;
          case_88: /* CIL Label */ 
#line 785
          cmdflag = 1;
#line 786
          goto switch_break;
          case_118: /* CIL Label */ 
          {
#line 789
          Panic(0, (char const   *)((char *)"Screen version %s"), (char *)version);
          }
          case_85: /* CIL Label */ 
#line 794
          if (nwin_options.encoding == -1) {
#line 794
            tmp___1094 = 8;
          } else {
#line 794
            tmp___1094 = 0;
          }
#line 794
          nwin_options.encoding = tmp___1094;
#line 795
          goto switch_break;
          switch_default___1: /* CIL Label */ 
          {
#line 799
          ap --;
#line 799
          exit_with_usage(myname, (char *)"Unknown option %s", ap);
          }
          switch_break: /* CIL Label */ ;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
      } else {
#line 804
        goto while_break___11;
      }
    } else {
#line 804
      goto while_break___11;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 808
  xsignal(7, CoreDump);
#line 810
  xsignal(11, CoreDump);
#line 814
  setlocale(6, (char const   *)((char *)""));
  }
#line 817
  if (nwin_options.encoding == -1) {
    {
#line 823
    __cil_tmp62 = nl_langinfo(14);
#line 823
    __cil_tmp63 = FindEncoding(__cil_tmp62);
#line 823
    nwin_options.encoding = __cil_tmp63;
    }
    {
#line 824
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 824
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
  }
  {
#line 838
  s = locale_name();
  }
#line 838
  if (s) {
    {
#line 839
    __cil_tmp68 = strncmp((char const   *)s, (char const   *)((char *)"ko_"), (unsigned long )3);
    }
    {
#line 839
    __cil_tmp67 = strncmp((char const   *)s, (char const   *)((char *)"ja_"), (unsigned long )3);
    }
    {
#line 839
    __cil_tmp66 = strncmp((char const   *)s, (char const   *)((char *)"zh_"), (unsigned long )3);
    }
#line 839
    if (! __cil_tmp66) {
#line 840
      cjkwidth = 1;
    } else
#line 839
    if (! __cil_tmp67) {
#line 840
      cjkwidth = 1;
    } else
#line 839
    if (! __cil_tmp68) {
#line 840
      cjkwidth = 1;
    }
  }
#line 847
  if (nwin_options.aka) {
#line 849
    if (nwin_options.encoding > 0) {
      {
#line 850
      __cil_tmp70 = strlen((char const   *)nwin_options.aka);
#line 850
      len = __cil_tmp70;
#line 852
      __cil_tmp73 = malloc(3UL * len);
#line 852
      newbuf = (char *)__cil_tmp73;
      }
#line 853
      if (! newbuf) {
        {
#line 854
        Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
        }
      }
      {
#line 855
      __cil_tmp74 = RecodeBuf((unsigned char *)nwin_options.aka, (int )len, nwin_options.encoding,
                              0, (unsigned char *)newbuf);
#line 855
      newsz = (size_t )__cil_tmp74;
#line 857
      *(newbuf + newsz) = (char )'\000';
#line 858
      nwin_options.aka = newbuf;
      }
    } else {
      {
#line 865
      nwin_options.aka = SaveStr((char const   *)nwin_options.aka);
      }
    }
  }
  {
#line 869
  __cil_tmp76 = strlen((char const   *)SockMatch);
  }
#line 869
  if (SockMatch) {
#line 869
    if (__cil_tmp76 >= 768UL) {
      {
#line 870
      Panic(0, (char const   *)((char *)"Ridiculously long socketname - try again."));
      }
    }
  }
#line 871
  if (cmdflag) {
#line 871
    if (! rflag) {
#line 871
      if (! dflag) {
#line 871
        if (! xflag) {
#line 872
          xflag = 1;
        }
      }
    }
  }
#line 873
  if (! cmdflag) {
#line 873
    if (dflag) {
#line 873
      if (mflag) {
#line 873
        if (! (rflag || xflag)) {
#line 874
          detached = 1;
        }
      }
    }
  }
#line 875
  nwin = nwin_options;
#line 878
  nwin.encoding = nwin_undef.encoding;
#line 880
  if (ac) {
#line 881
    nwin.args = av;
  }
  {
#line 895
  xsignal(25, (__sighandler_t )1);
#line 899
  xsignal(13, (__sighandler_t )1);
  }
#line 902
  if (! ShellProg) {
    {
#line 904
    sh = getenv((char const   *)((char *)"SHELL"));
    }
#line 905
    if (sh) {
#line 905
      tmp___1095 = sh;
    } else {
#line 905
      tmp___1095 = (char *)DefaultShell;
    }
    {
#line 905
    __cil_tmp80 = SaveStr((char const   *)tmp___1095);
#line 905
    ShellProg = __cil_tmp80;
    }
  }
  {
#line 907
  ShellArgs[0] = ShellProg;
#line 908
  home = getenv((char const   *)((char *)"HOME"));
  }
#line 909
  if (! mflag) {
#line 909
    if (! SockMatch) {
      {
#line 910
      sty = getenv((char const   *)((char *)"STY"));
      }
#line 911
      if (sty) {
#line 911
        if ((int )*sty == 0) {
#line 912
          sty = (char *)0;
        }
      }
    }
  }
  {
#line 916
  __cil_tmp83 = getenv((char const   *)((char *)"NETHACKOPTIONS"));
#line 916
  nethackflag = __cil_tmp83 != (char *)((void *)0);
  }
#line 916
  if (! nethackflag) {
    {
#line 919
    __cil_tmp85 = strlen((char const   *)home);
    }
#line 919
    if (home) {
#line 919
      if (__cil_tmp85 < 4076UL) {
        {
#line 920
        sprintf((char *)nethackrc, (char const   *)((char *)"%s/.nethackrc"), home);
#line 921
        __cil_tmp86 = access((char const   *)((char *)nethackrc), 0);
#line 921
        nethackflag = ! __cil_tmp86;
        }
      }
    }
  }
  {
#line 927
  multi_uid = real_uid;
#line 927
  own_uid = multi_uid;
#line 928
  sockp = index((char const   *)SockMatch, '/');
  }
#line 928
  if (SockMatch) {
#line 928
    if (sockp) {
#line 929
      *sockp = (char )0;
#line 930
      multi = SockMatch;
#line 931
      SockMatch = sockp + 1;
#line 932
      if (*multi) {
        {
#line 934
        mppp = getpwnam((char const   *)multi);
        }
#line 934
        if (mppp == (struct passwd *)0) {
          {
#line 935
          Panic(0, (char const   *)((char *)"Cannot identify account \'%s\'."), multi);
          }
        }
        {
#line 936
        multi_uid = (int )mppp->pw_uid;
#line 937
        multi_home = SaveStr((char const   *)mppp->pw_dir);
#line 938
        __cil_tmp91 = strlen((char const   *)multi_home);
        }
#line 938
        if (__cil_tmp91 > 4086UL) {
          {
#line 939
          Panic(0, (char const   *)((char *)"home directory path too long"));
          }
        }
#line 943
        if (rflag) {
#line 944
          xflag = 1;
        } else
#line 943
        if (lsflag) {
#line 944
          xflag = 1;
        }
#line 946
        detached = 0;
#line 947
        multiattach = 1;
      }
#line 950
      if (eff_uid) {
#line 950
        if (multi_uid != eff_uid) {
          {
#line 951
          Panic(0, (char const   *)((char *)"Must run suid root for multiuser support."));
          }
        }
      }
    }
  }
#line 953
  if (SockMatch) {
#line 953
    if ((int )*SockMatch == 0) {
#line 954
      SockMatch = (char *)0;
    }
  }
  {
#line 957
  LoginName = getlogin();
  }
#line 957
  if (LoginName) {
#line 957
    if ((int )*(LoginName + 0) != 0) {
      {
#line 958
      ppp = getpwnam((char const   *)LoginName);
      }
#line 958
      if (ppp != (struct passwd *)0) {
#line 959
        if ((int )ppp->pw_uid != real_uid) {
#line 960
          ppp = (struct passwd *)0;
        }
      }
    }
  }
#line 962
  if (ppp == (struct passwd *)0) {
    {
#line 963
    ppp = getpwuid((__uid_t )real_uid);
    }
#line 963
    if (ppp == (struct passwd *)0) {
      {
#line 964
      Panic(0, (char const   *)((char *)"getpwuid() can\'t identify your account!"));
#line 965
      exit(1);
      }
    }
#line 967
    LoginName = ppp->pw_name;
  }
  {
#line 969
  LoginName = SaveStr((char const   *)LoginName);
#line 970
  ppp = getpwbyname(LoginName, ppp);
  }
#line 987
  if (home == (char *)0) {
#line 988
    home = ppp->pw_dir;
  } else
#line 987
  if ((int )*home == 0) {
#line 988
    home = ppp->pw_dir;
  }
  {
#line 989
  __cil_tmp97 = strlen((char const   *)LoginName);
  }
#line 989
  if (__cil_tmp97 > 256UL) {
    {
#line 990
    Panic(0, (char const   *)((char *)"LoginName too long - sorry."));
    }
  }
  {
#line 993
  __cil_tmp98 = strlen((char const   *)multi);
  }
#line 993
  if (multi) {
#line 993
    if (__cil_tmp98 > 256UL) {
      {
#line 994
      Panic(0, (char const   *)((char *)"Screen owner name too long - sorry."));
      }
    }
  }
  {
#line 996
  __cil_tmp99 = strlen((char const   *)home);
  }
#line 996
  if (__cil_tmp99 > 4071UL) {
    {
#line 997
    Panic(0, (char const   *)((char *)"$HOME too long - sorry."));
    }
  }
#line 999
  attach_tty = (char *)"";
#line 1000
  if (! detached) {
#line 1000
    if (! lsflag) {
#line 1000
      if (! cmdflag) {
#line 1000
        if (! (((dflag && ! mflag) && ! rflag) && ! xflag)) {
#line 1000
          if (! ((((sty && ! SockMatch) && ! mflag) && ! rflag) && ! xflag)) {
            {
#line 1005
            SetTtyname(1, & st);
#line 1007
            tty_mode = (int )st.st_mode & 511;
#line 1010
            fl = fcntl(0, 3, 0);
            }
#line 1011
            if (fl != -1) {
#line 1011
              if ((fl & 3) == 2) {
#line 1012
                attach_fd = 0;
              }
            }
#line 1015
            if (attach_fd == -1) {
              {
#line 1016
              n = secopen(attach_tty, 2050, 0);
              }
#line 1016
              if (n < 0) {
                {
#line 1017
                Panic(0, (char const   *)((char *)"Cannot open your terminal \'%s\' - please check."),
                      attach_tty);
                }
              }
#line 1019
              attach_fd = n;
            }
            {
#line 1022
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 1022
              goto while_break___17;
            }
            while_break___17: /* CIL Label */ ;
            }
            {
#line 1024
            attach_term = getenv((char const   *)((char *)"TERM"));
            }
#line 1024
            if (attach_term == (char *)0) {
              {
              {
#line 1025
              Panic(0, (char const   *)((char *)"Please set a terminal type."));
              }
              }
            } else
#line 1024
            if ((int )*attach_term == 0) {
              {
              {
#line 1025
              Panic(0, (char const   *)((char *)"Please set a terminal type."));
              }
              }
            }
            {
#line 1026
            __cil_tmp104 = strlen((char const   *)attach_term);
            }
#line 1026
            if (__cil_tmp104 > 32UL) {
              {
#line 1027
              Panic(0, (char const   *)((char *)"$TERM too long - sorry."));
              }
            }
            {
#line 1029
            GetTTY(0, & attach_Mode);
            }
          }
        }
      }
    }
  }
  {
#line 1038
  __cil_tmp105 = umask((__mode_t )0);
#line 1038
  oumask = (int )__cil_tmp105;
  }
#line 1038
  if (oumask == -1) {
    {
#line 1039
    __cil_tmp106 = __errno_location();
#line 1039
    Panic(*__cil_tmp106, (char const   *)((char *)"Cannot change umask to zero"));
    }
  }
  {
#line 1042
  SockDir = getenv((char const   *)((char *)"SCREENDIR"));
  }
#line 1043
  if (SockDir) {
    {
#line 1044
    __cil_tmp108 = strlen((char const   *)SockDir);
    }
#line 1044
    if (__cil_tmp108 >= 4095UL) {
      {
#line 1045
      Panic(0, (char const   *)((char *)"Ridiculously long $SCREENDIR - try again."));
      }
    }
#line 1048
    if (multi) {
      {
#line 1049
      Panic(0, (char const   *)((char *)"No $SCREENDIR with multi screens, please."));
      }
    }
  }
#line 1054
  if (multiattach) {
#line 1059
    if (eff_uid) {
#line 1059
      tmp___1096 = (char *)"/tmp/uscreens";
    } else {
#line 1059
      tmp___1096 = (char *)"/tmp/screens";
    }
    {
#line 1059
    SockDir = tmp___1096;
#line 1060
    sprintf((char *)SockPath, (char const   *)((char *)"%s/S-%s"), SockDir, multi);
    }
  } else
#line 1073
  if (SockDir) {
    {
#line 1074
    __cil_tmp110 = access((char const   *)SockDir, 0);
    }
#line 1074
    if (__cil_tmp110) {
      {
#line 1075
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 1075
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 1076
      __cil_tmp111 = UserContext();
      }
#line 1076
      if (__cil_tmp111 > 0) {
        {
#line 1077
        __cil_tmp112 = mkdir((char const   *)SockDir, (__mode_t )448);
        }
#line 1077
        if (__cil_tmp112) {
          {
#line 1078
          UserReturn(0);
          }
        }
        {
#line 1079
        UserReturn(1);
        }
      }
      {
#line 1082
      __cil_tmp113 = UserStatus();
      }
#line 1082
      if (__cil_tmp113 <= 0) {
        {
#line 1083
        Panic(0, (char const   *)((char *)"Cannot make directory \'%s\'."), SockDir);
        }
      }
    }
#line 1085
    if (SockDir != (char *)SockPath) {
      {
#line 1086
      strcpy((char *)SockPath, (char const   *)SockDir);
      }
    }
  } else {
#line 1091
    if (eff_uid) {
#line 1091
      tmp___1097 = (char *)"/tmp/uscreens";
    } else {
#line 1091
      tmp___1097 = (char *)"/tmp/screens";
    }
    {
#line 1091
    SockDir = tmp___1097;
#line 1092
    __cil_tmp115 = stat((char const   *)SockDir, & st);
    }
#line 1092
    if (__cil_tmp115) {
#line 1093
      if (eff_uid == 0 && (real_uid || eff_gid == real_gid)) {
#line 1093
        tmp___1099 = 493;
      } else {
#line 1093
        if (eff_gid != real_gid) {
#line 1093
          tmp___1098 = 509;
        } else {
#line 1093
          tmp___1098 = 1023;
        }
#line 1093
        tmp___1099 = tmp___1098;
      }
      {
#line 1093
      n = tmp___1099;
#line 1101
      __cil_tmp118 = mkdir((char const   *)SockDir, (__mode_t )n);
      }
#line 1101
      if (__cil_tmp118 == -1) {
        {
#line 1102
        __cil_tmp119 = __errno_location();
#line 1102
        Panic(*__cil_tmp119, (char const   *)((char *)"Cannot make directory \'%s\'"),
              SockDir);
        }
      }
    } else {
#line 1105
      if (! ((st.st_mode & 61440U) == 16384U)) {
        {
#line 1106
        Panic(0, (char const   *)((char *)"\'%s\' must be a directory."), SockDir);
        }
      }
#line 1107
      if (eff_uid == 0) {
#line 1107
        if (real_uid) {
#line 1107
          if ((int )st.st_uid != eff_uid) {
            {
#line 1108
            Panic(0, (char const   *)((char *)"Directory \'%s\' must be owned by root."),
                  SockDir);
            }
          }
        }
      }
#line 1109
      if (eff_uid == 0 && (real_uid || (st.st_mode & 509U) != 509U)) {
#line 1109
        tmp___1101 = 493;
      } else {
#line 1109
        if (eff_gid == (int )st.st_gid && eff_gid != real_gid) {
#line 1109
          tmp___1100 = 509;
        } else {
#line 1109
          tmp___1100 = 511;
        }
#line 1109
        tmp___1101 = tmp___1100;
      }
#line 1109
      n = tmp___1101;
#line 1111
      if (((int )st.st_mode & 511) != n) {
        {
#line 1112
        Panic(0, (char const   *)((char *)"Directory \'%s\' must have mode %03o."),
              SockDir, n);
        }
      }
    }
    {
#line 1114
    sprintf((char *)SockPath, (char const   *)((char *)"%s/S-%s"), SockDir, LoginName);
#line 1115
    __cil_tmp122 = access((char const   *)((char *)SockPath), 0);
    }
#line 1115
    if (__cil_tmp122) {
      {
#line 1116
      __cil_tmp124 = __errno_location();
      }
      {
#line 1116
      __cil_tmp123 = mkdir((char const   *)((char *)SockPath), (__mode_t )448);
      }
#line 1116
      if (__cil_tmp123 == -1) {
#line 1116
        if (*__cil_tmp124 != 17) {
          {
#line 1117
          __cil_tmp125 = __errno_location();
#line 1117
          Panic(*__cil_tmp125, (char const   *)((char *)"Cannot make directory \'%s\'"),
                (char *)SockPath);
          }
        }
      }
      {
#line 1118
      __cil_tmp126 = chown((char const   *)((char *)SockPath), (__uid_t )real_uid,
                           (__gid_t )real_gid);
      }
    }
  }
  {
#line 1124
  __cil_tmp127 = stat((char const   *)((char *)SockPath), & st);
  }
#line 1124
  if (__cil_tmp127 == -1) {
    {
#line 1125
    __cil_tmp128 = __errno_location();
#line 1125
    Panic(*__cil_tmp128, (char const   *)((char *)"Cannot access %s"), (char *)SockPath);
    }
  } else
#line 1127
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 1128
    Panic(0, (char const   *)((char *)"%s is not a directory."), (char *)SockPath);
    }
  }
#line 1130
  if (multi) {
#line 1131
    if ((int )st.st_uid != multi_uid) {
      {
#line 1132
      Panic(0, (char const   *)((char *)"%s is not the owner of %s."), multi, (char *)SockPath);
      }
    }
  } else
#line 1142
  if ((int )st.st_uid != real_uid) {
    {
#line 1143
    Panic(0, (char const   *)((char *)"You are not the owner of %s."), (char *)SockPath);
    }
  }
#line 1147
  if ((st.st_mode & 511U) != 448U) {
    {
#line 1148
    Panic(0, (char const   *)((char *)"Directory %s must have mode 700."), (char *)SockPath);
    }
  }
  {
#line 1149
  __cil_tmp129 = index((char const   *)SockMatch, '/');
  }
#line 1149
  if (SockMatch) {
#line 1149
    if (__cil_tmp129) {
      {
#line 1150
      Panic(0, (char const   *)((char *)"Bad session name \'%s\'"), SockMatch);
      }
    }
  }
  {
#line 1151
  __cil_tmp130 = strlen((char const   *)((char *)SockPath));
#line 1151
  SockName = ((char *)SockPath + __cil_tmp130) + 1;
#line 1152
  *SockName = (char )0;
#line 1153
  __cil_tmp131 = umask((__mode_t )oumask);
  }
  {
#line 1154
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 1154
    goto while_break___19;
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 1163
  __cil_tmp132 = gethostname((char *)HostName, (size_t )768);
#line 1164
  HostName[767] = (char )'\000';
#line 1166
  ap = index((char const   *)((char *)HostName), '.');
  }
#line 1166
  if (ap != (char *)((void *)0)) {
#line 1167
    *ap = (char )'\000';
  }
#line 1169
  if (lsflag) {
#line 1174
    if (multi) {
#line 1175
      real_uid = multi_uid;
    }
    {
#line 1178
    while (1) {
      while_continue___20: /* CIL Label */ ;
      {
#line 1178
      setgid((__gid_t )real_gid);
#line 1178
      setuid((__uid_t )real_uid);
#line 1178
      eff_uid = real_uid;
#line 1178
      eff_gid = real_gid;
      }
#line 1178
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 1179
    i = FindSocket((int *)((void *)0), & fo, & oth, SockMatch, & sock);
    }
#line 1180
    if (quietflag) {
#line 1181
      if (rflag) {
        {
#line 1182
        exit(10 + i);
        }
      } else {
#line 1184
        if (fo || oth) {
#line 1184
          tmp___1102 = 1;
        } else {
#line 1184
          tmp___1102 = 0;
        }
        {
#line 1184
        exit((9 + tmp___1102) + fo);
        }
      }
    }
#line 1186
    if (fo == 0) {
      {
#line 1187
      Panic(0, (char const   *)((char *)"No Sockets found in %s.\n"), (char *)SockPath);
      }
    }
#line 1188
    if (fo > 1) {
#line 1188
      tmp___1103 = (char *)"s";
    } else {
#line 1188
      tmp___1103 = (char *)"";
    }
    {
#line 1188
    Msg(0, (char const   *)((char *)"%d Socket%s in %s."), fo, tmp___1103, (char *)SockPath);
#line 1189
    eexit(0);
    }
  }
  {
#line 1191
  xsignal(1, AttacherFinit);
  }
#line 1192
  if (cmdflag) {
    {
#line 1194
    SetTtyname(0, & st);
    }
#line 1195
    if (! *av) {
      {
#line 1196
      Panic(0, (char const   *)((char *)"Please specify a command."));
      }
    }
    {
#line 1197
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 1197
      setgid((__gid_t )real_gid);
#line 1197
      setuid((__uid_t )real_uid);
#line 1197
      eff_uid = real_uid;
#line 1197
      eff_gid = real_gid;
      }
#line 1197
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 1198
    SendCmdMessage(sty, SockMatch, av, queryflag >= 0);
#line 1199
    exit(0);
    }
  } else
#line 1201
  if (rflag) {
    _L: /* CIL Label */ 
    {
#line 1202
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1202
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 1203
    __cil_tmp141 = Attach(2);
    }
#line 1203
    if (__cil_tmp141) {
      {
#line 1204
      Attacher();
      }
    }
#line 1208
    if (multiattach) {
      {
#line 1209
      Panic(0, (char const   *)((char *)"Can\'t create sessions of other users."));
      }
    }
    {
#line 1212
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 1212
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
  } else
#line 1201
  if (xflag) {
#line 1201
    goto _L;
  } else
#line 1214
  if (dflag) {
#line 1214
    if (! mflag) {
      {
#line 1215
      SetTtyname(0, & st);
#line 1216
      Attach(4);
      }
#line 1217
      if (dflag > 1) {
#line 1217
        tmp___1104 = (char *)"power ";
      } else {
#line 1217
        tmp___1104 = (char *)"";
      }
      {
#line 1217
      Msg(0, (char const   *)((char *)"[%s %sdetached.]\n"), SockName, tmp___1104);
#line 1218
      eexit(0);
      }
    }
  }
#line 1221
  if (! SockMatch) {
#line 1221
    if (! mflag) {
#line 1221
      if (sty) {
        {
#line 1223
        SetTtyname(0, & st);
        }
        {
#line 1224
        while (1) {
          while_continue___24: /* CIL Label */ ;
          {
#line 1224
          setgid((__gid_t )real_gid);
#line 1224
          setuid((__uid_t )real_uid);
#line 1224
          eff_uid = real_uid;
#line 1224
          eff_gid = real_gid;
          }
#line 1224
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
        {
#line 1225
        nwin_options.args = av;
#line 1226
        SendCreateMsg(sty, & nwin);
#line 1227
        exit(0);
        }
      }
    }
  }
  {
#line 1230
  nwin_compose(& nwin_default, & nwin_options, & nwin_default);
  }
#line 1232
  if (! detached) {
    {
    {
#line 1233
    MasterPid = fork();
    }
    }
  } else
#line 1232
  if (dflag != 2) {
    {
    {
#line 1233
    MasterPid = fork();
    }
    }
  } else {
#line 1235
    MasterPid = 0;
  }
  {
#line 1238
  if (MasterPid == - 1) {
#line 1238
    goto case_exp;
  }
#line 1241
  if (MasterPid == 0) {
#line 1241
    goto case_0___1;
  }
#line 1243
  goto switch_default___2;
  case_exp: /* CIL Label */ 
  {
#line 1239
  __cil_tmp144 = __errno_location();
#line 1239
  Panic(*__cil_tmp144, (char const   *)((char *)"fork"));
  }
  case_0___1: /* CIL Label */ 
#line 1242
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 1244
  if (detached) {
    {
#line 1245
    exit(0);
    }
  }
#line 1246
  if (SockMatch) {
    {
#line 1247
    sprintf((char *)socknamebuf, (char const   *)((char *)"%d.%s"), MasterPid, SockMatch);
    }
  } else {
    {
#line 1249
    __cil_tmp145 = stripdev(attach_tty);
#line 1249
    sprintf((char *)socknamebuf, (char const   *)((char *)"%d.%s.%s"), MasterPid,
            __cil_tmp145, (char *)HostName);
    }
  }
#line 1250
  ap = (char *)socknamebuf;
  {
#line 1250
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 1250
    if (! *ap) {
#line 1250
      goto while_break___25;
    }
#line 1251
    if ((int )*ap == 47) {
#line 1252
      *ap = (char )'-';
    }
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 1250
  ap ++;
#line 1254
  __cil_tmp147 = strlen((char const   *)((char *)socknamebuf));
  }
#line 1254
  if (__cil_tmp147 > 255UL) {
#line 1255
    socknamebuf[255] = (char )0;
  }
  {
#line 1257
  __cil_tmp148 = strlen((char const   *)((char *)SockPath));
#line 1257
  sprintf((char *)SockPath + __cil_tmp148, (char const   *)((char *)"/%s"), (char *)socknamebuf);
  }
  {
#line 1258
  while (1) {
    while_continue___26: /* CIL Label */ ;
    {
#line 1258
    setgid((__gid_t )real_gid);
#line 1258
    setuid((__uid_t )real_uid);
#line 1258
    eff_uid = real_uid;
#line 1258
    eff_gid = real_gid;
    }
#line 1258
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
  {
#line 1259
  Attacher();
  }
  switch_break___2: /* CIL Label */ ;
  }
#line 1263
  if (! detached) {
    {
#line 1264
    PanicPid = getppid();
    }
  }
#line 1266
  if (DefaultEsc == -1) {
#line 1267
    DefaultEsc = 1;
  }
#line 1268
  if (DefaultMetaEsc == -1) {
#line 1269
    DefaultMetaEsc = 'a';
  }
  {
#line 1271
  __cil_tmp150 = strlen((char const   *)av0);
#line 1271
  ap = (av0 + __cil_tmp150) - 1;
  }
  {
#line 1272
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 1272
    if (! (ap >= av0)) {
#line 1272
      goto while_break___27;
    }
    {
#line 1273
    __cil_tmp151 = strncmp((char const   *)((char *)"screen"), (char const   *)ap,
                           (unsigned long )6);
    }
#line 1273
    if (! __cil_tmp151) {
      {
#line 1274
      memcpy((void *)ap, (void const   *)((char *)"SCREEN"), (unsigned long )6);
      }
#line 1275
      goto while_break___27;
    }
#line 1277
    __cil_tmp152 = ap;
#line 1277
    ap --;
  }
  while_break___27: /* CIL Label */ ;
  }
#line 1279
  if (ap < av0) {
#line 1280
    *av0 = (char )'S';
  }
#line 1296
  if (! detached) {
#line 1297
    if (attach_fd == -1) {
      {
#line 1298
      n = secopen(attach_tty, 2050, 0);
      }
#line 1298
      if (n < 0) {
        {
#line 1299
        Panic(0, (char const   *)((char *)"Cannot reopen \'%s\' - please check."),
              attach_tty);
        }
      }
    } else {
      {
#line 1302
      n = dup(attach_fd);
      }
    }
  } else {
#line 1305
    n = - 1;
  }
  {
#line 1306
  freopen((char const   *)((char *)"/dev/null"), (char const   *)((char *)"r"), stdin);
#line 1307
  freopen((char const   *)((char *)"/dev/null"), (char const   *)((char *)"w"), stdout);
#line 1312
  freopen((char const   *)((char *)"/dev/null"), (char const   *)((char *)"w"), stderr);
  }
  {
#line 1313
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 1313
    goto while_break___28;
  }
  while_break___28: /* CIL Label */ ;
  }
  {
#line 1319
  __cil_tmp155 = UserAdd(LoginName, (char *)0, (struct acluser **)0);
  }
#line 1319
  if (__cil_tmp155 < 0) {
    {
#line 1320
    Panic(0, (char const   *)((char *)"Could not create user info"));
    }
  }
#line 1321
  if (! detached) {
    {
#line 1322
    __cil_tmp156 = getppid();
#line 1322
    __cil_tmp157 = MakeDisplay(LoginName, attach_tty, attach_term, n, __cil_tmp156,
                               & attach_Mode);
    }
#line 1322
    if (__cil_tmp157 == (struct display *)0) {
      {
#line 1323
      Panic(0, (char const   *)((char *)"Could not alloc display"));
      }
    }
#line 1324
    PanicPid = 0;
#line 1326
    if (nwin_options.encoding > 0) {
#line 1326
      tmp___1105 = nwin_options.encoding;
    } else {
#line 1326
      tmp___1105 = 0;
    }
#line 1326
    display->d_encoding = tmp___1105;
    {
#line 1327
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 1327
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
  }
#line 1331
  if (SockMatch) {
    {
#line 1333
    __cil_tmp159 = getpid();
#line 1333
    sprintf((char *)socknamebuf, (char const   *)((char *)"%d.%s"), __cil_tmp159,
            SockMatch);
    }
  } else {
    {
#line 1336
    __cil_tmp160 = getpid();
    }
    {
#line 1336
    __cil_tmp161 = stripdev(attach_tty);
#line 1336
    sprintf((char *)socknamebuf, (char const   *)((char *)"%d.%s.%s"), __cil_tmp160,
            __cil_tmp161, (char *)HostName);
    }
  }
#line 1338
  ap = (char *)socknamebuf;
  {
#line 1338
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 1338
    if (! *ap) {
#line 1338
      goto while_break___30;
    }
#line 1339
    if ((int )*ap == 47) {
#line 1340
      *ap = (char )'-';
    }
  }
  while_break___30: /* CIL Label */ ;
  }
  {
#line 1338
  ap ++;
#line 1343
  __cil_tmp163 = strlen((char const   *)((char *)socknamebuf));
  }
#line 1343
  if (__cil_tmp163 > 255UL) {
    {
#line 1344
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 1344
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
#line 1345
    socknamebuf[255] = (char )0;
  }
  {
#line 1349
  __cil_tmp164 = strlen((char const   *)((char *)SockPath));
#line 1349
  sprintf((char *)SockPath + __cil_tmp164, (char const   *)((char *)"/%s"), (char *)socknamebuf);
#line 1353
  ServerSocket = MakeServerSocket(1);
#line 1357
  ap = getenv((char const   *)((char *)"SYSSCREENRC"));
  }
#line 1357
  if (ap) {
    {
#line 1358
    __cil_tmp167 = StartRc(ap, 0);
    }
  } else {
    {
#line 1361
    __cil_tmp168 = StartRc((char *)"/usr/etc/screenrc", 0);
    }
  }
  {
#line 1363
  __cil_tmp169 = StartRc(RcFileName, 0);
#line 1366
  InitUtmp();
  }
#line 1369
  if (display) {
    {
#line 1370
    __cil_tmp170 = InitTermcap(0, 0);
    }
#line 1370
    if (__cil_tmp170) {
      {
#line 1371
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 1371
        goto while_break___32;
      }
      while_break___32: /* CIL Label */ ;
      }
      {
#line 1372
      fcntl(display->d_userfd, 4, 0);
#line 1373
      freetty();
      }
#line 1374
      if (display->d_userpid) {
        {
#line 1375
        Kill(display->d_userpid, 1);
        }
      }
      {
#line 1376
      eexit(1);
      }
    }
    {
#line 1378
    MakeDefaultCanvas();
#line 1379
    InitTerm(0);
#line 1381
    RemoveLoginSlot();
    }
  } else {
    {
#line 1385
    MakeTermcap(1);
    }
  }
  {
#line 1388
  InitLoadav();
#line 1391
  InitKeytab();
#line 1392
  MakeNewEnv();
#line 1393
  xsignal(1, SigHup);
#line 1394
  xsignal(2, FinitHandler);
#line 1395
  xsignal(3, FinitHandler);
#line 1396
  xsignal(15, FinitHandler);
#line 1398
  xsignal(21, (__sighandler_t )1);
#line 1399
  xsignal(22, (__sighandler_t )1);
  }
#line 1402
  if (display) {
    {
#line 1403
    brktty(display->d_userfd);
#line 1404
    SetMode(& display->d_OldMode, & display->d_NewMode, display->d_flow, iflag);
#line 1406
    SetTTY(display->d_userfd, & display->d_NewMode);
#line 1407
    __cil_tmp171 = fcntl(display->d_userfd, 4, 2048);
    }
#line 1407
    if (__cil_tmp171) {
      {
#line 1408
      __cil_tmp172 = __errno_location();
#line 1408
      Msg(*__cil_tmp172, (char const   *)((char *)"Warning: NBLOCK fcntl failed"));
      }
    }
  } else {
    {
#line 1411
    brktty(- 1);
    }
  }
  {
#line 1412
  xsignal(17, SigChld);
#line 1415
  ap = getenv((char const   *)((char *)"SYSSCREENRC"));
  }
#line 1415
  if (ap) {
    {
#line 1416
    FinishRc(ap);
    }
  } else {
    {
#line 1419
    FinishRc((char *)"/usr/etc/screenrc");
    }
  }
  {
#line 1421
  FinishRc(RcFileName);
  }
  {
#line 1423
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 1423
    goto while_break___33;
  }
  while_break___33: /* CIL Label */ ;
  }
#line 1424
  if (windows == (struct win *)((void *)0)) {
    {
#line 1425
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 1425
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 1426
    __cil_tmp174 = MakeWindow(& nwin);
    }
#line 1426
    if (__cil_tmp174 == -1) {
#line 1428
      tv.tv_sec = (__time_t )(MsgWait / 1000);
      {
#line 1428
      tv.tv_usec = (__suseconds_t )(1000 * (MsgWait % 1000));
#line 1429
      rfd.fds_bits[0] |= (__fd_mask )(1UL << 0 % (8 * (int )sizeof(__fd_mask )));
#line 1431
      Msg(0, (char const   *)((char *)"Sorry, could not find a PTY or TTY."));
#line 1433
      select(1, & rfd, (fd_set *)((void *)0), (fd_set *)((void *)0), & tv);
#line 1434
      Finit(0);
      }
    }
  } else
#line 1438
  if (ac) {
    {
#line 1439
    MakeWindow(& nwin);
    }
  }
#line 1445
  if (display) {
#line 1445
    if (default_startup) {
      {
#line 1446
      display_copyright();
      }
    }
  }
  {
#line 1447
  xsignal(2, SigInt);
  }
#line 1448
  if (rflag) {
#line 1448
    if ((rflag & 1) == 0) {
#line 1448
      if (! quietflag) {
        {
#line 1449
        Msg(0, (char const   *)((char *)"New screen..."));
#line 1450
        rflag = 0;
        }
      }
    }
  }
  {
#line 1453
  serv_read.type = 1;
#line 1454
  serv_read.fd = ServerSocket;
#line 1455
  serv_read.handler = serv_read_fn;
#line 1456
  evenq(& serv_read);
#line 1458
  serv_select.pri = - 10;
#line 1459
  serv_select.type = 3;
#line 1460
  serv_select.handler = serv_select_fn;
#line 1461
  evenq(& serv_select);
#line 1463
  logflushev.type = 0;
#line 1464
  logflushev.handler = logflush_fn;
#line 1466
  sched();
  }
#line 1468
  return (0);
}
}
#line 1472 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void WindowDied(struct win *p , int wstat , int wstat_valid ) 
{ 
  int killit ;
  __pid_t __cil_tmp5 ;
  char buf[100] ;
  char *s ;
  char reason[100] ;
  time_t now ;
  char *tmp ;
  time_t __cil_tmp11 ;
  size_t __cil_tmp13 ;
  char *tmp___0 ;
  size_t __cil_tmp16 ;

  {
#line 1483
  killit = 0;
#line 1484
  if (p->w_destroyev.data == (char *)p) {
    {
#line 1485
    wstat = p->w_exitstatus;
#line 1486
    wstat_valid = 1;
#line 1487
    evdeq(& p->w_destroyev);
#line 1488
    p->w_destroyev.data = (char *)0;
    }
  }
#line 1492
  if (! wstat_valid) {
#line 1492
    if (p->w_pid > 0) {
      {
#line 1495
      __cil_tmp5 = waitpid(p->w_pid, & wstat, 3);
      }
#line 1495
      if (__cil_tmp5 == p->w_pid) {
#line 1496
        p->w_pid = 0;
#line 1497
        wstat_valid = 1;
      }
    }
  }
#line 1502
  if (ZombieKey_destroy) {
#line 1502
    if (ZombieKey_onerror) {
#line 1502
      if (wstat_valid) {
#line 1502
        if ((wstat & 127) == 0) {
#line 1502
          if ((wstat & 65280) >> 8 == 0) {
#line 1504
            killit = 1;
          }
        }
      }
    }
  }
#line 1506
  if (ZombieKey_destroy) {
#line 1506
    if (! killit) {
#line 1510
      if (wstat_valid) {
#line 1511
        if ((wstat & 127) == 0) {
#line 1512
          if ((wstat & 65280) >> 8) {
            {
#line 1513
            sprintf((char *)reason, (char const   *)((char *)"terminated with exit status %d"),
                    (wstat & 65280) >> 8);
            }
          } else {
            {
#line 1515
            sprintf((char *)reason, (char const   *)((char *)"terminated normally"));
            }
          }
        } else
#line 1516
        if ((int )((signed char )((wstat & 127) + 1)) >> 1 > 0) {
#line 1517
          if (wstat & 128) {
#line 1517
            tmp = (char *)" (core file generated)";
          } else {
#line 1517
            tmp = (char *)"";
          }
          {
#line 1517
          sprintf((char *)reason, (char const   *)((char *)"terminated with signal %d%s"),
                  wstat & 127, tmp);
          }
        }
      } else {
        {
#line 1525
        sprintf((char *)reason, (char const   *)((char *)"detached from window"));
        }
      }
      {
#line 1527
      __cil_tmp11 = time(& now);
#line 1528
      s = ctime(& now);
      }
#line 1529
      if (s) {
#line 1529
        if ((int )*s) {
          {
#line 1530
          __cil_tmp13 = strlen((char const   *)s);
#line 1530
          *(s + (__cil_tmp13 - 1UL)) = (char )'\000';
          }
        }
      }
      {
#line 1531
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1531
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1534
      if (p->w_slot != (slot_t )0) {
#line 1534
        if (p->w_slot != (slot_t )-1) {
          {
#line 1535
          RemoveUtmp(p);
#line 1536
          p->w_slot = (slot_t )0;
          }
        }
      }
      {
#line 1540
      CloseDevice(p);
#line 1541
      p->w_deadpid = p->w_pid;
#line 1542
      p->w_pid = 0;
#line 1543
      ResetWindow(p);
#line 1545
      p->w_layer.l_y = MFindUsedLine(p, p->w_bot, 1);
      }
#line 1546
      if (s) {
#line 1546
        tmp___0 = s;
      } else {
#line 1546
        tmp___0 = (char *)"?";
      }
      {
#line 1546
      sprintf((char *)buf, (char const   *)((char *)"\n\r=== Command %s (%s) ==="),
              (char *)reason, tmp___0);
#line 1547
      __cil_tmp16 = strlen((char const   *)((char *)buf));
#line 1547
      WriteString(p, (char *)buf, (int )__cil_tmp16);
      }
#line 1548
      if (p->w_poll_zombie_timeout) {
        {
#line 1549
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1549
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1551
        SetTimeout(& p->w_zombieev, p->w_poll_zombie_timeout * 1000);
#line 1552
        evenq(& p->w_zombieev);
        }
      }
      {
#line 1554
      WindowChanged(p, 'f');
      }
    } else {
      {
      {
#line 1557
      KillWindow(p);
      }
      }
    }
  } else {
    {
    {
#line 1557
    KillWindow(p);
    }
    }
  }

  return;
}
}
#line 1564 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void SigChldHandler(void) 
{ 
  struct stat st ;
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 1570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1570
    if (! GotSigChld) {
#line 1570
      goto while_break;
    }
    {
#line 1571
    GotSigChld = 0;
#line 1572
    DoWait();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1577
  __cil_tmp2 = stat((char const   *)((char *)SockPath), & st);
  }
#line 1577
  if (__cil_tmp2 == -1) {
    {
#line 1578
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1578
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1579
    __cil_tmp3 = RecoverSocket();
    }
#line 1579
    if (! __cil_tmp3) {
      {
#line 1580
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1580
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1581
      Finit(1);
      }
    } else {
      {
#line 1584
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1584
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1587
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1587
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 1590 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void SigChld(int sigsig ) 
{ 


  {
  {
#line 1592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1592
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1593
  GotSigChld = 1;
  return;
}
}
#line 1597 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void SigHup(int sigsig ) 
{ 


  {
  {
#line 1600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1600
    if (! (display != (struct display *)0)) {
#line 1600
      goto while_break;
    }
    {
#line 1601
    Hangup();
    }
  }
  while_break: /* CIL Label */ ;
  }

  return;
}
}
#line 1610 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void SigInt(int sigsig ) 
{ 


  {
  {
#line 1625
  xsignal(2, SigInt);
  }
  {
#line 1626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1626
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1627
  InterruptPlease = 1;
  return;
}
}
#line 1632 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void CoreDump(int sigsig ) 
{ 
  struct display *disp ;
  char buf[80] ;
  char *dump_msg ;
  int running_w_s_bit ;
  __uid_t __cil_tmp6 ;
  __uid_t __cil_tmp7 ;
  __gid_t __cil_tmp8 ;
  __uid_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  __pid_t __cil_tmp11 ;

  {
  {
#line 1639
  dump_msg = (char *)" (core dumped)";
#line 1640
  __cil_tmp7 = geteuid();
  }
  {
#line 1640
  __cil_tmp6 = getuid();
#line 1640
  running_w_s_bit = __cil_tmp6 != __cil_tmp7;
  }
#line 1643
  if (running_w_s_bit) {
#line 1644
    dump_msg = (char *)"";
  }
  {
#line 1650
  __cil_tmp8 = getgid();
#line 1650
  setgid(__cil_tmp8);
#line 1651
  __cil_tmp9 = getuid();
#line 1651
  setuid(__cil_tmp9);
#line 1652
  unlink((char const   *)((char *)"core"));
#line 1655
  sprintf((char *)buf, (char const   *)((char *)"\r\n[screen caught signal %d.%s]\r\n"),
          sigsig, dump_msg);
#line 1660
  disp = displays;
  }
  {
#line 1660
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1660
    if (! disp) {
#line 1660
      goto while_break;
    }
#line 1661
    if (disp->d_nonblock < -1) {
#line 1662
      goto while_continue;
    } else
#line 1661
    if (disp->d_nonblock > 1000000) {
#line 1662
      goto while_continue;
    }
    {
#line 1663
    fcntl(disp->d_userfd, 4, 0);
#line 1664
    SetTTY(disp->d_userfd, & display->d_OldMode);
#line 1665
    __cil_tmp10 = strlen((char const   *)((char *)buf));
#line 1665
    write(disp->d_userfd, (void const   *)((char *)buf), __cil_tmp10);
#line 1666
    Kill(disp->d_userpid, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1660
  disp = disp->d_next;
#line 1669
  if (running_w_s_bit) {
    {
#line 1671
    __cil_tmp11 = getpid();
#line 1671
    Kill(__cil_tmp11, 9);
#line 1672
    eexit(11);
    }
  } else {
    {
#line 1678
    abort();
    }
  }

  return;
}
}
#line 1683 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void DoWait(void) 
{ 
  register int pid ;
  struct win *p ;
  struct win *next ;
  int wstat ;
  int __cil_tmp6 ;

  {
  {
#line 1696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1696
    if (! (pid > 0)) {
#line 1696
      goto while_break;
    }
#line 1719
    p = windows;
    {
#line 1719
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1719
      if (! p) {
#line 1719
        goto while_break___0;
      }
#line 1720
      next = p->w_next;
#line 1721
      if (p->w_pid) {
#line 1721
        if (pid == p->w_pid) {
          _L: /* CIL Label */ 
#line 1723
          p->w_pid = 0;
#line 1726
          if ((wstat & 255) == 127) {
            {
#line 1727
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1727
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 1730
            if ((wstat & 65280) >> 8 == 21) {
              {
#line 1731
              Msg(0, (char const   *)((char *)"Suspended (tty input)"));
              }
#line 1732
              goto while_continue___0;
            }
#line 1738
            if ((wstat & 65280) >> 8 == 22) {
              {
#line 1739
              Msg(0, (char const   *)((char *)"Suspended (tty output)"));
              }
#line 1740
              goto while_continue___0;
            }
            {
#line 1745
            Msg(0, (char const   *)((char *)"Child has been stopped, restarting."));
#line 1746
            __cil_tmp6 = killpg(pid, 18);
            }
#line 1746
            if (__cil_tmp6) {
              {
#line 1747
              kill(pid, 18);
              }
            }
          } else {
            {
#line 1758
            p->w_destroyev.data = (char *)p;
#line 1759
            p->w_exitstatus = wstat;
#line 1760
            SetTimeout(& p->w_destroyev, 10000);
#line 1761
            evenq(& p->w_destroyev);
            }
          }
#line 1763
          goto while_break___0;
        } else {
#line 1721
          goto _L___1106;
        }
      } else
      _L___1106: /* CIL Label */ 
#line 1721
      if (p->w_deadpid) {
#line 1721
        if (pid == p->w_deadpid) {
#line 1721
          goto _L;
        }
      }
#line 1767
      if (p->w_pwin) {
#line 1767
        if (pid == (p->w_pwin)->p_pid) {
          {
#line 1768
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1768
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 1769
          FreePseudowin(p);
          }
#line 1770
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1719
    p = next;
#line 1776
    if (p == (struct win *)0) {
      {
#line 1777
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1777
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1782 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void FinitHandler(int sigsig ) 
{ 


  {
  {
#line 1785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1785
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1789
  Finit(1);
  }
  return;
}
}
#line 1793 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void Finit(int i ) 
{ 
  struct win *p ;
  int __cil_tmp3 ;

  {
  {
#line 1795
  xsignal(17, (__sighandler_t )0);
#line 1796
  xsignal(1, (__sighandler_t )1);
  }
  {
#line 1797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1797
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1798
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1798
    if (! windows) {
#line 1798
      goto while_break___0;
    }
    {
#line 1799
    p = windows;
#line 1800
    windows = windows->w_next;
#line 1801
    FreeWindow(p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1804
  if (ServerSocket != -1) {
    {
#line 1805
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1805
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1807
    xseteuid(real_uid);
#line 1808
    xsetegid(real_gid);
#line 1810
    __cil_tmp3 = unlink((char const   *)((char *)SockPath));
#line 1812
    xseteuid(eff_uid);
#line 1813
    xsetegid(eff_gid);
    }
  }
#line 1817
  display = displays;
  {
#line 1817
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1817
    if (! display) {
#line 1817
      goto while_break___2;
    }
#line 1818
    if (display->d_status) {
      {
#line 1819
      RemoveStatus();
      }
    }
    {
#line 1820
    FinitTerm();
#line 1822
    RestoreLoginSlot();
#line 1824
    AddStr((char *)"[screen is terminating]\r\n");
#line 1825
    Flush(3);
#line 1826
    SetTTY(display->d_userfd, & display->d_OldMode);
#line 1827
    fcntl(display->d_userfd, 4, 0);
#line 1828
    freetty();
#line 1829
    Kill(display->d_userpid, 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1817
  display = display->d_next;
#line 1835
  exit(i);
  }
}
}
#line 1838 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void eexit(int e ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1840
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1841
  if (ServerSocket != -1) {
    {
#line 1842
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1842
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1843
    setgid((__gid_t )real_gid);
#line 1844
    setuid((__uid_t )real_uid);
#line 1845
    __cil_tmp2 = unlink((char const   *)((char *)SockPath));
    }
  }
  {
#line 1847
  exit(e);
  }
}
}
#line 1850 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void Hangup(void) 
{ 


  {
#line 1852
  if (display == (struct display *)0) {
#line 1853
    return;
  }
  {
#line 1854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1854
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1855
  if (display->d_userfd >= 0) {
    {
#line 1856
    close(display->d_userfd);
#line 1857
    display->d_userfd = - 1;
    }
  }
#line 1859
  if (auto_detach) {
    {
    {
#line 1860
    Detach(6);
    }
    }
  } else
#line 1859
  if (displays->d_next) {
    {
    {
#line 1860
    Detach(6);
    }
    }
  } else {
    {
#line 1862
    Finit(0);
    }
  }
  return;
}
}
#line 1878 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void Detach(int mode ) 
{ 
  int sign ;
  int pid ;
  struct canvas *cv ;
  struct win *p ;
  int __cil_tmp6 ;
  int tmp ;
  int __cil_tmp8 ;

  {
#line 1880
  sign = 0;
#line 1884
  if (display == (struct display *)0) {
#line 1885
    return;
  }
  {
#line 1898
  xsignal(1, (__sighandler_t )1);
  }
  {
#line 1899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1899
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1900
  if (display->d_status) {
    {
#line 1901
    RemoveStatus();
    }
  }
  {
#line 1902
  FinitTerm();
  }
#line 1903
  if (! display) {
#line 1904
    return;
  }
  {
#line 1907
  if (mode == 6) {
#line 1907
    goto case_6;
  }
#line 1911
  if (mode == 0) {
#line 1911
    goto case_0;
  }
#line 1917
  if (mode == 1) {
#line 1917
    goto case_1;
  }
#line 1923
  if (mode == 2) {
#line 1923
    goto case_2;
  }
#line 1930
  if (mode == 3) {
#line 1930
    goto case_3;
  }
#line 1940
  if (mode == 4) {
#line 1940
    goto case_4;
  }
#line 1951
  if (mode == 5) {
#line 1951
    goto case_5;
  }
#line 1905
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1908
  sign = 1;
#line 1909
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1912
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1912
    if (SockName) {
      {
#line 1912
      AddStr((char *)"[detached from ");
#line 1912
      AddStr(SockName);
#line 1912
      AddStr((char *)"]\r\n");
      }
    } else {
      {
#line 1912
      AddStr((char *)"[detached]\r\n");
      }
    }
#line 1912
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1913
  sign = 1;
#line 1914
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1918
  sign = 20;
#line 1919
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1924
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1924
    if (SockName) {
      {
#line 1924
      AddStr((char *)"[remote detached from ");
#line 1924
      AddStr(SockName);
#line 1924
      AddStr((char *)"]\r\n");
      }
    } else {
      {
#line 1924
      AddStr((char *)"[remote detached]\r\n");
      }
    }
#line 1924
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1925
  sign = 1;
#line 1926
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1931
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1931
    if (SockName) {
      {
#line 1931
      AddStr((char *)"[power detached from ");
#line 1931
      AddStr(SockName);
#line 1931
      AddStr((char *)"]\r\n");
      }
    } else {
      {
#line 1931
      AddStr((char *)"[power detached]\r\n");
      }
    }
#line 1931
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1932
  if (PowDetachString) {
    {
#line 1933
    AddStr(PowDetachString);
#line 1934
    AddStr((char *)"\r\n");
    }
  }
#line 1936
  sign = 10;
#line 1937
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1941
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1941
    if (SockName) {
      {
#line 1941
      AddStr((char *)"[remote power detached from ");
#line 1941
      AddStr(SockName);
#line 1941
      AddStr((char *)"]\r\n");
      }
    } else {
      {
#line 1941
      AddStr((char *)"[remote power detached]\r\n");
      }
    }
#line 1941
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1942
  if (PowDetachString) {
    {
#line 1943
    AddStr(PowDetachString);
#line 1944
    AddStr((char *)"\r\n");
    }
  }
#line 1946
  sign = 10;
#line 1947
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1952
  ClearAll();
  }
#line 1953
  sign = 12;
#line 1955
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1959
  if (displays->d_next == (struct display *)0) {
#line 1960
    p = windows;
    {
#line 1960
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1960
      if (! p) {
#line 1960
        goto while_break___4;
      }
#line 1961
      if (p->w_slot != (slot_t )-1) {
#line 1961
        if (! (p->w_lflag & 2)) {
          {
#line 1962
          RemoveUtmp(p);
#line 1965
          p->w_slot = (slot_t )0;
          }
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1960
    p = p->w_next;
  }
#line 1969
  if (mode != 6) {
    {
#line 1970
    RestoreLoginSlot();
    }
  }
#line 1973
  if (displays->d_next == (struct display *)0) {
#line 1973
    if (console_window) {
      {
#line 1974
      __cil_tmp6 = TtyGrabConsole(console_window->w_ptyfd, 0, (char *)"detach");
      }
#line 1974
      if (__cil_tmp6) {
        {
#line 1975
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1975
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 1976
        KillWindow(console_window);
#line 1977
        display = displays;
        }
      }
    }
  }
#line 1980
  if (display->d_fore) {
    {
#line 1982
    ReleaseAutoWritelock(display, display->d_fore);
#line 1984
    (display->d_user)->u_detachwin = (display->d_fore)->w_number;
    }
#line 1985
    if (display->d_other) {
#line 1985
      tmp = (display->d_other)->w_number;
    } else {
#line 1985
      tmp = - 1;
    }
#line 1985
    (display->d_user)->u_detachotherwin = tmp;
  }
  {
#line 1988
  AutosaveLayout(display->d_layout);
#line 1989
  layout_last = display->d_layout;
#line 1990
  cv = display->d_cvlist;
  }
  {
#line 1990
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1990
    if (! cv) {
#line 1990
      goto while_break___6;
    }
    {
#line 1991
    p = (struct win *)((cv->c_layer)->l_bottom)->l_data;
#line 1992
    SetCanvasWindow(cv, (struct win *)0);
    }
#line 1993
    if (p) {
      {
#line 1994
      WindowChanged(p, 'u');
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1990
  cv = cv->c_next;
#line 1997
  pid = display->d_userpid;
  {
#line 1998
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1998
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1999
  FreeDisplay();
  }
#line 2001
  if (displays == (struct display *)0) {
    {
#line 2002
    __cil_tmp8 = chsock();
    }
  }
  {
#line 2009
  Kill(pid, sign);
  }
  {
#line 2010
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2010
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 2011
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2011
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 2012
  xsignal(1, SigHup);
  }
  return;
}
}
#line 2016 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static int IsSymbol(char *e , char *s ) 
{ 
  register int l ;
  size_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 2020
  __cil_tmp4 = strlen((char const   *)s);
#line 2020
  l = (int )__cil_tmp4;
#line 2021
  __cil_tmp5 = strncmp((char const   *)e, (char const   *)s, (unsigned long )l);
  }
#line 2021
  return (__cil_tmp5 == 0 && (int )*(e + l) == 61);
}
}
#line 2024 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void MakeNewEnv(void) 
{ 
  register char **op ;
  register char **np ;
  static char stybuf[768] ;
  void *__cil_tmp4 ;
  size_t __cil_tmp5 ;
  char *tmp ;
  char **__cil_tmp7 ;
  char **__cil_tmp8 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  char **__cil_tmp18 ;

  {
#line 2029
  op = environ;
  {
#line 2029
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2029
    if (! *op) {
#line 2029
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 2029
  op ++;
#line 2031
  if (NewEnv) {
    {
#line 2032
    free((void *)((char *)NewEnv));
    }
  }
  {
#line 2033
  __cil_tmp4 = malloc((unsigned long )((unsigned int )(((op - environ) + 7L) + 1L)) * sizeof(char **));
#line 2033
  np = (char **)__cil_tmp4;
#line 2033
  NewEnv = np;
  }
#line 2034
  if (! NewEnv) {
    {
#line 2035
    Panic(0, (char const   *)((char *)"%s"), (char *)strnomem);
    }
  }
  {
#line 2036
  __cil_tmp5 = strlen((char const   *)SockName);
  }
#line 2036
  if (__cil_tmp5 <= 763UL) {
#line 2036
    tmp = SockName;
  } else {
#line 2036
    tmp = (char *)"?";
  }
  {
#line 2036
  sprintf((char *)stybuf, (char const   *)((char *)"STY=%s"), tmp);
#line 2037
  __cil_tmp7 = np;
#line 2037
  np ++;
#line 2037
  *__cil_tmp7 = (char *)stybuf;
#line 2038
  __cil_tmp8 = np;
#line 2038
  np ++;
#line 2038
  *__cil_tmp8 = (char *)Term;
#line 2039
  np ++;
#line 2041
  np += 2;
#line 2046
  op = environ;
  }
  {
#line 2046
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2046
    if (! *op) {
#line 2046
      goto while_break___0;
    }
    {
#line 2047
    __cil_tmp17 = IsSymbol(*op, (char *)"COLUMNS");
    }
    {
#line 2047
    __cil_tmp16 = IsSymbol(*op, (char *)"LINES");
    }
    {
#line 2047
    __cil_tmp15 = IsSymbol(*op, (char *)"SHELL");
    }
    {
#line 2047
    __cil_tmp14 = IsSymbol(*op, (char *)"SCREENCAP");
    }
    {
#line 2047
    __cil_tmp13 = IsSymbol(*op, (char *)"WINDOW");
    }
    {
#line 2047
    __cil_tmp12 = IsSymbol(*op, (char *)"STY");
    }
    {
#line 2047
    __cil_tmp11 = IsSymbol(*op, (char *)"TERMCAP");
    }
    {
#line 2047
    __cil_tmp10 = IsSymbol(*op, (char *)"TERM");
    }
#line 2047
    if (! __cil_tmp10) {
#line 2047
      if (! __cil_tmp11) {
#line 2047
        if (! __cil_tmp12) {
#line 2047
          if (! __cil_tmp13) {
#line 2047
            if (! __cil_tmp14) {
#line 2047
              if (! __cil_tmp15) {
#line 2047
                if (! __cil_tmp16) {
#line 2047
                  if (! __cil_tmp17) {
#line 2051
                    __cil_tmp18 = np;
#line 2051
                    np ++;
#line 2051
                    *__cil_tmp18 = *op;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2046
  op ++;
#line 2053
  *np = (char *)0;
  return;
}
}
#line 2082 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void Msg(int err , char const   *fmt  , ...) 
{ 
  char buf[8192] ;
  char *p ;
  va_list ap ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *tty ;
  struct display *olddisplay ;
  size_t __cil_tmp14 ;

  {
  {
#line 2085
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2085
    p = (char *)buf;
#line 2085
    __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 2085
    fmt = DoNLS(fmt);
#line 2085
    __cil_tmp7 = vsnprintf(p, sizeof(buf) - 100UL, fmt, (__builtin_va_list *)ap);
#line 2085
    __builtin_va_end((__builtin_va_list *)ap);
    }
#line 2085
    if (err) {
      {
#line 2085
      __cil_tmp8 = strlen((char const   *)p);
      }
      {
#line 2085
      p += __cil_tmp8;
#line 2085
      __cil_tmp9 = p;
#line 2085
      p ++;
#line 2085
      *__cil_tmp9 = (char )':';
#line 2085
      __cil_tmp10 = p;
#line 2085
      p ++;
#line 2085
      *__cil_tmp10 = (char )' ';
#line 2085
      __cil_tmp11 = strerror(err);
#line 2085
      strncpy(p, (char const   *)__cil_tmp11, (unsigned long )((((char *)buf + sizeof(buf)) - p) - 1L));
#line 2085
      buf[sizeof(buf) - 1UL] = (char )0;
      }
    }
#line 2085
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2087
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2087
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2089
  if (display) {
#line 2089
    if (displays) {
      {
#line 2090
      MakeStatus((char *)buf);
      }
    } else {
#line 2089
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2091
  if (displays) {
#line 2092
    display = displays;
    {
#line 2092
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2092
      if (! display) {
#line 2092
        goto while_break___1;
      }
      {
#line 2093
      MakeStatus((char *)buf);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2092
    display = display->d_next;
  } else
#line 2095
  if (display) {
    {
#line 2099
    tty = (char *)display->d_usertty;
#line 2100
    olddisplay = display;
#line 2101
    display = (struct display *)0;
#line 2102
    SendErrorMsg(tty, (char *)buf);
#line 2103
    display = olddisplay;
    }
  } else {
    {
#line 2106
    printf((char const   *)((char *)"%s\r\n"), (char *)buf);
    }
  }
#line 2108
  if (queryflag >= 0) {
    {
#line 2109
    __cil_tmp14 = strlen((char const   *)((char *)buf));
#line 2109
    write(queryflag, (void const   *)((char *)buf), __cil_tmp14);
    }
  }
  return;
}
}
#line 2115 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void Panic(int err , char const   *fmt  , ...) 
{ 
  char buf[8192] ;
  char *p ;
  va_list ap ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *tty ;
  size_t __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 2118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2118
    p = (char *)buf;
#line 2118
    __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 2118
    fmt = DoNLS(fmt);
#line 2118
    __cil_tmp7 = vsnprintf(p, sizeof(buf) - 100UL, fmt, (__builtin_va_list *)ap);
#line 2118
    __builtin_va_end((__builtin_va_list *)ap);
    }
#line 2118
    if (err) {
      {
#line 2118
      __cil_tmp8 = strlen((char const   *)p);
      }
      {
#line 2118
      p += __cil_tmp8;
#line 2118
      __cil_tmp9 = p;
#line 2118
      p ++;
#line 2118
      *__cil_tmp9 = (char )':';
#line 2118
      __cil_tmp10 = p;
#line 2118
      p ++;
#line 2118
      *__cil_tmp10 = (char )' ';
#line 2118
      __cil_tmp11 = strerror(err);
#line 2118
      strncpy(p, (char const   *)__cil_tmp11, (unsigned long )((((char *)buf + sizeof(buf)) - p) - 1L));
#line 2118
      buf[sizeof(buf) - 1UL] = (char )0;
      }
    }
#line 2118
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2120
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2121
  if (displays == (struct display *)0) {
#line 2121
    if (display == (struct display *)0) {
      {
#line 2122
      printf((char const   *)((char *)"%s\r\n"), (char *)buf);
      }
#line 2123
      if (PanicPid) {
        {
#line 2124
        Kill(PanicPid, 1);
        }
      }
    } else {
#line 2121
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2126
  if (displays == (struct display *)0) {
    {
#line 2130
    tty = (char *)display->d_usertty;
#line 2131
    display = (struct display *)0;
#line 2132
    SendErrorMsg(tty, (char *)buf);
#line 2133
    sleep((unsigned int )2);
#line 2134
    _exit(1);
    }
  } else {
#line 2137
    display = displays;
    {
#line 2137
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2137
      if (! display) {
#line 2137
        goto while_break___1;
      }
#line 2138
      if (display->d_status) {
        {
#line 2139
        RemoveStatus();
        }
      }
      {
#line 2140
      FinitTerm();
#line 2141
      Flush(3);
#line 2143
      RestoreLoginSlot();
#line 2145
      SetTTY(display->d_userfd, & display->d_OldMode);
#line 2146
      fcntl(display->d_userfd, 4, 0);
#line 2147
      __cil_tmp13 = strlen((char const   *)((char *)buf));
#line 2147
      write(display->d_userfd, (void const   *)((char *)buf), __cil_tmp13);
#line 2148
      write(display->d_userfd, (void const   *)((char *)"\n"), (size_t )1);
#line 2149
      freetty();
      }
#line 2150
      if (display->d_userpid) {
        {
#line 2151
        Kill(display->d_userpid, 1);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2137
    display = display->d_next;
  }
#line 2154
  if (tty_oldmode >= 0) {
    {
#line 2157
    __cil_tmp14 = setuid((__uid_t )own_uid);
    }
#line 2157
    if (__cil_tmp14) {
      {
#line 2158
      xseteuid(own_uid);
      }
    }
    {
#line 2163
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2163
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2164
    chmod((char const   *)attach_tty, (__mode_t )tty_oldmode);
    }
  }
  {
#line 2167
  eexit(1);
  }
  return;
}
}
#line 2170 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void QueryMsg(int err , char const   *fmt  , ...) 
{ 
  char buf[8192] ;
  char *p ;
  va_list ap ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  size_t __cil_tmp12 ;

  {
#line 2174
  if (queryflag < 0) {
#line 2175
    return;
  }
  {
#line 2177
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2177
    p = (char *)buf;
#line 2177
    __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 2177
    fmt = DoNLS(fmt);
#line 2177
    __cil_tmp7 = vsnprintf(p, sizeof(buf) - 100UL, fmt, (__builtin_va_list *)ap);
#line 2177
    __builtin_va_end((__builtin_va_list *)ap);
    }
#line 2177
    if (err) {
      {
#line 2177
      __cil_tmp8 = strlen((char const   *)p);
      }
      {
#line 2177
      p += __cil_tmp8;
#line 2177
      __cil_tmp9 = p;
#line 2177
      p ++;
#line 2177
      *__cil_tmp9 = (char )':';
#line 2177
      __cil_tmp10 = p;
#line 2177
      p ++;
#line 2177
      *__cil_tmp10 = (char )' ';
#line 2177
      __cil_tmp11 = strerror(err);
#line 2177
      strncpy(p, (char const   *)__cil_tmp11, (unsigned long )((((char *)buf + sizeof(buf)) - p) - 1L));
#line 2177
      buf[sizeof(buf) - 1UL] = (char )0;
      }
    }
#line 2177
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2178
  __cil_tmp12 = strlen((char const   *)((char *)buf));
#line 2178
  write(queryflag, (void const   *)((char *)buf), __cil_tmp12);
  }
  return;
}
}
#line 2181 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void Dummy(int err , char const   *fmt  , ...) 
{ 


  {
  return;
}
}
#line 2200
static char winmsg_buf[768] ;
#line 2202
static int winmsg_rend[256] ;
#line 2203
static int winmsg_rendpos[256] ;
#line 2204
static int winmsg_numrend ;
#line 2206 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static char *pad_expand(char *buf , char *p , int numpad , int padlen ) 
{ 
  char *pn ;
  char *pn2 ;
  int i ;
  int r ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  int tmp ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 2211
  padlen = (int )((long )padlen - (p - buf));
#line 2212
  if (padlen < 0) {
#line 2213
    padlen = 0;
  }
#line 2214
  pn = p + padlen;
#line 2214
  pn2 = pn;
#line 2215
  r = winmsg_numrend;
  {
#line 2216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2216
    if (! (p >= buf)) {
#line 2216
      goto while_break;
    }
#line 2217
    if (r) {
#line 2217
      if ((int )*p != 127) {
#line 2217
        if (p - buf == (long )winmsg_rendpos[r - 1]) {
#line 2218
          r --;
#line 2218
          winmsg_rendpos[r] = (int )(pn - buf);
#line 2219
          goto while_continue;
        }
      }
    }
#line 2221
    __cil_tmp9 = pn;
#line 2221
    pn --;
#line 2221
    *__cil_tmp9 = *p;
#line 2222
    __cil_tmp10 = p;
#line 2222
    p --;
#line 2222
    if ((int )*__cil_tmp10 == 127) {
#line 2223
      *(pn + 1) = (char )' ';
#line 2224
      if (numpad > 0) {
#line 2224
        tmp = ((padlen + numpad) - 1) / numpad;
      } else {
#line 2224
        tmp = 0;
      }
#line 2224
      i = tmp;
#line 2225
      padlen -= i;
      {
#line 2227
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2227
        if (! (__cil_tmp12 > 0)) {
#line 2227
          goto while_break___0;
        }
#line 2228
        __cil_tmp13 = pn;
#line 2228
        pn --;
#line 2228
        *__cil_tmp13 = (char )' ';
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2230
      __cil_tmp14 = numpad;
#line 2230
      numpad --;
#line 2231
      if (r) {
#line 2231
        if ((p - buf) + 1L == (long )winmsg_rendpos[r - 1]) {
#line 2232
          r --;
#line 2232
          winmsg_rendpos[r] = (int )((pn - buf) + 1L);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2235
  return (pn2);
}
}
#line 2251
struct backtick *backticks ;
#line 2253 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void backtick_filter(struct backtick *bt ) 
{ 
  char *p ;
  char *q ;
  int c ;
  char *__cil_tmp6 ;

  {
#line 2258
  q = (char *)bt->result;
#line 2258
  p = q;
  {
#line 2258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2258
    if (! (c != 0)) {
#line 2258
      goto while_break;
    }
#line 2259
    if (c == 9) {
#line 2260
      c = ' ';
    }
#line 2261
    if (c >= 32) {
#line 2262
      __cil_tmp6 = q;
#line 2262
      q ++;
#line 2262
      *__cil_tmp6 = (char )c;
    } else
#line 2261
    if (c == 5) {
#line 2262
      __cil_tmp6 = q;
#line 2262
      q ++;
#line 2262
      *__cil_tmp6 = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2264
  *q = (char )0;
  return;
}
}
#line 2267 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void backtick_fn(struct event *ev , char *data ) 
{ 
  struct backtick *bt ;
  int i ;
  int j ;
  int k ;
  int l ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp10 ;

  {
#line 2272
  bt = (struct backtick *)data;
  {
#line 2273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2273
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2274
  i = bt->bufi;
#line 2275
  __cil_tmp8 = read(ev->fd, (void *)(bt->buf + i), (size_t )(768 - i));
#line 2275
  l = (int )__cil_tmp8;
  }
#line 2277
  if (l <= 0) {
    {
#line 2278
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2278
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2279
    evdeq(ev);
#line 2280
    close(ev->fd);
#line 2281
    ev->fd = - 1;
    }
#line 2282
    return;
  }
  {
#line 2285
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2285
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2286
  i += l;
#line 2287
  j = 0;
  {
#line 2287
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2287
    if (! (j < l)) {
#line 2287
      goto while_break___2;
    }
#line 2288
    if ((int )*(bt->buf + ((i - j) - 1)) == 10) {
#line 2289
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2287
  j ++;
#line 2291
  if (j < l) {
#line 2292
    k = (i - j) - 2;
    {
#line 2292
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2292
      if (! (k >= 0)) {
#line 2292
        goto while_break___3;
      }
#line 2293
      if ((int )*(bt->buf + k) == 10) {
#line 2294
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2292
    __cil_tmp10 = k;
#line 2292
    k --;
#line 2295
    k ++;
#line 2296
    bcopy((void const   *)(bt->buf + k), (void *)((char *)bt->result), (size_t )((i - j) - k));
#line 2297
    bt->result[((i - j) - k) - 1] = (char )0;
#line 2298
    backtick_filter(bt);
#line 2299
    WindowChanged((struct win *)0, '`');
    }
  }
#line 2302
  if (j == l) {
#line 2302
    if (i == 768) {
#line 2303
      j = 384;
#line 2304
      l = j + 1;
    }
  }
#line 2307
  if (j < l) {
#line 2308
    if (j) {
      {
#line 2309
      bcopy((void const   *)((bt->buf + i) - j), (void *)bt->buf, (size_t )j);
      }
    }
#line 2310
    i = j;
  }
#line 2312
  bt->bufi = i;
  return;
}
}
#line 2315 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void setbacktick(int num , int lifespan , int tick , char **cmdv ) 
{ 
  struct backtick **btp ;
  struct backtick *bt ;
  char **v ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 2320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2320
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2321
  btp = & backticks;
  {
#line 2321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2321
    if (! (bt != (struct backtick *)0)) {
#line 2321
      goto while_break___0;
    }
#line 2322
    if (bt->num == num) {
#line 2323
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2321
  btp = & bt->next;
#line 2325
  if (! bt) {
#line 2325
    if (! cmdv) {
#line 2326
      return;
    }
  }
#line 2328
  if (bt) {
#line 2329
    v = bt->cmdv;
    {
#line 2329
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2329
      if (! *v) {
#line 2329
        goto while_break___1;
      }
      {
#line 2330
      free((void *)*v);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2329
    v ++;
#line 2331
    free((void *)bt->cmdv);
    }
#line 2332
    if (bt->buf) {
      {
#line 2333
      free((void *)bt->buf);
      }
    }
#line 2334
    if (bt->ev.fd >= 0) {
      {
#line 2335
      close(bt->ev.fd);
      }
    }
    {
#line 2336
    evdeq(& bt->ev);
    }
  }
#line 2339
  if (bt) {
#line 2339
    if (! cmdv) {
      {
#line 2340
      *btp = bt->next;
#line 2341
      free((void *)bt);
      }
#line 2342
      return;
    }
  }
#line 2345
  if (! bt) {
    {
#line 2346
    __cil_tmp9 = malloc(sizeof(*bt));
#line 2346
    bt = (struct backtick *)__cil_tmp9;
    }
#line 2347
    if (! bt) {
      {
#line 2348
      Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
      }
#line 2349
      return;
    }
    {
#line 2351
    bzero((void *)bt, sizeof(*bt));
#line 2352
    bt->next = (struct backtick *)0;
#line 2353
    *btp = bt;
    }
  }
#line 2356
  bt->num = num;
#line 2357
  bt->tick = tick;
#line 2358
  bt->lifespan = lifespan;
#line 2359
  bt->bestbefore = (time_t )0;
#line 2360
  bt->result[0] = (char )0;
#line 2361
  bt->buf = (char *)0;
#line 2362
  bt->bufi = 0;
#line 2363
  bt->cmdv = cmdv;
#line 2364
  bt->ev.fd = - 1;
#line 2366
  if (bt->tick == 0) {
#line 2366
    if (bt->lifespan == 0) {
      {
#line 2367
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2367
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2368
      __cil_tmp10 = malloc((unsigned long )768);
#line 2368
      bt->buf = (char *)__cil_tmp10;
      }
#line 2369
      if (bt->buf == (char *)0) {
        {
#line 2370
        Msg(0, (char const   *)((char *)"%s"), (char *)strnomem);
#line 2371
        setbacktick(num, 0, 0, (char **)0);
        }
#line 2372
        return;
      }
      {
#line 2375
      bt->ev.type = 1;
#line 2376
      bt->ev.fd = readpipe(bt->cmdv);
#line 2377
      bt->ev.handler = backtick_fn;
#line 2378
      bt->ev.data = (char *)bt;
      }
#line 2379
      if (bt->ev.fd >= 0) {
        {
#line 2380
        evenq(& bt->ev);
        }
      }
    }
  }
  return;
}
}
#line 2384 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static char *runbacktick(struct backtick *bt , int *tickp , time_t now ) 
{ 
  int f ;
  int i ;
  int l ;
  int j ;
  time_t now2 ;
  int __cil_tmp12 ;
  time_t __cil_tmp13 ;

  {
  {
#line 2389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2389
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2390
  if (bt->tick) {
#line 2390
    if (! *tickp) {
#line 2391
      *tickp = bt->tick;
    } else
#line 2390
    if (bt->tick < *tickp) {
#line 2391
      *tickp = bt->tick;
    }
  }
#line 2392
  if (bt->lifespan == 0) {
#line 2392
    if (bt->tick == 0) {
      _L: /* CIL Label */ 
      {
#line 2393
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2393
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2394
      return ((char *)bt->result);
    } else {
#line 2392
      goto _L___1107;
    }
  } else
  _L___1107: /* CIL Label */ 
#line 2392
  if (now < bt->bestbefore) {
#line 2392
    goto _L;
  }
  {
#line 2397
  f = readpipe(bt->cmdv);
  }
#line 2398
  if (f == -1) {
#line 2399
    return ((char *)bt->result);
  }
#line 2400
  i = 0;
  {
#line 2401
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2401
    if (! (l > 0)) {
#line 2401
      goto while_break___1;
    }
    {
#line 2402
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2402
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2403
    i += l;
#line 2404
    j = 1;
    {
#line 2404
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2404
      if (! (j < l)) {
#line 2404
        goto while_break___3;
      }
#line 2405
      if ((int )bt->result[(i - j) - 1] == 10) {
#line 2406
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2404
    j ++;
#line 2408
    if (j == l) {
#line 2408
      if ((unsigned long )i == sizeof(bt->result)) {
#line 2409
        j = (int )(sizeof(bt->result) / 2UL);
#line 2410
        l = j + 1;
      }
    }
#line 2413
    if (j < l) {
      {
#line 2414
      bcopy((void const   *)(((char *)bt->result + i) - j), (void *)((char *)bt->result),
            (size_t )j);
#line 2415
      i = j;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2419
  close(f);
#line 2420
  bt->result[sizeof(bt->result) - 1UL] = (char )'\n';
  }
#line 2421
  if (i) {
#line 2421
    if ((int )bt->result[i - 1] == 10) {
#line 2422
      __cil_tmp12 = i;
#line 2422
      i --;
    }
  }
  {
#line 2423
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2423
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 2424
  bt->result[i] = (char )0;
#line 2425
  backtick_filter(bt);
#line 2426
  __cil_tmp13 = time(& now2);
#line 2427
  bt->bestbefore = now2 + (long )bt->lifespan;
  }
#line 2428
  return ((char *)bt->result);
}
}
#line 2431 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
int AddWinMsgRend(char const   *str , int r ) 
{ 


  {
#line 2433
  if (winmsg_numrend >= 256) {
#line 2434
    return (- 1);
  } else
#line 2433
  if (str < (char const   *)((char *)winmsg_buf)) {
#line 2434
    return (- 1);
  } else
#line 2433
  if (str >= (char const   *)((char *)winmsg_buf + 768)) {
#line 2434
    return (- 1);
  }
#line 2436
  winmsg_rend[winmsg_numrend] = r;
#line 2437
  winmsg_rendpos[winmsg_numrend] = (int )(str - (char *)winmsg_buf);
#line 2438
  winmsg_numrend ++;
#line 2439
  return (0);
}
}
#line 2442 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
char *MakeWinMsgEv(char *str , struct win *win , int esc , int padlen , struct event *ev ,
                   int rec ) 
{ 
  static int tick ;
  char *s ;
  register char *p ;
  register int ctrl ;
  struct timeval now ;
  struct tm *tm ;
  int l ;
  int i ;
  int r ;
  int num ;
  int zeroflg ;
  int longflg ;
  int minusflg ;
  int plusflg ;
  int qmflag ;
  int omflag ;
  int qmnumrend ;
  char *qmpos ;
  int numpad ;
  int lastpad ;
  int truncpos ;
  int truncper ;
  int trunclong ;
  struct backtick *bt ;
  char *__cil_tmp31 ;
  char *__cil_tmp35 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  time_t nowsec ;
  char *tmp ;
  char *tmp___1110 ;
  char *tmp___1111 ;
  char *tmp___1112 ;
  char *tmp___1113 ;
  char *tmp___1114 ;
  size_t __cil_tmp47 ;
  size_t __cil_tmp48 ;
  char *tmp___1115 ;
  size_t __cil_tmp50 ;
  size_t __cil_tmp51 ;
  char *__cil_tmp53 ;
  size_t __cil_tmp54 ;
  size_t __cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char savebuf[768] ;
  int oldtick ;
  int oldnumrend ;
  char *__cil_tmp61 ;
  char *tmp___1116 ;
  size_t __cil_tmp63 ;
  int __cil_tmp64 ;
  size_t __cil_tmp65 ;
  struct win *oldfore ;
  char *ss ;
  int tmp___1117 ;
  int tmp___1118 ;
  int tmp___1119 ;
  int tmp___1120 ;
  int tmp___1121 ;
  char *__cil_tmp73 ;
  size_t __cil_tmp74 ;
  size_t __cil_tmp75 ;
  size_t __cil_tmp76 ;
  size_t __cil_tmp77 ;
  size_t __cil_tmp78 ;
  char rbuf[128] ;
  char *__cil_tmp84 ;
  size_t __cil_tmp85 ;
  size_t __cil_tmp86 ;
  char *session_name ;
  char *__cil_tmp88 ;
  size_t __cil_tmp89 ;
  size_t __cil_tmp90 ;
  __pid_t __cil_tmp91 ;
  int tmp___1122 ;
  size_t __cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  struct canvas *cv ;
  char *__cil_tmp97 ;
  int tmp___1123 ;
  char *__cil_tmp99 ;
  int tmp___1124 ;
  int tmp___1125 ;
  int left ;
  int trunc ;
  int __cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp110 ;
  char *tmp___1126 ;
  size_t __cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;

  {
#line 2445
  s = str;
#line 2446
  p = (char *)winmsg_buf;
#line 2456
  qmflag = 0;
#line 2456
  omflag = 0;
#line 2456
  qmnumrend = 0;
#line 2457
  qmpos = (char *)0;
#line 2458
  numpad = 0;
#line 2459
  lastpad = 0;
#line 2460
  truncpos = - 1;
#line 2461
  truncper = 0;
#line 2462
  trunclong = 0;
#line 2463
  bt = (struct backtick *)((void *)0);
#line 2465
  if (winmsg_numrend >= 0) {
#line 2466
    winmsg_numrend = 0;
  } else {
#line 2468
    winmsg_numrend = - winmsg_numrend;
  }
  {
#line 2470
  tick = 0;
#line 2471
  tm = (struct tm *)0;
#line 2472
  ctrl = 0;
#line 2473
  gettimeofday(& now, (struct timezone *)((void *)0));
  }
  {
#line 2474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2474
    if (! ((int )*s && l > 0)) {
#line 2474
      goto while_break;
    }
#line 2475
    *p = *s;
#line 2476
    if (ctrl) {
#line 2477
      ctrl = 0;
#line 2478
      if ((int )*s != 94) {
#line 2478
        if ((int )*s >= 64) {
#line 2479
          *p &= 31;
        }
      }
#line 2480
      goto while_continue;
    }
#line 2483
    if ((int )*s != esc) {
#line 2484
      if (esc == 37) {
        {
#line 2491
        if ((int )*s == '^') {
#line 2491
          goto case_94;
        }
#line 2496
        goto switch_default;
        case_94: /* CIL Label */ 
#line 2492
        ctrl = 1;
#line 2493
        __cil_tmp31 = p;
#line 2493
        p --;
#line 2493
        *__cil_tmp31 = (char )'^';
#line 2494
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2497
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 2500
      goto while_continue;
    }
#line 2503
    s ++;
#line 2503
    if ((int )*s == esc) {
#line 2504
      goto while_continue;
    }
#line 2506
    plusflg = (int )*s == 43;
#line 2506
    if (plusflg != 0) {
#line 2507
      s ++;
    }
#line 2509
    minusflg = (int )*s == 45;
#line 2509
    if (minusflg != 0) {
#line 2510
      s ++;
    }
#line 2512
    zeroflg = (int )*s == 48;
#line 2512
    if (zeroflg != 0) {
#line 2513
      s ++;
    }
#line 2515
    num = 0;
    {
#line 2516
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2516
      if (! ((int )*s >= 48 && (int )*s <= 57)) {
#line 2516
        goto while_break___0;
      }
#line 2517
      __cil_tmp35 = s;
#line 2517
      s ++;
#line 2517
      num = num * 10 + ((int )*__cil_tmp35 - 48);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2519
    longflg = (int )*s == 76;
#line 2519
    if (longflg != 0) {
#line 2520
      s ++;
    }
    {
#line 2523
    if ((int )*s == '?') {
#line 2523
      goto case_63;
    }
#line 2539
    if ((int )*s == ':') {
#line 2539
      goto case_58;
    }
#line 2557
    if ((int )*s == 'C') {
#line 2557
      goto case_67;
    }
#line 2557
    if ((int )*s == 'c') {
#line 2557
      goto case_67;
    }
#line 2557
    if ((int )*s == 's') {
#line 2557
      goto case_67;
    }
#line 2557
    if ((int )*s == 'A') {
#line 2557
      goto case_67;
    }
#line 2557
    if ((int )*s == 'a') {
#line 2557
      goto case_67;
    }
#line 2557
    if ((int )*s == 'Y') {
#line 2557
      goto case_67;
    }
#line 2557
    if ((int )*s == 'y') {
#line 2557
      goto case_67;
    }
#line 2557
    if ((int )*s == 'M') {
#line 2557
      goto case_67;
    }
#line 2557
    if ((int )*s == 'm') {
#line 2557
      goto case_67;
    }
#line 2557
    if ((int )*s == 'D') {
#line 2557
      goto case_67;
    }
#line 2557
    if ((int )*s == 'd') {
#line 2557
      goto case_67;
    }
#line 2571
    if ((int )*s == 'd') {
#line 2571
      goto case_100___0;
    }
#line 2575
    if ((int )*s == 'D') {
#line 2575
      goto case_68___0;
    }
#line 2583
    if ((int )*s == 'm') {
#line 2583
      goto case_109___0;
    }
#line 2587
    if ((int )*s == 'M') {
#line 2587
      goto case_77___0;
    }
#line 2595
    if ((int )*s == 'y') {
#line 2595
      goto case_121___0;
    }
#line 2599
    if ((int )*s == 'Y') {
#line 2599
      goto case_89___0;
    }
#line 2603
    if ((int )*s == 'a') {
#line 2603
      goto case_97___0;
    }
#line 2607
    if ((int )*s == 'A') {
#line 2607
      goto case_65___0;
    }
#line 2611
    if ((int )*s == 's') {
#line 2611
      goto case_115___0;
    }
#line 2616
    if ((int )*s == 'c') {
#line 2616
      goto case_99___0;
    }
#line 2622
    if ((int )*s == 'C') {
#line 2622
      goto case_67___0;
    }
#line 2635
    if ((int )*s == 'x') {
#line 2635
      goto case_120;
    }
#line 2635
    if ((int )*s == 'X') {
#line 2635
      goto case_120;
    }
#line 2649
    if ((int )*s == 'l') {
#line 2649
      goto case_108;
    }
#line 2670
    if ((int )*s == 'h') {
#line 2670
      goto case_104;
    }
#line 2670
    if ((int )*s == '`') {
#line 2670
      goto case_104;
    }
#line 2709
    if ((int )*s == 'W') {
#line 2709
      goto case_87;
    }
#line 2709
    if ((int )*s == 'w') {
#line 2709
      goto case_87;
    }
#line 2728
    if ((int )*s == 'u') {
#line 2728
      goto case_117;
    }
#line 2737
    if ((int )*s == 'f') {
#line 2737
      goto case_102;
    }
#line 2746
    if ((int )*s == 't') {
#line 2746
      goto case_116;
    }
#line 2756
    if ((int )*s == '{') {
#line 2756
      goto case_123;
    }
#line 2785
    if ((int )*s == 'H') {
#line 2785
      goto case_72;
    }
#line 2795
    if ((int )*s == 'S') {
#line 2795
      goto case_83;
    }
#line 2809
    if ((int )*s == 'p') {
#line 2809
      goto case_112;
    }
#line 2816
    if ((int )*s == 'F') {
#line 2816
      goto case_70;
    }
#line 2825
    if ((int )*s == 'P') {
#line 2825
      goto case_80;
    }
#line 2838
    if ((int )*s == 'E') {
#line 2838
      goto case_69;
    }
#line 2844
    if ((int )*s == '>') {
#line 2844
      goto case_62;
    }
#line 2852
    if ((int )*s == '<') {
#line 2852
      goto case_60;
    }
#line 2852
    if ((int )*s == '=') {
#line 2852
      goto case_60;
    }
#line 2965
    if ((int )*s == 'n') {
#line 2965
      goto case_110;
    }
#line 2969
    goto switch_default___1;
    case_63: /* CIL Label */ 
#line 2524
    __cil_tmp37 = p;
#line 2524
    p --;
#line 2525
    if (qmpos) {
#line 2526
      if (! qmflag) {
#line 2526
        if (! omflag) {
          _L: /* CIL Label */ 
#line 2527
          p = qmpos;
#line 2528
          if (qmnumrend < winmsg_numrend) {
#line 2529
            winmsg_numrend = qmnumrend;
          }
        } else {
#line 2526
          goto _L___1108;
        }
      } else
      _L___1108: /* CIL Label */ 
#line 2526
      if (omflag == 1) {
#line 2526
        goto _L;
      }
#line 2531
      qmpos = (char *)0;
#line 2532
      goto switch_break___0;
    }
#line 2534
    qmpos = p;
#line 2535
    qmnumrend = winmsg_numrend;
#line 2536
    omflag = 0;
#line 2536
    qmflag = omflag;
#line 2537
    goto switch_break___0;
    case_58: /* CIL Label */ 
#line 2540
    __cil_tmp38 = p;
#line 2540
    p --;
#line 2541
    if (! qmpos) {
#line 2542
      goto switch_break___0;
    }
#line 2543
    if (qmflag) {
#line 2543
      if (omflag != 1) {
#line 2544
        omflag = 1;
#line 2545
        qmpos = p;
#line 2546
        qmnumrend = winmsg_numrend;
      } else {
#line 2543
        goto _L___1109;
      }
    } else {
      _L___1109: /* CIL Label */ 
#line 2549
      p = qmpos;
#line 2550
      if (qmnumrend < winmsg_numrend) {
#line 2551
        winmsg_numrend = qmnumrend;
      }
#line 2552
      omflag = - 1;
    }
#line 2554
    goto switch_break___0;
    case_67: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 2559
    if (l < 4) {
#line 2560
      goto switch_break___0;
    }
#line 2561
    if (tm == (struct tm *)0) {
      {
#line 2562
      nowsec = now.tv_sec;
#line 2563
      tm = localtime(& nowsec);
      }
    }
#line 2566
    qmflag = 1;
#line 2567
    if (! tick) {
#line 2568
      tick = 3600;
    } else
#line 2567
    if (tick > 3600) {
#line 2568
      tick = 3600;
    }
    {
#line 2571
    if ((int )*s == 'd') {
#line 2571
      goto case_100___0;
    }
#line 2575
    if ((int )*s == 'D') {
#line 2575
      goto case_68___0;
    }
#line 2583
    if ((int )*s == 'm') {
#line 2583
      goto case_109___0;
    }
#line 2587
    if ((int )*s == 'M') {
#line 2587
      goto case_77___0;
    }
#line 2595
    if ((int )*s == 'y') {
#line 2595
      goto case_121___0;
    }
#line 2599
    if ((int )*s == 'Y') {
#line 2599
      goto case_89___0;
    }
#line 2603
    if ((int )*s == 'a') {
#line 2603
      goto case_97___0;
    }
#line 2607
    if ((int )*s == 'A') {
#line 2607
      goto case_65___0;
    }
#line 2611
    if ((int )*s == 's') {
#line 2611
      goto case_115___0;
    }
#line 2616
    if ((int )*s == 'c') {
#line 2616
      goto case_99___0;
    }
#line 2622
    if ((int )*s == 'C') {
#line 2622
      goto case_67___0;
    }
#line 2628
    goto switch_default___0;
    case_100___0: /* CIL Label */ 
    {
#line 2572
    sprintf(p, (char const   *)((char *)"%02d"), tm->tm_mday % 100);
    }
#line 2573
    goto switch_break___1;
    case_68___0: /* CIL Label */ 
#line 2577
    if (longflg) {
#line 2577
      tmp = (char *)"%A";
    } else {
#line 2577
      tmp = (char *)"%a";
    }
    {
#line 2577
    strftime(p, (size_t )l, (char const   *)tmp, tm);
    }
#line 2581
    goto switch_break___1;
    case_109___0: /* CIL Label */ 
    {
#line 2584
    sprintf(p, (char const   *)((char *)"%02d"), tm->tm_mon + 1);
    }
#line 2585
    goto switch_break___1;
    case_77___0: /* CIL Label */ 
#line 2589
    if (longflg) {
#line 2589
      tmp___1110 = (char *)"%B";
    } else {
#line 2589
      tmp___1110 = (char *)"%b";
    }
    {
#line 2589
    strftime(p, (size_t )l, (char const   *)tmp___1110, tm);
    }
#line 2593
    goto switch_break___1;
    case_121___0: /* CIL Label */ 
    {
#line 2596
    sprintf(p, (char const   *)((char *)"%02d"), tm->tm_year % 100);
    }
#line 2597
    goto switch_break___1;
    case_89___0: /* CIL Label */ 
    {
#line 2600
    sprintf(p, (char const   *)((char *)"%04d"), tm->tm_year + 1900);
    }
#line 2601
    goto switch_break___1;
    case_97___0: /* CIL Label */ 
#line 2604
    if (tm->tm_hour >= 12) {
#line 2604
      tmp___1111 = (char *)"pm";
    } else {
#line 2604
      tmp___1111 = (char *)"am";
    }
    {
#line 2604
    sprintf(p, (char const   *)tmp___1111);
    }
#line 2605
    goto switch_break___1;
    case_65___0: /* CIL Label */ 
#line 2608
    if (tm->tm_hour >= 12) {
#line 2608
      tmp___1112 = (char *)"PM";
    } else {
#line 2608
      tmp___1112 = (char *)"AM";
    }
    {
#line 2608
    sprintf(p, (char const   *)tmp___1112);
    }
#line 2609
    goto switch_break___1;
    case_115___0: /* CIL Label */ 
    {
#line 2612
    sprintf(p, (char const   *)((char *)"%02d"), tm->tm_sec);
    }
#line 2613
    tick = 1;
#line 2614
    goto switch_break___1;
    case_99___0: /* CIL Label */ 
#line 2617
    if (zeroflg) {
#line 2617
      tmp___1113 = (char *)"%02d:%02d";
    } else {
#line 2617
      tmp___1113 = (char *)"%2d:%02d";
    }
    {
#line 2617
    sprintf(p, (char const   *)tmp___1113, tm->tm_hour, tm->tm_min);
    }
#line 2618
    if (! tick) {
#line 2619
      tick = 60;
    } else
#line 2618
    if (tick > 60) {
#line 2619
      tick = 60;
    }
#line 2620
    goto switch_break___1;
    case_67___0: /* CIL Label */ 
#line 2623
    if (zeroflg) {
#line 2623
      tmp___1114 = (char *)"%02d:%02d";
    } else {
#line 2623
      tmp___1114 = (char *)"%2d:%02d";
    }
    {
#line 2623
    sprintf(p, (char const   *)tmp___1114, (tm->tm_hour + 11) % 12 + 1, tm->tm_min);
    }
#line 2624
    if (! tick) {
#line 2625
      tick = 60;
    } else
#line 2624
    if (tick > 60) {
#line 2625
      tick = 60;
    }
#line 2626
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 2629
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 2632
    __cil_tmp47 = strlen((char const   *)p);
    }
#line 2632
    p += __cil_tmp47 - 1UL;
#line 2633
    goto switch_break___0;
    case_120: /* CIL Label */ 
    case_88: /* CIL Label */ 
#line 2636
    *p = (char )0;
#line 2637
    i = 0;
    {
#line 2637
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2637
      if (! (win && win->w_cmdargs[i])) {
#line 2637
        goto while_break___1;
      }
      {
#line 2638
      __cil_tmp48 = strlen((char const   *)win->w_cmdargs[i]);
      }
#line 2638
      if ((unsigned long )l < __cil_tmp48 + 1UL) {
#line 2639
        goto while_break___1;
      }
#line 2640
      if (i) {
#line 2640
        tmp___1115 = (char *)" %s";
      } else {
#line 2640
        tmp___1115 = (char *)"%s";
      }
      {
#line 2640
      sprintf(p, (char const   *)tmp___1115, win->w_cmdargs[i]);
#line 2641
      __cil_tmp50 = strlen((char const   *)p);
      }
      {
#line 2641
      l -= __cil_tmp50;
#line 2642
      __cil_tmp51 = strlen((char const   *)p);
      }
#line 2642
      p += __cil_tmp51;
#line 2643
      if (i == 0) {
#line 2643
        if ((int )*s == 88) {
#line 2644
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2637
    i ++;
#line 2646
    __cil_tmp53 = p;
#line 2646
    p --;
#line 2647
    goto switch_break___0;
    case_108: /* CIL Label */ 
#line 2651
    *p = (char )0;
#line 2652
    if (l > 20) {
      {
#line 2653
      AddLoadav(p);
      }
    }
#line 2654
    if (*p) {
      {
#line 2655
      qmflag = 1;
#line 2656
      __cil_tmp54 = strlen((char const   *)p);
      }
#line 2656
      p += __cil_tmp54 - 1UL;
    } else {
#line 2659
      *p = (char )'?';
    }
#line 2661
    if (! tick) {
#line 2662
      tick = 60;
    } else
#line 2661
    if (tick > 60) {
#line 2662
      tick = 60;
    }
    {
#line 2666
    __cil_tmp55 = strlen((char const   *)p);
    }
#line 2666
    p += __cil_tmp55 - 1UL;
#line 2667
    goto switch_break___0;
    case_104: /* CIL Label */ 
    case_96: /* CIL Label */ 
#line 2671
    if (rec >= 10) {
#line 2672
      __cil_tmp56 = p;
#line 2672
      p --;
#line 2673
      goto switch_break___0;
    } else
#line 2671
    if ((int )*s == 104) {
#line 2671
      if (win == (struct win *)0) {
#line 2672
        __cil_tmp56 = p;
#line 2672
        p --;
#line 2673
        goto switch_break___0;
      } else
#line 2671
      if (win->w_hstatus == (char *)0) {
#line 2672
        __cil_tmp56 = p;
#line 2672
        p --;
#line 2673
        goto switch_break___0;
      } else
#line 2671
      if ((int )*(win->w_hstatus) == 0) {
#line 2672
        __cil_tmp56 = p;
#line 2672
        p --;
#line 2673
        goto switch_break___0;
      }
    }
#line 2675
    if ((int )*s == 96) {
#line 2676
      bt = backticks;
      {
#line 2676
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2676
        if (! bt) {
#line 2676
          goto while_break___2;
        }
#line 2677
        if (bt->num == num) {
#line 2678
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2676
      bt = bt->next;
#line 2679
      if (bt == (struct backtick *)0) {
#line 2680
        __cil_tmp57 = p;
#line 2680
        p --;
#line 2681
        goto switch_break___0;
      }
    }
    {
#line 2686
    oldtick = tick;
#line 2687
    oldnumrend = winmsg_numrend;
#line 2689
    *p = (char )0;
#line 2690
    strcpy((char *)savebuf, (char const   *)((char *)winmsg_buf));
#line 2691
    winmsg_numrend = - winmsg_numrend;
    }
#line 2692
    if ((int )*s == 104) {
#line 2692
      tmp___1116 = win->w_hstatus;
    } else {
      {
#line 2692
      __cil_tmp61 = runbacktick(bt, & oldtick, now.tv_sec);
#line 2692
      tmp___1116 = __cil_tmp61;
      }
    }
    {
#line 2692
    MakeWinMsgEv(tmp___1116, win, '\005', 0, (struct event *)0, rec + 1);
    }
    {
#line 2694
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2694
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2695
    if (! tick) {
#line 2696
      tick = oldtick;
    } else
#line 2695
    if (oldtick < tick) {
#line 2696
      tick = oldtick;
    }
    {
#line 2697
    __cil_tmp63 = strlen((char const   *)((char *)winmsg_buf));
    }
#line 2697
    if ((int )__cil_tmp63 < l) {
      {
#line 2698
      strcat((char *)savebuf, (char const   *)((char *)winmsg_buf));
      }
    }
    {
#line 2699
    strcpy((char *)winmsg_buf, (char const   *)((char *)savebuf));
    }
    {
#line 2700
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2700
      if (! (oldnumrend < winmsg_numrend)) {
#line 2700
        goto while_break___4;
      }
#line 2701
      __cil_tmp64 = oldnumrend;
#line 2701
      oldnumrend ++;
#line 2701
      winmsg_rendpos[__cil_tmp64] += p - (char *)winmsg_buf;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2702
    if (*p) {
#line 2703
      qmflag = 1;
    }
    {
#line 2704
    __cil_tmp65 = strlen((char const   *)p);
    }
#line 2704
    p += __cil_tmp65 - 1UL;
#line 2706
    goto switch_break___0;
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 2711
    oldfore = (struct win *)0;
#line 2713
    if (display) {
#line 2714
      oldfore = display->d_fore;
#line 2715
      display->d_fore = win;
    }
#line 2717
    if (minusflg) {
#line 2717
      tmp___1120 = 8;
    } else {
#line 2717
      tmp___1120 = 0;
    }
#line 2717
    if (plusflg) {
#line 2717
      tmp___1119 = 4;
    } else {
#line 2717
      tmp___1119 = 0;
    }
#line 2717
    if (longflg) {
#line 2717
      tmp___1118 = 0;
    } else {
#line 2717
      tmp___1118 = 2;
    }
#line 2717
    if ((int )*s == 119) {
#line 2717
      tmp___1117 = 0;
    } else {
#line 2717
      tmp___1117 = 1;
    }
#line 2717
    if (win) {
#line 2717
      tmp___1121 = win->w_number;
    } else {
#line 2717
      tmp___1121 = - 1;
    }
    {
#line 2717
    __cil_tmp73 = AddWindows(p, l - 1, ((tmp___1117 | tmp___1118) | tmp___1119) | tmp___1120,
                             tmp___1121);
#line 2717
    ss = __cil_tmp73;
    }
#line 2720
    if (display) {
#line 2721
      display->d_fore = oldfore;
    }
#line 2723
    if (*p) {
#line 2724
      qmflag = 1;
    }
    {
#line 2725
    __cil_tmp74 = strlen((char const   *)p);
    }
#line 2725
    p += __cil_tmp74 - 1UL;
#line 2726
    goto switch_break___0;
    case_117: /* CIL Label */ 
#line 2729
    *p = (char )0;
#line 2730
    if (win) {
      {
#line 2731
      AddOtherUsers(p, l - 1, win);
      }
    }
#line 2732
    if (*p) {
#line 2733
      qmflag = 1;
    }
    {
#line 2734
    __cil_tmp75 = strlen((char const   *)p);
    }
#line 2734
    p += __cil_tmp75 - 1UL;
#line 2735
    goto switch_break___0;
    case_102: /* CIL Label */ 
#line 2738
    *p = (char )0;
#line 2739
    if (win) {
      {
#line 2740
      AddWindowFlags(p, l - 1, win);
      }
    }
#line 2741
    if (*p) {
#line 2742
      qmflag = 1;
    }
    {
#line 2743
    __cil_tmp76 = strlen((char const   *)p);
    }
#line 2743
    p += __cil_tmp76 - 1UL;
#line 2744
    goto switch_break___0;
    case_116: /* CIL Label */ 
#line 2747
    *p = (char )0;
    {
#line 2748
    __cil_tmp77 = strlen((char const   *)win->w_title);
    }
#line 2748
    if (win) {
#line 2748
      if ((int )__cil_tmp77 < l) {
        {
#line 2749
        strcpy(p, (char const   *)win->w_title);
        }
#line 2750
        if (*p) {
#line 2751
          qmflag = 1;
        }
      }
    }
    {
#line 2753
    __cil_tmp78 = strlen((char const   *)p);
    }
#line 2753
    p += __cil_tmp78 - 1UL;
#line 2754
    goto switch_break___0;
    case_123: /* CIL Label */ 
#line 2759
    s ++;
#line 2761
    i = 0;
    {
#line 2761
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2761
      if (! (i < 127)) {
#line 2761
        goto while_break___5;
      }
#line 2762
      if ((int )*(s + i)) {
#line 2762
        if ((int )*(s + i) != 125) {
#line 2763
          rbuf[i] = *(s + i);
        } else {
#line 2765
          goto while_break___5;
        }
      } else {
#line 2765
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2761
    i ++;
#line 2767
    if ((int )*(s + i) == 125) {
#line 2767
      if (winmsg_numrend < 256) {
#line 2768
        r = - 1;
#line 2769
        rbuf[i] = (char )0;
        {
#line 2770
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2770
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 2772
        if (i != 1) {
          {
          {
#line 2773
          r = ParseAttrColor((char *)rbuf, (char *)0, 0);
          }
          }
        } else
#line 2772
        if ((int )rbuf[0] != 45) {
          {
          {
#line 2773
          r = ParseAttrColor((char *)rbuf, (char *)0, 0);
          }
          }
        }
#line 2774
        if (r != -1) {
#line 2775
          winmsg_rend[winmsg_numrend] = r;
#line 2776
          winmsg_rendpos[winmsg_numrend] = (int )(p - (char *)winmsg_buf);
#line 2777
          winmsg_numrend ++;
        } else
#line 2774
        if (i == 1) {
#line 2774
          if ((int )rbuf[0] == 45) {
#line 2775
            winmsg_rend[winmsg_numrend] = r;
#line 2776
            winmsg_rendpos[winmsg_numrend] = (int )(p - (char *)winmsg_buf);
#line 2777
            winmsg_numrend ++;
          }
        }
      }
    }
#line 2780
    s += i;
#line 2781
    __cil_tmp84 = p;
#line 2781
    p --;
#line 2783
    goto switch_break___0;
    case_72: /* CIL Label */ 
#line 2786
    *p = (char )0;
    {
#line 2787
    __cil_tmp85 = strlen((char const   *)((char *)HostName));
    }
#line 2787
    if ((int )__cil_tmp85 < l) {
      {
#line 2788
      strcpy(p, (char const   *)((char *)HostName));
      }
#line 2789
      if (*p) {
#line 2790
        qmflag = 1;
      }
    }
    {
#line 2792
    __cil_tmp86 = strlen((char const   *)p);
    }
#line 2792
    p += __cil_tmp86 - 1UL;
#line 2793
    goto switch_break___0;
    case_83: /* CIL Label */ 
    {
#line 2798
    *p = (char )0;
#line 2799
    __cil_tmp88 = strchr((char const   *)SockName, '.');
#line 2799
    session_name = __cil_tmp88 + 1;
#line 2800
    __cil_tmp89 = strlen((char const   *)session_name);
    }
#line 2800
    if ((int )__cil_tmp89 < l) {
      {
#line 2801
      strcpy(p, (char const   *)session_name);
      }
#line 2802
      if (*p) {
#line 2803
        qmflag = 1;
      }
    }
    {
#line 2805
    __cil_tmp90 = strlen((char const   *)p);
    }
#line 2805
    p += __cil_tmp90 - 1UL;
#line 2807
    goto switch_break___0;
    case_112: /* CIL Label */ 
#line 2811
    if (plusflg && display) {
#line 2811
      tmp___1122 = display->d_userpid;
    } else {
      {
#line 2811
      __cil_tmp91 = getpid();
#line 2811
      tmp___1122 = __cil_tmp91;
      }
    }
    {
#line 2811
    sprintf(p, (char const   *)((char *)"%d"), tmp___1122);
#line 2812
    __cil_tmp93 = strlen((char const   *)p);
    }
#line 2812
    p += __cil_tmp93 - 1UL;
#line 2814
    goto switch_break___0;
    case_70: /* CIL Label */ 
#line 2817
    __cil_tmp94 = p;
#line 2817
    p --;
#line 2819
    if (display) {
#line 2819
      if (ev) {
#line 2819
        if (ev == & (display->d_forecv)->c_captev) {
#line 2820
          minusflg = ! minusflg;
        } else {
#line 2819
          goto _L___1119;
        }
      } else
      _L___1119: /* CIL Label */ 
#line 2819
      if (! ev) {
#line 2819
        if (win) {
#line 2819
          if (win == display->d_fore) {
#line 2820
            minusflg = ! minusflg;
          }
        }
      }
    }
#line 2821
    if (minusflg) {
#line 2822
      qmflag = 1;
    }
#line 2823
    goto switch_break___0;
    case_80: /* CIL Label */ 
#line 2826
    __cil_tmp95 = p;
#line 2826
    p --;
#line 2828
    if (display) {
#line 2828
      if (ev) {
#line 2828
        if (ev != & display->d_hstatusev) {
#line 2830
          cv = (struct canvas *)ev->data;
#line 2831
          if (ev == & cv->c_captev) {
#line 2831
            if ((cv->c_layer)->l_layfn == & MarkLf) {
#line 2832
              qmflag = 1;
            }
          }
        }
      }
    }
#line 2835
    goto switch_break___0;
    case_69: /* CIL Label */ 
#line 2839
    __cil_tmp97 = p;
#line 2839
    p --;
#line 2840
    if (display) {
#line 2840
      if (display->d_ESCseen) {
#line 2841
        qmflag = 1;
      }
    }
#line 2842
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 2845
    truncpos = (int )(p - (char *)winmsg_buf);
#line 2846
    if (num > 100) {
#line 2846
      tmp___1123 = 100;
    } else {
#line 2846
      tmp___1123 = num;
    }
#line 2846
    truncper = tmp___1123;
#line 2847
    trunclong = longflg;
#line 2848
    __cil_tmp99 = p;
#line 2848
    p --;
#line 2849
    goto switch_break___0;
    case_60: /* CIL Label */ 
    case_61: /* CIL Label */ 
#line 2853
    *p = (char )' ';
#line 2854
    if (num) {
      _L___1122: /* CIL Label */ 
#line 2856
      if (minusflg) {
#line 2857
        if (plusflg) {
#line 2857
          tmp___1124 = lastpad;
        } else {
#line 2857
          tmp___1124 = padlen;
        }
#line 2857
        num = tmp___1124 - num;
#line 2858
        if (! plusflg) {
#line 2858
          if (padlen == 0) {
#line 2859
            num = (int )(p - (char *)winmsg_buf);
          }
        }
#line 2860
        plusflg = 0;
      } else
#line 2862
      if (! zeroflg) {
#line 2863
        if ((int )*s != 61) {
#line 2863
          if (num == 0) {
#line 2863
            if (! plusflg) {
#line 2864
              num = 100;
            }
          }
        }
#line 2865
        if (num > 100) {
#line 2866
          num = 100;
        }
#line 2867
        if (padlen == 0) {
#line 2868
          num = (int )(p - (char *)winmsg_buf);
        } else {
#line 2870
          if (plusflg) {
#line 2870
            tmp___1125 = lastpad;
          } else {
#line 2870
            tmp___1125 = 0;
          }
#line 2870
          num = ((padlen - tmp___1125) * num) / 100;
        }
      }
#line 2873
      if (num < 0) {
#line 2874
        num = 0;
      }
#line 2876
      if (plusflg) {
#line 2877
        num += lastpad;
      }
#line 2879
      if (num > 767) {
#line 2880
        num = 767;
      }
#line 2882
      if (numpad) {
        {
#line 2883
        p = pad_expand((char *)winmsg_buf, p, numpad, num);
        }
      }
#line 2885
      numpad = 0;
#line 2886
      if (p - (char *)winmsg_buf > (long )num) {
#line 2886
        if (! longflg) {
#line 2888
          if (truncpos == -1) {
#line 2889
            truncpos = lastpad;
#line 2890
            truncper = 0;
          }
#line 2893
          trunc = lastpad + (truncper * (num - lastpad)) / 100;
#line 2894
          if (trunc > num) {
#line 2895
            trunc = num;
          }
#line 2896
          if (trunc < lastpad) {
#line 2897
            trunc = lastpad;
          }
#line 2898
          left = truncpos - trunc;
#line 2899
          if ((long )left > (p - (char *)winmsg_buf) - (long )num) {
#line 2900
            left = (int )((p - (char *)winmsg_buf) - (long )num);
          }
          {
#line 2901
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2901
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 2902
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 2902
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 2904
          if (left > 0) {
#line 2905
            if ((long )(left + lastpad) > p - (char *)winmsg_buf) {
#line 2906
              left = (int )((p - (char *)winmsg_buf) - (long )lastpad);
            }
#line 2907
            if (((p - (char *)winmsg_buf) - (long )lastpad) - (long )left > 0L) {
              {
#line 2908
              bcopy((void const   *)(((char *)winmsg_buf + lastpad) + left), (void *)((char *)winmsg_buf + lastpad),
                    (size_t )(((p - (char *)winmsg_buf) - (long )lastpad) - (long )left));
              }
            }
#line 2909
            p -= left;
#line 2910
            r = winmsg_numrend;
            {
#line 2911
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 2911
              if (! (r && winmsg_rendpos[r - 1] > lastpad)) {
#line 2911
                goto while_break___9;
              }
#line 2912
              __cil_tmp105 = r;
#line 2912
              r --;
#line 2913
              winmsg_rendpos[r] -= left;
#line 2914
              if (winmsg_rendpos[r] < lastpad) {
#line 2915
                winmsg_rendpos[r] = lastpad;
              }
            }
            while_break___9: /* CIL Label */ ;
            }
#line 2918
            if (trunclong) {
#line 2919
              if (p - (char *)winmsg_buf > (long )lastpad) {
#line 2920
                winmsg_buf[lastpad] = (char )'.';
              }
#line 2921
              if (p - (char *)winmsg_buf > (long )(lastpad + 1)) {
#line 2922
                winmsg_buf[lastpad + 1] = (char )'.';
              }
#line 2923
              if (p - (char *)winmsg_buf > (long )(lastpad + 2)) {
#line 2924
                winmsg_buf[lastpad + 2] = (char )'.';
              }
            }
          }
#line 2928
          if (p - (char *)winmsg_buf > (long )num) {
#line 2929
            p = (char *)winmsg_buf + num;
#line 2930
            if (trunclong) {
#line 2931
              if (num - 1 >= lastpad) {
#line 2932
                *(p + - 1) = (char )'.';
              }
#line 2933
              if (num - 2 >= lastpad) {
#line 2934
                *(p + - 2) = (char )'.';
              }
#line 2935
              if (num - 3 >= lastpad) {
#line 2936
                *(p + - 3) = (char )'.';
              }
            }
#line 2938
            r = winmsg_numrend;
            {
#line 2939
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 2939
              if (! (r && winmsg_rendpos[r - 1] > num)) {
#line 2939
                goto while_break___10;
              }
#line 2940
              r --;
#line 2940
              winmsg_rendpos[r] = num;
            }
            while_break___10: /* CIL Label */ ;
            }
          }
#line 2942
          truncpos = - 1;
#line 2943
          trunclong = 0;
#line 2944
          if ((long )lastpad > p - (char *)winmsg_buf) {
#line 2945
            lastpad = (int )(p - (char *)winmsg_buf);
          }
          {
#line 2946
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 2946
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
      }
#line 2949
      if ((int )*s == 61) {
        {
#line 2950
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 2950
          if (! (p - (char *)winmsg_buf < (long )num)) {
#line 2950
            goto while_break___12;
          }
#line 2951
          __cil_tmp106 = p;
#line 2951
          p ++;
#line 2951
          *__cil_tmp106 = (char )' ';
        }
        while_break___12: /* CIL Label */ ;
        }
#line 2952
        lastpad = (int )(p - (char *)winmsg_buf);
#line 2953
        truncpos = - 1;
#line 2954
        trunclong = 0;
        {
#line 2955
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 2955
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
#line 2957
      __cil_tmp107 = p;
#line 2957
      p --;
    } else
#line 2854
    if (zeroflg) {
#line 2854
      goto _L___1122;
    } else
#line 2854
    if (plusflg) {
#line 2854
      goto _L___1122;
    } else
#line 2854
    if (longflg) {
#line 2854
      goto _L___1122;
    } else
#line 2854
    if ((int )*s != 61) {
#line 2854
      goto _L___1122;
    } else
#line 2959
    if (padlen) {
#line 2960
      *p = (char )127;
#line 2961
      numpad ++;
    }
#line 2963
    goto switch_break___0;
    case_110: /* CIL Label */ 
#line 2966
    s ++;
    switch_default___1: /* CIL Label */ 
#line 2970
    __cil_tmp110 = s;
#line 2970
    s --;
#line 2971
    if (l > 10 + num) {
#line 2972
      if (num == 0) {
#line 2973
        num = 1;
      }
#line 2974
      if (! win) {
#line 2975
        if (num > 1) {
#line 2975
          tmp___1126 = (char *)"--";
        } else {
#line 2975
          tmp___1126 = (char *)"-";
        }
        {
#line 2975
        sprintf(p, (char const   *)((char *)"%*s"), num, tmp___1126);
        }
      } else {
        {
#line 2977
        sprintf(p, (char const   *)((char *)"%*d"), num, win->w_number);
        }
      }
      {
#line 2978
      qmflag = 1;
#line 2979
      __cil_tmp112 = strlen((char const   *)p);
      }
#line 2979
      p += __cil_tmp112 - 1UL;
    }
#line 2981
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2474
  __cil_tmp114 = p;
#line 2474
  p ++;
#line 2474
  __cil_tmp113 = s;
#line 2474
  s ++;
#line 2985
  if (qmpos) {
#line 2985
    if (! qmflag) {
#line 2986
      p = qmpos + 1;
    }
  }
#line 2987
  *p = (char )'\000';
#line 2988
  if (numpad) {
#line 2989
    if (padlen > 767) {
#line 2990
      padlen = 767;
    }
    {
#line 2991
    p = pad_expand((char *)winmsg_buf, p, numpad, padlen);
    }
  }
#line 2993
  if (ev) {
    {
#line 2994
    evdeq(ev);
#line 2995
    ev->timeout.tv_sec = (__time_t )0;
#line 2996
    ev->timeout.tv_usec = (__suseconds_t )0;
    }
  }
#line 2998
  if (ev) {
#line 2998
    if (tick) {
#line 2999
      now.tv_usec = (__suseconds_t )100000;
#line 3000
      if (tick == 1) {
#line 3001
        (now.tv_sec) ++;
      } else {
#line 3003
        now.tv_sec += (long )tick - now.tv_sec % (long )tick;
      }
#line 3004
      ev->timeout = now;
      {
#line 3005
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 3005
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
  }
#line 3007
  return ((char *)winmsg_buf);
}
}
#line 3011 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
char *MakeWinMsg(char *s , struct win *win , int esc ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 3013
  __cil_tmp4 = MakeWinMsgEv(s, win, esc, 0, (struct event *)0, 0);
  }
#line 3013
  return (__cil_tmp4);
}
}
#line 3016 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void PutWinMsg(char *s , int start , int max ) 
{ 
  int i ;
  int p ;
  int l ;
  int r ;
  int n ;
  struct mchar rend ;
  struct mchar rendstack[256] ;
  int rendstackn ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  char *__cil_tmp14 ;
  size_t __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  char *__cil_tmp25 ;

  {
#line 3021
  rendstackn = 0;
#line 3023
  if (s != (char *)winmsg_buf) {
    {
#line 3025
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3025
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3026
    __cil_tmp12 = strlen((char const   *)s);
#line 3026
    l = (int )__cil_tmp12;
    }
#line 3027
    if (l > max) {
#line 3028
      l = max;
    }
#line 3029
    l -= start;
#line 3030
    s += start;
    {
#line 3031
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3031
      if (! (__cil_tmp13 > 0)) {
#line 3031
        goto while_break___0;
      }
      {
#line 3032
      __cil_tmp14 = s;
#line 3032
      s ++;
#line 3032
      PUTCHARLP((int )*__cil_tmp14);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3033
    return;
  }
  {
#line 3035
  rend = display->d_rend;
#line 3036
  p = 0;
#line 3037
  __cil_tmp15 = strlen((char const   *)s);
#line 3037
  l = (int )__cil_tmp15;
  }
  {
#line 3038
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3038
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3039
  i = 0;
  {
#line 3039
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3039
    if (! (i < winmsg_numrend && max > 0)) {
#line 3039
      goto while_break___2;
    }
#line 3040
    if (p > winmsg_rendpos[i]) {
#line 3041
      goto while_break___2;
    } else
#line 3040
    if (winmsg_rendpos[i] > l) {
#line 3041
      goto while_break___2;
    }
#line 3042
    if (p < winmsg_rendpos[i]) {
#line 3043
      n = winmsg_rendpos[i] - p;
#line 3044
      if (n > max) {
#line 3045
        n = max;
      }
#line 3046
      max -= n;
#line 3047
      p += n;
      {
#line 3048
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3048
        if (! (__cil_tmp16 > 0)) {
#line 3048
          goto while_break___3;
        }
#line 3049
        __cil_tmp17 = start;
#line 3049
        start --;
#line 3049
        if (__cil_tmp17 > 0) {
#line 3050
          s ++;
        } else {
          {
#line 3052
          __cil_tmp19 = s;
#line 3052
          s ++;
#line 3052
          PUTCHARLP((int )*__cil_tmp19);
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 3056
    r = winmsg_rend[i];
#line 3057
    if (r == -1) {
#line 3058
      if (rendstackn > 0) {
#line 3059
        rendstackn --;
#line 3059
        rend = rendstack[rendstackn];
      }
    } else {
      {
#line 3062
      __cil_tmp20 = rendstackn;
#line 3062
      rendstackn ++;
#line 3062
      rendstack[__cil_tmp20] = rend;
#line 3063
      ApplyAttrColor(r, & rend);
      }
    }
    {
#line 3066
    SetRendition(& rend);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3039
  i ++;
#line 3068
  if (p < l) {
#line 3069
    n = l - p;
#line 3070
    if (n > max) {
#line 3071
      n = max;
    }
    {
#line 3072
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3072
      if (! (__cil_tmp22 > 0)) {
#line 3072
        goto while_break___4;
      }
#line 3073
      __cil_tmp23 = start;
#line 3073
      start --;
#line 3073
      if (__cil_tmp23 > 0) {
#line 3074
        s ++;
      } else {
        {
#line 3076
        __cil_tmp25 = s;
#line 3076
        s ++;
#line 3076
        PUTCHARLP((int )*__cil_tmp25);
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 3106 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void serv_read_fn(struct event *ev , char *data ) 
{ 


  {
  {
#line 3108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3108
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3109
  ReceiveMsg();
  }
  return;
}
}
#line 3112 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void serv_select_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char ibuf ;
  int tmp ;
  struct canvas *cv ;
  int visual ;
  char *__cil_tmp8 ;
  struct canvas *cv___0 ;
  char *__cil_tmp10 ;
  struct canvas *cv___1 ;
  int lx ;
  int ly ;
  int __cil_tmp14 ;
  int i ;
  int n ;
  struct display *olddisplay ;
  struct layer *oldflayer ;
  struct layer *l ;
  struct canvas *cvlist ;
  struct canvas *cvlnext ;
  int i___0 ;
  int n___0 ;
  struct display *olddisplay___0 ;
  struct layer *oldflayer___0 ;
  struct layer *l___0 ;
  struct canvas *cvlist___0 ;
  struct canvas *cvlnext___0 ;
  int i___1 ;
  int n___1 ;
  struct display *olddisplay___1 ;
  struct layer *oldflayer___1 ;
  struct layer *l___1 ;
  struct canvas *cvlist___1 ;
  struct canvas *cvlnext___1 ;
  int i___2 ;
  int n___2 ;
  struct display *olddisplay___2 ;
  struct layer *oldflayer___2 ;
  struct layer *l___2 ;
  struct canvas *cvlist___2 ;
  struct canvas *cvlnext___2 ;
  struct display *olddisplay___3 ;
  struct layer *oldflayer___3 ;
  struct layer *l___3 ;
  struct canvas *cvlist___3 ;
  struct canvas *cvlnext___3 ;

  {
  {
#line 3115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3115
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3117
  if (GotSigChld) {
    {
#line 3118
    SigChldHandler();
    }
  }
#line 3120
  if (InterruptPlease) {
    {
#line 3121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3121
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3124
    if (fore) {
#line 3124
      if (displays) {
#line 3126
        ibuf = (char )displays->d_OldMode.tio.c_cc[0];
#line 3133
        if (fore->w_pwin && (fore->w_pwin)->p_fdpat & 4096) {
#line 3133
          tmp = (fore->w_pwin)->p_ptyfd;
        } else {
#line 3133
          tmp = fore->w_ptyfd;
        }
        {
#line 3133
        write(tmp, (void const   *)(& ibuf), (size_t )1);
        }
        {
#line 3134
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3134
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 3135
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3135
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 3141
    InterruptPlease = 0;
  }
#line 3144
  p = windows;
  {
#line 3144
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3144
    if (! p) {
#line 3144
      goto while_break___3;
    }
#line 3145
    if (p->w_bell == 1) {
      _L___1127: /* CIL Label */ 
#line 3147
      visual = p->w_bell == 3 || visual_bell;
#line 3148
      p->w_bell = 0;
#line 3149
      display = displays;
      {
#line 3149
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3149
        if (! display) {
#line 3149
          goto while_break___4;
        }
#line 3150
        cv = display->d_cvlist;
        {
#line 3150
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 3150
          if (! cv) {
#line 3150
            goto while_break___5;
          }
#line 3151
          if ((cv->c_layer)->l_bottom == & p->w_layer) {
#line 3152
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 3150
        cv = cv->c_next;
#line 3154
        if (cv == (struct canvas *)0) {
          {
#line 3155
          p->w_bell = 2;
#line 3156
          __cil_tmp8 = MakeWinMsg(BellString, p, '%');
#line 3156
          Msg(0, (char const   *)((char *)"%s"), __cil_tmp8);
          }
        } else
#line 3158
        if (visual) {
#line 3158
          if (! display->d_tcs[43].str) {
#line 3158
            if (! display->d_status) {
              _L: /* CIL Label */ 
              {
#line 3159
              Msg(0, (char const   *)((char *)"%s"), VisualBellString);
              }
#line 3161
              if (display->d_status) {
#line 3162
                display->d_status_bell = (char )1;
                {
#line 3163
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 3163
                  goto while_break___6;
                }
                while_break___6: /* CIL Label */ ;
                }
                {
#line 3164
                SetTimeout(& display->d_statusev, VBellWait);
                }
              }
            } else
#line 3158
            if (! display->d_status_bell) {
#line 3158
              goto _L;
            }
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3149
      display = display->d_next;
#line 3170
      if (p->w_monitor == 2) {
#line 3171
        p->w_monitor = 3;
      }
      {
#line 3172
      WindowChanged(p, 'f');
      }
    } else
#line 3145
    if (p->w_bell == 3) {
#line 3145
      goto _L___1127;
    }
#line 3175
    if (p->w_monitor == 2) {
#line 3177
      p->w_monitor = 1;
#line 3178
      display = displays;
      {
#line 3178
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 3178
        if (! display) {
#line 3178
          goto while_break___7;
        }
#line 3179
        cv___0 = display->d_cvlist;
        {
#line 3179
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 3179
          if (! cv___0) {
#line 3179
            goto while_break___8;
          }
#line 3180
          if ((cv___0->c_layer)->l_bottom == & p->w_layer) {
#line 3181
            goto while_break___8;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 3179
        cv___0 = cv___0->c_next;
#line 3182
        if (cv___0) {
#line 3183
          goto while_continue___7;
        }
#line 3186
        if (! ((int )*(p->w_mon_notify + ((display->d_user)->u_id >> 3)) & (128 >> ((display->d_user)->u_id & 7)))) {
#line 3187
          goto while_continue___7;
        }
        {
#line 3190
        __cil_tmp10 = MakeWinMsg(ActivityString, p, '%');
#line 3190
        Msg(0, (char const   *)((char *)"%s"), __cil_tmp10);
#line 3191
        p->w_monitor = 3;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 3178
      display = display->d_next;
#line 3193
      WindowChanged(p, 'f');
      }
    }
#line 3196
    if (p->w_silence == 2) {
#line 3198
      if (p->w_layer.l_cvlist) {
        {
#line 3199
        p->w_silence = 1;
#line 3200
        WindowChanged(p, 'f');
        }
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3144
  p = p->w_next;
#line 3205
  display = displays;
  {
#line 3205
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 3205
    if (! display) {
#line 3205
      goto while_break___9;
    }
#line 3207
    if (display->d_status == 1) {
#line 3208
      goto while_continue___9;
    }
#line 3210
    cv___1 = display->d_cvlist;
    {
#line 3210
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 3210
      if (! cv___1) {
#line 3210
        goto while_break___10;
      }
#line 3214
      lx = (cv___1->c_layer)->l_x;
#line 3215
      ly = (cv___1->c_layer)->l_y;
#line 3216
      if (lx == (cv___1->c_layer)->l_width) {
#line 3217
        __cil_tmp14 = lx;
#line 3217
        lx --;
      }
#line 3218
      if (ly + cv___1->c_yoff < cv___1->c_ys) {
        {
#line 3219
        n = cv___1->c_ys - (ly + cv___1->c_yoff);
#line 3220
        cv___1->c_yoff = cv___1->c_ys - ly;
#line 3221
        RethinkViewportOffsets(cv___1);
        }
#line 3222
        if (n > (cv___1->c_layer)->l_height) {
#line 3223
          n = (cv___1->c_layer)->l_height;
        }
        {
#line 3224
        olddisplay = display;
#line 3224
        oldflayer = flayer;
#line 3224
        l = cv___1->c_layer;
#line 3224
        cvlist = l->l_cvlist;
#line 3224
        cvlnext = cv___1->c_lnext;
#line 3224
        flayer = l;
#line 3224
        l->l_cvlist = cv___1;
#line 3224
        cv___1->c_lnext = (struct canvas *)0;
#line 3224
        LScrollV(flayer, - n, 0, flayer->l_height - 1, 0);
#line 3224
        (*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1, - 1, - 1, 1);
#line 3224
        i = 0;
        }
        {
#line 3224
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 3224
          if (! (i < n)) {
#line 3224
            goto while_break___11;
          }
          {
#line 3224
          (*((flayer->l_layfn)->lf_LayRedisplayLine))(i, 0, flayer->l_width - 1, 1);
          }
        }
        while_break___11: /* CIL Label */ ;
        }
#line 3224
        i ++;
#line 3224
        if (cv___1 == (cv___1->c_display)->d_forecv) {
          {
#line 3224
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3224
        flayer = oldflayer;
#line 3224
        l->l_cvlist = cvlist;
#line 3224
        cv___1->c_lnext = cvlnext;
#line 3224
        display = olddisplay;
      } else
#line 3233
      if (ly + cv___1->c_yoff > cv___1->c_ye) {
        {
#line 3234
        n___0 = (ly + cv___1->c_yoff) - cv___1->c_ye;
#line 3235
        cv___1->c_yoff = cv___1->c_ye - ly;
#line 3236
        RethinkViewportOffsets(cv___1);
        }
#line 3237
        if (n___0 > (cv___1->c_layer)->l_height) {
#line 3238
          n___0 = (cv___1->c_layer)->l_height;
        }
        {
#line 3239
        olddisplay___0 = display;
#line 3239
        oldflayer___0 = flayer;
#line 3239
        l___0 = cv___1->c_layer;
#line 3239
        cvlist___0 = l___0->l_cvlist;
#line 3239
        cvlnext___0 = cv___1->c_lnext;
#line 3239
        flayer = l___0;
#line 3239
        l___0->l_cvlist = cv___1;
#line 3239
        cv___1->c_lnext = (struct canvas *)0;
#line 3239
        LScrollV(flayer, n___0, 0, (cv___1->c_layer)->l_height - 1, 0);
#line 3239
        (*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1, - 1, - 1, 1);
#line 3239
        i___0 = 0;
        }
        {
#line 3239
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 3239
          if (! (i___0 < n___0)) {
#line 3239
            goto while_break___12;
          }
          {
#line 3239
          (*((flayer->l_layfn)->lf_LayRedisplayLine))((i___0 + flayer->l_height) - n___0,
                                                      0, flayer->l_width - 1, 1);
          }
        }
        while_break___12: /* CIL Label */ ;
        }
#line 3239
        i___0 ++;
#line 3239
        if (cv___1 == (cv___1->c_display)->d_forecv) {
          {
#line 3239
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3239
        flayer = oldflayer___0;
#line 3239
        l___0->l_cvlist = cvlist___0;
#line 3239
        cv___1->c_lnext = cvlnext___0;
#line 3239
        display = olddisplay___0;
      }
#line 3248
      if (lx + cv___1->c_xoff < cv___1->c_xs) {
#line 3249
        n___1 = cv___1->c_xs - (lx + cv___1->c_xoff);
#line 3250
        if (n___1 < ((cv___1->c_xe - cv___1->c_xs) + 1) / 2) {
#line 3251
          n___1 = ((cv___1->c_xe - cv___1->c_xs) + 1) / 2;
        }
#line 3252
        if (cv___1->c_xoff + n___1 > cv___1->c_xs) {
#line 3253
          n___1 = cv___1->c_xs - cv___1->c_xoff;
        }
        {
#line 3254
        cv___1->c_xoff += n___1;
#line 3255
        RethinkViewportOffsets(cv___1);
        }
#line 3256
        if (n___1 > (cv___1->c_layer)->l_width) {
#line 3257
          n___1 = (cv___1->c_layer)->l_width;
        }
        {
#line 3258
        olddisplay___1 = display;
#line 3258
        oldflayer___1 = flayer;
#line 3258
        l___1 = cv___1->c_layer;
#line 3258
        cvlist___1 = l___1->l_cvlist;
#line 3258
        cvlnext___1 = cv___1->c_lnext;
#line 3258
        flayer = l___1;
#line 3258
        l___1->l_cvlist = cv___1;
#line 3258
        cv___1->c_lnext = (struct canvas *)0;
#line 3258
        (*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1, - 1, - 1, 1);
#line 3258
        i___1 = 0;
        }
        {
#line 3258
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 3258
          if (! (i___1 < flayer->l_height)) {
#line 3258
            goto while_break___13;
          }
          {
#line 3258
          LScrollH(flayer, - n___1, i___1, 0, flayer->l_width - 1, 0, (struct mline *)0);
#line 3258
          (*((flayer->l_layfn)->lf_LayRedisplayLine))(i___1, 0, n___1 - 1, 1);
          }
        }
        while_break___13: /* CIL Label */ ;
        }
#line 3258
        i___1 ++;
#line 3258
        if (cv___1 == (cv___1->c_display)->d_forecv) {
          {
#line 3258
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3258
        flayer = oldflayer___1;
#line 3258
        l___1->l_cvlist = cvlist___1;
#line 3258
        cv___1->c_lnext = cvlnext___1;
#line 3258
        display = olddisplay___1;
      } else
#line 3268
      if (lx + cv___1->c_xoff > cv___1->c_xe) {
#line 3269
        n___2 = (lx + cv___1->c_xoff) - cv___1->c_xe;
#line 3270
        if (n___2 < ((cv___1->c_xe - cv___1->c_xs) + 1) / 2) {
#line 3271
          n___2 = ((cv___1->c_xe - cv___1->c_xs) + 1) / 2;
        }
#line 3272
        if (((cv___1->c_xoff - n___2) + (cv___1->c_layer)->l_width) - 1 < cv___1->c_xe) {
#line 3273
          n___2 = ((cv___1->c_xoff + (cv___1->c_layer)->l_width) - 1) - cv___1->c_xe;
        }
        {
#line 3274
        cv___1->c_xoff -= n___2;
#line 3275
        RethinkViewportOffsets(cv___1);
        }
#line 3276
        if (n___2 > (cv___1->c_layer)->l_width) {
#line 3277
          n___2 = (cv___1->c_layer)->l_width;
        }
        {
#line 3278
        olddisplay___2 = display;
#line 3278
        oldflayer___2 = flayer;
#line 3278
        l___2 = cv___1->c_layer;
#line 3278
        cvlist___2 = l___2->l_cvlist;
#line 3278
        cvlnext___2 = cv___1->c_lnext;
#line 3278
        flayer = l___2;
#line 3278
        l___2->l_cvlist = cv___1;
#line 3278
        cv___1->c_lnext = (struct canvas *)0;
#line 3278
        (*((flayer->l_layfn)->lf_LayRedisplayLine))(- 1, - 1, - 1, 1);
#line 3278
        i___2 = 0;
        }
        {
#line 3278
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 3278
          if (! (i___2 < flayer->l_height)) {
#line 3278
            goto while_break___14;
          }
          {
#line 3278
          LScrollH(flayer, n___2, i___2, 0, flayer->l_width - 1, 0, (struct mline *)0);
#line 3278
          (*((flayer->l_layfn)->lf_LayRedisplayLine))(i___2, flayer->l_width - n___2,
                                                      flayer->l_width - 1, 1);
          }
        }
        while_break___14: /* CIL Label */ ;
        }
#line 3278
        i___2 ++;
#line 3278
        if (cv___1 == (cv___1->c_display)->d_forecv) {
          {
#line 3278
          LGotoPos(flayer, flayer->l_x, flayer->l_y);
          }
        }
#line 3278
        flayer = oldflayer___2;
#line 3278
        l___2->l_cvlist = cvlist___2;
#line 3278
        cv___1->c_lnext = cvlnext___2;
#line 3278
        display = olddisplay___2;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
#line 3210
    cv___1 = cv___1->c_next;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 3205
  display = display->d_next;
#line 3290
  display = displays;
  {
#line 3290
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 3290
    if (! display) {
#line 3290
      goto while_break___15;
    }
#line 3291
    if (display->d_status == 1) {
#line 3292
      goto while_continue___15;
    } else
#line 3291
    if (display->d_cvlist == (struct canvas *)0) {
#line 3292
      goto while_continue___15;
    } else
#line 3291
    if ((display->d_cvlist)->c_next == (struct canvas *)0) {
#line 3292
      goto while_continue___15;
    }
    {
#line 3293
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 3293
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 3294
    olddisplay___3 = display;
#line 3294
    oldflayer___3 = flayer;
#line 3294
    l___3 = (display->d_forecv)->c_layer;
#line 3294
    cvlist___3 = l___3->l_cvlist;
#line 3294
    cvlnext___3 = (display->d_forecv)->c_lnext;
#line 3294
    flayer = l___3;
#line 3294
    l___3->l_cvlist = display->d_forecv;
#line 3294
    (display->d_forecv)->c_lnext = (struct canvas *)0;
#line 3294
    (*((flayer->l_layfn)->lf_LayRestore))();
#line 3294
    LGotoPos(flayer, flayer->l_x, flayer->l_y);
#line 3294
    flayer = oldflayer___3;
#line 3294
    l___3->l_cvlist = cvlist___3;
#line 3294
    (display->d_forecv)->c_lnext = cvlnext___3;
#line 3294
    display = olddisplay___3;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
#line 3290
  display = display->d_next;
  return;
}
}
#line 3298 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static void logflush_fn(struct event *ev , char *data ) 
{ 
  struct win *p ;
  char *buf ;
  int n ;
  int __cil_tmp6 ;
  int tmp ;
  size_t __cil_tmp9 ;

  {
  {
#line 3304
  __cil_tmp6 = islogfile((char *)((void *)0));
  }
#line 3304
  if (! __cil_tmp6) {
#line 3305
    return;
  }
  {
#line 3306
  logfflush((struct logfile *)((void *)0));
  }
#line 3307
  if (log_flush) {
#line 3307
    tmp = log_flush;
  } else {
#line 3307
    tmp = (logtstamp_after + 4) / 5;
  }
#line 3307
  n = tmp;
#line 3309
  if (n) {
    {
#line 3310
    SetTimeout(ev, n * 1000);
#line 3311
    evenq(ev);
    }
  }
#line 3314
  if (! logtstamp_on) {
#line 3315
    return;
  }
#line 3318
  p = windows;
  {
#line 3318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3318
    if (! p) {
#line 3318
      goto while_break;
    }
#line 3319
    if (! p->w_log) {
#line 3320
      goto while_continue;
    }
#line 3321
    p->w_logsilence += n;
#line 3322
    if (p->w_logsilence < logtstamp_after) {
#line 3323
      goto while_continue;
    }
#line 3324
    if (p->w_logsilence - n >= logtstamp_after) {
#line 3325
      goto while_continue;
    }
    {
#line 3326
    buf = MakeWinMsg(logtstamp_string, p, '%');
#line 3327
    __cil_tmp9 = strlen((char const   *)buf);
#line 3327
    logfwrite(p->w_log, buf, (int )__cil_tmp9);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3318
  p = p->w_next;
  return;
}
}
#line 3338 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static char *ParseChar(char *p , char *cp ) 
{ 
  char *__cil_tmp3 ;

  {
#line 3340
  if ((int )*p == 0) {
#line 3341
    return ((char *)0);
  }
#line 3343
  if ((int )*p == 94) {
#line 3343
    if ((int )*(p + 1)) {
#line 3344
      p ++;
#line 3344
      if ((int )*p == 63) {
#line 3345
        *cp = (char )'\177';
      } else
#line 3346
      if ((int )*p >= 64) {
#line 3347
        *cp = (char )((int )*p & 31);
      } else {
#line 3349
        return ((char *)0);
      }
#line 3350
      p ++;
    } else {
#line 3343
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 3352
    p ++;
#line 3352
    if ((int )*p == 92) {
#line 3352
      if ((int )*p <= 55) {
#line 3352
        if ((int )*p >= 48) {
#line 3353
          *cp = (char )0;
          {
#line 3354
          while (1) {
            while_continue: /* CIL Label */ ;
#line 3355
            *cp = (char )(((int )*cp * 8 + (int )*p) - 48);
#line 3354
            if (! ((int )*p <= 55 && (int )*p >= 48)) {
#line 3354
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
        } else {
#line 3359
          __cil_tmp3 = p;
#line 3359
          p ++;
#line 3359
          *cp = *__cil_tmp3;
        }
      } else {
#line 3359
        __cil_tmp3 = p;
#line 3359
        p ++;
#line 3359
        *cp = *__cil_tmp3;
      }
    } else {
#line 3359
      __cil_tmp3 = p;
#line 3359
      p ++;
#line 3359
      *cp = *__cil_tmp3;
    }
  }
#line 3360
  return (p);
}
}
#line 3363 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
static int ParseEscape(char *p ) 
{ 
  unsigned char buf[2] ;

  {
#line 3367
  if ((int )*p == 0) {
    {
#line 3368
    SetEscape((struct acluser *)0, - 1, - 1);
    }
  } else {
    {
#line 3370
    p = ParseChar(p, (char *)((unsigned char *)buf) + 1);
    }
    {
#line 3370
    p = ParseChar(p, (char *)((unsigned char *)buf));
    }
#line 3370
    if (p == (char *)((void *)0)) {
#line 3372
      return (- 1);
    } else
#line 3370
    if (p == (char *)((void *)0)) {
#line 3372
      return (- 1);
    } else
#line 3370
    if ((int )*p) {
#line 3372
      return (- 1);
    }
    {
#line 3373
    SetEscape((struct acluser *)0, (int )buf[0], (int )buf[1]);
    }
  }
#line 3375
  return (0);
}
}
#line 3378 "/home/hyunsu/workspace/cr-bench/screen-4.7.0/screen.c"
void SetTtyname(int fatal , struct stat *st ) 
{ 
  int ret ;
  int saved_errno ;
  int *__cil_tmp5 ;
  int *__cil_tmp7 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int *__cil_tmp12 ;
  size_t __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 3381
  saved_errno = 0;
#line 3383
  attach_tty_is_in_new_ns = 0;
#line 3384
  memset((void *)(& attach_tty_name_in_ns), 0, sizeof(attach_tty_name_in_ns));
#line 3386
  __cil_tmp5 = __errno_location();
#line 3386
  *__cil_tmp5 = 0;
#line 3387
  attach_tty = ttyname(0);
  }
#line 3388
  if (! attach_tty) {
    {
#line 3389
    __cil_tmp7 = __errno_location();
    }
#line 3389
    if (*__cil_tmp7 == 19) {
      {
#line 3390
      saved_errno = (int )__errno_location();
#line 3391
      attach_tty = (char *)"/proc/self/fd/0";
#line 3392
      attach_tty_is_in_new_ns = 1;
#line 3393
      __cil_tmp9 = readlink((char const   *)attach_tty, (char *)attach_tty_name_in_ns,
                            sizeof(attach_tty_name_in_ns));
#line 3393
      ret = (int )__cil_tmp9;
      }
#line 3394
      if (ret < 0) {
        {
        {
#line 3395
        Panic(0, (char const   *)((char *)"Bad tty \'%s\'"), attach_tty);
        }
        }
      } else
#line 3394
      if ((size_t )ret >= sizeof(attach_tty_name_in_ns)) {
        {
        {
#line 3395
        Panic(0, (char const   *)((char *)"Bad tty \'%s\'"), attach_tty);
        }
        }
      }
    } else
#line 3396
    if (fatal) {
      {
#line 3397
      Panic(0, (char const   *)((char *)"Must be connected to a terminal."));
      }
    } else {
#line 3399
      attach_tty = (char *)"";
    }
  }
  {
#line 3403
  __cil_tmp10 = strcmp((char const   *)attach_tty, (char const   *)((char *)""));
  }
#line 3403
  if (attach_tty) {
#line 3403
    if (__cil_tmp10) {
      {
#line 3404
      __cil_tmp11 = stat((char const   *)attach_tty, st);
      }
#line 3404
      if (__cil_tmp11) {
        {
#line 3405
        __cil_tmp12 = __errno_location();
#line 3405
        Panic(*__cil_tmp12, (char const   *)((char *)"Cannot access \'%s\'"), attach_tty);
        }
      }
      {
#line 3407
      __cil_tmp13 = strlen((char const   *)attach_tty);
      }
#line 3407
      if (__cil_tmp13 >= 4096UL) {
        {
#line 3408
        Panic(0, (char const   *)((char *)"TtyName too long - sorry."));
        }
      }
      {
#line 3413
      __cil_tmp14 = CheckTtyname(attach_tty);
      }
#line 3413
      if (saved_errno != 19) {
#line 3413
        if (__cil_tmp14) {
          {
#line 3414
          Panic(0, (char const   *)((char *)"Bad tty \'%s\'"), attach_tty);
          }
        }
      }
    }
  }
  return;
}
}

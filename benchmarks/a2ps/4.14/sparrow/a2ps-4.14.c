/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 17 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_INVALID = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_OVERFLOW = 3
} ;
#line 21 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrtol.h"
typedef enum strtol_error strtol_error;
#line 214 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef unsigned int size_t;
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 23 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.h"
enum backup_type {
    none = 0,
    simple = 1,
    numbered_existing = 2,
    numbered = 3
} ;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 36 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.h"
struct a2ps_job;
#line 76
enum face_e {
    No_face = -1,
    First_face = 0,
    Plain = 0,
    Keyword = 1,
    Keyword_strong = 2,
    Label = 3,
    Label_strong = 4,
    String = 5,
    Symbol = 6,
    Error = 7,
    Comment = 8,
    Comment_strong = 9,
    Last_face = 9
} ;
#line 47 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.h"
struct hash_table_s {
   void **ht_vec ;
   unsigned long ht_size ;
   unsigned long ht_capacity ;
   unsigned long ht_fill ;
   unsigned long ht_collisions ;
   unsigned long ht_lookups ;
   unsigned int ht_rehashes ;
   unsigned long (*ht_hash_1)(void const   *key ) ;
   unsigned long (*ht_hash_2)(void const   *key ) ;
   int (*ht_compare)(void const   *x , void const   *y ) ;
};
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.h"
struct encoding;
#line 96
struct pair_htable;
#line 45 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.h"
struct output;
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.h"
struct medium {
   char *name ;
   int w ;
   int h ;
   int llx ;
   int lly ;
   int urx ;
   int ury ;
};
#line 53
enum __anonenum_ORIENTATION_53 {
    portrait = 0,
    landscape = 1
} ;
#line 53 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.h"
typedef enum __anonenum_ORIENTATION_53 ORIENTATION;
#line 33 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.h"
enum da_growth {
    da_steady = 0,
    da_linear = 1,
    da_geometrical = 2
} ;
#line 48 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.h"
struct darray {
   char const   *name ;
   size_t size ;
   size_t original_size ;
   enum da_growth growth ;
   size_t increment ;
   size_t len ;
   void **content ;
   void (*self_print)(void const   * , FILE *stream ) ;
   int (*cmp)(void const   *k1 , void const   *k2 ) ;
};
#line 34 "/home/ysko/Works/test-src/a2ps-4.14/lib/gen.h"
enum output_format {
    eps = 0,
    ps = 1
} ;
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.h"
typedef struct hash_table_s hash_table;
#line 46
enum duplex_e {
    simplex = 0,
    duplex = 1,
    tumble = 2
} ;
#line 55 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.h"
struct ps_status {
   unsigned int columnsperline ;
   unsigned long wxperline ;
   int linesperpage ;
   float title_bar_height ;
   int title_font_size ;
   unsigned char *magic_number ;
   unsigned char *page_label_format ;
   struct encoding *opened_encoding ;
   int page_are_ordered ;
   hash_table *needed_resources ;
   hash_table *supplied_resources ;
   hash_table *colors ;
   hash_table *pagedevice ;
   hash_table *statusdict ;
   struct output *setup ;
   unsigned char **page_label ;
   int start_page ;
   int start_line ;
   int line_continued ;
   int is_in_cut ;
   enum face_e face ;
   int face_declared ;
   int nonprinting_chars ;
   int chars ;
   int line ;
   unsigned int column ;
   unsigned long wx ;
};
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/lib/caret.h"
enum unprintable_format {
    caret = 0,
    space = 1,
    question_mark = 2,
    octal = 3,
    hexa = 4,
    Emacs = 5
} ;
#line 43 "/home/ysko/Works/test-src/a2ps-4.14/lib/common.h"
struct a2ps_common_s {
   char **path ;
};
#line 46 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.h"
struct a2ps_printers_s;
#line 34 "/home/ysko/Works/test-src/a2ps-4.14/lib/madir.h"
enum madir_e {
    madir_rows = 0,
    madir_columns = 1
} ;
#line 34 "/home/ysko/Works/test-src/a2ps-4.14/lib/madir.h"
typedef enum madir_e madir_t;
#line 35 "/home/ysko/Works/test-src/a2ps-4.14/lib/filalign.h"
typedef int file_align_t;
#line 49 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.h"
struct stream;
#line 52
struct page_range;
#line 52 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.h"
struct a2ps_job {
   char **argv ;
   size_t argc ;
   struct a2ps_common_s common ;
   char *file_command ;
   hash_table *media ;
   struct pair_htable *user_options ;
   struct tm run_tm ;
   enum backup_type backup_type ;
   int sheets ;
   int pages ;
   int lines_folded ;
   int total_files ;
   ORIENTATION orientation ;
   enum duplex_e duplex ;
   int columns ;
   int rows ;
   madir_t madir ;
   int virtual ;
   int copies ;
   int margin ;
   struct pair_htable *encodings_map ;
   struct output *ps_encodings ;
   int page_prefeed ;
   char *face_eo_font[10] ;
   unsigned char *stdin_filename ;
   struct a2ps_printers_s *printers ;
   enum output_format output_format ;
   struct stream *output_stream ;
   _Bool folding ;
   int numbering ;
   enum unprintable_format unprintable_format ;
   int interpret ;
   int print_binaries ;
   file_align_t file_align ;
   int border ;
   _Bool debug ;
   char *prolog ;
   struct medium *medium ;
   char *medium_request ;
   int tabsize ;
   int lines_requested ;
   int columns_requested ;
   float fontsize ;
   struct encoding *encoding ;
   char *requested_encoding_name ;
   struct encoding *requested_encoding ;
   struct encoding *saved_encoding ;
   struct hash_table_s *encodings ;
   struct pair_htable *fonts_map ;
   struct hash_table_s *font_infos ;
   unsigned char *title ;
   unsigned char *header ;
   unsigned char *center_title ;
   unsigned char *left_title ;
   unsigned char *right_title ;
   unsigned char *left_footer ;
   unsigned char *footer ;
   unsigned char *right_footer ;
   unsigned char *water ;
   unsigned char tag1[256] ;
   unsigned char tag2[256] ;
   unsigned char tag3[256] ;
   unsigned char tag4[256] ;
   struct pair_htable *macro_meta_sequences ;
   struct ps_status *status ;
   struct output *divertion ;
   char *tmp_filenames[10] ;
   struct page_range *page_range ;
   struct darray *jobs ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 36 "/home/ysko/Works/test-src/a2ps-4.14/lib/userdata.h"
struct userdata {
   char *login ;
   char *name ;
   char *comments ;
   char *home ;
};
#line 29 "/home/ysko/Works/test-src/a2ps-4.14/lib/tterm.h"
struct tterm;
#line 82 "/home/ysko/Works/test-src/a2ps-4.14/lib/tterm.c"
struct tterm {
   size_t tabsize ;
   size_t width ;
};
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/lib/stream.h"
struct stream {
   _Bool is_file ;
   FILE *fp ;
};
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.h"
struct string_htable;
#line 73 "/home/ysko/Works/test-src/a2ps-4.14/lib/signame.c"
struct __anonstruct_num_abbrev_43 {
   int number ;
   char const   *abbrev ;
};
#line 73 "/home/ysko/Works/test-src/a2ps-4.14/lib/signame.c"
typedef struct __anonstruct_num_abbrev_43 num_abbrev;
#line 21 "./quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    escape_quoting_style = 4,
    locale_quoting_style = 5
} ;
#line 40
struct quoting_options;
#line 326 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef int wchar_t;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_21 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_20 {
   int __count ;
   union __anonunion___value_21 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_20 __mbstate_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 72 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int quote_these_too[256UL / (sizeof(int ) * 8UL) + (unsigned long )(256UL % (sizeof(int ) * 8UL) != 0UL)] ;
};
#line 467 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
struct dict_entry {
   char *key ;
   char *value ;
   int def ;
};
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
typedef struct dict_entry dict_entry;
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.h"
struct file_job;
#line 52 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.h"
typedef struct a2ps_job a2ps_job;
#line 33 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.h"
struct file_job {
   unsigned char *name ;
   char *delegation_tmpname ;
   char *stdin_tmpname ;
   char const   *type ;
   _Bool is_toc ;
   struct tm mod_tm ;
   _Bool printable ;
   _Bool is_stdin ;
   int first_sheet ;
   int last_sheet ;
   int first_page ;
   int last_page ;
   int pages ;
   int sheets ;
   int num ;
   int top_line ;
   int top_page ;
   int lines ;
};
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.h"
struct ppd {
   char *key ;
   char *modelname ;
   char *nickname ;
   struct string_htable *fonts ;
};
#line 36 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.h"
struct lister;
#line 62 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
struct printer {
   char *key ;
   char *ppdkey ;
   char *command ;
};
#line 269 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
struct a2ps_printers_s {
   struct a2ps_common_s *common ;
   struct hash_table_s *printers ;
   struct printer default_printer ;
   struct printer unknown_printer ;
   char *default_ppdkey ;
   char *request_ppdkey ;
   struct ppd *ppd ;
   _Bool flag_output_is_printer ;
   char *flag_output_name ;
   _Bool output_is_file ;
   char *output_name ;
};
#line 45 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
struct interval {
   int min ;
   int max ;
};
#line 142 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
struct page_range {
   struct darray *intervals ;
   _Bool toc ;
};
#line 90 "parseppd.y"
union YYSTYPE {
   char *string ;
   unsigned char *ustring ;
   struct ppd *ppd ;
};
#line 90 "parseppd.y"
typedef union YYSTYPE YYSTYPE;
#line 213 "parseppd.c"
typedef unsigned char yytype_uint8;
#line 220 "parseppd.c"
typedef signed char yytype_int8;
#line 228 "parseppd.c"
typedef unsigned short yytype_uint16;
#line 234 "parseppd.c"
typedef short yytype_int16;
#line 365 "parseppd.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 48 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
struct pair {
   char *key ;
   char *value ;
};
#line 49 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.h"
enum ds_growth {
    ds_steady = 0,
    ds_linear = 1,
    ds_geometrical = 2
} ;
#line 62 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.h"
struct dstring {
   size_t len ;
   enum ds_growth growth ;
   size_t increment ;
   size_t size ;
   size_t original_size ;
   char *content ;
};
#line 47 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
enum derivation_type {
    nothing = 0,
    delayed_int = 1,
    delayed_string = 2,
    delayed_routine = 3,
    delayed_chunk = 4
} ;
#line 56 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
struct derivation {
   enum derivation_type type ;
   void *arg ;
   void (*delayed_routine)(FILE *stream , void *arg ) ;
   void *delayed_routine_arg ;
   int *delayed_int ;
   unsigned char **delayed_string ;
   struct output *delayed_chunk ;
};
#line 67 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
struct output {
   char const   *name ;
   struct dstring *chunk ;
   struct darray *derivations ;
   int to_void ;
};
#line 83 "/home/ysko/Works/test-src/a2ps-4.14/lib/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/lib/getnum.h"
enum range_type_e {
    range_no_limit = 0,
    range_min = 1,
    range_min_strict = 2,
    range_max = 3,
    range_max_strict = 4,
    range_min_max = 5,
    range_min_strict_max = 6,
    range_min_max_strict = 7,
    range_min_strict_max_strict = 8
} ;
#line 271 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
struct opt_optarg {
   int option ;
   char *optarg ;
   struct opt_optarg *next ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 152 "/usr/lib/gcc/i486-linux-gnu/4.3.2/include/stddef.h"
typedef int ptrdiff_t;
#line 162 "./obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 169 "./obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   ptrdiff_t temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 74 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
struct world {
   size_t *widths ;
   size_t width ;
   size_t valid_len ;
};
#line 83 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
struct multicol {
   size_t between ;
   size_t justify ;
   struct world *worlds ;
};
#line 100 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
struct separated {
   char const   *separator ;
   size_t between ;
   char const   *final ;
};
#line 113 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
struct lister {
   struct tterm *tterm ;
   FILE *stream ;
   size_t (*width_fn)(void const   *item ) ;
   void (*print_fn)(void const   *item , FILE *stream ) ;
   size_t before ;
   size_t after ;
   struct multicol multicol ;
   struct separated separated ;
};
#line 52 "lexppd.c"
typedef short flex_int16_t;
#line 53 "lexppd.c"
typedef int flex_int32_t;
#line 152
struct yy_buffer_state;
#line 152 "lexppd.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 201 "lexppd.c"
typedef unsigned int yy_size_t;
#line 206 "lexppd.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 352 "lexppd.c"
typedef unsigned char YY_CHAR;
#line 356 "lexppd.c"
typedef int yy_state_type;
#line 53 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
struct token;
#line 148 "fonts.l"
struct wx_entry {
   char *glyph ;
   int index ;
   unsigned int wx ;
};
#line 155 "fonts.l"
struct font_info {
   char *key ;
   struct hash_table_s *wx ;
};
#line 680
enum segment_type {
    ascii = 1,
    binary = 2,
    end_of_file = 3
} ;
#line 30 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.c"
typedef struct file_job fjob_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
struct face_and_name {
   char const   *name ;
   enum face_e face ;
};
#line 238 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
struct font_entry {
   char *key ;
   int used ;
   int reencode ;
   unsigned int *wx ;
};
#line 392 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
struct encoding {
   char *key ;
   char *name ;
   unsigned char *documentation ;
   char *default_font ;
   struct pair_htable *substitutes ;
   char *vector[256] ;
   struct darray *font_names_used ;
   struct hash_table_s *fonts ;
   unsigned int *faces_wx[10] ;
};
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
struct multivalued_entry {
   char *key ;
   struct string_htable *entries ;
};
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
typedef struct multivalued_entry multivalued_entry;
#line 120 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.h"
enum da_include_policy {
    da_1_wins = 0,
    da_2_wins = 1
} ;
#line 59 "confg.gperf"
enum keyword_e {
    AppendLibraryPath = 0,
    DefaultPPD = 1,
    DefaultPrinter = 2,
    Delegation = 3,
    FileCommand = 4,
    Include = 5,
    LibraryPath = 6,
    Medium = 7,
    Obsolete = 8,
    Options = 9,
    OutputFirstLine = 10,
    PageLabelFormat = 11,
    PrependLibraryPath = 12,
    Printer = 13,
    UnknownPrinter = 14,
    UserOption = 15,
    Variable = 16
} ;
#line 81 "confg.gperf"
struct keyword_s {
   char const   *name ;
   enum keyword_e code ;
   int argc ;
   _Bool line_token ;
};
#line 48 "sheets-map.l"
enum __anonenum_token_t_56 {
    tKEY = 10,
    tGLOB = 11,
    tFILE = 12
} ;
#line 48 "sheets-map.l"
typedef enum __anonenum_token_t_56 token_t;
#line 47 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.h"
enum fflag_e {
    ff_No_fflag = 0,
    ff_Invisible = 1,
    ff_Tag1 = 2,
    ff_Tag2 = 4,
    ff_Tag3 = 8,
    ff_Tag4 = 16,
    ff_Index1 = 32,
    ff_Index2 = 64,
    ff_Index3 = 128,
    ff_Index4 = 256,
    ff_Encoding = 512
} ;
#line 75 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.h"
struct fface_s {
   enum face_e face ;
   enum fflag_e flags ;
};
#line 52 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.h"
typedef unsigned long reg_syntax_t;
#line 323 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 39 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.h"
enum case_sensitiveness {
    case_sensitive = 0,
    case_insensitive = 1,
    case_undefined = 2
} ;
#line 48 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.h"
struct pattern {
   char *pattern ;
   size_t len ;
};
#line 60 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.h"
struct faced_string {
   unsigned char *string ;
   int reg_ref ;
   struct fface_s face ;
};
#line 74 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.h"
struct rule {
   unsigned char *word ;
   struct re_pattern_buffer *regex ;
   struct darray *rhs ;
};
#line 81 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.h"
struct words {
   struct darray *strings ;
   struct darray *regexps ;
   struct rule **min[256] ;
   struct rule **max[256] ;
};
#line 90 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.h"
struct sequence {
   struct rule *open ;
   struct fface_s face ;
   struct words *exceptions ;
   struct words *close ;
};
#line 98 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.h"
struct style_sheet {
   char const   *key ;
   unsigned char const   *name ;
   unsigned char const   *author ;
   int version[4] ;
   int requirement[4] ;
   unsigned char const   *documentation ;
   struct darray *ancestors ;
   enum case_sensitiveness sensitiveness ;
   unsigned char alpha1[256] ;
   unsigned char alpha2[256] ;
   struct words *keywords ;
   struct words *operators ;
   struct darray *sequences ;
};
#line 114 "/home/ysko/Works/test-src/a2ps-4.14/src/parsessh.h"
union YYSTYPE___0 {
   int integer ;
   unsigned char *string ;
   struct pattern *pattern ;
   struct style_sheet *sheet ;
   struct rule *rule ;
   struct sequence *sequence ;
   struct darray *array ;
   struct words *words ;
   struct faced_string *faced_string ;
   enum face_e face ;
   enum fflag_e fflags ;
   struct fface_s fface ;
   enum case_sensitiveness sensitiveness ;
};
#line 114 "/home/ysko/Works/test-src/a2ps-4.14/src/parsessh.h"
typedef union YYSTYPE___0 YYSTYPE___0;
#line 433 "parsessh.c"
union yyalloc___0 {
   yytype_int16 yyss ;
   YYSTYPE___0 yyvs ;
};
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.c"
struct fflag_and_name {
   char const   *name ;
   enum fflag_e flag ;
};
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.h"
enum eol_e {
    eol_r = 0,
    eol_n = 1,
    eol_rn = 2,
    eol_nr = 3,
    eol_auto = 4
} ;
#line 64 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.h"
struct buffer_s {
   unsigned char const   *buf ;
   size_t bufsize ;
   size_t bufoffset ;
   FILE *stream ;
   _Bool pipe_p ;
   unsigned char *content ;
   enum eol_e eol ;
   _Bool lower_case ;
   unsigned char *value ;
   size_t line ;
   size_t allocsize ;
   size_t len ;
   size_t curr ;
   struct obstack obstack ;
};
#line 64 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.h"
typedef struct buffer_s buffer_t;
#line 41 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 45 "./regex.h"
typedef unsigned long active_reg_t;
#line 283
enum __anonenum_reg_errcode_t_22 {
    REG_ENOSYS = -1,
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} ;
#line 283 "./regex.h"
typedef enum __anonenum_reg_errcode_t_22 reg_errcode_t;
#line 391 "./regex.h"
typedef struct re_pattern_buffer regex_t;
#line 394 "./regex.h"
typedef int regoff_t;
#line 399 "./regex.h"
struct re_registers {
   unsigned int num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 418 "./regex.h"
struct __anonstruct_regmatch_t_23 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 418 "./regex.h"
typedef struct __anonstruct_regmatch_t_23 regmatch_t;
#line 377 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
typedef char boolean;
#line 393
enum __anonenum_re_opcode_t_25 {
    no_op = 0,
    succeed = 1,
    exactn = 2,
    anychar = 3,
    charset = 4,
    charset_not = 5,
    start_memory = 6,
    stop_memory = 7,
    duplicate = 8,
    begline = 9,
    endline = 10,
    begbuf = 11,
    endbuf = 12,
    jump = 13,
    jump_past_alt = 14,
    on_failure_jump = 15,
    on_failure_keep_string_jump = 16,
    pop_failure_jump = 17,
    maybe_pop_jump = 18,
    dummy_failure_jump = 19,
    push_dummy_failure = 20,
    succeed_n = 21,
    jump_n = 22,
    set_number_at = 23,
    wordchar = 24,
    notwordchar = 25,
    wordbeg = 26,
    wordend = 27,
    wordbound = 28,
    notwordbound = 29
} ;
#line 393 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
typedef enum __anonenum_re_opcode_t_25 re_opcode_t;
#line 1127 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
union fail_stack_elt {
   unsigned char *pointer ;
   int integer ;
};
#line 1133 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
typedef union fail_stack_elt fail_stack_elt_t;
#line 1135 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
struct __anonstruct_fail_stack_type_26 {
   fail_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
#line 1135 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
typedef struct __anonstruct_fail_stack_type_26 fail_stack_type;
#line 1455 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
struct __anonstruct_bits_28 {
   unsigned int match_null_string_p : 2 ;
   unsigned int is_active : 1 ;
   unsigned int matched_something : 1 ;
   unsigned int ever_matched_something : 1 ;
};
#line 1455 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
union __anonunion_register_info_type_27 {
   fail_stack_elt_t word ;
   struct __anonstruct_bits_28 bits ;
};
#line 1455 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
typedef union __anonunion_register_info_type_27 register_info_type;
#line 1667 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
typedef unsigned int regnum_t;
#line 1675 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
typedef long pattern_offset_t;
#line 1677 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
struct __anonstruct_compile_stack_elt_t_29 {
   pattern_offset_t begalt_offset ;
   pattern_offset_t fixup_alt_jump ;
   pattern_offset_t inner_group_offset ;
   pattern_offset_t laststart_offset ;
   regnum_t regnum ;
};
#line 1677 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
typedef struct __anonstruct_compile_stack_elt_t_29 compile_stack_elt_t;
#line 1687 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
struct __anonstruct_compile_stack_type_30 {
   compile_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
#line 1687 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
typedef struct __anonstruct_compile_stack_type_30 compile_stack_type;
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.h"
struct delegation {
   char *name ;
   char *contract ;
   char *command ;
};
#line 209 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
enum continuation_e {
    no_continuation = 0,
    needed_resource = 1
} ;
#line 36 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
enum style_kind_e {
    no_style = 0,
    binary___0 = 1,
    sshparser = 2,
    unprintable = 3,
    delegate = 4
} ;
#line 57 "/home/ysko/Works/test-src/a2ps-4.14/src/select.h"
struct pattern_rule;
#line 61 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
struct pattern_rule {
   char const   *pattern ;
   char const   *command ;
   int on_file_verdict ;
   _Bool insensitive_p ;
};
#line 33 "/home/ysko/Works/test-src/a2ps-4.14/src/versions.h"
typedef int version_t[3];
#line 60 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
struct token {
   struct re_registers *registers ;
   struct darray *rhs ;
};
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 73 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
enum behavior {
    b_ps = 0,
    b_guess = 1,
    b_help = 2,
    b_version = 3,
    b_expand = 4,
    b_which = 5,
    b_glob = 6,
    b_list_options = 7,
    b_list_features = 8,
    b_list_media = 9,
    b_list_style_sheets = 10,
    b_list_html_style_sheets = 11,
    b_list_texinfo_style_sheets = 12,
    b_list_printers = 13,
    b_list_delegations = 14,
    b_list_macro_meta_sequences = 15,
    b_list_encodings = 16,
    b_list_texinfo_encodings = 17,
    b_list_user_options = 18,
    b_list_prologues = 19,
    b_list_texinfo_prologues = 20,
    b_list_ppd = 21
} ;
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *s ,
                                                                                     int c )  __attribute__((__pure__)) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 28 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 93 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrtol.c"
static int bkm_scale(long *x , int scale_factor ) 
{ 
  long product ;

  {
#line 96
  product = *x * (long )scale_factor;
#line 97
  if (*x != product / (long )scale_factor) {
#line 98
    return (1);
  }
#line 99
  *x = product;
#line 100
  return (0);
}
}
#line 103 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrtol.c"
static int bkm_scale_by_power(long *x , int base , int power ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    tmp___0 = power;
#line 106
    power --;
#line 106
    if (! tmp___0) {
#line 106
      goto while_break;
    }
    {
#line 107
    tmp = bkm_scale(x, base);
    }
#line 107
    if (tmp) {
#line 108
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (0);
}
}
#line 115 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  long tmp ;
  int *tmp___1 ;
  int *tmp___2 ;
  int base ;
  int suffixes ;
  int overflow ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 123
  if (0 <= strtol_base) {
#line 123
    if (! (strtol_base <= 36)) {
      {
#line 123
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrtol.c",
                    123U, "xstrtol");
      }
    }
  } else {
    {
#line 123
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrtol.c",
                  123U, "xstrtol");
    }
  }
#line 125
  if (ptr) {
#line 125
    p = ptr;
  } else {
#line 125
    p = & t_ptr;
  }
  {
#line 136
  tmp___1 = __errno_location();
#line 136
  *tmp___1 = 0;
#line 137
  tmp = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
#line 138
  tmp___2 = __errno_location();
  }
#line 138
  if (*tmp___2 != 0) {
#line 139
    return ((strtol_error )3);
  }
#line 140
  if ((unsigned long )*p == (unsigned long )s) {
#line 141
    return ((strtol_error )1);
  }
#line 146
  if (! valid_suffixes) {
#line 148
    *val = tmp;
#line 149
    return ((strtol_error )0);
  }
#line 152
  if ((int )*(*p) != 0) {
    {
#line 154
    base = 1024;
#line 155
    suffixes = 1;
#line 158
    tmp___3 = strchr(valid_suffixes, (int )*(*p));
    }
#line 158
    if (! tmp___3) {
#line 160
      *val = tmp;
#line 161
      return ((strtol_error )2);
    }
    {
#line 164
    tmp___4 = strchr(valid_suffixes, '0');
    }
#line 164
    if (tmp___4) {
      {
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_66;
      }
#line 176
      if ((int )*(*(p + 0) + 1) == 68) {
#line 176
        goto case_68;
      }
#line 170
      goto switch_break;
      case_66: /* CIL Label */ 
#line 173
      suffixes ++;
#line 174
      goto switch_break;
      case_68: /* CIL Label */ 
#line 177
      base = 1000;
#line 178
      suffixes ++;
#line 179
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 185
    if ((int )*(*p) == 98) {
#line 185
      goto case_98;
    }
#line 189
    if ((int )*(*p) == 66) {
#line 189
      goto case_66___0;
    }
#line 193
    if ((int )*(*p) == 99) {
#line 193
      goto case_99;
    }
#line 197
    if ((int )*(*p) == 69) {
#line 197
      goto case_69;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_71;
    }
#line 205
    if ((int )*(*p) == 107) {
#line 205
      goto case_107;
    }
#line 210
    if ((int )*(*p) == 109) {
#line 210
      goto case_109;
    }
#line 210
    if ((int )*(*p) == 77) {
#line 210
      goto case_109;
    }
#line 214
    if ((int )*(*p) == 80) {
#line 214
      goto case_80;
    }
#line 218
    if ((int )*(*p) == 84) {
#line 218
      goto case_84;
    }
#line 222
    if ((int )*(*p) == 119) {
#line 222
      goto case_119;
    }
#line 226
    if ((int )*(*p) == 89) {
#line 226
      goto case_89;
    }
#line 230
    if ((int )*(*p) == 90) {
#line 230
      goto case_90;
    }
#line 234
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 186
    overflow = bkm_scale(& tmp, 512);
    }
#line 187
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 190
    overflow = bkm_scale(& tmp, 1024);
    }
#line 191
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 194
    overflow = 0;
#line 195
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 198
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
#line 199
    goto switch_break___0;
    case_71: /* CIL Label */ 
    {
#line 202
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
#line 203
    goto switch_break___0;
    case_107: /* CIL Label */ 
    {
#line 206
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
#line 207
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 211
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
#line 212
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 215
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
#line 216
    goto switch_break___0;
    case_84: /* CIL Label */ 
    {
#line 219
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
#line 220
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 223
    overflow = bkm_scale(& tmp, 2);
    }
#line 224
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 227
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
#line 228
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 231
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
#line 232
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 235
    *val = tmp;
#line 236
    return ((strtol_error )2);
#line 237
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 240
    if (overflow) {
#line 241
      return ((strtol_error )3);
    }
#line 243
    *p += suffixes;
  }
#line 246
  *val = tmp;
#line 247
  return ((strtol_error )0);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 569
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) stpcpy)(char * __restrict  dest ,
                                                                                       char const   * __restrict  src ) ;
#line 59 "/home/ysko/Works/test-src/a2ps-4.14/lib/xalloc.h"
void *xmalloc(size_t n ) ;
#line 61
void *xrealloc(void *p , size_t n ) ;
#line 32 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrrpl.h"
char *xstrrpl(char const   *string , char const   *(*subst)[2] ) ;
#line 33
void strrpl(char **string , char const   *(*subst)[2] ) ;
#line 36
char *xvstrrpl(char const   *string  , ...) ;
#line 37
void vstrrpl(char **string  , ...) ;
#line 31 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrrpl.c"
char *xstrrpl(char const   *string , char const   *(*subst)[2] ) 
{ 
  char *res___2 ;
  char *cp ;
  int i ;
  size_t max ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  void *tmp___9 ;

  {
#line 37
  max = (size_t )0;
#line 38
  i = 0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! (*(subst + i))[0]) {
#line 38
      goto while_break;
    }
    {
#line 39
    tmp___1 = strlen((*(subst + i))[1]);
    }
#line 39
    if (max > tmp___1) {
#line 39
      max = max;
    } else {
      {
#line 39
      tmp___0 = strlen((*(subst + i))[1]);
#line 39
      max = tmp___0;
      }
    }
#line 38
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  tmp___2 = strlen(string);
#line 43
  tmp___3 = xmalloc((size_t )(sizeof(char ) * (unsigned long )(tmp___2 * (max + 1U) + 1U)));
#line 43
  res___2 = (char *)tmp___3;
#line 44
  cp = res___2;
  }
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 47
    if (! *string) {
#line 47
      goto while_break___0;
    }
#line 49
    i = 0;
    {
#line 49
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 49
      if (! (*(subst + i))[0]) {
#line 49
        goto while_break___1;
      }
      {
#line 50
      tmp___5 = strlen((*(subst + i))[0]);
#line 50
      tmp___6 = strncmp((*(subst + i))[0], string, tmp___5);
      }
#line 50
      if (! tmp___6) {
        {
#line 52
        cp = stpcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)(*(subst + i))[1]);
#line 53
        tmp___4 = strlen((*(subst + i))[0]);
#line 53
        string += tmp___4;
        }
#line 54
        goto __next_char;
      }
#line 49
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 56
    tmp___7 = cp;
#line 56
    cp ++;
#line 56
    tmp___8 = string;
#line 56
    string ++;
#line 56
    *tmp___7 = (char )*tmp___8;
    __next_char: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 61
  *cp = (char )'\000';
#line 66
  tmp___9 = xrealloc((void *)res___2, (size_t )(sizeof(char ) * (unsigned long )((cp - res___2) + 1L)));
#line 66
  res___2 = (char *)tmp___9;
  }
#line 68
  return (res___2);
}
}
#line 72 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrrpl.c"
void strrpl(char **string , char const   *(*subst)[2] ) 
{ 
  char *res___2 ;

  {
  {
#line 76
  res___2 = xstrrpl((char const   *)*string, subst);
#line 77
  free((void *)*string);
#line 78
  *string = res___2;
  }
#line 79
  return;
}
}
#line 86 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrrpl.c"
char *xvstrrpl(char const   *string  , ...) 
{ 
  va_list ap ;
  char const   *subst[100][2] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 99
  i = 0;
#line 103
  __builtin_va_start(ap, string);
#line 108
  i = 0;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    tmp___0 = __builtin_va_arg(ap, char *);
#line 108
    tmp = tmp___0;
#line 108
    subst[i / 2][i % 2] = tmp;
    }
#line 108
    if (! tmp) {
#line 108
      goto while_break;
    }
#line 108
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  __builtin_va_end(ap);
  }
#line 111
  if (i % 2) {
#line 112
    return ((char *)((void *)0));
  }
  {
#line 113
  tmp___1 = xstrrpl(string, subst);
  }
#line 113
  return (tmp___1);
}
}
#line 118 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrrpl.c"
void vstrrpl(char **string  , ...) 
{ 
  va_list ap ;
  char const   *subst[100][2] ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 131
  i = 0;
#line 135
  __builtin_va_start(ap, string);
#line 140
  i = 0;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 140
    tmp___0 = __builtin_va_arg(ap, char *);
#line 140
    tmp = tmp___0;
#line 140
    subst[i / 2][i % 2] = tmp;
    }
#line 140
    if (! tmp) {
#line 140
      goto while_break;
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  __builtin_va_end(ap);
  }
#line 143
  if (i % 2) {
    {
#line 144
    free((void *)*string);
    }
  } else {
    {
#line 146
    strrpl(string, subst);
    }
  }
#line 147
  return;
}
}
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrdup.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 45
  tmp = strlen(string);
#line 45
  tmp___0 = xmalloc(tmp + 1U);
#line 45
  tmp___1 = strcpy((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)string);
  }
#line 45
  return (tmp___1);
}
}
#line 52 "/home/ysko/Works/test-src/a2ps-4.14/lib/xstrdup.c"
char *xstrndup(char const   *string , size_t n ) 
{ 
  size_t len ;
  size_t tmp ;
  char *res___2 ;
  void *tmp___0 ;

  {
  {
#line 55
  tmp = strlen(string);
#line 55
  len = tmp;
  }
#line 57
  if (n < len) {
#line 58
    len = n;
  }
  {
#line 60
  tmp___0 = xmalloc(len + 1U);
#line 60
  res___2 = (char *)tmp___0;
#line 61
  strncpy((char */* __restrict  */)res___2, (char const   */* __restrict  */)string,
          len);
#line 62
  *(res___2 + len) = (char )'\000';
  }
#line 63
  return (res___2);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 49 "/home/ysko/Works/test-src/a2ps-4.14/lib/error.h"
extern void ( /* format attribute */  error)(int status , int errnum , char const   *format 
                                             , ...) ;
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/lib/xalloc.h"
int xalloc_exit_failure ;
#line 46
void (*xalloc_fail_func)(void) ;
#line 51
char * const  xalloc_msg_memory_exhausted ;
#line 57
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 60
void *xcalloc(size_t n , size_t s ) ;
#line 59 "/home/ysko/Works/test-src/a2ps-4.14/lib/xmalloc.c"
int xalloc_exit_failure  =    1;
#line 62 "/home/ysko/Works/test-src/a2ps-4.14/lib/xmalloc.c"
void (*xalloc_fail_func)(void)  =    (void (*)(void))0;
#line 66 "/home/ysko/Works/test-src/a2ps-4.14/lib/xmalloc.c"
char * const  xalloc_msg_memory_exhausted  =    (char */* const  */)"Memory exhausted";
#line 68
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 68 "/home/ysko/Works/test-src/a2ps-4.14/lib/xmalloc.c"
void xalloc_die(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;

  {
#line 71
  if (xalloc_fail_func) {
    {
#line 72
    (*xalloc_fail_func)();
    }
  }
  {
#line 73
  tmp = gettext((char const   *)xalloc_msg_memory_exhausted);
#line 73
  error(xalloc_exit_failure, 0, "%s", tmp);
#line 77
  exit(1);
  }
}
}
#line 82 "/home/ysko/Works/test-src/a2ps-4.14/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;

  {
  {
#line 87
  p = malloc(n);
  }
#line 88
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 89
    xalloc_die();
    }
  }
#line 90
  return (p);
}
}
#line 97 "/home/ysko/Works/test-src/a2ps-4.14/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
  {
#line 100
  p = realloc(p, n);
  }
#line 101
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 102
    xalloc_die();
    }
  }
#line 103
  return (p);
}
}
#line 108 "/home/ysko/Works/test-src/a2ps-4.14/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 113
  p = calloc(n, s);
  }
#line 114
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 115
    xalloc_die();
    }
  }
#line 116
  return (p);
}
}
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/lib/xgethostname.c"
extern int gethostname() ;
#line 44 "/home/ysko/Works/test-src/a2ps-4.14/lib/xgethostname.c"
char *xgethostname(void) 
{ 
  char *hostname ;
  size_t size ;
  int err ;
  void *tmp ;
  int k ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  char *__cil_tmp11 ;

  {
  {
#line 51
  size = (size_t )34;
#line 52
  tmp = xmalloc((size_t )(sizeof(char ) * (unsigned long )size));
#line 52
  hostname = (char *)tmp;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 58
    k = (int )(size - 2U);
#line 60
    tmp___0 = __errno_location();
#line 60
    *tmp___0 = 0;
#line 61
    *(hostname + k) = (char )'\000';
#line 62
    err = gethostname(hostname, size);
    }
#line 63
    if (err == 0) {
#line 63
      if ((int )*(hostname + k) == 0) {
#line 64
        goto while_break;
      } else {
#line 63
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 66
    if (err != 0) {
      {
#line 66
      tmp___2 = __errno_location();
      }
#line 66
      if (*tmp___2 != 36) {
        {
#line 66
        tmp___3 = __errno_location();
        }
#line 66
        if (*tmp___3 != 0) {
          {
#line 67
          tmp___1 = __errno_location();
#line 67
          error(1, *tmp___1, "gethostname");
          }
        }
      }
    }
    {
#line 69
    size *= 2U;
#line 70
    tmp___4 = xrealloc((void *)hostname, (size_t )(sizeof(char ) * (unsigned long )size));
#line 70
    hostname = (char *)tmp___4;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (hostname);
}
}
#line 507 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 50 "/home/ysko/Works/test-src/a2ps-4.14/lib/xgetcwd.c"
char *xgetcwd(void) 
{ 
  char *cwd ;
  char *ret ;
  unsigned int path_max ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int save_errno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 57
  tmp = __errno_location();
#line 57
  *tmp = 0;
#line 58
  path_max = 4096U;
#line 59
  path_max += 2U;
#line 61
  tmp___0 = xmalloc(path_max);
#line 61
  cwd = (char *)tmp___0;
#line 63
  tmp___1 = __errno_location();
#line 63
  *tmp___1 = 0;
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 64
    ret = getcwd(cwd, path_max);
    }
#line 64
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
      {
#line 64
      tmp___4 = __errno_location();
      }
#line 64
      if (! (*tmp___4 == 34)) {
#line 64
        goto while_break;
      }
    } else {
#line 64
      goto while_break;
    }
    {
#line 66
    path_max += 32U;
#line 67
    tmp___2 = xrealloc(cwd, path_max);
#line 67
    cwd = (char *)tmp___2;
#line 68
    tmp___3 = __errno_location();
#line 68
    *tmp___3 = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 73
    tmp___5 = __errno_location();
#line 73
    save_errno = *tmp___5;
#line 74
    free(cwd);
#line 75
    tmp___6 = __errno_location();
#line 75
    *tmp___6 = save_errno;
    }
#line 76
    return ((char *)((void *)0));
  }
#line 78
  return (cwd);
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 157
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 55 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.h"
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) ;
#line 36 "/home/ysko/Works/test-src/a2ps-4.14/lib/xbackupfile.h"
char *xfind_backup_file_name(char const   *file , enum backup_type backup_type ) ;
#line 39
FILE *fopen_backup(char const   *filename , enum backup_type backup_type ) ;
#line 42
int create_file_for_backup(char const   *file , int oflag , mode_t mode , enum backup_type backup_type ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 94 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.h"
char *quotearg(char const   *arg ) ;
#line 98 "/home/ysko/Works/test-src/a2ps-4.14/lib/xbackupfile.c"
char *xfind_backup_file_name(char const   *file , enum backup_type backup_type ) 
{ 
  char *res___2 ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 103
  res___2 = find_backup_file_name(file, backup_type);
  }
#line 104
  if (! res___2) {
    {
#line 105
    tmp = gettext("Memory exhausted");
#line 105
    error(1, 0, (char const   *)tmp);
    }
  }
#line 107
  return (res___2);
}
}
#line 146 "/home/ysko/Works/test-src/a2ps-4.14/lib/xbackupfile.c"
int create_file_for_backup(char const   *file , int oflag , mode_t mode , enum backup_type backup_type ) 
{ 
  int fd ;
  struct stat st ;
  int tmp ;
  char *backup ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 153
  if (! (oflag & 64)) {
    {
#line 153
    __assert_fail("oflag & 0100", "/home/ysko/Works/test-src/a2ps-4.14/lib/xbackupfile.c",
                  153U, "create_file_for_backup");
    }
  }
#line 155
  if ((unsigned int )backup_type == 0U) {
    {
#line 156
    tmp = open(file, oflag, mode);
    }
#line 156
    return (tmp);
  }
  {
#line 159
  fd = open(file, oflag | 128, mode);
  }
#line 175
  if (fd < 0) {
    {
#line 175
    tmp___3 = __errno_location();
    }
#line 175
    if (*tmp___3 == 17) {
      {
#line 179
      tmp___2 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
      }
#line 179
      if (tmp___2 == 0) {
#line 179
        if ((st.st_mode & 61440U) == 32768U) {
          {
#line 181
          tmp___0 = find_backup_file_name(file, backup_type);
#line 181
          backup = tmp___0;
#line 182
          tmp___1 = rename(file, (char const   *)backup);
          }
#line 182
          if (tmp___1 != 0) {
#line 183
            return (-1);
          }
          {
#line 184
          free((void *)backup);
          }
        }
      }
      {
#line 187
      fd = open(file, oflag, mode);
      }
    }
  }
#line 190
  return (fd);
}
}
#line 208 "/home/ysko/Works/test-src/a2ps-4.14/lib/xbackupfile.c"
FILE *fopen_backup(char const   *filename , enum backup_type backup_type ) 
{ 
  char *backup_name ;
  struct stat filestat ;
  FILE *res___2 ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 211
  backup_name = (char *)((void *)0);
#line 216
  tmp___4 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& filestat));
  }
#line 216
  if (tmp___4) {
    {
#line 218
    tmp___2 = __errno_location();
    }
#line 218
    if (*tmp___2 == 2) {
#line 221
      backup_type = (enum backup_type )0;
    } else {
      {
#line 218
      tmp___3 = __errno_location();
      }
#line 218
      if (*tmp___3 == 20) {
#line 221
        backup_type = (enum backup_type )0;
      } else {
        {
#line 224
        tmp = quotearg(filename);
#line 224
        tmp___0 = gettext("cannot get informations on file `%s\'");
#line 224
        tmp___1 = __errno_location();
#line 224
        error(1, *tmp___1, (char const   *)tmp___0, tmp);
        }
      }
    }
  }
#line 231
  if (! ((filestat.st_mode & 61440U) == 32768U)) {
#line 233
    backup_type = (enum backup_type )0;
  } else {
    {
#line 231
    tmp___5 = access(filename, 2);
    }
#line 231
    if (tmp___5) {
#line 233
      backup_type = (enum backup_type )0;
    }
  }
#line 236
  if ((unsigned int )backup_type != 0U) {
    {
#line 238
    backup_name = xfind_backup_file_name(filename, backup_type);
#line 239
    tmp___10 = rename(filename, (char const   *)backup_name);
    }
#line 239
    if (tmp___10) {
      {
#line 240
      tmp___6 = quotearg((char const   *)backup_name);
#line 240
      tmp___7 = quotearg(filename);
#line 240
      tmp___8 = gettext("cannot rename file `%s\' as `%s\'");
#line 240
      tmp___9 = __errno_location();
#line 240
      error(1, *tmp___9, (char const   *)tmp___8, tmp___7, tmp___6);
      }
    }
  }
  {
#line 245
  res___2 = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 246
  if (! res___2) {
    {
#line 248
    tmp___11 = quotearg(filename);
#line 248
    tmp___12 = gettext("cannot create file `%s\'");
#line 248
    tmp___13 = __errno_location();
#line 248
    error(0, *tmp___13, (char const   *)tmp___12, tmp___11);
    }
#line 249
    if (backup_name) {
      {
#line 251
      tmp___20 = rename(filename, (char const   *)backup_name);
      }
#line 251
      if (tmp___20) {
        {
#line 252
        tmp___14 = quotearg((char const   *)backup_name);
#line 252
        tmp___15 = quotearg(filename);
#line 252
        tmp___16 = gettext("cannot rename file `%s\' as `%s\'");
#line 252
        tmp___17 = __errno_location();
#line 252
        error(0, *tmp___17, (char const   *)tmp___16, tmp___15, tmp___14);
        }
      } else {
        {
#line 255
        tmp___18 = quotearg(filename);
#line 255
        tmp___19 = gettext("restored file `%s\'");
#line 255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___19,
                tmp___18);
        }
      }
    }
    {
#line 257
    exit(1);
    }
  }
#line 260
  if (backup_name) {
    {
#line 261
    free((void *)backup_name);
    }
  }
#line 263
  return (res___2);
}
}
#line 459 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 662 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 45 "/home/ysko/Works/test-src/a2ps-4.14/lib/useropt.h"
struct pair_htable *user_options_table_new(void) ;
#line 46
void user_options_table_free(struct pair_htable *table ) ;
#line 48
void user_option_add(struct a2ps_job *job___0 , char const   *key , char const   *value ) ;
#line 50
char *user_option_get(struct a2ps_job *job___0 , char *shortcut ) ;
#line 52
void user_options_list_short(struct a2ps_job *job___0 , FILE *stream ) ;
#line 53
void user_options_list_long(struct a2ps_job *job___0 , FILE *stream ) ;
#line 50 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.h"
struct pair_htable *pair_table_new(void) ;
#line 51
void pair_table_free(struct hash_table_s *table ) ;
#line 56
void pair_add(struct hash_table_s *table , char const   *key , char const   *value ) ;
#line 69
char *pair_get(struct hash_table_s *table , char const   *key ) ;
#line 72
void pair_table_list_short(struct hash_table_s *table , FILE *stream ) ;
#line 74
void pair_table_list_long(struct hash_table_s *table , FILE *stream ) ;
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/useropt.c"
struct pair_htable *user_options_table_new(void) 
{ 
  struct pair_htable *tmp ;

  {
  {
#line 44
  tmp = pair_table_new();
  }
#line 44
  return (tmp);
}
}
#line 50 "/home/ysko/Works/test-src/a2ps-4.14/lib/useropt.c"
void user_options_table_free(struct pair_htable *table ) 
{ 


  {
  {
#line 53
  pair_table_free(table);
  }
#line 54
  return;
}
}
#line 59 "/home/ysko/Works/test-src/a2ps-4.14/lib/useropt.c"
void user_option_add(struct a2ps_job *job___0 , char const   *key , char const   *value ) 
{ 


  {
  {
#line 62
  pair_add(job___0->user_options, key, value);
  }
#line 63
  return;
}
}
#line 68 "/home/ysko/Works/test-src/a2ps-4.14/lib/useropt.c"
char *user_option_get(struct a2ps_job *job___0 , char *shortcut ) 
{ 
  char *res___2 ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 73
  res___2 = pair_get(job___0->user_options, (char const   *)shortcut);
  }
#line 74
  if (! res___2) {
    {
#line 75
    tmp = quotearg((char const   *)shortcut);
#line 75
    tmp___0 = gettext("unknown user option `%s\'");
#line 75
    error(1, 0, (char const   *)tmp___0, tmp);
    }
  }
#line 77
  return (res___2);
}
}
#line 83 "/home/ysko/Works/test-src/a2ps-4.14/lib/useropt.c"
void user_options_list_short(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 86
  tmp = gettext("Known User Options");
#line 86
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
#line 87
  _IO_putc('\n', stream);
#line 88
  pair_table_list_short(job___0->user_options, stream);
  }
#line 89
  return;
}
}
#line 94 "/home/ysko/Works/test-src/a2ps-4.14/lib/useropt.c"
void user_options_list_long(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 97
  tmp = gettext("Known User Options");
#line 97
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
#line 98
  _IO_putc('\n', stream);
#line 99
  pair_table_list_long(job___0->user_options, stream);
  }
#line 100
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 119 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 684 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 44 "/home/ysko/Works/test-src/a2ps-4.14/lib/userdata.h"
void userdata_get(struct userdata *udata ) ;
#line 45
void userdata_free(struct userdata *udata ) ;
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/userdata.c"
void userdata_free(struct userdata *udata ) 
{ 


  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (udata->login) {
      {
#line 44
      free((void *)udata->login);
      }
    }
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 45
    if (udata->name) {
      {
#line 45
      free((void *)udata->name);
      }
    }
#line 45
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 46
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 46
    if (udata->comments) {
      {
#line 46
      free((void *)udata->comments);
      }
    }
#line 46
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 47
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 47
    if (udata->home) {
      {
#line 47
      free((void *)udata->home);
      }
    }
#line 47
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 50 "/home/ysko/Works/test-src/a2ps-4.14/lib/userdata.c"
void userdata_get(struct userdata *udata ) 
{ 
  struct passwd *passwd ;
  char const   *home ;
  char const   *login ;
  char *comments ;
  char *name ;
  char *cp ;
  __uid_t tmp ;
  char *gecos ;
  size_t amps ;
  char *cp2 ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 53
  passwd = (struct passwd *)((void *)0);
#line 55
  comments = (char *)((void *)0);
#line 55
  name = (char *)((void *)0);
#line 58
  tmp = getuid();
#line 58
  passwd = getpwuid(tmp);
#line 62
  cp = getenv("HOME");
  }
#line 62
  if (cp) {
#line 63
    home = (char const   *)cp;
  } else
#line 64
  if (passwd) {
#line 64
    if (passwd->pw_dir) {
#line 65
      home = (char const   *)passwd->pw_dir;
    } else {
#line 67
      home = "/home";
    }
  } else {
#line 67
    home = "/home";
  }
  {
#line 70
  cp = getenv("LOGNAME");
  }
#line 70
  if (cp) {
#line 71
    login = (char const   *)cp;
  } else {
    {
#line 72
    cp = getenv("USERNAME");
    }
#line 72
    if (cp) {
#line 73
      login = (char const   *)cp;
    } else
#line 74
    if (passwd) {
#line 74
      if (passwd->pw_name) {
#line 75
        login = (char const   *)passwd->pw_name;
      } else {
#line 77
        login = (char const   *)((void *)0);
      }
    } else {
#line 77
      login = (char const   *)((void *)0);
    }
  }
#line 82
  if (passwd) {
#line 82
    if (passwd->pw_gecos) {
#line 84
      gecos = (char *)((void *)0);
#line 85
      if (login) {
#line 89
        amps = (size_t )0;
#line 92
        cp = passwd->pw_gecos;
        {
#line 92
        while (1) {
          while_continue: /* CIL Label */ ;
#line 92
          if (! *cp) {
#line 92
            goto while_break;
          }
#line 93
          if ((int )*cp == 38) {
#line 94
            amps ++;
          }
#line 92
          cp ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 95
        tmp___0 = strlen((char const   *)passwd->pw_gecos);
#line 95
        tmp___1 = strlen(login);
#line 95
        tmp___2 = __builtin_alloca(sizeof(char ) * (unsigned long )((tmp___0 + amps * (tmp___1 - 1U)) + 1U));
#line 95
        gecos = (char *)tmp___2;
#line 99
        cp2 = gecos;
#line 101
        cp = passwd->pw_gecos;
        }
        {
#line 101
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 101
          if (! *cp) {
#line 101
            goto while_break___0;
          }
#line 102
          if ((int )*cp == 38) {
            {
#line 104
            tmp___3 = cp2;
#line 104
            cp2 ++;
#line 104
            tmp___4 = toupper((int )*login);
#line 104
            *tmp___3 = (char )tmp___4;
#line 105
            cp2 = stpcpy((char */* __restrict  */)cp2, (char const   */* __restrict  */)(login + 1));
            }
          } else {
#line 108
            tmp___5 = cp2;
#line 108
            cp2 ++;
#line 108
            *tmp___5 = *cp;
          }
#line 101
          cp ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 109
        *cp2 = (char )'\000';
      } else {
        {
#line 113
        tmp___6 = strlen((char const   *)passwd->pw_gecos);
#line 113
        tmp___7 = __builtin_alloca(sizeof(char ) * (unsigned long )(tmp___6 + 1U));
#line 113
        gecos = (char *)tmp___7;
#line 114
        stpcpy((char */* __restrict  */)gecos, (char const   */* __restrict  */)passwd->pw_gecos);
        }
      }
      {
#line 120
      name = gecos;
#line 121
      comments = strchr((char const   *)gecos, ',');
      }
#line 121
      if (comments) {
#line 123
        *comments = (char )'\000';
#line 124
        comments ++;
      }
    }
  }
#line 129
  if (login) {
#line 129
    tmp___9 = login;
  } else {
    {
#line 129
    tmp___8 = gettext("user");
#line 129
    tmp___9 = (char const   *)tmp___8;
    }
  }
  {
#line 129
  udata->login = xstrdup(tmp___9);
  }
#line 130
  if (name) {
#line 130
    tmp___11 = name;
  } else {
    {
#line 130
    tmp___10 = gettext("Unknown User");
#line 130
    tmp___11 = tmp___10;
    }
  }
  {
#line 130
  udata->name = xstrdup((char const   *)tmp___11);
  }
#line 131
  if (comments) {
    {
#line 131
    tmp___12 = xstrdup((char const   *)comments);
#line 131
    udata->comments = tmp___12;
    }
  } else {
#line 131
    udata->comments = (char *)((void *)0);
  }
#line 132
  if (home) {
#line 132
    tmp___13 = home;
  } else {
#line 132
    tmp___13 = "/home";
  }
  {
#line 132
  udata->home = xstrdup(tmp___13);
  }
#line 133
  return;
}
}
#line 33 "/home/ysko/Works/test-src/a2ps-4.14/lib/tterm.h"
void tterm_initialize(struct tterm *tterm , FILE *stream ) ;
#line 36
size_t tterm_width_set(struct tterm *tterm , size_t width ) ;
#line 39
size_t tterm_width(struct tterm *tterm ) ;
#line 42
size_t tterm_tabsize_set(struct tterm *tterm , size_t size ) ;
#line 45
size_t tterm_tabsize(struct tterm *tterm ) ;
#line 94 "/home/ysko/Works/test-src/a2ps-4.14/lib/tterm.c"
static struct tterm tterm_default  =    {(size_t )8, (size_t )80};
#line 102 "/home/ysko/Works/test-src/a2ps-4.14/lib/tterm.c"
size_t tterm_width_set(struct tterm *tterm , size_t width ) 
{ 
  struct tterm *t ;
  struct tterm *tmp ;
  size_t old ;

  {
#line 105
  if (tterm) {
#line 105
    tmp = tterm;
  } else {
#line 105
    tmp = & tterm_default;
  }
#line 105
  t = tmp;
#line 106
  old = t->width;
#line 107
  t->width = width;
#line 108
  return (old);
}
}
#line 114 "/home/ysko/Works/test-src/a2ps-4.14/lib/tterm.c"
size_t tterm_width(struct tterm *tterm ) 
{ 
  struct tterm *t ;
  struct tterm *tmp ;

  {
#line 117
  if (tterm) {
#line 117
    tmp = tterm;
  } else {
#line 117
    tmp = & tterm_default;
  }
#line 117
  t = tmp;
#line 118
  return (t->width);
}
}
#line 123 "/home/ysko/Works/test-src/a2ps-4.14/lib/tterm.c"
size_t tterm_tabsize_set(struct tterm *tterm , size_t size ) 
{ 
  struct tterm *t ;
  struct tterm *tmp ;
  size_t old ;

  {
#line 126
  if (tterm) {
#line 126
    tmp = tterm;
  } else {
#line 126
    tmp = & tterm_default;
  }
#line 126
  t = tmp;
#line 127
  old = t->tabsize;
#line 128
  t->tabsize = size;
#line 129
  return (old);
}
}
#line 135 "/home/ysko/Works/test-src/a2ps-4.14/lib/tterm.c"
size_t tterm_tabsize(struct tterm *tterm ) 
{ 
  struct tterm *t ;
  struct tterm *tmp ;

  {
#line 138
  if (tterm) {
#line 138
    tmp = tterm;
  } else {
#line 138
    tmp = & tterm_default;
  }
#line 138
  t = tmp;
#line 139
  return (t->tabsize);
}
}
#line 145 "/home/ysko/Works/test-src/a2ps-4.14/lib/tterm.c"
void tterm_initialize(struct tterm *tterm , FILE *stream ) 
{ 
  char const   *cp ;
  struct tterm *t ;
  struct tterm *tmp ;
  long tmp_long ;
  char *tmp___0 ;
  strtol_error tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  strtol_error tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 149
  if (tterm) {
#line 149
    tmp = tterm;
  } else {
#line 149
    tmp = & tterm_default;
  }
  {
#line 149
  t = tmp;
#line 153
  tmp___2 = getenv("COLUMNS");
#line 153
  cp = (char const   *)tmp___2;
  }
#line 153
  if (cp) {
#line 153
    if (*cp) {
      {
#line 155
      tmp___1 = xstrtol(cp, (char **)((void *)0), 0, & tmp_long, (char const   *)((void *)0));
      }
#line 155
      if ((unsigned int )tmp___1 == 0U) {
#line 155
        if (0L < tmp_long) {
#line 155
          if (tmp_long <= 2147483647L) {
#line 158
            t->width = (size_t )((int )tmp_long);
          } else {
            {
#line 162
            tmp___0 = quotearg(cp);
#line 162
            error(0, 0, "ignoring invalid width in environment variable COLUMNS: %s",
                  tmp___0);
            }
          }
        } else {
          {
#line 162
          tmp___0 = quotearg(cp);
#line 162
          error(0, 0, "ignoring invalid width in environment variable COLUMNS: %s",
                tmp___0);
          }
        }
      } else {
        {
#line 162
        tmp___0 = quotearg(cp);
#line 162
        error(0, 0, "ignoring invalid width in environment variable COLUMNS: %s",
              tmp___0);
        }
      }
    }
  }
  {
#line 180
  tmp___5 = getenv("POSIXLY_CORRECT");
  }
#line 180
  if (! tmp___5) {
    {
#line 180
    tmp___6 = getenv("TABSIZE");
#line 180
    cp = (char const   *)tmp___6;
    }
#line 180
    if (cp) {
#line 180
      if (*cp) {
        {
#line 182
        tmp___4 = xstrtol(cp, (char **)((void *)0), 0, & tmp_long, (char const   *)((void *)0));
        }
#line 182
        if ((unsigned int )tmp___4 == 0U) {
#line 182
          if (0L <= tmp_long) {
#line 182
            if (tmp_long <= 2147483647L) {
#line 185
              t->tabsize = (size_t )((int )tmp_long);
            } else {
              {
#line 189
              tmp___3 = quotearg(cp);
#line 189
              error(0, 0, "ignoring invalid tab size in environment variable TABSIZE: %s",
                    tmp___3);
              }
            }
          } else {
            {
#line 189
            tmp___3 = quotearg(cp);
#line 189
            error(0, 0, "ignoring invalid tab size in environment variable TABSIZE: %s",
                  tmp___3);
            }
          }
        } else {
          {
#line 189
          tmp___3 = quotearg(cp);
#line 189
          error(0, 0, "ignoring invalid tab size in environment variable TABSIZE: %s",
                tmp___3);
          }
        }
      }
    }
  }
#line 194
  return;
}
}
#line 219 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 348
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 34 "/home/ysko/Works/test-src/a2ps-4.14/lib/title.h"
void ( /* format attribute */  title)(FILE *stream , char c , int center_p , char const   *format 
                                      , ...) ;
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/printlen.h"
int vprintflen(char const   *format , va_list args ) ;
#line 64 "/home/ysko/Works/test-src/a2ps-4.14/lib/title.c"
void ( /* format attribute */  title)(FILE *stream , char c , int center_p , char const   *format 
                                      , ...) 
{ 
  int len ;
  int padding ;
  va_list args ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 83
  __builtin_va_start(args, format);
#line 85
  len = vprintflen(format, args);
#line 87
  __builtin_va_end(args);
#line 89
  tmp = (int )strlen(format);
  }
#line 89
  if ((int const   )*(format + (tmp - 1)) == 10) {
#line 90
    len --;
  }
#line 91
  if (center_p) {
#line 92
    padding = 0;
    {
#line 92
    while (1) {
      while_continue: /* CIL Label */ ;
#line 92
      if (! (padding < 79 - len)) {
#line 92
        goto while_break;
      }
      {
#line 93
      _IO_putc(' ', stream);
#line 92
      padding += 2;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 95
  __builtin_va_start(args, format);
#line 98
  vfprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)format,
           args);
#line 102
  __builtin_va_end(args);
#line 108
  tmp___0 = (int )strlen(format);
  }
#line 108
  if ((int const   )*(format + (tmp___0 - 1)) != 10) {
    {
#line 109
    _IO_putc('\n', stream);
    }
  }
#line 112
  if (center_p) {
#line 113
    padding = 0;
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 113
      if (! (padding < 79 - len)) {
#line 113
        goto while_break___0;
      }
      {
#line 114
      _IO_putc(' ', stream);
#line 113
      padding += 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 115
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 115
    if (! len) {
#line 115
      goto while_break___1;
    }
    {
#line 116
    _IO_putc((int )c, stream);
#line 115
    len --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 117
  _IO_putc('\n', stream);
#line 119
  fflush(stream);
  }
#line 120
  return;
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 56 "/home/ysko/Works/test-src/a2ps-4.14/lib/strverscmp.c"
int strverscmp(char const   *s1 , char const   *s2 ) ;
#line 56 "/home/ysko/Works/test-src/a2ps-4.14/lib/strverscmp.c"
static unsigned int const   next_state[16]  = 
#line 56
  {      (unsigned int const   )0,      (unsigned int const   )4,      (unsigned int const   )12,      (unsigned int const   )0, 
        (unsigned int const   )0,      (unsigned int const   )4,      (unsigned int const   )4,      (unsigned int const   )4, 
        (unsigned int const   )0,      (unsigned int const   )8,      (unsigned int const   )8,      (unsigned int const   )8, 
        (unsigned int const   )0,      (unsigned int const   )8,      (unsigned int const   )12,      (unsigned int const   )12};
#line 65 "/home/ysko/Works/test-src/a2ps-4.14/lib/strverscmp.c"
static int const   result_type[60]  = 
#line 65
  {      (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )3,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )-1,      (int const   )-1,      (int const   )2, 
        (int const   )1,      (int const   )3,      (int const   )3,      (int const   )2, 
        (int const   )1,      (int const   )3,      (int const   )3,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )3,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )-1,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )-1,      (int const   )2,      (int const   )2,      (int const   )2};
#line 45 "/home/ysko/Works/test-src/a2ps-4.14/lib/strverscmp.c"
int strverscmp(char const   *s1 , char const   *s2 ) 
{ 
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int state ;
  int diff ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned char const   *tmp___9 ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;

  {
#line 48
  p1 = (unsigned char const   *)s1;
#line 49
  p2 = (unsigned char const   *)s2;
#line 80
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 81
    return (0);
  }
  {
#line 83
  tmp = p1;
#line 83
  p1 ++;
#line 83
  c1 = (unsigned char )*tmp;
#line 84
  tmp___0 = p2;
#line 84
  p2 ++;
#line 84
  c2 = (unsigned char )*tmp___0;
#line 86
  tmp___1 = __ctype_b_loc();
#line 86
  state = ((int )c1 == 48) + (((int const   )*(*tmp___1 + (int )c1) & 2048) != 0);
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    diff = (int )c1 - (int )c2;
#line 88
    if (diff == 0) {
#line 88
      if (! ((int )c1 != 0)) {
#line 88
        goto while_break;
      }
    } else {
#line 88
      goto while_break;
    }
    {
#line 90
    state = (int )next_state[state];
#line 91
    tmp___2 = p1;
#line 91
    p1 ++;
#line 91
    c1 = (unsigned char )*tmp___2;
#line 92
    tmp___3 = p2;
#line 92
    p2 ++;
#line 92
    c2 = (unsigned char )*tmp___3;
#line 93
    tmp___4 = __ctype_b_loc();
#line 93
    state |= ((int )c1 == 48) + (((int const   )*(*tmp___4 + (int )c1) & 2048) != 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  tmp___5 = __ctype_b_loc();
#line 96
  state = (int )result_type[(state << 2) | (((int )c2 == 48) + (((int const   )*(*tmp___5 + (int )c2) & 2048) != 0))];
  }
  {
#line 100
  if (state == 2) {
#line 100
    goto case_2;
  }
#line 103
  if (state == 3) {
#line 103
    goto case_3;
  }
#line 110
  goto switch_default;
  case_2: /* CIL Label */ 
#line 101
  return (diff);
  case_3: /* CIL Label */ 
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 104
    tmp___8 = __ctype_b_loc();
#line 104
    tmp___9 = p1;
#line 104
    p1 ++;
    }
#line 104
    if (! ((int const   )*(*tmp___8 + (int )*tmp___9) & 2048)) {
#line 104
      goto while_break___0;
    }
    {
#line 105
    tmp___6 = __ctype_b_loc();
#line 105
    tmp___7 = p2;
#line 105
    p2 ++;
    }
#line 105
    if (! ((int const   )*(*tmp___6 + (int )*tmp___7) & 2048)) {
#line 106
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 108
  tmp___12 = __ctype_b_loc();
  }
#line 108
  if ((int const   )*(*tmp___12 + (int )*p2) & 2048) {
#line 108
    tmp___11 = -1;
  } else {
#line 108
    tmp___11 = diff;
  }
#line 108
  return (tmp___11);
  switch_default: /* CIL Label */ 
#line 111
  return (state);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 852
extern int pclose(FILE *__stream ) ;
#line 286 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 44 "/home/ysko/Works/test-src/a2ps-4.14/lib/stream.h"
struct stream *stream_ropen(char const   *command , _Bool is_file ) ;
#line 47
struct stream *stream_wopen(char const   *command , _Bool is_file ) ;
#line 50
struct stream *stream_wopen_backup(char const   *command , _Bool is_file , enum backup_type backup_type ) ;
#line 58
struct stream *stream_perl_open_backup(char const   *perl_command , enum backup_type backup ,
                                       char const   **name ) ;
#line 63
void stream_close(struct stream *stream ) ;
#line 245 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.h"
FILE *xrfopen(char const   *filename ) ;
#line 252
FILE *xrpopen(char const   *filename ) ;
#line 253
FILE *xwpopen(char const   *filename ) ;
#line 23 "/home/ysko/Works/test-src/a2ps-4.14/lib/message.h"
unsigned int msg_verbosity ;
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/lib/stream.c"
__inline static struct stream *_stream_ropen(char const   *command , _Bool is_file ) 
{ 
  struct stream *res___2 ;
  void *tmp ;

  {
  {
#line 45
  tmp = xmalloc((size_t )sizeof(struct stream ));
#line 45
  res___2 = (struct stream *)tmp;
#line 47
  res___2->is_file = is_file;
  }
#line 48
  if (! res___2->is_file) {
    {
#line 49
    res___2->fp = xrpopen(command);
    }
  } else
#line 52
  if ((unsigned long )command == (unsigned long )((void *)0)) {
#line 55
    res___2->fp = stdin;
  } else
#line 52
  if ((int const   )*command == 0) {
#line 55
    res___2->fp = stdin;
  } else {
    {
#line 53
    res___2->fp = xrfopen(command);
    }
  }
#line 57
  return (res___2);
}
}
#line 63 "/home/ysko/Works/test-src/a2ps-4.14/lib/stream.c"
struct stream *stream_ropen(char const   *command , _Bool is_file ) 
{ 
  struct stream *tmp ;

  {
  {
#line 66
  tmp = _stream_ropen(command, is_file);
  }
#line 66
  return (tmp);
}
}
#line 72 "/home/ysko/Works/test-src/a2ps-4.14/lib/stream.c"
__inline static struct stream *_stream_wopen(char const   *command , _Bool is_file ,
                                             enum backup_type backup_type ) 
{ 
  struct stream *res___2 ;
  void *tmp ;

  {
  {
#line 76
  tmp = xmalloc((size_t )sizeof(struct stream ));
#line 76
  res___2 = (struct stream *)tmp;
#line 78
  res___2->is_file = is_file;
  }
#line 79
  if (! res___2->is_file) {
    {
#line 80
    res___2->fp = xwpopen(command);
    }
  } else
#line 83
  if ((unsigned long )command == (unsigned long )((void *)0)) {
#line 86
    res___2->fp = stdout;
  } else
#line 83
  if ((int const   )*command == 0) {
#line 86
    res___2->fp = stdout;
  } else {
    {
#line 84
    res___2->fp = fopen_backup(command, backup_type);
    }
  }
#line 88
  return (res___2);
}
}
#line 94 "/home/ysko/Works/test-src/a2ps-4.14/lib/stream.c"
struct stream *stream_wopen(char const   *command , _Bool is_file ) 
{ 
  struct stream *tmp ;

  {
  {
#line 97
  tmp = _stream_wopen(command, is_file, (enum backup_type )0);
  }
#line 97
  return (tmp);
}
}
#line 100 "/home/ysko/Works/test-src/a2ps-4.14/lib/stream.c"
struct stream *stream_wopen_backup(char const   *command , _Bool is_file , enum backup_type backup_type ) 
{ 
  struct stream *tmp ;

  {
  {
#line 104
  tmp = _stream_wopen(command, is_file, backup_type);
  }
#line 104
  return (tmp);
}
}
#line 119 "/home/ysko/Works/test-src/a2ps-4.14/lib/stream.c"
struct stream *stream_perl_open_backup(char const   *perl_command , enum backup_type backup ,
                                       char const   **name ) 
{ 
  char *cp ;
  int len ;
  char *tmp ;
  size_t tmp___0 ;
  struct stream *tmp___1 ;
  struct stream *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  struct stream *tmp___5 ;
  struct stream *tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 127
  if (! perl_command) {
    {
#line 127
    __assert_fail("perl_command", "/home/ysko/Works/test-src/a2ps-4.14/lib/stream.c",
                  127U, "stream_perl_open_backup");
    }
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if ((unsigned int )(1 << 6) & msg_verbosity) {
      {
#line 128
      tmp = quotearg(perl_command);
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"perl-open (%s)\n",
              tmp);
      }
    }
#line 128
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = strspn(perl_command, "\t >|");
#line 131
  *name = perl_command + tmp___0;
  }
  {
#line 135
  if ((int const   )*perl_command == 124) {
#line 135
    goto case_124;
  }
#line 138
  if ((int const   )*perl_command == 62) {
#line 138
    goto case_62;
  }
#line 141
  goto switch_default;
  case_124: /* CIL Label */ 
  {
#line 136
  tmp___1 = _stream_wopen(*name, (_Bool)0, (enum backup_type )0);
  }
#line 136
  return (tmp___1);
  case_62: /* CIL Label */ 
  {
#line 139
  tmp___2 = _stream_wopen(*name, (_Bool)1, backup);
  }
#line 139
  return (tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 143
  tmp___3 = strlen(perl_command);
#line 143
  len = (int )tmp___3;
  }
  {
#line 146
  if ((int const   )*(perl_command + (len - 1)) == 124) {
#line 146
    goto case_124___0;
  }
#line 152
  goto switch_default___0;
  case_124___0: /* CIL Label */ 
  {
#line 148
  tmp___4 = __builtin_alloca(sizeof(char ) * (unsigned long )len);
#line 148
  cp = (char *)tmp___4;
#line 149
  strncpy((char */* __restrict  */)cp, (char const   */* __restrict  */)*name, (size_t )(len - 1));
#line 150
  tmp___5 = _stream_ropen((char const   *)cp, (_Bool)0);
  }
#line 150
  return (tmp___5);
  switch_default___0: /* CIL Label */ 
  {
#line 154
  tmp___6 = _stream_ropen(*name, (_Bool)1);
  }
#line 154
  return (tmp___6);
  switch_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 162 "/home/ysko/Works/test-src/a2ps-4.14/lib/stream.c"
void stream_close(struct stream *stream ) 
{ 


  {
#line 165
  if (stream->is_file) {
    {
#line 166
    fclose(stream->fp);
    }
  } else {
    {
#line 168
    pclose(stream->fp);
    }
  }
  {
#line 169
  free((void *)stream);
  }
#line 170
  return;
}
}
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.h"
struct hash_table_s *string_htable_new(void) ;
#line 43
void string_htable_free(struct hash_table_s *table ) ;
#line 48
void string_htable_add(struct hash_table_s *table , char const   *key ) ;
#line 50
char *string_htable_get(struct hash_table_s *table , char const   *key ) ;
#line 56
void string_htable_self_print(struct hash_table_s *table , FILE *stream ) ;
#line 58
char **string_htable_dump_sorted(struct hash_table_s *table ) ;
#line 63 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.h"
void hash_init(struct hash_table_s *ht , unsigned long size , unsigned long (*hash_1)(void const   *key ) ,
               unsigned long (*hash_2)(void const   *key ) , int (*hash_cmp)(void const   *x ,
                                                                             void const   *y ) ) ;
#line 68
void *hash_find_item(struct hash_table_s *ht , void const   *key ) ;
#line 69
void *hash_insert(struct hash_table_s *ht , void *item ) ;
#line 75
void hash_free(struct hash_table_s *ht , void (*free_fn)(void const   *item ) ) ;
#line 80
void **hash_dump(struct hash_table_s *ht , void **vector_0 , int (*compare)(void const   * ,
                                                                            void const   * ) ) ;
#line 46 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.c"
static unsigned long string_hash_1(char *string ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    result = 0UL;
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 49
      kk = (unsigned char const   *)string - 1;
      {
#line 49
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 49
        kk ++;
#line 49
        if (! *kk) {
#line 49
          goto while_break___1;
        }
#line 49
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 49
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 49
    return (result);
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (0UL);
}
}
#line 52 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.c"
static unsigned long string_hash_2(char *string ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    result = 0UL;
    {
#line 55
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 55
      kk = (unsigned char const   *)string - 1;
      {
#line 55
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 55
        kk ++;
#line 55
        if (! *kk) {
#line 55
          goto while_break___1;
        }
#line 55
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 55
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 55
    return (result);
#line 55
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (0UL);
}
}
#line 58 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.c"
static int string_hash_cmp(char *x , char *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 61
      xx = (unsigned char const   *)x - 1;
#line 61
      yy = (unsigned char const   *)y - 1;
      {
#line 61
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 61
        xx ++;
#line 61
        if ((int const   )*xx == 0) {
#line 61
          yy ++;
#line 61
          goto while_break___1;
        }
#line 61
        yy ++;
#line 61
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 61
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 61
      result = (int )((int const   )*xx - (int const   )*yy);
#line 61
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    return (result);
#line 61
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return (0);
}
}
#line 67 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.c"
static int string_hash_qcmp(char **x , char **y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 70
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 70
      xx = (unsigned char const   *)*x - 1;
#line 70
      yy = (unsigned char const   *)*y - 1;
      {
#line 70
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 70
        xx ++;
#line 70
        if ((int const   )*xx == 0) {
#line 70
          yy ++;
#line 70
          goto while_break___1;
        }
#line 70
        yy ++;
#line 70
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 70
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 70
      result = (int )((int const   )*xx - (int const   )*yy);
#line 70
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 70
    return (result);
#line 70
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (0);
}
}
#line 76 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.c"
struct hash_table_s *string_htable_new(void) 
{ 
  struct hash_table_s *res___2 ;
  void *tmp ;

  {
  {
#line 81
  tmp = xmalloc((size_t )sizeof(struct hash_table_s ));
#line 81
  res___2 = (struct hash_table_s *)tmp;
#line 82
  hash_init(res___2, 8UL, (unsigned long (*)(void const   *key ))(& string_hash_1),
            (unsigned long (*)(void const   *key ))(& string_hash_2), (int (*)(void const   *x ,
                                                                               void const   *y ))(& string_hash_cmp));
  }
#line 86
  return (res___2);
}
}
#line 92 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.c"
void string_htable_free(struct hash_table_s *table ) 
{ 


  {
  {
#line 95
  hash_free(table, (void (*)(void const   *item ))(& free));
#line 96
  free((void *)table);
  }
#line 97
  return;
}
}
#line 102 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.c"
void string_htable_add(struct hash_table_s *table , char const   *key ) 
{ 
  char *tmp ;
  void *tmp___0 ;

  {
  {
#line 105
  tmp___0 = hash_find_item(table, (void const   *)key);
  }
#line 105
  if (! tmp___0) {
    {
#line 106
    tmp = xstrdup(key);
#line 106
    hash_insert(table, (void *)tmp);
    }
  }
#line 107
  return;
}
}
#line 114 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.c"
char *string_htable_get(struct hash_table_s *table , char const   *key ) 
{ 
  void *tmp ;

  {
  {
#line 117
  tmp = hash_find_item(table, (void const   *)key);
  }
#line 117
  return ((char *)tmp);
}
}
#line 123 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.c"
void string_htable_self_print(struct hash_table_s *table , FILE *stream ) 
{ 
  int i ;
  char **entries ;
  void **tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 128
  tmp = hash_dump(table, (void **)((void *)0), (int (*)(void const   *x , void const   *y ))(& string_hash_qcmp));
#line 128
  entries = (char **)tmp;
#line 132
  i = 0;
  }
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! *(entries + i)) {
#line 132
      goto while_break;
    }
    {
#line 133
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s\n",
            *(entries + i));
#line 132
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  _IO_putc('\n', stream);
#line 136
  free((void *)entries);
  }
#line 137
  return;
}
}
#line 142 "/home/ysko/Works/test-src/a2ps-4.14/lib/str_ht.c"
char **string_htable_dump_sorted(struct hash_table_s *table ) 
{ 
  void **tmp ;

  {
  {
#line 145
  tmp = hash_dump(table, (void **)((void *)0), (int (*)(void const   * , void const   * ))(& string_hash_qcmp));
  }
#line 145
  return ((char **)tmp);
}
}
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 23 "/home/ysko/Works/test-src/a2ps-4.14/lib/signame.h"
void signame_init(void) ;
#line 28
char *sig_abbrev(int number ) ;
#line 32
int sig_number(char const   *abbrev ) ;
#line 78 "/home/ysko/Works/test-src/a2ps-4.14/lib/signame.c"
static num_abbrev sig_table[130]  ;
#line 80 "/home/ysko/Works/test-src/a2ps-4.14/lib/signame.c"
static int sig_table_nelts  =    0;
#line 84 "/home/ysko/Works/test-src/a2ps-4.14/lib/signame.c"
static void init_sig(int number , char const   *abbrev , char const   *name ) 
{ 
  int tmp ;

  {
#line 93
  sig_table[sig_table_nelts].number = number;
#line 94
  tmp = sig_table_nelts;
#line 94
  sig_table_nelts ++;
#line 94
  sig_table[tmp].abbrev = abbrev;
#line 95
  return;
}
}
#line 97 "/home/ysko/Works/test-src/a2ps-4.14/lib/signame.c"
void signame_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
  {
#line 109
  init_sig(1, "HUP", "Hangup");
#line 112
  init_sig(2, "INT", "Interrupt");
#line 115
  init_sig(3, "QUIT", "Quit");
#line 118
  init_sig(4, "ILL", "Illegal Instruction");
#line 121
  init_sig(5, "TRAP", "Trace/breakpoint trap");
#line 126
  init_sig(6, "ABRT", "Aborted");
#line 129
  init_sig(6, "IOT", "IOT trap");
#line 135
  init_sig(8, "FPE", "Floating point exception");
#line 138
  init_sig(9, "KILL", "Killed");
#line 141
  init_sig(7, "BUS", "Bus error");
#line 144
  init_sig(11, "SEGV", "Segmentation fault");
#line 147
  init_sig(31, "SYS", "Bad system call");
#line 150
  init_sig(13, "PIPE", "Broken pipe");
#line 153
  init_sig(14, "ALRM", "Alarm clock");
#line 156
  init_sig(15, "TERM", "Terminated");
#line 159
  init_sig(10, "USR1", "User defined signal 1");
#line 162
  init_sig(12, "USR2", "User defined signal 2");
#line 167
  init_sig(17, "CHLD", "Child exited");
#line 170
  init_sig(17, "CLD", "Child exited");
#line 173
  init_sig(30, "PWR", "Power failure");
#line 176
  init_sig(20, "TSTP", "Stopped");
#line 179
  init_sig(21, "TTIN", "Stopped (tty input)");
#line 182
  init_sig(22, "TTOU", "Stopped (tty output)");
#line 185
  init_sig(19, "STOP", "Stopped (signal)");
#line 188
  init_sig(24, "XCPU", "CPU time limit exceeded");
#line 191
  init_sig(25, "XFSZ", "File size limit exceeded");
#line 194
  init_sig(26, "VTALRM", "Virtual timer expired");
#line 197
  init_sig(27, "PROF", "Profiling timer expired");
#line 203
  init_sig(28, "WINCH", "Window changed");
#line 206
  init_sig(18, "CONT", "Continued");
#line 209
  init_sig(23, "URG", "Urgent I/O condition");
#line 216
  init_sig(29, "IO", "I/O possible");
#line 225
  init_sig(29, "POLL", "I/O possible");
  }
#line 239
  return;
}
}
#line 243 "/home/ysko/Works/test-src/a2ps-4.14/lib/signame.c"
char *sig_abbrev(int number ) 
{ 
  int i ;

  {
#line 249
  if (sig_table_nelts == 0) {
    {
#line 250
    signame_init();
    }
  }
#line 252
  i = 0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i < sig_table_nelts)) {
#line 252
      goto while_break;
    }
#line 253
    if (sig_table[i].number == number) {
#line 254
      return ((char *)sig_table[i].abbrev);
    }
#line 252
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((char *)((void *)0));
}
}
#line 261 "/home/ysko/Works/test-src/a2ps-4.14/lib/signame.c"
int sig_number(char const   *abbrev ) 
{ 
  int i ;
  int tmp ;

  {
#line 267
  if (sig_table_nelts == 0) {
    {
#line 268
    signame_init();
    }
  }
#line 271
  if ((int const   )*(abbrev + 0) == 83) {
#line 271
    if ((int const   )*(abbrev + 1) == 73) {
#line 271
      if ((int const   )*(abbrev + 2) == 71) {
#line 272
        abbrev += 3;
      }
    }
  }
#line 274
  i = 0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < sig_table_nelts)) {
#line 274
      goto while_break;
    }
#line 275
    if ((int const   )*(abbrev + 0) == (int const   )*(sig_table[i].abbrev + 0)) {
      {
#line 275
      tmp = strcmp(abbrev, sig_table[i].abbrev);
      }
#line 275
      if (tmp == 0) {
#line 277
        return (sig_table[i].number);
      }
    }
#line 274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  return (-1);
}
}
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 577 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) stpncpy)(char * __restrict  dest ,
                                                                                        char const   * __restrict  src ,
                                                                                        size_t n ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 834 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 222 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.h"
void string_to_array(unsigned char *arr , unsigned char const   *string ) ;
#line 223
int is_strlower(unsigned char const   *string ) ;
#line 224
unsigned char *strnlower(unsigned char *string , size_t len ) ;
#line 225
unsigned char *strlower(unsigned char *string ) ;
#line 226
unsigned char *strcpylc(unsigned char *dst , unsigned char const   *src ) ;
#line 228
void ustrccat(unsigned char *string , unsigned char c ) ;
#line 229
int strcnt(unsigned char *s , unsigned char c ) ;
#line 230
char *strsub(char *dest , char const   *string , int start , int length ) ;
#line 234
void streams_copy(FILE *in , FILE *out ) ;
#line 237
void stream_dump(FILE *stream , char const   *filename ) ;
#line 239
void unlink2(void *dummy  __attribute__((__unused__)) , char const   *filename ) ;
#line 242
FILE *xfopen(char const   *filename , char const   *rights , char const   *format ) ;
#line 246
FILE *xwfopen(char const   *filename ) ;
#line 249
FILE *xpopen(char const   *filename , char const   *rights , char const   *format ) ;
#line 39 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
void string_to_array(unsigned char *arr , unsigned char const   *string ) 
{ 
  int c ;

  {
#line 44
  c = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (c < 256)) {
#line 44
      goto while_break;
    }
#line 45
    *(arr + c) = (unsigned char)0;
#line 44
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 46
    if (! *string) {
#line 46
      goto while_break___0;
    }
#line 47
    *(arr + *string) = (unsigned char)1;
#line 46
    string ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 53 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
void ustrccat(unsigned char *string , unsigned char c ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 56
  tmp = strlen((char const   *)((char *)string));
#line 56
  len = (int )tmp;
#line 57
  *(string + len) = c;
#line 58
  *((string + len) + 1) = (unsigned char )'\000';
  }
#line 59
  return;
}
}
#line 64 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
int is_strlower(unsigned char const   *string ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! ((int const   )*string != 0)) {
#line 67
      goto while_break;
    }
    {
#line 68
    tmp = __ctype_b_loc();
    }
#line 68
    if ((int const   )*(*tmp + (int )*string) & 256) {
#line 69
      return (0);
    }
#line 67
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return (1);
}
}
#line 76 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
__inline static unsigned char *_strncpylc(unsigned char *dst , unsigned char const   *src ,
                                          size_t len ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 80
  i = (size_t )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < len)) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = tolower((int )*(src + i));
#line 81
    *(dst + i) = (unsigned char )tmp;
#line 80
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  *(dst + len) = (unsigned char )'\000';
#line 83
  return (dst);
}
}
#line 86 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
unsigned char *strnlower(unsigned char *string , size_t len ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 89
  tmp = _strncpylc(string, (unsigned char const   *)string, len);
  }
#line 89
  return (tmp);
}
}
#line 92 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
unsigned char *strlower(unsigned char *string ) 
{ 
  size_t tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 95
  tmp = strlen((char const   *)string);
#line 95
  tmp___0 = _strncpylc(string, (unsigned char const   *)string, tmp);
  }
#line 95
  return (tmp___0);
}
}
#line 98 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
unsigned char *strcpylc(unsigned char *dst , unsigned char const   *src ) 
{ 
  size_t tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 101
  tmp = strlen((char const   *)src);
#line 101
  tmp___0 = _strncpylc(dst, src, tmp);
  }
#line 101
  return (tmp___0);
}
}
#line 107 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
int strcnt(unsigned char *s , unsigned char c ) 
{ 
  int res___2 ;

  {
#line 111
  res___2 = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! *s) {
#line 111
      goto while_break;
    }
#line 112
    if ((int )*s == (int )c) {
#line 113
      res___2 ++;
    }
#line 111
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return (res___2);
}
}
#line 121 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
char *strsub(char *dest , char const   *string , int start , int length ) 
{ 
  char *end ;
  char *tmp ;

  {
  {
#line 124
  tmp = stpncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)(string + start),
                (size_t )length);
#line 124
  end = tmp;
#line 125
  *end = (char )'\000';
  }
#line 126
  return (end);
}
}
#line 132 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
__inline static FILE *_xfopen(char const   *filename , char const   *rights , char const   *format ) 
{ 
  FILE *res___2 ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if ((unsigned int )(1 << 6) & msg_verbosity) {
      {
#line 137
      tmp = quotearg(filename);
#line 137
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s-fopen (%s)\n",
              rights, tmp);
      }
    }
#line 137
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  res___2 = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)rights);
  }
#line 140
  if (! res___2) {
    {
#line 141
    tmp___0 = quotearg(filename);
#line 141
    tmp___1 = __errno_location();
#line 141
    error(1, *tmp___1, format, tmp___0);
    }
  }
#line 142
  return (res___2);
}
}
#line 145 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
FILE *xfopen(char const   *filename , char const   *rights , char const   *format ) 
{ 
  FILE *tmp ;

  {
  {
#line 148
  tmp = _xfopen(filename, rights, format);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
FILE *xrfopen(char const   *filename ) 
{ 
  char *tmp ;
  FILE *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 154
  tmp = gettext("cannot open file `%s\'");
#line 154
  tmp___0 = _xfopen(filename, "r", (char const   *)tmp);
  }
#line 154
  return (tmp___0);
}
}
#line 157 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
FILE *xwfopen(char const   *filename ) 
{ 
  char *tmp ;
  FILE *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 160
  tmp = gettext("cannot create file `%s\'");
#line 160
  tmp___0 = _xfopen(filename, "w", (char const   *)tmp);
  }
#line 160
  return (tmp___0);
}
}
#line 168 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
__inline static FILE *_xpopen(char const   *filename , char const   *rights , char const   *format ) 
{ 
  FILE *res___2 ;
  char *tmp ;
  int *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if ((unsigned int )(1 << 6) & msg_verbosity) {
      {
#line 173
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s-popen (%s)\n",
              rights, filename);
      }
    }
#line 173
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  res___2 = popen(filename, rights);
  }
#line 176
  if (! res___2) {
    {
#line 177
    tmp = quotearg(filename);
#line 177
    tmp___0 = __errno_location();
#line 177
    error(1, *tmp___0, format, tmp);
    }
  }
#line 178
  return (res___2);
}
}
#line 181 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
FILE *xpopen(char const   *filename , char const   *rights , char const   *format ) 
{ 
  FILE *tmp ;

  {
  {
#line 184
  tmp = _xpopen(filename, rights, format);
  }
#line 184
  return (tmp);
}
}
#line 187 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
FILE *xrpopen(char const   *filename ) 
{ 
  char *tmp ;
  FILE *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 190
  tmp = gettext("cannot open a pipe on `%s\'");
#line 190
  tmp___0 = _xpopen(filename, "r", (char const   *)tmp);
  }
#line 190
  return (tmp___0);
}
}
#line 193 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
FILE *xwpopen(char const   *filename ) 
{ 
  char *tmp ;
  FILE *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 196
  tmp = gettext("cannot open a pipe on `%s\'");
#line 196
  tmp___0 = _xpopen(filename, "w", (char const   *)tmp);
  }
#line 196
  return (tmp___0);
}
}
#line 202 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
__inline static void _streams_copy(FILE *in , FILE *out ) 
{ 
  size_t read_length ;
  char buf___0[8192] ;
  void *__cil_tmp5 ;

  {
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 208
    read_length = fread((void */* __restrict  */)(buf___0), (size_t )sizeof(char ),
                        (size_t )sizeof(buf___0), (FILE */* __restrict  */)in);
    }
#line 208
    if (! read_length) {
#line 208
      goto while_break;
    }
    {
#line 209
    fwrite((void const   */* __restrict  */)(buf___0), (size_t )sizeof(char ), read_length,
           (FILE */* __restrict  */)out);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return;
}
}
#line 212 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
void streams_copy(FILE *in , FILE *out ) 
{ 


  {
  {
#line 215
  _streams_copy(in, out);
  }
#line 216
  return;
}
}
#line 222 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
void stream_dump(FILE *stream , char const   *filename ) 
{ 
  FILE *fp ;
  char *__cil_tmp4 ;

  {
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if ((unsigned int )((1 << 7) | (1 << 6)) & msg_verbosity) {
      {
#line 227
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dumping file `%s\'\n",
              filename);
      }
    }
#line 227
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  fp = xrfopen(filename);
#line 230
  _streams_copy(fp, stream);
#line 231
  fclose(fp);
  }
#line 232
  return;
}
}
#line 237 "/home/ysko/Works/test-src/a2ps-4.14/lib/routines.c"
void unlink2(void *dummy  __attribute__((__unused__)) , char const   *filename ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if ((unsigned int )((1 << 7) | (1 << 6)) & msg_verbosity) {
      {
#line 240
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unlinking file `%s\'\n",
              filename);
      }
    }
#line 240
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 243
  unlink(filename);
  }
#line 244
  return;
}
}
#line 37 "./quotearg.h"
char const   * const  quoting_style_args[7] ;
#line 38
enum quoting_style  const  quoting_style_vals[6] ;
#line 56
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 60
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 64
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 72
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 82
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 91
char *quotearg_n(unsigned int n , char const   *arg ) ;
#line 99
char *quotearg_n_style(unsigned int n , enum quoting_style s , char const   *arg ) ;
#line 103
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 106
char *quotearg_char(char const   *arg , char ch ) ;
#line 109
char *quotearg_colon(char const   *arg ) ;
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 67
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 359 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 363
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 84 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
char const   * const  quoting_style_args[7]  = {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)0};
#line 96 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[6]  = {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5};
#line 107 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 112 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  struct quoting_options *p ;
  void *tmp ;
  struct quoting_options *tmp___0 ;

  {
  {
#line 115
  tmp = xmalloc((size_t )sizeof(struct quoting_options ));
#line 115
  p = (struct quoting_options *)tmp;
  }
#line 117
  if (o) {
#line 117
    tmp___0 = o;
  } else {
#line 117
    tmp___0 = & default_quoting_options;
  }
#line 117
  *p = *tmp___0;
#line 118
  return (p);
}
}
#line 122 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 125
  if (o) {
#line 125
    tmp = o;
  } else {
#line 125
    tmp = & default_quoting_options;
  }
#line 125
  return (tmp->style);
}
}
#line 130 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 133
  if (o) {
#line 133
    tmp = o;
  } else {
#line 133
    tmp = & default_quoting_options;
  }
#line 133
  tmp->style = s;
#line 134
  return;
}
}
#line 141 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 144
  uc = (unsigned char )c;
#line 145
  if (o) {
#line 145
    tmp = o;
  } else {
#line 145
    tmp = & default_quoting_options;
  }
#line 145
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 146
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 147
  r = (*p >> shift) & 1;
#line 148
  *p ^= ((i & 1) ^ r) << shift;
#line 149
  return (r);
}
}
#line 372
extern int ( /* missing proto */  iswprint)() ;
#line 165 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       struct quoting_options  const  *o ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  int backslash_escapes ;
  char *tmp ;
  char *tmp___0 ;
  unsigned char c ;
  unsigned char esc ;
  int tmp___1 ;
  size_t m ;
  int printable ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  size_t imax ;
  int tmp___7 ;
  size_t tmp___8 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 172
  len = (size_t )0;
#line 173
  quote_string = (char const   *)0;
#line 174
  quote_string_len = (size_t )0;
#line 175
  backslash_escapes = 0;
  {
#line 188
  if ((unsigned int )quoting_style == 3U) {
#line 188
    goto case_3;
  }
#line 195
  if ((unsigned int )quoting_style == 4U) {
#line 195
    goto case_4;
  }
#line 199
  if ((unsigned int )quoting_style == 5U) {
#line 199
    goto case_5;
  }
#line 207
  if ((unsigned int )quoting_style == 2U) {
#line 207
    goto case_2;
  }
#line 213
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (len < buffersize) {
#line 189
      *(buffer + len) = (char )'\"';
    }
#line 189
    len ++;
#line 189
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  backslash_escapes = 1;
#line 191
  quote_string = "\"";
#line 192
  quote_string_len = (size_t )1;
#line 193
  goto switch_break;
  case_4: /* CIL Label */ 
#line 196
  backslash_escapes = 1;
#line 197
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 200
  tmp = gettext("`");
#line 200
  quote_string = (char const   *)tmp;
  }
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    if (! *quote_string) {
#line 200
      goto while_break___0;
    }
    {
#line 201
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 201
      if (len < buffersize) {
#line 201
        *(buffer + len) = (char )*quote_string;
      }
#line 201
      len ++;
#line 201
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 200
    quote_string ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 202
  backslash_escapes = 1;
#line 203
  tmp___0 = gettext("\'");
#line 203
  quote_string = (char const   *)tmp___0;
#line 204
  quote_string_len = strlen(quote_string);
  }
#line 205
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 208
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 208
    if (len < buffersize) {
#line 208
      *(buffer + len) = (char )'\'';
    }
#line 208
    len ++;
#line 208
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 209
  quote_string = "\'";
#line 210
  quote_string_len = (size_t )1;
#line 211
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 214
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 217
  i = (size_t )0;
  {
#line 217
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 217
    if (argsize == 4294967295U) {
#line 217
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 217
      tmp___7 = i == argsize;
    }
#line 217
    if (tmp___7) {
#line 217
      goto while_break___3;
    }
#line 222
    if (backslash_escapes) {
#line 222
      if (quote_string_len) {
#line 222
        if (i + quote_string_len <= argsize) {
          {
#line 222
          tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 222
          if (tmp___1 == 0) {
            {
#line 226
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 226
              if (len < buffersize) {
#line 226
                *(buffer + len) = (char )'\\';
              }
#line 226
              len ++;
#line 226
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 228
    c = (unsigned char )*(arg + i);
    {
#line 231
    if ((int )c == 63) {
#line 231
      goto case_63;
    }
#line 261
    if ((int )c == 7) {
#line 261
      goto case_7;
    }
#line 263
    if ((int )c == 8) {
#line 263
      goto case_8;
    }
#line 264
    if ((int )c == 12) {
#line 264
      goto case_12;
    }
#line 265
    if ((int )c == 10) {
#line 265
      goto case_10;
    }
#line 266
    if ((int )c == 13) {
#line 266
      goto case_13;
    }
#line 267
    if ((int )c == 9) {
#line 267
      goto case_9;
    }
#line 268
    if ((int )c == 11) {
#line 268
      goto case_11;
    }
#line 269
    if ((int )c == 92) {
#line 269
      goto case_92;
    }
#line 281
    if ((int )c == 126) {
#line 281
      goto case_126;
    }
#line 281
    if ((int )c == 35) {
#line 281
      goto case_126;
    }
#line 291
    if ((int )c == 124) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 96) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 94) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 91) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 62) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 60) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 59) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 42) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 41) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 40) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 38) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 36) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 34) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 33) {
#line 291
      goto case_124;
    }
#line 291
    if ((int )c == 32) {
#line 291
      goto case_124;
    }
#line 300
    if ((int )c == 39) {
#line 300
      goto case_39___0;
    }
#line 329
    if ((int )c == 125) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 123) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 122) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 121) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 120) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 119) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 118) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 117) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 116) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 115) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 114) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 113) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 112) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 111) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 110) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 109) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 108) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 107) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 106) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 105) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 104) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 103) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 102) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 101) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 100) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 99) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 98) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 97) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 95) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 93) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 90) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 89) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 88) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 87) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 86) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 85) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 84) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 83) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 82) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 81) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 80) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 79) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 78) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 77) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 76) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 75) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 74) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 73) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 72) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 71) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 70) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 69) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 68) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 67) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 66) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 65) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 61) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 58) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 57) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 56) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 55) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 54) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 53) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 52) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 51) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 50) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 49) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 48) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 47) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 46) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 45) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 44) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 43) {
#line 329
      goto case_125;
    }
#line 329
    if ((int )c == 37) {
#line 329
      goto case_125;
    }
#line 334
    goto switch_default___2;
    case_63: /* CIL Label */ 
    {
#line 234
    if ((unsigned int )quoting_style == 1U) {
#line 234
      goto case_1;
    }
#line 237
    if ((unsigned int )quoting_style == 3U) {
#line 237
      goto case_3___0;
    }
#line 255
    goto switch_default___0;
    case_1: /* CIL Label */ 
#line 235
    goto use_shell_always_quoting_style;
    case_3___0: /* CIL Label */ 
#line 238
    if (i + 2U < argsize) {
#line 238
      if ((int const   )*(arg + (i + 1U)) == 63) {
        {
#line 243
        if ((int const   )*(arg + (i + 2U)) == 62) {
#line 243
          goto case_62;
        }
#line 243
        if ((int const   )*(arg + (i + 2U)) == 61) {
#line 243
          goto case_62;
        }
#line 243
        if ((int const   )*(arg + (i + 2U)) == 60) {
#line 243
          goto case_62;
        }
#line 243
        if ((int const   )*(arg + (i + 2U)) == 47) {
#line 243
          goto case_62;
        }
#line 243
        if ((int const   )*(arg + (i + 2U)) == 45) {
#line 243
          goto case_62;
        }
#line 243
        if ((int const   )*(arg + (i + 2U)) == 41) {
#line 243
          goto case_62;
        }
#line 243
        if ((int const   )*(arg + (i + 2U)) == 40) {
#line 243
          goto case_62;
        }
#line 243
        if ((int const   )*(arg + (i + 2U)) == 39) {
#line 243
          goto case_62;
        }
#line 243
        if ((int const   )*(arg + (i + 2U)) == 33) {
#line 243
          goto case_62;
        }
#line 239
        goto switch_break___2;
        case_62: /* CIL Label */ 
        case_61: /* CIL Label */ 
        case_60: /* CIL Label */ 
        case_47: /* CIL Label */ 
        case_45: /* CIL Label */ 
        case_41: /* CIL Label */ 
        case_40: /* CIL Label */ 
        case_39: /* CIL Label */ 
        case_33: /* CIL Label */ 
#line 246
        i += 2U;
#line 247
        c = (unsigned char )*(arg + (i + 2U));
        {
#line 248
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 248
          if (len < buffersize) {
#line 248
            *(buffer + len) = (char )'?';
          }
#line 248
          len ++;
#line 248
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 249
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 249
          if (len < buffersize) {
#line 249
            *(buffer + len) = (char )'\\';
          }
#line 249
          len ++;
#line 249
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 250
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 250
          if (len < buffersize) {
#line 250
            *(buffer + len) = (char )'?';
          }
#line 250
          len ++;
#line 250
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 251
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
      }
    }
#line 253
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 256
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 258
    goto switch_break___0;
    case_7: /* CIL Label */ 
#line 261
    esc = (unsigned char )'a';
#line 261
    goto c_escape;
    case_8: /* CIL Label */ 
#line 263
    esc = (unsigned char )'b';
#line 263
    goto c_escape;
    case_12: /* CIL Label */ 
#line 264
    esc = (unsigned char )'f';
#line 264
    goto c_escape;
    case_10: /* CIL Label */ 
#line 265
    esc = (unsigned char )'n';
#line 265
    goto c_escape;
    case_13: /* CIL Label */ 
#line 266
    esc = (unsigned char )'r';
#line 266
    goto c_escape;
    case_9: /* CIL Label */ 
#line 267
    esc = (unsigned char )'t';
#line 267
    goto c_escape;
    case_11: /* CIL Label */ 
#line 268
    esc = (unsigned char )'v';
#line 268
    goto c_escape;
    case_92: /* CIL Label */ 
#line 269
    esc = c;
#line 269
    goto c_escape;
    c_escape: 
#line 272
    if (backslash_escapes) {
#line 274
      c = esc;
#line 275
      goto store_escape;
    }
#line 277
    if ((unsigned int )quoting_style == 1U) {
#line 278
      goto use_shell_always_quoting_style;
    }
#line 279
    goto switch_break___0;
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 282
    if (i != 0U) {
#line 283
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 296
    if ((unsigned int )quoting_style == 1U) {
#line 297
      goto use_shell_always_quoting_style;
    }
#line 298
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
    {
#line 303
    if ((unsigned int )quoting_style == 1U) {
#line 303
      goto case_1___0;
    }
#line 306
    if ((unsigned int )quoting_style == 2U) {
#line 306
      goto case_2___0;
    }
#line 312
    goto switch_default___1;
    case_1___0: /* CIL Label */ 
#line 304
    goto use_shell_always_quoting_style;
    case_2___0: /* CIL Label */ 
    {
#line 307
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 307
      if (len < buffersize) {
#line 307
        *(buffer + len) = (char )'\'';
      }
#line 307
      len ++;
#line 307
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 308
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 308
      if (len < buffersize) {
#line 308
        *(buffer + len) = (char )'\\';
      }
#line 308
      len ++;
#line 308
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 309
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 309
      if (len < buffersize) {
#line 309
        *(buffer + len) = (char )'\'';
      }
#line 309
      len ++;
#line 309
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 310
    goto switch_break___3;
    switch_default___1: /* CIL Label */ 
#line 313
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 315
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 332
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
    {
#line 342
    m = (size_t )0;
#line 344
    printable = 1;
#line 346
    memset((void *)(& mbstate), 0, (size_t )sizeof(mbstate));
    }
#line 348
    if (argsize == 4294967295U) {
      {
#line 349
      argsize = strlen(arg);
      }
    }
    {
#line 351
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 354
      tmp___2 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                        argsize - (i + m), & mbstate);
#line 354
      bytes = tmp___2;
      }
#line 356
      if (bytes == 0U) {
#line 357
        goto while_break___11;
      } else
#line 358
      if (bytes == 4294967295U) {
#line 360
        printable = 0;
#line 361
        goto while_break___11;
      } else
#line 363
      if (bytes == 4294967294U) {
#line 365
        printable = 0;
        {
#line 366
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 366
          if (i + m < argsize) {
#line 366
            if (! *(arg + (i + m))) {
#line 366
              goto while_break___12;
            }
          } else {
#line 366
            goto while_break___12;
          }
#line 367
          m ++;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 368
        goto while_break___11;
      } else {
        {
#line 372
        tmp___3 = iswprint(w);
        }
#line 372
        if (! tmp___3) {
#line 373
          printable = 0;
        }
#line 374
        m += bytes;
      }
      {
#line 351
      tmp___4 = mbsinit((mbstate_t const   *)(& mbstate));
      }
#line 351
      if (tmp___4) {
#line 351
        goto while_break___11;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 379
    if (m <= 1U) {
#line 384
      if (backslash_escapes) {
        {
#line 384
        tmp___5 = __ctype_b_loc();
        }
#line 384
        if ((int const   )*(*tmp___5 + (int )c) & 16384) {
#line 384
          tmp___6 = 0;
        } else {
#line 384
          tmp___6 = 1;
        }
      } else {
#line 384
        tmp___6 = 0;
      }
#line 384
      m = (size_t )tmp___6;
#line 385
      printable = 0;
    }
#line 388
    if (m) {
#line 392
      imax = (i + m) - 1U;
      {
#line 394
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 396
        if (backslash_escapes) {
#line 396
          if (! printable) {
            {
#line 398
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 398
              if (len < buffersize) {
#line 398
                *(buffer + len) = (char )'\\';
              }
#line 398
              len ++;
#line 398
              goto while_break___14;
            }
            while_break___14: /* CIL Label */ ;
            }
            {
#line 399
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 399
              if (len < buffersize) {
#line 399
                *(buffer + len) = (char )(48 + ((int )c >> 6));
              }
#line 399
              len ++;
#line 399
              goto while_break___15;
            }
            while_break___15: /* CIL Label */ ;
            }
            {
#line 400
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 400
              if (len < buffersize) {
#line 400
                *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
              }
#line 400
              len ++;
#line 400
              goto while_break___16;
            }
            while_break___16: /* CIL Label */ ;
            }
#line 401
            c = (unsigned char )(48 + ((int )c & 7));
          }
        }
#line 403
        if (i == imax) {
#line 404
          goto while_break___13;
        }
        {
#line 405
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 405
          if (len < buffersize) {
#line 405
            *(buffer + len) = (char )c;
          }
#line 405
          len ++;
#line 405
          goto while_break___17;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 406
        i ++;
#line 406
        c = (unsigned char )*(arg + i);
      }
      while_break___13: /* CIL Label */ ;
      }
#line 409
      goto store_c;
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 414
    if (backslash_escapes) {
#line 414
      if (! (o->quote_these_too[(unsigned long )c / (sizeof(int ) * 8UL)] & (1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 416
        goto store_c;
      }
    } else {
#line 416
      goto store_c;
    }
    store_escape: 
    {
#line 419
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 419
      if (len < buffersize) {
#line 419
        *(buffer + len) = (char )'\\';
      }
#line 419
      len ++;
#line 419
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    store_c: 
    {
#line 422
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 422
      if (len < buffersize) {
#line 422
        *(buffer + len) = (char )c;
      }
#line 422
      len ++;
#line 422
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 217
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 425
  if (quote_string) {
    {
#line 426
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 426
      if (! *quote_string) {
#line 426
        goto while_break___20;
      }
      {
#line 427
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 427
        if (len < buffersize) {
#line 427
          *(buffer + len) = (char )*quote_string;
        }
#line 427
        len ++;
#line 427
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 426
      quote_string ++;
    }
    while_break___20: /* CIL Label */ ;
    }
  }
#line 429
  if (len < buffersize) {
#line 430
    *(buffer + len) = (char )'\000';
  }
#line 431
  return (len);
  use_shell_always_quoting_style: 
  {
#line 434
  tmp___8 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )2,
                                     o);
  }
#line 434
  return (tmp___8);
}
}
#line 446 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  size_t tmp___0 ;

  {
#line 451
  if (o) {
#line 451
    tmp = o;
  } else {
#line 451
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 451
  p = tmp;
#line 452
  tmp___0 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     p);
  }
#line 452
  return (tmp___0);
}
}
#line 466 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
static unsigned int nslots  ;
#line 467 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
static struct slotvec *slotvec  ;
#line 462 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , struct quoting_options  const  *options ) 
{ 
  int n1 ;
  size_t s ;
  void *tmp ;
  size_t size ;
  char *val ;
  size_t qsize ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 473
  if (nslots <= (unsigned int )n) {
#line 475
    n1 = n + 1;
#line 476
    s = (size_t )((unsigned long )n1 * sizeof(struct slotvec ));
#line 477
    if (0 < n1) {
#line 477
      if (! ((unsigned long )n1 == (unsigned long )s / sizeof(struct slotvec ))) {
        {
#line 478
        abort();
        }
      }
    } else {
      {
#line 478
      abort();
      }
    }
    {
#line 479
    tmp = xrealloc((void *)slotvec, s);
#line 479
    slotvec = (struct slotvec *)tmp;
#line 480
    memset((void *)(slotvec + nslots), 0, (size_t )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )));
#line 481
    nslots = (unsigned int )n;
    }
  }
  {
#line 485
  size = (slotvec + n)->size;
#line 486
  val = (slotvec + n)->val;
#line 487
  tmp___0 = quotearg_buffer(val, size, arg, (size_t )-1, options);
#line 487
  qsize = tmp___0;
  }
#line 489
  if (size <= qsize) {
    {
#line 491
    size = qsize + 1U;
#line 491
    (slotvec + n)->size = size;
#line 492
    tmp___1 = xrealloc((void *)val, size);
#line 492
    val = (char *)tmp___1;
#line 492
    (slotvec + n)->val = val;
#line 493
    quotearg_buffer(val, size, arg, (size_t )-1, options);
    }
  }
#line 496
  return (val);
}
}
#line 500 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
char *quotearg_n(unsigned int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 503
  tmp = quotearg_n_options((int )n, arg, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 503
  return (tmp);
}
}
#line 506 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 509
  tmp = quotearg_n(0U, arg);
  }
#line 509
  return (tmp);
}
}
#line 512 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
char *quotearg_n_style(unsigned int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  char *tmp ;

  {
  {
#line 516
  o.style = s;
#line 517
  memset((void *)(o.quote_these_too), 0, (size_t )sizeof(o.quote_these_too));
#line 518
  tmp = quotearg_n_options((int )n, arg, (struct quoting_options  const  *)(& o));
  }
#line 518
  return (tmp);
}
}
#line 521 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 524
  tmp = quotearg_n_style(0U, s, arg);
  }
#line 524
  return (tmp);
}
}
#line 527 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 531
  options = default_quoting_options;
#line 532
  set_char_quoting(& options, ch, 1);
#line 533
  tmp = quotearg_n_options(0, arg, (struct quoting_options  const  *)(& options));
  }
#line 533
  return (tmp);
}
}
#line 536 "/home/ysko/Works/test-src/a2ps-4.14/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 539
  tmp = quotearg_char(arg, (char )':');
  }
#line 539
  return (tmp);
}
}
#line 71 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.h"
void *hash_delete(struct hash_table_s *ht , void const   *item ) ;
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.h"
struct output *output_new(char const   *name ) ;
#line 52
void output_free(struct output *out ) ;
#line 56
void ( /* format attribute */  output)(struct output *out , char const   *format 
                                       , ...) ;
#line 97 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.h"
struct ps_status *new_ps_status(void) ;
#line 98
void ps_status_free(struct ps_status *status ) ;
#line 99
void initialize_ps_status(struct ps_status *status ) ;
#line 107
void output_pagedevice(struct a2ps_job *job___0 ) ;
#line 108
void pagedevice_dump(FILE *stream , struct a2ps_job *job___0 ) ;
#line 109
void dump_requirements(FILE *stream , struct a2ps_job *job___0 ) ;
#line 110
void setpagedevice(struct a2ps_job *job___0 , char const   *key , char const   *value ) ;
#line 112
void delpagedevice(struct a2ps_job *job___0 , char const   *key ) ;
#line 114
void list_pagedevice(struct a2ps_job *job___0 , FILE *stream ) ;
#line 119
void output_statusdict(struct a2ps_job *job___0 ) ;
#line 120
void setstatusdict(struct a2ps_job *job___0 , char const   *key , char const   *value ,
                   int def ) ;
#line 122
void delstatusdict(struct a2ps_job *job___0 , char const   *key ) ;
#line 124
void list_statusdict(struct a2ps_job *job___0 , FILE *stream ) ;
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.h"
struct hash_table_s *multivalued_table_new(void) ;
#line 42
void multivalued_table_free(struct hash_table_s *table ) ;
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static unsigned long key_hash_1(void const   *key ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    result = 0UL;
    {
#line 54
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 54
      kk = (unsigned char const   *)((dict_entry const   *)key)->key - 1;
      {
#line 54
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 54
        kk ++;
#line 54
        if (! *kk) {
#line 54
          goto while_break___1;
        }
#line 54
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 54
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 54
    return (result);
#line 54
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (0UL);
}
}
#line 57 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static unsigned long key_hash_2(void const   *key ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    result = 0UL;
    {
#line 60
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 60
      kk = (unsigned char const   *)((dict_entry const   *)key)->key - 1;
      {
#line 60
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 60
        kk ++;
#line 60
        if (! *kk) {
#line 60
          goto while_break___1;
        }
#line 60
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 60
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 60
    return (result);
#line 60
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (0UL);
}
}
#line 63 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static int key_hash_cmp(void const   *x , void const   *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 66
      xx = (unsigned char const   *)((dict_entry const   *)x)->key - 1;
#line 66
      yy = (unsigned char const   *)((dict_entry const   *)y)->key - 1;
      {
#line 66
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 66
        xx ++;
#line 66
        if ((int const   )*xx == 0) {
#line 66
          yy ++;
#line 66
          goto while_break___1;
        }
#line 66
        yy ++;
#line 66
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 66
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 66
      result = (int )((int const   )*xx - (int const   )*yy);
#line 66
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 66
    return (result);
#line 66
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  return (0);
}
}
#line 73 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static struct hash_table_s *res  ;
#line 70 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static struct hash_table_s *new_dict_entry_table(void) 
{ 
  void *tmp ;

  {
  {
#line 75
  tmp = xmalloc((size_t )sizeof(hash_table ));
#line 75
  res = (hash_table *)tmp;
#line 76
  hash_init(res, 8UL, & key_hash_1, & key_hash_2, & key_hash_cmp);
  }
#line 78
  return (res);
}
}
#line 81 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static void dict_entry_add(struct hash_table_s *table , char const   *key , char const   *value ,
                           int def ) 
{ 
  dict_entry *item ;
  void *tmp ;

  {
  {
#line 85
  tmp = xmalloc((size_t )sizeof(dict_entry ));
#line 85
  item = (dict_entry *)tmp;
#line 86
  item->key = xstrdup(key);
#line 87
  item->value = xstrdup(value);
#line 88
  item->def = def;
#line 89
  hash_insert(table, (void *)item);
  }
#line 90
  return;
}
}
#line 92 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static dict_entry *dict_entry_get(struct hash_table_s *table , char const   *key ) 
{ 
  struct dict_entry token___1 ;
  void *tmp ;

  {
  {
#line 96
  token___1.key = (char *)key;
#line 97
  tmp = hash_find_item(table, (void const   *)(& token___1));
  }
#line 97
  return ((struct dict_entry *)tmp);
}
}
#line 100 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static void free_dict_entry(struct dict_entry *entry ) 
{ 


  {
  {
#line 103
  free((void *)entry->key);
#line 104
  free((void *)entry->value);
#line 105
  free((void *)entry);
  }
#line 106
  return;
}
}
#line 108 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static void dict_entry_remove(struct hash_table_s *table , char const   *key ) 
{ 
  struct dict_entry *item ;

  {
  {
#line 112
  item = dict_entry_get(table, key);
  }
#line 113
  if (item) {
    {
#line 114
    hash_delete(table, (void const   *)item);
#line 115
    free_dict_entry(item);
    }
  }
#line 117
  return;
}
}
#line 119 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static void free_dict_entry_table(struct hash_table_s *table ) 
{ 


  {
  {
#line 122
  hash_free(table, (void (*)(void const   *item ))(& free_dict_entry));
#line 123
  free((void *)table);
  }
#line 124
  return;
}
}
#line 134 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
struct ps_status *new_ps_status(void) 
{ 
  struct ps_status *res___2 ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 137
  tmp = xmalloc((size_t )sizeof(struct ps_status ));
#line 137
  res___2 = (struct ps_status *)tmp;
#line 140
  tmp___0 = xstrdup("%!PS-Adobe-3.0");
#line 140
  res___2->magic_number = (unsigned char *)tmp___0;
#line 143
  tmp___1 = xstrdup("#!s|$p-|, |");
#line 143
  res___2->page_label_format = (unsigned char *)tmp___1;
#line 146
  res___2->opened_encoding = (struct encoding *)((void *)0);
#line 149
  res___2->page_are_ordered = 1;
#line 152
  res___2->needed_resources = multivalued_table_new();
#line 155
  res___2->supplied_resources = multivalued_table_new();
#line 158
  res___2->pagedevice = new_dict_entry_table();
#line 161
  res___2->statusdict = new_dict_entry_table();
#line 164
  res___2->setup = output_new("setup");
  }
#line 166
  return (res___2);
}
}
#line 169 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void ps_status_free(struct ps_status *status ) 
{ 


  {
  {
#line 172
  free((void *)status->magic_number);
#line 173
  free((void *)status->page_label_format);
#line 175
  multivalued_table_free(status->needed_resources);
#line 176
  multivalued_table_free(status->supplied_resources);
#line 177
  free_dict_entry_table(status->pagedevice);
#line 178
  free_dict_entry_table(status->statusdict);
#line 179
  output_free(status->setup);
#line 181
  free((void *)status);
  }
#line 182
  return;
}
}
#line 187 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void initialize_ps_status(struct ps_status *status ) 
{ 


  {
#line 195
  status->start_page = 1;
#line 196
  status->start_line = 1;
#line 197
  status->line_continued = 0;
#line 198
  status->is_in_cut = 0;
#line 199
  status->face = (enum face_e )0;
#line 200
  status->face_declared = 0;
#line 205
  status->nonprinting_chars = 0;
#line 206
  status->chars = 0;
#line 207
  status->line = 0;
#line 208
  status->column = 0U;
#line 209
  status->wx = 0UL;
#line 210
  return;
}
}
#line 218 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static void dict_entry_print(void const   *item , FILE *stream ) 
{ 
  dict_entry const   *tok ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 221
  tok = (dict_entry const   *)item;
#line 222
  if (tok->def) {
    {
#line 223
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s::%s ",
            tok->key, tok->value);
    }
  } else {
    {
#line 225
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s:%s ",
            tok->key, tok->value);
    }
  }
#line 226
  return;
}
}
#line 231 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
static void dict_entry_table_dump(struct hash_table_s *table , FILE *stream ) 
{ 
  int i ;
  struct dict_entry **items ;
  void **tmp ;

  {
  {
#line 237
  tmp = hash_dump(table, (void **)((void *)0), (int (*)(void const   * , void const   * ))((void *)0));
#line 237
  items = (struct dict_entry **)tmp;
#line 239
  i = 0;
  }
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! *(items + i)) {
#line 239
      goto while_break;
    }
    {
#line 240
    dict_entry_print((void const   *)*(items + i), stream);
#line 239
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 241
  _IO_putc('\n', stream);
#line 243
  free((void *)items);
  }
#line 244
  return;
}
}
#line 247 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void output_pagedevice(struct a2ps_job *job___0 ) 
{ 
  dict_entry **entries ;
  dict_entry **entry ;
  void **tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 250
  entries = (dict_entry **)((void *)0);
#line 252
  tmp = hash_dump((job___0->status)->pagedevice, (void **)((void *)0), (int (*)(void const   * ,
                                                                                void const   * ))((void *)0));
#line 252
  entries = (dict_entry **)tmp;
  }
#line 254
  if (! *entries) {
#line 255
    return;
  }
  {
#line 259
  output(job___0->divertion, "%%%% Pagedevice definitions:\ncountdictstack\n%% Push our own mark, since there can be several PS marks pushed depending\n%% where the failure really occured.\n/a2ps_mark\n{\n");
#line 268
  entry = entries;
  }
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! *entry) {
#line 268
      goto while_break;
    }
    {
#line 269
    tmp___0 = toupper((int )*((*entry)->value + 0));
#line 269
    output(job___0->divertion, "%%%%BeginFeature: *%s %c%s\n  (<<) cvx exec /%s (%s) cvx exec (>>) cvx exec setpagedevice\n%%%%EndFeature\n",
           (*entry)->key, tmp___0, (*entry)->value + 1, (*entry)->key, (*entry)->value);
#line 268
    entry ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  output(job___0->divertion, "} stopped\n%% My cleartomark\n{ /a2ps_mark eq { exit } if } loop\ncountdictstack exch sub dup 0 gt\n{\n  { end } repeat\n}{\n  pop\n} ifelse\n");
#line 289
  free((void *)entries);
  }
#line 290
  return;
}
}
#line 304 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void pagedevice_dump(FILE *stream , struct a2ps_job *job___0 ) 
{ 
  dict_entry **entries ;
  dict_entry **entry ;
  void **tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 307
  entries = (dict_entry **)((void *)0);
#line 309
  tmp = hash_dump((job___0->status)->pagedevice, (void **)((void *)0), (int (*)(void const   * ,
                                                                                void const   * ))((void *)0));
#line 309
  entries = (dict_entry **)tmp;
  }
#line 311
  if (! *entries) {
#line 312
    return;
  }
  {
#line 316
  fputs((char const   */* __restrict  */)"%% Pagedevice definitions:\ncountdictstack\n% Push our own mark, since there can be several PS marks pushed depending\n% where the failure really occured.\n/a2ps_mark\n{\n",
        (FILE */* __restrict  */)stream);
#line 325
  entry = entries;
  }
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! *entry) {
#line 325
      goto while_break;
    }
    {
#line 326
    tmp___0 = toupper((int )*((*entry)->value + 0));
#line 326
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%BeginFeature: *%s %c%s\n  (<<) cvx exec /%s (%s) cvx exec (>>) cvx exec\n  systemdict /setpagedevice get exec\n%%%%EndFeature\n",
            (*entry)->key, tmp___0, (*entry)->value + 1, (*entry)->key, (*entry)->value);
#line 325
    entry ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  fputs((char const   */* __restrict  */)"} stopped\n% My cleartomark\n{ /a2ps_mark eq { exit } if } loop\ncountdictstack exch sub dup 0 gt\n{\n  { end } repeat\n}{\n  pop\n} ifelse\n",
        (FILE */* __restrict  */)stream);
#line 347
  free((void *)entries);
  }
#line 348
  return;
}
}
#line 350 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void dump_requirements(FILE *stream , struct a2ps_job *job___0 ) 
{ 
  dict_entry **entries ;
  dict_entry **entry ;
  void **tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 353
  entries = (dict_entry **)((void *)0);
#line 355
  tmp = hash_dump((job___0->status)->pagedevice, (void **)((void *)0), (int (*)(void const   * ,
                                                                                void const   * ))((void *)0));
#line 355
  entries = (dict_entry **)tmp;
  }
#line 357
  if (*entries) {
    {
#line 359
    fputs((char const   */* __restrict  */)"%%Requirements: ", (FILE */* __restrict  */)stream);
#line 360
    entry = entries;
    }
    {
#line 360
    while (1) {
      while_continue: /* CIL Label */ ;
#line 360
      if (! *entry) {
#line 360
        goto while_break;
      }
      {
#line 361
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s ",
              (*entry)->key);
#line 360
      entry ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 362
    _IO_putc('\n', stream);
    }
  }
  {
#line 367
  free((void *)entries);
  }
#line 368
  return;
}
}
#line 370 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void setpagedevice(struct a2ps_job *job___0 , char const   *key , char const   *value ) 
{ 


  {
  {
#line 373
  dict_entry_add((job___0->status)->pagedevice, key, value, 0);
  }
#line 374
  return;
}
}
#line 376 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void delpagedevice(struct a2ps_job *job___0 , char const   *key ) 
{ 


  {
  {
#line 379
  dict_entry_remove((job___0->status)->pagedevice, key);
  }
#line 380
  return;
}
}
#line 385 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void list_pagedevice(struct a2ps_job *job___0 , FILE *stream ) 
{ 


  {
  {
#line 388
  dict_entry_table_dump((job___0->status)->pagedevice, stream);
  }
#line 389
  return;
}
}
#line 394 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void setstatusdict(struct a2ps_job *job___0 , char const   *key , char const   *value ,
                   int def ) 
{ 


  {
  {
#line 397
  dict_entry_add((job___0->status)->statusdict, key, value, def);
  }
#line 398
  return;
}
}
#line 400 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void delstatusdict(struct a2ps_job *job___0 , char const   *key ) 
{ 


  {
  {
#line 403
  dict_entry_remove((job___0->status)->statusdict, key);
  }
#line 404
  return;
}
}
#line 406 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void output_statusdict(struct a2ps_job *job___0 ) 
{ 
  dict_entry **entries ;
  dict_entry **entry ;
  void **tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 409
  entries = (dict_entry **)((void *)0);
#line 412
  tmp = hash_dump((job___0->status)->statusdict, (void **)((void *)0), (int (*)(void const   * ,
                                                                                void const   * ))((void *)0));
#line 412
  entries = (dict_entry **)tmp;
  }
#line 413
  if (*entries) {
    {
#line 414
    output(job___0->divertion, "%% Statustdict definitions:\n");
#line 415
    output(job___0->divertion, "statusdict begin\n");
#line 416
    entry = entries;
    }
    {
#line 416
    while (1) {
      while_continue: /* CIL Label */ ;
#line 416
      if (! *entry) {
#line 416
        goto while_break;
      }
#line 417
      if ((*entry)->def) {
        {
#line 418
        output(job___0->divertion, "  /%s %s def\n", (*entry)->key, (*entry)->value);
        }
      } else {
        {
#line 421
        output(job___0->divertion, "  %s %s\n", (*entry)->value, (*entry)->key);
        }
      }
#line 416
      entry ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 423
    output(job___0->divertion, "end\n");
    }
  }
  {
#line 425
  free((void *)entries);
  }
#line 426
  return;
}
}
#line 431 "/home/ysko/Works/test-src/a2ps-4.14/lib/psstat.c"
void list_statusdict(struct a2ps_job *job___0 , FILE *stream ) 
{ 


  {
  {
#line 434
  dict_entry_table_dump((job___0->status)->statusdict, stream);
  }
#line 435
  return;
}
}
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 61 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 56 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.h"
void ps_end_file(struct a2ps_job *job___0 ) ;
#line 104 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.h"
char const   *face_eo_ps(enum face_e face ) ;
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.h"
void ps_print_char(struct a2ps_job *job___0 , int c , enum face_e new_face ) ;
#line 43
void ps_print_string(struct a2ps_job *job___0 , unsigned char *string , enum face_e face ) ;
#line 45
void ps_print_buffer(struct a2ps_job *job___0 , unsigned char const   *buffer , size_t start ,
                     size_t end , enum face_e face ) ;
#line 50
void ps_begin_file(struct a2ps_job *job___0 ) ;
#line 53
void page_flush(struct a2ps_job *job___0 ) ;
#line 54
void require_fresh_page(struct a2ps_job *job___0 ) ;
#line 60
void ps_set_encoding(struct a2ps_job *job___0 , struct encoding *enc ) ;
#line 62
void ps_end_encoding(struct a2ps_job *job___0 ) ;
#line 63
void ps_switch_encoding(struct a2ps_job *job___0 , struct encoding *enc ) ;
#line 62 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.h"
void output_char(struct output *out , unsigned char c ) ;
#line 63
void output_delayed_int(struct output *out , int *ptr ) ;
#line 64
void output_delayed_string(struct output *out , unsigned char **ptr ) ;
#line 76
void output_to_void(struct output *out , int forget ) ;
#line 77
int output_is_to_void(struct output *out ) ;
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.h"
char *macro_meta_sequence_get(struct a2ps_job *job___0 , char const   *key ) ;
#line 65
unsigned char *expand_user_string(struct a2ps_job *job___0 , struct file_job *file ,
                                  unsigned char const   *context_name , unsigned char const   *str ) ;
#line 44 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.h"
unsigned int char_WX(struct a2ps_job *job___0 , unsigned char c ) ;
#line 54
char const   *encoding_get_key(struct encoding *enc ) ;
#line 57
int encoding_char_exists(struct encoding *enc , enum face_e face , unsigned char c ) ;
#line 63
void set_encoding(struct a2ps_job *job___0 , struct encoding *enc ) ;
#line 71 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.h"
void file_job_synchronize_sheets(struct a2ps_job *job___0 ) ;
#line 72
void file_job_synchronize_pages(struct a2ps_job *job___0 ) ;
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.h"
int print_page(struct a2ps_job *job___0 , int page_num ) ;
#line 80 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static int ps_escape_char(a2ps_job *job___0 , unsigned char c , unsigned char *res___2 ) 
{ 
  int len ;
  int __len ;
  size_t tmp ;
  int __len___0 ;
  size_t tmp___0 ;
  int tmp___1 ;
  int __len___1 ;
  size_t tmp___2 ;
  int __len___2 ;
  size_t tmp___3 ;
  int __len___3 ;
  size_t tmp___4 ;
  int __len___4 ;
  size_t tmp___5 ;
  int __len___5 ;
  size_t tmp___6 ;
  int __len___6 ;
  size_t tmp___7 ;
  int __len___7 ;
  size_t tmp___8 ;
  int __len___8 ;
  size_t tmp___9 ;
  int __len___9 ;
  size_t tmp___10 ;
  int __len___10 ;
  size_t tmp___11 ;
  int __len___11 ;
  size_t tmp___12 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 83
  len = 0;
#line 89
  if (32 <= (int )c) {
#line 89
    if ((int )c < 127) {
#line 90
      if ((int )c == 40) {
#line 90
        goto _L;
      } else
#line 90
      if ((int )c == 41) {
#line 90
        goto _L;
      } else
#line 90
      if ((int )c == 92) {
        _L: /* CIL Label */ 
        {
#line 91
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 91
          tmp = strlen((char const   *)res___2);
#line 91
          __len = (int )tmp;
#line 91
          *(res___2 + __len) = (unsigned char )'\\';
#line 91
          *((res___2 + __len) + 1) = (unsigned char )'\000';
          }
#line 91
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 92
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 92
        tmp___0 = strlen((char const   *)res___2);
#line 92
        __len___0 = (int )tmp___0;
#line 92
        *(res___2 + __len___0) = c;
#line 92
        *((res___2 + __len___0) + 1) = (unsigned char )'\000';
        }
#line 92
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 93
      return (1);
    }
  }
  {
#line 97
  tmp___1 = encoding_char_exists(job___0->encoding, (job___0->status)->face, c);
  }
#line 97
  if (tmp___1) {
#line 97
    if (127 < (int )c) {
      {
#line 99
      sprintf((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"%s\\%o",
              res___2, (int )c);
      }
#line 100
      return (1);
    } else
#line 97
    if ((int )c < 32) {
      {
#line 99
      sprintf((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"%s\\%o",
              res___2, (int )c);
      }
#line 100
      return (1);
    }
  }
#line 104
  ((job___0->status)->nonprinting_chars) ++;
  {
#line 109
  if ((unsigned int )job___0->unprintable_format == 3U) {
#line 109
    goto case_3;
  }
#line 113
  if ((unsigned int )job___0->unprintable_format == 4U) {
#line 113
    goto case_4;
  }
#line 117
  if ((unsigned int )job___0->unprintable_format == 2U) {
#line 117
    goto case_2;
  }
#line 121
  if ((unsigned int )job___0->unprintable_format == 1U) {
#line 121
    goto case_1;
  }
#line 125
  if ((unsigned int )job___0->unprintable_format == 0U) {
#line 125
    goto case_0;
  }
#line 150
  if ((unsigned int )job___0->unprintable_format == 5U) {
#line 150
    goto case_5;
  }
#line 108
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  sprintf((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"\\\\%03o",
          (int )c);
  }
#line 111
  return (4);
  case_4: /* CIL Label */ 
  {
#line 114
  sprintf((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"\\\\x%02x",
          (int )c);
  }
#line 115
  return (4);
  case_2: /* CIL Label */ 
  {
#line 118
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 118
    tmp___2 = strlen((char const   *)res___2);
#line 118
    __len___1 = (int )tmp___2;
#line 118
    *(res___2 + __len___1) = (unsigned char )'?';
#line 118
    *((res___2 + __len___1) + 1) = (unsigned char )'\000';
    }
#line 118
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 119
  return (1);
  case_1: /* CIL Label */ 
  {
#line 122
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 122
    tmp___3 = strlen((char const   *)res___2);
#line 122
    __len___2 = (int )tmp___3;
#line 122
    *(res___2 + __len___2) = (unsigned char )' ';
#line 122
    *((res___2 + __len___2) + 1) = (unsigned char )'\000';
    }
#line 122
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 123
  return (1);
  case_0: /* CIL Label */ 
#line 126
  if (127 < (int )c) {
    {
#line 127
    strcat((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"M-");
#line 128
    len += 2;
#line 129
    c = (unsigned char )((int )c & 127);
    }
  }
#line 132
  if ((int )c < 32) {
    {
#line 133
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 133
      tmp___4 = strlen((char const   *)res___2);
#line 133
      __len___3 = (int )tmp___4;
#line 133
      *(res___2 + __len___3) = (unsigned char )'^';
#line 133
      *((res___2 + __len___3) + 1) = (unsigned char )'\000';
      }
#line 133
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 134
    len += 2;
#line 135
    c = (unsigned char )((int )c + 64);
#line 136
    if ((int )c == 40) {
#line 136
      goto _L___0;
    } else
#line 136
    if ((int )c == 41) {
#line 136
      goto _L___0;
    } else
#line 136
    if ((int )c == 92) {
      _L___0: /* CIL Label */ 
      {
#line 137
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 137
        tmp___5 = strlen((char const   *)res___2);
#line 137
        __len___4 = (int )tmp___5;
#line 137
        *(res___2 + __len___4) = (unsigned char )'\\';
#line 137
        *((res___2 + __len___4) + 1) = (unsigned char )'\000';
        }
#line 137
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 138
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 138
      tmp___6 = strlen((char const   *)res___2);
#line 138
      __len___5 = (int )tmp___6;
#line 138
      *(res___2 + __len___5) = c;
#line 138
      *((res___2 + __len___5) + 1) = (unsigned char )'\000';
      }
#line 138
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 139
  if ((int )c == 127) {
    {
#line 140
    strcat((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"^?");
#line 141
    len += 2;
    }
  } else {
#line 143
    if ((int )c == 40) {
#line 143
      goto _L___1;
    } else
#line 143
    if ((int )c == 41) {
#line 143
      goto _L___1;
    } else
#line 143
    if ((int )c == 92) {
      _L___1: /* CIL Label */ 
      {
#line 144
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 144
        tmp___7 = strlen((char const   *)res___2);
#line 144
        __len___6 = (int )tmp___7;
#line 144
        *(res___2 + __len___6) = (unsigned char )'\\';
#line 144
        *((res___2 + __len___6) + 1) = (unsigned char )'\000';
        }
#line 144
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 145
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 145
      tmp___8 = strlen((char const   *)res___2);
#line 145
      __len___7 = (int )tmp___8;
#line 145
      *(res___2 + __len___7) = c;
#line 145
      *((res___2 + __len___7) + 1) = (unsigned char )'\000';
      }
#line 145
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 146
    len ++;
  }
#line 148
  return (len);
  case_5: /* CIL Label */ 
#line 151
  if (127 < (int )c) {
    {
#line 152
    strcat((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"M-");
#line 153
    len += 2;
#line 154
    c = (unsigned char )((int )c & 127);
    }
  }
#line 157
  if ((int )c < 32) {
    {
#line 158
    strcat((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"C-");
#line 159
    len += 3;
#line 160
    c = (unsigned char )((int )c + 64);
    }
#line 161
    if ((int )c == 40) {
#line 161
      goto _L___2;
    } else
#line 161
    if ((int )c == 41) {
#line 161
      goto _L___2;
    } else
#line 161
    if ((int )c == 92) {
      _L___2: /* CIL Label */ 
      {
#line 162
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 162
        tmp___9 = strlen((char const   *)res___2);
#line 162
        __len___8 = (int )tmp___9;
#line 162
        *(res___2 + __len___8) = (unsigned char )'\\';
#line 162
        *((res___2 + __len___8) + 1) = (unsigned char )'\000';
        }
#line 162
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
    {
#line 163
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 163
      tmp___10 = strlen((char const   *)res___2);
#line 163
      __len___9 = (int )tmp___10;
#line 163
      *(res___2 + __len___9) = c;
#line 163
      *((res___2 + __len___9) + 1) = (unsigned char )'\000';
      }
#line 163
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
  } else
#line 164
  if ((int )c == 127) {
    {
#line 165
    strcat((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"C-?");
#line 166
    len += 3;
    }
  } else {
#line 168
    if ((int )c == 40) {
#line 168
      goto _L___3;
    } else
#line 168
    if ((int )c == 41) {
#line 168
      goto _L___3;
    } else
#line 168
    if ((int )c == 92) {
      _L___3: /* CIL Label */ 
      {
#line 169
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 169
        tmp___11 = strlen((char const   *)res___2);
#line 169
        __len___10 = (int )tmp___11;
#line 169
        *(res___2 + __len___10) = (unsigned char )'\\';
#line 169
        *((res___2 + __len___10) + 1) = (unsigned char )'\000';
        }
#line 169
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
    {
#line 170
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 170
      tmp___12 = strlen((char const   *)res___2);
#line 170
      __len___11 = (int )tmp___12;
#line 170
      *(res___2 + __len___11) = c;
#line 170
      *((res___2 + __len___11) + 1) = (unsigned char )'\000';
      }
#line 170
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 171
    len ++;
  }
#line 173
  return (len);
  switch_break: /* CIL Label */ ;
  }
#line 176
  return (0);
}
}
#line 197 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void output_marker(a2ps_job *job___0 , char const   *kind , unsigned char *marker ) 
{ 
  unsigned char *cp ;
  unsigned char buf___0[256] ;
  int i ;
  void *__cil_tmp7 ;

  {
  {
#line 203
  cp = expand_user_string(job___0, (struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)),
                          (unsigned char const   *)kind, (unsigned char const   *)marker);
#line 206
  i = 0;
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! *(cp + i)) {
#line 206
      goto while_break;
    }
    {
#line 208
    if ((int )*(cp + i) == 7) {
#line 208
      goto case_7;
    }
#line 211
    if ((int )*(cp + i) == 8) {
#line 211
      goto case_8;
    }
#line 214
    if ((int )*(cp + i) == 4) {
#line 214
      goto case_4;
    }
#line 217
    if ((int )*(cp + i) == 5) {
#line 217
      goto case_5;
    }
#line 220
    if ((int )*(cp + i) == 6) {
#line 220
      goto case_6;
    }
#line 223
    if ((int )*(cp + i) == 1) {
#line 223
      goto case_1;
    }
#line 226
    if ((int )*(cp + i) == 2) {
#line 226
      goto case_2;
    }
#line 229
    if ((int )*(cp + i) == 3) {
#line 229
      goto case_3;
    }
#line 232
    goto switch_default;
    case_7: /* CIL Label */ 
    {
#line 209
    output_delayed_int(job___0->divertion, & ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->last_page);
    }
#line 210
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 212
    output_delayed_int(job___0->divertion, & ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->last_sheet);
    }
#line 213
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 215
    output_delayed_int(job___0->divertion, & ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->pages);
    }
#line 216
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 218
    output_delayed_int(job___0->divertion, & ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->sheets);
    }
#line 219
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 221
    output_delayed_int(job___0->divertion, & ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->lines);
    }
#line 222
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 224
    output_delayed_int(job___0->divertion, & job___0->pages);
    }
#line 225
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 227
    output_delayed_int(job___0->divertion, & job___0->sheets);
    }
#line 228
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 230
    output_delayed_int(job___0->divertion, & job___0->total_files);
    }
#line 231
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 233
    buf___0[0] = (unsigned char )'\000';
#line 234
    ps_escape_char(job___0, *(cp + i), buf___0);
#line 235
    output(job___0->divertion, (char const   *)((char *)(buf___0)));
    }
#line 236
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 206
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return;
}
}
#line 247 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
void ps_set_encoding(struct a2ps_job *job___0 , struct encoding *enc ) 
{ 
  char const   *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 250
  set_encoding(job___0, enc);
#line 251
  (job___0->status)->opened_encoding = enc;
#line 252
  tmp = encoding_get_key(enc);
#line 252
  output(job___0->divertion, "%sdict begin\n", tmp);
  }
#line 253
  return;
}
}
#line 255 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
void ps_end_encoding(struct a2ps_job *job___0 ) 
{ 
  char const   *tmp ;
  char *__cil_tmp3 ;

  {
#line 258
  if ((job___0->status)->opened_encoding) {
    {
#line 259
    tmp = encoding_get_key((job___0->status)->opened_encoding);
#line 259
    output(job___0->divertion, "end %% of %sdict\n", tmp);
    }
  }
  {
#line 261
  set_encoding(job___0, (struct encoding *)((void *)0));
#line 262
  (job___0->status)->opened_encoding = (struct encoding *)((void *)0);
  }
#line 263
  return;
}
}
#line 275 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void ps_internal_switch_encoding(a2ps_job *job___0 , struct encoding *enc ) 
{ 


  {
#line 278
  if ((unsigned long )job___0->encoding != (unsigned long )enc) {
#line 284
    if ((job___0->status)->opened_encoding) {
      {
#line 285
      ps_end_encoding(job___0);
#line 286
      ps_set_encoding(job___0, enc);
      }
    } else {
      {
#line 288
      ps_end_encoding(job___0);
#line 289
      set_encoding(job___0, enc);
      }
    }
#line 292
    (job___0->status)->face_declared = 0;
  }
#line 294
  return;
}
}
#line 302 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
void ps_switch_encoding(struct a2ps_job *job___0 , struct encoding *enc ) 
{ 
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 305
  if ((unsigned long )job___0->encoding != (unsigned long )enc) {
#line 307
    if (! (job___0->status)->start_line) {
#line 308
      if (! (job___0->status)->face_declared) {
        {
#line 309
        tmp = face_eo_ps((job___0->status)->face);
#line 309
        output(job___0->divertion, ") %s\n", tmp);
        }
      } else {
        {
#line 311
        output(job___0->divertion, ") S\n");
        }
      }
    }
    {
#line 313
    ps_internal_switch_encoding(job___0, enc);
#line 314
    job___0->saved_encoding = enc;
    }
#line 315
    if (! (job___0->status)->start_line) {
      {
#line 316
      output_char(job___0->divertion, (unsigned char )'(');
      }
    }
  }
#line 318
  return;
}
}
#line 320 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void ps_push_encoding(a2ps_job *job___0 , struct encoding *enc ) 
{ 


  {
  {
#line 323
  job___0->saved_encoding = job___0->encoding;
#line 324
  ps_internal_switch_encoding(job___0, enc);
  }
#line 325
  return;
}
}
#line 327 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void ps_pop_encoding(a2ps_job *job___0 ) 
{ 


  {
  {
#line 330
  ps_internal_switch_encoding(job___0, job___0->saved_encoding);
  }
#line 331
  return;
}
}
#line 342 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void page_begin(a2ps_job *job___0 ) 
{ 
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 345
  job___0->virtual = 1;
#line 347
  tmp = print_page(job___0, job___0->pages);
  }
#line 347
  if (tmp) {
#line 348
    (job___0->sheets) ++;
  }
  {
#line 351
  ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->top_page = ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->pages + 1;
#line 358
  tmp___1 = output_is_to_void(job___0->divertion);
  }
#line 358
  if (! tmp___1) {
    {
#line 360
    output(job___0->divertion, "%%%%Page: (");
#line 361
    tmp___0 = xmalloc((size_t )sizeof(unsigned char *));
#line 361
    (job___0->status)->page_label = (unsigned char **)tmp___0;
#line 362
    output_delayed_string(job___0->divertion, (job___0->status)->page_label);
#line 363
    output(job___0->divertion, ") %d\n", job___0->sheets);
    }
  }
  {
#line 367
  output(job___0->divertion, "%%%%BeginPageSetup\n");
#line 368
  output(job___0->divertion, "/pagesave save def\n");
  }
#line 371
  if (job___0->margin) {
#line 371
    if ((unsigned int )job___0->duplex == 0U) {
      {
#line 373
      output(job___0->divertion, "%d 0 translate\n", job___0->margin);
      }
    } else
#line 371
    if (job___0->sheets % 2) {
      {
#line 373
      output(job___0->divertion, "%d 0 translate\n", job___0->margin);
      }
    }
  }
#line 375
  if ((unsigned int )job___0->orientation == 1U) {
    {
#line 376
    output(job___0->divertion, "sh 0 translate 90 rotate\n");
    }
  }
  {
#line 378
  output(job___0->divertion, "%%%%EndPageSetup\n");
  }
#line 380
  if (job___0->debug) {
    {
#line 381
    output(job___0->divertion, "%% Display the bounding box\n  gsave\n    llx lly moveto\n    2 setlinewidth\n    0.9 setgray\n    urx lly lineto\n    urx ury lineto\n    llx ury lineto\n    closepath stroke\n  grestore\n\n");
    }
  }
  {
#line 394
  ps_set_encoding(job___0, job___0->requested_encoding);
  }
#line 397
  if (! ((unsigned long )((char const   *)job___0->water) == (unsigned long )((void *)0))) {
#line 397
    if (! ((int )*(job___0->water) == 0)) {
      {
#line 399
      output_char(job___0->divertion, (unsigned char )'(');
#line 400
      output_marker(job___0, "water mark", job___0->water);
#line 401
      tmp___2 = atan2((double )(job___0->medium)->w - (double )job___0->margin, (double )(job___0->medium)->h);
#line 401
      output(job___0->divertion, ") %4.2f water\n", ((double )((float )tmp___2) / 3.14159265) * (double )180);
      }
    }
  }
  {
#line 409
  output(job___0->divertion, "gsave\n");
  }
#line 410
  if ((unsigned long )((char const   *)job___0->footer) == (unsigned long )((void *)0)) {
#line 410
    goto _L___0;
  } else
#line 410
  if ((int )*(job___0->footer) == 0) {
    _L___0: /* CIL Label */ 
#line 410
    if ((unsigned long )((char const   *)job___0->left_footer) == (unsigned long )((void *)0)) {
#line 410
      goto _L;
    } else
#line 410
    if ((int )*(job___0->left_footer) == 0) {
      _L: /* CIL Label */ 
#line 410
      if ((unsigned long )((char const   *)job___0->right_footer) == (unsigned long )((void *)0)) {
#line 410
        tmp___3 = 0;
      } else
#line 410
      if ((int )*(job___0->right_footer) == 0) {
#line 410
        tmp___3 = 0;
      } else {
#line 410
        tmp___3 = 1;
      }
    } else {
#line 410
      tmp___3 = 1;
    }
  } else {
#line 410
    tmp___3 = 1;
  }
  {
#line 410
  output(job___0->divertion, "llx lly %d add translate\n", tmp___3 * 12);
#line 413
  ps_internal_switch_encoding(job___0, job___0->saved_encoding);
  }
#line 414
  return;
}
}
#line 419 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void page_end(a2ps_job *job___0 ) 
{ 
  unsigned char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 425
  tmp = expand_user_string(job___0, (struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)),
                           (unsigned char const   *)"Page label", (unsigned char const   *)(job___0->status)->page_label_format);
#line 425
  tmp___0 = xstrdup((char const   *)tmp);
#line 425
  *((job___0->status)->page_label) = (unsigned char *)tmp___0;
#line 430
  output(job___0->divertion, "grestore\n");
#line 433
  ps_push_encoding(job___0, job___0->requested_encoding);
  }
#line 436
  if (! ((unsigned long )((char const   *)job___0->header) == (unsigned long )((void *)0))) {
#line 436
    if (! ((int )*(job___0->header) == 0)) {
      {
#line 437
      output_char(job___0->divertion, (unsigned char )'(');
#line 438
      output_marker(job___0, "right header", job___0->header);
#line 439
      output(job___0->divertion, ") rhead\n");
      }
    }
  }
#line 445
  if ((unsigned long )((char const   *)job___0->footer) == (unsigned long )((void *)0)) {
#line 445
    goto _L___1;
  } else
#line 445
  if ((int )*(job___0->footer) == 0) {
    _L___1: /* CIL Label */ 
#line 445
    if ((unsigned long )((char const   *)job___0->left_footer) == (unsigned long )((void *)0)) {
#line 445
      goto _L___0;
    } else
#line 445
    if ((int )*(job___0->left_footer) == 0) {
      _L___0: /* CIL Label */ 
#line 445
      if (! ((unsigned long )((char const   *)job___0->right_footer) == (unsigned long )((void *)0))) {
#line 445
        if (! ((int )*(job___0->right_footer) == 0)) {
          _L: /* CIL Label */ 
#line 446
          if ((unsigned long )((char const   *)job___0->footer) == (unsigned long )((void *)0)) {
            {
#line 451
            output(job___0->divertion, "() ");
            }
          } else
#line 446
          if ((int )*(job___0->footer) == 0) {
            {
#line 451
            output(job___0->divertion, "() ");
            }
          } else {
            {
#line 447
            output_char(job___0->divertion, (unsigned char )'(');
#line 448
            output_marker(job___0, "center footer", job___0->footer);
#line 449
            output(job___0->divertion, ") ");
            }
          }
#line 454
          if ((unsigned long )((char const   *)job___0->right_footer) == (unsigned long )((void *)0)) {
            {
#line 459
            output(job___0->divertion, "() ");
            }
          } else
#line 454
          if ((int )*(job___0->right_footer) == 0) {
            {
#line 459
            output(job___0->divertion, "() ");
            }
          } else {
            {
#line 455
            output_char(job___0->divertion, (unsigned char )'(');
#line 456
            output_marker(job___0, "right footer", job___0->right_footer);
#line 457
            output(job___0->divertion, ") ");
            }
          }
#line 462
          if ((unsigned long )((char const   *)job___0->left_footer) == (unsigned long )((void *)0)) {
            {
#line 468
            output(job___0->divertion, "() ");
            }
          } else
#line 462
          if ((int )*(job___0->left_footer) == 0) {
            {
#line 468
            output(job___0->divertion, "() ");
            }
          } else {
            {
#line 463
            output_char(job___0->divertion, (unsigned char )'(');
#line 464
            output_marker(job___0, "left footer", job___0->left_footer);
#line 465
            output(job___0->divertion, ") ");
            }
          }
          {
#line 469
          output(job___0->divertion, "footer\n");
          }
        }
      }
    } else {
#line 445
      goto _L;
    }
  } else {
#line 445
    goto _L;
  }
  {
#line 473
  ps_end_encoding(job___0);
#line 475
  output(job___0->divertion, "pagesave restore\n");
#line 476
  output(job___0->divertion, "showpage\n");
#line 478
  job___0->virtual = 0;
  }
#line 479
  return;
}
}
#line 488 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void virtual_begin(a2ps_job *job___0 ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 491
  (job___0->pages) ++;
#line 493
  tmp = print_page(job___0, job___0->pages);
  }
#line 493
  if (tmp) {
    {
#line 494
    output_to_void(job___0->divertion, 0);
#line 495
    (job___0->virtual) ++;
    }
  } else {
    {
#line 497
    output_to_void(job___0->divertion, 1);
    }
  }
#line 501
  if (job___0->virtual == 1) {
    {
#line 502
    page_begin(job___0);
    }
  }
#line 504
  if (! job___0->encoding) {
    {
#line 505
    ps_set_encoding(job___0, job___0->saved_encoding);
    }
  }
  {
#line 507
  file_job_synchronize_pages(job___0);
#line 508
  file_job_synchronize_sheets(job___0);
#line 510
  output(job___0->divertion, "/v %d store\n", job___0->virtual - 1);
#line 511
  output(job___0->divertion, "/x0 x v get %f add sx cw mul add store\n", (0.7 * (double )job___0->fontsize) * 0.6);
  }
#line 513
  if ((unsigned long )((char const   *)job___0->center_title) == (unsigned long )((void *)0)) {
#line 513
    goto _L___0;
  } else
#line 513
  if ((int )*(job___0->center_title) == 0) {
    _L___0: /* CIL Label */ 
#line 513
    if ((unsigned long )((char const   *)job___0->left_title) == (unsigned long )((void *)0)) {
#line 513
      goto _L;
    } else
#line 513
    if ((int )*(job___0->left_title) == 0) {
      _L: /* CIL Label */ 
#line 513
      if ((unsigned long )((char const   *)job___0->right_title) == (unsigned long )((void *)0)) {
#line 513
        tmp___0 = "";
      } else
#line 513
      if ((int )*(job___0->right_title) == 0) {
#line 513
        tmp___0 = "";
      } else {
#line 513
        tmp___0 = "th add";
      }
    } else {
#line 513
      tmp___0 = "th add";
    }
  } else {
#line 513
    tmp___0 = "th add";
  }
  {
#line 513
  output(job___0->divertion, "/y0 y v get bfs %s sub store\n", tmp___0);
#line 515
  output(job___0->divertion, "x0 y0 moveto\n");
  }
#line 516
  return;
}
}
#line 522 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void virtual_end(a2ps_job *job___0 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 529
  if ((unsigned long )((char const   *)job___0->center_title) == (unsigned long )((void *)0)) {
#line 529
    goto _L___1;
  } else
#line 529
  if ((int )*(job___0->center_title) == 0) {
    _L___1: /* CIL Label */ 
#line 529
    if ((unsigned long )((char const   *)job___0->left_title) == (unsigned long )((void *)0)) {
#line 529
      goto _L___0;
    } else
#line 529
    if ((int )*(job___0->left_title) == 0) {
      _L___0: /* CIL Label */ 
#line 529
      if (! ((unsigned long )((char const   *)job___0->right_title) == (unsigned long )((void *)0))) {
#line 529
        if (! ((int )*(job___0->right_title) == 0)) {
          _L: /* CIL Label */ 
          {
#line 530
          ps_push_encoding(job___0, job___0->requested_encoding);
          }
#line 531
          if ((unsigned long )((char const   *)job___0->center_title) == (unsigned long )((void *)0)) {
            {
#line 536
            output(job___0->divertion, "() ");
            }
          } else
#line 531
          if ((int )*(job___0->center_title) == 0) {
            {
#line 536
            output(job___0->divertion, "() ");
            }
          } else {
            {
#line 532
            output_char(job___0->divertion, (unsigned char )'(');
#line 533
            output_marker(job___0, "center title", job___0->center_title);
#line 534
            output(job___0->divertion, ") ");
            }
          }
#line 538
          if ((unsigned long )((char const   *)job___0->right_title) == (unsigned long )((void *)0)) {
            {
#line 543
            output(job___0->divertion, "() ");
            }
          } else
#line 538
          if ((int )*(job___0->right_title) == 0) {
            {
#line 543
            output(job___0->divertion, "() ");
            }
          } else {
            {
#line 539
            output_char(job___0->divertion, (unsigned char )'(');
#line 540
            output_marker(job___0, "right title", job___0->right_title);
#line 541
            output(job___0->divertion, ") ");
            }
          }
#line 545
          if ((unsigned long )((char const   *)job___0->left_title) == (unsigned long )((void *)0)) {
            {
#line 550
            output(job___0->divertion, "() ");
            }
          } else
#line 545
          if ((int )*(job___0->left_title) == 0) {
            {
#line 550
            output(job___0->divertion, "() ");
            }
          } else {
            {
#line 546
            output_char(job___0->divertion, (unsigned char )'(');
#line 547
            output_marker(job___0, "left title", job___0->left_title);
#line 548
            output(job___0->divertion, ") ");
            }
          }
          {
#line 552
          output(job___0->divertion, "title\n");
#line 553
          ps_pop_encoding(job___0);
          }
        }
      }
    } else {
#line 529
      goto _L;
    }
  } else {
#line 529
    goto _L;
  }
#line 556
  if (job___0->border) {
    {
#line 557
    output(job___0->divertion, "border\n");
    }
  }
#line 559
  if (job___0->virtual == job___0->columns * job___0->rows) {
    {
#line 560
    page_end(job___0);
    }
  }
#line 562
  (job___0->status)->line = 0;
#line 563
  return;
}
}
#line 567 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void virtual_empty_output(a2ps_job *job___0 ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 572
  tmp = macro_meta_sequence_get(job___0, "opt.virtual.force");
  }
#line 572
  if (tmp) {
    {
#line 574
    virtual_begin(job___0);
#line 575
    virtual_end(job___0);
    }
  } else {
#line 580
    (job___0->pages) ++;
#line 581
    (job___0->virtual) ++;
#line 582
    if (job___0->virtual == job___0->columns * job___0->rows) {
      {
#line 583
      page_end(job___0);
      }
    }
  }
#line 585
  return;
}
}
#line 595 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
void page_flush(struct a2ps_job *job___0 ) 
{ 


  {
  {
#line 599
  output_to_void(job___0->divertion, 0);
  }
#line 602
  if (job___0->virtual != 0) {
    {
#line 603
    page_end(job___0);
    }
  }
#line 604
  return;
}
}
#line 609 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void page_empty_output(a2ps_job *job___0 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 612
  (job___0->sheets) ++;
#line 613
  file_job_synchronize_sheets(job___0);
#line 614
  output(job___0->divertion, "%%%%Page: (*) %d\n", job___0->sheets);
#line 615
  output(job___0->divertion, "%% Empty Page\n");
#line 616
  output(job___0->divertion, "showpage\n");
  }
#line 617
  return;
}
}
#line 619 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void sheet_flush(a2ps_job *job___0 ) 
{ 


  {
  {
#line 622
  page_flush(job___0);
  }
#line 625
  if ((unsigned int )job___0->duplex == 1U) {
#line 625
    goto _L;
  } else
#line 625
  if ((unsigned int )job___0->duplex == 2U) {
    _L: /* CIL Label */ 
#line 625
    if (job___0->sheets % 2 != 0) {
      {
#line 627
      page_empty_output(job___0);
      }
    }
  }
#line 628
  return;
}
}
#line 635 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
void require_fresh_page(struct a2ps_job *job___0 ) 
{ 


  {
#line 639
  if (job___0->virtual != 0) {
    {
#line 641
    page_flush(job___0);
    }
  }
#line 642
  return;
}
}
#line 655 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
static void check_binary_file(a2ps_job *job___0 ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
#line 658
  if ((job___0->status)->chars > 120) {
#line 660
    if (! job___0->print_binaries) {
#line 660
      if (((job___0->status)->nonprinting_chars * 100) / (job___0->status)->chars >= 40) {
        {
#line 662
        tmp = gettext("`%s\' is a binary file, printing aborted");
#line 662
        error(1, 0, (char const   *)tmp, ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->name);
        }
      }
    }
  }
#line 665
  return;
}
}
#line 667 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
__inline static void end_of_line___0(struct a2ps_job *job___0 ) 
{ 
  char const   *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 670
  if (! (job___0->status)->face_declared) {
    {
#line 671
    tmp = face_eo_ps((job___0->status)->face);
#line 671
    output(job___0->divertion, ") %s n\n", tmp);
#line 672
    (job___0->status)->face_declared = 1;
    }
  } else {
    {
#line 674
    output(job___0->divertion, ") N\n");
    }
  }
#line 675
  ((job___0->status)->line) ++;
#line 676
  (job___0->status)->column = 0U;
#line 677
  (job___0->status)->wx = 0UL;
#line 678
  return;
}
}
#line 688 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
__inline static void fold_line(struct a2ps_job *job___0 , enum face_e new_face ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 691
  (job___0->lines_folded) ++;
#line 692
  end_of_line___0(job___0);
  }
#line 693
  if ((job___0->status)->line >= (job___0->status)->linesperpage) {
    {
#line 695
    virtual_end(job___0);
#line 696
    virtual_begin(job___0);
#line 697
    (job___0->status)->face_declared = 0;
    }
  }
#line 699
  if (job___0->numbering) {
    {
#line 701
    output(job___0->divertion, "0 T (");
    }
  } else {
    {
#line 708
    output_char(job___0->divertion, (unsigned char )'(');
#line 709
    (job___0->status)->face_declared &= (int )(job___0->status)->face == (int )new_face;
#line 711
    (job___0->status)->face = new_face;
    }
  }
#line 713
  return;
}
}
#line 718 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
void ps_print_char(struct a2ps_job *job___0 , int c , enum face_e new_face ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  unsigned long tmp___1 ;
  char const   *tmp___2 ;
  unsigned char buf___0[256] ;
  int nchars ;
  char const   *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 733
  if ((job___0->status)->is_in_cut) {
#line 733
    if (c != 12) {
#line 733
      if (c != 10) {
#line 739
        return;
      }
    }
  }
#line 740
  (job___0->status)->is_in_cut = 0;
#line 743
  if ((job___0->status)->start_line) {
#line 745
    if ((job___0->status)->start_page) {
      {
#line 748
      virtual_begin(job___0);
#line 749
      (job___0->status)->start_page = 0;
#line 752
      (job___0->status)->face = new_face;
#line 753
      (job___0->status)->face_declared = 0;
      }
#line 755
      if (job___0->numbering) {
#line 757
        if (((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->lines % job___0->numbering == 0) {
          {
#line 758
          output(job___0->divertion, "(%d) # (", ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->lines);
          }
        } else {
          {
#line 760
          output(job___0->divertion, "0 T (");
          }
        }
      } else {
        {
#line 763
        output_char(job___0->divertion, (unsigned char )'(');
        }
      }
    } else
#line 768
    if (job___0->numbering) {
#line 770
      if (((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->lines % job___0->numbering == 0) {
        {
#line 771
        output(job___0->divertion, "(%d) # (", ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->lines);
        }
      } else {
        {
#line 773
        output(job___0->divertion, "0 T (");
        }
      }
    } else {
      {
#line 780
      output_char(job___0->divertion, (unsigned char )'(');
      }
#line 783
      if ((job___0->status)->face_declared) {
#line 783
        if ((int )(job___0->status)->face == (int )new_face) {
#line 783
          tmp = 1;
        } else {
#line 783
          tmp = 0;
        }
      } else {
#line 783
        tmp = 0;
      }
#line 783
      (job___0->status)->face_declared = tmp;
#line 785
      (job___0->status)->face = new_face;
    }
#line 788
    (job___0->status)->start_line = 0;
  }
  {
#line 799
  if (c == 12) {
#line 799
    goto case_12;
  }
#line 819
  if (c == 10) {
#line 819
    goto case_10;
  }
#line 838
  if (c == 9) {
#line 838
    goto case_9;
  }
#line 876
  goto print;
  case_12: /* CIL Label */ 
#line 800
  if (! job___0->interpret) {
#line 801
    goto print;
  }
#line 804
  if (! (job___0->status)->start_line) {
    {
#line 806
    end_of_line___0(job___0);
#line 807
    (job___0->status)->start_line = 1;
    }
  }
#line 810
  if ((job___0->status)->start_page) {
    {
#line 812
    virtual_begin(job___0);
    }
  }
  {
#line 815
  virtual_end(job___0);
#line 816
  (job___0->status)->start_page = 1;
  }
#line 817
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 828
  (((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->lines) ++;
#line 829
  (job___0->status)->start_line = 1;
#line 830
  end_of_line___0(job___0);
  }
#line 832
  if ((job___0->status)->line >= (job___0->status)->linesperpage) {
    {
#line 833
    virtual_end(job___0);
#line 834
    (job___0->status)->start_page = 1;
    }
  }
#line 836
  goto switch_break;
  case_9: /* CIL Label */ 
#line 839
  if (! job___0->interpret) {
#line 840
    goto print;
  }
#line 843
  if ((int )(job___0->status)->face != (int )new_face) {
#line 844
    if (! (job___0->status)->face_declared) {
      {
#line 845
      tmp___0 = face_eo_ps((job___0->status)->face);
#line 845
      output(job___0->divertion, ") %s\n(", tmp___0);
      }
    } else {
      {
#line 847
      output(job___0->divertion, ") S\n(");
      }
    }
#line 848
    (job___0->status)->face = new_face;
#line 849
    (job___0->status)->face_declared = 0;
  }
#line 855
  if ((job___0->status)->wx / 600UL > (unsigned long )(job___0->status)->column) {
#line 855
    tmp___1 = (job___0->status)->wx / 600UL;
  } else {
#line 855
    tmp___1 = (unsigned long )(job___0->status)->column;
  }
#line 855
  (job___0->status)->column = (unsigned int )((tmp___1 / (unsigned long )job___0->tabsize + 1UL) * (unsigned long )job___0->tabsize);
#line 858
  (job___0->status)->wx = (unsigned long )((job___0->status)->column * 600U);
#line 859
  if ((job___0->status)->wx > (job___0->status)->wxperline) {
#line 860
    if (job___0->folding) {
      {
#line 861
      fold_line(job___0, new_face);
      }
    } else {
#line 863
      (job___0->status)->is_in_cut = 1;
#line 864
      return;
    }
  }
#line 868
  if (! (job___0->status)->face_declared) {
    {
#line 869
    tmp___2 = face_eo_ps((job___0->status)->face);
#line 869
    output(job___0->divertion, ") %s", tmp___2);
#line 870
    (job___0->status)->face_declared = 1;
    }
  } else {
    {
#line 872
    output(job___0->divertion, ") S");
    }
  }
  {
#line 873
  output(job___0->divertion, " %d T (", (job___0->status)->column);
  }
#line 874
  goto switch_break;
  print: 
  switch_default: /* CIL Label */ 
#line 880
  buf___0[0] = (unsigned char )'\000';
#line 883
  if ((int )(job___0->status)->face != (int )new_face) {
#line 884
    if (! (job___0->status)->face_declared) {
      {
#line 885
      tmp___3 = face_eo_ps((job___0->status)->face);
#line 885
      output(job___0->divertion, ") %s\n(", tmp___3);
      }
    } else {
      {
#line 887
      output(job___0->divertion, ") S\n(");
      }
    }
#line 888
    (job___0->status)->face = new_face;
#line 889
    (job___0->status)->face_declared = 0;
  }
  {
#line 892
  nchars = ps_escape_char(job___0, (unsigned char )c, buf___0);
#line 893
  tmp___4 = char_WX(job___0, (unsigned char )c);
#line 893
  (job___0->status)->wx += (unsigned long )tmp___4;
#line 894
  (job___0->status)->column += (unsigned int )nchars;
  }
#line 895
  if ((job___0->status)->wx > (job___0->status)->wxperline) {
#line 896
    if (job___0->folding) {
      {
#line 897
      fold_line(job___0, new_face);
#line 898
      (job___0->status)->column = (unsigned int )nchars;
#line 899
      tmp___5 = char_WX(job___0, (unsigned char )c);
#line 899
      (job___0->status)->wx = (unsigned long )tmp___5;
      }
    } else {
#line 901
      (job___0->status)->is_in_cut = 1;
#line 902
      return;
    }
  }
  {
#line 905
  output(job___0->divertion, "%s", buf___0);
#line 906
  ((job___0->status)->chars) ++;
  }
#line 908
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 910
  return;
}
}
#line 915 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
void ps_print_string(struct a2ps_job *job___0 , unsigned char *string , enum face_e face ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 918
    if (! *string) {
#line 918
      goto while_break;
    }
    {
#line 919
    tmp = string;
#line 919
    string ++;
#line 919
    ps_print_char(job___0, (int )*tmp, face);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return;
}
}
#line 925 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
void ps_print_buffer(struct a2ps_job *job___0 , unsigned char const   *buffer , size_t start ,
                     size_t end , enum face_e face ) 
{ 
  size_t i ;

  {
#line 932
  i = start;
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 932
    if (! (i < end)) {
#line 932
      goto while_break;
    }
    {
#line 933
    ps_print_char(job___0, (int )*(buffer + i), face);
#line 932
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 934
  return;
}
}
#line 941 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
void ps_begin_file(struct a2ps_job *job___0 ) 
{ 
  int alignment ;
  int tmp ;

  {
  {
#line 945
  initialize_ps_status(job___0->status);
  }
#line 948
  if ((job___0->jobs)->len == 0U) {
#line 949
    return;
  }
  {
#line 953
  if (job___0->file_align == -4) {
#line 953
    goto case_neg_4;
  }
#line 957
  if (job___0->file_align == -3) {
#line 957
    goto case_neg_3;
  }
#line 966
  if (job___0->file_align == -2) {
#line 966
    goto case_neg_2;
  }
#line 971
  if (job___0->file_align == -1) {
#line 971
    goto case_neg_1;
  }
#line 976
  goto switch_default;
  case_neg_4: /* CIL Label */ 
#line 955
  goto switch_break;
  case_neg_3: /* CIL Label */ 
#line 960
  if ((unsigned int )job___0->madir == 0U) {
#line 960
    tmp = job___0->columns;
  } else {
#line 960
    tmp = job___0->rows;
  }
#line 960
  alignment = tmp;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! (job___0->pages % alignment != 0)) {
#line 961
      goto while_break;
    }
    {
#line 962
    virtual_empty_output(job___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 964
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
#line 968
  page_flush(job___0);
  }
#line 969
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 973
  sheet_flush(job___0);
  }
#line 974
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 980
  page_flush(job___0);
  }
  {
#line 981
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 981
    if (! (job___0->sheets % job___0->file_align != 0)) {
#line 981
      goto while_break___0;
    }
    {
#line 982
    page_empty_output(job___0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 983
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 985
  return;
}
}
#line 987 "/home/ysko/Works/test-src/a2ps-4.14/lib/psgen.c"
void ps_end_file(struct a2ps_job *job___0 ) 
{ 
  char const   *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 992
  if (! (job___0->status)->start_line) {
#line 994
    if (! (job___0->status)->face_declared) {
      {
#line 995
      tmp = face_eo_ps((job___0->status)->face);
#line 995
      output(job___0->divertion, ") %s\n", tmp);
      }
    } else {
      {
#line 997
      output(job___0->divertion, ") S\n");
      }
    }
  }
#line 999
  if (! (job___0->status)->start_page) {
    {
#line 1000
    virtual_end(job___0);
    }
  }
  {
#line 1003
  file_job_synchronize_pages(job___0);
#line 1004
  file_job_synchronize_sheets(job___0);
#line 1007
  check_binary_file(job___0);
  }
#line 1008
  return;
}
}
#line 604 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 255 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *asctime(struct tm  const  *__tp ) ;
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.h"
void (*ps_comment_hook)(struct a2ps_job *job , FILE *stream ) ;
#line 53
void ps_begin(struct a2ps_job *job___0 ) ;
#line 54
void ps_end(struct a2ps_job *job___0 ) ;
#line 61
void prologues_list_short(struct a2ps_job *job___0 , FILE *stream ) ;
#line 62
void prologues_list_long(struct a2ps_job *job___0 , FILE *stream ) ;
#line 63
void prologues_list_texinfo(struct a2ps_job *job___0 , FILE *stream ) ;
#line 69 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.h"
void output_file(struct output *out , struct a2ps_job *job___0 , char const   *name ,
                 char const   *suffix ) ;
#line 72
void output_delayed_routine(struct output *out , void (*fn)(FILE *stream , void *arg ) ,
                            void *fn_arg ) ;
#line 87
void undivert(struct a2ps_job *job___0 ) ;
#line 88
void output_dump(struct output *out , FILE *stream ) ;
#line 54 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.h"
void dump_process_color(FILE *stream , struct a2ps_job *job___0 ) ;
#line 59
void dump_needed_resources(FILE *stream , struct a2ps_job *job___0 ) ;
#line 64
void dump_supplied_resources(FILE *stream , struct a2ps_job *job___0 ) ;
#line 72
void dump_setup(FILE *stream , struct a2ps_job *job___0 ) ;
#line 110 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.h"
void check_face_eo_font(struct a2ps_job *job___0 ) ;
#line 77 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.h"
void encoding_build_faces_wx(struct a2ps_job *job___0 , struct encoding *encoding ) ;
#line 83
void dump_encodings_setup(FILE *stream , struct a2ps_job *job___0 ) ;
#line 73 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.h"
void da_free(struct darray *arr , void (*free_func)(void * ) ) ;
#line 59 "/home/ysko/Works/test-src/a2ps-4.14/lib/fonts.h"
void font_info_table_dump_special_font_setup(FILE *stream , struct a2ps_job *job___0 ) ;
#line 63
void dump_fonts(FILE *stream , struct a2ps_job *job___0 ) ;
#line 63 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.h"
char *xpw_find_file(char * const  *path , char const   *name , char const   *suffix ) ;
#line 81
struct darray *pw_glob_on_suffix(char * const  *path , char const   *suffix ) ;
#line 87
void pw_lister_on_suffix(FILE *stream , char * const  *path , char const   *suffix ) ;
#line 53 "/home/ysko/Works/test-src/a2ps-4.14/lib/getshline.h"
int getshline_numbered(int *firstline , int *lastline , char **lineptr , size_t *n ,
                       FILE *stream ) ;
#line 50 "/home/ysko/Works/test-src/a2ps-4.14/lib/document.h"
void documentation_print_plain(unsigned char const   *documentation , char const   *format ,
                               FILE *stream ) ;
#line 58
void documentation_print_texinfo(unsigned char const   *documentation , char const   *format ,
                                 FILE *stream ) ;
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
void (*ps_comment_hook)(struct a2ps_job *job , FILE *stream )  =    (void (*)(struct a2ps_job *job , FILE *stream ))((void *)0);
#line 95 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
void prologues_list_short(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 98
  tmp = gettext("Known Prologues");
#line 98
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
#line 99
  _IO_putc('\n', stream);
#line 100
  pw_lister_on_suffix(stream, (char * const  *)job___0->common.path, ".pro");
  }
#line 101
  return;
}
}
#line 106 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
__inline static void prologue_print_signature(struct a2ps_job *job___0 , char const   *prologue_name ,
                                              FILE *stream , char const   *name_format ,
                                              void (*documentation_fn)(unsigned char const   *documentation ,
                                                                       char const   *format ,
                                                                       FILE *stream ) ) 
{ 
  FILE *fp ;
  char *filename ;
  char *buf___0 ;
  int done ;
  int firstline ;
  int lastline ;
  size_t bufsiz ;
  char buf2[8192] ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 114
  buf___0 = (char *)((void *)0);
#line 115
  done = 0;
#line 116
  firstline = 0;
#line 116
  lastline = 0;
#line 117
  bufsiz = (size_t )0;
#line 120
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)name_format,
          prologue_name);
#line 122
  filename = xpw_find_file((char * const  *)job___0->common.path, prologue_name, ".pro");
#line 123
  fp = xrfopen((char const   *)filename);
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 126
    tmp___8 = getshline_numbered(& firstline, & lastline, & buf___0, & bufsiz, fp);
    }
#line 126
    if (tmp___8 != -1) {
#line 126
      if (! (! done)) {
#line 126
        goto while_break;
      }
    } else {
#line 126
      goto while_break;
    }
    {
#line 132
    tmp___6 = strlen("Documentation");
#line 132
    tmp___7 = strncmp("Documentation", (char const   *)buf___0, tmp___6);
    }
#line 132
    if (! tmp___7) {
      {
#line 137
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 137
        tmp___0 = fgets((char */* __restrict  */)(buf2), (int )sizeof(buf2), (FILE */* __restrict  */)fp);
        }
#line 137
        if (tmp___0) {
          {
#line 137
          tmp___1 = strlen("EndDocumentation");
#line 137
          tmp___2 = strncmp("EndDocumentation", (char const   *)(buf2), tmp___1);
          }
#line 137
          if (! tmp___2) {
#line 137
            goto while_break___0;
          }
        } else {
#line 137
          goto while_break___0;
        }
        {
#line 140
        tmp = strlen((char const   *)(buf2));
        }
#line 140
        if ((unsigned long )tmp < sizeof(buf2)) {
#line 141
          lastline ++;
        }
        {
#line 142
        (*documentation_fn)((unsigned char const   *)((unsigned char *)(buf2)), "%s",
                            stream);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 144
      tmp___4 = strlen("EndDocumentation");
#line 144
      tmp___5 = strncmp("EndDocumentation", (char const   *)(buf2), tmp___4);
      }
#line 144
      if (tmp___5) {
        {
#line 145
        tmp___3 = gettext("missing argument for `%s\'");
#line 145
        error(1, 0, (char const   *)filename, firstline, tmp___3, "`Documentation\'");
        }
      }
#line 147
      done = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  _IO_putc('\n', stream);
#line 152
  free((void *)buf___0);
#line 153
  fclose(fp);
#line 154
  free((void *)filename);
  }
#line 155
  return;
}
}
#line 160 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
__inline static void prologues_list_long_internal(a2ps_job *job___0 , FILE *stream ,
                                                  char const   *name_format , void (*documentation_fn)(unsigned char const   *documentation ,
                                                                                                       char const   *format ,
                                                                                                       FILE *stream ) ) 
{ 
  struct darray *entries ;
  size_t i ;
  char *__cil_tmp7 ;

  {
  {
#line 168
  entries = pw_glob_on_suffix((char * const  *)job___0->common.path, ".pro");
#line 170
  i = (size_t )0;
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < entries->len)) {
#line 170
      goto while_break;
    }
    {
#line 171
    prologue_print_signature(job___0, (char const   *)*(entries->content + i), stream,
                             name_format, documentation_fn);
#line 170
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  da_free(entries, & free);
  }
#line 176
  return;
}
}
#line 178 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
void prologues_list_long(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 181
  tmp = gettext("Known Prologues");
#line 181
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
#line 182
  _IO_putc('\n', stream);
#line 184
  prologues_list_long_internal(job___0, stream, "Prologue \"%s\":\n", & documentation_print_plain);
  }
#line 187
  return;
}
}
#line 189 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
void prologues_list_texinfo(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 192
  fputs((char const   */* __restrict  */)"@table @samp\n", (FILE */* __restrict  */)stream);
#line 193
  prologues_list_long_internal(job___0, stream, "@item %s\n", & documentation_print_texinfo);
#line 195
  fputs((char const   */* __restrict  */)"@end table\n", (FILE */* __restrict  */)stream);
  }
#line 196
  return;
}
}
#line 208 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
static void dump_encodings(FILE *stream , a2ps_job *job___0 ) 
{ 


  {
  {
#line 213
  output_dump(job___0->ps_encodings, stream);
  }
#line 214
  return;
}
}
#line 219 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
static void dump_prolog_comments(FILE *stream , struct a2ps_job *job___0 ) 
{ 
  unsigned char *cp ;
  char *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 226
  fputs((char const   */* __restrict  */)((char *)(job___0->status)->magic_number),
        (FILE */* __restrict  */)stream);
#line 227
  _IO_putc('\n', stream);
#line 229
  cp = expand_user_string(job___0, (struct file_job *)*((job___0->jobs)->content + 0),
                          (unsigned char const   *)((unsigned char *)"Document title"),
                          (unsigned char const   *)job___0->title);
#line 231
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%Title: %s\n",
          cp);
#line 233
  cp = expand_user_string(job___0, (struct file_job *)*((job___0->jobs)->content + 0),
                          (unsigned char const   *)((unsigned char *)"User Name"),
                          (unsigned char const   *)"%N");
#line 235
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%For: %s\n",
          cp);
#line 236
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%Creator: %s version %s\n",
          "a2ps", "4.14");
#line 237
  tmp = asctime((struct tm  const  *)(& job___0->run_tm));
#line 237
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%CreationDate: %s",
          tmp);
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%BoundingBox: %d %d %d %d\n",
          (job___0->medium)->llx, (job___0->medium)->lly, (job___0->medium)->urx,
          (job___0->medium)->ury);
#line 242
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%DocumentData: Clean7Bit\n");
  }
#line 243
  if ((unsigned int )job___0->orientation == 1U) {
#line 243
    tmp___0 = "Landscape";
  } else {
#line 243
    tmp___0 = "Portrait";
  }
  {
#line 243
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%Orientation: %s\n",
          tmp___0);
#line 245
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%Pages: %d\n",
          job___0->sheets);
  }
#line 246
  if ((job___0->status)->page_are_ordered) {
    {
#line 247
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%PageOrder: Ascend\n");
    }
  } else {
    {
#line 249
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%PageOrder: Special\n");
    }
  }
  {
#line 250
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%DocumentMedia: %s %d %d 0 () ()\n",
          (job___0->medium)->name, (job___0->medium)->w, (job___0->medium)->h);
#line 254
  dump_needed_resources(stream, job___0);
#line 255
  dump_process_color(stream, job___0);
#line 256
  dump_requirements(stream, job___0);
#line 257
  dump_supplied_resources(stream, job___0);
#line 258
  fputs((char const   */* __restrict  */)"%%EndComments\n", (FILE */* __restrict  */)stream);
  }
#line 262
  if (ps_comment_hook) {
    {
#line 263
    (*ps_comment_hook)(job___0, stream);
    }
  }
#line 264
  return;
}
}
#line 269 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
static void output_prolog(a2ps_job *job___0 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 273
  output_delayed_routine(job___0->divertion, (void (*)(FILE *stream , void *arg ))(& dump_prolog_comments),
                         (void *)job___0);
  }
#line 278
  if (job___0->debug) {
    {
#line 279
    output_file(job___0->divertion, job___0, "ehandler", ".ps");
    }
  }
  {
#line 282
  output(job___0->divertion, "/a2psdict 200 dict def\n");
#line 283
  output(job___0->divertion, "a2psdict begin\n");
#line 286
  output(job___0->divertion, "%%%%BeginProlog\n");
#line 288
  output_file(job___0->divertion, job___0, (char const   *)job___0->prolog, ".pro");
#line 289
  output(job___0->divertion, "%%%%EndProlog\n");
  }
#line 290
  return;
}
}
#line 295 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
static void output_document_setup(a2ps_job *job___0 ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
  {
#line 301
  output(job___0->divertion, "%%%%BeginSetup\n");
#line 304
  check_face_eo_font(job___0);
#line 308
  encoding_build_faces_wx(job___0, job___0->requested_encoding);
#line 311
  output_delayed_routine(job___0->divertion, (void (*)(FILE *stream , void *arg ))(& dump_encodings),
                         (void *)job___0);
#line 316
  output_delayed_routine(job___0->divertion, (void (*)(FILE *stream , void *arg ))(& dump_fonts),
                         (void *)job___0);
#line 321
  output(job___0->divertion, "%% Initialize page description variables.\n");
  }
  {
#line 324
  if ((unsigned int )job___0->orientation == 0U) {
#line 324
    goto case_0;
  }
#line 334
  if ((unsigned int )job___0->orientation == 1U) {
#line 334
    goto case_1;
  }
#line 322
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 326
  output(job___0->divertion, "/sh %d def\n", (job___0->medium)->h);
#line 327
  output(job___0->divertion, "/sw %d def\n", (job___0->medium)->w);
#line 328
  output(job___0->divertion, "/llx %d def\n", (job___0->medium)->llx);
#line 329
  output(job___0->divertion, "/urx %d def\n", (job___0->medium)->urx - job___0->margin);
#line 330
  output(job___0->divertion, "/ury %d def\n", (job___0->medium)->ury);
#line 331
  output(job___0->divertion, "/lly %d def\n", (job___0->medium)->lly);
  }
#line 332
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 335
  output(job___0->divertion, "/sh %d def\n", (job___0->medium)->w);
#line 336
  output(job___0->divertion, "/sw %d def\n", (job___0->medium)->h);
#line 337
  output(job___0->divertion, "/llx %d def\n", (job___0->medium)->lly);
#line 338
  output(job___0->divertion, "/urx %d def\n", (job___0->medium)->ury);
#line 339
  output(job___0->divertion, "/ury %d def\n", (job___0->medium)->w - (job___0->medium)->llx);
#line 341
  output(job___0->divertion, "/lly %d def\n", ((job___0->medium)->w - (job___0->medium)->urx) + job___0->margin);
  }
#line 343
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 347
  output(job___0->divertion, "/#copies %d def\n", job___0->copies);
  }
#line 350
  if (job___0->page_prefeed) {
    {
#line 351
    output(job___0->divertion, "true page_prefeed\n");
    }
  }
  {
#line 354
  output_statusdict(job___0);
#line 357
  output_pagedevice(job___0);
#line 360
  output(job___0->divertion, "/th %f def\n", (double )(job___0->status)->title_bar_height);
#line 364
  output(job___0->divertion, "/fnfs %d def\n", (job___0->status)->title_font_size);
#line 365
  output(job___0->divertion, "/bfs %f def\n", (double )job___0->fontsize);
#line 366
  output(job___0->divertion, "/cw %f def\n", (double )job___0->fontsize * 0.6);
#line 367
  output(job___0->divertion, "\n");
#line 372
  output_delayed_routine(job___0->divertion, (void (*)(FILE *stream , void *arg ))(& dump_encodings_setup),
                         (void *)job___0);
#line 376
  output_delayed_routine(job___0->divertion, (void (*)(FILE *stream , void *arg ))(& dump_setup),
                         (void *)job___0);
#line 381
  output_delayed_routine(job___0->divertion, (void (*)(FILE *stream , void *arg ))(& font_info_table_dump_special_font_setup),
                         (void *)job___0);
#line 386
  output(job___0->divertion, "/hm fnfs 0.25 mul def\n");
#line 389
  output(job___0->divertion, "/pw\n");
#line 390
  output(job___0->divertion, "   cw %f mul\n", (double )((float )(job___0->status)->columnsperline) + (double )2 * 0.7);
#line 392
  output(job___0->divertion, "def\n");
#line 393
  output(job___0->divertion, "/ph\n");
#line 394
  output(job___0->divertion, "   %f th add\n", ((double )(job___0->status)->linesperpage + 0.7) * (double )job___0->fontsize);
#line 396
  output(job___0->divertion, "def\n");
  }
#line 397
  if (job___0->columns > 1) {
    {
#line 398
    output(job___0->divertion, "/pmw urx llx sub pw %d mul sub %d div def\n", job___0->columns,
           job___0->columns - 1);
    }
  } else {
    {
#line 401
    output(job___0->divertion, "/pmw 0 def\n");
    }
  }
#line 402
  if (job___0->rows > 1) {
#line 403
    if ((unsigned long )((char const   *)job___0->header) == (unsigned long )((void *)0)) {
#line 403
      tmp = 0;
    } else
#line 403
    if ((int )*(job___0->header) == 0) {
#line 403
      tmp = 0;
    } else {
#line 403
      tmp = 1;
    }
#line 403
    if ((unsigned long )((char const   *)job___0->footer) == (unsigned long )((void *)0)) {
#line 403
      goto _L___0;
    } else
#line 403
    if ((int )*(job___0->footer) == 0) {
      _L___0: /* CIL Label */ 
#line 403
      if ((unsigned long )((char const   *)job___0->left_footer) == (unsigned long )((void *)0)) {
#line 403
        goto _L;
      } else
#line 403
      if ((int )*(job___0->left_footer) == 0) {
        _L: /* CIL Label */ 
#line 403
        if ((unsigned long )((char const   *)job___0->right_footer) == (unsigned long )((void *)0)) {
#line 403
          tmp___0 = 0;
        } else
#line 403
        if ((int )*(job___0->right_footer) == 0) {
#line 403
          tmp___0 = 0;
        } else {
#line 403
          tmp___0 = 1;
        }
      } else {
#line 403
        tmp___0 = 1;
      }
    } else {
#line 403
      tmp___0 = 1;
    }
    {
#line 403
    output(job___0->divertion, "/pmh ury lly sub ph %d mul sub %d sub %d div def\n",
           job___0->rows, (tmp + tmp___0) * 12, job___0->rows - 1);
    }
  } else {
    {
#line 408
    output(job___0->divertion, "/pmh 0 def\n");
    }
  }
  {
#line 409
  output(job___0->divertion, "/v 0 def\n");
  }
  {
#line 412
  if ((unsigned int )job___0->madir == 0U) {
#line 412
    goto case_0___0;
  }
#line 430
  if ((unsigned int )job___0->madir == 1U) {
#line 430
    goto case_1___0;
  }
#line 447
  goto switch_default;
  case_0___0: /* CIL Label */ 
  {
#line 413
  output(job___0->divertion, "/x [\n");
#line 414
  j = 1;
  }
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (j <= job___0->rows)) {
#line 414
      goto while_break;
    }
    {
#line 415
    output(job___0->divertion, "  0\n");
#line 416
    i = 2;
    }
    {
#line 416
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 416
      if (! (i <= job___0->columns)) {
#line 416
        goto while_break___0;
      }
      {
#line 417
      output(job___0->divertion, "  dup pmw add pw add\n");
#line 416
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 414
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 419
  output(job___0->divertion, "] def\n");
#line 421
  output(job___0->divertion, "/y [\n");
#line 422
  j = job___0->rows;
  }
  {
#line 422
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 422
    if (! (1 <= j)) {
#line 422
      goto while_break___1;
    }
    {
#line 423
    output(job___0->divertion, "  pmh ph add %d mul ph add\n", j - 1);
#line 424
    i = 2;
    }
    {
#line 424
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 424
      if (! (i <= job___0->columns)) {
#line 424
        goto while_break___2;
      }
      {
#line 425
      output(job___0->divertion, "  dup\n");
#line 424
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 422
    j --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 427
  output(job___0->divertion, "] def\n");
  }
#line 428
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 431
  output(job___0->divertion, "/x [\n");
#line 432
  i = 1;
  }
  {
#line 432
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 432
    if (! (i <= job___0->columns)) {
#line 432
      goto while_break___3;
    }
    {
#line 433
    output(job___0->divertion, "  pmw pw add %d mul\n", i - 1);
#line 434
    j = 2;
    }
    {
#line 434
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 434
      if (! (j <= job___0->rows)) {
#line 434
        goto while_break___4;
      }
      {
#line 435
      output(job___0->divertion, "  dup\n");
#line 434
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 432
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 438
  output(job___0->divertion, "] def\n");
#line 440
  output(job___0->divertion, "/y [\n");
#line 441
  i = 1;
  }
  {
#line 441
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 441
    if (! (i <= job___0->columns)) {
#line 441
      goto while_break___5;
    }
#line 442
    j = job___0->rows;
    {
#line 442
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 442
      if (! (j >= 1)) {
#line 442
        goto while_break___6;
      }
      {
#line 443
      output(job___0->divertion, "  pmh ph add %d mul ph add\n", j - 1);
#line 442
      j --;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 441
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 445
  output(job___0->divertion, "] def\n");
  }
#line 446
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 448
  error(1, 0, "output_document_setup: bad switch");
  }
#line 449
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 452
  output(job___0->divertion, "/scx sw 2 div def\n");
#line 453
  output(job___0->divertion, "/scy sh 2 div def\n");
#line 455
  output(job___0->divertion, "/snx urx def\n");
#line 456
  output(job___0->divertion, "/sny lly 2 add def\n");
#line 457
  output(job___0->divertion, "/dx llx def\n");
#line 458
  output(job___0->divertion, "/dy sny def\n");
#line 459
  output(job___0->divertion, "/fnx scx def\n");
#line 460
  output(job___0->divertion, "/fny dy def\n");
#line 461
  output(job___0->divertion, "/lx snx def\n");
#line 462
  output(job___0->divertion, "/ly ury fnfs 0.8 mul sub def\n");
  }
#line 463
  if (job___0->numbering) {
#line 463
    tmp___1 = 5;
  } else {
#line 463
    tmp___1 = 0;
  }
  {
#line 463
  output(job___0->divertion, "/sx %d def\n", tmp___1);
#line 464
  output(job___0->divertion, "/tab %d def\n", job___0->tabsize);
#line 465
  output(job___0->divertion, "/x0 0 def\n");
#line 466
  output(job___0->divertion, "/y0 0 def\n");
#line 469
  output(job___0->divertion, "%%%%EndSetup\n\n");
  }
#line 470
  return;
}
}
#line 472 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
static void end_document(a2ps_job *job___0 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 475
  page_flush(job___0);
#line 476
  output(job___0->divertion, "\n%%%%Trailer\n");
  }
#line 478
  if (job___0->page_prefeed) {
    {
#line 479
    output(job___0->divertion, "false page_prefeed\n");
    }
  }
  {
#line 482
  output(job___0->divertion, "end\n");
#line 483
  output(job___0->divertion, "%%%%EOF\n");
  }
#line 484
  return;
}
}
#line 491 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
void ps_begin(struct a2ps_job *job___0 ) 
{ 
  float area_w ;
  float area_h ;
  float printing_h ;
  float printing_w ;
  struct medium *medium ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 494
  area_w = (float )0.0;
#line 494
  area_h = (float )0.0;
#line 496
  medium = job___0->medium;
#line 502
  output_prolog(job___0);
#line 504
  job___0->virtual = 0;
  }
  {
#line 507
  if ((unsigned int )job___0->orientation == 0U) {
#line 507
    goto case_0;
  }
#line 514
  if ((unsigned int )job___0->orientation == 1U) {
#line 514
    goto case_1;
  }
#line 506
  goto switch_break;
  case_0: /* CIL Label */ 
#line 508
  if ((unsigned long )((char const   *)job___0->header) == (unsigned long )((void *)0)) {
#line 508
    tmp = 0;
  } else
#line 508
  if ((int )*(job___0->header) == 0) {
#line 508
    tmp = 0;
  } else {
#line 508
    tmp = 1;
  }
#line 508
  if ((unsigned long )((char const   *)job___0->footer) == (unsigned long )((void *)0)) {
#line 508
    goto _L___0;
  } else
#line 508
  if ((int )*(job___0->footer) == 0) {
    _L___0: /* CIL Label */ 
#line 508
    if ((unsigned long )((char const   *)job___0->left_footer) == (unsigned long )((void *)0)) {
#line 508
      goto _L;
    } else
#line 508
    if ((int )*(job___0->left_footer) == 0) {
      _L: /* CIL Label */ 
#line 508
      if ((unsigned long )((char const   *)job___0->right_footer) == (unsigned long )((void *)0)) {
#line 508
        tmp___0 = 0;
      } else
#line 508
      if ((int )*(job___0->right_footer) == 0) {
#line 508
        tmp___0 = 0;
      } else {
#line 508
        tmp___0 = 1;
      }
    } else {
#line 508
      tmp___0 = 1;
    }
  } else {
#line 508
    tmp___0 = 1;
  }
#line 508
  area_h = (float )((medium->ury - medium->lly) - (tmp + tmp___0) * 12);
#line 511
  area_w = (float )((medium->urx - medium->llx) - job___0->margin);
#line 513
  goto switch_break;
  case_1: /* CIL Label */ 
#line 515
  area_w = (float )(medium->ury - medium->lly);
#line 516
  if ((unsigned long )((char const   *)job___0->header) == (unsigned long )((void *)0)) {
#line 516
    tmp___1 = 0;
  } else
#line 516
  if ((int )*(job___0->header) == 0) {
#line 516
    tmp___1 = 0;
  } else {
#line 516
    tmp___1 = 1;
  }
#line 516
  if ((unsigned long )((char const   *)job___0->footer) == (unsigned long )((void *)0)) {
#line 516
    goto _L___2;
  } else
#line 516
  if ((int )*(job___0->footer) == 0) {
    _L___2: /* CIL Label */ 
#line 516
    if ((unsigned long )((char const   *)job___0->left_footer) == (unsigned long )((void *)0)) {
#line 516
      goto _L___1;
    } else
#line 516
    if ((int )*(job___0->left_footer) == 0) {
      _L___1: /* CIL Label */ 
#line 516
      if ((unsigned long )((char const   *)job___0->right_footer) == (unsigned long )((void *)0)) {
#line 516
        tmp___2 = 0;
      } else
#line 516
      if ((int )*(job___0->right_footer) == 0) {
#line 516
        tmp___2 = 0;
      } else {
#line 516
        tmp___2 = 1;
      }
    } else {
#line 516
      tmp___2 = 1;
    }
  } else {
#line 516
    tmp___2 = 1;
  }
#line 516
  area_h = (float )(((medium->urx - medium->llx) - (tmp___1 + tmp___2) * 12) - job___0->margin);
#line 520
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 524
  if ((unsigned long )((char const   *)job___0->center_title) == (unsigned long )((void *)0)) {
#line 524
    goto _L___5;
  } else
#line 524
  if ((int )*(job___0->center_title) == 0) {
    _L___5: /* CIL Label */ 
#line 524
    if ((unsigned long )((char const   *)job___0->left_title) == (unsigned long )((void *)0)) {
#line 524
      goto _L___4;
    } else
#line 524
    if ((int )*(job___0->left_title) == 0) {
      _L___4: /* CIL Label */ 
#line 524
      if ((unsigned long )((char const   *)job___0->right_title) == (unsigned long )((void *)0)) {
#line 525
        (job___0->status)->title_font_size = 11;
#line 526
        (job___0->status)->title_bar_height = (float )0.0;
      } else
#line 524
      if ((int )*(job___0->right_title) == 0) {
#line 525
        (job___0->status)->title_font_size = 11;
#line 526
        (job___0->status)->title_bar_height = (float )0.0;
      } else
      _L___3: /* CIL Label */ 
#line 527
      if (job___0->columns * job___0->rows > 1) {
#line 528
        (job___0->status)->title_font_size = 11;
#line 529
        (job___0->status)->title_bar_height = (float )15;
      } else {
#line 531
        (job___0->status)->title_font_size = 15;
#line 532
        (job___0->status)->title_bar_height = (float )20;
      }
    } else {
#line 524
      goto _L___3;
    }
  } else {
#line 524
    goto _L___3;
  }
#line 536
  if (job___0->rows > 1) {
#line 536
    tmp___3 = 12;
  } else {
#line 536
    tmp___3 = 0;
  }
#line 536
  printing_h = ((area_h - (float )job___0->rows * (job___0->status)->title_bar_height) - (float )tmp___3) / (float )job___0->rows;
#line 542
  if (job___0->columns > 1) {
#line 542
    tmp___4 = 12;
  } else {
#line 542
    tmp___4 = 0;
  }
#line 542
  printing_w = (area_w - (float )tmp___4) / (float )job___0->columns;
#line 555
  if (job___0->columns_requested != 0) {
#line 556
    if (job___0->numbering) {
#line 556
      tmp___5 = 5;
    } else {
#line 556
      tmp___5 = 0;
    }
#line 556
    job___0->fontsize = (float )(((double )printing_w / ((double )(job___0->columns_requested + tmp___5) + (double )2 * 0.7)) / 0.6);
  } else
#line 560
  if (job___0->lines_requested != 0) {
#line 561
    job___0->fontsize = (float )((double )printing_h / ((double )job___0->lines_requested + 0.7));
  } else
#line 563
  if ((double )job___0->fontsize == 0.0) {
#line 564
    if ((unsigned int )job___0->orientation == 1U) {
#line 564
      job___0->fontsize = (float )6.8;
    } else {
#line 564
      if (job___0->columns * job___0->rows > 1) {
#line 564
        tmp___6 = 6.4;
      } else {
#line 564
        tmp___6 = 9.0;
      }
#line 564
      job___0->fontsize = (float )tmp___6;
    }
  }
#line 568
  (job___0->status)->linesperpage = (int )((double )(printing_h / job___0->fontsize) - 0.7);
#line 570
  (job___0->status)->columnsperline = (unsigned int )((int )((double )printing_w / ((double )job___0->fontsize * 0.6) - (double )2 * 0.7));
#line 573
  if (job___0->columns_requested > 0) {
#line 574
    if (job___0->numbering) {
#line 574
      tmp___7 = 5;
    } else {
#line 574
      tmp___7 = 0;
    }
#line 574
    (job___0->status)->columnsperline = (unsigned int )(job___0->columns_requested + tmp___7);
  } else
#line 575
  if (job___0->lines_requested > 0) {
#line 576
    (job___0->status)->linesperpage = job___0->lines_requested;
  }
#line 578
  if ((job___0->status)->linesperpage <= 0) {
    {
#line 579
    tmp___8 = gettext("font %f too big");
#line 579
    error(1, 0, (char const   *)tmp___8, (double )job___0->fontsize);
    }
  } else
#line 578
  if ((job___0->status)->columnsperline <= 0U) {
    {
#line 579
    tmp___8 = gettext("font %f too big");
#line 579
    error(1, 0, (char const   *)tmp___8, (double )job___0->fontsize);
    }
  }
#line 581
  if (job___0->numbering) {
#line 581
    tmp___9 = 5;
  } else {
#line 581
    tmp___9 = 0;
  }
  {
#line 581
  (job___0->status)->wxperline = (unsigned long )(((job___0->status)->columnsperline - (unsigned int )tmp___9) * 600U);
#line 584
  output_document_setup(job___0);
#line 595
  job___0->saved_encoding = job___0->requested_encoding;
  }
#line 596
  return;
}
}
#line 601 "/home/ysko/Works/test-src/a2ps-4.14/lib/prolog.c"
void ps_end(struct a2ps_job *job___0 ) 
{ 


  {
  {
#line 607
  output_to_void(job___0->divertion, 0);
#line 610
  end_document(job___0);
#line 613
  undivert(job___0);
  }
#line 614
  return;
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
#line 720 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/lib/printlen.h"
int ( /* format attribute */  printflen)(char const   *format  , ...) ;
#line 30 "/home/ysko/Works/test-src/a2ps-4.14/lib/printlen.c"
static int int_printflen(char const   *format , va_list ap ) 
{ 
  char const   *cp ;
  int total_width ;
  int width ;
  char *tmp ;
  int tmp___1 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___6 ;
  double tmp___8 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___13 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 34
  total_width = 0;
#line 35
  width = 0;
#line 37
  cp = format;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! *cp) {
#line 37
      goto while_break;
    }
#line 39
    if ((int const   )*cp != 37) {
#line 40
      total_width ++;
    } else {
#line 44
      cp ++;
#line 45
      width = 0;
      {
#line 46
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 46
        tmp = strchr("-+ #0", (int )*cp);
        }
#line 46
        if (! tmp) {
#line 46
          goto while_break___0;
        }
#line 47
        cp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 48
      if ((int const   )*cp == 42) {
        {
#line 50
        cp ++;
#line 51
        tmp___1 = __builtin_va_arg(ap, int );
#line 51
        width = abs(tmp___1);
        }
      }
#line 53
      if ((int const   )*cp == 46) {
#line 55
        cp ++;
#line 56
        if ((int const   )*cp == 42) {
          {
#line 58
          cp ++;
#line 59
          tmp___3 = __builtin_va_arg(ap, int );
#line 59
          width = abs(tmp___3);
          }
        }
      }
      {
#line 62
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 62
        tmp___4 = strchr("hlL", (int )*cp);
        }
#line 62
        if (! tmp___4) {
#line 62
          goto while_break___1;
        }
#line 63
        cp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 73
      if ((int const   )*cp == 99) {
#line 73
        goto case_99;
      }
#line 73
      if ((int const   )*cp == 88) {
#line 73
        goto case_99;
      }
#line 73
      if ((int const   )*cp == 120) {
#line 73
        goto case_99;
      }
#line 73
      if ((int const   )*cp == 117) {
#line 73
        goto case_99;
      }
#line 73
      if ((int const   )*cp == 111) {
#line 73
        goto case_99;
      }
#line 73
      if ((int const   )*cp == 105) {
#line 73
        goto case_99;
      }
#line 73
      if ((int const   )*cp == 100) {
#line 73
        goto case_99;
      }
#line 80
      if ((int const   )*cp == 71) {
#line 80
        goto case_71;
      }
#line 80
      if ((int const   )*cp == 103) {
#line 80
        goto case_71;
      }
#line 80
      if ((int const   )*cp == 69) {
#line 80
        goto case_71;
      }
#line 80
      if ((int const   )*cp == 101) {
#line 80
        goto case_71;
      }
#line 80
      if ((int const   )*cp == 102) {
#line 80
        goto case_71;
      }
#line 83
      if ((int const   )*cp == 115) {
#line 83
        goto case_115;
      }
#line 87
      if ((int const   )*cp == 110) {
#line 87
        goto case_110;
      }
#line 87
      if ((int const   )*cp == 112) {
#line 87
        goto case_110;
      }
#line 65
      goto switch_break;
      case_99: /* CIL Label */ 
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
      {
#line 74
      tmp___6 = __builtin_va_arg(ap, int );
      }
#line 75
      goto switch_break;
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_102: /* CIL Label */ 
      {
#line 81
      tmp___8 = __builtin_va_arg(ap, double );
      }
#line 82
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 84
      tmp___10 = __builtin_va_arg(ap, char *);
#line 84
      tmp___11 = strlen((char const   *)tmp___10);
#line 84
      total_width = (int )((size_t )total_width + tmp___11);
      }
#line 85
      goto switch_break;
      case_110: /* CIL Label */ 
      case_112: /* CIL Label */ 
      {
#line 88
      tmp___13 = __builtin_va_arg(ap, char *);
      }
#line 89
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 37
    cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return (total_width);
}
}
#line 96 "/home/ysko/Works/test-src/a2ps-4.14/lib/printlen.c"
int vprintflen(char const   *format , va_list args ) 
{ 
  va_list ap ;
  int ret ;

  {
  {
#line 102
  __builtin_va_copy(ap, args);
#line 104
  ret = int_printflen(format, ap);
#line 106
  __builtin_va_end(ap);
  }
#line 108
  return (ret);
}
}
#line 111 "/home/ysko/Works/test-src/a2ps-4.14/lib/printlen.c"
int ( /* format attribute */  printflen)(char const   *format  , ...) 
{ 
  va_list args ;
  int res___2 ;

  {
  {
#line 123
  __builtin_va_start(args, format);
#line 125
  res___2 = vprintflen(format, args);
#line 126
  __builtin_va_end(args);
  }
#line 128
  return (res___2);
}
}
#line 346 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 77 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.h"
void hash_maparg(struct hash_table_s *ht , void (*map)(void const   *item , void const   *arg ) ,
                 void const   *arg , int (*compare)(void const   * , void const   * ) ) ;
#line 49 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.h"
void a2ps_printers_list_short(struct a2ps_job *job___0 , FILE *stream ) ;
#line 50
void a2ps_printers_list_long(struct a2ps_job *job___0 , FILE *stream ) ;
#line 51
void a2ps_ppd_list_short(struct a2ps_job *job___0 , FILE *stream ) ;
#line 52
void a2ps_ppd_list_long(struct a2ps_job *job___0 , FILE *stream ) ;
#line 56
void a2ps_open_output_stream(struct a2ps_job *job___0 ) ;
#line 57
void a2ps_close_output_stream(struct a2ps_job *job___0 ) ;
#line 59
unsigned char *a2ps_flag_destination_to_string(struct a2ps_job *job___0 ) ;
#line 61
unsigned char *a2ps_destination_to_string(struct a2ps_job *job___0 ) ;
#line 65
struct a2ps_printers_s *a2ps_printers_new(struct a2ps_common_s *common ) ;
#line 69
void a2ps_printers_free(struct a2ps_printers_s *printers ) ;
#line 72
void a2ps_printers_finalize(struct a2ps_printers_s *printers ) ;
#line 75
char const   *a2ps_printers_default_ppdkey_get(struct a2ps_printers_s *printers ) ;
#line 78
void a2ps_printers_default_ppdkey_set(struct a2ps_printers_s *printers , char const   *ppdkey ) ;
#line 82
char const   *a2ps_printers_request_ppdkey_get(struct a2ps_printers_s *printers ) ;
#line 85
void a2ps_printers_request_ppdkey_set(struct a2ps_printers_s *printers , char const   *ppdkey ) ;
#line 89
_Bool a2ps_printers_add(struct a2ps_printers_s *printers , char const   *key , char *definition ) ;
#line 93
int a2ps_printers_font_known_p(struct a2ps_printers_s *printers , char const   *name ) ;
#line 101
void a2ps_printers_flag_output_set(struct a2ps_printers_s *printers , char const   *flag_output_name ,
                                   _Bool is_printer ) ;
#line 104
char const   *a2ps_printers_flag_output_name_get(struct a2ps_printers_s *printers ) ;
#line 106
_Bool a2ps_printers_flag_output_is_printer_get(struct a2ps_printers_s *printers ) ;
#line 53 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.h"
int ppd_font_known_p(struct ppd *ppd , char const   *fontname ) ;
#line 59
void ppd_free(struct ppd *ppd ) ;
#line 60
struct ppd *_a2ps_ppd_get(char * const  *path , char const   *key ) ;
#line 65
void _a2ps_ppd_list_short(char * const  *path , FILE *stream ) ;
#line 66
void _a2ps_ppd_list_long(char * const  *path , FILE *stream ) ;
#line 63 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.h"
void lister_fprint_vertical(struct lister *lister , FILE *unused  __attribute__((__unused__)) ,
                            void **items , size_t item_number , size_t (*item_width_fn)(void const   *item ) ,
                            void (*item_print_fn)(void const   *item , FILE *stream ) ) ;
#line 72 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static unsigned long printer_hash_1(struct printer *printer ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    result = 0UL;
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 75
      kk = (unsigned char const   *)printer->key - 1;
      {
#line 75
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 75
        kk ++;
#line 75
        if (! *kk) {
#line 75
          goto while_break___1;
        }
#line 75
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 75
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 75
    return (result);
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (0UL);
}
}
#line 78 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static unsigned long printer_hash_2(struct printer *printer ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    result = 0UL;
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      kk = (unsigned char const   *)printer->key - 1;
      {
#line 81
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 81
        kk ++;
#line 81
        if (! *kk) {
#line 81
          goto while_break___1;
        }
#line 81
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 81
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 81
    return (result);
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (0UL);
}
}
#line 84 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static int printer_hash_cmp(struct printer *x , struct printer *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 87
      xx = (unsigned char const   *)x->key - 1;
#line 87
      yy = (unsigned char const   *)y->key - 1;
      {
#line 87
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 87
        xx ++;
#line 87
        if ((int const   )*xx == 0) {
#line 87
          yy ++;
#line 87
          goto while_break___1;
        }
#line 87
        yy ++;
#line 87
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 87
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 87
      result = (int )((int const   )*xx - (int const   )*yy);
#line 87
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 87
    return (result);
#line 87
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (0);
}
}
#line 90 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static int printer_hash_qcmp(struct printer **x , struct printer **y ) 
{ 
  int tmp ;

  {
  {
#line 93
  tmp = strverscmp((char const   *)(*x)->key, (char const   *)(*y)->key);
  }
#line 93
  return (tmp);
}
}
#line 98 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static size_t printer_key_len(struct printer *printer ) 
{ 
  size_t tmp ;

  {
  {
#line 101
  tmp = strlen((char const   *)printer->key);
  }
#line 101
  return (tmp);
}
}
#line 106 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static void printer_key_fputs(struct printer *printer , FILE *stream ) 
{ 


  {
  {
#line 109
  fputs((char const   */* __restrict  */)printer->key, (FILE */* __restrict  */)stream);
  }
#line 110
  return;
}
}
#line 114 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static void printer_create(struct printer *p , char const   *key ) 
{ 


  {
  {
#line 117
  p->key = xstrdup(key);
#line 118
  p->ppdkey = (char *)((void *)0);
#line 119
  p->command = (char *)((void *)0);
  }
#line 120
  return;
}
}
#line 123 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static void printer_set(struct printer *p , char const   *ppdkey , char const   *command ) 
{ 
  char const   *my_s2 ;
  char *tmp ;
  char const   *my_s2___0 ;
  char *tmp___0 ;

  {
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    my_s2 = ppdkey;
    {
#line 127
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 127
      if (p->ppdkey) {
        {
#line 127
        free((void *)p->ppdkey);
        }
      }
#line 127
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 127
    if ((unsigned long )my_s2 == (unsigned long )((void *)0)) {
#line 127
      p->ppdkey = (char *)((void *)0);
    } else
#line 127
    if ((int const   )*my_s2 == 0) {
#line 127
      p->ppdkey = (char *)((void *)0);
    } else {
      {
#line 127
      tmp = xstrdup(my_s2);
#line 127
      p->ppdkey = tmp;
      }
    }
#line 127
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 128
    my_s2___0 = command;
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 128
      if (p->command) {
        {
#line 128
        free((void *)p->command);
        }
      }
#line 128
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 128
    if ((unsigned long )my_s2___0 == (unsigned long )((void *)0)) {
#line 128
      p->command = (char *)((void *)0);
    } else
#line 128
    if ((int const   )*my_s2___0 == 0) {
#line 128
      p->command = (char *)((void *)0);
    } else {
      {
#line 128
      tmp___0 = xstrdup(my_s2___0);
#line 128
      p->command = tmp___0;
      }
    }
#line 128
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 133 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static struct printer *printer_new(char const   *key ) 
{ 
  struct printer *res___2 ;
  void *tmp ;

  {
  {
#line 136
  tmp = xmalloc((size_t )sizeof(struct printer ));
#line 136
  res___2 = (struct printer *)tmp;
#line 137
  printer_create(res___2, key);
  }
#line 138
  return (res___2);
}
}
#line 144 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static void printer_free(struct printer *printer ) 
{ 


  {
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (printer->key) {
      {
#line 148
      free((void *)printer->key);
      }
    }
#line 148
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if (printer->ppdkey) {
      {
#line 149
      free((void *)printer->ppdkey);
      }
    }
#line 149
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 150
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 150
    if (printer->command) {
      {
#line 150
      free((void *)printer->command);
      }
    }
#line 150
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 157 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static void printer_self_print(struct printer *printer , FILE *stream ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 160
  fputs((char const   */* __restrict  */)"- ", (FILE */* __restrict  */)stream);
#line 161
  fputs((char const   */* __restrict  */)printer->key, (FILE */* __restrict  */)stream);
  }
#line 162
  if (printer->ppdkey) {
    {
#line 163
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" (PPD: %s)",
            printer->ppdkey);
    }
  }
  {
#line 164
  _IO_putc('\n', stream);
  }
#line 166
  if (printer->command) {
    {
#line 167
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  %s\n",
            printer->command);
    }
  }
#line 168
  return;
}
}
#line 177 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
__inline static struct hash_table_s *printer_table_new(void) 
{ 
  struct hash_table_s *res___2 ;
  void *tmp ;

  {
  {
#line 180
  tmp = xmalloc((size_t )sizeof(struct hash_table_s ));
#line 180
  res___2 = (struct hash_table_s *)tmp;
#line 182
  hash_init(res___2, 8UL, (unsigned long (*)(void const   *key ))(& printer_hash_1),
            (unsigned long (*)(void const   *key ))(& printer_hash_2), (int (*)(void const   *x ,
                                                                                void const   *y ))(& printer_hash_cmp));
  }
#line 187
  return (res___2);
}
}
#line 193 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
__inline static void printer_table_free(struct hash_table_s *table ) 
{ 


  {
  {
#line 196
  hash_free(table, (void (*)(void const   *item ))(& printer_free));
#line 197
  free((void *)table);
  }
#line 198
  return;
}
}
#line 203 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
__inline static struct printer *printer_table_find(struct hash_table_s *table , char const   *key ) 
{ 
  struct printer token___1 ;
  void *tmp ;

  {
  {
#line 208
  token___1.key = (char *)key;
#line 209
  tmp = hash_find_item(table, (void const   *)(& token___1));
  }
#line 209
  return ((struct printer *)tmp);
}
}
#line 216 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
__inline static void printer_table_add(struct hash_table_s *table , char const   *key ,
                                       char const   *ppdkey , char const   *command ) 
{ 
  struct printer *printer ;

  {
  {
#line 223
  printer = printer_table_find(table, key);
  }
#line 224
  if (! printer) {
    {
#line 225
    printer = printer_new(key);
    }
  }
  {
#line 227
  printer_set(printer, ppdkey, command);
#line 229
  hash_insert(table, (void *)printer);
  }
#line 230
  return;
}
}
#line 235 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static void printer_table_short_self_print(struct hash_table_s *table , FILE *stream ) 
{ 
  struct printer **entries ;
  size_t size ;
  void **tmp ;

  {
  {
#line 241
  tmp = hash_dump(table, (void **)((void *)0), (int (*)(void const   *x , void const   *y ))(& printer_hash_qcmp));
#line 241
  entries = (struct printer **)tmp;
#line 245
  size = (size_t )0;
  }
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! *(entries + size)) {
#line 245
      goto while_break;
    }
#line 245
    size ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 248
  lister_fprint_vertical((struct lister *)((void *)0), stream, (void **)((void *)entries),
                         size, (size_t (*)(void const   *item ))(& printer_key_len),
                         (void (*)(void const   *item , FILE *stream ))(& printer_key_fputs));
#line 253
  free((void *)entries);
  }
#line 254
  return;
}
}
#line 259 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static void printer_table_self_print(struct hash_table_s *table , FILE *stream ) 
{ 


  {
  {
#line 262
  hash_maparg(table, (void (*)(void const   *item , void const   *arg ))(& printer_self_print),
              (void const   *)stream, (int (*)(void const   * , void const   * ))(& printer_hash_qcmp));
  }
#line 264
  return;
}
}
#line 299 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
struct a2ps_printers_s *a2ps_printers_new(struct a2ps_common_s *common ) 
{ 
  struct a2ps_printers_s *res___2 ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 302
  tmp = xmalloc((size_t )sizeof(struct a2ps_printers_s ));
#line 302
  res___2 = (struct a2ps_printers_s *)tmp;
#line 305
  res___2->common = common;
#line 308
  res___2->printers = printer_table_new();
#line 309
  tmp___0 = gettext("Default Printer");
#line 309
  printer_create(& res___2->default_printer, (char const   *)tmp___0);
#line 310
  tmp___1 = gettext("Unknown Printer");
#line 310
  printer_create(& res___2->unknown_printer, (char const   *)tmp___1);
#line 313
  res___2->request_ppdkey = (char *)((void *)0);
#line 314
  res___2->default_ppdkey = xstrdup("level1");
#line 315
  res___2->ppd = (struct ppd *)((void *)0);
#line 319
  res___2->flag_output_is_printer = (_Bool)1;
#line 320
  res___2->flag_output_name = (char *)((void *)0);
#line 321
  res___2->output_is_file = (_Bool)1;
#line 322
  res___2->output_name = (char *)((void *)0);
  }
#line 324
  return (res___2);
}
}
#line 331 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_printers_free(struct a2ps_printers_s *printers ) 
{ 


  {
  {
#line 336
  printer_table_free(printers->printers);
#line 337
  printer_free(& printers->default_printer);
#line 338
  printer_free(& printers->unknown_printer);
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (printers->request_ppdkey) {
      {
#line 341
      free((void *)printers->request_ppdkey);
      }
    }
#line 341
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 342
    if (printers->default_ppdkey) {
      {
#line 342
      free((void *)printers->default_ppdkey);
      }
    }
#line 342
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 343
  ppd_free(printers->ppd);
  }
  {
#line 346
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 346
    if (printers->flag_output_name) {
      {
#line 346
      free((void *)printers->flag_output_name);
      }
    }
#line 346
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 347
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 347
    if (printers->output_name) {
      {
#line 347
      free((void *)printers->output_name);
      }
    }
#line 347
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 349
  free((void *)printers);
  }
#line 350
  return;
}
}
#line 356 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static char const   *a2ps_printers_ppdkey_get(struct a2ps_printers_s *printers , char const   *key ) 
{ 
  struct printer *printer ;

  {
#line 363
  if (! key) {
#line 364
    return ((char const   *)printers->default_printer.ppdkey);
  }
  {
#line 367
  printer = printer_table_find(printers->printers, key);
  }
#line 369
  if (printer) {
#line 369
    if (printer->ppdkey) {
#line 371
      return ((char const   *)printer->ppdkey);
    }
  }
#line 375
  return ((char const   *)printers->unknown_printer.ppdkey);
}
}
#line 381 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static char const   *a2ps_printers_command_get(struct a2ps_printers_s *printers ,
                                               char const   *key ) 
{ 
  struct printer *printer ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 388
  if (! key) {
#line 390
    if (! printers->default_printer.command) {
      {
#line 395
      tmp = gettext("Default Printer");
#line 395
      tmp___0 = gettext("no command for the `%s\' (%s%s)");
#line 395
      error(1, 0, (char const   *)tmp___0, tmp, "-d", "");
      }
    }
#line 398
    return ((char const   *)printers->default_printer.command);
  }
  {
#line 402
  printer = printer_table_find(printers->printers, key);
  }
#line 404
  if (printer) {
#line 404
    if (printer->command) {
#line 406
      return ((char const   *)printer->command);
    }
  }
#line 410
  if (! printers->unknown_printer.command) {
    {
#line 412
    tmp___1 = gettext("Unknown Printer");
#line 412
    tmp___2 = gettext("no command for the `%s\' (%s%s)");
#line 412
    error(1, 0, (char const   *)tmp___2, tmp___1, "-P ", key);
    }
  }
#line 416
  return ((char const   *)printers->unknown_printer.command);
}
}
#line 421 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
static unsigned char *destination_to_string(char const   *name , _Bool file_p ) 
{ 
  unsigned char *res___2 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *format ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 426
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 426
    goto _L;
  } else
#line 426
  if ((int const   )*name == 0) {
    _L: /* CIL Label */ 
#line 428
    if (file_p) {
      {
#line 428
      tmp = gettext("sent to the standard output");
#line 428
      tmp___0 = xstrdup((char const   *)tmp);
#line 428
      res___2 = (unsigned char *)tmp___0;
      }
    } else {
      {
#line 428
      tmp___1 = gettext("sent to the default printer");
#line 428
      tmp___2 = xstrdup((char const   *)tmp___1);
#line 428
      res___2 = (unsigned char *)tmp___2;
      }
    }
  } else {
#line 434
    if (file_p) {
      {
#line 434
      tmp___3 = gettext("saved into the file `%s\'");
#line 434
      tmp___5 = tmp___3;
      }
    } else {
      {
#line 434
      tmp___4 = gettext("sent to the printer `%s\'");
#line 434
      tmp___5 = tmp___4;
      }
    }
    {
#line 434
    format = tmp___5;
#line 437
    tmp___6 = strlen((char const   *)format);
#line 437
    tmp___7 = strlen(name);
#line 437
    tmp___8 = xmalloc((size_t )(sizeof(unsigned char ) * (unsigned long )(tmp___6 + tmp___7)));
#line 437
    res___2 = (unsigned char *)tmp___8;
#line 438
    sprintf((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)format,
            name);
    }
  }
#line 440
  return (res___2);
}
}
#line 448 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
unsigned char *a2ps_flag_destination_to_string(struct a2ps_job *job___0 ) 
{ 
  int tmp ;
  unsigned char *tmp___0 ;

  {
#line 452
  if ((job___0->printers)->flag_output_is_printer) {
#line 452
    tmp = 0;
  } else {
#line 452
    tmp = 1;
  }
  {
#line 452
  tmp___0 = destination_to_string((char const   *)(job___0->printers)->flag_output_name,
                                  (_Bool )tmp);
  }
#line 452
  return (tmp___0);
}
}
#line 460 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
unsigned char *a2ps_destination_to_string(struct a2ps_job *job___0 ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 465
  tmp = destination_to_string((char const   *)(job___0->printers)->output_name, (job___0->printers)->output_is_file);
  }
#line 465
  return (tmp);
}
}
#line 474 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_printers_finalize(struct a2ps_printers_s *printers ) 
{ 
  char const   *ppdkey ;

  {
#line 480
  ppdkey = (char const   *)printers->request_ppdkey;
#line 480
  if (! ppdkey) {
#line 482
    if (printers->flag_output_is_printer) {
      {
#line 483
      ppdkey = a2ps_printers_ppdkey_get(printers, (char const   *)printers->flag_output_name);
      }
    }
  }
#line 484
  if (! ppdkey) {
#line 485
    ppdkey = (char const   *)printers->default_ppdkey;
  }
  {
#line 488
  printers->ppd = _a2ps_ppd_get((char * const  *)(printers->common)->path, ppdkey);
  }
#line 490
  return;
}
}
#line 496 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
_Bool a2ps_printers_add(struct a2ps_printers_s *printers , char const   *key , char *definition ) 
{ 
  char *ppdkey ;
  char *token___1 ;
  char *command ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 500
  ppdkey = (char *)((void *)0);
#line 501
  token___1 = (char *)((void *)0);
#line 502
  command = (char *)((void *)0);
#line 505
  tmp = strspn((char const   *)definition, " \t");
#line 505
  token___1 = definition + tmp;
  }
#line 508
  if ((int )*token___1 != 62) {
#line 508
    if ((int )*token___1 != 124) {
      {
#line 512
      ppdkey = strtok((char */* __restrict  */)token___1, (char const   */* __restrict  */)" \t");
#line 513
      token___1 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 518
      tmp___0 = strspn((char const   *)token___1, " \t");
#line 518
      token___1 += tmp___0;
      }
    }
  } else {
    {
#line 518
    tmp___0 = strspn((char const   *)token___1, " \t");
#line 518
    token___1 += tmp___0;
    }
  }
  {
#line 522
  command = token___1;
#line 525
  tmp___3 = gettext("Default Printer");
#line 525
  tmp___4 = strcmp(key, (char const   *)tmp___3);
  }
#line 525
  if (tmp___4 == 0) {
    {
#line 526
    printer_set(& printers->default_printer, (char const   *)ppdkey, (char const   *)command);
    }
  } else {
    {
#line 527
    tmp___1 = gettext("Unknown Printer");
#line 527
    tmp___2 = strcmp(key, (char const   *)tmp___1);
    }
#line 527
    if (tmp___2 == 0) {
      {
#line 528
      printer_set(& printers->unknown_printer, (char const   *)ppdkey, (char const   *)command);
      }
    } else {
      {
#line 530
      printer_table_add(printers->printers, key, (char const   *)ppdkey, (char const   *)command);
      }
    }
  }
#line 533
  return ((_Bool)1);
}
}
#line 539 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
char const   *a2ps_printers_default_ppdkey_get(struct a2ps_printers_s *printers ) 
{ 


  {
#line 542
  return ((char const   *)printers->default_ppdkey);
}
}
#line 545 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_printers_default_ppdkey_set(struct a2ps_printers_s *printers , char const   *ppdkey ) 
{ 
  char const   *my_s2 ;
  char *tmp ;

  {
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 549
    my_s2 = ppdkey;
    {
#line 549
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 549
      if (printers->default_ppdkey) {
        {
#line 549
        free((void *)printers->default_ppdkey);
        }
      }
#line 549
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 549
    if ((unsigned long )my_s2 == (unsigned long )((void *)0)) {
#line 549
      printers->default_ppdkey = (char *)((void *)0);
    } else
#line 549
    if ((int const   )*my_s2 == 0) {
#line 549
      printers->default_ppdkey = (char *)((void *)0);
    } else {
      {
#line 549
      tmp = xstrdup(my_s2);
#line 549
      printers->default_ppdkey = tmp;
      }
    }
#line 549
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 550
  return;
}
}
#line 552 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
char const   *a2ps_printers_request_ppdkey_get(struct a2ps_printers_s *printers ) 
{ 


  {
#line 555
  return ((char const   *)printers->request_ppdkey);
}
}
#line 558 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_printers_request_ppdkey_set(struct a2ps_printers_s *printers , char const   *ppdkey ) 
{ 
  char const   *my_s2 ;
  char *tmp ;

  {
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    my_s2 = ppdkey;
    {
#line 562
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 562
      if (printers->request_ppdkey) {
        {
#line 562
        free((void *)printers->request_ppdkey);
        }
      }
#line 562
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 562
    if ((unsigned long )my_s2 == (unsigned long )((void *)0)) {
#line 562
      printers->request_ppdkey = (char *)((void *)0);
    } else
#line 562
    if ((int const   )*my_s2 == 0) {
#line 562
      printers->request_ppdkey = (char *)((void *)0);
    } else {
      {
#line 562
      tmp = xstrdup(my_s2);
#line 562
      printers->request_ppdkey = tmp;
      }
    }
#line 562
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  return;
}
}
#line 568 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_printers_flag_output_set(struct a2ps_printers_s *printers , char const   *flag_output_name ,
                                   _Bool is_printer ) 
{ 
  char const   *my_s2 ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 573
  printers->flag_output_is_printer = is_printer;
#line 575
  if (! is_printer) {
#line 575
    if (flag_output_name) {
      {
#line 575
      tmp___0 = strcmp(flag_output_name, "-");
      }
#line 575
      if (tmp___0 == 0) {
        {
#line 578
        while (1) {
          while_continue: /* CIL Label */ ;
#line 578
          if (printers->flag_output_name) {
            {
#line 578
            free((void *)printers->flag_output_name);
            }
          }
#line 578
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 579
        printers->flag_output_name = (char *)((void *)0);
      } else {
#line 575
        goto _L___0;
      }
    } else {
#line 575
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 582
      my_s2 = flag_output_name;
      {
#line 582
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 582
        if (printers->flag_output_name) {
          {
#line 582
          free((void *)printers->flag_output_name);
          }
        }
#line 582
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 582
      if ((unsigned long )my_s2 == (unsigned long )((void *)0)) {
#line 582
        printers->flag_output_name = (char *)((void *)0);
      } else
#line 582
      if ((int const   )*my_s2 == 0) {
#line 582
        printers->flag_output_name = (char *)((void *)0);
      } else {
        {
#line 582
        tmp = xstrdup(my_s2);
#line 582
        printers->flag_output_name = tmp;
        }
      }
#line 582
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 583
  return;
}
}
#line 585 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
char const   *a2ps_printers_flag_output_name_get(struct a2ps_printers_s *printers ) 
{ 


  {
#line 588
  return ((char const   *)printers->flag_output_name);
}
}
#line 591 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
_Bool a2ps_printers_flag_output_is_printer_get(struct a2ps_printers_s *printers ) 
{ 


  {
#line 594
  return (printers->flag_output_is_printer);
}
}
#line 600 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
int a2ps_printers_font_known_p(struct a2ps_printers_s *printers , char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 604
  tmp = ppd_font_known_p(printers->ppd, name);
  }
#line 604
  return (tmp);
}
}
#line 610 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_printers_list_short(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 613
  tmp = gettext("Known Outputs (Printers, etc.)");
#line 613
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
#line 614
  _IO_putc('\n', stream);
#line 615
  printer_table_short_self_print((job___0->printers)->printers, stream);
  }
#line 616
  return;
}
}
#line 618 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_printers_list_long(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 621
  tmp = gettext("Known Outputs (Printers, etc.)");
#line 621
  title(stream, (char )'=', 1, (char const   *)tmp);
#line 622
  _IO_putc('\n', stream);
#line 623
  printer_self_print(& (job___0->printers)->default_printer, stream);
#line 624
  printer_self_print(& (job___0->printers)->unknown_printer, stream);
#line 625
  printer_table_self_print((job___0->printers)->printers, stream);
  }
#line 626
  return;
}
}
#line 628 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_ppd_list_short(struct a2ps_job *job___0 , FILE *stream ) 
{ 


  {
  {
#line 631
  _a2ps_ppd_list_short((char * const  *)job___0->common.path, stream);
  }
#line 632
  return;
}
}
#line 634 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_ppd_list_long(struct a2ps_job *job___0 , FILE *stream ) 
{ 


  {
  {
#line 637
  _a2ps_ppd_list_long((char * const  *)job___0->common.path, stream);
  }
#line 638
  return;
}
}
#line 643 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_open_output_stream(struct a2ps_job *job___0 ) 
{ 
  struct a2ps_printers_s *printers ;
  char const   *my_s2 ;
  char *tmp ;
  char const   *name ;
  char const   *command ;
  char const   *printer_cmd ;
  unsigned char *tmp___0 ;
  char const   *my_s2___0 ;
  char *tmp___1 ;
  char *__cil_tmp11 ;

  {
#line 646
  printers = job___0->printers;
#line 650
  if (! printers->flag_output_is_printer) {
    {
#line 653
    job___0->output_stream = stream_wopen_backup((char const   *)printers->flag_output_name,
                                                 (_Bool)1, job___0->backup_type);
    }
    {
#line 657
    while (1) {
      while_continue: /* CIL Label */ ;
#line 657
      my_s2 = (char const   *)printers->flag_output_name;
      {
#line 657
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 657
        if (printers->output_name) {
          {
#line 657
          free((void *)printers->output_name);
          }
        }
#line 657
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 657
      if ((unsigned long )my_s2 == (unsigned long )((void *)0)) {
#line 657
        printers->output_name = (char *)((void *)0);
      } else
#line 657
      if ((int const   )*my_s2 == 0) {
#line 657
        printers->output_name = (char *)((void *)0);
      } else {
        {
#line 657
        tmp = xstrdup(my_s2);
#line 657
        printers->output_name = tmp;
        }
      }
#line 657
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 658
    printers->output_is_file = (_Bool)1;
  } else {
    {
#line 667
    printer_cmd = a2ps_printers_command_get(printers, (char const   *)printers->flag_output_name);
#line 671
    tmp___0 = expand_user_string(job___0, (struct file_job *)*((job___0->jobs)->content + 0),
                                 (unsigned char const   *)((unsigned char *)"output command"),
                                 (unsigned char const   *)((unsigned char *)printer_cmd));
#line 671
    command = (char const   *)((char *)tmp___0);
#line 674
    job___0->output_stream = stream_perl_open_backup(command, job___0->backup_type,
                                                     & name);
    }
#line 677
    if ((int const   )*command == 62) {
      {
#line 679
      printers->output_is_file = (_Bool)1;
#line 680
      printers->output_name = xstrdup(name);
      }
    } else {
      {
#line 685
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 685
        my_s2___0 = (char const   *)printers->flag_output_name;
        {
#line 685
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 685
          if (printers->output_name) {
            {
#line 685
            free((void *)printers->output_name);
            }
          }
#line 685
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 685
        if ((unsigned long )my_s2___0 == (unsigned long )((void *)0)) {
#line 685
          printers->output_name = (char *)((void *)0);
        } else
#line 685
        if ((int const   )*my_s2___0 == 0) {
#line 685
          printers->output_name = (char *)((void *)0);
        } else {
          {
#line 685
          tmp___1 = xstrdup(my_s2___0);
#line 685
          printers->output_name = tmp___1;
          }
        }
#line 685
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 686
      printers->output_is_file = (_Bool)0;
    }
  }
#line 689
  return;
}
}
#line 694 "/home/ysko/Works/test-src/a2ps-4.14/lib/printers.c"
void a2ps_close_output_stream(struct a2ps_job *job___0 ) 
{ 


  {
  {
#line 697
  stream_close(job___0->output_stream);
  }
#line 698
  return;
}
}
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 67 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.h"
struct darray *da_new(char const   *name , size_t size , enum da_growth growth , size_t increment ,
                      void (*self_print)(void const   * , FILE *stream ) , int (*cmp)(void const   *k1 ,
                                                                                      void const   *k2 ) ) ;
#line 72
void da_free_content(struct darray *arr , void (*free_func)(void * ) ) ;
#line 102
void da_append(struct darray *arr , void *elem ) ;
#line 116
void da_self_print(struct darray *arr , FILE *stream ) ;
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.h"
struct page_range *page_range_new(void) ;
#line 43
void page_range_free(struct page_range *page_range ) ;
#line 45
void a2ps_page_range_set_string(struct a2ps_job *job___0 , char const   *string ) ;
#line 48
void report_pages_to_print(struct a2ps_job *job___0 , FILE *stream ) ;
#line 54
void page_range_to_buffer(struct page_range *page_range , unsigned char *buf___0 ,
                          int offset ) ;
#line 56
int page_range_applies_above(struct page_range *page_range , int offset ) ;
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
static struct interval *interval_new(int min , int max ) 
{ 
  struct interval *res___2 ;
  void *tmp ;

  {
  {
#line 54
  tmp = xmalloc((size_t )sizeof(struct interval ));
#line 54
  res___2 = (struct interval *)tmp;
#line 55
  res___2->min = min;
#line 56
  res___2->max = max;
  }
#line 57
  return (res___2);
}
}
#line 60 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
static void interval_self_print(struct interval *interval , FILE *stream ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 63
  if (interval->min) {
#line 63
    if (interval->max) {
      {
#line 64
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d-%d",
              interval->min, interval->max);
      }
    } else {
#line 63
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 65
  if (interval->min) {
    {
#line 66
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d-",
            interval->min);
    }
  } else {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-%d",
            interval->max);
    }
  }
#line 69
  return;
}
}
#line 71 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
static int interval_is_in(struct interval *interval , int num ) 
{ 
  int tmp ;

  {
#line 74
  if (interval->min) {
#line 74
    if (interval->max) {
#line 75
      if (interval->min <= num) {
#line 75
        if (num <= interval->max) {
#line 75
          tmp = 1;
        } else {
#line 75
          tmp = 0;
        }
      } else {
#line 75
        tmp = 0;
      }
#line 75
      return (tmp);
    } else {
#line 74
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 76
  if (interval->min) {
#line 77
    return (interval->min <= num);
  } else {
#line 79
    return (num <= interval->max);
  }
}
}
#line 87 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
static unsigned char *interval_to_buffer(struct interval *interval , unsigned char *buf___0 ,
                                         int offset ) 
{ 
  int min ;
  size_t tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 90
  min = 0;
#line 93
  if (interval->max) {
#line 93
    if (interval->max < offset) {
#line 95
      return (buf___0);
    }
  }
#line 98
  if (interval->min) {
#line 98
    if (interval->min <= offset) {
#line 100
      min = 1;
    } else {
#line 102
      min = interval->min - offset;
    }
  } else {
#line 102
    min = interval->min - offset;
  }
#line 104
  if (min == interval->max) {
    {
#line 105
    sprintf((char */* __restrict  */)((char *)buf___0), (char const   */* __restrict  */)"%d",
            min);
    }
  } else
#line 106
  if (min) {
#line 106
    if (interval->max) {
      {
#line 107
      sprintf((char */* __restrict  */)((char *)buf___0), (char const   */* __restrict  */)"%d-%d",
              min, interval->max - offset);
      }
    } else {
#line 106
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 108
  if (min) {
    {
#line 109
    sprintf((char */* __restrict  */)((char *)buf___0), (char const   */* __restrict  */)"%d-",
            min);
    }
  } else {
    {
#line 113
    sprintf((char */* __restrict  */)((char *)buf___0), (char const   */* __restrict  */)"1-%d",
            interval->max - offset);
    }
  }
  {
#line 115
  tmp = strlen((char const   *)buf___0);
  }
#line 115
  return (buf___0 + tmp);
}
}
#line 125 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
__inline static int interval_applies_above(struct interval *interval , int offset ) 
{ 


  {
#line 128
  if (interval->min <= offset) {
#line 128
    if (interval->max == 0) {
#line 130
      return (0);
    }
  }
#line 135
  return (1);
}
}
#line 150 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
struct page_range *page_range_new(void) 
{ 
  struct page_range *res___2 ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 153
  tmp = xmalloc((size_t )sizeof(struct page_range ));
#line 153
  res___2 = (struct page_range *)tmp;
#line 154
  res___2->intervals = da_new("Page Range Interval", (size_t )5, (enum da_growth )1,
                              (size_t )10, (void (*)(void const   * , FILE *stream ))(& interval_self_print),
                              (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
#line 156
  res___2->toc = (_Bool)0;
  }
#line 157
  return (res___2);
}
}
#line 163 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
void page_range_free(struct page_range *page_range ) 
{ 


  {
  {
#line 166
  da_free(page_range->intervals, & free);
#line 167
  free((void *)page_range);
  }
#line 168
  return;
}
}
#line 173 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
static void page_range_reset(struct page_range *page_range ) 
{ 


  {
  {
#line 176
  da_free_content(page_range->intervals, & free);
#line 177
  page_range->toc = (_Bool)0;
  }
#line 178
  return;
}
}
#line 183 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
__inline static void page_range_self_print(struct page_range *page_range , FILE *stream ) 
{ 


  {
  {
#line 186
  da_self_print(page_range->intervals, stream);
  }
#line 187
  return;
}
}
#line 195 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
__inline static int add_pages_interval(struct a2ps_job *job___0 , int min , int max ) 
{ 
  struct interval *tmp ;

  {
#line 202
  if (max) {
#line 202
    if (max < min) {
#line 203
      return (0);
    }
  }
  {
#line 205
  tmp = interval_new(min, max);
#line 205
  da_append((job___0->page_range)->intervals, (void *)tmp);
  }
#line 206
  return (1);
}
}
#line 214 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
void page_range_to_buffer(struct page_range *page_range , unsigned char *buf___0 ,
                          int offset ) 
{ 
  size_t i ;
  int put_a_comma ;
  struct interval **intervals ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 218
  put_a_comma = 0;
#line 219
  intervals = (struct interval **)(page_range->intervals)->content;
#line 222
  i = (size_t )0;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (i < (page_range->intervals)->len)) {
#line 222
      goto while_break;
    }
    {
#line 223
    tmp___0 = interval_applies_above(*(intervals + i), offset);
    }
#line 223
    if (tmp___0) {
#line 225
      if (put_a_comma) {
#line 226
        tmp = buf___0;
#line 226
        buf___0 ++;
#line 226
        *tmp = (unsigned char )',';
      }
      {
#line 227
      buf___0 = interval_to_buffer(*(intervals + i), buf___0, offset);
#line 228
      put_a_comma = 1;
      }
    }
#line 222
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  return;
}
}
#line 237 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
int page_range_applies_above(struct page_range *page_range , int offset ) 
{ 
  size_t i ;
  struct interval **intervals ;

  {
#line 241
  intervals = (struct interval **)(page_range->intervals)->content;
#line 244
  if ((page_range->intervals)->len == 0U) {
#line 245
    return (0);
  }
#line 247
  i = (size_t )0;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (i < (page_range->intervals)->len)) {
#line 247
      goto while_break;
    }
#line 248
    if ((*(intervals + i))->min < offset) {
#line 248
      if ((*(intervals + i))->max == 0) {
#line 251
        return (0);
      }
    }
#line 247
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (1);
}
}
#line 263 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
void a2ps_page_range_set_string(struct a2ps_job *job___0 , char const   *string ) 
{ 
  char *cp ;
  char *string_copy ;
  int min ;
  int max ;
  char const   *_tmp_ ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 272
  page_range_reset(job___0->page_range);
  }
#line 273
  if (! string) {
#line 274
    return;
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 277
    _tmp_ = string;
#line 277
    tmp = strlen(_tmp_);
#line 277
    tmp___0 = __builtin_alloca(sizeof(char ) * (unsigned long )(tmp + 1U));
#line 277
    string_copy = (char *)tmp___0;
#line 277
    strcpy((char */* __restrict  */)string_copy, (char const   */* __restrict  */)_tmp_);
    }
#line 277
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  cp = strtok((char */* __restrict  */)string_copy, (char const   */* __restrict  */)", \t");
  }
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 280
    if (! cp) {
#line 280
      goto while_break___0;
    }
    {
#line 282
    max = 0;
#line 282
    min = max;
#line 283
    tmp___2 = __ctype_b_loc();
    }
#line 283
    if ((int const   )*(*tmp___2 + (int )*cp) & 2048) {
      {
#line 285
      min = atoi((char const   *)cp);
      }
      {
#line 286
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 286
        tmp___1 = __ctype_b_loc();
        }
#line 286
        if (! ((int const   )*(*tmp___1 + (int )*cp) & 2048)) {
#line 286
          goto while_break___1;
        }
#line 287
        cp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 289
    tmp___3 = cp;
#line 289
    cp ++;
    {
#line 291
    if ((int )*tmp___3 == 0) {
#line 291
      goto case_0;
    }
#line 296
    if ((int )*tmp___3 == 45) {
#line 296
      goto case_45;
    }
#line 296
    if ((int )*tmp___3 == 58) {
#line 296
      goto case_45;
    }
#line 308
    if ((int )*tmp___3 == 116) {
#line 308
      goto case_116;
    }
#line 322
    goto failed;
    case_0: /* CIL Label */ 
    {
#line 292
    add_pages_interval(job___0, min, min);
    }
#line 293
    goto switch_break;
    case_45: /* CIL Label */ 
    case_58: /* CIL Label */ 
    {
#line 297
    max = atoi((char const   *)cp);
    }
    {
#line 298
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 298
      tmp___4 = __ctype_b_loc();
      }
#line 298
      if (! ((int const   )*(*tmp___4 + (int )*cp) & 2048)) {
#line 298
        goto while_break___2;
      }
#line 299
      cp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 301
    if ((int )*cp != 0) {
#line 302
      goto failed;
    }
    {
#line 303
    tmp___7 = add_pages_interval(job___0, min, max);
    }
#line 303
    if (! tmp___7) {
      {
#line 304
      tmp___5 = quotearg(string);
#line 304
      tmp___6 = gettext("invalid interval `%s\'");
#line 304
      error(1, 0, (char const   *)tmp___6, tmp___5);
      }
    }
#line 306
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 309
    tmp___8 = strlen("toc");
#line 309
    tmp___9 = strncmp("toc", (char const   *)(cp - 1), tmp___8);
    }
#line 309
    if (tmp___9) {
#line 318
      goto failed;
    } else {
#line 312
      (job___0->page_range)->toc = (_Bool)1;
#line 313
      cp += 2;
#line 315
      if ((int )*cp != 0) {
#line 316
        goto failed;
      }
    }
#line 319
    goto switch_break;
    failed: 
    switch_default: /* CIL Label */ 
    {
#line 323
    tmp___10 = quotearg(string);
#line 323
    tmp___11 = gettext("invalid interval `%s\'");
#line 323
    error(1, 0, (char const   *)tmp___11, tmp___10);
    }
#line 324
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 326
    cp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)", \t");
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return;
}
}
#line 330 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
void report_pages_to_print(struct a2ps_job *job___0 , FILE *stream ) 
{ 


  {
  {
#line 333
  page_range_self_print(job___0->page_range, stream);
  }
#line 334
  return;
}
}
#line 339 "/home/ysko/Works/test-src/a2ps-4.14/lib/prange.c"
int print_page(struct a2ps_job *job___0 , int page_num ) 
{ 
  size_t i ;
  struct interval **intervals ;
  int tmp ;

  {
#line 343
  intervals = (struct interval **)((job___0->page_range)->intervals)->content;
#line 349
  if ((job___0->page_range)->toc) {
#line 349
    if (((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->is_toc) {
#line 350
      return (1);
    }
  }
#line 354
  if (((job___0->page_range)->intervals)->len == 0U) {
#line 354
    if (! (job___0->page_range)->toc) {
#line 355
      return (1);
    }
  }
#line 357
  i = (size_t )0;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (i < ((job___0->page_range)->intervals)->len)) {
#line 357
      goto while_break;
    }
    {
#line 358
    tmp = interval_is_in(*(intervals + i), page_num);
    }
#line 358
    if (tmp) {
#line 359
      return (1);
    }
#line 357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (0);
}
}
#line 52 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.h"
void ppd_font_add(struct ppd *ppd , char const   *fontname ) ;
#line 58
struct ppd *ppd_new(void) ;
#line 70
struct ppd *a2ps_ppd_parse(char const   *filename , char * const  *path ) ;
#line 68 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.h"
void lister_fprint_separated(struct lister *lister , FILE *unused  __attribute__((__unused__)) ,
                             void **items , size_t item_number , size_t (*item_width_fn)(void const   *item ) ,
                             void (*item_print_fn)(void const   *item , FILE *stream ) ) ;
#line 49 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.c"
void ppd_font_add(struct ppd *ppd , char const   *fontname ) 
{ 


  {
  {
#line 52
  string_htable_add(ppd->fonts, fontname);
  }
#line 53
  return;
}
}
#line 55 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.c"
int ppd_font_known_p(struct ppd *ppd , char const   *fontname ) 
{ 
  char *tmp ;

  {
  {
#line 58
  tmp = string_htable_get(ppd->fonts, fontname);
  }
#line 58
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#line 64 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.c"
struct ppd *ppd_new(void) 
{ 
  struct ppd *res___2 ;
  void *tmp ;

  {
  {
#line 67
  tmp = xmalloc((size_t )sizeof(struct ppd ));
#line 67
  res___2 = (struct ppd *)tmp;
#line 68
  res___2->fonts = (struct string_htable *)string_htable_new();
#line 69
  res___2->key = (char *)((void *)0);
#line 70
  res___2->modelname = (char *)((void *)0);
#line 71
  res___2->nickname = (char *)((void *)0);
  }
#line 72
  return (res___2);
}
}
#line 75 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.c"
void ppd_free(struct ppd *ppd ) 
{ 


  {
#line 78
  if (ppd) {
    {
#line 79
    string_htable_free(ppd->fonts);
    }
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
#line 80
      if (ppd->key) {
        {
#line 80
        free((void *)ppd->key);
        }
      }
#line 80
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      if (ppd->modelname) {
        {
#line 81
        free((void *)ppd->modelname);
        }
      }
#line 81
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 82
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 82
      if (ppd->nickname) {
        {
#line 82
        free((void *)ppd->nickname);
        }
      }
#line 82
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 83
    free((void *)ppd);
    }
  }
#line 85
  return;
}
}
#line 90 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.c"
static void ppd_self_print(struct ppd *ppd , FILE *stream ) 
{ 
  char *cp ;
  char **fonts ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 98
  if (ppd->nickname) {
#line 99
    cp = ppd->nickname;
  } else
#line 100
  if (ppd->modelname) {
#line 101
    cp = ppd->modelname;
  } else {
#line 103
    cp = ppd->key;
  }
  {
#line 104
  title(stream, (char )'-', 1, "%s (%s)", cp, ppd->key);
#line 107
  fonts = string_htable_dump_sorted(ppd->fonts);
#line 108
  tmp = gettext("Known Fonts");
#line 108
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
  }
#line 109
  if (! *fonts) {
    {
#line 111
    tmp___0 = gettext("\n  None.\n");
#line 111
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
    }
  } else {
    {
#line 114
    _IO_putc('\n', stream);
#line 115
    lister_fprint_separated((struct lister *)((void *)0), stream, (void **)fonts,
                            (size_t )-1, (size_t (*)(void const   *item ))(& strlen),
                            (void (*)(void const   *item , FILE *stream ))(& fputs));
    }
  }
  {
#line 120
  free((void *)fonts);
  }
#line 121
  return;
}
}
#line 127 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.c"
struct ppd *_a2ps_ppd_get(char * const  *path , char const   *key ) 
{ 
  struct ppd *res___2 ;
  char *ppd_filepath ;
  char *__cil_tmp5 ;

  {
  {
#line 133
  ppd_filepath = xpw_find_file(path, key, ".ppd");
#line 134
  res___2 = a2ps_ppd_parse((char const   *)ppd_filepath, path);
#line 135
  res___2->key = xstrdup(key);
#line 136
  free((void *)ppd_filepath);
  }
#line 137
  return (res___2);
}
}
#line 146 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.c"
void _a2ps_ppd_list_short(char * const  *path , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 149
  tmp = gettext("Known PostScript Printer Descriptions");
#line 149
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
#line 150
  _IO_putc('\n', stream);
#line 151
  pw_lister_on_suffix(stream, path, ".ppd");
  }
#line 152
  return;
}
}
#line 157 "/home/ysko/Works/test-src/a2ps-4.14/lib/ppd.c"
void _a2ps_ppd_list_long(char * const  *path , FILE *stream ) 
{ 
  struct darray *entries ;
  size_t i ;
  char *tmp ;
  struct ppd *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 163
  entries = pw_glob_on_suffix(path, ".ppd");
#line 165
  tmp = gettext("Known PostScript Printer Descriptions");
#line 165
  title(stream, (char )'=', 1, (char const   *)tmp);
#line 166
  _IO_putc('\n', stream);
#line 168
  i = (size_t )0;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < entries->len)) {
#line 168
      goto while_break;
    }
    {
#line 170
    tmp___0 = _a2ps_ppd_get(path, (char const   *)*(entries->content + i));
#line 170
    ppd_self_print(tmp___0, stream);
#line 171
    _IO_putc('\n', stream);
#line 168
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  da_free(entries, & free);
  }
#line 175
  return;
}
}
#line 260 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 62 "./fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__string , int __flags ) ;
#line 52 "/home/ysko/Works/test-src/a2ps-4.14/lib/error.h"
extern void ( /* format attribute */  error_at_line)(int status , int errnum , char const   *fname ,
                                                     unsigned int lineno , char const   *format 
                                                     , ...) ;
#line 36 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.h"
char **pw_string_to_path(char const   *path ) ;
#line 37
char **pw_append_string_to_path(char **path1 , char const   *dir2 ) ;
#line 39
char **pw_prepend_string_to_path(char **path1 , char const   *dir2 ) ;
#line 41
void pw_free_path(char **path ) ;
#line 42
void pw_fprintf_path(FILE *stream , char const   *format , char * const  *path ) ;
#line 48
int pw_paste_file(char * const  *path , char const   *name , char const   *suffix ) ;
#line 54
int pw_file_exists_p(char * const  *path , char const   *name , char const   *suffix ) ;
#line 60
char *pw_find_file(char * const  *path , char const   *name , char const   *suffix ) ;
#line 69
char *xpw_find_included_file(char * const  *path , char const   *including_file ,
                             char const   *name , char const   *suffix ) ;
#line 76
struct darray *pw_glob(char * const  *path , char const   *pattern ) ;
#line 78
void pw_glob_print(char * const  *path , char const   *pattern , FILE *stream ) ;
#line 112 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.h"
void da_qsort(struct darray *arr ) ;
#line 117
void da_unique(struct darray *arr , void (*free_func)(void * ) ) ;
#line 131
void da_map(struct darray *arr , void (*fn)(void * ) ) ;
#line 139
void da_str_print(char const   *s1 , FILE *stream ) ;
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/lib/filtdir.h"
void filterdir(char const   *dir , _Bool (*filter)(char const   *dir , char const   *file ,
                                                   void *filtarg ) , void *filtarg ,
               void (*fun)(char const   *dir , char const   *file , void *filtarg ) ,
               void *arg ) ;
#line 28 "/home/ysko/Works/test-src/a2ps-4.14/lib/dirname.h"
char *dir_name(char const   *path ) ;
#line 57 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
static char **pw_internal_string_to_path(char const   *path , char sep , int *length ) 
{ 
  char **res___2 ;
  int allocated ;
  int entries ;
  char const   *cp ;
  char const   *cp2 ;
  int len ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 60
  res___2 = (char **)((void *)0);
#line 61
  allocated = 5;
#line 62
  entries = 0;
#line 66
  tmp = xcalloc((size_t )sizeof(char *), (size_t )allocated);
#line 66
  res___2 = (char **)tmp;
#line 67
  cp = path;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! cp) {
#line 67
      goto while_break;
    }
#line 69
    if ((unsigned long )cp != (unsigned long )path) {
#line 70
      cp ++;
    }
    {
#line 72
    tmp___1 = strchr(cp, (int )sep);
#line 72
    cp2 = (char const   *)tmp___1;
    }
#line 73
    if (cp2) {
#line 74
      len = (int )(cp2 - cp);
    } else {
      {
#line 76
      tmp___2 = strlen(cp);
#line 76
      len = (int )tmp___2;
      }
    }
#line 78
    if (len == 0) {
#line 81
      cp ++;
#line 82
      goto __Cont;
    } else
#line 87
    if ((int const   )*(cp + len) == 47) {
#line 88
      len --;
    }
    {
#line 91
    tmp___3 = xmalloc((size_t )(sizeof(char ) * (unsigned long )(len + 1)));
#line 91
    *(res___2 + entries) = (char *)tmp___3;
#line 92
    strncpy((char */* __restrict  */)*(res___2 + entries), (char const   */* __restrict  */)cp,
            (size_t )len);
#line 93
    *(*(res___2 + entries) + len) = (char )'\000';
#line 95
    entries ++;
    }
#line 96
    if (entries >= allocated) {
      {
#line 98
      allocated *= 2;
#line 99
      tmp___4 = xrealloc((void *)res___2, (size_t )(sizeof(char *) * (unsigned long )allocated));
#line 99
      res___2 = (char **)tmp___4;
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 67
    tmp___0 = strchr(cp, (int )sep);
#line 67
    cp = (char const   *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  *length = entries;
#line 105
  *(res___2 + *length) = (char *)((void *)0);
#line 106
  tmp___5 = xrealloc((void *)res___2, (size_t )(sizeof(char *) * (unsigned long )(*length + 1)));
#line 106
  res___2 = (char **)tmp___5;
  }
#line 107
  return (res___2);
}
}
#line 113 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
__inline static int pw_path_length(char **path ) 
{ 
  int res___2 ;

  {
#line 118
  if (! path) {
#line 119
    return (0);
  }
#line 121
  res___2 = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! *(path + res___2)) {
#line 121
      goto while_break;
    }
#line 121
    res___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return (res___2);
}
}
#line 131 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
char **pw_string_to_path(char const   *path ) 
{ 
  int dummy ;
  char **tmp ;

  {
  {
#line 135
  tmp = pw_internal_string_to_path(path, (char )':', & dummy);
  }
#line 135
  return (tmp);
}
}
#line 142 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
__inline static char **pw_path_concat(char **path1 , int len1 , char **path2 , int len2 ) 
{ 
  int i ;
  void *tmp ;

  {
#line 147
  if (path2) {
    {
#line 149
    tmp = xrealloc((void *)path1, (size_t )(sizeof(char *) * (unsigned long )((len1 + len2) + 1)));
#line 149
    path1 = (char **)tmp;
#line 150
    i = 0;
    }
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 150
      if (! (i <= len2)) {
#line 150
        goto while_break;
      }
#line 151
      *(path1 + (len1 + i)) = *(path2 + i);
#line 150
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 152
    free((void *)path2);
    }
  }
#line 155
  return (path1);
}
}
#line 162 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
char **pw_append_string_to_path(char **path1 , char const   *dir2 ) 
{ 
  int len1 ;
  int len2 ;
  char **path2 ;
  char **tmp ;

  {
  {
#line 168
  len1 = pw_path_length(path1);
#line 169
  path2 = pw_internal_string_to_path(dir2, (char )':', & len2);
#line 171
  tmp = pw_path_concat(path1, len1, path2, len2);
  }
#line 171
  return (tmp);
}
}
#line 177 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
char **pw_prepend_string_to_path(char **path1 , char const   *dir2 ) 
{ 
  int len1 ;
  int len2 ;
  char **path2 ;
  char **tmp ;

  {
  {
#line 183
  len1 = pw_path_length(path1);
#line 184
  path2 = pw_internal_string_to_path(dir2, (char )':', & len2);
#line 186
  tmp = pw_path_concat(path2, len2, path1, len1);
  }
#line 186
  return (tmp);
}
}
#line 192 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
void pw_free_path(char **path ) 
{ 
  int i ;

  {
#line 196
  if (path) {
#line 197
    i = 0;
    {
#line 197
    while (1) {
      while_continue: /* CIL Label */ ;
#line 197
      if (! *(path + i)) {
#line 197
        goto while_break;
      }
      {
#line 198
      free((void *)*(path + i));
#line 197
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 199
    if (path) {
      {
#line 199
      free((void *)path);
      }
    }
#line 199
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 200
  return;
}
}
#line 202 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
void pw_fprintf_path(FILE *stream , char const   *format , char * const  *path ) 
{ 


  {
#line 205
  if (path) {
    {
#line 206
    while (1) {
      while_continue: /* CIL Label */ ;
#line 206
      if (! *path) {
#line 206
        goto while_break;
      }
      {
#line 207
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)format,
              *path);
#line 208
      path ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 210
  return;
}
}
#line 217 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
static int pw_find_file_index(char * const  *path , char const   *name , char const   *suffix ) 
{ 
  int i ;
  struct stat stat_st ;
  char *filename ;
  char *fullpath ;
  char const   *_tmp1_ ;
  char const   *_tmp2_ ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp1 ;
  char const   *tmp2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 225
  if (suffix) {
    {
#line 226
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 226
      _tmp1_ = name;
#line 226
      _tmp2_ = suffix;
#line 226
      tmp = strlen(_tmp1_);
#line 226
      tmp___0 = strlen(_tmp2_);
#line 226
      tmp___1 = __builtin_alloca(sizeof(char ) * (unsigned long )((tmp + tmp___0) + 1U));
#line 226
      filename = (char *)tmp___1;
      }
      {
#line 226
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 226
        tmp___2 = stpcpy((char */* __restrict  */)filename, (char const   */* __restrict  */)name);
#line 226
        stpcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)suffix);
        }
#line 226
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 226
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 228
    filename = (char *)name;
  }
  {
#line 230
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 230
    if ((unsigned int )(1 << 3) & msg_verbosity) {
      {
#line 230
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pw: looking for `%s\'\n",
              filename);
      }
    }
#line 230
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 233
  if (path) {
#line 234
    i = 0;
    {
#line 234
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 234
      if (! *(path + i)) {
#line 234
        goto while_break___2;
      }
      {
#line 236
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 236
        tmp1 = (char *)*(path + i);
#line 236
        tmp2 = (char const   *)filename;
#line 236
        tmp___3 = strlen((char const   *)tmp1);
#line 236
        tmp___4 = strlen(tmp2);
#line 236
        tmp___5 = __builtin_alloca(sizeof(char ) * (unsigned long )((tmp___3 + tmp___4) + 2U));
#line 236
        fullpath = (char *)tmp___5;
#line 236
        tmp1 = stpcpy((char */* __restrict  */)fullpath, (char const   */* __restrict  */)tmp1);
#line 236
        tmp___6 = tmp1;
#line 236
        tmp1 ++;
#line 236
        *tmp___6 = (char )'/';
#line 236
        stpcpy((char */* __restrict  */)tmp1, (char const   */* __restrict  */)tmp2);
        }
#line 236
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 237
      tmp___7 = stat((char const   */* __restrict  */)fullpath, (struct stat */* __restrict  */)(& stat_st));
      }
#line 237
      if (tmp___7 == 0) {
        {
#line 240
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 240
          if ((unsigned int )(1 << 3) & msg_verbosity) {
            {
#line 240
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pw: success in %s\n",
                    *(path + i));
            }
          }
#line 240
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 241
        return (i + 1);
      }
#line 234
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 245
  if ((unsigned int )(1 << 3) & msg_verbosity) {
    {
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pw: did not find `%s\' in path\n",
            filename);
#line 248
    pw_fprintf_path(stderr, "pw:  %s\n", path);
    }
  }
#line 251
  return (0);
}
}
#line 258 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
int pw_file_exists_p(char * const  *path , char const   *name , char const   *suffix ) 
{ 
  int tmp ;

  {
  {
#line 262
  tmp = pw_find_file_index(path, name, suffix);
  }
#line 262
  return (tmp);
}
}
#line 270 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
__inline static char *_pw_find_file(char * const  *path , char const   *name , char const   *suffix ) 
{ 
  char *res___2 ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 277
  i = pw_find_file_index(path, name, suffix);
  }
#line 279
  if (i) {
#line 282
    if (suffix) {
      {
#line 284
      tmp = strlen((char const   *)*(path + (i - 1)));
#line 284
      tmp___0 = strlen(name);
#line 284
      tmp___1 = strlen(suffix);
#line 284
      tmp___2 = xmalloc((size_t )(sizeof(char ) * (unsigned long )(((tmp + 2U) + tmp___0) + tmp___1)));
#line 284
      res___2 = (char *)tmp___2;
#line 287
      sprintf((char */* __restrict  */)res___2, (char const   */* __restrict  */)"%s%c%s%s",
              *(path + (i - 1)), '/', name, suffix);
      }
    } else {
      {
#line 292
      tmp___3 = strlen((char const   *)*(path + (i - 1)));
#line 292
      tmp___4 = strlen(name);
#line 292
      tmp___5 = xmalloc((size_t )(sizeof(char ) * (unsigned long )((tmp___3 + 2U) + tmp___4)));
#line 292
      res___2 = (char *)tmp___5;
#line 295
      sprintf((char */* __restrict  */)res___2, (char const   */* __restrict  */)"%s%c%s",
              *(path + (i - 1)), '/', name);
      }
    }
#line 298
    return (res___2);
  } else {
#line 301
    return ((char *)((void *)0));
  }
}
}
#line 307 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
char *pw_find_file(char * const  *path , char const   *name , char const   *suffix ) 
{ 
  char *tmp ;

  {
  {
#line 311
  tmp = _pw_find_file(path, name, suffix);
  }
#line 311
  return (tmp);
}
}
#line 317 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
char *xpw_find_file(char * const  *path , char const   *name , char const   *suffix ) 
{ 
  char *res___2 ;
  char *tmp ;
  char *file ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 321
  tmp = _pw_find_file(path, name, suffix);
#line 321
  res___2 = tmp;
  }
#line 323
  if (! res___2) {
    {
#line 326
    tmp___0 = strlen(name);
    }
#line 326
    if (suffix) {
      {
#line 326
      tmp___1 = strlen(suffix);
#line 326
      tmp___2 = tmp___1;
      }
    } else {
#line 326
      tmp___2 = (size_t )0;
    }
    {
#line 326
    tmp___3 = __builtin_alloca(sizeof(char ) * (unsigned long )((tmp___0 + tmp___2) + 1U));
#line 326
    file = (char *)tmp___3;
    }
#line 327
    if ((unsigned long )((void const   *)suffix) == (unsigned long )((void *)0)) {
#line 327
      tmp___4 = "";
    } else {
#line 327
      tmp___4 = suffix;
    }
    {
#line 327
    sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)"%s%s",
            name, tmp___4);
#line 328
    tmp___5 = quotearg((char const   *)file);
#line 328
    tmp___6 = gettext("cannot find file `%s\'");
#line 328
    tmp___7 = __errno_location();
#line 328
    error(1, *tmp___7, (char const   *)tmp___6, tmp___5);
    }
  }
#line 330
  return (res___2);
}
}
#line 335 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
char *xpw_find_included_file(char * const  *path , char const   *including_file ,
                             char const   *name , char const   *suffix ) 
{ 
  char *dir ;
  char *res___2 ;
  struct stat statbuf ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 344
  if ((int const   )*name == 47) {
#line 346
    dir = (char *)((void *)0);
  } else {
    {
#line 349
    dir = dir_name(including_file);
    }
  }
  {
#line 351
  tmp = strlen((char const   *)dir);
#line 351
  tmp___0 = strlen(name);
  }
#line 351
  if (suffix) {
    {
#line 351
    tmp___1 = strlen(suffix);
#line 351
    tmp___2 = tmp___1;
    }
  } else {
#line 351
    tmp___2 = (size_t )0;
  }
  {
#line 351
  tmp___3 = __builtin_alloca(sizeof(char ) * (unsigned long )(((tmp + tmp___0) + tmp___2) + 2U));
#line 351
  res___2 = (char *)tmp___3;
  }
#line 355
  if (suffix) {
#line 355
    tmp___4 = suffix;
  } else {
#line 355
    tmp___4 = "";
  }
  {
#line 355
  sprintf((char */* __restrict  */)res___2, (char const   */* __restrict  */)"%s%c%s%s",
          dir, '/', name, tmp___4);
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (dir) {
      {
#line 357
      free((void *)dir);
      }
    }
#line 357
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 358
  tmp___6 = stat((char const   */* __restrict  */)res___2, (struct stat */* __restrict  */)(& statbuf));
  }
#line 358
  if (tmp___6 == 0) {
    {
#line 359
    tmp___5 = xstrdup((char const   *)res___2);
    }
#line 359
    return (tmp___5);
  }
  {
#line 362
  tmp___7 = xpw_find_file(path, name, suffix);
  }
#line 362
  return (tmp___7);
}
}
#line 368 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
int pw_paste_file(char * const  *path , char const   *name , char const   *suffix ) 
{ 
  char buf___0[512] ;
  char *fullpath ;
  FILE *fp ;
  int line ;
  char const   *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *file ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 375
  line = 0;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if ((unsigned int )(1 << 3) & msg_verbosity) {
#line 377
      if (suffix) {
#line 377
        tmp = suffix;
      } else {
#line 377
        tmp = "";
      }
      {
#line 377
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pw: pasting `%s%s\'\n",
              name, tmp);
      }
    }
#line 377
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 380
  fullpath = _pw_find_file(path, name, suffix);
  }
#line 382
  if (! fullpath) {
#line 383
    return (0);
  }
  {
#line 385
  fp = fopen((char const   */* __restrict  */)fullpath, (char const   */* __restrict  */)"r");
  }
#line 387
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 388
    return (0);
  }
  {
#line 392
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 392
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 392
    if (! tmp___2) {
#line 392
      goto while_break___0;
    }
    {
#line 394
    line ++;
#line 395
    tmp___0 = strlen("% -- code follows this line --");
#line 395
    tmp___1 = strncmp((char const   *)(buf___0), "% -- code follows this line --",
                      tmp___0);
    }
#line 395
    if (tmp___1 == 0) {
#line 396
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 401
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 401
    tmp___10 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 401
    if (! tmp___10) {
#line 401
      goto while_break___1;
    }
    {
#line 403
    line ++;
#line 404
    tmp___8 = strlen("% -- include file:");
#line 404
    tmp___9 = strncmp((char const   *)(buf___0), "% -- include file:", tmp___8);
    }
#line 404
    if (tmp___9 == 0) {
      {
#line 406
      tmp___3 = strlen("% -- include file:");
#line 406
      file = buf___0 + tmp___3;
#line 407
      file = strtok((char */* __restrict  */)file, (char const   */* __restrict  */)" \n\t");
      }
      {
#line 408
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 408
        if ((unsigned int )(1 << 3) & msg_verbosity) {
          {
#line 408
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pw: including file \'%s\' upon request given in \'%s\':%d\n",
                  file, fullpath, line);
          }
        }
#line 408
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 412
      tmp___7 = pw_paste_file(path, (char const   *)file, (char const   *)((void *)0));
      }
#line 412
      if (! tmp___7) {
        {
#line 413
        tmp___4 = quotearg((char const   *)file);
#line 413
        tmp___5 = gettext("cannot find file `%s\'");
#line 413
        tmp___6 = __errno_location();
#line 413
        error_at_line(1, *tmp___6, (char const   *)fullpath, (unsigned int )line,
                      (char const   *)tmp___5, tmp___4);
        }
      }
#line 415
      goto while_continue___1;
    }
    {
#line 417
    fputs((char const   */* __restrict  */)(buf___0), (FILE */* __restrict  */)stdout);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 420
  fclose(fp);
#line 421
  free((void *)fullpath);
  }
#line 422
  return (1);
}
}
#line 427 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
static _Bool pw_filter_fnmatch(char const   *dir  __attribute__((__unused__)) , char const   *file ,
                               char const   *pattern ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 431
  tmp = fnmatch(pattern, file, 0);
  }
#line 431
  if (tmp) {
#line 431
    tmp___0 = 0;
  } else {
#line 431
    tmp___0 = 1;
  }
#line 431
  return ((_Bool )tmp___0);
}
}
#line 434 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
static void pw_filter_da_append(char const   *dir  __attribute__((__unused__)) , char const   *file ,
                                struct darray *da ) 
{ 
  char *tmp ;

  {
  {
#line 438
  tmp = xstrdup(file);
#line 438
  da_append(da, (void *)tmp);
  }
#line 439
  return;
}
}
#line 441 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
static void pw_filter_print(char const   *dir , char const   *file , FILE *stream ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 444
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s%c%s\n",
          dir, '/', file);
  }
#line 445
  return;
}
}
#line 447 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
static void pw_filterdir(char * const  *path , _Bool (*filter)(char const   *dir ,
                                                               char const   *file ,
                                                               void *filtarg ) , void *filtarg ,
                         void (*fun)(char const   *dir , char const   *file , void *filtarg ) ,
                         void *arg ) 
{ 


  {
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    if (! *path) {
#line 452
      goto while_break;
    }
    {
#line 453
    filterdir((char const   *)*path, filter, filtarg, fun, arg);
#line 452
    path ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  return;
}
}
#line 462 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
struct darray *pw_glob(char * const  *path , char const   *pattern ) 
{ 
  struct darray *res___2 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 467
  if ((unsigned int )(1 << 3) & msg_verbosity) {
    {
#line 469
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pw: globbing `%s\'\n",
            pattern);
#line 470
    pw_fprintf_path(stderr, "\t-> %s\n", path);
    }
  }
  {
#line 473
  res___2 = da_new("Dir entries", (size_t )20, (enum da_growth )2, (size_t )2, (void (*)(void const   * ,
                                                                                         FILE *stream ))(& da_str_print),
                   (int (*)(void const   *k1 , void const   *k2 ))(& strverscmp));
#line 478
  pw_filterdir(path, (_Bool (*)(char const   *dir , char const   *file , void *filtarg ))(& pw_filter_fnmatch),
               (void *)pattern, (void (*)(char const   *dir , char const   *file ,
                                          void *filtarg ))(& pw_filter_da_append),
               (void *)res___2);
#line 482
  da_qsort(res___2);
#line 483
  da_unique(res___2, & free);
  }
#line 485
  return (res___2);
}
}
#line 488 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
void pw_glob_print(char * const  *path , char const   *pattern , FILE *stream ) 
{ 


  {
  {
#line 491
  pw_filterdir(path, (_Bool (*)(char const   *dir , char const   *file , void *filtarg ))(& pw_filter_fnmatch),
               (void *)pattern, (void (*)(char const   *dir , char const   *file ,
                                          void *filtarg ))(& pw_filter_print), (void *)stream);
  }
#line 494
  return;
}
}
#line 500 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
static void da_str_cut_suffix(char *string ) 
{ 
  char *tmp ;

  {
  {
#line 503
  tmp = strrchr((char const   *)string, '.');
#line 503
  *tmp = (char )'\000';
  }
#line 504
  return;
}
}
#line 511 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
struct darray *pw_glob_on_suffix(char * const  *path , char const   *suffix ) 
{ 
  struct darray *res___2 ;
  char *pattern ;
  char const   *_tmp1_ ;
  char const   *_tmp2_ ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 518
    _tmp1_ = "*";
#line 518
    _tmp2_ = suffix;
#line 518
    tmp = strlen(_tmp1_);
#line 518
    tmp___0 = strlen(_tmp2_);
#line 518
    tmp___1 = __builtin_alloca(sizeof(char ) * (unsigned long )((tmp + tmp___0) + 1U));
#line 518
    pattern = (char *)tmp___1;
    }
    {
#line 518
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 518
      tmp___2 = stpcpy((char */* __restrict  */)pattern, (char const   */* __restrict  */)"*");
#line 518
      stpcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)suffix);
      }
#line 518
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 518
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 519
  res___2 = pw_glob(path, (char const   *)pattern);
#line 522
  da_map(res___2, (void (*)(void * ))(& da_str_cut_suffix));
  }
#line 524
  return (res___2);
}
}
#line 530 "/home/ysko/Works/test-src/a2ps-4.14/lib/pathwalk.c"
void pw_lister_on_suffix(FILE *stream , char * const  *path , char const   *suffix ) 
{ 
  struct darray *entries ;

  {
  {
#line 535
  entries = pw_glob_on_suffix(path, suffix);
#line 536
  lister_fprint_vertical((struct lister *)((void *)0), stream, (void **)((void *)entries->content),
                         entries->len, (size_t (*)(void const   *item ))(& strlen),
                         (void (*)(void const   *item , FILE *stream ))(& fputs));
#line 540
  da_free(entries, & free);
  }
#line 541
  return;
}
}
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 32 "/home/ysko/Works/test-src/a2ps-4.14/lib/path-concat.h"
char *path_concat(char const   *dir , char const   *base , char **base_in_result ) ;
#line 37
char *xpath_concat(char const   *dir , char const   *base , char **base_in_result ) ;
#line 60 "/home/ysko/Works/test-src/a2ps-4.14/lib/path-concat.c"
char *path_concat(char const   *dir , char const   *base , char **base_in_result ) 
{ 
  char *p ;
  char *p_concat ;
  size_t base_len ;
  size_t dir_len ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 68
  if (! dir) {
    {
#line 70
    p_concat = strdup(base);
    }
#line 71
    if (base_in_result) {
#line 72
      *base_in_result = p_concat;
    }
#line 73
    return (p_concat);
  }
  {
#line 77
  base_len = strlen(base);
#line 78
  dir_len = strlen(dir);
#line 81
  tmp = (int )malloc((dir_len + base_len) + 2U);
#line 81
  p_concat = (char *)tmp;
  }
#line 82
  if (! p_concat) {
#line 83
    return ((char *)0);
  }
  {
#line 85
  tmp___0 = memcpy((void */* __restrict  */)p_concat, (void const   */* __restrict  */)dir,
                   dir_len);
#line 85
  p = (char *)((void *)((char *)tmp___0 + dir_len));
  }
#line 87
  if ((int )*(p - 1) == 47) {
#line 87
    if ((int const   )*base == 47) {
#line 88
      p --;
    } else {
#line 87
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 89
  if (! ((int )*(p - 1) == 47)) {
#line 89
    if (! ((int const   )*base == 47)) {
#line 90
      tmp___1 = p;
#line 90
      p ++;
#line 90
      *tmp___1 = (char )'/';
    }
  }
#line 92
  if (base_in_result) {
#line 93
    *base_in_result = p;
  }
  {
#line 95
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)base, base_len + 1U);
  }
#line 97
  return (p_concat);
}
}
#line 102 "/home/ysko/Works/test-src/a2ps-4.14/lib/path-concat.c"
char *xpath_concat(char const   *dir , char const   *base , char **base_in_result ) 
{ 
  char *res___2 ;
  char *tmp ;

  {
  {
#line 105
  tmp = path_concat(dir, base, base_in_result);
#line 105
  res___2 = tmp;
  }
#line 106
  if (res___2) {
#line 107
    return (res___2);
  }
  {
#line 108
  xalloc_die();
  }
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/lib/lexppd.h"
int ppdlineno ;
#line 41
char *ppdfilename ;
#line 44
char * const  *ppdpath ;
#line 55 "parseppd.y"
FILE *ppdin ;
#line 59
void ppderror(char const   *msg ) ;
#line 60
static void yyprint(FILE *file , int type , YYSTYPE value ) ;
#line 63
void ppdlex_initialize(void) ;
#line 65
int ppdlex(void) ;
#line 67 "parseppd.y"
static struct ppd *ppd_parse_result  ;
#line 438 "parseppd.c"
static yytype_uint8 const   yytranslate[266]  = 
#line 438 "parseppd.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )11,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10};
#line 472 "parseppd.c"
static yytype_uint8 const   yyprhs[14]  = 
#line 472
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )10,      (yytype_uint8 const   )16,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )28,      (yytype_uint8 const   )31,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )45};
#line 479 "parseppd.c"
static yytype_int8 const   yyrhs[49]  = 
#line 479
  {      (yytype_int8 const   )13,      (yytype_int8 const   )0,      (yytype_int8 const   )-1,      (yytype_int8 const   )14, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )15, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )6, 
        (yytype_int8 const   )11,      (yytype_int8 const   )8,      (yytype_int8 const   )3,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )14,      (yytype_int8 const   )7,      (yytype_int8 const   )11,      (yytype_int8 const   )8, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )9, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )8,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )14,      (yytype_int8 const   )10,      (yytype_int8 const   )-1,      (yytype_int8 const   )14, 
        (yytype_int8 const   )11,      (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )5,      (yytype_int8 const   )9,      (yytype_int8 const   )11, 
        (yytype_int8 const   )9,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )9, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )4,      (yytype_int8 const   )11,      (yytype_int8 const   )9, 
        (yytype_int8 const   )-1};
#line 489 "parseppd.c"
static yytype_uint8 const   yyrline[14]  = 
#line 489
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )92,      (yytype_uint8 const   )92,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )109,      (yytype_uint8 const   )115,      (yytype_uint8 const   )121, 
        (yytype_uint8 const   )125,      (yytype_uint8 const   )129,      (yytype_uint8 const   )133,      (yytype_uint8 const   )137, 
        (yytype_uint8 const   )147,      (yytype_uint8 const   )149};
#line 499 "parseppd.c"
static char const   * const  yytname[17]  = 
#line 499
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"EOL", 
        (char const   */* const  */)"tDefaultFont",      (char const   */* const  */)"tFont",      (char const   */* const  */)"tModelName",      (char const   */* const  */)"tNickName", 
        (char const   */* const  */)"STRING",      (char const   */* const  */)"SYMBOL",      (char const   */* const  */)"USTRING",      (char const   */* const  */)"\':\'", 
        (char const   */* const  */)"$accept",      (char const   */* const  */)"file",      (char const   */* const  */)"ppd",      (char const   */* const  */)"font_clause", 
        (char const   */* const  */)0};
#line 510 "parseppd.c"
static yytype_uint16 const   yytoknum[12]  = 
#line 510
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )256,      (yytype_uint16 const   )257,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )259,      (yytype_uint16 const   )260,      (yytype_uint16 const   )261,      (yytype_uint16 const   )262, 
        (yytype_uint16 const   )263,      (yytype_uint16 const   )264,      (yytype_uint16 const   )265,      (yytype_uint16 const   )58};
#line 518 "parseppd.c"
static yytype_uint8 const   ppdr1[14]  = 
#line 518
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )14,      (yytype_uint8 const   )14,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )14,      (yytype_uint8 const   )14,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )15};
#line 525 "parseppd.c"
static yytype_uint8 const   ppdr2[14]  = 
#line 525
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )3};
#line 534 "parseppd.c"
static yytype_uint8 const   yydefact[29]  = 
#line 534
  {      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )7,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )12};
#line 542 "parseppd.c"
static yytype_int8 const   yydefgoto[4]  = {      (yytype_int8 const   )-1,      (yytype_int8 const   )1,      (yytype_int8 const   )2,      (yytype_int8 const   )13};
#line 550 "parseppd.c"
static yytype_int8 const   ppdpact[29]  = 
#line 550
  {      (yytype_int8 const   )-4,      (yytype_int8 const   )9,      (yytype_int8 const   )-3,      (yytype_int8 const   )-4, 
        (yytype_int8 const   )-4,      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )1, 
        (yytype_int8 const   )3,      (yytype_int8 const   )-4,      (yytype_int8 const   )-4,      (yytype_int8 const   )-4, 
        (yytype_int8 const   )-4,      (yytype_int8 const   )10,      (yytype_int8 const   )6,      (yytype_int8 const   )5, 
        (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )-4,      (yytype_int8 const   )-4, 
        (yytype_int8 const   )8,      (yytype_int8 const   )15,      (yytype_int8 const   )18,      (yytype_int8 const   )14, 
        (yytype_int8 const   )-4,      (yytype_int8 const   )-4,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )-4};
#line 558 "parseppd.c"
static yytype_int8 const   yypgoto[4]  = {      (yytype_int8 const   )-4,      (yytype_int8 const   )-4,      (yytype_int8 const   )-4,      (yytype_int8 const   )-4};
#line 568 "parseppd.c"
static yytype_uint8 const   ppdyytable[27]  = 
#line 568
  {      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )3,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )18,      (yytype_uint8 const   )17,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28};
#line 575 "parseppd.c"
static yytype_int8 const   ppdyycheck[27]  = 
#line 575
  {      (yytype_int8 const   )3,      (yytype_int8 const   )4,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )11,      (yytype_int8 const   )0,      (yytype_int8 const   )11,      (yytype_int8 const   )9, 
        (yytype_int8 const   )11,      (yytype_int8 const   )3,      (yytype_int8 const   )11,      (yytype_int8 const   )9, 
        (yytype_int8 const   )11,      (yytype_int8 const   )9,      (yytype_int8 const   )3,      (yytype_int8 const   )8, 
        (yytype_int8 const   )8,      (yytype_int8 const   )3,      (yytype_int8 const   )8,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )9,      (yytype_int8 const   )9};
#line 584 "parseppd.c"
static yytype_uint8 const   yystos[29]  = 
#line 584
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )15,      (yytype_uint8 const   )11,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )11,      (yytype_uint8 const   )3,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9};
#line 714 "parseppd.c"
static void yy_symbol_value_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 


  {
#line 724
  if (! yyvaluep) {
#line 725
    return;
  }
#line 727
  if (yytype < 12) {
    {
#line 728
    yyprint(yyoutput, (int const   )yytoknum[yytype], *yyvaluep);
    }
  }
  {
#line 734
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 735
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 737
  return;
}
}
#line 746 "parseppd.c"
static void yy_symbol_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 756
  if (yytype < 12) {
    {
#line 757
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"token %s (",
            yytname[yytype]);
    }
  } else {
    {
#line 759
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"nterm %s (",
            yytname[yytype]);
    }
  }
  {
#line 761
  yy_symbol_value_print(yyoutput, yytype, yyvaluep);
#line 762
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)")");
  }
#line 763
  return;
}
}
#line 772 "parseppd.c"
static void yy_stack_print(yytype_int16 *bottom , yytype_int16 *top ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 781
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 782
    if (! ((unsigned long )bottom <= (unsigned long )top)) {
#line 782
      goto while_break;
    }
    {
#line 783
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            (int )*bottom);
#line 782
    bottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 784
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 785
  return;
}
}
#line 800 "parseppd.c"
static void yy_reduce_print(YYSTYPE *yyvsp , int ppdyyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 809
  yynrhs = (int )ppdr2[ppdyyrule];
#line 811
  yylno = (unsigned long )yyrline[ppdyyrule];
#line 812
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          ppdyyrule - 1, yylno);
#line 815
  yyi = 0;
  }
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    if (! (yyi < yynrhs)) {
#line 815
      goto while_break;
    }
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yyi + 1);
#line 818
    yy_symbol_print(stderr, (int )yyrhs[(int const   )yyprhs[ppdyyrule] + (int const   )yyi],
                    (YYSTYPE const   */* const  */)(yyvsp + ((yyi + 1) - yynrhs)));
#line 821
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 815
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 823
  return;
}
}
#line 833 "parseppd.c"
int ppddebug  ;
#line 893 "parseppd.c"
static char *yystpcpy(char *yydest , char const   *yysrc ) 
{ 
  char *yyd ;
  char const   *ppds ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 902
  yyd = yydest;
#line 903
  ppds = yysrc;
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;
#line 905
    tmp = yyd;
#line 905
    yyd ++;
#line 905
    tmp___1 = ppds;
#line 905
    ppds ++;
#line 905
    tmp___0 = (char )*tmp___1;
#line 905
    *tmp = tmp___0;
#line 905
    if (! ((int )tmp___0 != 0)) {
#line 905
      goto while_break;
    }
#line 906
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 908
  return (yyd - 1);
}
}
#line 921 "parseppd.c"
static unsigned int yytnamerr(char *yyres , char const   *yystr ) 
{ 
  unsigned int yyn ;
  char const   *yyp ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 924
  if ((int const   )*yystr == 34) {
#line 926
    yyn = 0U;
#line 927
    yyp = yystr;
    {
#line 929
    while (1) {
      while_continue: /* CIL Label */ ;
#line 930
      yyp ++;
      {
#line 933
      if ((int const   )*yyp == 44) {
#line 933
        goto case_44;
      }
#line 933
      if ((int const   )*yyp == 39) {
#line 933
        goto case_44;
      }
#line 936
      if ((int const   )*yyp == 92) {
#line 936
        goto case_92;
      }
#line 946
      if ((int const   )*yyp == 34) {
#line 946
        goto case_34;
      }
#line 940
      goto switch_default;
      case_44: /* CIL Label */ 
      case_39: /* CIL Label */ 
#line 934
      goto do_not_strip_quotes;
      case_92: /* CIL Label */ 
#line 937
      yyp ++;
#line 937
      if ((int const   )*yyp != 92) {
#line 938
        goto do_not_strip_quotes;
      }
      switch_default: /* CIL Label */ 
#line 941
      if (yyres) {
#line 942
        *(yyres + yyn) = (char )*yyp;
      }
#line 943
      yyn ++;
#line 944
      goto switch_break;
      case_34: /* CIL Label */ 
#line 947
      if (yyres) {
#line 948
        *(yyres + yyn) = (char )'\000';
      }
#line 949
      return (yyn);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    do_not_strip_quotes: ;
  }
#line 954
  if (! yyres) {
    {
#line 955
    tmp = strlen(yystr);
    }
#line 955
    return (tmp);
  }
  {
#line 957
  tmp___0 = yystpcpy(yyres, yystr);
  }
#line 957
  return ((unsigned int )(tmp___0 - yyres));
}
}
#line 997
static unsigned int yysyntax_error(char *yyresult , int ppdstate , int ppdchar___0 ) ;
#line 997 "parseppd.c"
static char const   yyunexpected[28]  = 
#line 997
  {      (char const   )'s',      (char const   )'y',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'x',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )',',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 998 "parseppd.c"
static char const   yyexpecting[15]  = 
#line 998
  {      (char const   )',',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 999 "parseppd.c"
static char const   yyor[7]  = {      (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 968 "parseppd.c"
static unsigned int yysyntax_error(char *yyresult , int ppdstate , int ppdchar___0 ) 
{ 
  int yyn ;
  int yytype ;
  int tmp ;
  unsigned int yysize0 ;
  unsigned int tmp___0 ;
  unsigned int yysize ;
  unsigned int yysize1 ;
  int yysize_overflow ;
  char const   *yyarg[5] ;
  int yyx ;
  char *yyfmt ;
  char const   *yyf ;
  char yyformat[((sizeof(yyunexpected) + sizeof(yyexpecting)) - 1UL) + 3UL * (sizeof(yyor) - 1UL)] ;
  char const   *yyprefix ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yycount ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  size_t tmp___5 ;
  char *yyp ;
  int yyi ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  char tmp___8 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
#line 971
  yyn = (int )ppdpact[ppdstate];
#line 973
  if (-4 < yyn) {
#line 973
    if (yyn <= 26) {
#line 977
      if ((unsigned int )ppdchar___0 <= 265U) {
#line 977
        tmp = (int const   )yytranslate[ppdchar___0];
      } else {
#line 977
        tmp = (int const   )2;
      }
      {
#line 977
      yytype = (int )tmp;
#line 978
      tmp___0 = yytnamerr((char *)0, (char const   *)yytname[yytype]);
#line 978
      yysize0 = tmp___0;
#line 979
      yysize = yysize0;
#line 981
      yysize_overflow = 0;
#line 1004
      yyprefix = yyexpecting;
      }
#line 1008
      if (yyn < 0) {
#line 1008
        tmp___1 = - yyn;
      } else {
#line 1008
        tmp___1 = 0;
      }
#line 1008
      yyxbegin = tmp___1;
#line 1011
      yychecklim = (26 - yyn) + 1;
#line 1012
      if (yychecklim < 12) {
#line 1012
        tmp___2 = yychecklim;
      } else {
#line 1012
        tmp___2 = 12;
      }
      {
#line 1012
      yyxend = tmp___2;
#line 1013
      yycount = 1;
#line 1015
      yyarg[0] = (char const   *)yytname[yytype];
#line 1016
      yyfmt = yystpcpy(yyformat, yyunexpected);
#line 1018
      yyx = yyxbegin;
      }
      {
#line 1018
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1018
        if (! (yyx < yyxend)) {
#line 1018
          goto while_break;
        }
#line 1019
        if ((int const   )ppdyycheck[yyx + yyn] == (int const   )yyx) {
#line 1019
          if (yyx != 1) {
#line 1021
            if (yycount == 5) {
#line 1023
              yycount = 1;
#line 1024
              yysize = yysize0;
#line 1025
              yyformat[sizeof(yyunexpected) - 1UL] = (char )'\000';
#line 1026
              goto while_break;
            }
            {
#line 1028
            tmp___3 = yycount;
#line 1028
            yycount ++;
#line 1028
            yyarg[tmp___3] = (char const   *)yytname[yyx];
#line 1029
            tmp___4 = yytnamerr((char *)0, (char const   *)yytname[yyx]);
#line 1029
            yysize1 = yysize + tmp___4;
#line 1030
            yysize_overflow |= yysize1 < yysize;
#line 1031
            yysize = yysize1;
#line 1032
            yyfmt = yystpcpy(yyfmt, yyprefix);
#line 1033
            yyprefix = yyor;
            }
          }
        }
#line 1018
        yyx ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1036
      yyf = (char const   *)(yyformat);
#line 1037
      tmp___5 = strlen(yyf);
#line 1037
      yysize1 = yysize + tmp___5;
#line 1038
      yysize_overflow |= yysize1 < yysize;
#line 1039
      yysize = yysize1;
      }
#line 1041
      if (yysize_overflow) {
#line 1042
        return (4294967295U);
      }
#line 1044
      if (yyresult) {
#line 1049
        yyp = yyresult;
#line 1050
        yyi = 0;
        {
#line 1051
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1051
          tmp___8 = (char )*yyf;
#line 1051
          *yyp = tmp___8;
#line 1051
          if (! ((int )tmp___8 != 0)) {
#line 1051
            goto while_break___0;
          }
#line 1053
          if ((int )*yyp == 37) {
#line 1053
            if ((int const   )*(yyf + 1) == 115) {
#line 1053
              if (yyi < yycount) {
                {
#line 1055
                tmp___6 = yyi;
#line 1055
                yyi ++;
#line 1055
                tmp___7 = yytnamerr(yyp, yyarg[tmp___6]);
#line 1055
                yyp += tmp___7;
#line 1056
                yyf += 2;
                }
              } else {
#line 1060
                yyp ++;
#line 1061
                yyf ++;
              }
            } else {
#line 1060
              yyp ++;
#line 1061
              yyf ++;
            }
          } else {
#line 1060
            yyp ++;
#line 1061
            yyf ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1065
      return (yysize);
    } else {
#line 974
      return (0U);
    }
  } else {
#line 974
    return (0U);
  }
}
}
#line 1078 "parseppd.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1090
  if (! yymsg) {
#line 1091
    yymsg = "Deleting";
  }
  {
#line 1092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1092
    if (ppddebug) {
      {
#line 1092
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yymsg);
#line 1092
      yy_symbol_print(stderr, yytype, (YYSTYPE const   */* const  */)yyvaluep);
#line 1092
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1092
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1097
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1098
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1100
  return;
}
}
#line 1113
int ppdparse(void) ;
#line 1122 "parseppd.c"
int ppdchar  ;
#line 1125 "parseppd.c"
YYSTYPE ppdlval  ;
#line 1128 "parseppd.c"
int ppdnerrs  ;
#line 1149 "parseppd.c"
int ppdparse(void) 
{ 
  int ppdstate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned int yymsg_alloc ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned int yystacksize ;
  YYSTYPE ppdval ;
  int ppdyylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  unsigned int yysize___0 ;
  unsigned int tmp___0 ;
  unsigned int yyalloc ;
  void *tmp___1 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 1165
  yytoken = 0;
#line 1169
  yymsg = yymsgbuf;
#line 1170
  yymsg_alloc = (unsigned int )sizeof(yymsgbuf);
#line 1183
  yyss = yyssa;
#line 1188
  yyvs = yyvsa;
#line 1195
  yystacksize = 200U;
#line 1204
  ppdyylen = 0;
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    if (ppddebug) {
      {
#line 1206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 1206
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1208
  ppdstate = 0;
#line 1209
  yyerrstatus = 0;
#line 1210
  ppdnerrs = 0;
#line 1211
  ppdchar = -2;
#line 1218
  yyssp = yyss;
#line 1219
  yyvsp = yyvs;
#line 1221
  goto yysetstate;
  yynewstate: 
#line 1229
  yyssp ++;
  yysetstate: 
#line 1232
  *yyssp = (yytype_int16 )ppdstate;
#line 1234
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1237
    yysize = (unsigned int )((yyssp - yyss) + 1L);
#line 1266
    if (10000U <= yystacksize) {
#line 1267
      goto yyexhaustedlab;
    }
#line 1268
    yystacksize *= 2U;
#line 1269
    if (10000U < yystacksize) {
#line 1270
      yystacksize = 10000U;
    }
    {
#line 1273
    yyss1 = yyss;
#line 1274
    tmp = malloc((size_t )((unsigned long )yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL)));
#line 1274
    yyptr = (union yyalloc *)tmp;
    }
#line 1276
    if (! yyptr) {
#line 1277
      goto yyexhaustedlab;
    }
    {
#line 1278
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1278
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, (unsigned long )yysize * sizeof(*yyss));
#line 1278
      yyss = & yyptr->yyss;
#line 1278
      yynewbytes = (unsigned int )((unsigned long )yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL));
#line 1278
      yyptr += (unsigned long )yynewbytes / sizeof(*yyptr);
      }
#line 1278
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1279
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1279
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, (unsigned long )yysize * sizeof(*yyvs));
#line 1279
      yyvs = & yyptr->yyvs;
#line 1279
      yynewbytes___0 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL));
#line 1279
      yyptr += (unsigned long )yynewbytes___0 / sizeof(*yyptr);
      }
#line 1279
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1282
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1283
      free((void *)yyss1);
      }
    }
#line 1288
    yyssp = (yyss + yysize) - 1;
#line 1289
    yyvsp = (yyvs + yysize) - 1;
    {
#line 1292
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1292
      if (ppddebug) {
        {
#line 1292
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                (unsigned long )yystacksize);
        }
      }
#line 1292
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1295
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1296
      goto yyabortlab;
    }
  }
  {
#line 1299
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1299
    if (ppddebug) {
      {
#line 1299
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              ppdstate);
      }
    }
#line 1299
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1301
  goto yybackup;
  yybackup: 
#line 1312
  yyn = (int )ppdpact[ppdstate];
#line 1313
  if (yyn == -4) {
#line 1314
    goto yydefault;
  }
#line 1319
  if (ppdchar == -2) {
    {
#line 1321
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1321
      if (ppddebug) {
        {
#line 1321
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 1321
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1322
    ppdchar = ppdlex();
    }
  }
#line 1325
  if (ppdchar <= 0) {
#line 1327
    yytoken = 0;
#line 1327
    ppdchar = yytoken;
    {
#line 1328
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1328
      if (ppddebug) {
        {
#line 1328
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 1328
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 1332
    if ((unsigned int )ppdchar <= 265U) {
#line 1332
      yytoken = (int )yytranslate[ppdchar];
    } else {
#line 1332
      yytoken = 2;
    }
    {
#line 1333
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1333
      if (ppddebug) {
        {
#line 1333
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 1333
        yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& ppdlval));
#line 1333
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 1333
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1338
  yyn += yytoken;
#line 1339
  if (yyn < 0) {
#line 1340
    goto yydefault;
  } else
#line 1339
  if (26 < yyn) {
#line 1340
    goto yydefault;
  } else
#line 1339
  if ((int const   )ppdyycheck[yyn] != (int const   )yytoken) {
#line 1340
    goto yydefault;
  }
#line 1341
  yyn = (int )ppdyytable[yyn];
#line 1342
  if (yyn <= 0) {
#line 1344
    if (yyn == 0) {
#line 1345
      goto yyerrlab;
    } else
#line 1344
    if (yyn == -1) {
#line 1345
      goto yyerrlab;
    }
#line 1346
    yyn = - yyn;
#line 1347
    goto yyreduce;
  }
#line 1350
  if (yyn == 3) {
#line 1351
    goto yyacceptlab;
  }
#line 1355
  if (yyerrstatus) {
#line 1356
    yyerrstatus --;
  }
  {
#line 1359
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1359
    if (ppddebug) {
      {
#line 1359
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1359
      yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& ppdlval));
#line 1359
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1359
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1362
  if (ppdchar != 0) {
#line 1363
    ppdchar = -2;
  }
#line 1365
  ppdstate = yyn;
#line 1366
  yyvsp ++;
#line 1366
  *yyvsp = ppdlval;
#line 1368
  goto yynewstate;
  yydefault: 
#line 1375
  yyn = (int )yydefact[ppdstate];
#line 1376
  if (yyn == 0) {
#line 1377
    goto yyerrlab;
  }
#line 1378
  goto yyreduce;
  yyreduce: 
#line 1386
  ppdyylen = (int )ppdr2[yyn];
#line 1396
  ppdval = *(yyvsp + (1 - ppdyylen));
  {
#line 1399
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1399
    if (ppddebug) {
      {
#line 1399
      yy_reduce_print(yyvsp, yyn);
      }
    }
#line 1399
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1402
  if (yyn == 2) {
#line 1402
    goto case_2;
  }
#line 99
  if (yyn == 3) {
#line 99 "parseppd.y"
    goto case_3;
  }
#line 106
  if (yyn == 4) {
#line 106
    goto case_4;
  }
#line 111
  if (yyn == 5) {
#line 111
    goto case_5;
  }
#line 117
  if (yyn == 6) {
#line 117
    goto case_6;
  }
#line 123
  if (yyn == 7) {
#line 123
    goto case_7;
  }
#line 127
  if (yyn == 8) {
#line 127
    goto case_8;
  }
#line 131
  if (yyn == 9) {
#line 131
    goto case_9;
  }
#line 135
  if (yyn == 10) {
#line 135
    goto case_10;
  }
#line 139
  if (yyn == 11) {
#line 139
    goto case_11;
  }
#line 143
  if (yyn == 12) {
#line 143
    goto case_12;
  }
#line 151
  if (yyn == 13) {
#line 151
    goto case_13;
  }
#line 1491 "parseppd.c"
  goto switch_default;
  case_2: /* CIL Label */ 
#line 94 "parseppd.y"
  ppd_parse_result = (yyvsp + 0)->ppd;
#line 97
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 102
  ppdval.ppd = ppd_new();
  }
#line 104
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 106
  ppd_font_add((yyvsp + -2)->ppd, (char const   *)(yyvsp + -1)->string);
#line 107
  ppdval.ppd = (yyvsp + -2)->ppd;
  }
#line 109
  goto switch_break;
  case_5: /* CIL Label */ 
#line 111
  if (! ((yyvsp + -4)->ppd)->modelname) {
#line 112
    ((yyvsp + -4)->ppd)->modelname = (yyvsp + -1)->string;
  }
#line 113
  ppdval.ppd = (yyvsp + -4)->ppd;
#line 115
  goto switch_break;
  case_6: /* CIL Label */ 
#line 117
  if (! ((yyvsp + -4)->ppd)->nickname) {
#line 118
    ((yyvsp + -4)->ppd)->nickname = (yyvsp + -1)->string;
  }
#line 119
  ppdval.ppd = (yyvsp + -4)->ppd;
#line 121
  goto switch_break;
  case_7: /* CIL Label */ 
#line 123
  ppdval.ppd = (yyvsp + -1)->ppd;
#line 125
  goto switch_break;
  case_8: /* CIL Label */ 
#line 127
  ppdval.ppd = (yyvsp + -1)->ppd;
#line 129
  goto switch_break;
  case_9: /* CIL Label */ 
#line 131
  ppdval.ppd = (yyvsp + -1)->ppd;
#line 133
  goto switch_break;
  case_10: /* CIL Label */ 
#line 135
  ppdval.ppd = (yyvsp + -1)->ppd;
#line 137
  goto switch_break;
  case_11: /* CIL Label */ 
#line 139
  ppdval.ppd = (yyvsp + -1)->ppd;
#line 141
  goto switch_break;
  case_12: /* CIL Label */ 
#line 148
  ppdval.string = (yyvsp + -5)->string;
#line 149
  goto switch_break;
  case_13: /* CIL Label */ 
#line 150
  ppdval.string = (yyvsp + 0)->string;
#line 151
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1491 "parseppd.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1493
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1493
    if (ppddebug) {
      {
#line 1493
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 1493
      yy_symbol_print(stderr, (int )ppdr1[yyn], (YYSTYPE const   */* const  */)(& ppdval));
#line 1493
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1493
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1495
  yyvsp -= ppdyylen;
#line 1495
  yyssp -= ppdyylen;
#line 1496
  ppdyylen = 0;
  {
#line 1497
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1497
    if (ppddebug) {
      {
#line 1497
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1497
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 1499
  yyvsp ++;
#line 1499
  *yyvsp = ppdval;
#line 1506
  yyn = (int )ppdr1[yyn];
#line 1508
  ppdstate = (int )((int const   )yypgoto[yyn - 12] + (int const   )*yyssp);
#line 1509
  if (0 <= ppdstate) {
#line 1509
    if (ppdstate <= 26) {
#line 1509
      if ((int const   )ppdyycheck[ppdstate] == (int const   )*yyssp) {
#line 1510
        ppdstate = (int )ppdyytable[ppdstate];
      } else {
#line 1512
        ppdstate = (int )yydefgoto[yyn - 12];
      }
    } else {
#line 1512
      ppdstate = (int )yydefgoto[yyn - 12];
    }
  } else {
#line 1512
    ppdstate = (int )yydefgoto[yyn - 12];
  }
#line 1514
  goto yynewstate;
  yyerrlab: 
#line 1522
  if (! yyerrstatus) {
    {
#line 1524
    ppdnerrs ++;
#line 1529
    tmp___0 = yysyntax_error((char *)0, ppdstate, ppdchar);
#line 1529
    yysize___0 = tmp___0;
    }
#line 1530
    if (yymsg_alloc < yysize___0) {
#line 1530
      if (yymsg_alloc < 4294967295U) {
#line 1532
        yyalloc = 2U * yysize___0;
#line 1533
        if (yysize___0 <= yyalloc) {
#line 1533
          if (! (yyalloc <= 4294967295U)) {
#line 1534
            yyalloc = 4294967295U;
          }
        } else {
#line 1534
          yyalloc = 4294967295U;
        }
#line 1535
        if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
          {
#line 1536
          free((void *)yymsg);
          }
        }
        {
#line 1537
        tmp___1 = malloc(yyalloc);
#line 1537
        yymsg = (char *)tmp___1;
        }
#line 1538
        if (yymsg) {
#line 1539
          yymsg_alloc = yyalloc;
        } else {
#line 1542
          yymsg = yymsgbuf;
#line 1543
          yymsg_alloc = (unsigned int )sizeof(yymsgbuf);
        }
      }
    }
#line 1547
    if (0U < yysize___0) {
#line 1547
      if (yysize___0 <= yymsg_alloc) {
        {
#line 1549
        yysyntax_error(yymsg, ppdstate, ppdchar);
#line 1550
        ppderror((char const   *)yymsg);
        }
      } else {
#line 1547
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1554
      ppderror("syntax error");
      }
#line 1555
      if (yysize___0 != 0U) {
#line 1556
        goto yyexhaustedlab;
      }
    }
  }
#line 1564
  if (yyerrstatus == 3) {
#line 1569
    if (ppdchar <= 0) {
#line 1572
      if (ppdchar == 0) {
#line 1573
        goto yyabortlab;
      }
    } else {
      {
#line 1577
      yydestruct("Error: discarding", yytoken, & ppdlval);
#line 1579
      ppdchar = -2;
      }
    }
  }
#line 1585
  goto yyerrlab1;
#line 1601
  yyvsp -= ppdyylen;
#line 1601
  yyssp -= ppdyylen;
#line 1602
  ppdyylen = 0;
  {
#line 1603
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1603
    if (ppddebug) {
      {
#line 1603
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1603
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1604
  ppdstate = (int )*yyssp;
#line 1605
  goto yyerrlab1;
  yyerrlab1: 
#line 1612
  yyerrstatus = 3;
  {
#line 1614
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1616
    yyn = (int )ppdpact[ppdstate];
#line 1617
    if (yyn != -4) {
#line 1619
      yyn ++;
#line 1620
      if (0 <= yyn) {
#line 1620
        if (yyn <= 26) {
#line 1620
          if ((int const   )ppdyycheck[yyn] == 1) {
#line 1622
            yyn = (int )ppdyytable[yyn];
#line 1623
            if (0 < yyn) {
#line 1624
              goto while_break___12;
            }
          }
        }
      }
    }
#line 1629
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 1630
      goto yyabortlab;
    }
    {
#line 1633
    yydestruct("Error: popping", (int )yystos[ppdstate], yyvsp);
#line 1635
    yyvsp --;
#line 1635
    yyssp --;
#line 1636
    ppdstate = (int )*yyssp;
    }
    {
#line 1637
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1637
      if (ppddebug) {
        {
#line 1637
        yy_stack_print(yyss, yyssp);
        }
      }
#line 1637
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 1640
  if (yyn == 3) {
#line 1641
    goto yyacceptlab;
  }
#line 1643
  yyvsp ++;
#line 1643
  *yyvsp = ppdlval;
  {
#line 1647
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 1647
    if (ppddebug) {
      {
#line 1647
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1647
      yy_symbol_print(stderr, (int )yystos[yyn], (YYSTYPE const   */* const  */)yyvsp);
#line 1647
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1647
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 1649
  ppdstate = yyn;
#line 1650
  goto yynewstate;
  yyacceptlab: 
#line 1657
  yyresult = 0;
#line 1658
  goto yyreturn;
  yyabortlab: 
#line 1664
  yyresult = 1;
#line 1665
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 1672
  ppderror("memory exhausted");
#line 1673
  yyresult = 2;
  }
  yyreturn: 
#line 1678
  if (ppdchar != 0) {
#line 1678
    if (ppdchar != -2) {
      {
#line 1679
      yydestruct("Cleanup: discarding lookahead", yytoken, & ppdlval);
      }
    }
  }
#line 1683
  yyvsp -= ppdyylen;
#line 1683
  yyssp -= ppdyylen;
  {
#line 1684
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 1684
    if (ppddebug) {
      {
#line 1684
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1684
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 1685
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1685
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 1685
      goto while_break___16;
    }
    {
#line 1687
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 1689
    yyvsp --;
#line 1689
    yyssp --;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1692
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 1693
    free((void *)yyss);
    }
  }
#line 1696
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    {
#line 1697
    free((void *)yymsg);
    }
  }
#line 1700
  return (yyresult);
}
}
#line 154 "parseppd.y"
void ppderror(char const   *msg ) 
{ 


  {
  {
#line 157
  error_at_line(1, 0, (char const   *)ppdfilename, (unsigned int )ppdlineno, msg);
  }
#line 158
  return;
}
}
#line 163 "parseppd.y"
static void yyprint(FILE *file , int type , YYSTYPE value ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 167
  if (type == 263) {
#line 167
    goto case_263;
  }
#line 171
  if (type == 264) {
#line 171
    goto case_264;
  }
#line 175
  if (type == 265) {
#line 175
    goto case_265;
  }
#line 166
  goto switch_break;
  case_263: /* CIL Label */ 
  {
#line 168
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" \"%s\"",
          value.string);
  }
#line 169
  goto switch_break;
  case_264: /* CIL Label */ 
  {
#line 172
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s", value.string);
  }
#line 173
  goto switch_break;
  case_265: /* CIL Label */ 
  {
#line 176
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" u\"%s\"",
          value.ustring);
  }
#line 177
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 179
  return;
}
}
#line 181 "parseppd.y"
struct ppd *a2ps_ppd_parse(char const   *filename , char * const  *path ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 185
  ppdfilename = (char *)filename;
#line 186
  ppdlineno = 1;
#line 187
  ppdin = xrfopen((char const   *)ppdfilename);
#line 188
  ppdpath = path;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if ((unsigned int )(((1 << 6) | (1 << 9)) | (1 << 11)) & msg_verbosity) {
      {
#line 190
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing file `%s\'\n",
              ppdfilename);
      }
    }
#line 190
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  ppdlex_initialize();
  }
#line 195
  if ((unsigned int )(1 << 11) & msg_verbosity) {
#line 196
    ppddebug = 1;
  } else {
#line 198
    ppddebug = 0;
  }
  {
#line 200
  ppdparse();
#line 202
  fclose(ppdin);
  }
#line 203
  return (ppd_parse_result);
}
}
#line 63 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.h"
void pair_delete(struct hash_table_s *table , char const   *key ) ;
#line 76
void pair_table_self_print(struct hash_table_s *table , FILE *stream ) ;
#line 82
void pair_table_map(struct hash_table_s *table , void (*map_fn)(int i , char const   *key ,
                                                                char const   *value ,
                                                                void const   *arg ) ,
                    int (*select_fn)(char const   *key , char const   *value ) , void const   *arg ) ;
#line 90
int pair_table_load(struct hash_table_s *table , char const   *file ) ;
#line 57 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
static unsigned long pair_hash_1(struct pair *pair ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    result = 0UL;
    {
#line 60
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 60
      kk = (unsigned char const   *)pair->key - 1;
      {
#line 60
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 60
        kk ++;
#line 60
        if (! *kk) {
#line 60
          goto while_break___1;
        }
#line 60
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 60
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 60
    return (result);
#line 60
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (0UL);
}
}
#line 63 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
static unsigned long pair_hash_2(struct pair *pair ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    result = 0UL;
    {
#line 66
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 66
      kk = (unsigned char const   *)pair->key - 1;
      {
#line 66
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 66
        kk ++;
#line 66
        if (! *kk) {
#line 66
          goto while_break___1;
        }
#line 66
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 66
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 66
    return (result);
#line 66
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return (0UL);
}
}
#line 69 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
static int pair_hash_cmp(struct pair *x , struct pair *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 72
      xx = (unsigned char const   *)x->key - 1;
#line 72
      yy = (unsigned char const   *)y->key - 1;
      {
#line 72
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 72
        xx ++;
#line 72
        if ((int const   )*xx == 0) {
#line 72
          yy ++;
#line 72
          goto while_break___1;
        }
#line 72
        yy ++;
#line 72
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 72
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 72
      result = (int )((int const   )*xx - (int const   )*yy);
#line 72
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 72
    return (result);
#line 72
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (0);
}
}
#line 78 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
static int pair_hash_qcmp(struct pair **x , struct pair **y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      xx = (unsigned char const   *)(*x)->key - 1;
#line 81
      yy = (unsigned char const   *)(*y)->key - 1;
      {
#line 81
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 81
        xx ++;
#line 81
        if ((int const   )*xx == 0) {
#line 81
          yy ++;
#line 81
          goto while_break___1;
        }
#line 81
        yy ++;
#line 81
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 81
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 81
      result = (int )((int const   )*xx - (int const   )*yy);
#line 81
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 81
    return (result);
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (0);
}
}
#line 87 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
static void pair_free(struct pair *pair ) 
{ 


  {
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (pair->key) {
      {
#line 90
      free((void *)pair->key);
      }
    }
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (pair->value) {
      {
#line 91
      free((void *)pair->value);
      }
    }
#line 91
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 92
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 92
    if (pair) {
      {
#line 92
      free((void *)pair);
      }
    }
#line 92
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 97 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
static size_t pair_key_len(struct pair *pair ) 
{ 
  size_t tmp ;

  {
  {
#line 100
  tmp = strlen((char const   *)pair->key);
  }
#line 100
  return (tmp);
}
}
#line 104 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
static void pair_key_fputs(struct pair *pair , FILE *stream ) 
{ 


  {
  {
#line 107
  fputs((char const   */* __restrict  */)pair->key, (FILE */* __restrict  */)stream);
  }
#line 108
  return;
}
}
#line 115 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
struct pair_htable *pair_table_new(void) 
{ 
  struct hash_table_s *res___2 ;
  void *tmp ;

  {
  {
#line 120
  tmp = xmalloc((size_t )sizeof(struct hash_table_s ));
#line 120
  res___2 = (struct hash_table_s *)tmp;
#line 121
  hash_init(res___2, 8UL, (unsigned long (*)(void const   *key ))(& pair_hash_1),
            (unsigned long (*)(void const   *key ))(& pair_hash_2), (int (*)(void const   *x ,
                                                                             void const   *y ))(& pair_hash_cmp));
  }
#line 125
  return (res___2);
}
}
#line 131 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
void pair_table_free(struct hash_table_s *table ) 
{ 


  {
  {
#line 134
  hash_free(table, (void (*)(void const   *item ))(& pair_free));
#line 135
  free((void *)table);
  }
#line 136
  return;
}
}
#line 142 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
void pair_add(struct hash_table_s *table , char const   *key , char const   *value ) 
{ 
  struct pair *item ;
  struct pair token___1 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 148
  token___1.key = (char *)key;
#line 149
  tmp = hash_find_item(table, (void const   *)(& token___1));
#line 149
  item = (struct pair *)tmp;
  }
#line 151
  if (item) {
#line 152
    if (item->value) {
      {
#line 153
      free((void *)item->value);
      }
    }
  } else {
    {
#line 155
    tmp___0 = xmalloc((size_t )sizeof(struct pair ));
#line 155
    item = (struct pair *)tmp___0;
#line 156
    item->key = xstrdup(key);
    }
  }
#line 159
  if (value) {
    {
#line 160
    item->value = xstrdup(value);
    }
  } else {
#line 162
    item->value = (char *)((void *)0);
  }
  {
#line 164
  hash_insert(table, (void *)item);
  }
#line 165
  return;
}
}
#line 171 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
void pair_delete(struct hash_table_s *table , char const   *key ) 
{ 
  struct pair *item ;
  struct pair token___1 ;
  void *tmp ;

  {
  {
#line 176
  token___1.key = (char *)key;
#line 177
  tmp = hash_find_item(table, (void const   *)(& token___1));
#line 177
  item = (struct pair *)tmp;
  }
#line 179
  if (item) {
    {
#line 180
    hash_delete(table, (void const   *)item);
#line 181
    pair_free(item);
    }
  }
#line 183
  return;
}
}
#line 190 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
char *pair_get(struct hash_table_s *table , char const   *key ) 
{ 
  struct pair *item ;
  struct pair token___1 ;
  void *tmp ;

  {
  {
#line 195
  token___1.key = (char *)key;
#line 196
  tmp = hash_find_item(table, (void const   *)(& token___1));
#line 196
  item = (struct pair *)tmp;
  }
#line 198
  if (item) {
#line 199
    return (item->value);
  } else {
#line 201
    return ((char *)((void *)0));
  }
}
}
#line 207 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
void pair_table_map(struct hash_table_s *table , void (*map_fn)(int i , char const   *key ,
                                                                char const   *value ,
                                                                void const   *arg ) ,
                    int (*select_fn)(char const   *key , char const   *value ) , void const   *arg ) 
{ 
  int i ;
  int num ;
  struct pair **entries ;
  void **tmp ;
  int tmp___0 ;

  {
  {
#line 213
  num = 0;
#line 215
  tmp = hash_dump(table, (void **)((void *)0), (int (*)(void const   *x , void const   *y ))(& pair_hash_qcmp));
#line 215
  entries = (struct pair **)tmp;
#line 219
  i = 0;
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! *(entries + i)) {
#line 219
      goto while_break;
    }
#line 220
    if (! select_fn) {
      {
#line 223
      (*map_fn)(num, (char const   *)(*(entries + i))->key, (char const   *)(*(entries + i))->value,
                arg);
#line 224
      num ++;
      }
    } else {
      {
#line 220
      tmp___0 = (*select_fn)((char const   *)(*(entries + i))->key, (char const   *)(*(entries + i))->value);
      }
#line 220
      if (tmp___0) {
        {
#line 223
        (*map_fn)(num, (char const   *)(*(entries + i))->key, (char const   *)(*(entries + i))->value,
                  arg);
#line 224
        num ++;
        }
      }
    }
#line 219
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  free((void *)entries);
  }
#line 229
  return;
}
}
#line 234 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
void pair_table_list_short(struct hash_table_s *table , FILE *stream ) 
{ 
  struct pair **entries ;
  void **tmp ;

  {
  {
#line 238
  tmp = hash_dump(table, (void **)((void *)0), (int (*)(void const   *x , void const   *y ))(& pair_hash_qcmp));
#line 238
  entries = (struct pair **)tmp;
#line 242
  lister_fprint_vertical((struct lister *)((void *)0), stream, (void **)entries, (size_t )-1,
                         (size_t (*)(void const   *item ))(& pair_key_len), (void (*)(void const   *item ,
                                                                                      FILE *stream ))(& pair_key_fputs));
#line 246
  free((void *)entries);
  }
#line 247
  return;
}
}
#line 252 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
void pair_table_list_long(struct hash_table_s *table , FILE *stream ) 
{ 
  int i ;
  struct pair **entries ;
  void **tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 257
  tmp = hash_dump(table, (void **)((void *)0), (int (*)(void const   *x , void const   *y ))(& pair_hash_qcmp));
#line 257
  entries = (struct pair **)tmp;
#line 261
  i = 0;
  }
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! *(entries + i)) {
#line 261
      goto while_break;
    }
#line 262
    if ((*(entries + i))->value) {
#line 262
      tmp___0 = (char const   *)(*(entries + i))->value;
    } else {
#line 262
      tmp___0 = "<NULL>";
    }
    {
#line 262
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%-16s = %s\n",
            (*(entries + i))->key, tmp___0);
#line 261
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  _IO_putc('\n', stream);
#line 267
  free((void *)entries);
  }
#line 268
  return;
}
}
#line 273 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
void pair_table_self_print(struct hash_table_s *table , FILE *stream ) 
{ 
  int i ;
  struct pair **entries ;
  void **tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 278
  tmp = hash_dump(table, (void **)((void *)0), (int (*)(void const   *x , void const   *y ))(& pair_hash_qcmp));
#line 278
  entries = (struct pair **)tmp;
#line 282
  i = 0;
  }
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! *(entries + i)) {
#line 282
      goto while_break;
    }
#line 283
    if ((*(entries + i))->value) {
#line 283
      tmp___0 = (char const   *)(*(entries + i))->value;
    } else {
#line 283
      tmp___0 = "<NULL>";
    }
    {
#line 283
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s:%s\n",
            (*(entries + i))->key, tmp___0);
#line 282
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 287
  _IO_putc('\n', stream);
#line 288
  free((void *)entries);
  }
#line 289
  return;
}
}
#line 301 "/home/ysko/Works/test-src/a2ps-4.14/lib/pair_ht.c"
int pair_table_load(struct hash_table_s *table , char const   *file ) 
{ 
  FILE *fp ;
  char *buf___0 ;
  size_t bufsiz ;
  char *token___1 ;
  char *token2 ;
  int firstline ;
  int lastline ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 305
  buf___0 = (char *)((void *)0);
#line 306
  bufsiz = (size_t )0;
#line 308
  firstline = 0;
#line 308
  lastline = 0;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if ((unsigned int )(1 << 6) & msg_verbosity) {
      {
#line 310
      tmp = quotearg(file);
#line 310
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Loading map file `%s\'\n",
              tmp);
      }
    }
#line 310
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  fp = xrfopen(file);
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 314
    tmp___5 = getshline_numbered(& firstline, & lastline, & buf___0, & bufsiz, fp);
    }
#line 314
    if (! (tmp___5 != -1)) {
#line 314
      goto while_break___0;
    }
    {
#line 316
    token___1 = strtok((char */* __restrict  */)buf___0, (char const   */* __restrict  */)" \t\n");
    }
#line 318
    if (! token___1) {
#line 320
      goto while_continue___0;
    }
    {
#line 322
    tmp___4 = strcmp((char const   *)token___1, "***");
    }
#line 322
    if (tmp___4 == 0) {
      {
#line 325
      token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
      }
#line 326
      if ((unsigned long )token2 == (unsigned long )((void *)0)) {
        {
#line 326
        tmp___0 = quotearg((char const   *)token___1);
#line 326
        tmp___1 = gettext("missing argument for `%s\'");
#line 326
        error_at_line(1, 0, file, (unsigned int )firstline, (char const   *)tmp___1,
                      tmp___0);
        }
      }
      {
#line 327
      pair_table_load(table, (char const   *)token2);
      }
    } else {
      {
#line 331
      token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
      }
#line 332
      if ((unsigned long )token2 == (unsigned long )((void *)0)) {
        {
#line 332
        tmp___2 = quotearg((char const   *)token___1);
#line 332
        tmp___3 = gettext("missing argument for `%s\'");
#line 332
        error_at_line(1, 0, file, (unsigned int )firstline, (char const   *)tmp___3,
                      tmp___2);
        }
      }
      {
#line 333
      pair_add(table, (char const   *)token___1, (char const   *)token2);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 337
  free((void *)buf___0);
#line 338
  fclose(fp);
  }
#line 339
  return (1);
}
}
#line 103 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.h"
enum face_e string_to_face(char const   *string ) ;
#line 112
void face_set_font(struct a2ps_job *job___0 , enum face_e face , char const   *font_name ) ;
#line 69 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.h"
char const   *encoding_resolve_font_substitute(struct a2ps_job *job___0 , struct encoding *encoding ,
                                               char const   *font_list ) ;
#line 79
void encoding_add_font_name_used(struct encoding *encoding , char const   *name ) ;
#line 53 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.h"
void output_report(struct output *out , FILE *stream ) ;
#line 65
void output_delayed_chunk(struct output *out , struct output *out2 ) ;
#line 82
void output_self_print(struct output *out , FILE *stream ) ;
#line 75 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.h"
void da_print_stats(struct darray *arr , FILE *stream ) ;
#line 83 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.h"
struct dstring *ds_new(size_t size , enum ds_growth growth , size_t increment ) ;
#line 86
void ds_erase(struct dstring *string ) ;
#line 87
void ds_print_stats(struct dstring *str , FILE *stream ) ;
#line 105
void ds_strccat(struct dstring *s , char c ) ;
#line 120
void ds_unsafe_cat_vsprintf(struct dstring *ds , char const   *format , va_list args ) ;
#line 47 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.h"
void add_needed_resource(struct a2ps_job *job___0 , char const   *key , char const   *value ) ;
#line 49
int exist_resource(struct a2ps_job *job___0 , char const   *key , char const   *value ) ;
#line 52
void add_process_color(struct a2ps_job *job___0 , char const   *value ) ;
#line 62
void add_supplied_resource(struct a2ps_job *job___0 , char const   *key , char const   *value ) ;
#line 70
void add_required_font(struct a2ps_job *job___0 , char const   *name ) ;
#line 76 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
static struct derivation *new_derivation(enum derivation_type type ) 
{ 
  struct derivation *res___2 ;
  void *tmp ;

  {
  {
#line 79
  tmp = xmalloc((size_t )sizeof(struct derivation ));
#line 79
  res___2 = (struct derivation *)tmp;
#line 80
  res___2->type = type;
  }
#line 81
  return (res___2);
}
}
#line 84 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
static void derivation_self_print(struct derivation *derivation , FILE *stream ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 87
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"At %x: ",
          (int )derivation);
  }
  {
#line 90
  if ((unsigned int )derivation->type == 0U) {
#line 90
    goto case_0;
  }
#line 94
  if ((unsigned int )derivation->type == 1U) {
#line 94
    goto case_1;
  }
#line 98
  if ((unsigned int )derivation->type == 2U) {
#line 98
    goto case_2;
  }
#line 106
  if ((unsigned int )derivation->type == 3U) {
#line 106
    goto case_3;
  }
#line 110
  if ((unsigned int )derivation->type == 4U) {
#line 110
    goto case_4;
  }
#line 88
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 91
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"nothing ");
  }
#line 92
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 95
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"delayed_int (%d)",
          *(derivation->delayed_int));
  }
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 99
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"delayed_string ");
  }
#line 100
  if (*(derivation->delayed_string)) {
    {
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(%s)",
            *(derivation->delayed_string));
    }
  } else {
    {
#line 103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"##BROKEN##");
    }
  }
#line 104
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 107
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"delayed_routine ");
  }
#line 108
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 111
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"delayed_chunk ");
  }
#line 112
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 122 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
struct output *output_new(char const   *name ) 
{ 
  struct output *res___2 ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 125
  res___2 = (struct output *)((void *)0);
#line 127
  tmp = xmalloc((size_t )sizeof(struct output ));
#line 127
  res___2 = (struct output *)tmp;
#line 128
  res___2->name = name;
#line 129
  res___2->chunk = ds_new((size_t )51200, (enum ds_growth )2, (size_t )2);
#line 130
  res___2->derivations = da_new("derivations", (size_t )10, (enum da_growth )2, (size_t )2,
                                (void (*)(void const   * , FILE *stream ))(& derivation_self_print),
                                (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
#line 134
  res___2->to_void = 0;
  }
#line 136
  return (res___2);
}
}
#line 142 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_free(struct output *out ) 
{ 


  {
  {
#line 145
  ds_erase(out->chunk);
#line 146
  da_free(out->derivations, & free);
#line 147
  free((void *)out);
  }
#line 148
  return;
}
}
#line 150 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_report(struct output *out , FILE *stream ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 153
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Output `%s\' stats:\n",
          out->name);
#line 154
  ds_print_stats(out->chunk, stream);
#line 155
  da_print_stats(out->derivations, stream);
  }
#line 156
  return;
}
}
#line 161 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_to_void(struct output *out , int forget ) 
{ 


  {
#line 164
  out->to_void = forget;
#line 165
  return;
}
}
#line 170 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
int output_is_to_void(struct output *out ) 
{ 


  {
#line 173
  return (out->to_void);
}
}
#line 182 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void ( /* format attribute */  output)(struct output *out , char const   *format 
                                       , ...) 
{ 
  va_list args ;

  {
  {
#line 195
  __builtin_va_start(args, format);
  }
#line 198
  if (out->to_void) {
#line 199
    return;
  }
  {
#line 202
  ds_unsafe_cat_vsprintf(out->chunk, format, args);
#line 204
  __builtin_va_end(args);
  }
#line 209
  return;
}
}
#line 214 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_char(struct output *out , unsigned char c ) 
{ 


  {
#line 217
  if (out->to_void) {
#line 218
    return;
  }
  {
#line 220
  ds_strccat(out->chunk, (char )c);
  }
#line 221
  return;
}
}
#line 226 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_delayed_routine(struct output *out , void (*fn)(FILE *stream , void *arg ) ,
                            void *fn_arg ) 
{ 
  struct derivation *tmp ;

  {
#line 233
  if (out->to_void) {
#line 234
    return;
  }
  {
#line 236
  tmp = new_derivation((enum derivation_type )3);
#line 237
  tmp->delayed_routine = fn;
#line 238
  tmp->delayed_routine_arg = fn_arg;
#line 240
  output_char(out, (unsigned char )'\000');
#line 241
  da_append(out->derivations, (void *)tmp);
  }
#line 242
  return;
}
}
#line 244 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_delayed_chunk(struct output *out , struct output *out2 ) 
{ 
  struct derivation *tmp ;

  {
#line 249
  if (out->to_void) {
#line 250
    return;
  }
  {
#line 252
  tmp = new_derivation((enum derivation_type )4);
#line 253
  tmp->delayed_chunk = out2;
#line 255
  output_char(out, (unsigned char )'\000');
#line 256
  da_append(out->derivations, (void *)tmp);
  }
#line 257
  return;
}
}
#line 262 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_delayed_int(struct output *out , int *ptr ) 
{ 
  struct derivation *tmp ;

  {
#line 267
  if (out->to_void) {
#line 268
    return;
  }
  {
#line 270
  tmp = new_derivation((enum derivation_type )1);
#line 271
  tmp->delayed_int = ptr;
#line 273
  output_char(out, (unsigned char )'\000');
#line 274
  da_append(out->derivations, (void *)tmp);
  }
#line 275
  return;
}
}
#line 280 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_delayed_string(struct output *out , unsigned char **ptr ) 
{ 
  struct derivation *tmp ;

  {
#line 285
  if (out->to_void) {
#line 286
    return;
  }
  {
#line 288
  tmp = new_derivation((enum derivation_type )2);
#line 289
  tmp->delayed_string = ptr;
#line 291
  output_char(out, (unsigned char )'\000');
#line 292
  da_append(out->derivations, (void *)tmp);
  }
#line 293
  return;
}
}
#line 306 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_file(struct output *out , struct a2ps_job *job___0 , char const   *name ,
                 char const   *suffix ) 
{ 
  char buf___0[512] ;
  FILE *stream ;
  char *filename ;
  char *token___1 ;
  char *token2 ;
  int line ;
  int dont_output ;
  struct output *dest ;
  char const   *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *value ;
  char *res___2 ;
  char *buf2 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *res___3 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *fontname ;
  enum face_e face ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *basefontname ;
  char const   *true_font_name ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *expansion ;
  size_t tmp___31 ;
  unsigned char *tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  size_t tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  size_t tmp___43 ;
  int tmp___44 ;
  size_t tmp___45 ;
  int tmp___46 ;
  size_t tmp___47 ;
  int tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  void *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;

  {
#line 313
  token___1 = (char *)((void *)0);
#line 313
  token2 = (char *)((void *)0);
#line 314
  line = 0;
#line 315
  dont_output = 0;
#line 316
  dest = out;
#line 318
  if (out->to_void) {
#line 319
    return;
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if ((unsigned int )(1 << 6) & msg_verbosity) {
#line 321
      if ((unsigned long )((void const   *)suffix) == (unsigned long )((void *)0)) {
#line 321
        tmp = "";
      } else {
#line 321
        tmp = suffix;
      }
      {
#line 321
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Outputing file %s%s\n",
              name, tmp);
      }
    }
#line 321
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  filename = xpw_find_file((char * const  *)job___0->common.path, name, suffix);
#line 324
  stream = xrfopen((char const   *)filename);
  }
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 328
    tmp___2 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)stream);
    }
#line 328
    if (! tmp___2) {
#line 328
      goto while_break___0;
    }
    {
#line 329
    line ++;
#line 330
    tmp___0 = strlen("% -- code follows this line --");
#line 330
    tmp___1 = strncmp("% -- code follows this line --", (char const   *)(buf___0),
                      tmp___0);
    }
#line 330
    if (! tmp___1) {
#line 331
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 335
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 335
    tmp___49 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)stream);
    }
#line 335
    if (! tmp___49) {
#line 335
      goto while_break___1;
    }
    {
#line 336
    line ++;
#line 339
    tmp___5 = strlen("%%EndFontUsed");
#line 339
    tmp___6 = strncmp("%%EndFontUsed", (char const   *)(buf___0), tmp___5);
    }
#line 339
    if (tmp___6) {
#line 345
      if (dont_output) {
#line 346
        goto while_continue___1;
      } else {
        {
#line 351
        tmp___3 = strlen("%%IfFontUsed:");
#line 351
        tmp___4 = strncmp("%%IfFontUsed:", (char const   *)(buf___0), tmp___3);
        }
#line 351
        if (! tmp___4) {
#line 368
          goto while_continue___1;
        }
      }
    } else {
#line 341
      dont_output = 0;
#line 342
      goto while_continue___1;
    }
    {
#line 372
    tmp___47 = strlen("%%IncludeResource:");
#line 372
    tmp___48 = strncmp("%%IncludeResource:", (char const   *)(buf___0), tmp___47);
    }
#line 372
    if (tmp___48) {
      {
#line 407
      tmp___45 = strlen("%%DocumentProcessColors:");
#line 407
      tmp___46 = strncmp("%%DocumentProcessColors:", (char const   *)(buf___0), tmp___45);
      }
#line 407
      if (tmp___46) {
        {
#line 418
        tmp___43 = strlen("%%BeginResource:");
#line 418
        tmp___44 = strncmp("%%BeginResource:", (char const   *)(buf___0), tmp___43);
        }
#line 418
        if (tmp___44) {
          {
#line 434
          tmp___41 = strlen("%%EndSetup");
#line 434
          tmp___42 = strncmp("%%EndSetup", (char const   *)(buf___0), tmp___41);
          }
#line 434
          if (tmp___42) {
            {
#line 443
            tmp___39 = strlen("%%BeginSetup");
#line 443
            tmp___40 = strncmp("%%BeginSetup", (char const   *)(buf___0), tmp___39);
            }
#line 443
            if (tmp___40) {
              {
#line 450
              tmp___37 = strlen("%Face:");
#line 450
              tmp___38 = strncmp("%Face:", (char const   *)(buf___0), tmp___37);
              }
#line 450
              if (tmp___38) {
                {
#line 485
                tmp___35 = strlen("%Font:");
#line 485
                tmp___36 = strncmp("%Font:", (char const   *)(buf___0), tmp___35);
                }
#line 485
                if (tmp___36) {
                  {
#line 519
                  tmp___33 = strlen("%Expand:");
#line 519
                  tmp___34 = strncmp("%Expand:", (char const   *)(buf___0), tmp___33);
                  }
#line 519
                  if (! tmp___34) {
                    {
#line 523
                    tmp___31 = strlen("%Expand:");
#line 523
                    token___1 = strtok((char */* __restrict  */)(buf___0 + tmp___31),
                                       (char const   */* __restrict  */)"\n");
#line 524
                    tmp___32 = expand_user_string(job___0, (struct file_job *)*((job___0->jobs)->content + 0),
                                                  (unsigned char const   *)"Expand: requirement",
                                                  (unsigned char const   *)token___1);
#line 524
                    expansion = (char *)tmp___32;
#line 528
                    output(dest, (char const   *)expansion);
                    }
#line 529
                    goto while_continue___1;
                  }
                } else {
                  {
#line 490
                  token___1 = strtok((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" \t\n");
#line 494
                  token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
                  }
#line 495
                  if ((unsigned long )token2 == (unsigned long )((void *)0)) {
                    {
#line 495
                    tmp___27 = quotearg((char const   *)token___1);
#line 495
                    tmp___28 = gettext("missing argument for `%s\'");
#line 495
                    error_at_line(1, 0, (char const   *)filename, (unsigned int )line,
                                  (char const   *)tmp___28, tmp___27);
                    }
                  }
                  {
#line 496
                  basefontname = token2;
#line 498
                  token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
                  }
#line 499
                  if ((unsigned long )token2 == (unsigned long )((void *)0)) {
                    {
#line 499
                    tmp___29 = quotearg((char const   *)token___1);
#line 499
                    tmp___30 = gettext("missing argument for `%s\'");
#line 499
                    error_at_line(1, 0, (char const   *)filename, (unsigned int )line,
                                  (char const   *)tmp___30, tmp___29);
                    }
                  }
                  {
#line 501
                  encoding_add_font_name_used(job___0->requested_encoding, (char const   *)basefontname);
#line 508
                  true_font_name = encoding_resolve_font_substitute(job___0, job___0->requested_encoding,
                                                                    (char const   *)basefontname);
#line 512
                  add_required_font(job___0, true_font_name);
#line 515
                  output(dest, "  f%s %s scalefont setfont\n", basefontname, token2);
                  }
#line 516
                  goto while_continue___1;
                }
              } else {
                {
#line 456
                token___1 = strtok((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" \t\n");
#line 459
                token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
                }
#line 460
                if ((unsigned long )token2 == (unsigned long )((void *)0)) {
                  {
#line 460
                  tmp___19 = quotearg((char const   *)token___1);
#line 460
                  tmp___20 = gettext("missing argument for `%s\'");
#line 460
                  error_at_line(1, 0, (char const   *)filename, (unsigned int )line,
                                (char const   *)tmp___20, tmp___19);
                  }
                }
                {
#line 461
                face = string_to_face((char const   *)token2);
                }
#line 462
                if ((int )face == -1) {
                  {
#line 465
                  tmp___21 = quotearg((char const   *)token2);
#line 465
                  tmp___22 = gettext("invalid face `%s\'");
#line 465
                  error_at_line(1, 0, (char const   *)filename, (unsigned int )line,
                                (char const   *)tmp___22, tmp___21);
                  }
                }
                {
#line 469
                token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
                }
#line 470
                if ((unsigned long )token2 == (unsigned long )((void *)0)) {
                  {
#line 470
                  tmp___23 = quotearg((char const   *)token___1);
#line 470
                  tmp___24 = gettext("missing argument for `%s\'");
#line 470
                  error_at_line(1, 0, (char const   *)filename, (unsigned int )line,
                                (char const   *)tmp___24, tmp___23);
                  }
                }
                {
#line 471
                fontname = token2;
#line 474
                face_set_font(job___0, face, (char const   *)fontname);
#line 477
                token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
                }
#line 478
                if ((unsigned long )token2 == (unsigned long )((void *)0)) {
                  {
#line 478
                  tmp___25 = quotearg((char const   *)token___1);
#line 478
                  tmp___26 = gettext("missing argument for `%s\'");
#line 478
                  error_at_line(1, 0, (char const   *)filename, (unsigned int )line,
                                (char const   *)tmp___26, tmp___25);
                  }
                }
                {
#line 479
                output(dest, "  f%s %s scalefont setfont\n", fontname, token2);
                }
#line 481
                goto while_continue___1;
              }
            } else {
#line 445
              dest = (job___0->status)->setup;
#line 446
              goto while_continue___1;
            }
          } else {
#line 436
            if ((unsigned long )dest == (unsigned long )out) {
              {
#line 437
              error(1, 0, "`setup\' incoherence in output_file");
              }
            }
#line 438
            dest = out;
#line 439
            goto while_continue___1;
          }
        } else {
          {
#line 421
          output(dest, "%s", buf___0);
#line 423
          token___1 = strtok((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" \t\n");
#line 424
          token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
          }
#line 425
          if ((unsigned long )token2 == (unsigned long )((void *)0)) {
            {
#line 425
            tmp___15 = quotearg((char const   *)token___1);
#line 425
            tmp___16 = gettext("missing argument for `%s\'");
#line 425
            error_at_line(1, 0, (char const   *)filename, (unsigned int )line, (char const   *)tmp___16,
                          tmp___15);
            }
          }
          {
#line 426
          res___3 = token2;
#line 427
          token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
          }
#line 428
          if ((unsigned long )token2 == (unsigned long )((void *)0)) {
            {
#line 428
            tmp___17 = quotearg((char const   *)token___1);
#line 428
            tmp___18 = gettext("missing argument for `%s\'");
#line 428
            error_at_line(1, 0, (char const   *)filename, (unsigned int )line, (char const   *)tmp___18,
                          tmp___17);
            }
          }
          {
#line 429
          add_supplied_resource(job___0, (char const   *)res___3, (char const   *)token2);
          }
#line 430
          goto while_continue___1;
        }
      } else {
        {
#line 409
        token___1 = strtok((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" \t\n");
#line 410
        token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
        }
#line 411
        if ((unsigned long )token2 == (unsigned long )((void *)0)) {
          {
#line 411
          tmp___13 = quotearg((char const   *)token___1);
#line 411
          tmp___14 = gettext("missing argument for `%s\'");
#line 411
          error_at_line(1, 0, (char const   *)filename, (unsigned int )line, (char const   *)tmp___14,
                        tmp___13);
          }
        }
        {
#line 412
        add_process_color(job___0, (char const   *)token2);
        }
        {
#line 413
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 413
          token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
          }
#line 413
          if (! token2) {
#line 413
            goto while_break___2;
          }
          {
#line 414
          add_process_color(job___0, (char const   *)token2);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 415
        goto while_continue___1;
      }
    } else {
      {
#line 375
      buf2 = xstrdup((char const   *)(buf___0));
#line 376
      token___1 = strtok((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" \t\n");
#line 377
      token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
      }
#line 378
      if ((unsigned long )token2 == (unsigned long )((void *)0)) {
        {
#line 378
        tmp___7 = quotearg((char const   *)token___1);
#line 378
        tmp___8 = gettext("missing argument for `%s\'");
#line 378
        error_at_line(1, 0, (char const   *)filename, (unsigned int )line, (char const   *)tmp___8,
                      tmp___7);
        }
      }
      {
#line 379
      res___2 = token2;
#line 380
      tmp___12 = strcmp((char const   *)res___2, "file");
      }
#line 380
      if (tmp___12 == 0) {
        {
#line 383
        token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
        }
#line 384
        if ((unsigned long )token2 == (unsigned long )((void *)0)) {
          {
#line 384
          tmp___9 = quotearg((char const   *)token___1);
#line 384
          tmp___10 = gettext("missing argument for `%s\'");
#line 384
          error_at_line(1, 0, (char const   *)filename, (unsigned int )line, (char const   *)tmp___10,
                        tmp___9);
          }
        }
        {
#line 385
        value = token2;
#line 386
        tmp___11 = exist_resource(job___0, (char const   *)res___2, (char const   *)value);
        }
#line 386
        if (! tmp___11) {
          {
#line 388
          add_needed_resource(job___0, (char const   *)res___2, (char const   *)value);
          }
          {
#line 389
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 389
            if ((unsigned int )(1 << 6) & msg_verbosity) {
              {
#line 389
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Including file \'%s\' upon request given in \'%s\':%d\n",
                      value, filename, line);
              }
            }
#line 389
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 393
          output_file(dest, job___0, (char const   *)value, (char const   *)((void *)0));
          }
        }
      } else {
        {
#line 399
        output(dest, "%s", buf2);
        }
        {
#line 400
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 400
          value = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
          }
#line 400
          if (! value) {
#line 400
            goto while_break___4;
          }
          {
#line 401
          add_needed_resource(job___0, (char const   *)res___2, (char const   *)value);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 403
      free((void *)buf2);
      }
#line 404
      goto while_continue___1;
    }
    {
#line 532
    output(dest, "%s", buf___0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 535
  if ((unsigned long )dest != (unsigned long )out) {
    {
#line 537
    tmp___50 = gettext("`%s\' with no matching `%s\'");
#line 537
    error_at_line(1, 0, (char const   *)filename, (unsigned int )line, (char const   *)tmp___50,
                  "%%BeginSetup", "%%EndSetup");
    }
  }
  {
#line 541
  fclose(stream);
#line 542
  free((void *)filename);
  }
#line 543
  return;
}
}
#line 548 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
__inline static void underivation(FILE *stream , struct derivation  const  *derivation ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 553
  if ((unsigned int const   )derivation->type == 3U) {
#line 553
    goto case_3;
  }
#line 558
  if ((unsigned int const   )derivation->type == 1U) {
#line 558
    goto case_1;
  }
#line 562
  if ((unsigned int const   )derivation->type == 2U) {
#line 562
    goto case_2;
  }
#line 566
  if ((unsigned int const   )derivation->type == 4U) {
#line 566
    goto case_4;
  }
#line 570
  if ((unsigned int const   )derivation->type == 0U) {
#line 570
    goto case_0;
  }
#line 573
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 554
  (*(derivation->delayed_routine))(stream, (void *)derivation->delayed_routine_arg);
  }
#line 556
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 559
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d",
          *(derivation->delayed_int));
  }
#line 560
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 563
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
          *(derivation->delayed_string));
  }
#line 564
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 567
  output_dump((struct output *)derivation->delayed_chunk, stream);
  }
#line 568
  goto switch_break;
  case_0: /* CIL Label */ 
#line 571
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 574
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 576
  return;
}
}
#line 581 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_self_print(struct output *out , FILE *stream ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 584
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"The derivations:\n");
#line 585
  da_self_print(out->derivations, stream);
  }
#line 586
  return;
}
}
#line 591 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void output_dump(struct output *out , FILE *stream ) 
{ 
  size_t i ;
  char *piece ;
  struct derivation **derivations ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 595
  piece = (out->chunk)->content;
#line 596
  derivations = (struct derivation **)(out->derivations)->content;
#line 599
  if ((unsigned int )(1 << 7) & msg_verbosity) {
    {
#line 600
    output_report(out, stderr);
    }
  }
  {
#line 602
  fputs((char const   */* __restrict  */)piece, (FILE */* __restrict  */)stream);
#line 603
  tmp = strlen((char const   *)piece);
#line 603
  piece += tmp;
#line 604
  i = (size_t )0;
  }
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 604
    if (! (i < (out->derivations)->len)) {
#line 604
      goto while_break;
    }
    {
#line 606
    underivation(stream, (struct derivation  const  *)*(derivations + i));
#line 607
    piece ++;
#line 608
    fputs((char const   */* __restrict  */)piece, (FILE */* __restrict  */)stream);
#line 609
    tmp___0 = strlen((char const   *)piece);
#line 609
    piece += tmp___0;
#line 604
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  return;
}
}
#line 617 "/home/ysko/Works/test-src/a2ps-4.14/lib/output.c"
void undivert(struct a2ps_job *job___0 ) 
{ 


  {
  {
#line 621
  a2ps_open_output_stream(job___0);
#line 624
  output_dump(job___0->divertion, (job___0->output_stream)->fp);
#line 630
  a2ps_close_output_stream(job___0);
  }
#line 631
  return;
}
}
#line 282 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 36 "./getopt.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 39 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.h"
int (*handle_option_hook)(int opt , char *arg ) ;
#line 42
_Bool a2ps_get_bool(char const   *option , char const   *arg ) ;
#line 48
int a2ps_handle_options(struct a2ps_job *job___0 , int argc , char **argv ) ;
#line 51
int a2ps_handle_string_options(struct a2ps_job *job___0 , char const   *string ) ;
#line 71 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.h"
void (*argmatch_die)(void) ;
#line 99
int __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                         char const   *vallist , size_t valsize , int case_sensitive ,
                         void (*exit_fn)(void) ) ;
#line 140 "/home/ysko/Works/test-src/a2ps-4.14/lib/getopt.h"
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 29 "/home/ysko/Works/test-src/a2ps-4.14/lib/message.h"
int msg_verbosity_argmatch(char const   *option , char *arg ) ;
#line 45 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.h"
char const   *simple_backup_suffix ;
#line 56
enum backup_type get_version(char const   *context , char const   *version ) ;
#line 39 "/home/ysko/Works/test-src/a2ps-4.14/lib/madir.h"
madir_t madir_argmatch(char const   *option , char const   *arg ) ;
#line 57 "/home/ysko/Works/test-src/a2ps-4.14/lib/filalign.h"
file_align_t file_align_argmatch(char const   *option , char const   *arg ) ;
#line 46 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.h"
_Bool macro_meta_sequence_add(struct a2ps_job *job___0 , char const   *key , char const   *value ) ;
#line 49
void macro_meta_sequence_delete(struct a2ps_job *job___0 , char const   *key ) ;
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/lib/getnum.h"
int get_integer_in_range(char const   *option , char const   *arg , int min , int max ,
                         enum range_type_e range_type ) ;
#line 56
float get_length(char const   *option , char const   *arg , float min , float max ,
                 char const   *unit , enum range_type_e range_type ) ;
#line 95 "/home/ysko/Works/test-src/a2ps-4.14/lib/argv.h"
void freeargv_from(char **vector , int from ) ;
#line 144
char **buildargv_argc(char const   *input , int *argc ) ;
#line 59 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
char const   *program_name ;
#line 60
char const   *program_invocation_name ;
#line 65 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
int (*handle_option_hook)(int opt , char *arg )  =    (int (*)(int opt , char *arg ))((void *)0);
#line 69 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
static struct option  const  long_options[75]  = 
#line 69
  {      {"help", 0, (int *)0, 'h'}, 
        {"guess", 0, (int *)0, 138}, 
        {"list", 1, (int *)0, 145}, 
        {"version", 0, (int *)0, 'V'}, 
        {"list-options", 0, (int *)0, 139}, 
        {"list-media", 0, (int *)0, 161}, 
        {"list-style-sheets", 0, (int *)0, 162}, 
        {"help-languages", 0, (int *)0, 162}, 
        {"help-pretty-print", 0, (int *)0, 162}, 
        {"macro-meta-sequence", 1, (int *)0, 'D'}, 
        {"variable", 1, (int *)0, 'D'}, 
        {"define", 1, (int *)0, 'D'}, 
        {"user-option", 1, (int *)0, '='}, 
        {"pretty-print", 2, (int *)0, 'E'}, 
        {"ppd", 2, (int *)0, 163}, 
        {"prologue", 1, (int *)0, 134}, 
        {"include", 1, (int *)0, 134}, 
        {"sides", 1, (int *)0, 's'}, 
        {"statusdict", 1, (int *)0, 164}, 
        {"setpagedevice", 1, (int *)0, 'S'}, 
        {"columns", 1, (int *)0, 132}, 
        {"rows", 1, (int *)0, 133}, 
        {"compact", 1, (int *)0, 'A'}, 
        {"file-align", 1, (int *)0, 'A'}, 
        {"header", 2, (int *)0, 'b'}, 
        {"no-header", 0, (int *)0, 'B'}, 
        {"truncate-lines", 1, (int *)0, 151}, 
        {"line-numbers", 1, (int *)0, 152}, 
        {"font-size", 1, (int *)0, 'f'}, 
        {"graphic-symbols", 1, (int *)0, 154}, 
        {"highlight-level", 1, (int *)0, 173}, 
        {"interpret", 1, (int *)0, 155}, 
        {"end-of-line", 1, (int *)0, 169}, 
        {"borders", 1, (int *)0, 156}, 
        {"page-prefeed", 0, (int *)0, 'k'}, 
        {"no-page-prefeed", 0, (int *)0, 'K'}, 
        {"lines-per-page", 1, (int *)0, 'L'}, 
        {"chars-per-line", 1, (int *)0, 'l'}, 
        {"catman", 0, (int *)0, 'm'}, 
        {"medium", 1, (int *)0, 'M'}, 
        {"media", 1, (int *)0, 'M'}, 
        {"copies", 1, (int *)0, 'n'}, 
        {"output", 1, (int *)0, 'o'}, 
        {"printer", 2, (int *)0, 'P'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"silent", 0, (int *)0, 'q'}, 
        {"landscape", 0, (int *)0, 'r'}, 
        {"portrait", 0, (int *)0, 'R'}, 
        {"title", 2, (int *)0, 't'}, 
        {"tabsize", 1, (int *)0, 'T'}, 
        {"underlay", 1, (int *)0, 'u'}, 
        {"verbose", 2, (int *)0, 'v'}, 
        {"encoding", 1, (int *)0, 'X'}, 
        {"non-printable-format", 1, (int *)0, 135}, 
        {"print-anyway", 1, (int *)0, 136}, 
        {"center-title", 2, (int *)0, 149}, 
        {"left-title", 2, (int *)0, 140}, 
        {"right-title", 2, (int *)0, 141}, 
        {"left-footer", 2, (int *)0, 142}, 
        {"footer", 2, (int *)0, 143}, 
        {"right-footer", 2, (int *)0, 144}, 
        {"stdin", 1, (int *)0, 166}, 
        {"margin", 2, (int *)0, 147}, 
        {"strip-level", 1, (int *)0, 148}, 
        {"major", 1, (int *)0, 157}, 
        {"version-control", 1, (int *)0, 158}, 
        {"suffix", 1, (int *)0, 159}, 
        {"debug", 0, (int *)0, 146}, 
        {"delegate", 1, (int *)0, 160}, 
        {"pass-through", 1, (int *)0, 160}, 
        {"toc", 2, (int *)0, 167}, 
        {"pages", 2, (int *)0, 'a'}, 
        {"which", 0, (int *)0, 137}, 
        {"glob", 0, (int *)0, 150}, 
        {(char const   *)((void *)0), 0, (int *)0, 0}};
#line 187 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
static char const   * const  bool_args[7]  = {      (char const   */* const  */)"yes",      (char const   */* const  */)"on",      (char const   */* const  */)"1",      (char const   */* const  */)"no", 
        (char const   */* const  */)"off",      (char const   */* const  */)"0",      (char const   */* const  */)0};
#line 194 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
static _Bool const   bool_types[6]  = {      (_Bool const   )1,      (_Bool const   )1,      (_Bool const   )1,      (_Bool const   )0, 
        (_Bool const   )0,      (_Bool const   )0};
#line 203 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
_Bool a2ps_get_bool(char const   *option , char const   *arg ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 206
  if (! (sizeof(bool_args) / sizeof(bool_args[0]) == sizeof(bool_types) / sizeof(bool_types[0]) + 1UL)) {
    {
#line 206
    __assert_fail("(sizeof (((bool_args))) / sizeof (*((bool_args)))) == (sizeof (((bool_types))) / sizeof (*((bool_types)))) + 1",
                  "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c", 206U, "a2ps_get_bool");
    }
  }
  {
#line 207
  tmp = __xargmatch_internal(option, arg, bool_args, (char const   *)(bool_types),
                             (size_t )sizeof(bool_types[0]), 0, argmatch_die);
  }
#line 207
  return ((_Bool )bool_types[tmp]);
}
}
#line 212 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
static char const   * const  non_printable_args[9]  = 
#line 212
  {      (char const   */* const  */)"octal",      (char const   */* const  */)"hexa",      (char const   */* const  */)"emacs",      (char const   */* const  */)"questionmark", 
        (char const   */* const  */)"space",      (char const   */* const  */)"white",      (char const   */* const  */)"blank",      (char const   */* const  */)"caret", 
        (char const   */* const  */)0};
#line 223 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
static enum unprintable_format  const  non_printable_types[8]  = 
#line 223
  {      (enum unprintable_format  const  )3,      (enum unprintable_format  const  )4,      (enum unprintable_format  const  )5,      (enum unprintable_format  const  )2, 
        (enum unprintable_format  const  )1,      (enum unprintable_format  const  )1,      (enum unprintable_format  const  )1,      (enum unprintable_format  const  )0};
#line 237 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
static char const   * const  duplex_args[7]  = {      (char const   */* const  */)"simplex",      (char const   */* const  */)"1",      (char const   */* const  */)"none",      (char const   */* const  */)"duplex", 
        (char const   */* const  */)"2",      (char const   */* const  */)"tumble",      (char const   */* const  */)0};
#line 245 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
static enum duplex_e  const  duplex_types[6]  = {      (enum duplex_e  const  )0,      (enum duplex_e  const  )0,      (enum duplex_e  const  )0,      (enum duplex_e  const  )1, 
        (enum duplex_e  const  )1,      (enum duplex_e  const  )2};
#line 278 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
int a2ps_handle_options(struct a2ps_job *job___0 , int argc , char **argv ) 
{ 
  struct opt_optarg *opt_optarg_head ;
  struct opt_optarg *opt_optarg ;
  int res___2 ;
  int option_index ;
  int option ;
  struct opt_optarg *new ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  unsigned char const   *my_s2 ;
  char *tmp___3 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  char *value ;
  size_t tmp___7 ;
  char *cp ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  char const   *my_s2___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *value___0 ;
  unsigned char const   *my_s2___1 ;
  char *tmp___13 ;
  unsigned char const   *my_s2___2 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char const   *my_s2___3 ;
  char *tmp___17 ;
  int tmp___18 ;
  _Bool tmp___19 ;
  char *value___1 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  _Bool tmp___24 ;
  unsigned char const   *my_s2___4 ;
  char *tmp___25 ;
  unsigned char const   *my_s2___5 ;
  char *tmp___26 ;
  unsigned char const   *my_s2___6 ;
  char *tmp___27 ;
  unsigned char const   *my_s2___7 ;
  char *tmp___28 ;
  unsigned char const   *my_s2___8 ;
  char *tmp___29 ;
  unsigned char const   *my_s2___9 ;
  char *tmp___30 ;
  char *tmp___31 ;
  unsigned char const   *my_s2___10 ;
  char *tmp___32 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;

  {
#line 281
  opt_optarg_head = (struct opt_optarg *)((void *)0);
#line 282
  opt_optarg = (struct opt_optarg *)((void *)0);
#line 286
  optind = 0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 291
    option_index = 0;
#line 295
    option = getopt_long(argc, (char * const  *)argv, "123456789=:A:a:b::BcCdD:E::f:gGhijkKl:L:mM:n:o:P:qrRs:S:t::T:u::v::VX:Z",
                         long_options, & option_index);
    }
#line 298
    if (option == 63) {
      {
#line 301
      tmp = gettext("Try `%s --help\' for more information.\n");
#line 301
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              program_invocation_name);
#line 304
      exit(1);
      }
    }
    {
#line 308
    tmp___0 = __builtin_alloca(sizeof(struct opt_optarg ));
#line 308
    new = (struct opt_optarg *)tmp___0;
#line 309
    new->option = option;
#line 310
    new->optarg = optarg;
#line 311
    new->next = (struct opt_optarg *)((void *)0);
    }
#line 312
    if (! opt_optarg) {
#line 314
      opt_optarg_head = new;
#line 315
      opt_optarg = opt_optarg_head;
    } else {
#line 319
      opt_optarg->next = new;
#line 320
      opt_optarg = opt_optarg->next;
    }
#line 324
    if (option == -1) {
#line 325
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  res___2 = optind;
#line 336
  opt_optarg = opt_optarg_head;
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 336
    if (! (opt_optarg->option != -1)) {
#line 336
      goto while_break___0;
    }
#line 340
    optarg = opt_optarg->optarg;
#line 346
    if (handle_option_hook) {
      {
#line 346
      tmp___1 = (*handle_option_hook)(opt_optarg->option, optarg);
      }
#line 346
      if (tmp___1) {
#line 349
        goto __Cont;
      }
    }
    {
#line 362
    if (opt_optarg->option == 49) {
#line 362
      goto case_49;
    }
#line 366
    if (opt_optarg->option == 50) {
#line 366
      goto case_50;
    }
#line 370
    if (opt_optarg->option == 51) {
#line 370
      goto case_51;
    }
#line 374
    if (opt_optarg->option == 52) {
#line 374
      goto case_52;
    }
#line 378
    if (opt_optarg->option == 53) {
#line 378
      goto case_53;
    }
#line 382
    if (opt_optarg->option == 54) {
#line 382
      goto case_54;
    }
#line 386
    if (opt_optarg->option == 55) {
#line 386
      goto case_55;
    }
#line 390
    if (opt_optarg->option == 56) {
#line 390
      goto case_56;
    }
#line 394
    if (opt_optarg->option == 57) {
#line 394
      goto case_57;
    }
#line 398
    if (opt_optarg->option == 61) {
#line 398
      goto case_61;
    }
#line 402
    if (opt_optarg->option == 97) {
#line 402
      goto case_97;
    }
#line 406
    if (opt_optarg->option == 65) {
#line 406
      goto case_65;
    }
#line 410
    if (opt_optarg->option == 98) {
#line 410
      goto case_98;
    }
#line 414
    if (opt_optarg->option == 66) {
#line 414
      goto case_66;
    }
#line 435
    if (opt_optarg->option == 99) {
#line 435
      goto case_99;
    }
#line 439
    if (opt_optarg->option == 151) {
#line 439
      goto case_151;
    }
#line 444
    if (opt_optarg->option == 67) {
#line 444
      goto case_67;
    }
#line 448
    if (opt_optarg->option == 152) {
#line 448
      goto case_152;
    }
#line 456
    if (opt_optarg->option == 100) {
#line 456
      goto case_100;
    }
#line 460
    if (opt_optarg->option == 83) {
#line 460
      goto case_83;
    }
#line 478
    if (opt_optarg->option == 102) {
#line 478
      goto case_102;
    }
#line 495
    if (opt_optarg->option == 105) {
#line 495
      goto case_105;
    }
#line 499
    if (opt_optarg->option == 155) {
#line 499
      goto case_155;
    }
#line 503
    if (opt_optarg->option == 106) {
#line 503
      goto case_106;
    }
#line 507
    if (opt_optarg->option == 156) {
#line 507
      goto case_156;
    }
#line 511
    if (opt_optarg->option == 107) {
#line 511
      goto case_107;
    }
#line 515
    if (opt_optarg->option == 75) {
#line 515
      goto case_75;
    }
#line 519
    if (opt_optarg->option == 108) {
#line 519
      goto case_108;
    }
#line 526
    if (opt_optarg->option == 76) {
#line 526
      goto case_76;
    }
#line 536
    if (opt_optarg->option == 109) {
#line 536
      goto case_109;
    }
#line 541
    if (opt_optarg->option == 77) {
#line 541
      goto case_77;
    }
#line 545
    if (opt_optarg->option == 110) {
#line 545
      goto case_110;
    }
#line 550
    if (opt_optarg->option == 111) {
#line 550
      goto case_111;
    }
#line 554
    if (opt_optarg->option == 80) {
#line 554
      goto case_80;
    }
#line 558
    if (opt_optarg->option == 113) {
#line 558
      goto case_113;
    }
#line 564
    if (opt_optarg->option == 114) {
#line 564
      goto case_114;
    }
#line 568
    if (opt_optarg->option == 82) {
#line 568
      goto case_82;
    }
#line 572
    if (opt_optarg->option == 115) {
#line 572
      goto case_115;
    }
#line 595
    if (opt_optarg->option == 164) {
#line 595
      goto case_164;
    }
#line 615
    if (opt_optarg->option == 116) {
#line 615
      goto case_116;
    }
#line 619
    if (opt_optarg->option == 84) {
#line 619
      goto case_84;
    }
#line 624
    if (opt_optarg->option == 117) {
#line 624
      goto case_117;
    }
#line 628
    if (opt_optarg->option == 118) {
#line 628
      goto case_118;
    }
#line 643
    if (opt_optarg->option == 88) {
#line 643
      goto case_88;
    }
#line 657
    if (opt_optarg->option == 132) {
#line 657
      goto case_132;
    }
#line 662
    if (opt_optarg->option == 133) {
#line 662
      goto case_133;
    }
#line 667
    if (opt_optarg->option == 134) {
#line 667
      goto case_134;
    }
#line 671
    if (opt_optarg->option == 135) {
#line 671
      goto case_135;
    }
#line 678
    if (opt_optarg->option == 136) {
#line 678
      goto case_136;
    }
#line 682
    if (opt_optarg->option == 68) {
#line 682
      goto case_68;
    }
#line 707
    if (opt_optarg->option == 140) {
#line 707
      goto case_140;
    }
#line 711
    if (opt_optarg->option == 141) {
#line 711
      goto case_141;
    }
#line 715
    if (opt_optarg->option == 149) {
#line 715
      goto case_149;
    }
#line 719
    if (opt_optarg->option == 142) {
#line 719
      goto case_142;
    }
#line 723
    if (opt_optarg->option == 143) {
#line 723
      goto case_143;
    }
#line 727
    if (opt_optarg->option == 144) {
#line 727
      goto case_144;
    }
#line 731
    if (opt_optarg->option == 146) {
#line 731
      goto case_146;
    }
#line 735
    if (opt_optarg->option == 147) {
#line 735
      goto case_147;
    }
#line 743
    if (opt_optarg->option == 157) {
#line 743
      goto case_157;
    }
#line 747
    if (opt_optarg->option == 158) {
#line 747
      goto case_158;
    }
#line 751
    if (opt_optarg->option == 159) {
#line 751
      goto case_159;
    }
#line 755
    if (opt_optarg->option == 163) {
#line 755
      goto case_163;
    }
#line 759
    if (opt_optarg->option == 166) {
#line 759
      goto case_166;
    }
#line 763
    if (opt_optarg->option == 63) {
#line 763
      goto case_63;
    }
#line 353
    goto switch_break;
    case_49: /* CIL Label */ 
#line 363
    job___0->columns = 1;
#line 363
    job___0->rows = 1;
#line 363
    job___0->orientation = (ORIENTATION )0;
#line 363
    job___0->columns_requested = 80;
#line 363
    job___0->lines_requested = 0;
#line 363
    job___0->madir = (madir_t )0;
#line 364
    goto switch_break;
    case_50: /* CIL Label */ 
#line 367
    job___0->columns = 2;
#line 367
    job___0->rows = 1;
#line 367
    job___0->orientation = (ORIENTATION )1;
#line 367
    job___0->columns_requested = 80;
#line 367
    job___0->lines_requested = 0;
#line 367
    job___0->madir = (madir_t )0;
#line 368
    goto switch_break;
    case_51: /* CIL Label */ 
#line 371
    job___0->columns = 3;
#line 371
    job___0->rows = 1;
#line 371
    job___0->orientation = (ORIENTATION )1;
#line 371
    job___0->columns_requested = 80;
#line 371
    job___0->lines_requested = 0;
#line 371
    job___0->madir = (madir_t )0;
#line 372
    goto switch_break;
    case_52: /* CIL Label */ 
#line 375
    job___0->columns = 2;
#line 375
    job___0->rows = 2;
#line 375
    job___0->orientation = (ORIENTATION )0;
#line 375
    job___0->columns_requested = 80;
#line 375
    job___0->lines_requested = 0;
#line 375
    job___0->madir = (madir_t )0;
#line 376
    goto switch_break;
    case_53: /* CIL Label */ 
#line 379
    job___0->columns = 5;
#line 379
    job___0->rows = 1;
#line 379
    job___0->orientation = (ORIENTATION )1;
#line 379
    job___0->columns_requested = 80;
#line 379
    job___0->lines_requested = 0;
#line 379
    job___0->madir = (madir_t )0;
#line 380
    goto switch_break;
    case_54: /* CIL Label */ 
#line 383
    job___0->columns = 3;
#line 383
    job___0->rows = 2;
#line 383
    job___0->orientation = (ORIENTATION )1;
#line 383
    job___0->columns_requested = 80;
#line 383
    job___0->lines_requested = 0;
#line 383
    job___0->madir = (madir_t )0;
#line 384
    goto switch_break;
    case_55: /* CIL Label */ 
#line 387
    job___0->columns = 7;
#line 387
    job___0->rows = 1;
#line 387
    job___0->orientation = (ORIENTATION )1;
#line 387
    job___0->columns_requested = 80;
#line 387
    job___0->lines_requested = 0;
#line 387
    job___0->madir = (madir_t )0;
#line 388
    goto switch_break;
    case_56: /* CIL Label */ 
#line 391
    job___0->columns = 4;
#line 391
    job___0->rows = 2;
#line 391
    job___0->orientation = (ORIENTATION )1;
#line 391
    job___0->columns_requested = 80;
#line 391
    job___0->lines_requested = 0;
#line 391
    job___0->madir = (madir_t )0;
#line 392
    goto switch_break;
    case_57: /* CIL Label */ 
#line 395
    job___0->columns = 3;
#line 395
    job___0->rows = 3;
#line 395
    job___0->orientation = (ORIENTATION )0;
#line 395
    job___0->columns_requested = 80;
#line 395
    job___0->lines_requested = 0;
#line 395
    job___0->madir = (madir_t )0;
#line 396
    goto switch_break;
    case_61: /* CIL Label */ 
    {
#line 399
    tmp___2 = user_option_get(job___0, optarg);
#line 399
    a2ps_handle_string_options(job___0, (char const   *)tmp___2);
    }
#line 400
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 403
    a2ps_page_range_set_string(job___0, (char const   *)optarg);
    }
#line 404
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 407
    job___0->file_align = file_align_argmatch("--file-align", (char const   *)optarg);
    }
#line 408
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 411
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 411
      my_s2 = (unsigned char const   *)((unsigned char *)optarg);
      {
#line 411
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 411
        if (job___0->header) {
          {
#line 411
          free((void *)job___0->header);
          }
        }
#line 411
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 411
      if ((unsigned long )((char const   *)my_s2) == (unsigned long )((void *)0)) {
#line 411
        job___0->header = (unsigned char *)((void *)0);
      } else
#line 411
      if ((int const   )*my_s2 == 0) {
#line 411
        job___0->header = (unsigned char *)((void *)0);
      } else {
        {
#line 411
        tmp___3 = xstrdup((char const   *)my_s2);
#line 411
        job___0->header = (unsigned char *)tmp___3;
        }
      }
#line 411
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 412
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 416
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 416
      if (job___0->header) {
        {
#line 416
        free((void *)job___0->header);
        }
      }
#line 416
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 417
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 417
      if (job___0->left_footer) {
        {
#line 417
        free((void *)job___0->left_footer);
        }
      }
#line 417
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 418
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 418
      if (job___0->footer) {
        {
#line 418
        free((void *)job___0->footer);
        }
      }
#line 418
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 419
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 419
      if (job___0->right_footer) {
        {
#line 419
        free((void *)job___0->right_footer);
        }
      }
#line 419
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 420
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 420
      if (job___0->left_title) {
        {
#line 420
        free((void *)job___0->left_title);
        }
      }
#line 420
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 421
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 421
      if (job___0->center_title) {
        {
#line 421
        free((void *)job___0->center_title);
        }
      }
#line 421
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 422
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 422
      if (job___0->right_title) {
        {
#line 422
        free((void *)job___0->right_title);
        }
      }
#line 422
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 423
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 423
      if (job___0->water) {
        {
#line 423
        free((void *)job___0->water);
        }
      }
#line 423
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 425
    job___0->header = (unsigned char *)((void *)0);
#line 426
    job___0->left_footer = (unsigned char *)((void *)0);
#line 427
    job___0->footer = (unsigned char *)((void *)0);
#line 428
    job___0->right_footer = (unsigned char *)((void *)0);
#line 429
    job___0->left_title = (unsigned char *)((void *)0);
#line 430
    job___0->center_title = (unsigned char *)((void *)0);
#line 431
    job___0->right_title = (unsigned char *)((void *)0);
#line 432
    job___0->water = (unsigned char *)((void *)0);
#line 433
    goto switch_break;
    case_99: /* CIL Label */ 
#line 436
    job___0->folding = (_Bool)0;
#line 437
    goto switch_break;
    case_151: /* CIL Label */ 
    {
#line 440
    tmp___5 = a2ps_get_bool("--truncate-lines", (char const   *)optarg);
    }
#line 440
    if (tmp___5) {
#line 440
      job___0->folding = (_Bool)0;
    } else {
#line 440
      job___0->folding = (_Bool)1;
    }
#line 442
    goto switch_break;
    case_67: /* CIL Label */ 
#line 445
    job___0->numbering = 5;
#line 446
    goto switch_break;
    case_152: /* CIL Label */ 
#line 450
    if (optarg) {
      {
#line 450
      tmp___6 = get_integer_in_range("--line-numbers", (char const   *)optarg, 0,
                                     0, (enum range_type_e )1);
#line 450
      job___0->numbering = tmp___6;
      }
    } else {
#line 450
      job___0->numbering = 1;
    }
#line 454
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 457
    a2ps_printers_flag_output_set(job___0->printers, (char const   *)((void *)0),
                                  (_Bool)1);
    }
#line 458
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 463
    tmp___7 = strcspn((char const   *)optarg, " \t:=");
#line 463
    value = optarg + tmp___7;
    }
#line 466
    if (*value) {
#line 468
      *value = (char )'\000';
#line 469
      value ++;
    }
#line 471
    if (*value) {
      {
#line 472
      setpagedevice(job___0, (char const   *)optarg, (char const   *)value);
      }
    } else {
      {
#line 474
      delpagedevice(job___0, (char const   *)optarg);
      }
    }
#line 476
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 482
    cp = strchr((char const   *)optarg, '@');
    }
#line 483
    if (cp) {
#line 484
      cp ++;
    } else {
#line 486
      cp = optarg;
    }
    {
#line 488
    job___0->fontsize = get_length("--font-size", (char const   *)cp, (float )0.0,
                                   (float )0.0, "pt", (enum range_type_e )2);
#line 490
    job___0->columns_requested = 0;
#line 491
    job___0->lines_requested = 0;
    }
#line 493
    goto switch_break;
    case_105: /* CIL Label */ 
#line 496
    job___0->interpret = 1;
#line 497
    goto switch_break;
    case_155: /* CIL Label */ 
    {
#line 500
    tmp___8 = a2ps_get_bool("--interpret", (char const   *)optarg);
#line 500
    job___0->interpret = (int )tmp___8;
    }
#line 501
    goto switch_break;
    case_106: /* CIL Label */ 
#line 504
    job___0->border = 1;
#line 505
    goto switch_break;
    case_156: /* CIL Label */ 
    {
#line 508
    tmp___9 = a2ps_get_bool("--border", (char const   *)optarg);
#line 508
    job___0->border = (int )tmp___9;
    }
#line 509
    goto switch_break;
    case_107: /* CIL Label */ 
#line 512
    job___0->page_prefeed = 1;
#line 513
    goto switch_break;
    case_75: /* CIL Label */ 
#line 516
    job___0->page_prefeed = 0;
#line 517
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 521
    job___0->columns_requested = get_integer_in_range("--chars-per-line", (char const   *)optarg,
                                                      1, 0, (enum range_type_e )1);
#line 523
    job___0->lines_requested = 0;
    }
#line 524
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 529
    job___0->lines_requested = get_integer_in_range("--lines-per-page", (char const   *)optarg,
                                                    1, 0, (enum range_type_e )1);
#line 533
    job___0->columns_requested = 0;
    }
#line 534
    goto switch_break;
    case_109: /* CIL Label */ 
#line 537
    job___0->lines_requested = 66;
#line 538
    job___0->columns_requested = 0;
#line 539
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 542
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 542
      my_s2___0 = (char const   *)optarg;
      {
#line 542
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 542
        if (job___0->medium_request) {
          {
#line 542
          free((void *)job___0->medium_request);
          }
        }
#line 542
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 542
      if ((unsigned long )my_s2___0 == (unsigned long )((void *)0)) {
#line 542
        job___0->medium_request = (char *)((void *)0);
      } else
#line 542
      if ((int const   )*my_s2___0 == 0) {
#line 542
        job___0->medium_request = (char *)((void *)0);
      } else {
        {
#line 542
        tmp___10 = xstrdup(my_s2___0);
#line 542
        job___0->medium_request = tmp___10;
        }
      }
#line 542
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 543
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 546
    job___0->copies = get_integer_in_range("--copies", (char const   *)optarg, 1,
                                           0, (enum range_type_e )1);
    }
#line 548
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 551
    a2ps_printers_flag_output_set(job___0->printers, (char const   *)optarg, (_Bool)0);
    }
#line 552
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 555
    a2ps_printers_flag_output_set(job___0->printers, (char const   *)optarg, (_Bool)1);
    }
#line 556
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 560
    tmp___11 = getenv("A2PS_VERBOSITY");
    }
#line 560
    if (! tmp___11) {
#line 561
      msg_verbosity = 0U;
    }
#line 562
    goto switch_break;
    case_114: /* CIL Label */ 
#line 565
    job___0->orientation = (ORIENTATION )1;
#line 566
    goto switch_break;
    case_82: /* CIL Label */ 
#line 569
    job___0->orientation = (ORIENTATION )0;
#line 570
    goto switch_break;
    case_115: /* CIL Label */ 
#line 574
    if (! (sizeof(duplex_args) / sizeof(duplex_args[0]) == sizeof(duplex_types) / sizeof(duplex_types[0]) + 1UL)) {
      {
#line 574
      __assert_fail("(sizeof (((duplex_args))) / sizeof (*((duplex_args)))) == (sizeof (((duplex_types))) / sizeof (*((duplex_types)))) + 1",
                    "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c", 574U, "a2ps_handle_options");
      }
    }
    {
#line 575
    tmp___12 = __xargmatch_internal("--sides", (char const   *)optarg, duplex_args,
                                    (char const   *)(duplex_types), (size_t )sizeof(duplex_types[0]),
                                    0, argmatch_die);
#line 575
    job___0->duplex = (enum duplex_e )duplex_types[tmp___12];
    }
    {
#line 579
    if ((unsigned int )job___0->duplex == 0U) {
#line 579
      goto case_0;
    }
#line 583
    if ((unsigned int )job___0->duplex == 1U) {
#line 583
      goto case_1;
    }
#line 588
    if ((unsigned int )job___0->duplex == 2U) {
#line 588
      goto case_2;
    }
#line 577
    goto switch_break___0;
    case_0: /* CIL Label */ 
    {
#line 580
    delpagedevice(job___0, "Duplex");
    }
#line 581
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 584
    setpagedevice(job___0, "Duplex", "true");
#line 585
    setpagedevice(job___0, "Tumble", "false");
    }
#line 586
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 589
    setpagedevice(job___0, "Duplex", "true");
#line 590
    setpagedevice(job___0, "Tumble", "true");
    }
#line 591
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 593
    goto switch_break;
    case_164: /* CIL Label */ 
    {
#line 598
    value___0 = strchr((char const   *)optarg, ':');
    }
#line 599
    if ((unsigned long )((char const   *)value___0) == (unsigned long )((void *)0)) {
      {
#line 601
      delstatusdict(job___0, (char const   *)optarg);
      }
    } else
#line 599
    if ((int )*value___0 == 0) {
      {
#line 601
      delstatusdict(job___0, (char const   *)optarg);
      }
    } else {
#line 605
      *value___0 = (char )'\000';
#line 606
      value___0 ++;
#line 607
      if ((int )*value___0 == 58) {
        {
#line 608
        setstatusdict(job___0, (char const   *)optarg, (char const   *)(value___0 + 1),
                      1);
        }
      } else {
        {
#line 610
        setstatusdict(job___0, (char const   *)optarg, (char const   *)value___0,
                      0);
        }
      }
    }
#line 613
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 616
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 616
      my_s2___1 = (unsigned char const   *)((unsigned char *)optarg);
      {
#line 616
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 616
        if (job___0->title) {
          {
#line 616
          free((void *)job___0->title);
          }
        }
#line 616
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 616
      if ((unsigned long )((char const   *)my_s2___1) == (unsigned long )((void *)0)) {
#line 616
        job___0->title = (unsigned char *)((void *)0);
      } else
#line 616
      if ((int const   )*my_s2___1 == 0) {
#line 616
        job___0->title = (unsigned char *)((void *)0);
      } else {
        {
#line 616
        tmp___13 = xstrdup((char const   *)my_s2___1);
#line 616
        job___0->title = (unsigned char *)tmp___13;
        }
      }
#line 616
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 617
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 620
    job___0->tabsize = get_integer_in_range("--tabsize", (char const   *)optarg, 1,
                                            0, (enum range_type_e )1);
    }
#line 622
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 625
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 625
      my_s2___2 = (unsigned char const   *)((unsigned char *)optarg);
      {
#line 625
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 625
        if (job___0->water) {
          {
#line 625
          free((void *)job___0->water);
          }
        }
#line 625
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 625
      if ((unsigned long )((char const   *)my_s2___2) == (unsigned long )((void *)0)) {
#line 625
        job___0->water = (unsigned char *)((void *)0);
      } else
#line 625
      if ((int const   )*my_s2___2 == 0) {
#line 625
        job___0->water = (unsigned char *)((void *)0);
      } else {
        {
#line 625
        tmp___14 = xstrdup((char const   *)my_s2___2);
#line 625
        job___0->water = (unsigned char *)tmp___14;
        }
      }
#line 625
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 626
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 631
    tmp___16 = getenv("A2PS_VERBOSITY");
    }
#line 631
    if (! tmp___16) {
#line 633
      if ((unsigned long )((char const   *)optarg) == (unsigned long )((void *)0)) {
#line 639
        msg_verbosity = (unsigned int )((1 << 1) | 1);
      } else
#line 633
      if ((int )*optarg == 0) {
#line 639
        msg_verbosity = (unsigned int )((1 << 1) | 1);
      } else {
        {
#line 635
        tmp___15 = msg_verbosity_argmatch("--verbose", optarg);
#line 635
        msg_verbosity = (unsigned int )tmp___15;
        }
      }
    }
#line 641
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 653
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 653
      if (job___0->requested_encoding_name) {
        {
#line 653
        free((void *)job___0->requested_encoding_name);
        }
      }
#line 653
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 654
    job___0->requested_encoding_name = xstrdup((char const   *)optarg);
    }
#line 655
    goto switch_break;
    case_132: /* CIL Label */ 
    {
#line 658
    job___0->columns = get_integer_in_range("--columns", (char const   *)optarg, 1,
                                            0, (enum range_type_e )1);
    }
#line 660
    goto switch_break;
    case_133: /* CIL Label */ 
    {
#line 663
    job___0->rows = get_integer_in_range("--rows", (char const   *)optarg, 1, 0, (enum range_type_e )1);
    }
#line 665
    goto switch_break;
    case_134: /* CIL Label */ 
    {
#line 668
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 668
      my_s2___3 = (char const   *)optarg;
      {
#line 668
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 668
        if (job___0->prolog) {
          {
#line 668
          free((void *)job___0->prolog);
          }
        }
#line 668
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 668
      if ((unsigned long )my_s2___3 == (unsigned long )((void *)0)) {
#line 668
        job___0->prolog = (char *)((void *)0);
      } else
#line 668
      if ((int const   )*my_s2___3 == 0) {
#line 668
        job___0->prolog = (char *)((void *)0);
      } else {
        {
#line 668
        tmp___17 = xstrdup(my_s2___3);
#line 668
        job___0->prolog = tmp___17;
        }
      }
#line 668
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 669
    goto switch_break;
    case_135: /* CIL Label */ 
#line 672
    if (! (sizeof(non_printable_args) / sizeof(non_printable_args[0]) == sizeof(non_printable_types) / sizeof(non_printable_types[0]) + 1UL)) {
      {
#line 672
      __assert_fail("(sizeof (((non_printable_args))) / sizeof (*((non_printable_args)))) == (sizeof (((non_printable_types))) / sizeof (*((non_printable_types)))) + 1",
                    "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c", 672U, "a2ps_handle_options");
      }
    }
    {
#line 673
    tmp___18 = __xargmatch_internal("--non-printable", (char const   *)optarg, non_printable_args,
                                    (char const   *)(non_printable_types), (size_t )sizeof(non_printable_types[0]),
                                    0, argmatch_die);
#line 673
    job___0->unprintable_format = (enum unprintable_format )non_printable_types[tmp___18];
    }
#line 676
    goto switch_break;
    case_136: /* CIL Label */ 
    {
#line 679
    tmp___19 = a2ps_get_bool("--print-anyway", (char const   *)optarg);
#line 679
    job___0->print_binaries = (int )tmp___19;
    }
#line 680
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 685
    tmp___20 = strcspn((char const   *)optarg, " \t:=");
#line 685
    value___1 = optarg + tmp___20;
    }
#line 689
    if (*value___1) {
#line 690
      tmp___21 = value___1;
#line 690
      value___1 ++;
#line 690
      *tmp___21 = (char )'\000';
    } else {
#line 692
      value___1 = (char *)((void *)0);
    }
#line 693
    if (value___1) {
      {
#line 695
      tmp___24 = macro_meta_sequence_add(job___0, (char const   *)optarg, (char const   *)value___1);
      }
#line 695
      if (! tmp___24) {
        {
#line 696
        tmp___22 = quotearg((char const   *)optarg);
#line 696
        tmp___23 = gettext("invalid variable identifier `%s\'");
#line 696
        error(1, 0, (char const   *)tmp___23, tmp___22);
        }
      }
    } else {
      {
#line 702
      macro_meta_sequence_delete(job___0, (char const   *)optarg);
      }
    }
#line 705
    goto switch_break;
    case_140: /* CIL Label */ 
    {
#line 708
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 708
      my_s2___4 = (unsigned char const   *)((unsigned char *)optarg);
      {
#line 708
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 708
        if (job___0->left_title) {
          {
#line 708
          free((void *)job___0->left_title);
          }
        }
#line 708
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 708
      if ((unsigned long )((char const   *)my_s2___4) == (unsigned long )((void *)0)) {
#line 708
        job___0->left_title = (unsigned char *)((void *)0);
      } else
#line 708
      if ((int const   )*my_s2___4 == 0) {
#line 708
        job___0->left_title = (unsigned char *)((void *)0);
      } else {
        {
#line 708
        tmp___25 = xstrdup((char const   *)my_s2___4);
#line 708
        job___0->left_title = (unsigned char *)tmp___25;
        }
      }
#line 708
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 709
    goto switch_break;
    case_141: /* CIL Label */ 
    {
#line 712
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 712
      my_s2___5 = (unsigned char const   *)((unsigned char *)optarg);
      {
#line 712
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 712
        if (job___0->right_title) {
          {
#line 712
          free((void *)job___0->right_title);
          }
        }
#line 712
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 712
      if ((unsigned long )((char const   *)my_s2___5) == (unsigned long )((void *)0)) {
#line 712
        job___0->right_title = (unsigned char *)((void *)0);
      } else
#line 712
      if ((int const   )*my_s2___5 == 0) {
#line 712
        job___0->right_title = (unsigned char *)((void *)0);
      } else {
        {
#line 712
        tmp___26 = xstrdup((char const   *)my_s2___5);
#line 712
        job___0->right_title = (unsigned char *)tmp___26;
        }
      }
#line 712
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 713
    goto switch_break;
    case_149: /* CIL Label */ 
    {
#line 716
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 716
      my_s2___6 = (unsigned char const   *)((unsigned char *)optarg);
      {
#line 716
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 716
        if (job___0->center_title) {
          {
#line 716
          free((void *)job___0->center_title);
          }
        }
#line 716
        goto while_break___25;
      }
      while_break___25: /* CIL Label */ ;
      }
#line 716
      if ((unsigned long )((char const   *)my_s2___6) == (unsigned long )((void *)0)) {
#line 716
        job___0->center_title = (unsigned char *)((void *)0);
      } else
#line 716
      if ((int const   )*my_s2___6 == 0) {
#line 716
        job___0->center_title = (unsigned char *)((void *)0);
      } else {
        {
#line 716
        tmp___27 = xstrdup((char const   *)my_s2___6);
#line 716
        job___0->center_title = (unsigned char *)tmp___27;
        }
      }
#line 716
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
#line 717
    goto switch_break;
    case_142: /* CIL Label */ 
    {
#line 720
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 720
      my_s2___7 = (unsigned char const   *)((unsigned char *)optarg);
      {
#line 720
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 720
        if (job___0->left_footer) {
          {
#line 720
          free((void *)job___0->left_footer);
          }
        }
#line 720
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 720
      if ((unsigned long )((char const   *)my_s2___7) == (unsigned long )((void *)0)) {
#line 720
        job___0->left_footer = (unsigned char *)((void *)0);
      } else
#line 720
      if ((int const   )*my_s2___7 == 0) {
#line 720
        job___0->left_footer = (unsigned char *)((void *)0);
      } else {
        {
#line 720
        tmp___28 = xstrdup((char const   *)my_s2___7);
#line 720
        job___0->left_footer = (unsigned char *)tmp___28;
        }
      }
#line 720
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 721
    goto switch_break;
    case_143: /* CIL Label */ 
    {
#line 724
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 724
      my_s2___8 = (unsigned char const   *)((unsigned char *)optarg);
      {
#line 724
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 724
        if (job___0->footer) {
          {
#line 724
          free((void *)job___0->footer);
          }
        }
#line 724
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 724
      if ((unsigned long )((char const   *)my_s2___8) == (unsigned long )((void *)0)) {
#line 724
        job___0->footer = (unsigned char *)((void *)0);
      } else
#line 724
      if ((int const   )*my_s2___8 == 0) {
#line 724
        job___0->footer = (unsigned char *)((void *)0);
      } else {
        {
#line 724
        tmp___29 = xstrdup((char const   *)my_s2___8);
#line 724
        job___0->footer = (unsigned char *)tmp___29;
        }
      }
#line 724
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 725
    goto switch_break;
    case_144: /* CIL Label */ 
    {
#line 728
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 728
      my_s2___9 = (unsigned char const   *)((unsigned char *)optarg);
      {
#line 728
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 728
        if (job___0->right_footer) {
          {
#line 728
          free((void *)job___0->right_footer);
          }
        }
#line 728
        goto while_break___31;
      }
      while_break___31: /* CIL Label */ ;
      }
#line 728
      if ((unsigned long )((char const   *)my_s2___9) == (unsigned long )((void *)0)) {
#line 728
        job___0->right_footer = (unsigned char *)((void *)0);
      } else
#line 728
      if ((int const   )*my_s2___9 == 0) {
#line 728
        job___0->right_footer = (unsigned char *)((void *)0);
      } else {
        {
#line 728
        tmp___30 = xstrdup((char const   *)my_s2___9);
#line 728
        job___0->right_footer = (unsigned char *)tmp___30;
        }
      }
#line 728
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
#line 729
    goto switch_break;
    case_146: /* CIL Label */ 
#line 732
    job___0->debug = (_Bool)1;
#line 733
    goto switch_break;
    case_147: /* CIL Label */ 
#line 736
    if (optarg) {
      {
#line 737
      job___0->margin = get_integer_in_range("--margin", (char const   *)optarg, 0,
                                             0, (enum range_type_e )1);
      }
    } else {
#line 740
      job___0->margin = 12;
    }
#line 741
    goto switch_break;
    case_157: /* CIL Label */ 
    {
#line 744
    job___0->madir = madir_argmatch("--major", (char const   *)optarg);
    }
#line 745
    goto switch_break;
    case_158: /* CIL Label */ 
    {
#line 748
    job___0->backup_type = get_version("--version-control", (char const   *)optarg);
    }
#line 749
    goto switch_break;
    case_159: /* CIL Label */ 
    {
#line 752
    tmp___31 = xstrdup((char const   *)optarg);
#line 752
    simple_backup_suffix = (char const   *)tmp___31;
    }
#line 753
    goto switch_break;
    case_163: /* CIL Label */ 
    {
#line 756
    a2ps_printers_request_ppdkey_set(job___0->printers, (char const   *)optarg);
    }
#line 757
    goto switch_break;
    case_166: /* CIL Label */ 
    {
#line 760
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 760
      my_s2___10 = (unsigned char const   *)((unsigned char *)optarg);
      {
#line 760
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 760
        if (job___0->stdin_filename) {
          {
#line 760
          free((void *)job___0->stdin_filename);
          }
        }
#line 760
        goto while_break___33;
      }
      while_break___33: /* CIL Label */ ;
      }
#line 760
      if ((unsigned long )((char const   *)my_s2___10) == (unsigned long )((void *)0)) {
#line 760
        job___0->stdin_filename = (unsigned char *)((void *)0);
      } else
#line 760
      if ((int const   )*my_s2___10 == 0) {
#line 760
        job___0->stdin_filename = (unsigned char *)((void *)0);
      } else {
        {
#line 760
        tmp___32 = xstrdup((char const   *)my_s2___10);
#line 760
        job___0->stdin_filename = (unsigned char *)tmp___32;
        }
      }
#line 760
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
#line 761
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 766
    abort();
    }
#line 767
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 336
    opt_optarg = opt_optarg->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 771
  return (res___2);
}
}
#line 782 "/home/ysko/Works/test-src/a2ps-4.14/lib/options.c"
int a2ps_handle_string_options(struct a2ps_job *job___0 , char const   *string ) 
{ 
  int argc ;
  char **argv ;
  int res___2 ;
  int i ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 789
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 790
    return (0);
  }
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 792
    if ((unsigned int )(1 << 5) & msg_verbosity) {
      {
#line 792
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"handle_string_options(%s)",
              string);
      }
    }
#line 792
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 795
  argc = 1;
#line 796
  argv = buildargv_argc(string, & argc);
#line 797
  *(argv + 0) = program_name;
  }
#line 799
  if ((unsigned int )(1 << 5) & msg_verbosity) {
#line 802
    i = 0;
    {
#line 802
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 802
      if (! (i < argc)) {
#line 802
        goto while_break___0;
      }
      {
#line 803
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   %3d = `%s\'\n",
              i, *(argv + i));
#line 802
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 807
  res___2 = a2ps_handle_options(job___0, argc, argv);
#line 810
  freeargv_from(argv, 1);
  }
#line 812
  return (res___2);
}
}
#line 193 "/usr/include/time.h"
 __attribute__((__nothrow__)) time_t mktime(struct tm *tp ) ;
#line 237
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 102 "/home/ysko/Works/test-src/a2ps-4.14/lib/mktime.c"
unsigned short const   __mon_yday[2][13]  = { {        (unsigned short const   )0,        (unsigned short const   )31,        (unsigned short const   )59,        (unsigned short const   )90, 
            (unsigned short const   )120,        (unsigned short const   )151,        (unsigned short const   )181,        (unsigned short const   )212, 
            (unsigned short const   )243,        (unsigned short const   )273,        (unsigned short const   )304,        (unsigned short const   )334, 
            (unsigned short const   )365}, 
   {        (unsigned short const   )0,        (unsigned short const   )31,        (unsigned short const   )60,        (unsigned short const   )91, 
            (unsigned short const   )121,        (unsigned short const   )152,        (unsigned short const   )182,        (unsigned short const   )213, 
            (unsigned short const   )244,        (unsigned short const   )274,        (unsigned short const   )305,        (unsigned short const   )335, 
            (unsigned short const   )366}};
#line 117 "/home/ysko/Works/test-src/a2ps-4.14/lib/mktime.c"
static struct tm *my_mktime_localtime_r(time_t const   *t , struct tm *tp ) 
{ 
  struct tm *l ;
  struct tm *tmp ;

  {
  {
#line 120
  tmp = localtime(t);
#line 120
  l = tmp;
  }
#line 121
  if (! l) {
#line 122
    return ((struct tm *)0);
  }
#line 123
  *tp = *l;
#line 124
  return (tp);
}
}
#line 135 "/home/ysko/Works/test-src/a2ps-4.14/lib/mktime.c"
static time_t ydhms_tm_diff(int year , int yday , int hour , int min , int sec , struct tm  const  *tp ) 
{ 
  int a4 ;
  int b4 ;
  int a100 ;
  int b100 ;
  int a400 ;
  int b400 ;
  int intervening_leap_days ;
  time_t years ;
  time_t days ;

  {
#line 139
  if (! tp) {
#line 140
    return ((time_t )1);
  } else {
#line 148
    a4 = ((year >> 2) + (1900 >> 2)) - ! (year & 3);
#line 149
    b4 = (int )(((tp->tm_year >> 2) + (int const   )(1900 >> 2)) - (int const   )(! (tp->tm_year & 3)));
#line 150
    a100 = a4 / 25 - (a4 % 25 < 0);
#line 151
    b100 = b4 / 25 - (b4 % 25 < 0);
#line 152
    a400 = a100 >> 2;
#line 153
    b400 = b100 >> 2;
#line 154
    intervening_leap_days = ((a4 - b4) - (a100 - b100)) + (a400 - b400);
#line 155
    years = (time_t )year - (time_t )tp->tm_year;
#line 156
    days = (365L * years + (time_t )intervening_leap_days) + (time_t )(yday - (int )tp->tm_yday);
#line 158
    return (60L * (60L * (24L * days + (time_t )(hour - (int )tp->tm_hour)) + (time_t )(min - (int )tp->tm_min)) + (time_t )(sec - (int )tp->tm_sec));
  }
}
}
#line 167 "/home/ysko/Works/test-src/a2ps-4.14/lib/mktime.c"
static struct tm *ranged_convert(struct tm *(*convert)(time_t const   * , struct tm * ) ,
                                 time_t *t , struct tm *tp ) 
{ 
  struct tm *r ;
  time_t bad ;
  time_t ok ;
  struct tm tm ;
  time_t mid ;
  time_t tmp ;
  int tmp___0 ;

  {
  {
#line 173
  r = (*convert)((time_t const   *)t, tp);
  }
#line 173
  if (! r) {
#line 173
    if (*t) {
#line 175
      bad = *t;
#line 176
      ok = (time_t )0;
      {
#line 182
      while (1) {
        while_continue: /* CIL Label */ ;
#line 182
        if (bad < 0L) {
#line 182
          tmp___0 = -1;
        } else {
#line 182
          tmp___0 = 1;
        }
#line 182
        if (! (bad != ok + (time_t )tmp___0)) {
#line 182
          goto while_break;
        }
#line 184
        if (bad < 0L) {
#line 184
          tmp = bad + ((ok - bad) >> 1);
        } else {
#line 184
          tmp = ok + ((bad - ok) >> 1);
        }
        {
#line 184
        *t = tmp;
#line 184
        mid = tmp;
#line 187
        r = (*convert)((time_t const   *)t, tp);
        }
#line 187
        if (r) {
#line 189
          tm = *r;
#line 190
          ok = mid;
        } else {
#line 193
          bad = mid;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 196
      if (! r) {
#line 196
        if (ok) {
#line 200
          *t = ok;
#line 201
          *tp = tm;
#line 202
          r = tp;
        }
      }
    }
  }
#line 206
  return (r);
}
}
#line 215 "/home/ysko/Works/test-src/a2ps-4.14/lib/mktime.c"
time_t __mktime_internal(struct tm *tp , struct tm *(*convert)(time_t const   * ,
                                                               struct tm * ) , time_t *offset ) 
{ 
  time_t t ;
  time_t dt ;
  time_t t0 ;
  time_t t1 ;
  time_t t2 ;
  struct tm tm ;
  int remaining_probes ;
  int sec ;
  int min ;
  int hour ;
  int mday ;
  int mon ;
  int year_requested ;
  int isdst ;
  int mon_remainder ;
  int negative_mon_remainder ;
  int mon_years ;
  int year ;
  int yday ;
  int tmp ;
  int sec_requested ;
  struct tm *tmp___0 ;
  int quarter ;
  int i ;
  time_t ot ;
  struct tm otm ;
  time_t tmp___1 ;
  int tmp___2 ;
  struct tm *tmp___3 ;
  double dyear ;
  double dday ;
  double dsec ;
  time_t time_t_max ;
  time_t time_t_min ;
  double tmp___4 ;

  {
#line 227
  remaining_probes = 6;
#line 231
  sec = tp->tm_sec;
#line 232
  min = tp->tm_min;
#line 233
  hour = tp->tm_hour;
#line 234
  mday = tp->tm_mday;
#line 235
  mon = tp->tm_mon;
#line 236
  year_requested = tp->tm_year;
#line 237
  isdst = tp->tm_isdst;
#line 240
  mon_remainder = mon % 12;
#line 241
  negative_mon_remainder = mon_remainder < 0;
#line 242
  mon_years = mon / 12 - negative_mon_remainder;
#line 243
  year = year_requested + mon_years;
#line 252
  if ((year + 1900) % 4 == 0) {
#line 252
    if ((year + 1900) % 100 != 0) {
#line 252
      tmp = 1;
    } else
#line 252
    if ((year + 1900) % 400 == 0) {
#line 252
      tmp = 1;
    } else {
#line 252
      tmp = 0;
    }
  } else {
#line 252
    tmp = 0;
  }
#line 252
  yday = (int )(((int const   )__mon_yday[tmp][mon_remainder + 12 * negative_mon_remainder] + (int const   )mday) - 1);
#line 256
  sec_requested = sec;
#line 260
  if (sec < 0) {
#line 261
    sec = 0;
  }
#line 262
  if (59 < sec) {
#line 263
    sec = 59;
  }
  {
#line 269
  tm.tm_year = 70;
#line 270
  tm.tm_sec = 0;
#line 270
  tm.tm_min = tm.tm_sec;
#line 270
  tm.tm_hour = tm.tm_min;
#line 270
  tm.tm_yday = tm.tm_hour;
#line 271
  t0 = ydhms_tm_diff(year, yday, hour, min, sec, (struct tm  const  *)(& tm));
#line 273
  t2 = t0 + *offset;
#line 273
  t1 = t2;
#line 273
  t = t1;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 273
    tmp___0 = ranged_convert(convert, & t, & tm);
#line 273
    dt = ydhms_tm_diff(year, yday, hour, min, sec, (struct tm  const  *)tmp___0);
    }
#line 273
    if (! dt) {
#line 273
      goto while_break;
    }
#line 277
    if (t == t1) {
#line 277
      if (t != t2) {
#line 277
        if (isdst < 0) {
#line 287
          goto while_break;
        } else
#line 277
        if (tm.tm_isdst < 0) {
#line 287
          goto while_break;
        } else
#line 277
        if ((isdst != 0) != (tm.tm_isdst != 0)) {
#line 287
          goto while_break;
        } else {
#line 277
          goto _L___0;
        }
      } else {
#line 277
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 288
      remaining_probes --;
#line 288
      if (remaining_probes == 0) {
#line 289
        return ((time_t )-1);
      }
    }
#line 273
    t1 = t2;
#line 273
    t2 = t;
#line 273
    t += dt;
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  if (dt == 0L) {
#line 293
    if (isdst != tm.tm_isdst) {
#line 293
      if (0 <= isdst) {
#line 293
        if (0 <= tm.tm_isdst) {
#line 300
          quarter = 7889238;
#line 304
          if (t < (-1L << (sizeof(time_t ) * 8UL - 1UL)) + (time_t )(3 * quarter)) {
#line 305
            quarter = - quarter;
          }
#line 307
          i = 1;
          {
#line 307
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 307
            if (! (i <= 3)) {
#line 307
              goto while_break___0;
            }
            {
#line 309
            ot = t - (time_t )(i * quarter);
#line 311
            ranged_convert(convert, & ot, & otm);
            }
#line 312
            if (otm.tm_isdst == isdst) {
              {
#line 316
              tmp___1 = ydhms_tm_diff(year, yday, hour, min, sec, (struct tm  const  *)(& otm));
#line 316
              t = ot + tmp___1;
#line 317
              ranged_convert(convert, & t, & tm);
              }
#line 318
              goto while_break___0;
            }
#line 307
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 323
  *offset = t - t0;
#line 326
  if (sec_requested != tm.tm_sec) {
#line 330
    if (sec == 0) {
#line 330
      if (tm.tm_sec == 60) {
#line 330
        tmp___2 = 1;
      } else {
#line 330
        tmp___2 = 0;
      }
    } else {
#line 330
      tmp___2 = 0;
    }
    {
#line 330
    t += (time_t )((sec_requested - sec) + tmp___2);
#line 331
    tmp___3 = (*convert)((time_t const   *)(& t), & tm);
    }
#line 331
    if (! tmp___3) {
#line 332
      return ((time_t )-1);
    }
  }
#line 336
  if ((((((-1L - (-1L << (sizeof(time_t ) * 8UL - 1UL))) / 2147483647L) / 366L) / 24L) / 60L) / 60L < 3L) {
#line 344
    dyear = ((double )year_requested + (double )mon_years) - (double )tm.tm_year;
#line 345
    dday = (double )366 * dyear + (double )mday;
#line 346
    dsec = (double )60 * ((double )60 * ((double )24 * dday + (double )hour) + (double )min) + (double )sec_requested;
#line 353
    time_t_max = -1L - (-1L << (sizeof(time_t ) * 8UL - 1UL));
#line 354
    time_t_min = -1L << (sizeof(time_t ) * 8UL - 1UL);
#line 356
    if (dsec < (double )0) {
#line 356
      tmp___4 = - dsec;
    } else {
#line 356
      tmp___4 = dsec;
    }
#line 356
    if ((double )(time_t_max / 3L - time_t_min / 3L) < tmp___4) {
#line 357
      return ((time_t )-1);
    }
  }
#line 360
  *tp = tm;
#line 361
  return (t);
}
}
#line 365 "/home/ysko/Works/test-src/a2ps-4.14/lib/mktime.c"
static time_t localtime_offset  ;
#line 368
 __attribute__((__nothrow__)) time_t mktime(struct tm *tp ) ;
#line 368 "/home/ysko/Works/test-src/a2ps-4.14/lib/mktime.c"
time_t mktime(struct tm *tp ) 
{ 
  time_t tmp ;

  {
  {
#line 379
  tmp = __mktime_internal(tp, & my_mktime_localtime_r, & localtime_offset);
  }
#line 379
  return (tmp);
}
}
#line 204 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx )  __attribute__((__malloc__)) ;
#line 312 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 74 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.h"
void da_erase(struct darray *arr ) ;
#line 83
struct darray *da_clone(struct darray *array ) ;
#line 104
void da_remove_at(struct darray *arr , size_t where , void (*free_func)(void * ) ) ;
#line 69 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.h"
int file_name_cmp(struct file_job *f1 , struct file_job *f2 ) ;
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.h"
struct pair_htable *macro_meta_sequence_table_new(void) ;
#line 43
void macro_meta_sequence_table_free(struct pair_htable *table ) ;
#line 53
void macro_meta_sequences_list_short(struct a2ps_job *job___0 , FILE *stream ) ;
#line 56
void macro_meta_sequences_list_long(struct a2ps_job *job___0 , FILE *stream ) ;
#line 203 "./obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 205
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 231
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 53 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
struct pair_htable *macro_meta_sequence_table_new(void) 
{ 
  struct pair_htable *tmp ;

  {
  {
#line 56
  tmp = pair_table_new();
  }
#line 56
  return (tmp);
}
}
#line 62 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
void macro_meta_sequence_table_free(struct pair_htable *table ) 
{ 


  {
  {
#line 65
  pair_table_free(table);
  }
#line 66
  return;
}
}
#line 73 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
_Bool macro_meta_sequence_add(struct a2ps_job *job___0 , char const   *key , char const   *value ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 77
  tmp = strpbrk(key, ":(){}");
  }
#line 77
  if (tmp) {
#line 78
    return ((_Bool)0);
  }
  {
#line 81
  tmp___0 = strspn(value, "\t ");
#line 81
  pair_add(job___0->macro_meta_sequences, key, value + tmp___0);
  }
#line 83
  return ((_Bool)1);
}
}
#line 86 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
void macro_meta_sequence_delete(struct a2ps_job *job___0 , char const   *key ) 
{ 


  {
  {
#line 89
  pair_delete(job___0->macro_meta_sequences, key);
  }
#line 90
  return;
}
}
#line 92 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
char *macro_meta_sequence_get(struct a2ps_job *job___0 , char const   *key ) 
{ 
  char *tmp ;

  {
  {
#line 95
  tmp = pair_get(job___0->macro_meta_sequences, key);
  }
#line 95
  return (tmp);
}
}
#line 98 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
void macro_meta_sequences_list_short(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 104
  tmp = gettext("Known Variables");
#line 104
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp);
#line 105
  _IO_putc('\n', stream);
#line 106
  pair_table_list_short(job___0->macro_meta_sequences, stream);
  }
#line 107
  return;
}
}
#line 109 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
void macro_meta_sequences_list_long(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 113
  tmp = gettext("Known Variables");
#line 113
  title(stream, (char )'=', 1, (char const   *)tmp);
#line 114
  _IO_putc('\n', stream);
#line 115
  pair_table_list_long(job___0->macro_meta_sequences, stream);
  }
#line 116
  return;
}
}
#line 193 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
static void grow_user_string_obstack(struct obstack *user_string_stack___0 , struct a2ps_job *job___0 ,
                                     struct file_job *file , unsigned char const   *context_name ,
                                     unsigned char const   *str ) 
{ 
  unsigned char *cp ;
  unsigned char *cp2 ;
  size_t i ;
  size_t j ;
  unsigned char padding ;
  unsigned char buf___0[512] ;
  unsigned char buf2[512] ;
  unsigned char buf3[256] ;
  size_t width ;
  int justification ;
  int type ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  int a ;
  struct obstack *__o ;
  char *tmp___5 ;
  struct obstack *__o___0 ;
  char *tmp___6 ;
  struct obstack *__o___1 ;
  char *tmp___7 ;
  int a___0 ;
  struct obstack *__o___2 ;
  char *tmp___8 ;
  struct obstack *__o___3 ;
  char *tmp___9 ;
  struct obstack *__o___4 ;
  char *tmp___10 ;
  int a___1 ;
  struct obstack *__o___5 ;
  char *tmp___11 ;
  struct obstack *__o___6 ;
  char *tmp___12 ;
  struct obstack *__o___7 ;
  char *tmp___13 ;
  int a___2 ;
  struct obstack *__o___8 ;
  char *tmp___14 ;
  struct obstack *__o___9 ;
  char *tmp___15 ;
  struct obstack *__o___10 ;
  char *tmp___16 ;
  int a___3 ;
  struct obstack *__o___11 ;
  char *tmp___17 ;
  struct obstack *__o___12 ;
  char *tmp___18 ;
  struct obstack *__o___13 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t len ;
  size_t tmp___22 ;
  size_t nspace ;
  struct obstack *__o___14 ;
  char *tmp___23 ;
  struct obstack *__o___15 ;
  int __len ;
  struct obstack *__o___16 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  size_t len___0 ;
  size_t tmp___29 ;
  size_t nspace___0 ;
  struct obstack *__o___17 ;
  char *tmp___30 ;
  struct obstack *__o___18 ;
  int __len___0 ;
  struct obstack *__o___19 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  size_t len___1 ;
  size_t tmp___36 ;
  size_t nspace___1 ;
  struct obstack *__o___20 ;
  char *tmp___37 ;
  struct obstack *__o___21 ;
  int __len___1 ;
  struct obstack *__o___22 ;
  char *tmp___38 ;
  size_t len___2 ;
  size_t tmp___39 ;
  size_t nspace___2 ;
  struct obstack *__o___23 ;
  char *tmp___40 ;
  struct obstack *__o___24 ;
  int __len___2 ;
  struct obstack *__o___25 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  int *tmp___44 ;
  size_t len___3 ;
  size_t tmp___45 ;
  size_t nspace___3 ;
  struct obstack *__o___26 ;
  char *tmp___46 ;
  struct obstack *__o___27 ;
  int __len___3 ;
  struct obstack *__o___28 ;
  char *tmp___47 ;
  char *tmp___48 ;
  size_t len___4 ;
  size_t tmp___49 ;
  size_t nspace___4 ;
  struct obstack *__o___29 ;
  char *tmp___50 ;
  struct obstack *__o___30 ;
  int __len___4 ;
  struct obstack *__o___31 ;
  char *tmp___51 ;
  char *tmp___52 ;
  size_t len___5 ;
  size_t tmp___53 ;
  size_t nspace___5 ;
  struct obstack *__o___32 ;
  char *tmp___54 ;
  struct obstack *__o___33 ;
  int __len___5 ;
  struct obstack *__o___34 ;
  char *tmp___55 ;
  char *tmp___56 ;
  size_t len___6 ;
  size_t tmp___57 ;
  size_t nspace___6 ;
  struct obstack *__o___35 ;
  char *tmp___58 ;
  struct obstack *__o___36 ;
  int __len___6 ;
  struct obstack *__o___37 ;
  char *tmp___59 ;
  size_t len___7 ;
  size_t tmp___60 ;
  size_t nspace___7 ;
  struct obstack *__o___38 ;
  char *tmp___61 ;
  struct obstack *__o___39 ;
  int __len___7 ;
  struct obstack *__o___40 ;
  char *tmp___62 ;
  char *tmp___63 ;
  size_t tmp___64 ;
  void *tmp___65 ;
  char *tmp___66 ;
  size_t len___8 ;
  size_t tmp___67 ;
  size_t nspace___8 ;
  struct obstack *__o___41 ;
  char *tmp___68 ;
  struct obstack *__o___42 ;
  int __len___8 ;
  struct obstack *__o___43 ;
  char *tmp___69 ;
  size_t len___9 ;
  char *tmp___70 ;
  size_t tmp___71 ;
  size_t nspace___9 ;
  struct obstack *__o___44 ;
  char *tmp___72 ;
  struct obstack *__o___45 ;
  int __len___9 ;
  char *tmp___73 ;
  struct obstack *__o___46 ;
  char *tmp___74 ;
  size_t len___10 ;
  char *tmp___75 ;
  size_t tmp___76 ;
  size_t nspace___10 ;
  struct obstack *__o___47 ;
  char *tmp___77 ;
  struct obstack *__o___48 ;
  int __len___10 ;
  char *tmp___78 ;
  struct obstack *__o___49 ;
  char *tmp___79 ;
  size_t len___11 ;
  char *tmp___80 ;
  size_t tmp___81 ;
  size_t nspace___11 ;
  struct obstack *__o___50 ;
  char *tmp___82 ;
  struct obstack *__o___51 ;
  int __len___11 ;
  char *tmp___83 ;
  struct obstack *__o___52 ;
  char *tmp___84 ;
  size_t len___12 ;
  size_t tmp___85 ;
  size_t nspace___12 ;
  struct obstack *__o___53 ;
  char *tmp___86 ;
  struct obstack *__o___54 ;
  int __len___12 ;
  struct obstack *__o___55 ;
  char *tmp___87 ;
  int a___4 ;
  struct obstack *__o___56 ;
  char *tmp___88 ;
  struct obstack *__o___57 ;
  char *tmp___89 ;
  struct obstack *__o___58 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  size_t len___13 ;
  size_t tmp___93 ;
  size_t nspace___13 ;
  struct obstack *__o___59 ;
  char *tmp___94 ;
  struct obstack *__o___60 ;
  int __len___13 ;
  struct obstack *__o___61 ;
  char *tmp___95 ;
  char *tmp___96 ;
  size_t len___14 ;
  size_t tmp___97 ;
  size_t nspace___14 ;
  struct obstack *__o___62 ;
  char *tmp___98 ;
  struct obstack *__o___63 ;
  int __len___14 ;
  struct obstack *__o___64 ;
  char *tmp___99 ;
  size_t len___15 ;
  size_t tmp___100 ;
  size_t nspace___15 ;
  struct obstack *__o___65 ;
  char *tmp___101 ;
  struct obstack *__o___66 ;
  int __len___15 ;
  struct obstack *__o___67 ;
  char *tmp___102 ;
  int a___5 ;
  struct obstack *__o___68 ;
  char *tmp___103 ;
  struct obstack *__o___69 ;
  char *tmp___104 ;
  struct obstack *__o___70 ;
  char *tmp___105 ;
  char *tmp___106 ;
  char const   *tmp___107 ;
  int tmp___108 ;
  size_t len___16 ;
  size_t tmp___109 ;
  size_t nspace___16 ;
  struct obstack *__o___71 ;
  char *tmp___110 ;
  struct obstack *__o___72 ;
  int __len___16 ;
  struct obstack *__o___73 ;
  char *tmp___111 ;
  size_t len___17 ;
  size_t tmp___112 ;
  size_t nspace___17 ;
  struct obstack *__o___74 ;
  char *tmp___113 ;
  struct obstack *__o___75 ;
  int __len___17 ;
  struct obstack *__o___76 ;
  char *tmp___114 ;
  size_t len___18 ;
  size_t tmp___115 ;
  size_t nspace___18 ;
  struct obstack *__o___77 ;
  char *tmp___116 ;
  struct obstack *__o___78 ;
  int __len___18 ;
  struct obstack *__o___79 ;
  char *tmp___117 ;
  size_t len___19 ;
  size_t tmp___118 ;
  size_t nspace___19 ;
  struct obstack *__o___80 ;
  char *tmp___119 ;
  struct obstack *__o___81 ;
  int __len___19 ;
  struct obstack *__o___82 ;
  char *tmp___120 ;
  size_t len___20 ;
  size_t tmp___121 ;
  size_t nspace___20 ;
  struct obstack *__o___83 ;
  char *tmp___122 ;
  struct obstack *__o___84 ;
  int __len___20 ;
  struct obstack *__o___85 ;
  char *tmp___123 ;
  char *tmp___124 ;
  int a___6 ;
  struct obstack *__o___86 ;
  char *tmp___125 ;
  struct obstack *__o___87 ;
  char *tmp___126 ;
  struct obstack *__o___88 ;
  char *tmp___127 ;
  size_t len___21 ;
  size_t tmp___128 ;
  size_t nspace___21 ;
  struct obstack *__o___89 ;
  char *tmp___129 ;
  struct obstack *__o___90 ;
  int __len___21 ;
  struct obstack *__o___91 ;
  char *tmp___130 ;
  size_t tmp___131 ;
  char *tmp___132 ;
  char *tmp___133 ;
  char *tmp___134 ;
  size_t len___22 ;
  size_t tmp___135 ;
  size_t nspace___22 ;
  struct obstack *__o___92 ;
  char *tmp___136 ;
  struct obstack *__o___93 ;
  int __len___22 ;
  struct obstack *__o___94 ;
  char *tmp___137 ;
  char *tmp___138 ;
  size_t tmp___139 ;
  size_t tmp___140 ;
  char *tmp___141 ;
  char *tmp___142 ;
  size_t len___23 ;
  size_t tmp___143 ;
  size_t nspace___23 ;
  struct obstack *__o___95 ;
  char *tmp___144 ;
  struct obstack *__o___96 ;
  int __len___23 ;
  struct obstack *__o___97 ;
  char *tmp___145 ;
  size_t len___24 ;
  size_t tmp___146 ;
  size_t nspace___24 ;
  struct obstack *__o___98 ;
  char *tmp___147 ;
  struct obstack *__o___99 ;
  int __len___24 ;
  struct obstack *__o___100 ;
  char *tmp___148 ;
  size_t len___25 ;
  size_t tmp___149 ;
  size_t nspace___25 ;
  struct obstack *__o___101 ;
  char *tmp___150 ;
  struct obstack *__o___102 ;
  int __len___25 ;
  struct obstack *__o___103 ;
  char *tmp___151 ;
  size_t len___26 ;
  size_t tmp___152 ;
  size_t nspace___26 ;
  struct obstack *__o___104 ;
  char *tmp___153 ;
  struct obstack *__o___105 ;
  int __len___26 ;
  struct obstack *__o___106 ;
  char *tmp___154 ;
  char *tmp___155 ;
  char *tmp___156 ;
  unsigned short const   **tmp___157 ;
  size_t value ;
  size_t tmp___158 ;
  unsigned short const   **tmp___159 ;
  char *tmp___160 ;
  char *tmp___161 ;
  size_t len___27 ;
  size_t tmp___162 ;
  size_t nspace___27 ;
  struct obstack *__o___107 ;
  char *tmp___163 ;
  struct obstack *__o___108 ;
  int __len___27 ;
  struct obstack *__o___109 ;
  char *tmp___164 ;
  size_t len___28 ;
  size_t tmp___165 ;
  size_t nspace___28 ;
  struct obstack *__o___110 ;
  char *tmp___166 ;
  struct obstack *__o___111 ;
  int __len___28 ;
  struct obstack *__o___112 ;
  char *tmp___167 ;
  size_t len___29 ;
  size_t tmp___168 ;
  size_t nspace___29 ;
  struct obstack *__o___113 ;
  char *tmp___169 ;
  struct obstack *__o___114 ;
  int __len___29 ;
  struct obstack *__o___115 ;
  char *tmp___170 ;
  char *tmp___171 ;
  size_t len___30 ;
  size_t tmp___172 ;
  size_t nspace___30 ;
  struct obstack *__o___116 ;
  char *tmp___173 ;
  struct obstack *__o___117 ;
  int __len___30 ;
  struct obstack *__o___118 ;
  char *tmp___174 ;
  int a___7 ;
  struct obstack *__o___119 ;
  char *tmp___175 ;
  struct obstack *__o___120 ;
  char *tmp___176 ;
  struct obstack *__o___121 ;
  char *tmp___177 ;
  char *tmp___178 ;
  size_t len___31 ;
  size_t tmp___179 ;
  size_t nspace___31 ;
  struct obstack *__o___122 ;
  char *tmp___180 ;
  struct obstack *__o___123 ;
  int __len___31 ;
  struct obstack *__o___124 ;
  char *tmp___181 ;
  char *tmp___182 ;
  size_t len___32 ;
  size_t tmp___183 ;
  size_t nspace___32 ;
  struct obstack *__o___125 ;
  char *tmp___184 ;
  struct obstack *__o___126 ;
  int __len___32 ;
  struct obstack *__o___127 ;
  char *tmp___185 ;
  char *tmp___186 ;
  size_t len___33 ;
  size_t tmp___187 ;
  size_t nspace___33 ;
  struct obstack *__o___128 ;
  char *tmp___188 ;
  struct obstack *__o___129 ;
  int __len___33 ;
  struct obstack *__o___130 ;
  char *tmp___189 ;
  size_t len___34 ;
  size_t tmp___190 ;
  size_t nspace___34 ;
  struct obstack *__o___131 ;
  char *tmp___191 ;
  struct obstack *__o___132 ;
  int __len___34 ;
  struct obstack *__o___133 ;
  char *tmp___192 ;
  size_t len___35 ;
  size_t tmp___193 ;
  size_t nspace___35 ;
  struct obstack *__o___134 ;
  char *tmp___194 ;
  struct obstack *__o___135 ;
  int __len___35 ;
  struct obstack *__o___136 ;
  char *tmp___195 ;
  size_t len___36 ;
  size_t tmp___196 ;
  size_t nspace___36 ;
  struct obstack *__o___137 ;
  char *tmp___197 ;
  struct obstack *__o___138 ;
  int __len___36 ;
  struct obstack *__o___139 ;
  char *tmp___198 ;
  size_t len___37 ;
  size_t tmp___199 ;
  size_t nspace___37 ;
  struct obstack *__o___140 ;
  char *tmp___200 ;
  struct obstack *__o___141 ;
  int __len___37 ;
  struct obstack *__o___142 ;
  char *tmp___201 ;
  size_t len___38 ;
  size_t tmp___202 ;
  size_t nspace___38 ;
  struct obstack *__o___143 ;
  char *tmp___203 ;
  struct obstack *__o___144 ;
  int __len___38 ;
  struct obstack *__o___145 ;
  char *tmp___204 ;
  int a___8 ;
  struct obstack *__o___146 ;
  char *tmp___205 ;
  struct obstack *__o___147 ;
  char *tmp___206 ;
  struct obstack *__o___148 ;
  char *tmp___207 ;
  char *tmp___208 ;
  char *tmp___209 ;
  char *tmp___210 ;
  size_t len___39 ;
  size_t tmp___211 ;
  size_t nspace___39 ;
  struct obstack *__o___149 ;
  char *tmp___212 ;
  struct obstack *__o___150 ;
  int __len___39 ;
  struct obstack *__o___151 ;
  char *tmp___213 ;
  size_t len___40 ;
  size_t tmp___214 ;
  size_t nspace___40 ;
  struct obstack *__o___152 ;
  char *tmp___215 ;
  struct obstack *__o___153 ;
  int __len___40 ;
  struct obstack *__o___154 ;
  char *tmp___216 ;
  char *tmp___217 ;
  size_t len___41 ;
  size_t tmp___218 ;
  size_t nspace___41 ;
  struct obstack *__o___155 ;
  char *tmp___219 ;
  struct obstack *__o___156 ;
  int __len___41 ;
  struct obstack *__o___157 ;
  char *tmp___220 ;
  size_t len___42 ;
  size_t tmp___221 ;
  size_t nspace___42 ;
  struct obstack *__o___158 ;
  char *tmp___222 ;
  struct obstack *__o___159 ;
  int __len___42 ;
  struct obstack *__o___160 ;
  char *tmp___223 ;
  size_t len___43 ;
  size_t tmp___224 ;
  size_t nspace___43 ;
  struct obstack *__o___161 ;
  char *tmp___225 ;
  struct obstack *__o___162 ;
  int __len___43 ;
  struct obstack *__o___163 ;
  char *tmp___226 ;
  size_t len___44 ;
  size_t tmp___227 ;
  size_t nspace___44 ;
  struct obstack *__o___164 ;
  char *tmp___228 ;
  struct obstack *__o___165 ;
  int __len___44 ;
  struct obstack *__o___166 ;
  char *tmp___229 ;
  size_t len___45 ;
  size_t tmp___230 ;
  size_t nspace___45 ;
  struct obstack *__o___167 ;
  char *tmp___231 ;
  struct obstack *__o___168 ;
  int __len___45 ;
  struct obstack *__o___169 ;
  char *tmp___232 ;
  size_t len___46 ;
  size_t tmp___233 ;
  size_t nspace___46 ;
  struct obstack *__o___170 ;
  char *tmp___234 ;
  struct obstack *__o___171 ;
  int __len___46 ;
  struct obstack *__o___172 ;
  char *tmp___235 ;
  int a___9 ;
  struct obstack *__o___173 ;
  char *tmp___236 ;
  struct obstack *__o___174 ;
  char *tmp___237 ;
  struct obstack *__o___175 ;
  char *tmp___238 ;
  size_t len___47 ;
  size_t tmp___239 ;
  size_t nspace___47 ;
  struct obstack *__o___176 ;
  char *tmp___240 ;
  struct obstack *__o___177 ;
  int __len___47 ;
  struct obstack *__o___178 ;
  char *tmp___241 ;
  int a___10 ;
  struct obstack *__o___179 ;
  char *tmp___242 ;
  struct obstack *__o___180 ;
  char *tmp___243 ;
  struct obstack *__o___181 ;
  char *tmp___244 ;
  char *tmp___245 ;
  char *tmp___246 ;
  size_t len___48 ;
  size_t tmp___247 ;
  size_t nspace___48 ;
  struct obstack *__o___182 ;
  char *tmp___248 ;
  struct obstack *__o___183 ;
  int __len___48 ;
  struct obstack *__o___184 ;
  char *tmp___249 ;
  char *tmp___250 ;
  char *tmp___251 ;
  size_t len___49 ;
  size_t tmp___252 ;
  size_t nspace___49 ;
  struct obstack *__o___185 ;
  char *tmp___253 ;
  struct obstack *__o___186 ;
  int __len___49 ;
  struct obstack *__o___187 ;
  char *tmp___254 ;
  size_t len___50 ;
  size_t tmp___255 ;
  size_t nspace___50 ;
  struct obstack *__o___188 ;
  char *tmp___256 ;
  struct obstack *__o___189 ;
  int __len___50 ;
  struct obstack *__o___190 ;
  char *tmp___257 ;
  size_t len___51 ;
  size_t tmp___258 ;
  size_t nspace___51 ;
  struct obstack *__o___191 ;
  char *tmp___259 ;
  struct obstack *__o___192 ;
  int __len___51 ;
  struct obstack *__o___193 ;
  char *tmp___260 ;
  size_t len___52 ;
  size_t tmp___261 ;
  size_t nspace___52 ;
  struct obstack *__o___194 ;
  char *tmp___262 ;
  struct obstack *__o___195 ;
  int __len___52 ;
  struct obstack *__o___196 ;
  char *tmp___263 ;
  int a___11 ;
  struct obstack *__o___197 ;
  char *tmp___264 ;
  struct obstack *__o___198 ;
  char *tmp___265 ;
  struct obstack *__o___199 ;
  char *tmp___266 ;
  size_t len___53 ;
  size_t tmp___267 ;
  size_t nspace___53 ;
  struct obstack *__o___200 ;
  char *tmp___268 ;
  struct obstack *__o___201 ;
  int __len___53 ;
  struct obstack *__o___202 ;
  char *tmp___269 ;
  int a___12 ;
  struct obstack *__o___203 ;
  char *tmp___270 ;
  struct obstack *__o___204 ;
  char *tmp___271 ;
  struct obstack *__o___205 ;
  char *tmp___272 ;
  char *tmp___273 ;
  size_t len___54 ;
  size_t tmp___274 ;
  size_t nspace___54 ;
  struct obstack *__o___206 ;
  char *tmp___275 ;
  struct obstack *__o___207 ;
  int __len___54 ;
  struct obstack *__o___208 ;
  char *tmp___276 ;
  size_t len___55 ;
  size_t tmp___277 ;
  size_t nspace___55 ;
  struct obstack *__o___209 ;
  char *tmp___278 ;
  struct obstack *__o___210 ;
  int __len___55 ;
  struct obstack *__o___211 ;
  char *tmp___279 ;
  size_t len___56 ;
  size_t tmp___280 ;
  size_t nspace___56 ;
  struct obstack *__o___212 ;
  char *tmp___281 ;
  struct obstack *__o___213 ;
  int __len___56 ;
  struct obstack *__o___214 ;
  char *tmp___282 ;
  size_t len___57 ;
  size_t tmp___283 ;
  size_t nspace___57 ;
  struct obstack *__o___215 ;
  char *tmp___284 ;
  struct obstack *__o___216 ;
  int __len___57 ;
  struct obstack *__o___217 ;
  char *tmp___285 ;
  char const   *tmp___286 ;
  int tmp___287 ;
  size_t len___58 ;
  size_t tmp___288 ;
  size_t nspace___58 ;
  struct obstack *__o___218 ;
  char *tmp___289 ;
  struct obstack *__o___219 ;
  int __len___58 ;
  struct obstack *__o___220 ;
  char *tmp___290 ;
  size_t len___59 ;
  size_t tmp___291 ;
  size_t nspace___59 ;
  struct obstack *__o___221 ;
  char *tmp___292 ;
  struct obstack *__o___222 ;
  int __len___59 ;
  struct obstack *__o___223 ;
  char *tmp___293 ;
  size_t len___60 ;
  size_t tmp___294 ;
  size_t nspace___60 ;
  struct obstack *__o___224 ;
  char *tmp___295 ;
  struct obstack *__o___225 ;
  int __len___60 ;
  struct obstack *__o___226 ;
  char *tmp___296 ;
  char *tmp___297 ;
  int a___13 ;
  struct obstack *__o___227 ;
  char *tmp___298 ;
  struct obstack *__o___228 ;
  char *tmp___299 ;
  struct obstack *__o___229 ;
  char *tmp___300 ;
  size_t tmp___301 ;
  char *tmp___302 ;
  char *tmp___303 ;
  char *tmp___304 ;
  char *tmp___305 ;
  size_t tmp___306 ;
  size_t tmp___307 ;
  char *tmp___308 ;
  char *tmp___309 ;
  size_t len___61 ;
  size_t tmp___310 ;
  size_t nspace___61 ;
  struct obstack *__o___230 ;
  char *tmp___311 ;
  struct obstack *__o___231 ;
  int __len___61 ;
  struct obstack *__o___232 ;
  char *tmp___312 ;
  size_t len___62 ;
  size_t tmp___313 ;
  size_t nspace___62 ;
  struct obstack *__o___233 ;
  char *tmp___314 ;
  struct obstack *__o___234 ;
  int __len___62 ;
  struct obstack *__o___235 ;
  char *tmp___315 ;
  char *tmp___316 ;
  size_t len___63 ;
  size_t tmp___317 ;
  size_t nspace___63 ;
  struct obstack *__o___236 ;
  char *tmp___318 ;
  struct obstack *__o___237 ;
  int __len___63 ;
  struct obstack *__o___238 ;
  char *tmp___319 ;
  int test ;
  unsigned char cond ;
  unsigned char sep ;
  unsigned char *if_true ;
  unsigned char *if_false ;
  unsigned char *next ;
  char *tmp___320 ;
  char *tmp___321 ;
  char *tmp___322 ;
  unsigned char *tmp___323 ;
  char *tmp___324 ;
  char *tmp___325 ;
  unsigned char *tmp___326 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  char *tmp___332 ;
  unsigned char category ;
  unsigned char sep___0 ;
  unsigned char *in ;
  unsigned char *between ;
  unsigned char *next___0 ;
  char *tmp___333 ;
  char *tmp___334 ;
  char *tmp___335 ;
  unsigned char *tmp___336 ;
  char *tmp___337 ;
  char *tmp___338 ;
  unsigned char *tmp___339 ;
  size_t fnum ;
  size_t fmax___0 ;
  size_t tmp___340 ;
  size_t len___64 ;
  size_t tmp___341 ;
  size_t nspace___64 ;
  struct obstack *__o___239 ;
  char *tmp___342 ;
  struct obstack *__o___240 ;
  int __len___64 ;
  struct obstack *__o___241 ;
  char *tmp___343 ;
  size_t fnum___0 ;
  size_t fmax___1 ;
  size_t tmp___344 ;
  size_t fnum___1 ;
  size_t fmax___2 ;
  struct darray *ordered ;
  size_t tmp___345 ;
  size_t fnum___2 ;
  size_t fmax___3 ;
  struct darray *selected ;
  size_t tmp___346 ;
  char *tmp___347 ;
  int k ;
  char *tmp___348 ;
  char *tmp___349 ;
  size_t len___65 ;
  size_t tmp___350 ;
  size_t nspace___65 ;
  struct obstack *__o___242 ;
  char *tmp___351 ;
  struct obstack *__o___243 ;
  int __len___65 ;
  struct obstack *__o___244 ;
  char *tmp___352 ;
  size_t len___66 ;
  size_t tmp___353 ;
  size_t nspace___66 ;
  struct obstack *__o___245 ;
  char *tmp___354 ;
  struct obstack *__o___246 ;
  int __len___66 ;
  struct obstack *__o___247 ;
  char *tmp___355 ;
  size_t len___67 ;
  char const   *tmp___356 ;
  size_t tmp___357 ;
  size_t nspace___67 ;
  struct obstack *__o___248 ;
  char *tmp___358 ;
  struct obstack *__o___249 ;
  int __len___67 ;
  char const   *tmp___359 ;
  struct obstack *__o___250 ;
  char *tmp___360 ;
  char const   *tmp___361 ;
  char *tmp___362 ;
  size_t len___68 ;
  char const   *tmp___363 ;
  size_t tmp___364 ;
  size_t nspace___68 ;
  struct obstack *__o___251 ;
  char *tmp___365 ;
  struct obstack *__o___252 ;
  int __len___68 ;
  char const   *tmp___366 ;
  struct obstack *__o___253 ;
  char *tmp___367 ;
  _Bool tmp___368 ;
  size_t len___69 ;
  size_t tmp___369 ;
  size_t nspace___69 ;
  struct obstack *__o___254 ;
  char *tmp___370 ;
  struct obstack *__o___255 ;
  int __len___69 ;
  struct obstack *__o___256 ;
  char *tmp___371 ;
  size_t len___70 ;
  size_t tmp___372 ;
  size_t nspace___70 ;
  struct obstack *__o___257 ;
  char *tmp___373 ;
  struct obstack *__o___258 ;
  int __len___70 ;
  struct obstack *__o___259 ;
  char *tmp___374 ;
  size_t len___71 ;
  size_t tmp___375 ;
  size_t nspace___71 ;
  struct obstack *__o___260 ;
  char *tmp___376 ;
  struct obstack *__o___261 ;
  int __len___71 ;
  struct obstack *__o___262 ;
  char *tmp___377 ;
  char *tmp___378 ;
  int a___14 ;
  struct obstack *__o___263 ;
  char *tmp___379 ;
  struct obstack *__o___264 ;
  char *tmp___380 ;
  struct obstack *__o___265 ;
  char *tmp___381 ;
  void *__cil_tmp925 ;
  void *__cil_tmp926 ;
  void *__cil_tmp927 ;
  char *__cil_tmp928 ;
  char *__cil_tmp929 ;
  char *__cil_tmp930 ;
  char *__cil_tmp931 ;
  char *__cil_tmp932 ;
  char *__cil_tmp933 ;
  char *__cil_tmp934 ;
  char *__cil_tmp935 ;
  char *__cil_tmp936 ;
  char *__cil_tmp937 ;
  char *__cil_tmp938 ;
  char *__cil_tmp939 ;
  char *__cil_tmp940 ;
  char *__cil_tmp941 ;
  char *__cil_tmp942 ;
  char *__cil_tmp943 ;
  char *__cil_tmp944 ;
  char *__cil_tmp945 ;
  char *__cil_tmp946 ;
  char *__cil_tmp947 ;
  char *__cil_tmp948 ;
  char *__cil_tmp949 ;
  char *__cil_tmp950 ;
  char *__cil_tmp951 ;
  char *__cil_tmp952 ;
  char *__cil_tmp953 ;
  char *__cil_tmp954 ;
  char *__cil_tmp955 ;
  char *__cil_tmp956 ;
  char *__cil_tmp957 ;
  char *__cil_tmp958 ;
  char *__cil_tmp959 ;
  char *__cil_tmp960 ;
  char *__cil_tmp961 ;
  char *__cil_tmp962 ;
  char *__cil_tmp963 ;
  char *__cil_tmp964 ;
  char *__cil_tmp965 ;
  char *__cil_tmp966 ;
  char *__cil_tmp967 ;
  char *__cil_tmp968 ;
  char *__cil_tmp969 ;
  char *__cil_tmp970 ;
  char *__cil_tmp971 ;
  char *__cil_tmp972 ;
  char *__cil_tmp973 ;
  char *__cil_tmp974 ;
  char *__cil_tmp975 ;
  char *__cil_tmp976 ;
  char *__cil_tmp977 ;
  char *__cil_tmp978 ;
  char *__cil_tmp979 ;
  char *__cil_tmp980 ;
  char *__cil_tmp981 ;
  char *__cil_tmp982 ;
  char *__cil_tmp983 ;
  char *__cil_tmp984 ;
  char *__cil_tmp985 ;
  char *__cil_tmp986 ;
  char *__cil_tmp987 ;
  char *__cil_tmp988 ;
  char *__cil_tmp989 ;
  char *__cil_tmp990 ;
  char *__cil_tmp991 ;
  char *__cil_tmp992 ;
  char *__cil_tmp993 ;
  char *__cil_tmp994 ;
  char *__cil_tmp995 ;
  char *__cil_tmp996 ;
  char *__cil_tmp997 ;
  char *__cil_tmp998 ;
  char *__cil_tmp999 ;
  char *__cil_tmp1000 ;
  char *__cil_tmp1001 ;
  char *__cil_tmp1002 ;
  char *__cil_tmp1003 ;
  char *__cil_tmp1004 ;
  char *__cil_tmp1005 ;
  char *__cil_tmp1006 ;
  char *__cil_tmp1007 ;
  char *__cil_tmp1008 ;
  char *__cil_tmp1009 ;
  char *__cil_tmp1010 ;
  char *__cil_tmp1011 ;
  char *__cil_tmp1012 ;
  char *__cil_tmp1013 ;
  char *__cil_tmp1014 ;
  char *__cil_tmp1015 ;
  char *__cil_tmp1016 ;
  char *__cil_tmp1017 ;
  char *__cil_tmp1018 ;
  char *__cil_tmp1019 ;
  char *__cil_tmp1020 ;
  char *__cil_tmp1021 ;
  char *__cil_tmp1022 ;
  char *__cil_tmp1023 ;
  char *__cil_tmp1024 ;
  char *__cil_tmp1025 ;
  char *__cil_tmp1026 ;
  char *__cil_tmp1027 ;
  char *__cil_tmp1028 ;
  char *__cil_tmp1029 ;
  char *__cil_tmp1030 ;
  char *__cil_tmp1031 ;
  char *__cil_tmp1032 ;
  char *__cil_tmp1033 ;
  char *__cil_tmp1034 ;
  char *__cil_tmp1035 ;
  char *__cil_tmp1036 ;
  char *__cil_tmp1037 ;
  char *__cil_tmp1038 ;
  char *__cil_tmp1039 ;
  char *__cil_tmp1040 ;
  char *__cil_tmp1041 ;
  char *__cil_tmp1042 ;
  char *__cil_tmp1043 ;
  char *__cil_tmp1044 ;
  char *__cil_tmp1045 ;
  char *__cil_tmp1046 ;
  char *__cil_tmp1047 ;
  char *__cil_tmp1048 ;
  char *__cil_tmp1049 ;
  char *__cil_tmp1050 ;
  char *__cil_tmp1051 ;
  char *__cil_tmp1052 ;
  char *__cil_tmp1053 ;
  char *__cil_tmp1054 ;
  char *__cil_tmp1055 ;
  char *__cil_tmp1056 ;
  char *__cil_tmp1057 ;
  char *__cil_tmp1058 ;
  char *__cil_tmp1059 ;
  char *__cil_tmp1060 ;

  {
#line 201
  i = (size_t )0;
#line 202
  padding = (unsigned char )' ';
#line 204
  width = (size_t )0;
#line 205
  justification = 1;
#line 208
  i = (size_t )0;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! ((int const   )*(str + i) != 0)) {
#line 208
      goto while_break;
    }
#line 212
    type = (int )*(str + i);
#line 213
    if (type == 37) {
#line 213
      goto _L___27;
    } else
#line 213
    if (type == 36) {
#line 213
      goto _L___27;
    } else
#line 213
    if (type == 35) {
#line 213
      goto _L___27;
    } else
#line 213
    if (type == 92) {
      _L___27: /* CIL Label */ 
#line 214
      i ++;
#line 215
      width = (size_t )0;
#line 216
      justification = 1;
#line 217
      padding = (unsigned char )' ';
#line 220
      if ((int const   )*(str + i) == 45) {
        {
#line 221
        i ++;
#line 222
        justification = -1;
#line 223
        tmp___0 = __ctype_b_loc();
        }
#line 223
        if (! ((int const   )*(*tmp___0 + (int )*(str + i)) & 2048)) {
#line 224
          tmp = i;
#line 224
          i ++;
#line 224
          padding = (unsigned char )*(str + tmp);
        }
      }
#line 226
      if ((int const   )*(str + i) == 43) {
        {
#line 227
        i ++;
#line 228
        justification = 1;
#line 229
        tmp___2 = __ctype_b_loc();
        }
#line 229
        if (! ((int const   )*(*tmp___2 + (int )*(str + i)) & 2048)) {
#line 230
          tmp___1 = i;
#line 230
          i ++;
#line 230
          padding = (unsigned char )*(str + tmp___1);
        }
      }
      {
#line 232
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 232
        tmp___4 = __ctype_b_loc();
        }
#line 232
        if (! ((int const   )*(*tmp___4 + (int )*(str + i)) & 2048)) {
#line 232
          goto while_break___0;
        }
#line 233
        tmp___3 = i;
#line 233
        i ++;
#line 233
        width = (width * 10U + (size_t )*(str + tmp___3)) - 48U;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 248
      if (type == 92) {
#line 248
        goto case_92;
      }
#line 275
      if (type == 37) {
#line 275
        goto case_37;
      }
#line 509
      if (type == 36) {
#line 509
        goto case_36;
      }
#line 937
      if (type == 35) {
#line 937
        goto case_35___6;
      }
#line 236
      goto switch_break;
      case_92: /* CIL Label */ 
      {
#line 250
      if ((int const   )*(str + i) == 102) {
#line 250
        goto case_102;
      }
#line 254
      if ((int const   )*(str + i) == 110) {
#line 254
        goto case_110;
      }
#line 258
      goto switch_default;
      case_102: /* CIL Label */ 
      {
#line 251
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 251
        if (width) {
#line 251
          if (justification < 0) {
#line 251
            __o = user_string_stack___0;
#line 251
            if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
              {
#line 251
              _obstack_newchunk(__o, 1);
              }
            }
#line 251
            tmp___5 = __o->next_free;
#line 251
            (__o->next_free) ++;
#line 251
            *tmp___5 = (char )'\f';
          }
        }
#line 251
        a = 0;
        {
#line 251
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 251
          if (! (a < (int )width - 1)) {
#line 251
            goto while_break___2;
          }
#line 251
          __o___0 = user_string_stack___0;
#line 251
          if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
            {
#line 251
            _obstack_newchunk(__o___0, 1);
            }
          }
#line 251
          tmp___6 = __o___0->next_free;
#line 251
          (__o___0->next_free) ++;
#line 251
          *tmp___6 = (char )padding;
#line 251
          a ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 251
        if (! width) {
#line 251
          goto _L;
        } else
#line 251
        if (justification > 0) {
          _L: /* CIL Label */ 
#line 251
          __o___1 = user_string_stack___0;
#line 251
          if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
            {
#line 251
            _obstack_newchunk(__o___1, 1);
            }
          }
#line 251
          tmp___7 = __o___1->next_free;
#line 251
          (__o___1->next_free) ++;
#line 251
          *tmp___7 = (char )'\f';
        }
#line 251
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 252
      goto switch_break___0;
      case_110: /* CIL Label */ 
      {
#line 255
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 255
        if (width) {
#line 255
          if (justification < 0) {
#line 255
            __o___2 = user_string_stack___0;
#line 255
            if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
              {
#line 255
              _obstack_newchunk(__o___2, 1);
              }
            }
#line 255
            tmp___8 = __o___2->next_free;
#line 255
            (__o___2->next_free) ++;
#line 255
            *tmp___8 = (char )'\n';
          }
        }
#line 255
        a___0 = 0;
        {
#line 255
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 255
          if (! (a___0 < (int )width - 1)) {
#line 255
            goto while_break___4;
          }
#line 255
          __o___3 = user_string_stack___0;
#line 255
          if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
            {
#line 255
            _obstack_newchunk(__o___3, 1);
            }
          }
#line 255
          tmp___9 = __o___3->next_free;
#line 255
          (__o___3->next_free) ++;
#line 255
          *tmp___9 = (char )padding;
#line 255
          a___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 255
        if (! width) {
#line 255
          goto _L___0;
        } else
#line 255
        if (justification > 0) {
          _L___0: /* CIL Label */ 
#line 255
          __o___4 = user_string_stack___0;
#line 255
          if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
            {
#line 255
            _obstack_newchunk(__o___4, 1);
            }
          }
#line 255
          tmp___10 = __o___4->next_free;
#line 255
          (__o___4->next_free) ++;
#line 255
          *tmp___10 = (char )'\n';
        }
#line 255
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 256
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 259
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 259
        if (width) {
#line 259
          if (justification < 0) {
#line 259
            __o___5 = user_string_stack___0;
#line 259
            if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
              {
#line 259
              _obstack_newchunk(__o___5, 1);
              }
            }
#line 259
            tmp___11 = __o___5->next_free;
#line 259
            (__o___5->next_free) ++;
#line 259
            *tmp___11 = (char )*(str + i);
          }
        }
#line 259
        a___1 = 0;
        {
#line 259
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 259
          if (! (a___1 < (int )width - 1)) {
#line 259
            goto while_break___6;
          }
#line 259
          __o___6 = user_string_stack___0;
#line 259
          if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
            {
#line 259
            _obstack_newchunk(__o___6, 1);
            }
          }
#line 259
          tmp___12 = __o___6->next_free;
#line 259
          (__o___6->next_free) ++;
#line 259
          *tmp___12 = (char )padding;
#line 259
          a___1 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 259
        if (! width) {
#line 259
          goto _L___1;
        } else
#line 259
        if (justification > 0) {
          _L___1: /* CIL Label */ 
#line 259
          __o___7 = user_string_stack___0;
#line 259
          if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
            {
#line 259
            _obstack_newchunk(__o___7, 1);
            }
          }
#line 259
          tmp___13 = __o___7->next_free;
#line 259
          (__o___7->next_free) ++;
#line 259
          *tmp___13 = (char )*(str + i);
        }
#line 259
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 260
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 262
      goto switch_break;
      case_37: /* CIL Label */ 
      {
#line 278
      if ((int const   )*(str + i) == 37) {
#line 278
        goto case_37___0;
      }
#line 282
      if ((int const   )*(str + i) == 35) {
#line 282
        goto case_35;
      }
#line 286
      if ((int const   )*(str + i) == 97) {
#line 286
        goto case_97;
      }
#line 293
      if ((int const   )*(str + i) == 65) {
#line 293
        goto case_65;
      }
#line 304
      if ((int const   )*(str + i) == 99) {
#line 304
        goto case_99;
      }
#line 317
      if ((int const   )*(str + i) == 67) {
#line 317
        goto case_67;
      }
#line 323
      if ((int const   )*(str + i) == 100) {
#line 323
        goto case_100;
      }
#line 332
      if ((int const   )*(str + i) == 68) {
#line 332
        goto case_68;
      }
#line 359
      if ((int const   )*(str + i) == 101) {
#line 359
        goto case_101;
      }
#line 368
      if ((int const   )*(str + i) == 69) {
#line 368
        goto case_69;
      }
#line 377
      if ((int const   )*(str + i) == 70) {
#line 377
        goto case_70;
      }
#line 385
      if ((int const   )*(str + i) == 109) {
#line 385
        goto case_109;
      }
#line 395
      if ((int const   )*(str + i) == 77) {
#line 395
        goto case_77;
      }
#line 399
      if ((int const   )*(str + i) == 110) {
#line 399
        goto case_110___0;
      }
#line 403
      if ((int const   )*(str + i) == 78) {
#line 403
        goto case_78;
      }
#line 407
      if ((int const   )*(str + i) == 112) {
#line 407
        goto case_112;
      }
#line 425
      if ((int const   )*(str + i) == 113) {
#line 425
        goto case_113;
      }
#line 430
      if ((int const   )*(str + i) == 81) {
#line 430
        goto case_81;
      }
#line 436
      if ((int const   )*(str + i) == 115) {
#line 436
        goto case_115;
      }
#line 454
      if ((int const   )*(str + i) == 116) {
#line 454
        goto case_116;
      }
#line 463
      if ((int const   )*(str + i) == 84) {
#line 463
        goto case_84;
      }
#line 469
      if ((int const   )*(str + i) == 42) {
#line 469
        goto case_42;
      }
#line 477
      if ((int const   )*(str + i) == 86) {
#line 477
        goto case_86;
      }
#line 482
      if ((int const   )*(str + i) == 87) {
#line 482
        goto case_87;
      }
#line 490
      goto switch_default___2;
      case_37___0: /* CIL Label */ 
      {
#line 279
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 279
        if (width) {
#line 279
          if (justification < 0) {
#line 279
            __o___8 = user_string_stack___0;
#line 279
            if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
              {
#line 279
              _obstack_newchunk(__o___8, 1);
              }
            }
#line 279
            tmp___14 = __o___8->next_free;
#line 279
            (__o___8->next_free) ++;
#line 279
            *tmp___14 = (char )'%';
          }
        }
#line 279
        a___2 = 0;
        {
#line 279
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 279
          if (! (a___2 < (int )width - 1)) {
#line 279
            goto while_break___8;
          }
#line 279
          __o___9 = user_string_stack___0;
#line 279
          if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
            {
#line 279
            _obstack_newchunk(__o___9, 1);
            }
          }
#line 279
          tmp___15 = __o___9->next_free;
#line 279
          (__o___9->next_free) ++;
#line 279
          *tmp___15 = (char )padding;
#line 279
          a___2 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 279
        if (! width) {
#line 279
          goto _L___2;
        } else
#line 279
        if (justification > 0) {
          _L___2: /* CIL Label */ 
#line 279
          __o___10 = user_string_stack___0;
#line 279
          if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
            {
#line 279
            _obstack_newchunk(__o___10, 1);
            }
          }
#line 279
          tmp___16 = __o___10->next_free;
#line 279
          (__o___10->next_free) ++;
#line 279
          *tmp___16 = (char )'%';
        }
#line 279
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 280
      goto switch_break___1;
      case_35: /* CIL Label */ 
      {
#line 283
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 283
        if (width) {
#line 283
          if (justification < 0) {
#line 283
            __o___11 = user_string_stack___0;
#line 283
            if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
              {
#line 283
              _obstack_newchunk(__o___11, 1);
              }
            }
#line 283
            tmp___17 = __o___11->next_free;
#line 283
            (__o___11->next_free) ++;
#line 283
            *tmp___17 = (char)3;
          }
        }
#line 283
        a___3 = 0;
        {
#line 283
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 283
          if (! (a___3 < (int )width - 1)) {
#line 283
            goto while_break___10;
          }
#line 283
          __o___12 = user_string_stack___0;
#line 283
          if ((unsigned long )(__o___12->next_free + 1) > (unsigned long )__o___12->chunk_limit) {
            {
#line 283
            _obstack_newchunk(__o___12, 1);
            }
          }
#line 283
          tmp___18 = __o___12->next_free;
#line 283
          (__o___12->next_free) ++;
#line 283
          *tmp___18 = (char )padding;
#line 283
          a___3 ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 283
        if (! width) {
#line 283
          goto _L___3;
        } else
#line 283
        if (justification > 0) {
          _L___3: /* CIL Label */ 
#line 283
          __o___13 = user_string_stack___0;
#line 283
          if ((unsigned long )(__o___13->next_free + 1) > (unsigned long )__o___13->chunk_limit) {
            {
#line 283
            _obstack_newchunk(__o___13, 1);
            }
          }
#line 283
          tmp___19 = __o___13->next_free;
#line 283
          (__o___13->next_free) ++;
#line 283
          *tmp___19 = (char)3;
        }
#line 283
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 284
      goto switch_break___1;
      case_97: /* CIL Label */ 
      {
#line 287
      tmp___20 = macro_meta_sequence_get(job___0, "user.name");
#line 287
      tmp___21 = gettext("Printed by %s");
#line 287
      sprintf((char */* __restrict  */)((char *)(buf2)), (char const   */* __restrict  */)tmp___21,
              tmp___20);
      }
      {
#line 290
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 290
        tmp___22 = strlen((char const   *)(buf2));
#line 290
        len = tmp___22;
        }
#line 290
        if (len > width) {
#line 290
          nspace = (size_t )0;
        } else {
#line 290
          nspace = width - len;
        }
#line 290
        if (width) {
#line 290
          if (justification > 0) {
            {
#line 290
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 290
              if (! nspace) {
#line 290
                goto while_break___12;
              }
#line 290
              __o___14 = user_string_stack___0;
#line 290
              if ((unsigned long )(__o___14->next_free + 1) > (unsigned long )__o___14->chunk_limit) {
                {
#line 290
                _obstack_newchunk(__o___14, 1);
                }
              }
#line 290
              tmp___23 = __o___14->next_free;
#line 290
              (__o___14->next_free) ++;
#line 290
              *tmp___23 = (char )padding;
#line 290
              nspace --;
            }
            while_break___12: /* CIL Label */ ;
            }
          }
        }
#line 290
        __o___15 = user_string_stack___0;
#line 290
        __len = (int )len;
#line 290
        if ((unsigned long )(__o___15->next_free + __len) > (unsigned long )__o___15->chunk_limit) {
          {
#line 290
          _obstack_newchunk(__o___15, __len);
          }
        }
        {
#line 290
        memcpy((void */* __restrict  */)__o___15->next_free, (void const   */* __restrict  */)((char *)(buf2)),
               (size_t )__len);
#line 290
        __o___15->next_free += __len;
        }
#line 290
        if (width) {
#line 290
          if (justification < 0) {
            {
#line 290
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 290
              if (! nspace) {
#line 290
                goto while_break___13;
              }
#line 290
              __o___16 = user_string_stack___0;
#line 290
              if ((unsigned long )(__o___16->next_free + 1) > (unsigned long )__o___16->chunk_limit) {
                {
#line 290
                _obstack_newchunk(__o___16, 1);
                }
              }
#line 290
              tmp___24 = __o___16->next_free;
#line 290
              (__o___16->next_free) ++;
#line 290
              *tmp___24 = (char )padding;
#line 290
              nspace --;
            }
            while_break___13: /* CIL Label */ ;
            }
          }
        }
#line 290
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 291
      goto switch_break___1;
      case_65: /* CIL Label */ 
      {
#line 294
      tmp___25 = macro_meta_sequence_get(job___0, "user.name");
#line 294
      cp = (unsigned char *)tmp___25;
#line 295
      tmp___26 = macro_meta_sequence_get(job___0, "user.host");
#line 295
      cp2 = (unsigned char *)tmp___26;
      }
#line 296
      if (cp2) {
        {
#line 297
        tmp___27 = gettext("Printed by %s from %s");
#line 297
        sprintf((char */* __restrict  */)((char *)(buf3)), (char const   */* __restrict  */)tmp___27,
                cp, cp2);
        }
      } else {
        {
#line 300
        tmp___28 = gettext("Printed by %s");
#line 300
        sprintf((char */* __restrict  */)((char *)(buf3)), (char const   */* __restrict  */)tmp___28,
                cp);
        }
      }
      {
#line 301
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 301
        tmp___29 = strlen((char const   *)(buf3));
#line 301
        len___0 = tmp___29;
        }
#line 301
        if (len___0 > width) {
#line 301
          nspace___0 = (size_t )0;
        } else {
#line 301
          nspace___0 = width - len___0;
        }
#line 301
        if (width) {
#line 301
          if (justification > 0) {
            {
#line 301
            while (1) {
              while_continue___15: /* CIL Label */ ;
#line 301
              if (! nspace___0) {
#line 301
                goto while_break___15;
              }
#line 301
              __o___17 = user_string_stack___0;
#line 301
              if ((unsigned long )(__o___17->next_free + 1) > (unsigned long )__o___17->chunk_limit) {
                {
#line 301
                _obstack_newchunk(__o___17, 1);
                }
              }
#line 301
              tmp___30 = __o___17->next_free;
#line 301
              (__o___17->next_free) ++;
#line 301
              *tmp___30 = (char )padding;
#line 301
              nspace___0 --;
            }
            while_break___15: /* CIL Label */ ;
            }
          }
        }
#line 301
        __o___18 = user_string_stack___0;
#line 301
        __len___0 = (int )len___0;
#line 301
        if ((unsigned long )(__o___18->next_free + __len___0) > (unsigned long )__o___18->chunk_limit) {
          {
#line 301
          _obstack_newchunk(__o___18, __len___0);
          }
        }
        {
#line 301
        memcpy((void */* __restrict  */)__o___18->next_free, (void const   */* __restrict  */)((char *)(buf3)),
               (size_t )__len___0);
#line 301
        __o___18->next_free += __len___0;
        }
#line 301
        if (width) {
#line 301
          if (justification < 0) {
            {
#line 301
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 301
              if (! nspace___0) {
#line 301
                goto while_break___16;
              }
#line 301
              __o___19 = user_string_stack___0;
#line 301
              if ((unsigned long )(__o___19->next_free + 1) > (unsigned long )__o___19->chunk_limit) {
                {
#line 301
                _obstack_newchunk(__o___19, 1);
                }
              }
#line 301
              tmp___31 = __o___19->next_free;
#line 301
              (__o___19->next_free) ++;
#line 301
              *tmp___31 = (char )padding;
#line 301
              nspace___0 --;
            }
            while_break___16: /* CIL Label */ ;
            }
          }
        }
#line 301
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 302
      goto switch_break___1;
      case_99: /* CIL Label */ 
      {
#line 305
      tmp___32 = xgetcwd();
#line 305
      cp = (unsigned char *)tmp___32;
      }
#line 306
      if (! cp) {
        {
#line 307
        tmp___33 = gettext("cannot get current working directory");
#line 307
        tmp___34 = __errno_location();
#line 307
        error(1, *tmp___34, (char const   *)tmp___33);
        }
      }
      {
#line 309
      tmp___35 = strrchr((char const   *)((char *)cp), '/');
#line 309
      cp2 = (unsigned char *)tmp___35;
      }
#line 310
      if (cp2) {
#line 311
        cp2 ++;
      } else {
#line 313
        cp2 = cp;
      }
      {
#line 314
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 314
        tmp___36 = strlen((char const   *)cp2);
#line 314
        len___1 = tmp___36;
        }
#line 314
        if (len___1 > width) {
#line 314
          nspace___1 = (size_t )0;
        } else {
#line 314
          nspace___1 = width - len___1;
        }
#line 314
        if (width) {
#line 314
          if (justification > 0) {
            {
#line 314
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 314
              if (! nspace___1) {
#line 314
                goto while_break___18;
              }
#line 314
              __o___20 = user_string_stack___0;
#line 314
              if ((unsigned long )(__o___20->next_free + 1) > (unsigned long )__o___20->chunk_limit) {
                {
#line 314
                _obstack_newchunk(__o___20, 1);
                }
              }
#line 314
              tmp___37 = __o___20->next_free;
#line 314
              (__o___20->next_free) ++;
#line 314
              *tmp___37 = (char )padding;
#line 314
              nspace___1 --;
            }
            while_break___18: /* CIL Label */ ;
            }
          }
        }
#line 314
        __o___21 = user_string_stack___0;
#line 314
        __len___1 = (int )len___1;
#line 314
        if ((unsigned long )(__o___21->next_free + __len___1) > (unsigned long )__o___21->chunk_limit) {
          {
#line 314
          _obstack_newchunk(__o___21, __len___1);
          }
        }
        {
#line 314
        memcpy((void */* __restrict  */)__o___21->next_free, (void const   */* __restrict  */)((char *)cp2),
               (size_t )__len___1);
#line 314
        __o___21->next_free += __len___1;
        }
#line 314
        if (width) {
#line 314
          if (justification < 0) {
            {
#line 314
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 314
              if (! nspace___1) {
#line 314
                goto while_break___19;
              }
#line 314
              __o___22 = user_string_stack___0;
#line 314
              if ((unsigned long )(__o___22->next_free + 1) > (unsigned long )__o___22->chunk_limit) {
                {
#line 314
                _obstack_newchunk(__o___22, 1);
                }
              }
#line 314
              tmp___38 = __o___22->next_free;
#line 314
              (__o___22->next_free) ++;
#line 314
              *tmp___38 = (char )padding;
#line 314
              nspace___1 --;
            }
            while_break___19: /* CIL Label */ ;
            }
          }
        }
#line 314
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 315
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 315
        if (cp) {
          {
#line 315
          free((void *)cp);
          }
        }
#line 315
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 316
      goto switch_break___1;
      case_67: /* CIL Label */ 
      {
#line 318
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d:%02d:%02d",
              job___0->run_tm.tm_hour, job___0->run_tm.tm_min, job___0->run_tm.tm_sec);
      }
      {
#line 320
      while (1) {
        while_continue___21: /* CIL Label */ ;
        {
#line 320
        tmp___39 = strlen((char const   *)(buf___0));
#line 320
        len___2 = tmp___39;
        }
#line 320
        if (len___2 > width) {
#line 320
          nspace___2 = (size_t )0;
        } else {
#line 320
          nspace___2 = width - len___2;
        }
#line 320
        if (width) {
#line 320
          if (justification > 0) {
            {
#line 320
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 320
              if (! nspace___2) {
#line 320
                goto while_break___22;
              }
#line 320
              __o___23 = user_string_stack___0;
#line 320
              if ((unsigned long )(__o___23->next_free + 1) > (unsigned long )__o___23->chunk_limit) {
                {
#line 320
                _obstack_newchunk(__o___23, 1);
                }
              }
#line 320
              tmp___40 = __o___23->next_free;
#line 320
              (__o___23->next_free) ++;
#line 320
              *tmp___40 = (char )padding;
#line 320
              nspace___2 --;
            }
            while_break___22: /* CIL Label */ ;
            }
          }
        }
#line 320
        __o___24 = user_string_stack___0;
#line 320
        __len___2 = (int )len___2;
#line 320
        if ((unsigned long )(__o___24->next_free + __len___2) > (unsigned long )__o___24->chunk_limit) {
          {
#line 320
          _obstack_newchunk(__o___24, __len___2);
          }
        }
        {
#line 320
        memcpy((void */* __restrict  */)__o___24->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___2);
#line 320
        __o___24->next_free += __len___2;
        }
#line 320
        if (width) {
#line 320
          if (justification < 0) {
            {
#line 320
            while (1) {
              while_continue___23: /* CIL Label */ ;
#line 320
              if (! nspace___2) {
#line 320
                goto while_break___23;
              }
#line 320
              __o___25 = user_string_stack___0;
#line 320
              if ((unsigned long )(__o___25->next_free + 1) > (unsigned long )__o___25->chunk_limit) {
                {
#line 320
                _obstack_newchunk(__o___25, 1);
                }
              }
#line 320
              tmp___41 = __o___25->next_free;
#line 320
              (__o___25->next_free) ++;
#line 320
              *tmp___41 = (char )padding;
#line 320
              nspace___2 --;
            }
            while_break___23: /* CIL Label */ ;
            }
          }
        }
#line 320
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 321
      goto switch_break___1;
      case_100: /* CIL Label */ 
      {
#line 324
      tmp___42 = xgetcwd();
#line 324
      cp = (unsigned char *)tmp___42;
      }
#line 325
      if (! cp) {
        {
#line 326
        tmp___43 = gettext("cannot get current working directory");
#line 326
        tmp___44 = __errno_location();
#line 326
        error(1, *tmp___44, (char const   *)tmp___43);
        }
      }
      {
#line 328
      while (1) {
        while_continue___24: /* CIL Label */ ;
        {
#line 328
        tmp___45 = strlen((char const   *)cp);
#line 328
        len___3 = tmp___45;
        }
#line 328
        if (len___3 > width) {
#line 328
          nspace___3 = (size_t )0;
        } else {
#line 328
          nspace___3 = width - len___3;
        }
#line 328
        if (width) {
#line 328
          if (justification > 0) {
            {
#line 328
            while (1) {
              while_continue___25: /* CIL Label */ ;
#line 328
              if (! nspace___3) {
#line 328
                goto while_break___25;
              }
#line 328
              __o___26 = user_string_stack___0;
#line 328
              if ((unsigned long )(__o___26->next_free + 1) > (unsigned long )__o___26->chunk_limit) {
                {
#line 328
                _obstack_newchunk(__o___26, 1);
                }
              }
#line 328
              tmp___46 = __o___26->next_free;
#line 328
              (__o___26->next_free) ++;
#line 328
              *tmp___46 = (char )padding;
#line 328
              nspace___3 --;
            }
            while_break___25: /* CIL Label */ ;
            }
          }
        }
#line 328
        __o___27 = user_string_stack___0;
#line 328
        __len___3 = (int )len___3;
#line 328
        if ((unsigned long )(__o___27->next_free + __len___3) > (unsigned long )__o___27->chunk_limit) {
          {
#line 328
          _obstack_newchunk(__o___27, __len___3);
          }
        }
        {
#line 328
        memcpy((void */* __restrict  */)__o___27->next_free, (void const   */* __restrict  */)((char *)cp),
               (size_t )__len___3);
#line 328
        __o___27->next_free += __len___3;
        }
#line 328
        if (width) {
#line 328
          if (justification < 0) {
            {
#line 328
            while (1) {
              while_continue___26: /* CIL Label */ ;
#line 328
              if (! nspace___3) {
#line 328
                goto while_break___26;
              }
#line 328
              __o___28 = user_string_stack___0;
#line 328
              if ((unsigned long )(__o___28->next_free + 1) > (unsigned long )__o___28->chunk_limit) {
                {
#line 328
                _obstack_newchunk(__o___28, 1);
                }
              }
#line 328
              tmp___47 = __o___28->next_free;
#line 328
              (__o___28->next_free) ++;
#line 328
              *tmp___47 = (char )padding;
#line 328
              nspace___3 --;
            }
            while_break___26: /* CIL Label */ ;
            }
          }
        }
#line 328
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
      {
#line 329
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 329
        if (cp) {
          {
#line 329
          free((void *)cp);
          }
        }
#line 329
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 330
      goto switch_break___1;
      case_68: /* CIL Label */ 
#line 333
      if ((int const   )*(str + (i + 1U)) == 123) {
#line 336
        j = (size_t )0;
#line 336
        i += 2U;
        {
#line 336
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 336
          if ((unsigned long )j < sizeof(buf2)) {
#line 336
            if (*(str + i)) {
#line 336
              if (! ((int const   )*(str + i) != 125)) {
#line 336
                goto while_break___28;
              }
            } else {
#line 336
              goto while_break___28;
            }
          } else {
#line 336
            goto while_break___28;
          }
#line 339
          buf2[j] = (unsigned char )*(str + i);
#line 336
          i ++;
#line 336
          j ++;
        }
        while_break___28: /* CIL Label */ ;
        }
#line 340
        if ((int const   )*(str + i) != 125) {
          {
#line 341
          tmp___48 = gettext("%s: too long argument for %s escape");
#line 341
          error(1, 0, (char const   *)tmp___48, context_name, "%D{}");
          }
        }
        {
#line 344
        buf2[j] = (unsigned char )'\000';
#line 345
        strftime((char */* __restrict  */)((char *)(buf___0)), (size_t )sizeof(buf___0),
                 (char const   */* __restrict  */)((char *)(buf2)), (struct tm  const  */* __restrict  */)(& job___0->run_tm));
        }
      } else {
        {
#line 351
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%02d-%02d-%02d",
                job___0->run_tm.tm_year % 100, job___0->run_tm.tm_mon + 1, job___0->run_tm.tm_mday);
        }
      }
      {
#line 356
      while (1) {
        while_continue___29: /* CIL Label */ ;
        {
#line 356
        tmp___49 = strlen((char const   *)(buf___0));
#line 356
        len___4 = tmp___49;
        }
#line 356
        if (len___4 > width) {
#line 356
          nspace___4 = (size_t )0;
        } else {
#line 356
          nspace___4 = width - len___4;
        }
#line 356
        if (width) {
#line 356
          if (justification > 0) {
            {
#line 356
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 356
              if (! nspace___4) {
#line 356
                goto while_break___30;
              }
#line 356
              __o___29 = user_string_stack___0;
#line 356
              if ((unsigned long )(__o___29->next_free + 1) > (unsigned long )__o___29->chunk_limit) {
                {
#line 356
                _obstack_newchunk(__o___29, 1);
                }
              }
#line 356
              tmp___50 = __o___29->next_free;
#line 356
              (__o___29->next_free) ++;
#line 356
              *tmp___50 = (char )padding;
#line 356
              nspace___4 --;
            }
            while_break___30: /* CIL Label */ ;
            }
          }
        }
#line 356
        __o___30 = user_string_stack___0;
#line 356
        __len___4 = (int )len___4;
#line 356
        if ((unsigned long )(__o___30->next_free + __len___4) > (unsigned long )__o___30->chunk_limit) {
          {
#line 356
          _obstack_newchunk(__o___30, __len___4);
          }
        }
        {
#line 356
        memcpy((void */* __restrict  */)__o___30->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___4);
#line 356
        __o___30->next_free += __len___4;
        }
#line 356
        if (width) {
#line 356
          if (justification < 0) {
            {
#line 356
            while (1) {
              while_continue___31: /* CIL Label */ ;
#line 356
              if (! nspace___4) {
#line 356
                goto while_break___31;
              }
#line 356
              __o___31 = user_string_stack___0;
#line 356
              if ((unsigned long )(__o___31->next_free + 1) > (unsigned long )__o___31->chunk_limit) {
                {
#line 356
                _obstack_newchunk(__o___31, 1);
                }
              }
#line 356
              tmp___51 = __o___31->next_free;
#line 356
              (__o___31->next_free) ++;
#line 356
              *tmp___51 = (char )padding;
#line 356
              nspace___4 --;
            }
            while_break___31: /* CIL Label */ ;
            }
          }
        }
#line 356
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
#line 357
      goto switch_break___1;
      case_101: /* CIL Label */ 
      {
#line 360
      tmp___52 = gettext("%b %d, %y");
#line 360
      strftime((char */* __restrict  */)((char *)(buf___0)), (size_t )sizeof(buf___0),
               (char const   */* __restrict  */)tmp___52, (struct tm  const  */* __restrict  */)(& job___0->run_tm));
      }
      {
#line 365
      while (1) {
        while_continue___32: /* CIL Label */ ;
        {
#line 365
        tmp___53 = strlen((char const   *)(buf___0));
#line 365
        len___5 = tmp___53;
        }
#line 365
        if (len___5 > width) {
#line 365
          nspace___5 = (size_t )0;
        } else {
#line 365
          nspace___5 = width - len___5;
        }
#line 365
        if (width) {
#line 365
          if (justification > 0) {
            {
#line 365
            while (1) {
              while_continue___33: /* CIL Label */ ;
#line 365
              if (! nspace___5) {
#line 365
                goto while_break___33;
              }
#line 365
              __o___32 = user_string_stack___0;
#line 365
              if ((unsigned long )(__o___32->next_free + 1) > (unsigned long )__o___32->chunk_limit) {
                {
#line 365
                _obstack_newchunk(__o___32, 1);
                }
              }
#line 365
              tmp___54 = __o___32->next_free;
#line 365
              (__o___32->next_free) ++;
#line 365
              *tmp___54 = (char )padding;
#line 365
              nspace___5 --;
            }
            while_break___33: /* CIL Label */ ;
            }
          }
        }
#line 365
        __o___33 = user_string_stack___0;
#line 365
        __len___5 = (int )len___5;
#line 365
        if ((unsigned long )(__o___33->next_free + __len___5) > (unsigned long )__o___33->chunk_limit) {
          {
#line 365
          _obstack_newchunk(__o___33, __len___5);
          }
        }
        {
#line 365
        memcpy((void */* __restrict  */)__o___33->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___5);
#line 365
        __o___33->next_free += __len___5;
        }
#line 365
        if (width) {
#line 365
          if (justification < 0) {
            {
#line 365
            while (1) {
              while_continue___34: /* CIL Label */ ;
#line 365
              if (! nspace___5) {
#line 365
                goto while_break___34;
              }
#line 365
              __o___34 = user_string_stack___0;
#line 365
              if ((unsigned long )(__o___34->next_free + 1) > (unsigned long )__o___34->chunk_limit) {
                {
#line 365
                _obstack_newchunk(__o___34, 1);
                }
              }
#line 365
              tmp___55 = __o___34->next_free;
#line 365
              (__o___34->next_free) ++;
#line 365
              *tmp___55 = (char )padding;
#line 365
              nspace___5 --;
            }
            while_break___34: /* CIL Label */ ;
            }
          }
        }
#line 365
        goto while_break___32;
      }
      while_break___32: /* CIL Label */ ;
      }
#line 366
      goto switch_break___1;
      case_69: /* CIL Label */ 
      {
#line 372
      tmp___56 = gettext("%A %B %d, %Y");
#line 372
      strftime((char */* __restrict  */)((char *)(buf___0)), (size_t )sizeof(buf___0),
               (char const   */* __restrict  */)tmp___56, (struct tm  const  */* __restrict  */)(& job___0->run_tm));
      }
      {
#line 374
      while (1) {
        while_continue___35: /* CIL Label */ ;
        {
#line 374
        tmp___57 = strlen((char const   *)(buf___0));
#line 374
        len___6 = tmp___57;
        }
#line 374
        if (len___6 > width) {
#line 374
          nspace___6 = (size_t )0;
        } else {
#line 374
          nspace___6 = width - len___6;
        }
#line 374
        if (width) {
#line 374
          if (justification > 0) {
            {
#line 374
            while (1) {
              while_continue___36: /* CIL Label */ ;
#line 374
              if (! nspace___6) {
#line 374
                goto while_break___36;
              }
#line 374
              __o___35 = user_string_stack___0;
#line 374
              if ((unsigned long )(__o___35->next_free + 1) > (unsigned long )__o___35->chunk_limit) {
                {
#line 374
                _obstack_newchunk(__o___35, 1);
                }
              }
#line 374
              tmp___58 = __o___35->next_free;
#line 374
              (__o___35->next_free) ++;
#line 374
              *tmp___58 = (char )padding;
#line 374
              nspace___6 --;
            }
            while_break___36: /* CIL Label */ ;
            }
          }
        }
#line 374
        __o___36 = user_string_stack___0;
#line 374
        __len___6 = (int )len___6;
#line 374
        if ((unsigned long )(__o___36->next_free + __len___6) > (unsigned long )__o___36->chunk_limit) {
          {
#line 374
          _obstack_newchunk(__o___36, __len___6);
          }
        }
        {
#line 374
        memcpy((void */* __restrict  */)__o___36->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___6);
#line 374
        __o___36->next_free += __len___6;
        }
#line 374
        if (width) {
#line 374
          if (justification < 0) {
            {
#line 374
            while (1) {
              while_continue___37: /* CIL Label */ ;
#line 374
              if (! nspace___6) {
#line 374
                goto while_break___37;
              }
#line 374
              __o___37 = user_string_stack___0;
#line 374
              if ((unsigned long )(__o___37->next_free + 1) > (unsigned long )__o___37->chunk_limit) {
                {
#line 374
                _obstack_newchunk(__o___37, 1);
                }
              }
#line 374
              tmp___59 = __o___37->next_free;
#line 374
              (__o___37->next_free) ++;
#line 374
              *tmp___59 = (char )padding;
#line 374
              nspace___6 --;
            }
            while_break___37: /* CIL Label */ ;
            }
          }
        }
#line 374
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
#line 375
      goto switch_break___1;
      case_70: /* CIL Label */ 
      {
#line 378
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d.%d.%d",
              job___0->run_tm.tm_mday, job___0->run_tm.tm_mon + 1, job___0->run_tm.tm_year + 1900);
      }
      {
#line 382
      while (1) {
        while_continue___38: /* CIL Label */ ;
        {
#line 382
        tmp___60 = strlen((char const   *)(buf___0));
#line 382
        len___7 = tmp___60;
        }
#line 382
        if (len___7 > width) {
#line 382
          nspace___7 = (size_t )0;
        } else {
#line 382
          nspace___7 = width - len___7;
        }
#line 382
        if (width) {
#line 382
          if (justification > 0) {
            {
#line 382
            while (1) {
              while_continue___39: /* CIL Label */ ;
#line 382
              if (! nspace___7) {
#line 382
                goto while_break___39;
              }
#line 382
              __o___38 = user_string_stack___0;
#line 382
              if ((unsigned long )(__o___38->next_free + 1) > (unsigned long )__o___38->chunk_limit) {
                {
#line 382
                _obstack_newchunk(__o___38, 1);
                }
              }
#line 382
              tmp___61 = __o___38->next_free;
#line 382
              (__o___38->next_free) ++;
#line 382
              *tmp___61 = (char )padding;
#line 382
              nspace___7 --;
            }
            while_break___39: /* CIL Label */ ;
            }
          }
        }
#line 382
        __o___39 = user_string_stack___0;
#line 382
        __len___7 = (int )len___7;
#line 382
        if ((unsigned long )(__o___39->next_free + __len___7) > (unsigned long )__o___39->chunk_limit) {
          {
#line 382
          _obstack_newchunk(__o___39, __len___7);
          }
        }
        {
#line 382
        memcpy((void */* __restrict  */)__o___39->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___7);
#line 382
        __o___39->next_free += __len___7;
        }
#line 382
        if (width) {
#line 382
          if (justification < 0) {
            {
#line 382
            while (1) {
              while_continue___40: /* CIL Label */ ;
#line 382
              if (! nspace___7) {
#line 382
                goto while_break___40;
              }
#line 382
              __o___40 = user_string_stack___0;
#line 382
              if ((unsigned long )(__o___40->next_free + 1) > (unsigned long )__o___40->chunk_limit) {
                {
#line 382
                _obstack_newchunk(__o___40, 1);
                }
              }
#line 382
              tmp___62 = __o___40->next_free;
#line 382
              (__o___40->next_free) ++;
#line 382
              *tmp___62 = (char )padding;
#line 382
              nspace___7 --;
            }
            while_break___40: /* CIL Label */ ;
            }
          }
        }
#line 382
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 383
      goto switch_break___1;
      case_109: /* CIL Label */ 
      {
#line 386
      tmp___63 = macro_meta_sequence_get(job___0, "user.host");
#line 386
      cp = (unsigned char *)tmp___63;
#line 387
      tmp___64 = strlen((char const   *)cp);
#line 387
      tmp___65 = __builtin_alloca(sizeof(unsigned char ) * (unsigned long )(tmp___64 + 1U));
#line 387
      cp2 = (unsigned char *)tmp___65;
#line 388
      strcpy((char */* __restrict  */)cp2, (char const   */* __restrict  */)cp);
#line 389
      tmp___66 = strchr((char const   *)((char *)cp2), '.');
#line 389
      cp = (unsigned char *)tmp___66;
      }
#line 390
      if (cp) {
#line 391
        *cp = (unsigned char )'\000';
      }
      {
#line 392
      while (1) {
        while_continue___41: /* CIL Label */ ;
        {
#line 392
        tmp___67 = strlen((char const   *)cp2);
#line 392
        len___8 = tmp___67;
        }
#line 392
        if (len___8 > width) {
#line 392
          nspace___8 = (size_t )0;
        } else {
#line 392
          nspace___8 = width - len___8;
        }
#line 392
        if (width) {
#line 392
          if (justification > 0) {
            {
#line 392
            while (1) {
              while_continue___42: /* CIL Label */ ;
#line 392
              if (! nspace___8) {
#line 392
                goto while_break___42;
              }
#line 392
              __o___41 = user_string_stack___0;
#line 392
              if ((unsigned long )(__o___41->next_free + 1) > (unsigned long )__o___41->chunk_limit) {
                {
#line 392
                _obstack_newchunk(__o___41, 1);
                }
              }
#line 392
              tmp___68 = __o___41->next_free;
#line 392
              (__o___41->next_free) ++;
#line 392
              *tmp___68 = (char )padding;
#line 392
              nspace___8 --;
            }
            while_break___42: /* CIL Label */ ;
            }
          }
        }
#line 392
        __o___42 = user_string_stack___0;
#line 392
        __len___8 = (int )len___8;
#line 392
        if ((unsigned long )(__o___42->next_free + __len___8) > (unsigned long )__o___42->chunk_limit) {
          {
#line 392
          _obstack_newchunk(__o___42, __len___8);
          }
        }
        {
#line 392
        memcpy((void */* __restrict  */)__o___42->next_free, (void const   */* __restrict  */)((char *)cp2),
               (size_t )__len___8);
#line 392
        __o___42->next_free += __len___8;
        }
#line 392
        if (width) {
#line 392
          if (justification < 0) {
            {
#line 392
            while (1) {
              while_continue___43: /* CIL Label */ ;
#line 392
              if (! nspace___8) {
#line 392
                goto while_break___43;
              }
#line 392
              __o___43 = user_string_stack___0;
#line 392
              if ((unsigned long )(__o___43->next_free + 1) > (unsigned long )__o___43->chunk_limit) {
                {
#line 392
                _obstack_newchunk(__o___43, 1);
                }
              }
#line 392
              tmp___69 = __o___43->next_free;
#line 392
              (__o___43->next_free) ++;
#line 392
              *tmp___69 = (char )padding;
#line 392
              nspace___8 --;
            }
            while_break___43: /* CIL Label */ ;
            }
          }
        }
#line 392
        goto while_break___41;
      }
      while_break___41: /* CIL Label */ ;
      }
#line 393
      goto switch_break___1;
      case_77: /* CIL Label */ 
      {
#line 396
      while (1) {
        while_continue___44: /* CIL Label */ ;
        {
#line 396
        tmp___70 = macro_meta_sequence_get(job___0, "user.host");
#line 396
        tmp___71 = strlen((char const   *)tmp___70);
#line 396
        len___9 = tmp___71;
        }
#line 396
        if (len___9 > width) {
#line 396
          nspace___9 = (size_t )0;
        } else {
#line 396
          nspace___9 = width - len___9;
        }
#line 396
        if (width) {
#line 396
          if (justification > 0) {
            {
#line 396
            while (1) {
              while_continue___45: /* CIL Label */ ;
#line 396
              if (! nspace___9) {
#line 396
                goto while_break___45;
              }
#line 396
              __o___44 = user_string_stack___0;
#line 396
              if ((unsigned long )(__o___44->next_free + 1) > (unsigned long )__o___44->chunk_limit) {
                {
#line 396
                _obstack_newchunk(__o___44, 1);
                }
              }
#line 396
              tmp___72 = __o___44->next_free;
#line 396
              (__o___44->next_free) ++;
#line 396
              *tmp___72 = (char )padding;
#line 396
              nspace___9 --;
            }
            while_break___45: /* CIL Label */ ;
            }
          }
        }
#line 396
        __o___45 = user_string_stack___0;
#line 396
        __len___9 = (int )len___9;
#line 396
        if ((unsigned long )(__o___45->next_free + __len___9) > (unsigned long )__o___45->chunk_limit) {
          {
#line 396
          _obstack_newchunk(__o___45, __len___9);
          }
        }
        {
#line 396
        tmp___73 = macro_meta_sequence_get(job___0, "user.host");
#line 396
        memcpy((void */* __restrict  */)__o___45->next_free, (void const   */* __restrict  */)tmp___73,
               (size_t )__len___9);
#line 396
        __o___45->next_free += __len___9;
        }
#line 396
        if (width) {
#line 396
          if (justification < 0) {
            {
#line 396
            while (1) {
              while_continue___46: /* CIL Label */ ;
#line 396
              if (! nspace___9) {
#line 396
                goto while_break___46;
              }
#line 396
              __o___46 = user_string_stack___0;
#line 396
              if ((unsigned long )(__o___46->next_free + 1) > (unsigned long )__o___46->chunk_limit) {
                {
#line 396
                _obstack_newchunk(__o___46, 1);
                }
              }
#line 396
              tmp___74 = __o___46->next_free;
#line 396
              (__o___46->next_free) ++;
#line 396
              *tmp___74 = (char )padding;
#line 396
              nspace___9 --;
            }
            while_break___46: /* CIL Label */ ;
            }
          }
        }
#line 396
        goto while_break___44;
      }
      while_break___44: /* CIL Label */ ;
      }
#line 397
      goto switch_break___1;
      case_110___0: /* CIL Label */ 
      {
#line 400
      while (1) {
        while_continue___47: /* CIL Label */ ;
        {
#line 400
        tmp___75 = macro_meta_sequence_get(job___0, "user.login");
#line 400
        tmp___76 = strlen((char const   *)tmp___75);
#line 400
        len___10 = tmp___76;
        }
#line 400
        if (len___10 > width) {
#line 400
          nspace___10 = (size_t )0;
        } else {
#line 400
          nspace___10 = width - len___10;
        }
#line 400
        if (width) {
#line 400
          if (justification > 0) {
            {
#line 400
            while (1) {
              while_continue___48: /* CIL Label */ ;
#line 400
              if (! nspace___10) {
#line 400
                goto while_break___48;
              }
#line 400
              __o___47 = user_string_stack___0;
#line 400
              if ((unsigned long )(__o___47->next_free + 1) > (unsigned long )__o___47->chunk_limit) {
                {
#line 400
                _obstack_newchunk(__o___47, 1);
                }
              }
#line 400
              tmp___77 = __o___47->next_free;
#line 400
              (__o___47->next_free) ++;
#line 400
              *tmp___77 = (char )padding;
#line 400
              nspace___10 --;
            }
            while_break___48: /* CIL Label */ ;
            }
          }
        }
#line 400
        __o___48 = user_string_stack___0;
#line 400
        __len___10 = (int )len___10;
#line 400
        if ((unsigned long )(__o___48->next_free + __len___10) > (unsigned long )__o___48->chunk_limit) {
          {
#line 400
          _obstack_newchunk(__o___48, __len___10);
          }
        }
        {
#line 400
        tmp___78 = macro_meta_sequence_get(job___0, "user.login");
#line 400
        memcpy((void */* __restrict  */)__o___48->next_free, (void const   */* __restrict  */)tmp___78,
               (size_t )__len___10);
#line 400
        __o___48->next_free += __len___10;
        }
#line 400
        if (width) {
#line 400
          if (justification < 0) {
            {
#line 400
            while (1) {
              while_continue___49: /* CIL Label */ ;
#line 400
              if (! nspace___10) {
#line 400
                goto while_break___49;
              }
#line 400
              __o___49 = user_string_stack___0;
#line 400
              if ((unsigned long )(__o___49->next_free + 1) > (unsigned long )__o___49->chunk_limit) {
                {
#line 400
                _obstack_newchunk(__o___49, 1);
                }
              }
#line 400
              tmp___79 = __o___49->next_free;
#line 400
              (__o___49->next_free) ++;
#line 400
              *tmp___79 = (char )padding;
#line 400
              nspace___10 --;
            }
            while_break___49: /* CIL Label */ ;
            }
          }
        }
#line 400
        goto while_break___47;
      }
      while_break___47: /* CIL Label */ ;
      }
#line 401
      goto switch_break___1;
      case_78: /* CIL Label */ 
      {
#line 404
      while (1) {
        while_continue___50: /* CIL Label */ ;
        {
#line 404
        tmp___80 = macro_meta_sequence_get(job___0, "user.name");
#line 404
        tmp___81 = strlen((char const   *)tmp___80);
#line 404
        len___11 = tmp___81;
        }
#line 404
        if (len___11 > width) {
#line 404
          nspace___11 = (size_t )0;
        } else {
#line 404
          nspace___11 = width - len___11;
        }
#line 404
        if (width) {
#line 404
          if (justification > 0) {
            {
#line 404
            while (1) {
              while_continue___51: /* CIL Label */ ;
#line 404
              if (! nspace___11) {
#line 404
                goto while_break___51;
              }
#line 404
              __o___50 = user_string_stack___0;
#line 404
              if ((unsigned long )(__o___50->next_free + 1) > (unsigned long )__o___50->chunk_limit) {
                {
#line 404
                _obstack_newchunk(__o___50, 1);
                }
              }
#line 404
              tmp___82 = __o___50->next_free;
#line 404
              (__o___50->next_free) ++;
#line 404
              *tmp___82 = (char )padding;
#line 404
              nspace___11 --;
            }
            while_break___51: /* CIL Label */ ;
            }
          }
        }
#line 404
        __o___51 = user_string_stack___0;
#line 404
        __len___11 = (int )len___11;
#line 404
        if ((unsigned long )(__o___51->next_free + __len___11) > (unsigned long )__o___51->chunk_limit) {
          {
#line 404
          _obstack_newchunk(__o___51, __len___11);
          }
        }
        {
#line 404
        tmp___83 = macro_meta_sequence_get(job___0, "user.name");
#line 404
        memcpy((void */* __restrict  */)__o___51->next_free, (void const   */* __restrict  */)tmp___83,
               (size_t )__len___11);
#line 404
        __o___51->next_free += __len___11;
        }
#line 404
        if (width) {
#line 404
          if (justification < 0) {
            {
#line 404
            while (1) {
              while_continue___52: /* CIL Label */ ;
#line 404
              if (! nspace___11) {
#line 404
                goto while_break___52;
              }
#line 404
              __o___52 = user_string_stack___0;
#line 404
              if ((unsigned long )(__o___52->next_free + 1) > (unsigned long )__o___52->chunk_limit) {
                {
#line 404
                _obstack_newchunk(__o___52, 1);
                }
              }
#line 404
              tmp___84 = __o___52->next_free;
#line 404
              (__o___52->next_free) ++;
#line 404
              *tmp___84 = (char )padding;
#line 404
              nspace___11 --;
            }
            while_break___52: /* CIL Label */ ;
            }
          }
        }
#line 404
        goto while_break___50;
      }
      while_break___50: /* CIL Label */ ;
      }
#line 405
      goto switch_break___1;
      case_112: /* CIL Label */ 
#line 408
      i ++;
      {
#line 409
      if ((int const   )*(str + i) == 46) {
#line 409
        goto case_46;
      }
#line 414
      if ((int const   )*(str + i) == 35) {
#line 414
        goto case_35___0;
      }
#line 418
      goto switch_default___0;
      case_46: /* CIL Label */ 
      {
#line 410
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              job___0->pages);
      }
      {
#line 411
      while (1) {
        while_continue___53: /* CIL Label */ ;
        {
#line 411
        tmp___85 = strlen((char const   *)(buf___0));
#line 411
        len___12 = tmp___85;
        }
#line 411
        if (len___12 > width) {
#line 411
          nspace___12 = (size_t )0;
        } else {
#line 411
          nspace___12 = width - len___12;
        }
#line 411
        if (width) {
#line 411
          if (justification > 0) {
            {
#line 411
            while (1) {
              while_continue___54: /* CIL Label */ ;
#line 411
              if (! nspace___12) {
#line 411
                goto while_break___54;
              }
#line 411
              __o___53 = user_string_stack___0;
#line 411
              if ((unsigned long )(__o___53->next_free + 1) > (unsigned long )__o___53->chunk_limit) {
                {
#line 411
                _obstack_newchunk(__o___53, 1);
                }
              }
#line 411
              tmp___86 = __o___53->next_free;
#line 411
              (__o___53->next_free) ++;
#line 411
              *tmp___86 = (char )padding;
#line 411
              nspace___12 --;
            }
            while_break___54: /* CIL Label */ ;
            }
          }
        }
#line 411
        __o___54 = user_string_stack___0;
#line 411
        __len___12 = (int )len___12;
#line 411
        if ((unsigned long )(__o___54->next_free + __len___12) > (unsigned long )__o___54->chunk_limit) {
          {
#line 411
          _obstack_newchunk(__o___54, __len___12);
          }
        }
        {
#line 411
        memcpy((void */* __restrict  */)__o___54->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___12);
#line 411
        __o___54->next_free += __len___12;
        }
#line 411
        if (width) {
#line 411
          if (justification < 0) {
            {
#line 411
            while (1) {
              while_continue___55: /* CIL Label */ ;
#line 411
              if (! nspace___12) {
#line 411
                goto while_break___55;
              }
#line 411
              __o___55 = user_string_stack___0;
#line 411
              if ((unsigned long )(__o___55->next_free + 1) > (unsigned long )__o___55->chunk_limit) {
                {
#line 411
                _obstack_newchunk(__o___55, 1);
                }
              }
#line 411
              tmp___87 = __o___55->next_free;
#line 411
              (__o___55->next_free) ++;
#line 411
              *tmp___87 = (char )padding;
#line 411
              nspace___12 --;
            }
            while_break___55: /* CIL Label */ ;
            }
          }
        }
#line 411
        goto while_break___53;
      }
      while_break___53: /* CIL Label */ ;
      }
#line 412
      goto switch_break___2;
      case_35___0: /* CIL Label */ 
      {
#line 415
      while (1) {
        while_continue___56: /* CIL Label */ ;
#line 415
        if (width) {
#line 415
          if (justification < 0) {
#line 415
            __o___56 = user_string_stack___0;
#line 415
            if ((unsigned long )(__o___56->next_free + 1) > (unsigned long )__o___56->chunk_limit) {
              {
#line 415
              _obstack_newchunk(__o___56, 1);
              }
            }
#line 415
            tmp___88 = __o___56->next_free;
#line 415
            (__o___56->next_free) ++;
#line 415
            *tmp___88 = (char)1;
          }
        }
#line 415
        a___4 = 0;
        {
#line 415
        while (1) {
          while_continue___57: /* CIL Label */ ;
#line 415
          if (! (a___4 < (int )width - 1)) {
#line 415
            goto while_break___57;
          }
#line 415
          __o___57 = user_string_stack___0;
#line 415
          if ((unsigned long )(__o___57->next_free + 1) > (unsigned long )__o___57->chunk_limit) {
            {
#line 415
            _obstack_newchunk(__o___57, 1);
            }
          }
#line 415
          tmp___89 = __o___57->next_free;
#line 415
          (__o___57->next_free) ++;
#line 415
          *tmp___89 = (char )padding;
#line 415
          a___4 ++;
        }
        while_break___57: /* CIL Label */ ;
        }
#line 415
        if (! width) {
#line 415
          goto _L___4;
        } else
#line 415
        if (justification > 0) {
          _L___4: /* CIL Label */ 
#line 415
          __o___58 = user_string_stack___0;
#line 415
          if ((unsigned long )(__o___58->next_free + 1) > (unsigned long )__o___58->chunk_limit) {
            {
#line 415
            _obstack_newchunk(__o___58, 1);
            }
          }
#line 415
          tmp___90 = __o___58->next_free;
#line 415
          (__o___58->next_free) ++;
#line 415
          *tmp___90 = (char)1;
        }
#line 415
        goto while_break___56;
      }
      while_break___56: /* CIL Label */ ;
      }
#line 416
      goto switch_break___2;
      switch_default___0: /* CIL Label */ 
      {
#line 419
      tmp___91 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 419
      error(1, 0, (char const   *)tmp___91, context_name, "%p", (int const   )*(str + i),
            (int const   )*(str + i));
      }
#line 421
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 423
      goto switch_break___1;
      case_113: /* CIL Label */ 
      {
#line 426
      tmp___92 = gettext("Page %d");
#line 426
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)tmp___92,
              job___0->pages);
      }
      {
#line 427
      while (1) {
        while_continue___58: /* CIL Label */ ;
        {
#line 427
        tmp___93 = strlen((char const   *)(buf___0));
#line 427
        len___13 = tmp___93;
        }
#line 427
        if (len___13 > width) {
#line 427
          nspace___13 = (size_t )0;
        } else {
#line 427
          nspace___13 = width - len___13;
        }
#line 427
        if (width) {
#line 427
          if (justification > 0) {
            {
#line 427
            while (1) {
              while_continue___59: /* CIL Label */ ;
#line 427
              if (! nspace___13) {
#line 427
                goto while_break___59;
              }
#line 427
              __o___59 = user_string_stack___0;
#line 427
              if ((unsigned long )(__o___59->next_free + 1) > (unsigned long )__o___59->chunk_limit) {
                {
#line 427
                _obstack_newchunk(__o___59, 1);
                }
              }
#line 427
              tmp___94 = __o___59->next_free;
#line 427
              (__o___59->next_free) ++;
#line 427
              *tmp___94 = (char )padding;
#line 427
              nspace___13 --;
            }
            while_break___59: /* CIL Label */ ;
            }
          }
        }
#line 427
        __o___60 = user_string_stack___0;
#line 427
        __len___13 = (int )len___13;
#line 427
        if ((unsigned long )(__o___60->next_free + __len___13) > (unsigned long )__o___60->chunk_limit) {
          {
#line 427
          _obstack_newchunk(__o___60, __len___13);
          }
        }
        {
#line 427
        memcpy((void */* __restrict  */)__o___60->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___13);
#line 427
        __o___60->next_free += __len___13;
        }
#line 427
        if (width) {
#line 427
          if (justification < 0) {
            {
#line 427
            while (1) {
              while_continue___60: /* CIL Label */ ;
#line 427
              if (! nspace___13) {
#line 427
                goto while_break___60;
              }
#line 427
              __o___61 = user_string_stack___0;
#line 427
              if ((unsigned long )(__o___61->next_free + 1) > (unsigned long )__o___61->chunk_limit) {
                {
#line 427
                _obstack_newchunk(__o___61, 1);
                }
              }
#line 427
              tmp___95 = __o___61->next_free;
#line 427
              (__o___61->next_free) ++;
#line 427
              *tmp___95 = (char )padding;
#line 427
              nspace___13 --;
            }
            while_break___60: /* CIL Label */ ;
            }
          }
        }
#line 427
        goto while_break___58;
      }
      while_break___58: /* CIL Label */ ;
      }
#line 428
      goto switch_break___1;
      case_81: /* CIL Label */ 
      {
#line 431
      tmp___96 = gettext("Page %d/%c");
#line 431
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)tmp___96,
              job___0->pages, 1);
      }
      {
#line 433
      while (1) {
        while_continue___61: /* CIL Label */ ;
        {
#line 433
        tmp___97 = strlen((char const   *)(buf___0));
#line 433
        len___14 = tmp___97;
        }
#line 433
        if (len___14 > width) {
#line 433
          nspace___14 = (size_t )0;
        } else {
#line 433
          nspace___14 = width - len___14;
        }
#line 433
        if (width) {
#line 433
          if (justification > 0) {
            {
#line 433
            while (1) {
              while_continue___62: /* CIL Label */ ;
#line 433
              if (! nspace___14) {
#line 433
                goto while_break___62;
              }
#line 433
              __o___62 = user_string_stack___0;
#line 433
              if ((unsigned long )(__o___62->next_free + 1) > (unsigned long )__o___62->chunk_limit) {
                {
#line 433
                _obstack_newchunk(__o___62, 1);
                }
              }
#line 433
              tmp___98 = __o___62->next_free;
#line 433
              (__o___62->next_free) ++;
#line 433
              *tmp___98 = (char )padding;
#line 433
              nspace___14 --;
            }
            while_break___62: /* CIL Label */ ;
            }
          }
        }
#line 433
        __o___63 = user_string_stack___0;
#line 433
        __len___14 = (int )len___14;
#line 433
        if ((unsigned long )(__o___63->next_free + __len___14) > (unsigned long )__o___63->chunk_limit) {
          {
#line 433
          _obstack_newchunk(__o___63, __len___14);
          }
        }
        {
#line 433
        memcpy((void */* __restrict  */)__o___63->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___14);
#line 433
        __o___63->next_free += __len___14;
        }
#line 433
        if (width) {
#line 433
          if (justification < 0) {
            {
#line 433
            while (1) {
              while_continue___63: /* CIL Label */ ;
#line 433
              if (! nspace___14) {
#line 433
                goto while_break___63;
              }
#line 433
              __o___64 = user_string_stack___0;
#line 433
              if ((unsigned long )(__o___64->next_free + 1) > (unsigned long )__o___64->chunk_limit) {
                {
#line 433
                _obstack_newchunk(__o___64, 1);
                }
              }
#line 433
              tmp___99 = __o___64->next_free;
#line 433
              (__o___64->next_free) ++;
#line 433
              *tmp___99 = (char )padding;
#line 433
              nspace___14 --;
            }
            while_break___63: /* CIL Label */ ;
            }
          }
        }
#line 433
        goto while_break___61;
      }
      while_break___61: /* CIL Label */ ;
      }
#line 434
      goto switch_break___1;
      case_115: /* CIL Label */ 
#line 437
      i ++;
      {
#line 438
      if ((int const   )*(str + i) == 46) {
#line 438
        goto case_46___0;
      }
#line 443
      if ((int const   )*(str + i) == 35) {
#line 443
        goto case_35___1;
      }
#line 447
      goto switch_default___1;
      case_46___0: /* CIL Label */ 
      {
#line 439
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              job___0->sheets);
      }
      {
#line 440
      while (1) {
        while_continue___64: /* CIL Label */ ;
        {
#line 440
        tmp___100 = strlen((char const   *)(buf___0));
#line 440
        len___15 = tmp___100;
        }
#line 440
        if (len___15 > width) {
#line 440
          nspace___15 = (size_t )0;
        } else {
#line 440
          nspace___15 = width - len___15;
        }
#line 440
        if (width) {
#line 440
          if (justification > 0) {
            {
#line 440
            while (1) {
              while_continue___65: /* CIL Label */ ;
#line 440
              if (! nspace___15) {
#line 440
                goto while_break___65;
              }
#line 440
              __o___65 = user_string_stack___0;
#line 440
              if ((unsigned long )(__o___65->next_free + 1) > (unsigned long )__o___65->chunk_limit) {
                {
#line 440
                _obstack_newchunk(__o___65, 1);
                }
              }
#line 440
              tmp___101 = __o___65->next_free;
#line 440
              (__o___65->next_free) ++;
#line 440
              *tmp___101 = (char )padding;
#line 440
              nspace___15 --;
            }
            while_break___65: /* CIL Label */ ;
            }
          }
        }
#line 440
        __o___66 = user_string_stack___0;
#line 440
        __len___15 = (int )len___15;
#line 440
        if ((unsigned long )(__o___66->next_free + __len___15) > (unsigned long )__o___66->chunk_limit) {
          {
#line 440
          _obstack_newchunk(__o___66, __len___15);
          }
        }
        {
#line 440
        memcpy((void */* __restrict  */)__o___66->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___15);
#line 440
        __o___66->next_free += __len___15;
        }
#line 440
        if (width) {
#line 440
          if (justification < 0) {
            {
#line 440
            while (1) {
              while_continue___66: /* CIL Label */ ;
#line 440
              if (! nspace___15) {
#line 440
                goto while_break___66;
              }
#line 440
              __o___67 = user_string_stack___0;
#line 440
              if ((unsigned long )(__o___67->next_free + 1) > (unsigned long )__o___67->chunk_limit) {
                {
#line 440
                _obstack_newchunk(__o___67, 1);
                }
              }
#line 440
              tmp___102 = __o___67->next_free;
#line 440
              (__o___67->next_free) ++;
#line 440
              *tmp___102 = (char )padding;
#line 440
              nspace___15 --;
            }
            while_break___66: /* CIL Label */ ;
            }
          }
        }
#line 440
        goto while_break___64;
      }
      while_break___64: /* CIL Label */ ;
      }
#line 441
      goto switch_break___3;
      case_35___1: /* CIL Label */ 
      {
#line 444
      while (1) {
        while_continue___67: /* CIL Label */ ;
#line 444
        if (width) {
#line 444
          if (justification < 0) {
#line 444
            __o___68 = user_string_stack___0;
#line 444
            if ((unsigned long )(__o___68->next_free + 1) > (unsigned long )__o___68->chunk_limit) {
              {
#line 444
              _obstack_newchunk(__o___68, 1);
              }
            }
#line 444
            tmp___103 = __o___68->next_free;
#line 444
            (__o___68->next_free) ++;
#line 444
            *tmp___103 = (char)2;
          }
        }
#line 444
        a___5 = 0;
        {
#line 444
        while (1) {
          while_continue___68: /* CIL Label */ ;
#line 444
          if (! (a___5 < (int )width - 1)) {
#line 444
            goto while_break___68;
          }
#line 444
          __o___69 = user_string_stack___0;
#line 444
          if ((unsigned long )(__o___69->next_free + 1) > (unsigned long )__o___69->chunk_limit) {
            {
#line 444
            _obstack_newchunk(__o___69, 1);
            }
          }
#line 444
          tmp___104 = __o___69->next_free;
#line 444
          (__o___69->next_free) ++;
#line 444
          *tmp___104 = (char )padding;
#line 444
          a___5 ++;
        }
        while_break___68: /* CIL Label */ ;
        }
#line 444
        if (! width) {
#line 444
          goto _L___5;
        } else
#line 444
        if (justification > 0) {
          _L___5: /* CIL Label */ 
#line 444
          __o___70 = user_string_stack___0;
#line 444
          if ((unsigned long )(__o___70->next_free + 1) > (unsigned long )__o___70->chunk_limit) {
            {
#line 444
            _obstack_newchunk(__o___70, 1);
            }
          }
#line 444
          tmp___105 = __o___70->next_free;
#line 444
          (__o___70->next_free) ++;
#line 444
          *tmp___105 = (char)2;
        }
#line 444
        goto while_break___67;
      }
      while_break___67: /* CIL Label */ ;
      }
#line 445
      goto switch_break___3;
      switch_default___1: /* CIL Label */ 
      {
#line 448
      tmp___106 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 448
      error(1, 0, (char const   *)tmp___106, context_name, "%s", (int const   )*(str + i),
            (int const   )*(str + i));
      }
#line 450
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
#line 452
      goto switch_break___1;
      case_116: /* CIL Label */ 
#line 455
      if (job___0->run_tm.tm_hour > 12) {
#line 455
        tmp___107 = "pm";
      } else {
#line 455
        tmp___107 = "am";
      }
#line 455
      if (job___0->run_tm.tm_hour > 12) {
#line 455
        tmp___108 = job___0->run_tm.tm_hour - 12;
      } else {
#line 455
        tmp___108 = job___0->run_tm.tm_hour;
      }
      {
#line 455
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d:%02d%s",
              tmp___108, job___0->run_tm.tm_min, tmp___107);
      }
      {
#line 460
      while (1) {
        while_continue___69: /* CIL Label */ ;
        {
#line 460
        tmp___109 = strlen((char const   *)(buf___0));
#line 460
        len___16 = tmp___109;
        }
#line 460
        if (len___16 > width) {
#line 460
          nspace___16 = (size_t )0;
        } else {
#line 460
          nspace___16 = width - len___16;
        }
#line 460
        if (width) {
#line 460
          if (justification > 0) {
            {
#line 460
            while (1) {
              while_continue___70: /* CIL Label */ ;
#line 460
              if (! nspace___16) {
#line 460
                goto while_break___70;
              }
#line 460
              __o___71 = user_string_stack___0;
#line 460
              if ((unsigned long )(__o___71->next_free + 1) > (unsigned long )__o___71->chunk_limit) {
                {
#line 460
                _obstack_newchunk(__o___71, 1);
                }
              }
#line 460
              tmp___110 = __o___71->next_free;
#line 460
              (__o___71->next_free) ++;
#line 460
              *tmp___110 = (char )padding;
#line 460
              nspace___16 --;
            }
            while_break___70: /* CIL Label */ ;
            }
          }
        }
#line 460
        __o___72 = user_string_stack___0;
#line 460
        __len___16 = (int )len___16;
#line 460
        if ((unsigned long )(__o___72->next_free + __len___16) > (unsigned long )__o___72->chunk_limit) {
          {
#line 460
          _obstack_newchunk(__o___72, __len___16);
          }
        }
        {
#line 460
        memcpy((void */* __restrict  */)__o___72->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___16);
#line 460
        __o___72->next_free += __len___16;
        }
#line 460
        if (width) {
#line 460
          if (justification < 0) {
            {
#line 460
            while (1) {
              while_continue___71: /* CIL Label */ ;
#line 460
              if (! nspace___16) {
#line 460
                goto while_break___71;
              }
#line 460
              __o___73 = user_string_stack___0;
#line 460
              if ((unsigned long )(__o___73->next_free + 1) > (unsigned long )__o___73->chunk_limit) {
                {
#line 460
                _obstack_newchunk(__o___73, 1);
                }
              }
#line 460
              tmp___111 = __o___73->next_free;
#line 460
              (__o___73->next_free) ++;
#line 460
              *tmp___111 = (char )padding;
#line 460
              nspace___16 --;
            }
            while_break___71: /* CIL Label */ ;
            }
          }
        }
#line 460
        goto while_break___69;
      }
      while_break___69: /* CIL Label */ ;
      }
#line 461
      goto switch_break___1;
      case_84: /* CIL Label */ 
      {
#line 464
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d:%02d",
              job___0->run_tm.tm_hour, job___0->run_tm.tm_min);
      }
      {
#line 466
      while (1) {
        while_continue___72: /* CIL Label */ ;
        {
#line 466
        tmp___112 = strlen((char const   *)(buf___0));
#line 466
        len___17 = tmp___112;
        }
#line 466
        if (len___17 > width) {
#line 466
          nspace___17 = (size_t )0;
        } else {
#line 466
          nspace___17 = width - len___17;
        }
#line 466
        if (width) {
#line 466
          if (justification > 0) {
            {
#line 466
            while (1) {
              while_continue___73: /* CIL Label */ ;
#line 466
              if (! nspace___17) {
#line 466
                goto while_break___73;
              }
#line 466
              __o___74 = user_string_stack___0;
#line 466
              if ((unsigned long )(__o___74->next_free + 1) > (unsigned long )__o___74->chunk_limit) {
                {
#line 466
                _obstack_newchunk(__o___74, 1);
                }
              }
#line 466
              tmp___113 = __o___74->next_free;
#line 466
              (__o___74->next_free) ++;
#line 466
              *tmp___113 = (char )padding;
#line 466
              nspace___17 --;
            }
            while_break___73: /* CIL Label */ ;
            }
          }
        }
#line 466
        __o___75 = user_string_stack___0;
#line 466
        __len___17 = (int )len___17;
#line 466
        if ((unsigned long )(__o___75->next_free + __len___17) > (unsigned long )__o___75->chunk_limit) {
          {
#line 466
          _obstack_newchunk(__o___75, __len___17);
          }
        }
        {
#line 466
        memcpy((void */* __restrict  */)__o___75->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___17);
#line 466
        __o___75->next_free += __len___17;
        }
#line 466
        if (width) {
#line 466
          if (justification < 0) {
            {
#line 466
            while (1) {
              while_continue___74: /* CIL Label */ ;
#line 466
              if (! nspace___17) {
#line 466
                goto while_break___74;
              }
#line 466
              __o___76 = user_string_stack___0;
#line 466
              if ((unsigned long )(__o___76->next_free + 1) > (unsigned long )__o___76->chunk_limit) {
                {
#line 466
                _obstack_newchunk(__o___76, 1);
                }
              }
#line 466
              tmp___114 = __o___76->next_free;
#line 466
              (__o___76->next_free) ++;
#line 466
              *tmp___114 = (char )padding;
#line 466
              nspace___17 --;
            }
            while_break___74: /* CIL Label */ ;
            }
          }
        }
#line 466
        goto while_break___72;
      }
      while_break___72: /* CIL Label */ ;
      }
#line 467
      goto switch_break___1;
      case_42: /* CIL Label */ 
      {
#line 470
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d:%02d:%02d",
              job___0->run_tm.tm_hour, job___0->run_tm.tm_min, job___0->run_tm.tm_sec);
      }
      {
#line 474
      while (1) {
        while_continue___75: /* CIL Label */ ;
        {
#line 474
        tmp___115 = strlen((char const   *)(buf___0));
#line 474
        len___18 = tmp___115;
        }
#line 474
        if (len___18 > width) {
#line 474
          nspace___18 = (size_t )0;
        } else {
#line 474
          nspace___18 = width - len___18;
        }
#line 474
        if (width) {
#line 474
          if (justification > 0) {
            {
#line 474
            while (1) {
              while_continue___76: /* CIL Label */ ;
#line 474
              if (! nspace___18) {
#line 474
                goto while_break___76;
              }
#line 474
              __o___77 = user_string_stack___0;
#line 474
              if ((unsigned long )(__o___77->next_free + 1) > (unsigned long )__o___77->chunk_limit) {
                {
#line 474
                _obstack_newchunk(__o___77, 1);
                }
              }
#line 474
              tmp___116 = __o___77->next_free;
#line 474
              (__o___77->next_free) ++;
#line 474
              *tmp___116 = (char )padding;
#line 474
              nspace___18 --;
            }
            while_break___76: /* CIL Label */ ;
            }
          }
        }
#line 474
        __o___78 = user_string_stack___0;
#line 474
        __len___18 = (int )len___18;
#line 474
        if ((unsigned long )(__o___78->next_free + __len___18) > (unsigned long )__o___78->chunk_limit) {
          {
#line 474
          _obstack_newchunk(__o___78, __len___18);
          }
        }
        {
#line 474
        memcpy((void */* __restrict  */)__o___78->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___18);
#line 474
        __o___78->next_free += __len___18;
        }
#line 474
        if (width) {
#line 474
          if (justification < 0) {
            {
#line 474
            while (1) {
              while_continue___77: /* CIL Label */ ;
#line 474
              if (! nspace___18) {
#line 474
                goto while_break___77;
              }
#line 474
              __o___79 = user_string_stack___0;
#line 474
              if ((unsigned long )(__o___79->next_free + 1) > (unsigned long )__o___79->chunk_limit) {
                {
#line 474
                _obstack_newchunk(__o___79, 1);
                }
              }
#line 474
              tmp___117 = __o___79->next_free;
#line 474
              (__o___79->next_free) ++;
#line 474
              *tmp___117 = (char )padding;
#line 474
              nspace___18 --;
            }
            while_break___77: /* CIL Label */ ;
            }
          }
        }
#line 474
        goto while_break___75;
      }
      while_break___75: /* CIL Label */ ;
      }
#line 475
      goto switch_break___1;
      case_86: /* CIL Label */ 
      {
#line 478
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%s %s",
              "a2ps", "4.14");
      }
      {
#line 479
      while (1) {
        while_continue___78: /* CIL Label */ ;
        {
#line 479
        tmp___118 = strlen((char const   *)(buf___0));
#line 479
        len___19 = tmp___118;
        }
#line 479
        if (len___19 > width) {
#line 479
          nspace___19 = (size_t )0;
        } else {
#line 479
          nspace___19 = width - len___19;
        }
#line 479
        if (width) {
#line 479
          if (justification > 0) {
            {
#line 479
            while (1) {
              while_continue___79: /* CIL Label */ ;
#line 479
              if (! nspace___19) {
#line 479
                goto while_break___79;
              }
#line 479
              __o___80 = user_string_stack___0;
#line 479
              if ((unsigned long )(__o___80->next_free + 1) > (unsigned long )__o___80->chunk_limit) {
                {
#line 479
                _obstack_newchunk(__o___80, 1);
                }
              }
#line 479
              tmp___119 = __o___80->next_free;
#line 479
              (__o___80->next_free) ++;
#line 479
              *tmp___119 = (char )padding;
#line 479
              nspace___19 --;
            }
            while_break___79: /* CIL Label */ ;
            }
          }
        }
#line 479
        __o___81 = user_string_stack___0;
#line 479
        __len___19 = (int )len___19;
#line 479
        if ((unsigned long )(__o___81->next_free + __len___19) > (unsigned long )__o___81->chunk_limit) {
          {
#line 479
          _obstack_newchunk(__o___81, __len___19);
          }
        }
        {
#line 479
        memcpy((void */* __restrict  */)__o___81->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___19);
#line 479
        __o___81->next_free += __len___19;
        }
#line 479
        if (width) {
#line 479
          if (justification < 0) {
            {
#line 479
            while (1) {
              while_continue___80: /* CIL Label */ ;
#line 479
              if (! nspace___19) {
#line 479
                goto while_break___80;
              }
#line 479
              __o___82 = user_string_stack___0;
#line 479
              if ((unsigned long )(__o___82->next_free + 1) > (unsigned long )__o___82->chunk_limit) {
                {
#line 479
                _obstack_newchunk(__o___82, 1);
                }
              }
#line 479
              tmp___120 = __o___82->next_free;
#line 479
              (__o___82->next_free) ++;
#line 479
              *tmp___120 = (char )padding;
#line 479
              nspace___19 --;
            }
            while_break___80: /* CIL Label */ ;
            }
          }
        }
#line 479
        goto while_break___78;
      }
      while_break___78: /* CIL Label */ ;
      }
#line 480
      goto switch_break___1;
      case_87: /* CIL Label */ 
      {
#line 483
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%02d/%02d/%02d",
              job___0->run_tm.tm_mon + 1, job___0->run_tm.tm_mday, job___0->run_tm.tm_year % 100);
      }
      {
#line 487
      while (1) {
        while_continue___81: /* CIL Label */ ;
        {
#line 487
        tmp___121 = strlen((char const   *)(buf___0));
#line 487
        len___20 = tmp___121;
        }
#line 487
        if (len___20 > width) {
#line 487
          nspace___20 = (size_t )0;
        } else {
#line 487
          nspace___20 = width - len___20;
        }
#line 487
        if (width) {
#line 487
          if (justification > 0) {
            {
#line 487
            while (1) {
              while_continue___82: /* CIL Label */ ;
#line 487
              if (! nspace___20) {
#line 487
                goto while_break___82;
              }
#line 487
              __o___83 = user_string_stack___0;
#line 487
              if ((unsigned long )(__o___83->next_free + 1) > (unsigned long )__o___83->chunk_limit) {
                {
#line 487
                _obstack_newchunk(__o___83, 1);
                }
              }
#line 487
              tmp___122 = __o___83->next_free;
#line 487
              (__o___83->next_free) ++;
#line 487
              *tmp___122 = (char )padding;
#line 487
              nspace___20 --;
            }
            while_break___82: /* CIL Label */ ;
            }
          }
        }
#line 487
        __o___84 = user_string_stack___0;
#line 487
        __len___20 = (int )len___20;
#line 487
        if ((unsigned long )(__o___84->next_free + __len___20) > (unsigned long )__o___84->chunk_limit) {
          {
#line 487
          _obstack_newchunk(__o___84, __len___20);
          }
        }
        {
#line 487
        memcpy((void */* __restrict  */)__o___84->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___20);
#line 487
        __o___84->next_free += __len___20;
        }
#line 487
        if (width) {
#line 487
          if (justification < 0) {
            {
#line 487
            while (1) {
              while_continue___83: /* CIL Label */ ;
#line 487
              if (! nspace___20) {
#line 487
                goto while_break___83;
              }
#line 487
              __o___85 = user_string_stack___0;
#line 487
              if ((unsigned long )(__o___85->next_free + 1) > (unsigned long )__o___85->chunk_limit) {
                {
#line 487
                _obstack_newchunk(__o___85, 1);
                }
              }
#line 487
              tmp___123 = __o___85->next_free;
#line 487
              (__o___85->next_free) ++;
#line 487
              *tmp___123 = (char )padding;
#line 487
              nspace___20 --;
            }
            while_break___83: /* CIL Label */ ;
            }
          }
        }
#line 487
        goto while_break___81;
      }
      while_break___81: /* CIL Label */ ;
      }
#line 488
      goto switch_break___1;
      switch_default___2: /* CIL Label */ 
      {
#line 491
      tmp___124 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 491
      error(1, 0, (char const   *)tmp___124, context_name, "%", (int const   )*(str + i),
            (int const   )*(str + i));
      }
#line 493
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 496
      goto switch_break;
      case_36: /* CIL Label */ 
      {
#line 512
      if ((int const   )*(str + i) == 36) {
#line 512
        goto case_36___0;
      }
#line 516
      if ((int const   )*(str + i) == 42) {
#line 516
        goto case_42___0;
      }
#line 524
      if ((int const   )*(str + i) == 40) {
#line 524
        goto case_40;
      }
#line 543
      if ((int const   )*(str + i) == 123) {
#line 543
        goto case_123;
      }
#line 599
      if ((int const   )*(str + i) == 91) {
#line 599
        goto case_91;
      }
#line 619
      if ((int const   )*(str + i) == 35) {
#line 619
        goto case_35___2;
      }
#line 624
      if ((int const   )*(str + i) == 67) {
#line 624
        goto case_67___0;
      }
#line 632
      if ((int const   )*(str + i) == 100) {
#line 632
        goto case_100___0;
      }
#line 643
      if ((int const   )*(str + i) == 68) {
#line 643
        goto case_68___0;
      }
#line 670
      if ((int const   )*(str + i) == 101) {
#line 670
        goto case_101___0;
      }
#line 679
      if ((int const   )*(str + i) == 69) {
#line 679
        goto case_69___0;
      }
#line 688
      if ((int const   )*(str + i) == 102) {
#line 688
        goto case_102___0;
      }
#line 692
      if ((int const   )*(str + i) == 70) {
#line 692
        goto case_70___0;
      }
#line 700
      if ((int const   )*(str + i) == 108) {
#line 700
        goto case_108;
      }
#line 730
      if ((int const   )*(str + i) == 78) {
#line 730
        goto case_78___0;
      }
#line 749
      if ((int const   )*(str + i) == 110) {
#line 749
        goto case_110___1;
      }
#line 758
      if ((int const   )*(str + i) == 112) {
#line 758
        goto case_112___0;
      }
#line 814
      if ((int const   )*(str + i) == 113) {
#line 814
        goto case_113___0;
      }
#line 819
      if ((int const   )*(str + i) == 81) {
#line 819
        goto case_81___0;
      }
#line 832
      if ((int const   )*(str + i) == 115) {
#line 832
        goto case_115___0;
      }
#line 873
      if ((int const   )*(str + i) == 116) {
#line 873
        goto case_116___0;
      }
#line 906
      if ((int const   )*(str + i) == 84) {
#line 906
        goto case_84___0;
      }
#line 913
      if ((int const   )*(str + i) == 87) {
#line 913
        goto case_87___0;
      }
#line 921
      goto switch_default___9;
      case_36___0: /* CIL Label */ 
      {
#line 513
      while (1) {
        while_continue___84: /* CIL Label */ ;
#line 513
        if (width) {
#line 513
          if (justification < 0) {
#line 513
            __o___86 = user_string_stack___0;
#line 513
            if ((unsigned long )(__o___86->next_free + 1) > (unsigned long )__o___86->chunk_limit) {
              {
#line 513
              _obstack_newchunk(__o___86, 1);
              }
            }
#line 513
            tmp___125 = __o___86->next_free;
#line 513
            (__o___86->next_free) ++;
#line 513
            *tmp___125 = (char )'$';
          }
        }
#line 513
        a___6 = 0;
        {
#line 513
        while (1) {
          while_continue___85: /* CIL Label */ ;
#line 513
          if (! (a___6 < (int )width - 1)) {
#line 513
            goto while_break___85;
          }
#line 513
          __o___87 = user_string_stack___0;
#line 513
          if ((unsigned long )(__o___87->next_free + 1) > (unsigned long )__o___87->chunk_limit) {
            {
#line 513
            _obstack_newchunk(__o___87, 1);
            }
          }
#line 513
          tmp___126 = __o___87->next_free;
#line 513
          (__o___87->next_free) ++;
#line 513
          *tmp___126 = (char )padding;
#line 513
          a___6 ++;
        }
        while_break___85: /* CIL Label */ ;
        }
#line 513
        if (! width) {
#line 513
          goto _L___6;
        } else
#line 513
        if (justification > 0) {
          _L___6: /* CIL Label */ 
#line 513
          __o___88 = user_string_stack___0;
#line 513
          if ((unsigned long )(__o___88->next_free + 1) > (unsigned long )__o___88->chunk_limit) {
            {
#line 513
            _obstack_newchunk(__o___88, 1);
            }
          }
#line 513
          tmp___127 = __o___88->next_free;
#line 513
          (__o___88->next_free) ++;
#line 513
          *tmp___127 = (char )'$';
        }
#line 513
        goto while_break___84;
      }
      while_break___84: /* CIL Label */ ;
      }
#line 514
      goto switch_break___4;
      case_42___0: /* CIL Label */ 
      {
#line 517
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d:%02d:%02d",
              file->mod_tm.tm_hour, file->mod_tm.tm_min, file->mod_tm.tm_sec);
      }
      {
#line 521
      while (1) {
        while_continue___86: /* CIL Label */ ;
        {
#line 521
        tmp___128 = strlen((char const   *)(buf___0));
#line 521
        len___21 = tmp___128;
        }
#line 521
        if (len___21 > width) {
#line 521
          nspace___21 = (size_t )0;
        } else {
#line 521
          nspace___21 = width - len___21;
        }
#line 521
        if (width) {
#line 521
          if (justification > 0) {
            {
#line 521
            while (1) {
              while_continue___87: /* CIL Label */ ;
#line 521
              if (! nspace___21) {
#line 521
                goto while_break___87;
              }
#line 521
              __o___89 = user_string_stack___0;
#line 521
              if ((unsigned long )(__o___89->next_free + 1) > (unsigned long )__o___89->chunk_limit) {
                {
#line 521
                _obstack_newchunk(__o___89, 1);
                }
              }
#line 521
              tmp___129 = __o___89->next_free;
#line 521
              (__o___89->next_free) ++;
#line 521
              *tmp___129 = (char )padding;
#line 521
              nspace___21 --;
            }
            while_break___87: /* CIL Label */ ;
            }
          }
        }
#line 521
        __o___90 = user_string_stack___0;
#line 521
        __len___21 = (int )len___21;
#line 521
        if ((unsigned long )(__o___90->next_free + __len___21) > (unsigned long )__o___90->chunk_limit) {
          {
#line 521
          _obstack_newchunk(__o___90, __len___21);
          }
        }
        {
#line 521
        memcpy((void */* __restrict  */)__o___90->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___21);
#line 521
        __o___90->next_free += __len___21;
        }
#line 521
        if (width) {
#line 521
          if (justification < 0) {
            {
#line 521
            while (1) {
              while_continue___88: /* CIL Label */ ;
#line 521
              if (! nspace___21) {
#line 521
                goto while_break___88;
              }
#line 521
              __o___91 = user_string_stack___0;
#line 521
              if ((unsigned long )(__o___91->next_free + 1) > (unsigned long )__o___91->chunk_limit) {
                {
#line 521
                _obstack_newchunk(__o___91, 1);
                }
              }
#line 521
              tmp___130 = __o___91->next_free;
#line 521
              (__o___91->next_free) ++;
#line 521
              *tmp___130 = (char )padding;
#line 521
              nspace___21 --;
            }
            while_break___88: /* CIL Label */ ;
            }
          }
        }
#line 521
        goto while_break___86;
      }
      while_break___86: /* CIL Label */ ;
      }
#line 522
      goto switch_break___4;
      case_40: /* CIL Label */ 
#line 525
      j = (size_t )0;
#line 525
      i ++;
      {
#line 525
      while (1) {
        while_continue___89: /* CIL Label */ ;
#line 525
        if (*(str + i)) {
#line 525
          if ((int const   )*(str + i) != 41) {
#line 525
            if (! ((unsigned long )j < sizeof(buf___0) - 1UL)) {
#line 525
              goto while_break___89;
            }
          } else {
#line 525
            goto while_break___89;
          }
        } else {
#line 525
          goto while_break___89;
        }
#line 528
        tmp___131 = j;
#line 528
        j ++;
#line 528
        buf___0[tmp___131] = (unsigned char )*(str + i);
#line 525
        i ++;
      }
      while_break___89: /* CIL Label */ ;
      }
#line 530
      if ((int const   )*(str + i) == 0) {
        {
#line 531
        tmp___132 = gettext("%s: missing `%c\' for %s%c escape");
#line 531
        error(1, 0, (char const   *)tmp___132, context_name, ')', "$(", ')');
        }
      }
#line 533
      if ((int const   )*(str + i) != 41) {
        {
#line 534
        tmp___133 = gettext("%s: too long argument for %s escape");
#line 534
        error(1, 0, (char const   *)tmp___133, context_name, "$()");
        }
      }
      {
#line 536
      buf___0[j] = (unsigned char )'\000';
#line 538
      tmp___134 = getenv((char const   *)((char *)(buf___0)));
#line 538
      cp = (unsigned char *)tmp___134;
      }
#line 539
      if (cp) {
        {
#line 540
        while (1) {
          while_continue___90: /* CIL Label */ ;
          {
#line 540
          tmp___135 = strlen((char const   *)cp);
#line 540
          len___22 = tmp___135;
          }
#line 540
          if (len___22 > width) {
#line 540
            nspace___22 = (size_t )0;
          } else {
#line 540
            nspace___22 = width - len___22;
          }
#line 540
          if (width) {
#line 540
            if (justification > 0) {
              {
#line 540
              while (1) {
                while_continue___91: /* CIL Label */ ;
#line 540
                if (! nspace___22) {
#line 540
                  goto while_break___91;
                }
#line 540
                __o___92 = user_string_stack___0;
#line 540
                if ((unsigned long )(__o___92->next_free + 1) > (unsigned long )__o___92->chunk_limit) {
                  {
#line 540
                  _obstack_newchunk(__o___92, 1);
                  }
                }
#line 540
                tmp___136 = __o___92->next_free;
#line 540
                (__o___92->next_free) ++;
#line 540
                *tmp___136 = (char )padding;
#line 540
                nspace___22 --;
              }
              while_break___91: /* CIL Label */ ;
              }
            }
          }
#line 540
          __o___93 = user_string_stack___0;
#line 540
          __len___22 = (int )len___22;
#line 540
          if ((unsigned long )(__o___93->next_free + __len___22) > (unsigned long )__o___93->chunk_limit) {
            {
#line 540
            _obstack_newchunk(__o___93, __len___22);
            }
          }
          {
#line 540
          memcpy((void */* __restrict  */)__o___93->next_free, (void const   */* __restrict  */)((char *)cp),
                 (size_t )__len___22);
#line 540
          __o___93->next_free += __len___22;
          }
#line 540
          if (width) {
#line 540
            if (justification < 0) {
              {
#line 540
              while (1) {
                while_continue___92: /* CIL Label */ ;
#line 540
                if (! nspace___22) {
#line 540
                  goto while_break___92;
                }
#line 540
                __o___94 = user_string_stack___0;
#line 540
                if ((unsigned long )(__o___94->next_free + 1) > (unsigned long )__o___94->chunk_limit) {
                  {
#line 540
                  _obstack_newchunk(__o___94, 1);
                  }
                }
#line 540
                tmp___137 = __o___94->next_free;
#line 540
                (__o___94->next_free) ++;
#line 540
                *tmp___137 = (char )padding;
#line 540
                nspace___22 --;
              }
              while_break___92: /* CIL Label */ ;
              }
            }
          }
#line 540
          goto while_break___90;
        }
        while_break___90: /* CIL Label */ ;
        }
      }
#line 541
      goto switch_break___4;
      case_123: /* CIL Label */ 
#line 544
      cp2 = (unsigned char *)((void *)0);
#line 545
      j = (size_t )0;
#line 545
      i ++;
      {
#line 545
      while (1) {
        while_continue___93: /* CIL Label */ ;
#line 545
        if ((int const   )*(str + i) != 125) {
#line 545
          if (! ((unsigned long )j < sizeof(buf___0) - 1UL)) {
#line 545
            goto while_break___93;
          }
        } else {
#line 545
          goto while_break___93;
        }
        {
#line 547
        if ((int const   )*(str + i) == 0) {
#line 547
          goto case_0;
        }
#line 552
        if ((int const   )*(str + i) == 58) {
#line 552
          goto case_58;
        }
#line 558
        goto switch_default___3;
        case_0: /* CIL Label */ 
        {
#line 548
        tmp___138 = gettext("%s: missing `%c\' for %s%c escape");
#line 548
        error(1, 0, (char const   *)tmp___138, context_name, '}', "${", '}');
        }
#line 550
        goto switch_break___5;
        case_58: /* CIL Label */ 
#line 554
        tmp___139 = j;
#line 554
        j ++;
#line 554
        buf___0[tmp___139] = (unsigned char )'\000';
#line 555
        cp2 = buf___0 + j;
#line 556
        goto switch_break___5;
        switch_default___3: /* CIL Label */ 
#line 559
        tmp___140 = j;
#line 559
        j ++;
#line 559
        buf___0[tmp___140] = (unsigned char )*(str + i);
#line 560
        goto switch_break___5;
        switch_break___5: /* CIL Label */ ;
        }
#line 545
        i ++;
      }
      while_break___93: /* CIL Label */ ;
      }
#line 562
      if ((int const   )*(str + i) != 125) {
        {
#line 563
        tmp___141 = gettext("%s: too long argument for %s escape");
#line 563
        error(1, 0, (char const   *)tmp___141, context_name, "${}");
        }
      }
      {
#line 565
      buf___0[j] = (unsigned char )'\000';
#line 568
      tmp___142 = getenv((char const   *)((char *)(buf___0)));
#line 568
      cp = (unsigned char *)tmp___142;
      }
#line 569
      if ((unsigned long )((char const   *)cp2) == (unsigned long )((void *)0)) {
#line 569
        goto _L___8;
      } else
#line 569
      if ((int )*cp2 == 0) {
        _L___8: /* CIL Label */ 
#line 572
        if (cp) {
          {
#line 573
          while (1) {
            while_continue___94: /* CIL Label */ ;
            {
#line 573
            tmp___143 = strlen((char const   *)cp);
#line 573
            len___23 = tmp___143;
            }
#line 573
            if (len___23 > width) {
#line 573
              nspace___23 = (size_t )0;
            } else {
#line 573
              nspace___23 = width - len___23;
            }
#line 573
            if (width) {
#line 573
              if (justification > 0) {
                {
#line 573
                while (1) {
                  while_continue___95: /* CIL Label */ ;
#line 573
                  if (! nspace___23) {
#line 573
                    goto while_break___95;
                  }
#line 573
                  __o___95 = user_string_stack___0;
#line 573
                  if ((unsigned long )(__o___95->next_free + 1) > (unsigned long )__o___95->chunk_limit) {
                    {
#line 573
                    _obstack_newchunk(__o___95, 1);
                    }
                  }
#line 573
                  tmp___144 = __o___95->next_free;
#line 573
                  (__o___95->next_free) ++;
#line 573
                  *tmp___144 = (char )padding;
#line 573
                  nspace___23 --;
                }
                while_break___95: /* CIL Label */ ;
                }
              }
            }
#line 573
            __o___96 = user_string_stack___0;
#line 573
            __len___23 = (int )len___23;
#line 573
            if ((unsigned long )(__o___96->next_free + __len___23) > (unsigned long )__o___96->chunk_limit) {
              {
#line 573
              _obstack_newchunk(__o___96, __len___23);
              }
            }
            {
#line 573
            memcpy((void */* __restrict  */)__o___96->next_free, (void const   */* __restrict  */)((char *)cp),
                   (size_t )__len___23);
#line 573
            __o___96->next_free += __len___23;
            }
#line 573
            if (width) {
#line 573
              if (justification < 0) {
                {
#line 573
                while (1) {
                  while_continue___96: /* CIL Label */ ;
#line 573
                  if (! nspace___23) {
#line 573
                    goto while_break___96;
                  }
#line 573
                  __o___97 = user_string_stack___0;
#line 573
                  if ((unsigned long )(__o___97->next_free + 1) > (unsigned long )__o___97->chunk_limit) {
                    {
#line 573
                    _obstack_newchunk(__o___97, 1);
                    }
                  }
#line 573
                  tmp___145 = __o___97->next_free;
#line 573
                  (__o___97->next_free) ++;
#line 573
                  *tmp___145 = (char )padding;
#line 573
                  nspace___23 --;
                }
                while_break___96: /* CIL Label */ ;
                }
              }
            }
#line 573
            goto while_break___94;
          }
          while_break___94: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 579
        if ((int )*cp2 == 45) {
#line 579
          goto case_45;
        }
#line 586
        if ((int )*cp2 == 43) {
#line 586
          goto case_43;
        }
#line 591
        goto switch_default___4;
        case_45: /* CIL Label */ 
#line 580
        if ((unsigned long )((char const   *)cp) == (unsigned long )((void *)0)) {
#line 580
          goto _L___7;
        } else
#line 580
        if ((int )*cp == 0) {
          _L___7: /* CIL Label */ 
          {
#line 583
          while (1) {
            while_continue___97: /* CIL Label */ ;
            {
#line 583
            tmp___149 = strlen((char const   *)(cp2 + 1));
#line 583
            len___25 = tmp___149;
            }
#line 583
            if (len___25 > width) {
#line 583
              nspace___25 = (size_t )0;
            } else {
#line 583
              nspace___25 = width - len___25;
            }
#line 583
            if (width) {
#line 583
              if (justification > 0) {
                {
#line 583
                while (1) {
                  while_continue___98: /* CIL Label */ ;
#line 583
                  if (! nspace___25) {
#line 583
                    goto while_break___98;
                  }
#line 583
                  __o___101 = user_string_stack___0;
#line 583
                  if ((unsigned long )(__o___101->next_free + 1) > (unsigned long )__o___101->chunk_limit) {
                    {
#line 583
                    _obstack_newchunk(__o___101, 1);
                    }
                  }
#line 583
                  tmp___150 = __o___101->next_free;
#line 583
                  (__o___101->next_free) ++;
#line 583
                  *tmp___150 = (char )padding;
#line 583
                  nspace___25 --;
                }
                while_break___98: /* CIL Label */ ;
                }
              }
            }
#line 583
            __o___102 = user_string_stack___0;
#line 583
            __len___25 = (int )len___25;
#line 583
            if ((unsigned long )(__o___102->next_free + __len___25) > (unsigned long )__o___102->chunk_limit) {
              {
#line 583
              _obstack_newchunk(__o___102, __len___25);
              }
            }
            {
#line 583
            memcpy((void */* __restrict  */)__o___102->next_free, (void const   */* __restrict  */)((char *)(cp2 + 1)),
                   (size_t )__len___25);
#line 583
            __o___102->next_free += __len___25;
            }
#line 583
            if (width) {
#line 583
              if (justification < 0) {
                {
#line 583
                while (1) {
                  while_continue___99: /* CIL Label */ ;
#line 583
                  if (! nspace___25) {
#line 583
                    goto while_break___99;
                  }
#line 583
                  __o___103 = user_string_stack___0;
#line 583
                  if ((unsigned long )(__o___103->next_free + 1) > (unsigned long )__o___103->chunk_limit) {
                    {
#line 583
                    _obstack_newchunk(__o___103, 1);
                    }
                  }
#line 583
                  tmp___151 = __o___103->next_free;
#line 583
                  (__o___103->next_free) ++;
#line 583
                  *tmp___151 = (char )padding;
#line 583
                  nspace___25 --;
                }
                while_break___99: /* CIL Label */ ;
                }
              }
            }
#line 583
            goto while_break___97;
          }
          while_break___97: /* CIL Label */ ;
          }
        } else {
          {
#line 581
          while (1) {
            while_continue___100: /* CIL Label */ ;
            {
#line 581
            tmp___146 = strlen((char const   *)cp);
#line 581
            len___24 = tmp___146;
            }
#line 581
            if (len___24 > width) {
#line 581
              nspace___24 = (size_t )0;
            } else {
#line 581
              nspace___24 = width - len___24;
            }
#line 581
            if (width) {
#line 581
              if (justification > 0) {
                {
#line 581
                while (1) {
                  while_continue___101: /* CIL Label */ ;
#line 581
                  if (! nspace___24) {
#line 581
                    goto while_break___101;
                  }
#line 581
                  __o___98 = user_string_stack___0;
#line 581
                  if ((unsigned long )(__o___98->next_free + 1) > (unsigned long )__o___98->chunk_limit) {
                    {
#line 581
                    _obstack_newchunk(__o___98, 1);
                    }
                  }
#line 581
                  tmp___147 = __o___98->next_free;
#line 581
                  (__o___98->next_free) ++;
#line 581
                  *tmp___147 = (char )padding;
#line 581
                  nspace___24 --;
                }
                while_break___101: /* CIL Label */ ;
                }
              }
            }
#line 581
            __o___99 = user_string_stack___0;
#line 581
            __len___24 = (int )len___24;
#line 581
            if ((unsigned long )(__o___99->next_free + __len___24) > (unsigned long )__o___99->chunk_limit) {
              {
#line 581
              _obstack_newchunk(__o___99, __len___24);
              }
            }
            {
#line 581
            memcpy((void */* __restrict  */)__o___99->next_free, (void const   */* __restrict  */)((char *)cp),
                   (size_t )__len___24);
#line 581
            __o___99->next_free += __len___24;
            }
#line 581
            if (width) {
#line 581
              if (justification < 0) {
                {
#line 581
                while (1) {
                  while_continue___102: /* CIL Label */ ;
#line 581
                  if (! nspace___24) {
#line 581
                    goto while_break___102;
                  }
#line 581
                  __o___100 = user_string_stack___0;
#line 581
                  if ((unsigned long )(__o___100->next_free + 1) > (unsigned long )__o___100->chunk_limit) {
                    {
#line 581
                    _obstack_newchunk(__o___100, 1);
                    }
                  }
#line 581
                  tmp___148 = __o___100->next_free;
#line 581
                  (__o___100->next_free) ++;
#line 581
                  *tmp___148 = (char )padding;
#line 581
                  nspace___24 --;
                }
                while_break___102: /* CIL Label */ ;
                }
              }
            }
#line 581
            goto while_break___100;
          }
          while_break___100: /* CIL Label */ ;
          }
        }
#line 584
        goto switch_break___6;
        case_43: /* CIL Label */ 
#line 587
        if (! ((unsigned long )((char const   *)cp) == (unsigned long )((void *)0))) {
#line 587
          if (! ((int )*cp == 0)) {
            {
#line 588
            while (1) {
              while_continue___103: /* CIL Label */ ;
              {
#line 588
              tmp___152 = strlen((char const   *)(cp2 + 1));
#line 588
              len___26 = tmp___152;
              }
#line 588
              if (len___26 > width) {
#line 588
                nspace___26 = (size_t )0;
              } else {
#line 588
                nspace___26 = width - len___26;
              }
#line 588
              if (width) {
#line 588
                if (justification > 0) {
                  {
#line 588
                  while (1) {
                    while_continue___104: /* CIL Label */ ;
#line 588
                    if (! nspace___26) {
#line 588
                      goto while_break___104;
                    }
#line 588
                    __o___104 = user_string_stack___0;
#line 588
                    if ((unsigned long )(__o___104->next_free + 1) > (unsigned long )__o___104->chunk_limit) {
                      {
#line 588
                      _obstack_newchunk(__o___104, 1);
                      }
                    }
#line 588
                    tmp___153 = __o___104->next_free;
#line 588
                    (__o___104->next_free) ++;
#line 588
                    *tmp___153 = (char )padding;
#line 588
                    nspace___26 --;
                  }
                  while_break___104: /* CIL Label */ ;
                  }
                }
              }
#line 588
              __o___105 = user_string_stack___0;
#line 588
              __len___26 = (int )len___26;
#line 588
              if ((unsigned long )(__o___105->next_free + __len___26) > (unsigned long )__o___105->chunk_limit) {
                {
#line 588
                _obstack_newchunk(__o___105, __len___26);
                }
              }
              {
#line 588
              memcpy((void */* __restrict  */)__o___105->next_free, (void const   */* __restrict  */)((char *)(cp2 + 1)),
                     (size_t )__len___26);
#line 588
              __o___105->next_free += __len___26;
              }
#line 588
              if (width) {
#line 588
                if (justification < 0) {
                  {
#line 588
                  while (1) {
                    while_continue___105: /* CIL Label */ ;
#line 588
                    if (! nspace___26) {
#line 588
                      goto while_break___105;
                    }
#line 588
                    __o___106 = user_string_stack___0;
#line 588
                    if ((unsigned long )(__o___106->next_free + 1) > (unsigned long )__o___106->chunk_limit) {
                      {
#line 588
                      _obstack_newchunk(__o___106, 1);
                      }
                    }
#line 588
                    tmp___154 = __o___106->next_free;
#line 588
                    (__o___106->next_free) ++;
#line 588
                    *tmp___154 = (char )padding;
#line 588
                    nspace___26 --;
                  }
                  while_break___105: /* CIL Label */ ;
                  }
                }
              }
#line 588
              goto while_break___103;
            }
            while_break___103: /* CIL Label */ ;
            }
          }
        }
#line 589
        goto switch_break___6;
        switch_default___4: /* CIL Label */ 
        {
#line 592
        tmp___155 = gettext("%s: invalid separator `%s%c\' for `%s\' escape");
#line 592
        error(1, 0, (char const   *)tmp___155, context_name, ":", (int )*cp2, "${}");
        }
        switch_break___6: /* CIL Label */ ;
        }
      }
#line 597
      goto switch_break___4;
      case_91: /* CIL Label */ 
      {
#line 600
      tmp___157 = __ctype_b_loc();
      }
#line 600
      if (! ((int const   )*(*tmp___157 + (int )*(str + i)) & 2048)) {
        {
#line 601
        tmp___156 = gettext("%s: invalid argument for %s%c escape");
#line 601
        error(1, 0, (char const   *)tmp___156, context_name, "$[", ']');
        }
      }
#line 604
      value = (size_t )0;
      {
#line 605
      while (1) {
        while_continue___106: /* CIL Label */ ;
        {
#line 605
        tmp___159 = __ctype_b_loc();
        }
#line 605
        if (! ((int const   )*(*tmp___159 + (int )*(str + i)) & 2048)) {
#line 605
          goto while_break___106;
        }
#line 606
        tmp___158 = i;
#line 606
        i ++;
#line 606
        value = (value * 10U + (size_t )*(str + tmp___158)) - 48U;
      }
      while_break___106: /* CIL Label */ ;
      }
#line 607
      if ((int const   )*(str + i) == 0) {
        {
#line 608
        tmp___160 = gettext("%s: missing `%c\' for %s%c escape");
#line 608
        error(1, 0, (char const   *)tmp___160, context_name, ']', "$[", ']');
        }
      }
#line 610
      if ((int const   )*(str + i) != 93) {
        {
#line 611
        tmp___161 = gettext("%s: invalid argument for %s%c escape");
#line 611
        error(1, 0, (char const   *)tmp___161, context_name, "$[", ']');
        }
      }
#line 614
      if (value < job___0->argc) {
        {
#line 615
        while (1) {
          while_continue___107: /* CIL Label */ ;
          {
#line 615
          tmp___162 = strlen((char const   *)*(job___0->argv + value));
#line 615
          len___27 = tmp___162;
          }
#line 615
          if (len___27 > width) {
#line 615
            nspace___27 = (size_t )0;
          } else {
#line 615
            nspace___27 = width - len___27;
          }
#line 615
          if (width) {
#line 615
            if (justification > 0) {
              {
#line 615
              while (1) {
                while_continue___108: /* CIL Label */ ;
#line 615
                if (! nspace___27) {
#line 615
                  goto while_break___108;
                }
#line 615
                __o___107 = user_string_stack___0;
#line 615
                if ((unsigned long )(__o___107->next_free + 1) > (unsigned long )__o___107->chunk_limit) {
                  {
#line 615
                  _obstack_newchunk(__o___107, 1);
                  }
                }
#line 615
                tmp___163 = __o___107->next_free;
#line 615
                (__o___107->next_free) ++;
#line 615
                *tmp___163 = (char )padding;
#line 615
                nspace___27 --;
              }
              while_break___108: /* CIL Label */ ;
              }
            }
          }
#line 615
          __o___108 = user_string_stack___0;
#line 615
          __len___27 = (int )len___27;
#line 615
          if ((unsigned long )(__o___108->next_free + __len___27) > (unsigned long )__o___108->chunk_limit) {
            {
#line 615
            _obstack_newchunk(__o___108, __len___27);
            }
          }
          {
#line 615
          memcpy((void */* __restrict  */)__o___108->next_free, (void const   */* __restrict  */)*(job___0->argv + value),
                 (size_t )__len___27);
#line 615
          __o___108->next_free += __len___27;
          }
#line 615
          if (width) {
#line 615
            if (justification < 0) {
              {
#line 615
              while (1) {
                while_continue___109: /* CIL Label */ ;
#line 615
                if (! nspace___27) {
#line 615
                  goto while_break___109;
                }
#line 615
                __o___109 = user_string_stack___0;
#line 615
                if ((unsigned long )(__o___109->next_free + 1) > (unsigned long )__o___109->chunk_limit) {
                  {
#line 615
                  _obstack_newchunk(__o___109, 1);
                  }
                }
#line 615
                tmp___164 = __o___109->next_free;
#line 615
                (__o___109->next_free) ++;
#line 615
                *tmp___164 = (char )padding;
#line 615
                nspace___27 --;
              }
              while_break___109: /* CIL Label */ ;
              }
            }
          }
#line 615
          goto while_break___107;
        }
        while_break___107: /* CIL Label */ ;
        }
      }
#line 617
      goto switch_break___4;
      case_35___2: /* CIL Label */ 
      {
#line 620
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              file->num);
      }
      {
#line 621
      while (1) {
        while_continue___110: /* CIL Label */ ;
        {
#line 621
        tmp___165 = strlen((char const   *)(buf___0));
#line 621
        len___28 = tmp___165;
        }
#line 621
        if (len___28 > width) {
#line 621
          nspace___28 = (size_t )0;
        } else {
#line 621
          nspace___28 = width - len___28;
        }
#line 621
        if (width) {
#line 621
          if (justification > 0) {
            {
#line 621
            while (1) {
              while_continue___111: /* CIL Label */ ;
#line 621
              if (! nspace___28) {
#line 621
                goto while_break___111;
              }
#line 621
              __o___110 = user_string_stack___0;
#line 621
              if ((unsigned long )(__o___110->next_free + 1) > (unsigned long )__o___110->chunk_limit) {
                {
#line 621
                _obstack_newchunk(__o___110, 1);
                }
              }
#line 621
              tmp___166 = __o___110->next_free;
#line 621
              (__o___110->next_free) ++;
#line 621
              *tmp___166 = (char )padding;
#line 621
              nspace___28 --;
            }
            while_break___111: /* CIL Label */ ;
            }
          }
        }
#line 621
        __o___111 = user_string_stack___0;
#line 621
        __len___28 = (int )len___28;
#line 621
        if ((unsigned long )(__o___111->next_free + __len___28) > (unsigned long )__o___111->chunk_limit) {
          {
#line 621
          _obstack_newchunk(__o___111, __len___28);
          }
        }
        {
#line 621
        memcpy((void */* __restrict  */)__o___111->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___28);
#line 621
        __o___111->next_free += __len___28;
        }
#line 621
        if (width) {
#line 621
          if (justification < 0) {
            {
#line 621
            while (1) {
              while_continue___112: /* CIL Label */ ;
#line 621
              if (! nspace___28) {
#line 621
                goto while_break___112;
              }
#line 621
              __o___112 = user_string_stack___0;
#line 621
              if ((unsigned long )(__o___112->next_free + 1) > (unsigned long )__o___112->chunk_limit) {
                {
#line 621
                _obstack_newchunk(__o___112, 1);
                }
              }
#line 621
              tmp___167 = __o___112->next_free;
#line 621
              (__o___112->next_free) ++;
#line 621
              *tmp___167 = (char )padding;
#line 621
              nspace___28 --;
            }
            while_break___112: /* CIL Label */ ;
            }
          }
        }
#line 621
        goto while_break___110;
      }
      while_break___110: /* CIL Label */ ;
      }
#line 622
      goto switch_break___4;
      case_67___0: /* CIL Label */ 
      {
#line 625
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d:%02d:%02d",
              file->mod_tm.tm_hour, file->mod_tm.tm_min, file->mod_tm.tm_sec);
      }
      {
#line 629
      while (1) {
        while_continue___113: /* CIL Label */ ;
        {
#line 629
        tmp___168 = strlen((char const   *)(buf___0));
#line 629
        len___29 = tmp___168;
        }
#line 629
        if (len___29 > width) {
#line 629
          nspace___29 = (size_t )0;
        } else {
#line 629
          nspace___29 = width - len___29;
        }
#line 629
        if (width) {
#line 629
          if (justification > 0) {
            {
#line 629
            while (1) {
              while_continue___114: /* CIL Label */ ;
#line 629
              if (! nspace___29) {
#line 629
                goto while_break___114;
              }
#line 629
              __o___113 = user_string_stack___0;
#line 629
              if ((unsigned long )(__o___113->next_free + 1) > (unsigned long )__o___113->chunk_limit) {
                {
#line 629
                _obstack_newchunk(__o___113, 1);
                }
              }
#line 629
              tmp___169 = __o___113->next_free;
#line 629
              (__o___113->next_free) ++;
#line 629
              *tmp___169 = (char )padding;
#line 629
              nspace___29 --;
            }
            while_break___114: /* CIL Label */ ;
            }
          }
        }
#line 629
        __o___114 = user_string_stack___0;
#line 629
        __len___29 = (int )len___29;
#line 629
        if ((unsigned long )(__o___114->next_free + __len___29) > (unsigned long )__o___114->chunk_limit) {
          {
#line 629
          _obstack_newchunk(__o___114, __len___29);
          }
        }
        {
#line 629
        memcpy((void */* __restrict  */)__o___114->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___29);
#line 629
        __o___114->next_free += __len___29;
        }
#line 629
        if (width) {
#line 629
          if (justification < 0) {
            {
#line 629
            while (1) {
              while_continue___115: /* CIL Label */ ;
#line 629
              if (! nspace___29) {
#line 629
                goto while_break___115;
              }
#line 629
              __o___115 = user_string_stack___0;
#line 629
              if ((unsigned long )(__o___115->next_free + 1) > (unsigned long )__o___115->chunk_limit) {
                {
#line 629
                _obstack_newchunk(__o___115, 1);
                }
              }
#line 629
              tmp___170 = __o___115->next_free;
#line 629
              (__o___115->next_free) ++;
#line 629
              *tmp___170 = (char )padding;
#line 629
              nspace___29 --;
            }
            while_break___115: /* CIL Label */ ;
            }
          }
        }
#line 629
        goto while_break___113;
      }
      while_break___113: /* CIL Label */ ;
      }
#line 630
      goto switch_break___4;
      case_100___0: /* CIL Label */ 
      {
#line 633
      tmp___171 = strrchr((char const   *)((char *)file->name), '/');
#line 633
      cp = (unsigned char *)tmp___171;
      }
#line 634
      if (cp) {
        {
#line 635
        strncpy((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)((char const   *)file->name),
                (size_t )(cp - file->name));
#line 636
        buf___0[cp - file->name] = (unsigned char )'\000';
        }
        {
#line 637
        while (1) {
          while_continue___116: /* CIL Label */ ;
          {
#line 637
          tmp___172 = strlen((char const   *)(buf___0));
#line 637
          len___30 = tmp___172;
          }
#line 637
          if (len___30 > width) {
#line 637
            nspace___30 = (size_t )0;
          } else {
#line 637
            nspace___30 = width - len___30;
          }
#line 637
          if (width) {
#line 637
            if (justification > 0) {
              {
#line 637
              while (1) {
                while_continue___117: /* CIL Label */ ;
#line 637
                if (! nspace___30) {
#line 637
                  goto while_break___117;
                }
#line 637
                __o___116 = user_string_stack___0;
#line 637
                if ((unsigned long )(__o___116->next_free + 1) > (unsigned long )__o___116->chunk_limit) {
                  {
#line 637
                  _obstack_newchunk(__o___116, 1);
                  }
                }
#line 637
                tmp___173 = __o___116->next_free;
#line 637
                (__o___116->next_free) ++;
#line 637
                *tmp___173 = (char )padding;
#line 637
                nspace___30 --;
              }
              while_break___117: /* CIL Label */ ;
              }
            }
          }
#line 637
          __o___117 = user_string_stack___0;
#line 637
          __len___30 = (int )len___30;
#line 637
          if ((unsigned long )(__o___117->next_free + __len___30) > (unsigned long )__o___117->chunk_limit) {
            {
#line 637
            _obstack_newchunk(__o___117, __len___30);
            }
          }
          {
#line 637
          memcpy((void */* __restrict  */)__o___117->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
                 (size_t )__len___30);
#line 637
          __o___117->next_free += __len___30;
          }
#line 637
          if (width) {
#line 637
            if (justification < 0) {
              {
#line 637
              while (1) {
                while_continue___118: /* CIL Label */ ;
#line 637
                if (! nspace___30) {
#line 637
                  goto while_break___118;
                }
#line 637
                __o___118 = user_string_stack___0;
#line 637
                if ((unsigned long )(__o___118->next_free + 1) > (unsigned long )__o___118->chunk_limit) {
                  {
#line 637
                  _obstack_newchunk(__o___118, 1);
                  }
                }
#line 637
                tmp___174 = __o___118->next_free;
#line 637
                (__o___118->next_free) ++;
#line 637
                *tmp___174 = (char )padding;
#line 637
                nspace___30 --;
              }
              while_break___118: /* CIL Label */ ;
              }
            }
          }
#line 637
          goto while_break___116;
        }
        while_break___116: /* CIL Label */ ;
        }
      } else {
        {
#line 639
        while (1) {
          while_continue___119: /* CIL Label */ ;
#line 639
          if (width) {
#line 639
            if (justification < 0) {
#line 639
              __o___119 = user_string_stack___0;
#line 639
              if ((unsigned long )(__o___119->next_free + 1) > (unsigned long )__o___119->chunk_limit) {
                {
#line 639
                _obstack_newchunk(__o___119, 1);
                }
              }
#line 639
              tmp___175 = __o___119->next_free;
#line 639
              (__o___119->next_free) ++;
#line 639
              *tmp___175 = (char )'.';
            }
          }
#line 639
          a___7 = 0;
          {
#line 639
          while (1) {
            while_continue___120: /* CIL Label */ ;
#line 639
            if (! (a___7 < (int )width - 1)) {
#line 639
              goto while_break___120;
            }
#line 639
            __o___120 = user_string_stack___0;
#line 639
            if ((unsigned long )(__o___120->next_free + 1) > (unsigned long )__o___120->chunk_limit) {
              {
#line 639
              _obstack_newchunk(__o___120, 1);
              }
            }
#line 639
            tmp___176 = __o___120->next_free;
#line 639
            (__o___120->next_free) ++;
#line 639
            *tmp___176 = (char )padding;
#line 639
            a___7 ++;
          }
          while_break___120: /* CIL Label */ ;
          }
#line 639
          if (! width) {
#line 639
            goto _L___9;
          } else
#line 639
          if (justification > 0) {
            _L___9: /* CIL Label */ 
#line 639
            __o___121 = user_string_stack___0;
#line 639
            if ((unsigned long )(__o___121->next_free + 1) > (unsigned long )__o___121->chunk_limit) {
              {
#line 639
              _obstack_newchunk(__o___121, 1);
              }
            }
#line 639
            tmp___177 = __o___121->next_free;
#line 639
            (__o___121->next_free) ++;
#line 639
            *tmp___177 = (char )'.';
          }
#line 639
          goto while_break___119;
        }
        while_break___119: /* CIL Label */ ;
        }
      }
#line 641
      goto switch_break___4;
      case_68___0: /* CIL Label */ 
#line 644
      if ((int const   )*(str + (i + 1U)) == 123) {
#line 647
        j = (size_t )0;
#line 647
        i += 2U;
        {
#line 647
        while (1) {
          while_continue___121: /* CIL Label */ ;
#line 647
          if ((unsigned long )j < sizeof(buf2)) {
#line 647
            if (*(str + i)) {
#line 647
              if (! ((int const   )*(str + i) != 125)) {
#line 647
                goto while_break___121;
              }
            } else {
#line 647
              goto while_break___121;
            }
          } else {
#line 647
            goto while_break___121;
          }
#line 650
          buf2[j] = (unsigned char )*(str + i);
#line 647
          i ++;
#line 647
          j ++;
        }
        while_break___121: /* CIL Label */ ;
        }
#line 651
        if ((int const   )*(str + i) != 125) {
          {
#line 652
          tmp___178 = gettext("%s: too long argument for %s escape");
#line 652
          error(1, 0, (char const   *)tmp___178, context_name, "$D{}");
          }
        }
        {
#line 655
        buf2[j] = (unsigned char )'\000';
#line 656
        strftime((char */* __restrict  */)((char *)(buf___0)), (size_t )sizeof(buf___0),
                 (char const   */* __restrict  */)((char *)(buf2)), (struct tm  const  */* __restrict  */)(& file->mod_tm));
        }
      } else {
        {
#line 662
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%02d-%02d-%02d",
                file->mod_tm.tm_year % 100, file->mod_tm.tm_mon + 1, file->mod_tm.tm_mday);
        }
      }
      {
#line 667
      while (1) {
        while_continue___122: /* CIL Label */ ;
        {
#line 667
        tmp___179 = strlen((char const   *)(buf___0));
#line 667
        len___31 = tmp___179;
        }
#line 667
        if (len___31 > width) {
#line 667
          nspace___31 = (size_t )0;
        } else {
#line 667
          nspace___31 = width - len___31;
        }
#line 667
        if (width) {
#line 667
          if (justification > 0) {
            {
#line 667
            while (1) {
              while_continue___123: /* CIL Label */ ;
#line 667
              if (! nspace___31) {
#line 667
                goto while_break___123;
              }
#line 667
              __o___122 = user_string_stack___0;
#line 667
              if ((unsigned long )(__o___122->next_free + 1) > (unsigned long )__o___122->chunk_limit) {
                {
#line 667
                _obstack_newchunk(__o___122, 1);
                }
              }
#line 667
              tmp___180 = __o___122->next_free;
#line 667
              (__o___122->next_free) ++;
#line 667
              *tmp___180 = (char )padding;
#line 667
              nspace___31 --;
            }
            while_break___123: /* CIL Label */ ;
            }
          }
        }
#line 667
        __o___123 = user_string_stack___0;
#line 667
        __len___31 = (int )len___31;
#line 667
        if ((unsigned long )(__o___123->next_free + __len___31) > (unsigned long )__o___123->chunk_limit) {
          {
#line 667
          _obstack_newchunk(__o___123, __len___31);
          }
        }
        {
#line 667
        memcpy((void */* __restrict  */)__o___123->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___31);
#line 667
        __o___123->next_free += __len___31;
        }
#line 667
        if (width) {
#line 667
          if (justification < 0) {
            {
#line 667
            while (1) {
              while_continue___124: /* CIL Label */ ;
#line 667
              if (! nspace___31) {
#line 667
                goto while_break___124;
              }
#line 667
              __o___124 = user_string_stack___0;
#line 667
              if ((unsigned long )(__o___124->next_free + 1) > (unsigned long )__o___124->chunk_limit) {
                {
#line 667
                _obstack_newchunk(__o___124, 1);
                }
              }
#line 667
              tmp___181 = __o___124->next_free;
#line 667
              (__o___124->next_free) ++;
#line 667
              *tmp___181 = (char )padding;
#line 667
              nspace___31 --;
            }
            while_break___124: /* CIL Label */ ;
            }
          }
        }
#line 667
        goto while_break___122;
      }
      while_break___122: /* CIL Label */ ;
      }
#line 668
      goto switch_break___4;
      case_101___0: /* CIL Label */ 
      {
#line 674
      tmp___182 = gettext("%b %d, %y");
#line 674
      strftime((char */* __restrict  */)((char *)(buf___0)), (size_t )sizeof(buf___0),
               (char const   */* __restrict  */)tmp___182, (struct tm  const  */* __restrict  */)(& file->mod_tm));
      }
      {
#line 676
      while (1) {
        while_continue___125: /* CIL Label */ ;
        {
#line 676
        tmp___183 = strlen((char const   *)(buf___0));
#line 676
        len___32 = tmp___183;
        }
#line 676
        if (len___32 > width) {
#line 676
          nspace___32 = (size_t )0;
        } else {
#line 676
          nspace___32 = width - len___32;
        }
#line 676
        if (width) {
#line 676
          if (justification > 0) {
            {
#line 676
            while (1) {
              while_continue___126: /* CIL Label */ ;
#line 676
              if (! nspace___32) {
#line 676
                goto while_break___126;
              }
#line 676
              __o___125 = user_string_stack___0;
#line 676
              if ((unsigned long )(__o___125->next_free + 1) > (unsigned long )__o___125->chunk_limit) {
                {
#line 676
                _obstack_newchunk(__o___125, 1);
                }
              }
#line 676
              tmp___184 = __o___125->next_free;
#line 676
              (__o___125->next_free) ++;
#line 676
              *tmp___184 = (char )padding;
#line 676
              nspace___32 --;
            }
            while_break___126: /* CIL Label */ ;
            }
          }
        }
#line 676
        __o___126 = user_string_stack___0;
#line 676
        __len___32 = (int )len___32;
#line 676
        if ((unsigned long )(__o___126->next_free + __len___32) > (unsigned long )__o___126->chunk_limit) {
          {
#line 676
          _obstack_newchunk(__o___126, __len___32);
          }
        }
        {
#line 676
        memcpy((void */* __restrict  */)__o___126->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___32);
#line 676
        __o___126->next_free += __len___32;
        }
#line 676
        if (width) {
#line 676
          if (justification < 0) {
            {
#line 676
            while (1) {
              while_continue___127: /* CIL Label */ ;
#line 676
              if (! nspace___32) {
#line 676
                goto while_break___127;
              }
#line 676
              __o___127 = user_string_stack___0;
#line 676
              if ((unsigned long )(__o___127->next_free + 1) > (unsigned long )__o___127->chunk_limit) {
                {
#line 676
                _obstack_newchunk(__o___127, 1);
                }
              }
#line 676
              tmp___185 = __o___127->next_free;
#line 676
              (__o___127->next_free) ++;
#line 676
              *tmp___185 = (char )padding;
#line 676
              nspace___32 --;
            }
            while_break___127: /* CIL Label */ ;
            }
          }
        }
#line 676
        goto while_break___125;
      }
      while_break___125: /* CIL Label */ ;
      }
#line 677
      goto switch_break___4;
      case_69___0: /* CIL Label */ 
      {
#line 680
      tmp___186 = gettext("%A %B %d, %Y");
#line 680
      strftime((char */* __restrict  */)((char *)(buf___0)), (size_t )sizeof(buf___0),
               (char const   */* __restrict  */)tmp___186, (struct tm  const  */* __restrict  */)(& file->mod_tm));
      }
      {
#line 685
      while (1) {
        while_continue___128: /* CIL Label */ ;
        {
#line 685
        tmp___187 = strlen((char const   *)(buf___0));
#line 685
        len___33 = tmp___187;
        }
#line 685
        if (len___33 > width) {
#line 685
          nspace___33 = (size_t )0;
        } else {
#line 685
          nspace___33 = width - len___33;
        }
#line 685
        if (width) {
#line 685
          if (justification > 0) {
            {
#line 685
            while (1) {
              while_continue___129: /* CIL Label */ ;
#line 685
              if (! nspace___33) {
#line 685
                goto while_break___129;
              }
#line 685
              __o___128 = user_string_stack___0;
#line 685
              if ((unsigned long )(__o___128->next_free + 1) > (unsigned long )__o___128->chunk_limit) {
                {
#line 685
                _obstack_newchunk(__o___128, 1);
                }
              }
#line 685
              tmp___188 = __o___128->next_free;
#line 685
              (__o___128->next_free) ++;
#line 685
              *tmp___188 = (char )padding;
#line 685
              nspace___33 --;
            }
            while_break___129: /* CIL Label */ ;
            }
          }
        }
#line 685
        __o___129 = user_string_stack___0;
#line 685
        __len___33 = (int )len___33;
#line 685
        if ((unsigned long )(__o___129->next_free + __len___33) > (unsigned long )__o___129->chunk_limit) {
          {
#line 685
          _obstack_newchunk(__o___129, __len___33);
          }
        }
        {
#line 685
        memcpy((void */* __restrict  */)__o___129->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___33);
#line 685
        __o___129->next_free += __len___33;
        }
#line 685
        if (width) {
#line 685
          if (justification < 0) {
            {
#line 685
            while (1) {
              while_continue___130: /* CIL Label */ ;
#line 685
              if (! nspace___33) {
#line 685
                goto while_break___130;
              }
#line 685
              __o___130 = user_string_stack___0;
#line 685
              if ((unsigned long )(__o___130->next_free + 1) > (unsigned long )__o___130->chunk_limit) {
                {
#line 685
                _obstack_newchunk(__o___130, 1);
                }
              }
#line 685
              tmp___189 = __o___130->next_free;
#line 685
              (__o___130->next_free) ++;
#line 685
              *tmp___189 = (char )padding;
#line 685
              nspace___33 --;
            }
            while_break___130: /* CIL Label */ ;
            }
          }
        }
#line 685
        goto while_break___128;
      }
      while_break___128: /* CIL Label */ ;
      }
#line 686
      goto switch_break___4;
      case_102___0: /* CIL Label */ 
      {
#line 689
      while (1) {
        while_continue___131: /* CIL Label */ ;
        {
#line 689
        tmp___190 = strlen((char const   *)file->name);
#line 689
        len___34 = tmp___190;
        }
#line 689
        if (len___34 > width) {
#line 689
          nspace___34 = (size_t )0;
        } else {
#line 689
          nspace___34 = width - len___34;
        }
#line 689
        if (width) {
#line 689
          if (justification > 0) {
            {
#line 689
            while (1) {
              while_continue___132: /* CIL Label */ ;
#line 689
              if (! nspace___34) {
#line 689
                goto while_break___132;
              }
#line 689
              __o___131 = user_string_stack___0;
#line 689
              if ((unsigned long )(__o___131->next_free + 1) > (unsigned long )__o___131->chunk_limit) {
                {
#line 689
                _obstack_newchunk(__o___131, 1);
                }
              }
#line 689
              tmp___191 = __o___131->next_free;
#line 689
              (__o___131->next_free) ++;
#line 689
              *tmp___191 = (char )padding;
#line 689
              nspace___34 --;
            }
            while_break___132: /* CIL Label */ ;
            }
          }
        }
#line 689
        __o___132 = user_string_stack___0;
#line 689
        __len___34 = (int )len___34;
#line 689
        if ((unsigned long )(__o___132->next_free + __len___34) > (unsigned long )__o___132->chunk_limit) {
          {
#line 689
          _obstack_newchunk(__o___132, __len___34);
          }
        }
        {
#line 689
        memcpy((void */* __restrict  */)__o___132->next_free, (void const   */* __restrict  */)((char *)file->name),
               (size_t )__len___34);
#line 689
        __o___132->next_free += __len___34;
        }
#line 689
        if (width) {
#line 689
          if (justification < 0) {
            {
#line 689
            while (1) {
              while_continue___133: /* CIL Label */ ;
#line 689
              if (! nspace___34) {
#line 689
                goto while_break___133;
              }
#line 689
              __o___133 = user_string_stack___0;
#line 689
              if ((unsigned long )(__o___133->next_free + 1) > (unsigned long )__o___133->chunk_limit) {
                {
#line 689
                _obstack_newchunk(__o___133, 1);
                }
              }
#line 689
              tmp___192 = __o___133->next_free;
#line 689
              (__o___133->next_free) ++;
#line 689
              *tmp___192 = (char )padding;
#line 689
              nspace___34 --;
            }
            while_break___133: /* CIL Label */ ;
            }
          }
        }
#line 689
        goto while_break___131;
      }
      while_break___131: /* CIL Label */ ;
      }
#line 690
      goto switch_break___4;
      case_70___0: /* CIL Label */ 
      {
#line 693
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d.%d.%d",
              file->mod_tm.tm_mday, file->mod_tm.tm_mon + 1, file->mod_tm.tm_year + 1900);
      }
      {
#line 697
      while (1) {
        while_continue___134: /* CIL Label */ ;
        {
#line 697
        tmp___193 = strlen((char const   *)(buf___0));
#line 697
        len___35 = tmp___193;
        }
#line 697
        if (len___35 > width) {
#line 697
          nspace___35 = (size_t )0;
        } else {
#line 697
          nspace___35 = width - len___35;
        }
#line 697
        if (width) {
#line 697
          if (justification > 0) {
            {
#line 697
            while (1) {
              while_continue___135: /* CIL Label */ ;
#line 697
              if (! nspace___35) {
#line 697
                goto while_break___135;
              }
#line 697
              __o___134 = user_string_stack___0;
#line 697
              if ((unsigned long )(__o___134->next_free + 1) > (unsigned long )__o___134->chunk_limit) {
                {
#line 697
                _obstack_newchunk(__o___134, 1);
                }
              }
#line 697
              tmp___194 = __o___134->next_free;
#line 697
              (__o___134->next_free) ++;
#line 697
              *tmp___194 = (char )padding;
#line 697
              nspace___35 --;
            }
            while_break___135: /* CIL Label */ ;
            }
          }
        }
#line 697
        __o___135 = user_string_stack___0;
#line 697
        __len___35 = (int )len___35;
#line 697
        if ((unsigned long )(__o___135->next_free + __len___35) > (unsigned long )__o___135->chunk_limit) {
          {
#line 697
          _obstack_newchunk(__o___135, __len___35);
          }
        }
        {
#line 697
        memcpy((void */* __restrict  */)__o___135->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___35);
#line 697
        __o___135->next_free += __len___35;
        }
#line 697
        if (width) {
#line 697
          if (justification < 0) {
            {
#line 697
            while (1) {
              while_continue___136: /* CIL Label */ ;
#line 697
              if (! nspace___35) {
#line 697
                goto while_break___136;
              }
#line 697
              __o___136 = user_string_stack___0;
#line 697
              if ((unsigned long )(__o___136->next_free + 1) > (unsigned long )__o___136->chunk_limit) {
                {
#line 697
                _obstack_newchunk(__o___136, 1);
                }
              }
#line 697
              tmp___195 = __o___136->next_free;
#line 697
              (__o___136->next_free) ++;
#line 697
              *tmp___195 = (char )padding;
#line 697
              nspace___35 --;
            }
            while_break___136: /* CIL Label */ ;
            }
          }
        }
#line 697
        goto while_break___134;
      }
      while_break___134: /* CIL Label */ ;
      }
#line 698
      goto switch_break___4;
      case_108: /* CIL Label */ 
#line 701
      i ++;
      {
#line 702
      if ((int const   )*(str + i) == 94) {
#line 702
        goto case_94;
      }
#line 707
      if ((int const   )*(str + i) == 46) {
#line 707
        goto case_46___1;
      }
#line 712
      if ((int const   )*(str + i) == 35) {
#line 712
        goto case_35___3;
      }
#line 723
      goto switch_default___5;
      case_94: /* CIL Label */ 
      {
#line 703
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              file->top_line);
      }
      {
#line 704
      while (1) {
        while_continue___137: /* CIL Label */ ;
        {
#line 704
        tmp___196 = strlen((char const   *)(buf___0));
#line 704
        len___36 = tmp___196;
        }
#line 704
        if (len___36 > width) {
#line 704
          nspace___36 = (size_t )0;
        } else {
#line 704
          nspace___36 = width - len___36;
        }
#line 704
        if (width) {
#line 704
          if (justification > 0) {
            {
#line 704
            while (1) {
              while_continue___138: /* CIL Label */ ;
#line 704
              if (! nspace___36) {
#line 704
                goto while_break___138;
              }
#line 704
              __o___137 = user_string_stack___0;
#line 704
              if ((unsigned long )(__o___137->next_free + 1) > (unsigned long )__o___137->chunk_limit) {
                {
#line 704
                _obstack_newchunk(__o___137, 1);
                }
              }
#line 704
              tmp___197 = __o___137->next_free;
#line 704
              (__o___137->next_free) ++;
#line 704
              *tmp___197 = (char )padding;
#line 704
              nspace___36 --;
            }
            while_break___138: /* CIL Label */ ;
            }
          }
        }
#line 704
        __o___138 = user_string_stack___0;
#line 704
        __len___36 = (int )len___36;
#line 704
        if ((unsigned long )(__o___138->next_free + __len___36) > (unsigned long )__o___138->chunk_limit) {
          {
#line 704
          _obstack_newchunk(__o___138, __len___36);
          }
        }
        {
#line 704
        memcpy((void */* __restrict  */)__o___138->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___36);
#line 704
        __o___138->next_free += __len___36;
        }
#line 704
        if (width) {
#line 704
          if (justification < 0) {
            {
#line 704
            while (1) {
              while_continue___139: /* CIL Label */ ;
#line 704
              if (! nspace___36) {
#line 704
                goto while_break___139;
              }
#line 704
              __o___139 = user_string_stack___0;
#line 704
              if ((unsigned long )(__o___139->next_free + 1) > (unsigned long )__o___139->chunk_limit) {
                {
#line 704
                _obstack_newchunk(__o___139, 1);
                }
              }
#line 704
              tmp___198 = __o___139->next_free;
#line 704
              (__o___139->next_free) ++;
#line 704
              *tmp___198 = (char )padding;
#line 704
              nspace___36 --;
            }
            while_break___139: /* CIL Label */ ;
            }
          }
        }
#line 704
        goto while_break___137;
      }
      while_break___137: /* CIL Label */ ;
      }
#line 705
      goto switch_break___7;
      case_46___1: /* CIL Label */ 
      {
#line 708
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              file->lines - 1);
      }
      {
#line 709
      while (1) {
        while_continue___140: /* CIL Label */ ;
        {
#line 709
        tmp___199 = strlen((char const   *)(buf___0));
#line 709
        len___37 = tmp___199;
        }
#line 709
        if (len___37 > width) {
#line 709
          nspace___37 = (size_t )0;
        } else {
#line 709
          nspace___37 = width - len___37;
        }
#line 709
        if (width) {
#line 709
          if (justification > 0) {
            {
#line 709
            while (1) {
              while_continue___141: /* CIL Label */ ;
#line 709
              if (! nspace___37) {
#line 709
                goto while_break___141;
              }
#line 709
              __o___140 = user_string_stack___0;
#line 709
              if ((unsigned long )(__o___140->next_free + 1) > (unsigned long )__o___140->chunk_limit) {
                {
#line 709
                _obstack_newchunk(__o___140, 1);
                }
              }
#line 709
              tmp___200 = __o___140->next_free;
#line 709
              (__o___140->next_free) ++;
#line 709
              *tmp___200 = (char )padding;
#line 709
              nspace___37 --;
            }
            while_break___141: /* CIL Label */ ;
            }
          }
        }
#line 709
        __o___141 = user_string_stack___0;
#line 709
        __len___37 = (int )len___37;
#line 709
        if ((unsigned long )(__o___141->next_free + __len___37) > (unsigned long )__o___141->chunk_limit) {
          {
#line 709
          _obstack_newchunk(__o___141, __len___37);
          }
        }
        {
#line 709
        memcpy((void */* __restrict  */)__o___141->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___37);
#line 709
        __o___141->next_free += __len___37;
        }
#line 709
        if (width) {
#line 709
          if (justification < 0) {
            {
#line 709
            while (1) {
              while_continue___142: /* CIL Label */ ;
#line 709
              if (! nspace___37) {
#line 709
                goto while_break___142;
              }
#line 709
              __o___142 = user_string_stack___0;
#line 709
              if ((unsigned long )(__o___142->next_free + 1) > (unsigned long )__o___142->chunk_limit) {
                {
#line 709
                _obstack_newchunk(__o___142, 1);
                }
              }
#line 709
              tmp___201 = __o___142->next_free;
#line 709
              (__o___142->next_free) ++;
#line 709
              *tmp___201 = (char )padding;
#line 709
              nspace___37 --;
            }
            while_break___142: /* CIL Label */ ;
            }
          }
        }
#line 709
        goto while_break___140;
      }
      while_break___140: /* CIL Label */ ;
      }
#line 710
      goto switch_break___7;
      case_35___3: /* CIL Label */ 
#line 713
      if ((unsigned long )file != (unsigned long )((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))) {
        {
#line 715
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
                file->lines);
        }
        {
#line 716
        while (1) {
          while_continue___143: /* CIL Label */ ;
          {
#line 716
          tmp___202 = strlen((char const   *)(buf___0));
#line 716
          len___38 = tmp___202;
          }
#line 716
          if (len___38 > width) {
#line 716
            nspace___38 = (size_t )0;
          } else {
#line 716
            nspace___38 = width - len___38;
          }
#line 716
          if (width) {
#line 716
            if (justification > 0) {
              {
#line 716
              while (1) {
                while_continue___144: /* CIL Label */ ;
#line 716
                if (! nspace___38) {
#line 716
                  goto while_break___144;
                }
#line 716
                __o___143 = user_string_stack___0;
#line 716
                if ((unsigned long )(__o___143->next_free + 1) > (unsigned long )__o___143->chunk_limit) {
                  {
#line 716
                  _obstack_newchunk(__o___143, 1);
                  }
                }
#line 716
                tmp___203 = __o___143->next_free;
#line 716
                (__o___143->next_free) ++;
#line 716
                *tmp___203 = (char )padding;
#line 716
                nspace___38 --;
              }
              while_break___144: /* CIL Label */ ;
              }
            }
          }
#line 716
          __o___144 = user_string_stack___0;
#line 716
          __len___38 = (int )len___38;
#line 716
          if ((unsigned long )(__o___144->next_free + __len___38) > (unsigned long )__o___144->chunk_limit) {
            {
#line 716
            _obstack_newchunk(__o___144, __len___38);
            }
          }
          {
#line 716
          memcpy((void */* __restrict  */)__o___144->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
                 (size_t )__len___38);
#line 716
          __o___144->next_free += __len___38;
          }
#line 716
          if (width) {
#line 716
            if (justification < 0) {
              {
#line 716
              while (1) {
                while_continue___145: /* CIL Label */ ;
#line 716
                if (! nspace___38) {
#line 716
                  goto while_break___145;
                }
#line 716
                __o___145 = user_string_stack___0;
#line 716
                if ((unsigned long )(__o___145->next_free + 1) > (unsigned long )__o___145->chunk_limit) {
                  {
#line 716
                  _obstack_newchunk(__o___145, 1);
                  }
                }
#line 716
                tmp___204 = __o___145->next_free;
#line 716
                (__o___145->next_free) ++;
#line 716
                *tmp___204 = (char )padding;
#line 716
                nspace___38 --;
              }
              while_break___145: /* CIL Label */ ;
              }
            }
          }
#line 716
          goto while_break___143;
        }
        while_break___143: /* CIL Label */ ;
        }
      } else {
        {
#line 719
        while (1) {
          while_continue___146: /* CIL Label */ ;
#line 719
          if (width) {
#line 719
            if (justification < 0) {
#line 719
              __o___146 = user_string_stack___0;
#line 719
              if ((unsigned long )(__o___146->next_free + 1) > (unsigned long )__o___146->chunk_limit) {
                {
#line 719
                _obstack_newchunk(__o___146, 1);
                }
              }
#line 719
              tmp___205 = __o___146->next_free;
#line 719
              (__o___146->next_free) ++;
#line 719
              *tmp___205 = (char)6;
            }
          }
#line 719
          a___8 = 0;
          {
#line 719
          while (1) {
            while_continue___147: /* CIL Label */ ;
#line 719
            if (! (a___8 < (int )width - 1)) {
#line 719
              goto while_break___147;
            }
#line 719
            __o___147 = user_string_stack___0;
#line 719
            if ((unsigned long )(__o___147->next_free + 1) > (unsigned long )__o___147->chunk_limit) {
              {
#line 719
              _obstack_newchunk(__o___147, 1);
              }
            }
#line 719
            tmp___206 = __o___147->next_free;
#line 719
            (__o___147->next_free) ++;
#line 719
            *tmp___206 = (char )padding;
#line 719
            a___8 ++;
          }
          while_break___147: /* CIL Label */ ;
          }
#line 719
          if (! width) {
#line 719
            goto _L___10;
          } else
#line 719
          if (justification > 0) {
            _L___10: /* CIL Label */ 
#line 719
            __o___148 = user_string_stack___0;
#line 719
            if ((unsigned long )(__o___148->next_free + 1) > (unsigned long )__o___148->chunk_limit) {
              {
#line 719
              _obstack_newchunk(__o___148, 1);
              }
            }
#line 719
            tmp___207 = __o___148->next_free;
#line 719
            (__o___148->next_free) ++;
#line 719
            *tmp___207 = (char)6;
          }
#line 719
          goto while_break___146;
        }
        while_break___146: /* CIL Label */ ;
        }
      }
#line 721
      goto switch_break___7;
      switch_default___5: /* CIL Label */ 
      {
#line 724
      tmp___208 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 724
      error(1, 0, (char const   *)tmp___208, context_name, "$l", (int const   )*(str + i),
            (int const   )*(str + i));
      }
#line 726
      goto switch_break___7;
      switch_break___7: /* CIL Label */ ;
      }
#line 728
      goto switch_break___4;
      case_78___0: /* CIL Label */ 
      {
#line 733
      tmp___209 = strrchr((char const   *)((char *)file->name), '/');
#line 733
      cp = (unsigned char *)tmp___209;
      }
#line 734
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 735
        cp = file->name;
      } else {
#line 737
        cp ++;
      }
      {
#line 740
      tmp___210 = strrchr((char const   *)((char *)cp), '.');
#line 740
      cp2 = (unsigned char *)tmp___210;
      }
#line 741
      if (cp2) {
        {
#line 742
        strncpy((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)((char const   *)cp),
                (size_t )(cp2 - cp));
#line 743
        buf___0[cp2 - cp] = (unsigned char )'\000';
        }
        {
#line 744
        while (1) {
          while_continue___148: /* CIL Label */ ;
          {
#line 744
          tmp___211 = strlen((char const   *)(buf___0));
#line 744
          len___39 = tmp___211;
          }
#line 744
          if (len___39 > width) {
#line 744
            nspace___39 = (size_t )0;
          } else {
#line 744
            nspace___39 = width - len___39;
          }
#line 744
          if (width) {
#line 744
            if (justification > 0) {
              {
#line 744
              while (1) {
                while_continue___149: /* CIL Label */ ;
#line 744
                if (! nspace___39) {
#line 744
                  goto while_break___149;
                }
#line 744
                __o___149 = user_string_stack___0;
#line 744
                if ((unsigned long )(__o___149->next_free + 1) > (unsigned long )__o___149->chunk_limit) {
                  {
#line 744
                  _obstack_newchunk(__o___149, 1);
                  }
                }
#line 744
                tmp___212 = __o___149->next_free;
#line 744
                (__o___149->next_free) ++;
#line 744
                *tmp___212 = (char )padding;
#line 744
                nspace___39 --;
              }
              while_break___149: /* CIL Label */ ;
              }
            }
          }
#line 744
          __o___150 = user_string_stack___0;
#line 744
          __len___39 = (int )len___39;
#line 744
          if ((unsigned long )(__o___150->next_free + __len___39) > (unsigned long )__o___150->chunk_limit) {
            {
#line 744
            _obstack_newchunk(__o___150, __len___39);
            }
          }
          {
#line 744
          memcpy((void */* __restrict  */)__o___150->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
                 (size_t )__len___39);
#line 744
          __o___150->next_free += __len___39;
          }
#line 744
          if (width) {
#line 744
            if (justification < 0) {
              {
#line 744
              while (1) {
                while_continue___150: /* CIL Label */ ;
#line 744
                if (! nspace___39) {
#line 744
                  goto while_break___150;
                }
#line 744
                __o___151 = user_string_stack___0;
#line 744
                if ((unsigned long )(__o___151->next_free + 1) > (unsigned long )__o___151->chunk_limit) {
                  {
#line 744
                  _obstack_newchunk(__o___151, 1);
                  }
                }
#line 744
                tmp___213 = __o___151->next_free;
#line 744
                (__o___151->next_free) ++;
#line 744
                *tmp___213 = (char )padding;
#line 744
                nspace___39 --;
              }
              while_break___150: /* CIL Label */ ;
              }
            }
          }
#line 744
          goto while_break___148;
        }
        while_break___148: /* CIL Label */ ;
        }
      } else {
        {
#line 746
        while (1) {
          while_continue___151: /* CIL Label */ ;
          {
#line 746
          tmp___214 = strlen((char const   *)cp);
#line 746
          len___40 = tmp___214;
          }
#line 746
          if (len___40 > width) {
#line 746
            nspace___40 = (size_t )0;
          } else {
#line 746
            nspace___40 = width - len___40;
          }
#line 746
          if (width) {
#line 746
            if (justification > 0) {
              {
#line 746
              while (1) {
                while_continue___152: /* CIL Label */ ;
#line 746
                if (! nspace___40) {
#line 746
                  goto while_break___152;
                }
#line 746
                __o___152 = user_string_stack___0;
#line 746
                if ((unsigned long )(__o___152->next_free + 1) > (unsigned long )__o___152->chunk_limit) {
                  {
#line 746
                  _obstack_newchunk(__o___152, 1);
                  }
                }
#line 746
                tmp___215 = __o___152->next_free;
#line 746
                (__o___152->next_free) ++;
#line 746
                *tmp___215 = (char )padding;
#line 746
                nspace___40 --;
              }
              while_break___152: /* CIL Label */ ;
              }
            }
          }
#line 746
          __o___153 = user_string_stack___0;
#line 746
          __len___40 = (int )len___40;
#line 746
          if ((unsigned long )(__o___153->next_free + __len___40) > (unsigned long )__o___153->chunk_limit) {
            {
#line 746
            _obstack_newchunk(__o___153, __len___40);
            }
          }
          {
#line 746
          memcpy((void */* __restrict  */)__o___153->next_free, (void const   */* __restrict  */)((char *)cp),
                 (size_t )__len___40);
#line 746
          __o___153->next_free += __len___40;
          }
#line 746
          if (width) {
#line 746
            if (justification < 0) {
              {
#line 746
              while (1) {
                while_continue___153: /* CIL Label */ ;
#line 746
                if (! nspace___40) {
#line 746
                  goto while_break___153;
                }
#line 746
                __o___154 = user_string_stack___0;
#line 746
                if ((unsigned long )(__o___154->next_free + 1) > (unsigned long )__o___154->chunk_limit) {
                  {
#line 746
                  _obstack_newchunk(__o___154, 1);
                  }
                }
#line 746
                tmp___216 = __o___154->next_free;
#line 746
                (__o___154->next_free) ++;
#line 746
                *tmp___216 = (char )padding;
#line 746
                nspace___40 --;
              }
              while_break___153: /* CIL Label */ ;
              }
            }
          }
#line 746
          goto while_break___151;
        }
        while_break___151: /* CIL Label */ ;
        }
      }
#line 747
      goto switch_break___4;
      case_110___1: /* CIL Label */ 
      {
#line 750
      tmp___217 = strrchr((char const   *)((char *)file->name), '/');
#line 750
      cp = (unsigned char *)tmp___217;
      }
#line 751
      if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 752
        cp = file->name;
      } else {
#line 754
        cp ++;
      }
      {
#line 755
      while (1) {
        while_continue___154: /* CIL Label */ ;
        {
#line 755
        tmp___218 = strlen((char const   *)cp);
#line 755
        len___41 = tmp___218;
        }
#line 755
        if (len___41 > width) {
#line 755
          nspace___41 = (size_t )0;
        } else {
#line 755
          nspace___41 = width - len___41;
        }
#line 755
        if (width) {
#line 755
          if (justification > 0) {
            {
#line 755
            while (1) {
              while_continue___155: /* CIL Label */ ;
#line 755
              if (! nspace___41) {
#line 755
                goto while_break___155;
              }
#line 755
              __o___155 = user_string_stack___0;
#line 755
              if ((unsigned long )(__o___155->next_free + 1) > (unsigned long )__o___155->chunk_limit) {
                {
#line 755
                _obstack_newchunk(__o___155, 1);
                }
              }
#line 755
              tmp___219 = __o___155->next_free;
#line 755
              (__o___155->next_free) ++;
#line 755
              *tmp___219 = (char )padding;
#line 755
              nspace___41 --;
            }
            while_break___155: /* CIL Label */ ;
            }
          }
        }
#line 755
        __o___156 = user_string_stack___0;
#line 755
        __len___41 = (int )len___41;
#line 755
        if ((unsigned long )(__o___156->next_free + __len___41) > (unsigned long )__o___156->chunk_limit) {
          {
#line 755
          _obstack_newchunk(__o___156, __len___41);
          }
        }
        {
#line 755
        memcpy((void */* __restrict  */)__o___156->next_free, (void const   */* __restrict  */)((char *)cp),
               (size_t )__len___41);
#line 755
        __o___156->next_free += __len___41;
        }
#line 755
        if (width) {
#line 755
          if (justification < 0) {
            {
#line 755
            while (1) {
              while_continue___156: /* CIL Label */ ;
#line 755
              if (! nspace___41) {
#line 755
                goto while_break___156;
              }
#line 755
              __o___157 = user_string_stack___0;
#line 755
              if ((unsigned long )(__o___157->next_free + 1) > (unsigned long )__o___157->chunk_limit) {
                {
#line 755
                _obstack_newchunk(__o___157, 1);
                }
              }
#line 755
              tmp___220 = __o___157->next_free;
#line 755
              (__o___157->next_free) ++;
#line 755
              *tmp___220 = (char )padding;
#line 755
              nspace___41 --;
            }
            while_break___156: /* CIL Label */ ;
            }
          }
        }
#line 755
        goto while_break___154;
      }
      while_break___154: /* CIL Label */ ;
      }
#line 756
      goto switch_break___4;
      case_112___0: /* CIL Label */ 
#line 759
      i ++;
      {
#line 760
      if ((int const   )*(str + i) == 94) {
#line 760
        goto case_94___0;
      }
#line 766
      if ((int const   )*(str + i) == 45) {
#line 766
        goto case_45___0;
      }
#line 775
      if ((int const   )*(str + i) == 60) {
#line 775
        goto case_60;
      }
#line 780
      if ((int const   )*(str + i) == 46) {
#line 780
        goto case_46___2;
      }
#line 785
      if ((int const   )*(str + i) == 62) {
#line 785
        goto case_62;
      }
#line 796
      if ((int const   )*(str + i) == 35) {
#line 796
        goto case_35___4;
      }
#line 807
      goto switch_default___6;
      case_94___0: /* CIL Label */ 
      {
#line 762
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              file->top_page);
      }
      {
#line 763
      while (1) {
        while_continue___157: /* CIL Label */ ;
        {
#line 763
        tmp___221 = strlen((char const   *)(buf___0));
#line 763
        len___42 = tmp___221;
        }
#line 763
        if (len___42 > width) {
#line 763
          nspace___42 = (size_t )0;
        } else {
#line 763
          nspace___42 = width - len___42;
        }
#line 763
        if (width) {
#line 763
          if (justification > 0) {
            {
#line 763
            while (1) {
              while_continue___158: /* CIL Label */ ;
#line 763
              if (! nspace___42) {
#line 763
                goto while_break___158;
              }
#line 763
              __o___158 = user_string_stack___0;
#line 763
              if ((unsigned long )(__o___158->next_free + 1) > (unsigned long )__o___158->chunk_limit) {
                {
#line 763
                _obstack_newchunk(__o___158, 1);
                }
              }
#line 763
              tmp___222 = __o___158->next_free;
#line 763
              (__o___158->next_free) ++;
#line 763
              *tmp___222 = (char )padding;
#line 763
              nspace___42 --;
            }
            while_break___158: /* CIL Label */ ;
            }
          }
        }
#line 763
        __o___159 = user_string_stack___0;
#line 763
        __len___42 = (int )len___42;
#line 763
        if ((unsigned long )(__o___159->next_free + __len___42) > (unsigned long )__o___159->chunk_limit) {
          {
#line 763
          _obstack_newchunk(__o___159, __len___42);
          }
        }
        {
#line 763
        memcpy((void */* __restrict  */)__o___159->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___42);
#line 763
        __o___159->next_free += __len___42;
        }
#line 763
        if (width) {
#line 763
          if (justification < 0) {
            {
#line 763
            while (1) {
              while_continue___159: /* CIL Label */ ;
#line 763
              if (! nspace___42) {
#line 763
                goto while_break___159;
              }
#line 763
              __o___160 = user_string_stack___0;
#line 763
              if ((unsigned long )(__o___160->next_free + 1) > (unsigned long )__o___160->chunk_limit) {
                {
#line 763
                _obstack_newchunk(__o___160, 1);
                }
              }
#line 763
              tmp___223 = __o___160->next_free;
#line 763
              (__o___160->next_free) ++;
#line 763
              *tmp___223 = (char )padding;
#line 763
              nspace___42 --;
            }
            while_break___159: /* CIL Label */ ;
            }
          }
        }
#line 763
        goto while_break___157;
      }
      while_break___157: /* CIL Label */ ;
      }
#line 764
      goto switch_break___8;
      case_45___0: /* CIL Label */ 
#line 768
      if (file->top_page == file->pages) {
        {
#line 769
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
                file->top_page);
        }
      } else {
        {
#line 771
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d-%d",
                file->top_page, file->pages);
        }
      }
      {
#line 772
      while (1) {
        while_continue___160: /* CIL Label */ ;
        {
#line 772
        tmp___224 = strlen((char const   *)(buf___0));
#line 772
        len___43 = tmp___224;
        }
#line 772
        if (len___43 > width) {
#line 772
          nspace___43 = (size_t )0;
        } else {
#line 772
          nspace___43 = width - len___43;
        }
#line 772
        if (width) {
#line 772
          if (justification > 0) {
            {
#line 772
            while (1) {
              while_continue___161: /* CIL Label */ ;
#line 772
              if (! nspace___43) {
#line 772
                goto while_break___161;
              }
#line 772
              __o___161 = user_string_stack___0;
#line 772
              if ((unsigned long )(__o___161->next_free + 1) > (unsigned long )__o___161->chunk_limit) {
                {
#line 772
                _obstack_newchunk(__o___161, 1);
                }
              }
#line 772
              tmp___225 = __o___161->next_free;
#line 772
              (__o___161->next_free) ++;
#line 772
              *tmp___225 = (char )padding;
#line 772
              nspace___43 --;
            }
            while_break___161: /* CIL Label */ ;
            }
          }
        }
#line 772
        __o___162 = user_string_stack___0;
#line 772
        __len___43 = (int )len___43;
#line 772
        if ((unsigned long )(__o___162->next_free + __len___43) > (unsigned long )__o___162->chunk_limit) {
          {
#line 772
          _obstack_newchunk(__o___162, __len___43);
          }
        }
        {
#line 772
        memcpy((void */* __restrict  */)__o___162->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___43);
#line 772
        __o___162->next_free += __len___43;
        }
#line 772
        if (width) {
#line 772
          if (justification < 0) {
            {
#line 772
            while (1) {
              while_continue___162: /* CIL Label */ ;
#line 772
              if (! nspace___43) {
#line 772
                goto while_break___162;
              }
#line 772
              __o___163 = user_string_stack___0;
#line 772
              if ((unsigned long )(__o___163->next_free + 1) > (unsigned long )__o___163->chunk_limit) {
                {
#line 772
                _obstack_newchunk(__o___163, 1);
                }
              }
#line 772
              tmp___226 = __o___163->next_free;
#line 772
              (__o___163->next_free) ++;
#line 772
              *tmp___226 = (char )padding;
#line 772
              nspace___43 --;
            }
            while_break___162: /* CIL Label */ ;
            }
          }
        }
#line 772
        goto while_break___160;
      }
      while_break___160: /* CIL Label */ ;
      }
#line 773
      goto switch_break___8;
      case_60: /* CIL Label */ 
      {
#line 776
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              file->first_page);
      }
      {
#line 777
      while (1) {
        while_continue___163: /* CIL Label */ ;
        {
#line 777
        tmp___227 = strlen((char const   *)(buf___0));
#line 777
        len___44 = tmp___227;
        }
#line 777
        if (len___44 > width) {
#line 777
          nspace___44 = (size_t )0;
        } else {
#line 777
          nspace___44 = width - len___44;
        }
#line 777
        if (width) {
#line 777
          if (justification > 0) {
            {
#line 777
            while (1) {
              while_continue___164: /* CIL Label */ ;
#line 777
              if (! nspace___44) {
#line 777
                goto while_break___164;
              }
#line 777
              __o___164 = user_string_stack___0;
#line 777
              if ((unsigned long )(__o___164->next_free + 1) > (unsigned long )__o___164->chunk_limit) {
                {
#line 777
                _obstack_newchunk(__o___164, 1);
                }
              }
#line 777
              tmp___228 = __o___164->next_free;
#line 777
              (__o___164->next_free) ++;
#line 777
              *tmp___228 = (char )padding;
#line 777
              nspace___44 --;
            }
            while_break___164: /* CIL Label */ ;
            }
          }
        }
#line 777
        __o___165 = user_string_stack___0;
#line 777
        __len___44 = (int )len___44;
#line 777
        if ((unsigned long )(__o___165->next_free + __len___44) > (unsigned long )__o___165->chunk_limit) {
          {
#line 777
          _obstack_newchunk(__o___165, __len___44);
          }
        }
        {
#line 777
        memcpy((void */* __restrict  */)__o___165->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___44);
#line 777
        __o___165->next_free += __len___44;
        }
#line 777
        if (width) {
#line 777
          if (justification < 0) {
            {
#line 777
            while (1) {
              while_continue___165: /* CIL Label */ ;
#line 777
              if (! nspace___44) {
#line 777
                goto while_break___165;
              }
#line 777
              __o___166 = user_string_stack___0;
#line 777
              if ((unsigned long )(__o___166->next_free + 1) > (unsigned long )__o___166->chunk_limit) {
                {
#line 777
                _obstack_newchunk(__o___166, 1);
                }
              }
#line 777
              tmp___229 = __o___166->next_free;
#line 777
              (__o___166->next_free) ++;
#line 777
              *tmp___229 = (char )padding;
#line 777
              nspace___44 --;
            }
            while_break___165: /* CIL Label */ ;
            }
          }
        }
#line 777
        goto while_break___163;
      }
      while_break___163: /* CIL Label */ ;
      }
#line 778
      goto switch_break___8;
      case_46___2: /* CIL Label */ 
      {
#line 781
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              file->pages);
      }
      {
#line 782
      while (1) {
        while_continue___166: /* CIL Label */ ;
        {
#line 782
        tmp___230 = strlen((char const   *)(buf___0));
#line 782
        len___45 = tmp___230;
        }
#line 782
        if (len___45 > width) {
#line 782
          nspace___45 = (size_t )0;
        } else {
#line 782
          nspace___45 = width - len___45;
        }
#line 782
        if (width) {
#line 782
          if (justification > 0) {
            {
#line 782
            while (1) {
              while_continue___167: /* CIL Label */ ;
#line 782
              if (! nspace___45) {
#line 782
                goto while_break___167;
              }
#line 782
              __o___167 = user_string_stack___0;
#line 782
              if ((unsigned long )(__o___167->next_free + 1) > (unsigned long )__o___167->chunk_limit) {
                {
#line 782
                _obstack_newchunk(__o___167, 1);
                }
              }
#line 782
              tmp___231 = __o___167->next_free;
#line 782
              (__o___167->next_free) ++;
#line 782
              *tmp___231 = (char )padding;
#line 782
              nspace___45 --;
            }
            while_break___167: /* CIL Label */ ;
            }
          }
        }
#line 782
        __o___168 = user_string_stack___0;
#line 782
        __len___45 = (int )len___45;
#line 782
        if ((unsigned long )(__o___168->next_free + __len___45) > (unsigned long )__o___168->chunk_limit) {
          {
#line 782
          _obstack_newchunk(__o___168, __len___45);
          }
        }
        {
#line 782
        memcpy((void */* __restrict  */)__o___168->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___45);
#line 782
        __o___168->next_free += __len___45;
        }
#line 782
        if (width) {
#line 782
          if (justification < 0) {
            {
#line 782
            while (1) {
              while_continue___168: /* CIL Label */ ;
#line 782
              if (! nspace___45) {
#line 782
                goto while_break___168;
              }
#line 782
              __o___169 = user_string_stack___0;
#line 782
              if ((unsigned long )(__o___169->next_free + 1) > (unsigned long )__o___169->chunk_limit) {
                {
#line 782
                _obstack_newchunk(__o___169, 1);
                }
              }
#line 782
              tmp___232 = __o___169->next_free;
#line 782
              (__o___169->next_free) ++;
#line 782
              *tmp___232 = (char )padding;
#line 782
              nspace___45 --;
            }
            while_break___168: /* CIL Label */ ;
            }
          }
        }
#line 782
        goto while_break___166;
      }
      while_break___166: /* CIL Label */ ;
      }
#line 783
      goto switch_break___8;
      case_62: /* CIL Label */ 
#line 786
      if ((unsigned long )file != (unsigned long )((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))) {
        {
#line 788
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
                file->last_page);
        }
        {
#line 789
        while (1) {
          while_continue___169: /* CIL Label */ ;
          {
#line 789
          tmp___233 = strlen((char const   *)(buf___0));
#line 789
          len___46 = tmp___233;
          }
#line 789
          if (len___46 > width) {
#line 789
            nspace___46 = (size_t )0;
          } else {
#line 789
            nspace___46 = width - len___46;
          }
#line 789
          if (width) {
#line 789
            if (justification > 0) {
              {
#line 789
              while (1) {
                while_continue___170: /* CIL Label */ ;
#line 789
                if (! nspace___46) {
#line 789
                  goto while_break___170;
                }
#line 789
                __o___170 = user_string_stack___0;
#line 789
                if ((unsigned long )(__o___170->next_free + 1) > (unsigned long )__o___170->chunk_limit) {
                  {
#line 789
                  _obstack_newchunk(__o___170, 1);
                  }
                }
#line 789
                tmp___234 = __o___170->next_free;
#line 789
                (__o___170->next_free) ++;
#line 789
                *tmp___234 = (char )padding;
#line 789
                nspace___46 --;
              }
              while_break___170: /* CIL Label */ ;
              }
            }
          }
#line 789
          __o___171 = user_string_stack___0;
#line 789
          __len___46 = (int )len___46;
#line 789
          if ((unsigned long )(__o___171->next_free + __len___46) > (unsigned long )__o___171->chunk_limit) {
            {
#line 789
            _obstack_newchunk(__o___171, __len___46);
            }
          }
          {
#line 789
          memcpy((void */* __restrict  */)__o___171->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
                 (size_t )__len___46);
#line 789
          __o___171->next_free += __len___46;
          }
#line 789
          if (width) {
#line 789
            if (justification < 0) {
              {
#line 789
              while (1) {
                while_continue___171: /* CIL Label */ ;
#line 789
                if (! nspace___46) {
#line 789
                  goto while_break___171;
                }
#line 789
                __o___172 = user_string_stack___0;
#line 789
                if ((unsigned long )(__o___172->next_free + 1) > (unsigned long )__o___172->chunk_limit) {
                  {
#line 789
                  _obstack_newchunk(__o___172, 1);
                  }
                }
#line 789
                tmp___235 = __o___172->next_free;
#line 789
                (__o___172->next_free) ++;
#line 789
                *tmp___235 = (char )padding;
#line 789
                nspace___46 --;
              }
              while_break___171: /* CIL Label */ ;
              }
            }
          }
#line 789
          goto while_break___169;
        }
        while_break___169: /* CIL Label */ ;
        }
      } else {
        {
#line 792
        while (1) {
          while_continue___172: /* CIL Label */ ;
#line 792
          if (width) {
#line 792
            if (justification < 0) {
#line 792
              __o___173 = user_string_stack___0;
#line 792
              if ((unsigned long )(__o___173->next_free + 1) > (unsigned long )__o___173->chunk_limit) {
                {
#line 792
                _obstack_newchunk(__o___173, 1);
                }
              }
#line 792
              tmp___236 = __o___173->next_free;
#line 792
              (__o___173->next_free) ++;
#line 792
              *tmp___236 = (char)7;
            }
          }
#line 792
          a___9 = 0;
          {
#line 792
          while (1) {
            while_continue___173: /* CIL Label */ ;
#line 792
            if (! (a___9 < (int )width - 1)) {
#line 792
              goto while_break___173;
            }
#line 792
            __o___174 = user_string_stack___0;
#line 792
            if ((unsigned long )(__o___174->next_free + 1) > (unsigned long )__o___174->chunk_limit) {
              {
#line 792
              _obstack_newchunk(__o___174, 1);
              }
            }
#line 792
            tmp___237 = __o___174->next_free;
#line 792
            (__o___174->next_free) ++;
#line 792
            *tmp___237 = (char )padding;
#line 792
            a___9 ++;
          }
          while_break___173: /* CIL Label */ ;
          }
#line 792
          if (! width) {
#line 792
            goto _L___11;
          } else
#line 792
          if (justification > 0) {
            _L___11: /* CIL Label */ 
#line 792
            __o___175 = user_string_stack___0;
#line 792
            if ((unsigned long )(__o___175->next_free + 1) > (unsigned long )__o___175->chunk_limit) {
              {
#line 792
              _obstack_newchunk(__o___175, 1);
              }
            }
#line 792
            tmp___238 = __o___175->next_free;
#line 792
            (__o___175->next_free) ++;
#line 792
            *tmp___238 = (char)7;
          }
#line 792
          goto while_break___172;
        }
        while_break___172: /* CIL Label */ ;
        }
      }
#line 794
      goto switch_break___8;
      case_35___4: /* CIL Label */ 
#line 797
      if ((unsigned long )file != (unsigned long )((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))) {
        {
#line 799
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
                file->pages);
        }
        {
#line 800
        while (1) {
          while_continue___174: /* CIL Label */ ;
          {
#line 800
          tmp___239 = strlen((char const   *)(buf___0));
#line 800
          len___47 = tmp___239;
          }
#line 800
          if (len___47 > width) {
#line 800
            nspace___47 = (size_t )0;
          } else {
#line 800
            nspace___47 = width - len___47;
          }
#line 800
          if (width) {
#line 800
            if (justification > 0) {
              {
#line 800
              while (1) {
                while_continue___175: /* CIL Label */ ;
#line 800
                if (! nspace___47) {
#line 800
                  goto while_break___175;
                }
#line 800
                __o___176 = user_string_stack___0;
#line 800
                if ((unsigned long )(__o___176->next_free + 1) > (unsigned long )__o___176->chunk_limit) {
                  {
#line 800
                  _obstack_newchunk(__o___176, 1);
                  }
                }
#line 800
                tmp___240 = __o___176->next_free;
#line 800
                (__o___176->next_free) ++;
#line 800
                *tmp___240 = (char )padding;
#line 800
                nspace___47 --;
              }
              while_break___175: /* CIL Label */ ;
              }
            }
          }
#line 800
          __o___177 = user_string_stack___0;
#line 800
          __len___47 = (int )len___47;
#line 800
          if ((unsigned long )(__o___177->next_free + __len___47) > (unsigned long )__o___177->chunk_limit) {
            {
#line 800
            _obstack_newchunk(__o___177, __len___47);
            }
          }
          {
#line 800
          memcpy((void */* __restrict  */)__o___177->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
                 (size_t )__len___47);
#line 800
          __o___177->next_free += __len___47;
          }
#line 800
          if (width) {
#line 800
            if (justification < 0) {
              {
#line 800
              while (1) {
                while_continue___176: /* CIL Label */ ;
#line 800
                if (! nspace___47) {
#line 800
                  goto while_break___176;
                }
#line 800
                __o___178 = user_string_stack___0;
#line 800
                if ((unsigned long )(__o___178->next_free + 1) > (unsigned long )__o___178->chunk_limit) {
                  {
#line 800
                  _obstack_newchunk(__o___178, 1);
                  }
                }
#line 800
                tmp___241 = __o___178->next_free;
#line 800
                (__o___178->next_free) ++;
#line 800
                *tmp___241 = (char )padding;
#line 800
                nspace___47 --;
              }
              while_break___176: /* CIL Label */ ;
              }
            }
          }
#line 800
          goto while_break___174;
        }
        while_break___174: /* CIL Label */ ;
        }
      } else {
        {
#line 803
        while (1) {
          while_continue___177: /* CIL Label */ ;
#line 803
          if (width) {
#line 803
            if (justification < 0) {
#line 803
              __o___179 = user_string_stack___0;
#line 803
              if ((unsigned long )(__o___179->next_free + 1) > (unsigned long )__o___179->chunk_limit) {
                {
#line 803
                _obstack_newchunk(__o___179, 1);
                }
              }
#line 803
              tmp___242 = __o___179->next_free;
#line 803
              (__o___179->next_free) ++;
#line 803
              *tmp___242 = (char)4;
            }
          }
#line 803
          a___10 = 0;
          {
#line 803
          while (1) {
            while_continue___178: /* CIL Label */ ;
#line 803
            if (! (a___10 < (int )width - 1)) {
#line 803
              goto while_break___178;
            }
#line 803
            __o___180 = user_string_stack___0;
#line 803
            if ((unsigned long )(__o___180->next_free + 1) > (unsigned long )__o___180->chunk_limit) {
              {
#line 803
              _obstack_newchunk(__o___180, 1);
              }
            }
#line 803
            tmp___243 = __o___180->next_free;
#line 803
            (__o___180->next_free) ++;
#line 803
            *tmp___243 = (char )padding;
#line 803
            a___10 ++;
          }
          while_break___178: /* CIL Label */ ;
          }
#line 803
          if (! width) {
#line 803
            goto _L___12;
          } else
#line 803
          if (justification > 0) {
            _L___12: /* CIL Label */ 
#line 803
            __o___181 = user_string_stack___0;
#line 803
            if ((unsigned long )(__o___181->next_free + 1) > (unsigned long )__o___181->chunk_limit) {
              {
#line 803
              _obstack_newchunk(__o___181, 1);
              }
            }
#line 803
            tmp___244 = __o___181->next_free;
#line 803
            (__o___181->next_free) ++;
#line 803
            *tmp___244 = (char)4;
          }
#line 803
          goto while_break___177;
        }
        while_break___177: /* CIL Label */ ;
        }
      }
#line 805
      goto switch_break___8;
      switch_default___6: /* CIL Label */ 
      {
#line 808
      tmp___245 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 808
      error(1, 0, (char const   *)tmp___245, context_name, "$p", (int const   )*(str + i),
            (int const   )*(str + i));
      }
#line 810
      goto switch_break___8;
      switch_break___8: /* CIL Label */ ;
      }
#line 812
      goto switch_break___4;
      case_113___0: /* CIL Label */ 
      {
#line 815
      tmp___246 = gettext("Page %d");
#line 815
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)tmp___246,
              file->pages);
      }
      {
#line 816
      while (1) {
        while_continue___179: /* CIL Label */ ;
        {
#line 816
        tmp___247 = strlen((char const   *)(buf___0));
#line 816
        len___48 = tmp___247;
        }
#line 816
        if (len___48 > width) {
#line 816
          nspace___48 = (size_t )0;
        } else {
#line 816
          nspace___48 = width - len___48;
        }
#line 816
        if (width) {
#line 816
          if (justification > 0) {
            {
#line 816
            while (1) {
              while_continue___180: /* CIL Label */ ;
#line 816
              if (! nspace___48) {
#line 816
                goto while_break___180;
              }
#line 816
              __o___182 = user_string_stack___0;
#line 816
              if ((unsigned long )(__o___182->next_free + 1) > (unsigned long )__o___182->chunk_limit) {
                {
#line 816
                _obstack_newchunk(__o___182, 1);
                }
              }
#line 816
              tmp___248 = __o___182->next_free;
#line 816
              (__o___182->next_free) ++;
#line 816
              *tmp___248 = (char )padding;
#line 816
              nspace___48 --;
            }
            while_break___180: /* CIL Label */ ;
            }
          }
        }
#line 816
        __o___183 = user_string_stack___0;
#line 816
        __len___48 = (int )len___48;
#line 816
        if ((unsigned long )(__o___183->next_free + __len___48) > (unsigned long )__o___183->chunk_limit) {
          {
#line 816
          _obstack_newchunk(__o___183, __len___48);
          }
        }
        {
#line 816
        memcpy((void */* __restrict  */)__o___183->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___48);
#line 816
        __o___183->next_free += __len___48;
        }
#line 816
        if (width) {
#line 816
          if (justification < 0) {
            {
#line 816
            while (1) {
              while_continue___181: /* CIL Label */ ;
#line 816
              if (! nspace___48) {
#line 816
                goto while_break___181;
              }
#line 816
              __o___184 = user_string_stack___0;
#line 816
              if ((unsigned long )(__o___184->next_free + 1) > (unsigned long )__o___184->chunk_limit) {
                {
#line 816
                _obstack_newchunk(__o___184, 1);
                }
              }
#line 816
              tmp___249 = __o___184->next_free;
#line 816
              (__o___184->next_free) ++;
#line 816
              *tmp___249 = (char )padding;
#line 816
              nspace___48 --;
            }
            while_break___181: /* CIL Label */ ;
            }
          }
        }
#line 816
        goto while_break___179;
      }
      while_break___179: /* CIL Label */ ;
      }
#line 817
      goto switch_break___4;
      case_81___0: /* CIL Label */ 
#line 820
      if ((unsigned long )file != (unsigned long )((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))) {
        {
#line 822
        tmp___250 = gettext("Page %d/%d");
#line 822
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)tmp___250,
                file->pages, file->pages);
        }
      } else {
        {
#line 826
        tmp___251 = gettext("Page %d/%c");
#line 826
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)tmp___251,
                file->pages, 4);
        }
      }
      {
#line 829
      while (1) {
        while_continue___182: /* CIL Label */ ;
        {
#line 829
        tmp___252 = strlen((char const   *)(buf___0));
#line 829
        len___49 = tmp___252;
        }
#line 829
        if (len___49 > width) {
#line 829
          nspace___49 = (size_t )0;
        } else {
#line 829
          nspace___49 = width - len___49;
        }
#line 829
        if (width) {
#line 829
          if (justification > 0) {
            {
#line 829
            while (1) {
              while_continue___183: /* CIL Label */ ;
#line 829
              if (! nspace___49) {
#line 829
                goto while_break___183;
              }
#line 829
              __o___185 = user_string_stack___0;
#line 829
              if ((unsigned long )(__o___185->next_free + 1) > (unsigned long )__o___185->chunk_limit) {
                {
#line 829
                _obstack_newchunk(__o___185, 1);
                }
              }
#line 829
              tmp___253 = __o___185->next_free;
#line 829
              (__o___185->next_free) ++;
#line 829
              *tmp___253 = (char )padding;
#line 829
              nspace___49 --;
            }
            while_break___183: /* CIL Label */ ;
            }
          }
        }
#line 829
        __o___186 = user_string_stack___0;
#line 829
        __len___49 = (int )len___49;
#line 829
        if ((unsigned long )(__o___186->next_free + __len___49) > (unsigned long )__o___186->chunk_limit) {
          {
#line 829
          _obstack_newchunk(__o___186, __len___49);
          }
        }
        {
#line 829
        memcpy((void */* __restrict  */)__o___186->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___49);
#line 829
        __o___186->next_free += __len___49;
        }
#line 829
        if (width) {
#line 829
          if (justification < 0) {
            {
#line 829
            while (1) {
              while_continue___184: /* CIL Label */ ;
#line 829
              if (! nspace___49) {
#line 829
                goto while_break___184;
              }
#line 829
              __o___187 = user_string_stack___0;
#line 829
              if ((unsigned long )(__o___187->next_free + 1) > (unsigned long )__o___187->chunk_limit) {
                {
#line 829
                _obstack_newchunk(__o___187, 1);
                }
              }
#line 829
              tmp___254 = __o___187->next_free;
#line 829
              (__o___187->next_free) ++;
#line 829
              *tmp___254 = (char )padding;
#line 829
              nspace___49 --;
            }
            while_break___184: /* CIL Label */ ;
            }
          }
        }
#line 829
        goto while_break___182;
      }
      while_break___182: /* CIL Label */ ;
      }
#line 830
      goto switch_break___4;
      case_115___0: /* CIL Label */ 
#line 833
      i ++;
      {
#line 834
      if ((int const   )*(str + i) == 60) {
#line 834
        goto case_60___0;
      }
#line 839
      if ((int const   )*(str + i) == 46) {
#line 839
        goto case_46___3;
      }
#line 844
      if ((int const   )*(str + i) == 62) {
#line 844
        goto case_62___0;
      }
#line 855
      if ((int const   )*(str + i) == 35) {
#line 855
        goto case_35___5;
      }
#line 866
      goto switch_default___7;
      case_60___0: /* CIL Label */ 
      {
#line 835
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              file->first_sheet);
      }
      {
#line 836
      while (1) {
        while_continue___185: /* CIL Label */ ;
        {
#line 836
        tmp___255 = strlen((char const   *)(buf___0));
#line 836
        len___50 = tmp___255;
        }
#line 836
        if (len___50 > width) {
#line 836
          nspace___50 = (size_t )0;
        } else {
#line 836
          nspace___50 = width - len___50;
        }
#line 836
        if (width) {
#line 836
          if (justification > 0) {
            {
#line 836
            while (1) {
              while_continue___186: /* CIL Label */ ;
#line 836
              if (! nspace___50) {
#line 836
                goto while_break___186;
              }
#line 836
              __o___188 = user_string_stack___0;
#line 836
              if ((unsigned long )(__o___188->next_free + 1) > (unsigned long )__o___188->chunk_limit) {
                {
#line 836
                _obstack_newchunk(__o___188, 1);
                }
              }
#line 836
              tmp___256 = __o___188->next_free;
#line 836
              (__o___188->next_free) ++;
#line 836
              *tmp___256 = (char )padding;
#line 836
              nspace___50 --;
            }
            while_break___186: /* CIL Label */ ;
            }
          }
        }
#line 836
        __o___189 = user_string_stack___0;
#line 836
        __len___50 = (int )len___50;
#line 836
        if ((unsigned long )(__o___189->next_free + __len___50) > (unsigned long )__o___189->chunk_limit) {
          {
#line 836
          _obstack_newchunk(__o___189, __len___50);
          }
        }
        {
#line 836
        memcpy((void */* __restrict  */)__o___189->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___50);
#line 836
        __o___189->next_free += __len___50;
        }
#line 836
        if (width) {
#line 836
          if (justification < 0) {
            {
#line 836
            while (1) {
              while_continue___187: /* CIL Label */ ;
#line 836
              if (! nspace___50) {
#line 836
                goto while_break___187;
              }
#line 836
              __o___190 = user_string_stack___0;
#line 836
              if ((unsigned long )(__o___190->next_free + 1) > (unsigned long )__o___190->chunk_limit) {
                {
#line 836
                _obstack_newchunk(__o___190, 1);
                }
              }
#line 836
              tmp___257 = __o___190->next_free;
#line 836
              (__o___190->next_free) ++;
#line 836
              *tmp___257 = (char )padding;
#line 836
              nspace___50 --;
            }
            while_break___187: /* CIL Label */ ;
            }
          }
        }
#line 836
        goto while_break___185;
      }
      while_break___185: /* CIL Label */ ;
      }
#line 837
      goto switch_break___9;
      case_46___3: /* CIL Label */ 
      {
#line 840
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              file->sheets);
      }
      {
#line 841
      while (1) {
        while_continue___188: /* CIL Label */ ;
        {
#line 841
        tmp___258 = strlen((char const   *)(buf___0));
#line 841
        len___51 = tmp___258;
        }
#line 841
        if (len___51 > width) {
#line 841
          nspace___51 = (size_t )0;
        } else {
#line 841
          nspace___51 = width - len___51;
        }
#line 841
        if (width) {
#line 841
          if (justification > 0) {
            {
#line 841
            while (1) {
              while_continue___189: /* CIL Label */ ;
#line 841
              if (! nspace___51) {
#line 841
                goto while_break___189;
              }
#line 841
              __o___191 = user_string_stack___0;
#line 841
              if ((unsigned long )(__o___191->next_free + 1) > (unsigned long )__o___191->chunk_limit) {
                {
#line 841
                _obstack_newchunk(__o___191, 1);
                }
              }
#line 841
              tmp___259 = __o___191->next_free;
#line 841
              (__o___191->next_free) ++;
#line 841
              *tmp___259 = (char )padding;
#line 841
              nspace___51 --;
            }
            while_break___189: /* CIL Label */ ;
            }
          }
        }
#line 841
        __o___192 = user_string_stack___0;
#line 841
        __len___51 = (int )len___51;
#line 841
        if ((unsigned long )(__o___192->next_free + __len___51) > (unsigned long )__o___192->chunk_limit) {
          {
#line 841
          _obstack_newchunk(__o___192, __len___51);
          }
        }
        {
#line 841
        memcpy((void */* __restrict  */)__o___192->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___51);
#line 841
        __o___192->next_free += __len___51;
        }
#line 841
        if (width) {
#line 841
          if (justification < 0) {
            {
#line 841
            while (1) {
              while_continue___190: /* CIL Label */ ;
#line 841
              if (! nspace___51) {
#line 841
                goto while_break___190;
              }
#line 841
              __o___193 = user_string_stack___0;
#line 841
              if ((unsigned long )(__o___193->next_free + 1) > (unsigned long )__o___193->chunk_limit) {
                {
#line 841
                _obstack_newchunk(__o___193, 1);
                }
              }
#line 841
              tmp___260 = __o___193->next_free;
#line 841
              (__o___193->next_free) ++;
#line 841
              *tmp___260 = (char )padding;
#line 841
              nspace___51 --;
            }
            while_break___190: /* CIL Label */ ;
            }
          }
        }
#line 841
        goto while_break___188;
      }
      while_break___188: /* CIL Label */ ;
      }
#line 842
      goto switch_break___9;
      case_62___0: /* CIL Label */ 
#line 845
      if ((unsigned long )file != (unsigned long )((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))) {
        {
#line 847
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
                file->last_sheet);
        }
        {
#line 848
        while (1) {
          while_continue___191: /* CIL Label */ ;
          {
#line 848
          tmp___261 = strlen((char const   *)(buf___0));
#line 848
          len___52 = tmp___261;
          }
#line 848
          if (len___52 > width) {
#line 848
            nspace___52 = (size_t )0;
          } else {
#line 848
            nspace___52 = width - len___52;
          }
#line 848
          if (width) {
#line 848
            if (justification > 0) {
              {
#line 848
              while (1) {
                while_continue___192: /* CIL Label */ ;
#line 848
                if (! nspace___52) {
#line 848
                  goto while_break___192;
                }
#line 848
                __o___194 = user_string_stack___0;
#line 848
                if ((unsigned long )(__o___194->next_free + 1) > (unsigned long )__o___194->chunk_limit) {
                  {
#line 848
                  _obstack_newchunk(__o___194, 1);
                  }
                }
#line 848
                tmp___262 = __o___194->next_free;
#line 848
                (__o___194->next_free) ++;
#line 848
                *tmp___262 = (char )padding;
#line 848
                nspace___52 --;
              }
              while_break___192: /* CIL Label */ ;
              }
            }
          }
#line 848
          __o___195 = user_string_stack___0;
#line 848
          __len___52 = (int )len___52;
#line 848
          if ((unsigned long )(__o___195->next_free + __len___52) > (unsigned long )__o___195->chunk_limit) {
            {
#line 848
            _obstack_newchunk(__o___195, __len___52);
            }
          }
          {
#line 848
          memcpy((void */* __restrict  */)__o___195->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
                 (size_t )__len___52);
#line 848
          __o___195->next_free += __len___52;
          }
#line 848
          if (width) {
#line 848
            if (justification < 0) {
              {
#line 848
              while (1) {
                while_continue___193: /* CIL Label */ ;
#line 848
                if (! nspace___52) {
#line 848
                  goto while_break___193;
                }
#line 848
                __o___196 = user_string_stack___0;
#line 848
                if ((unsigned long )(__o___196->next_free + 1) > (unsigned long )__o___196->chunk_limit) {
                  {
#line 848
                  _obstack_newchunk(__o___196, 1);
                  }
                }
#line 848
                tmp___263 = __o___196->next_free;
#line 848
                (__o___196->next_free) ++;
#line 848
                *tmp___263 = (char )padding;
#line 848
                nspace___52 --;
              }
              while_break___193: /* CIL Label */ ;
              }
            }
          }
#line 848
          goto while_break___191;
        }
        while_break___191: /* CIL Label */ ;
        }
      } else {
        {
#line 851
        while (1) {
          while_continue___194: /* CIL Label */ ;
#line 851
          if (width) {
#line 851
            if (justification < 0) {
#line 851
              __o___197 = user_string_stack___0;
#line 851
              if ((unsigned long )(__o___197->next_free + 1) > (unsigned long )__o___197->chunk_limit) {
                {
#line 851
                _obstack_newchunk(__o___197, 1);
                }
              }
#line 851
              tmp___264 = __o___197->next_free;
#line 851
              (__o___197->next_free) ++;
#line 851
              *tmp___264 = (char)8;
            }
          }
#line 851
          a___11 = 0;
          {
#line 851
          while (1) {
            while_continue___195: /* CIL Label */ ;
#line 851
            if (! (a___11 < (int )width - 1)) {
#line 851
              goto while_break___195;
            }
#line 851
            __o___198 = user_string_stack___0;
#line 851
            if ((unsigned long )(__o___198->next_free + 1) > (unsigned long )__o___198->chunk_limit) {
              {
#line 851
              _obstack_newchunk(__o___198, 1);
              }
            }
#line 851
            tmp___265 = __o___198->next_free;
#line 851
            (__o___198->next_free) ++;
#line 851
            *tmp___265 = (char )padding;
#line 851
            a___11 ++;
          }
          while_break___195: /* CIL Label */ ;
          }
#line 851
          if (! width) {
#line 851
            goto _L___13;
          } else
#line 851
          if (justification > 0) {
            _L___13: /* CIL Label */ 
#line 851
            __o___199 = user_string_stack___0;
#line 851
            if ((unsigned long )(__o___199->next_free + 1) > (unsigned long )__o___199->chunk_limit) {
              {
#line 851
              _obstack_newchunk(__o___199, 1);
              }
            }
#line 851
            tmp___266 = __o___199->next_free;
#line 851
            (__o___199->next_free) ++;
#line 851
            *tmp___266 = (char)8;
          }
#line 851
          goto while_break___194;
        }
        while_break___194: /* CIL Label */ ;
        }
      }
#line 853
      goto switch_break___9;
      case_35___5: /* CIL Label */ 
#line 856
      if ((unsigned long )file != (unsigned long )((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))) {
        {
#line 858
        sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
                file->sheets);
        }
        {
#line 859
        while (1) {
          while_continue___196: /* CIL Label */ ;
          {
#line 859
          tmp___267 = strlen((char const   *)(buf___0));
#line 859
          len___53 = tmp___267;
          }
#line 859
          if (len___53 > width) {
#line 859
            nspace___53 = (size_t )0;
          } else {
#line 859
            nspace___53 = width - len___53;
          }
#line 859
          if (width) {
#line 859
            if (justification > 0) {
              {
#line 859
              while (1) {
                while_continue___197: /* CIL Label */ ;
#line 859
                if (! nspace___53) {
#line 859
                  goto while_break___197;
                }
#line 859
                __o___200 = user_string_stack___0;
#line 859
                if ((unsigned long )(__o___200->next_free + 1) > (unsigned long )__o___200->chunk_limit) {
                  {
#line 859
                  _obstack_newchunk(__o___200, 1);
                  }
                }
#line 859
                tmp___268 = __o___200->next_free;
#line 859
                (__o___200->next_free) ++;
#line 859
                *tmp___268 = (char )padding;
#line 859
                nspace___53 --;
              }
              while_break___197: /* CIL Label */ ;
              }
            }
          }
#line 859
          __o___201 = user_string_stack___0;
#line 859
          __len___53 = (int )len___53;
#line 859
          if ((unsigned long )(__o___201->next_free + __len___53) > (unsigned long )__o___201->chunk_limit) {
            {
#line 859
            _obstack_newchunk(__o___201, __len___53);
            }
          }
          {
#line 859
          memcpy((void */* __restrict  */)__o___201->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
                 (size_t )__len___53);
#line 859
          __o___201->next_free += __len___53;
          }
#line 859
          if (width) {
#line 859
            if (justification < 0) {
              {
#line 859
              while (1) {
                while_continue___198: /* CIL Label */ ;
#line 859
                if (! nspace___53) {
#line 859
                  goto while_break___198;
                }
#line 859
                __o___202 = user_string_stack___0;
#line 859
                if ((unsigned long )(__o___202->next_free + 1) > (unsigned long )__o___202->chunk_limit) {
                  {
#line 859
                  _obstack_newchunk(__o___202, 1);
                  }
                }
#line 859
                tmp___269 = __o___202->next_free;
#line 859
                (__o___202->next_free) ++;
#line 859
                *tmp___269 = (char )padding;
#line 859
                nspace___53 --;
              }
              while_break___198: /* CIL Label */ ;
              }
            }
          }
#line 859
          goto while_break___196;
        }
        while_break___196: /* CIL Label */ ;
        }
      } else {
        {
#line 862
        while (1) {
          while_continue___199: /* CIL Label */ ;
#line 862
          if (width) {
#line 862
            if (justification < 0) {
#line 862
              __o___203 = user_string_stack___0;
#line 862
              if ((unsigned long )(__o___203->next_free + 1) > (unsigned long )__o___203->chunk_limit) {
                {
#line 862
                _obstack_newchunk(__o___203, 1);
                }
              }
#line 862
              tmp___270 = __o___203->next_free;
#line 862
              (__o___203->next_free) ++;
#line 862
              *tmp___270 = (char)5;
            }
          }
#line 862
          a___12 = 0;
          {
#line 862
          while (1) {
            while_continue___200: /* CIL Label */ ;
#line 862
            if (! (a___12 < (int )width - 1)) {
#line 862
              goto while_break___200;
            }
#line 862
            __o___204 = user_string_stack___0;
#line 862
            if ((unsigned long )(__o___204->next_free + 1) > (unsigned long )__o___204->chunk_limit) {
              {
#line 862
              _obstack_newchunk(__o___204, 1);
              }
            }
#line 862
            tmp___271 = __o___204->next_free;
#line 862
            (__o___204->next_free) ++;
#line 862
            *tmp___271 = (char )padding;
#line 862
            a___12 ++;
          }
          while_break___200: /* CIL Label */ ;
          }
#line 862
          if (! width) {
#line 862
            goto _L___14;
          } else
#line 862
          if (justification > 0) {
            _L___14: /* CIL Label */ 
#line 862
            __o___205 = user_string_stack___0;
#line 862
            if ((unsigned long )(__o___205->next_free + 1) > (unsigned long )__o___205->chunk_limit) {
              {
#line 862
              _obstack_newchunk(__o___205, 1);
              }
            }
#line 862
            tmp___272 = __o___205->next_free;
#line 862
            (__o___205->next_free) ++;
#line 862
            *tmp___272 = (char)5;
          }
#line 862
          goto while_break___199;
        }
        while_break___199: /* CIL Label */ ;
        }
      }
#line 864
      goto switch_break___9;
      switch_default___7: /* CIL Label */ 
      {
#line 867
      tmp___273 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 867
      error(1, 0, (char const   *)tmp___273, context_name, "$s", (int const   )*(str + i),
            (int const   )*(str + i));
      }
#line 869
      goto switch_break___9;
      switch_break___9: /* CIL Label */ ;
      }
#line 871
      goto switch_break___4;
      case_116___0: /* CIL Label */ 
      {
#line 875
      if ((int const   )*(str + (i + 1U)) == 49) {
#line 875
        goto case_49;
      }
#line 880
      if ((int const   )*(str + (i + 1U)) == 50) {
#line 880
        goto case_50;
      }
#line 885
      if ((int const   )*(str + (i + 1U)) == 51) {
#line 885
        goto case_51;
      }
#line 890
      if ((int const   )*(str + (i + 1U)) == 52) {
#line 890
        goto case_52;
      }
#line 895
      goto switch_default___8;
      case_49: /* CIL Label */ 
#line 876
      i ++;
      {
#line 877
      while (1) {
        while_continue___201: /* CIL Label */ ;
        {
#line 877
        tmp___274 = strlen((char const   *)(job___0->tag1));
#line 877
        len___54 = tmp___274;
        }
#line 877
        if (len___54 > width) {
#line 877
          nspace___54 = (size_t )0;
        } else {
#line 877
          nspace___54 = width - len___54;
        }
#line 877
        if (width) {
#line 877
          if (justification > 0) {
            {
#line 877
            while (1) {
              while_continue___202: /* CIL Label */ ;
#line 877
              if (! nspace___54) {
#line 877
                goto while_break___202;
              }
#line 877
              __o___206 = user_string_stack___0;
#line 877
              if ((unsigned long )(__o___206->next_free + 1) > (unsigned long )__o___206->chunk_limit) {
                {
#line 877
                _obstack_newchunk(__o___206, 1);
                }
              }
#line 877
              tmp___275 = __o___206->next_free;
#line 877
              (__o___206->next_free) ++;
#line 877
              *tmp___275 = (char )padding;
#line 877
              nspace___54 --;
            }
            while_break___202: /* CIL Label */ ;
            }
          }
        }
#line 877
        __o___207 = user_string_stack___0;
#line 877
        __len___54 = (int )len___54;
#line 877
        if ((unsigned long )(__o___207->next_free + __len___54) > (unsigned long )__o___207->chunk_limit) {
          {
#line 877
          _obstack_newchunk(__o___207, __len___54);
          }
        }
        {
#line 877
        memcpy((void */* __restrict  */)__o___207->next_free, (void const   */* __restrict  */)((char *)(job___0->tag1)),
               (size_t )__len___54);
#line 877
        __o___207->next_free += __len___54;
        }
#line 877
        if (width) {
#line 877
          if (justification < 0) {
            {
#line 877
            while (1) {
              while_continue___203: /* CIL Label */ ;
#line 877
              if (! nspace___54) {
#line 877
                goto while_break___203;
              }
#line 877
              __o___208 = user_string_stack___0;
#line 877
              if ((unsigned long )(__o___208->next_free + 1) > (unsigned long )__o___208->chunk_limit) {
                {
#line 877
                _obstack_newchunk(__o___208, 1);
                }
              }
#line 877
              tmp___276 = __o___208->next_free;
#line 877
              (__o___208->next_free) ++;
#line 877
              *tmp___276 = (char )padding;
#line 877
              nspace___54 --;
            }
            while_break___203: /* CIL Label */ ;
            }
          }
        }
#line 877
        goto while_break___201;
      }
      while_break___201: /* CIL Label */ ;
      }
#line 878
      goto switch_break___10;
      case_50: /* CIL Label */ 
#line 881
      i ++;
      {
#line 882
      while (1) {
        while_continue___204: /* CIL Label */ ;
        {
#line 882
        tmp___277 = strlen((char const   *)(job___0->tag2));
#line 882
        len___55 = tmp___277;
        }
#line 882
        if (len___55 > width) {
#line 882
          nspace___55 = (size_t )0;
        } else {
#line 882
          nspace___55 = width - len___55;
        }
#line 882
        if (width) {
#line 882
          if (justification > 0) {
            {
#line 882
            while (1) {
              while_continue___205: /* CIL Label */ ;
#line 882
              if (! nspace___55) {
#line 882
                goto while_break___205;
              }
#line 882
              __o___209 = user_string_stack___0;
#line 882
              if ((unsigned long )(__o___209->next_free + 1) > (unsigned long )__o___209->chunk_limit) {
                {
#line 882
                _obstack_newchunk(__o___209, 1);
                }
              }
#line 882
              tmp___278 = __o___209->next_free;
#line 882
              (__o___209->next_free) ++;
#line 882
              *tmp___278 = (char )padding;
#line 882
              nspace___55 --;
            }
            while_break___205: /* CIL Label */ ;
            }
          }
        }
#line 882
        __o___210 = user_string_stack___0;
#line 882
        __len___55 = (int )len___55;
#line 882
        if ((unsigned long )(__o___210->next_free + __len___55) > (unsigned long )__o___210->chunk_limit) {
          {
#line 882
          _obstack_newchunk(__o___210, __len___55);
          }
        }
        {
#line 882
        memcpy((void */* __restrict  */)__o___210->next_free, (void const   */* __restrict  */)((char *)(job___0->tag2)),
               (size_t )__len___55);
#line 882
        __o___210->next_free += __len___55;
        }
#line 882
        if (width) {
#line 882
          if (justification < 0) {
            {
#line 882
            while (1) {
              while_continue___206: /* CIL Label */ ;
#line 882
              if (! nspace___55) {
#line 882
                goto while_break___206;
              }
#line 882
              __o___211 = user_string_stack___0;
#line 882
              if ((unsigned long )(__o___211->next_free + 1) > (unsigned long )__o___211->chunk_limit) {
                {
#line 882
                _obstack_newchunk(__o___211, 1);
                }
              }
#line 882
              tmp___279 = __o___211->next_free;
#line 882
              (__o___211->next_free) ++;
#line 882
              *tmp___279 = (char )padding;
#line 882
              nspace___55 --;
            }
            while_break___206: /* CIL Label */ ;
            }
          }
        }
#line 882
        goto while_break___204;
      }
      while_break___204: /* CIL Label */ ;
      }
#line 883
      goto switch_break___10;
      case_51: /* CIL Label */ 
#line 886
      i ++;
      {
#line 887
      while (1) {
        while_continue___207: /* CIL Label */ ;
        {
#line 887
        tmp___280 = strlen((char const   *)(job___0->tag3));
#line 887
        len___56 = tmp___280;
        }
#line 887
        if (len___56 > width) {
#line 887
          nspace___56 = (size_t )0;
        } else {
#line 887
          nspace___56 = width - len___56;
        }
#line 887
        if (width) {
#line 887
          if (justification > 0) {
            {
#line 887
            while (1) {
              while_continue___208: /* CIL Label */ ;
#line 887
              if (! nspace___56) {
#line 887
                goto while_break___208;
              }
#line 887
              __o___212 = user_string_stack___0;
#line 887
              if ((unsigned long )(__o___212->next_free + 1) > (unsigned long )__o___212->chunk_limit) {
                {
#line 887
                _obstack_newchunk(__o___212, 1);
                }
              }
#line 887
              tmp___281 = __o___212->next_free;
#line 887
              (__o___212->next_free) ++;
#line 887
              *tmp___281 = (char )padding;
#line 887
              nspace___56 --;
            }
            while_break___208: /* CIL Label */ ;
            }
          }
        }
#line 887
        __o___213 = user_string_stack___0;
#line 887
        __len___56 = (int )len___56;
#line 887
        if ((unsigned long )(__o___213->next_free + __len___56) > (unsigned long )__o___213->chunk_limit) {
          {
#line 887
          _obstack_newchunk(__o___213, __len___56);
          }
        }
        {
#line 887
        memcpy((void */* __restrict  */)__o___213->next_free, (void const   */* __restrict  */)((char *)(job___0->tag3)),
               (size_t )__len___56);
#line 887
        __o___213->next_free += __len___56;
        }
#line 887
        if (width) {
#line 887
          if (justification < 0) {
            {
#line 887
            while (1) {
              while_continue___209: /* CIL Label */ ;
#line 887
              if (! nspace___56) {
#line 887
                goto while_break___209;
              }
#line 887
              __o___214 = user_string_stack___0;
#line 887
              if ((unsigned long )(__o___214->next_free + 1) > (unsigned long )__o___214->chunk_limit) {
                {
#line 887
                _obstack_newchunk(__o___214, 1);
                }
              }
#line 887
              tmp___282 = __o___214->next_free;
#line 887
              (__o___214->next_free) ++;
#line 887
              *tmp___282 = (char )padding;
#line 887
              nspace___56 --;
            }
            while_break___209: /* CIL Label */ ;
            }
          }
        }
#line 887
        goto while_break___207;
      }
      while_break___207: /* CIL Label */ ;
      }
#line 888
      goto switch_break___10;
      case_52: /* CIL Label */ 
#line 891
      i ++;
      {
#line 892
      while (1) {
        while_continue___210: /* CIL Label */ ;
        {
#line 892
        tmp___283 = strlen((char const   *)(job___0->tag4));
#line 892
        len___57 = tmp___283;
        }
#line 892
        if (len___57 > width) {
#line 892
          nspace___57 = (size_t )0;
        } else {
#line 892
          nspace___57 = width - len___57;
        }
#line 892
        if (width) {
#line 892
          if (justification > 0) {
            {
#line 892
            while (1) {
              while_continue___211: /* CIL Label */ ;
#line 892
              if (! nspace___57) {
#line 892
                goto while_break___211;
              }
#line 892
              __o___215 = user_string_stack___0;
#line 892
              if ((unsigned long )(__o___215->next_free + 1) > (unsigned long )__o___215->chunk_limit) {
                {
#line 892
                _obstack_newchunk(__o___215, 1);
                }
              }
#line 892
              tmp___284 = __o___215->next_free;
#line 892
              (__o___215->next_free) ++;
#line 892
              *tmp___284 = (char )padding;
#line 892
              nspace___57 --;
            }
            while_break___211: /* CIL Label */ ;
            }
          }
        }
#line 892
        __o___216 = user_string_stack___0;
#line 892
        __len___57 = (int )len___57;
#line 892
        if ((unsigned long )(__o___216->next_free + __len___57) > (unsigned long )__o___216->chunk_limit) {
          {
#line 892
          _obstack_newchunk(__o___216, __len___57);
          }
        }
        {
#line 892
        memcpy((void */* __restrict  */)__o___216->next_free, (void const   */* __restrict  */)((char *)(job___0->tag4)),
               (size_t )__len___57);
#line 892
        __o___216->next_free += __len___57;
        }
#line 892
        if (width) {
#line 892
          if (justification < 0) {
            {
#line 892
            while (1) {
              while_continue___212: /* CIL Label */ ;
#line 892
              if (! nspace___57) {
#line 892
                goto while_break___212;
              }
#line 892
              __o___217 = user_string_stack___0;
#line 892
              if ((unsigned long )(__o___217->next_free + 1) > (unsigned long )__o___217->chunk_limit) {
                {
#line 892
                _obstack_newchunk(__o___217, 1);
                }
              }
#line 892
              tmp___285 = __o___217->next_free;
#line 892
              (__o___217->next_free) ++;
#line 892
              *tmp___285 = (char )padding;
#line 892
              nspace___57 --;
            }
            while_break___212: /* CIL Label */ ;
            }
          }
        }
#line 892
        goto while_break___210;
      }
      while_break___210: /* CIL Label */ ;
      }
#line 893
      goto switch_break___10;
      switch_default___8: /* CIL Label */ 
#line 896
      if (file->mod_tm.tm_hour > 12) {
#line 896
        tmp___286 = "pm";
      } else {
#line 896
        tmp___286 = "am";
      }
#line 896
      if (file->mod_tm.tm_hour > 12) {
#line 896
        tmp___287 = file->mod_tm.tm_hour - 12;
      } else {
#line 896
        tmp___287 = file->mod_tm.tm_hour;
      }
      {
#line 896
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d:%02d%s",
              tmp___287, file->mod_tm.tm_min, tmp___286);
      }
      {
#line 902
      while (1) {
        while_continue___213: /* CIL Label */ ;
        {
#line 902
        tmp___288 = strlen((char const   *)(buf___0));
#line 902
        len___58 = tmp___288;
        }
#line 902
        if (len___58 > width) {
#line 902
          nspace___58 = (size_t )0;
        } else {
#line 902
          nspace___58 = width - len___58;
        }
#line 902
        if (width) {
#line 902
          if (justification > 0) {
            {
#line 902
            while (1) {
              while_continue___214: /* CIL Label */ ;
#line 902
              if (! nspace___58) {
#line 902
                goto while_break___214;
              }
#line 902
              __o___218 = user_string_stack___0;
#line 902
              if ((unsigned long )(__o___218->next_free + 1) > (unsigned long )__o___218->chunk_limit) {
                {
#line 902
                _obstack_newchunk(__o___218, 1);
                }
              }
#line 902
              tmp___289 = __o___218->next_free;
#line 902
              (__o___218->next_free) ++;
#line 902
              *tmp___289 = (char )padding;
#line 902
              nspace___58 --;
            }
            while_break___214: /* CIL Label */ ;
            }
          }
        }
#line 902
        __o___219 = user_string_stack___0;
#line 902
        __len___58 = (int )len___58;
#line 902
        if ((unsigned long )(__o___219->next_free + __len___58) > (unsigned long )__o___219->chunk_limit) {
          {
#line 902
          _obstack_newchunk(__o___219, __len___58);
          }
        }
        {
#line 902
        memcpy((void */* __restrict  */)__o___219->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___58);
#line 902
        __o___219->next_free += __len___58;
        }
#line 902
        if (width) {
#line 902
          if (justification < 0) {
            {
#line 902
            while (1) {
              while_continue___215: /* CIL Label */ ;
#line 902
              if (! nspace___58) {
#line 902
                goto while_break___215;
              }
#line 902
              __o___220 = user_string_stack___0;
#line 902
              if ((unsigned long )(__o___220->next_free + 1) > (unsigned long )__o___220->chunk_limit) {
                {
#line 902
                _obstack_newchunk(__o___220, 1);
                }
              }
#line 902
              tmp___290 = __o___220->next_free;
#line 902
              (__o___220->next_free) ++;
#line 902
              *tmp___290 = (char )padding;
#line 902
              nspace___58 --;
            }
            while_break___215: /* CIL Label */ ;
            }
          }
        }
#line 902
        goto while_break___213;
      }
      while_break___213: /* CIL Label */ ;
      }
      switch_break___10: /* CIL Label */ ;
      }
#line 904
      goto switch_break___4;
      case_84___0: /* CIL Label */ 
      {
#line 907
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d:%02d",
              file->mod_tm.tm_hour, file->mod_tm.tm_min);
      }
      {
#line 910
      while (1) {
        while_continue___216: /* CIL Label */ ;
        {
#line 910
        tmp___291 = strlen((char const   *)(buf___0));
#line 910
        len___59 = tmp___291;
        }
#line 910
        if (len___59 > width) {
#line 910
          nspace___59 = (size_t )0;
        } else {
#line 910
          nspace___59 = width - len___59;
        }
#line 910
        if (width) {
#line 910
          if (justification > 0) {
            {
#line 910
            while (1) {
              while_continue___217: /* CIL Label */ ;
#line 910
              if (! nspace___59) {
#line 910
                goto while_break___217;
              }
#line 910
              __o___221 = user_string_stack___0;
#line 910
              if ((unsigned long )(__o___221->next_free + 1) > (unsigned long )__o___221->chunk_limit) {
                {
#line 910
                _obstack_newchunk(__o___221, 1);
                }
              }
#line 910
              tmp___292 = __o___221->next_free;
#line 910
              (__o___221->next_free) ++;
#line 910
              *tmp___292 = (char )padding;
#line 910
              nspace___59 --;
            }
            while_break___217: /* CIL Label */ ;
            }
          }
        }
#line 910
        __o___222 = user_string_stack___0;
#line 910
        __len___59 = (int )len___59;
#line 910
        if ((unsigned long )(__o___222->next_free + __len___59) > (unsigned long )__o___222->chunk_limit) {
          {
#line 910
          _obstack_newchunk(__o___222, __len___59);
          }
        }
        {
#line 910
        memcpy((void */* __restrict  */)__o___222->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___59);
#line 910
        __o___222->next_free += __len___59;
        }
#line 910
        if (width) {
#line 910
          if (justification < 0) {
            {
#line 910
            while (1) {
              while_continue___218: /* CIL Label */ ;
#line 910
              if (! nspace___59) {
#line 910
                goto while_break___218;
              }
#line 910
              __o___223 = user_string_stack___0;
#line 910
              if ((unsigned long )(__o___223->next_free + 1) > (unsigned long )__o___223->chunk_limit) {
                {
#line 910
                _obstack_newchunk(__o___223, 1);
                }
              }
#line 910
              tmp___293 = __o___223->next_free;
#line 910
              (__o___223->next_free) ++;
#line 910
              *tmp___293 = (char )padding;
#line 910
              nspace___59 --;
            }
            while_break___218: /* CIL Label */ ;
            }
          }
        }
#line 910
        goto while_break___216;
      }
      while_break___216: /* CIL Label */ ;
      }
#line 911
      goto switch_break___4;
      case_87___0: /* CIL Label */ 
      {
#line 914
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%02d/%02d/%02d",
              file->mod_tm.tm_mon + 1, file->mod_tm.tm_mday, file->mod_tm.tm_year % 100);
      }
      {
#line 918
      while (1) {
        while_continue___219: /* CIL Label */ ;
        {
#line 918
        tmp___294 = strlen((char const   *)(buf___0));
#line 918
        len___60 = tmp___294;
        }
#line 918
        if (len___60 > width) {
#line 918
          nspace___60 = (size_t )0;
        } else {
#line 918
          nspace___60 = width - len___60;
        }
#line 918
        if (width) {
#line 918
          if (justification > 0) {
            {
#line 918
            while (1) {
              while_continue___220: /* CIL Label */ ;
#line 918
              if (! nspace___60) {
#line 918
                goto while_break___220;
              }
#line 918
              __o___224 = user_string_stack___0;
#line 918
              if ((unsigned long )(__o___224->next_free + 1) > (unsigned long )__o___224->chunk_limit) {
                {
#line 918
                _obstack_newchunk(__o___224, 1);
                }
              }
#line 918
              tmp___295 = __o___224->next_free;
#line 918
              (__o___224->next_free) ++;
#line 918
              *tmp___295 = (char )padding;
#line 918
              nspace___60 --;
            }
            while_break___220: /* CIL Label */ ;
            }
          }
        }
#line 918
        __o___225 = user_string_stack___0;
#line 918
        __len___60 = (int )len___60;
#line 918
        if ((unsigned long )(__o___225->next_free + __len___60) > (unsigned long )__o___225->chunk_limit) {
          {
#line 918
          _obstack_newchunk(__o___225, __len___60);
          }
        }
        {
#line 918
        memcpy((void */* __restrict  */)__o___225->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___60);
#line 918
        __o___225->next_free += __len___60;
        }
#line 918
        if (width) {
#line 918
          if (justification < 0) {
            {
#line 918
            while (1) {
              while_continue___221: /* CIL Label */ ;
#line 918
              if (! nspace___60) {
#line 918
                goto while_break___221;
              }
#line 918
              __o___226 = user_string_stack___0;
#line 918
              if ((unsigned long )(__o___226->next_free + 1) > (unsigned long )__o___226->chunk_limit) {
                {
#line 918
                _obstack_newchunk(__o___226, 1);
                }
              }
#line 918
              tmp___296 = __o___226->next_free;
#line 918
              (__o___226->next_free) ++;
#line 918
              *tmp___296 = (char )padding;
#line 918
              nspace___60 --;
            }
            while_break___221: /* CIL Label */ ;
            }
          }
        }
#line 918
        goto while_break___219;
      }
      while_break___219: /* CIL Label */ ;
      }
#line 919
      goto switch_break___4;
      switch_default___9: /* CIL Label */ 
      {
#line 922
      tmp___297 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 922
      error(1, 0, (char const   *)tmp___297, context_name, "$", (int const   )*(str + i),
            (int const   )*(str + i));
      }
#line 924
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
#line 926
      goto switch_break;
      case_35___6: /* CIL Label */ 
      {
#line 939
      if ((int const   )*(str + i) == 35) {
#line 939
        goto case_35___7;
      }
#line 943
      if ((int const   )*(str + i) == 40) {
#line 943
        goto case_40___0;
      }
#line 967
      if ((int const   )*(str + i) == 123) {
#line 967
        goto case_123___0;
      }
#line 1027
      if ((int const   )*(str + i) == 46) {
#line 1027
        goto case_46___4;
      }
#line 1032
      if ((int const   )*(str + i) == 63) {
#line 1032
        goto case_63;
      }
#line 1123
      if ((int const   )*(str + i) == 33) {
#line 1123
        goto case_33;
      }
#line 1242
      if ((int const   )*(str + i) == 102) {
#line 1242
        goto case_102___2;
      }
#line 1253
      if ((int const   )*(str + i) == 104) {
#line 1253
        goto case_104;
      }
#line 1258
      if ((int const   )*(str + i) == 111) {
#line 1258
        goto case_111___0;
      }
#line 1262
      if ((int const   )*(str + i) == 79) {
#line 1262
        goto case_79;
      }
#line 1272
      if ((int const   )*(str + i) == 112) {
#line 1272
        goto case_112___2;
      }
#line 1278
      if ((int const   )*(str + i) == 118) {
#line 1278
        goto case_118___0;
      }
#line 1283
      if ((int const   )*(str + i) == 119) {
#line 1283
        goto case_119;
      }
#line 1288
      goto switch_default___14;
      case_35___7: /* CIL Label */ 
      {
#line 940
      while (1) {
        while_continue___222: /* CIL Label */ ;
#line 940
        if (width) {
#line 940
          if (justification < 0) {
#line 940
            __o___227 = user_string_stack___0;
#line 940
            if ((unsigned long )(__o___227->next_free + 1) > (unsigned long )__o___227->chunk_limit) {
              {
#line 940
              _obstack_newchunk(__o___227, 1);
              }
            }
#line 940
            tmp___298 = __o___227->next_free;
#line 940
            (__o___227->next_free) ++;
#line 940
            *tmp___298 = (char )'#';
          }
        }
#line 940
        a___13 = 0;
        {
#line 940
        while (1) {
          while_continue___223: /* CIL Label */ ;
#line 940
          if (! (a___13 < (int )width - 1)) {
#line 940
            goto while_break___223;
          }
#line 940
          __o___228 = user_string_stack___0;
#line 940
          if ((unsigned long )(__o___228->next_free + 1) > (unsigned long )__o___228->chunk_limit) {
            {
#line 940
            _obstack_newchunk(__o___228, 1);
            }
          }
#line 940
          tmp___299 = __o___228->next_free;
#line 940
          (__o___228->next_free) ++;
#line 940
          *tmp___299 = (char )padding;
#line 940
          a___13 ++;
        }
        while_break___223: /* CIL Label */ ;
        }
#line 940
        if (! width) {
#line 940
          goto _L___15;
        } else
#line 940
        if (justification > 0) {
          _L___15: /* CIL Label */ 
#line 940
          __o___229 = user_string_stack___0;
#line 940
          if ((unsigned long )(__o___229->next_free + 1) > (unsigned long )__o___229->chunk_limit) {
            {
#line 940
            _obstack_newchunk(__o___229, 1);
            }
          }
#line 940
          tmp___300 = __o___229->next_free;
#line 940
          (__o___229->next_free) ++;
#line 940
          *tmp___300 = (char )'#';
        }
#line 940
        goto while_break___222;
      }
      while_break___222: /* CIL Label */ ;
      }
#line 941
      goto switch_break___11;
      case_40___0: /* CIL Label */ 
#line 945
      j = (size_t )0;
#line 945
      i ++;
      {
#line 945
      while (1) {
        while_continue___224: /* CIL Label */ ;
#line 945
        if (*(str + i)) {
#line 945
          if ((int const   )*(str + i) != 41) {
#line 945
            if (! ((unsigned long )j < sizeof(buf___0) - 1UL)) {
#line 945
              goto while_break___224;
            }
          } else {
#line 945
            goto while_break___224;
          }
        } else {
#line 945
          goto while_break___224;
        }
#line 948
        tmp___301 = j;
#line 948
        j ++;
#line 948
        buf___0[tmp___301] = (unsigned char )*(str + i);
#line 945
        i ++;
      }
      while_break___224: /* CIL Label */ ;
      }
#line 950
      if ((int const   )*(str + i) == 0) {
        {
#line 951
        tmp___302 = gettext("%s: missing `%c\' for %s%c escape");
#line 951
        error(1, 0, (char const   *)tmp___302, context_name, ')', "#(", ')');
        }
      }
#line 953
      if ((int const   )*(str + i) != 41) {
        {
#line 954
        tmp___303 = gettext("%s: too long argument for %s escape");
#line 954
        error(1, 0, (char const   *)tmp___303, context_name, "#()");
        }
      }
      {
#line 956
      buf___0[j] = (unsigned char )'\000';
#line 958
      tmp___304 = macro_meta_sequence_get(job___0, (char const   *)((char *)(buf___0)));
#line 958
      cp = (unsigned char *)tmp___304;
      }
#line 960
      if (cp) {
        {
#line 961
        grow_user_string_obstack(user_string_stack___0, job___0, file, context_name,
                                 (unsigned char const   *)cp);
        }
      }
#line 964
      goto switch_break___11;
      case_123___0: /* CIL Label */ 
#line 968
      cp2 = (unsigned char *)((void *)0);
#line 969
      j = (size_t )0;
#line 969
      i ++;
      {
#line 969
      while (1) {
        while_continue___225: /* CIL Label */ ;
#line 969
        if ((int const   )*(str + i) != 125) {
#line 969
          if (! ((unsigned long )j < sizeof(buf___0) - 1UL)) {
#line 969
            goto while_break___225;
          }
        } else {
#line 969
          goto while_break___225;
        }
        {
#line 971
        if ((int const   )*(str + i) == 0) {
#line 971
          goto case_0___0;
        }
#line 976
        if ((int const   )*(str + i) == 58) {
#line 976
          goto case_58___0;
        }
#line 982
        goto switch_default___10;
        case_0___0: /* CIL Label */ 
        {
#line 972
        tmp___305 = gettext("%s: missing `%c\' for %s%c escape");
#line 972
        error(1, 0, (char const   *)tmp___305, context_name, '}', "#{", '}');
        }
#line 974
        goto switch_break___12;
        case_58___0: /* CIL Label */ 
#line 978
        tmp___306 = j;
#line 978
        j ++;
#line 978
        buf___0[tmp___306] = (unsigned char )'\000';
#line 979
        cp2 = buf___0 + j;
#line 980
        goto switch_break___12;
        switch_default___10: /* CIL Label */ 
#line 983
        tmp___307 = j;
#line 983
        j ++;
#line 983
        buf___0[tmp___307] = (unsigned char )*(str + i);
#line 984
        goto switch_break___12;
        switch_break___12: /* CIL Label */ ;
        }
#line 969
        i ++;
      }
      while_break___225: /* CIL Label */ ;
      }
#line 986
      if ((int const   )*(str + i) != 125) {
        {
#line 987
        tmp___308 = gettext("%s: too long argument for %s escape");
#line 987
        error(1, 0, (char const   *)tmp___308, context_name, "#{}");
        }
      }
      {
#line 989
      buf___0[j] = (unsigned char )'\000';
#line 992
      tmp___309 = macro_meta_sequence_get(job___0, (char const   *)((char *)(buf___0)));
#line 992
      cp = (unsigned char *)tmp___309;
      }
#line 993
      if ((unsigned long )((char const   *)cp2) == (unsigned long )((void *)0)) {
#line 993
        goto _L___17;
      } else
#line 993
      if ((int )*cp2 == 0) {
        _L___17: /* CIL Label */ 
#line 996
        if (cp) {
          {
#line 997
          grow_user_string_obstack(user_string_stack___0, job___0, file, context_name,
                                   (unsigned char const   *)cp);
          }
        }
      } else {
        {
#line 1005
        if ((int )*cp2 == 45) {
#line 1005
          goto case_45___1;
        }
#line 1014
        if ((int )*cp2 == 43) {
#line 1014
          goto case_43___0;
        }
#line 1019
        goto switch_default___11;
        case_45___1: /* CIL Label */ 
#line 1006
        if ((unsigned long )((char const   *)cp) == (unsigned long )((void *)0)) {
#line 1006
          goto _L___16;
        } else
#line 1006
        if ((int )*cp == 0) {
          _L___16: /* CIL Label */ 
          {
#line 1011
          while (1) {
            while_continue___226: /* CIL Label */ ;
            {
#line 1011
            tmp___310 = strlen((char const   *)(cp2 + 1));
#line 1011
            len___61 = tmp___310;
            }
#line 1011
            if (len___61 > width) {
#line 1011
              nspace___61 = (size_t )0;
            } else {
#line 1011
              nspace___61 = width - len___61;
            }
#line 1011
            if (width) {
#line 1011
              if (justification > 0) {
                {
#line 1011
                while (1) {
                  while_continue___227: /* CIL Label */ ;
#line 1011
                  if (! nspace___61) {
#line 1011
                    goto while_break___227;
                  }
#line 1011
                  __o___230 = user_string_stack___0;
#line 1011
                  if ((unsigned long )(__o___230->next_free + 1) > (unsigned long )__o___230->chunk_limit) {
                    {
#line 1011
                    _obstack_newchunk(__o___230, 1);
                    }
                  }
#line 1011
                  tmp___311 = __o___230->next_free;
#line 1011
                  (__o___230->next_free) ++;
#line 1011
                  *tmp___311 = (char )padding;
#line 1011
                  nspace___61 --;
                }
                while_break___227: /* CIL Label */ ;
                }
              }
            }
#line 1011
            __o___231 = user_string_stack___0;
#line 1011
            __len___61 = (int )len___61;
#line 1011
            if ((unsigned long )(__o___231->next_free + __len___61) > (unsigned long )__o___231->chunk_limit) {
              {
#line 1011
              _obstack_newchunk(__o___231, __len___61);
              }
            }
            {
#line 1011
            memcpy((void */* __restrict  */)__o___231->next_free, (void const   */* __restrict  */)((char *)(cp2 + 1)),
                   (size_t )__len___61);
#line 1011
            __o___231->next_free += __len___61;
            }
#line 1011
            if (width) {
#line 1011
              if (justification < 0) {
                {
#line 1011
                while (1) {
                  while_continue___228: /* CIL Label */ ;
#line 1011
                  if (! nspace___61) {
#line 1011
                    goto while_break___228;
                  }
#line 1011
                  __o___232 = user_string_stack___0;
#line 1011
                  if ((unsigned long )(__o___232->next_free + 1) > (unsigned long )__o___232->chunk_limit) {
                    {
#line 1011
                    _obstack_newchunk(__o___232, 1);
                    }
                  }
#line 1011
                  tmp___312 = __o___232->next_free;
#line 1011
                  (__o___232->next_free) ++;
#line 1011
                  *tmp___312 = (char )padding;
#line 1011
                  nspace___61 --;
                }
                while_break___228: /* CIL Label */ ;
                }
              }
            }
#line 1011
            goto while_break___226;
          }
          while_break___226: /* CIL Label */ ;
          }
        } else {
          {
#line 1007
          grow_user_string_obstack(user_string_stack___0, job___0, file, context_name,
                                   (unsigned char const   *)cp);
          }
        }
#line 1012
        goto switch_break___13;
        case_43___0: /* CIL Label */ 
#line 1015
        if (! ((unsigned long )((char const   *)cp) == (unsigned long )((void *)0))) {
#line 1015
          if (! ((int )*cp == 0)) {
            {
#line 1016
            while (1) {
              while_continue___229: /* CIL Label */ ;
              {
#line 1016
              tmp___313 = strlen((char const   *)(cp2 + 1));
#line 1016
              len___62 = tmp___313;
              }
#line 1016
              if (len___62 > width) {
#line 1016
                nspace___62 = (size_t )0;
              } else {
#line 1016
                nspace___62 = width - len___62;
              }
#line 1016
              if (width) {
#line 1016
                if (justification > 0) {
                  {
#line 1016
                  while (1) {
                    while_continue___230: /* CIL Label */ ;
#line 1016
                    if (! nspace___62) {
#line 1016
                      goto while_break___230;
                    }
#line 1016
                    __o___233 = user_string_stack___0;
#line 1016
                    if ((unsigned long )(__o___233->next_free + 1) > (unsigned long )__o___233->chunk_limit) {
                      {
#line 1016
                      _obstack_newchunk(__o___233, 1);
                      }
                    }
#line 1016
                    tmp___314 = __o___233->next_free;
#line 1016
                    (__o___233->next_free) ++;
#line 1016
                    *tmp___314 = (char )padding;
#line 1016
                    nspace___62 --;
                  }
                  while_break___230: /* CIL Label */ ;
                  }
                }
              }
#line 1016
              __o___234 = user_string_stack___0;
#line 1016
              __len___62 = (int )len___62;
#line 1016
              if ((unsigned long )(__o___234->next_free + __len___62) > (unsigned long )__o___234->chunk_limit) {
                {
#line 1016
                _obstack_newchunk(__o___234, __len___62);
                }
              }
              {
#line 1016
              memcpy((void */* __restrict  */)__o___234->next_free, (void const   */* __restrict  */)((char *)(cp2 + 1)),
                     (size_t )__len___62);
#line 1016
              __o___234->next_free += __len___62;
              }
#line 1016
              if (width) {
#line 1016
                if (justification < 0) {
                  {
#line 1016
                  while (1) {
                    while_continue___231: /* CIL Label */ ;
#line 1016
                    if (! nspace___62) {
#line 1016
                      goto while_break___231;
                    }
#line 1016
                    __o___235 = user_string_stack___0;
#line 1016
                    if ((unsigned long )(__o___235->next_free + 1) > (unsigned long )__o___235->chunk_limit) {
                      {
#line 1016
                      _obstack_newchunk(__o___235, 1);
                      }
                    }
#line 1016
                    tmp___315 = __o___235->next_free;
#line 1016
                    (__o___235->next_free) ++;
#line 1016
                    *tmp___315 = (char )padding;
#line 1016
                    nspace___62 --;
                  }
                  while_break___231: /* CIL Label */ ;
                  }
                }
              }
#line 1016
              goto while_break___229;
            }
            while_break___229: /* CIL Label */ ;
            }
          }
        }
#line 1017
        goto switch_break___13;
        switch_default___11: /* CIL Label */ 
        {
#line 1020
        tmp___316 = gettext("%s: invalid separator `%s%c\' for `%s\' escape");
#line 1020
        error(1, 0, (char const   *)tmp___316, context_name, ":", (int )*cp2, "#{}");
        }
        switch_break___13: /* CIL Label */ ;
        }
      }
#line 1025
      goto switch_break___11;
      case_46___4: /* CIL Label */ 
      {
#line 1029
      while (1) {
        while_continue___232: /* CIL Label */ ;
        {
#line 1029
        tmp___317 = strlen("ps");
#line 1029
        len___63 = tmp___317;
        }
#line 1029
        if (len___63 > width) {
#line 1029
          nspace___63 = (size_t )0;
        } else {
#line 1029
          nspace___63 = width - len___63;
        }
#line 1029
        if (width) {
#line 1029
          if (justification > 0) {
            {
#line 1029
            while (1) {
              while_continue___233: /* CIL Label */ ;
#line 1029
              if (! nspace___63) {
#line 1029
                goto while_break___233;
              }
#line 1029
              __o___236 = user_string_stack___0;
#line 1029
              if ((unsigned long )(__o___236->next_free + 1) > (unsigned long )__o___236->chunk_limit) {
                {
#line 1029
                _obstack_newchunk(__o___236, 1);
                }
              }
#line 1029
              tmp___318 = __o___236->next_free;
#line 1029
              (__o___236->next_free) ++;
#line 1029
              *tmp___318 = (char )padding;
#line 1029
              nspace___63 --;
            }
            while_break___233: /* CIL Label */ ;
            }
          }
        }
#line 1029
        __o___237 = user_string_stack___0;
#line 1029
        __len___63 = (int )len___63;
#line 1029
        if ((unsigned long )(__o___237->next_free + __len___63) > (unsigned long )__o___237->chunk_limit) {
          {
#line 1029
          _obstack_newchunk(__o___237, __len___63);
          }
        }
        {
#line 1029
        memcpy((void */* __restrict  */)__o___237->next_free, (void const   */* __restrict  */)((char *)"ps"),
               (size_t )__len___63);
#line 1029
        __o___237->next_free += __len___63;
        }
#line 1029
        if (width) {
#line 1029
          if (justification < 0) {
            {
#line 1029
            while (1) {
              while_continue___234: /* CIL Label */ ;
#line 1029
              if (! nspace___63) {
#line 1029
                goto while_break___234;
              }
#line 1029
              __o___238 = user_string_stack___0;
#line 1029
              if ((unsigned long )(__o___238->next_free + 1) > (unsigned long )__o___238->chunk_limit) {
                {
#line 1029
                _obstack_newchunk(__o___238, 1);
                }
              }
#line 1029
              tmp___319 = __o___238->next_free;
#line 1029
              (__o___238->next_free) ++;
#line 1029
              *tmp___319 = (char )padding;
#line 1029
              nspace___63 --;
            }
            while_break___234: /* CIL Label */ ;
            }
          }
        }
#line 1029
        goto while_break___232;
      }
      while_break___232: /* CIL Label */ ;
      }
#line 1030
      goto switch_break___11;
      case_63: /* CIL Label */ 
      {
#line 1034
      test = 0;
#line 1039
      i ++;
#line 1039
      cond = (unsigned char )*(str + i);
#line 1040
      i ++;
#line 1040
      sep = (unsigned char )*(str + i);
#line 1041
      i ++;
#line 1041
      tmp___320 = xstrdup((char const   *)(str + i));
#line 1041
      next = (unsigned char *)tmp___320;
      }
      {
#line 1043
      while (1) {
        while_continue___235: /* CIL Label */ ;
        {
#line 1043
        if_true = next;
#line 1043
        tmp___321 = strchr((char const   *)((char *)next), (int )sep);
#line 1043
        next = (unsigned char *)tmp___321;
        }
#line 1043
        if (! next) {
          {
#line 1043
          tmp___322 = gettext("%s: missing `%c\' for %s%c escape");
#line 1043
          error(1, 0, (char const   *)tmp___322, context_name, (int )sep, "#?", (int )cond);
          }
        }
#line 1043
        tmp___323 = next;
#line 1043
        next ++;
#line 1043
        *tmp___323 = (unsigned char )'\000';
#line 1043
        goto while_break___235;
      }
      while_break___235: /* CIL Label */ ;
      }
      {
#line 1044
      while (1) {
        while_continue___236: /* CIL Label */ ;
        {
#line 1044
        if_false = next;
#line 1044
        tmp___324 = strchr((char const   *)((char *)next), (int )sep);
#line 1044
        next = (unsigned char *)tmp___324;
        }
#line 1044
        if (! next) {
          {
#line 1044
          tmp___325 = gettext("%s: missing `%c\' for %s%c escape");
#line 1044
          error(1, 0, (char const   *)tmp___325, context_name, (int )sep, "#?", (int )cond);
          }
        }
#line 1044
        tmp___326 = next;
#line 1044
        next ++;
#line 1044
        *tmp___326 = (unsigned char )'\000';
#line 1044
        goto while_break___236;
      }
      while_break___236: /* CIL Label */ ;
      }
#line 1045
      i = (size_t )((long )i + ((next - if_true) - 1L));
      {
#line 1048
      if ((int )cond == 49) {
#line 1048
        goto case_49___0;
      }
#line 1051
      if ((int )cond == 50) {
#line 1051
        goto case_50___0;
      }
#line 1054
      if ((int )cond == 51) {
#line 1054
        goto case_51___0;
      }
#line 1057
      if ((int )cond == 52) {
#line 1057
        goto case_52___0;
      }
#line 1061
      if ((int )cond == 100) {
#line 1061
        goto case_100___1;
      }
#line 1065
      if ((int )cond == 106) {
#line 1065
        goto case_106;
      }
#line 1069
      if ((int )cond == 108) {
#line 1069
        goto case_108___0;
      }
#line 1073
      if ((int )cond == 111) {
#line 1073
        goto case_111;
      }
#line 1077
      if ((int )cond == 112) {
#line 1077
        goto case_112___1;
      }
#line 1082
      if ((int )cond == 113) {
#line 1082
        goto case_113___1;
      }
#line 1086
      if ((int )cond == 114) {
#line 1086
        goto case_114;
      }
#line 1090
      if ((int )cond == 86) {
#line 1090
        goto case_86___0;
      }
#line 1094
      if ((int )cond == 118) {
#line 1094
        goto case_118;
      }
#line 1098
      goto switch_default___12;
      case_49___0: /* CIL Label */ 
#line 1049
      if ((unsigned long )((char const   *)(job___0->tag1)) == (unsigned long )((void *)0)) {
#line 1049
        tmp___327 = 0;
      } else
#line 1049
      if ((int )job___0->tag1[0] == 0) {
#line 1049
        tmp___327 = 0;
      } else {
#line 1049
        tmp___327 = 1;
      }
#line 1049
      test = tmp___327;
#line 1050
      goto switch_break___14;
      case_50___0: /* CIL Label */ 
#line 1052
      if ((unsigned long )((char const   *)(job___0->tag2)) == (unsigned long )((void *)0)) {
#line 1052
        tmp___328 = 0;
      } else
#line 1052
      if ((int )job___0->tag2[0] == 0) {
#line 1052
        tmp___328 = 0;
      } else {
#line 1052
        tmp___328 = 1;
      }
#line 1052
      test = tmp___328;
#line 1053
      goto switch_break___14;
      case_51___0: /* CIL Label */ 
#line 1055
      if ((unsigned long )((char const   *)(job___0->tag3)) == (unsigned long )((void *)0)) {
#line 1055
        tmp___329 = 0;
      } else
#line 1055
      if ((int )job___0->tag3[0] == 0) {
#line 1055
        tmp___329 = 0;
      } else {
#line 1055
        tmp___329 = 1;
      }
#line 1055
      test = tmp___329;
#line 1056
      goto switch_break___14;
      case_52___0: /* CIL Label */ 
#line 1058
      if ((unsigned long )((char const   *)(job___0->tag4)) == (unsigned long )((void *)0)) {
#line 1058
        tmp___330 = 0;
      } else
#line 1058
      if ((int )job___0->tag4[0] == 0) {
#line 1058
        tmp___330 = 0;
      } else {
#line 1058
        tmp___330 = 1;
      }
#line 1058
      test = tmp___330;
#line 1059
      goto switch_break___14;
      case_100___1: /* CIL Label */ 
#line 1062
      if ((unsigned int )job___0->duplex == 1U) {
#line 1062
        tmp___331 = 1;
      } else
#line 1062
      if ((unsigned int )job___0->duplex == 2U) {
#line 1062
        tmp___331 = 1;
      } else {
#line 1062
        tmp___331 = 0;
      }
#line 1062
      test = tmp___331;
#line 1063
      goto switch_break___14;
      case_106: /* CIL Label */ 
#line 1066
      test = job___0->border;
#line 1067
      goto switch_break___14;
      case_108___0: /* CIL Label */ 
#line 1070
      test = (unsigned int )job___0->orientation == 1U;
#line 1071
      goto switch_break___14;
      case_111: /* CIL Label */ 
#line 1074
      test = job___0->rows * job___0->columns == 1;
#line 1075
      goto switch_break___14;
      case_112___1: /* CIL Label */ 
      {
#line 1079
      test = page_range_applies_above(job___0->page_range, job___0->pages);
      }
#line 1080
      goto switch_break___14;
      case_113___1: /* CIL Label */ 
#line 1083
      test = msg_verbosity == 0U;
#line 1084
      goto switch_break___14;
      case_114: /* CIL Label */ 
#line 1087
      test = (unsigned int )job___0->madir == 0U;
#line 1088
      goto switch_break___14;
      case_86___0: /* CIL Label */ 
#line 1091
      test = (int )((unsigned int )(1 << 7) & msg_verbosity);
#line 1092
      goto switch_break___14;
      case_118: /* CIL Label */ 
#line 1095
      test = job___0->sheets & 1;
#line 1096
      goto switch_break___14;
      switch_default___12: /* CIL Label */ 
      {
#line 1099
      tmp___332 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 1099
      error(1, 0, (char const   *)tmp___332, context_name, "#?", (int )cond, (int )cond);
      }
#line 1101
      goto switch_break___14;
      switch_break___14: /* CIL Label */ ;
      }
#line 1111
      if (test) {
        {
#line 1112
        grow_user_string_obstack(user_string_stack___0, job___0, file, context_name,
                                 (unsigned char const   *)if_true);
        }
      } else {
        {
#line 1116
        grow_user_string_obstack(user_string_stack___0, job___0, file, context_name,
                                 (unsigned char const   *)if_false);
        }
      }
      {
#line 1119
      free((void *)if_true);
      }
#line 1121
      goto switch_break___11;
      case_33: /* CIL Label */ 
      {
#line 1129
      i ++;
#line 1129
      category = (unsigned char )*(str + i);
#line 1130
      i ++;
#line 1130
      sep___0 = (unsigned char )*(str + i);
#line 1131
      i ++;
#line 1131
      tmp___333 = xstrdup((char const   *)(str + i));
#line 1131
      next___0 = (unsigned char *)tmp___333;
      }
      {
#line 1133
      while (1) {
        while_continue___237: /* CIL Label */ ;
        {
#line 1133
        in = next___0;
#line 1133
        tmp___334 = strchr((char const   *)((char *)next___0), (int )sep___0);
#line 1133
        next___0 = (unsigned char *)tmp___334;
        }
#line 1133
        if (! next___0) {
          {
#line 1133
          tmp___335 = gettext("%s: missing `%c\' for %s%c escape");
#line 1133
          error(1, 0, (char const   *)tmp___335, context_name, (int )sep___0, "#!",
                (int )category);
          }
        }
#line 1133
        tmp___336 = next___0;
#line 1133
        next___0 ++;
#line 1133
        *tmp___336 = (unsigned char )'\000';
#line 1133
        goto while_break___237;
      }
      while_break___237: /* CIL Label */ ;
      }
      {
#line 1134
      while (1) {
        while_continue___238: /* CIL Label */ ;
        {
#line 1134
        between = next___0;
#line 1134
        tmp___337 = strchr((char const   *)((char *)next___0), (int )sep___0);
#line 1134
        next___0 = (unsigned char *)tmp___337;
        }
#line 1134
        if (! next___0) {
          {
#line 1134
          tmp___338 = gettext("%s: missing `%c\' for %s%c escape");
#line 1134
          error(1, 0, (char const   *)tmp___338, context_name, (int )sep___0, "#!",
                (int )category);
          }
        }
#line 1134
        tmp___339 = next___0;
#line 1134
        next___0 ++;
#line 1134
        *tmp___339 = (unsigned char )'\000';
#line 1134
        goto while_break___238;
      }
      while_break___238: /* CIL Label */ ;
      }
#line 1135
      i = (size_t )((long )i + ((next___0 - in) - 1L));
      {
#line 1138
      if ((int )category == 36) {
#line 1138
        goto case_36___1;
      }
#line 1153
      if ((int )category == 102) {
#line 1153
        goto case_102___1;
      }
#line 1171
      if ((int )category == 70) {
#line 1171
        goto case_70___1;
      }
#line 1197
      if ((int )category == 115) {
#line 1197
        goto case_115___1;
      }
#line 1233
      goto switch_default___13;
      case_36___1: /* CIL Label */ 
#line 1141
      if (width > 0U) {
#line 1141
        if (justification > 0) {
#line 1141
          if (width < job___0->argc) {
#line 1141
            fmax___0 = width;
          } else {
#line 1141
            goto _L___19;
          }
        } else {
#line 1141
          goto _L___19;
        }
      } else {
        _L___19: /* CIL Label */ 
#line 1141
        if (width > 0U) {
#line 1141
          if (justification < 0) {
#line 1141
            if (width <= job___0->argc) {
#line 1141
              tmp___340 = job___0->argc - width;
            } else {
#line 1141
              tmp___340 = job___0->argc;
            }
          } else {
#line 1141
            tmp___340 = job___0->argc;
          }
        } else {
#line 1141
          tmp___340 = job___0->argc;
        }
#line 1141
        fmax___0 = tmp___340;
      }
#line 1142
      fnum = (size_t )0;
      {
#line 1142
      while (1) {
        while_continue___239: /* CIL Label */ ;
#line 1142
        if (! (fnum < fmax___0)) {
#line 1142
          goto while_break___239;
        }
        {
#line 1143
        while (1) {
          while_continue___240: /* CIL Label */ ;
          {
#line 1143
          tmp___341 = strlen((char const   *)*(job___0->argv + fnum));
#line 1143
          len___64 = tmp___341;
          }
#line 1143
          if (len___64 > width) {
#line 1143
            nspace___64 = (size_t )0;
          } else {
#line 1143
            nspace___64 = width - len___64;
          }
#line 1143
          if (width) {
#line 1143
            if (justification > 0) {
              {
#line 1143
              while (1) {
                while_continue___241: /* CIL Label */ ;
#line 1143
                if (! nspace___64) {
#line 1143
                  goto while_break___241;
                }
#line 1143
                __o___239 = user_string_stack___0;
#line 1143
                if ((unsigned long )(__o___239->next_free + 1) > (unsigned long )__o___239->chunk_limit) {
                  {
#line 1143
                  _obstack_newchunk(__o___239, 1);
                  }
                }
#line 1143
                tmp___342 = __o___239->next_free;
#line 1143
                (__o___239->next_free) ++;
#line 1143
                *tmp___342 = (char )padding;
#line 1143
                nspace___64 --;
              }
              while_break___241: /* CIL Label */ ;
              }
            }
          }
#line 1143
          __o___240 = user_string_stack___0;
#line 1143
          __len___64 = (int )len___64;
#line 1143
          if ((unsigned long )(__o___240->next_free + __len___64) > (unsigned long )__o___240->chunk_limit) {
            {
#line 1143
            _obstack_newchunk(__o___240, __len___64);
            }
          }
          {
#line 1143
          memcpy((void */* __restrict  */)__o___240->next_free, (void const   */* __restrict  */)*(job___0->argv + fnum),
                 (size_t )__len___64);
#line 1143
          __o___240->next_free += __len___64;
          }
#line 1143
          if (width) {
#line 1143
            if (justification < 0) {
              {
#line 1143
              while (1) {
                while_continue___242: /* CIL Label */ ;
#line 1143
                if (! nspace___64) {
#line 1143
                  goto while_break___242;
                }
#line 1143
                __o___241 = user_string_stack___0;
#line 1143
                if ((unsigned long )(__o___241->next_free + 1) > (unsigned long )__o___241->chunk_limit) {
                  {
#line 1143
                  _obstack_newchunk(__o___241, 1);
                  }
                }
#line 1143
                tmp___343 = __o___241->next_free;
#line 1143
                (__o___241->next_free) ++;
#line 1143
                *tmp___343 = (char )padding;
#line 1143
                nspace___64 --;
              }
              while_break___242: /* CIL Label */ ;
              }
            }
          }
#line 1143
          goto while_break___240;
        }
        while_break___240: /* CIL Label */ ;
        }
#line 1144
        if (fnum < fmax___0 - 1U) {
          {
#line 1145
          grow_user_string_obstack(user_string_stack___0, job___0, (struct file_job *)*((job___0->jobs)->content + fnum),
                                   context_name, (unsigned char const   *)between);
          }
        }
#line 1142
        fnum ++;
      }
      while_break___239: /* CIL Label */ ;
      }
#line 1151
      goto switch_break___15;
      case_102___1: /* CIL Label */ 
#line 1156
      if (width > 0U) {
#line 1156
        if (justification > 0) {
#line 1156
          if (width < (job___0->jobs)->len) {
#line 1156
            fmax___1 = width;
          } else {
#line 1156
            goto _L___21;
          }
        } else {
#line 1156
          goto _L___21;
        }
      } else {
        _L___21: /* CIL Label */ 
#line 1156
        if (width > 0U) {
#line 1156
          if (justification < 0) {
#line 1156
            if (width <= (job___0->jobs)->len) {
#line 1156
              tmp___344 = (job___0->jobs)->len - width;
            } else {
#line 1156
              tmp___344 = (job___0->jobs)->len;
            }
          } else {
#line 1156
            tmp___344 = (job___0->jobs)->len;
          }
        } else {
#line 1156
          tmp___344 = (job___0->jobs)->len;
        }
#line 1156
        fmax___1 = tmp___344;
      }
#line 1157
      fnum___0 = (size_t )0;
      {
#line 1157
      while (1) {
        while_continue___243: /* CIL Label */ ;
#line 1157
        if (! (fnum___0 < fmax___1)) {
#line 1157
          goto while_break___243;
        }
        {
#line 1158
        grow_user_string_obstack(user_string_stack___0, job___0, (struct file_job *)*((job___0->jobs)->content + fnum___0),
                                 context_name, (unsigned char const   *)in);
        }
#line 1162
        if (fnum___0 < fmax___1 - 1U) {
          {
#line 1163
          grow_user_string_obstack(user_string_stack___0, job___0, (struct file_job *)*((job___0->jobs)->content + fnum___0),
                                   context_name, (unsigned char const   *)between);
          }
        }
#line 1157
        fnum___0 ++;
      }
      while_break___243: /* CIL Label */ ;
      }
#line 1169
      goto switch_break___15;
      case_70___1: /* CIL Label */ 
      {
#line 1178
      ordered = da_clone(job___0->jobs);
#line 1179
      ordered->cmp = (int (*)(void const   *k1 , void const   *k2 ))(& file_name_cmp);
#line 1180
      da_qsort(ordered);
      }
#line 1181
      if (width > 0U) {
#line 1181
        if (justification > 0) {
#line 1181
          if (width < (job___0->jobs)->len) {
#line 1181
            fmax___2 = width;
          } else {
#line 1181
            goto _L___23;
          }
        } else {
#line 1181
          goto _L___23;
        }
      } else {
        _L___23: /* CIL Label */ 
#line 1181
        if (width > 0U) {
#line 1181
          if (justification < 0) {
#line 1181
            if (width <= (job___0->jobs)->len) {
#line 1181
              tmp___345 = (job___0->jobs)->len - width;
            } else {
#line 1181
              tmp___345 = (job___0->jobs)->len;
            }
          } else {
#line 1181
            tmp___345 = (job___0->jobs)->len;
          }
        } else {
#line 1181
          tmp___345 = (job___0->jobs)->len;
        }
#line 1181
        fmax___2 = tmp___345;
      }
#line 1182
      fnum___1 = (size_t )0;
      {
#line 1182
      while (1) {
        while_continue___244: /* CIL Label */ ;
#line 1182
        if (! (fnum___1 < fmax___2)) {
#line 1182
          goto while_break___244;
        }
        {
#line 1183
        grow_user_string_obstack(user_string_stack___0, job___0, (struct file_job *)*(ordered->content + fnum___1),
                                 context_name, (unsigned char const   *)in);
        }
#line 1187
        if (fnum___1 < fmax___2 - 1U) {
          {
#line 1188
          grow_user_string_obstack(user_string_stack___0, job___0, (struct file_job *)*(ordered->content + fnum___1),
                                   context_name, (unsigned char const   *)between);
          }
        }
#line 1182
        fnum___1 ++;
      }
      while_break___244: /* CIL Label */ ;
      }
      {
#line 1193
      da_erase(ordered);
      }
#line 1195
      goto switch_break___15;
      case_115___1: /* CIL Label */ 
      {
#line 1204
      selected = da_clone(job___0->jobs);
#line 1209
      fnum___2 = (size_t )0;
      }
      {
#line 1210
      while (1) {
        while_continue___245: /* CIL Label */ ;
#line 1210
        if (! (fnum___2 < selected->len)) {
#line 1210
          goto while_break___245;
        }
#line 1211
        if (((struct file_job *)*(selected->content + fnum___2))->last_sheet < job___0->sheets) {
          {
#line 1212
          da_remove_at(selected, fnum___2, (void (*)(void * ))((void *)0));
          }
        } else {
#line 1214
          fnum___2 ++;
        }
      }
      while_break___245: /* CIL Label */ ;
      }
#line 1217
      if (width > 0U) {
#line 1217
        if (justification > 0) {
#line 1217
          if (width < selected->len) {
#line 1217
            fmax___3 = width;
          } else {
#line 1217
            goto _L___25;
          }
        } else {
#line 1217
          goto _L___25;
        }
      } else {
        _L___25: /* CIL Label */ 
#line 1217
        if (width > 0U) {
#line 1217
          if (justification < 0) {
#line 1217
            if (width <= selected->len) {
#line 1217
              tmp___346 = selected->len - width;
            } else {
#line 1217
              tmp___346 = selected->len;
            }
          } else {
#line 1217
            tmp___346 = selected->len;
          }
        } else {
#line 1217
          tmp___346 = selected->len;
        }
#line 1217
        fmax___3 = tmp___346;
      }
#line 1218
      fnum___2 = (size_t )0;
      {
#line 1218
      while (1) {
        while_continue___246: /* CIL Label */ ;
#line 1218
        if (! (fnum___2 < fmax___3)) {
#line 1218
          goto while_break___246;
        }
        {
#line 1219
        grow_user_string_obstack(user_string_stack___0, job___0, (struct file_job *)*(selected->content + fnum___2),
                                 context_name, (unsigned char const   *)in);
        }
#line 1223
        if (fnum___2 < fmax___3 - 1U) {
          {
#line 1224
          grow_user_string_obstack(user_string_stack___0, job___0, (struct file_job *)*(selected->content + fnum___2),
                                   context_name, (unsigned char const   *)between);
          }
        }
#line 1218
        fnum___2 ++;
      }
      while_break___246: /* CIL Label */ ;
      }
      {
#line 1229
      da_erase(selected);
      }
#line 1231
      goto switch_break___15;
      switch_default___13: /* CIL Label */ 
      {
#line 1234
      tmp___347 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 1234
      error(1, 0, (char const   *)tmp___347, context_name, "#!", (int )category, (int )category);
      }
#line 1236
      goto switch_break___15;
      switch_break___15: /* CIL Label */ ;
      }
      {
#line 1238
      free((void *)in);
      }
#line 1240
      goto switch_break___11;
      case_102___2: /* CIL Label */ 
#line 1244
      i ++;
#line 1244
      k = (int )((int const   )*(str + i) - 48);
#line 1245
      if (k < 0) {
        {
#line 1246
        tmp___348 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 1246
        error(1, 0, (char const   *)tmp___348, context_name, "#f", (int const   )*(str + i),
              (int const   )*(str + i));
        }
      } else
#line 1245
      if (9 < k) {
        {
#line 1246
        tmp___348 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 1246
        error(1, 0, (char const   *)tmp___348, context_name, "#f", (int const   )*(str + i),
              (int const   )*(str + i));
        }
      }
      {
#line 1248
      while (1) {
        while_continue___247: /* CIL Label */ ;
#line 1248
        if (job___0->tmp_filenames[k]) {
#line 1248
          job___0->tmp_filenames[k] = job___0->tmp_filenames[k];
        } else {
          {
#line 1248
          tmp___349 = tempnam((char const   *)((void *)0), "a2_");
#line 1248
          job___0->tmp_filenames[k] = tmp___349;
          }
        }
#line 1248
        goto while_break___247;
      }
      while_break___247: /* CIL Label */ ;
      }
      {
#line 1249
      while (1) {
        while_continue___248: /* CIL Label */ ;
        {
#line 1249
        tmp___350 = strlen((char const   *)job___0->tmp_filenames[k]);
#line 1249
        len___65 = tmp___350;
        }
#line 1249
        if (len___65 > width) {
#line 1249
          nspace___65 = (size_t )0;
        } else {
#line 1249
          nspace___65 = width - len___65;
        }
#line 1249
        if (width) {
#line 1249
          if (justification > 0) {
            {
#line 1249
            while (1) {
              while_continue___249: /* CIL Label */ ;
#line 1249
              if (! nspace___65) {
#line 1249
                goto while_break___249;
              }
#line 1249
              __o___242 = user_string_stack___0;
#line 1249
              if ((unsigned long )(__o___242->next_free + 1) > (unsigned long )__o___242->chunk_limit) {
                {
#line 1249
                _obstack_newchunk(__o___242, 1);
                }
              }
#line 1249
              tmp___351 = __o___242->next_free;
#line 1249
              (__o___242->next_free) ++;
#line 1249
              *tmp___351 = (char )padding;
#line 1249
              nspace___65 --;
            }
            while_break___249: /* CIL Label */ ;
            }
          }
        }
#line 1249
        __o___243 = user_string_stack___0;
#line 1249
        __len___65 = (int )len___65;
#line 1249
        if ((unsigned long )(__o___243->next_free + __len___65) > (unsigned long )__o___243->chunk_limit) {
          {
#line 1249
          _obstack_newchunk(__o___243, __len___65);
          }
        }
        {
#line 1249
        memcpy((void */* __restrict  */)__o___243->next_free, (void const   */* __restrict  */)job___0->tmp_filenames[k],
               (size_t )__len___65);
#line 1249
        __o___243->next_free += __len___65;
        }
#line 1249
        if (width) {
#line 1249
          if (justification < 0) {
            {
#line 1249
            while (1) {
              while_continue___250: /* CIL Label */ ;
#line 1249
              if (! nspace___65) {
#line 1249
                goto while_break___250;
              }
#line 1249
              __o___244 = user_string_stack___0;
#line 1249
              if ((unsigned long )(__o___244->next_free + 1) > (unsigned long )__o___244->chunk_limit) {
                {
#line 1249
                _obstack_newchunk(__o___244, 1);
                }
              }
#line 1249
              tmp___352 = __o___244->next_free;
#line 1249
              (__o___244->next_free) ++;
#line 1249
              *tmp___352 = (char )padding;
#line 1249
              nspace___65 --;
            }
            while_break___250: /* CIL Label */ ;
            }
          }
        }
#line 1249
        goto while_break___248;
      }
      while_break___248: /* CIL Label */ ;
      }
#line 1251
      goto switch_break___11;
      case_104: /* CIL Label */ 
      {
#line 1254
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              (job___0->medium)->h);
      }
      {
#line 1255
      while (1) {
        while_continue___251: /* CIL Label */ ;
        {
#line 1255
        tmp___353 = strlen((char const   *)(buf___0));
#line 1255
        len___66 = tmp___353;
        }
#line 1255
        if (len___66 > width) {
#line 1255
          nspace___66 = (size_t )0;
        } else {
#line 1255
          nspace___66 = width - len___66;
        }
#line 1255
        if (width) {
#line 1255
          if (justification > 0) {
            {
#line 1255
            while (1) {
              while_continue___252: /* CIL Label */ ;
#line 1255
              if (! nspace___66) {
#line 1255
                goto while_break___252;
              }
#line 1255
              __o___245 = user_string_stack___0;
#line 1255
              if ((unsigned long )(__o___245->next_free + 1) > (unsigned long )__o___245->chunk_limit) {
                {
#line 1255
                _obstack_newchunk(__o___245, 1);
                }
              }
#line 1255
              tmp___354 = __o___245->next_free;
#line 1255
              (__o___245->next_free) ++;
#line 1255
              *tmp___354 = (char )padding;
#line 1255
              nspace___66 --;
            }
            while_break___252: /* CIL Label */ ;
            }
          }
        }
#line 1255
        __o___246 = user_string_stack___0;
#line 1255
        __len___66 = (int )len___66;
#line 1255
        if ((unsigned long )(__o___246->next_free + __len___66) > (unsigned long )__o___246->chunk_limit) {
          {
#line 1255
          _obstack_newchunk(__o___246, __len___66);
          }
        }
        {
#line 1255
        memcpy((void */* __restrict  */)__o___246->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___66);
#line 1255
        __o___246->next_free += __len___66;
        }
#line 1255
        if (width) {
#line 1255
          if (justification < 0) {
            {
#line 1255
            while (1) {
              while_continue___253: /* CIL Label */ ;
#line 1255
              if (! nspace___66) {
#line 1255
                goto while_break___253;
              }
#line 1255
              __o___247 = user_string_stack___0;
#line 1255
              if ((unsigned long )(__o___247->next_free + 1) > (unsigned long )__o___247->chunk_limit) {
                {
#line 1255
                _obstack_newchunk(__o___247, 1);
                }
              }
#line 1255
              tmp___355 = __o___247->next_free;
#line 1255
              (__o___247->next_free) ++;
#line 1255
              *tmp___355 = (char )padding;
#line 1255
              nspace___66 --;
            }
            while_break___253: /* CIL Label */ ;
            }
          }
        }
#line 1255
        goto while_break___251;
      }
      while_break___251: /* CIL Label */ ;
      }
#line 1256
      goto switch_break___11;
      case_111___0: /* CIL Label */ 
      {
#line 1259
      while (1) {
        while_continue___254: /* CIL Label */ ;
        {
#line 1259
        tmp___356 = a2ps_printers_flag_output_name_get(job___0->printers);
#line 1259
        tmp___357 = strlen(tmp___356);
#line 1259
        len___67 = tmp___357;
        }
#line 1259
        if (len___67 > width) {
#line 1259
          nspace___67 = (size_t )0;
        } else {
#line 1259
          nspace___67 = width - len___67;
        }
#line 1259
        if (width) {
#line 1259
          if (justification > 0) {
            {
#line 1259
            while (1) {
              while_continue___255: /* CIL Label */ ;
#line 1259
              if (! nspace___67) {
#line 1259
                goto while_break___255;
              }
#line 1259
              __o___248 = user_string_stack___0;
#line 1259
              if ((unsigned long )(__o___248->next_free + 1) > (unsigned long )__o___248->chunk_limit) {
                {
#line 1259
                _obstack_newchunk(__o___248, 1);
                }
              }
#line 1259
              tmp___358 = __o___248->next_free;
#line 1259
              (__o___248->next_free) ++;
#line 1259
              *tmp___358 = (char )padding;
#line 1259
              nspace___67 --;
            }
            while_break___255: /* CIL Label */ ;
            }
          }
        }
#line 1259
        __o___249 = user_string_stack___0;
#line 1259
        __len___67 = (int )len___67;
#line 1259
        if ((unsigned long )(__o___249->next_free + __len___67) > (unsigned long )__o___249->chunk_limit) {
          {
#line 1259
          _obstack_newchunk(__o___249, __len___67);
          }
        }
        {
#line 1259
        tmp___359 = a2ps_printers_flag_output_name_get(job___0->printers);
#line 1259
        memcpy((void */* __restrict  */)__o___249->next_free, (void const   */* __restrict  */)((char *)tmp___359),
               (size_t )__len___67);
#line 1259
        __o___249->next_free += __len___67;
        }
#line 1259
        if (width) {
#line 1259
          if (justification < 0) {
            {
#line 1259
            while (1) {
              while_continue___256: /* CIL Label */ ;
#line 1259
              if (! nspace___67) {
#line 1259
                goto while_break___256;
              }
#line 1259
              __o___250 = user_string_stack___0;
#line 1259
              if ((unsigned long )(__o___250->next_free + 1) > (unsigned long )__o___250->chunk_limit) {
                {
#line 1259
                _obstack_newchunk(__o___250, 1);
                }
              }
#line 1259
              tmp___360 = __o___250->next_free;
#line 1259
              (__o___250->next_free) ++;
#line 1259
              *tmp___360 = (char )padding;
#line 1259
              nspace___67 --;
            }
            while_break___256: /* CIL Label */ ;
            }
          }
        }
#line 1259
        goto while_break___254;
      }
      while_break___254: /* CIL Label */ ;
      }
#line 1260
      goto switch_break___11;
      case_79: /* CIL Label */ 
      {
#line 1263
      tmp___368 = a2ps_printers_flag_output_is_printer_get(job___0->printers);
      }
#line 1263
      if (tmp___368) {
        {
#line 1264
        tmp___361 = a2ps_printers_flag_output_name_get(job___0->printers);
#line 1264
        tmp___362 = gettext("output command");
#line 1264
        grow_user_string_obstack(user_string_stack___0, job___0, file, (unsigned char const   *)tmp___362,
                                 (unsigned char const   *)tmp___361);
        }
      } else {
        {
#line 1269
        while (1) {
          while_continue___257: /* CIL Label */ ;
          {
#line 1269
          tmp___363 = a2ps_printers_flag_output_name_get(job___0->printers);
#line 1269
          tmp___364 = strlen(tmp___363);
#line 1269
          len___68 = tmp___364;
          }
#line 1269
          if (len___68 > width) {
#line 1269
            nspace___68 = (size_t )0;
          } else {
#line 1269
            nspace___68 = width - len___68;
          }
#line 1269
          if (width) {
#line 1269
            if (justification > 0) {
              {
#line 1269
              while (1) {
                while_continue___258: /* CIL Label */ ;
#line 1269
                if (! nspace___68) {
#line 1269
                  goto while_break___258;
                }
#line 1269
                __o___251 = user_string_stack___0;
#line 1269
                if ((unsigned long )(__o___251->next_free + 1) > (unsigned long )__o___251->chunk_limit) {
                  {
#line 1269
                  _obstack_newchunk(__o___251, 1);
                  }
                }
#line 1269
                tmp___365 = __o___251->next_free;
#line 1269
                (__o___251->next_free) ++;
#line 1269
                *tmp___365 = (char )padding;
#line 1269
                nspace___68 --;
              }
              while_break___258: /* CIL Label */ ;
              }
            }
          }
#line 1269
          __o___252 = user_string_stack___0;
#line 1269
          __len___68 = (int )len___68;
#line 1269
          if ((unsigned long )(__o___252->next_free + __len___68) > (unsigned long )__o___252->chunk_limit) {
            {
#line 1269
            _obstack_newchunk(__o___252, __len___68);
            }
          }
          {
#line 1269
          tmp___366 = a2ps_printers_flag_output_name_get(job___0->printers);
#line 1269
          memcpy((void */* __restrict  */)__o___252->next_free, (void const   */* __restrict  */)((char *)tmp___366),
                 (size_t )__len___68);
#line 1269
          __o___252->next_free += __len___68;
          }
#line 1269
          if (width) {
#line 1269
            if (justification < 0) {
              {
#line 1269
              while (1) {
                while_continue___259: /* CIL Label */ ;
#line 1269
                if (! nspace___68) {
#line 1269
                  goto while_break___259;
                }
#line 1269
                __o___253 = user_string_stack___0;
#line 1269
                if ((unsigned long )(__o___253->next_free + 1) > (unsigned long )__o___253->chunk_limit) {
                  {
#line 1269
                  _obstack_newchunk(__o___253, 1);
                  }
                }
#line 1269
                tmp___367 = __o___253->next_free;
#line 1269
                (__o___253->next_free) ++;
#line 1269
                *tmp___367 = (char )padding;
#line 1269
                nspace___68 --;
              }
              while_break___259: /* CIL Label */ ;
              }
            }
          }
#line 1269
          goto while_break___257;
        }
        while_break___257: /* CIL Label */ ;
        }
      }
#line 1270
      goto switch_break___11;
      case_112___2: /* CIL Label */ 
      {
#line 1274
      page_range_to_buffer(job___0->page_range, buf___0, job___0->pages);
      }
      {
#line 1275
      while (1) {
        while_continue___260: /* CIL Label */ ;
        {
#line 1275
        tmp___369 = strlen((char const   *)(buf___0));
#line 1275
        len___69 = tmp___369;
        }
#line 1275
        if (len___69 > width) {
#line 1275
          nspace___69 = (size_t )0;
        } else {
#line 1275
          nspace___69 = width - len___69;
        }
#line 1275
        if (width) {
#line 1275
          if (justification > 0) {
            {
#line 1275
            while (1) {
              while_continue___261: /* CIL Label */ ;
#line 1275
              if (! nspace___69) {
#line 1275
                goto while_break___261;
              }
#line 1275
              __o___254 = user_string_stack___0;
#line 1275
              if ((unsigned long )(__o___254->next_free + 1) > (unsigned long )__o___254->chunk_limit) {
                {
#line 1275
                _obstack_newchunk(__o___254, 1);
                }
              }
#line 1275
              tmp___370 = __o___254->next_free;
#line 1275
              (__o___254->next_free) ++;
#line 1275
              *tmp___370 = (char )padding;
#line 1275
              nspace___69 --;
            }
            while_break___261: /* CIL Label */ ;
            }
          }
        }
#line 1275
        __o___255 = user_string_stack___0;
#line 1275
        __len___69 = (int )len___69;
#line 1275
        if ((unsigned long )(__o___255->next_free + __len___69) > (unsigned long )__o___255->chunk_limit) {
          {
#line 1275
          _obstack_newchunk(__o___255, __len___69);
          }
        }
        {
#line 1275
        memcpy((void */* __restrict  */)__o___255->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___69);
#line 1275
        __o___255->next_free += __len___69;
        }
#line 1275
        if (width) {
#line 1275
          if (justification < 0) {
            {
#line 1275
            while (1) {
              while_continue___262: /* CIL Label */ ;
#line 1275
              if (! nspace___69) {
#line 1275
                goto while_break___262;
              }
#line 1275
              __o___256 = user_string_stack___0;
#line 1275
              if ((unsigned long )(__o___256->next_free + 1) > (unsigned long )__o___256->chunk_limit) {
                {
#line 1275
                _obstack_newchunk(__o___256, 1);
                }
              }
#line 1275
              tmp___371 = __o___256->next_free;
#line 1275
              (__o___256->next_free) ++;
#line 1275
              *tmp___371 = (char )padding;
#line 1275
              nspace___69 --;
            }
            while_break___262: /* CIL Label */ ;
            }
          }
        }
#line 1275
        goto while_break___260;
      }
      while_break___260: /* CIL Label */ ;
      }
#line 1276
      goto switch_break___11;
      case_118___0: /* CIL Label */ 
      {
#line 1279
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              job___0->rows * job___0->columns);
      }
      {
#line 1280
      while (1) {
        while_continue___263: /* CIL Label */ ;
        {
#line 1280
        tmp___372 = strlen((char const   *)(buf___0));
#line 1280
        len___70 = tmp___372;
        }
#line 1280
        if (len___70 > width) {
#line 1280
          nspace___70 = (size_t )0;
        } else {
#line 1280
          nspace___70 = width - len___70;
        }
#line 1280
        if (width) {
#line 1280
          if (justification > 0) {
            {
#line 1280
            while (1) {
              while_continue___264: /* CIL Label */ ;
#line 1280
              if (! nspace___70) {
#line 1280
                goto while_break___264;
              }
#line 1280
              __o___257 = user_string_stack___0;
#line 1280
              if ((unsigned long )(__o___257->next_free + 1) > (unsigned long )__o___257->chunk_limit) {
                {
#line 1280
                _obstack_newchunk(__o___257, 1);
                }
              }
#line 1280
              tmp___373 = __o___257->next_free;
#line 1280
              (__o___257->next_free) ++;
#line 1280
              *tmp___373 = (char )padding;
#line 1280
              nspace___70 --;
            }
            while_break___264: /* CIL Label */ ;
            }
          }
        }
#line 1280
        __o___258 = user_string_stack___0;
#line 1280
        __len___70 = (int )len___70;
#line 1280
        if ((unsigned long )(__o___258->next_free + __len___70) > (unsigned long )__o___258->chunk_limit) {
          {
#line 1280
          _obstack_newchunk(__o___258, __len___70);
          }
        }
        {
#line 1280
        memcpy((void */* __restrict  */)__o___258->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___70);
#line 1280
        __o___258->next_free += __len___70;
        }
#line 1280
        if (width) {
#line 1280
          if (justification < 0) {
            {
#line 1280
            while (1) {
              while_continue___265: /* CIL Label */ ;
#line 1280
              if (! nspace___70) {
#line 1280
                goto while_break___265;
              }
#line 1280
              __o___259 = user_string_stack___0;
#line 1280
              if ((unsigned long )(__o___259->next_free + 1) > (unsigned long )__o___259->chunk_limit) {
                {
#line 1280
                _obstack_newchunk(__o___259, 1);
                }
              }
#line 1280
              tmp___374 = __o___259->next_free;
#line 1280
              (__o___259->next_free) ++;
#line 1280
              *tmp___374 = (char )padding;
#line 1280
              nspace___70 --;
            }
            while_break___265: /* CIL Label */ ;
            }
          }
        }
#line 1280
        goto while_break___263;
      }
      while_break___263: /* CIL Label */ ;
      }
#line 1281
      goto switch_break___11;
      case_119: /* CIL Label */ 
      {
#line 1284
      sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)"%d",
              (job___0->medium)->w);
      }
      {
#line 1285
      while (1) {
        while_continue___266: /* CIL Label */ ;
        {
#line 1285
        tmp___375 = strlen((char const   *)(buf___0));
#line 1285
        len___71 = tmp___375;
        }
#line 1285
        if (len___71 > width) {
#line 1285
          nspace___71 = (size_t )0;
        } else {
#line 1285
          nspace___71 = width - len___71;
        }
#line 1285
        if (width) {
#line 1285
          if (justification > 0) {
            {
#line 1285
            while (1) {
              while_continue___267: /* CIL Label */ ;
#line 1285
              if (! nspace___71) {
#line 1285
                goto while_break___267;
              }
#line 1285
              __o___260 = user_string_stack___0;
#line 1285
              if ((unsigned long )(__o___260->next_free + 1) > (unsigned long )__o___260->chunk_limit) {
                {
#line 1285
                _obstack_newchunk(__o___260, 1);
                }
              }
#line 1285
              tmp___376 = __o___260->next_free;
#line 1285
              (__o___260->next_free) ++;
#line 1285
              *tmp___376 = (char )padding;
#line 1285
              nspace___71 --;
            }
            while_break___267: /* CIL Label */ ;
            }
          }
        }
#line 1285
        __o___261 = user_string_stack___0;
#line 1285
        __len___71 = (int )len___71;
#line 1285
        if ((unsigned long )(__o___261->next_free + __len___71) > (unsigned long )__o___261->chunk_limit) {
          {
#line 1285
          _obstack_newchunk(__o___261, __len___71);
          }
        }
        {
#line 1285
        memcpy((void */* __restrict  */)__o___261->next_free, (void const   */* __restrict  */)((char *)(buf___0)),
               (size_t )__len___71);
#line 1285
        __o___261->next_free += __len___71;
        }
#line 1285
        if (width) {
#line 1285
          if (justification < 0) {
            {
#line 1285
            while (1) {
              while_continue___268: /* CIL Label */ ;
#line 1285
              if (! nspace___71) {
#line 1285
                goto while_break___268;
              }
#line 1285
              __o___262 = user_string_stack___0;
#line 1285
              if ((unsigned long )(__o___262->next_free + 1) > (unsigned long )__o___262->chunk_limit) {
                {
#line 1285
                _obstack_newchunk(__o___262, 1);
                }
              }
#line 1285
              tmp___377 = __o___262->next_free;
#line 1285
              (__o___262->next_free) ++;
#line 1285
              *tmp___377 = (char )padding;
#line 1285
              nspace___71 --;
            }
            while_break___268: /* CIL Label */ ;
            }
          }
        }
#line 1285
        goto while_break___266;
      }
      while_break___266: /* CIL Label */ ;
      }
#line 1286
      goto switch_break___11;
      switch_default___14: /* CIL Label */ 
      {
#line 1289
      tmp___378 = gettext("%s: unknown `%s\' escape `%c\' (%d)");
#line 1289
      error(1, 0, (char const   *)tmp___378, context_name, "#", (int const   )*(str + i),
            (int const   )*(str + i));
      }
#line 1291
      goto switch_break___11;
      switch_break___11: /* CIL Label */ ;
      }
#line 1293
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1296
      width = (size_t )0;
#line 1297
      justification = 1;
    } else {
      {
#line 1300
      while (1) {
        while_continue___269: /* CIL Label */ ;
#line 1300
        if (width) {
#line 1300
          if (justification < 0) {
#line 1300
            __o___263 = user_string_stack___0;
#line 1300
            if ((unsigned long )(__o___263->next_free + 1) > (unsigned long )__o___263->chunk_limit) {
              {
#line 1300
              _obstack_newchunk(__o___263, 1);
              }
            }
#line 1300
            tmp___379 = __o___263->next_free;
#line 1300
            (__o___263->next_free) ++;
#line 1300
            *tmp___379 = (char )*(str + i);
          }
        }
#line 1300
        a___14 = 0;
        {
#line 1300
        while (1) {
          while_continue___270: /* CIL Label */ ;
#line 1300
          if (! (a___14 < (int )width - 1)) {
#line 1300
            goto while_break___270;
          }
#line 1300
          __o___264 = user_string_stack___0;
#line 1300
          if ((unsigned long )(__o___264->next_free + 1) > (unsigned long )__o___264->chunk_limit) {
            {
#line 1300
            _obstack_newchunk(__o___264, 1);
            }
          }
#line 1300
          tmp___380 = __o___264->next_free;
#line 1300
          (__o___264->next_free) ++;
#line 1300
          *tmp___380 = (char )padding;
#line 1300
          a___14 ++;
        }
        while_break___270: /* CIL Label */ ;
        }
#line 1300
        if (! width) {
#line 1300
          goto _L___26;
        } else
#line 1300
        if (justification > 0) {
          _L___26: /* CIL Label */ 
#line 1300
          __o___265 = user_string_stack___0;
#line 1300
          if ((unsigned long )(__o___265->next_free + 1) > (unsigned long )__o___265->chunk_limit) {
            {
#line 1300
            _obstack_newchunk(__o___265, 1);
            }
          }
#line 1300
          tmp___381 = __o___265->next_free;
#line 1300
          (__o___265->next_free) ++;
#line 1300
          *tmp___381 = (char )*(str + i);
        }
#line 1300
        goto while_break___269;
      }
      while_break___269: /* CIL Label */ ;
      }
    }
#line 208
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1302
  return;
}
}
#line 1314 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
static int first_time  =    1;
#line 1315 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
static struct obstack user_string_stack  ;
#line 1308 "/home/ysko/Works/test-src/a2ps-4.14/lib/metaseq.c"
unsigned char *expand_user_string(struct a2ps_job *job___0 , struct file_job *file ,
                                  unsigned char const   *context_name , unsigned char const   *str ) 
{ 
  unsigned char *res___2 ;
  struct obstack *__o ;
  char *tmp ;
  struct obstack *__o1 ;
  void *value ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1319
  if (first_time) {
    {
#line 1321
    first_time = 0;
#line 1322
    _obstack_begin(& user_string_stack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
    }
  }
#line 1325
  if (! str) {
#line 1326
    return ((unsigned char *)((void *)0));
  }
  {
#line 1328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1328
    if ((unsigned int )(1 << 10) & msg_verbosity) {
      {
#line 1328
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expanding of %s user string (`%s\')\n",
              context_name, str);
      }
    }
#line 1328
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1332
  grow_user_string_obstack(& user_string_stack, job___0, file, context_name, str);
#line 1335
  __o = & user_string_stack;
  }
#line 1335
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 1335
    _obstack_newchunk(__o, 1);
    }
  }
#line 1335
  tmp = __o->next_free;
#line 1335
  (__o->next_free) ++;
#line 1335
  *tmp = (char )'\000';
#line 1336
  __o1 = & user_string_stack;
#line 1336
  value = (void *)__o1->object_base;
#line 1336
  if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 1336
    __o1->maybe_empty_object = 1U;
  }
#line 1336
  __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 1336
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 1336
    __o1->next_free = __o1->chunk_limit;
  }
#line 1336
  __o1->object_base = __o1->next_free;
#line 1336
  res___2 = (unsigned char *)value;
#line 1337
  __o___0 = & user_string_stack;
#line 1337
  __obj = (void *)res___2;
#line 1337
  if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 1337
    if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 1337
      tmp___0 = (char *)__obj;
#line 1337
      __o___0->object_base = tmp___0;
#line 1337
      __o___0->next_free = tmp___0;
    } else {
      {
#line 1337
      obstack_free(__o___0, __obj);
      }
    }
  } else {
    {
#line 1337
    obstack_free(__o___0, __obj);
    }
  }
  {
#line 1339
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1339
    if ((unsigned int )(1 << 10) & msg_verbosity) {
      {
#line 1339
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expansion of %s (`%s\') is `%s\'\n",
              context_name, str, res___2);
      }
    }
#line 1339
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1342
  return (res___2);
}
}
#line 76 "/home/ysko/Works/test-src/a2ps-4.14/lib/message.c"
unsigned int msg_verbosity  =    0U;
#line 25 "/home/ysko/Works/test-src/a2ps-4.14/lib/msg.c"
char const   * const  _msg_verbosity_args[15]  = 
#line 25 "/home/ysko/Works/test-src/a2ps-4.14/lib/msg.c"
  {      (char const   */* const  */)"sheets",      (char const   */* const  */)"pathwalk",      (char const   */* const  */)"pw",      (char const   */* const  */)"encodings", 
        (char const   */* const  */)"configuration",      (char const   */* const  */)"options",      (char const   */* const  */)"files",      (char const   */* const  */)"tools", 
        (char const   */* const  */)"fonts",      (char const   */* const  */)"ppd",      (char const   */* const  */)"variables",      (char const   */* const  */)"meta-sequences", 
        (char const   */* const  */)"parsers",      (char const   */* const  */)"all",      (char const   */* const  */)0};
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/msg.c"
int const   _msg_verbosity_types[14]  = 
#line 41
  {      (int const   )(1 << 2),      (int const   )(1 << 3),      (int const   )(1 << 3),      (int const   )(1 << 4), 
        (int const   )(1 << 5),      (int const   )(1 << 5),      (int const   )(1 << 6),      (int const   )(1 << 7), 
        (int const   )(1 << 8),      (int const   )(1 << 9),      (int const   )(1 << 10),      (int const   )(1 << 10), 
        (int const   )(1 << 11),      (int const   )65535};
#line 90 "/home/ysko/Works/test-src/a2ps-4.14/lib/message.c"
int msg_verbosity_argmatch(char const   *option , char *arg ) 
{ 
  int res___2 ;
  char *token___1 ;
  char *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 93
  res___2 = 0;
#line 95
  if (! (sizeof(_msg_verbosity_args) / sizeof(_msg_verbosity_args[0]) == sizeof(_msg_verbosity_types) / sizeof(_msg_verbosity_types[0]) + 1UL)) {
    {
#line 95
    __assert_fail("(sizeof (((_msg_verbosity_args))) / sizeof (*((_msg_verbosity_args)))) == (sizeof (((_msg_verbosity_types))) / sizeof (*((_msg_verbosity_types)))) + 1",
                  "/home/ysko/Works/test-src/a2ps-4.14/lib/message.c", 95U, "msg_verbosity_argmatch");
    }
  }
  {
#line 97
  tmp___1 = __ctype_b_loc();
  }
#line 97
  if ((int const   )*(*tmp___1 + (int )*arg) & 2048) {
    {
#line 100
    res___2 = get_integer_in_range(option, (char const   *)arg, 0, 0, (enum range_type_e )1);
    }
  } else {
    {
#line 105
    tmp = strtok((char */* __restrict  */)arg, (char const   */* __restrict  */)",:;+");
#line 105
    token___1 = tmp;
    }
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 108
      tmp___0 = __xargmatch_internal(option, (char const   *)token___1, _msg_verbosity_args,
                                     (char const   *)(_msg_verbosity_types), (size_t )sizeof(_msg_verbosity_types[0]),
                                     0, argmatch_die);
#line 108
      res___2 |= (int )_msg_verbosity_types[tmp___0];
#line 106
      token___1 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",:;+");
      }
#line 106
      if (! token___1) {
#line 106
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 114
  return (res___2);
}
}
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 58 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.h"
struct hash_table_s *new_medium_table(void) ;
#line 60
void free_medium_table(struct hash_table_s *table ) ;
#line 62
struct medium *a2ps_get_medium(struct a2ps_job *job___0 , char const   *name ) ;
#line 65
char const   *a2ps_get_medium_name(struct a2ps_job *job___0 , char const   *name ) ;
#line 68
_Bool a2ps_medium_libpaper_p(struct a2ps_job *job___0  __attribute__((__unused__)) ,
                             char const   *name ) ;
#line 71
void add_medium(struct a2ps_job *job___0 , char const   *name , int w , int h , int llx ,
                int lly , int urx , int ury ) ;
#line 76
void list_media_long(struct a2ps_job *job___0 , FILE *stream ) ;
#line 77
void list_media_short(struct a2ps_job *job___0 , FILE *stream ) ;
#line 53 "/usr/include/paper.h"
extern char *systempapername(void) ;
#line 54 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
static unsigned long medium_hash_1(void const   *key ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    result = 0UL;
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 57
      kk = (unsigned char const   *)((struct medium  const  *)key)->name - 1;
      {
#line 57
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 57
        kk ++;
#line 57
        if (! *kk) {
#line 57
          goto while_break___1;
        }
        {
#line 57
        tmp = tolower((int )*kk);
#line 57
        tmp___0 = tolower((int )*(kk + 1));
#line 57
        result += (unsigned long )(tmp << (tmp___0 & 15));
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 57
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 57
    return (result);
#line 57
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return (0UL);
}
}
#line 60 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
static unsigned long medium_hash_2(void const   *key ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    result = 0UL;
    {
#line 63
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 63
      kk = (unsigned char const   *)((struct medium  const  *)key)->name - 1;
      {
#line 63
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 63
        kk ++;
#line 63
        if (! *kk) {
#line 63
          goto while_break___1;
        }
#line 63
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 63
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    return (result);
#line 63
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return (0UL);
}
}
#line 66 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
static int medium_hash_cmp(void const   *x , void const   *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 69
      xx = (unsigned char const   *)((struct medium  const  *)x)->name - 1;
#line 69
      yy = (unsigned char const   *)((struct medium  const  *)y)->name - 1;
      {
#line 69
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 69
        xx ++;
#line 69
        if ((int const   )*xx == 0) {
#line 69
          yy ++;
#line 69
          goto while_break___1;
        }
        {
#line 69
        yy ++;
#line 69
        tmp = tolower((int )*xx);
#line 69
        tmp___0 = tolower((int )*yy);
        }
#line 69
        if (! (tmp == tmp___0)) {
#line 69
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 69
      tmp___1 = tolower((int )*xx);
#line 69
      tmp___2 = tolower((int )*yy);
#line 69
      result = tmp___1 - tmp___2;
      }
#line 69
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 69
    return (result);
#line 69
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (0);
}
}
#line 73 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
static int medium_hash_qcmp(void const   *x , void const   *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      xx = (unsigned char const   *)(*((struct medium * const  *)x))->name - 1;
#line 76
      yy = (unsigned char const   *)(*((struct medium * const  *)y))->name - 1;
      {
#line 76
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 76
        xx ++;
#line 76
        if ((int const   )*xx == 0) {
#line 76
          yy ++;
#line 76
          goto while_break___1;
        }
        {
#line 76
        yy ++;
#line 76
        tmp = tolower((int )*xx);
#line 76
        tmp___0 = tolower((int )*yy);
        }
#line 76
        if (! (tmp == tmp___0)) {
#line 76
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 76
      tmp___1 = tolower((int )*xx);
#line 76
      tmp___2 = tolower((int )*yy);
#line 76
      result = tmp___1 - tmp___2;
      }
#line 76
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 76
    return (result);
#line 76
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (0);
}
}
#line 82 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
static size_t medium_name_len(struct medium *medium ) 
{ 
  size_t tmp ;

  {
  {
#line 85
  tmp = strlen((char const   *)medium->name);
  }
#line 85
  return (tmp);
}
}
#line 90 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
static void medium_name_fputs(struct medium *medium , FILE *stream ) 
{ 


  {
  {
#line 93
  fputs((char const   */* __restrict  */)medium->name, (FILE */* __restrict  */)stream);
  }
#line 94
  return;
}
}
#line 100 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
void add_medium(struct a2ps_job *job___0 , char const   *name , int w , int h , int llx ,
                int lly , int urx , int ury ) 
{ 
  struct medium *a_medium ;
  void *tmp ;

  {
  {
#line 106
  tmp = xmalloc((size_t )sizeof(struct medium ));
#line 106
  a_medium = (struct medium *)tmp;
#line 108
  a_medium->name = xstrdup(name);
#line 109
  a_medium->w = w;
#line 110
  a_medium->h = h;
#line 111
  a_medium->llx = llx;
#line 112
  a_medium->lly = lly;
#line 113
  a_medium->urx = urx;
#line 114
  a_medium->ury = ury;
#line 116
  hash_insert(job___0->media, (void *)a_medium);
  }
#line 117
  return;
}
}
#line 122 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
static void hash_free_medium(struct medium *medium ) 
{ 


  {
  {
#line 125
  free((void *)medium->name);
#line 126
  free((void *)medium);
  }
#line 127
  return;
}
}
#line 132 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
struct hash_table_s *new_medium_table(void) 
{ 
  struct hash_table_s *res___2 ;
  void *tmp ;

  {
  {
#line 137
  tmp = xmalloc((size_t )sizeof(struct hash_table_s ));
#line 137
  res___2 = (struct hash_table_s *)tmp;
#line 138
  hash_init(res___2, 16UL, & medium_hash_1, & medium_hash_2, & medium_hash_cmp);
  }
#line 141
  return (res___2);
}
}
#line 147 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
void free_medium_table(struct hash_table_s *table ) 
{ 


  {
  {
#line 150
  hash_free(table, (void (*)(void const   *item ))(& hash_free_medium));
#line 151
  free((void *)table);
  }
#line 152
  return;
}
}
#line 157 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
struct medium *a2ps_get_medium(struct a2ps_job *job___0 , char const   *name ) 
{ 
  struct medium *item ;
  struct medium token___1 ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 163
  token___1.name = (char *)((void *)0);
#line 164
  tmp___0 = strcasecmp(name, "libpaper");
  }
#line 164
  if (! tmp___0) {
    {
#line 165
    tmp = systempapername();
#line 165
    token___1.name = tmp;
    }
  }
#line 167
  if (! token___1.name) {
#line 168
    token___1.name = (char *)name;
  }
  {
#line 170
  tmp___1 = hash_find_item(job___0->media, (void const   *)(& token___1));
#line 170
  item = (struct medium *)tmp___1;
  }
#line 172
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    {
#line 173
    tmp___2 = quotearg((char const   *)token___1.name);
#line 173
    tmp___3 = gettext("unknown medium `%s\'");
#line 173
    error(1, 0, (char const   *)tmp___3, tmp___2);
    }
  }
#line 175
  return (item);
}
}
#line 180 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
char const   *a2ps_get_medium_name(struct a2ps_job *job___0 , char const   *name ) 
{ 
  struct medium *medium ;

  {
  {
#line 187
  medium = a2ps_get_medium(job___0, name);
  }
#line 188
  return ((char const   *)medium->name);
}
}
#line 192 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
_Bool a2ps_medium_libpaper_p(struct a2ps_job *job___0  __attribute__((__unused__)) ,
                             char const   *name ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 195
  tmp___1 = strcmp(name, "libpaper");
  }
#line 195
  if (tmp___1 == 0) {
#line 195
    tmp___0 = 1;
  } else {
#line 195
    tmp___0 = 0;
  }
#line 195
  return ((_Bool )tmp___0);
}
}
#line 201 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
void list_media_long(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  int i ;
  struct medium **media ;
  void **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 206
  tmp = hash_dump(job___0->media, (void **)((void *)0), & medium_hash_qcmp);
#line 206
  media = (struct medium **)tmp;
#line 208
  tmp___0 = gettext("Known Media");
#line 208
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 209
  _IO_putc('\n', stream);
#line 210
  tmp___1 = gettext("dimensions");
#line 210
  tmp___2 = gettext("Name");
#line 210
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  %-10s\t%11s (%4s, %4s, %4s, %4s)\n",
          tmp___2, tmp___1, "llx", "lly", "urx", "ury");
#line 216
  i = 0;
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! *(media + i)) {
#line 216
      goto while_break;
    }
    {
#line 217
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  %-10s\t%4d x %4d (%4d, %4d, %4d, %4d)\n",
            (*(media + i))->name, (*(media + i))->w, (*(media + i))->h, (*(media + i))->llx,
            (*(media + i))->lly, (*(media + i))->urx, (*(media + i))->ury);
#line 216
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  _IO_putc('\n', stream);
#line 224
  free((void *)media);
  }
#line 225
  return;
}
}
#line 230 "/home/ysko/Works/test-src/a2ps-4.14/lib/media.c"
void list_media_short(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  struct medium **media ;
  void **tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 235
  tmp = hash_dump(job___0->media, (void **)((void *)0), & medium_hash_qcmp);
#line 235
  media = (struct medium **)tmp;
#line 237
  tmp___0 = gettext("Known Media");
#line 237
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 238
  _IO_putc('\n', stream);
#line 239
  lister_fprint_vertical((struct lister *)((void *)0), stream, (void **)media, (size_t )-1,
                         (size_t (*)(void const   *item ))(& medium_name_len), (void (*)(void const   *item ,
                                                                                         FILE *stream ))(& medium_name_fputs));
#line 244
  free((void *)media);
  }
#line 245
  return;
}
}
#line 40 "/home/ysko/Works/test-src/a2ps-4.14/lib/madir.h"
char const   *madir_to_string(madir_t madir ) ;
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/lib/madir.c"
static char const   * const  madir_args[3]  = {      (char const   */* const  */)"rows",      (char const   */* const  */)"columns",      (char const   */* const  */)0};
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/lib/madir.c"
static madir_t madir_types[2]  = {      (madir_t )0,      (madir_t )1};
#line 47 "/home/ysko/Works/test-src/a2ps-4.14/lib/madir.c"
madir_t madir_argmatch(char const   *option , char const   *arg ) 
{ 
  int tmp ;

  {
  {
#line 50
  tmp = __xargmatch_internal(option, arg, madir_args, (char const   *)(madir_types),
                             (size_t )sizeof(madir_types[0]), 0, argmatch_die);
  }
#line 50
  return (madir_types[tmp]);
}
}
#line 53 "/home/ysko/Works/test-src/a2ps-4.14/lib/madir.c"
char const   *madir_to_string(madir_t madir ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 58
  if ((unsigned int )madir == 0U) {
#line 58
    goto case_0;
  }
#line 61
  if ((unsigned int )madir == 1U) {
#line 61
    goto case_1;
  }
#line 64
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 59
  tmp = gettext("rows first");
  }
#line 59
  return ((char const   *)tmp);
  case_1: /* CIL Label */ 
  {
#line 62
  tmp___0 = gettext("columns first");
  }
#line 62
  return ((char const   *)tmp___0);
  switch_default: /* CIL Label */ 
  {
#line 65
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 43 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.h"
void lister_initialize(struct lister *lister , FILE *stream ) ;
#line 46
struct tterm *lister_tterm_set(struct lister *lister , struct tterm *tterm ) ;
#line 51
size_t lister_before_set(struct lister *lister , size_t size ) ;
#line 55
size_t lister_after_set(struct lister *lister , size_t size ) ;
#line 58
void lister_fprint_horizontal(struct lister *lister , FILE *unused  __attribute__((__unused__)) ,
                              void **items , size_t item_number , size_t (*item_width_fn)(void const   *item ) ,
                              void (*item_print_fn)(void const   *item , FILE *stream ) ) ;
#line 76
void lister_print_vertical(struct lister *lister , void **items , size_t item_number ) ;
#line 79
void lister_print_horizontal(struct lister *lister , void **items , size_t item_number ) ;
#line 82
void lister_print_separated(struct lister *lister , void **items , size_t item_number ) ;
#line 141 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
static struct lister lister_default  = 
#line 141 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
     {(struct tterm *)((void *)0), (FILE *)((void *)0), (size_t (*)(void const   *item ))(& strlen),
    (void (*)(void const   *item , FILE *stream ))(& fputs), (size_t )0, (size_t )0,
    {(size_t )2, (size_t )0, (struct world *)((void *)0)}, {",", (size_t )2, "."}};
#line 170 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
static size_t max_idx  ;
#line 178 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
void lister_initialize(struct lister *lister , FILE *stream ) 
{ 
  struct lister *l ;
  struct lister *tmp ;

  {
#line 181
  if (lister) {
#line 181
    tmp = lister;
  } else {
#line 181
    tmp = & lister_default;
  }
  {
#line 181
  l = tmp;
#line 182
  tterm_initialize((struct tterm *)((void *)0), stream);
#line 183
  l->stream = stream;
  }
#line 184
  return;
}
}
#line 210 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
static void init_worlds(struct lister *l ) 
{ 
  size_t i ;
  size_t line_width ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t j ;

  {
  {
#line 214
  tmp = tterm_width(l->tterm);
#line 214
  line_width = tmp;
  }
#line 219
  if ((unsigned long )l->multicol.worlds == (unsigned long )((void *)0)) {
    {
#line 221
    tmp___0 = xmalloc((size_t )(sizeof(struct world ) * (unsigned long )line_width));
#line 221
    l->multicol.worlds = (struct world *)tmp___0;
#line 222
    i = (size_t )0;
    }
    {
#line 222
    while (1) {
      while_continue: /* CIL Label */ ;
#line 222
      if (! (i < line_width)) {
#line 222
        goto while_break;
      }
      {
#line 223
      tmp___1 = xmalloc((size_t )(sizeof(size_t ) * (unsigned long )(i + 1U)));
#line 223
      (l->multicol.worlds + i)->widths = (size_t *)tmp___1;
#line 222
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 226
  max_idx = (((line_width - l->before) - l->after) - l->multicol.between) / (1U + l->multicol.between);
#line 229
  if (max_idx == 0U) {
#line 230
    max_idx = (size_t )1;
  }
#line 232
  i = (size_t )0;
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 232
    if (! (i < max_idx)) {
#line 232
      goto while_break___0;
    }
#line 236
    (l->multicol.worlds + i)->valid_len = (size_t )1;
#line 237
    (l->multicol.worlds + i)->width = i + 1U;
#line 239
    j = (size_t )0;
    {
#line 239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 239
      if (! (j <= i)) {
#line 239
        goto while_break___1;
      }
#line 240
      *((l->multicol.worlds + i)->widths + j) = (size_t )1;
#line 239
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 232
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 246 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
struct tterm *lister_tterm_set(struct lister *lister , struct tterm *tterm ) 
{ 
  struct lister *l ;
  struct lister *tmp ;
  struct tterm *old ;

  {
#line 249
  if (lister) {
#line 249
    tmp = lister;
  } else {
#line 249
    tmp = & lister_default;
  }
#line 249
  l = tmp;
#line 250
  old = l->tterm;
#line 251
  l->tterm = tterm;
#line 252
  return (old);
}
}
#line 258 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
size_t lister_before_set(struct lister *lister , size_t size ) 
{ 
  struct lister *l ;
  struct lister *tmp ;
  size_t old ;

  {
#line 261
  if (lister) {
#line 261
    tmp = lister;
  } else {
#line 261
    tmp = & lister_default;
  }
#line 261
  l = tmp;
#line 262
  old = l->before;
#line 263
  l->before = size;
#line 264
  return (old);
}
}
#line 270 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
size_t lister_after_set(struct lister *lister , size_t size ) 
{ 
  struct lister *l ;
  struct lister *tmp ;
  size_t old ;

  {
#line 273
  if (lister) {
#line 273
    tmp = lister;
  } else {
#line 273
    tmp = & lister_default;
  }
#line 273
  l = tmp;
#line 274
  old = l->after;
#line 275
  l->after = size;
#line 276
  return (old);
}
}
#line 280 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
static size_t lister_vertical_format(struct lister *l , void **items , size_t item_number ,
                                     size_t (*item_width_fn)(void const   *item ) ,
                                     struct world **line_fmt ) 
{ 
  size_t max_cols ;
  size_t cols ;
  size_t itemno ;
  size_t item_width ;
  struct multicol *m ;
  size_t available_width ;
  size_t tmp ;
  struct world *worlds ;
  size_t i ;
  size_t effective_width ;
  size_t idx ;
  size_t real_width ;

  {
  {
#line 290
  m = & l->multicol;
#line 291
  tmp = tterm_width(l->tterm);
#line 291
  available_width = (tmp - l->after) - l->before;
#line 292
  worlds = m->worlds;
  }
#line 297
  if (max_idx > item_number) {
#line 297
    max_cols = item_number;
  } else {
#line 297
    max_cols = max_idx;
  }
#line 300
  itemno = (size_t )0;
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! (itemno < item_number)) {
#line 300
      goto while_break;
    }
    {
#line 304
    item_width = (*item_width_fn)((void const   *)*(items + itemno));
#line 306
    i = (size_t )0;
    }
    {
#line 306
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 306
      if (! (i < max_cols)) {
#line 306
        goto while_break___0;
      }
#line 308
      if ((worlds + i)->valid_len) {
#line 310
        effective_width = available_width - i * m->between;
#line 311
        idx = itemno / ((item_number + i) / (i + 1U));
#line 312
        real_width = item_width;
#line 314
        if (real_width > *((worlds + i)->widths + idx)) {
#line 316
          (worlds + i)->width += real_width - *((worlds + i)->widths + idx);
#line 317
          *((worlds + i)->widths + idx) = real_width;
#line 318
          (worlds + i)->valid_len = (size_t )((worlds + i)->width <= effective_width);
        }
      }
#line 306
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 300
    itemno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  cols = max_cols;
  {
#line 325
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 325
    if (! (cols > 1U)) {
#line 325
      goto while_break___1;
    }
#line 327
    if ((worlds + (cols - 1U))->valid_len) {
#line 328
      goto while_break___1;
    }
#line 325
    cols --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 331
  *line_fmt = worlds + (cols - 1U);
#line 332
  return (cols);
}
}
#line 335 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
void lister_fprint_vertical(struct lister *lister , FILE *unused  __attribute__((__unused__)) ,
                            void **items , size_t item_number , size_t (*item_width_fn)(void const   *item ) ,
                            void (*item_print_fn)(void const   *item , FILE *stream ) ) 
{ 
  struct world *line_fmt ;
  size_t itemno ;
  size_t row ;
  size_t col_width ;
  size_t item_width ;
  size_t pos ;
  size_t cols ;
  size_t rows ;
  struct lister *l ;
  struct lister *tmp ;
  struct multicol *m ;
  size_t tabsize ;
  size_t tmp___0 ;
  FILE *stream ;
  size_t col ;
  size_t nextpos ;
  size_t nextcolpos ;
  size_t tmp___1 ;
  size_t from ;
  size_t to ;

  {
#line 349
  if (lister) {
#line 349
    tmp = lister;
  } else {
#line 349
    tmp = & lister_default;
  }
  {
#line 349
  l = tmp;
#line 350
  m = & l->multicol;
#line 351
  tmp___0 = tterm_tabsize(l->tterm);
#line 351
  tabsize = tmp___0;
#line 352
  stream = l->stream;
#line 354
  init_worlds(l);
  }
#line 360
  if (item_number == 4294967295U) {
#line 362
    item_number = (size_t )0;
    {
#line 362
    while (1) {
      while_continue: /* CIL Label */ ;
#line 362
      if (! *(items + item_number)) {
#line 362
        goto while_break;
      }
#line 362
      item_number ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 366
  cols = lister_vertical_format(l, items, item_number, item_width_fn, & line_fmt);
#line 371
  rows = item_number / cols + (size_t )(item_number % cols != 0U);
#line 373
  row = (size_t )0;
  }
  {
#line 373
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 373
    if (! (row < rows)) {
#line 373
      goto while_break___0;
    }
#line 375
    col = (size_t )0;
#line 377
    itemno = row;
#line 380
    pos = (size_t )0;
#line 381
    nextpos = l->before;
#line 381
    nextcolpos = nextpos;
    {
#line 382
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 384
      tmp___1 = col;
#line 384
      col ++;
#line 384
      col_width = *(line_fmt->widths + tmp___1);
#line 385
      item_width = (*item_width_fn)((void const   *)*(items + itemno));
#line 386
      nextpos += ((col_width - item_width) * m->justify) / 2U;
#line 387
      nextcolpos += col_width + m->between;
      }
      {
#line 389
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 389
        from = pos;
#line 389
        to = nextpos;
        {
#line 389
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 389
          if (! (from < to)) {
#line 389
            goto while_break___3;
          }
#line 389
          if (tabsize > 0U) {
#line 389
            if (to / tabsize > (from + 1U) / tabsize) {
              {
#line 389
              _IO_putc('\t', stream);
#line 389
              from += tabsize - from % tabsize;
              }
            } else {
              {
#line 389
              _IO_putc(' ', stream);
#line 389
              from ++;
              }
            }
          } else {
            {
#line 389
            _IO_putc(' ', stream);
#line 389
            from ++;
            }
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 389
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 390
      (*item_print_fn)((void const   *)*(items + itemno), stream);
#line 392
      itemno += rows;
      }
#line 393
      if (itemno >= item_number) {
#line 394
        goto while_break___1;
      }
#line 396
      pos = nextpos + item_width;
#line 397
      nextpos = nextcolpos;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 399
    _IO_putc('\n', stream);
#line 373
    row ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 401
  return;
}
}
#line 406 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
void lister_print_vertical(struct lister *lister , void **items , size_t item_number ) 
{ 
  struct lister *l ;
  struct lister *tmp ;

  {
#line 410
  if (lister) {
#line 410
    tmp = lister;
  } else {
#line 410
    tmp = & lister_default;
  }
  {
#line 410
  l = tmp;
#line 411
  lister_fprint_vertical(lister, (FILE *)((void *)0), items, item_number, l->width_fn,
                         l->print_fn);
  }
#line 414
  return;
}
}
#line 428 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
static size_t lister_horizontal_format(struct lister *l , void **items , size_t item_number ,
                                       size_t (*item_width_fn)(void const   *item ) ,
                                       struct world **line_fmt ) 
{ 
  size_t max_cols ;
  size_t cols ;
  size_t itemno ;
  size_t item_width ;
  struct multicol *m ;
  size_t available_width ;
  size_t tmp ;
  struct world *worlds ;
  size_t i ;
  size_t effective_width ;
  size_t idx ;
  size_t real_width ;

  {
  {
#line 438
  m = & l->multicol;
#line 439
  tmp = tterm_width(l->tterm);
#line 439
  available_width = (tmp - l->after) - l->before;
#line 440
  worlds = m->worlds;
  }
#line 445
  if (max_idx > item_number) {
#line 445
    max_cols = item_number;
  } else {
#line 445
    max_cols = max_idx;
  }
#line 448
  itemno = (size_t )0;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if (! (itemno < item_number)) {
#line 448
      goto while_break;
    }
    {
#line 452
    item_width = (*item_width_fn)((void const   *)*(items + itemno));
#line 454
    i = (size_t )0;
    }
    {
#line 454
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 454
      if (! (i < max_cols)) {
#line 454
        goto while_break___0;
      }
#line 456
      if ((worlds + i)->valid_len) {
#line 458
        effective_width = available_width - i * m->between;
#line 459
        idx = itemno % (i + 1U);
#line 460
        real_width = item_width;
#line 462
        if (real_width > *((worlds + i)->widths + idx)) {
#line 464
          (worlds + i)->width += real_width - *((worlds + i)->widths + idx);
#line 465
          *((worlds + i)->widths + idx) = real_width;
#line 466
          (worlds + i)->valid_len = (size_t )((worlds + i)->width <= effective_width);
        }
      }
#line 454
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 448
    itemno ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  cols = max_cols;
  {
#line 473
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 473
    if (! (cols > 1U)) {
#line 473
      goto while_break___1;
    }
#line 475
    if ((worlds + (cols - 1U))->valid_len) {
#line 476
      goto while_break___1;
    }
#line 473
    cols --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 479
  *line_fmt = worlds + (cols - 1U);
#line 480
  return (cols);
}
}
#line 485 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
void lister_fprint_horizontal(struct lister *lister , FILE *unused  __attribute__((__unused__)) ,
                              void **items , size_t item_number , size_t (*item_width_fn)(void const   *item ) ,
                              void (*item_print_fn)(void const   *item , FILE *stream ) ) 
{ 
  struct world *line_fmt ;
  size_t itemno ;
  size_t col_width ;
  size_t item_width ;
  size_t cols ;
  size_t pos ;
  size_t nextpos ;
  size_t nextcolpos ;
  struct lister *l ;
  struct lister *tmp ;
  struct multicol *m ;
  size_t tabsize ;
  size_t tmp___0 ;
  FILE *stream ;
  size_t col ;
  size_t from ;
  size_t to ;

  {
#line 498
  if (lister) {
#line 498
    tmp = lister;
  } else {
#line 498
    tmp = & lister_default;
  }
  {
#line 498
  l = tmp;
#line 499
  m = & l->multicol;
#line 500
  tmp___0 = tterm_tabsize(l->tterm);
#line 500
  tabsize = tmp___0;
#line 501
  stream = l->stream;
#line 503
  init_worlds(l);
  }
#line 509
  if (item_number == 4294967295U) {
#line 511
    item_number = (size_t )0;
    {
#line 511
    while (1) {
      while_continue: /* CIL Label */ ;
#line 511
      if (! *(items + item_number)) {
#line 511
        goto while_break;
      }
#line 511
      item_number ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 515
  cols = lister_horizontal_format(l, items, item_number, item_width_fn, & line_fmt);
#line 519
  pos = (size_t )0;
#line 520
  nextpos = l->before;
#line 520
  nextcolpos = nextpos;
#line 523
  itemno = (size_t )0;
  }
  {
#line 523
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 523
    if (! (itemno < item_number)) {
#line 523
      goto while_break___0;
    }
    {
#line 525
    col = itemno % cols;
#line 527
    item_width = strlen((char const   *)*(items + itemno));
#line 528
    col_width = *(line_fmt->widths + col);
    }
#line 530
    if (col == 0U) {
#line 530
      if (itemno != 0U) {
        {
#line 532
        _IO_putc('\n', stream);
#line 533
        pos = (size_t )0;
#line 534
        nextpos = l->before;
#line 534
        nextcolpos = nextpos;
        }
      }
    }
#line 537
    nextpos += ((col_width - item_width) * m->justify) / 2U;
    {
#line 538
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 538
      from = pos;
#line 538
      to = nextpos;
      {
#line 538
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 538
        if (! (from < to)) {
#line 538
          goto while_break___2;
        }
#line 538
        if (tabsize > 0U) {
#line 538
          if (to / tabsize > (from + 1U) / tabsize) {
            {
#line 538
            _IO_putc('\t', stream);
#line 538
            from += tabsize - from % tabsize;
            }
          } else {
            {
#line 538
            _IO_putc(' ', stream);
#line 538
            from ++;
            }
          }
        } else {
          {
#line 538
          _IO_putc(' ', stream);
#line 538
          from ++;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 538
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 539
    (*item_print_fn)((void const   *)*(items + itemno), stream);
#line 540
    pos = nextpos + item_width;
#line 541
    nextcolpos += col_width + m->between;
#line 542
    nextpos = nextcolpos;
#line 523
    itemno ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 544
  _IO_putc('\n', stream);
  }
#line 545
  return;
}
}
#line 551 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
void lister_print_horizontal(struct lister *lister , void **items , size_t item_number ) 
{ 
  struct lister *l ;
  struct lister *tmp ;

  {
#line 555
  if (lister) {
#line 555
    tmp = lister;
  } else {
#line 555
    tmp = & lister_default;
  }
  {
#line 555
  l = tmp;
#line 556
  lister_fprint_horizontal(lister, (FILE *)((void *)0), items, item_number, l->width_fn,
                           l->print_fn);
  }
#line 559
  return;
}
}
#line 579 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
void lister_fprint_separated(struct lister *lister , FILE *unused  __attribute__((__unused__)) ,
                             void **items , size_t item_number , size_t (*item_width_fn)(void const   *item ) ,
                             void (*item_print_fn)(void const   *item , FILE *stream ) ) 
{ 
  size_t itemno ;
  size_t pos ;
  struct lister *l ;
  struct lister *tmp ;
  struct separated *s ;
  size_t final_width ;
  size_t tmp___0 ;
  size_t separator_width ;
  size_t tmp___1 ;
  size_t tabsize ;
  size_t tmp___2 ;
  FILE *stream ;
  size_t line_width ;
  size_t tmp___3 ;
  size_t old_pos ;
  size_t from ;
  size_t to ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t from___0 ;
  size_t to___0 ;
  size_t from___1 ;
  size_t to___1 ;
  char const   *tmp___6 ;
  int tmp___7 ;

  {
#line 587
  if (lister) {
#line 587
    tmp = lister;
  } else {
#line 587
    tmp = & lister_default;
  }
  {
#line 587
  l = tmp;
#line 588
  s = & l->separated;
#line 589
  tmp___0 = strlen(s->final);
#line 589
  final_width = tmp___0;
#line 590
  tmp___1 = strlen(s->separator);
#line 590
  separator_width = tmp___1;
#line 591
  tmp___2 = tterm_tabsize(l->tterm);
#line 591
  tabsize = tmp___2;
#line 592
  stream = l->stream;
#line 597
  tmp___3 = tterm_width(l->tterm);
#line 597
  line_width = tmp___3 - l->after;
#line 600
  pos = l->before;
  }
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    from = (size_t )0;
#line 601
    to = pos;
    {
#line 601
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 601
      if (! (from < to)) {
#line 601
        goto while_break___0;
      }
#line 601
      if (tabsize > 0U) {
#line 601
        if (to / tabsize > (from + 1U) / tabsize) {
          {
#line 601
          _IO_putc('\t', stream);
#line 601
          from += tabsize - from % tabsize;
          }
        } else {
          {
#line 601
          _IO_putc(' ', stream);
#line 601
          from ++;
          }
        }
      } else {
        {
#line 601
        _IO_putc(' ', stream);
#line 601
        from ++;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 601
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  itemno = (size_t )0;
  {
#line 603
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 603
    if (item_number != 4294967295U) {
#line 603
      tmp___7 = itemno < item_number;
    } else {
#line 603
      tmp___7 = (unsigned long )*(items + itemno) != (unsigned long )((void *)0);
    }
#line 603
    if (! tmp___7) {
#line 603
      goto while_break___1;
    }
    {
#line 609
    old_pos = pos;
#line 611
    tmp___4 = (*item_width_fn)((void const   *)*(items + itemno));
#line 611
    pos += tmp___4;
    }
#line 612
    if (itemno + 1U < item_number) {
#line 612
      tmp___5 = separator_width;
    } else {
#line 612
      tmp___5 = final_width;
    }
#line 612
    pos += tmp___5;
#line 614
    if (itemno) {
#line 616
      if (pos + s->between > line_width) {
        {
#line 618
        _IO_putc('\n', stream);
        }
        {
#line 619
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 619
          from___0 = (size_t )0;
#line 619
          to___0 = l->before;
          {
#line 619
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 619
            if (! (from___0 < to___0)) {
#line 619
              goto while_break___3;
            }
#line 619
            if (tabsize > 0U) {
#line 619
              if (to___0 / tabsize > (from___0 + 1U) / tabsize) {
                {
#line 619
                _IO_putc('\t', stream);
#line 619
                from___0 += tabsize - from___0 % tabsize;
                }
              } else {
                {
#line 619
                _IO_putc(' ', stream);
#line 619
                from___0 ++;
                }
              }
            } else {
              {
#line 619
              _IO_putc(' ', stream);
#line 619
              from___0 ++;
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 619
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 620
        pos = (pos - old_pos) + l->before;
      } else {
        {
#line 624
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 624
          from___1 = old_pos;
#line 624
          to___1 = old_pos + s->between;
          {
#line 624
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 624
            if (! (from___1 < to___1)) {
#line 624
              goto while_break___5;
            }
#line 624
            if (tabsize > 0U) {
#line 624
              if (to___1 / tabsize > (from___1 + 1U) / tabsize) {
                {
#line 624
                _IO_putc('\t', stream);
#line 624
                from___1 += tabsize - from___1 % tabsize;
                }
              } else {
                {
#line 624
                _IO_putc(' ', stream);
#line 624
                from___1 ++;
                }
              }
            } else {
              {
#line 624
              _IO_putc(' ', stream);
#line 624
              from___1 ++;
              }
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 624
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 625
        pos += s->between;
      }
    }
    {
#line 628
    (*item_print_fn)((void const   *)*(items + itemno), stream);
    }
#line 629
    if (itemno + 1U < item_number) {
#line 629
      tmp___6 = s->separator;
    } else {
#line 629
      tmp___6 = s->final;
    }
    {
#line 629
    fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)stream);
#line 603
    itemno ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 631
  _IO_putc('\n', stream);
  }
#line 632
  return;
}
}
#line 637 "/home/ysko/Works/test-src/a2ps-4.14/lib/lister.c"
void lister_print_separated(struct lister *lister , void **items , size_t item_number ) 
{ 
  struct lister *l ;
  struct lister *tmp ;

  {
#line 641
  if (lister) {
#line 641
    tmp = lister;
  } else {
#line 641
    tmp = & lister_default;
  }
  {
#line 641
  l = tmp;
#line 642
  lister_fprint_separated(lister, (FILE *)((void *)0), items, item_number, l->width_fn,
                          l->print_fn);
  }
#line 645
  return;
}
}
#line 458 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 799 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 155 "lexppd.c"
int ppdleng  ;
#line 157
FILE *ppdout ;
#line 270 "lexppd.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 271 "lexppd.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 272 "lexppd.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 290 "lexppd.c"
static char yy_hold_char  ;
#line 291 "lexppd.c"
static int yy_n_chars  ;
#line 295 "lexppd.c"
static char *yy_c_buf_p  =    (char *)0;
#line 296 "lexppd.c"
static int yy_init  =    0;
#line 297 "lexppd.c"
static int yy_start  =    0;
#line 302 "lexppd.c"
static int yy_did_buffer_switch_on_eof  ;
#line 304
void ppdrestart(FILE *input_file ) ;
#line 305
void ppd_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 306
YY_BUFFER_STATE ppd_create_buffer(FILE *file , int size ) ;
#line 307
void ppd_delete_buffer(YY_BUFFER_STATE b ) ;
#line 308
void ppd_flush_buffer(YY_BUFFER_STATE b ) ;
#line 309
void ppdpush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 310
void ppdpop_buffer_state(void) ;
#line 312
static void ppdensure_buffer_stack(void) ;
#line 313
static void ppd_load_buffer_state(void) ;
#line 314
static void ppd_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 318
YY_BUFFER_STATE ppd_scan_buffer(char *base , yy_size_t size ) ;
#line 319
YY_BUFFER_STATE ppd_scan_string(char const   *yystr ) ;
#line 320
YY_BUFFER_STATE ppd_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 322
void *ppdalloc(yy_size_t size ) ;
#line 323
void *ppdrealloc(void *ptr , yy_size_t size ) ;
#line 324
void ppdfree(void *ptr ) ;
#line 354 "lexppd.c"
FILE *ppdin  =    (FILE *)0;
#line 354 "lexppd.c"
FILE *ppdout  =    (FILE *)0;
#line 360 "lexppd.c"
int ppdlineno  =    1;
#line 362 "lexppd.c"
char *ppdtext  ;
#line 365
static yy_state_type yy_get_previous_state(void) ;
#line 366
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 367
static int yy_get_next_buffer(void) ;
#line 368
static void yy_fatal_error(char const   *msg ) ;
#line 389 "lexppd.c"
static flex_int16_t const   yy_accept[115]  = 
#line 389
  {      (flex_int16_t const   )0,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )44,      (flex_int16_t const   )10,      (flex_int16_t const   )2, 
        (flex_int16_t const   )12,      (flex_int16_t const   )11,      (flex_int16_t const   )3,      (flex_int16_t const   )11, 
        (flex_int16_t const   )10,      (flex_int16_t const   )4,      (flex_int16_t const   )26,      (flex_int16_t const   )13, 
        (flex_int16_t const   )26,      (flex_int16_t const   )40,      (flex_int16_t const   )27,      (flex_int16_t const   )43, 
        (flex_int16_t const   )43,      (flex_int16_t const   )41,      (flex_int16_t const   )43,      (flex_int16_t const   )10, 
        (flex_int16_t const   )2,      (flex_int16_t const   )12,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )26,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )14, 
        (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )18,      (flex_int16_t const   )19, 
        (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )23, 
        (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )40,      (flex_int16_t const   )39, 
        (flex_int16_t const   )28,      (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )32, 
        (flex_int16_t const   )33,      (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )36, 
        (flex_int16_t const   )37,      (flex_int16_t const   )38,      (flex_int16_t const   )39,      (flex_int16_t const   )41, 
        (flex_int16_t const   )0,      (flex_int16_t const   )10,      (flex_int16_t const   )0,      (flex_int16_t const   )1, 
        (flex_int16_t const   )0,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )14,      (flex_int16_t const   )15, 
        (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )42,      (flex_int16_t const   )1, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )28, 
        (flex_int16_t const   )29,      (flex_int16_t const   )10,      (flex_int16_t const   )7,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )5, 
        (flex_int16_t const   )10,      (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )8, 
        (flex_int16_t const   )10,      (flex_int16_t const   )6,      (flex_int16_t const   )0};
#line 406 "lexppd.c"
static flex_int32_t const   yy_ec[256]  = 
#line 406
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )8,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )9,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )10, 
        (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11, 
        (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11,      (flex_int32_t const   )11, 
        (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )14,      (flex_int32_t const   )12,      (flex_int32_t const   )15,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )16,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )17,      (flex_int32_t const   )18,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )19,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )20,      (flex_int32_t const   )21,      (flex_int32_t const   )22, 
        (flex_int32_t const   )23,      (flex_int32_t const   )24,      (flex_int32_t const   )25,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )26,      (flex_int32_t const   )1,      (flex_int32_t const   )27, 
        (flex_int32_t const   )28,      (flex_int32_t const   )29,      (flex_int32_t const   )30,      (flex_int32_t const   )31, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )32,      (flex_int32_t const   )1, 
        (flex_int32_t const   )33,      (flex_int32_t const   )34,      (flex_int32_t const   )35,      (flex_int32_t const   )1, 
        (flex_int32_t const   )36,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 438 "lexppd.c"
static flex_int32_t const   yy_meta[37]  = 
#line 438
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )4, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )7,      (flex_int32_t const   )6,      (flex_int32_t const   )6, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )8, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1};
#line 446 "lexppd.c"
static flex_int16_t const   yy_base[129]  = 
#line 446
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )5, 
        (flex_int16_t const   )14,      (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )6, 
        (flex_int16_t const   )26,      (flex_int16_t const   )125,      (flex_int16_t const   )0,      (flex_int16_t const   )27, 
        (flex_int16_t const   )263,      (flex_int16_t const   )121,      (flex_int16_t const   )263,      (flex_int16_t const   )263, 
        (flex_int16_t const   )36,      (flex_int16_t const   )263,      (flex_int16_t const   )0,      (flex_int16_t const   )263, 
        (flex_int16_t const   )52,      (flex_int16_t const   )0,      (flex_int16_t const   )263,      (flex_int16_t const   )78, 
        (flex_int16_t const   )263,      (flex_int16_t const   )120,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )36,      (flex_int16_t const   )263,      (flex_int16_t const   )113,      (flex_int16_t const   )97, 
        (flex_int16_t const   )81,      (flex_int16_t const   )79,      (flex_int16_t const   )76,      (flex_int16_t const   )80, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )263,      (flex_int16_t const   )94, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )116,      (flex_int16_t const   )0,      (flex_int16_t const   )263, 
        (flex_int16_t const   )93,      (flex_int16_t const   )263,      (flex_int16_t const   )263,      (flex_int16_t const   )263, 
        (flex_int16_t const   )263,      (flex_int16_t const   )263,      (flex_int16_t const   )263,      (flex_int16_t const   )263, 
        (flex_int16_t const   )263,      (flex_int16_t const   )263,      (flex_int16_t const   )0,      (flex_int16_t const   )98, 
        (flex_int16_t const   )91,      (flex_int16_t const   )140,      (flex_int16_t const   )36,      (flex_int16_t const   )263, 
        (flex_int16_t const   )42,      (flex_int16_t const   )71,      (flex_int16_t const   )65,      (flex_int16_t const   )72, 
        (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )80,      (flex_int16_t const   )143, 
        (flex_int16_t const   )79,      (flex_int16_t const   )0,      (flex_int16_t const   )80,      (flex_int16_t const   )263, 
        (flex_int16_t const   )63,      (flex_int16_t const   )48,      (flex_int16_t const   )52,      (flex_int16_t const   )55, 
        (flex_int16_t const   )51,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )263, 
        (flex_int16_t const   )263,      (flex_int16_t const   )40,      (flex_int16_t const   )0,      (flex_int16_t const   )37, 
        (flex_int16_t const   )42,      (flex_int16_t const   )51,      (flex_int16_t const   )40,      (flex_int16_t const   )44, 
        (flex_int16_t const   )48,      (flex_int16_t const   )45,      (flex_int16_t const   )31,      (flex_int16_t const   )38, 
        (flex_int16_t const   )41,      (flex_int16_t const   )31,      (flex_int16_t const   )44,      (flex_int16_t const   )44, 
        (flex_int16_t const   )27,      (flex_int16_t const   )25,      (flex_int16_t const   )17,      (flex_int16_t const   )263, 
        (flex_int16_t const   )22,      (flex_int16_t const   )0,      (flex_int16_t const   )5,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1,      (flex_int16_t const   )0,      (flex_int16_t const   )263,      (flex_int16_t const   )168, 
        (flex_int16_t const   )176,      (flex_int16_t const   )184,      (flex_int16_t const   )192,      (flex_int16_t const   )200, 
        (flex_int16_t const   )208,      (flex_int16_t const   )216,      (flex_int16_t const   )224,      (flex_int16_t const   )230, 
        (flex_int16_t const   )238,      (flex_int16_t const   )246,      (flex_int16_t const   )24,      (flex_int16_t const   )254, 
        (flex_int16_t const   )17};
#line 464 "lexppd.c"
static flex_int16_t const   yy_def[129]  = 
#line 464
  {      (flex_int16_t const   )0,      (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )117,      (flex_int16_t const   )117,      (flex_int16_t const   )118, 
        (flex_int16_t const   )118,      (flex_int16_t const   )114,      (flex_int16_t const   )119,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )119,      (flex_int16_t const   )114,      (flex_int16_t const   )120,      (flex_int16_t const   )114, 
        (flex_int16_t const   )121,      (flex_int16_t const   )122,      (flex_int16_t const   )114,      (flex_int16_t const   )123, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )124,      (flex_int16_t const   )119, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )125,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )114,      (flex_int16_t const   )120, 
        (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )120, 
        (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )120, 
        (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )122,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )126,      (flex_int16_t const   )114, 
        (flex_int16_t const   )124,      (flex_int16_t const   )125,      (flex_int16_t const   )127,      (flex_int16_t const   )114, 
        (flex_int16_t const   )127,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )120,      (flex_int16_t const   )120, 
        (flex_int16_t const   )114,      (flex_int16_t const   )128,      (flex_int16_t const   )124,      (flex_int16_t const   )114, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )114, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119, 
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )0,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114};
#line 482 "lexppd.c"
static flex_int16_t const   yy_nxt[300]  = 
#line 482
  {      (flex_int16_t const   )0,      (flex_int16_t const   )114,      (flex_int16_t const   )11,      (flex_int16_t const   )12, 
        (flex_int16_t const   )11,      (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )15, 
        (flex_int16_t const   )25,      (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )19, 
        (flex_int16_t const   )26,      (flex_int16_t const   )15,      (flex_int16_t const   )11,      (flex_int16_t const   )12, 
        (flex_int16_t const   )11,      (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )15, 
        (flex_int16_t const   )19,      (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )88, 
        (flex_int16_t const   )20,      (flex_int16_t const   )15,      (flex_int16_t const   )22,      (flex_int16_t const   )22, 
        (flex_int16_t const   )25,      (flex_int16_t const   )28,      (flex_int16_t const   )77,      (flex_int16_t const   )28, 
        (flex_int16_t const   )26,      (flex_int16_t const   )20,      (flex_int16_t const   )113,      (flex_int16_t const   )112, 
        (flex_int16_t const   )22,      (flex_int16_t const   )22,      (flex_int16_t const   )28,      (flex_int16_t const   )67, 
        (flex_int16_t const   )28,      (flex_int16_t const   )68,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )30,      (flex_int16_t const   )79,      (flex_int16_t const   )111,      (flex_int16_t const   )68, 
        (flex_int16_t const   )110,      (flex_int16_t const   )109,      (flex_int16_t const   )31,      (flex_int16_t const   )32, 
        (flex_int16_t const   )33,      (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )36, 
        (flex_int16_t const   )108,      (flex_int16_t const   )107,      (flex_int16_t const   )38,      (flex_int16_t const   )106, 
        (flex_int16_t const   )105,      (flex_int16_t const   )104,      (flex_int16_t const   )103,      (flex_int16_t const   )39, 
        (flex_int16_t const   )102,      (flex_int16_t const   )101,      (flex_int16_t const   )100,      (flex_int16_t const   )99, 
        (flex_int16_t const   )98,      (flex_int16_t const   )97,      (flex_int16_t const   )96,      (flex_int16_t const   )95, 
        (flex_int16_t const   )40,      (flex_int16_t const   )41,      (flex_int16_t const   )94,      (flex_int16_t const   )42, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )93,      (flex_int16_t const   )92, 
        (flex_int16_t const   )91,      (flex_int16_t const   )90,      (flex_int16_t const   )45,      (flex_int16_t const   )89, 
        (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )78,      (flex_int16_t const   )48, 
        (flex_int16_t const   )49,      (flex_int16_t const   )52,      (flex_int16_t const   )87,      (flex_int16_t const   )85, 
        (flex_int16_t const   )84,      (flex_int16_t const   )83,      (flex_int16_t const   )82,      (flex_int16_t const   )81, 
        (flex_int16_t const   )80,      (flex_int16_t const   )78,      (flex_int16_t const   )53,      (flex_int16_t const   )54, 
        (flex_int16_t const   )63,      (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )57, 
        (flex_int16_t const   )76,      (flex_int16_t const   )74,      (flex_int16_t const   )73,      (flex_int16_t const   )72, 
        (flex_int16_t const   )58,      (flex_int16_t const   )71,      (flex_int16_t const   )59,      (flex_int16_t const   )60, 
        (flex_int16_t const   )70,      (flex_int16_t const   )61,      (flex_int16_t const   )62,      (flex_int16_t const   )66, 
        (flex_int16_t const   )67,      (flex_int16_t const   )66,      (flex_int16_t const   )68,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )69,      (flex_int16_t const   )63,      (flex_int16_t const   )66, 
        (flex_int16_t const   )29,      (flex_int16_t const   )114,      (flex_int16_t const   )66,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )114,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )66,      (flex_int16_t const   )67, 
        (flex_int16_t const   )66,      (flex_int16_t const   )68,      (flex_int16_t const   )66,      (flex_int16_t const   )66, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )66,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )66,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )114,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )86, 
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )86,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18, 
        (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18, 
        (flex_int16_t const   )18,      (flex_int16_t const   )21,      (flex_int16_t const   )21,      (flex_int16_t const   )21, 
        (flex_int16_t const   )21,      (flex_int16_t const   )21,      (flex_int16_t const   )21,      (flex_int16_t const   )21, 
        (flex_int16_t const   )21,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )27,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )27,      (flex_int16_t const   )114, 
        (flex_int16_t const   )27,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )36,      (flex_int16_t const   )114,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )36,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37, 
        (flex_int16_t const   )37,      (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )114, 
        (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )51, 
        (flex_int16_t const   )51,      (flex_int16_t const   )114,      (flex_int16_t const   )51,      (flex_int16_t const   )51, 
        (flex_int16_t const   )51,      (flex_int16_t const   )51,      (flex_int16_t const   )51,      (flex_int16_t const   )64, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )64,      (flex_int16_t const   )64, 
        (flex_int16_t const   )64,      (flex_int16_t const   )64,      (flex_int16_t const   )64,      (flex_int16_t const   )65, 
        (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65, 
        (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )66,      (flex_int16_t const   )66,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )66,      (flex_int16_t const   )66,      (flex_int16_t const   )9, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114};
#line 519 "lexppd.c"
static flex_int16_t const   yy_chk[300]  = 
#line 519
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )7,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )3, 
        (flex_int16_t const   )7,      (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )2, 
        (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2, 
        (flex_int16_t const   )4,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )128, 
        (flex_int16_t const   )3,      (flex_int16_t const   )2,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )8,      (flex_int16_t const   )11,      (flex_int16_t const   )126,      (flex_int16_t const   )11, 
        (flex_int16_t const   )8,      (flex_int16_t const   )4,      (flex_int16_t const   )112,      (flex_int16_t const   )110, 
        (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )28,      (flex_int16_t const   )66, 
        (flex_int16_t const   )28,      (flex_int16_t const   )66,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )16,      (flex_int16_t const   )68,      (flex_int16_t const   )108,      (flex_int16_t const   )68, 
        (flex_int16_t const   )106,      (flex_int16_t const   )105,      (flex_int16_t const   )16,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )20, 
        (flex_int16_t const   )104,      (flex_int16_t const   )103,      (flex_int16_t const   )20,      (flex_int16_t const   )102, 
        (flex_int16_t const   )101,      (flex_int16_t const   )100,      (flex_int16_t const   )99,      (flex_int16_t const   )20, 
        (flex_int16_t const   )98,      (flex_int16_t const   )97,      (flex_int16_t const   )96,      (flex_int16_t const   )95, 
        (flex_int16_t const   )94,      (flex_int16_t const   )93,      (flex_int16_t const   )92,      (flex_int16_t const   )91, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )89,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )84,      (flex_int16_t const   )83, 
        (flex_int16_t const   )82,      (flex_int16_t const   )81,      (flex_int16_t const   )20,      (flex_int16_t const   )80, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )78,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )23,      (flex_int16_t const   )76,      (flex_int16_t const   )74, 
        (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )71,      (flex_int16_t const   )70, 
        (flex_int16_t const   )69,      (flex_int16_t const   )64,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )63,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )52,      (flex_int16_t const   )39,      (flex_int16_t const   )35,      (flex_int16_t const   )34, 
        (flex_int16_t const   )23,      (flex_int16_t const   )33,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )32,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )30, 
        (flex_int16_t const   )30,      (flex_int16_t const   )30,      (flex_int16_t const   )30,      (flex_int16_t const   )30, 
        (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )25,      (flex_int16_t const   )30, 
        (flex_int16_t const   )13,      (flex_int16_t const   )9,      (flex_int16_t const   )30,      (flex_int16_t const   )49, 
        (flex_int16_t const   )49,      (flex_int16_t const   )0,      (flex_int16_t const   )49,      (flex_int16_t const   )49, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )49, 
        (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )65,      (flex_int16_t const   )65, 
        (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )65,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )65,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )0,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )115, 
        (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )115, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )117,      (flex_int16_t const   )117,      (flex_int16_t const   )117, 
        (flex_int16_t const   )117,      (flex_int16_t const   )117,      (flex_int16_t const   )117,      (flex_int16_t const   )117, 
        (flex_int16_t const   )117,      (flex_int16_t const   )118,      (flex_int16_t const   )118,      (flex_int16_t const   )118, 
        (flex_int16_t const   )118,      (flex_int16_t const   )118,      (flex_int16_t const   )118,      (flex_int16_t const   )118, 
        (flex_int16_t const   )118,      (flex_int16_t const   )119,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )119,      (flex_int16_t const   )0, 
        (flex_int16_t const   )119,      (flex_int16_t const   )120,      (flex_int16_t const   )120,      (flex_int16_t const   )120, 
        (flex_int16_t const   )120,      (flex_int16_t const   )0,      (flex_int16_t const   )120,      (flex_int16_t const   )120, 
        (flex_int16_t const   )120,      (flex_int16_t const   )121,      (flex_int16_t const   )121,      (flex_int16_t const   )121, 
        (flex_int16_t const   )121,      (flex_int16_t const   )121,      (flex_int16_t const   )121,      (flex_int16_t const   )121, 
        (flex_int16_t const   )121,      (flex_int16_t const   )122,      (flex_int16_t const   )122,      (flex_int16_t const   )0, 
        (flex_int16_t const   )122,      (flex_int16_t const   )122,      (flex_int16_t const   )122,      (flex_int16_t const   )123, 
        (flex_int16_t const   )123,      (flex_int16_t const   )0,      (flex_int16_t const   )123,      (flex_int16_t const   )123, 
        (flex_int16_t const   )123,      (flex_int16_t const   )123,      (flex_int16_t const   )123,      (flex_int16_t const   )124, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )124,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )125, 
        (flex_int16_t const   )125,      (flex_int16_t const   )125,      (flex_int16_t const   )125,      (flex_int16_t const   )125, 
        (flex_int16_t const   )125,      (flex_int16_t const   )125,      (flex_int16_t const   )125,      (flex_int16_t const   )127, 
        (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127, 
        (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114, 
        (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114,      (flex_int16_t const   )114};
#line 557 "lexppd.c"
static flex_int32_t const   yy_rule_can_match_eol[44]  = 
#line 557
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0};
#line 563 "lexppd.c"
static yy_state_type yy_last_accepting_state  ;
#line 564 "lexppd.c"
static char *yy_last_accepting_cpos  ;
#line 566
int ppd_flex_debug ;
#line 567 "lexppd.c"
int ppd_flex_debug  =    0;
#line 787 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/lexppd.h"
char *ppdfilename  ;
#line 44 "/home/ysko/Works/test-src/a2ps-4.14/lib/lexppd.h"
char * const  *ppdpath  ;
#line 53 "lexppd.l"
static struct obstack string_stack  ;
#line 58 "lexppd.l"
static YY_BUFFER_STATE include_stack[10]  ;
#line 59 "lexppd.l"
static char *filename_stack[10]  ;
#line 60 "lexppd.l"
static int include_stack_ptr  =    0;
#line 660 "lexppd.c"
static int yy_init_globals(void) ;
#line 670
int ppdwrap(void) ;
#line 791 "lexppd.c"
int ppdlex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  int yyl ;
  char *string ;
  struct obstack *__o ;
  char *tmp___0 ;
  struct obstack *__o1 ;
  void *value ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___1 ;
  int value___0 ;
  char *cursor ;
  char *tmp___2 ;
  struct obstack *__o___1 ;
  char *tmp___3 ;
  int value___1 ;
  char *cursor___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct obstack *__o___2 ;
  char *tmp___7 ;
  struct obstack *__o___3 ;
  char *tmp___8 ;
  struct obstack *__o___4 ;
  char *tmp___9 ;
  struct obstack *__o___5 ;
  char *tmp___10 ;
  struct obstack *__o___6 ;
  char *tmp___11 ;
  struct obstack *__o___7 ;
  char *tmp___12 ;
  struct obstack *__o___8 ;
  char *tmp___13 ;
  struct obstack *__o___9 ;
  char *tmp___14 ;
  struct obstack *__o___10 ;
  char *tmp___15 ;
  struct obstack *__o___11 ;
  char *tmp___16 ;
  struct obstack *__o___12 ;
  char *tmp___17 ;
  struct obstack *__o___13 ;
  int __len ;
  unsigned char *string___0 ;
  struct obstack *__o___14 ;
  char *tmp___18 ;
  struct obstack *__o1___0 ;
  void *value___2 ;
  struct obstack *__o___15 ;
  void *__obj___0 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int value___3 ;
  char *cursor___1 ;
  char *tmp___21 ;
  struct obstack *__o___16 ;
  char *tmp___22 ;
  int value___4 ;
  char *cursor___2 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  struct obstack *__o___17 ;
  char *tmp___26 ;
  struct obstack *__o___18 ;
  char *tmp___27 ;
  struct obstack *__o___19 ;
  char *tmp___28 ;
  struct obstack *__o___20 ;
  char *tmp___29 ;
  struct obstack *__o___21 ;
  char *tmp___30 ;
  struct obstack *__o___22 ;
  char *tmp___31 ;
  struct obstack *__o___23 ;
  char *tmp___32 ;
  struct obstack *__o___24 ;
  char *tmp___33 ;
  struct obstack *__o___25 ;
  char *tmp___34 ;
  struct obstack *__o___26 ;
  char *tmp___35 ;
  struct obstack *__o___27 ;
  char *tmp___36 ;
  struct obstack *__o___28 ;
  int __len___0 ;
  char *tmp___37 ;
  int tmp___38 ;
  YY_BUFFER_STATE tmp___39 ;
  YY_BUFFER_STATE tmp___40 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___41 ;
  int tmp___42 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;

  {
#line 802
  if (! yy_init) {
#line 804
    yy_init = 1;
#line 810
    if (! yy_start) {
#line 811
      yy_start = 1;
    }
#line 813
    if (! ppdin) {
#line 814
      ppdin = stdin;
    }
#line 816
    if (! ppdout) {
#line 817
      ppdout = stdout;
    }
#line 819
    if (yy_buffer_stack) {
#line 819
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 819
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 819
    if (! tmp) {
      {
#line 820
      ppdensure_buffer_stack();
#line 821
      *(yy_buffer_stack + yy_buffer_stack_top) = ppd_create_buffer(ppdin, 16384);
      }
    }
    {
#line 825
    ppd_load_buffer_state();
    }
  }
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 830
    yy_cp = yy_c_buf_p;
#line 833
    *yy_cp = yy_hold_char;
#line 838
    yy_bp = yy_cp;
#line 840
    yy_current_state = yy_start;
    yy_match: 
    {
#line 842
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 844
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 845
      if (yy_accept[yy_current_state]) {
#line 847
        yy_last_accepting_state = yy_current_state;
#line 848
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 850
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 850
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 850
          goto while_break___1;
        }
#line 852
        yy_current_state = (int )yy_def[yy_current_state];
#line 853
        if (yy_current_state >= 115) {
#line 854
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 856
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 857
      yy_cp ++;
#line 842
      if (! ((int const   )yy_base[yy_current_state] != 263)) {
#line 842
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 862
    yy_act = (int )yy_accept[yy_current_state];
#line 863
    if (yy_act == 0) {
#line 865
      yy_cp = yy_last_accepting_cpos;
#line 866
      yy_current_state = yy_last_accepting_state;
#line 867
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 870
    ppdtext = yy_bp;
#line 870
    ppdleng = (int )((size_t )(yy_cp - yy_bp));
#line 870
    yy_hold_char = *yy_cp;
#line 870
    *yy_cp = (char )'\000';
#line 870
    yy_c_buf_p = yy_cp;
#line 872
    if (yy_act != 44) {
#line 872
      if (yy_rule_can_match_eol[yy_act]) {
#line 875
        yyl = 0;
        {
#line 875
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 875
          if (! (yyl < ppdleng)) {
#line 875
            goto while_break___2;
          }
#line 876
          if ((int )*(ppdtext + yyl) == 10) {
#line 878
            ppdlineno ++;
          }
#line 875
          yyl ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    do_action: 
    {
#line 886
    if (yy_act == 0) {
#line 886
      goto case_0;
    }
#line 893
    if (yy_act == 1) {
#line 893
      goto case_1;
    }
#line 80
    if (yy_act == 2) {
#line 80 "lexppd.l"
      goto case_2;
    }
#line 81
    if (yy_act == 3) {
#line 81
      goto case_3;
    }
#line 83
    if (yy_act == 4) {
#line 83
      goto case_4;
    }
#line 84
    if (yy_act == 5) {
#line 84
      goto case_5;
    }
#line 85
    if (yy_act == 6) {
#line 85
      goto case_6;
    }
#line 87
    if (yy_act == 7) {
#line 87
      goto case_7;
    }
#line 88
    if (yy_act == 8) {
#line 88
      goto case_8;
    }
#line 89
    if (yy_act == 9) {
#line 89
      goto case_9;
    }
#line 90
    if (yy_act == 10) {
#line 90
      goto case_10;
    }
#line 94
    if (yy_act == 11) {
#line 94
      goto case_11;
    }
#line 96
    if (yy_act == 12) {
#line 96
      goto case_12;
    }
#line 99
    if (yy_act == 13) {
#line 99
      goto case_13;
    }
#line 113
    if (yy_act == 14) {
#line 113
      goto case_14;
    }
#line 122
    if (yy_act == 15) {
#line 122
      goto case_15;
    }
#line 136
    if (yy_act == 16) {
#line 136
      goto case_16;
    }
#line 138
    if (yy_act == 17) {
#line 138
      goto case_17;
    }
#line 139
    if (yy_act == 18) {
#line 139
      goto case_18;
    }
#line 140
    if (yy_act == 19) {
#line 140
      goto case_19;
    }
#line 141
    if (yy_act == 20) {
#line 141
      goto case_20;
    }
#line 142
    if (yy_act == 21) {
#line 142
      goto case_21;
    }
#line 143
    if (yy_act == 22) {
#line 143
      goto case_22;
    }
#line 144
    if (yy_act == 23) {
#line 144
      goto case_23;
    }
#line 145
    if (yy_act == 24) {
#line 145
      goto case_24;
    }
#line 146
    if (yy_act == 25) {
#line 146
      goto case_25;
    }
#line 147
    if (yy_act == 26) {
#line 147
      goto case_26;
    }
#line 153
    if (yy_act == 27) {
#line 153
      goto case_27;
    }
#line 167
    if (yy_act == 28) {
#line 167
      goto case_28;
    }
#line 176
    if (yy_act == 29) {
#line 176
      goto case_29;
    }
#line 190
    if (yy_act == 30) {
#line 190
      goto case_30;
    }
#line 192
    if (yy_act == 31) {
#line 192
      goto case_31;
    }
#line 193
    if (yy_act == 32) {
#line 193
      goto case_32;
    }
#line 194
    if (yy_act == 33) {
#line 194
      goto case_33;
    }
#line 195
    if (yy_act == 34) {
#line 195
      goto case_34;
    }
#line 196
    if (yy_act == 35) {
#line 196
      goto case_35;
    }
#line 197
    if (yy_act == 36) {
#line 197
      goto case_36;
    }
#line 198
    if (yy_act == 37) {
#line 198
      goto case_37;
    }
#line 199
    if (yy_act == 38) {
#line 199
      goto case_38;
    }
#line 200
    if (yy_act == 39) {
#line 200
      goto case_39;
    }
#line 201
    if (yy_act == 40) {
#line 201
      goto case_40;
    }
#line 207
    if (yy_act == 41) {
#line 207
      goto case_41;
    }
#line 210
    if (yy_act == 42) {
#line 210
      goto case_42;
    }
#line 236
    if (yy_act == 48) {
#line 236
      goto case_48;
    }
#line 236
    if (yy_act == 47) {
#line 236
      goto case_48;
    }
#line 236
    if (yy_act == 46) {
#line 236
      goto case_48;
    }
#line 236
    if (yy_act == 45) {
#line 236
      goto case_48;
    }
#line 250
    if (yy_act == 43) {
#line 250
      goto case_43;
    }
#line 1231
    if (yy_act == 44) {
#line 1231 "lexppd.c"
      goto case_44;
    }
#line 1353
    goto switch_default;
    case_0: /* CIL Label */ 
#line 888
    *yy_cp = yy_hold_char;
#line 889
    yy_cp = yy_last_accepting_cpos;
#line 890
    yy_current_state = yy_last_accepting_state;
#line 891
    goto yy_find_action;
    case_1: /* CIL Label */ ;
#line 79 "lexppd.l"
    goto switch_break;
    case_2: /* CIL Label */ ;
#line 80
    goto switch_break;
    case_3: /* CIL Label */ 
#line 81
    yy_start = 3;
#line 82
    goto switch_break;
    case_4: /* CIL Label */ 
#line 82
    yy_start = 5;
#line 83
    goto switch_break;
    case_5: /* CIL Label */ 
#line 83
    yy_start = 7;
#line 84
    goto switch_break;
    case_6: /* CIL Label */ 
#line 85
    return (259);
#line 86
    goto switch_break;
    case_7: /* CIL Label */ 
#line 86
    return (260);
#line 87
    goto switch_break;
    case_8: /* CIL Label */ 
#line 87
    return (261);
#line 88
    goto switch_break;
    case_9: /* CIL Label */ 
#line 88
    return (262);
#line 89
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 90
    ppdlval.string = xstrdup((char const   *)ppdtext);
    }
#line 91
    return (264);
#line 93
    goto switch_break;
    case_11: /* CIL Label */ 
#line 94
    return ((int )*(ppdtext + 0));
#line 95
    goto switch_break;
    case_12: /* CIL Label */ 
#line 96
    return (258);
#line 97
    goto switch_break;
    case_13: /* CIL Label */ 
#line 102
    __o = & string_stack;
#line 102
    if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
      {
#line 102
      _obstack_newchunk(__o, 1);
      }
    }
#line 102
    tmp___0 = __o->next_free;
#line 102
    (__o->next_free) ++;
#line 102
    *tmp___0 = (char )'\000';
#line 103
    __o1 = & string_stack;
#line 103
    value = (void *)__o1->object_base;
#line 103
    if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 103
      __o1->maybe_empty_object = 1U;
    }
#line 103
    __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 103
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 103
      __o1->next_free = __o1->chunk_limit;
    }
#line 103
    __o1->object_base = __o1->next_free;
#line 103
    string = (char *)value;
#line 105
    __o___0 = & string_stack;
#line 105
    __obj = (void *)string;
#line 105
    if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 105
      if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 105
        tmp___1 = (char *)__obj;
#line 105
        __o___0->object_base = tmp___1;
#line 105
        __o___0->next_free = tmp___1;
      } else {
        {
#line 105
        obstack_free(__o___0, __obj);
        }
      }
    } else {
      {
#line 105
      obstack_free(__o___0, __obj);
      }
    }
    {
#line 107
    yy_start = 1;
#line 108
    ppdlval.string = xstrdup((char const   *)string);
    }
#line 110
    return (263);
#line 112
    goto switch_break;
    case_14: /* CIL Label */ 
#line 114
    value___0 = (int )*(ppdtext + 1) - 48;
#line 115
    cursor = ppdtext + 2;
    {
#line 117
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 117
      if (! *cursor) {
#line 117
        goto while_break___3;
      }
#line 118
      tmp___2 = cursor;
#line 118
      cursor ++;
#line 118
      value___0 = (8 * value___0 + (int )*tmp___2) - 48;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 119
    __o___1 = & string_stack;
#line 119
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 119
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 119
    tmp___3 = __o___1->next_free;
#line 119
    (__o___1->next_free) ++;
#line 119
    *tmp___3 = (char )value___0;
#line 121
    goto switch_break;
    case_15: /* CIL Label */ 
#line 123
    value___1 = 0;
#line 124
    cursor___0 = ppdtext + 2;
    {
#line 126
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 126
      if (! *cursor___0) {
#line 126
        goto while_break___4;
      }
#line 127
      if ((int )*cursor___0 >= 97) {
#line 127
        if ((int )*cursor___0 <= 102) {
#line 128
          tmp___4 = cursor___0;
#line 128
          cursor___0 ++;
#line 128
          value___1 = ((16 * value___1 + (int )*tmp___4) - 97) + 10;
        } else {
#line 127
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 129
      if ((int )*cursor___0 >= 65) {
#line 129
        if ((int )*cursor___0 <= 70) {
#line 130
          tmp___5 = cursor___0;
#line 130
          cursor___0 ++;
#line 130
          value___1 = ((16 * value___1 + (int )*tmp___5) - 65) + 10;
        } else {
#line 132
          tmp___6 = cursor___0;
#line 132
          cursor___0 ++;
#line 132
          value___1 = (16 * value___1 + (int )*tmp___6) - 48;
        }
      } else {
#line 132
        tmp___6 = cursor___0;
#line 132
        cursor___0 ++;
#line 132
        value___1 = (16 * value___1 + (int )*tmp___6) - 48;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 133
    __o___2 = & string_stack;
#line 133
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 133
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 133
    tmp___7 = __o___2->next_free;
#line 133
    (__o___2->next_free) ++;
#line 133
    *tmp___7 = (char )value___1;
#line 135
    goto switch_break;
    case_16: /* CIL Label */ 
#line 136
    __o___3 = & string_stack;
#line 136
    if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
      {
#line 136
      _obstack_newchunk(__o___3, 1);
      }
    }
#line 136
    tmp___8 = __o___3->next_free;
#line 136
    (__o___3->next_free) ++;
#line 136
    *tmp___8 = (char )'\a';
#line 137
    goto switch_break;
    case_17: /* CIL Label */ 
#line 137
    __o___4 = & string_stack;
#line 137
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 137
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 137
    tmp___9 = __o___4->next_free;
#line 137
    (__o___4->next_free) ++;
#line 137
    *tmp___9 = (char )'\b';
#line 138
    goto switch_break;
    case_18: /* CIL Label */ 
#line 138
    __o___5 = & string_stack;
#line 138
    if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
      {
#line 138
      _obstack_newchunk(__o___5, 1);
      }
    }
#line 138
    tmp___10 = __o___5->next_free;
#line 138
    (__o___5->next_free) ++;
#line 138
    *tmp___10 = (char)127;
#line 139
    goto switch_break;
    case_19: /* CIL Label */ 
#line 139
    __o___6 = & string_stack;
#line 139
    if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
      {
#line 139
      _obstack_newchunk(__o___6, 1);
      }
    }
#line 139
    tmp___11 = __o___6->next_free;
#line 139
    (__o___6->next_free) ++;
#line 139
    *tmp___11 = (char)27;
#line 140
    goto switch_break;
    case_20: /* CIL Label */ 
#line 140
    __o___7 = & string_stack;
#line 140
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 140
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 140
    tmp___12 = __o___7->next_free;
#line 140
    (__o___7->next_free) ++;
#line 140
    *tmp___12 = (char )'\f';
#line 141
    goto switch_break;
    case_21: /* CIL Label */ 
#line 141
    __o___8 = & string_stack;
#line 141
    if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
      {
#line 141
      _obstack_newchunk(__o___8, 1);
      }
    }
#line 141
    tmp___13 = __o___8->next_free;
#line 141
    (__o___8->next_free) ++;
#line 141
    *tmp___13 = (char )'\n';
#line 142
    goto switch_break;
    case_22: /* CIL Label */ 
#line 142
    __o___9 = & string_stack;
#line 142
    if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
      {
#line 142
      _obstack_newchunk(__o___9, 1);
      }
    }
#line 142
    tmp___14 = __o___9->next_free;
#line 142
    (__o___9->next_free) ++;
#line 142
    *tmp___14 = (char )'\r';
#line 143
    goto switch_break;
    case_23: /* CIL Label */ 
#line 143
    __o___10 = & string_stack;
#line 143
    if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
      {
#line 143
      _obstack_newchunk(__o___10, 1);
      }
    }
#line 143
    tmp___15 = __o___10->next_free;
#line 143
    (__o___10->next_free) ++;
#line 143
    *tmp___15 = (char )'\t';
#line 144
    goto switch_break;
    case_24: /* CIL Label */ 
#line 144
    __o___11 = & string_stack;
#line 144
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 144
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 144
    tmp___16 = __o___11->next_free;
#line 144
    (__o___11->next_free) ++;
#line 144
    *tmp___16 = (char )'\v';
#line 145
    goto switch_break;
    case_25: /* CIL Label */ 
#line 145
    __o___12 = & string_stack;
#line 145
    if ((unsigned long )(__o___12->next_free + 1) > (unsigned long )__o___12->chunk_limit) {
      {
#line 145
      _obstack_newchunk(__o___12, 1);
      }
    }
#line 145
    tmp___17 = __o___12->next_free;
#line 145
    (__o___12->next_free) ++;
#line 145
    *tmp___17 = *(ppdtext + 1);
#line 146
    goto switch_break;
    case_26: /* CIL Label */ 
#line 148
    __o___13 = & string_stack;
#line 148
    __len = ppdleng;
#line 148
    if ((unsigned long )(__o___13->next_free + __len) > (unsigned long )__o___13->chunk_limit) {
      {
#line 148
      _obstack_newchunk(__o___13, __len);
      }
    }
    {
#line 148
    memcpy((void */* __restrict  */)__o___13->next_free, (void const   */* __restrict  */)ppdtext,
           (size_t )__len);
#line 148
    __o___13->next_free += __len;
    }
#line 150
    goto switch_break;
    case_27: /* CIL Label */ 
#line 156
    __o___14 = & string_stack;
#line 156
    if ((unsigned long )(__o___14->next_free + 1) > (unsigned long )__o___14->chunk_limit) {
      {
#line 156
      _obstack_newchunk(__o___14, 1);
      }
    }
#line 156
    tmp___18 = __o___14->next_free;
#line 156
    (__o___14->next_free) ++;
#line 156
    *tmp___18 = (char )'\000';
#line 157
    __o1___0 = & string_stack;
#line 157
    value___2 = (void *)__o1___0->object_base;
#line 157
    if ((unsigned long )__o1___0->next_free == (unsigned long )value___2) {
#line 157
      __o1___0->maybe_empty_object = 1U;
    }
#line 157
    __o1___0->next_free = (char *)0 + (((__o1___0->next_free - (char *)0) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 157
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 157
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 157
    __o1___0->object_base = __o1___0->next_free;
#line 157
    string___0 = (unsigned char *)value___2;
#line 159
    __o___15 = & string_stack;
#line 159
    __obj___0 = (void *)string___0;
#line 159
    if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___15->chunk)) {
#line 159
      if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___15->chunk_limit)) {
#line 159
        tmp___19 = (char *)__obj___0;
#line 159
        __o___15->object_base = tmp___19;
#line 159
        __o___15->next_free = tmp___19;
      } else {
        {
#line 159
        obstack_free(__o___15, __obj___0);
        }
      }
    } else {
      {
#line 159
      obstack_free(__o___15, __obj___0);
      }
    }
    {
#line 161
    yy_start = 1;
#line 162
    tmp___20 = xstrdup((char const   *)string___0);
#line 162
    ppdlval.ustring = (unsigned char *)tmp___20;
    }
#line 164
    return (265);
#line 166
    goto switch_break;
    case_28: /* CIL Label */ 
#line 168
    value___3 = (int )*(ppdtext + 1) - 48;
#line 169
    cursor___1 = ppdtext + 2;
    {
#line 171
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 171
      if (! *cursor___1) {
#line 171
        goto while_break___5;
      }
#line 172
      tmp___21 = cursor___1;
#line 172
      cursor___1 ++;
#line 172
      value___3 = (8 * value___3 + (int )*tmp___21) - 48;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 173
    __o___16 = & string_stack;
#line 173
    if ((unsigned long )(__o___16->next_free + 1) > (unsigned long )__o___16->chunk_limit) {
      {
#line 173
      _obstack_newchunk(__o___16, 1);
      }
    }
#line 173
    tmp___22 = __o___16->next_free;
#line 173
    (__o___16->next_free) ++;
#line 173
    *tmp___22 = (char )value___3;
#line 175
    goto switch_break;
    case_29: /* CIL Label */ 
#line 177
    value___4 = 0;
#line 178
    cursor___2 = ppdtext + 2;
    {
#line 180
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 180
      if (! *cursor___2) {
#line 180
        goto while_break___6;
      }
#line 181
      if ((int )*cursor___2 >= 97) {
#line 181
        if ((int )*cursor___2 <= 102) {
#line 182
          tmp___23 = cursor___2;
#line 182
          cursor___2 ++;
#line 182
          value___4 = ((16 * value___4 + (int )*tmp___23) - 97) + 10;
        } else {
#line 181
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 183
      if ((int )*cursor___2 >= 65) {
#line 183
        if ((int )*cursor___2 <= 70) {
#line 184
          tmp___24 = cursor___2;
#line 184
          cursor___2 ++;
#line 184
          value___4 = ((16 * value___4 + (int )*tmp___24) - 65) + 10;
        } else {
#line 186
          tmp___25 = cursor___2;
#line 186
          cursor___2 ++;
#line 186
          value___4 = (16 * value___4 + (int )*tmp___25) - 48;
        }
      } else {
#line 186
        tmp___25 = cursor___2;
#line 186
        cursor___2 ++;
#line 186
        value___4 = (16 * value___4 + (int )*tmp___25) - 48;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 187
    __o___17 = & string_stack;
#line 187
    if ((unsigned long )(__o___17->next_free + 1) > (unsigned long )__o___17->chunk_limit) {
      {
#line 187
      _obstack_newchunk(__o___17, 1);
      }
    }
#line 187
    tmp___26 = __o___17->next_free;
#line 187
    (__o___17->next_free) ++;
#line 187
    *tmp___26 = (char )value___4;
#line 189
    goto switch_break;
    case_30: /* CIL Label */ 
#line 190
    __o___18 = & string_stack;
#line 190
    if ((unsigned long )(__o___18->next_free + 1) > (unsigned long )__o___18->chunk_limit) {
      {
#line 190
      _obstack_newchunk(__o___18, 1);
      }
    }
#line 190
    tmp___27 = __o___18->next_free;
#line 190
    (__o___18->next_free) ++;
#line 190
    *tmp___27 = (char )'\a';
#line 191
    goto switch_break;
    case_31: /* CIL Label */ 
#line 191
    __o___19 = & string_stack;
#line 191
    if ((unsigned long )(__o___19->next_free + 1) > (unsigned long )__o___19->chunk_limit) {
      {
#line 191
      _obstack_newchunk(__o___19, 1);
      }
    }
#line 191
    tmp___28 = __o___19->next_free;
#line 191
    (__o___19->next_free) ++;
#line 191
    *tmp___28 = (char )'\b';
#line 192
    goto switch_break;
    case_32: /* CIL Label */ 
#line 192
    __o___20 = & string_stack;
#line 192
    if ((unsigned long )(__o___20->next_free + 1) > (unsigned long )__o___20->chunk_limit) {
      {
#line 192
      _obstack_newchunk(__o___20, 1);
      }
    }
#line 192
    tmp___29 = __o___20->next_free;
#line 192
    (__o___20->next_free) ++;
#line 192
    *tmp___29 = (char)127;
#line 193
    goto switch_break;
    case_33: /* CIL Label */ 
#line 193
    __o___21 = & string_stack;
#line 193
    if ((unsigned long )(__o___21->next_free + 1) > (unsigned long )__o___21->chunk_limit) {
      {
#line 193
      _obstack_newchunk(__o___21, 1);
      }
    }
#line 193
    tmp___30 = __o___21->next_free;
#line 193
    (__o___21->next_free) ++;
#line 193
    *tmp___30 = (char)27;
#line 194
    goto switch_break;
    case_34: /* CIL Label */ 
#line 194
    __o___22 = & string_stack;
#line 194
    if ((unsigned long )(__o___22->next_free + 1) > (unsigned long )__o___22->chunk_limit) {
      {
#line 194
      _obstack_newchunk(__o___22, 1);
      }
    }
#line 194
    tmp___31 = __o___22->next_free;
#line 194
    (__o___22->next_free) ++;
#line 194
    *tmp___31 = (char )'\f';
#line 195
    goto switch_break;
    case_35: /* CIL Label */ 
#line 195
    __o___23 = & string_stack;
#line 195
    if ((unsigned long )(__o___23->next_free + 1) > (unsigned long )__o___23->chunk_limit) {
      {
#line 195
      _obstack_newchunk(__o___23, 1);
      }
    }
#line 195
    tmp___32 = __o___23->next_free;
#line 195
    (__o___23->next_free) ++;
#line 195
    *tmp___32 = (char )'\n';
#line 196
    goto switch_break;
    case_36: /* CIL Label */ 
#line 196
    __o___24 = & string_stack;
#line 196
    if ((unsigned long )(__o___24->next_free + 1) > (unsigned long )__o___24->chunk_limit) {
      {
#line 196
      _obstack_newchunk(__o___24, 1);
      }
    }
#line 196
    tmp___33 = __o___24->next_free;
#line 196
    (__o___24->next_free) ++;
#line 196
    *tmp___33 = (char )'\r';
#line 197
    goto switch_break;
    case_37: /* CIL Label */ 
#line 197
    __o___25 = & string_stack;
#line 197
    if ((unsigned long )(__o___25->next_free + 1) > (unsigned long )__o___25->chunk_limit) {
      {
#line 197
      _obstack_newchunk(__o___25, 1);
      }
    }
#line 197
    tmp___34 = __o___25->next_free;
#line 197
    (__o___25->next_free) ++;
#line 197
    *tmp___34 = (char )'\t';
#line 198
    goto switch_break;
    case_38: /* CIL Label */ 
#line 198
    __o___26 = & string_stack;
#line 198
    if ((unsigned long )(__o___26->next_free + 1) > (unsigned long )__o___26->chunk_limit) {
      {
#line 198
      _obstack_newchunk(__o___26, 1);
      }
    }
#line 198
    tmp___35 = __o___26->next_free;
#line 198
    (__o___26->next_free) ++;
#line 198
    *tmp___35 = (char )'\v';
#line 199
    goto switch_break;
    case_39: /* CIL Label */ 
#line 199
    __o___27 = & string_stack;
#line 199
    if ((unsigned long )(__o___27->next_free + 1) > (unsigned long )__o___27->chunk_limit) {
      {
#line 199
      _obstack_newchunk(__o___27, 1);
      }
    }
#line 199
    tmp___36 = __o___27->next_free;
#line 199
    (__o___27->next_free) ++;
#line 199
    *tmp___36 = *(ppdtext + 1);
#line 200
    goto switch_break;
    case_40: /* CIL Label */ 
#line 202
    __o___28 = & string_stack;
#line 202
    __len___0 = ppdleng;
#line 202
    if ((unsigned long )(__o___28->next_free + __len___0) > (unsigned long )__o___28->chunk_limit) {
      {
#line 202
      _obstack_newchunk(__o___28, __len___0);
      }
    }
    {
#line 202
    memcpy((void */* __restrict  */)__o___28->next_free, (void const   */* __restrict  */)ppdtext,
           (size_t )__len___0);
#line 202
    __o___28->next_free += __len___0;
    }
#line 204
    goto switch_break;
    case_41: /* CIL Label */ ;
#line 209
    goto switch_break;
    case_42: /* CIL Label */ 
#line 210
    if (include_stack_ptr >= 10) {
      {
#line 211
      tmp___37 = gettext("too many includes");
#line 211
      error(1, 0, (char const   *)tmp___37);
      }
    }
#line 213
    if (yy_buffer_stack) {
#line 213
      include_stack[include_stack_ptr] = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 213
      include_stack[include_stack_ptr] = (YY_BUFFER_STATE )((void *)0);
    }
#line 214
    tmp___38 = include_stack_ptr;
#line 214
    include_stack_ptr ++;
#line 214
    filename_stack[tmp___38] = ppdfilename;
#line 217
    ppdtext ++;
#line 218
    *(ppdtext + (ppdleng - 2)) = (char)0;
    {
#line 219
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 219
      if ((unsigned int )(1 << 6) & msg_verbosity) {
        {
#line 219
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: includes %s\n",
                ppdfilename, ppdlineno, ppdtext);
        }
      }
#line 219
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 223
    ppdfilename = xpw_find_included_file(ppdpath, (char const   *)ppdfilename, (char const   *)ppdtext,
                                         (char const   *)((void *)0));
#line 225
    ppdin = xrfopen((char const   *)ppdfilename);
#line 227
    tmp___39 = ppd_create_buffer(ppdin, 16384);
#line 227
    ppd_switch_to_buffer(tmp___39);
#line 229
    yy_start = 1;
    }
#line 231
    goto switch_break;
    case_48: /* CIL Label */ 
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45: /* CIL Label */ 
    {
#line 234
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 234
      if ((unsigned int )(1 << 6) & msg_verbosity) {
        {
#line 234
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"End of PPD file `%s\'.\n",
                ppdfilename);
        }
      }
#line 234
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 235
    include_stack_ptr --;
#line 235
    if (include_stack_ptr < 0) {
#line 237
      return (0);
    } else {
      {
#line 241
      fclose(ppdin);
      }
#line 242
      if (yy_buffer_stack) {
#line 242
        tmp___40 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 242
        tmp___40 = (YY_BUFFER_STATE )((void *)0);
      }
      {
#line 242
      ppd_delete_buffer(tmp___40);
      }
      {
#line 243
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 243
        if (ppdfilename) {
          {
#line 243
          free((void *)ppdfilename);
          }
        }
#line 243
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 244
      ppdfilename = filename_stack[include_stack_ptr];
#line 245
      ppd_switch_to_buffer(include_stack[include_stack_ptr]);
      }
      {
#line 246
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 246
        if ((unsigned int )(1 << 6) & msg_verbosity) {
          {
#line 246
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Back to file `%s\'.\n",
                  ppdfilename);
          }
        }
#line 246
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 249
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 250
    fwrite((void const   */* __restrict  */)ppdtext, (size_t )ppdleng, (size_t )1,
           (FILE */* __restrict  */)ppdout);
    }
#line 251
    goto switch_break;
    case_44: /* CIL Label */ 
#line 1234 "lexppd.c"
    yy_amount_of_matched_text = (int )(yy_cp - ppdtext) - 1;
#line 1237
    *yy_cp = yy_hold_char;
#line 1240
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1251
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1252
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = ppdin;
#line 1253
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1263
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1267
      yy_c_buf_p = ppdtext + yy_amount_of_matched_text;
#line 1269
      yy_current_state = yy_get_previous_state();
#line 1280
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1282
      yy_bp = ppdtext + 0;
      }
#line 1284
      if (yy_next_state) {
#line 1287
        yy_c_buf_p ++;
#line 1287
        yy_cp = yy_c_buf_p;
#line 1288
        yy_current_state = yy_next_state;
#line 1289
        goto yy_match;
      } else {
#line 1294
        yy_cp = yy_c_buf_p;
#line 1295
        goto yy_find_action;
      }
    } else {
      {
#line 1299
      tmp___41 = yy_get_next_buffer();
      }
      {
#line 1301
      if (tmp___41 == 1) {
#line 1301
        goto case_1___0;
      }
#line 1330
      if (tmp___41 == 0) {
#line 1330
        goto case_0___0;
      }
#line 1340
      if (tmp___41 == 2) {
#line 1340
        goto case_2___0;
      }
#line 1299
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1303
      yy_did_buffer_switch_on_eof = 0;
#line 1305
      tmp___42 = ppdwrap();
      }
#line 1305
      if (tmp___42) {
#line 1316
        yy_c_buf_p = ppdtext + 0;
#line 1318
        yy_act = (44 + (yy_start - 1) / 2) + 1;
#line 1319
        goto do_action;
      } else
#line 1324
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1325
        ppdrestart(ppdin);
        }
      }
#line 1327
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1331
      yy_c_buf_p = ppdtext + yy_amount_of_matched_text;
#line 1334
      yy_current_state = yy_get_previous_state();
#line 1336
      yy_cp = yy_c_buf_p;
#line 1337
      yy_bp = ppdtext + 0;
      }
#line 1338
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1341
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1344
      yy_current_state = yy_get_previous_state();
#line 1346
      yy_cp = yy_c_buf_p;
#line 1347
      yy_bp = ppdtext + 0;
      }
#line 1348
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1350
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1354
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1367 "lexppd.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 1369
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1370
  source = ppdtext;
#line 1374
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1375
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1378
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1380
    if (yy_c_buf_p - ppdtext == 1L) {
#line 1385
      return (1);
    } else {
#line 1393
      return (2);
    }
  }
#line 1400
  number_to_move = (int )(yy_c_buf_p - ppdtext) - 1;
#line 1402
  i = 0;
  {
#line 1402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1402
    if (! (i < number_to_move)) {
#line 1402
      goto while_break;
    }
#line 1403
    tmp = dest;
#line 1403
    dest ++;
#line 1403
    tmp___0 = source;
#line 1403
    source ++;
#line 1403
    *tmp = *tmp___0;
#line 1402
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1405
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1409
    yy_n_chars = 0;
#line 1409
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1413
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1416
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1416
      if (! (num_to_read <= 0)) {
#line 1416
        goto while_break___0;
      }
#line 1420
      if (yy_buffer_stack) {
#line 1420
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1420
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1420
      b = tmp___1;
#line 1422
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1425
      if (b->yy_is_our_buffer) {
#line 1427
        new_size = (int )(b->yy_buf_size * 2U);
#line 1429
        if (new_size <= 0) {
#line 1430
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1432
          b->yy_buf_size *= 2U;
        }
        {
#line 1434
        tmp___2 = ppdrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1434
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1440
        b->yy_ch_buf = (char *)0;
      }
#line 1442
      if (! b->yy_ch_buf) {
        {
#line 1443
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1446
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1448
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1453
    if (num_to_read > 8192) {
#line 1454
      num_to_read = 8192;
    }
#line 1457
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1457
      c = '*';
#line 1457
      n = (size_t )0;
      {
#line 1457
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1457
        if (n < (size_t )num_to_read) {
          {
#line 1457
          c = _IO_getc(ppdin);
          }
#line 1457
          if (c != -1) {
#line 1457
            if (! (c != 10)) {
#line 1457
              goto while_break___1;
            }
          } else {
#line 1457
            goto while_break___1;
          }
        } else {
#line 1457
          goto while_break___1;
        }
#line 1457
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1457
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1457
      if (c == 10) {
#line 1457
        tmp___3 = n;
#line 1457
        n ++;
#line 1457
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1457
      if (c == -1) {
        {
#line 1457
        tmp___4 = ferror(ppdin);
        }
#line 1457
        if (tmp___4) {
          {
#line 1457
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1457
      yy_n_chars = (int )n;
    } else {
      {
#line 1457
      tmp___5 = __errno_location();
#line 1457
      *tmp___5 = 0;
      }
      {
#line 1457
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1457
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)ppdin);
#line 1457
        yy_n_chars = (int )tmp___8;
        }
#line 1457
        if (yy_n_chars == 0) {
          {
#line 1457
          tmp___9 = ferror(ppdin);
          }
#line 1457
          if (! tmp___9) {
#line 1457
            goto while_break___2;
          }
        } else {
#line 1457
          goto while_break___2;
        }
        {
#line 1457
        tmp___6 = __errno_location();
        }
#line 1457
        if (*tmp___6 != 4) {
          {
#line 1457
          yy_fatal_error("input in flex scanner failed");
          }
#line 1457
          goto while_break___2;
        }
        {
#line 1457
        tmp___7 = __errno_location();
#line 1457
        *tmp___7 = 0;
#line 1457
        clearerr(ppdin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1460
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1463
  if (yy_n_chars == 0) {
#line 1465
    if (number_to_move == 0) {
      {
#line 1467
      ret_val = 1;
#line 1468
      ppdrestart(ppdin);
      }
    } else {
#line 1473
      ret_val = 2;
#line 1474
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1480
    ret_val = 0;
  }
#line 1482
  yy_n_chars += number_to_move;
#line 1483
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1484
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1486
  ppdtext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1488
  return (ret_val);
}
}
#line 1493 "lexppd.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1498
  yy_current_state = yy_start;
#line 1500
  yy_cp = ppdtext + 0;
  {
#line 1500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1500
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1500
      goto while_break;
    }
#line 1502
    if (*yy_cp) {
#line 1502
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1502
      tmp = (flex_int32_t const   )1;
    }
#line 1502
    yy_c = (YY_CHAR )tmp;
#line 1503
    if (yy_accept[yy_current_state]) {
#line 1505
      yy_last_accepting_state = yy_current_state;
#line 1506
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1508
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1508
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1508
        goto while_break___0;
      }
#line 1510
      yy_current_state = (int )yy_def[yy_current_state];
#line 1511
      if (yy_current_state >= 115) {
#line 1512
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1514
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1500
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1517
  return (yy_current_state);
}
}
#line 1525 "lexppd.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1528
  yy_cp = yy_c_buf_p;
#line 1530
  yy_c = (YY_CHAR )1;
#line 1531
  if (yy_accept[yy_current_state]) {
#line 1533
    yy_last_accepting_state = yy_current_state;
#line 1534
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1536
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1536
      goto while_break;
    }
#line 1538
    yy_current_state = (int )yy_def[yy_current_state];
#line 1539
    if (yy_current_state >= 115) {
#line 1540
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1542
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1543
  yy_is_jam = yy_current_state == 114;
#line 1545
  if (yy_is_jam) {
#line 1545
    tmp = 0;
  } else {
#line 1545
    tmp = yy_current_state;
  }
#line 1545
  return (tmp);
}
}
#line 1673 "lexppd.c"
void ppdrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1676
  if (yy_buffer_stack) {
#line 1676
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1676
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1676
  if (! tmp) {
    {
#line 1677
    ppdensure_buffer_stack();
#line 1678
    *(yy_buffer_stack + yy_buffer_stack_top) = ppd_create_buffer(ppdin, 16384);
    }
  }
#line 1682
  if (yy_buffer_stack) {
#line 1682
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1682
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1682
  ppd_init_buffer(tmp___0, input_file);
#line 1683
  ppd_load_buffer_state();
  }
#line 1684
  return;
}
}
#line 1690 "lexppd.c"
void ppd_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1698
  ppdensure_buffer_stack();
  }
#line 1699
  if (yy_buffer_stack) {
#line 1699
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1699
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1699
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1700
    return;
  }
#line 1702
  if (yy_buffer_stack) {
#line 1702
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1702
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1702
  if (tmp___0) {
#line 1705
    *yy_c_buf_p = yy_hold_char;
#line 1706
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1707
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1710
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1711
  ppd_load_buffer_state();
#line 1718
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1719
  return;
}
}
#line 1721 "lexppd.c"
static void ppd_load_buffer_state(void) 
{ 


  {
#line 1723
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1724
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1724
  ppdtext = yy_c_buf_p;
#line 1725
  ppdin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1726
  yy_hold_char = *yy_c_buf_p;
#line 1727
  return;
}
}
#line 1735 "lexppd.c"
YY_BUFFER_STATE ppd_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1739
  tmp = ppdalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1739
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1740
  if (! b) {
    {
#line 1741
    yy_fatal_error("out of dynamic memory in ppd_create_buffer()");
    }
  }
  {
#line 1743
  b->yy_buf_size = (yy_size_t )size;
#line 1748
  tmp___0 = ppdalloc(b->yy_buf_size + 2U);
#line 1748
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1749
  if (! b->yy_ch_buf) {
    {
#line 1750
    yy_fatal_error("out of dynamic memory in ppd_create_buffer()");
    }
  }
  {
#line 1752
  b->yy_is_our_buffer = 1;
#line 1754
  ppd_init_buffer(b, file);
  }
#line 1756
  return (b);
}
}
#line 1763 "lexppd.c"
void ppd_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1766
  if (! b) {
#line 1767
    return;
  }
#line 1769
  if (yy_buffer_stack) {
#line 1769
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1769
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1769
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1770
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1772
  if (b->yy_is_our_buffer) {
    {
#line 1773
    ppdfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1775
  ppdfree((void *)b);
  }
#line 1776
  return;
}
}
#line 1786 "lexppd.c"
static void ppd_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1789
  tmp = __errno_location();
#line 1789
  oerrno = *tmp;
#line 1791
  ppd_flush_buffer(b);
#line 1793
  b->yy_input_file = file;
#line 1794
  b->yy_fill_buffer = 1;
  }
#line 1800
  if (yy_buffer_stack) {
#line 1800
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1800
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1800
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1801
    b->yy_bs_lineno = 1;
#line 1802
    b->yy_bs_column = 0;
  }
#line 1805
  if (file) {
    {
#line 1805
    tmp___1 = fileno(file);
#line 1805
    tmp___2 = isatty(tmp___1);
#line 1805
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1805
    b->yy_is_interactive = 0;
  }
  {
#line 1807
  tmp___3 = __errno_location();
#line 1807
  *tmp___3 = oerrno;
  }
#line 1808
  return;
}
}
#line 1814 "lexppd.c"
void ppd_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1816
  if (! b) {
#line 1817
    return;
  }
#line 1819
  b->yy_n_chars = 0;
#line 1825
  *(b->yy_ch_buf + 0) = (char)0;
#line 1826
  *(b->yy_ch_buf + 1) = (char)0;
#line 1828
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1830
  b->yy_at_bol = 1;
#line 1831
  b->yy_buffer_status = 0;
#line 1833
  if (yy_buffer_stack) {
#line 1833
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1833
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1833
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1834
    ppd_load_buffer_state();
    }
  }
#line 1835
  return;
}
}
#line 1843 "lexppd.c"
void ppdpush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1845
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1846
    return;
  }
  {
#line 1848
  ppdensure_buffer_stack();
  }
#line 1851
  if (yy_buffer_stack) {
#line 1851
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1851
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1851
  if (tmp) {
#line 1854
    *yy_c_buf_p = yy_hold_char;
#line 1855
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1856
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1860
  if (yy_buffer_stack) {
#line 1860
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1860
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1860
  if (tmp___0) {
#line 1861
    yy_buffer_stack_top ++;
  }
  {
#line 1862
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1865
  ppd_load_buffer_state();
#line 1866
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1867
  return;
}
}
#line 1873 "lexppd.c"
void ppdpop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1875
  if (yy_buffer_stack) {
#line 1875
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1875
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1875
  if (! tmp) {
#line 1876
    return;
  }
#line 1878
  if (yy_buffer_stack) {
#line 1878
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1878
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1878
  ppd_delete_buffer(tmp___0);
#line 1879
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1880
  if (yy_buffer_stack_top > 0U) {
#line 1881
    yy_buffer_stack_top --;
  }
#line 1883
  if (yy_buffer_stack) {
#line 1883
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1883
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1883
  if (tmp___1) {
    {
#line 1884
    ppd_load_buffer_state();
#line 1885
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1887
  return;
}
}
#line 1892 "lexppd.c"
static void ppdensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1896
  if (! yy_buffer_stack) {
    {
#line 1902
    num_to_alloc = 1;
#line 1903
    tmp = ppdalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1903
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
#line 1907
    memset((void *)yy_buffer_stack, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1909
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1910
    yy_buffer_stack_top = (size_t )0;
    }
#line 1911
    return;
  }
#line 1914
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1U) {
    {
#line 1917
    grow_size = 8;
#line 1919
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1920
    tmp___0 = ppdrealloc((void *)yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1920
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
#line 1926
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 1927
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1929
  return;
}
}
#line 1937 "lexppd.c"
YY_BUFFER_STATE ppd_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 1941
  if (size < 2U) {
#line 1945
    return ((YY_BUFFER_STATE )0);
  } else
#line 1941
  if ((int )*(base + (size - 2U)) != 0) {
#line 1945
    return ((YY_BUFFER_STATE )0);
  } else
#line 1941
  if ((int )*(base + (size - 1U)) != 0) {
#line 1945
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1947
  tmp = ppdalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1947
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1948
  if (! b) {
    {
#line 1949
    yy_fatal_error("out of dynamic memory in ppd_scan_buffer()");
    }
  }
  {
#line 1951
  b->yy_buf_size = size - 2U;
#line 1952
  tmp___0 = base;
#line 1952
  b->yy_ch_buf = tmp___0;
#line 1952
  b->yy_buf_pos = tmp___0;
#line 1953
  b->yy_is_our_buffer = 0;
#line 1954
  b->yy_input_file = (FILE *)0;
#line 1955
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1956
  b->yy_is_interactive = 0;
#line 1957
  b->yy_at_bol = 1;
#line 1958
  b->yy_fill_buffer = 0;
#line 1959
  b->yy_buffer_status = 0;
#line 1961
  ppd_switch_to_buffer(b);
  }
#line 1963
  return (b);
}
}
#line 1974 "lexppd.c"
YY_BUFFER_STATE ppd_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1977
  tmp = strlen(yystr);
#line 1977
  tmp___0 = ppd_scan_bytes(yystr, (int )tmp);
  }
#line 1977
  return (tmp___0);
}
}
#line 1987 "lexppd.c"
YY_BUFFER_STATE ppd_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1995
  n = (yy_size_t )(_yybytes_len + 2);
#line 1996
  tmp = ppdalloc(n);
#line 1996
  buf___0 = (char *)tmp;
  }
#line 1997
  if (! buf___0) {
    {
#line 1998
    yy_fatal_error("out of dynamic memory in ppd_scan_bytes()");
    }
  }
#line 2000
  i = 0;
  {
#line 2000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2000
    if (! (i < _yybytes_len)) {
#line 2000
      goto while_break;
    }
#line 2001
    *(buf___0 + i) = (char )*(yybytes + i);
#line 2000
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2003
  tmp___0 = (char)0;
#line 2003
  *(buf___0 + (_yybytes_len + 1)) = tmp___0;
#line 2003
  *(buf___0 + _yybytes_len) = tmp___0;
#line 2005
  b = ppd_scan_buffer(buf___0, n);
  }
#line 2006
  if (! b) {
    {
#line 2007
    yy_fatal_error("bad buffer in ppd_scan_bytes()");
    }
  }
#line 2012
  b->yy_is_our_buffer = 1;
#line 2014
  return (b);
}
}
#line 2021 "lexppd.c"
static void yy_fatal_error(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 2023
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2024
  exit(2);
  }
}
}
#line 2049 "lexppd.c"
int ppdget_lineno(void) 
{ 


  {
#line 2052
  return (ppdlineno);
}
}
#line 2058 "lexppd.c"
FILE *ppdget_in(void) 
{ 


  {
#line 2060
  return (ppdin);
}
}
#line 2066 "lexppd.c"
FILE *ppdget_out(void) 
{ 


  {
#line 2068
  return (ppdout);
}
}
#line 2074 "lexppd.c"
int ppdget_leng(void) 
{ 


  {
#line 2076
  return (ppdleng);
}
}
#line 2083 "lexppd.c"
char *ppdget_text(void) 
{ 


  {
#line 2085
  return (ppdtext);
}
}
#line 2092 "lexppd.c"
void ppdset_lineno(int line_number ) 
{ 


  {
#line 2095
  ppdlineno = line_number;
#line 2096
  return;
}
}
#line 2104 "lexppd.c"
void ppdset_in(FILE *in_str ) 
{ 


  {
#line 2106
  ppdin = in_str;
#line 2107
  return;
}
}
#line 2109 "lexppd.c"
void ppdset_out(FILE *out_str ) 
{ 


  {
#line 2111
  ppdout = out_str;
#line 2112
  return;
}
}
#line 2114 "lexppd.c"
int ppdget_debug(void) 
{ 


  {
#line 2116
  return (ppd_flex_debug);
}
}
#line 2119 "lexppd.c"
void ppdset_debug(int bdebug ) 
{ 


  {
#line 2121
  ppd_flex_debug = bdebug;
#line 2122
  return;
}
}
#line 2124 "lexppd.c"
static int yy_init_globals(void) 
{ 


  {
#line 2131
  ppdlineno = 1;
#line 2133
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2134
  yy_buffer_stack_top = (size_t )0;
#line 2135
  yy_buffer_stack_max = (size_t )0;
#line 2136
  yy_c_buf_p = (char *)0;
#line 2137
  yy_init = 0;
#line 2138
  yy_start = 0;
#line 2145
  ppdin = (FILE *)0;
#line 2146
  ppdout = (FILE *)0;
#line 2152
  return (0);
}
}
#line 2156 "lexppd.c"
int ppdlex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2160
    if (yy_buffer_stack) {
#line 2160
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2160
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2160
    if (! tmp___0) {
#line 2160
      goto while_break;
    }
#line 2161
    if (yy_buffer_stack) {
#line 2161
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2161
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2161
    ppd_delete_buffer(tmp);
#line 2162
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2163
    ppdpop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2167
  ppdfree((void *)yy_buffer_stack);
#line 2168
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2172
  yy_init_globals();
  }
#line 2174
  return (0);
}
}
#line 2201 "lexppd.c"
void *ppdalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2203
  tmp = malloc(size);
  }
#line 2203
  return (tmp);
}
}
#line 2206 "lexppd.c"
void *ppdrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2215
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2215
  return (tmp);
}
}
#line 2218 "lexppd.c"
void ppdfree(void *ptr ) 
{ 


  {
  {
#line 2220
  free((void *)((char *)ptr));
  }
#line 2221
  return;
}
}
#line 253 "lexppd.l"
int ppdwrap(void) 
{ 


  {
#line 256
  return (1);
}
}
#line 265 "lexppd.l"
static int first_time___0  =    1;
#line 262 "lexppd.l"
void ppdlex_initialize(void) 
{ 


  {
#line 266
  if (first_time___0) {
    {
#line 268
    first_time___0 = 0;
#line 269
    _obstack_begin(& string_stack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
    }
  }
#line 272
  include_stack_ptr = 0;
#line 273
  return;
}
}
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 108 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.h"
void init_face_eo_font(struct a2ps_job *job___0 ) ;
#line 109
void face_eo_font_free(char **face_eo_font ) ;
#line 59 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.h"
struct encoding *get_encoding_by_alias(struct a2ps_job *job___0 , char *alias ) ;
#line 96
struct pair_htable *encodings_map_new(void) ;
#line 97
void encodings_map_free(struct pair_htable *table ) ;
#line 99
struct hash_table_s *encodings_table_new(void) ;
#line 100
void encodings_table_free(struct hash_table_s *table ) ;
#line 102
int load_main_encodings_map(struct a2ps_job *job___0 ) ;
#line 49 "/home/ysko/Works/test-src/a2ps-4.14/lib/common.h"
void a2ps_common_reset(struct a2ps_common_s *common ) ;
#line 55
void a2ps_common_free(struct a2ps_common_s *common ) ;
#line 59
void a2ps_common_finalize(struct a2ps_common_s *common , char const   *home ) ;
#line 160 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.h"
struct a2ps_job *a2ps_job_new(void) ;
#line 163
void a2ps_job_finalize(struct a2ps_job *job___0 ) ;
#line 166
void a2ps_job_free(struct a2ps_job *job___0 ) ;
#line 175
void a2ps_job_unlink_tmpfiles(struct a2ps_job *job___0 ) ;
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/fonts.h"
struct pair_htable *fonts_map_new(void) ;
#line 42
void fonts_map_free(struct pair_htable *table ) ;
#line 43
int load_main_fonts_map(struct a2ps_job *job___0 ) ;
#line 46
struct hash_table_s *font_info_table_new(void) ;
#line 47
void font_info_table_free(struct hash_table_s *table ) ;
#line 73 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.h"
void file_job_self_print(struct file_job *file , FILE *stream ) ;
#line 74
void file_job_unlink_tmpfile(struct file_job *file ) ;
#line 75
void file_job_free(struct file_job *file_job ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 53 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.c"
__inline static void a2ps_job_register_user(a2ps_job *job___0 ) 
{ 
  struct userdata u ;
  char *host ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 58
  userdata_get(& u);
  }
#line 59
  if (u.login) {
    {
#line 60
    macro_meta_sequence_add(job___0, "user.login", (char const   *)u.login);
    }
  }
#line 61
  if (u.name) {
    {
#line 62
    macro_meta_sequence_add(job___0, "user.name", (char const   *)u.name);
    }
  }
#line 63
  if (u.comments) {
    {
#line 64
    macro_meta_sequence_add(job___0, "user.comments", (char const   *)u.comments);
    }
  }
#line 65
  if (u.home) {
    {
#line 66
    macro_meta_sequence_add(job___0, "user.home", (char const   *)u.home);
    }
  }
  {
#line 67
  userdata_free(& u);
#line 71
  tmp = xgethostname();
#line 71
  host = tmp;
#line 72
  macro_meta_sequence_add(job___0, "user.host", (char const   *)host);
#line 73
  free((void *)host);
  }
#line 75
  return;
}
}
#line 80 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.c"
static void tmpfiles_reset(struct a2ps_job *job___0 ) 
{ 
  size_t i ;

  {
#line 85
  i = (size_t )0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! ((unsigned long )i < sizeof(job___0->tmp_filenames) / sizeof(job___0->tmp_filenames[0]))) {
#line 85
      goto while_break;
    }
#line 86
    job___0->tmp_filenames[i] = (char *)((void *)0);
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 92 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.c"
static void tmpfiles_free(struct a2ps_job *job___0 ) 
{ 
  size_t i ;

  {
#line 97
  i = (size_t )0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! ((unsigned long )i < sizeof(job___0->tmp_filenames) / sizeof(job___0->tmp_filenames[0]))) {
#line 97
      goto while_break;
    }
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (job___0->tmp_filenames[i]) {
        {
#line 98
        free((void *)job___0->tmp_filenames[i]);
        }
      }
#line 98
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 104 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.c"
void a2ps_job_unlink_tmpfiles(struct a2ps_job *job___0 ) 
{ 
  size_t i ;

  {
#line 110
  i = (size_t )0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! ((unsigned long )i < sizeof(job___0->tmp_filenames) / sizeof(job___0->tmp_filenames[0]))) {
#line 110
      goto while_break;
    }
#line 111
    if (job___0->tmp_filenames[i]) {
      {
#line 112
      unlink((char const   *)job___0->tmp_filenames[i]);
      }
    }
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  da_map(job___0->jobs, (void (*)(void * ))(& file_job_unlink_tmpfile));
  }
#line 116
  return;
}
}
#line 123 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.c"
struct a2ps_job *a2ps_job_new(void) 
{ 
  time_t tim ;
  struct tm *tm ;
  a2ps_job *res___2 ;
  char *cp ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 131
  tmp = xmalloc((size_t )sizeof(a2ps_job ));
#line 131
  res___2 = (a2ps_job *)tmp;
#line 134
  set_quoting_style((struct quoting_options *)((void *)0), (enum quoting_style )4);
#line 137
  setlocale(2, "");
#line 141
  setlocale(0, "");
#line 143
  bindtextdomain("a2ps", "/usr/local/share/locale");
#line 144
  textdomain("a2ps");
#line 147
  lister_initialize((struct lister *)((void *)0), stdout);
#line 148
  lister_before_set((struct lister *)((void *)0), (size_t )2);
#line 152
  msg_verbosity = 2U;
#line 153
  cp = getenv("A2PS_VERBOSITY");
  }
#line 153
  if (cp) {
#line 153
    if (*cp) {
      {
#line 154
      tmp___0 = msg_verbosity_argmatch("$A2PS_VERBOSITY", cp);
#line 154
      msg_verbosity = (unsigned int )tmp___0;
      }
    }
  }
  {
#line 157
  res___2->argv = (char **)((void *)0);
#line 158
  res___2->argc = (size_t )0;
#line 160
  a2ps_common_reset(& res___2->common);
#line 161
  res___2->file_command = (char *)((void *)0);
#line 166
  res___2->media = new_medium_table();
#line 169
  res___2->user_options = user_options_table_new();
#line 172
  cp = getenv("SIMPLE_BACKUP_SUFFIX");
  }
#line 172
  if (cp) {
#line 173
    simple_backup_suffix = (char const   *)cp;
  }
  {
#line 174
  tmp___1 = getenv("VERSION_CONTROL");
#line 174
  res___2->backup_type = get_version("$VERSION_CONTROL", (char const   *)tmp___1);
#line 178
  tim = time((time_t *)((void *)0));
#line 179
  tm = localtime((time_t const   *)(& tim));
#line 180
  memcpy((void */* __restrict  */)(& res___2->run_tm), (void const   */* __restrict  */)tm,
         (size_t )sizeof(*tm));
#line 182
  res___2->sheets = 0;
#line 183
  res___2->pages = 0;
#line 184
  res___2->lines_folded = 0;
#line 185
  res___2->total_files = 0;
#line 186
  res___2->orientation = (ORIENTATION )0;
#line 187
  res___2->duplex = (enum duplex_e )0;
#line 188
  res___2->columns = 1;
#line 189
  res___2->rows = 1;
#line 190
  res___2->madir = (madir_t )0;
#line 191
  res___2->virtual = 0;
#line 192
  res___2->copies = 1;
#line 193
  res___2->margin = 0;
#line 196
  res___2->encodings_map = encodings_map_new();
#line 199
  res___2->ps_encodings = output_new("PS encodings");
#line 201
  res___2->page_prefeed = 0;
#line 204
  init_face_eo_font(res___2);
#line 207
  tmp___2 = xstrdup("stdin");
#line 207
  res___2->stdin_filename = (unsigned char *)tmp___2;
#line 212
  res___2->output_format = (enum output_format )1;
#line 214
  res___2->printers = a2ps_printers_new(& res___2->common);
#line 215
  res___2->output_stream = (struct stream *)((void *)0);
#line 217
  res___2->folding = (_Bool)1;
#line 218
  res___2->numbering = 0;
#line 219
  res___2->unprintable_format = (enum unprintable_format )0;
#line 220
  res___2->interpret = 1;
#line 221
  res___2->print_binaries = 0;
#line 223
  res___2->file_align = -2;
#line 224
  res___2->border = 1;
#line 225
  res___2->debug = (_Bool)0;
#line 226
  res___2->prolog = xstrdup("bw");
#line 227
  res___2->medium_request = (char *)((void *)0);
#line 228
  res___2->medium = (struct medium *)((void *)0);
#line 229
  res___2->tabsize = 8;
#line 230
  res___2->lines_requested = 0;
#line 231
  res___2->columns_requested = 0;
#line 232
  res___2->fontsize = (float )0.0;
#line 233
  res___2->encoding = (struct encoding *)((void *)0);
#line 234
  res___2->requested_encoding_name = (char *)((void *)0);
#line 235
  res___2->requested_encoding = (struct encoding *)((void *)0);
#line 236
  res___2->saved_encoding = (struct encoding *)((void *)0);
#line 237
  res___2->encodings = encodings_table_new();
#line 241
  res___2->fonts_map = fonts_map_new();
#line 242
  res___2->font_infos = font_info_table_new();
#line 245
  tmp___3 = xstrdup("a2ps output");
#line 245
  res___2->title = (unsigned char *)tmp___3;
#line 248
  res___2->header = (unsigned char *)((void *)0);
#line 249
  res___2->center_title = (unsigned char *)((void *)0);
#line 250
  res___2->left_title = (unsigned char *)((void *)0);
#line 251
  res___2->right_title = (unsigned char *)((void *)0);
#line 252
  res___2->left_footer = (unsigned char *)((void *)0);
#line 253
  res___2->footer = (unsigned char *)((void *)0);
#line 254
  res___2->right_footer = (unsigned char *)((void *)0);
#line 255
  res___2->water = (unsigned char *)((void *)0);
#line 256
  res___2->tag1[0] = (unsigned char )'\000';
#line 257
  res___2->tag2[0] = (unsigned char )'\000';
#line 258
  res___2->tag3[0] = (unsigned char )'\000';
#line 259
  res___2->tag4[0] = (unsigned char )'\000';
#line 262
  res___2->macro_meta_sequences = macro_meta_sequence_table_new();
#line 263
  a2ps_job_register_user(res___2);
#line 266
  res___2->status = new_ps_status();
#line 269
  res___2->divertion = output_new("Main trunk");
#line 272
  tmpfiles_reset(res___2);
#line 275
  res___2->page_range = page_range_new();
#line 278
  res___2->jobs = da_new("List of the jobs", (size_t )10, (enum da_growth )1, (size_t )10,
                         (void (*)(void const   * , FILE *stream ))(& file_job_self_print),
                         (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
  }
#line 281
  return (res___2);
}
}
#line 290 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.c"
void a2ps_job_finalize(struct a2ps_job *job___0 ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 294
  tmp = macro_meta_sequence_get(job___0, "user.home");
#line 294
  a2ps_common_finalize(& job___0->common, (char const   *)tmp);
#line 298
  a2ps_printers_finalize(job___0->printers);
#line 301
  load_main_encodings_map(job___0);
#line 305
  job___0->requested_encoding = get_encoding_by_alias(job___0, job___0->requested_encoding_name);
  }
#line 307
  if (! job___0->requested_encoding) {
#line 308
    if ((unsigned long )((void const   *)job___0->requested_encoding_name) == (unsigned long )((void *)0)) {
#line 308
      tmp___0 = "";
    } else {
#line 308
      tmp___0 = (char const   *)job___0->requested_encoding_name;
    }
    {
#line 308
    tmp___1 = quotearg(tmp___0);
#line 308
    tmp___2 = gettext("unknown encoding `%s\'");
#line 308
    error(1, 0, (char const   *)tmp___2, tmp___1);
    }
  }
  {
#line 312
  job___0->medium = a2ps_get_medium(job___0, (char const   *)job___0->medium_request);
#line 315
  load_main_fonts_map(job___0);
  }
#line 316
  return;
}
}
#line 321 "/home/ysko/Works/test-src/a2ps-4.14/lib/jobs.c"
void a2ps_job_free(struct a2ps_job *job___0 ) 
{ 


  {
#line 324
  if ((unsigned int )(1 << 6) & msg_verbosity) {
    {
#line 325
    da_self_print(job___0->jobs, stderr);
    }
  }
  {
#line 327
  free_medium_table(job___0->media);
#line 332
  a2ps_common_free(& job___0->common);
#line 334
  encodings_map_free(job___0->encodings_map);
#line 335
  face_eo_font_free((char **)(job___0->face_eo_font));
#line 337
  output_free(job___0->ps_encodings);
#line 339
  a2ps_printers_free(job___0->printers);
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (job___0->stdin_filename) {
      {
#line 341
      free((void *)job___0->stdin_filename);
      }
    }
#line 341
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 344
  encodings_table_free(job___0->encodings);
#line 347
  fonts_map_free(job___0->fonts_map);
#line 348
  font_info_table_free(job___0->font_infos);
  }
  {
#line 351
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 351
    if (job___0->title) {
      {
#line 351
      free((void *)job___0->title);
      }
    }
#line 351
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 352
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 352
    if (job___0->header) {
      {
#line 352
      free((void *)job___0->header);
      }
    }
#line 352
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 353
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 353
    if (job___0->center_title) {
      {
#line 353
      free((void *)job___0->center_title);
      }
    }
#line 353
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 354
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 354
    if (job___0->left_title) {
      {
#line 354
      free((void *)job___0->left_title);
      }
    }
#line 354
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 355
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 355
    if (job___0->right_title) {
      {
#line 355
      free((void *)job___0->right_title);
      }
    }
#line 355
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 356
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 356
    if (job___0->left_footer) {
      {
#line 356
      free((void *)job___0->left_footer);
      }
    }
#line 356
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 357
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 357
    if (job___0->footer) {
      {
#line 357
      free((void *)job___0->footer);
      }
    }
#line 357
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 358
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 358
    if (job___0->right_footer) {
      {
#line 358
      free((void *)job___0->right_footer);
      }
    }
#line 358
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 359
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 359
    if (job___0->water) {
      {
#line 359
      free((void *)job___0->water);
      }
    }
#line 359
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 361
  free((void *)job___0->prolog);
#line 362
  free((void *)job___0->medium_request);
#line 365
  macro_meta_sequence_table_free(job___0->macro_meta_sequences);
#line 367
  ps_status_free(job___0->status);
  }
#line 369
  if ((unsigned int )(1 << 6) & msg_verbosity) {
    {
#line 370
    output_self_print(job___0->divertion, stderr);
    }
  }
  {
#line 371
  output_free(job___0->divertion);
#line 374
  a2ps_job_unlink_tmpfiles(job___0);
#line 375
  tmpfiles_free(job___0);
#line 377
  page_range_free(job___0->page_range);
#line 381
  da_free(job___0->jobs, (void (*)(void * ))(& file_job_free));
#line 383
  free((void *)job___0);
  }
#line 384
  return;
}
}
#line 36 "/home/ysko/Works/test-src/a2ps-4.14/lib/isdir.c"
int isdir(char const   *path ) 
{ 
  struct stat stats ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 41
  tmp = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& stats));
  }
#line 41
  if (tmp == 0) {
#line 41
    if ((stats.st_mode & 61440U) == 16384U) {
#line 41
      tmp___0 = 1;
    } else {
#line 41
      tmp___0 = 0;
    }
  } else {
#line 41
    tmp___0 = 0;
  }
#line 41
  return (tmp___0);
}
}
#line 710 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 65 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.h"
void hash_load(struct hash_table_s *ht , void *item_table , unsigned long cardinality ,
               unsigned long size ) ;
#line 67
void **hash_find_slot(struct hash_table_s *ht , void const   *key ) ;
#line 70
void *hash_insert_at(struct hash_table_s *ht , void *item , void const   *slot ) ;
#line 72
void *hash_delete_at(struct hash_table_s *ht , void const   *slot ) ;
#line 73
void hash_delete_items(struct hash_table_s *ht ) ;
#line 74
void hash_free_items(struct hash_table_s *ht , void (*free_fn)(void const   *item ) ) ;
#line 76
void hash_map(struct hash_table_s *ht , void (*map)(void const   *item ) ) ;
#line 79
void hash_print_stats(struct hash_table_s *ht , FILE *out_FILE ) ;
#line 81
void **hash_dump_select(struct hash_table_s *ht , void **vector_0 , int (*select_fn)(void const   *item ) ,
                        int (*compare)(void const   * , void const   * ) ) ;
#line 84
void *hash_deleted_item ;
#line 31 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
static void hash_rehash(struct hash_table_s *ht ) ;
#line 32
static unsigned long round_up_2(unsigned long rough ) ;
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void *hash_deleted_item  =    (void *)(& hash_deleted_item);
#line 46 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void hash_init(struct hash_table_s *ht , unsigned long size , unsigned long (*hash_1)(void const   *key ) ,
               unsigned long (*hash_2)(void const   *key ) , int (*hash_cmp)(void const   *x ,
                                                                             void const   *y ) ) 
{ 
  void *tmp ;

  {
  {
#line 50
  ht->ht_size = round_up_2(size);
  }
#line 51
  if (ht->ht_size > 131072UL) {
#line 52
    ht->ht_size /= 2UL;
  }
  {
#line 53
  tmp = xcalloc((size_t )sizeof(struct token *), (size_t )ht->ht_size);
#line 53
  ht->ht_vec = (void **)((struct token **)tmp);
#line 54
  ht->ht_capacity = (ht->ht_size * 15UL) / 16UL;
#line 55
  ht->ht_fill = 0UL;
#line 56
  ht->ht_collisions = 0UL;
#line 57
  ht->ht_lookups = 0UL;
#line 58
  ht->ht_rehashes = 0U;
#line 59
  ht->ht_hash_1 = hash_1;
#line 60
  ht->ht_hash_2 = hash_2;
#line 61
  ht->ht_compare = hash_cmp;
  }
#line 62
  return;
}
}
#line 66 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void hash_load(struct hash_table_s *ht , void *item_table , unsigned long cardinality ,
               unsigned long size ) 
{ 
  char *items ;
  unsigned long tmp ;

  {
#line 69
  items = (char *)item_table;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    tmp = cardinality;
#line 70
    cardinality --;
#line 70
    if (! tmp) {
#line 70
      goto while_break;
    }
    {
#line 72
    hash_insert(ht, (void *)items);
#line 73
    items += size;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 82 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void **hash_find_slot(struct hash_table_s *ht , void const   *key ) 
{ 
  void **slot ;
  void **deleted_slot ;
  unsigned int hash_2 ;
  unsigned int hash_1 ;
  unsigned long tmp ;
  void **tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 86
  deleted_slot = (void **)0;
#line 87
  hash_2 = 0U;
#line 88
  tmp = (*(ht->ht_hash_1))(key);
#line 88
  hash_1 = (unsigned int )tmp;
#line 90
  (ht->ht_lookups) ++;
  }
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    hash_1 = (unsigned int )((unsigned long )hash_1 % ht->ht_size);
#line 94
    slot = ht->ht_vec + hash_1;
#line 96
    if ((unsigned long )*slot == (unsigned long )((void *)0)) {
#line 97
      if (deleted_slot) {
#line 97
        tmp___0 = deleted_slot;
      } else {
#line 97
        tmp___0 = slot;
      }
#line 97
      return (tmp___0);
    }
#line 98
    if ((unsigned long )*slot == (unsigned long )hash_deleted_item) {
#line 100
      if ((unsigned long )deleted_slot == (unsigned long )((void **)0)) {
#line 101
        deleted_slot = slot;
      }
    } else {
#line 105
      if ((unsigned long )key == (unsigned long )*slot) {
#line 106
        return (slot);
      }
      {
#line 107
      tmp___1 = (*(ht->ht_compare))(key, (void const   *)*slot);
      }
#line 107
      if (tmp___1 == 0) {
#line 108
        return (slot);
      }
#line 109
      (ht->ht_collisions) ++;
    }
#line 111
    if (! hash_2) {
      {
#line 112
      tmp___2 = (*(ht->ht_hash_2))(key);
#line 112
      hash_2 = (unsigned int )(tmp___2 | 1UL);
      }
    }
#line 113
    hash_1 += hash_2;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 117 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void *hash_find_item(struct hash_table_s *ht , void const   *key ) 
{ 
  void **slot ;
  void **tmp ;
  void *tmp___0 ;

  {
  {
#line 120
  tmp = hash_find_slot(ht, key);
#line 120
  slot = tmp;
  }
#line 121
  if ((unsigned long )*slot == (unsigned long )((void *)0)) {
#line 121
    tmp___0 = (void *)0;
  } else
#line 121
  if ((unsigned long )*slot == (unsigned long )hash_deleted_item) {
#line 121
    tmp___0 = (void *)0;
  } else {
#line 121
    tmp___0 = *slot;
  }
#line 121
  return (tmp___0);
}
}
#line 124 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void *hash_insert(struct hash_table_s *ht , void *item ) 
{ 
  void **slot ;
  void **tmp ;
  void *tmp___0 ;

  {
  {
#line 127
  tmp = hash_find_slot(ht, (void const   *)item);
#line 127
  slot = tmp;
#line 128
  tmp___0 = hash_insert_at(ht, item, (void const   *)slot);
  }
#line 128
  return (tmp___0);
}
}
#line 131 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void *hash_insert_at(struct hash_table_s *ht , void *item , void const   *slot ) 
{ 
  void *old_item ;

  {
#line 134
  old_item = *((void **)slot);
#line 135
  if ((unsigned long )old_item == (unsigned long )((void *)0)) {
#line 137
    (ht->ht_fill) ++;
#line 138
    old_item = item;
  } else
#line 135
  if ((unsigned long )old_item == (unsigned long )hash_deleted_item) {
#line 137
    (ht->ht_fill) ++;
#line 138
    old_item = item;
  }
#line 140
  *((void const   **)slot) = (void const   *)item;
#line 141
  if (ht->ht_fill >= ht->ht_capacity) {
    {
#line 142
    hash_rehash(ht);
    }
  }
#line 143
  return (old_item);
}
}
#line 146 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void *hash_delete(struct hash_table_s *ht , void const   *item ) 
{ 
  void **slot ;
  void **tmp ;
  void *tmp___0 ;

  {
  {
#line 149
  tmp = hash_find_slot(ht, item);
#line 149
  slot = tmp;
#line 150
  tmp___0 = hash_delete_at(ht, (void const   *)slot);
  }
#line 150
  return (tmp___0);
}
}
#line 153 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void *hash_delete_at(struct hash_table_s *ht , void const   *slot ) 
{ 
  void *item ;

  {
#line 156
  item = *((void **)slot);
#line 157
  if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 164
    return ((void *)0);
  } else
#line 157
  if ((unsigned long )item == (unsigned long )hash_deleted_item) {
#line 164
    return ((void *)0);
  } else {
#line 159
    *((void const   **)slot) = (void const   *)hash_deleted_item;
#line 160
    (ht->ht_fill) --;
#line 161
    return (item);
  }
}
}
#line 167 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void hash_free_items(struct hash_table_s *ht , void (*free_fn)(void const   *item ) ) 
{ 
  void **vec ;
  void **end ;
  void *item ;

  {
#line 170
  vec = ht->ht_vec;
#line 171
  end = vec + ht->ht_size;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! ((unsigned long )vec < (unsigned long )end)) {
#line 172
      goto while_break;
    }
#line 174
    item = *vec;
#line 175
    if (! ((unsigned long )item == (unsigned long )((void *)0))) {
#line 175
      if (! ((unsigned long )item == (unsigned long )hash_deleted_item)) {
        {
#line 176
        (*free_fn)((void const   *)item);
        }
      }
    }
#line 177
    *vec = (void *)0;
#line 172
    vec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  ht->ht_fill = 0UL;
#line 180
  return;
}
}
#line 182 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void hash_delete_items(struct hash_table_s *ht ) 
{ 
  void **vec ;
  void **end ;

  {
#line 185
  vec = ht->ht_vec;
#line 186
  end = vec + ht->ht_size;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )vec < (unsigned long )end)) {
#line 187
      goto while_break;
    }
#line 188
    *vec = (void *)0;
#line 187
    vec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  ht->ht_fill = 0UL;
#line 190
  ht->ht_collisions = 0UL;
#line 191
  ht->ht_lookups = 0UL;
#line 192
  ht->ht_rehashes = 0U;
#line 193
  return;
}
}
#line 195 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void hash_free(struct hash_table_s *ht , void (*free_fn)(void const   *item ) ) 
{ 


  {
#line 198
  if (free_fn) {
    {
#line 199
    hash_free_items(ht, free_fn);
    }
  }
  {
#line 200
  free((void *)ht->ht_vec);
#line 201
  ht->ht_vec = (void **)0;
#line 202
  ht->ht_fill = 0UL;
#line 203
  ht->ht_capacity = 0UL;
  }
#line 204
  return;
}
}
#line 206 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void hash_map(struct hash_table_s *ht , void (*map)(void const   *item ) ) 
{ 
  void **slot ;
  void **end ;

  {
#line 210
  end = ht->ht_vec + ht->ht_size;
#line 212
  slot = ht->ht_vec;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((unsigned long )slot < (unsigned long )end)) {
#line 212
      goto while_break;
    }
#line 214
    if (! ((unsigned long )*slot == (unsigned long )((void *)0))) {
#line 214
      if (! ((unsigned long )*slot == (unsigned long )hash_deleted_item)) {
        {
#line 215
        (*map)((void const   *)*slot);
        }
      }
    }
#line 212
    slot ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 221 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
static void hash_rehash(struct hash_table_s *ht ) 
{ 
  unsigned long old_ht_size ;
  void **old_vec ;
  void **ovp ;
  void **slot ;
  void *tmp ;

  {
  {
#line 224
  old_ht_size = ht->ht_size;
#line 225
  old_vec = ht->ht_vec;
#line 229
  ht->ht_size *= 2UL;
#line 230
  (ht->ht_rehashes) ++;
#line 231
  ht->ht_capacity = ht->ht_size - (ht->ht_size >> 4);
#line 232
  tmp = xcalloc((size_t )sizeof(struct token *), (size_t )ht->ht_size);
#line 232
  ht->ht_vec = (void **)((struct token **)tmp);
#line 234
  ovp = old_vec;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! ((unsigned long )ovp < (unsigned long )(old_vec + old_ht_size))) {
#line 234
      goto while_break;
    }
#line 236
    if ((unsigned long )*ovp == (unsigned long )((void *)0)) {
#line 237
      goto __Cont;
    }
    {
#line 238
    slot = hash_find_slot(ht, (void const   *)*ovp);
#line 239
    *slot = *ovp;
    }
    __Cont: /* CIL Label */ 
#line 234
    ovp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 241
  free((void *)old_vec);
  }
#line 242
  return;
}
}
#line 244 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void hash_print_stats(struct hash_table_s *ht , FILE *out_FILE ) 
{ 
  double tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 247
  fprintf((FILE */* __restrict  */)out_FILE, (char const   */* __restrict  */)"Load=%ld/%ld=%.0f%%, ",
          ht->ht_fill, ht->ht_size, (100.0 * (double )ht->ht_fill) / (double )ht->ht_size);
#line 249
  fprintf((FILE */* __restrict  */)out_FILE, (char const   */* __restrict  */)"Rehash=%d, ",
          ht->ht_rehashes);
  }
#line 250
  if (ht->ht_lookups) {
#line 250
    tmp = (100.0 * (double )ht->ht_collisions) / (double )ht->ht_lookups;
  } else {
#line 250
    tmp = (double )0;
  }
  {
#line 250
  fprintf((FILE */* __restrict  */)out_FILE, (char const   */* __restrict  */)"Collisions=%ld/%ld=%.0f%%\n",
          ht->ht_collisions, ht->ht_lookups, tmp);
  }
#line 255
  return;
}
}
#line 260 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void **hash_dump(struct hash_table_s *ht , void **vector_0 , int (*compare)(void const   * ,
                                                                            void const   * ) ) 
{ 
  void **vector ;
  void **slot ;
  void **end ;
  void *tmp ;
  void **tmp___0 ;

  {
#line 265
  end = ht->ht_vec + ht->ht_size;
#line 267
  if ((unsigned long )vector_0 == (unsigned long )((void **)0)) {
    {
#line 268
    tmp = xmalloc((size_t )(sizeof(void *) * (ht->ht_fill + 1UL)));
#line 268
    vector_0 = (void **)tmp;
    }
  }
#line 269
  vector = vector_0;
#line 271
  slot = ht->ht_vec;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! ((unsigned long )slot < (unsigned long )end)) {
#line 271
      goto while_break;
    }
#line 272
    if (! ((unsigned long )*slot == (unsigned long )((void *)0))) {
#line 272
      if (! ((unsigned long )*slot == (unsigned long )hash_deleted_item)) {
#line 273
        tmp___0 = vector;
#line 273
        vector ++;
#line 273
        *tmp___0 = *slot;
      }
    }
#line 271
    slot ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  *vector = (void *)0;
#line 276
  if (compare) {
    {
#line 277
    qsort((void *)vector_0, (size_t )ht->ht_fill, (size_t )sizeof(void *), compare);
    }
  }
#line 278
  return (vector_0);
}
}
#line 285 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void **hash_dump_select(struct hash_table_s *ht , void **vector_0 , int (*select_fn)(void const   *item ) ,
                        int (*compare)(void const   * , void const   * ) ) 
{ 
  void **slot ;
  void **end ;
  int vector_0_malloced ;
  size_t fill ;
  void **tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 290
  end = ht->ht_vec + ht->ht_size;
#line 291
  vector_0_malloced = 0;
#line 292
  fill = (size_t )0;
#line 294
  if (! select_fn) {
    {
#line 295
    tmp = hash_dump(ht, vector_0, compare);
    }
#line 295
    return (tmp);
  }
#line 297
  if ((unsigned long )vector_0 == (unsigned long )((void **)0)) {
    {
#line 299
    tmp___0 = xmalloc((size_t )(sizeof(void *) * (ht->ht_fill + 1UL)));
#line 299
    vector_0 = (void **)tmp___0;
#line 300
    vector_0_malloced = 1;
    }
  }
#line 303
  slot = ht->ht_vec;
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! ((unsigned long )slot < (unsigned long )end)) {
#line 303
      goto while_break;
    }
#line 304
    if (! ((unsigned long )*slot == (unsigned long )((void *)0))) {
#line 304
      if (! ((unsigned long )*slot == (unsigned long )hash_deleted_item)) {
        {
#line 304
        tmp___2 = (*select_fn)((void const   *)*slot);
        }
#line 304
        if (tmp___2) {
#line 306
          tmp___1 = fill;
#line 306
          fill ++;
#line 306
          *(vector_0 + tmp___1) = *slot;
        }
      }
    }
#line 303
    slot ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  *(vector_0 + fill) = (void *)0;
#line 309
  if (vector_0_malloced) {
    {
#line 310
    tmp___3 = xrealloc((void *)vector_0, (size_t )(sizeof(void *) * (unsigned long )(fill + 1U)));
#line 310
    vector_0 = (void **)tmp___3;
    }
  }
#line 312
  if (compare) {
#line 312
    if (fill > 1U) {
      {
#line 313
      qsort((void *)vector_0, fill, (size_t )sizeof(void *), compare);
      }
    }
  }
#line 314
  return (vector_0);
}
}
#line 319 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
void hash_maparg(struct hash_table_s *ht , void (*map)(void const   *item , void const   *arg ) ,
                 void const   *arg , int (*compare)(void const   * , void const   * ) ) 
{ 
  void **vector ;
  void **vector_0 ;

  {
  {
#line 325
  vector_0 = hash_dump(ht, (void **)((void *)0), compare);
#line 327
  vector = vector_0;
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! *vector) {
#line 327
      goto while_break;
    }
    {
#line 328
    (*map)((void const   *)*vector, arg);
#line 327
    vector ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 330
  free((void *)vector_0);
  }
#line 331
  return;
}
}
#line 335 "/home/ysko/Works/test-src/a2ps-4.14/lib/hashtab.c"
static unsigned long round_up_2(unsigned long rough ) 
{ 
  int round ;

  {
#line 340
  round = 1;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! rough) {
#line 341
      goto while_break;
    }
#line 343
    round <<= 1;
#line 344
    rough >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  return ((unsigned long )round);
}
}
#line 35 "/home/ysko/Works/test-src/a2ps-4.14/lib/getshline.h"
int getshline(char **lineptr , size_t *n , FILE *stream ) ;
#line 38
int getshdelim(char **lineptr , size_t *n , int delimiter , int delimiter_quote ,
               int commentor , FILE *stream ) ;
#line 58
int getshdelim_numbered(int *firstline , int *lastline , char **lineptr , size_t *n ,
                        int delimiter , int delimiter_quote , int commentor , FILE *stream ) ;
#line 47 "/home/ysko/Works/test-src/a2ps-4.14/lib/getshline.c"
static int getshstr(int *firstline , int *lastline , char **lineptr , size_t *n ,
                    FILE *stream , char terminator , int terminator_quote , int commentor ,
                    size_t offset ) 
{ 
  int nchars_avail ;
  char *read_pos ;
  int ret ;
  void *tmp ;
  register int c ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 58
  if (! lineptr) {
#line 59
    return (-1);
  } else
#line 58
  if (! n) {
#line 59
    return (-1);
  } else
#line 58
  if (! stream) {
#line 59
    return (-1);
  }
#line 61
  if (! *lineptr) {
    {
#line 63
    *n = (size_t )64;
#line 64
    tmp = xmalloc((size_t )(sizeof(char ) * (unsigned long )*n));
#line 64
    *lineptr = (char *)tmp;
    }
#line 65
    if (! *lineptr) {
#line 66
      return (-1);
    }
  }
#line 70
  (*lastline) ++;
#line 70
  *firstline = *lastline;
#line 71
  nchars_avail = (int )(*n - offset);
#line 72
  read_pos = *lineptr + offset;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    tmp___0 = _IO_getc(stream);
#line 76
    c = tmp___0;
    }
#line 81
    if (! ((unsigned long )(*lineptr + *n) == (unsigned long )(read_pos + nchars_avail))) {
      {
#line 81
      __assert_fail("*n + *lineptr == read_pos + nchars_avail", "/home/ysko/Works/test-src/a2ps-4.14/lib/getshline.c",
                    81U, "getshstr");
      }
    }
#line 82
    if (nchars_avail < 2) {
#line 84
      if (*n > 64U) {
#line 85
        *n *= 2U;
      } else {
#line 87
        *n += 64U;
      }
      {
#line 89
      nchars_avail = (int )((*lineptr + *n) - read_pos);
#line 90
      tmp___1 = xrealloc((void *)*lineptr, (size_t )(sizeof(char ) * (unsigned long )*n));
#line 90
      *lineptr = (char *)tmp___1;
      }
#line 91
      if (! *lineptr) {
#line 92
        return (-1);
      }
#line 93
      read_pos = *lineptr + (*n - (size_t )nchars_avail);
#line 94
      if (! ((unsigned long )(*lineptr + *n) == (unsigned long )(read_pos + nchars_avail))) {
        {
#line 94
        __assert_fail("*n + *lineptr == read_pos + nchars_avail", "/home/ysko/Works/test-src/a2ps-4.14/lib/getshline.c",
                      94U, "getshstr");
        }
      }
    }
#line 97
    if (c == -1) {
#line 97
      goto _L;
    } else {
      {
#line 97
      tmp___2 = ferror(stream);
      }
#line 97
      if (tmp___2) {
        _L: /* CIL Label */ 
#line 100
        if ((unsigned long )read_pos == (unsigned long )*lineptr) {
#line 101
          return (-1);
        } else {
#line 103
          goto while_break;
        }
      }
    }
#line 106
    tmp___3 = read_pos;
#line 106
    read_pos ++;
#line 106
    *tmp___3 = (char )c;
#line 107
    nchars_avail --;
#line 109
    if (c == (int )terminator) {
#line 113
      if ((int )*(*lineptr) == (int )terminator) {
        {
#line 117
        *firstline = *lastline + 1;
#line 118
        tmp___4 = getshstr(firstline, lastline, lineptr, n, stream, terminator, terminator_quote,
                           commentor, offset);
        }
#line 118
        return (tmp___4);
      } else
#line 113
      if ((int )*(*lineptr) == commentor) {
        {
#line 117
        *firstline = *lastline + 1;
#line 118
        tmp___4 = getshstr(firstline, lastline, lineptr, n, stream, terminator, terminator_quote,
                           commentor, offset);
        }
#line 118
        return (tmp___4);
      }
#line 122
      if ((unsigned long )(read_pos - 2) <= (unsigned long )*lineptr) {
#line 125
        goto while_break;
      } else
#line 122
      if ((int )*(read_pos - 2) != terminator_quote) {
#line 125
        goto while_break;
      }
#line 128
      read_pos -= 2;
#line 129
      nchars_avail += 2;
#line 130
      (*lastline) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  *read_pos = (char )'\000';
#line 137
  ret = (int )(read_pos - (*lineptr + offset));
#line 138
  return (ret);
}
}
#line 141 "/home/ysko/Works/test-src/a2ps-4.14/lib/getshline.c"
int getshline_numbered(int *firstline , int *lastline , char **lineptr , size_t *n ,
                       FILE *stream ) 
{ 
  int tmp ;

  {
  {
#line 145
  tmp = getshstr(firstline, lastline, lineptr, n, stream, (char )'\n', '\\', '#',
                 (size_t )0);
  }
#line 145
  return (tmp);
}
}
#line 149 "/home/ysko/Works/test-src/a2ps-4.14/lib/getshline.c"
int getshline(char **lineptr , size_t *n , FILE *stream ) 
{ 
  int firstline ;
  int lastline ;
  int tmp ;

  {
  {
#line 153
  tmp = getshstr(& firstline, & lastline, lineptr, n, stream, (char )'\n', '\\', '#',
                 (size_t )0);
  }
#line 153
  return (tmp);
}
}
#line 158 "/home/ysko/Works/test-src/a2ps-4.14/lib/getshline.c"
int getshdelim_numbered(int *firstline , int *lastline , char **lineptr , size_t *n ,
                        int delimiter , int delimiter_quote , int commentor , FILE *stream ) 
{ 
  int tmp ;

  {
  {
#line 164
  tmp = getshstr(firstline, lastline, lineptr, n, stream, (char )delimiter, delimiter_quote,
                 commentor, (size_t )0);
  }
#line 164
  return (tmp);
}
}
#line 168 "/home/ysko/Works/test-src/a2ps-4.14/lib/getshline.c"
int getshdelim(char **lineptr , size_t *n , int delimiter , int delimiter_quote ,
               int commentor , FILE *stream ) 
{ 
  int firstline ;
  int lastline ;
  int tmp ;

  {
  {
#line 174
  tmp = getshstr(& firstline, & lastline, lineptr, n, stream, (char )delimiter, delimiter_quote,
                 commentor, (size_t )0);
  }
#line 174
  return (tmp);
}
}
#line 415 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 55 "/home/ysko/Works/test-src/a2ps-4.14/lib/getnum.c"
int get_integer_in_range(char const   *option , char const   *arg , int min , int max ,
                         enum range_type_e range_type ) 
{ 
  char buf___0[256] ;
  int res___2 ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 62
  tmp___1 = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%d%255s",
                   & res___2, buf___0);
  }
#line 62
  if (tmp___1 != 1) {
    {
#line 63
    tmp = quotearg(arg);
#line 63
    tmp___0 = gettext("invalid argument `%s\' for `%s\'");
#line 63
    error(1, 0, (char const   *)tmp___0, tmp, option);
    }
  }
#line 66
  buf___0[0] = (char )'\000';
  {
#line 70
  if ((unsigned int )range_type == 1U) {
#line 70
    goto case_1;
  }
#line 75
  if ((unsigned int )range_type == 2U) {
#line 75
    goto case_2;
  }
#line 80
  if ((unsigned int )range_type == 3U) {
#line 80
    goto case_3;
  }
#line 85
  if ((unsigned int )range_type == 4U) {
#line 85
    goto case_4;
  }
#line 90
  if ((unsigned int )range_type == 5U) {
#line 90
    goto case_5;
  }
#line 95
  if ((unsigned int )range_type == 6U) {
#line 95
    goto case_6;
  }
#line 100
  if ((unsigned int )range_type == 7U) {
#line 100
    goto case_7;
  }
#line 105
  if ((unsigned int )range_type == 8U) {
#line 105
    goto case_8;
  }
#line 110
  if ((unsigned int )range_type == 0U) {
#line 110
    goto case_0;
  }
#line 113
  goto switch_default;
  case_1: /* CIL Label */ 
#line 71
  if (res___2 < min) {
    {
#line 72
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d <= n",
            min);
    }
  }
#line 73
  goto switch_break;
  case_2: /* CIL Label */ 
#line 76
  if (res___2 <= min) {
    {
#line 77
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d < n",
            min);
    }
  }
#line 78
  goto switch_break;
  case_3: /* CIL Label */ 
#line 81
  if (res___2 > max) {
    {
#line 82
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"n <= %d",
            max);
    }
  }
#line 83
  goto switch_break;
  case_4: /* CIL Label */ 
#line 86
  if (res___2 >= max) {
    {
#line 87
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"n <= %d",
            max);
    }
  }
#line 88
  goto switch_break;
  case_5: /* CIL Label */ 
#line 91
  if (res___2 < min) {
    {
#line 92
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d <= n <= %d",
            min, max);
    }
  } else
#line 91
  if (res___2 > max) {
    {
#line 92
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d <= n <= %d",
            min, max);
    }
  }
#line 93
  goto switch_break;
  case_6: /* CIL Label */ 
#line 96
  if (res___2 <= min) {
    {
#line 97
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d < n <= %d",
            min, max);
    }
  } else
#line 96
  if (res___2 > max) {
    {
#line 97
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d < n <= %d",
            min, max);
    }
  }
#line 98
  goto switch_break;
  case_7: /* CIL Label */ 
#line 101
  if (res___2 < min) {
    {
#line 102
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d <= n < %d",
            min, max);
    }
  } else
#line 101
  if (res___2 >= max) {
    {
#line 102
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d <= n < %d",
            min, max);
    }
  }
#line 103
  goto switch_break;
  case_8: /* CIL Label */ 
#line 106
  if (res___2 < min) {
    {
#line 107
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d < n < %d",
            min, max);
    }
  } else
#line 106
  if (res___2 >= max) {
    {
#line 107
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d < n < %d",
            min, max);
    }
  }
#line 108
  goto switch_break;
  case_0: /* CIL Label */ 
#line 111
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 114
  abort();
  }
#line 115
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 118
  if (buf___0[0]) {
    {
#line 120
    tmp___2 = quotearg(arg);
#line 120
    tmp___3 = gettext("invalid argument `%s\' for `%s\'");
#line 120
    error(0, 0, (char const   *)tmp___3, tmp___2, option);
#line 122
    tmp___4 = gettext("Valid arguments are integers n such that: %s\n");
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
            buf___0);
#line 124
    exit(1);
    }
  }
#line 126
  return (res___2);
}
}
#line 132 "/home/ysko/Works/test-src/a2ps-4.14/lib/getnum.c"
static float get_float_in_range(char const   *option , char const   *arg , char const   * const  *args_list ,
                                float *types_list , float min , float max , char const   *unit ,
                                enum range_type_e range_type ) 
{ 
  float res___2 ;
  char buf___0[256] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 142
  tmp = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%f%255s",
               & res___2, buf___0);
  }
  {
#line 144
  if (tmp == 2) {
#line 144
    goto case_2;
  }
#line 149
  if (tmp == 1) {
#line 149
    goto case_1;
  }
#line 152
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 146
  tmp___0 = __xargmatch_internal(option, (char const   *)(buf___0), args_list, (char const   *)types_list,
                                 (size_t )sizeof(*types_list), 0, argmatch_die);
#line 146
  res___2 *= *(types_list + tmp___0);
  }
#line 147
  goto switch_break;
  case_1: /* CIL Label */ 
#line 150
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 153
  tmp___1 = quotearg(arg);
#line 153
  tmp___2 = gettext("invalid argument `%s\' for `%s\'");
#line 153
  error(1, 0, (char const   *)tmp___2, tmp___1, option);
  }
#line 155
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 159
  tmp___3 = __xargmatch_internal("internal conversion", unit, args_list, (char const   *)types_list,
                                 (size_t )sizeof(*types_list), 1, & abort);
#line 159
  res___2 /= *(types_list + tmp___3);
#line 165
  buf___0[0] = (char )'\000';
  }
  {
#line 170
  if ((unsigned int )range_type == 1U) {
#line 170
    goto case_1___0;
  }
#line 175
  if ((unsigned int )range_type == 2U) {
#line 175
    goto case_2___0;
  }
#line 180
  if ((unsigned int )range_type == 3U) {
#line 180
    goto case_3;
  }
#line 185
  if ((unsigned int )range_type == 4U) {
#line 185
    goto case_4;
  }
#line 190
  if ((unsigned int )range_type == 5U) {
#line 190
    goto case_5;
  }
#line 195
  if ((unsigned int )range_type == 6U) {
#line 195
    goto case_6;
  }
#line 200
  if ((unsigned int )range_type == 7U) {
#line 200
    goto case_7;
  }
#line 205
  if ((unsigned int )range_type == 8U) {
#line 205
    goto case_8;
  }
#line 210
  if ((unsigned int )range_type == 0U) {
#line 210
    goto case_0;
  }
#line 213
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 171
  if (res___2 < min) {
    {
#line 172
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s <= f",
            (double )min, unit);
    }
  }
#line 173
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 176
  if (res___2 <= min) {
    {
#line 177
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s < f",
            (double )min, unit);
    }
  }
#line 178
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 181
  if (res___2 > max) {
    {
#line 182
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"f <= %.1f%s",
            (double )max, unit);
    }
  }
#line 183
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 186
  if (res___2 >= max) {
    {
#line 187
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"f <= %.1f%s",
            (double )max, unit);
    }
  }
#line 188
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 191
  if (res___2 < min) {
    {
#line 192
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s <= f <= %.1f%s",
            (double )min, unit, (double )max, unit);
    }
  } else
#line 191
  if (res___2 > max) {
    {
#line 192
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s <= f <= %.1f%s",
            (double )min, unit, (double )max, unit);
    }
  }
#line 193
  goto switch_break___0;
  case_6: /* CIL Label */ 
#line 196
  if (res___2 <= min) {
    {
#line 197
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s < f <= %.1f%s",
            (double )min, unit, (double )max, unit);
    }
  } else
#line 196
  if (res___2 > max) {
    {
#line 197
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s < f <= %.1f%s",
            (double )min, unit, (double )max, unit);
    }
  }
#line 198
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 201
  if (res___2 < min) {
    {
#line 202
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s <= f < %.1f%s",
            (double )min, unit, (double )max, unit);
    }
  } else
#line 201
  if (res___2 >= max) {
    {
#line 202
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s <= f < %.1f%s",
            (double )min, unit, (double )max, unit);
    }
  }
#line 203
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 206
  if (res___2 <= min) {
    {
#line 207
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s < f < %.1f%s",
            (double )min, unit, (double )max, unit);
    }
  } else
#line 206
  if (res___2 >= max) {
    {
#line 207
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%.1f%s < f < %.1f%s",
            (double )min, unit, (double )max, unit);
    }
  }
#line 208
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 211
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 214
  abort();
  }
#line 215
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 218
  if (buf___0[0]) {
    {
#line 220
    tmp___4 = quotearg(arg);
#line 220
    tmp___5 = gettext("invalid argument `%s\' for `%s\'");
#line 220
    error(0, 0, (char const   *)tmp___5, tmp___4, option);
#line 222
    tmp___6 = gettext("Valid arguments are floats f such that: %s\n");
#line 222
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            buf___0);
#line 224
    exit(1);
    }
  }
#line 227
  return (res___2);
}
}
#line 233 "/home/ysko/Works/test-src/a2ps-4.14/lib/getnum.c"
static char const   * const  length_args[6]  = {      (char const   */* const  */)"points",      (char const   */* const  */)"pts",      (char const   */* const  */)"inchs",      (char const   */* const  */)"cm", 
        (char const   */* const  */)"centimeters",      (char const   */* const  */)0};
#line 241 "/home/ysko/Works/test-src/a2ps-4.14/lib/getnum.c"
static float length_types[5]  = {      (float )1.0,      (float )1.0,      (float )72.0,      (float )((double )72 / 2.54), 
        (float )((double )72 / 2.54)};
#line 251 "/home/ysko/Works/test-src/a2ps-4.14/lib/getnum.c"
float get_length(char const   *option , char const   *arg , float min , float max ,
                 char const   *unit , enum range_type_e range_type ) 
{ 
  float tmp ;

  {
  {
#line 255
  tmp = get_float_in_range(option, arg, length_args, length_types, min, max, unit,
                           range_type);
  }
#line 255
  return (tmp);
}
}
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/lib/gen.h"
char const   *output_format_to_key(enum output_format format ) ;
#line 42
void a2ps_print_char(struct a2ps_job *job___0 , int c , enum face_e new_face ) ;
#line 46
void a2ps_print_string(struct a2ps_job *job___0 , unsigned char const   *string ,
                       enum face_e new_face ) ;
#line 50
void a2ps_print_buffer(struct a2ps_job *job___0 , unsigned char const   *buffer ,
                       size_t start , size_t end , enum face_e new_face ) ;
#line 55
void a2ps_open_output_session(struct a2ps_job *job___0 ) ;
#line 56
void a2ps_close_output_session(struct a2ps_job *job___0 ) ;
#line 59
void a2ps_open_input_session(struct a2ps_job *job___0 , unsigned char *name ) ;
#line 60
void a2ps_close_input_session(struct a2ps_job *job___0 ) ;
#line 66 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.h"
struct file_job *_a2ps_file_job_new(unsigned char *name , int num , struct tm *run_tm ) ;
#line 43 "/home/ysko/Works/test-src/a2ps-4.14/lib/gen.c"
void a2ps_print_char(struct a2ps_job *job___0 , int c , enum face_e new_face ) 
{ 


  {
  {
#line 48
  if ((unsigned int )job___0->output_format == 1U) {
#line 48
    goto case_1;
  }
#line 52
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 49
  ps_print_char(job___0, c, new_face);
  }
#line 50
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 53
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 55
  return;
}
}
#line 60 "/home/ysko/Works/test-src/a2ps-4.14/lib/gen.c"
void a2ps_print_string(struct a2ps_job *job___0 , unsigned char const   *string ,
                       enum face_e new_face ) 
{ 
  unsigned char const   *tmp ;

  {
  {
#line 65
  if ((unsigned int )job___0->output_format == 1U) {
#line 65
    goto case_1;
  }
#line 70
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! *string) {
#line 66
      goto while_break;
    }
    {
#line 67
    tmp = string;
#line 67
    string ++;
#line 67
    ps_print_char(job___0, (int )*tmp, new_face);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 71
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 73
  return;
}
}
#line 78 "/home/ysko/Works/test-src/a2ps-4.14/lib/gen.c"
void a2ps_print_buffer(struct a2ps_job *job___0 , unsigned char const   *buffer ,
                       size_t start , size_t end , enum face_e new_face ) 
{ 
  size_t i ;

  {
  {
#line 88
  if ((unsigned int )job___0->output_format == 1U) {
#line 88
    goto case_1;
  }
#line 93
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  i = start;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < end)) {
#line 89
      goto while_break;
    }
    {
#line 90
    ps_print_char(job___0, (int )*(buffer + i), new_face);
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 94
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 96
  return;
}
}
#line 101 "/home/ysko/Works/test-src/a2ps-4.14/lib/gen.c"
void a2ps_open_output_session(struct a2ps_job *job___0 ) 
{ 


  {
  {
#line 106
  if ((unsigned int )job___0->output_format == 1U) {
#line 106
    goto case_1;
  }
#line 110
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 107
  ps_begin(job___0);
  }
#line 108
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 111
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 118 "/home/ysko/Works/test-src/a2ps-4.14/lib/gen.c"
void a2ps_open_input_session(struct a2ps_job *job___0 , unsigned char *name ) 
{ 
  struct file_job *file_job ;
  unsigned char *tmp ;

  {
#line 123
  (job___0->total_files) ++;
#line 123
  if ((unsigned long )((char const   *)name) == (unsigned long )((void *)0)) {
#line 123
    tmp = job___0->stdin_filename;
  } else
#line 123
  if ((int )*name == 0) {
#line 123
    tmp = job___0->stdin_filename;
  } else {
#line 123
    tmp = name;
  }
  {
#line 123
  file_job = _a2ps_file_job_new(tmp, job___0->total_files, & job___0->run_tm);
#line 128
  job___0->tag1[0] = (unsigned char )'\000';
#line 129
  job___0->tag2[0] = (unsigned char )'\000';
#line 130
  job___0->tag3[0] = (unsigned char )'\000';
#line 131
  job___0->tag4[0] = (unsigned char )'\000';
  }
  {
#line 135
  if ((unsigned int )job___0->output_format == 1U) {
#line 135
    goto case_1;
  }
#line 139
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 136
  ps_begin_file(job___0);
  }
#line 137
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 140
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 144
  da_append(job___0->jobs, (void *)file_job);
  }
#line 145
  return;
}
}
#line 150 "/home/ysko/Works/test-src/a2ps-4.14/lib/gen.c"
void a2ps_close_input_session(struct a2ps_job *job___0 ) 
{ 


  {
  {
#line 160
  if ((unsigned int )job___0->output_format == 1U) {
#line 160
    goto case_1;
  }
#line 164
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 161
  ps_end_file(job___0);
  }
#line 162
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 165
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 172 "/home/ysko/Works/test-src/a2ps-4.14/lib/gen.c"
void a2ps_close_output_session(struct a2ps_job *job___0 ) 
{ 


  {
  {
#line 177
  if ((unsigned int )job___0->output_format == 1U) {
#line 177
    goto case_1;
  }
#line 181
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 178
  ps_end(job___0);
  }
#line 179
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 182
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 186 "/home/ysko/Works/test-src/a2ps-4.14/lib/gen.c"
char const   *output_format_to_key(enum output_format format ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 192
  if ((unsigned int )format == 0U) {
#line 192
    goto case_0;
  }
#line 192
  if ((unsigned int )format == 1U) {
#line 192
    goto case_0;
  }
#line 195
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 193
  return ("ps");
  switch_default: /* CIL Label */ 
  {
#line 196
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 198
  return ((char const   *)((void *)0));
}
}
#line 675 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 155 "fonts.c"
int afmleng  ;
#line 157
FILE *afmin ;
#line 157
FILE *afmout ;
#line 270 "fonts.c"
static size_t yy_buffer_stack_top___0  =    (size_t )0;
#line 271 "fonts.c"
static size_t yy_buffer_stack_max___0  =    (size_t )0;
#line 272 "fonts.c"
static YY_BUFFER_STATE *yy_buffer_stack___0  =    (YY_BUFFER_STATE *)0;
#line 290 "fonts.c"
static char yy_hold_char___0  ;
#line 291 "fonts.c"
static int yy_n_chars___0  ;
#line 295 "fonts.c"
static char *yy_c_buf_p___0  =    (char *)0;
#line 296 "fonts.c"
static int yy_init___0  =    0;
#line 297 "fonts.c"
static int yy_start___0  =    0;
#line 302 "fonts.c"
static int yy_did_buffer_switch_on_eof___0  ;
#line 304
void afmrestart(FILE *input_file ) ;
#line 305
void afm_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 306
YY_BUFFER_STATE afm_create_buffer(FILE *file , int size ) ;
#line 307
void afm_delete_buffer(YY_BUFFER_STATE b ) ;
#line 308
void afm_flush_buffer(YY_BUFFER_STATE b ) ;
#line 309
void afmpush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 310
void afmpop_buffer_state(void) ;
#line 312
static void afmensure_buffer_stack(void) ;
#line 313
static void afm_load_buffer_state(void) ;
#line 314
static void afm_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 318
YY_BUFFER_STATE afm_scan_buffer(char *base , yy_size_t size ) ;
#line 319
YY_BUFFER_STATE afm_scan_string(char const   *yystr ) ;
#line 320
YY_BUFFER_STATE afm_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 322
void *afmalloc(yy_size_t size ) ;
#line 323
void *afmrealloc(void *ptr , yy_size_t size ) ;
#line 324
void afmfree(void *ptr ) ;
#line 354 "fonts.c"
FILE *afmin  =    (FILE *)0;
#line 354 "fonts.c"
FILE *afmout  =    (FILE *)0;
#line 358
int afmlineno ;
#line 360 "fonts.c"
int afmlineno  =    1;
#line 362 "fonts.c"
char *afmtext  ;
#line 365
static yy_state_type yy_get_previous_state___0(void) ;
#line 366
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) ;
#line 367
static int yy_get_next_buffer___0(void) ;
#line 368
static void yy_fatal_error___0(char const   *msg ) ;
#line 389 "fonts.c"
static flex_int16_t const   yy_accept___0[57]  = 
#line 389
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )11,      (flex_int16_t const   )10,      (flex_int16_t const   )2, 
        (flex_int16_t const   )10,      (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )0, 
        (flex_int16_t const   )2,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )7,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )4,      (flex_int16_t const   )0,      (flex_int16_t const   )7,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )5,      (flex_int16_t const   )0,      (flex_int16_t const   )6, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )3, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1, 
        (flex_int16_t const   )0};
#line 399 "fonts.c"
static flex_int32_t const   yy_ec___0[256]  = 
#line 399
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )5,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )8,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )11, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )14,      (flex_int32_t const   )1,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )17,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )20,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )21,      (flex_int32_t const   )22, 
        (flex_int32_t const   )23,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 431 "fonts.c"
static flex_int32_t const   yy_meta___0[24]  = 
#line 431
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 438 "fonts.c"
static flex_int16_t const   yy_base___0[62]  = 
#line 438
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )10, 
        (flex_int16_t const   )20,      (flex_int16_t const   )83,      (flex_int16_t const   )79,      (flex_int16_t const   )84, 
        (flex_int16_t const   )2,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )77, 
        (flex_int16_t const   )60,      (flex_int16_t const   )75,      (flex_int16_t const   )65,      (flex_int16_t const   )74, 
        (flex_int16_t const   )84,      (flex_int16_t const   )5,      (flex_int16_t const   )1,      (flex_int16_t const   )60, 
        (flex_int16_t const   )0,      (flex_int16_t const   )71,      (flex_int16_t const   )12,      (flex_int16_t const   )68, 
        (flex_int16_t const   )67,      (flex_int16_t const   )65,      (flex_int16_t const   )0,      (flex_int16_t const   )65, 
        (flex_int16_t const   )6,      (flex_int16_t const   )64,      (flex_int16_t const   )42,      (flex_int16_t const   )53, 
        (flex_int16_t const   )7,      (flex_int16_t const   )44,      (flex_int16_t const   )13,      (flex_int16_t const   )36, 
        (flex_int16_t const   )21,      (flex_int16_t const   )47,      (flex_int16_t const   )18,      (flex_int16_t const   )35, 
        (flex_int16_t const   )31,      (flex_int16_t const   )28,      (flex_int16_t const   )33,      (flex_int16_t const   )28, 
        (flex_int16_t const   )23,      (flex_int16_t const   )29,      (flex_int16_t const   )34,      (flex_int16_t const   )32, 
        (flex_int16_t const   )35,      (flex_int16_t const   )23,      (flex_int16_t const   )38,      (flex_int16_t const   )84, 
        (flex_int16_t const   )39,      (flex_int16_t const   )41,      (flex_int16_t const   )40,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )61,      (flex_int16_t const   )63,      (flex_int16_t const   )65, 
        (flex_int16_t const   )0,      (flex_int16_t const   )67};
#line 449 "fonts.c"
static flex_int16_t const   yy_def___0[62]  = 
#line 449
  {      (flex_int16_t const   )0,      (flex_int16_t const   )57,      (flex_int16_t const   )57,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )56,      (flex_int16_t const   )59,      (flex_int16_t const   )56, 
        (flex_int16_t const   )59,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )59, 
        (flex_int16_t const   )56,      (flex_int16_t const   )59,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )60,      (flex_int16_t const   )56,      (flex_int16_t const   )59,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )60,      (flex_int16_t const   )56, 
        (flex_int16_t const   )59,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )59,      (flex_int16_t const   )56,      (flex_int16_t const   )59,      (flex_int16_t const   )56, 
        (flex_int16_t const   )59,      (flex_int16_t const   )56,      (flex_int16_t const   )59,      (flex_int16_t const   )56, 
        (flex_int16_t const   )59,      (flex_int16_t const   )56,      (flex_int16_t const   )59,      (flex_int16_t const   )56, 
        (flex_int16_t const   )59,      (flex_int16_t const   )56,      (flex_int16_t const   )59,      (flex_int16_t const   )56, 
        (flex_int16_t const   )59,      (flex_int16_t const   )56,      (flex_int16_t const   )59,      (flex_int16_t const   )56, 
        (flex_int16_t const   )59,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )56, 
        (flex_int16_t const   )0,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56};
#line 460 "fonts.c"
static flex_int16_t const   yy_nxt___0[108]  = 
#line 460
  {      (flex_int16_t const   )0,      (flex_int16_t const   )26,      (flex_int16_t const   )56,      (flex_int16_t const   )7, 
        (flex_int16_t const   )7,      (flex_int16_t const   )16,      (flex_int16_t const   )23,      (flex_int16_t const   )24, 
        (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )10,      (flex_int16_t const   )34,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )22, 
        (flex_int16_t const   )13,      (flex_int16_t const   )16,      (flex_int16_t const   )14,      (flex_int16_t const   )10, 
        (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )16,      (flex_int16_t const   )11, 
        (flex_int16_t const   )12,      (flex_int16_t const   )32,      (flex_int16_t const   )13,      (flex_int16_t const   )36, 
        (flex_int16_t const   )14,      (flex_int16_t const   )28,      (flex_int16_t const   )16,      (flex_int16_t const   )38, 
        (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )40, 
        (flex_int16_t const   )42,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )55, 
        (flex_int16_t const   )55,      (flex_int16_t const   )51,      (flex_int16_t const   )46,      (flex_int16_t const   )49, 
        (flex_int16_t const   )47,      (flex_int16_t const   )45,      (flex_int16_t const   )44,      (flex_int16_t const   )43, 
        (flex_int16_t const   )41,      (flex_int16_t const   )52,      (flex_int16_t const   )50,      (flex_int16_t const   )48, 
        (flex_int16_t const   )39,      (flex_int16_t const   )37,      (flex_int16_t const   )35,      (flex_int16_t const   )31, 
        (flex_int16_t const   )33,      (flex_int16_t const   )53,      (flex_int16_t const   )6,      (flex_int16_t const   )6, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )15,      (flex_int16_t const   )15, 
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )29,      (flex_int16_t const   )31, 
        (flex_int16_t const   )30,      (flex_int16_t const   )24,      (flex_int16_t const   )29,      (flex_int16_t const   )27, 
        (flex_int16_t const   )25,      (flex_int16_t const   )16,      (flex_int16_t const   )21,      (flex_int16_t const   )20, 
        (flex_int16_t const   )19,      (flex_int16_t const   )18,      (flex_int16_t const   )16,      (flex_int16_t const   )56, 
        (flex_int16_t const   )5,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56};
#line 476 "fonts.c"
static flex_int16_t const   yy_chk___0[108]  = 
#line 476
  {      (flex_int16_t const   )0,      (flex_int16_t const   )60,      (flex_int16_t const   )0,      (flex_int16_t const   )1, 
        (flex_int16_t const   )2,      (flex_int16_t const   )8,      (flex_int16_t const   )18,      (flex_int16_t const   )18, 
        (flex_int16_t const   )17,      (flex_int16_t const   )28,      (flex_int16_t const   )32,      (flex_int16_t const   )1, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )32,      (flex_int16_t const   )22, 
        (flex_int16_t const   )34,      (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )17, 
        (flex_int16_t const   )3,      (flex_int16_t const   )38,      (flex_int16_t const   )3,      (flex_int16_t const   )4, 
        (flex_int16_t const   )36,      (flex_int16_t const   )8,      (flex_int16_t const   )44,      (flex_int16_t const   )4, 
        (flex_int16_t const   )4,      (flex_int16_t const   )28,      (flex_int16_t const   )4,      (flex_int16_t const   )34, 
        (flex_int16_t const   )4,      (flex_int16_t const   )22,      (flex_int16_t const   )40,      (flex_int16_t const   )36, 
        (flex_int16_t const   )42,      (flex_int16_t const   )46,      (flex_int16_t const   )48,      (flex_int16_t const   )38, 
        (flex_int16_t const   )40,      (flex_int16_t const   )50,      (flex_int16_t const   )52,      (flex_int16_t const   )54, 
        (flex_int16_t const   )53,      (flex_int16_t const   )49,      (flex_int16_t const   )44,      (flex_int16_t const   )47, 
        (flex_int16_t const   )45,      (flex_int16_t const   )43,      (flex_int16_t const   )42,      (flex_int16_t const   )41, 
        (flex_int16_t const   )39,      (flex_int16_t const   )50,      (flex_int16_t const   )48,      (flex_int16_t const   )46, 
        (flex_int16_t const   )37,      (flex_int16_t const   )35,      (flex_int16_t const   )33,      (flex_int16_t const   )31, 
        (flex_int16_t const   )30,      (flex_int16_t const   )52,      (flex_int16_t const   )57,      (flex_int16_t const   )57, 
        (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )59,      (flex_int16_t const   )59, 
        (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )29,      (flex_int16_t const   )27, 
        (flex_int16_t const   )25,      (flex_int16_t const   )24,      (flex_int16_t const   )23,      (flex_int16_t const   )21, 
        (flex_int16_t const   )19,      (flex_int16_t const   )15,      (flex_int16_t const   )14,      (flex_int16_t const   )13, 
        (flex_int16_t const   )12,      (flex_int16_t const   )11,      (flex_int16_t const   )6,      (flex_int16_t const   )5, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56};
#line 493 "fonts.c"
static flex_int32_t const   yy_rule_can_match_eol___0[11]  = 
#line 493
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )0};
#line 497 "fonts.c"
static yy_state_type yy_last_accepting_state___0  ;
#line 498 "fonts.c"
static char *yy_last_accepting_cpos___0  ;
#line 500
int afm_flex_debug ;
#line 501 "fonts.c"
int afm_flex_debug  =    0;
#line 48 "/home/ysko/Works/test-src/a2ps-4.14/lib/fonts.h"
void font_info_add(struct a2ps_job *job___0 , char const   *key ) ;
#line 50
int font_exists(struct a2ps_job *job___0 , char const   *key ) ;
#line 51
int font_is_to_reencode(struct a2ps_job *job___0  __attribute__((__unused__)) , char const   *key ) ;
#line 53
void font_info_get_wx_for_vector(struct a2ps_job *job___0 , char const   *key , char **vector ,
                                 unsigned int *wx ) ;
#line 71 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.h"
char **required_fonts_get(struct a2ps_job *job___0 ) ;
#line 83 "fonts.l"
struct pair_htable *fonts_map_new(void) 
{ 
  struct pair_htable *tmp ;

  {
  {
#line 86
  tmp = pair_table_new();
  }
#line 86
  return (tmp);
}
}
#line 89 "fonts.l"
void fonts_map_free(struct pair_htable *table ) 
{ 


  {
  {
#line 92
  pair_table_free(table);
  }
#line 93
  return;
}
}
#line 107 "fonts.l"
static char const   *fonts_map_resolve_alias(struct pair_htable *fonts_map , char const   *fontname ) 
{ 
  char *res___2 ;

  {
  {
#line 112
  res___2 = pair_get(fonts_map, fontname);
  }
#line 113
  if (res___2) {
#line 114
    return ((char const   *)res___2);
  } else {
#line 117
    return (fontname);
  }
}
}
#line 123 "fonts.l"
static int load_fonts_map(struct a2ps_job *job___0 , char const   *file ) 
{ 
  int tmp ;

  {
  {
#line 126
  tmp = pair_table_load(job___0->fonts_map, file);
  }
#line 126
  return (tmp);
}
}
#line 132 "fonts.l"
int load_main_fonts_map(struct a2ps_job *job___0 ) 
{ 
  char *file ;
  char *__cil_tmp3 ;

  {
  {
#line 138
  file = xpw_find_file((char * const  *)job___0->common.path, "fonts.map", (char const   *)((void *)0));
#line 139
  load_fonts_map(job___0, (char const   *)file);
#line 140
  free((void *)file);
  }
#line 141
  return (1);
}
}
#line 167 "fonts.l"
static unsigned int last_wx_read  ;
#line 168 "fonts.l"
static int last_index_read  ;
#line 171 "fonts.l"
static struct font_info *font_info_being_parsed  =    (struct font_info *)((void *)0);
#line 173
static void wx_entry_add(struct hash_table_s *table , char const   *glyph , int the_index ,
                         unsigned int wx ) ;
#line 177
int afmlex(void) ;
#line 708 "fonts.c"
static int yy_init_globals___0(void) ;
#line 718
int afmwrap(void) ;
#line 839 "fonts.c"
int afmlex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  int yyl ;
  char *cursor ;
  char *tmp___0 ;
  char *cursor___0 ;
  char *tmp___1 ;
  char *cursor___1 ;
  char *tmp___2 ;
  char *cursor___2 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp19 ;

  {
#line 850
  if (! yy_init___0) {
#line 852
    yy_init___0 = 1;
#line 858
    if (! yy_start___0) {
#line 859
      yy_start___0 = 1;
    }
#line 861
    if (! afmin) {
#line 862
      afmin = stdin;
    }
#line 864
    if (! afmout) {
#line 865
      afmout = stdout;
    }
#line 867
    if (yy_buffer_stack___0) {
#line 867
      tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
    } else {
#line 867
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 867
    if (! tmp) {
      {
#line 868
      afmensure_buffer_stack();
#line 869
      *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = afm_create_buffer(afmin,
                                                                           16384);
      }
    }
    {
#line 873
    afm_load_buffer_state();
    }
  }
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 878
    yy_cp = yy_c_buf_p___0;
#line 881
    *yy_cp = yy_hold_char___0;
#line 886
    yy_bp = yy_cp;
#line 888
    yy_current_state = yy_start___0;
    yy_match: 
    {
#line 890
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 892
      yy_c = (YY_CHAR )yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
#line 893
      if (yy_accept___0[yy_current_state]) {
#line 895
        yy_last_accepting_state___0 = yy_current_state;
#line 896
        yy_last_accepting_cpos___0 = yy_cp;
      }
      {
#line 898
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 898
        if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 898
          goto while_break___1;
        }
#line 900
        yy_current_state = (int )yy_def___0[yy_current_state];
#line 901
        if (yy_current_state >= 57) {
#line 902
          yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 904
      yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 905
      yy_cp ++;
#line 890
      if (! ((int const   )yy_base___0[yy_current_state] != 84)) {
#line 890
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 910
    yy_act = (int )yy_accept___0[yy_current_state];
#line 911
    if (yy_act == 0) {
#line 913
      yy_cp = yy_last_accepting_cpos___0;
#line 914
      yy_current_state = yy_last_accepting_state___0;
#line 915
      yy_act = (int )yy_accept___0[yy_current_state];
    }
#line 918
    afmtext = yy_bp;
#line 918
    afmleng = (int )((size_t )(yy_cp - yy_bp));
#line 918
    yy_hold_char___0 = *yy_cp;
#line 918
    *yy_cp = (char )'\000';
#line 918
    yy_c_buf_p___0 = yy_cp;
#line 920
    if (yy_act != 11) {
#line 920
      if (yy_rule_can_match_eol___0[yy_act]) {
#line 923
        yyl = 0;
        {
#line 923
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 923
          if (! (yyl < afmleng)) {
#line 923
            goto while_break___2;
          }
#line 924
          if ((int )*(afmtext + yyl) == 10) {
#line 926
            afmlineno ++;
          }
#line 923
          yyl ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    do_action: 
    {
#line 934
    if (yy_act == 0) {
#line 934
      goto case_0;
    }
#line 941
    if (yy_act == 1) {
#line 941
      goto case_1;
    }
#line 194
    if (yy_act == 2) {
#line 194 "fonts.l"
      goto case_2;
    }
#line 197
    if (yy_act == 3) {
#line 197
      goto case_3;
    }
#line 206
    if (yy_act == 4) {
#line 206
      goto case_4;
    }
#line 214
    if (yy_act == 5) {
#line 214
      goto case_5;
    }
#line 223
    if (yy_act == 6) {
#line 223
      goto case_6;
    }
#line 231
    if (yy_act == 7) {
#line 231
      goto case_7;
    }
#line 237
    if (yy_act == 8) {
#line 237
      goto case_8;
    }
#line 239
    if (yy_act == 9) {
#line 239
      goto case_9;
    }
#line 241
    if (yy_act == 10) {
#line 241
      goto case_10;
    }
#line 1027
    if (yy_act == 13) {
#line 1027 "fonts.c"
      goto case_13;
    }
#line 1027
    if (yy_act == 12) {
#line 1027
      goto case_13;
    }
#line 1030
    if (yy_act == 11) {
#line 1030
      goto case_11;
    }
#line 1152
    goto switch_default;
    case_0: /* CIL Label */ 
#line 936
    *yy_cp = yy_hold_char___0;
#line 937
    yy_cp = yy_last_accepting_cpos___0;
#line 938
    yy_current_state = yy_last_accepting_state___0;
#line 939
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 192 "fonts.l"
    yy_start___0 = 3;
#line 193
    goto switch_break;
    case_2: /* CIL Label */ ;
#line 195
    goto switch_break;
    case_3: /* CIL Label */ 
#line 201
    yy_start___0 = 1;
#line 203
    return (0);
#line 205
    goto switch_break;
    case_4: /* CIL Label */ 
#line 207
    cursor = afmtext + 3;
#line 209
    last_index_read = (int )*(afmtext + 2) - 48;
    {
#line 210
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 210
      if (! *cursor) {
#line 210
        goto while_break___3;
      }
#line 211
      tmp___0 = cursor;
#line 211
      cursor ++;
#line 211
      last_index_read = (10 * last_index_read + (int )*tmp___0) - 48;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 213
    goto switch_break;
    case_5: /* CIL Label */ 
#line 215
    cursor___0 = afmtext + 4;
#line 217
    last_index_read = (int )*(afmtext + 3) - 48;
    {
#line 218
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 218
      if (! *cursor___0) {
#line 218
        goto while_break___4;
      }
#line 219
      tmp___1 = cursor___0;
#line 219
      cursor___0 ++;
#line 219
      last_index_read = (10 * last_index_read + (int )*tmp___1) - 48;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 220
    last_index_read = - last_index_read;
#line 222
    goto switch_break;
    case_6: /* CIL Label */ 
#line 224
    cursor___1 = afmtext + 4;
#line 226
    last_wx_read = (unsigned int )((int )*(afmtext + 3) - 48);
    {
#line 227
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 227
      if (! *cursor___1) {
#line 227
        goto while_break___5;
      }
#line 228
      tmp___2 = cursor___1;
#line 228
      cursor___1 ++;
#line 228
      last_wx_read = (10U * last_wx_read + (unsigned int )*tmp___2) - 48U;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 230
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 232
    cursor___2 = afmtext + 2;
#line 233
    wx_entry_add(font_info_being_parsed->wx, (char const   *)cursor___2, last_index_read,
                 last_wx_read);
    }
#line 236
    goto switch_break;
    case_8: /* CIL Label */ ;
#line 238
    goto switch_break;
    case_9: /* CIL Label */ ;
#line 239
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 241
    fwrite((void const   */* __restrict  */)afmtext, (size_t )afmleng, (size_t )1,
           (FILE */* __restrict  */)afmout);
    }
#line 242
    goto switch_break;
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 1028 "fonts.c"
    return (0);
    case_11: /* CIL Label */ 
#line 1033
    yy_amount_of_matched_text = (int )(yy_cp - afmtext) - 1;
#line 1036
    *yy_cp = yy_hold_char___0;
#line 1039
    if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status == 0) {
#line 1050
      yy_n_chars___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars;
#line 1051
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_input_file = afmin;
#line 1052
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status = 1;
    }
#line 1062
    if ((unsigned long )yy_c_buf_p___0 <= (unsigned long )((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + yy_n_chars___0)) {
      {
#line 1066
      yy_c_buf_p___0 = afmtext + yy_amount_of_matched_text;
#line 1068
      yy_current_state = yy_get_previous_state___0();
#line 1079
      yy_next_state = yy_try_NUL_trans___0(yy_current_state);
#line 1081
      yy_bp = afmtext + 0;
      }
#line 1083
      if (yy_next_state) {
#line 1086
        yy_c_buf_p___0 ++;
#line 1086
        yy_cp = yy_c_buf_p___0;
#line 1087
        yy_current_state = yy_next_state;
#line 1088
        goto yy_match;
      } else {
#line 1093
        yy_cp = yy_c_buf_p___0;
#line 1094
        goto yy_find_action;
      }
    } else {
      {
#line 1098
      tmp___3 = yy_get_next_buffer___0();
      }
      {
#line 1100
      if (tmp___3 == 1) {
#line 1100
        goto case_1___0;
      }
#line 1129
      if (tmp___3 == 0) {
#line 1129
        goto case_0___0;
      }
#line 1139
      if (tmp___3 == 2) {
#line 1139
        goto case_2___0;
      }
#line 1098
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1102
      yy_did_buffer_switch_on_eof___0 = 0;
#line 1104
      tmp___4 = afmwrap();
      }
#line 1104
      if (tmp___4) {
#line 1115
        yy_c_buf_p___0 = afmtext + 0;
#line 1117
        yy_act = (11 + (yy_start___0 - 1) / 2) + 1;
#line 1118
        goto do_action;
      } else
#line 1123
      if (! yy_did_buffer_switch_on_eof___0) {
        {
#line 1124
        afmrestart(afmin);
        }
      }
#line 1126
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1130
      yy_c_buf_p___0 = afmtext + yy_amount_of_matched_text;
#line 1133
      yy_current_state = yy_get_previous_state___0();
#line 1135
      yy_cp = yy_c_buf_p___0;
#line 1136
      yy_bp = afmtext + 0;
      }
#line 1137
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1140
      yy_c_buf_p___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + yy_n_chars___0;
#line 1143
      yy_current_state = yy_get_previous_state___0();
#line 1145
      yy_cp = yy_c_buf_p___0;
#line 1146
      yy_bp = afmtext + 0;
      }
#line 1147
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1149
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1153
    yy_fatal_error___0("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1166 "fonts.c"
static int yy_get_next_buffer___0(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 1168
  dest = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf;
#line 1169
  source = afmtext;
#line 1173
  if ((unsigned long )yy_c_buf_p___0 > (unsigned long )((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + (yy_n_chars___0 + 1))) {
    {
#line 1174
    yy_fatal_error___0("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1177
  if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_fill_buffer == 0) {
#line 1179
    if (yy_c_buf_p___0 - afmtext == 1L) {
#line 1184
      return (1);
    } else {
#line 1192
      return (2);
    }
  }
#line 1199
  number_to_move = (int )(yy_c_buf_p___0 - afmtext) - 1;
#line 1201
  i = 0;
  {
#line 1201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1201
    if (! (i < number_to_move)) {
#line 1201
      goto while_break;
    }
#line 1202
    tmp = dest;
#line 1202
    dest ++;
#line 1202
    tmp___0 = source;
#line 1202
    source ++;
#line 1202
    *tmp = *tmp___0;
#line 1201
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1204
  if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status == 2) {
#line 1208
    yy_n_chars___0 = 0;
#line 1208
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  } else {
#line 1212
    num_to_read = (int )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1215
      if (! (num_to_read <= 0)) {
#line 1215
        goto while_break___0;
      }
#line 1219
      if (yy_buffer_stack___0) {
#line 1219
        tmp___1 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
      } else {
#line 1219
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1219
      b = tmp___1;
#line 1221
      yy_c_buf_p_offset = (int )(yy_c_buf_p___0 - b->yy_ch_buf);
#line 1224
      if (b->yy_is_our_buffer) {
#line 1226
        new_size = (int )(b->yy_buf_size * 2U);
#line 1228
        if (new_size <= 0) {
#line 1229
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1231
          b->yy_buf_size *= 2U;
        }
        {
#line 1233
        tmp___2 = afmrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1233
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1239
        b->yy_ch_buf = (char *)0;
      }
#line 1241
      if (! b->yy_ch_buf) {
        {
#line 1242
        yy_fatal_error___0("fatal error - scanner input buffer overflow");
        }
      }
#line 1245
      yy_c_buf_p___0 = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1247
      num_to_read = (int )(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1252
    if (num_to_read > 8192) {
#line 1253
      num_to_read = 8192;
    }
#line 1256
    if ((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_is_interactive) {
#line 1256
      c = '*';
#line 1256
      n = (size_t )0;
      {
#line 1256
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1256
        if (n < (size_t )num_to_read) {
          {
#line 1256
          c = _IO_getc(afmin);
          }
#line 1256
          if (c != -1) {
#line 1256
            if (! (c != 10)) {
#line 1256
              goto while_break___1;
            }
          } else {
#line 1256
            goto while_break___1;
          }
        } else {
#line 1256
          goto while_break___1;
        }
#line 1256
        *(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1256
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1256
      if (c == 10) {
#line 1256
        tmp___3 = n;
#line 1256
        n ++;
#line 1256
        *(((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1256
      if (c == -1) {
        {
#line 1256
        tmp___4 = ferror(afmin);
        }
#line 1256
        if (tmp___4) {
          {
#line 1256
          yy_fatal_error___0("input in flex scanner failed");
          }
        }
      }
#line 1256
      yy_n_chars___0 = (int )n;
    } else {
      {
#line 1256
      tmp___5 = __errno_location();
#line 1256
      *tmp___5 = 0;
      }
      {
#line 1256
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1256
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)afmin);
#line 1256
        yy_n_chars___0 = (int )tmp___8;
        }
#line 1256
        if (yy_n_chars___0 == 0) {
          {
#line 1256
          tmp___9 = ferror(afmin);
          }
#line 1256
          if (! tmp___9) {
#line 1256
            goto while_break___2;
          }
        } else {
#line 1256
          goto while_break___2;
        }
        {
#line 1256
        tmp___6 = __errno_location();
        }
#line 1256
        if (*tmp___6 != 4) {
          {
#line 1256
          yy_fatal_error___0("input in flex scanner failed");
          }
#line 1256
          goto while_break___2;
        }
        {
#line 1256
        tmp___7 = __errno_location();
#line 1256
        *tmp___7 = 0;
#line 1256
        clearerr(afmin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1259
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  }
#line 1262
  if (yy_n_chars___0 == 0) {
#line 1264
    if (number_to_move == 0) {
      {
#line 1266
      ret_val = 1;
#line 1267
      afmrestart(afmin);
      }
    } else {
#line 1272
      ret_val = 2;
#line 1273
      (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buffer_status = 2;
    }
  } else {
#line 1279
    ret_val = 0;
  }
#line 1281
  yy_n_chars___0 += number_to_move;
#line 1282
  *((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + yy_n_chars___0) = (char)0;
#line 1283
  *((*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + (yy_n_chars___0 + 1)) = (char)0;
#line 1285
  afmtext = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_ch_buf + 0;
#line 1287
  return (ret_val);
}
}
#line 1292 "fonts.c"
static yy_state_type yy_get_previous_state___0(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1297
  yy_current_state = yy_start___0;
#line 1299
  yy_cp = afmtext + 0;
  {
#line 1299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1299
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p___0)) {
#line 1299
      goto while_break;
    }
#line 1301
    if (*yy_cp) {
#line 1301
      tmp = yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1301
      tmp = (flex_int32_t const   )1;
    }
#line 1301
    yy_c = (YY_CHAR )tmp;
#line 1302
    if (yy_accept___0[yy_current_state]) {
#line 1304
      yy_last_accepting_state___0 = yy_current_state;
#line 1305
      yy_last_accepting_cpos___0 = yy_cp;
    }
    {
#line 1307
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1307
      if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1307
        goto while_break___0;
      }
#line 1309
      yy_current_state = (int )yy_def___0[yy_current_state];
#line 1310
      if (yy_current_state >= 57) {
#line 1311
        yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1313
    yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1299
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1316
  return (yy_current_state);
}
}
#line 1324 "fonts.c"
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1327
  yy_cp = yy_c_buf_p___0;
#line 1329
  yy_c = (YY_CHAR )1;
#line 1330
  if (yy_accept___0[yy_current_state]) {
#line 1332
    yy_last_accepting_state___0 = yy_current_state;
#line 1333
    yy_last_accepting_cpos___0 = yy_cp;
  }
  {
#line 1335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1335
    if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1335
      goto while_break;
    }
#line 1337
    yy_current_state = (int )yy_def___0[yy_current_state];
#line 1338
    if (yy_current_state >= 57) {
#line 1339
      yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1341
  yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1342
  yy_is_jam = yy_current_state == 56;
#line 1344
  if (yy_is_jam) {
#line 1344
    tmp = 0;
  } else {
#line 1344
    tmp = yy_current_state;
  }
#line 1344
  return (tmp);
}
}
#line 1472 "fonts.c"
void afmrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1475
  if (yy_buffer_stack___0) {
#line 1475
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1475
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1475
  if (! tmp) {
    {
#line 1476
    afmensure_buffer_stack();
#line 1477
    *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = afm_create_buffer(afmin, 16384);
    }
  }
#line 1481
  if (yy_buffer_stack___0) {
#line 1481
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1481
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1481
  afm_init_buffer(tmp___0, input_file);
#line 1482
  afm_load_buffer_state();
  }
#line 1483
  return;
}
}
#line 1489 "fonts.c"
void afm_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1497
  afmensure_buffer_stack();
  }
#line 1498
  if (yy_buffer_stack___0) {
#line 1498
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1498
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1498
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1499
    return;
  }
#line 1501
  if (yy_buffer_stack___0) {
#line 1501
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1501
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1501
  if (tmp___0) {
#line 1504
    *yy_c_buf_p___0 = yy_hold_char___0;
#line 1505
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_pos = yy_c_buf_p___0;
#line 1506
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  }
  {
#line 1509
  *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = new_buffer;
#line 1510
  afm_load_buffer_state();
#line 1517
  yy_did_buffer_switch_on_eof___0 = 1;
  }
#line 1518
  return;
}
}
#line 1520 "fonts.c"
static void afm_load_buffer_state(void) 
{ 


  {
#line 1522
  yy_n_chars___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars;
#line 1523
  yy_c_buf_p___0 = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_pos;
#line 1523
  afmtext = yy_c_buf_p___0;
#line 1524
  afmin = (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_input_file;
#line 1525
  yy_hold_char___0 = *yy_c_buf_p___0;
#line 1526
  return;
}
}
#line 1534 "fonts.c"
YY_BUFFER_STATE afm_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1538
  tmp = afmalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1538
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1539
  if (! b) {
    {
#line 1540
    yy_fatal_error___0("out of dynamic memory in afm_create_buffer()");
    }
  }
  {
#line 1542
  b->yy_buf_size = (yy_size_t )size;
#line 1547
  tmp___0 = afmalloc(b->yy_buf_size + 2U);
#line 1547
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1548
  if (! b->yy_ch_buf) {
    {
#line 1549
    yy_fatal_error___0("out of dynamic memory in afm_create_buffer()");
    }
  }
  {
#line 1551
  b->yy_is_our_buffer = 1;
#line 1553
  afm_init_buffer(b, file);
  }
#line 1555
  return (b);
}
}
#line 1562 "fonts.c"
void afm_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1565
  if (! b) {
#line 1566
    return;
  }
#line 1568
  if (yy_buffer_stack___0) {
#line 1568
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1568
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1568
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1569
    *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = (YY_BUFFER_STATE )0;
  }
#line 1571
  if (b->yy_is_our_buffer) {
    {
#line 1572
    afmfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1574
  afmfree((void *)b);
  }
#line 1575
  return;
}
}
#line 1585 "fonts.c"
static void afm_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1588
  tmp = __errno_location();
#line 1588
  oerrno = *tmp;
#line 1590
  afm_flush_buffer(b);
#line 1592
  b->yy_input_file = file;
#line 1593
  b->yy_fill_buffer = 1;
  }
#line 1599
  if (yy_buffer_stack___0) {
#line 1599
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1599
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1599
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1600
    b->yy_bs_lineno = 1;
#line 1601
    b->yy_bs_column = 0;
  }
#line 1604
  if (file) {
    {
#line 1604
    tmp___1 = fileno(file);
#line 1604
    tmp___2 = isatty(tmp___1);
#line 1604
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1604
    b->yy_is_interactive = 0;
  }
  {
#line 1606
  tmp___3 = __errno_location();
#line 1606
  *tmp___3 = oerrno;
  }
#line 1607
  return;
}
}
#line 1613 "fonts.c"
void afm_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1615
  if (! b) {
#line 1616
    return;
  }
#line 1618
  b->yy_n_chars = 0;
#line 1624
  *(b->yy_ch_buf + 0) = (char)0;
#line 1625
  *(b->yy_ch_buf + 1) = (char)0;
#line 1627
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1629
  b->yy_at_bol = 1;
#line 1630
  b->yy_buffer_status = 0;
#line 1632
  if (yy_buffer_stack___0) {
#line 1632
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1632
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1632
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1633
    afm_load_buffer_state();
    }
  }
#line 1634
  return;
}
}
#line 1642 "fonts.c"
void afmpush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1644
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1645
    return;
  }
  {
#line 1647
  afmensure_buffer_stack();
  }
#line 1650
  if (yy_buffer_stack___0) {
#line 1650
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1650
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1650
  if (tmp) {
#line 1653
    *yy_c_buf_p___0 = yy_hold_char___0;
#line 1654
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_buf_pos = yy_c_buf_p___0;
#line 1655
    (*(yy_buffer_stack___0 + yy_buffer_stack_top___0))->yy_n_chars = yy_n_chars___0;
  }
#line 1659
  if (yy_buffer_stack___0) {
#line 1659
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1659
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1659
  if (tmp___0) {
#line 1660
    yy_buffer_stack_top___0 ++;
  }
  {
#line 1661
  *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = new_buffer;
#line 1664
  afm_load_buffer_state();
#line 1665
  yy_did_buffer_switch_on_eof___0 = 1;
  }
#line 1666
  return;
}
}
#line 1672 "fonts.c"
void afmpop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1674
  if (yy_buffer_stack___0) {
#line 1674
    tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1674
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1674
  if (! tmp) {
#line 1675
    return;
  }
#line 1677
  if (yy_buffer_stack___0) {
#line 1677
    tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1677
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1677
  afm_delete_buffer(tmp___0);
#line 1678
  *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1679
  if (yy_buffer_stack_top___0 > 0U) {
#line 1680
    yy_buffer_stack_top___0 --;
  }
#line 1682
  if (yy_buffer_stack___0) {
#line 1682
    tmp___1 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
  } else {
#line 1682
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1682
  if (tmp___1) {
    {
#line 1683
    afm_load_buffer_state();
#line 1684
    yy_did_buffer_switch_on_eof___0 = 1;
    }
  }
#line 1686
  return;
}
}
#line 1691 "fonts.c"
static void afmensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1695
  if (! yy_buffer_stack___0) {
    {
#line 1701
    num_to_alloc = 1;
#line 1702
    tmp = afmalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1702
    yy_buffer_stack___0 = (struct yy_buffer_state **)tmp;
#line 1706
    memset((void *)yy_buffer_stack___0, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1708
    yy_buffer_stack_max___0 = (size_t )num_to_alloc;
#line 1709
    yy_buffer_stack_top___0 = (size_t )0;
    }
#line 1710
    return;
  }
#line 1713
  if (yy_buffer_stack_top___0 >= yy_buffer_stack_max___0 - 1U) {
    {
#line 1716
    grow_size = 8;
#line 1718
    num_to_alloc = (int )(yy_buffer_stack_max___0 + (size_t )grow_size);
#line 1719
    tmp___0 = afmrealloc((void *)yy_buffer_stack___0, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1719
    yy_buffer_stack___0 = (struct yy_buffer_state **)tmp___0;
#line 1725
    memset((void *)(yy_buffer_stack___0 + yy_buffer_stack_max___0), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 1726
    yy_buffer_stack_max___0 = (size_t )num_to_alloc;
    }
  }
#line 1728
  return;
}
}
#line 1736 "fonts.c"
YY_BUFFER_STATE afm_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 1740
  if (size < 2U) {
#line 1744
    return ((YY_BUFFER_STATE )0);
  } else
#line 1740
  if ((int )*(base + (size - 2U)) != 0) {
#line 1744
    return ((YY_BUFFER_STATE )0);
  } else
#line 1740
  if ((int )*(base + (size - 1U)) != 0) {
#line 1744
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1746
  tmp = afmalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1746
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1747
  if (! b) {
    {
#line 1748
    yy_fatal_error___0("out of dynamic memory in afm_scan_buffer()");
    }
  }
  {
#line 1750
  b->yy_buf_size = size - 2U;
#line 1751
  tmp___0 = base;
#line 1751
  b->yy_ch_buf = tmp___0;
#line 1751
  b->yy_buf_pos = tmp___0;
#line 1752
  b->yy_is_our_buffer = 0;
#line 1753
  b->yy_input_file = (FILE *)0;
#line 1754
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1755
  b->yy_is_interactive = 0;
#line 1756
  b->yy_at_bol = 1;
#line 1757
  b->yy_fill_buffer = 0;
#line 1758
  b->yy_buffer_status = 0;
#line 1760
  afm_switch_to_buffer(b);
  }
#line 1762
  return (b);
}
}
#line 1773 "fonts.c"
YY_BUFFER_STATE afm_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1776
  tmp = strlen(yystr);
#line 1776
  tmp___0 = afm_scan_bytes(yystr, (int )tmp);
  }
#line 1776
  return (tmp___0);
}
}
#line 1786 "fonts.c"
YY_BUFFER_STATE afm_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1794
  n = (yy_size_t )(_yybytes_len + 2);
#line 1795
  tmp = afmalloc(n);
#line 1795
  buf___0 = (char *)tmp;
  }
#line 1796
  if (! buf___0) {
    {
#line 1797
    yy_fatal_error___0("out of dynamic memory in afm_scan_bytes()");
    }
  }
#line 1799
  i = 0;
  {
#line 1799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1799
    if (! (i < _yybytes_len)) {
#line 1799
      goto while_break;
    }
#line 1800
    *(buf___0 + i) = (char )*(yybytes + i);
#line 1799
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1802
  tmp___0 = (char)0;
#line 1802
  *(buf___0 + (_yybytes_len + 1)) = tmp___0;
#line 1802
  *(buf___0 + _yybytes_len) = tmp___0;
#line 1804
  b = afm_scan_buffer(buf___0, n);
  }
#line 1805
  if (! b) {
    {
#line 1806
    yy_fatal_error___0("bad buffer in afm_scan_bytes()");
    }
  }
#line 1811
  b->yy_is_our_buffer = 1;
#line 1813
  return (b);
}
}
#line 1820 "fonts.c"
static void yy_fatal_error___0(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1822
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1823
  exit(2);
  }
}
}
#line 1848 "fonts.c"
int afmget_lineno(void) 
{ 


  {
#line 1851
  return (afmlineno);
}
}
#line 1857 "fonts.c"
FILE *afmget_in(void) 
{ 


  {
#line 1859
  return (afmin);
}
}
#line 1865 "fonts.c"
FILE *afmget_out(void) 
{ 


  {
#line 1867
  return (afmout);
}
}
#line 1873 "fonts.c"
int afmget_leng(void) 
{ 


  {
#line 1875
  return (afmleng);
}
}
#line 1882 "fonts.c"
char *afmget_text(void) 
{ 


  {
#line 1884
  return (afmtext);
}
}
#line 1891 "fonts.c"
void afmset_lineno(int line_number ) 
{ 


  {
#line 1894
  afmlineno = line_number;
#line 1895
  return;
}
}
#line 1903 "fonts.c"
void afmset_in(FILE *in_str ) 
{ 


  {
#line 1905
  afmin = in_str;
#line 1906
  return;
}
}
#line 1908 "fonts.c"
void afmset_out(FILE *out_str ) 
{ 


  {
#line 1910
  afmout = out_str;
#line 1911
  return;
}
}
#line 1913 "fonts.c"
int afmget_debug(void) 
{ 


  {
#line 1915
  return (afm_flex_debug);
}
}
#line 1918 "fonts.c"
void afmset_debug(int bdebug ) 
{ 


  {
#line 1920
  afm_flex_debug = bdebug;
#line 1921
  return;
}
}
#line 1923 "fonts.c"
static int yy_init_globals___0(void) 
{ 


  {
#line 1930
  afmlineno = 1;
#line 1932
  yy_buffer_stack___0 = (YY_BUFFER_STATE *)0;
#line 1933
  yy_buffer_stack_top___0 = (size_t )0;
#line 1934
  yy_buffer_stack_max___0 = (size_t )0;
#line 1935
  yy_c_buf_p___0 = (char *)0;
#line 1936
  yy_init___0 = 0;
#line 1937
  yy_start___0 = 0;
#line 1944
  afmin = (FILE *)0;
#line 1945
  afmout = (FILE *)0;
#line 1951
  return (0);
}
}
#line 1955 "fonts.c"
int afmlex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1959
    if (yy_buffer_stack___0) {
#line 1959
      tmp___0 = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
    } else {
#line 1959
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1959
    if (! tmp___0) {
#line 1959
      goto while_break;
    }
#line 1960
    if (yy_buffer_stack___0) {
#line 1960
      tmp = *(yy_buffer_stack___0 + yy_buffer_stack_top___0);
    } else {
#line 1960
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 1960
    afm_delete_buffer(tmp);
#line 1961
    *(yy_buffer_stack___0 + yy_buffer_stack_top___0) = (YY_BUFFER_STATE )((void *)0);
#line 1962
    afmpop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1966
  afmfree((void *)yy_buffer_stack___0);
#line 1967
  yy_buffer_stack___0 = (YY_BUFFER_STATE *)((void *)0);
#line 1971
  yy_init_globals___0();
  }
#line 1973
  return (0);
}
}
#line 2000 "fonts.c"
void *afmalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2002
  tmp = malloc(size);
  }
#line 2002
  return (tmp);
}
}
#line 2005 "fonts.c"
void *afmrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2014
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2014
  return (tmp);
}
}
#line 2017 "fonts.c"
void afmfree(void *ptr ) 
{ 


  {
  {
#line 2019
  free((void *)((char *)ptr));
  }
#line 2020
  return;
}
}
#line 243 "fonts.l"
int afmwrap(void) 
{ 


  {
#line 246
  return (1);
}
}
#line 255 "fonts.l"
static unsigned long wx_entry_hash_1(struct wx_entry *wx_entry ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    result = 0UL;
    {
#line 258
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 258
      kk = (unsigned char const   *)wx_entry->glyph - 1;
      {
#line 258
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 258
        kk ++;
#line 258
        if (! *kk) {
#line 258
          goto while_break___1;
        }
#line 258
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 258
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    return (result);
#line 258
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return (0UL);
}
}
#line 261 "fonts.l"
static unsigned long wx_entry_hash_2(struct wx_entry *wx_entry ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    result = 0UL;
    {
#line 264
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 264
      kk = (unsigned char const   *)wx_entry->glyph - 1;
      {
#line 264
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 264
        kk ++;
#line 264
        if (! *kk) {
#line 264
          goto while_break___1;
        }
#line 264
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 264
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 264
    return (result);
#line 264
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return (0UL);
}
}
#line 267 "fonts.l"
static int wx_entry_hash_cmp(struct wx_entry *x , struct wx_entry *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 270
      xx = (unsigned char const   *)x->glyph - 1;
#line 270
      yy = (unsigned char const   *)y->glyph - 1;
      {
#line 270
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 270
        xx ++;
#line 270
        if ((int const   )*xx == 0) {
#line 270
          yy ++;
#line 270
          goto while_break___1;
        }
#line 270
        yy ++;
#line 270
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 270
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 270
      result = (int )((int const   )*xx - (int const   )*yy);
#line 270
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 270
    return (result);
#line 270
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  return (0);
}
}
#line 288 "fonts.l"
static int wx_entry_hash_index_qcmp(struct wx_entry **x , struct wx_entry **y ) 
{ 


  {
#line 291
  return ((*y)->index - (*x)->index);
}
}
#line 297 "fonts.l"
static struct hash_table_s *wx_entry_table_new(void) 
{ 
  struct hash_table_s *res___2 ;
  void *tmp ;

  {
  {
#line 302
  tmp = xmalloc((size_t )sizeof(struct hash_table_s ));
#line 302
  res___2 = (struct hash_table_s *)tmp;
#line 303
  hash_init(res___2, 8UL, (unsigned long (*)(void const   *key ))(& wx_entry_hash_1),
            (unsigned long (*)(void const   *key ))(& wx_entry_hash_2), (int (*)(void const   *x ,
                                                                                 void const   *y ))(& wx_entry_hash_cmp));
  }
#line 307
  return (res___2);
}
}
#line 313 "fonts.l"
static void hash_free_wx_entry(struct wx_entry *wx_entry ) 
{ 


  {
  {
#line 316
  free((void *)wx_entry->glyph);
#line 317
  free((void *)wx_entry);
  }
#line 318
  return;
}
}
#line 323 "fonts.l"
static void wx_entry_table_free(struct hash_table_s *table ) 
{ 


  {
  {
#line 326
  hash_free(table, (void (*)(void const   *item ))(& hash_free_wx_entry));
#line 327
  free((void *)table);
  }
#line 328
  return;
}
}
#line 334 "fonts.l"
static void wx_entry_add(struct hash_table_s *table , char const   *glyph , int the_index ,
                         unsigned int wx ) 
{ 
  struct wx_entry *item ;
  struct wx_entry token___1 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 340
  token___1.glyph = (char *)glyph;
#line 341
  tmp = hash_find_item(table, (void const   *)(& token___1));
#line 341
  item = (struct wx_entry *)tmp;
  }
#line 343
  if (item) {
#line 347
    return;
  } else {
    {
#line 349
    tmp___0 = xmalloc((size_t )sizeof(struct wx_entry ));
#line 349
    item = (struct wx_entry *)tmp___0;
#line 350
    item->glyph = xstrdup(glyph);
#line 351
    item->wx = wx;
#line 352
    item->index = the_index;
#line 353
    hash_insert(table, (void *)item);
    }
  }
#line 355
  return;
}
}
#line 362 "fonts.l"
__inline static unsigned int wx_entry_get_wx(struct hash_table_s *table , char const   *glyph ) 
{ 
  struct wx_entry *item ;
  struct wx_entry token___1 ;
  void *tmp ;

  {
  {
#line 368
  token___1.glyph = (char *)glyph;
#line 369
  tmp = hash_find_item(table, (void const   *)(& token___1));
#line 369
  item = (struct wx_entry *)tmp;
  }
#line 371
  if (item) {
#line 372
    return (item->wx);
  }
#line 374
  return (0U);
}
}
#line 425 "fonts.l"
__inline static struct wx_entry **wx_entry_get_in_index_order(struct hash_table_s *table ) 
{ 
  void **tmp ;

  {
  {
#line 428
  tmp = hash_dump(table, (void **)((void *)0), (int (*)(void const   *x , void const   *y ))(& wx_entry_hash_index_qcmp));
  }
#line 428
  return ((struct wx_entry **)tmp);
}
}
#line 439 "fonts.l"
static unsigned long font_info_hash_1(struct font_info *font_info ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    result = 0UL;
    {
#line 442
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 442
      kk = (unsigned char const   *)font_info->key - 1;
      {
#line 442
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 442
        kk ++;
#line 442
        if (! *kk) {
#line 442
          goto while_break___1;
        }
#line 442
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 442
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 442
    return (result);
#line 442
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  return (0UL);
}
}
#line 445 "fonts.l"
static unsigned long font_info_hash_2(struct font_info *font_info ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    result = 0UL;
    {
#line 448
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 448
      kk = (unsigned char const   *)font_info->key - 1;
      {
#line 448
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 448
        kk ++;
#line 448
        if (! *kk) {
#line 448
          goto while_break___1;
        }
#line 448
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 448
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 448
    return (result);
#line 448
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  return (0UL);
}
}
#line 451 "fonts.l"
static int font_info_hash_cmp(struct font_info *x , struct font_info *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 454
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 454
      xx = (unsigned char const   *)x->key - 1;
#line 454
      yy = (unsigned char const   *)y->key - 1;
      {
#line 454
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 454
        xx ++;
#line 454
        if ((int const   )*xx == 0) {
#line 454
          yy ++;
#line 454
          goto while_break___1;
        }
#line 454
        yy ++;
#line 454
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 454
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 454
      result = (int )((int const   )*xx - (int const   )*yy);
#line 454
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 454
    return (result);
#line 454
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return (0);
}
}
#line 471 "fonts.l"
struct hash_table_s *font_info_table_new(void) 
{ 
  struct hash_table_s *res___2 ;
  void *tmp ;

  {
  {
#line 474
  tmp = xmalloc((size_t )sizeof(struct hash_table_s ));
#line 474
  res___2 = (struct hash_table_s *)tmp;
#line 476
  hash_init(res___2, 8UL, (unsigned long (*)(void const   *key ))(& font_info_hash_1),
            (unsigned long (*)(void const   *key ))(& font_info_hash_2), (int (*)(void const   *x ,
                                                                                  void const   *y ))(& font_info_hash_cmp));
  }
#line 480
  return (res___2);
}
}
#line 486 "fonts.l"
static void hash_free_font_info(struct font_info *font_info ) 
{ 


  {
  {
#line 489
  free((void *)font_info->key);
#line 490
  wx_entry_table_free(font_info->wx);
#line 491
  free((void *)font_info);
  }
#line 492
  return;
}
}
#line 497 "fonts.l"
void font_info_table_free(struct hash_table_s *table ) 
{ 


  {
  {
#line 500
  hash_free(table, (void (*)(void const   *item ))(& hash_free_font_info));
#line 501
  free((void *)table);
  }
#line 502
  return;
}
}
#line 507 "fonts.l"
__inline static struct font_info *font_info_new(char const   *key ) 
{ 
  struct font_info *res___2 ;
  void *tmp ;

  {
  {
#line 510
  tmp = xmalloc((size_t )sizeof(struct font_info ));
#line 510
  res___2 = (struct font_info *)tmp;
#line 512
  res___2->key = xstrdup(key);
#line 513
  res___2->wx = wx_entry_table_new();
  }
#line 515
  return (res___2);
}
}
#line 521 "fonts.l"
static void font_info_finalize(struct a2ps_job *job___0 , struct font_info *font ) 
{ 
  char *file ;
  char const   *filename ;
  FILE *stream ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 528
  afmlineno = 0;
#line 531
  filename = fonts_map_resolve_alias(job___0->fonts_map, (char const   *)font->key);
#line 532
  file = xpw_find_file((char * const  *)job___0->common.path, filename, ".afm");
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if ((unsigned int )(((1 << 8) | (1 << 6)) | (1 << 11)) & msg_verbosity) {
      {
#line 535
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing file `%s\'\n",
              file);
      }
    }
#line 535
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 537
  stream = xrfopen((char const   *)file);
#line 541
  font_info_being_parsed = font;
#line 542
  afmrestart(stream);
#line 543
  afmlex();
#line 545
  fclose(stream);
#line 546
  free((void *)file);
  }
#line 547
  return;
}
}
#line 553 "fonts.l"
void font_info_add(struct a2ps_job *job___0 , char const   *key ) 
{ 
  struct font_info *font ;

  {
  {
#line 559
  font = font_info_new(key);
#line 560
  font_info_finalize(job___0, font);
#line 561
  hash_insert(job___0->font_infos, (void *)font);
#line 564
  add_required_font(job___0, key);
  }
#line 565
  return;
}
}
#line 570 "fonts.l"
__inline static struct font_info *font_info_get(struct a2ps_job *job___0 , char const   *key ) 
{ 
  struct font_info token___1 ;
  struct font_info *res___2 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 575
  token___1.key = (char *)key;
#line 576
  tmp = hash_find_item(job___0->font_infos, (void const   *)(& token___1));
#line 576
  res___2 = (struct font_info *)tmp;
  }
#line 577
  if (! res___2) {
    {
#line 578
    font_info_add(job___0, key);
#line 579
    tmp___0 = hash_find_item(job___0->font_infos, (void const   *)(& token___1));
#line 579
    res___2 = (struct font_info *)tmp___0;
    }
  }
#line 581
  return (res___2);
}
}
#line 588 "fonts.l"
int font_is_to_reencode(struct a2ps_job *job___0  __attribute__((__unused__)) , char const   *key ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 591
  tmp = strcmp(key, "Symbol");
  }
#line 591
  if (tmp == 0) {
#line 591
    tmp___0 = 0;
  } else {
#line 591
    tmp___0 = 1;
  }
#line 591
  return (tmp___0);
}
}
#line 598 "fonts.l"
void font_info_get_wx_for_vector(struct a2ps_job *job___0 , char const   *key , char **vector ,
                                 unsigned int *wx ) 
{ 
  struct font_info *font_info ;
  struct font_info *tmp ;
  struct wx_entry **sorted_by_index ;
  int c ;
  int the_index ;
  int tmp___0 ;

  {
  {
#line 604
  tmp = font_info_get(job___0, key);
#line 604
  font_info = tmp;
#line 608
  tmp___0 = font_is_to_reencode(job___0, key);
  }
#line 608
  if (tmp___0) {
#line 612
    c = 0;
    {
#line 612
    while (1) {
      while_continue: /* CIL Label */ ;
#line 612
      if (! (c < 256)) {
#line 612
        goto while_break;
      }
      {
#line 613
      *(wx + c) = wx_entry_get_wx(font_info->wx, (char const   *)*(vector + c));
#line 612
      c ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 618
    c = 0;
    {
#line 618
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 618
      if (! (c < 256)) {
#line 618
        goto while_break___0;
      }
#line 619
      *(wx + c) = 0U;
#line 618
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 620
    sorted_by_index = wx_entry_get_in_index_order(font_info->wx);
#line 621
    c = 0;
    }
    {
#line 621
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 621
      if (! *(sorted_by_index + c)) {
#line 621
        goto while_break___1;
      }
#line 623
      the_index = (*(sorted_by_index + c))->index;
#line 624
      if (0 <= the_index) {
#line 624
        if (the_index < 256) {
#line 625
          *(wx + the_index) = (*(sorted_by_index + c))->wx;
        }
      }
#line 621
      c ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 628
  return;
}
}
#line 633 "fonts.l"
int font_exists(struct a2ps_job *job___0 , char const   *key ) 
{ 
  char const   *filename ;
  int tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 638
  filename = fonts_map_resolve_alias(job___0->fonts_map, key);
#line 639
  tmp = pw_file_exists_p((char * const  *)job___0->common.path, filename, ".afm");
  }
#line 639
  return (tmp);
}
}
#line 645 "fonts.l"
void font_info_table_dump_special_font_setup(FILE *stream , struct a2ps_job *job___0 ) 
{ 
  struct font_info **fonts ;
  int i ;
  void **tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 652
  tmp = hash_dump(job___0->font_infos, (void **)((void *)0), (int (*)(void const   * ,
                                                                      void const   * ))((void *)0));
#line 652
  fonts = (struct font_info **)tmp;
#line 655
  i = 0;
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    if (! *(fonts + i)) {
#line 655
      goto while_break;
    }
    {
#line 656
    tmp___0 = font_is_to_reencode(job___0, (char const   *)(*(fonts + i))->key);
    }
#line 656
    if (! tmp___0) {
      {
#line 657
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"/f%s /%s findfont def\n",
              (*(fonts + i))->key, (*(fonts + i))->key);
      }
    }
#line 655
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  return;
}
}
#line 677 "fonts.l"
__inline static int binary_font_dump_segment(FILE *in , FILE *out ) 
{ 
  enum segment_type segment_type ;
  int magic ;
  size_t length ;
  size_t read_length ;
  size_t length_to_read ;
  unsigned char buf___0[8192] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t i ;
  size_t i___0 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 689
  magic = _IO_getc(in);
  }
#line 691
  if (magic != 128) {
#line 692
    return (1);
  }
  {
#line 695
  tmp = _IO_getc(in);
#line 695
  segment_type = (enum segment_type )tmp;
#line 698
  tmp___0 = _IO_getc(in);
#line 698
  length = (size_t )tmp___0;
#line 699
  tmp___1 = _IO_getc(in);
#line 699
  length += (size_t )(tmp___1 * 256);
#line 700
  tmp___2 = _IO_getc(in);
#line 700
  length += (size_t )((tmp___2 * 256) * 256);
#line 701
  tmp___3 = _IO_getc(in);
#line 701
  length += (size_t )(((tmp___3 * 256) * 256) * 256);
  }
  {
#line 705
  if ((unsigned int )segment_type == 1U) {
#line 705
    goto case_1;
  }
#line 728
  if ((unsigned int )segment_type == 2U) {
#line 728
    goto case_2;
  }
#line 749
  if ((unsigned int )segment_type == 3U) {
#line 749
    goto case_3;
  }
#line 753
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! length) {
#line 706
      goto while_break;
    }
#line 710
    if ((unsigned long )length < sizeof(buf___0)) {
#line 710
      length_to_read = length;
    } else {
#line 710
      length_to_read = (size_t )sizeof(buf___0);
    }
    {
#line 711
    read_length = fread((void */* __restrict  */)(buf___0), (size_t )sizeof(char ),
                        length_to_read, (FILE */* __restrict  */)in);
    }
#line 712
    if (! read_length) {
#line 714
      return (2);
    }
#line 715
    length -= read_length;
#line 716
    i = (size_t )0;
    {
#line 716
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 716
      if (! (i < read_length)) {
#line 716
        goto while_break___0;
      }
      {
#line 719
      if ((int )buf___0[i] == 13) {
#line 719
        goto case_13;
      }
#line 722
      goto switch_default;
      case_13: /* CIL Label */ 
      {
#line 720
      _IO_putc('\n', out);
      }
#line 721
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 723
      _IO_putc((int )buf___0[i], out);
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 716
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 729
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 729
    if (! length) {
#line 729
      goto while_break___1;
    }
#line 733
    if ((unsigned long )length < sizeof(buf___0)) {
#line 733
      length_to_read = length;
    } else {
#line 733
      length_to_read = (size_t )sizeof(buf___0);
    }
    {
#line 734
    read_length = fread((void */* __restrict  */)(buf___0), (size_t )sizeof(char ),
                        length_to_read, (FILE */* __restrict  */)in);
    }
#line 735
    if (! read_length) {
#line 737
      return (2);
    }
#line 738
    length -= read_length;
#line 739
    i___0 = (size_t )0;
    {
#line 739
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 739
      if (! (i___0 < read_length)) {
#line 739
        goto while_break___2;
      }
      {
#line 741
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%02X",
              (int )buf___0[i___0]);
      }
#line 743
      if (! ((i___0 + 1U) % 32U)) {
        {
#line 744
        _IO_putc('\n', out);
        }
      }
#line 739
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 747
  goto switch_break;
  case_3: /* CIL Label */ 
#line 751
  return (1);
  switch_default___0: /* CIL Label */ 
  {
#line 754
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 757
  _IO_putc('\n', out);
  }
#line 758
  return (0);
}
}
#line 765 "fonts.l"
__inline static int binary_font_dump(FILE *in , FILE *out ) 
{ 
  int status ;

  {
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 770
    status = binary_font_dump_segment(in, out);
    }
#line 770
    if (status) {
#line 770
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  if (status == 2) {
#line 774
    return (0);
  } else {
#line 776
    return (1);
  }
}
}
#line 783 "fonts.l"
static int internal_font_file_dump(FILE *in , FILE *out ) 
{ 
  int c ;
  int tmp ;

  {
  {
#line 788
  c = _IO_getc(in);
#line 789
  ungetc(c, in);
  }
#line 790
  if (c == 128) {
    {
#line 793
    tmp = binary_font_dump(in, out);
    }
#line 793
    return (tmp);
  } else {
    {
#line 797
    streams_copy(in, out);
    }
#line 798
    return (1);
  }
}
}
#line 805 "fonts.l"
void dump_fonts(FILE *stream , struct a2ps_job *job___0 ) 
{ 
  FILE *fp ;
  char *filename ;
  char const   *fontname ;
  char **fonts ;
  int i ;
  char *file ;
  char const   *_tmp1_ ;
  char const   *_tmp2_ ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 816
  fonts = required_fonts_get(job___0);
  }
#line 817
  if (! fonts) {
#line 818
    return;
  }
#line 820
  i = 0;
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    if (! *(fonts + i)) {
#line 820
      goto while_break;
    }
    {
#line 823
    fontname = fonts_map_resolve_alias(job___0->fonts_map, (char const   *)*(fonts + i));
#line 827
    filename = pw_find_file((char * const  *)job___0->common.path, fontname, ".pfb");
    }
#line 828
    if (! filename) {
      {
#line 829
      filename = pw_find_file((char * const  *)job___0->common.path, fontname, ".pfa");
      }
    }
#line 830
    if (! filename) {
      {
#line 831
      filename = pw_find_file((char * const  *)job___0->common.path, fontname, ".gsf");
      }
    }
#line 832
    if (! filename) {
      {
#line 837
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 837
        _tmp1_ = fontname;
#line 837
        _tmp2_ = ".pfb";
#line 837
        tmp = strlen(_tmp1_);
#line 837
        tmp___0 = strlen(_tmp2_);
#line 837
        tmp___1 = __builtin_alloca(sizeof(char ) * (unsigned long )((tmp + tmp___0) + 1U));
#line 837
        file = (char *)tmp___1;
        }
        {
#line 837
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 837
          tmp___2 = stpcpy((char */* __restrict  */)file, (char const   */* __restrict  */)fontname);
#line 837
          stpcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)".pfb");
          }
#line 837
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 837
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 838
      tmp___3 = quotearg((char const   *)file);
#line 838
      tmp___4 = gettext("cannot find file `%s\'");
#line 838
      error(0, 0, (char const   *)tmp___4, tmp___3);
      }
      {
#line 839
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 839
        tmp___5 = stpcpy((char */* __restrict  */)file, (char const   */* __restrict  */)fontname);
#line 839
        stpcpy((char */* __restrict  */)tmp___5, (char const   */* __restrict  */)".pfa");
        }
#line 839
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 840
      tmp___6 = quotearg((char const   *)file);
#line 840
      tmp___7 = gettext("cannot find file `%s\'");
#line 840
      error(0, 0, (char const   *)tmp___7, tmp___6);
      }
      {
#line 841
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 841
        tmp___8 = stpcpy((char */* __restrict  */)file, (char const   */* __restrict  */)fontname);
#line 841
        stpcpy((char */* __restrict  */)tmp___8, (char const   */* __restrict  */)".gsf");
        }
#line 841
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 842
      tmp___9 = quotearg((char const   *)file);
#line 842
      tmp___10 = gettext("cannot find file `%s\'");
#line 842
      error(1, 0, (char const   *)tmp___10, tmp___9);
      }
    }
    {
#line 846
    fp = xrfopen((char const   *)filename);
    }
    {
#line 849
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 849
      if ((unsigned int )((1 << 8) | (1 << 6)) & msg_verbosity) {
        {
#line 849
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dumping file `%s\'\n",
                filename);
        }
      }
#line 849
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 850
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%BeginResource: font %s\n",
            *(fonts + i));
#line 851
    tmp___11 = internal_font_file_dump(fp, stream);
    }
#line 851
    if (! tmp___11) {
      {
#line 852
      error(1, 0, "Bad PostScript font file `%s\'\n", filename);
      }
    }
    {
#line 853
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%%%%EndResource\n");
#line 856
    fclose(fp);
#line 857
    free((void *)filename);
#line 820
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 859
  free((void *)fonts);
  }
#line 860
  return;
}
}
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.c"
struct file_job *_a2ps_file_job_new(unsigned char *name , int num , struct tm *run_tm ) 
{ 
  fjob_t *res___2 ;
  void *tmp ;

  {
  {
#line 40
  tmp = xmalloc((size_t )sizeof(fjob_t ));
#line 40
  res___2 = (fjob_t *)tmp;
#line 44
  res___2->name = name;
#line 45
  res___2->delegation_tmpname = (char *)((void *)0);
#line 46
  res___2->stdin_tmpname = (char *)((void *)0);
#line 49
  res___2->type = (char const   *)((void *)0);
#line 51
  res___2->is_toc = (_Bool)0;
#line 54
  res___2->mod_tm = *run_tm;
#line 58
  res___2->printable = (_Bool)1;
#line 61
  res___2->is_stdin = (_Bool)0;
#line 67
  res___2->first_sheet = 0;
#line 68
  res___2->sheets = 0;
#line 69
  res___2->last_sheet = 0;
#line 70
  res___2->first_page = 0;
#line 71
  res___2->pages = 0;
#line 72
  res___2->last_page = 0;
#line 73
  res___2->top_line = 1;
#line 74
  res___2->top_page = 0;
#line 75
  res___2->lines = 1;
#line 76
  res___2->num = num;
  }
#line 78
  return (res___2);
}
}
#line 84 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.c"
void file_job_free(struct file_job *file_job ) 
{ 


  {
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (file_job->delegation_tmpname) {
      {
#line 87
      free((void *)file_job->delegation_tmpname);
      }
    }
#line 87
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (file_job->stdin_tmpname) {
      {
#line 88
      free((void *)file_job->stdin_tmpname);
      }
    }
#line 88
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 89
  free((void *)file_job);
  }
#line 90
  return;
}
}
#line 92 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.c"
void file_job_self_print(struct file_job *file , FILE *stream ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 95
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"File `%s\': Pages %d-%d (%d), Sheets %d-%d (%d)\n",
          file->name, file->first_page, file->last_page, file->pages, file->first_sheet,
          file->last_sheet, file->sheets);
  }
#line 100
  if ((unsigned long )((void const   *)file->stdin_tmpname) == (unsigned long )((void *)0)) {
#line 100
    tmp = "";
  } else {
#line 100
    tmp = (char const   *)file->stdin_tmpname;
  }
#line 100
  if ((unsigned long )((void const   *)file->delegation_tmpname) == (unsigned long )((void *)0)) {
#line 100
    tmp___0 = "";
  } else {
#line 100
    tmp___0 = (char const   *)file->delegation_tmpname;
  }
  {
#line 100
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\tdel-tmp: `%s\', stdin-tmp: `%s\', is_toc: %d",
          tmp___0, tmp, (int )file->is_toc);
  }
#line 105
  return;
}
}
#line 110 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.c"
void file_job_synchronize_sheets(struct a2ps_job *job___0 ) 
{ 
  fjob_t *file ;

  {
#line 113
  file = (struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U));
#line 116
  if (! file->first_sheet) {
#line 117
    file->first_sheet = job___0->sheets;
  }
#line 120
  file->last_sheet = job___0->sheets;
#line 121
  file->sheets = (file->last_sheet - file->first_sheet) + 1;
#line 122
  return;
}
}
#line 127 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.c"
void file_job_synchronize_pages(struct a2ps_job *job___0 ) 
{ 
  fjob_t *file ;

  {
#line 130
  file = (struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U));
#line 133
  if (! file->first_page) {
#line 134
    file->first_page = job___0->pages;
  }
#line 136
  if (! file->top_page) {
#line 137
    file->top_page = 1;
  }
#line 139
  file->last_page = job___0->pages;
#line 140
  file->top_line = ((struct file_job *)*((job___0->jobs)->content + ((job___0->jobs)->len - 1U)))->lines;
#line 142
  file->pages = (file->last_page - file->first_page) + 1;
#line 143
  return;
}
}
#line 148 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.c"
void file_job_unlink_tmpfile(struct file_job *file ) 
{ 


  {
#line 151
  if (file->delegation_tmpname) {
    {
#line 152
    unlink((char const   *)file->delegation_tmpname);
    }
  }
#line 153
  if (file->stdin_tmpname) {
    {
#line 154
    unlink((char const   *)file->stdin_tmpname);
    }
  }
#line 155
  return;
}
}
#line 160 "/home/ysko/Works/test-src/a2ps-4.14/lib/fjobs.c"
int file_name_cmp(struct file_job *f1 , struct file_job *f2 ) 
{ 
  int tmp ;

  {
  {
#line 163
  tmp = strcmp((char const   *)f1->name, (char const   *)f2->name);
  }
#line 163
  return (tmp);
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 93 "/home/ysko/Works/test-src/a2ps-4.14/lib/filtdir.c"
void filterdir(char const   *dir , _Bool (*filter)(char const   *dir , char const   *file ,
                                                   void *filtarg ) , void *filtarg ,
               void (*fun)(char const   *dir , char const   *file , void *filtarg ) ,
               void *arg ) 
{ 
  DIR *dirp ;
  struct dirent *dp ;
  _Bool tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;

  {
  {
#line 101
  dirp = opendir(dir);
  }
#line 102
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 103
    return;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    dp = readdir(dirp);
    }
#line 106
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 106
      goto while_break;
    }
#line 108
    if ((int )dp->d_name[0] != 46) {
#line 108
      goto _L___0;
    } else
#line 108
    if ((int )dp->d_name[1] != 0) {
#line 108
      if ((int )dp->d_name[1] != 46) {
#line 108
        goto _L___0;
      } else
#line 108
      if ((int )dp->d_name[2] != 0) {
        _L___0: /* CIL Label */ 
#line 108
        if (! filter) {
          {
#line 110
          (*fun)(dir, (char const   *)(dp->d_name), arg);
          }
        } else {
          {
#line 108
          tmp = (*filter)(dir, (char const   *)(dp->d_name), filtarg);
          }
#line 108
          if (tmp) {
            {
#line 110
            (*fun)(dir, (char const   *)(dp->d_name), arg);
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  tmp___2 = closedir(dirp);
  }
#line 112
  if (tmp___2) {
    {
#line 113
    tmp___0 = gettext("cannot close directory `%s\'");
#line 113
    tmp___1 = __errno_location();
#line 113
    error(1, *tmp___1, (char const   *)tmp___0, dir);
    }
  }
#line 114
  return;
}
}
#line 60 "/home/ysko/Works/test-src/a2ps-4.14/lib/filalign.h"
char const   *file_align_to_string(file_align_t file_align ) ;
#line 57 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.h"
int argcasematch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                 size_t valsize ) ;
#line 121
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
#line 39 "/home/ysko/Works/test-src/a2ps-4.14/lib/filalign.c"
static char const   * const  file_align_args[8]  = 
#line 39 "/home/ysko/Works/test-src/a2ps-4.14/lib/filalign.c"
  {      (char const   */* const  */)"sheet",      (char const   */* const  */)"page",      (char const   */* const  */)"no",      (char const   */* const  */)"rank", 
        (char const   */* const  */)"virtual",      (char const   */* const  */)"fill",      (char const   */* const  */)"yes",      (char const   */* const  */)0};
#line 48 "/home/ysko/Works/test-src/a2ps-4.14/lib/filalign.c"
static file_align_t const   file_align_types[7]  = {      (file_align_t const   )-1,      (file_align_t const   )-2,      (file_align_t const   )-2,      (file_align_t const   )-3, 
        (file_align_t const   )-4,      (file_align_t const   )-4,      (file_align_t const   )-4};
#line 59 "/home/ysko/Works/test-src/a2ps-4.14/lib/filalign.c"
file_align_t file_align_argmatch(char const   *option , char const   *arg ) 
{ 
  int i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 64
  if (! (sizeof(file_align_args) / sizeof(file_align_args[0]) == sizeof(file_align_types) / sizeof(file_align_types[0]) + 1UL)) {
    {
#line 64
    __assert_fail("(sizeof (((file_align_args))) / sizeof (*((file_align_args)))) == (sizeof (((file_align_types))) / sizeof (*((file_align_types)))) + 1",
                  "/home/ysko/Works/test-src/a2ps-4.14/lib/filalign.c", 64U, "file_align_argmatch");
    }
  }
  {
#line 66
  i = argcasematch(arg, file_align_args, (char const   *)(file_align_types), (size_t )sizeof(file_align_types[0]));
  }
#line 67
  if (i >= 0) {
#line 68
    return ((file_align_t )file_align_types[i]);
  }
  {
#line 70
  i = get_integer_in_range(option, arg, 1, 0, (enum range_type_e )1);
  }
#line 71
  return (i);
}
}
#line 79 "/home/ysko/Works/test-src/a2ps-4.14/lib/filalign.c"
static char buf[25]  ;
#line 76 "/home/ysko/Works/test-src/a2ps-4.14/lib/filalign.c"
char const   *file_align_to_string(file_align_t file_align ) 
{ 
  char const   *tmp ;
  char *__cil_tmp3 ;

  {
#line 81
  if (file_align < 0) {
    {
#line 82
    tmp = argmatch_to_argument((char const   *)(& file_align), file_align_args, (char const   *)(file_align_types),
                               (size_t )sizeof(file_align_types[0]));
    }
#line 82
    return (tmp);
  }
  {
#line 85
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d", file_align);
  }
#line 86
  return ((char const   *)(buf));
}
}
#line 101 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.h"
enum face_e base_faces[11] ;
#line 105
char const   *face_to_string(enum face_e face ) ;
#line 106
void face_self_print(enum face_e face , FILE *stream ) ;
#line 111
int face_eo_font_is_set(struct a2ps_job *job___0 ) ;
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
enum face_e base_faces[11]  = 
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
  {      (enum face_e )0,      (enum face_e )1,      (enum face_e )2,      (enum face_e )3, 
        (enum face_e )4,      (enum face_e )5,      (enum face_e )6,      (enum face_e )7, 
        (enum face_e )8,      (enum face_e )9,      (enum face_e )-1};
#line 56 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
static struct face_and_name  const  face_and_name[12]  = 
#line 56
  {      {"NoFace", (enum face_e )-1}, 
        {"Plain", (enum face_e )0}, 
        {"Keyword", (enum face_e )1}, 
        {"Keyword_strong", (enum face_e )2}, 
        {"Label", (enum face_e )3}, 
        {"Label_strong", (enum face_e )4}, 
        {"String", (enum face_e )5}, 
        {"Symbol", (enum face_e )6}, 
        {"Error", (enum face_e )7}, 
        {"Comment", (enum face_e )8}, 
        {"Comment_strong", (enum face_e )9}, 
        {(char const   *)((void *)0), (enum face_e )-1}};
#line 71 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
enum face_e string_to_face(char const   *string ) 
{ 
  int i ;
  int tmp ;

  {
#line 76
  i = 0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! face_and_name[i].name) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp = strcmp(string, (char const   *)face_and_name[i].name);
    }
#line 77
    if (tmp == 0) {
#line 78
      return ((enum face_e )face_and_name[i].face);
    }
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return ((enum face_e )-1);
}
}
#line 83 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
__inline static char const   *_face_to_string(enum face_e face ) 
{ 
  int i ;
  char *__cil_tmp3 ;

  {
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! face_and_name[i].name) {
#line 88
      goto while_break;
    }
#line 89
    if ((int )face == (int )face_and_name[i].face) {
#line 90
      return ((char const   *)face_and_name[i].name);
    }
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return ("UnknownFace");
}
}
#line 95 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
char const   *face_to_string(enum face_e face ) 
{ 
  char const   *tmp ;

  {
  {
#line 98
  tmp = _face_to_string(face);
  }
#line 98
  return (tmp);
}
}
#line 104 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
void face_self_print(enum face_e face , FILE *stream ) 
{ 
  char const   *tmp ;

  {
  {
#line 107
  tmp = _face_to_string(face);
#line 107
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
  }
#line 108
  return;
}
}
#line 111 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
char const   *face_eo_ps(enum face_e face ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 115
  if ((int )face == 0) {
#line 115
    goto case_0;
  }
#line 117
  if ((int )face == 6) {
#line 117
    goto case_6;
  }
#line 119
  if ((int )face == 1) {
#line 119
    goto case_1;
  }
#line 121
  if ((int )face == 2) {
#line 121
    goto case_2;
  }
#line 123
  if ((int )face == 8) {
#line 123
    goto case_8;
  }
#line 125
  if ((int )face == 9) {
#line 125
    goto case_9;
  }
#line 127
  if ((int )face == 3) {
#line 127
    goto case_3;
  }
#line 129
  if ((int )face == 4) {
#line 129
    goto case_4;
  }
#line 131
  if ((int )face == 5) {
#line 131
    goto case_5;
  }
#line 133
  if ((int )face == 7) {
#line 133
    goto case_7;
  }
#line 135
  goto switch_default;
  case_0: /* CIL Label */ 
#line 116
  return ("p");
  case_6: /* CIL Label */ 
#line 118
  return ("sy");
  case_1: /* CIL Label */ 
#line 120
  return ("k");
  case_2: /* CIL Label */ 
#line 122
  return ("K");
  case_8: /* CIL Label */ 
#line 124
  return ("c");
  case_9: /* CIL Label */ 
#line 126
  return ("C");
  case_3: /* CIL Label */ 
#line 128
  return ("l");
  case_4: /* CIL Label */ 
#line 130
  return ("L");
  case_5: /* CIL Label */ 
#line 132
  return ("str");
  case_7: /* CIL Label */ 
#line 134
  return ("e");
  switch_default: /* CIL Label */ 
  {
#line 136
  error(1, 0, "face_eo_ps: %d", (int )face);
  }
  switch_break: /* CIL Label */ ;
  }
#line 138
  return ((char const   *)0);
}
}
#line 142 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
void check_face_eo_font(struct a2ps_job *job___0 ) 
{ 
  int i ;
  int err ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 146
  err = 0;
#line 148
  i = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! ((int )base_faces[i] != -1)) {
#line 148
      goto while_break;
    }
#line 149
    if (! job___0->face_eo_font[base_faces[i]]) {
      {
#line 150
      err = 1;
#line 151
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: face `",
              program_name);
#line 152
      face_self_print(base_faces[i], stderr);
#line 153
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\' (%d) has no specified font\n",
              (int )base_faces[i]);
      }
    }
#line 148
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  if (err) {
    {
#line 156
    tmp = gettext("incomplete knowledge of faces");
#line 156
    error(1, 0, (char const   *)tmp);
    }
  }
#line 157
  return;
}
}
#line 162 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
int face_eo_font_is_set(struct a2ps_job *job___0 ) 
{ 
  enum face_e f ;
  int res___2 ;

  {
#line 166
  res___2 = 1;
#line 168
  f = (enum face_e )0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! ((int )f <= 9)) {
#line 168
      goto while_break;
    }
#line 169
    if (! job___0->face_eo_font[f]) {
#line 170
      res___2 = 0;
    }
#line 168
    f = (enum face_e )((int )f + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return (res___2);
}
}
#line 176 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
void init_face_eo_font(struct a2ps_job *job___0 ) 
{ 
  enum face_e f ;

  {
#line 180
  f = (enum face_e )0;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((int )f <= 9)) {
#line 180
      goto while_break;
    }
#line 181
    job___0->face_eo_font[f] = (char *)((void *)0);
#line 180
    f = (enum face_e )((int )f + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 184 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
void face_eo_font_free(char **face_eo_font ) 
{ 
  enum face_e f ;

  {
#line 188
  f = (enum face_e )0;
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! ((int )f <= 9)) {
#line 188
      goto while_break;
    }
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 191
      if (*(face_eo_font + f)) {
        {
#line 191
        free((void *)*(face_eo_font + f));
        }
      }
#line 191
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 188
    f = (enum face_e )((int )f + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 194 "/home/ysko/Works/test-src/a2ps-4.14/lib/faces.c"
void face_set_font(struct a2ps_job *job___0 , enum face_e face , char const   *font_name ) 
{ 


  {
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (job___0->face_eo_font[face]) {
      {
#line 197
      free((void *)job___0->face_eo_font[face]);
      }
    }
#line 197
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  job___0->face_eo_font[face] = xstrdup(font_name);
  }
#line 199
  return;
}
}
#line 45 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.h"
unsigned int string_WX(struct a2ps_job *job___0 , unsigned char *string ) ;
#line 53
char const   *encoding_get_name(struct encoding *enc ) ;
#line 55
void encoding_self_print(struct encoding *item , FILE *stream ) ;
#line 88
void list_encodings_short(struct a2ps_job *job___0 , FILE *stream ) ;
#line 89
void list_encodings_long(struct a2ps_job *job___0 , FILE *stream ) ;
#line 90
void list_texinfo_encodings_long(struct a2ps_job *job___0 , FILE *stream ) ;
#line 113 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.h"
void da_qsort_with_arg(struct darray *arr , int (*cmp)(void const   *k1 , void const   *k2 ,
                                                       void const   *arg ) , void const   *arg ) ;
#line 138
int da_str_cmp(char const   *s1 , char const   *s2 ) ;
#line 136 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
struct pair_htable *encodings_map_new(void) 
{ 
  struct pair_htable *tmp ;

  {
  {
#line 139
  tmp = pair_table_new();
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
void encodings_map_free(struct pair_htable *table ) 
{ 


  {
  {
#line 145
  pair_table_free(table);
  }
#line 146
  return;
}
}
#line 151 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static char *encodings_map_resolve_alias(struct pair_htable *encodings_map , char const   *alias ) 
{ 
  char *tmp ;

  {
  {
#line 155
  tmp = pair_get(encodings_map, alias);
  }
#line 155
  return (tmp);
}
}
#line 161 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static int load_encodings_map(struct a2ps_job *job___0 , char const   *file ) 
{ 
  int tmp ;

  {
  {
#line 164
  tmp = pair_table_load(job___0->encodings_map, file);
  }
#line 164
  return (tmp);
}
}
#line 170 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
int load_main_encodings_map(struct a2ps_job *job___0 ) 
{ 
  char *file ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 176
  file = xpw_find_file((char * const  *)job___0->common.path, "encoding.map", (char const   *)((void *)0));
#line 177
  load_encodings_map(job___0, (char const   *)file);
  }
#line 178
  if ((unsigned int )(1 << 4) & msg_verbosity) {
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Read encoding.map:\n");
#line 181
    pair_table_list_long(job___0->encodings_map, stderr);
    }
  }
  {
#line 183
  free((void *)file);
  }
#line 184
  return (1);
}
}
#line 190 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
__inline static unsigned int *wx_new(void) 
{ 
  int i ;
  unsigned int *res___2 ;
  void *tmp ;

  {
  {
#line 194
  tmp = xmalloc((size_t )(sizeof(unsigned int ) * 256UL));
#line 194
  res___2 = (unsigned int *)tmp;
#line 196
  i = 0;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < 256)) {
#line 196
      goto while_break;
    }
#line 197
    *(res___2 + i) = 0U;
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (res___2);
}
}
#line 202 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void wx_self_print(unsigned int *wx , FILE *stream ) 
{ 
  int j ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 207
  if (wx) {
#line 208
    j = 0;
    {
#line 208
    while (1) {
      while_continue: /* CIL Label */ ;
#line 208
      if (! (j < 256)) {
#line 208
        goto while_break;
      }
      {
#line 209
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%3d: %04u %04u %04u %04u %04u %04u %04u %04u\n",
              j, *(wx + j), *(wx + (j + 1)), *(wx + (j + 2)), *(wx + (j + 3)), *(wx + (j + 4)),
              *(wx + (j + 5)), *(wx + (j + 6)), *(wx + (j + 7)));
#line 208
      j += 8;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 214
    fputs((char const   */* __restrict  */)"<No WX defined>\n", (FILE */* __restrict  */)stream);
    }
  }
#line 215
  return;
}
}
#line 246 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static unsigned long font_entry_hash_1(struct font_entry *entry ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    result = 0UL;
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      kk = (unsigned char const   *)entry->key - 1;
      {
#line 249
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 249
        kk ++;
#line 249
        if (! *kk) {
#line 249
          goto while_break___1;
        }
#line 249
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 249
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 249
    return (result);
#line 249
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return (0UL);
}
}
#line 252 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static unsigned long font_entry_hash_2(struct font_entry *entry ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    result = 0UL;
    {
#line 255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 255
      kk = (unsigned char const   *)entry->key - 1;
      {
#line 255
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 255
        kk ++;
#line 255
        if (! *kk) {
#line 255
          goto while_break___1;
        }
#line 255
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 255
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 255
    return (result);
#line 255
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return (0UL);
}
}
#line 258 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static int font_entry_hash_cmp(struct font_entry *x , struct font_entry *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 261
      xx = (unsigned char const   *)x->key - 1;
#line 261
      yy = (unsigned char const   *)y->key - 1;
      {
#line 261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 261
        xx ++;
#line 261
        if ((int const   )*xx == 0) {
#line 261
          yy ++;
#line 261
          goto while_break___1;
        }
#line 261
        yy ++;
#line 261
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 261
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 261
      result = (int )((int const   )*xx - (int const   )*yy);
#line 261
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 261
    return (result);
#line 261
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (0);
}
}
#line 264 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static int font_entry_hash_qcmp(struct font_entry **x , struct font_entry **y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 267
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 267
      xx = (unsigned char const   *)(*x)->key - 1;
#line 267
      yy = (unsigned char const   *)(*y)->key - 1;
      {
#line 267
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 267
        xx ++;
#line 267
        if ((int const   )*xx == 0) {
#line 267
          yy ++;
#line 267
          goto while_break___1;
        }
#line 267
        yy ++;
#line 267
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 267
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 267
      result = (int )((int const   )*xx - (int const   )*yy);
#line 267
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 267
    return (result);
#line 267
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (0);
}
}
#line 286 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
__inline static void font_entry_free(struct font_entry *item ) 
{ 


  {
  {
#line 289
  free((void *)item->key);
#line 290
  free((void *)item);
  }
#line 291
  return;
}
}
#line 293 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void font_entry_self_print(struct font_entry *entry , FILE *stream ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 296
  if (entry->reencode) {
#line 296
    tmp = "to share between encodings";
  } else {
#line 296
    tmp = "reencode";
  }
#line 296
  if (entry->used) {
#line 296
    tmp___0 = "used";
  } else {
#line 296
    tmp___0 = "not used";
  }
  {
#line 296
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"***** %s ***** (%s, %s) ",
          entry->key, tmp___0, tmp);
#line 300
  wx_self_print(entry->wx, stream);
  }
#line 301
  return;
}
}
#line 306 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static struct hash_table_s *font_table_new(void) 
{ 
  struct hash_table_s *res___2 ;
  void *tmp ;

  {
  {
#line 311
  tmp = xmalloc((size_t )sizeof(hash_table ));
#line 311
  res___2 = (hash_table *)tmp;
#line 312
  hash_init(res___2, 32UL, (unsigned long (*)(void const   *key ))(& font_entry_hash_1),
            (unsigned long (*)(void const   *key ))(& font_entry_hash_2), (int (*)(void const   *x ,
                                                                                   void const   *y ))(& font_entry_hash_cmp));
  }
#line 316
  return (res___2);
}
}
#line 319 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void font_table_free(struct hash_table_s *table ) 
{ 


  {
  {
#line 322
  hash_free(table, (void (*)(void const   *item ))(& font_entry_free));
#line 323
  free((void *)table);
  }
#line 324
  return;
}
}
#line 326 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void font_table_self_print(struct hash_table_s *table , FILE *stream ) 
{ 
  int i ;
  struct font_entry **entries ;
  void **tmp ;

  {
  {
#line 331
  tmp = hash_dump(table, (void **)((void *)0), (int (*)(void const   *x , void const   *y ))(& font_entry_hash_qcmp));
#line 331
  entries = (struct font_entry **)tmp;
#line 335
  i = 0;
  }
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! *(entries + i)) {
#line 335
      goto while_break;
    }
    {
#line 336
    font_entry_self_print(*(entries + i), stream);
#line 335
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 337
  _IO_putc('\n', stream);
#line 338
  free((void *)entries);
  }
#line 339
  return;
}
}
#line 415 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static struct encoding *encoding_new(char const   *key ) 
{ 
  int i ;
  struct encoding *res___2 ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 420
  tmp = xmalloc((size_t )sizeof(struct encoding ));
#line 420
  res___2 = (struct encoding *)tmp;
#line 422
  res___2->key = xstrdup(key);
#line 423
  res___2->name = (char *)((void *)0);
#line 424
  res___2->default_font = (char *)((void *)0);
#line 425
  res___2->documentation = (unsigned char *)((void *)0);
#line 428
  res___2->substitutes = pair_table_new();
#line 429
  res___2->font_names_used = da_new("List of font names", (size_t )10, (enum da_growth )1,
                                    (size_t )10, (void (*)(void const   * , FILE *stream ))(& da_str_print),
                                    (int (*)(void const   *k1 , void const   *k2 ))(& da_str_cmp));
#line 433
  res___2->fonts = font_table_new();
#line 434
  i = 0;
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < 10)) {
#line 434
      goto while_break;
    }
#line 435
    res___2->faces_wx[i] = (unsigned int *)((void *)0);
#line 434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  i = 0;
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 436
    if (! ((int )base_faces[i] != -1)) {
#line 436
      goto while_break___0;
    }
    {
#line 437
    res___2->faces_wx[base_faces[i]] = wx_new();
#line 436
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 438
  return (res___2);
}
}
#line 441 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void encoding_free(struct encoding *encoding ) 
{ 
  int i ;

  {
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (encoding->key) {
      {
#line 446
      free((void *)encoding->key);
      }
    }
#line 446
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 447
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 447
    if (encoding->name) {
      {
#line 447
      free((void *)encoding->name);
      }
    }
#line 447
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 448
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 448
    if (encoding->default_font) {
      {
#line 448
      free((void *)encoding->default_font);
      }
    }
#line 448
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 449
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 449
    if (encoding->documentation) {
      {
#line 449
      free((void *)encoding->documentation);
      }
    }
#line 449
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 451
  i = 0;
  {
#line 451
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 451
    if (! (i < 256)) {
#line 451
      goto while_break___3;
    }
    {
#line 452
    free((void *)encoding->vector[i]);
#line 451
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 454
  pair_table_free(encoding->substitutes);
#line 455
  da_free(encoding->font_names_used, & free);
#line 456
  font_table_free(encoding->fonts);
#line 458
  i = 0;
  }
  {
#line 458
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 458
    if (! ((int )base_faces[i] != -1)) {
#line 458
      goto while_break___4;
    }
    {
#line 459
    free((void *)encoding->faces_wx[base_faces[i]]);
#line 458
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 460
  free((void *)encoding);
  }
#line 461
  return;
}
}
#line 466 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void encoding_add_font_substitute(struct encoding *encoding , char const   *orig ,
                                         char const   *subs ) 
{ 


  {
  {
#line 470
  pair_add(encoding->substitutes, orig, subs);
  }
#line 471
  return;
}
}
#line 481 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
char const   *encoding_resolve_font_substitute(struct a2ps_job *job___0 , struct encoding *encoding ,
                                               char const   *font_list ) 
{ 
  char const   *res___2 ;
  char *font_list_copy ;
  char *font_name ;
  char const   *_tmp_ ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 486
  res___2 = (char const   *)((void *)0);
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 490
    _tmp_ = font_list;
#line 490
    tmp = strlen(_tmp_);
#line 490
    tmp___0 = __builtin_alloca(sizeof(char ) * (unsigned long )(tmp + 1U));
#line 490
    font_list_copy = (char *)tmp___0;
#line 490
    strcpy((char */* __restrict  */)font_list_copy, (char const   */* __restrict  */)_tmp_);
    }
#line 490
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 491
  font_name = strtok((char */* __restrict  */)font_list_copy, (char const   */* __restrict  */)",<>;");
  }
  {
#line 493
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 496
    tmp___1 = pair_get(encoding->substitutes, (char const   *)font_name);
#line 496
    res___2 = (char const   *)tmp___1;
    }
#line 497
    if (! res___2) {
      {
#line 499
      tmp___3 = font_exists(job___0, (char const   *)font_name);
      }
#line 499
      if (tmp___3) {
        {
#line 501
        tmp___2 = xstrdup((char const   *)font_name);
#line 501
        res___2 = (char const   *)tmp___2;
        }
      }
    }
#line 493
    if (! res___2) {
      {
#line 493
      font_name = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",<>;");
      }
#line 493
      if (! font_name) {
#line 493
        goto while_break___0;
      }
    } else {
#line 493
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 507
  if (! res___2) {
#line 509
    if (encoding->default_font) {
#line 510
      res___2 = (char const   *)encoding->default_font;
    } else {
      {
#line 512
      error(1, 0, "Cannot find font %s, nor any substitute", font_name);
      }
    }
  }
  {
#line 516
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 516
    if ((unsigned int )(1 << 4) & msg_verbosity) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"In encoding %s, font %s is resolved as %s\n",
              encoding->key, font_name, res___2);
      }
    }
#line 516
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 519
  return (res___2);
}
}
#line 542
static void load_encoding_description_file(a2ps_job *job___0 , struct encoding *encoding ) ;
#line 542 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static int first_time___1  =    1;
#line 543 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static struct obstack documentation_stack  ;
#line 532 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void load_encoding_description_file(a2ps_job *job___0 , struct encoding *encoding ) 
{ 
  FILE *stream ;
  char *buf___0 ;
  char *fname ;
  size_t bufsiz ;
  char *token___1 ;
  char *token2 ;
  int firstline ;
  int lastline ;
  int c ;
  char buf2[256] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *documentation ;
  char buf2___0[8192] ;
  size_t read_length ;
  struct obstack *__o ;
  int __len ;
  char *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  struct obstack *__o___0 ;
  char *tmp___13 ;
  struct obstack *__o1 ;
  void *value ;
  struct obstack *__o___1 ;
  void *__obj ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *orig ;
  char *subs ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
#line 537
  buf___0 = (char *)((void *)0);
#line 539
  bufsiz = (size_t )0;
#line 541
  firstline = 0;
#line 541
  lastline = 0;
#line 545
  if (first_time___1) {
    {
#line 549
    first_time___1 = 0;
#line 550
    _obstack_begin(& documentation_stack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
    }
  }
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    if ((unsigned int )(1 << 4) & msg_verbosity) {
      {
#line 553
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Loading encoding file `%s.edf\'\n",
              encoding->key);
      }
    }
#line 553
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 555
  fname = xpw_find_file((char * const  *)job___0->common.path, (char const   *)encoding->key,
                        ".edf");
#line 556
  stream = xrfopen((char const   *)fname);
  }
  {
#line 558
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 558
    tmp___27 = getshline_numbered(& firstline, & lastline, & buf___0, & bufsiz, stream);
    }
#line 558
    if (! (tmp___27 != -1)) {
#line 558
      goto while_break___0;
    }
    {
#line 561
    token___1 = strtok((char */* __restrict  */)buf___0, (char const   */* __restrict  */)" \t\n");
    }
#line 563
    if (! token___1) {
#line 565
      goto while_continue___0;
    }
    {
#line 567
    tmp___26 = strcmp((char const   *)token___1, "Vector:");
    }
#line 567
    if (tmp___26 == 0) {
#line 569
      c = 0;
      {
#line 572
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 572
        if (! (c < 256)) {
#line 572
          goto while_break___1;
        }
        {
#line 574
        tmp___0 = fgets((char */* __restrict  */)(buf2), (int )sizeof(buf2), (FILE */* __restrict  */)stream);
        }
#line 574
        if (! tmp___0) {
          {
#line 575
          tmp = gettext("missing argument for `%s\'");
#line 575
          error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, (char const   *)tmp,
                        "`Vector:\'");
          }
        }
        {
#line 577
        lastline ++;
#line 578
        token___1 = strtok((char */* __restrict  */)(buf2), (char const   */* __restrict  */)" \t\n");
#line 579
        tmp___1 = c;
#line 579
        c ++;
#line 579
        encoding->vector[tmp___1] = xstrdup((char const   *)token___1);
        }
        {
#line 580
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 580
          token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
          }
#line 580
          if (! token2) {
#line 580
            goto while_break___2;
          }
          {
#line 581
          tmp___2 = c;
#line 581
          c ++;
#line 581
          encoding->vector[tmp___2] = xstrdup((char const   *)token2);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 584
      tmp___25 = strcmp((char const   *)token___1, "Name:");
      }
#line 584
      if (tmp___25 == 0) {
        {
#line 586
        token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
        }
#line 587
        if ((unsigned long )token2 == (unsigned long )((void *)0)) {
          {
#line 587
          tmp___3 = quotearg((char const   *)token___1);
#line 587
          tmp___4 = gettext("missing argument for `%s\'");
#line 587
          error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, (char const   *)tmp___4,
                        tmp___3);
          }
        }
        {
#line 588
        encoding->name = xstrdup((char const   *)token2);
        }
      } else {
        {
#line 590
        tmp___24 = strcmp((char const   *)token___1, "Default:");
        }
#line 590
        if (tmp___24 == 0) {
          {
#line 592
          token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
          }
#line 593
          if ((unsigned long )token2 == (unsigned long )((void *)0)) {
            {
#line 593
            tmp___5 = quotearg((char const   *)token___1);
#line 593
            tmp___6 = gettext("missing argument for `%s\'");
#line 593
            error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, (char const   *)tmp___6,
                          tmp___5);
            }
          }
          {
#line 594
          encoding->default_font = xstrdup((char const   *)token2);
          }
        } else {
          {
#line 596
          tmp___23 = strcmp((char const   *)token___1, "Documentation");
          }
#line 596
          if (tmp___23 == 0) {
            {
#line 605
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 605
              tmp___7 = fgets((char */* __restrict  */)(buf2___0), (int )sizeof(buf2___0),
                              (FILE */* __restrict  */)stream);
              }
#line 605
              if (tmp___7) {
                {
#line 605
                tmp___8 = strlen("EndDocumentation");
#line 605
                tmp___9 = strncmp("EndDocumentation", (char const   *)(buf2___0),
                                  tmp___8);
                }
#line 605
                if (! tmp___9) {
#line 605
                  goto while_break___3;
                }
              } else {
#line 605
                goto while_break___3;
              }
              {
#line 608
              read_length = strlen((char const   *)(buf2___0));
              }
#line 609
              if ((unsigned long )read_length < sizeof(buf2___0)) {
#line 610
                lastline ++;
              }
#line 612
              __o = & documentation_stack;
#line 612
              __len = (int )read_length;
#line 612
              if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
                {
#line 612
                _obstack_newchunk(__o, __len);
                }
              }
              {
#line 612
              memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)(buf2___0),
                     (size_t )__len);
#line 612
              __o->next_free += __len;
              }
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 614
            tmp___11 = strlen("EndDocumentation");
#line 614
            tmp___12 = strncmp("EndDocumentation", (char const   *)(buf2___0), tmp___11);
            }
#line 614
            if (tmp___12) {
              {
#line 615
              tmp___10 = gettext("missing argument for `%s\'");
#line 615
              error(1, 0, (char const   *)fname, firstline, tmp___10, "`Documentation\'");
              }
            }
#line 618
            __o___0 = & documentation_stack;
#line 618
            if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
              {
#line 618
              _obstack_newchunk(__o___0, 1);
              }
            }
#line 618
            tmp___13 = __o___0->next_free;
#line 618
            (__o___0->next_free) ++;
#line 618
            *tmp___13 = (char )'\000';
#line 620
            __o1 = & documentation_stack;
#line 620
            value = (void *)__o1->object_base;
#line 620
            if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 620
              __o1->maybe_empty_object = 1U;
            }
#line 620
            __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 620
            if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 620
              __o1->next_free = __o1->chunk_limit;
            }
#line 620
            __o1->object_base = __o1->next_free;
#line 620
            documentation = (char *)value;
#line 621
            __o___1 = & documentation_stack;
#line 621
            __obj = (void *)documentation;
#line 621
            if ((unsigned long )__obj > (unsigned long )((void *)__o___1->chunk)) {
#line 621
              if ((unsigned long )__obj < (unsigned long )((void *)__o___1->chunk_limit)) {
#line 621
                tmp___14 = (char *)__obj;
#line 621
                __o___1->object_base = tmp___14;
#line 621
                __o___1->next_free = tmp___14;
              } else {
                {
#line 621
                obstack_free(__o___1, __obj);
                }
              }
            } else {
              {
#line 621
              obstack_free(__o___1, __obj);
              }
            }
            {
#line 622
            tmp___15 = xstrdup((char const   *)documentation);
#line 622
            encoding->documentation = (unsigned char *)tmp___15;
            }
          } else {
            {
#line 624
            tmp___22 = strcmp((char const   *)token___1, "Substitute:");
            }
#line 624
            if (tmp___22 == 0) {
              {
#line 628
              token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
              }
#line 629
              if ((unsigned long )token2 == (unsigned long )((void *)0)) {
                {
#line 629
                tmp___16 = quotearg((char const   *)token___1);
#line 629
                tmp___17 = gettext("missing argument for `%s\'");
#line 629
                error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline,
                              (char const   *)tmp___17, tmp___16);
                }
              }
              {
#line 630
              orig = token2;
#line 631
              token2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
              }
#line 632
              if ((unsigned long )token2 == (unsigned long )((void *)0)) {
                {
#line 632
                tmp___18 = quotearg((char const   *)token___1);
#line 632
                tmp___19 = gettext("missing argument for `%s\'");
#line 632
                error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline,
                              (char const   *)tmp___19, tmp___18);
                }
              }
              {
#line 633
              subs = token2;
#line 634
              encoding_add_font_substitute(encoding, (char const   *)orig, (char const   *)subs);
              }
            } else {
              {
#line 637
              tmp___20 = quotearg((char const   *)token___1);
#line 637
              tmp___21 = gettext("invalid option `%s\'");
#line 637
              error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline,
                            (char const   *)tmp___21, tmp___20);
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 641
  fclose(stream);
#line 642
  free((void *)buf___0);
#line 643
  free((void *)fname);
  }
#line 644
  return;
}
}
#line 649 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void encoding_print_signature(struct encoding *item , FILE *stream ) 
{ 
  int i ;
  int title_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 654
  tmp = strlen(" ()");
#line 654
  tmp___0 = strlen((char const   *)item->name);
#line 654
  tmp___1 = strlen((char const   *)item->key);
#line 654
  title_len = (int )((tmp + tmp___0) + tmp___1);
#line 657
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s)\n",
          item->name, item->key);
#line 658
  i = 0;
  }
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! (i < title_len)) {
#line 658
      goto while_break;
    }
    {
#line 659
    _IO_putc('-', stream);
#line 658
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 660
  _IO_putc('\n', stream);
#line 662
  documentation_print_plain((unsigned char const   *)item->documentation, "%s", stream);
  }
#line 663
  return;
}
}
#line 668 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void encoding_output_ps_vector(struct a2ps_job *job___0 , struct encoding *encoding ) 
{ 
  int c ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 674
  output(job___0->ps_encodings, "%%%%BeginResource: encoding %sEncoding\n", encoding->name);
#line 676
  output(job___0->ps_encodings, "/%sEncoding [", encoding->name);
#line 678
  c = 0;
  }
  {
#line 678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 678
    if (! (c < 256)) {
#line 678
      goto while_break;
    }
#line 680
    if (! (c % 8)) {
      {
#line 681
      output_char(job___0->ps_encodings, (unsigned char )'\n');
      }
    }
    {
#line 682
    output(job___0->ps_encodings, "/%s ", encoding->vector[c]);
#line 678
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 684
  output(job___0->ps_encodings, "\n] def\n");
#line 685
  output(job___0->ps_encodings, "%%%%EndResource\n");
  }
#line 686
  return;
}
}
#line 691 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
void encoding_self_print(struct encoding *item , FILE *stream ) 
{ 
  int c ;
  enum face_e face ;
  int i ;
  char const   *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 696
  encoding_print_signature(item, stream);
  }
#line 698
  if (! ((unsigned long )((char const   *)item->default_font) == (unsigned long )((void *)0))) {
#line 698
    if (! ((int )*(item->default_font) == 0)) {
      {
#line 699
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Default font is `%s\'\n",
              item->default_font);
      }
    }
  }
  {
#line 701
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Substitution of fonts:\n");
#line 702
  pair_table_list_long(item->substitutes, stream);
#line 703
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Name of fonts used (before substitution):\n");
#line 704
  da_self_print(item->font_names_used, stream);
#line 706
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Encoding array:");
#line 707
  c = 0;
  }
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! (c < 256)) {
#line 707
      goto while_break;
    }
#line 709
    if (! (c % 8)) {
      {
#line 710
      _IO_putc('\n', stream);
      }
    }
    {
#line 711
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%-10s ",
            item->vector[c]);
#line 707
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 713
  _IO_putc('\n', stream);
#line 715
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Fonts:\n");
#line 716
  font_table_self_print(item->fonts, stream);
  }
#line 717
  if ((unsigned int )(1 << 4) & msg_verbosity) {
    {
#line 721
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Faces:\n");
#line 722
    i = 0;
    }
    {
#line 722
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 722
      if (! ((int )base_faces[i] != -1)) {
#line 722
        goto while_break___0;
      }
      {
#line 724
      face = base_faces[i];
#line 725
      tmp = face_to_string(face);
#line 725
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Face %s (%d)\n",
              tmp, (int )face);
#line 726
      wx_self_print(item->faces_wx[face], stream);
#line 722
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 729
  return;
}
}
#line 734 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
char const   *encoding_get_name(struct encoding *enc ) 
{ 


  {
#line 737
  return ((char const   *)enc->name);
}
}
#line 743 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
char const   *encoding_get_key(struct encoding *enc ) 
{ 


  {
#line 746
  return ((char const   *)enc->key);
}
}
#line 749 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
int encoding_char_exists(struct encoding *enc , enum face_e face , unsigned char c ) 
{ 


  {
#line 753
  return ((int )*(enc->faces_wx[face] + c));
}
}
#line 763 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void dump_encoding_setup(FILE *stream , struct a2ps_job *job___0 , struct encoding *encoding ) 
{ 
  size_t i ;
  size_t nb ;
  char const   *real_font_name ;
  char **font_names ;
  int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 770
  font_names = (char **)(encoding->font_names_used)->content;
#line 773
  da_qsort(encoding->font_names_used);
#line 774
  da_unique(encoding->font_names_used, & free);
#line 778
  i = (size_t )0;
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
#line 778
    if (! (i < (encoding->font_names_used)->len)) {
#line 778
      goto while_break;
    }
    {
#line 780
    real_font_name = encoding_resolve_font_substitute(job___0, encoding, (char const   *)*(font_names + i));
#line 782
    tmp = font_is_to_reencode(job___0, real_font_name);
    }
#line 782
    if (! tmp) {
      {
#line 783
      da_remove_at(encoding->font_names_used, i, & free);
      }
    }
#line 778
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 788
  nb = (encoding->font_names_used)->len;
#line 791
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%% Dictionary for %s support\n",
          encoding->name);
#line 793
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"/%sdict %d dict begin\n",
          encoding->key, nb);
#line 794
  i = (size_t )0;
  }
  {
#line 794
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 794
    if (! (i < nb)) {
#line 794
      goto while_break___0;
    }
    {
#line 795
    tmp___0 = encoding_resolve_font_substitute(job___0, encoding, (char const   *)*(font_names + i));
#line 795
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  /f%s %sEncoding /%s reencode_font\n",
            *(font_names + i), encoding->name, tmp___0);
#line 794
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 799
  fputs((char const   */* __restrict  */)"currentdict end def\n", (FILE */* __restrict  */)stream);
  }
#line 800
  return;
}
}
#line 808 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static unsigned long encoding_hash_1(struct encoding *entry ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 811
    result = 0UL;
    {
#line 811
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 811
      kk = (unsigned char const   *)entry->key - 1;
      {
#line 811
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 811
        kk ++;
#line 811
        if (! *kk) {
#line 811
          goto while_break___1;
        }
#line 811
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 811
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 811
    return (result);
#line 811
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 812
  return (0UL);
}
}
#line 814 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static unsigned long encoding_hash_2(struct encoding *entry ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 817
    result = 0UL;
    {
#line 817
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 817
      kk = (unsigned char const   *)entry->key - 1;
      {
#line 817
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 817
        kk ++;
#line 817
        if (! *kk) {
#line 817
          goto while_break___1;
        }
#line 817
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 817
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 817
    return (result);
#line 817
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 818
  return (0UL);
}
}
#line 820 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static int encoding_hash_cmp(struct encoding *x , struct encoding *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 823
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 823
      xx = (unsigned char const   *)x->key - 1;
#line 823
      yy = (unsigned char const   *)y->key - 1;
      {
#line 823
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 823
        xx ++;
#line 823
        if ((int const   )*xx == 0) {
#line 823
          yy ++;
#line 823
          goto while_break___1;
        }
#line 823
        yy ++;
#line 823
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 823
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 823
      result = (int )((int const   )*xx - (int const   )*yy);
#line 823
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 823
    return (result);
#line 823
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 824
  return (0);
}
}
#line 826 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static int encoding_hash_qcmp(struct encoding **x , struct encoding **y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 830
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 830
      xx = (unsigned char const   *)(*x)->key - 1;
#line 830
      yy = (unsigned char const   *)(*y)->key - 1;
      {
#line 830
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 830
        xx ++;
#line 830
        if ((int const   )*xx == 0) {
#line 830
          yy ++;
#line 830
          goto while_break___1;
        }
#line 830
        yy ++;
#line 830
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 830
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 830
      result = (int )((int const   )*xx - (int const   )*yy);
#line 830
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 830
    return (result);
#line 830
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 831
  return (0);
}
}
#line 836 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
struct hash_table_s *encodings_table_new(void) 
{ 
  struct hash_table_s *res___2 ;
  void *tmp ;

  {
  {
#line 841
  tmp = xmalloc((size_t )sizeof(hash_table ));
#line 841
  res___2 = (hash_table *)tmp;
#line 842
  hash_init(res___2, 32UL, (unsigned long (*)(void const   *key ))(& encoding_hash_1),
            (unsigned long (*)(void const   *key ))(& encoding_hash_2), (int (*)(void const   *x ,
                                                                                 void const   *y ))(& encoding_hash_cmp));
  }
#line 846
  return (res___2);
}
}
#line 852 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
void encodings_table_free(struct hash_table_s *table ) 
{ 


  {
  {
#line 855
  hash_free(table, (void (*)(void const   *item ))(& encoding_free));
#line 856
  free((void *)table);
  }
#line 857
  return;
}
}
#line 862 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void encoding_setup(struct a2ps_job *job___0 , struct encoding *encoding ) 
{ 
  char *cp ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 868
  load_encoding_description_file(job___0, encoding);
  }
  {
#line 872
  if ((unsigned int )job___0->output_format == 0U) {
#line 872
    goto case_0;
  }
#line 872
  if ((unsigned int )job___0->output_format == 1U) {
#line 872
    goto case_0;
  }
#line 869
  goto switch_break;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 876
  tmp = strlen((char const   *)encoding->name);
#line 876
  tmp___0 = strlen("Encoding");
#line 876
  tmp___1 = __builtin_alloca(sizeof(char ) * (unsigned long )((tmp + tmp___0) + 1U));
#line 876
  cp = (char *)tmp___1;
#line 877
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"%sEncoding",
          encoding->name);
#line 879
  add_supplied_resource(job___0, "encoding", (char const   *)cp);
#line 880
  encoding_output_ps_vector(job___0, encoding);
  }
#line 881
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 883
  return;
}
}
#line 889 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void encoding_add(struct a2ps_job *job___0 , char const   *key ) 
{ 
  struct encoding *encoding ;
  int tmp ;

  {
  {
#line 894
  encoding = encoding_new(key);
#line 895
  encoding_setup(job___0, encoding);
#line 899
  tmp = face_eo_font_is_set(job___0);
  }
#line 899
  if (tmp) {
    {
#line 900
    encoding_build_faces_wx(job___0, encoding);
    }
  }
#line 901
  if ((unsigned int )(1 << 4) & msg_verbosity) {
    {
#line 902
    encoding_self_print(encoding, stderr);
    }
  }
  {
#line 903
  hash_insert(job___0->encodings, (void *)encoding);
  }
#line 904
  return;
}
}
#line 906 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
void encoding_add_font_name_used(struct encoding *encoding , char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 910
  tmp = xstrdup(name);
#line 910
  da_append(encoding->font_names_used, (void *)tmp);
  }
#line 911
  return;
}
}
#line 921 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
void encoding_build_faces_wx(struct a2ps_job *job___0 , struct encoding *encoding ) 
{ 
  int i ;
  enum face_e face ;
  char const   *true_font_name ;

  {
#line 928
  i = 0;
  {
#line 928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 928
    if (! ((int )base_faces[i] != -1)) {
#line 928
      goto while_break;
    }
    {
#line 930
    face = base_faces[i];
#line 931
    encoding_add_font_name_used(encoding, (char const   *)job___0->face_eo_font[face]);
#line 934
    true_font_name = encoding_resolve_font_substitute(job___0, encoding, (char const   *)job___0->face_eo_font[face]);
#line 938
    font_info_get_wx_for_vector(job___0, true_font_name, (char **)(encoding->vector),
                                encoding->faces_wx[face]);
#line 928
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 943
  return;
}
}
#line 948 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static struct encoding *encoding_get(struct a2ps_job *job___0 , char const   *key ) 
{ 
  struct encoding token___1 ;
  struct encoding *res___2 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 953
  token___1.key = (char *)key;
#line 954
  tmp = hash_find_item(job___0->encodings, (void const   *)(& token___1));
#line 954
  res___2 = (struct encoding *)tmp;
  }
#line 956
  if (! res___2) {
    {
#line 958
    encoding_add(job___0, key);
#line 959
    tmp___0 = hash_find_item(job___0->encodings, (void const   *)(& token___1));
#line 959
    res___2 = (struct encoding *)tmp___0;
    }
  }
#line 961
  return (res___2);
}
}
#line 967 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
struct encoding *get_encoding_by_alias(struct a2ps_job *job___0 , char *alias ) 
{ 
  char const   *key ;
  unsigned char *tmp ;
  char *tmp___0 ;
  struct encoding *tmp___1 ;

  {
  {
#line 972
  tmp = strlower((unsigned char *)alias);
#line 972
  tmp___0 = encodings_map_resolve_alias(job___0->encodings_map, (char const   *)tmp);
#line 972
  key = (char const   *)tmp___0;
  }
#line 973
  if (key) {
    {
#line 974
    tmp___1 = encoding_get(job___0, key);
    }
#line 974
    return (tmp___1);
  } else {
#line 977
    return ((struct encoding *)((void *)0));
  }
}
}
#line 984 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
void dump_encodings_setup(FILE *stream , struct a2ps_job *job___0 ) 
{ 
  int i ;
  struct encoding **encodings ;
  void **tmp ;

  {
  {
#line 992
  tmp = hash_dump(job___0->encodings, (void **)((void *)0), (int (*)(void const   *x ,
                                                                     void const   *y ))(& encoding_hash_qcmp));
#line 992
  encodings = (struct encoding **)tmp;
#line 996
  i = 0;
  }
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 996
    if (! *(encodings + i)) {
#line 996
      goto while_break;
    }
    {
#line 997
    dump_encoding_setup(stream, job___0, *(encodings + i));
#line 996
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 999
  free((void *)encodings);
  }
#line 1000
  return;
}
}
#line 1008 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
unsigned int char_WX(struct a2ps_job *job___0 , unsigned char c ) 
{ 
  unsigned int wx ;
  char buf___0[3] ;
  char buf___1[4] ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1012
  wx = *((job___0->encoding)->faces_wx[(job___0->status)->face] + (int )c);
#line 1015
  if (wx) {
#line 1016
    return (wx);
  }
  {
#line 1020
  if ((unsigned int )job___0->unprintable_format == 4U) {
#line 1020
    goto case_4;
  }
#line 1027
  if ((unsigned int )job___0->unprintable_format == 3U) {
#line 1027
    goto case_3;
  }
#line 1035
  if ((unsigned int )job___0->unprintable_format == 1U) {
#line 1035
    goto case_1;
  }
#line 1038
  if ((unsigned int )job___0->unprintable_format == 2U) {
#line 1038
    goto case_2;
  }
#line 1041
  if ((unsigned int )job___0->unprintable_format == 0U) {
#line 1041
    goto case_0;
  }
#line 1055
  if ((unsigned int )job___0->unprintable_format == 5U) {
#line 1055
    goto case_5;
  }
#line 1069
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 1023
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%02x",
          (int )c);
  }
#line 1024
  return (((*((job___0->encoding)->faces_wx[(job___0->status)->face] + 92) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + 120)) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + (int )buf___0[0])) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + (int )buf___0[1]));
  case_3: /* CIL Label */ 
  {
#line 1030
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%03o",
          (int )c);
  }
#line 1031
  return (((*((job___0->encoding)->faces_wx[(job___0->status)->face] + 92) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + (int )buf___1[0])) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + (int )buf___1[1])) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + (int )buf___1[2]));
  case_1: /* CIL Label */ 
#line 1036
  return (*((job___0->encoding)->faces_wx[(job___0->status)->face] + ' '));
  case_2: /* CIL Label */ 
#line 1039
  return (*((job___0->encoding)->faces_wx[(job___0->status)->face] + '?'));
  case_0: /* CIL Label */ 
#line 1042
  if (127 < (int )c) {
#line 1044
    wx += *((job___0->encoding)->faces_wx[(job___0->status)->face] + 77) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + 45);
#line 1045
    c = (unsigned char )((int )c & 127);
  }
#line 1047
  if ((int )c == 127) {
#line 1048
    wx += *((job___0->encoding)->faces_wx[(job___0->status)->face] + 94) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + 63);
  } else
#line 1049
  if ((int )c < 32) {
#line 1050
    wx += *((job___0->encoding)->faces_wx[(job___0->status)->face] + 94) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + ((int )c + 64));
  } else {
#line 1052
    wx += *((job___0->encoding)->faces_wx[(job___0->status)->face] + (int )c);
  }
#line 1053
  return (wx);
  case_5: /* CIL Label */ 
#line 1056
  if (127 < (int )c) {
#line 1058
    wx += *((job___0->encoding)->faces_wx[(job___0->status)->face] + 77) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + 45);
#line 1059
    c = (unsigned char )((int )c & 127);
  }
#line 1061
  if ((int )c == 127) {
#line 1062
    wx += (*((job___0->encoding)->faces_wx[(job___0->status)->face] + 67) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + 45)) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + 63);
  } else
#line 1063
  if ((int )c < 32) {
#line 1064
    wx += (*((job___0->encoding)->faces_wx[(job___0->status)->face] + 67) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + 45)) + *((job___0->encoding)->faces_wx[(job___0->status)->face] + ((int )c + 64));
  } else {
#line 1066
    wx += *((job___0->encoding)->faces_wx[(job___0->status)->face] + (int )c);
  }
#line 1067
  return (wx);
  switch_default: /* CIL Label */ 
  {
#line 1070
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1073
  return (0U);
}
}
#line 1079 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
unsigned int string_WX(struct a2ps_job *job___0 , unsigned char *string ) 
{ 
  unsigned int result ;
  unsigned int tmp ;

  {
#line 1082
  result = 0U;
  {
#line 1084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1084
    if (! *string) {
#line 1084
      goto while_break;
    }
    {
#line 1085
    tmp = char_WX(job___0, *string);
#line 1085
    result += tmp;
#line 1084
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1087
  return (result);
}
}
#line 1093 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
void set_encoding(struct a2ps_job *job___0 , struct encoding *enc ) 
{ 


  {
#line 1096
  job___0->encoding = enc;
#line 1097
  return;
}
}
#line 1101 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static int da_encoding_name_cmp(char *key1 , char *key2 , struct a2ps_job *job___0 ) 
{ 
  struct encoding *tmp ;
  struct encoding *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1104
  tmp = encoding_get(job___0, (char const   *)key2);
#line 1104
  tmp___0 = encoding_get(job___0, (char const   *)key1);
#line 1104
  tmp___1 = strverscmp((char const   *)tmp___0->name, (char const   *)tmp->name);
  }
#line 1104
  return (tmp___1);
}
}
#line 1111 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
void list_encodings_short(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1114
  tmp = gettext("Known Encodings");
#line 1114
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
#line 1115
  _IO_putc('\n', stream);
#line 1116
  pw_lister_on_suffix(stream, (char * const  *)job___0->common.path, ".edf");
  }
#line 1117
  return;
}
}
#line 1122 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
void list_encodings_long(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  struct darray *entries ;
  struct encoding *encoding ;
  size_t i ;
  char *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1129
  entries = pw_glob_on_suffix((char * const  *)job___0->common.path, ".edf");
#line 1132
  da_qsort_with_arg(entries, (int (*)(void const   *k1 , void const   *k2 , void const   *arg ))(& da_encoding_name_cmp),
                    (void const   *)job___0);
#line 1135
  tmp = gettext("Known Encodings");
#line 1135
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
#line 1136
  _IO_putc('\n', stream);
#line 1138
  i = (size_t )0;
  }
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! (i < entries->len)) {
#line 1138
      goto while_break;
    }
    {
#line 1141
    encoding = encoding_get(job___0, (char const   *)*(entries->content + i));
#line 1142
    encoding_print_signature(encoding, stream);
#line 1143
    _IO_putc('\n', stream);
#line 1138
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1145
  da_free(entries, & free);
  }
#line 1146
  return;
}
}
#line 1154 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
static void encoding_texinfo_print_signature(struct encoding *encoding , FILE *stream ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1158
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"@deftp {Encoding} {%s} (@file{%s.edf})\n",
          encoding->name, encoding->key);
#line 1161
  documentation_print_texinfo((unsigned char const   *)encoding->documentation, "%s",
                              stream);
#line 1162
  fputs((char const   */* __restrict  */)"@end deftp\n\n", (FILE */* __restrict  */)stream);
  }
#line 1163
  return;
}
}
#line 1168 "/home/ysko/Works/test-src/a2ps-4.14/lib/encoding.c"
void list_texinfo_encodings_long(struct a2ps_job *job___0 , FILE *stream ) 
{ 
  struct darray *entries ;
  struct encoding *encoding ;
  unsigned int i ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1175
  entries = pw_glob_on_suffix((char * const  *)job___0->common.path, ".edf");
#line 1178
  da_qsort_with_arg(entries, (int (*)(void const   *k1 , void const   *k2 , void const   *arg ))(& da_encoding_name_cmp),
                    (void const   *)job___0);
#line 1181
  fputs((char const   */* __restrict  */)"The known encodings are:\n", (FILE */* __restrict  */)stream);
#line 1183
  i = 0U;
  }
  {
#line 1183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1183
    if (! (i < entries->len)) {
#line 1183
      goto while_break;
    }
    {
#line 1186
    encoding = encoding_get(job___0, (char const   *)*(entries->content + i));
#line 1187
    encoding_texinfo_print_signature(encoding, stream);
#line 1183
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1189
  da_free(entries, & free);
  }
#line 1190
  return;
}
}
#line 356 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 44 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.h"
int ds_exit_error ;
#line 88
void ds_resize(struct dstring *string , size_t size ) ;
#line 89
void ds_grow(struct dstring *string ) ;
#line 96
int ds_is_full(struct dstring *str ) ;
#line 103
void ds_strcat(struct dstring *s , char *t ) ;
#line 104
void ds_strncat(struct dstring *s , char *t , int n ) ;
#line 111
void ds_vsprintf(struct dstring *ds , char const   *format , va_list args ) ;
#line 114
void ds_cat_vsprintf(struct dstring *ds , char const   *format , va_list args ) ;
#line 118
void ds_unsafe_vsprintf(struct dstring *ds , char const   *format , va_list args ) ;
#line 125
void ( /* format attribute */  ds_sprintf)(struct dstring *ds , char const   *format 
                                           , ...) ;
#line 128
void ( /* format attribute */  ds_unsafe_sprintf)(struct dstring *ds , char const   *format 
                                                  , ...) ;
#line 130
void ( /* format attribute */  ds_cat_sprintf)(struct dstring *ds , char const   *format 
                                               , ...) ;
#line 133
void ( /* format attribute */  ds_unsafe_cat_sprintf)(struct dstring *ds , char const   *format 
                                                      , ...) ;
#line 145
char *ds_getline(struct dstring *s , FILE *f ) ;
#line 146
char *ds_getdelim(struct dstring *s , char eos , FILE *f ) ;
#line 27 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
int ds_exit_error  =    1;
#line 33 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
struct dstring *ds_new(size_t size , enum ds_growth growth , size_t increment ) 
{ 
  struct dstring *res___2 ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 39
  if (size == 0U) {
    {
#line 40
    error(ds_exit_error, 0, "invalid size for dynamic string: %d", size);
    }
  }
#line 43
  if (increment == 0U) {
#line 43
    if ((unsigned int )growth != 0U) {
      {
#line 44
      error(ds_exit_error, 0, "invalid increment for dynamic string: %d", increment);
      }
    }
  }
  {
#line 47
  tmp = xmalloc((size_t )sizeof(struct dstring ));
#line 47
  res___2 = (struct dstring *)tmp;
#line 48
  res___2->len = (size_t )0;
#line 49
  res___2->size = size;
#line 50
  res___2->original_size = size;
#line 51
  res___2->growth = growth;
#line 52
  res___2->increment = increment;
#line 53
  tmp___0 = xmalloc((size_t )(sizeof(char ) * (unsigned long )size));
#line 53
  res___2->content = (char *)tmp___0;
#line 54
  *(res___2->content + 0) = (char )'\000';
  }
#line 56
  return (res___2);
}
}
#line 61 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_erase(struct dstring *string ) 
{ 


  {
  {
#line 64
  free((void *)string->content);
#line 65
  free((void *)string);
  }
#line 66
  return;
}
}
#line 71 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_print_stats(struct dstring *str , FILE *stream ) 
{ 
  char const   *cp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 74
  cp = (char const   *)((void *)0);
#line 76
  tmp = gettext("Dynamic string:\n");
#line 76
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp);
#line 77
  tmp___0 = gettext("\tload: %d/%d (%2.1f%%)\n");
#line 77
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___0,
          str->len, str->size, (100.0 * (double )str->len) / (double )str->size);
  }
  {
#line 80
  if ((unsigned int )str->growth == 0U) {
#line 80
    goto case_0;
  }
#line 83
  if ((unsigned int )str->growth == 1U) {
#line 83
    goto case_1;
  }
#line 86
  if ((unsigned int )str->growth == 2U) {
#line 86
    goto case_2;
  }
#line 89
  goto switch_default;
  case_0: /* CIL Label */ 
#line 81
  cp = "[const]";
#line 82
  goto switch_break;
  case_1: /* CIL Label */ 
#line 84
  cp = "+=";
#line 85
  goto switch_break;
  case_2: /* CIL Label */ 
#line 87
  cp = "*=";
#line 88
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 90
  error(ds_exit_error, 0, "invalid growth type for dstring");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 92
  tmp___1 = gettext("\toriginal size: %d, growth: %s %d\n");
#line 92
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          str->original_size, cp, str->increment);
  }
#line 94
  return;
}
}
#line 99 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_resize(struct dstring *string , size_t size ) 
{ 
  void *tmp ;

  {
#line 102
  if (string->len + 1U < size) {
    {
#line 104
    string->size = size;
#line 105
    tmp = xrealloc((void *)string->content, (size_t )(sizeof(char ) * (unsigned long )size));
#line 105
    string->content = (char *)tmp;
    }
  }
#line 107
  return;
}
}
#line 112 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_grow(struct dstring *string ) 
{ 
  void *tmp ;

  {
  {
#line 116
  if ((unsigned int )string->growth == 0U) {
#line 116
    goto case_0;
  }
#line 119
  if ((unsigned int )string->growth == 1U) {
#line 119
    goto case_1;
  }
#line 123
  if ((unsigned int )string->growth == 2U) {
#line 123
    goto case_2;
  }
#line 115
  goto switch_break;
  case_0: /* CIL Label */ 
#line 117
  return;
  case_1: /* CIL Label */ 
#line 120
  string->size += string->increment;
#line 121
  goto switch_break;
  case_2: /* CIL Label */ 
#line 124
  string->size *= string->increment;
#line 125
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp = xrealloc((void *)string->content, (size_t )(sizeof(char ) * (unsigned long )string->size));
#line 127
  string->content = (char *)tmp;
  }
#line 128
  return;
}
}
#line 136 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
int ds_is_full(struct dstring *str ) 
{ 


  {
#line 139
  return (str->len + 1U >= str->size);
}
}
#line 148 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_strcat(struct dstring *s , char *t ) 
{ 
  size_t len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 151
  len = s->len;
#line 153
  tmp = strlen((char const   *)t);
#line 153
  s->len += tmp;
#line 154
  tmp___0 = ds_is_full(s);
  }
#line 154
  if (tmp___0) {
    {
#line 155
    ds_grow(s);
    }
  }
  {
#line 157
  strcpy((char */* __restrict  */)(s->content + len), (char const   */* __restrict  */)t);
  }
#line 158
  return;
}
}
#line 160 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_strncat(struct dstring *s , char *t , int n ) 
{ 
  size_t len ;
  int tmp ;

  {
  {
#line 163
  len = s->len;
#line 165
  s->len += (size_t )n;
#line 166
  tmp = ds_is_full(s);
  }
#line 166
  if (tmp) {
    {
#line 167
    ds_grow(s);
    }
  }
  {
#line 169
  strncpy((char */* __restrict  */)(s->content + len), (char const   */* __restrict  */)t,
          (size_t )n);
#line 170
  *(s->content + s->len) = (char )'\000';
  }
#line 171
  return;
}
}
#line 176 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_strccat(struct dstring *s , char c ) 
{ 
  size_t tmp ;

  {
#line 179
  if (s->len + 2U >= s->size) {
    {
#line 180
    ds_grow(s);
    }
  }
#line 182
  tmp = s->len;
#line 182
  (s->len) ++;
#line 182
  *(s->content + tmp) = c;
#line 183
  *(s->content + s->len) = (char )'\000';
#line 184
  return;
}
}
#line 192 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_vsprintf(struct dstring *ds , char const   *format , va_list args ) 
{ 
  int len ;

  {
  {
#line 197
  len = vprintflen(format, args);
#line 198
  ds_resize(ds, (size_t )len);
#line 200
  vsprintf((char */* __restrict  */)ds->content, (char const   */* __restrict  */)format,
           args);
#line 201
  ds->len = strlen((char const   *)ds->content);
  }
#line 202
  return;
}
}
#line 208 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ( /* format attribute */  ds_sprintf)(struct dstring *ds , char const   *format 
                                           , ...) 
{ 
  va_list args ;

  {
  {
#line 221
  __builtin_va_start(args, format);
#line 222
  ds_vsprintf(ds, format, args);
#line 224
  __builtin_va_end(args);
  }
#line 229
  return;
}
}
#line 235 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_cat_vsprintf(struct dstring *ds , char const   *format , va_list args ) 
{ 
  int len ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 239
  tmp = vprintflen(format, args);
#line 239
  len = (int )(ds->len + (size_t )tmp);
#line 241
  ds_resize(ds, (size_t )len);
#line 243
  vsprintf((char */* __restrict  */)(ds->content + ds->len), (char const   */* __restrict  */)format,
           args);
#line 244
  tmp___0 = strlen((char const   *)(ds->content + ds->len));
#line 244
  ds->len += tmp___0;
  }
#line 245
  return;
}
}
#line 251 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ( /* format attribute */  ds_cat_sprintf)(struct dstring *ds , char const   *format 
                                               , ...) 
{ 
  va_list args ;

  {
  {
#line 264
  __builtin_va_start(args, format);
#line 266
  ds_cat_vsprintf(ds, format, args);
#line 268
  __builtin_va_end(args);
  }
#line 273
  return;
}
}
#line 282 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_unsafe_vsprintf(struct dstring *ds , char const   *format , va_list args ) 
{ 


  {
  {
#line 285
  vsprintf((char */* __restrict  */)ds->content, (char const   */* __restrict  */)format,
           args);
#line 286
  ds->len = strlen((char const   *)ds->content);
  }
#line 287
  return;
}
}
#line 293 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ( /* format attribute */  ds_unsafe_sprintf)(struct dstring *ds , char const   *format 
                                                  , ...) 
{ 
  va_list args ;

  {
  {
#line 306
  __builtin_va_start(args, format);
#line 307
  ds_unsafe_vsprintf(ds, format, args);
#line 309
  __builtin_va_end(args);
  }
#line 314
  return;
}
}
#line 320 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ds_unsafe_cat_vsprintf(struct dstring *ds , char const   *format , va_list args ) 
{ 
  size_t tmp ;

  {
#line 323
  if (ds->size < ds->len + 1024U) {
    {
#line 324
    ds_grow(ds);
    }
  }
  {
#line 326
  vsprintf((char */* __restrict  */)(ds->content + ds->len), (char const   */* __restrict  */)format,
           args);
#line 327
  tmp = strlen((char const   *)(ds->content + ds->len));
#line 327
  ds->len += tmp;
  }
#line 328
  return;
}
}
#line 334 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
void ( /* format attribute */  ds_unsafe_cat_sprintf)(struct dstring *ds , char const   *format 
                                                      , ...) 
{ 
  va_list args ;

  {
  {
#line 347
  __builtin_va_start(args, format);
#line 348
  ds_unsafe_cat_vsprintf(ds, format, args);
#line 350
  __builtin_va_end(args);
  }
#line 355
  return;
}
}
#line 367 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
char *ds_getdelim(struct dstring *s , char eos , FILE *f ) 
{ 
  int insize ;
  int strsize ;
  int next_ch ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 375
  insize = 0;
#line 376
  strsize = (int )s->len;
#line 379
  next_ch = _IO_getc(f);
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (next_ch != (int )eos) {
#line 380
      if (! (next_ch != -1)) {
#line 380
        goto while_break;
      }
    } else {
#line 380
      goto while_break;
    }
#line 382
    if (insize >= strsize - 1) {
      {
#line 384
      ds_grow(s);
#line 385
      strsize = (int )s->len;
      }
    }
    {
#line 387
    tmp = insize;
#line 387
    insize ++;
#line 387
    *(s->content + tmp) = (char )next_ch;
#line 388
    next_ch = _IO_getc(f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  tmp___0 = insize;
#line 390
  insize ++;
#line 390
  *(s->content + tmp___0) = (char )'\000';
#line 392
  if (insize == 1) {
#line 392
    if (next_ch == -1) {
#line 393
      return ((char *)((void *)0));
    } else {
#line 395
      return (s->content);
    }
  } else {
#line 395
    return (s->content);
  }
}
}
#line 398 "/home/ysko/Works/test-src/a2ps-4.14/lib/dstring.c"
char *ds_getline(struct dstring *s , FILE *f ) 
{ 
  char *tmp ;

  {
  {
#line 401
  tmp = ds_getdelim(s, (char )'\n', f);
  }
#line 401
  return (tmp);
}
}
#line 46 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static unsigned long mv_key_hash_1(struct multivalued_entry *key ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    result = 0UL;
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 49
      kk = (unsigned char const   *)key->key - 1;
      {
#line 49
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 49
        kk ++;
#line 49
        if (! *kk) {
#line 49
          goto while_break___1;
        }
#line 49
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 49
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 49
    return (result);
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (0UL);
}
}
#line 52 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static unsigned long mv_key_hash_2(struct multivalued_entry *key ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    result = 0UL;
    {
#line 55
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 55
      kk = (unsigned char const   *)key->key - 1;
      {
#line 55
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 55
        kk ++;
#line 55
        if (! *kk) {
#line 55
          goto while_break___1;
        }
#line 55
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 55
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 55
    return (result);
#line 55
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (0UL);
}
}
#line 58 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static int mv_key_hash_cmp(struct multivalued_entry *x , struct multivalued_entry *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 61
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 61
      xx = (unsigned char const   *)x->key - 1;
#line 61
      yy = (unsigned char const   *)y->key - 1;
      {
#line 61
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 61
        xx ++;
#line 61
        if ((int const   )*xx == 0) {
#line 61
          yy ++;
#line 61
          goto while_break___1;
        }
#line 61
        yy ++;
#line 61
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 61
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 61
      result = (int )((int const   )*xx - (int const   )*yy);
#line 61
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    return (result);
#line 61
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return (0);
}
}
#line 67 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static struct multivalued_entry *multivalued_entry_new(char const   *type ) 
{ 
  struct multivalued_entry *res___2 ;
  void *tmp ;

  {
  {
#line 70
  tmp = xmalloc((size_t )sizeof(struct multivalued_entry ));
#line 70
  res___2 = (struct multivalued_entry *)tmp;
#line 71
  res___2->key = xstrdup(type);
#line 72
  res___2->entries = (struct string_htable *)string_htable_new();
  }
#line 73
  return (res___2);
}
}
#line 79 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static void multivalued_entry_free(struct multivalued_entry *entry ) 
{ 


  {
  {
#line 82
  free((void *)entry->key);
#line 83
  string_htable_free(entry->entries);
#line 84
  free((void *)entry);
  }
#line 85
  return;
}
}
#line 94 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static struct multivalued_entry token  ;
#line 94 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static struct multivalued_entry *res___0  ;
#line 91 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static struct multivalued_entry *multivalued_entry_get(struct hash_table_s *table ,
                                                       char const   *type ) 
{ 
  void *tmp ;

  {
  {
#line 96
  token.key = (char *)type;
#line 97
  tmp = hash_find_item(table, (void const   *)(& token));
#line 97
  res___0 = (struct multivalued_entry *)tmp;
  }
#line 98
  return (res___0);
}
}
#line 104 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static void multivalued_entry_add(struct hash_table_s *table , struct multivalued_entry *item ) 
{ 
  struct multivalued_entry *old_item ;

  {
  {
#line 110
  old_item = multivalued_entry_get(table, (char const   *)item->key);
  }
#line 111
  if (old_item) {
    {
#line 112
    multivalued_entry_free(old_item);
    }
  }
  {
#line 114
  hash_insert(table, (void *)item);
  }
#line 115
  return;
}
}
#line 121 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static void multivalued_entry_add_couple(hash_table *table , char const   *type ,
                                         char const   *value ) 
{ 
  struct multivalued_entry *sub_table ;

  {
  {
#line 127
  sub_table = multivalued_entry_get(table, type);
  }
#line 128
  if ((unsigned long )sub_table == (unsigned long )((void *)0)) {
    {
#line 129
    sub_table = multivalued_entry_new(type);
#line 130
    multivalued_entry_add(table, sub_table);
    }
  }
  {
#line 133
  string_htable_add(sub_table->entries, value);
  }
#line 134
  return;
}
}
#line 140 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static struct string_htable *multivalued_entry_get_sub_table(struct hash_table_s *table ,
                                                             char const   *type ) 
{ 
  struct multivalued_entry *item ;

  {
  {
#line 145
  item = multivalued_entry_get(table, type);
  }
#line 146
  if (! item) {
#line 147
    return ((struct string_htable *)((void *)0));
  }
#line 148
  return (item->entries);
}
}
#line 155 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static char const   *multivalued_entry_get_sub_item(struct hash_table_s *table , char const   *type ,
                                                    char const   *value ) 
{ 
  struct string_htable *sub_table ;
  char *tmp ;

  {
  {
#line 162
  sub_table = multivalued_entry_get_sub_table(table, type);
  }
#line 163
  if (! sub_table) {
#line 164
    return ((char const   *)((void *)0));
  }
  {
#line 165
  tmp = string_htable_get(sub_table, value);
  }
#line 165
  return ((char const   *)tmp);
}
}
#line 171 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static struct hash_table_s *res___1  ;
#line 168 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
struct hash_table_s *multivalued_table_new(void) 
{ 
  void *tmp ;

  {
  {
#line 173
  tmp = xmalloc((size_t )sizeof(hash_table ));
#line 173
  res___1 = (hash_table *)tmp;
#line 174
  hash_init(res___1, 8UL, (unsigned long (*)(void const   *key ))(& mv_key_hash_1),
            (unsigned long (*)(void const   *key ))(& mv_key_hash_2), (int (*)(void const   *x ,
                                                                               void const   *y ))(& mv_key_hash_cmp));
  }
#line 178
  return (res___1);
}
}
#line 181 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
void multivalued_table_free(struct hash_table_s *table ) 
{ 


  {
  {
#line 184
  hash_free(table, (void (*)(void const   *item ))(& multivalued_entry_free));
#line 185
  free((void *)table);
  }
#line 186
  return;
}
}
#line 194 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
int exist_resource(struct a2ps_job *job___0 , char const   *key , char const   *value ) 
{ 
  char const   *tmp ;

  {
  {
#line 197
  tmp = multivalued_entry_get_sub_item((job___0->status)->needed_resources, key, value);
  }
#line 197
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#line 205 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
void add_supplied_resource(struct a2ps_job *job___0 , char const   *key , char const   *value ) 
{ 


  {
  {
#line 208
  multivalued_entry_add_couple((job___0->status)->supplied_resources, key, value);
  }
#line 209
  return;
}
}
#line 224 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static void multivalued_entry_dump(FILE *stream , int first , char const   *fmt_first ,
                                   char const   *fmt_others , struct multivalued_entry *entry ) 
{ 
  char **values ;
  int i ;
  char **tmp ;

  {
  {
#line 236
  tmp = string_htable_dump_sorted(entry->entries);
#line 236
  values = tmp;
#line 237
  i = 0;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! *(values + i)) {
#line 237
      goto while_break;
    }
#line 238
    if (first) {
      {
#line 239
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)fmt_first,
              entry->key, *(values + i));
#line 240
      first = 0;
      }
    } else {
      {
#line 242
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)fmt_others,
              entry->key, *(values + i));
      }
    }
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  free((void *)values);
  }
#line 247
  return;
}
}
#line 252 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
void dump_supplied_resources(FILE *stream , struct a2ps_job *job___0 ) 
{ 
  int i ;
  multivalued_entry **list ;
  void **tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 258
  tmp = hash_dump((job___0->status)->supplied_resources, (void **)((void *)0), (int (*)(void const   * ,
                                                                                        void const   * ))((void *)0));
#line 258
  list = (multivalued_entry **)tmp;
#line 261
  i = 0;
  }
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! *(list + i)) {
#line 261
      goto while_break;
    }
    {
#line 263
    multivalued_entry_dump(stream, i == 0, "%%%%DocumentSuppliedResources: %s %s\n",
                           "%%%%+ %s %s\n", *(list + i));
#line 261
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  free((void *)list);
  }
#line 268
  return;
}
}
#line 273 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
void add_needed_resource(struct a2ps_job *job___0 , char const   *key , char const   *value ) 
{ 


  {
  {
#line 276
  multivalued_entry_add_couple((job___0->status)->needed_resources, key, value);
  }
#line 277
  return;
}
}
#line 283 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
static char const   *needed_resource_get(a2ps_job *job___0 , char const   *key , char const   *value ) 
{ 
  char const   *tmp ;

  {
  {
#line 286
  tmp = multivalued_entry_get_sub_item((job___0->status)->needed_resources, key, value);
  }
#line 286
  return (tmp);
}
}
#line 293 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
void dump_needed_resources(FILE *stream , struct a2ps_job *job___0 ) 
{ 
  int i ;
  int first ;
  multivalued_entry **list ;
  void **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 297
  first = 1;
#line 300
  tmp = hash_dump((job___0->status)->needed_resources, (void **)((void *)0), (int (*)(void const   * ,
                                                                                      void const   * ))((void *)0));
#line 300
  list = (multivalued_entry **)tmp;
#line 303
  i = 0;
  }
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! *(list + i)) {
#line 303
      goto while_break;
    }
    {
#line 306
    tmp___0 = strcmp((char const   *)(*(list + i))->key, "color");
    }
#line 306
    if (tmp___0 == 0) {
#line 309
      goto __Cont;
    } else {
      {
#line 306
      tmp___1 = strcmp((char const   *)(*(list + i))->key, "file");
      }
#line 306
      if (tmp___1 == 0) {
#line 309
        goto __Cont;
      }
    }
    {
#line 311
    multivalued_entry_dump(stream, first, "%%%%DocumentNeededResources: %s %s\n",
                           "%%%%+ %s %s\n", *(list + i));
#line 315
    first = 0;
    }
    __Cont: /* CIL Label */ 
#line 303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  free((void *)list);
  }
#line 319
  return;
}
}
#line 324 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
void add_process_color(struct a2ps_job *job___0 , char const   *value ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 327
  multivalued_entry_add_couple((job___0->status)->needed_resources, "color", value);
  }
#line 329
  return;
}
}
#line 334 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
void dump_process_color(FILE *stream , struct a2ps_job *job___0 ) 
{ 
  struct string_htable *color_table ;
  int i ;
  char **colors ;
  char **tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 339
  color_table = multivalued_entry_get_sub_table((job___0->status)->needed_resources,
                                                "color");
  }
#line 342
  if (color_table) {
    {
#line 345
    tmp = string_htable_dump_sorted(color_table);
#line 345
    colors = tmp;
    }
#line 347
    if ((unsigned long )*colors != (unsigned long )((void *)0)) {
      {
#line 348
      fputs((char const   */* __restrict  */)"%%DocumentProcessColors: ", (FILE */* __restrict  */)stream);
#line 349
      i = 0;
      }
      {
#line 349
      while (1) {
        while_continue: /* CIL Label */ ;
#line 349
        if (! *(colors + i)) {
#line 349
          goto while_break;
        }
        {
#line 350
        fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s ",
                *(colors + i));
#line 349
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 351
      _IO_putc('\n', stream);
      }
    }
    {
#line 353
    free((void *)colors);
    }
  }
#line 355
  return;
}
}
#line 365 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
void add_required_font(struct a2ps_job *job___0 , char const   *name ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 368
  tmp___0 = a2ps_printers_font_known_p(job___0->printers, name);
  }
#line 368
  if (tmp___0) {
    {
#line 373
    tmp = needed_resource_get(job___0, "font", name);
    }
#line 373
    if (! tmp) {
      {
#line 374
      add_needed_resource(job___0, "font", name);
#line 375
      output(job___0->divertion, "%%%%IncludeResource: font %s\n", name);
      }
    }
  } else {
    {
#line 380
    add_supplied_resource(job___0, "font", name);
    }
  }
#line 382
  return;
}
}
#line 388 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
char **required_fonts_get(struct a2ps_job *job___0 ) 
{ 
  struct string_htable *font_table ;
  char **tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 392
  font_table = multivalued_entry_get_sub_table((job___0->status)->supplied_resources,
                                               "font");
  }
#line 396
  if (font_table) {
    {
#line 397
    tmp = string_htable_dump_sorted(font_table);
    }
#line 397
    return (tmp);
  }
#line 398
  return ((char **)((void *)0));
}
}
#line 409 "/home/ysko/Works/test-src/a2ps-4.14/lib/dsc.c"
void dump_setup(FILE *stream , struct a2ps_job *job___0 ) 
{ 


  {
  {
#line 412
  output_dump((job___0->status)->setup, stream);
  }
#line 413
  return;
}
}
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/lib/document.h"
void authors_print_plain(unsigned char const   *authors , FILE *stream , char const   *before ) ;
#line 40
void authors_print_html(unsigned char const   *authors , FILE *stream , char const   *before ) ;
#line 43
void authors_print_texinfo(unsigned char const   *authors , FILE *stream , char const   *before ) ;
#line 54
void documentation_print_html(unsigned char const   *documentation , char const   *format ,
                              FILE *stream ) ;
#line 112 "/home/ysko/Works/test-src/a2ps-4.14/lib/document.c"
__inline static void authors_print(unsigned char const   *authors , FILE *stream ,
                                   char const   *before , char const   *author_fmt ,
                                   char const   *between , char const   *after ) 
{ 
  char *cp ;
  char *author ;
  char *email ;
  _Bool first ;
  char const   *_tmp_ ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 119
  first = (_Bool)1;
#line 121
  if (! authors) {
#line 122
    return;
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 125
    _tmp_ = (char const   *)authors;
#line 125
    tmp = strlen(_tmp_);
#line 125
    tmp___0 = __builtin_alloca(sizeof(char ) * (unsigned long )(tmp + 1U));
#line 125
    cp = (char *)tmp___0;
#line 125
    strcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)_tmp_);
    }
#line 125
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  cp = strtok((char */* __restrict  */)cp, (char const   */* __restrict  */)",");
  }
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 128
    if (! cp) {
#line 128
      goto while_break___0;
    }
    {
#line 130
    author = cp;
#line 131
    tmp___1 = strcspn((char const   *)author, "<");
#line 131
    email = author + tmp___1;
#line 132
    *(email - 1) = (char )'\000';
#line 133
    email ++;
#line 134
    tmp___2 = strcspn((char const   *)email, ">");
#line 134
    *(email + tmp___2) = (char )'\000';
#line 135
    *(email - 1) = (char )'\000';
#line 136
    tmp___3 = strcmp((char const   *)author, "Akim Demaille");
    }
#line 136
    if (! (tmp___3 == 0)) {
#line 138
      if (first) {
        {
#line 140
        fputs((char const   */* __restrict  */)before, (FILE */* __restrict  */)stream);
#line 141
        first = (_Bool)0;
        }
      } else {
        {
#line 144
        fputs((char const   */* __restrict  */)between, (FILE */* __restrict  */)stream);
        }
      }
      {
#line 145
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)author_fmt,
              author, email);
      }
    }
    {
#line 147
    cp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 149
  if (! first) {
    {
#line 150
    fputs((char const   */* __restrict  */)after, (FILE */* __restrict  */)stream);
    }
  }
#line 151
  return;
}
}
#line 156 "/home/ysko/Works/test-src/a2ps-4.14/lib/document.c"
void authors_print_plain(unsigned char const   *authors , FILE *stream , char const   *before ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 160
  authors_print(authors, stream, before, "%s <%s>", ", ", ".\n");
  }
#line 162
  return;
}
}
#line 167 "/home/ysko/Works/test-src/a2ps-4.14/lib/document.c"
void authors_print_html(unsigned char const   *authors , FILE *stream , char const   *before ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 171
  authors_print(authors, stream, before, "<a href=\"mailto:%2$s\">%1$s</a>", ", ",
                ".\n");
  }
#line 175
  return;
}
}
#line 180 "/home/ysko/Works/test-src/a2ps-4.14/lib/document.c"
void authors_print_texinfo(unsigned char const   *authors , FILE *stream , char const   *before ) 
{ 
  unsigned char *cp ;
  char *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 186
  tmp = xvstrrpl((char const   *)authors, "@", "@@", (void *)0);
#line 186
  cp = (unsigned char *)tmp;
#line 190
  authors_print((unsigned char const   *)cp, stream, before, "%s", ", ", ".\n");
#line 192
  free((void *)cp);
  }
#line 193
  return;
}
}
#line 198 "/home/ysko/Works/test-src/a2ps-4.14/lib/document.c"
void documentation_print_plain(unsigned char const   *documentation , char const   *format ,
                               FILE *stream ) 
{ 
  char *cp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 204
  if (! documentation) {
#line 205
    return;
  }
  {
#line 207
  cp = xvstrrpl((char const   *)documentation, "url(", "", ")url(", " (", ")url",
                ")", "samp(", "`", ")samp", "\'", "emph(", "*", ")emph", "*", "code(",
                "", ")code", "", "@example\n", "", "@end example\n", "", "@end example",
                "", "@itemize\n", "", "@end itemize", "", "@item\n", " - ", "@@",
                "@", (void *)0);
#line 208
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)format,
          cp);
#line 209
  free((void *)cp);
  }
#line 210
  return;
}
}
#line 213 "/home/ysko/Works/test-src/a2ps-4.14/lib/document.c"
void documentation_print_html(unsigned char const   *documentation , char const   *format ,
                              FILE *stream ) 
{ 
  char *cp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 219
  if (! documentation) {
#line 220
    return;
  }
  {
#line 222
  cp = xvstrrpl((char const   *)documentation, "url(", "<a href=\"", ")url(", "\">",
                ")url", "</a>", "emph(", "<emph>", ")emph", "</emph>\'", "samp(",
                "`<code>", ")samp", "</code>\'", "code(", "<code>", ")code", "</code>",
                "@example", "<pre>", "@end example", "</pre>", "@itemize", "<ul>",
                "@end itemize", "</ul>", "@item\n", "<li>", "@@", "@", (void *)0);
#line 223
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)format,
          cp);
#line 224
  free((void *)cp);
  }
#line 225
  return;
}
}
#line 228 "/home/ysko/Works/test-src/a2ps-4.14/lib/document.c"
void documentation_print_texinfo(unsigned char const   *documentation , char const   *format ,
                                 FILE *stream ) 
{ 
  char *cp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 234
  if (! documentation) {
#line 235
    return;
  }
  {
#line 237
  cp = xvstrrpl((char const   *)documentation, "emph(", "@emph{", ")emph", "}", "samp(",
                "@samp{", ")samp", "}", "code(", "@code{", ")code", "}", "url(", "@href{",
                ")url(", ",", ")url", "}", "@itemize", "@itemize @minus", (void *)0);
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)format,
          cp);
#line 239
  free((void *)cp);
  }
#line 240
  return;
}
}
#line 43 "/home/ysko/Works/test-src/a2ps-4.14/lib/dirname.c"
char *dir_name(char const   *path ) 
{ 
  char *newpath ;
  char *slash ;
  int length ;
  void *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 50
  slash = strrchr(path, '/');
  }
#line 51
  if ((unsigned long )slash == (unsigned long )((char *)0)) {
#line 54
    path = ".";
#line 55
    length = 1;
  } else {
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
#line 60
      if ((unsigned long )slash > (unsigned long )path) {
#line 60
        if (! ((int )*slash == 47)) {
#line 60
          goto while_break;
        }
      } else {
#line 60
        goto while_break;
      }
#line 61
      slash --;
    }
    while_break: /* CIL Label */ ;
    }
#line 63
    length = (int )((slash - (char *)path) + 1L);
    zoo_assume(length> 1);
  }
  {
#line 65
  tmp = malloc((size_t )(length + 1));
#line 65
  newpath = (char *)tmp;
  }
#line 66
  if ((unsigned long )newpath == (unsigned long )((char *)0)) {
#line 67
    return ((char *)0);
  }
  {
#line 68
  strncpy((char */* __restrict  */)newpath, (char const   */* __restrict  */)path,
          (size_t )length);
#line 69
  *(newpath + length) = (char)0;
  }
#line 70
  return (newpath);
}
}
#line 61 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.h"
int da_exit_error ;
#line 76
void da_resize(struct darray *arr , size_t size ) ;
#line 77
void da_grow(struct darray *arr ) ;
#line 89
int da_is_sorted(struct darray *arr ) ;
#line 93
int da_equal(struct darray *ar1 , struct darray *ar2 ) ;
#line 95
int da_cmp_equal(struct darray *ar1 , struct darray *ar2 ) ;
#line 96
int da_where(struct darray *arr , void const   *stuff ) ;
#line 97
int da_includes(struct darray *arr , void const   *stuff ) ;
#line 103
void da_insert_at(struct darray *arr , void *elem , size_t where ) ;
#line 106
void da_concat(struct darray *arr , struct darray *arr2 ) ;
#line 107
void da_prefix(struct darray *arr , struct darray *arr2 ) ;
#line 126
void da_merge(struct darray *a1 , struct darray *a2 , void (*free_func)(void * ) ,
              enum da_include_policy policy ) ;
#line 132
void da_maparg(struct darray *arr , void (*func)(void * , void * ) , void *arg ) ;
#line 140
void da_str_printnl(char const   *s1 , FILE *stream ) ;
#line 25 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
int da_exit_error  =    1;
#line 40 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
struct darray *da_new(char const   *name , size_t size , enum da_growth growth , size_t increment ,
                      void (*self_print)(void const   * , FILE *stream ) , int (*cmp)(void const   *k1 ,
                                                                                      void const   *k2 ) ) 
{ 
  struct darray *res___2 ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 49
  if (size == 0U) {
    {
#line 50
    error(da_exit_error, 0, "invalid size for dynamic array `%s\': %d", name, size);
    }
  }
#line 52
  if (increment == 0U) {
#line 52
    if ((unsigned int )growth != 0U) {
      {
#line 53
      error(da_exit_error, 0, "invalid increment for dynamic array `%s\': %d", name,
            increment);
      }
    }
  }
  {
#line 56
  tmp = xmalloc((size_t )sizeof(struct darray ));
#line 56
  res___2 = (struct darray *)tmp;
#line 57
  res___2->name = name;
#line 58
  res___2->original_size = size;
#line 59
  res___2->size = size;
#line 60
  tmp___0 = xcalloc((size_t )sizeof(void *), res___2->size);
#line 60
  res___2->content = (void **)tmp___0;
#line 61
  res___2->growth = growth;
#line 62
  res___2->increment = increment;
#line 63
  res___2->len = (size_t )0;
#line 66
  res___2->self_print = self_print;
#line 67
  res___2->cmp = cmp;
  }
#line 69
  return (res___2);
}
}
#line 72 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
__inline static void _da_erase(struct darray *arr ) 
{ 


  {
#line 75
  if (arr) {
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
#line 76
      if (arr->content) {
        {
#line 76
        free((void *)arr->content);
        }
      }
#line 76
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 77
    free((void *)arr);
    }
  }
#line 79
  return;
}
}
#line 81 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_erase(struct darray *arr ) 
{ 


  {
  {
#line 84
  _da_erase(arr);
  }
#line 85
  return;
}
}
#line 90 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
__inline static void _da_free_content(struct darray *arr , void (*free_func)(void * ) ) 
{ 
  size_t i ;

  {
#line 95
  if (free_func) {
#line 96
    i = (size_t )0;
    {
#line 96
    while (1) {
      while_continue: /* CIL Label */ ;
#line 96
      if (! (i < arr->len)) {
#line 96
        goto while_break;
      }
      {
#line 97
      (*free_func)(*(arr->content + i));
#line 96
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 99
  arr->len = (size_t )0;
#line 100
  return;
}
}
#line 102 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_free_content(struct darray *arr , void (*free_func)(void * ) ) 
{ 


  {
  {
#line 105
  _da_free_content(arr, free_func);
  }
#line 106
  return;
}
}
#line 112 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_free(struct darray *arr , void (*free_func)(void * ) ) 
{ 


  {
  {
#line 115
  _da_free_content(arr, free_func);
#line 116
  _da_erase(arr);
  }
#line 117
  return;
}
}
#line 122 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_print_stats(struct darray *arr , FILE *stream ) 
{ 
  char const   *cp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 125
  cp = (char const   *)((void *)0);
#line 127
  tmp = gettext("Dynamic array `%s\':\n");
#line 127
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp, arr->name);
#line 128
  tmp___0 = gettext("\tload: %d/%d (%2.1f%%)\n");
#line 128
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___0,
          arr->len, arr->size, (100.0 * (double )arr->len) / (double )arr->size);
  }
  {
#line 131
  if ((unsigned int )arr->growth == 0U) {
#line 131
    goto case_0;
  }
#line 135
  if ((unsigned int )arr->growth == 1U) {
#line 135
    goto case_1;
  }
#line 139
  if ((unsigned int )arr->growth == 2U) {
#line 139
    goto case_2;
  }
#line 143
  goto switch_default;
  case_0: /* CIL Label */ 
#line 133
  cp = "[const]";
#line 134
  goto switch_break;
  case_1: /* CIL Label */ 
#line 137
  cp = "+=";
#line 138
  goto switch_break;
  case_2: /* CIL Label */ 
#line 141
  cp = "*=";
#line 142
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 144
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 146
  tmp___1 = gettext("\toriginal size: %d, growth: %s %d\n");
#line 146
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          arr->original_size, cp, arr->increment);
  }
#line 148
  return;
}
}
#line 153 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_resize(struct darray *arr , size_t size ) 
{ 
  void *tmp ;

  {
#line 156
  if (arr->len + 1U < size) {
    {
#line 158
    arr->size = size;
#line 159
    tmp = xrealloc((void *)arr->content, (size_t )(sizeof(void *) * (unsigned long )arr->size));
#line 159
    arr->content = (void **)tmp;
    }
  }
#line 161
  return;
}
}
#line 166 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_grow(struct darray *arr ) 
{ 
  void *tmp ;

  {
  {
#line 170
  if ((unsigned int )arr->growth == 0U) {
#line 170
    goto case_0;
  }
#line 173
  if ((unsigned int )arr->growth == 1U) {
#line 173
    goto case_1;
  }
#line 177
  if ((unsigned int )arr->growth == 2U) {
#line 177
    goto case_2;
  }
#line 181
  goto switch_default;
  case_0: /* CIL Label */ 
#line 171
  return;
  case_1: /* CIL Label */ 
#line 174
  arr->size += arr->increment;
#line 175
  goto switch_break;
  case_2: /* CIL Label */ 
#line 178
  arr->size *= arr->increment;
#line 179
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 182
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 184
  tmp = xrealloc((void *)arr->content, (size_t )(sizeof(void *) * (unsigned long )arr->size));
#line 184
  arr->content = (void **)tmp;
  }
#line 185
  return;
}
}
#line 190 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
struct darray *da_clone(struct darray *array ) 
{ 
  struct darray *res___2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 194
  tmp = xmalloc((size_t )sizeof(*array));
#line 194
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)array,
                   (size_t )sizeof(*array));
#line 194
  res___2 = (struct darray *)tmp___0;
#line 195
  tmp___1 = xmalloc((size_t )(sizeof(*(array->content)) * (unsigned long )array->len));
#line 195
  tmp___2 = memcpy((void */* __restrict  */)tmp___1, (void const   */* __restrict  */)array->content,
                   (size_t )(sizeof(*(array->content)) * (unsigned long )array->len));
#line 195
  res___2->content = (void **)tmp___2;
  }
#line 196
  return (res___2);
}
}
#line 203 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
int da_is_sorted(struct darray *arr ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 208
  i = (size_t )1;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (i < arr->len)) {
#line 208
      goto while_break;
    }
    {
#line 209
    tmp = (*(arr->cmp))((void const   *)*(arr->content + i), (void const   *)*(arr->content + (i - 1U)));
    }
#line 209
    if (tmp < 0) {
#line 210
      return (0);
    }
#line 208
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (1);
}
}
#line 217 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
int da_equal(struct darray *ar1 , struct darray *ar2 ) 
{ 
  size_t i ;

  {
#line 222
  if (ar1->len != ar2->len) {
#line 223
    return (0);
  }
#line 225
  i = (size_t )0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < ar1->len)) {
#line 225
      goto while_break;
    }
#line 226
    if ((unsigned long )*(ar1->content + i) != (unsigned long )*(ar2->content + i)) {
#line 227
      return (0);
    }
#line 225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (1);
}
}
#line 235 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
int da_cmp_equal(struct darray *ar1 , struct darray *ar2 ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 240
  if (ar1->len != ar2->len) {
#line 241
    return (0);
  }
#line 243
  i = (size_t )0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (i < ar1->len)) {
#line 243
      goto while_break;
    }
    {
#line 244
    tmp = (*(ar1->cmp))((void const   *)*(ar1->content + i), (void const   *)*(ar2->content + i));
    }
#line 244
    if (tmp) {
#line 245
      return (0);
    }
#line 243
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return (1);
}
}
#line 253 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
int da_where(struct darray *arr , void const   *stuff ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 258
  i = (size_t )0;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (i < arr->len)) {
#line 258
      goto while_break;
    }
    {
#line 259
    tmp = (*(arr->cmp))((void const   *)*(arr->content + i), stuff);
    }
#line 259
    if (! tmp) {
#line 260
      return ((int )i);
    }
#line 258
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (-1);
}
}
#line 268 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
int da_includes(struct darray *arr , void const   *stuff ) 
{ 
  int tmp ;

  {
  {
#line 271
  tmp = da_where(arr, stuff);
  }
#line 271
  return (tmp != -1);
}
}
#line 277 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_append(struct darray *arr , void *elem ) 
{ 
  size_t tmp ;

  {
#line 280
  if (arr->len + 1U >= arr->size) {
    {
#line 281
    da_grow(arr);
    }
  }
#line 283
  tmp = arr->len;
#line 283
  (arr->len) ++;
#line 283
  *(arr->content + tmp) = elem;
#line 284
  return;
}
}
#line 289 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_insert_at(struct darray *arr , void *elem , size_t where ) 
{ 
  size_t i ;
  char *__cil_tmp5 ;

  {
#line 294
  if (where > arr->len) {
    {
#line 295
    error(da_exit_error, 0, "can\'t insert at %d in darray %s [0,%d]\n", where, arr->name,
          arr->len - 1U);
    }
  }
#line 298
  if (arr->len + 1U >= arr->size) {
    {
#line 299
    da_grow(arr);
    }
  }
#line 301
  i = arr->len;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (where < i)) {
#line 301
      goto while_break;
    }
#line 302
    *(arr->content + i) = *(arr->content + (i - 1U));
#line 301
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  *(arr->content + where) = elem;
#line 305
  (arr->len) ++;
#line 306
  return;
}
}
#line 311 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_remove_at(struct darray *arr , size_t where , void (*free_func)(void * ) ) 
{ 
  size_t i ;
  char *__cil_tmp5 ;

  {
#line 316
  if (where >= arr->len) {
    {
#line 317
    error(da_exit_error, 0, "can\'t remove at %d in darray %s [0,%d]\n", where, arr->name,
          arr->len - 1U);
    }
  }
#line 320
  if (free_func) {
    {
#line 321
    (*free_func)(*(arr->content + where));
    }
  }
#line 323
  i = where + 1U;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (i < arr->len)) {
#line 323
      goto while_break;
    }
#line 324
    *(arr->content + (i - 1U)) = *(arr->content + i);
#line 323
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  (arr->len) --;
#line 327
  return;
}
}
#line 332 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_concat(struct darray *arr , struct darray *arr2 ) 
{ 
  size_t i ;
  size_t len ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 336
  len = arr->len + arr2->len;
#line 338
  if (len > arr->size) {
    {
#line 339
    arr->size = len + 1U;
#line 340
    tmp = xrealloc((void *)arr->content, (size_t )(sizeof(void *) * (unsigned long )arr->size));
#line 340
    arr->content = (void **)tmp;
    }
  }
#line 343
  i = (size_t )0;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (i < arr2->len)) {
#line 343
      goto while_break;
    }
#line 344
    tmp___0 = arr->len;
#line 344
    (arr->len) ++;
#line 344
    *(arr->content + tmp___0) = *(arr2->content + i);
#line 343
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return;
}
}
#line 350 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_prefix(struct darray *arr , struct darray *arr2 ) 
{ 
  int i ;
  size_t len ;
  void *tmp ;

  {
#line 354
  len = arr->len + arr2->len;
#line 356
  if (len > arr->size) {
    {
#line 357
    arr->size = len + 1U;
#line 358
    tmp = xrealloc((void *)arr->content, (size_t )(sizeof(void *) * (unsigned long )arr->size));
#line 358
    arr->content = (void **)tmp;
    }
  }
#line 362
  i = (int )arr->len - 1;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (i >= 0)) {
#line 362
      goto while_break;
    }
#line 363
    *(arr->content + ((size_t )i + arr2->len)) = *(arr->content + i);
#line 362
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  i = 0;
  {
#line 366
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 366
    if (! (i < (int )arr2->len)) {
#line 366
      goto while_break___0;
    }
#line 367
    *(arr->content + i) = *(arr2->content + i);
#line 366
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 369
  arr->len += arr2->len;
#line 370
  return;
}
}
#line 375 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_qsort(struct darray *arr ) 
{ 
  int ir ;
  int j ;
  int k ;
  int l ;
  int i ;
  int jstack ;
  int *istack ;
  void *a ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp20 ;

  {
#line 383
  if (arr->len <= 1U) {
#line 384
    return;
  }
  {
#line 386
  tmp___0 = xmalloc((size_t )(sizeof(int ) * 100UL));
#line 386
  istack = (int *)tmp___0;
#line 387
  ir = (int )(arr->len - 1U);
#line 388
  l = 0;
#line 389
  jstack = 0;
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (ir - l < 37) {
#line 394
      j = l + 1;
      {
#line 394
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 394
        if (! (j <= ir)) {
#line 394
          goto while_break___0;
        }
#line 395
        a = *(arr->content + j);
#line 396
        i = j - 1;
        {
#line 396
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 396
          if (! (i >= l)) {
#line 396
            goto while_break___1;
          }
          {
#line 397
          tmp___1 = (*(arr->cmp))((void const   *)*(arr->content + i), (void const   *)a);
          }
#line 397
          if (tmp___1 <= 0) {
#line 398
            goto while_break___1;
          }
#line 399
          *(arr->content + (i + 1)) = *(arr->content + i);
#line 396
          i --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 401
        *(arr->content + (i + 1)) = a;
#line 394
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 403
      if (jstack == 0) {
#line 404
        goto while_break;
      }
#line 405
      tmp___2 = jstack;
#line 405
      jstack --;
#line 405
      ir = *(istack + tmp___2);
#line 406
      tmp___3 = jstack;
#line 406
      jstack --;
#line 406
      l = *(istack + tmp___3);
    } else {
#line 410
      k = (l + ir) / 2;
      {
#line 411
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 411
        tmp = *(arr->content + k);
#line 411
        *(arr->content + k) = *(arr->content + (l + 1));
#line 411
        *(arr->content + (l + 1)) = tmp;
#line 411
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 412
      tmp___4 = (*(arr->cmp))((void const   *)*(arr->content + l), (void const   *)*(arr->content + ir));
      }
#line 412
      if (tmp___4 > 0) {
        {
#line 413
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 413
          tmp = *(arr->content + l);
#line 413
          *(arr->content + l) = *(arr->content + ir);
#line 413
          *(arr->content + ir) = tmp;
#line 413
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 414
      tmp___5 = (*(arr->cmp))((void const   *)*(arr->content + (l + 1)), (void const   *)*(arr->content + ir));
      }
#line 414
      if (tmp___5 > 0) {
        {
#line 415
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 415
          tmp = *(arr->content + (l + 1));
#line 415
          *(arr->content + (l + 1)) = *(arr->content + ir);
#line 415
          *(arr->content + ir) = tmp;
#line 415
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 416
      tmp___6 = (*(arr->cmp))((void const   *)*(arr->content + l), (void const   *)*(arr->content + (l + 1)));
      }
#line 416
      if (tmp___6 > 0) {
        {
#line 417
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 417
          tmp = *(arr->content + l);
#line 417
          *(arr->content + l) = *(arr->content + (l + 1));
#line 417
          *(arr->content + (l + 1)) = tmp;
#line 417
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 418
      i = l + 1;
#line 419
      j = ir;
#line 420
      a = *(arr->content + (l + 1));
      {
#line 421
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 422
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 422
          i ++;
#line 422
          tmp___7 = (*(arr->cmp))((void const   *)*(arr->content + i), (void const   *)a);
          }
#line 422
          if (! (tmp___7 < 0)) {
#line 422
            goto while_break___7;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 423
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 423
          j --;
#line 423
          tmp___8 = (*(arr->cmp))((void const   *)*(arr->content + j), (void const   *)a);
          }
#line 423
          if (! (tmp___8 > 0)) {
#line 423
            goto while_break___8;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 424
        if (j < i) {
#line 425
          goto while_break___6;
        }
        {
#line 426
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 426
          tmp = *(arr->content + i);
#line 426
          *(arr->content + i) = *(arr->content + j);
#line 426
          *(arr->content + j) = tmp;
#line 426
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 428
      *(arr->content + (l + 1)) = *(arr->content + j);
#line 429
      *(arr->content + j) = a;
#line 430
      jstack += 2;
#line 433
      if (jstack > 100) {
        {
#line 434
        error(da_exit_error, 0, "da_qsort: QSORT_STACK too small (%d)", 100);
        }
      }
#line 436
      if ((ir - i) + 1 >= j - l) {
#line 437
        *(istack + jstack) = ir;
#line 438
        *(istack + (jstack - 1)) = i;
#line 439
        ir = j - 1;
      } else {
#line 441
        *(istack + jstack) = j - 1;
#line 442
        *(istack + (jstack - 1)) = l;
#line 443
        l = i;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 447
  free((void *)istack);
  }
#line 448
  return;
}
}
#line 453 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_qsort_with_arg(struct darray *arr , int (*cmp)(void const   *k1 , void const   *k2 ,
                                                       void const   *arg ) , void const   *arg ) 
{ 
  int ir ;
  int j ;
  int k ;
  int l ;
  int i ;
  int jstack ;
  int *istack ;
  void *a ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp22 ;

  {
#line 462
  if (arr->len <= 1U) {
#line 463
    return;
  }
  {
#line 465
  tmp___0 = xmalloc((size_t )(sizeof(int ) * 100UL));
#line 465
  istack = (int *)tmp___0;
#line 466
  ir = (int )(arr->len - 1U);
#line 467
  l = 0;
#line 468
  jstack = 0;
  }
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (ir - l < 37) {
#line 473
      j = l + 1;
      {
#line 473
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 473
        if (! (j <= ir)) {
#line 473
          goto while_break___0;
        }
#line 474
        a = *(arr->content + j);
#line 475
        i = j - 1;
        {
#line 475
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 475
          if (! (i >= l)) {
#line 475
            goto while_break___1;
          }
          {
#line 476
          tmp___1 = (*cmp)((void const   *)*(arr->content + i), (void const   *)a,
                           arg);
          }
#line 476
          if (tmp___1 <= 0) {
#line 477
            goto while_break___1;
          }
#line 478
          *(arr->content + (i + 1)) = *(arr->content + i);
#line 475
          i --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 480
        *(arr->content + (i + 1)) = a;
#line 473
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 482
      if (jstack == 0) {
#line 483
        goto while_break;
      }
#line 484
      tmp___2 = jstack;
#line 484
      jstack --;
#line 484
      ir = *(istack + tmp___2);
#line 485
      tmp___3 = jstack;
#line 485
      jstack --;
#line 485
      l = *(istack + tmp___3);
    } else {
#line 489
      k = (l + ir) / 2;
      {
#line 490
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 490
        tmp = *(arr->content + k);
#line 490
        *(arr->content + k) = *(arr->content + (l + 1));
#line 490
        *(arr->content + (l + 1)) = tmp;
#line 490
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 491
      tmp___4 = (*cmp)((void const   *)*(arr->content + l), (void const   *)*(arr->content + ir),
                       arg);
      }
#line 491
      if (tmp___4 > 0) {
        {
#line 492
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 492
          tmp = *(arr->content + l);
#line 492
          *(arr->content + l) = *(arr->content + ir);
#line 492
          *(arr->content + ir) = tmp;
#line 492
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 493
      tmp___5 = (*cmp)((void const   *)*(arr->content + (l + 1)), (void const   *)*(arr->content + ir),
                       arg);
      }
#line 493
      if (tmp___5 > 0) {
        {
#line 494
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 494
          tmp = *(arr->content + (l + 1));
#line 494
          *(arr->content + (l + 1)) = *(arr->content + ir);
#line 494
          *(arr->content + ir) = tmp;
#line 494
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      {
#line 495
      tmp___6 = (*cmp)((void const   *)*(arr->content + l), (void const   *)*(arr->content + (l + 1)),
                       arg);
      }
#line 495
      if (tmp___6 > 0) {
        {
#line 496
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 496
          tmp = *(arr->content + l);
#line 496
          *(arr->content + l) = *(arr->content + (l + 1));
#line 496
          *(arr->content + (l + 1)) = tmp;
#line 496
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 497
      i = l + 1;
#line 498
      j = ir;
#line 499
      a = *(arr->content + (l + 1));
      {
#line 500
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 501
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 501
          i ++;
#line 501
          tmp___7 = (*cmp)((void const   *)*(arr->content + i), (void const   *)a,
                           arg);
          }
#line 501
          if (! (tmp___7 < 0)) {
#line 501
            goto while_break___7;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 502
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 502
          j --;
#line 502
          tmp___8 = (*cmp)((void const   *)*(arr->content + j), (void const   *)a,
                           arg);
          }
#line 502
          if (! (tmp___8 > 0)) {
#line 502
            goto while_break___8;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 503
        if (j < i) {
#line 504
          goto while_break___6;
        }
        {
#line 505
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 505
          tmp = *(arr->content + i);
#line 505
          *(arr->content + i) = *(arr->content + j);
#line 505
          *(arr->content + j) = tmp;
#line 505
          goto while_break___9;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 507
      *(arr->content + (l + 1)) = *(arr->content + j);
#line 508
      *(arr->content + j) = a;
#line 509
      jstack += 2;
#line 512
      if (jstack > 100) {
        {
#line 513
        error(da_exit_error, 0, "da_qsort: QSORT_STACK too small (%d)", 100);
        }
      }
#line 515
      if ((ir - i) + 1 >= j - l) {
#line 516
        *(istack + jstack) = ir;
#line 517
        *(istack + (jstack - 1)) = i;
#line 518
        ir = j - 1;
      } else {
#line 520
        *(istack + jstack) = j - 1;
#line 521
        *(istack + (jstack - 1)) = l;
#line 522
        l = i;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 526
  free((void *)istack);
  }
#line 527
  return;
}
}
#line 532 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_unique(struct darray *arr , void (*free_func)(void * ) ) 
{ 
  size_t c ;
  int tmp ;

  {
#line 537
  c = (size_t )1;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (! (c < arr->len)) {
#line 538
      goto while_break;
    }
    {
#line 539
    tmp = (*(arr->cmp))((void const   *)*(arr->content + (c - 1U)), (void const   *)*(arr->content + c));
    }
#line 539
    if (tmp == 0) {
      {
#line 540
      da_remove_at(arr, c, free_func);
      }
    } else {
#line 542
      c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 559 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_merge(struct darray *a1 , struct darray *a2 , void (*free_func)(void * ) ,
              enum da_include_policy policy ) 
{ 
  size_t c1 ;
  size_t c2 ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 565
  c2 = (size_t )0;
#line 565
  c1 = c2;
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    if (! (c1 != a1->len)) {
#line 567
      if (! (c2 != a2->len)) {
#line 567
        goto while_break;
      }
    }
    {
#line 571
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 571
      if (c1 < a1->len) {
#line 571
        if (! (c2 == a2->len)) {
          {
#line 571
          tmp = (*(a1->cmp))((void const   *)*(a1->content + c1), (void const   *)*(a2->content + c2));
          }
#line 571
          if (! (tmp < 0)) {
#line 571
            goto while_break___0;
          }
        }
      } else {
#line 571
        goto while_break___0;
      }
#line 574
      c1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 577
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 577
      if (c1 < a1->len) {
#line 577
        if (c2 < a2->len) {
          {
#line 577
          tmp___0 = (*(a1->cmp))((void const   *)*(a1->content + c1), (void const   *)*(a2->content + c2));
          }
#line 577
          if (! (tmp___0 == 0)) {
#line 577
            goto while_break___1;
          }
        } else {
#line 577
          goto while_break___1;
        }
      } else {
#line 577
        goto while_break___1;
      }
#line 579
      if ((unsigned int )policy == 0U) {
#line 581
        if (free_func) {
          {
#line 582
          da_remove_at(a2, c2, free_func);
          }
        } else {
#line 584
          c2 ++;
        }
      } else
#line 588
      if (free_func) {
        {
#line 589
        da_remove_at(a1, c1, free_func);
        }
      } else {
#line 591
        c1 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 596
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 596
      if (c2 < a2->len) {
#line 596
        if (! (c1 == a1->len)) {
          {
#line 596
          tmp___2 = (*(a1->cmp))((void const   *)*(a1->content + c1), (void const   *)*(a2->content + c2));
          }
#line 596
          if (! (tmp___2 >= 0)) {
#line 596
            goto while_break___2;
          }
        }
      } else {
#line 596
        goto while_break___2;
      }
      {
#line 599
      tmp___1 = c2;
#line 599
      c2 ++;
#line 599
      da_insert_at(a1, *(a2->content + tmp___1), c1);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  return;
}
}
#line 607 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_self_print(struct darray *arr , FILE *stream ) 
{ 
  size_t i ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 612
  tmp = gettext("Dynamic array `%s\':\n");
#line 612
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp, arr->name);
  }
#line 613
  if (! arr->self_print) {
    {
#line 614
    abort();
    }
  }
#line 615
  i = (size_t )0;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! (i < arr->len)) {
#line 615
      goto while_break;
    }
    {
#line 616
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"[%2d] = ",
            i);
#line 617
    (*(arr->self_print))((void const   *)*(arr->content + i), stream);
#line 618
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n");
#line 615
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  return;
}
}
#line 625 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_map(struct darray *arr , void (*fn)(void * ) ) 
{ 
  size_t i ;

  {
#line 630
  i = (size_t )0;
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! (i < arr->len)) {
#line 630
      goto while_break;
    }
    {
#line 631
    (*fn)(*(arr->content + i));
#line 630
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  return;
}
}
#line 637 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_maparg(struct darray *arr , void (*func)(void * , void * ) , void *arg ) 
{ 
  size_t i ;

  {
#line 641
  i = (size_t )0;
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! (i < arr->len)) {
#line 641
      goto while_break;
    }
    {
#line 642
    (*func)(*(arr->content + i), arg);
#line 641
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 643
  return;
}
}
#line 651 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
int da_str_cmp(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;

  {
  {
#line 654
  tmp = strcmp(s1, s2);
  }
#line 654
  return (tmp);
}
}
#line 657 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_str_print(char const   *s1 , FILE *stream ) 
{ 


  {
  {
#line 660
  fputs((char const   */* __restrict  */)s1, (FILE */* __restrict  */)stream);
  }
#line 661
  return;
}
}
#line 663 "/home/ysko/Works/test-src/a2ps-4.14/lib/darray.c"
void da_str_printnl(char const   *s1 , FILE *stream ) 
{ 


  {
  {
#line 666
  fputs((char const   */* __restrict  */)s1, (FILE */* __restrict  */)stream);
#line 667
  _IO_putc('\n', stream);
  }
#line 668
  return;
}
}
#line 44 "/home/ysko/Works/test-src/a2ps-4.14/lib/confg.h"
void (*delegation_hook)(char const   *filename , int line , char *config_line ) ;
#line 45
void (*toc_entry_hook)(char const   *filename , int line , char *config_line ) ;
#line 51
int a2_read_config(struct a2ps_job *job___0 , char const   *path , char const   *file ) ;
#line 58
void a2_read_sys_config(struct a2ps_job *job___0 ) ;
#line 56 "confg.gperf"
void (*delegation_hook)(char const   *filename , int line , char *config_line )  =    (void (*)(char const   *filename ,
             int line , char *config_line ))((void *)0);
#line 57 "confg.gperf"
void (*toc_entry_hook)(char const   *filename , int line , char *config_line )  =    (void (*)(char const   *filename ,
             int line , char *config_line ))((void *)0);
#line 109
__inline static unsigned int hash(char const   *str , unsigned int len ) ;
#line 109 "confg.gperf"
static unsigned char asso_values[256]  = 
#line 109
  {      (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)10, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)15,      (unsigned char)34,      (unsigned char)34,      (unsigned char)15, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)5,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)0,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)10,      (unsigned char)34,      (unsigned char)10, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)15,      (unsigned char)5, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)20,      (unsigned char)0,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34, 
        (unsigned char)34,      (unsigned char)34,      (unsigned char)34,      (unsigned char)34};
#line 100 "confg.gperf"
__inline static unsigned int hash(char const   *str , unsigned int len ) 
{ 


  {
#line 138
  return (len + (unsigned int )asso_values[(unsigned char )*(str + 4)]);
}
}
#line 150
__inline struct keyword_s *in_word_set(char const   *str , unsigned int len ) ;
#line 150 "confg.gperf"
static struct keyword_s wordlist[21]  = 
#line 150
  {      {"Media:", (enum keyword_e )7, 2, (_Bool)1}, 
        {"Medium:", (enum keyword_e )7, 2, (_Bool)1}, 
        {"Include:", (enum keyword_e )5, 1, (_Bool)0}, 
        {"Variable:", (enum keyword_e )16, 2, (_Bool)1}, 
        {"DefaultPPD:", (enum keyword_e )1, 1, (_Bool)0}, 
        {"LibraryPath:", (enum keyword_e )6, 1, (_Bool)0}, 
        {"Options:", (enum keyword_e )9, 1, (_Bool)1}, 
        {"DefaultPrinter:", (enum keyword_e )2, 1, (_Bool)1}, 
        {"OutputFirstLine:", (enum keyword_e )10, 1, (_Bool)1}, 
        {"PassThrough:", (enum keyword_e )8, 1, (_Bool)1}, 
        {"Pattern:", (enum keyword_e )8, 1, (_Bool)1}, 
        {"UnknownPrinter:", (enum keyword_e )14, 1, (_Bool)1}, 
        {"Delegation:", (enum keyword_e )3, 1, (_Bool)1}, 
        {"FileCommand:", (enum keyword_e )4, 1, (_Bool)1}, 
        {"MacroMetaSequence:", (enum keyword_e )16, 2, (_Bool)1}, 
        {"TemporaryDirectory:", (enum keyword_e )8, 1, (_Bool)1}, 
        {"UserOption:", (enum keyword_e )15, 2, (_Bool)1}, 
        {"Printer:", (enum keyword_e )13, 2, (_Bool)1}, 
        {"PrependLibraryPath:", (enum keyword_e )12, 1, (_Bool)1}, 
        {"PageLabelFormat:", (enum keyword_e )11, 1, (_Bool)1}, 
        {"AppendLibraryPath:", (enum keyword_e )0, 1, (_Bool)1}};
#line 95 "confg.gperf"
static short lookup[34]  = 
#line 95
  {      (short)-1,      (short)-1,      (short)-1,      (short)-1, 
        (short)-1,      (short)-1,      (short)0,      (short)1, 
        (short)2,      (short)3,      (short)-1,      (short)4, 
        (short)5,      (short)6,      (short)-1,      (short)7, 
        (short)8,      (short)9,      (short)10,      (short)-1, 
        (short)11,      (short)12,      (short)13,      (short)14, 
        (short)15,      (short)-1,      (short)16,      (short)-1, 
        (short)17,      (short)18,      (short)-1,      (short)19, 
        (short)-1,      (short)20};
#line 142 "confg.gperf"
__inline struct keyword_s *in_word_set(char const   *str , unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register int index___0 ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 102
  if (len <= 19U) {
#line 102
    if (len >= 6U) {
      {
#line 104
      tmp = hash(str, len);
#line 104
      key = (int )tmp;
      }
#line 106
      if (key <= 33) {
#line 106
        if (key >= 0) {
#line 108
          index___0 = (int )lookup[key];
#line 110
          if (index___0 >= 0) {
#line 112
            s = wordlist[index___0].name;
#line 114
            if ((int const   )*str == (int const   )*s) {
              {
#line 114
              tmp___0 = strcmp(str + 1, s + 1);
              }
#line 114
              if (! tmp___0) {
#line 115
                return (& wordlist[index___0]);
              }
            }
          }
        }
      }
    }
  }
#line 119
  return ((struct keyword_s *)0);
}
}
#line 117 "confg.gperf"
int a2_read_config(struct a2ps_job *job___0 , char const   *path , char const   *file ) 
{ 
  FILE *fp ;
  char *fname ;
  char *buf___0 ;
  size_t bufsiz ;
  int firstline ;
  int lastline ;
  struct keyword_s *keyword ;
  int argc ;
  char *argv[10] ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *dir ;
  char *included_file ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  char *old_program_name ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  _Bool tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  _Bool tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  _Bool tmp___27 ;
  unsigned char const   *my_s2 ;
  char *tmp___28 ;
  unsigned char const   *my_s2___0 ;
  char *tmp___29 ;
  int w ;
  int h ;
  int llx ;
  int lly ;
  int urx ;
  int ury ;
  int tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  _Bool tmp___34 ;
  char const   *my_s2___1 ;
  char *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  void *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;

  {
  {
#line 124
  buf___0 = (char *)((void *)0);
#line 125
  bufsiz = (size_t )0;
#line 126
  firstline = 0;
#line 126
  lastline = 0;
#line 128
  fname = xpath_concat(path, file, (char **)((void *)0));
#line 130
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 131
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 133
    free((void *)fname);
    }
#line 134
    return (0);
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if ((unsigned int )((1 << 5) | (1 << 6)) & msg_verbosity) {
      {
#line 137
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading configuration file `%s\'\n",
              fname);
      }
    }
#line 137
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 140
    tmp___37 = getshline_numbered(& firstline, & lastline, & buf___0, & bufsiz, fp);
    }
#line 140
    if (! (tmp___37 != -1)) {
#line 140
      goto while_break___0;
    }
    {
#line 148
    argv[0] = strtok((char */* __restrict  */)buf___0, (char const   */* __restrict  */)" \t\n");
    }
#line 151
    if (! argv[0]) {
#line 152
      goto while_continue___0;
    }
    {
#line 154
    tmp = strlen((char const   *)argv[0]);
#line 154
    keyword = in_word_set((char const   *)argv[0], tmp);
    }
#line 155
    if (! keyword) {
      {
#line 156
      tmp___0 = quotearg((char const   *)argv[0]);
#line 156
      tmp___1 = gettext("invalid option `%s\'");
#line 156
      error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, (char const   *)tmp___1,
                    tmp___0);
      }
    }
#line 160
    argc = 1;
    {
#line 160
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 160
      if (! (argc <= keyword->argc)) {
#line 160
        goto while_break___1;
      }
#line 162
      if (keyword->line_token) {
#line 162
        if (argc == keyword->argc) {
          {
#line 163
          argv[argc] = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
          }
        } else {
          {
#line 165
          argv[argc] = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
          }
        }
      } else {
        {
#line 165
        argv[argc] = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
        }
      }
#line 166
      if ((unsigned long )argv[argc] == (unsigned long )((void *)0)) {
        {
#line 167
        tmp___2 = quotearg((char const   *)argv[0]);
#line 167
        tmp___3 = gettext("missing argument for `%s\'");
#line 167
        error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, (char const   *)tmp___3,
                      tmp___2);
        }
      }
#line 160
      argc ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 171
    tmp___5 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
    }
#line 171
    if (tmp___5) {
      {
#line 172
      tmp___4 = quotearg((char const   *)argv[0]);
#line 172
      error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, "extra argument for `%s\'",
                    tmp___4);
      }
    }
    {
#line 178
    if ((unsigned int )keyword->code == 5U) {
#line 178
      goto case_5;
    }
#line 200
    if ((unsigned int )keyword->code == 9U) {
#line 200
      goto case_9;
    }
#line 216
    if ((unsigned int )keyword->code == 1U) {
#line 216
      goto case_1;
    }
#line 221
    if ((unsigned int )keyword->code == 13U) {
#line 221
      goto case_13;
    }
#line 228
    if ((unsigned int )keyword->code == 14U) {
#line 228
      goto case_14;
    }
#line 235
    if ((unsigned int )keyword->code == 2U) {
#line 235
      goto case_2;
    }
#line 242
    if ((unsigned int )keyword->code == 3U) {
#line 242
      goto case_3;
    }
#line 249
    if ((unsigned int )keyword->code == 15U) {
#line 249
      goto case_15;
    }
#line 253
    if ((unsigned int )keyword->code == 10U) {
#line 253
      goto case_10;
    }
#line 257
    if ((unsigned int )keyword->code == 11U) {
#line 257
      goto case_11;
    }
#line 261
    if ((unsigned int )keyword->code == 7U) {
#line 261
      goto case_7;
    }
#line 289
    if ((unsigned int )keyword->code == 16U) {
#line 289
      goto case_16;
    }
#line 297
    if ((unsigned int )keyword->code == 6U) {
#line 297
      goto case_6___0;
    }
#line 302
    if ((unsigned int )keyword->code == 0U) {
#line 302
      goto case_0;
    }
#line 307
    if ((unsigned int )keyword->code == 12U) {
#line 307
      goto case_12;
    }
#line 312
    if ((unsigned int )keyword->code == 4U) {
#line 312
      goto case_4;
    }
#line 316
    if ((unsigned int )keyword->code == 8U) {
#line 316
      goto case_8;
    }
#line 176
    goto switch_break;
    case_5: /* CIL Label */ 
#line 181
    if ((int )*(argv[1]) == 47) {
#line 183
      dir = (char *)((void *)0);
    } else {
      {
#line 186
      dir = dir_name((char const   *)fname);
      }
    }
    {
#line 188
    tmp___10 = a2_read_config(job___0, (char const   *)dir, (char const   *)argv[1]);
    }
#line 188
    if (! tmp___10) {
      {
#line 190
      tmp___6 = xpath_concat((char const   *)dir, (char const   *)argv[1], (char **)((void *)0));
#line 190
      included_file = tmp___6;
#line 191
      tmp___7 = quotearg((char const   *)included_file);
#line 191
      tmp___8 = gettext("cannot open file `%s\'");
#line 191
      tmp___9 = __errno_location();
#line 191
      error_at_line(0, *tmp___9, (char const   *)fname, (unsigned int )firstline,
                    (char const   *)tmp___8, tmp___7);
#line 194
      free((void *)included_file);
      }
    }
    {
#line 196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 196
      if (dir) {
        {
#line 196
        free((void *)dir);
        }
      }
#line 196
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 198
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 204
    old_program_name = program_name;
#line 205
    tmp___11 = strlen((char const   *)program_name);
#line 205
    tmp___12 = strlen((char const   *)fname);
#line 205
    tmp___13 = strlen("%:%:999990");
#line 205
    tmp___14 = __builtin_alloca(sizeof(char ) * (unsigned long )((tmp___11 + tmp___12) + tmp___13));
#line 205
    program_name = (char *)tmp___14;
#line 209
    sprintf((char */* __restrict  */)program_name, (char const   */* __restrict  */)"%s:%s:%d",
            old_program_name, fname, firstline);
#line 211
    a2ps_handle_string_options(job___0, (char const   *)argv[1]);
#line 212
    program_name = old_program_name;
    }
#line 214
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 217
    a2ps_printers_default_ppdkey_set(job___0->printers, (char const   *)argv[1]);
    }
#line 218
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 222
    tmp___17 = a2ps_printers_add(job___0->printers, (char const   *)argv[1], argv[2]);
    }
#line 222
    if (! tmp___17) {
      {
#line 223
      tmp___15 = quotearg((char const   *)argv[2]);
#line 223
      tmp___16 = gettext("invalid definition for printer `%s\': %s");
#line 223
      error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, (char const   *)tmp___16,
                    argv[1], tmp___15);
      }
    }
#line 226
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 229
    tmp___21 = gettext("Unknown Printer");
#line 229
    tmp___22 = a2ps_printers_add(job___0->printers, (char const   *)tmp___21, argv[1]);
    }
#line 229
    if (! tmp___22) {
      {
#line 230
      tmp___18 = quotearg((char const   *)argv[1]);
#line 230
      tmp___19 = gettext("Unknown Printer");
#line 230
      tmp___20 = gettext("invalid definition for printer `%s\': %s");
#line 230
      error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, (char const   *)tmp___20,
                    tmp___19, tmp___18);
      }
    }
#line 233
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 236
    tmp___26 = gettext("Default Printer");
#line 236
    tmp___27 = a2ps_printers_add(job___0->printers, (char const   *)tmp___26, argv[1]);
    }
#line 236
    if (! tmp___27) {
      {
#line 237
      tmp___23 = quotearg((char const   *)argv[1]);
#line 237
      tmp___24 = gettext("Default Printer");
#line 237
      tmp___25 = gettext("invalid definition for printer `%s\': %s");
#line 237
      error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, (char const   *)tmp___25,
                    tmp___24, tmp___23);
      }
    }
#line 240
    goto switch_break;
    case_3: /* CIL Label */ 
#line 245
    if (delegation_hook) {
      {
#line 246
      (*delegation_hook)((char const   *)fname, firstline, argv[1]);
      }
    }
#line 247
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 250
    user_option_add(job___0, (char const   *)argv[1], (char const   *)argv[2]);
    }
#line 251
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 254
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 254
      my_s2 = (unsigned char const   *)((unsigned char *)argv[1]);
      {
#line 254
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 254
        if ((job___0->status)->magic_number) {
          {
#line 254
          free((void *)(job___0->status)->magic_number);
          }
        }
#line 254
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 254
      if ((unsigned long )((char const   *)my_s2) == (unsigned long )((void *)0)) {
#line 254
        (job___0->status)->magic_number = (unsigned char *)((void *)0);
      } else
#line 254
      if ((int const   )*my_s2 == 0) {
#line 254
        (job___0->status)->magic_number = (unsigned char *)((void *)0);
      } else {
        {
#line 254
        tmp___28 = xstrdup((char const   *)my_s2);
#line 254
        (job___0->status)->magic_number = (unsigned char *)tmp___28;
        }
      }
#line 254
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 255
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 258
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 258
      my_s2___0 = (unsigned char const   *)((unsigned char *)argv[1]);
      {
#line 258
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 258
        if ((job___0->status)->page_label_format) {
          {
#line 258
          free((void *)(job___0->status)->page_label_format);
          }
        }
#line 258
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 258
      if ((unsigned long )((char const   *)my_s2___0) == (unsigned long )((void *)0)) {
#line 258
        (job___0->status)->page_label_format = (unsigned char *)((void *)0);
      } else
#line 258
      if ((int const   )*my_s2___0 == 0) {
#line 258
        (job___0->status)->page_label_format = (unsigned char *)((void *)0);
      } else {
        {
#line 258
        tmp___29 = xstrdup((char const   *)my_s2___0);
#line 258
        (job___0->status)->page_label_format = (unsigned char *)tmp___29;
        }
      }
#line 258
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 259
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 265
    tmp___30 = sscanf((char const   */* __restrict  */)argv[2], (char const   */* __restrict  */)"%d %d %d %d %d %d",
                      & w, & h, & llx, & lly, & urx, & ury);
    }
    {
#line 268
    if (tmp___30 == 6) {
#line 268
      goto case_6;
    }
#line 272
    if (tmp___30 == 2) {
#line 272
      goto case_2___0;
    }
#line 280
    goto switch_default;
    case_6: /* CIL Label */ 
#line 270
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 275
    lly = 24;
#line 275
    llx = lly;
#line 276
    urx = w - 24;
#line 277
    ury = h - 24;
#line 278
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 281
    tmp___31 = quotearg((char const   *)argv[0]);
#line 281
    error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, "invalid number of arguments for `%s\'",
                  tmp___31);
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 285
    add_medium(job___0, (char const   *)argv[1], w, h, llx, lly, urx, ury);
    }
#line 287
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 290
    tmp___34 = macro_meta_sequence_add(job___0, (char const   *)argv[1], (char const   *)argv[2]);
    }
#line 290
    if (! tmp___34) {
      {
#line 291
      tmp___32 = quotearg((char const   *)argv[1]);
#line 291
      tmp___33 = gettext("invalid variable identifier `%s\'");
#line 291
      error_at_line(1, 0, (char const   *)fname, (unsigned int )firstline, (char const   *)tmp___33,
                    tmp___32);
      }
    }
#line 294
    goto switch_break;
    case_6___0: /* CIL Label */ 
    {
#line 298
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 298
      if (job___0->common.path) {
        {
#line 298
        free((void *)job___0->common.path);
        }
      }
#line 298
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 299
    job___0->common.path = pw_string_to_path((char const   *)argv[1]);
    }
#line 300
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 303
    job___0->common.path = pw_append_string_to_path(job___0->common.path, (char const   *)argv[1]);
    }
#line 305
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 308
    job___0->common.path = pw_prepend_string_to_path(job___0->common.path, (char const   *)argv[1]);
    }
#line 310
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 313
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 313
      my_s2___1 = (char const   *)argv[1];
      {
#line 313
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 313
        if (job___0->file_command) {
          {
#line 313
          free((void *)job___0->file_command);
          }
        }
#line 313
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 313
      if ((unsigned long )my_s2___1 == (unsigned long )((void *)0)) {
#line 313
        job___0->file_command = (char *)((void *)0);
      } else
#line 313
      if ((int const   )*my_s2___1 == 0) {
#line 313
        job___0->file_command = (char *)((void *)0);
      } else {
        {
#line 313
        tmp___35 = xstrdup(my_s2___1);
#line 313
        job___0->file_command = tmp___35;
        }
      }
#line 313
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 314
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 320
    tmp___36 = gettext("obsolete `%s\' entry.  Ignored");
#line 320
    error_at_line(0, 0, (char const   *)fname, (unsigned int )firstline, (char const   *)tmp___36,
                  argv[0]);
    }
#line 322
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 325
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 325
    if (fname) {
      {
#line 325
      free((void *)fname);
      }
    }
#line 325
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 326
  fclose(fp);
#line 328
  free((void *)buf___0);
  }
#line 329
  return (1);
}
}
#line 341 "confg.gperf"
void a2_read_sys_config(struct a2ps_job *job___0 ) 
{ 
  char const   *config_file ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 346
  tmp = getenv("A2PS_CONFIG");
#line 346
  config_file = (char const   *)tmp;
  }
#line 347
  if (! config_file) {
#line 348
    config_file = "/usr/local/etc/a2ps.cfg";
  }
  {
#line 352
  tmp___0 = a2_read_config(job___0, (char const   *)((void *)0), config_file);
  }
#line 352
  if (tmp___0) {
#line 353
    return;
  }
  {
#line 354
  tmp___1 = quotearg(config_file);
#line 354
  tmp___2 = gettext("cannot open file `%s\'");
#line 354
  tmp___3 = __errno_location();
#line 354
  error(0, *tmp___3, (char const   *)tmp___2, tmp___1);
  }
#line 356
  return;
}
}
#line 52 "/home/ysko/Works/test-src/a2ps-4.14/lib/common.h"
struct a2ps_common_s *a2ps_common_new(void) ;
#line 39 "/home/ysko/Works/test-src/a2ps-4.14/lib/common.c"
void a2ps_common_reset(struct a2ps_common_s *common ) 
{ 


  {
#line 42
  common->path = (char **)((void *)0);
#line 43
  return;
}
}
#line 48 "/home/ysko/Works/test-src/a2ps-4.14/lib/common.c"
struct a2ps_common_s *a2ps_common_new(void) 
{ 
  struct a2ps_common_s *res___2 ;
  void *tmp ;

  {
  {
#line 51
  tmp = xmalloc((size_t )sizeof(struct a2ps_common_s ));
#line 51
  res___2 = (struct a2ps_common_s *)tmp;
#line 52
  a2ps_common_reset(res___2);
  }
#line 53
  return (res___2);
}
}
#line 59 "/home/ysko/Works/test-src/a2ps-4.14/lib/common.c"
void a2ps_common_free(struct a2ps_common_s *common ) 
{ 


  {
  {
#line 62
  pw_free_path(common->path);
  }
#line 63
  return;
}
}
#line 69 "/home/ysko/Works/test-src/a2ps-4.14/lib/common.c"
void a2ps_common_finalize(struct a2ps_common_s *common , char const   *home ) 
{ 
  char buf___0[512] ;
  char *tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 76
  tmp = getenv("NO_HOME_CONF");
  }
#line 76
  if (! tmp) {
    {
#line 78
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s%c.a2ps",
            home, '/');
#line 79
    common->path = pw_prepend_string_to_path(common->path, (char const   *)(buf___0));
    }
  }
#line 81
  return;
}
}
#line 9 "/home/ysko/Works/test-src/a2ps-4.14/lib/closeout.h"
void close_stdout(void) ;
#line 10
void close_stdout_status(int status ) ;
#line 67 "/home/ysko/Works/test-src/a2ps-4.14/lib/closeout.c"
void close_stdout_status(int status ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 70
  tmp___0 = ferror(stdout);
  }
#line 70
  if (tmp___0) {
    {
#line 71
    tmp = gettext("write error");
#line 71
    error(status, 0, (char const   *)tmp);
    }
  }
  {
#line 72
  tmp___3 = fclose(stdout);
  }
#line 72
  if (tmp___3 != 0) {
    {
#line 73
    tmp___1 = gettext("write error");
#line 73
    tmp___2 = __errno_location();
#line 73
    error(status, *tmp___2, (char const   *)tmp___1);
    }
  }
#line 74
  return;
}
}
#line 77 "/home/ysko/Works/test-src/a2ps-4.14/lib/closeout.c"
void close_stdout(void) 
{ 


  {
  {
#line 80
  close_stdout_status(1);
  }
#line 81
  return;
}
}
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/lib/caret.h"
char const   *unprintable_format_to_string(enum unprintable_format format ) ;
#line 46
int escape_unprintable(struct a2ps_job *job___0 , int c , unsigned char *res___2 ) ;
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/lib/caret.c"
char const   *unprintable_format_to_string(enum unprintable_format format ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 42
  if ((unsigned int )format == 1U) {
#line 42
    goto case_1;
  }
#line 44
  if ((unsigned int )format == 3U) {
#line 44
    goto case_3;
  }
#line 46
  if ((unsigned int )format == 4U) {
#line 46
    goto case_4;
  }
#line 48
  if ((unsigned int )format == 0U) {
#line 48
    goto case_0;
  }
#line 50
  if ((unsigned int )format == 5U) {
#line 50
    goto case_5;
  }
#line 52
  if ((unsigned int )format == 2U) {
#line 52
    goto case_2;
  }
#line 41
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 43
  tmp = gettext("space (i.e., ` \')");
  }
#line 43
  return ((char const   *)tmp);
  case_3: /* CIL Label */ 
  {
#line 45
  tmp___0 = gettext("octal (i.e., `\\001\' etc.)");
  }
#line 45
  return ((char const   *)tmp___0);
  case_4: /* CIL Label */ 
  {
#line 47
  tmp___1 = gettext("hexadecimal (i.e., `\\x0a\' etc.)");
  }
#line 47
  return ((char const   *)tmp___1);
  case_0: /* CIL Label */ 
  {
#line 49
  tmp___2 = gettext("caret (i.e., `^C\', `M-^C\' etc.)");
  }
#line 49
  return ((char const   *)tmp___2);
  case_5: /* CIL Label */ 
  {
#line 51
  tmp___3 = gettext("emacs (i.e., `C-c\', `M-C-c\' etc.)");
  }
#line 51
  return ((char const   *)tmp___3);
  case_2: /* CIL Label */ 
  {
#line 53
  tmp___4 = gettext("question-mark (i.e., `?\')");
  }
#line 53
  return ((char const   *)tmp___4);
  switch_break: /* CIL Label */ ;
  }
  {
#line 55
  error(1, 0, "switch of unprintable_format_to_string");
  }
#line 57
  return ((char const   *)((void *)0));
}
}
#line 66 "/home/ysko/Works/test-src/a2ps-4.14/lib/caret.c"
int escape_unprintable(struct a2ps_job *job___0 , int c , unsigned char *res___2 ) 
{ 
  int len ;
  int __len ;
  size_t tmp ;
  int __len___0 ;
  size_t tmp___0 ;
  int __len___1 ;
  size_t tmp___1 ;
  int __len___2 ;
  size_t tmp___2 ;
  int __len___3 ;
  size_t tmp___3 ;
  int __len___4 ;
  size_t tmp___4 ;
  int __len___5 ;
  size_t tmp___5 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 70
  len = 0;
  {
#line 73
  if ((unsigned int )job___0->unprintable_format == 3U) {
#line 73
    goto case_3;
  }
#line 77
  if ((unsigned int )job___0->unprintable_format == 4U) {
#line 77
    goto case_4;
  }
#line 81
  if ((unsigned int )job___0->unprintable_format == 2U) {
#line 81
    goto case_2;
  }
#line 85
  if ((unsigned int )job___0->unprintable_format == 1U) {
#line 85
    goto case_1;
  }
#line 89
  if ((unsigned int )job___0->unprintable_format == 0U) {
#line 89
    goto case_0;
  }
#line 109
  if ((unsigned int )job___0->unprintable_format == 5U) {
#line 109
    goto case_5;
  }
#line 72
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 74
  sprintf((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"\\\\%03o",
          c);
  }
#line 75
  return (4);
  case_4: /* CIL Label */ 
  {
#line 78
  sprintf((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"\\\\x%02x",
          c);
  }
#line 79
  return (4);
  case_2: /* CIL Label */ 
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 82
    tmp = strlen((char const   *)res___2);
#line 82
    __len = (int )tmp;
#line 82
    *(res___2 + __len) = (unsigned char )'?';
#line 82
    *((res___2 + __len) + 1) = (unsigned char )'\000';
    }
#line 82
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return (1);
  case_1: /* CIL Label */ 
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 86
    tmp___0 = strlen((char const   *)res___2);
#line 86
    __len___0 = (int )tmp___0;
#line 86
    *(res___2 + __len___0) = (unsigned char )' ';
#line 86
    *((res___2 + __len___0) + 1) = (unsigned char )'\000';
    }
#line 86
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 87
  return (1);
  case_0: /* CIL Label */ 
#line 90
  if (127 < c) {
    {
#line 91
    strcat((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"M-");
#line 92
    len += 2;
#line 93
    c &= 127;
    }
  }
#line 96
  if (c < 32) {
    {
#line 97
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 97
      tmp___1 = strlen((char const   *)res___2);
#line 97
      __len___1 = (int )tmp___1;
#line 97
      *(res___2 + __len___1) = (unsigned char )'^';
#line 97
      *((res___2 + __len___1) + 1) = (unsigned char )'\000';
      }
#line 97
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 98
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 98
      tmp___2 = strlen((char const   *)res___2);
#line 98
      __len___2 = (int )tmp___2;
#line 98
      *(res___2 + __len___2) = (unsigned char )c;
#line 98
      *((res___2 + __len___2) + 1) = (unsigned char )'\000';
      }
#line 98
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 99
    len += 2;
  } else
#line 100
  if (c == 127) {
    {
#line 101
    strcat((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"^?");
#line 102
    len += 2;
    }
  } else {
    {
#line 104
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 104
      tmp___3 = strlen((char const   *)res___2);
#line 104
      __len___3 = (int )tmp___3;
#line 104
      *(res___2 + __len___3) = (unsigned char )c;
#line 104
      *((res___2 + __len___3) + 1) = (unsigned char )'\000';
      }
#line 104
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 105
    len ++;
  }
#line 107
  return (len);
  case_5: /* CIL Label */ 
#line 110
  if (127 < c) {
    {
#line 111
    strcat((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"M-");
#line 112
    len += 2;
#line 113
    c &= 127;
    }
  }
#line 116
  if (c < 32) {
    {
#line 117
    strcat((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"C-");
    }
    {
#line 118
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 118
      tmp___4 = strlen((char const   *)res___2);
#line 118
      __len___4 = (int )tmp___4;
#line 118
      *(res___2 + __len___4) = (unsigned char )c;
#line 118
      *((res___2 + __len___4) + 1) = (unsigned char )'\000';
      }
#line 118
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 119
    len += 3;
  } else
#line 120
  if (c == 127) {
    {
#line 121
    strcat((char */* __restrict  */)((char *)res___2), (char const   */* __restrict  */)"C-?");
#line 122
    len += 3;
    }
  } else {
    {
#line 124
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 124
      tmp___5 = strlen((char const   *)res___2);
#line 124
      __len___5 = (int )tmp___5;
#line 124
      *(res___2 + __len___5) = (unsigned char )c;
#line 124
      *((res___2 + __len___5) + 1) = (unsigned char )'\000';
      }
#line 124
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 125
    len ++;
  }
#line 127
  return (len);
  switch_break: /* CIL Label */ ;
  }
#line 129
  return (0);
}
}
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/lib/basename.c"
char *base_name(char const   *name ) ;
#line 45 "/home/ysko/Works/test-src/a2ps-4.14/lib/basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base ;
  int all_slashes ;
  char const   *p ;

  {
#line 48
  name += 0;
#line 48
  base = name;
#line 49
  all_slashes = 1;
#line 52
  p = name;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! *p) {
#line 52
      goto while_break;
    }
#line 54
    if ((int const   )*p == 47) {
#line 55
      base = p + 1;
    } else {
#line 57
      all_slashes = 0;
    }
#line 52
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  if ((int const   )*base == 0) {
#line 61
    if ((int const   )*name == 47) {
#line 61
      if (all_slashes) {
#line 62
        base --;
      }
    }
  }
#line 64
  return ((char *)base);
}
}
#line 57 "./backupfile.h"
enum backup_type xget_version(char const   *context , char const   *version ) ;
#line 58
void addext(char *filename , char const   *ext , int e ) ;
#line 108 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.c"
char const   *simple_backup_suffix  =    "~";
#line 110
static int max_backup_version(char const   *file , char const   *dir ) ;
#line 111
static int version_number(char const   *base , char const   *backup , size_t base_length ) ;
#line 118 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.c"
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) 
{ 
  size_t backup_suffix_size_max ;
  size_t file_len ;
  size_t tmp ;
  size_t numbered_suffix_size_max ;
  char *s ;
  char const   *suffix ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int highest_backup ;
  size_t dir_len ;
  char *tmp___2 ;
  char *numbered_suffix ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 122
  tmp = strlen(file);
#line 122
  file_len = tmp;
#line 123
  numbered_suffix_size_max = (size_t )((((sizeof(int ) * 8UL - 1UL) * 302UL) / 1000UL + 2UL) + 4UL);
#line 125
  suffix = simple_backup_suffix;
#line 128
  tmp___0 = strlen(simple_backup_suffix);
#line 128
  backup_suffix_size_max = tmp___0 + 1U;
  }
#line 129
  if (backup_suffix_size_max < numbered_suffix_size_max) {
#line 130
    backup_suffix_size_max = numbered_suffix_size_max;
  }
  {
#line 132
  tmp___1 = malloc((file_len + backup_suffix_size_max) + numbered_suffix_size_max);
#line 132
  s = (char *)tmp___1;
  }
#line 133
  if (s) {
    {
#line 135
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)file);
    }
#line 138
    if ((unsigned int )backup_type != 1U) {
      {
#line 141
      tmp___2 = base_name((char const   *)s);
#line 141
      dir_len = (size_t )(tmp___2 - s);
#line 143
      strcpy((char */* __restrict  */)(s + dir_len), (char const   */* __restrict  */)".");
#line 144
      highest_backup = max_backup_version(file + dir_len, (char const   *)s);
      }
#line 145
      if ((unsigned int )backup_type == 2U) {
#line 145
        if (! (highest_backup == 0)) {
          {
#line 147
          numbered_suffix = s + (file_len + backup_suffix_size_max);
#line 148
          sprintf((char */* __restrict  */)numbered_suffix, (char const   */* __restrict  */)".~%d~",
                  highest_backup + 1);
#line 149
          suffix = (char const   *)numbered_suffix;
          }
        }
      } else {
        {
#line 147
        numbered_suffix = s + (file_len + backup_suffix_size_max);
#line 148
        sprintf((char */* __restrict  */)numbered_suffix, (char const   */* __restrict  */)".~%d~",
                highest_backup + 1);
#line 149
        suffix = (char const   *)numbered_suffix;
        }
      }
      {
#line 151
      strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)file);
      }
    }
    {
#line 155
    addext(s, suffix, '~');
    }
  }
#line 157
  return (s);
}
}
#line 167 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.c"
static int max_backup_version(char const   *file , char const   *dir ) 
{ 
  DIR *dirp ;
  struct dirent *dp ;
  int highest_version ;
  int this_version ;
  size_t file_name_length ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 176
  dirp = opendir(dir);
  }
#line 177
  if (! dirp) {
#line 178
    return (0);
  }
  {
#line 180
  highest_version = 0;
#line 181
  file_name_length = strlen(file);
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 183
    dp = readdir(dirp);
    }
#line 183
    if (! ((unsigned long )dp != (unsigned long )((struct dirent *)0))) {
#line 183
      goto while_break;
    }
    {
#line 185
    tmp = strlen((char const   *)(dp->d_name));
    }
#line 185
    if (tmp < file_name_length + 4U) {
#line 186
      goto while_continue;
    }
    {
#line 188
    this_version = version_number(file, (char const   *)(dp->d_name), file_name_length);
    }
#line 189
    if (this_version > highest_version) {
#line 190
      highest_version = this_version;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  tmp___0 = closedir(dirp);
  }
#line 192
  if (tmp___0) {
#line 193
    return (0);
  }
#line 194
  return (highest_version);
}
}
#line 201 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.c"
static int version_number(char const   *base , char const   *backup , size_t base_length ) 
{ 
  int version ;
  char const   *p ;
  int tmp ;

  {
  {
#line 207
  version = 0;
#line 208
  tmp = strncmp(base, backup, base_length);
  }
#line 208
  if (tmp == 0) {
#line 208
    if ((int const   )*(backup + base_length) == 46) {
#line 208
      if ((int const   )*(backup + (base_length + 1U)) == 126) {
#line 212
        p = backup + (base_length + 2U);
        {
#line 212
        while (1) {
          while_continue: /* CIL Label */ ;
#line 212
          if (! ((unsigned int )*p - 48U <= 9U)) {
#line 212
            goto while_break;
          }
#line 213
          version = (version * 10 + (int )*p) - 48;
#line 212
          p ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 214
        if ((int const   )*(p + 0) != 126) {
#line 215
          version = 0;
        } else
#line 214
        if (*(p + 1)) {
#line 215
          version = 0;
        }
      }
    }
  }
#line 217
  return (version);
}
}
#line 221 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.c"
static char const   * const  backup_args[9]  = 
#line 221
  {      (char const   */* const  */)"none",      (char const   */* const  */)"off",      (char const   */* const  */)"simple",      (char const   */* const  */)"never", 
        (char const   */* const  */)"existing",      (char const   */* const  */)"nil",      (char const   */* const  */)"numbered",      (char const   */* const  */)"t", 
        (char const   */* const  */)0};
#line 232 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.c"
static enum backup_type  const  backup_types[8]  = 
#line 232
  {      (enum backup_type  const  )0,      (enum backup_type  const  )0,      (enum backup_type  const  )1,      (enum backup_type  const  )1, 
        (enum backup_type  const  )2,      (enum backup_type  const  )2,      (enum backup_type  const  )3,      (enum backup_type  const  )3};
#line 245 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.c"
enum backup_type get_version(char const   *context , char const   *version ) 
{ 
  int tmp ;

  {
#line 248
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 249
    return ((enum backup_type )2);
  } else
#line 248
  if ((int const   )*version == 0) {
#line 249
    return ((enum backup_type )2);
  } else {
    {
#line 251
    tmp = __xargmatch_internal(context, version, backup_args, (char const   *)(backup_types),
                               (size_t )sizeof(backup_types[0]), 1, argmatch_die);
    }
#line 251
    return ((enum backup_type )backup_types[tmp]);
  }
}
}
#line 261 "/home/ysko/Works/test-src/a2ps-4.14/lib/backupfile.c"
enum backup_type xget_version(char const   *context , char const   *version ) 
{ 
  enum backup_type tmp ;
  char *tmp___0 ;
  enum backup_type tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 264
  if (version) {
#line 264
    if (*version) {
      {
#line 265
      tmp = get_version(context, version);
      }
#line 265
      return (tmp);
    } else {
      {
#line 267
      tmp___0 = getenv("VERSION_CONTROL");
#line 267
      tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
      }
#line 267
      return (tmp___1);
    }
  } else {
    {
#line 267
    tmp___0 = getenv("VERSION_CONTROL");
#line 267
    tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
    }
#line 267
    return (tmp___1);
  }
}
}
#line 69 "/home/ysko/Works/test-src/a2ps-4.14/lib/argv.h"
char **dupargv(char **argv ) ;
#line 94
void freeargv(char **vector ) ;
#line 145
char **buildargv(char const   *string ) ;
#line 109 "/home/ysko/Works/test-src/a2ps-4.14/lib/argv.c"
char **dupargv(char **argv ) 
{ 
  int argc ;
  char **copy ;
  void *tmp ;
  int len ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 116
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 117
    return ((char **)((void *)0));
  }
#line 120
  argc = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! ((unsigned long )*(argv + argc) != (unsigned long )((void *)0))) {
#line 120
      goto while_break;
    }
#line 120
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  tmp = malloc((size_t )((unsigned long )(argc + 1) * sizeof(char *)));
#line 121
  copy = (char **)tmp;
  }
#line 122
  if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 123
    return ((char **)((void *)0));
  }
#line 126
  argc = 0;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )*(argv + argc) != (unsigned long )((void *)0))) {
#line 126
      goto while_break___0;
    }
    {
#line 128
    tmp___0 = strlen((char const   *)*(argv + argc));
#line 128
    len = (int )tmp___0;
#line 129
    tmp___1 = malloc((size_t )(sizeof(char *) * (unsigned long )(len + 1)));
#line 129
    *(copy + argc) = (char *)tmp___1;
    }
#line 130
    if ((unsigned long )*(copy + argc) == (unsigned long )((void *)0)) {
      {
#line 132
      freeargv(copy);
      }
#line 133
      return ((char **)((void *)0));
    }
    {
#line 135
    strcpy((char */* __restrict  */)*(copy + argc), (char const   */* __restrict  */)*(argv + argc));
#line 126
    argc ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 137
  *(copy + argc) = (char *)((void *)0);
#line 138
  return (copy);
}
}
#line 143 "/home/ysko/Works/test-src/a2ps-4.14/lib/argv.c"
void freeargv(char **vector ) 
{ 
  register char **scan ;

  {
#line 148
  if ((unsigned long )vector != (unsigned long )((void *)0)) {
#line 150
    scan = vector;
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 150
      if (! ((unsigned long )*scan != (unsigned long )((void *)0))) {
#line 150
        goto while_break;
      }
      {
#line 152
      free((void *)*scan);
#line 150
      scan ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 154
    free((void *)vector);
    }
  }
#line 156
  return;
}
}
#line 158 "/home/ysko/Works/test-src/a2ps-4.14/lib/argv.c"
void freeargv_from(char **vector , int from ) 
{ 
  register char **scan ;

  {
#line 164
  if ((unsigned long )vector != (unsigned long )((void *)0)) {
#line 166
    scan = vector;
    {
#line 166
    while (1) {
      while_continue: /* CIL Label */ ;
#line 166
      if (from > 0) {
#line 166
        if (! ((unsigned long )*scan != (unsigned long )((void *)0))) {
#line 166
          goto while_break;
        }
      } else {
#line 166
        goto while_break;
      }
#line 167
      scan ++;
#line 166
      from --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 169
      if (! ((unsigned long )*scan != (unsigned long )((void *)0))) {
#line 169
        goto while_break___0;
      }
      {
#line 170
      free((void *)*scan);
#line 169
      scan ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 171
    free((void *)vector);
    }
  }
#line 173
  return;
}
}
#line 177 "/home/ysko/Works/test-src/a2ps-4.14/lib/argv.c"
char **buildargv_argc(char const   *input , int *argc ) 
{ 
  char *arg ;
  char *copybuf ;
  int squote ;
  int dquote ;
  int bsquote ;
  int maxargc ;
  char **argv ;
  char **nargv ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;

  {
#line 183
  squote = 0;
#line 184
  dquote = 0;
#line 185
  bsquote = 0;
#line 186
  maxargc = 0;
#line 187
  argv = (char **)((void *)0);
#line 190
  if ((unsigned long )input != (unsigned long )((void *)0)) {
    {
#line 192
    tmp = strlen(input);
#line 192
    tmp___0 = __builtin_alloca((unsigned long )(tmp + 1U));
#line 192
    copybuf = (char *)tmp___0;
    }
    {
#line 195
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 198
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 198
        tmp___1 = __ctype_b_loc();
        }
#line 198
        if (! ((int const   )*(*tmp___1 + (int )*input) & 8192)) {
#line 198
          goto while_break___0;
        }
#line 199
        input ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 200
      if (maxargc == 0) {
#line 200
        goto _L;
      } else
#line 200
      if (*argc >= maxargc - 1) {
        _L: /* CIL Label */ 
#line 203
        if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 205
          if (*argc > 8) {
#line 205
            maxargc = *argc;
          } else {
#line 205
            maxargc = 8;
          }
          {
#line 206
          tmp___2 = malloc((size_t )((unsigned long )maxargc * sizeof(char *)));
#line 206
          nargv = (char **)tmp___2;
          }
        } else {
          {
#line 210
          maxargc *= 2;
#line 211
          tmp___3 = realloc((void *)argv, (size_t )((unsigned long )maxargc * sizeof(char *)));
#line 211
          nargv = (char **)tmp___3;
          }
        }
#line 213
        if ((unsigned long )nargv == (unsigned long )((void *)0)) {
#line 215
          if ((unsigned long )argv != (unsigned long )((void *)0)) {
            {
#line 217
            freeargv(argv);
#line 218
            argv = (char **)((void *)0);
            }
          }
#line 220
          goto while_break;
        }
#line 222
        argv = nargv;
#line 223
        *(argv + *argc) = (char *)((void *)0);
      }
#line 226
      arg = copybuf;
      {
#line 227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 227
        if (! ((int const   )*input != 0)) {
#line 227
          goto while_break___1;
        }
        {
#line 229
        tmp___8 = __ctype_b_loc();
        }
#line 229
        if ((int const   )*(*tmp___8 + (int )*input) & 8192) {
#line 229
          if (! squote) {
#line 229
            if (! dquote) {
#line 229
              if (! bsquote) {
#line 230
                goto while_break___1;
              } else {
#line 229
                goto _L___2;
              }
            } else {
#line 229
              goto _L___2;
            }
          } else {
#line 229
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 233
          if (bsquote) {
#line 235
            bsquote = 0;
#line 236
            tmp___4 = arg;
#line 236
            arg ++;
#line 236
            *tmp___4 = (char )*input;
          } else
#line 238
          if ((int const   )*input == 92) {
#line 240
            bsquote = 1;
          } else
#line 242
          if (squote) {
#line 244
            if ((int const   )*input == 39) {
#line 245
              squote = 0;
            } else {
#line 247
              tmp___5 = arg;
#line 247
              arg ++;
#line 247
              *tmp___5 = (char )*input;
            }
          } else
#line 249
          if (dquote) {
#line 251
            if ((int const   )*input == 34) {
#line 252
              dquote = 0;
            } else {
#line 254
              tmp___6 = arg;
#line 254
              arg ++;
#line 254
              *tmp___6 = (char )*input;
            }
          } else
#line 258
          if ((int const   )*input == 39) {
#line 260
            squote = 1;
          } else
#line 262
          if ((int const   )*input == 34) {
#line 264
            dquote = 1;
          } else {
#line 268
            tmp___7 = arg;
#line 268
            arg ++;
#line 268
            *tmp___7 = (char )*input;
          }
#line 271
          input ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 274
      *arg = (char )'\000';
#line 275
      *(argv + *argc) = strdup((char const   *)copybuf);
      }
#line 276
      if ((unsigned long )*(argv + *argc) == (unsigned long )((void *)0)) {
        {
#line 278
        freeargv(argv);
#line 279
        argv = (char **)((void *)0);
        }
#line 280
        goto while_break;
      }
#line 282
      (*argc) ++;
#line 283
      *(argv + *argc) = (char *)((void *)0);
      {
#line 285
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 285
        tmp___9 = __ctype_b_loc();
        }
#line 285
        if (! ((int const   )*(*tmp___9 + (int )*input) & 8192)) {
#line 285
          goto while_break___2;
        }
#line 286
        input ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 195
      if (! ((int const   )*input != 0)) {
#line 195
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 290
  return (argv);
}
}
#line 293 "/home/ysko/Works/test-src/a2ps-4.14/lib/argv.c"
char **buildargv(char const   *string ) 
{ 
  int argc ;
  char **tmp ;

  {
  {
#line 296
  argc = 0;
#line 297
  tmp = buildargv_argc(string, & argc);
  }
#line 297
  return (tmp);
}
}
#line 54 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.h"
int argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
             size_t valsize ) ;
#line 75
void argmatch_invalid(char const   *context , char const   *value , int problem ) ;
#line 87
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 66 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 69
  exit(1);
  }
}
}
#line 74 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 89 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.c"
static int __argmatch_internal(char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , int case_sensitive ) 
{ 
  int i ;
  size_t arglen ;
  int matchind ;
  int ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 96
  matchind = -1;
#line 97
  ambiguous = 0;
#line 99
  arglen = strlen(arg);
#line 102
  i = 0;
  }
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! *(arglist + i)) {
#line 102
      goto while_break;
    }
#line 104
    if (case_sensitive) {
      {
#line 104
      tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
      }
#line 104
      if (tmp___1) {
#line 104
        tmp___2 = 0;
      } else {
#line 104
        tmp___2 = 1;
      }
#line 104
      tmp___5 = tmp___2;
    } else {
      {
#line 104
      tmp___3 = strncasecmp((char const   *)*(arglist + i), arg, arglen);
      }
#line 104
      if (tmp___3) {
#line 104
        tmp___4 = 0;
      } else {
#line 104
        tmp___4 = 1;
      }
#line 104
      tmp___5 = tmp___4;
    }
#line 104
    if (tmp___5) {
      {
#line 108
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 108
      if (tmp___0 == arglen) {
#line 110
        return (i);
      } else
#line 111
      if (matchind == -1) {
#line 113
        matchind = i;
      } else
#line 117
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 123
        ambiguous = 1;
      } else {
        {
#line 117
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * (size_t )i),
                     valsize);
        }
#line 117
        if (tmp) {
#line 123
          ambiguous = 1;
        }
      }
    }
#line 102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if (ambiguous) {
#line 129
    return (-2);
  } else {
#line 131
    return (matchind);
  }
}
}
#line 135 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.c"
int argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
             size_t valsize ) 
{ 
  int tmp ;

  {
  {
#line 139
  tmp = __argmatch_internal(arg, arglist, vallist, valsize, 1);
  }
#line 139
  return (tmp);
}
}
#line 143 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.c"
int argcasematch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                 size_t valsize ) 
{ 
  int tmp ;

  {
  {
#line 147
  tmp = __argmatch_internal(arg, arglist, vallist, valsize, 0);
  }
#line 147
  return (tmp);
}
}
#line 155 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , int problem ) 
{ 
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 158
  if (problem == -1) {
    {
#line 158
    tmp = gettext("invalid argument %s for `%s\'");
#line 158
    tmp___1 = tmp;
    }
  } else {
    {
#line 158
    tmp___0 = gettext("ambiguous argument %s for `%s\'");
#line 158
    tmp___1 = tmp___0;
    }
  }
  {
#line 158
  format = (char const   *)tmp___1;
#line 162
  tmp___2 = quotearg_style((enum quoting_style )5, value);
#line 162
  error(0, 0, format, tmp___2, context);
  }
#line 163
  return;
}
}
#line 169 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  int i ;
  char const   *last_val ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 174
  last_val = (char const   *)((void *)0);
#line 178
  tmp = gettext("Valid arguments are:");
#line 178
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 179
  i = 0;
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! *(arglist + i)) {
#line 179
      goto while_break;
    }
#line 180
    if (i == 0) {
      {
#line 183
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - `%s\'",
              *(arglist + i));
#line 184
      last_val = vallist + valsize * (size_t )i;
      }
    } else {
      {
#line 180
      tmp___0 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * (size_t )i),
                       valsize);
      }
#line 180
      if (tmp___0) {
        {
#line 183
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - `%s\'",
                *(arglist + i));
#line 184
        last_val = vallist + valsize * (size_t )i;
        }
      } else {
        {
#line 188
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", `%s\'",
                *(arglist + i));
        }
      }
    }
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 190
  _IO_putc('\n', stderr);
  }
#line 191
  return;
}
}
#line 199 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.c"
int __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                         char const   *vallist , size_t valsize , int case_sensitive ,
                         void (*exit_fn)(void) ) 
{ 
  int res___2 ;
  int tmp ;

  {
  {
#line 206
  tmp = __argmatch_internal(arg, arglist, vallist, valsize, case_sensitive);
#line 206
  res___2 = tmp;
  }
#line 209
  if (res___2 >= 0) {
#line 211
    return (res___2);
  }
  {
#line 214
  argmatch_invalid(context, arg, res___2);
#line 215
  argmatch_valid(arglist, vallist, valsize);
#line 216
  (*exit_fn)();
  }
#line 218
  return (-1);
}
}
#line 223 "/home/ysko/Works/test-src/a2ps-4.14/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  int i ;
  int tmp ;

  {
#line 230
  i = 0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! *(arglist + i)) {
#line 230
      goto while_break;
    }
    {
#line 231
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * (size_t )i),
                 valsize);
    }
#line 231
    if (! tmp) {
#line 232
      return ((char const   *)*(arglist + i));
    }
#line 230
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return ((char const   *)((void *)0));
}
}
#line 57 "/home/ysko/Works/test-src/a2ps-4.14/lib/addext.c"
void addext(char *filename , char const   *ext , int e ) 
{ 
  char *s ;
  char *tmp ;
  size_t slen ;
  size_t tmp___0 ;
  size_t extlen ;
  size_t tmp___1 ;
  long slen_max ;

  {
  {
#line 60
  tmp = base_name((char const   *)filename);
#line 60
  s = tmp;
#line 61
  tmp___0 = strlen((char const   *)s);
#line 61
  slen = tmp___0;
#line 61
  tmp___1 = strlen(ext);
#line 61
  extlen = tmp___1;
#line 62
  slen_max = -1L;
  }
#line 78
  if (slen_max < 0L) {
#line 79
    slen_max = 14L;
  }
#line 96
  if ((long )(slen + extlen) <= slen_max) {
    {
#line 97
    strcpy((char */* __restrict  */)(s + slen), (char const   */* __restrict  */)ext);
    }
  } else {
#line 100
    if (slen_max <= (long )slen) {
#line 101
      slen = (size_t )(slen_max - 1L);
    }
#line 102
    *(s + slen) = (char )e;
#line 103
    *(s + (slen + 1U)) = (char)0;
  }
#line 105
  return;
}
}
#line 155 "sheets-map.c"
int smapleng  ;
#line 157
FILE *smapin ;
#line 157
FILE *smapout ;
#line 270 "sheets-map.c"
static size_t yy_buffer_stack_top___1  =    (size_t )0;
#line 271 "sheets-map.c"
static size_t yy_buffer_stack_max___1  =    (size_t )0;
#line 272 "sheets-map.c"
static YY_BUFFER_STATE *yy_buffer_stack___1  =    (YY_BUFFER_STATE *)0;
#line 290 "sheets-map.c"
static char yy_hold_char___1  ;
#line 291 "sheets-map.c"
static int yy_n_chars___1  ;
#line 295 "sheets-map.c"
static char *yy_c_buf_p___1  =    (char *)0;
#line 296 "sheets-map.c"
static int yy_init___1  =    0;
#line 297 "sheets-map.c"
static int yy_start___1  =    0;
#line 302 "sheets-map.c"
static int yy_did_buffer_switch_on_eof___1  ;
#line 304
void smaprestart(FILE *input_file ) ;
#line 305
void smap_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 306
YY_BUFFER_STATE smap_create_buffer(FILE *file , int size ) ;
#line 307
void smap_delete_buffer(YY_BUFFER_STATE b ) ;
#line 308
void smap_flush_buffer(YY_BUFFER_STATE b ) ;
#line 309
void smappush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 310
void smappop_buffer_state(void) ;
#line 312
static void smapensure_buffer_stack(void) ;
#line 313
static void smap_load_buffer_state(void) ;
#line 314
static void smap_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 318
YY_BUFFER_STATE smap_scan_buffer(char *base , yy_size_t size ) ;
#line 319
YY_BUFFER_STATE smap_scan_string(char const   *yystr ) ;
#line 320
YY_BUFFER_STATE smap_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 322
void *smapalloc(yy_size_t size ) ;
#line 323
void *smaprealloc(void *ptr , yy_size_t size ) ;
#line 324
void smapfree(void *ptr ) ;
#line 354 "sheets-map.c"
FILE *smapin  =    (FILE *)0;
#line 354 "sheets-map.c"
FILE *smapout  =    (FILE *)0;
#line 358
int smaplineno ;
#line 360 "sheets-map.c"
int smaplineno  =    1;
#line 362 "sheets-map.c"
char *smaptext  ;
#line 365
static yy_state_type yy_get_previous_state___1(void) ;
#line 366
static yy_state_type yy_try_NUL_trans___1(yy_state_type yy_current_state ) ;
#line 367
static int yy_get_next_buffer___1(void) ;
#line 368
static void yy_fatal_error___1(char const   *msg ) ;
#line 389 "sheets-map.c"
static flex_int16_t const   yy_accept___1[74]  = 
#line 389
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )39, 
        (flex_int16_t const   )7,      (flex_int16_t const   )4,      (flex_int16_t const   )4,      (flex_int16_t const   )5, 
        (flex_int16_t const   )7,      (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )7, 
        (flex_int16_t const   )22,      (flex_int16_t const   )21,      (flex_int16_t const   )8,      (flex_int16_t const   )38, 
        (flex_int16_t const   )37,      (flex_int16_t const   )36,      (flex_int16_t const   )23,      (flex_int16_t const   )38, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )0,      (flex_int16_t const   )1, 
        (flex_int16_t const   )0,      (flex_int16_t const   )22,      (flex_int16_t const   )8,      (flex_int16_t const   )20, 
        (flex_int16_t const   )9,      (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )13, 
        (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )17, 
        (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )37, 
        (flex_int16_t const   )23,      (flex_int16_t const   )35,      (flex_int16_t const   )24,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )30, 
        (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )33,      (flex_int16_t const   )34, 
        (flex_int16_t const   )35,      (flex_int16_t const   )0,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )0,      (flex_int16_t const   )9, 
        (flex_int16_t const   )10,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )6,      (flex_int16_t const   )0};
#line 401 "sheets-map.c"
static flex_int32_t const   yy_ec___1[256]  = 
#line 401
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )2, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )4, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )1,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9, 
        (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )1, 
        (flex_int32_t const   )12,      (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )1, 
        (flex_int32_t const   )14,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )20,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )21,      (flex_int32_t const   )7,      (flex_int32_t const   )7, 
        (flex_int32_t const   )22,      (flex_int32_t const   )7,      (flex_int32_t const   )23,      (flex_int32_t const   )7, 
        (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )24,      (flex_int32_t const   )7, 
        (flex_int32_t const   )25,      (flex_int32_t const   )26,      (flex_int32_t const   )27,      (flex_int32_t const   )7, 
        (flex_int32_t const   )28,      (flex_int32_t const   )7,      (flex_int32_t const   )7,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 433 "sheets-map.c"
static flex_int32_t const   yy_meta___1[29]  = 
#line 433
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )4, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )4, 
        (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4};
#line 440 "sheets-map.c"
static flex_int16_t const   yy_base___1[85]  = 
#line 440
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )29,      (flex_int16_t const   )33,      (flex_int16_t const   )154, 
        (flex_int16_t const   )174,      (flex_int16_t const   )35,      (flex_int16_t const   )42,      (flex_int16_t const   )0, 
        (flex_int16_t const   )140,      (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )28, 
        (flex_int16_t const   )0,      (flex_int16_t const   )174,      (flex_int16_t const   )122,      (flex_int16_t const   )51, 
        (flex_int16_t const   )0,      (flex_int16_t const   )174,      (flex_int16_t const   )103,      (flex_int16_t const   )79, 
        (flex_int16_t const   )46,      (flex_int16_t const   )0,      (flex_int16_t const   )112,      (flex_int16_t const   )174, 
        (flex_int16_t const   )97,      (flex_int16_t const   )0,      (flex_int16_t const   )174,      (flex_int16_t const   )174, 
        (flex_int16_t const   )110,      (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174, 
        (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174, 
        (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )108,      (flex_int16_t const   )174, 
        (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174, 
        (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174, 
        (flex_int16_t const   )0,      (flex_int16_t const   )98,      (flex_int16_t const   )106,      (flex_int16_t const   )0, 
        (flex_int16_t const   )103,      (flex_int16_t const   )0,      (flex_int16_t const   )99,      (flex_int16_t const   )174, 
        (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )100, 
        (flex_int16_t const   )102,      (flex_int16_t const   )111,      (flex_int16_t const   )0,      (flex_int16_t const   )76, 
        (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )125,      (flex_int16_t const   )133, 
        (flex_int16_t const   )141,      (flex_int16_t const   )146,      (flex_int16_t const   )152,      (flex_int16_t const   )159, 
        (flex_int16_t const   )48,      (flex_int16_t const   )44,      (flex_int16_t const   )27,      (flex_int16_t const   )25, 
        (flex_int16_t const   )165};
#line 453 "sheets-map.c"
static flex_int16_t const   yy_def___1[85]  = 
#line 453
  {      (flex_int16_t const   )0,      (flex_int16_t const   )73,      (flex_int16_t const   )1,      (flex_int16_t const   )74, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )76, 
        (flex_int16_t const   )77,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )77, 
        (flex_int16_t const   )78,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )79,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )76,      (flex_int16_t const   )77,      (flex_int16_t const   )73, 
        (flex_int16_t const   )77,      (flex_int16_t const   )78,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )80,      (flex_int16_t const   )79, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )81,      (flex_int16_t const   )77,      (flex_int16_t const   )73,      (flex_int16_t const   )82, 
        (flex_int16_t const   )73,      (flex_int16_t const   )83,      (flex_int16_t const   )77,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )77, 
        (flex_int16_t const   )77,      (flex_int16_t const   )77,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )73,      (flex_int16_t const   )0,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73};
#line 466 "sheets-map.c"
static flex_int16_t const   yy_nxt___1[203]  = 
#line 466
  {      (flex_int16_t const   )0,      (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )11,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )12, 
        (flex_int16_t const   )13,      (flex_int16_t const   )12,      (flex_int16_t const   )12,      (flex_int16_t const   )8, 
        (flex_int16_t const   )14,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )12, 
        (flex_int16_t const   )12,      (flex_int16_t const   )12,      (flex_int16_t const   )12,      (flex_int16_t const   )12, 
        (flex_int16_t const   )12,      (flex_int16_t const   )15,      (flex_int16_t const   )12,      (flex_int16_t const   )12, 
        (flex_int16_t const   )12,      (flex_int16_t const   )12,      (flex_int16_t const   )12,      (flex_int16_t const   )12, 
        (flex_int16_t const   )12,      (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )66, 
        (flex_int16_t const   )21,      (flex_int16_t const   )64,      (flex_int16_t const   )18,      (flex_int16_t const   )18, 
        (flex_int16_t const   )21,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )27, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )22,      (flex_int16_t const   )23, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )22,      (flex_int16_t const   )23, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )61,      (flex_int16_t const   )28, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )59,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )32,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )33,      (flex_int16_t const   )34, 
        (flex_int16_t const   )31,      (flex_int16_t const   )35,      (flex_int16_t const   )36,      (flex_int16_t const   )37, 
        (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )38,      (flex_int16_t const   )39, 
        (flex_int16_t const   )40,      (flex_int16_t const   )31,      (flex_int16_t const   )41,      (flex_int16_t const   )42, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )72,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )46,      (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )47,      (flex_int16_t const   )48, 
        (flex_int16_t const   )45,      (flex_int16_t const   )49,      (flex_int16_t const   )50,      (flex_int16_t const   )51, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )52,      (flex_int16_t const   )53, 
        (flex_int16_t const   )54,      (flex_int16_t const   )45,      (flex_int16_t const   )55,      (flex_int16_t const   )56, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )65,      (flex_int16_t const   )27,      (flex_int16_t const   )57,      (flex_int16_t const   )63, 
        (flex_int16_t const   )70,      (flex_int16_t const   )60,      (flex_int16_t const   )68,      (flex_int16_t const   )58, 
        (flex_int16_t const   )62,      (flex_int16_t const   )69,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )44,      (flex_int16_t const   )67,      (flex_int16_t const   )16,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )25,      (flex_int16_t const   )30, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )26,      (flex_int16_t const   )27, 
        (flex_int16_t const   )26,      (flex_int16_t const   )29,      (flex_int16_t const   )73,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )73,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )43,      (flex_int16_t const   )73,      (flex_int16_t const   )43,      (flex_int16_t const   )43, 
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )71,      (flex_int16_t const   )71, 
        (flex_int16_t const   )73,      (flex_int16_t const   )71,      (flex_int16_t const   )71,      (flex_int16_t const   )71, 
        (flex_int16_t const   )71,      (flex_int16_t const   )71,      (flex_int16_t const   )7,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73};
#line 493 "sheets-map.c"
static flex_int16_t const   yy_chk___1[203]  = 
#line 493
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )3,      (flex_int16_t const   )4,      (flex_int16_t const   )83, 
        (flex_int16_t const   )5,      (flex_int16_t const   )82,      (flex_int16_t const   )3,      (flex_int16_t const   )4, 
        (flex_int16_t const   )6,      (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )15, 
        (flex_int16_t const   )3,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )5, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )6,      (flex_int16_t const   )6, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )81,      (flex_int16_t const   )15, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )80,      (flex_int16_t const   )19, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )19, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )71,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )28,      (flex_int16_t const   )57,      (flex_int16_t const   )62,      (flex_int16_t const   )67, 
        (flex_int16_t const   )60,      (flex_int16_t const   )68,      (flex_int16_t const   )28,      (flex_int16_t const   )58, 
        (flex_int16_t const   )69,      (flex_int16_t const   )46,      (flex_int16_t const   )67,      (flex_int16_t const   )32, 
        (flex_int16_t const   )57,      (flex_int16_t const   )68,      (flex_int16_t const   )69,      (flex_int16_t const   )26, 
        (flex_int16_t const   )22,      (flex_int16_t const   )62,      (flex_int16_t const   )74,      (flex_int16_t const   )74, 
        (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )74, 
        (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )76,      (flex_int16_t const   )18, 
        (flex_int16_t const   )76,      (flex_int16_t const   )76,      (flex_int16_t const   )76,      (flex_int16_t const   )76, 
        (flex_int16_t const   )76,      (flex_int16_t const   )76,      (flex_int16_t const   )77,      (flex_int16_t const   )12, 
        (flex_int16_t const   )77,      (flex_int16_t const   )78,      (flex_int16_t const   )7,      (flex_int16_t const   )78, 
        (flex_int16_t const   )78,      (flex_int16_t const   )0,      (flex_int16_t const   )78,      (flex_int16_t const   )78, 
        (flex_int16_t const   )79,      (flex_int16_t const   )0,      (flex_int16_t const   )79,      (flex_int16_t const   )79, 
        (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )0,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73};
#line 521 "sheets-map.c"
static flex_int32_t const   yy_rule_can_match_eol___1[39]  = 
#line 521
  {      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )0};
#line 526 "sheets-map.c"
static yy_state_type yy_last_accepting_state___1  ;
#line 527 "sheets-map.c"
static char *yy_last_accepting_cpos___1  ;
#line 529
int smap_flex_debug ;
#line 530 "sheets-map.c"
int smap_flex_debug  =    0;
#line 47 "/home/ysko/Works/test-src/a2ps-4.14/src/select.h"
void sheets_map_add(char const   *pattern , int on_file_verdict , _Bool insensitive_p___0 ,
                    char const   *key ) ;
#line 63
void sheets_map_load(char const   *filename ) ;
#line 31 "sheets-map.l"
int smaplex(void) ;
#line 33
static void yy_include_push(char *file ) ;
#line 34
static void yy_include_pop(void) ;
#line 37 "sheets-map.l"
static struct obstack string_stack___0  ;
#line 42 "sheets-map.l"
static YY_BUFFER_STATE include_stack___0[10]  ;
#line 43 "sheets-map.l"
static int lineno_stack[10]  ;
#line 44 "sheets-map.l"
static char *filename_stack___0[10]  ;
#line 45 "sheets-map.l"
static int include_stack_ptr___0  ;
#line 46 "sheets-map.l"
static char *yyfilename  ;
#line 55 "sheets-map.l"
static char *token_val  ;
#line 56 "sheets-map.l"
static _Bool insensitive_p  ;
#line 58 "sheets-map.l"
__inline static void obstack_hexa_grow(struct obstack *o , char const   *str ) 
{ 
  int value ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  struct obstack *__o ;
  char *tmp___2 ;

  {
#line 61
  value = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! *str) {
#line 64
      goto while_break;
    }
#line 65
    if ((int const   )*str >= 97) {
#line 65
      if ((int const   )*str <= 102) {
#line 66
        tmp = str;
#line 66
        str ++;
#line 66
        value = ((16 * value + (int )*tmp) - 97) + 10;
      } else {
#line 65
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 67
    if ((int const   )*str >= 65) {
#line 67
      if ((int const   )*str <= 70) {
#line 68
        tmp___0 = str;
#line 68
        str ++;
#line 68
        value = ((16 * value + (int )*tmp___0) - 65) + 10;
      } else {
#line 70
        tmp___1 = str;
#line 70
        str ++;
#line 70
        value = (16 * value + (int )*tmp___1) - 48;
      }
    } else {
#line 70
      tmp___1 = str;
#line 70
      str ++;
#line 70
      value = (16 * value + (int )*tmp___1) - 48;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  __o = o;
#line 71
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 71
    _obstack_newchunk(__o, 1);
    }
  }
#line 71
  tmp___2 = __o->next_free;
#line 71
  (__o->next_free) ++;
#line 71
  *tmp___2 = (char )value;
#line 72
  return;
}
}
#line 74 "sheets-map.l"
__inline static void obstack_octal_grow(struct obstack *o , char const   *str ) 
{ 
  int value ;
  char const   *tmp ;
  char const   *tmp___0 ;
  struct obstack *__o ;
  char *tmp___1 ;

  {
#line 77
  tmp = str;
#line 77
  str ++;
#line 77
  value = (int )((int const   )*tmp - 48);
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! *str) {
#line 79
      goto while_break;
    }
#line 80
    tmp___0 = str;
#line 80
    str ++;
#line 80
    value = (8 * value + (int )*tmp___0) - 48;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  __o = o;
#line 81
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 81
    _obstack_newchunk(__o, 1);
    }
  }
#line 81
  tmp___1 = __o->next_free;
#line 81
  (__o->next_free) ++;
#line 81
  *tmp___1 = (char )value;
#line 82
  return;
}
}
#line 645 "sheets-map.c"
static int yy_init_globals___1(void) ;
#line 655
int smapwrap(void) ;
#line 776 "sheets-map.c"
int smaplex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  int yyl ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned char *string ;
  struct obstack *__o ;
  char *tmp___2 ;
  struct obstack *__o1 ;
  void *value ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct obstack *__o___1 ;
  char *tmp___5 ;
  struct obstack *__o___2 ;
  char *tmp___6 ;
  struct obstack *__o___3 ;
  char *tmp___7 ;
  struct obstack *__o___4 ;
  char *tmp___8 ;
  struct obstack *__o___5 ;
  char *tmp___9 ;
  struct obstack *__o___6 ;
  char *tmp___10 ;
  struct obstack *__o___7 ;
  char *tmp___11 ;
  struct obstack *__o___8 ;
  char *tmp___12 ;
  struct obstack *__o___9 ;
  char *tmp___13 ;
  struct obstack *__o___10 ;
  char *tmp___14 ;
  char *tmp___15 ;
  struct obstack *__o___11 ;
  int __len ;
  unsigned char *string___0 ;
  struct obstack *__o___12 ;
  char *tmp___16 ;
  struct obstack *__o1___0 ;
  void *value___0 ;
  struct obstack *__o___13 ;
  void *__obj___0 ;
  char *tmp___17 ;
  char *tmp___18 ;
  struct obstack *__o___14 ;
  char *tmp___19 ;
  struct obstack *__o___15 ;
  char *tmp___20 ;
  struct obstack *__o___16 ;
  char *tmp___21 ;
  struct obstack *__o___17 ;
  char *tmp___22 ;
  struct obstack *__o___18 ;
  char *tmp___23 ;
  struct obstack *__o___19 ;
  char *tmp___24 ;
  struct obstack *__o___20 ;
  char *tmp___25 ;
  struct obstack *__o___21 ;
  char *tmp___26 ;
  struct obstack *__o___22 ;
  char *tmp___27 ;
  struct obstack *__o___23 ;
  char *tmp___28 ;
  char *tmp___29 ;
  struct obstack *__o___24 ;
  int __len___0 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___30 ;
  int tmp___31 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;

  {
#line 787
  if (! yy_init___1) {
#line 789
    yy_init___1 = 1;
#line 795
    if (! yy_start___1) {
#line 796
      yy_start___1 = 1;
    }
#line 798
    if (! smapin) {
#line 799
      smapin = stdin;
    }
#line 801
    if (! smapout) {
#line 802
      smapout = stdout;
    }
#line 804
    if (yy_buffer_stack___1) {
#line 804
      tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
    } else {
#line 804
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 804
    if (! tmp) {
      {
#line 805
      smapensure_buffer_stack();
#line 806
      *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = smap_create_buffer(smapin,
                                                                            16384);
      }
    }
    {
#line 810
    smap_load_buffer_state();
    }
  }
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    yy_cp = yy_c_buf_p___1;
#line 818
    *yy_cp = yy_hold_char___1;
#line 823
    yy_bp = yy_cp;
#line 825
    yy_current_state = yy_start___1;
    yy_match: 
    {
#line 827
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 829
      yy_c = (YY_CHAR )yy_ec___1[(unsigned int )((unsigned char )*yy_cp)];
#line 830
      if (yy_accept___1[yy_current_state]) {
#line 832
        yy_last_accepting_state___1 = yy_current_state;
#line 833
        yy_last_accepting_cpos___1 = yy_cp;
      }
      {
#line 835
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 835
        if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 835
          goto while_break___1;
        }
#line 837
        yy_current_state = (int )yy_def___1[yy_current_state];
#line 838
        if (yy_current_state >= 74) {
#line 839
          yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 841
      yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 842
      yy_cp ++;
#line 827
      if (! ((int const   )yy_base___1[yy_current_state] != 174)) {
#line 827
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 847
    yy_act = (int )yy_accept___1[yy_current_state];
#line 848
    if (yy_act == 0) {
#line 850
      yy_cp = yy_last_accepting_cpos___1;
#line 851
      yy_current_state = yy_last_accepting_state___1;
#line 852
      yy_act = (int )yy_accept___1[yy_current_state];
    }
#line 855
    smaptext = yy_bp;
#line 855
    smapleng = (int )((size_t )(yy_cp - yy_bp));
#line 855
    yy_hold_char___1 = *yy_cp;
#line 855
    *yy_cp = (char )'\000';
#line 855
    yy_c_buf_p___1 = yy_cp;
#line 857
    if (yy_act != 39) {
#line 857
      if (yy_rule_can_match_eol___1[yy_act]) {
#line 860
        yyl = 0;
        {
#line 860
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 860
          if (! (yyl < smapleng)) {
#line 860
            goto while_break___2;
          }
#line 861
          if ((int )*(smaptext + yyl) == 10) {
#line 863
            smaplineno ++;
          }
#line 860
          yyl ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    do_action: 
    {
#line 871
    if (yy_act == 0) {
#line 871
      goto case_0;
    }
#line 878
    if (yy_act == 1) {
#line 878
      goto case_1;
    }
#line 102
    if (yy_act == 2) {
#line 102 "sheets-map.l"
      goto case_2;
    }
#line 103
    if (yy_act == 3) {
#line 103
      goto case_3;
    }
#line 104
    if (yy_act == 4) {
#line 104
      goto case_4;
    }
#line 105
    if (yy_act == 5) {
#line 105
      goto case_5;
    }
#line 106
    if (yy_act == 6) {
#line 106
      goto case_6;
    }
#line 110
    if (yy_act == 7) {
#line 110
      goto case_7;
    }
#line 116
    if (yy_act == 42) {
#line 116
      goto case_42;
    }
#line 116
    if (yy_act == 41) {
#line 116
      goto case_42;
    }
#line 116
    if (yy_act == 40) {
#line 116
      goto case_42;
    }
#line 122
    if (yy_act == 8) {
#line 122
      goto case_8;
    }
#line 137
    if (yy_act == 9) {
#line 137
      goto case_9;
    }
#line 139
    if (yy_act == 10) {
#line 139
      goto case_10;
    }
#line 140
    if (yy_act == 11) {
#line 140
      goto case_11;
    }
#line 141
    if (yy_act == 12) {
#line 141
      goto case_12;
    }
#line 142
    if (yy_act == 13) {
#line 142
      goto case_13;
    }
#line 143
    if (yy_act == 14) {
#line 143
      goto case_14;
    }
#line 144
    if (yy_act == 15) {
#line 144
      goto case_15;
    }
#line 145
    if (yy_act == 16) {
#line 145
      goto case_16;
    }
#line 146
    if (yy_act == 17) {
#line 146
      goto case_17;
    }
#line 147
    if (yy_act == 18) {
#line 147
      goto case_18;
    }
#line 148
    if (yy_act == 19) {
#line 148
      goto case_19;
    }
#line 149
    if (yy_act == 20) {
#line 149
      goto case_20;
    }
#line 150
    if (yy_act == 21) {
#line 150
      goto case_21;
    }
#line 156
    if (yy_act == 22) {
#line 156
      goto case_22;
    }
#line 162
    if (yy_act == 23) {
#line 162
      goto case_23;
    }
#line 177
    if (yy_act == 24) {
#line 177
      goto case_24;
    }
#line 179
    if (yy_act == 25) {
#line 179
      goto case_25;
    }
#line 180
    if (yy_act == 26) {
#line 180
      goto case_26;
    }
#line 181
    if (yy_act == 27) {
#line 181
      goto case_27;
    }
#line 182
    if (yy_act == 28) {
#line 182
      goto case_28;
    }
#line 183
    if (yy_act == 29) {
#line 183
      goto case_29;
    }
#line 184
    if (yy_act == 30) {
#line 184
      goto case_30;
    }
#line 185
    if (yy_act == 31) {
#line 185
      goto case_31;
    }
#line 186
    if (yy_act == 32) {
#line 186
      goto case_32;
    }
#line 187
    if (yy_act == 33) {
#line 187
      goto case_33;
    }
#line 188
    if (yy_act == 34) {
#line 188
      goto case_34;
    }
#line 189
    if (yy_act == 35) {
#line 189
      goto case_35;
    }
#line 190
    if (yy_act == 36) {
#line 190
      goto case_36;
    }
#line 195
    if (yy_act == 37) {
#line 195
      goto case_37;
    }
#line 200
    if (yy_act == 38) {
#line 200
      goto case_38;
    }
#line 1132
    if (yy_act == 39) {
#line 1132 "sheets-map.c"
      goto case_39;
    }
#line 1254
    goto switch_default;
    case_0: /* CIL Label */ 
#line 873
    *yy_cp = yy_hold_char___1;
#line 874
    yy_cp = yy_last_accepting_cpos___1;
#line 875
    yy_current_state = yy_last_accepting_state___1;
#line 876
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 100 "sheets-map.l"
    token_val = xstrndup((char const   *)smaptext, (size_t )(smapleng - 1));
    }
#line 100
    return (10);
#line 101
    goto switch_break;
    case_2: /* CIL Label */ 
#line 101
    yy_start___1 = 3;
#line 102
    goto switch_break;
    case_3: /* CIL Label */ 
#line 102
    yy_start___1 = 5;
#line 103
    goto switch_break;
    case_4: /* CIL Label */ ;
#line 104
    goto switch_break;
    case_5: /* CIL Label */ ;
#line 105
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 106
    *(smaptext + (smapleng - 1)) = (char )'\000';
#line 107
    tmp___0 = strlen("include(");
#line 107
    yy_include_push(smaptext + tmp___0);
    }
#line 109
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 110
    tmp___1 = gettext("unexpected character `%c\'");
#line 110
    error_at_line(1, 0, (char const   *)yyfilename, (unsigned int )smaplineno, (char const   *)tmp___1,
                  (int )*smaptext);
    }
#line 113
    goto switch_break;
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    {
#line 113
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 113
      if ((unsigned int )(1 << 6) & msg_verbosity) {
        {
#line 113
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"End of file `%s\'.\n",
                yyfilename);
        }
      }
#line 113
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 115
    include_stack_ptr___0 --;
#line 115
    if (include_stack_ptr___0 < 0) {
#line 116
      return (0);
    } else {
      {
#line 118
      yy_include_pop();
      }
    }
#line 120
    goto switch_break;
    case_8: /* CIL Label */ 
#line 125
    __o = & string_stack___0;
#line 125
    if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
      {
#line 125
      _obstack_newchunk(__o, 1);
      }
    }
#line 125
    tmp___2 = __o->next_free;
#line 125
    (__o->next_free) ++;
#line 125
    *tmp___2 = (char )'\000';
#line 126
    __o1 = & string_stack___0;
#line 126
    value = (void *)__o1->object_base;
#line 126
    if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 126
      __o1->maybe_empty_object = 1U;
    }
#line 126
    __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 126
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 126
      __o1->next_free = __o1->chunk_limit;
    }
#line 126
    __o1->object_base = __o1->next_free;
#line 126
    string = (unsigned char *)value;
#line 127
    __o___0 = & string_stack___0;
#line 127
    __obj = (void *)string;
#line 127
    if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 127
      if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 127
        tmp___3 = (char *)__obj;
#line 127
        __o___0->object_base = tmp___3;
#line 127
        __o___0->next_free = tmp___3;
      } else {
        {
#line 127
        obstack_free(__o___0, __obj);
        }
      }
    } else {
      {
#line 127
      obstack_free(__o___0, __obj);
      }
    }
    {
#line 128
    tmp___4 = xstrdup((char const   *)string);
#line 128
    token_val = (char *)((unsigned char *)tmp___4);
#line 131
    insensitive_p = (_Bool )((int )*(smaptext + 1) == 105);
#line 133
    yy_start___1 = 1;
    }
#line 134
    return (11);
#line 136
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 137
    obstack_octal_grow(& string_stack___0, (char const   *)(smaptext + 1));
    }
#line 138
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 138
    obstack_hexa_grow(& string_stack___0, (char const   *)(smaptext + 2));
    }
#line 139
    goto switch_break;
    case_11: /* CIL Label */ 
#line 139
    __o___1 = & string_stack___0;
#line 139
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 139
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 139
    tmp___5 = __o___1->next_free;
#line 139
    (__o___1->next_free) ++;
#line 139
    *tmp___5 = (char )'\a';
#line 140
    goto switch_break;
    case_12: /* CIL Label */ 
#line 140
    __o___2 = & string_stack___0;
#line 140
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 140
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 140
    tmp___6 = __o___2->next_free;
#line 140
    (__o___2->next_free) ++;
#line 140
    *tmp___6 = (char )'\b';
#line 141
    goto switch_break;
    case_13: /* CIL Label */ 
#line 141
    __o___3 = & string_stack___0;
#line 141
    if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
      {
#line 141
      _obstack_newchunk(__o___3, 1);
      }
    }
#line 141
    tmp___7 = __o___3->next_free;
#line 141
    (__o___3->next_free) ++;
#line 141
    *tmp___7 = (char)127;
#line 142
    goto switch_break;
    case_14: /* CIL Label */ 
#line 142
    __o___4 = & string_stack___0;
#line 142
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 142
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 142
    tmp___8 = __o___4->next_free;
#line 142
    (__o___4->next_free) ++;
#line 142
    *tmp___8 = (char)27;
#line 143
    goto switch_break;
    case_15: /* CIL Label */ 
#line 143
    __o___5 = & string_stack___0;
#line 143
    if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
      {
#line 143
      _obstack_newchunk(__o___5, 1);
      }
    }
#line 143
    tmp___9 = __o___5->next_free;
#line 143
    (__o___5->next_free) ++;
#line 143
    *tmp___9 = (char )'\f';
#line 144
    goto switch_break;
    case_16: /* CIL Label */ 
#line 144
    __o___6 = & string_stack___0;
#line 144
    if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
      {
#line 144
      _obstack_newchunk(__o___6, 1);
      }
    }
#line 144
    tmp___10 = __o___6->next_free;
#line 144
    (__o___6->next_free) ++;
#line 144
    *tmp___10 = (char )'\n';
#line 145
    goto switch_break;
    case_17: /* CIL Label */ 
#line 145
    __o___7 = & string_stack___0;
#line 145
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 145
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 145
    tmp___11 = __o___7->next_free;
#line 145
    (__o___7->next_free) ++;
#line 145
    *tmp___11 = (char )'\r';
#line 146
    goto switch_break;
    case_18: /* CIL Label */ 
#line 146
    __o___8 = & string_stack___0;
#line 146
    if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
      {
#line 146
      _obstack_newchunk(__o___8, 1);
      }
    }
#line 146
    tmp___12 = __o___8->next_free;
#line 146
    (__o___8->next_free) ++;
#line 146
    *tmp___12 = (char )'\t';
#line 147
    goto switch_break;
    case_19: /* CIL Label */ 
#line 147
    __o___9 = & string_stack___0;
#line 147
    if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
      {
#line 147
      _obstack_newchunk(__o___9, 1);
      }
    }
#line 147
    tmp___13 = __o___9->next_free;
#line 147
    (__o___9->next_free) ++;
#line 147
    *tmp___13 = (char )'\v';
#line 148
    goto switch_break;
    case_20: /* CIL Label */ 
#line 148
    __o___10 = & string_stack___0;
#line 148
    if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
      {
#line 148
      _obstack_newchunk(__o___10, 1);
      }
    }
#line 148
    tmp___14 = __o___10->next_free;
#line 148
    (__o___10->next_free) ++;
#line 148
    *tmp___14 = *(smaptext + 1);
#line 149
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 151
    tmp___15 = gettext("end of line inside a %s");
#line 151
    error_at_line(1, 0, (char const   *)yyfilename, (unsigned int )smaplineno, (char const   *)tmp___15,
                  "/../");
    }
#line 155
    goto switch_break;
    case_22: /* CIL Label */ 
#line 157
    __o___11 = & string_stack___0;
#line 157
    __len = smapleng;
#line 157
    if ((unsigned long )(__o___11->next_free + __len) > (unsigned long )__o___11->chunk_limit) {
      {
#line 157
      _obstack_newchunk(__o___11, __len);
      }
    }
    {
#line 157
    memcpy((void */* __restrict  */)__o___11->next_free, (void const   */* __restrict  */)smaptext,
           (size_t )__len);
#line 157
    __o___11->next_free += __len;
    }
#line 159
    goto switch_break;
    case_23: /* CIL Label */ 
#line 165
    __o___12 = & string_stack___0;
#line 165
    if ((unsigned long )(__o___12->next_free + 1) > (unsigned long )__o___12->chunk_limit) {
      {
#line 165
      _obstack_newchunk(__o___12, 1);
      }
    }
#line 165
    tmp___16 = __o___12->next_free;
#line 165
    (__o___12->next_free) ++;
#line 165
    *tmp___16 = (char )'\000';
#line 166
    __o1___0 = & string_stack___0;
#line 166
    value___0 = (void *)__o1___0->object_base;
#line 166
    if ((unsigned long )__o1___0->next_free == (unsigned long )value___0) {
#line 166
      __o1___0->maybe_empty_object = 1U;
    }
#line 166
    __o1___0->next_free = (char *)0 + (((__o1___0->next_free - (char *)0) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 166
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 166
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 166
    __o1___0->object_base = __o1___0->next_free;
#line 166
    string___0 = (unsigned char *)value___0;
#line 167
    __o___13 = & string_stack___0;
#line 167
    __obj___0 = (void *)string___0;
#line 167
    if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___13->chunk)) {
#line 167
      if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___13->chunk_limit)) {
#line 167
        tmp___17 = (char *)__obj___0;
#line 167
        __o___13->object_base = tmp___17;
#line 167
        __o___13->next_free = tmp___17;
      } else {
        {
#line 167
        obstack_free(__o___13, __obj___0);
        }
      }
    } else {
      {
#line 167
      obstack_free(__o___13, __obj___0);
      }
    }
    {
#line 168
    tmp___18 = xstrdup((char const   *)string___0);
#line 168
    token_val = (char *)((unsigned char *)tmp___18);
#line 171
    insensitive_p = (_Bool )((int )*(smaptext + 1) == 105);
#line 173
    yy_start___1 = 1;
    }
#line 174
    return (12);
#line 176
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 177
    obstack_octal_grow(& string_stack___0, (char const   *)(smaptext + 1));
    }
#line 178
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 178
    obstack_hexa_grow(& string_stack___0, (char const   *)(smaptext + 2));
    }
#line 179
    goto switch_break;
    case_26: /* CIL Label */ 
#line 179
    __o___14 = & string_stack___0;
#line 179
    if ((unsigned long )(__o___14->next_free + 1) > (unsigned long )__o___14->chunk_limit) {
      {
#line 179
      _obstack_newchunk(__o___14, 1);
      }
    }
#line 179
    tmp___19 = __o___14->next_free;
#line 179
    (__o___14->next_free) ++;
#line 179
    *tmp___19 = (char )'\a';
#line 180
    goto switch_break;
    case_27: /* CIL Label */ 
#line 180
    __o___15 = & string_stack___0;
#line 180
    if ((unsigned long )(__o___15->next_free + 1) > (unsigned long )__o___15->chunk_limit) {
      {
#line 180
      _obstack_newchunk(__o___15, 1);
      }
    }
#line 180
    tmp___20 = __o___15->next_free;
#line 180
    (__o___15->next_free) ++;
#line 180
    *tmp___20 = (char )'\b';
#line 181
    goto switch_break;
    case_28: /* CIL Label */ 
#line 181
    __o___16 = & string_stack___0;
#line 181
    if ((unsigned long )(__o___16->next_free + 1) > (unsigned long )__o___16->chunk_limit) {
      {
#line 181
      _obstack_newchunk(__o___16, 1);
      }
    }
#line 181
    tmp___21 = __o___16->next_free;
#line 181
    (__o___16->next_free) ++;
#line 181
    *tmp___21 = (char)127;
#line 182
    goto switch_break;
    case_29: /* CIL Label */ 
#line 182
    __o___17 = & string_stack___0;
#line 182
    if ((unsigned long )(__o___17->next_free + 1) > (unsigned long )__o___17->chunk_limit) {
      {
#line 182
      _obstack_newchunk(__o___17, 1);
      }
    }
#line 182
    tmp___22 = __o___17->next_free;
#line 182
    (__o___17->next_free) ++;
#line 182
    *tmp___22 = (char)27;
#line 183
    goto switch_break;
    case_30: /* CIL Label */ 
#line 183
    __o___18 = & string_stack___0;
#line 183
    if ((unsigned long )(__o___18->next_free + 1) > (unsigned long )__o___18->chunk_limit) {
      {
#line 183
      _obstack_newchunk(__o___18, 1);
      }
    }
#line 183
    tmp___23 = __o___18->next_free;
#line 183
    (__o___18->next_free) ++;
#line 183
    *tmp___23 = (char )'\f';
#line 184
    goto switch_break;
    case_31: /* CIL Label */ 
#line 184
    __o___19 = & string_stack___0;
#line 184
    if ((unsigned long )(__o___19->next_free + 1) > (unsigned long )__o___19->chunk_limit) {
      {
#line 184
      _obstack_newchunk(__o___19, 1);
      }
    }
#line 184
    tmp___24 = __o___19->next_free;
#line 184
    (__o___19->next_free) ++;
#line 184
    *tmp___24 = (char )'\n';
#line 185
    goto switch_break;
    case_32: /* CIL Label */ 
#line 185
    __o___20 = & string_stack___0;
#line 185
    if ((unsigned long )(__o___20->next_free + 1) > (unsigned long )__o___20->chunk_limit) {
      {
#line 185
      _obstack_newchunk(__o___20, 1);
      }
    }
#line 185
    tmp___25 = __o___20->next_free;
#line 185
    (__o___20->next_free) ++;
#line 185
    *tmp___25 = (char )'\r';
#line 186
    goto switch_break;
    case_33: /* CIL Label */ 
#line 186
    __o___21 = & string_stack___0;
#line 186
    if ((unsigned long )(__o___21->next_free + 1) > (unsigned long )__o___21->chunk_limit) {
      {
#line 186
      _obstack_newchunk(__o___21, 1);
      }
    }
#line 186
    tmp___26 = __o___21->next_free;
#line 186
    (__o___21->next_free) ++;
#line 186
    *tmp___26 = (char )'\t';
#line 187
    goto switch_break;
    case_34: /* CIL Label */ 
#line 187
    __o___22 = & string_stack___0;
#line 187
    if ((unsigned long )(__o___22->next_free + 1) > (unsigned long )__o___22->chunk_limit) {
      {
#line 187
      _obstack_newchunk(__o___22, 1);
      }
    }
#line 187
    tmp___27 = __o___22->next_free;
#line 187
    (__o___22->next_free) ++;
#line 187
    *tmp___27 = (char )'\v';
#line 188
    goto switch_break;
    case_35: /* CIL Label */ 
#line 188
    __o___23 = & string_stack___0;
#line 188
    if ((unsigned long )(__o___23->next_free + 1) > (unsigned long )__o___23->chunk_limit) {
      {
#line 188
      _obstack_newchunk(__o___23, 1);
      }
    }
#line 188
    tmp___28 = __o___23->next_free;
#line 188
    (__o___23->next_free) ++;
#line 188
    *tmp___28 = *(smaptext + 1);
#line 189
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 191
    tmp___29 = gettext("end of line inside a %s");
#line 191
    error_at_line(1, 0, (char const   *)yyfilename, (unsigned int )smaplineno, (char const   *)tmp___29,
                  "<..>");
    }
#line 194
    goto switch_break;
    case_37: /* CIL Label */ 
#line 196
    __o___24 = & string_stack___0;
#line 196
    __len___0 = smapleng;
#line 196
    if ((unsigned long )(__o___24->next_free + __len___0) > (unsigned long )__o___24->chunk_limit) {
      {
#line 196
      _obstack_newchunk(__o___24, __len___0);
      }
    }
    {
#line 196
    memcpy((void */* __restrict  */)__o___24->next_free, (void const   */* __restrict  */)smaptext,
           (size_t )__len___0);
#line 196
    __o___24->next_free += __len___0;
    }
#line 198
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 199
    fwrite((void const   */* __restrict  */)smaptext, (size_t )smapleng, (size_t )1,
           (FILE */* __restrict  */)smapout);
    }
#line 200
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1135 "sheets-map.c"
    yy_amount_of_matched_text = (int )(yy_cp - smaptext) - 1;
#line 1138
    *yy_cp = yy_hold_char___1;
#line 1141
    if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buffer_status == 0) {
#line 1152
      yy_n_chars___1 = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars;
#line 1153
      (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_input_file = smapin;
#line 1154
      (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buffer_status = 1;
    }
#line 1164
    if ((unsigned long )yy_c_buf_p___1 <= (unsigned long )((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + yy_n_chars___1)) {
      {
#line 1168
      yy_c_buf_p___1 = smaptext + yy_amount_of_matched_text;
#line 1170
      yy_current_state = yy_get_previous_state___1();
#line 1181
      yy_next_state = yy_try_NUL_trans___1(yy_current_state);
#line 1183
      yy_bp = smaptext + 0;
      }
#line 1185
      if (yy_next_state) {
#line 1188
        yy_c_buf_p___1 ++;
#line 1188
        yy_cp = yy_c_buf_p___1;
#line 1189
        yy_current_state = yy_next_state;
#line 1190
        goto yy_match;
      } else {
#line 1195
        yy_cp = yy_c_buf_p___1;
#line 1196
        goto yy_find_action;
      }
    } else {
      {
#line 1200
      tmp___30 = yy_get_next_buffer___1();
      }
      {
#line 1202
      if (tmp___30 == 1) {
#line 1202
        goto case_1___0;
      }
#line 1231
      if (tmp___30 == 0) {
#line 1231
        goto case_0___0;
      }
#line 1241
      if (tmp___30 == 2) {
#line 1241
        goto case_2___0;
      }
#line 1200
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1204
      yy_did_buffer_switch_on_eof___1 = 0;
#line 1206
      tmp___31 = smapwrap();
      }
#line 1206
      if (tmp___31) {
#line 1217
        yy_c_buf_p___1 = smaptext + 0;
#line 1219
        yy_act = (39 + (yy_start___1 - 1) / 2) + 1;
#line 1220
        goto do_action;
      } else
#line 1225
      if (! yy_did_buffer_switch_on_eof___1) {
        {
#line 1226
        smaprestart(smapin);
        }
      }
#line 1228
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1232
      yy_c_buf_p___1 = smaptext + yy_amount_of_matched_text;
#line 1235
      yy_current_state = yy_get_previous_state___1();
#line 1237
      yy_cp = yy_c_buf_p___1;
#line 1238
      yy_bp = smaptext + 0;
      }
#line 1239
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1242
      yy_c_buf_p___1 = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + yy_n_chars___1;
#line 1245
      yy_current_state = yy_get_previous_state___1();
#line 1247
      yy_cp = yy_c_buf_p___1;
#line 1248
      yy_bp = smaptext + 0;
      }
#line 1249
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1251
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1255
    yy_fatal_error___1("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1268 "sheets-map.c"
static int yy_get_next_buffer___1(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 1270
  dest = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf;
#line 1271
  source = smaptext;
#line 1275
  if ((unsigned long )yy_c_buf_p___1 > (unsigned long )((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + (yy_n_chars___1 + 1))) {
    {
#line 1276
    yy_fatal_error___1("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1279
  if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_fill_buffer == 0) {
#line 1281
    if (yy_c_buf_p___1 - smaptext == 1L) {
#line 1286
      return (1);
    } else {
#line 1294
      return (2);
    }
  }
#line 1301
  number_to_move = (int )(yy_c_buf_p___1 - smaptext) - 1;
#line 1303
  i = 0;
  {
#line 1303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1303
    if (! (i < number_to_move)) {
#line 1303
      goto while_break;
    }
#line 1304
    tmp = dest;
#line 1304
    dest ++;
#line 1304
    tmp___0 = source;
#line 1304
    source ++;
#line 1304
    *tmp = *tmp___0;
#line 1303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1306
  if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buffer_status == 2) {
#line 1310
    yy_n_chars___1 = 0;
#line 1310
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
  } else {
#line 1314
    num_to_read = (int )(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1317
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1317
      if (! (num_to_read <= 0)) {
#line 1317
        goto while_break___0;
      }
#line 1321
      if (yy_buffer_stack___1) {
#line 1321
        tmp___1 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
      } else {
#line 1321
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1321
      b = tmp___1;
#line 1323
      yy_c_buf_p_offset = (int )(yy_c_buf_p___1 - b->yy_ch_buf);
#line 1326
      if (b->yy_is_our_buffer) {
#line 1328
        new_size = (int )(b->yy_buf_size * 2U);
#line 1330
        if (new_size <= 0) {
#line 1331
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1333
          b->yy_buf_size *= 2U;
        }
        {
#line 1335
        tmp___2 = smaprealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1335
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1341
        b->yy_ch_buf = (char *)0;
      }
#line 1343
      if (! b->yy_ch_buf) {
        {
#line 1344
        yy_fatal_error___1("fatal error - scanner input buffer overflow");
        }
      }
#line 1347
      yy_c_buf_p___1 = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1349
      num_to_read = (int )(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1354
    if (num_to_read > 8192) {
#line 1355
      num_to_read = 8192;
    }
#line 1358
    if ((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_is_interactive) {
#line 1358
      c = '*';
#line 1358
      n = (size_t )0;
      {
#line 1358
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1358
        if (n < (size_t )num_to_read) {
          {
#line 1358
          c = _IO_getc(smapin);
          }
#line 1358
          if (c != -1) {
#line 1358
            if (! (c != 10)) {
#line 1358
              goto while_break___1;
            }
          } else {
#line 1358
            goto while_break___1;
          }
        } else {
#line 1358
          goto while_break___1;
        }
#line 1358
        *(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1358
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1358
      if (c == 10) {
#line 1358
        tmp___3 = n;
#line 1358
        n ++;
#line 1358
        *(((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1358
      if (c == -1) {
        {
#line 1358
        tmp___4 = ferror(smapin);
        }
#line 1358
        if (tmp___4) {
          {
#line 1358
          yy_fatal_error___1("input in flex scanner failed");
          }
        }
      }
#line 1358
      yy_n_chars___1 = (int )n;
    } else {
      {
#line 1358
      tmp___5 = __errno_location();
#line 1358
      *tmp___5 = 0;
      }
      {
#line 1358
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1358
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)smapin);
#line 1358
        yy_n_chars___1 = (int )tmp___8;
        }
#line 1358
        if (yy_n_chars___1 == 0) {
          {
#line 1358
          tmp___9 = ferror(smapin);
          }
#line 1358
          if (! tmp___9) {
#line 1358
            goto while_break___2;
          }
        } else {
#line 1358
          goto while_break___2;
        }
        {
#line 1358
        tmp___6 = __errno_location();
        }
#line 1358
        if (*tmp___6 != 4) {
          {
#line 1358
          yy_fatal_error___1("input in flex scanner failed");
          }
#line 1358
          goto while_break___2;
        }
        {
#line 1358
        tmp___7 = __errno_location();
#line 1358
        *tmp___7 = 0;
#line 1358
        clearerr(smapin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1361
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
  }
#line 1364
  if (yy_n_chars___1 == 0) {
#line 1366
    if (number_to_move == 0) {
      {
#line 1368
      ret_val = 1;
#line 1369
      smaprestart(smapin);
      }
    } else {
#line 1374
      ret_val = 2;
#line 1375
      (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buffer_status = 2;
    }
  } else {
#line 1381
    ret_val = 0;
  }
#line 1383
  yy_n_chars___1 += number_to_move;
#line 1384
  *((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + yy_n_chars___1) = (char)0;
#line 1385
  *((*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + (yy_n_chars___1 + 1)) = (char)0;
#line 1387
  smaptext = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_ch_buf + 0;
#line 1389
  return (ret_val);
}
}
#line 1394 "sheets-map.c"
static yy_state_type yy_get_previous_state___1(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1399
  yy_current_state = yy_start___1;
#line 1401
  yy_cp = smaptext + 0;
  {
#line 1401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p___1)) {
#line 1401
      goto while_break;
    }
#line 1403
    if (*yy_cp) {
#line 1403
      tmp = yy_ec___1[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1403
      tmp = (flex_int32_t const   )1;
    }
#line 1403
    yy_c = (YY_CHAR )tmp;
#line 1404
    if (yy_accept___1[yy_current_state]) {
#line 1406
      yy_last_accepting_state___1 = yy_current_state;
#line 1407
      yy_last_accepting_cpos___1 = yy_cp;
    }
    {
#line 1409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1409
      if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1409
        goto while_break___0;
      }
#line 1411
      yy_current_state = (int )yy_def___1[yy_current_state];
#line 1412
      if (yy_current_state >= 74) {
#line 1413
        yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1415
    yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1401
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1418
  return (yy_current_state);
}
}
#line 1426 "sheets-map.c"
static yy_state_type yy_try_NUL_trans___1(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1429
  yy_cp = yy_c_buf_p___1;
#line 1431
  yy_c = (YY_CHAR )1;
#line 1432
  if (yy_accept___1[yy_current_state]) {
#line 1434
    yy_last_accepting_state___1 = yy_current_state;
#line 1435
    yy_last_accepting_cpos___1 = yy_cp;
  }
  {
#line 1437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1437
    if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1437
      goto while_break;
    }
#line 1439
    yy_current_state = (int )yy_def___1[yy_current_state];
#line 1440
    if (yy_current_state >= 74) {
#line 1441
      yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1443
  yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1444
  yy_is_jam = yy_current_state == 73;
#line 1446
  if (yy_is_jam) {
#line 1446
    tmp = 0;
  } else {
#line 1446
    tmp = yy_current_state;
  }
#line 1446
  return (tmp);
}
}
#line 1574 "sheets-map.c"
void smaprestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1577
  if (yy_buffer_stack___1) {
#line 1577
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1577
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1577
  if (! tmp) {
    {
#line 1578
    smapensure_buffer_stack();
#line 1579
    *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = smap_create_buffer(smapin,
                                                                          16384);
    }
  }
#line 1583
  if (yy_buffer_stack___1) {
#line 1583
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1583
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1583
  smap_init_buffer(tmp___0, input_file);
#line 1584
  smap_load_buffer_state();
  }
#line 1585
  return;
}
}
#line 1591 "sheets-map.c"
void smap_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1599
  smapensure_buffer_stack();
  }
#line 1600
  if (yy_buffer_stack___1) {
#line 1600
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1600
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1600
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1601
    return;
  }
#line 1603
  if (yy_buffer_stack___1) {
#line 1603
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1603
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1603
  if (tmp___0) {
#line 1606
    *yy_c_buf_p___1 = yy_hold_char___1;
#line 1607
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_pos = yy_c_buf_p___1;
#line 1608
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
  }
  {
#line 1611
  *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = new_buffer;
#line 1612
  smap_load_buffer_state();
#line 1619
  yy_did_buffer_switch_on_eof___1 = 1;
  }
#line 1620
  return;
}
}
#line 1622 "sheets-map.c"
static void smap_load_buffer_state(void) 
{ 


  {
#line 1624
  yy_n_chars___1 = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars;
#line 1625
  yy_c_buf_p___1 = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_pos;
#line 1625
  smaptext = yy_c_buf_p___1;
#line 1626
  smapin = (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_input_file;
#line 1627
  yy_hold_char___1 = *yy_c_buf_p___1;
#line 1628
  return;
}
}
#line 1636 "sheets-map.c"
YY_BUFFER_STATE smap_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1640
  tmp = smapalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1640
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1641
  if (! b) {
    {
#line 1642
    yy_fatal_error___1("out of dynamic memory in smap_create_buffer()");
    }
  }
  {
#line 1644
  b->yy_buf_size = (yy_size_t )size;
#line 1649
  tmp___0 = smapalloc(b->yy_buf_size + 2U);
#line 1649
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1650
  if (! b->yy_ch_buf) {
    {
#line 1651
    yy_fatal_error___1("out of dynamic memory in smap_create_buffer()");
    }
  }
  {
#line 1653
  b->yy_is_our_buffer = 1;
#line 1655
  smap_init_buffer(b, file);
  }
#line 1657
  return (b);
}
}
#line 1664 "sheets-map.c"
void smap_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1667
  if (! b) {
#line 1668
    return;
  }
#line 1670
  if (yy_buffer_stack___1) {
#line 1670
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1670
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1670
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1671
    *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = (YY_BUFFER_STATE )0;
  }
#line 1673
  if (b->yy_is_our_buffer) {
    {
#line 1674
    smapfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1676
  smapfree((void *)b);
  }
#line 1677
  return;
}
}
#line 1687 "sheets-map.c"
static void smap_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1690
  tmp = __errno_location();
#line 1690
  oerrno = *tmp;
#line 1692
  smap_flush_buffer(b);
#line 1694
  b->yy_input_file = file;
#line 1695
  b->yy_fill_buffer = 1;
  }
#line 1701
  if (yy_buffer_stack___1) {
#line 1701
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1701
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1701
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1702
    b->yy_bs_lineno = 1;
#line 1703
    b->yy_bs_column = 0;
  }
#line 1706
  if (file) {
    {
#line 1706
    tmp___1 = fileno(file);
#line 1706
    tmp___2 = isatty(tmp___1);
#line 1706
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1706
    b->yy_is_interactive = 0;
  }
  {
#line 1708
  tmp___3 = __errno_location();
#line 1708
  *tmp___3 = oerrno;
  }
#line 1709
  return;
}
}
#line 1715 "sheets-map.c"
void smap_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1717
  if (! b) {
#line 1718
    return;
  }
#line 1720
  b->yy_n_chars = 0;
#line 1726
  *(b->yy_ch_buf + 0) = (char)0;
#line 1727
  *(b->yy_ch_buf + 1) = (char)0;
#line 1729
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1731
  b->yy_at_bol = 1;
#line 1732
  b->yy_buffer_status = 0;
#line 1734
  if (yy_buffer_stack___1) {
#line 1734
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1734
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1734
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1735
    smap_load_buffer_state();
    }
  }
#line 1736
  return;
}
}
#line 1744 "sheets-map.c"
void smappush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1746
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1747
    return;
  }
  {
#line 1749
  smapensure_buffer_stack();
  }
#line 1752
  if (yy_buffer_stack___1) {
#line 1752
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1752
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1752
  if (tmp) {
#line 1755
    *yy_c_buf_p___1 = yy_hold_char___1;
#line 1756
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_buf_pos = yy_c_buf_p___1;
#line 1757
    (*(yy_buffer_stack___1 + yy_buffer_stack_top___1))->yy_n_chars = yy_n_chars___1;
  }
#line 1761
  if (yy_buffer_stack___1) {
#line 1761
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1761
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1761
  if (tmp___0) {
#line 1762
    yy_buffer_stack_top___1 ++;
  }
  {
#line 1763
  *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = new_buffer;
#line 1766
  smap_load_buffer_state();
#line 1767
  yy_did_buffer_switch_on_eof___1 = 1;
  }
#line 1768
  return;
}
}
#line 1774 "sheets-map.c"
void smappop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1776
  if (yy_buffer_stack___1) {
#line 1776
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1776
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1776
  if (! tmp) {
#line 1777
    return;
  }
#line 1779
  if (yy_buffer_stack___1) {
#line 1779
    tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1779
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1779
  smap_delete_buffer(tmp___0);
#line 1780
  *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1781
  if (yy_buffer_stack_top___1 > 0U) {
#line 1782
    yy_buffer_stack_top___1 --;
  }
#line 1784
  if (yy_buffer_stack___1) {
#line 1784
    tmp___1 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 1784
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1784
  if (tmp___1) {
    {
#line 1785
    smap_load_buffer_state();
#line 1786
    yy_did_buffer_switch_on_eof___1 = 1;
    }
  }
#line 1788
  return;
}
}
#line 1793 "sheets-map.c"
static void smapensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1797
  if (! yy_buffer_stack___1) {
    {
#line 1803
    num_to_alloc = 1;
#line 1804
    tmp = smapalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1804
    yy_buffer_stack___1 = (struct yy_buffer_state **)tmp;
#line 1808
    memset((void *)yy_buffer_stack___1, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1810
    yy_buffer_stack_max___1 = (size_t )num_to_alloc;
#line 1811
    yy_buffer_stack_top___1 = (size_t )0;
    }
#line 1812
    return;
  }
#line 1815
  if (yy_buffer_stack_top___1 >= yy_buffer_stack_max___1 - 1U) {
    {
#line 1818
    grow_size = 8;
#line 1820
    num_to_alloc = (int )(yy_buffer_stack_max___1 + (size_t )grow_size);
#line 1821
    tmp___0 = smaprealloc((void *)yy_buffer_stack___1, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1821
    yy_buffer_stack___1 = (struct yy_buffer_state **)tmp___0;
#line 1827
    memset((void *)(yy_buffer_stack___1 + yy_buffer_stack_max___1), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 1828
    yy_buffer_stack_max___1 = (size_t )num_to_alloc;
    }
  }
#line 1830
  return;
}
}
#line 1838 "sheets-map.c"
YY_BUFFER_STATE smap_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 1842
  if (size < 2U) {
#line 1846
    return ((YY_BUFFER_STATE )0);
  } else
#line 1842
  if ((int )*(base + (size - 2U)) != 0) {
#line 1846
    return ((YY_BUFFER_STATE )0);
  } else
#line 1842
  if ((int )*(base + (size - 1U)) != 0) {
#line 1846
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1848
  tmp = smapalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1848
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1849
  if (! b) {
    {
#line 1850
    yy_fatal_error___1("out of dynamic memory in smap_scan_buffer()");
    }
  }
  {
#line 1852
  b->yy_buf_size = size - 2U;
#line 1853
  tmp___0 = base;
#line 1853
  b->yy_ch_buf = tmp___0;
#line 1853
  b->yy_buf_pos = tmp___0;
#line 1854
  b->yy_is_our_buffer = 0;
#line 1855
  b->yy_input_file = (FILE *)0;
#line 1856
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1857
  b->yy_is_interactive = 0;
#line 1858
  b->yy_at_bol = 1;
#line 1859
  b->yy_fill_buffer = 0;
#line 1860
  b->yy_buffer_status = 0;
#line 1862
  smap_switch_to_buffer(b);
  }
#line 1864
  return (b);
}
}
#line 1875 "sheets-map.c"
YY_BUFFER_STATE smap_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1878
  tmp = strlen(yystr);
#line 1878
  tmp___0 = smap_scan_bytes(yystr, (int )tmp);
  }
#line 1878
  return (tmp___0);
}
}
#line 1888 "sheets-map.c"
YY_BUFFER_STATE smap_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1896
  n = (yy_size_t )(_yybytes_len + 2);
#line 1897
  tmp = smapalloc(n);
#line 1897
  buf___0 = (char *)tmp;
  }
#line 1898
  if (! buf___0) {
    {
#line 1899
    yy_fatal_error___1("out of dynamic memory in smap_scan_bytes()");
    }
  }
#line 1901
  i = 0;
  {
#line 1901
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1901
    if (! (i < _yybytes_len)) {
#line 1901
      goto while_break;
    }
#line 1902
    *(buf___0 + i) = (char )*(yybytes + i);
#line 1901
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1904
  tmp___0 = (char)0;
#line 1904
  *(buf___0 + (_yybytes_len + 1)) = tmp___0;
#line 1904
  *(buf___0 + _yybytes_len) = tmp___0;
#line 1906
  b = smap_scan_buffer(buf___0, n);
  }
#line 1907
  if (! b) {
    {
#line 1908
    yy_fatal_error___1("bad buffer in smap_scan_bytes()");
    }
  }
#line 1913
  b->yy_is_our_buffer = 1;
#line 1915
  return (b);
}
}
#line 1922 "sheets-map.c"
static void yy_fatal_error___1(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1924
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1925
  exit(2);
  }
}
}
#line 1950 "sheets-map.c"
int smapget_lineno(void) 
{ 


  {
#line 1953
  return (smaplineno);
}
}
#line 1959 "sheets-map.c"
FILE *smapget_in(void) 
{ 


  {
#line 1961
  return (smapin);
}
}
#line 1967 "sheets-map.c"
FILE *smapget_out(void) 
{ 


  {
#line 1969
  return (smapout);
}
}
#line 1975 "sheets-map.c"
int smapget_leng(void) 
{ 


  {
#line 1977
  return (smapleng);
}
}
#line 1984 "sheets-map.c"
char *smapget_text(void) 
{ 


  {
#line 1986
  return (smaptext);
}
}
#line 1993 "sheets-map.c"
void smapset_lineno(int line_number ) 
{ 


  {
#line 1996
  smaplineno = line_number;
#line 1997
  return;
}
}
#line 2005 "sheets-map.c"
void smapset_in(FILE *in_str ) 
{ 


  {
#line 2007
  smapin = in_str;
#line 2008
  return;
}
}
#line 2010 "sheets-map.c"
void smapset_out(FILE *out_str ) 
{ 


  {
#line 2012
  smapout = out_str;
#line 2013
  return;
}
}
#line 2015 "sheets-map.c"
int smapget_debug(void) 
{ 


  {
#line 2017
  return (smap_flex_debug);
}
}
#line 2020 "sheets-map.c"
void smapset_debug(int bdebug ) 
{ 


  {
#line 2022
  smap_flex_debug = bdebug;
#line 2023
  return;
}
}
#line 2025 "sheets-map.c"
static int yy_init_globals___1(void) 
{ 


  {
#line 2032
  smaplineno = 1;
#line 2034
  yy_buffer_stack___1 = (YY_BUFFER_STATE *)0;
#line 2035
  yy_buffer_stack_top___1 = (size_t )0;
#line 2036
  yy_buffer_stack_max___1 = (size_t )0;
#line 2037
  yy_c_buf_p___1 = (char *)0;
#line 2038
  yy_init___1 = 0;
#line 2039
  yy_start___1 = 0;
#line 2046
  smapin = (FILE *)0;
#line 2047
  smapout = (FILE *)0;
#line 2053
  return (0);
}
}
#line 2057 "sheets-map.c"
int smaplex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2061
    if (yy_buffer_stack___1) {
#line 2061
      tmp___0 = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
    } else {
#line 2061
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2061
    if (! tmp___0) {
#line 2061
      goto while_break;
    }
#line 2062
    if (yy_buffer_stack___1) {
#line 2062
      tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
    } else {
#line 2062
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2062
    smap_delete_buffer(tmp);
#line 2063
    *(yy_buffer_stack___1 + yy_buffer_stack_top___1) = (YY_BUFFER_STATE )((void *)0);
#line 2064
    smappop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2068
  smapfree((void *)yy_buffer_stack___1);
#line 2069
  yy_buffer_stack___1 = (YY_BUFFER_STATE *)((void *)0);
#line 2073
  yy_init_globals___1();
  }
#line 2075
  return (0);
}
}
#line 2102 "sheets-map.c"
void *smapalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2104
  tmp = malloc(size);
  }
#line 2104
  return (tmp);
}
}
#line 2107 "sheets-map.c"
void *smaprealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2116
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2116
  return (tmp);
}
}
#line 2119 "sheets-map.c"
void smapfree(void *ptr ) 
{ 


  {
  {
#line 2121
  free((void *)((char *)ptr));
  }
#line 2122
  return;
}
}
#line 208 "sheets-map.l"
static void yy_include_push(char *file ) 
{ 
  char *tmp ;
  int tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 211
  if (include_stack_ptr___0 >= 10) {
    {
#line 212
    tmp = gettext("too many includes");
#line 212
    error(1, 0, (char const   *)tmp);
    }
  }
#line 214
  if (yy_buffer_stack___1) {
#line 214
    include_stack___0[include_stack_ptr___0] = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 214
    include_stack___0[include_stack_ptr___0] = (YY_BUFFER_STATE )((void *)0);
  }
#line 215
  lineno_stack[include_stack_ptr___0] = smaplineno;
#line 216
  tmp___0 = include_stack_ptr___0;
#line 216
  include_stack_ptr___0 ++;
#line 216
  filename_stack___0[tmp___0] = yyfilename;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if ((unsigned int )(1 << 6) & msg_verbosity) {
      {
#line 218
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: includes %s\n",
              yyfilename, smaplineno, file);
      }
    }
#line 218
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 221
  yyfilename = file;
#line 222
  smapin = xrfopen((char const   *)yyfilename);
#line 224
  tmp___1 = smap_create_buffer(smapin, 16384);
#line 224
  smap_switch_to_buffer(tmp___1);
  }
#line 225
  return;
}
}
#line 229 "sheets-map.l"
static void yy_include_pop(void) 
{ 
  YY_BUFFER_STATE tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 232
  fclose(smapin);
  }
#line 233
  if (yy_buffer_stack___1) {
#line 233
    tmp = *(yy_buffer_stack___1 + yy_buffer_stack_top___1);
  } else {
#line 233
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 233
  smap_delete_buffer(tmp);
#line 234
  yyfilename = filename_stack___0[include_stack_ptr___0];
#line 235
  smaplineno = lineno_stack[include_stack_ptr___0];
#line 236
  smap_switch_to_buffer(include_stack___0[include_stack_ptr___0]);
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if ((unsigned int )(1 << 6) & msg_verbosity) {
      {
#line 237
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Back to file `%s\'.\n",
              yyfilename);
      }
    }
#line 237
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return;
}
}
#line 247 "sheets-map.l"
__inline static void yy_open(char const   *file ) 
{ 


  {
  {
#line 250
  yyfilename = xstrdup(file);
#line 251
  smapin = xrfopen((char const   *)yyfilename);
#line 252
  include_stack_ptr___0 = 0;
  }
#line 253
  return;
}
}
#line 257 "sheets-map.l"
__inline static void yy_close(void) 
{ 


  {
  {
#line 260
  fclose(smapin);
#line 261
  free((void *)yyfilename);
  }
#line 262
  return;
}
}
#line 264 "sheets-map.l"
int smapwrap(void) 
{ 


  {
#line 267
  return (1);
}
}
#line 274 "sheets-map.l"
static int first_time___2  =    1;
#line 271 "sheets-map.l"
void sheets_map_load(char const   *filename ) 
{ 
  token_t token___1 ;
  char *key ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 276
  key = (char *)((void *)0);
#line 278
  if (first_time___2) {
    {
#line 280
    first_time___2 = 0;
#line 281
    _obstack_begin(& string_stack___0, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
    }
  }
  {
#line 284
  yy_open(filename);
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 286
    tmp___3 = smaplex();
#line 286
    token___1 = (token_t )tmp___3;
    }
#line 286
    if (! token___1) {
#line 286
      goto while_break;
    }
    {
#line 290
    if ((unsigned int )token___1 == 10U) {
#line 290
      goto case_10;
    }
#line 294
    if ((unsigned int )token___1 == 11U) {
#line 294
      goto case_11;
    }
#line 301
    if ((unsigned int )token___1 == 12U) {
#line 301
      goto case_12;
    }
#line 288
    goto switch_break;
    case_10: /* CIL Label */ 
#line 291
    key = token_val;
#line 292
    goto switch_break;
    case_11: /* CIL Label */ 
#line 295
    if (! key) {
      {
#line 296
      tmp = quotearg((char const   *)token_val);
#line 296
      tmp___0 = gettext("no key defined for `%s\'");
#line 296
      error_at_line(1, 0, (char const   *)yyfilename, (unsigned int )smaplineno, (char const   *)tmp___0,
                    tmp);
      }
    }
    {
#line 298
    sheets_map_add((char const   *)token_val, 0, insensitive_p, (char const   *)key);
    }
#line 299
    goto switch_break;
    case_12: /* CIL Label */ 
#line 302
    if (! key) {
      {
#line 303
      tmp___1 = quotearg((char const   *)token_val);
#line 303
      tmp___2 = gettext("no key defined for `%s\'");
#line 303
      error_at_line(1, 0, (char const   *)yyfilename, (unsigned int )smaplineno, (char const   *)tmp___2,
                    tmp___1);
      }
    }
    {
#line 305
    sheets_map_add((char const   *)token_val, 1, insensitive_p, (char const   *)key);
    }
#line 306
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  yy_close();
  }
#line 311
  return;
}
}
#line 155 "lexps.c"
int psleng  ;
#line 157
FILE *psin ;
#line 157
FILE *psout ;
#line 257 "lexps.c"
static size_t yy_buffer_stack_top___2  =    (size_t )0;
#line 258 "lexps.c"
static size_t yy_buffer_stack_max___2  =    (size_t )0;
#line 259 "lexps.c"
static YY_BUFFER_STATE *yy_buffer_stack___2  =    (YY_BUFFER_STATE *)0;
#line 277 "lexps.c"
static char yy_hold_char___2  ;
#line 278 "lexps.c"
static int yy_n_chars___2  ;
#line 282 "lexps.c"
static char *yy_c_buf_p___2  =    (char *)0;
#line 283 "lexps.c"
static int yy_init___2  =    0;
#line 284 "lexps.c"
static int yy_start___2  =    0;
#line 289 "lexps.c"
static int yy_did_buffer_switch_on_eof___2  ;
#line 291
void psrestart(FILE *input_file ) ;
#line 292
void ps_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 293
YY_BUFFER_STATE ps_create_buffer(FILE *file , int size ) ;
#line 294
void ps_delete_buffer(YY_BUFFER_STATE b ) ;
#line 295
void ps_flush_buffer(YY_BUFFER_STATE b ) ;
#line 296
void pspush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 297
void pspop_buffer_state(void) ;
#line 299
static void psensure_buffer_stack(void) ;
#line 300
static void ps_load_buffer_state(void) ;
#line 301
static void ps_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 305
YY_BUFFER_STATE ps_scan_buffer(char *base , yy_size_t size ) ;
#line 306
YY_BUFFER_STATE ps_scan_string(char const   *yystr ) ;
#line 307
YY_BUFFER_STATE ps_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 309
void *psalloc(yy_size_t size ) ;
#line 310
void *psrealloc(void *ptr , yy_size_t size ) ;
#line 311
void psfree(void *ptr ) ;
#line 341 "lexps.c"
FILE *psin  =    (FILE *)0;
#line 341 "lexps.c"
FILE *psout  =    (FILE *)0;
#line 345
int pslineno ;
#line 347 "lexps.c"
int pslineno  =    1;
#line 349 "lexps.c"
char *pstext  ;
#line 352
static yy_state_type yy_get_previous_state___2(void) ;
#line 353
static yy_state_type yy_try_NUL_trans___2(yy_state_type yy_current_state ) ;
#line 354
static int yy_get_next_buffer___2(void) ;
#line 355
static void yy_fatal_error___2(char const   *msg ) ;
#line 376 "lexps.c"
static flex_int16_t const   yy_accept___2[26]  = 
#line 376
  {      (flex_int16_t const   )0,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )3,      (flex_int16_t const   )5,      (flex_int16_t const   )2,      (flex_int16_t const   )4, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )2,      (flex_int16_t const   )2, 
        (flex_int16_t const   )3,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2, 
        (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2, 
        (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )2, 
        (flex_int16_t const   )1,      (flex_int16_t const   )0};
#line 383 "lexps.c"
static flex_int32_t const   yy_ec___2[256]  = 
#line 383
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )5, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )8,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )9,      (flex_int32_t const   )1, 
        (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 415 "lexps.c"
static flex_int32_t const   yy_meta___2[13]  = 
#line 415
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1};
#line 421 "lexps.c"
static flex_int16_t const   yy_base___2[31]  = 
#line 421
  {      (flex_int16_t const   )0,      (flex_int16_t const   )25,      (flex_int16_t const   )0,      (flex_int16_t const   )24, 
        (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )0,      (flex_int16_t const   )28, 
        (flex_int16_t const   )20,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )18, 
        (flex_int16_t const   )0,      (flex_int16_t const   )15,      (flex_int16_t const   )13,      (flex_int16_t const   )11, 
        (flex_int16_t const   )9,      (flex_int16_t const   )12,      (flex_int16_t const   )10,      (flex_int16_t const   )4, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )10,      (flex_int16_t const   )9, 
        (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )3,      (flex_int16_t const   )5, 
        (flex_int16_t const   )9,      (flex_int16_t const   )0,      (flex_int16_t const   )7};
#line 428 "lexps.c"
static flex_int16_t const   yy_def___2[31]  = 
#line 428
  {      (flex_int16_t const   )0,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )25,      (flex_int16_t const   )28,      (flex_int16_t const   )25, 
        (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )28,      (flex_int16_t const   )28, 
        (flex_int16_t const   )29,      (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )28, 
        (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )28, 
        (flex_int16_t const   )28,      (flex_int16_t const   )28,      (flex_int16_t const   )30,      (flex_int16_t const   )30, 
        (flex_int16_t const   )25,      (flex_int16_t const   )0,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25};
#line 435 "lexps.c"
static flex_int16_t const   yy_nxt___2[41]  = 
#line 435
  {      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )6,      (flex_int16_t const   )6,      (flex_int16_t const   )9,      (flex_int16_t const   )9, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )10,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )22,      (flex_int16_t const   )21,      (flex_int16_t const   )20, 
        (flex_int16_t const   )19,      (flex_int16_t const   )18,      (flex_int16_t const   )17,      (flex_int16_t const   )16, 
        (flex_int16_t const   )15,      (flex_int16_t const   )14,      (flex_int16_t const   )13,      (flex_int16_t const   )11, 
        (flex_int16_t const   )25,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )7, 
        (flex_int16_t const   )5,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25};
#line 443 "lexps.c"
static flex_int16_t const   yy_chk___2[41]  = 
#line 443
  {      (flex_int16_t const   )0,      (flex_int16_t const   )29,      (flex_int16_t const   )2,      (flex_int16_t const   )2, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )30,      (flex_int16_t const   )30,      (flex_int16_t const   )28,      (flex_int16_t const   )23, 
        (flex_int16_t const   )22,      (flex_int16_t const   )21,      (flex_int16_t const   )20,      (flex_int16_t const   )19, 
        (flex_int16_t const   )18,      (flex_int16_t const   )17,      (flex_int16_t const   )16,      (flex_int16_t const   )15, 
        (flex_int16_t const   )14,      (flex_int16_t const   )13,      (flex_int16_t const   )11,      (flex_int16_t const   )8, 
        (flex_int16_t const   )5,      (flex_int16_t const   )4,      (flex_int16_t const   )3,      (flex_int16_t const   )1, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25};
#line 451 "lexps.c"
static yy_state_type yy_last_accepting_state___2  ;
#line 452 "lexps.c"
static char *yy_last_accepting_cpos___2  ;
#line 454
int ps_flex_debug ;
#line 455 "lexps.c"
int ps_flex_debug  =    0;
#line 61 "/home/ysko/Works/test-src/a2ps-4.14/src/main.h"
struct a2ps_job *job ;
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/src/lexps.h"
void pslex_dump(FILE *stream , char const   *filename ) ;
#line 29 "lexps.l"
int pslex(void) ;
#line 517 "lexps.c"
static int yy_init_globals___2(void) ;
#line 527
int pswrap(void) ;
#line 651 "lexps.c"
int pslex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;

  {
#line 662
  if (! yy_init___2) {
#line 664
    yy_init___2 = 1;
#line 670
    if (! yy_start___2) {
#line 671
      yy_start___2 = 1;
    }
#line 673
    if (! psin) {
#line 674
      psin = stdin;
    }
#line 676
    if (! psout) {
#line 677
      psout = stdout;
    }
#line 679
    if (yy_buffer_stack___2) {
#line 679
      tmp = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
    } else {
#line 679
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 679
    if (! tmp) {
      {
#line 680
      psensure_buffer_stack();
#line 681
      *(yy_buffer_stack___2 + yy_buffer_stack_top___2) = ps_create_buffer(psin, 16384);
      }
    }
    {
#line 685
    ps_load_buffer_state();
    }
  }
  {
#line 688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    yy_cp = yy_c_buf_p___2;
#line 693
    *yy_cp = yy_hold_char___2;
#line 698
    yy_bp = yy_cp;
#line 700
    yy_current_state = yy_start___2;
#line 701
    yy_current_state += (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_at_bol;
    yy_match: 
    {
#line 703
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 705
      yy_c = (YY_CHAR )yy_ec___2[(unsigned int )((unsigned char )*yy_cp)];
#line 706
      if (yy_accept___2[yy_current_state]) {
#line 708
        yy_last_accepting_state___2 = yy_current_state;
#line 709
        yy_last_accepting_cpos___2 = yy_cp;
      }
      {
#line 711
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 711
        if (! ((int const   )yy_chk___2[(int const   )yy_base___2[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 711
          goto while_break___1;
        }
#line 713
        yy_current_state = (int )yy_def___2[yy_current_state];
#line 714
        if (yy_current_state >= 26) {
#line 715
          yy_c = (YY_CHAR )yy_meta___2[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 717
      yy_current_state = (yy_state_type )yy_nxt___2[(unsigned int )yy_base___2[yy_current_state] + (unsigned int )yy_c];
#line 718
      yy_cp ++;
#line 703
      if (! ((int const   )yy_base___2[yy_current_state] != 28)) {
#line 703
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 723
    yy_act = (int )yy_accept___2[yy_current_state];
#line 724
    if (yy_act == 0) {
#line 726
      yy_cp = yy_last_accepting_cpos___2;
#line 727
      yy_current_state = yy_last_accepting_state___2;
#line 728
      yy_act = (int )yy_accept___2[yy_current_state];
    }
#line 731
    pstext = yy_bp;
#line 731
    psleng = (int )((size_t )(yy_cp - yy_bp));
#line 731
    yy_hold_char___2 = *yy_cp;
#line 731
    *yy_cp = (char )'\000';
#line 731
    yy_c_buf_p___2 = yy_cp;
    do_action: 
    {
#line 737
    if (yy_act == 0) {
#line 737
      goto case_0;
    }
#line 744
    if (yy_act == 1) {
#line 744
      goto case_1;
    }
#line 50
    if (yy_act == 2) {
#line 50 "lexps.l"
      goto case_2;
    }
#line 53
    if (yy_act == 3) {
#line 53
      goto case_3;
    }
#line 56
    if (yy_act == 4) {
#line 56
      goto case_4;
    }
#line 773
    if (yy_act == 7) {
#line 773 "lexps.c"
      goto case_7;
    }
#line 773
    if (yy_act == 6) {
#line 773
      goto case_7;
    }
#line 776
    if (yy_act == 5) {
#line 776
      goto case_5;
    }
#line 898
    goto switch_default;
    case_0: /* CIL Label */ 
#line 739
    *yy_cp = yy_hold_char___2;
#line 740
    yy_cp = yy_last_accepting_cpos___2;
#line 741
    yy_current_state = yy_last_accepting_state___2;
#line 742
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 746
    if (psleng > 0) {
#line 746
      (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_at_bol = (int )*(pstext + (psleng - 1)) == 10;
    }
    {
#line 45 "lexps.l"
    fwrite((void const   */* __restrict  */)pstext, (size_t )psleng, (size_t )1, (FILE */* __restrict  */)psout);
#line 46
    pagedevice_dump(psout, job);
#line 47
    yy_start___2 = 3;
    }
#line 49
    goto switch_break;
    case_2: /* CIL Label */ 
#line 51
    if (psleng > 0) {
#line 51
      (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_at_bol = (int )*(pstext + (psleng - 1)) == 10;
    }
    {
#line 50
    fwrite((void const   */* __restrict  */)pstext, (size_t )psleng, (size_t )1, (FILE */* __restrict  */)psout);
    }
#line 51
    goto switch_break;
    case_3: /* CIL Label */ 
#line 54
    if (psleng > 0) {
#line 54
      (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_at_bol = (int )*(pstext + (psleng - 1)) == 10;
    }
    {
#line 53
    fwrite((void const   */* __restrict  */)pstext, (size_t )psleng, (size_t )1, (FILE */* __restrict  */)psout);
    }
#line 54
    goto switch_break;
    case_4: /* CIL Label */ 
#line 57
    if (psleng > 0) {
#line 57
      (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_at_bol = (int )*(pstext + (psleng - 1)) == 10;
    }
    {
#line 55
    fwrite((void const   */* __restrict  */)pstext, (size_t )psleng, (size_t )1, (FILE */* __restrict  */)psout);
    }
#line 56
    goto switch_break;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 774 "lexps.c"
    return (0);
    case_5: /* CIL Label */ 
#line 779
    yy_amount_of_matched_text = (int )(yy_cp - pstext) - 1;
#line 782
    *yy_cp = yy_hold_char___2;
#line 785
    if ((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_buffer_status == 0) {
#line 796
      yy_n_chars___2 = (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_n_chars;
#line 797
      (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_input_file = psin;
#line 798
      (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_buffer_status = 1;
    }
#line 808
    if ((unsigned long )yy_c_buf_p___2 <= (unsigned long )((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_ch_buf + yy_n_chars___2)) {
      {
#line 812
      yy_c_buf_p___2 = pstext + yy_amount_of_matched_text;
#line 814
      yy_current_state = yy_get_previous_state___2();
#line 825
      yy_next_state = yy_try_NUL_trans___2(yy_current_state);
#line 827
      yy_bp = pstext + 0;
      }
#line 829
      if (yy_next_state) {
#line 832
        yy_c_buf_p___2 ++;
#line 832
        yy_cp = yy_c_buf_p___2;
#line 833
        yy_current_state = yy_next_state;
#line 834
        goto yy_match;
      } else {
#line 839
        yy_cp = yy_c_buf_p___2;
#line 840
        goto yy_find_action;
      }
    } else {
      {
#line 844
      tmp___0 = yy_get_next_buffer___2();
      }
      {
#line 846
      if (tmp___0 == 1) {
#line 846
        goto case_1___0;
      }
#line 875
      if (tmp___0 == 0) {
#line 875
        goto case_0___0;
      }
#line 885
      if (tmp___0 == 2) {
#line 885
        goto case_2___0;
      }
#line 844
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 848
      yy_did_buffer_switch_on_eof___2 = 0;
#line 850
      tmp___1 = pswrap();
      }
#line 850
      if (tmp___1) {
#line 861
        yy_c_buf_p___2 = pstext + 0;
#line 863
        yy_act = (5 + (yy_start___2 - 1) / 2) + 1;
#line 864
        goto do_action;
      } else
#line 869
      if (! yy_did_buffer_switch_on_eof___2) {
        {
#line 870
        psrestart(psin);
        }
      }
#line 872
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 876
      yy_c_buf_p___2 = pstext + yy_amount_of_matched_text;
#line 879
      yy_current_state = yy_get_previous_state___2();
#line 881
      yy_cp = yy_c_buf_p___2;
#line 882
      yy_bp = pstext + 0;
      }
#line 883
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 886
      yy_c_buf_p___2 = (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_ch_buf + yy_n_chars___2;
#line 889
      yy_current_state = yy_get_previous_state___2();
#line 891
      yy_cp = yy_c_buf_p___2;
#line 892
      yy_bp = pstext + 0;
      }
#line 893
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 895
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 899
    yy_fatal_error___2("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 912 "lexps.c"
static int yy_get_next_buffer___2(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 914
  dest = (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_ch_buf;
#line 915
  source = pstext;
#line 919
  if ((unsigned long )yy_c_buf_p___2 > (unsigned long )((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_ch_buf + (yy_n_chars___2 + 1))) {
    {
#line 920
    yy_fatal_error___2("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 923
  if ((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_fill_buffer == 0) {
#line 925
    if (yy_c_buf_p___2 - pstext == 1L) {
#line 930
      return (1);
    } else {
#line 938
      return (2);
    }
  }
#line 945
  number_to_move = (int )(yy_c_buf_p___2 - pstext) - 1;
#line 947
  i = 0;
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
#line 947
    if (! (i < number_to_move)) {
#line 947
      goto while_break;
    }
#line 948
    tmp = dest;
#line 948
    dest ++;
#line 948
    tmp___0 = source;
#line 948
    source ++;
#line 948
    *tmp = *tmp___0;
#line 947
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 950
  if ((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_buffer_status == 2) {
#line 954
    yy_n_chars___2 = 0;
#line 954
    (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_n_chars = yy_n_chars___2;
  } else {
#line 958
    num_to_read = (int )(((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 961
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 961
      if (! (num_to_read <= 0)) {
#line 961
        goto while_break___0;
      }
#line 965
      if (yy_buffer_stack___2) {
#line 965
        tmp___1 = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
      } else {
#line 965
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 965
      b = tmp___1;
#line 967
      yy_c_buf_p_offset = (int )(yy_c_buf_p___2 - b->yy_ch_buf);
#line 970
      if (b->yy_is_our_buffer) {
#line 972
        new_size = (int )(b->yy_buf_size * 2U);
#line 974
        if (new_size <= 0) {
#line 975
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 977
          b->yy_buf_size *= 2U;
        }
        {
#line 979
        tmp___2 = psrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 979
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 985
        b->yy_ch_buf = (char *)0;
      }
#line 987
      if (! b->yy_ch_buf) {
        {
#line 988
        yy_fatal_error___2("fatal error - scanner input buffer overflow");
        }
      }
#line 991
      yy_c_buf_p___2 = b->yy_ch_buf + yy_c_buf_p_offset;
#line 993
      num_to_read = (int )(((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 998
    if (num_to_read > 8192) {
#line 999
      num_to_read = 8192;
    }
#line 1002
    if ((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_is_interactive) {
#line 1002
      c = '*';
#line 1002
      n = (size_t )0;
      {
#line 1002
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1002
        if (n < (size_t )num_to_read) {
          {
#line 1002
          c = _IO_getc(psin);
          }
#line 1002
          if (c != -1) {
#line 1002
            if (! (c != 10)) {
#line 1002
              goto while_break___1;
            }
          } else {
#line 1002
            goto while_break___1;
          }
        } else {
#line 1002
          goto while_break___1;
        }
#line 1002
        *(((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1002
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1002
      if (c == 10) {
#line 1002
        tmp___3 = n;
#line 1002
        n ++;
#line 1002
        *(((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1002
      if (c == -1) {
        {
#line 1002
        tmp___4 = ferror(psin);
        }
#line 1002
        if (tmp___4) {
          {
#line 1002
          yy_fatal_error___2("input in flex scanner failed");
          }
        }
      }
#line 1002
      yy_n_chars___2 = (int )n;
    } else {
      {
#line 1002
      tmp___5 = __errno_location();
#line 1002
      *tmp___5 = 0;
      }
      {
#line 1002
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1002
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)psin);
#line 1002
        yy_n_chars___2 = (int )tmp___8;
        }
#line 1002
        if (yy_n_chars___2 == 0) {
          {
#line 1002
          tmp___9 = ferror(psin);
          }
#line 1002
          if (! tmp___9) {
#line 1002
            goto while_break___2;
          }
        } else {
#line 1002
          goto while_break___2;
        }
        {
#line 1002
        tmp___6 = __errno_location();
        }
#line 1002
        if (*tmp___6 != 4) {
          {
#line 1002
          yy_fatal_error___2("input in flex scanner failed");
          }
#line 1002
          goto while_break___2;
        }
        {
#line 1002
        tmp___7 = __errno_location();
#line 1002
        *tmp___7 = 0;
#line 1002
        clearerr(psin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1005
    (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_n_chars = yy_n_chars___2;
  }
#line 1008
  if (yy_n_chars___2 == 0) {
#line 1010
    if (number_to_move == 0) {
      {
#line 1012
      ret_val = 1;
#line 1013
      psrestart(psin);
      }
    } else {
#line 1018
      ret_val = 2;
#line 1019
      (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_buffer_status = 2;
    }
  } else {
#line 1025
    ret_val = 0;
  }
#line 1027
  yy_n_chars___2 += number_to_move;
#line 1028
  *((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_ch_buf + yy_n_chars___2) = (char)0;
#line 1029
  *((*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_ch_buf + (yy_n_chars___2 + 1)) = (char)0;
#line 1031
  pstext = (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_ch_buf + 0;
#line 1033
  return (ret_val);
}
}
#line 1038 "lexps.c"
static yy_state_type yy_get_previous_state___2(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1043
  yy_current_state = yy_start___2;
#line 1044
  yy_current_state += (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_at_bol;
#line 1046
  yy_cp = pstext + 0;
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1046
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p___2)) {
#line 1046
      goto while_break;
    }
#line 1048
    if (*yy_cp) {
#line 1048
      tmp = yy_ec___2[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1048
      tmp = (flex_int32_t const   )1;
    }
#line 1048
    yy_c = (YY_CHAR )tmp;
#line 1049
    if (yy_accept___2[yy_current_state]) {
#line 1051
      yy_last_accepting_state___2 = yy_current_state;
#line 1052
      yy_last_accepting_cpos___2 = yy_cp;
    }
    {
#line 1054
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1054
      if (! ((int const   )yy_chk___2[(int const   )yy_base___2[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1054
        goto while_break___0;
      }
#line 1056
      yy_current_state = (int )yy_def___2[yy_current_state];
#line 1057
      if (yy_current_state >= 26) {
#line 1058
        yy_c = (YY_CHAR )yy_meta___2[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1060
    yy_current_state = (yy_state_type )yy_nxt___2[(unsigned int )yy_base___2[yy_current_state] + (unsigned int )yy_c];
#line 1046
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1063
  return (yy_current_state);
}
}
#line 1071 "lexps.c"
static yy_state_type yy_try_NUL_trans___2(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1074
  yy_cp = yy_c_buf_p___2;
#line 1076
  yy_c = (YY_CHAR )1;
#line 1077
  if (yy_accept___2[yy_current_state]) {
#line 1079
    yy_last_accepting_state___2 = yy_current_state;
#line 1080
    yy_last_accepting_cpos___2 = yy_cp;
  }
  {
#line 1082
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1082
    if (! ((int const   )yy_chk___2[(int const   )yy_base___2[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1082
      goto while_break;
    }
#line 1084
    yy_current_state = (int )yy_def___2[yy_current_state];
#line 1085
    if (yy_current_state >= 26) {
#line 1086
      yy_c = (YY_CHAR )yy_meta___2[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1088
  yy_current_state = (yy_state_type )yy_nxt___2[(unsigned int )yy_base___2[yy_current_state] + (unsigned int )yy_c];
#line 1089
  yy_is_jam = yy_current_state == 25;
#line 1091
  if (yy_is_jam) {
#line 1091
    tmp = 0;
  } else {
#line 1091
    tmp = yy_current_state;
  }
#line 1091
  return (tmp);
}
}
#line 1212 "lexps.c"
void psrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1215
  if (yy_buffer_stack___2) {
#line 1215
    tmp = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1215
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1215
  if (! tmp) {
    {
#line 1216
    psensure_buffer_stack();
#line 1217
    *(yy_buffer_stack___2 + yy_buffer_stack_top___2) = ps_create_buffer(psin, 16384);
    }
  }
#line 1221
  if (yy_buffer_stack___2) {
#line 1221
    tmp___0 = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1221
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1221
  ps_init_buffer(tmp___0, input_file);
#line 1222
  ps_load_buffer_state();
  }
#line 1223
  return;
}
}
#line 1229 "lexps.c"
void ps_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1237
  psensure_buffer_stack();
  }
#line 1238
  if (yy_buffer_stack___2) {
#line 1238
    tmp = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1238
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1238
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1239
    return;
  }
#line 1241
  if (yy_buffer_stack___2) {
#line 1241
    tmp___0 = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1241
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1241
  if (tmp___0) {
#line 1244
    *yy_c_buf_p___2 = yy_hold_char___2;
#line 1245
    (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_buf_pos = yy_c_buf_p___2;
#line 1246
    (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_n_chars = yy_n_chars___2;
  }
  {
#line 1249
  *(yy_buffer_stack___2 + yy_buffer_stack_top___2) = new_buffer;
#line 1250
  ps_load_buffer_state();
#line 1257
  yy_did_buffer_switch_on_eof___2 = 1;
  }
#line 1258
  return;
}
}
#line 1260 "lexps.c"
static void ps_load_buffer_state(void) 
{ 


  {
#line 1262
  yy_n_chars___2 = (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_n_chars;
#line 1263
  yy_c_buf_p___2 = (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_buf_pos;
#line 1263
  pstext = yy_c_buf_p___2;
#line 1264
  psin = (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_input_file;
#line 1265
  yy_hold_char___2 = *yy_c_buf_p___2;
#line 1266
  return;
}
}
#line 1274 "lexps.c"
YY_BUFFER_STATE ps_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1278
  tmp = psalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1278
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1279
  if (! b) {
    {
#line 1280
    yy_fatal_error___2("out of dynamic memory in ps_create_buffer()");
    }
  }
  {
#line 1282
  b->yy_buf_size = (yy_size_t )size;
#line 1287
  tmp___0 = psalloc(b->yy_buf_size + 2U);
#line 1287
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1288
  if (! b->yy_ch_buf) {
    {
#line 1289
    yy_fatal_error___2("out of dynamic memory in ps_create_buffer()");
    }
  }
  {
#line 1291
  b->yy_is_our_buffer = 1;
#line 1293
  ps_init_buffer(b, file);
  }
#line 1295
  return (b);
}
}
#line 1302 "lexps.c"
void ps_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1305
  if (! b) {
#line 1306
    return;
  }
#line 1308
  if (yy_buffer_stack___2) {
#line 1308
    tmp = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1308
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1308
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1309
    *(yy_buffer_stack___2 + yy_buffer_stack_top___2) = (YY_BUFFER_STATE )0;
  }
#line 1311
  if (b->yy_is_our_buffer) {
    {
#line 1312
    psfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1314
  psfree((void *)b);
  }
#line 1315
  return;
}
}
#line 1325 "lexps.c"
static void ps_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1328
  tmp = __errno_location();
#line 1328
  oerrno = *tmp;
#line 1330
  ps_flush_buffer(b);
#line 1332
  b->yy_input_file = file;
#line 1333
  b->yy_fill_buffer = 1;
  }
#line 1339
  if (yy_buffer_stack___2) {
#line 1339
    tmp___0 = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1339
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1339
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1340
    b->yy_bs_lineno = 1;
#line 1341
    b->yy_bs_column = 0;
  }
#line 1344
  if (file) {
    {
#line 1344
    tmp___1 = fileno(file);
#line 1344
    tmp___2 = isatty(tmp___1);
#line 1344
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1344
    b->yy_is_interactive = 0;
  }
  {
#line 1346
  tmp___3 = __errno_location();
#line 1346
  *tmp___3 = oerrno;
  }
#line 1347
  return;
}
}
#line 1353 "lexps.c"
void ps_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1355
  if (! b) {
#line 1356
    return;
  }
#line 1358
  b->yy_n_chars = 0;
#line 1364
  *(b->yy_ch_buf + 0) = (char)0;
#line 1365
  *(b->yy_ch_buf + 1) = (char)0;
#line 1367
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1369
  b->yy_at_bol = 1;
#line 1370
  b->yy_buffer_status = 0;
#line 1372
  if (yy_buffer_stack___2) {
#line 1372
    tmp = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1372
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1372
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1373
    ps_load_buffer_state();
    }
  }
#line 1374
  return;
}
}
#line 1382 "lexps.c"
void pspush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1384
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1385
    return;
  }
  {
#line 1387
  psensure_buffer_stack();
  }
#line 1390
  if (yy_buffer_stack___2) {
#line 1390
    tmp = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1390
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1390
  if (tmp) {
#line 1393
    *yy_c_buf_p___2 = yy_hold_char___2;
#line 1394
    (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_buf_pos = yy_c_buf_p___2;
#line 1395
    (*(yy_buffer_stack___2 + yy_buffer_stack_top___2))->yy_n_chars = yy_n_chars___2;
  }
#line 1399
  if (yy_buffer_stack___2) {
#line 1399
    tmp___0 = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1399
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1399
  if (tmp___0) {
#line 1400
    yy_buffer_stack_top___2 ++;
  }
  {
#line 1401
  *(yy_buffer_stack___2 + yy_buffer_stack_top___2) = new_buffer;
#line 1404
  ps_load_buffer_state();
#line 1405
  yy_did_buffer_switch_on_eof___2 = 1;
  }
#line 1406
  return;
}
}
#line 1412 "lexps.c"
void pspop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1414
  if (yy_buffer_stack___2) {
#line 1414
    tmp = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1414
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1414
  if (! tmp) {
#line 1415
    return;
  }
#line 1417
  if (yy_buffer_stack___2) {
#line 1417
    tmp___0 = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1417
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1417
  ps_delete_buffer(tmp___0);
#line 1418
  *(yy_buffer_stack___2 + yy_buffer_stack_top___2) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1419
  if (yy_buffer_stack_top___2 > 0U) {
#line 1420
    yy_buffer_stack_top___2 --;
  }
#line 1422
  if (yy_buffer_stack___2) {
#line 1422
    tmp___1 = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
  } else {
#line 1422
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1422
  if (tmp___1) {
    {
#line 1423
    ps_load_buffer_state();
#line 1424
    yy_did_buffer_switch_on_eof___2 = 1;
    }
  }
#line 1426
  return;
}
}
#line 1431 "lexps.c"
static void psensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1435
  if (! yy_buffer_stack___2) {
    {
#line 1441
    num_to_alloc = 1;
#line 1442
    tmp = psalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1442
    yy_buffer_stack___2 = (struct yy_buffer_state **)tmp;
#line 1446
    memset((void *)yy_buffer_stack___2, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1448
    yy_buffer_stack_max___2 = (size_t )num_to_alloc;
#line 1449
    yy_buffer_stack_top___2 = (size_t )0;
    }
#line 1450
    return;
  }
#line 1453
  if (yy_buffer_stack_top___2 >= yy_buffer_stack_max___2 - 1U) {
    {
#line 1456
    grow_size = 8;
#line 1458
    num_to_alloc = (int )(yy_buffer_stack_max___2 + (size_t )grow_size);
#line 1459
    tmp___0 = psrealloc((void *)yy_buffer_stack___2, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1459
    yy_buffer_stack___2 = (struct yy_buffer_state **)tmp___0;
#line 1465
    memset((void *)(yy_buffer_stack___2 + yy_buffer_stack_max___2), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 1466
    yy_buffer_stack_max___2 = (size_t )num_to_alloc;
    }
  }
#line 1468
  return;
}
}
#line 1476 "lexps.c"
YY_BUFFER_STATE ps_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 1480
  if (size < 2U) {
#line 1484
    return ((YY_BUFFER_STATE )0);
  } else
#line 1480
  if ((int )*(base + (size - 2U)) != 0) {
#line 1484
    return ((YY_BUFFER_STATE )0);
  } else
#line 1480
  if ((int )*(base + (size - 1U)) != 0) {
#line 1484
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1486
  tmp = psalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1486
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1487
  if (! b) {
    {
#line 1488
    yy_fatal_error___2("out of dynamic memory in ps_scan_buffer()");
    }
  }
  {
#line 1490
  b->yy_buf_size = size - 2U;
#line 1491
  tmp___0 = base;
#line 1491
  b->yy_ch_buf = tmp___0;
#line 1491
  b->yy_buf_pos = tmp___0;
#line 1492
  b->yy_is_our_buffer = 0;
#line 1493
  b->yy_input_file = (FILE *)0;
#line 1494
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1495
  b->yy_is_interactive = 0;
#line 1496
  b->yy_at_bol = 1;
#line 1497
  b->yy_fill_buffer = 0;
#line 1498
  b->yy_buffer_status = 0;
#line 1500
  ps_switch_to_buffer(b);
  }
#line 1502
  return (b);
}
}
#line 1513 "lexps.c"
YY_BUFFER_STATE ps_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1516
  tmp = strlen(yystr);
#line 1516
  tmp___0 = ps_scan_bytes(yystr, (int )tmp);
  }
#line 1516
  return (tmp___0);
}
}
#line 1526 "lexps.c"
YY_BUFFER_STATE ps_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1534
  n = (yy_size_t )(_yybytes_len + 2);
#line 1535
  tmp = psalloc(n);
#line 1535
  buf___0 = (char *)tmp;
  }
#line 1536
  if (! buf___0) {
    {
#line 1537
    yy_fatal_error___2("out of dynamic memory in ps_scan_bytes()");
    }
  }
#line 1539
  i = 0;
  {
#line 1539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1539
    if (! (i < _yybytes_len)) {
#line 1539
      goto while_break;
    }
#line 1540
    *(buf___0 + i) = (char )*(yybytes + i);
#line 1539
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1542
  tmp___0 = (char)0;
#line 1542
  *(buf___0 + (_yybytes_len + 1)) = tmp___0;
#line 1542
  *(buf___0 + _yybytes_len) = tmp___0;
#line 1544
  b = ps_scan_buffer(buf___0, n);
  }
#line 1545
  if (! b) {
    {
#line 1546
    yy_fatal_error___2("bad buffer in ps_scan_bytes()");
    }
  }
#line 1551
  b->yy_is_our_buffer = 1;
#line 1553
  return (b);
}
}
#line 1560 "lexps.c"
static void yy_fatal_error___2(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1562
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1563
  exit(2);
  }
}
}
#line 1588 "lexps.c"
int psget_lineno(void) 
{ 


  {
#line 1591
  return (pslineno);
}
}
#line 1597 "lexps.c"
FILE *psget_in(void) 
{ 


  {
#line 1599
  return (psin);
}
}
#line 1605 "lexps.c"
FILE *psget_out(void) 
{ 


  {
#line 1607
  return (psout);
}
}
#line 1613 "lexps.c"
int psget_leng(void) 
{ 


  {
#line 1615
  return (psleng);
}
}
#line 1622 "lexps.c"
char *psget_text(void) 
{ 


  {
#line 1624
  return (pstext);
}
}
#line 1631 "lexps.c"
void psset_lineno(int line_number ) 
{ 


  {
#line 1634
  pslineno = line_number;
#line 1635
  return;
}
}
#line 1643 "lexps.c"
void psset_in(FILE *in_str ) 
{ 


  {
#line 1645
  psin = in_str;
#line 1646
  return;
}
}
#line 1648 "lexps.c"
void psset_out(FILE *out_str ) 
{ 


  {
#line 1650
  psout = out_str;
#line 1651
  return;
}
}
#line 1653 "lexps.c"
int psget_debug(void) 
{ 


  {
#line 1655
  return (ps_flex_debug);
}
}
#line 1658 "lexps.c"
void psset_debug(int bdebug ) 
{ 


  {
#line 1660
  ps_flex_debug = bdebug;
#line 1661
  return;
}
}
#line 1663 "lexps.c"
static int yy_init_globals___2(void) 
{ 


  {
#line 1669
  yy_buffer_stack___2 = (YY_BUFFER_STATE *)0;
#line 1670
  yy_buffer_stack_top___2 = (size_t )0;
#line 1671
  yy_buffer_stack_max___2 = (size_t )0;
#line 1672
  yy_c_buf_p___2 = (char *)0;
#line 1673
  yy_init___2 = 0;
#line 1674
  yy_start___2 = 0;
#line 1681
  psin = (FILE *)0;
#line 1682
  psout = (FILE *)0;
#line 1688
  return (0);
}
}
#line 1692 "lexps.c"
int pslex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1696
    if (yy_buffer_stack___2) {
#line 1696
      tmp___0 = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
    } else {
#line 1696
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1696
    if (! tmp___0) {
#line 1696
      goto while_break;
    }
#line 1697
    if (yy_buffer_stack___2) {
#line 1697
      tmp = *(yy_buffer_stack___2 + yy_buffer_stack_top___2);
    } else {
#line 1697
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 1697
    ps_delete_buffer(tmp);
#line 1698
    *(yy_buffer_stack___2 + yy_buffer_stack_top___2) = (YY_BUFFER_STATE )((void *)0);
#line 1699
    pspop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1703
  psfree((void *)yy_buffer_stack___2);
#line 1704
  yy_buffer_stack___2 = (YY_BUFFER_STATE *)((void *)0);
#line 1708
  yy_init_globals___2();
  }
#line 1710
  return (0);
}
}
#line 1737 "lexps.c"
void *psalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1739
  tmp = malloc(size);
  }
#line 1739
  return (tmp);
}
}
#line 1742 "lexps.c"
void *psrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1751
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 1751
  return (tmp);
}
}
#line 1754 "lexps.c"
void psfree(void *ptr ) 
{ 


  {
  {
#line 1756
  free((void *)((char *)ptr));
  }
#line 1757
  return;
}
}
#line 58 "lexps.l"
int pswrap(void) 
{ 


  {
#line 61
  return (1);
}
}
#line 67 "lexps.l"
void pslex_dump(FILE *stream , char const   *filename ) 
{ 


  {
  {
#line 70
  psin = xrfopen(filename);
#line 71
  psout = stream;
#line 73
  pslex();
  }
#line 74
  return;
}
}
#line 155 "lexssh.c"
int sshleng  ;
#line 157
FILE *sshin ;
#line 157
FILE *sshout ;
#line 270 "lexssh.c"
static size_t yy_buffer_stack_top___3  =    (size_t )0;
#line 271 "lexssh.c"
static size_t yy_buffer_stack_max___3  =    (size_t )0;
#line 272 "lexssh.c"
static YY_BUFFER_STATE *yy_buffer_stack___3  =    (YY_BUFFER_STATE *)0;
#line 290 "lexssh.c"
static char yy_hold_char___3  ;
#line 291 "lexssh.c"
static int yy_n_chars___3  ;
#line 295 "lexssh.c"
static char *yy_c_buf_p___3  =    (char *)0;
#line 296 "lexssh.c"
static int yy_init___3  =    0;
#line 297 "lexssh.c"
static int yy_start___3  =    0;
#line 302 "lexssh.c"
static int yy_did_buffer_switch_on_eof___3  ;
#line 304
void sshrestart(FILE *input_file ) ;
#line 305
void ssh_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 306
YY_BUFFER_STATE ssh_create_buffer(FILE *file , int size ) ;
#line 307
void ssh_delete_buffer(YY_BUFFER_STATE b ) ;
#line 308
void ssh_flush_buffer(YY_BUFFER_STATE b ) ;
#line 309
void sshpush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 310
void sshpop_buffer_state(void) ;
#line 312
static void sshensure_buffer_stack(void) ;
#line 313
static void ssh_load_buffer_state(void) ;
#line 314
static void ssh_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 318
YY_BUFFER_STATE ssh_scan_buffer(char *base , yy_size_t size ) ;
#line 319
YY_BUFFER_STATE ssh_scan_string(char const   *yystr ) ;
#line 320
YY_BUFFER_STATE ssh_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 322
void *sshalloc(yy_size_t size ) ;
#line 323
void *sshrealloc(void *ptr , yy_size_t size ) ;
#line 324
void sshfree(void *ptr ) ;
#line 354 "lexssh.c"
FILE *sshin  =    (FILE *)0;
#line 354 "lexssh.c"
FILE *sshout  =    (FILE *)0;
#line 358
int sshlineno ;
#line 360 "lexssh.c"
int sshlineno  =    1;
#line 362 "lexssh.c"
char *sshtext  ;
#line 365
static yy_state_type yy_get_previous_state___3(void) ;
#line 366
static yy_state_type yy_try_NUL_trans___3(yy_state_type yy_current_state ) ;
#line 367
static int yy_get_next_buffer___3(void) ;
#line 368
static void yy_fatal_error___3(char const   *msg ) ;
#line 389 "lexssh.c"
static flex_int16_t const   yy_accept___3[901]  = 
#line 389
  {      (flex_int16_t const   )0,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )218, 
        (flex_int16_t const   )185,      (flex_int16_t const   )2,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )1,      (flex_int16_t const   )186,      (flex_int16_t const   )185,      (flex_int16_t const   )4, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )201,      (flex_int16_t const   )200, 
        (flex_int16_t const   )187,      (flex_int16_t const   )217,      (flex_int16_t const   )216,      (flex_int16_t const   )215, 
        (flex_int16_t const   )202,      (flex_int16_t const   )217,      (flex_int16_t const   )185,      (flex_int16_t const   )2, 
        (flex_int16_t const   )1,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )137,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )143,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )152, 
        (flex_int16_t const   )154,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )201,      (flex_int16_t const   )199,      (flex_int16_t const   )188,      (flex_int16_t const   )190, 
        (flex_int16_t const   )191,      (flex_int16_t const   )192,      (flex_int16_t const   )193,      (flex_int16_t const   )194, 
        (flex_int16_t const   )195,      (flex_int16_t const   )196,      (flex_int16_t const   )197,      (flex_int16_t const   )198, 
        (flex_int16_t const   )199,      (flex_int16_t const   )216,      (flex_int16_t const   )214,      (flex_int16_t const   )203, 
        (flex_int16_t const   )205,      (flex_int16_t const   )206,      (flex_int16_t const   )207,      (flex_int16_t const   )208, 
        (flex_int16_t const   )209,      (flex_int16_t const   )210,      (flex_int16_t const   )211,      (flex_int16_t const   )212, 
        (flex_int16_t const   )213,      (flex_int16_t const   )214,      (flex_int16_t const   )91,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )94,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )24,      (flex_int16_t const   )185,      (flex_int16_t const   )95, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )32,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )107,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )50,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )51,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )53,      (flex_int16_t const   )80,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )96,      (flex_int16_t const   )61,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )142, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )149, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )203, 
        (flex_int16_t const   )204,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )175,      (flex_int16_t const   )176,      (flex_int16_t const   )177, 
        (flex_int16_t const   )178,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )11, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )16, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )14, 
        (flex_int16_t const   )33,      (flex_int16_t const   )26,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )28,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )100, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )40,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )101, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )86,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )45, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )81,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )134, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )67, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )87,      (flex_int16_t const   )117, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )43,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )62,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )55, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )64,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )130,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )57,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )119,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )138, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )144,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )188,      (flex_int16_t const   )189, 
        (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )168,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )169,      (flex_int16_t const   )165, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )10, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )17,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )34, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )39,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )116, 
        (flex_int16_t const   )79,      (flex_int16_t const   )185,      (flex_int16_t const   )8,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )46,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )36, 
        (flex_int16_t const   )185,      (flex_int16_t const   )114,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )115,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )63,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )151, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )162,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )146, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )179, 
        (flex_int16_t const   )180,      (flex_int16_t const   )181,      (flex_int16_t const   )182,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )171,      (flex_int16_t const   )172, 
        (flex_int16_t const   )9,      (flex_int16_t const   )12,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )15,      (flex_int16_t const   )19,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )31,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )27,      (flex_int16_t const   )25,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )93,      (flex_int16_t const   )38,      (flex_int16_t const   )109,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )41,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )88,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )44,      (flex_int16_t const   )185,      (flex_int16_t const   )68, 
        (flex_int16_t const   )48,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )131, 
        (flex_int16_t const   )90,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )110,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )60, 
        (flex_int16_t const   )185,      (flex_int16_t const   )98,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )66,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )135,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )56,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )54,      (flex_int16_t const   )82, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )59, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )118,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )157, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )173,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )166,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )20,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )89, 
        (flex_int16_t const   )85,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )6,      (flex_int16_t const   )69,      (flex_int16_t const   )5,      (flex_int16_t const   )185, 
        (flex_int16_t const   )49,      (flex_int16_t const   )126,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )132,      (flex_int16_t const   )108,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )97,      (flex_int16_t const   )185,      (flex_int16_t const   )83,      (flex_int16_t const   )185, 
        (flex_int16_t const   )133,      (flex_int16_t const   )185,      (flex_int16_t const   )136,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )105,      (flex_int16_t const   )185,      (flex_int16_t const   )102, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )47, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )145,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )163,      (flex_int16_t const   )164,      (flex_int16_t const   )147,      (flex_int16_t const   )185, 
        (flex_int16_t const   )183,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )13,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )23,      (flex_int16_t const   )185,      (flex_int16_t const   )122,      (flex_int16_t const   )29, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )42,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )52, 
        (flex_int16_t const   )84,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )76,      (flex_int16_t const   )58, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )139, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )155,      (flex_int16_t const   )185,      (flex_int16_t const   )160,      (flex_int16_t const   )156, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )184, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )70, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )99, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )127,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )106,      (flex_int16_t const   )7,      (flex_int16_t const   )103,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )30,      (flex_int16_t const   )18,      (flex_int16_t const   )185, 
        (flex_int16_t const   )140,      (flex_int16_t const   )141,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )159,      (flex_int16_t const   )158,      (flex_int16_t const   )161, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )124, 
        (flex_int16_t const   )121,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )128,      (flex_int16_t const   )185,      (flex_int16_t const   )78,      (flex_int16_t const   )72, 
        (flex_int16_t const   )75,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )37, 
        (flex_int16_t const   )185,      (flex_int16_t const   )73,      (flex_int16_t const   )35,      (flex_int16_t const   )129, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )150,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )123,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )104,      (flex_int16_t const   )77,      (flex_int16_t const   )65,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )153,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )170, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )71,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )111,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )112,      (flex_int16_t const   )185, 
        (flex_int16_t const   )113,      (flex_int16_t const   )148,      (flex_int16_t const   )174,      (flex_int16_t const   )167, 
        (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185,      (flex_int16_t const   )185, 
        (flex_int16_t const   )120,      (flex_int16_t const   )92,      (flex_int16_t const   )74,      (flex_int16_t const   )125, 
        (flex_int16_t const   )0};
#line 492 "lexssh.c"
static flex_int32_t const   yy_ec___3[256]  = 
#line 492
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )5, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )7,      (flex_int32_t const   )1,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )11,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )9,      (flex_int32_t const   )9,      (flex_int32_t const   )9, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )20,      (flex_int32_t const   )21, 
        (flex_int32_t const   )1,      (flex_int32_t const   )22,      (flex_int32_t const   )1,      (flex_int32_t const   )23, 
        (flex_int32_t const   )24,      (flex_int32_t const   )25,      (flex_int32_t const   )26,      (flex_int32_t const   )27, 
        (flex_int32_t const   )28,      (flex_int32_t const   )1,      (flex_int32_t const   )29,      (flex_int32_t const   )30, 
        (flex_int32_t const   )31,      (flex_int32_t const   )32,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )33,      (flex_int32_t const   )1,      (flex_int32_t const   )34,      (flex_int32_t const   )1, 
        (flex_int32_t const   )35,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )36, 
        (flex_int32_t const   )1,      (flex_int32_t const   )37,      (flex_int32_t const   )38,      (flex_int32_t const   )39, 
        (flex_int32_t const   )40,      (flex_int32_t const   )41,      (flex_int32_t const   )42,      (flex_int32_t const   )43, 
        (flex_int32_t const   )44,      (flex_int32_t const   )45,      (flex_int32_t const   )1,      (flex_int32_t const   )46, 
        (flex_int32_t const   )47,      (flex_int32_t const   )48,      (flex_int32_t const   )49,      (flex_int32_t const   )50, 
        (flex_int32_t const   )51,      (flex_int32_t const   )52,      (flex_int32_t const   )53,      (flex_int32_t const   )54, 
        (flex_int32_t const   )55,      (flex_int32_t const   )56,      (flex_int32_t const   )57,      (flex_int32_t const   )58, 
        (flex_int32_t const   )59,      (flex_int32_t const   )60,      (flex_int32_t const   )61,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 524 "lexssh.c"
static flex_int32_t const   yy_meta___3[62]  = 
#line 524
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3, 
        (flex_int32_t const   )4,      (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 535 "lexssh.c"
static flex_int16_t const   yy_base___3[913]  = 
#line 535
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )59, 
        (flex_int16_t const   )61,      (flex_int16_t const   )63,      (flex_int16_t const   )64,      (flex_int16_t const   )1012, 
        (flex_int16_t const   )0,      (flex_int16_t const   )66,      (flex_int16_t const   )71,      (flex_int16_t const   )1013, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1013,      (flex_int16_t const   )1004,      (flex_int16_t const   )1013, 
        (flex_int16_t const   )63,      (flex_int16_t const   )26,      (flex_int16_t const   )961,      (flex_int16_t const   )968, 
        (flex_int16_t const   )971,      (flex_int16_t const   )960,      (flex_int16_t const   )21,      (flex_int16_t const   )969, 
        (flex_int16_t const   )113,      (flex_int16_t const   )164,      (flex_int16_t const   )945,      (flex_int16_t const   )40, 
        (flex_int16_t const   )954,      (flex_int16_t const   )29,      (flex_int16_t const   )958,      (flex_int16_t const   )31, 
        (flex_int16_t const   )961,      (flex_int16_t const   )950,      (flex_int16_t const   )959,      (flex_int16_t const   )42, 
        (flex_int16_t const   )958,      (flex_int16_t const   )945,      (flex_int16_t const   )0,      (flex_int16_t const   )1013, 
        (flex_int16_t const   )1013,      (flex_int16_t const   )209,      (flex_int16_t const   )0,      (flex_int16_t const   )1013, 
        (flex_int16_t const   )1013,      (flex_int16_t const   )260,      (flex_int16_t const   )0,      (flex_int16_t const   )87, 
        (flex_int16_t const   )0,      (flex_int16_t const   )990,      (flex_int16_t const   )47,      (flex_int16_t const   )948, 
        (flex_int16_t const   )956,      (flex_int16_t const   )941,      (flex_int16_t const   )51,      (flex_int16_t const   )933, 
        (flex_int16_t const   )954,      (flex_int16_t const   )954,      (flex_int16_t const   )937,      (flex_int16_t const   )941, 
        (flex_int16_t const   )945,      (flex_int16_t const   )93,      (flex_int16_t const   )940,      (flex_int16_t const   )945, 
        (flex_int16_t const   )941,      (flex_int16_t const   )43,      (flex_int16_t const   )60,      (flex_int16_t const   )947, 
        (flex_int16_t const   )62,      (flex_int16_t const   )946,      (flex_int16_t const   )80,      (flex_int16_t const   )926, 
        (flex_int16_t const   )925,      (flex_int16_t const   )932,      (flex_int16_t const   )132,      (flex_int16_t const   )137, 
        (flex_int16_t const   )934,      (flex_int16_t const   )72,      (flex_int16_t const   )927,      (flex_int16_t const   )932, 
        (flex_int16_t const   )935,      (flex_int16_t const   )136,      (flex_int16_t const   )138,      (flex_int16_t const   )151, 
        (flex_int16_t const   )139,      (flex_int16_t const   )151,      (flex_int16_t const   )45,      (flex_int16_t const   )156, 
        (flex_int16_t const   )934,      (flex_int16_t const   )69,      (flex_int16_t const   )937,      (flex_int16_t const   )186, 
        (flex_int16_t const   )917,      (flex_int16_t const   )192,      (flex_int16_t const   )157,      (flex_int16_t const   )237, 
        (flex_int16_t const   )193,      (flex_int16_t const   )209,      (flex_int16_t const   )199,      (flex_int16_t const   )921, 
        (flex_int16_t const   )163,      (flex_int16_t const   )173,      (flex_int16_t const   )926,      (flex_int16_t const   )929, 
        (flex_int16_t const   )918,      (flex_int16_t const   )917,      (flex_int16_t const   )928,      (flex_int16_t const   )925, 
        (flex_int16_t const   )0,      (flex_int16_t const   )911,      (flex_int16_t const   )914,      (flex_int16_t const   )924, 
        (flex_int16_t const   )922,      (flex_int16_t const   )922,      (flex_int16_t const   )907,      (flex_int16_t const   )905, 
        (flex_int16_t const   )0,      (flex_int16_t const   )898,      (flex_int16_t const   )190,      (flex_int16_t const   )905, 
        (flex_int16_t const   )228,      (flex_int16_t const   )896,      (flex_int16_t const   )902,      (flex_int16_t const   )909, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1013,      (flex_int16_t const   )283,      (flex_int16_t const   )1013, 
        (flex_int16_t const   )1013,      (flex_int16_t const   )1013,      (flex_int16_t const   )1013,      (flex_int16_t const   )1013, 
        (flex_int16_t const   )1013,      (flex_int16_t const   )1013,      (flex_int16_t const   )1013,      (flex_int16_t const   )1013, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1013,      (flex_int16_t const   )294, 
        (flex_int16_t const   )1013,      (flex_int16_t const   )1013,      (flex_int16_t const   )1013,      (flex_int16_t const   )1013, 
        (flex_int16_t const   )1013,      (flex_int16_t const   )1013,      (flex_int16_t const   )1013,      (flex_int16_t const   )1013, 
        (flex_int16_t const   )1013,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )909, 
        (flex_int16_t const   )897,      (flex_int16_t const   )903,      (flex_int16_t const   )900,      (flex_int16_t const   )899, 
        (flex_int16_t const   )907,      (flex_int16_t const   )902,      (flex_int16_t const   )888,      (flex_int16_t const   )904, 
        (flex_int16_t const   )899,      (flex_int16_t const   )898,      (flex_int16_t const   )904,      (flex_int16_t const   )276, 
        (flex_int16_t const   )890,      (flex_int16_t const   )885,      (flex_int16_t const   )894,      (flex_int16_t const   )891, 
        (flex_int16_t const   )879,      (flex_int16_t const   )882,      (flex_int16_t const   )898,      (flex_int16_t const   )886, 
        (flex_int16_t const   )0,      (flex_int16_t const   )878,      (flex_int16_t const   )881,      (flex_int16_t const   )883, 
        (flex_int16_t const   )888,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )212, 
        (flex_int16_t const   )884,      (flex_int16_t const   )0,      (flex_int16_t const   )883,      (flex_int16_t const   )0, 
        (flex_int16_t const   )877,      (flex_int16_t const   )883,      (flex_int16_t const   )882,      (flex_int16_t const   )868, 
        (flex_int16_t const   )882,      (flex_int16_t const   )155,      (flex_int16_t const   )0,      (flex_int16_t const   )867, 
        (flex_int16_t const   )267,      (flex_int16_t const   )878,      (flex_int16_t const   )869,      (flex_int16_t const   )864, 
        (flex_int16_t const   )871,      (flex_int16_t const   )188,      (flex_int16_t const   )867,      (flex_int16_t const   )871, 
        (flex_int16_t const   )862,      (flex_int16_t const   )858,      (flex_int16_t const   )210,      (flex_int16_t const   )862, 
        (flex_int16_t const   )865,      (flex_int16_t const   )218,      (flex_int16_t const   )853,      (flex_int16_t const   )859, 
        (flex_int16_t const   )855,      (flex_int16_t const   )852,      (flex_int16_t const   )870,      (flex_int16_t const   )861, 
        (flex_int16_t const   )855,      (flex_int16_t const   )851,      (flex_int16_t const   )855,      (flex_int16_t const   )850, 
        (flex_int16_t const   )864,      (flex_int16_t const   )221,      (flex_int16_t const   )845,      (flex_int16_t const   )848, 
        (flex_int16_t const   )167,      (flex_int16_t const   )857,      (flex_int16_t const   )847,      (flex_int16_t const   )268, 
        (flex_int16_t const   )849,      (flex_int16_t const   )0,      (flex_int16_t const   )857,      (flex_int16_t const   )842, 
        (flex_int16_t const   )838,      (flex_int16_t const   )0,      (flex_int16_t const   )238,      (flex_int16_t const   )845, 
        (flex_int16_t const   )846,      (flex_int16_t const   )837,      (flex_int16_t const   )836,      (flex_int16_t const   )843, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )266,      (flex_int16_t const   )842, 
        (flex_int16_t const   )272,      (flex_int16_t const   )845,      (flex_int16_t const   )842,      (flex_int16_t const   )837, 
        (flex_int16_t const   )833,      (flex_int16_t const   )839,      (flex_int16_t const   )279,      (flex_int16_t const   )844, 
        (flex_int16_t const   )285,      (flex_int16_t const   )824,      (flex_int16_t const   )838,      (flex_int16_t const   )830, 
        (flex_int16_t const   )840,      (flex_int16_t const   )277,      (flex_int16_t const   )823,      (flex_int16_t const   )834, 
        (flex_int16_t const   )834,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )818, 
        (flex_int16_t const   )818,      (flex_int16_t const   )827,      (flex_int16_t const   )829,      (flex_int16_t const   )0, 
        (flex_int16_t const   )828,      (flex_int16_t const   )814,      (flex_int16_t const   )811,      (flex_int16_t const   )0, 
        (flex_int16_t const   )825,      (flex_int16_t const   )811,      (flex_int16_t const   )823,      (flex_int16_t const   )805, 
        (flex_int16_t const   )809,      (flex_int16_t const   )816,      (flex_int16_t const   )804,      (flex_int16_t const   )809, 
        (flex_int16_t const   )804,      (flex_int16_t const   )801,      (flex_int16_t const   )809,      (flex_int16_t const   )801, 
        (flex_int16_t const   )799,      (flex_int16_t const   )330,      (flex_int16_t const   )0,      (flex_int16_t const   )335, 
        (flex_int16_t const   )0,      (flex_int16_t const   )816,      (flex_int16_t const   )799,      (flex_int16_t const   )810, 
        (flex_int16_t const   )810,      (flex_int16_t const   )796,      (flex_int16_t const   )789,      (flex_int16_t const   )793, 
        (flex_int16_t const   )796,      (flex_int16_t const   )798,      (flex_int16_t const   )795,      (flex_int16_t const   )794, 
        (flex_int16_t const   )792,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )797,      (flex_int16_t const   )803,      (flex_int16_t const   )0, 
        (flex_int16_t const   )784,      (flex_int16_t const   )789,      (flex_int16_t const   )792,      (flex_int16_t const   )0, 
        (flex_int16_t const   )788,      (flex_int16_t const   )798,      (flex_int16_t const   )783,      (flex_int16_t const   )795, 
        (flex_int16_t const   )777,      (flex_int16_t const   )788,      (flex_int16_t const   )791,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )785,      (flex_int16_t const   )780, 
        (flex_int16_t const   )0,      (flex_int16_t const   )772,      (flex_int16_t const   )773,      (flex_int16_t const   )780, 
        (flex_int16_t const   )787,      (flex_int16_t const   )772,      (flex_int16_t const   )778,      (flex_int16_t const   )774, 
        (flex_int16_t const   )767,      (flex_int16_t const   )782,      (flex_int16_t const   )771,      (flex_int16_t const   )0, 
        (flex_int16_t const   )764,      (flex_int16_t const   )761,      (flex_int16_t const   )0,      (flex_int16_t const   )776, 
        (flex_int16_t const   )776,      (flex_int16_t const   )770,      (flex_int16_t const   )752,      (flex_int16_t const   )0, 
        (flex_int16_t const   )756,      (flex_int16_t const   )762,      (flex_int16_t const   )0,      (flex_int16_t const   )760, 
        (flex_int16_t const   )753,      (flex_int16_t const   )762,      (flex_int16_t const   )761,      (flex_int16_t const   )0, 
        (flex_int16_t const   )751,      (flex_int16_t const   )751,      (flex_int16_t const   )766,      (flex_int16_t const   )754, 
        (flex_int16_t const   )0,      (flex_int16_t const   )748,      (flex_int16_t const   )745,      (flex_int16_t const   )0, 
        (flex_int16_t const   )762,      (flex_int16_t const   )747,      (flex_int16_t const   )759,      (flex_int16_t const   )753, 
        (flex_int16_t const   )750,      (flex_int16_t const   )739,      (flex_int16_t const   )738,      (flex_int16_t const   )0, 
        (flex_int16_t const   )742,      (flex_int16_t const   )744,      (flex_int16_t const   )0,      (flex_int16_t const   )755, 
        (flex_int16_t const   )746,      (flex_int16_t const   )749,      (flex_int16_t const   )731,      (flex_int16_t const   )738, 
        (flex_int16_t const   )730,      (flex_int16_t const   )733,      (flex_int16_t const   )0,      (flex_int16_t const   )735, 
        (flex_int16_t const   )286,      (flex_int16_t const   )0,      (flex_int16_t const   )737,      (flex_int16_t const   )738, 
        (flex_int16_t const   )735,      (flex_int16_t const   )734,      (flex_int16_t const   )728,      (flex_int16_t const   )0, 
        (flex_int16_t const   )733,      (flex_int16_t const   )728,      (flex_int16_t const   )0,      (flex_int16_t const   )735, 
        (flex_int16_t const   )720,      (flex_int16_t const   )729,      (flex_int16_t const   )0,      (flex_int16_t const   )718, 
        (flex_int16_t const   )731,      (flex_int16_t const   )0,      (flex_int16_t const   )275,      (flex_int16_t const   )729, 
        (flex_int16_t const   )729,      (flex_int16_t const   )715,      (flex_int16_t const   )722,      (flex_int16_t const   )317, 
        (flex_int16_t const   )0,      (flex_int16_t const   )723,      (flex_int16_t const   )728,      (flex_int16_t const   )0, 
        (flex_int16_t const   )727,      (flex_int16_t const   )709,      (flex_int16_t const   )0,      (flex_int16_t const   )721, 
        (flex_int16_t const   )713,      (flex_int16_t const   )709,      (flex_int16_t const   )704,      (flex_int16_t const   )709, 
        (flex_int16_t const   )707,      (flex_int16_t const   )719,      (flex_int16_t const   )705,      (flex_int16_t const   )709, 
        (flex_int16_t const   )704,      (flex_int16_t const   )707,      (flex_int16_t const   )710,      (flex_int16_t const   )709, 
        (flex_int16_t const   )704,      (flex_int16_t const   )693,      (flex_int16_t const   )1013,      (flex_int16_t const   )1013, 
        (flex_int16_t const   )1013,      (flex_int16_t const   )1013,      (flex_int16_t const   )694,      (flex_int16_t const   )701, 
        (flex_int16_t const   )696,      (flex_int16_t const   )699,      (flex_int16_t const   )0,      (flex_int16_t const   )340, 
        (flex_int16_t const   )698,      (flex_int16_t const   )689,      (flex_int16_t const   )705,      (flex_int16_t const   )0, 
        (flex_int16_t const   )697,      (flex_int16_t const   )692,      (flex_int16_t const   )701,      (flex_int16_t const   )0, 
        (flex_int16_t const   )700,      (flex_int16_t const   )699,      (flex_int16_t const   )688,      (flex_int16_t const   )697, 
        (flex_int16_t const   )0,      (flex_int16_t const   )696,      (flex_int16_t const   )692,      (flex_int16_t const   )203, 
        (flex_int16_t const   )694,      (flex_int16_t const   )677,      (flex_int16_t const   )674,      (flex_int16_t const   )691, 
        (flex_int16_t const   )690,      (flex_int16_t const   )673,      (flex_int16_t const   )678,      (flex_int16_t const   )0, 
        (flex_int16_t const   )680,      (flex_int16_t const   )686,      (flex_int16_t const   )681,      (flex_int16_t const   )671, 
        (flex_int16_t const   )0,      (flex_int16_t const   )679,      (flex_int16_t const   )674,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )664,      (flex_int16_t const   )0,      (flex_int16_t const   )664, 
        (flex_int16_t const   )679,      (flex_int16_t const   )665,      (flex_int16_t const   )677,      (flex_int16_t const   )653, 
        (flex_int16_t const   )665,      (flex_int16_t const   )654,      (flex_int16_t const   )655,      (flex_int16_t const   )664, 
        (flex_int16_t const   )661,      (flex_int16_t const   )670,      (flex_int16_t const   )651,      (flex_int16_t const   )645, 
        (flex_int16_t const   )0,      (flex_int16_t const   )667,      (flex_int16_t const   )663,      (flex_int16_t const   )655, 
        (flex_int16_t const   )654,      (flex_int16_t const   )646,      (flex_int16_t const   )321,      (flex_int16_t const   )649, 
        (flex_int16_t const   )661,      (flex_int16_t const   )280,      (flex_int16_t const   )660,      (flex_int16_t const   )643, 
        (flex_int16_t const   )641,      (flex_int16_t const   )653,      (flex_int16_t const   )648,      (flex_int16_t const   )0, 
        (flex_int16_t const   )651,      (flex_int16_t const   )0,      (flex_int16_t const   )636,      (flex_int16_t const   )651, 
        (flex_int16_t const   )642,      (flex_int16_t const   )641,      (flex_int16_t const   )633,      (flex_int16_t const   )636, 
        (flex_int16_t const   )630,      (flex_int16_t const   )647,      (flex_int16_t const   )642,      (flex_int16_t const   )641, 
        (flex_int16_t const   )626,      (flex_int16_t const   )639,      (flex_int16_t const   )0,      (flex_int16_t const   )638, 
        (flex_int16_t const   )641,      (flex_int16_t const   )623,      (flex_int16_t const   )635,      (flex_int16_t const   )622, 
        (flex_int16_t const   )627,      (flex_int16_t const   )622,      (flex_int16_t const   )622,      (flex_int16_t const   )626, 
        (flex_int16_t const   )310,      (flex_int16_t const   )629,      (flex_int16_t const   )624,      (flex_int16_t const   )316, 
        (flex_int16_t const   )627,      (flex_int16_t const   )0,      (flex_int16_t const   )629,      (flex_int16_t const   )611, 
        (flex_int16_t const   )612,      (flex_int16_t const   )623,      (flex_int16_t const   )608,      (flex_int16_t const   )0, 
        (flex_int16_t const   )608,      (flex_int16_t const   )608,      (flex_int16_t const   )605,      (flex_int16_t const   )610, 
        (flex_int16_t const   )605,      (flex_int16_t const   )617,      (flex_int16_t const   )601,      (flex_int16_t const   )606, 
        (flex_int16_t const   )0,      (flex_int16_t const   )604,      (flex_int16_t const   )612,      (flex_int16_t const   )0, 
        (flex_int16_t const   )603,      (flex_int16_t const   )596,      (flex_int16_t const   )601,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )611, 
        (flex_int16_t const   )608,      (flex_int16_t const   )593,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )593,      (flex_int16_t const   )595, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )607,      (flex_int16_t const   )590, 
        (flex_int16_t const   )597,      (flex_int16_t const   )0,      (flex_int16_t const   )591,      (flex_int16_t const   )603, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )589,      (flex_int16_t const   )588, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )578, 
        (flex_int16_t const   )581,      (flex_int16_t const   )598,      (flex_int16_t const   )578,      (flex_int16_t const   )588, 
        (flex_int16_t const   )0,      (flex_int16_t const   )583,      (flex_int16_t const   )578,      (flex_int16_t const   )576, 
        (flex_int16_t const   )579,      (flex_int16_t const   )0,      (flex_int16_t const   )574,      (flex_int16_t const   )578, 
        (flex_int16_t const   )579,      (flex_int16_t const   )0,      (flex_int16_t const   )571,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )587,      (flex_int16_t const   )582,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )569,      (flex_int16_t const   )576,      (flex_int16_t const   )567, 
        (flex_int16_t const   )0,      (flex_int16_t const   )570,      (flex_int16_t const   )562,      (flex_int16_t const   )0, 
        (flex_int16_t const   )567,      (flex_int16_t const   )0,      (flex_int16_t const   )562,      (flex_int16_t const   )578, 
        (flex_int16_t const   )0,      (flex_int16_t const   )564,      (flex_int16_t const   )576,      (flex_int16_t const   )571, 
        (flex_int16_t const   )0,      (flex_int16_t const   )556,      (flex_int16_t const   )557,      (flex_int16_t const   )572, 
        (flex_int16_t const   )0,      (flex_int16_t const   )554,      (flex_int16_t const   )552,      (flex_int16_t const   )562, 
        (flex_int16_t const   )550,      (flex_int16_t const   )562,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )555,      (flex_int16_t const   )552,      (flex_int16_t const   )551,      (flex_int16_t const   )546, 
        (flex_int16_t const   )548,      (flex_int16_t const   )561,      (flex_int16_t const   )552,      (flex_int16_t const   )0, 
        (flex_int16_t const   )553,      (flex_int16_t const   )552,      (flex_int16_t const   )553,      (flex_int16_t const   )556, 
        (flex_int16_t const   )0,      (flex_int16_t const   )551,      (flex_int16_t const   )541,      (flex_int16_t const   )536, 
        (flex_int16_t const   )540,      (flex_int16_t const   )543,      (flex_int16_t const   )542,      (flex_int16_t const   )546, 
        (flex_int16_t const   )535,      (flex_int16_t const   )547,      (flex_int16_t const   )542,      (flex_int16_t const   )0, 
        (flex_int16_t const   )537,      (flex_int16_t const   )542,      (flex_int16_t const   )531,      (flex_int16_t const   )530, 
        (flex_int16_t const   )535,      (flex_int16_t const   )541,      (flex_int16_t const   )533,      (flex_int16_t const   )528, 
        (flex_int16_t const   )538,      (flex_int16_t const   )518,      (flex_int16_t const   )519,      (flex_int16_t const   )522, 
        (flex_int16_t const   )0,      (flex_int16_t const   )517,      (flex_int16_t const   )526,      (flex_int16_t const   )519, 
        (flex_int16_t const   )514,      (flex_int16_t const   )508,      (flex_int16_t const   )516,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )521,      (flex_int16_t const   )518,      (flex_int16_t const   )519, 
        (flex_int16_t const   )521,      (flex_int16_t const   )507,      (flex_int16_t const   )518,      (flex_int16_t const   )509, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )501, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )503,      (flex_int16_t const   )512, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )516,      (flex_int16_t const   )504, 
        (flex_int16_t const   )0,      (flex_int16_t const   )505,      (flex_int16_t const   )0,      (flex_int16_t const   )504, 
        (flex_int16_t const   )0,      (flex_int16_t const   )509,      (flex_int16_t const   )0,      (flex_int16_t const   )496, 
        (flex_int16_t const   )492,      (flex_int16_t const   )506,      (flex_int16_t const   )509,      (flex_int16_t const   )504, 
        (flex_int16_t const   )494,      (flex_int16_t const   )506,      (flex_int16_t const   )484,      (flex_int16_t const   )492, 
        (flex_int16_t const   )495,      (flex_int16_t const   )479,      (flex_int16_t const   )490,      (flex_int16_t const   )0, 
        (flex_int16_t const   )492,      (flex_int16_t const   )488,      (flex_int16_t const   )480,      (flex_int16_t const   )494, 
        (flex_int16_t const   )478,      (flex_int16_t const   )479,      (flex_int16_t const   )0,      (flex_int16_t const   )476, 
        (flex_int16_t const   )480,      (flex_int16_t const   )474,      (flex_int16_t const   )474,      (flex_int16_t const   )474, 
        (flex_int16_t const   )479,      (flex_int16_t const   )471,      (flex_int16_t const   )467,      (flex_int16_t const   )482, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )468, 
        (flex_int16_t const   )0,      (flex_int16_t const   )480,      (flex_int16_t const   )462,      (flex_int16_t const   )459, 
        (flex_int16_t const   )460,      (flex_int16_t const   )0,      (flex_int16_t const   )453,      (flex_int16_t const   )454, 
        (flex_int16_t const   )0,      (flex_int16_t const   )444,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )449,      (flex_int16_t const   )27,      (flex_int16_t const   )56,      (flex_int16_t const   )136, 
        (flex_int16_t const   )234,      (flex_int16_t const   )244,      (flex_int16_t const   )0,      (flex_int16_t const   )284, 
        (flex_int16_t const   )282,      (flex_int16_t const   )291,      (flex_int16_t const   )305,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )320,      (flex_int16_t const   )309,      (flex_int16_t const   )310, 
        (flex_int16_t const   )319,      (flex_int16_t const   )313,      (flex_int16_t const   )311,      (flex_int16_t const   )315, 
        (flex_int16_t const   )320,      (flex_int16_t const   )322,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )329,      (flex_int16_t const   )324,      (flex_int16_t const   )328,      (flex_int16_t const   )325, 
        (flex_int16_t const   )343,      (flex_int16_t const   )344,      (flex_int16_t const   )341,      (flex_int16_t const   )329, 
        (flex_int16_t const   )330,      (flex_int16_t const   )348,      (flex_int16_t const   )337,      (flex_int16_t const   )342, 
        (flex_int16_t const   )0,      (flex_int16_t const   )334,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )348,      (flex_int16_t const   )336,      (flex_int16_t const   )336,      (flex_int16_t const   )0, 
        (flex_int16_t const   )337,      (flex_int16_t const   )343,      (flex_int16_t const   )336,      (flex_int16_t const   )337, 
        (flex_int16_t const   )341,      (flex_int16_t const   )347,      (flex_int16_t const   )345,      (flex_int16_t const   )0, 
        (flex_int16_t const   )344,      (flex_int16_t const   )344,      (flex_int16_t const   )343,      (flex_int16_t const   )0, 
        (flex_int16_t const   )347,      (flex_int16_t const   )345,      (flex_int16_t const   )349,      (flex_int16_t const   )364, 
        (flex_int16_t const   )347,      (flex_int16_t const   )0,      (flex_int16_t const   )357,      (flex_int16_t const   )353, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )368, 
        (flex_int16_t const   )364,      (flex_int16_t const   )361,      (flex_int16_t const   )367,      (flex_int16_t const   )364, 
        (flex_int16_t const   )359,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )367, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )361,      (flex_int16_t const   )363, 
        (flex_int16_t const   )361,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )366,      (flex_int16_t const   )367,      (flex_int16_t const   )372,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )385,      (flex_int16_t const   )365,      (flex_int16_t const   )383, 
        (flex_int16_t const   )0,      (flex_int16_t const   )380,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )389,      (flex_int16_t const   )372,      (flex_int16_t const   )0, 
        (flex_int16_t const   )370,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )380,      (flex_int16_t const   )387,      (flex_int16_t const   )391,      (flex_int16_t const   )391, 
        (flex_int16_t const   )396,      (flex_int16_t const   )389,      (flex_int16_t const   )0,      (flex_int16_t const   )394, 
        (flex_int16_t const   )386,      (flex_int16_t const   )387,      (flex_int16_t const   )395,      (flex_int16_t const   )386, 
        (flex_int16_t const   )0,      (flex_int16_t const   )385,      (flex_int16_t const   )386,      (flex_int16_t const   )389, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )399, 
        (flex_int16_t const   )390,      (flex_int16_t const   )392,      (flex_int16_t const   )393,      (flex_int16_t const   )397, 
        (flex_int16_t const   )0,      (flex_int16_t const   )399,      (flex_int16_t const   )400,      (flex_int16_t const   )0, 
        (flex_int16_t const   )397,      (flex_int16_t const   )395,      (flex_int16_t const   )0,      (flex_int16_t const   )399, 
        (flex_int16_t const   )398,      (flex_int16_t const   )398,      (flex_int16_t const   )0,      (flex_int16_t const   )409, 
        (flex_int16_t const   )407,      (flex_int16_t const   )414,      (flex_int16_t const   )415,      (flex_int16_t const   )409, 
        (flex_int16_t const   )407,      (flex_int16_t const   )411,      (flex_int16_t const   )0,      (flex_int16_t const   )417, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )405,      (flex_int16_t const   )415,      (flex_int16_t const   )407,      (flex_int16_t const   )411, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1013,      (flex_int16_t const   )466,      (flex_int16_t const   )473,      (flex_int16_t const   )480, 
        (flex_int16_t const   )487,      (flex_int16_t const   )494,      (flex_int16_t const   )500,      (flex_int16_t const   )507, 
        (flex_int16_t const   )513,      (flex_int16_t const   )476,      (flex_int16_t const   )477,      (flex_int16_t const   )478, 
        (flex_int16_t const   )479};
#line 640 "lexssh.c"
static flex_int16_t const   yy_def___3[913]  = 
#line 640
  {      (flex_int16_t const   )0,      (flex_int16_t const   )900,      (flex_int16_t const   )1,      (flex_int16_t const   )901, 
        (flex_int16_t const   )901,      (flex_int16_t const   )902,      (flex_int16_t const   )902,      (flex_int16_t const   )900, 
        (flex_int16_t const   )903,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )904,      (flex_int16_t const   )900,      (flex_int16_t const   )903,      (flex_int16_t const   )900, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )900,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )905,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )906,      (flex_int16_t const   )907,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )908,      (flex_int16_t const   )903,      (flex_int16_t const   )900, 
        (flex_int16_t const   )904,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )905,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )909,      (flex_int16_t const   )907,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )910,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )900,      (flex_int16_t const   )911,      (flex_int16_t const   )900, 
        (flex_int16_t const   )912,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )0,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900};
#line 745 "lexssh.c"
static flex_int16_t const   yy_nxt___3[1075]  = 
#line 745
  {      (flex_int16_t const   )0,      (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )16,      (flex_int16_t const   )8,      (flex_int16_t const   )17, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )18,      (flex_int16_t const   )19, 
        (flex_int16_t const   )20,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8, 
        (flex_int16_t const   )21,      (flex_int16_t const   )8,      (flex_int16_t const   )22,      (flex_int16_t const   )23, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )24, 
        (flex_int16_t const   )8,      (flex_int16_t const   )25,      (flex_int16_t const   )26,      (flex_int16_t const   )27, 
        (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )33,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )36,      (flex_int16_t const   )37,      (flex_int16_t const   )8, 
        (flex_int16_t const   )8,      (flex_int16_t const   )8,      (flex_int16_t const   )39,      (flex_int16_t const   )40, 
        (flex_int16_t const   )39,      (flex_int16_t const   )40,      (flex_int16_t const   )43,      (flex_int16_t const   )43, 
        (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )50,      (flex_int16_t const   )44, 
        (flex_int16_t const   )44,      (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )52, 
        (flex_int16_t const   )58,      (flex_int16_t const   )109,      (flex_int16_t const   )112,      (flex_int16_t const   )53, 
        (flex_int16_t const   )115,      (flex_int16_t const   )59,      (flex_int16_t const   )791,      (flex_int16_t const   )120, 
        (flex_int16_t const   )167,      (flex_int16_t const   )116,      (flex_int16_t const   )151,      (flex_int16_t const   )110, 
        (flex_int16_t const   )113,      (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )156, 
        (flex_int16_t const   )212,      (flex_int16_t const   )168,      (flex_int16_t const   )41,      (flex_int16_t const   )213, 
        (flex_int16_t const   )41,      (flex_int16_t const   )121,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )792,      (flex_int16_t const   )152,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )157,      (flex_int16_t const   )187,      (flex_int16_t const   )172,      (flex_int16_t const   )169, 
        (flex_int16_t const   )173,      (flex_int16_t const   )51,      (flex_int16_t const   )46,      (flex_int16_t const   )170, 
        (flex_int16_t const   )188,      (flex_int16_t const   )175,      (flex_int16_t const   )217,      (flex_int16_t const   )218, 
        (flex_int16_t const   )46,      (flex_int16_t const   )176,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )62,      (flex_int16_t const   )63,      (flex_int16_t const   )64,      (flex_int16_t const   )65, 
        (flex_int16_t const   )66,      (flex_int16_t const   )46,      (flex_int16_t const   )67,      (flex_int16_t const   )68, 
        (flex_int16_t const   )69,      (flex_int16_t const   )70,      (flex_int16_t const   )71,      (flex_int16_t const   )72, 
        (flex_int16_t const   )73,      (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )76, 
        (flex_int16_t const   )77,      (flex_int16_t const   )78,      (flex_int16_t const   )79,      (flex_int16_t const   )80, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )81,      (flex_int16_t const   )82, 
        (flex_int16_t const   )83,      (flex_int16_t const   )84,      (flex_int16_t const   )85,      (flex_int16_t const   )86, 
        (flex_int16_t const   )87,      (flex_int16_t const   )88,      (flex_int16_t const   )89,      (flex_int16_t const   )90, 
        (flex_int16_t const   )91,      (flex_int16_t const   )92,      (flex_int16_t const   )93,      (flex_int16_t const   )94, 
        (flex_int16_t const   )95,      (flex_int16_t const   )46,      (flex_int16_t const   )96,      (flex_int16_t const   )97, 
        (flex_int16_t const   )98,      (flex_int16_t const   )99,      (flex_int16_t const   )100,      (flex_int16_t const   )101, 
        (flex_int16_t const   )102,      (flex_int16_t const   )46,      (flex_int16_t const   )103,      (flex_int16_t const   )104, 
        (flex_int16_t const   )180,      (flex_int16_t const   )181,      (flex_int16_t const   )183,      (flex_int16_t const   )195, 
        (flex_int16_t const   )204,      (flex_int16_t const   )184,      (flex_int16_t const   )185,      (flex_int16_t const   )192, 
        (flex_int16_t const   )205,      (flex_int16_t const   )193,      (flex_int16_t const   )182,      (flex_int16_t const   )194, 
        (flex_int16_t const   )197,      (flex_int16_t const   )206,      (flex_int16_t const   )793,      (flex_int16_t const   )198, 
        (flex_int16_t const   )322,      (flex_int16_t const   )214,      (flex_int16_t const   )196,      (flex_int16_t const   )199, 
        (flex_int16_t const   )200,      (flex_int16_t const   )215,      (flex_int16_t const   )201,      (flex_int16_t const   )207, 
        (flex_int16_t const   )254,      (flex_int16_t const   )202,      (flex_int16_t const   )208,      (flex_int16_t const   )209, 
        (flex_int16_t const   )255,      (flex_int16_t const   )230,      (flex_int16_t const   )210,      (flex_int16_t const   )203, 
        (flex_int16_t const   )231,      (flex_int16_t const   )323,      (flex_int16_t const   )211,      (flex_int16_t const   )105, 
        (flex_int16_t const   )232,      (flex_int16_t const   )106,      (flex_int16_t const   )256,      (flex_int16_t const   )358, 
        (flex_int16_t const   )359,      (flex_int16_t const   )107,      (flex_int16_t const   )126,      (flex_int16_t const   )126, 
        (flex_int16_t const   )126,      (flex_int16_t const   )126,      (flex_int16_t const   )126,      (flex_int16_t const   )220, 
        (flex_int16_t const   )257,      (flex_int16_t const   )221,      (flex_int16_t const   )222,      (flex_int16_t const   )223, 
        (flex_int16_t const   )224,      (flex_int16_t const   )226,      (flex_int16_t const   )240,      (flex_int16_t const   )272, 
        (flex_int16_t const   )241,      (flex_int16_t const   )227,      (flex_int16_t const   )242,      (flex_int16_t const   )243, 
        (flex_int16_t const   )249,      (flex_int16_t const   )244,      (flex_int16_t const   )245,      (flex_int16_t const   )331, 
        (flex_int16_t const   )563,      (flex_int16_t const   )332,      (flex_int16_t const   )228,      (flex_int16_t const   )250, 
        (flex_int16_t const   )251,      (flex_int16_t const   )273,      (flex_int16_t const   )127,      (flex_int16_t const   )128, 
        (flex_int16_t const   )229,      (flex_int16_t const   )129,      (flex_int16_t const   )130,      (flex_int16_t const   )131, 
        (flex_int16_t const   )252,      (flex_int16_t const   )313,      (flex_int16_t const   )246,      (flex_int16_t const   )341, 
        (flex_int16_t const   )564,      (flex_int16_t const   )314,      (flex_int16_t const   )132,      (flex_int16_t const   )337, 
        (flex_int16_t const   )247,      (flex_int16_t const   )338,      (flex_int16_t const   )133,      (flex_int16_t const   )354, 
        (flex_int16_t const   )134,      (flex_int16_t const   )248,      (flex_int16_t const   )135,      (flex_int16_t const   )275, 
        (flex_int16_t const   )136,      (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )139, 
        (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )233,      (flex_int16_t const   )342, 
        (flex_int16_t const   )355,      (flex_int16_t const   )276,      (flex_int16_t const   )234,      (flex_int16_t const   )368, 
        (flex_int16_t const   )277,      (flex_int16_t const   )235,      (flex_int16_t const   )236,      (flex_int16_t const   )369, 
        (flex_int16_t const   )794,      (flex_int16_t const   )237,      (flex_int16_t const   )297,      (flex_int16_t const   )298, 
        (flex_int16_t const   )299,      (flex_int16_t const   )300,      (flex_int16_t const   )238,      (flex_int16_t const   )239, 
        (flex_int16_t const   )281,      (flex_int16_t const   )281,      (flex_int16_t const   )281,      (flex_int16_t const   )281, 
        (flex_int16_t const   )281,      (flex_int16_t const   )140,      (flex_int16_t const   )141,      (flex_int16_t const   )795, 
        (flex_int16_t const   )142,      (flex_int16_t const   )143,      (flex_int16_t const   )144,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )325,      (flex_int16_t const   )145,      (flex_int16_t const   )362,      (flex_int16_t const   )375, 
        (flex_int16_t const   )378,      (flex_int16_t const   )146,      (flex_int16_t const   )397,      (flex_int16_t const   )147, 
        (flex_int16_t const   )376,      (flex_int16_t const   )148,      (flex_int16_t const   )326,      (flex_int16_t const   )149, 
        (flex_int16_t const   )363,      (flex_int16_t const   )379,      (flex_int16_t const   )385,      (flex_int16_t const   )388, 
        (flex_int16_t const   )389,      (flex_int16_t const   )601,      (flex_int16_t const   )497,      (flex_int16_t const   )386, 
        (flex_int16_t const   )511,      (flex_int16_t const   )796,      (flex_int16_t const   )512,      (flex_int16_t const   )398, 
        (flex_int16_t const   )797,      (flex_int16_t const   )390,      (flex_int16_t const   )602,      (flex_int16_t const   )798, 
        (flex_int16_t const   )391,      (flex_int16_t const   )498,      (flex_int16_t const   )392,      (flex_int16_t const   )422, 
        (flex_int16_t const   )422,      (flex_int16_t const   )422,      (flex_int16_t const   )422,      (flex_int16_t const   )422, 
        (flex_int16_t const   )424,      (flex_int16_t const   )424,      (flex_int16_t const   )424,      (flex_int16_t const   )424, 
        (flex_int16_t const   )424,      (flex_int16_t const   )517,      (flex_int16_t const   )547,      (flex_int16_t const   )548, 
        (flex_int16_t const   )549,      (flex_int16_t const   )550,      (flex_int16_t const   )630,      (flex_int16_t const   )631, 
        (flex_int16_t const   )518,      (flex_int16_t const   )519,      (flex_int16_t const   )597,      (flex_int16_t const   )799, 
        (flex_int16_t const   )634,      (flex_int16_t const   )800,      (flex_int16_t const   )801,      (flex_int16_t const   )802, 
        (flex_int16_t const   )803,      (flex_int16_t const   )804,      (flex_int16_t const   )805,      (flex_int16_t const   )806, 
        (flex_int16_t const   )520,      (flex_int16_t const   )635,      (flex_int16_t const   )521,      (flex_int16_t const   )522, 
        (flex_int16_t const   )523,      (flex_int16_t const   )807,      (flex_int16_t const   )598,      (flex_int16_t const   )808, 
        (flex_int16_t const   )809,      (flex_int16_t const   )810,      (flex_int16_t const   )811,      (flex_int16_t const   )812, 
        (flex_int16_t const   )813,      (flex_int16_t const   )814,      (flex_int16_t const   )815,      (flex_int16_t const   )816, 
        (flex_int16_t const   )817,      (flex_int16_t const   )818,      (flex_int16_t const   )819,      (flex_int16_t const   )820, 
        (flex_int16_t const   )821,      (flex_int16_t const   )822,      (flex_int16_t const   )823,      (flex_int16_t const   )824, 
        (flex_int16_t const   )825,      (flex_int16_t const   )826,      (flex_int16_t const   )827,      (flex_int16_t const   )828, 
        (flex_int16_t const   )829,      (flex_int16_t const   )830,      (flex_int16_t const   )831,      (flex_int16_t const   )832, 
        (flex_int16_t const   )833,      (flex_int16_t const   )834,      (flex_int16_t const   )835,      (flex_int16_t const   )836, 
        (flex_int16_t const   )837,      (flex_int16_t const   )838,      (flex_int16_t const   )839,      (flex_int16_t const   )840, 
        (flex_int16_t const   )841,      (flex_int16_t const   )842,      (flex_int16_t const   )843,      (flex_int16_t const   )844, 
        (flex_int16_t const   )845,      (flex_int16_t const   )846,      (flex_int16_t const   )847,      (flex_int16_t const   )848, 
        (flex_int16_t const   )849,      (flex_int16_t const   )850,      (flex_int16_t const   )851,      (flex_int16_t const   )852, 
        (flex_int16_t const   )853,      (flex_int16_t const   )854,      (flex_int16_t const   )855,      (flex_int16_t const   )856, 
        (flex_int16_t const   )857,      (flex_int16_t const   )858,      (flex_int16_t const   )859,      (flex_int16_t const   )860, 
        (flex_int16_t const   )861,      (flex_int16_t const   )862,      (flex_int16_t const   )863,      (flex_int16_t const   )864, 
        (flex_int16_t const   )865,      (flex_int16_t const   )866,      (flex_int16_t const   )867,      (flex_int16_t const   )868, 
        (flex_int16_t const   )869,      (flex_int16_t const   )870,      (flex_int16_t const   )871,      (flex_int16_t const   )872, 
        (flex_int16_t const   )873,      (flex_int16_t const   )874,      (flex_int16_t const   )875,      (flex_int16_t const   )876, 
        (flex_int16_t const   )877,      (flex_int16_t const   )878,      (flex_int16_t const   )879,      (flex_int16_t const   )880, 
        (flex_int16_t const   )881,      (flex_int16_t const   )882,      (flex_int16_t const   )883,      (flex_int16_t const   )884, 
        (flex_int16_t const   )885,      (flex_int16_t const   )886,      (flex_int16_t const   )887,      (flex_int16_t const   )888, 
        (flex_int16_t const   )889,      (flex_int16_t const   )890,      (flex_int16_t const   )891,      (flex_int16_t const   )892, 
        (flex_int16_t const   )893,      (flex_int16_t const   )894,      (flex_int16_t const   )895,      (flex_int16_t const   )896, 
        (flex_int16_t const   )897,      (flex_int16_t const   )898,      (flex_int16_t const   )899,      (flex_int16_t const   )38, 
        (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )38, 
        (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )46,      (flex_int16_t const   )282,      (flex_int16_t const   )284, 
        (flex_int16_t const   )423,      (flex_int16_t const   )425,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )790,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )789,      (flex_int16_t const   )788,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )125,      (flex_int16_t const   )125,      (flex_int16_t const   )787, 
        (flex_int16_t const   )125,      (flex_int16_t const   )125,      (flex_int16_t const   )125,      (flex_int16_t const   )125, 
        (flex_int16_t const   )137,      (flex_int16_t const   )137,      (flex_int16_t const   )786,      (flex_int16_t const   )137, 
        (flex_int16_t const   )785,      (flex_int16_t const   )137,      (flex_int16_t const   )138,      (flex_int16_t const   )138, 
        (flex_int16_t const   )784,      (flex_int16_t const   )138,      (flex_int16_t const   )138,      (flex_int16_t const   )138, 
        (flex_int16_t const   )138,      (flex_int16_t const   )783,      (flex_int16_t const   )782,      (flex_int16_t const   )781, 
        (flex_int16_t const   )780,      (flex_int16_t const   )779,      (flex_int16_t const   )778,      (flex_int16_t const   )777, 
        (flex_int16_t const   )776,      (flex_int16_t const   )775,      (flex_int16_t const   )774,      (flex_int16_t const   )773, 
        (flex_int16_t const   )772,      (flex_int16_t const   )771,      (flex_int16_t const   )770,      (flex_int16_t const   )769, 
        (flex_int16_t const   )768,      (flex_int16_t const   )767,      (flex_int16_t const   )766,      (flex_int16_t const   )765, 
        (flex_int16_t const   )764,      (flex_int16_t const   )763,      (flex_int16_t const   )762,      (flex_int16_t const   )761, 
        (flex_int16_t const   )760,      (flex_int16_t const   )759,      (flex_int16_t const   )758,      (flex_int16_t const   )757, 
        (flex_int16_t const   )756,      (flex_int16_t const   )755,      (flex_int16_t const   )754,      (flex_int16_t const   )753, 
        (flex_int16_t const   )752,      (flex_int16_t const   )751,      (flex_int16_t const   )750,      (flex_int16_t const   )749, 
        (flex_int16_t const   )748,      (flex_int16_t const   )747,      (flex_int16_t const   )746,      (flex_int16_t const   )745, 
        (flex_int16_t const   )744,      (flex_int16_t const   )743,      (flex_int16_t const   )742,      (flex_int16_t const   )741, 
        (flex_int16_t const   )740,      (flex_int16_t const   )739,      (flex_int16_t const   )738,      (flex_int16_t const   )737, 
        (flex_int16_t const   )736,      (flex_int16_t const   )735,      (flex_int16_t const   )734,      (flex_int16_t const   )733, 
        (flex_int16_t const   )732,      (flex_int16_t const   )731,      (flex_int16_t const   )730,      (flex_int16_t const   )729, 
        (flex_int16_t const   )728,      (flex_int16_t const   )727,      (flex_int16_t const   )726,      (flex_int16_t const   )725, 
        (flex_int16_t const   )724,      (flex_int16_t const   )723,      (flex_int16_t const   )722,      (flex_int16_t const   )721, 
        (flex_int16_t const   )720,      (flex_int16_t const   )719,      (flex_int16_t const   )718,      (flex_int16_t const   )717, 
        (flex_int16_t const   )716,      (flex_int16_t const   )715,      (flex_int16_t const   )714,      (flex_int16_t const   )713, 
        (flex_int16_t const   )712,      (flex_int16_t const   )711,      (flex_int16_t const   )710,      (flex_int16_t const   )709, 
        (flex_int16_t const   )708,      (flex_int16_t const   )707,      (flex_int16_t const   )706,      (flex_int16_t const   )705, 
        (flex_int16_t const   )704,      (flex_int16_t const   )703,      (flex_int16_t const   )702,      (flex_int16_t const   )701, 
        (flex_int16_t const   )700,      (flex_int16_t const   )699,      (flex_int16_t const   )698,      (flex_int16_t const   )697, 
        (flex_int16_t const   )696,      (flex_int16_t const   )695,      (flex_int16_t const   )694,      (flex_int16_t const   )693, 
        (flex_int16_t const   )692,      (flex_int16_t const   )691,      (flex_int16_t const   )690,      (flex_int16_t const   )689, 
        (flex_int16_t const   )688,      (flex_int16_t const   )687,      (flex_int16_t const   )686,      (flex_int16_t const   )685, 
        (flex_int16_t const   )684,      (flex_int16_t const   )683,      (flex_int16_t const   )682,      (flex_int16_t const   )681, 
        (flex_int16_t const   )680,      (flex_int16_t const   )679,      (flex_int16_t const   )678,      (flex_int16_t const   )677, 
        (flex_int16_t const   )676,      (flex_int16_t const   )675,      (flex_int16_t const   )674,      (flex_int16_t const   )673, 
        (flex_int16_t const   )672,      (flex_int16_t const   )671,      (flex_int16_t const   )670,      (flex_int16_t const   )669, 
        (flex_int16_t const   )668,      (flex_int16_t const   )667,      (flex_int16_t const   )666,      (flex_int16_t const   )665, 
        (flex_int16_t const   )664,      (flex_int16_t const   )663,      (flex_int16_t const   )662,      (flex_int16_t const   )661, 
        (flex_int16_t const   )660,      (flex_int16_t const   )659,      (flex_int16_t const   )658,      (flex_int16_t const   )657, 
        (flex_int16_t const   )656,      (flex_int16_t const   )655,      (flex_int16_t const   )654,      (flex_int16_t const   )653, 
        (flex_int16_t const   )652,      (flex_int16_t const   )651,      (flex_int16_t const   )650,      (flex_int16_t const   )649, 
        (flex_int16_t const   )648,      (flex_int16_t const   )647,      (flex_int16_t const   )646,      (flex_int16_t const   )645, 
        (flex_int16_t const   )644,      (flex_int16_t const   )643,      (flex_int16_t const   )642,      (flex_int16_t const   )641, 
        (flex_int16_t const   )640,      (flex_int16_t const   )639,      (flex_int16_t const   )638,      (flex_int16_t const   )637, 
        (flex_int16_t const   )636,      (flex_int16_t const   )633,      (flex_int16_t const   )632,      (flex_int16_t const   )629, 
        (flex_int16_t const   )628,      (flex_int16_t const   )627,      (flex_int16_t const   )626,      (flex_int16_t const   )625, 
        (flex_int16_t const   )624,      (flex_int16_t const   )623,      (flex_int16_t const   )622,      (flex_int16_t const   )621, 
        (flex_int16_t const   )620,      (flex_int16_t const   )619,      (flex_int16_t const   )618,      (flex_int16_t const   )617, 
        (flex_int16_t const   )616,      (flex_int16_t const   )615,      (flex_int16_t const   )614,      (flex_int16_t const   )613, 
        (flex_int16_t const   )612,      (flex_int16_t const   )611,      (flex_int16_t const   )610,      (flex_int16_t const   )609, 
        (flex_int16_t const   )608,      (flex_int16_t const   )607,      (flex_int16_t const   )606,      (flex_int16_t const   )605, 
        (flex_int16_t const   )604,      (flex_int16_t const   )603,      (flex_int16_t const   )600,      (flex_int16_t const   )599, 
        (flex_int16_t const   )596,      (flex_int16_t const   )595,      (flex_int16_t const   )594,      (flex_int16_t const   )593, 
        (flex_int16_t const   )592,      (flex_int16_t const   )591,      (flex_int16_t const   )590,      (flex_int16_t const   )589, 
        (flex_int16_t const   )588,      (flex_int16_t const   )587,      (flex_int16_t const   )586,      (flex_int16_t const   )585, 
        (flex_int16_t const   )584,      (flex_int16_t const   )583,      (flex_int16_t const   )582,      (flex_int16_t const   )581, 
        (flex_int16_t const   )580,      (flex_int16_t const   )579,      (flex_int16_t const   )578,      (flex_int16_t const   )577, 
        (flex_int16_t const   )576,      (flex_int16_t const   )575,      (flex_int16_t const   )574,      (flex_int16_t const   )573, 
        (flex_int16_t const   )572,      (flex_int16_t const   )571,      (flex_int16_t const   )570,      (flex_int16_t const   )569, 
        (flex_int16_t const   )568,      (flex_int16_t const   )567,      (flex_int16_t const   )566,      (flex_int16_t const   )565, 
        (flex_int16_t const   )562,      (flex_int16_t const   )561,      (flex_int16_t const   )560,      (flex_int16_t const   )559, 
        (flex_int16_t const   )558,      (flex_int16_t const   )557,      (flex_int16_t const   )556,      (flex_int16_t const   )555, 
        (flex_int16_t const   )554,      (flex_int16_t const   )553,      (flex_int16_t const   )552,      (flex_int16_t const   )551, 
        (flex_int16_t const   )546,      (flex_int16_t const   )545,      (flex_int16_t const   )544,      (flex_int16_t const   )543, 
        (flex_int16_t const   )542,      (flex_int16_t const   )541,      (flex_int16_t const   )540,      (flex_int16_t const   )539, 
        (flex_int16_t const   )538,      (flex_int16_t const   )537,      (flex_int16_t const   )536,      (flex_int16_t const   )535, 
        (flex_int16_t const   )534,      (flex_int16_t const   )533,      (flex_int16_t const   )532,      (flex_int16_t const   )531, 
        (flex_int16_t const   )530,      (flex_int16_t const   )529,      (flex_int16_t const   )528,      (flex_int16_t const   )527, 
        (flex_int16_t const   )526,      (flex_int16_t const   )525,      (flex_int16_t const   )524,      (flex_int16_t const   )516, 
        (flex_int16_t const   )515,      (flex_int16_t const   )514,      (flex_int16_t const   )513,      (flex_int16_t const   )510, 
        (flex_int16_t const   )509,      (flex_int16_t const   )508,      (flex_int16_t const   )507,      (flex_int16_t const   )506, 
        (flex_int16_t const   )505,      (flex_int16_t const   )504,      (flex_int16_t const   )503,      (flex_int16_t const   )502, 
        (flex_int16_t const   )501,      (flex_int16_t const   )500,      (flex_int16_t const   )499,      (flex_int16_t const   )496, 
        (flex_int16_t const   )495,      (flex_int16_t const   )494,      (flex_int16_t const   )493,      (flex_int16_t const   )492, 
        (flex_int16_t const   )491,      (flex_int16_t const   )490,      (flex_int16_t const   )489,      (flex_int16_t const   )488, 
        (flex_int16_t const   )487,      (flex_int16_t const   )486,      (flex_int16_t const   )485,      (flex_int16_t const   )484, 
        (flex_int16_t const   )483,      (flex_int16_t const   )482,      (flex_int16_t const   )481,      (flex_int16_t const   )480, 
        (flex_int16_t const   )479,      (flex_int16_t const   )478,      (flex_int16_t const   )477,      (flex_int16_t const   )476, 
        (flex_int16_t const   )475,      (flex_int16_t const   )474,      (flex_int16_t const   )473,      (flex_int16_t const   )472, 
        (flex_int16_t const   )471,      (flex_int16_t const   )470,      (flex_int16_t const   )469,      (flex_int16_t const   )468, 
        (flex_int16_t const   )467,      (flex_int16_t const   )466,      (flex_int16_t const   )465,      (flex_int16_t const   )464, 
        (flex_int16_t const   )463,      (flex_int16_t const   )462,      (flex_int16_t const   )461,      (flex_int16_t const   )460, 
        (flex_int16_t const   )459,      (flex_int16_t const   )458,      (flex_int16_t const   )457,      (flex_int16_t const   )456, 
        (flex_int16_t const   )455,      (flex_int16_t const   )454,      (flex_int16_t const   )453,      (flex_int16_t const   )452, 
        (flex_int16_t const   )451,      (flex_int16_t const   )450,      (flex_int16_t const   )449,      (flex_int16_t const   )448, 
        (flex_int16_t const   )447,      (flex_int16_t const   )446,      (flex_int16_t const   )445,      (flex_int16_t const   )444, 
        (flex_int16_t const   )443,      (flex_int16_t const   )442,      (flex_int16_t const   )441,      (flex_int16_t const   )440, 
        (flex_int16_t const   )439,      (flex_int16_t const   )438,      (flex_int16_t const   )437,      (flex_int16_t const   )436, 
        (flex_int16_t const   )435,      (flex_int16_t const   )434,      (flex_int16_t const   )433,      (flex_int16_t const   )432, 
        (flex_int16_t const   )431,      (flex_int16_t const   )430,      (flex_int16_t const   )429,      (flex_int16_t const   )428, 
        (flex_int16_t const   )427,      (flex_int16_t const   )426,      (flex_int16_t const   )421,      (flex_int16_t const   )420, 
        (flex_int16_t const   )419,      (flex_int16_t const   )418,      (flex_int16_t const   )417,      (flex_int16_t const   )416, 
        (flex_int16_t const   )415,      (flex_int16_t const   )414,      (flex_int16_t const   )413,      (flex_int16_t const   )412, 
        (flex_int16_t const   )411,      (flex_int16_t const   )410,      (flex_int16_t const   )409,      (flex_int16_t const   )408, 
        (flex_int16_t const   )407,      (flex_int16_t const   )406,      (flex_int16_t const   )405,      (flex_int16_t const   )404, 
        (flex_int16_t const   )403,      (flex_int16_t const   )402,      (flex_int16_t const   )401,      (flex_int16_t const   )400, 
        (flex_int16_t const   )399,      (flex_int16_t const   )396,      (flex_int16_t const   )395,      (flex_int16_t const   )394, 
        (flex_int16_t const   )393,      (flex_int16_t const   )387,      (flex_int16_t const   )384,      (flex_int16_t const   )383, 
        (flex_int16_t const   )382,      (flex_int16_t const   )381,      (flex_int16_t const   )380,      (flex_int16_t const   )377, 
        (flex_int16_t const   )374,      (flex_int16_t const   )373,      (flex_int16_t const   )372,      (flex_int16_t const   )371, 
        (flex_int16_t const   )370,      (flex_int16_t const   )367,      (flex_int16_t const   )366,      (flex_int16_t const   )365, 
        (flex_int16_t const   )364,      (flex_int16_t const   )361,      (flex_int16_t const   )360,      (flex_int16_t const   )357, 
        (flex_int16_t const   )356,      (flex_int16_t const   )353,      (flex_int16_t const   )352,      (flex_int16_t const   )351, 
        (flex_int16_t const   )350,      (flex_int16_t const   )349,      (flex_int16_t const   )348,      (flex_int16_t const   )347, 
        (flex_int16_t const   )346,      (flex_int16_t const   )345,      (flex_int16_t const   )344,      (flex_int16_t const   )343, 
        (flex_int16_t const   )340,      (flex_int16_t const   )339,      (flex_int16_t const   )336,      (flex_int16_t const   )335, 
        (flex_int16_t const   )334,      (flex_int16_t const   )333,      (flex_int16_t const   )330,      (flex_int16_t const   )329, 
        (flex_int16_t const   )328,      (flex_int16_t const   )327,      (flex_int16_t const   )324,      (flex_int16_t const   )321, 
        (flex_int16_t const   )320,      (flex_int16_t const   )319,      (flex_int16_t const   )318,      (flex_int16_t const   )317, 
        (flex_int16_t const   )316,      (flex_int16_t const   )315,      (flex_int16_t const   )312,      (flex_int16_t const   )311, 
        (flex_int16_t const   )310,      (flex_int16_t const   )309,      (flex_int16_t const   )308,      (flex_int16_t const   )307, 
        (flex_int16_t const   )306,      (flex_int16_t const   )305,      (flex_int16_t const   )304,      (flex_int16_t const   )303, 
        (flex_int16_t const   )302,      (flex_int16_t const   )301,      (flex_int16_t const   )296,      (flex_int16_t const   )295, 
        (flex_int16_t const   )294,      (flex_int16_t const   )293,      (flex_int16_t const   )292,      (flex_int16_t const   )291, 
        (flex_int16_t const   )290,      (flex_int16_t const   )289,      (flex_int16_t const   )288,      (flex_int16_t const   )287, 
        (flex_int16_t const   )286,      (flex_int16_t const   )285,      (flex_int16_t const   )280,      (flex_int16_t const   )279, 
        (flex_int16_t const   )278,      (flex_int16_t const   )274,      (flex_int16_t const   )271,      (flex_int16_t const   )270, 
        (flex_int16_t const   )269,      (flex_int16_t const   )268,      (flex_int16_t const   )267,      (flex_int16_t const   )266, 
        (flex_int16_t const   )265,      (flex_int16_t const   )264,      (flex_int16_t const   )263,      (flex_int16_t const   )262, 
        (flex_int16_t const   )261,      (flex_int16_t const   )260,      (flex_int16_t const   )259,      (flex_int16_t const   )258, 
        (flex_int16_t const   )253,      (flex_int16_t const   )225,      (flex_int16_t const   )219,      (flex_int16_t const   )216, 
        (flex_int16_t const   )191,      (flex_int16_t const   )190,      (flex_int16_t const   )189,      (flex_int16_t const   )186, 
        (flex_int16_t const   )179,      (flex_int16_t const   )178,      (flex_int16_t const   )177,      (flex_int16_t const   )174, 
        (flex_int16_t const   )171,      (flex_int16_t const   )166,      (flex_int16_t const   )165,      (flex_int16_t const   )164, 
        (flex_int16_t const   )163,      (flex_int16_t const   )162,      (flex_int16_t const   )161,      (flex_int16_t const   )160, 
        (flex_int16_t const   )159,      (flex_int16_t const   )158,      (flex_int16_t const   )155,      (flex_int16_t const   )154, 
        (flex_int16_t const   )153,      (flex_int16_t const   )150,      (flex_int16_t const   )123,      (flex_int16_t const   )122, 
        (flex_int16_t const   )119,      (flex_int16_t const   )118,      (flex_int16_t const   )117,      (flex_int16_t const   )114, 
        (flex_int16_t const   )111,      (flex_int16_t const   )108,      (flex_int16_t const   )60,      (flex_int16_t const   )57, 
        (flex_int16_t const   )56,      (flex_int16_t const   )55,      (flex_int16_t const   )54,      (flex_int16_t const   )49, 
        (flex_int16_t const   )900,      (flex_int16_t const   )7,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900};
#line 867 "lexssh.c"
static flex_int16_t const   yy_chk___3[1075]  = 
#line 867
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )3,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )16,      (flex_int16_t const   )5, 
        (flex_int16_t const   )6,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )17, 
        (flex_int16_t const   )22,      (flex_int16_t const   )27,      (flex_int16_t const   )29,      (flex_int16_t const   )17, 
        (flex_int16_t const   )31,      (flex_int16_t const   )22,      (flex_int16_t const   )741,      (flex_int16_t const   )35, 
        (flex_int16_t const   )65,      (flex_int16_t const   )31,      (flex_int16_t const   )50,      (flex_int16_t const   )27, 
        (flex_int16_t const   )29,      (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )54, 
        (flex_int16_t const   )86,      (flex_int16_t const   )65,      (flex_int16_t const   )3,      (flex_int16_t const   )86, 
        (flex_int16_t const   )4,      (flex_int16_t const   )35,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )742,      (flex_int16_t const   )50,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61,      (flex_int16_t const   )61, 
        (flex_int16_t const   )54,      (flex_int16_t const   )77,      (flex_int16_t const   )68,      (flex_int16_t const   )66, 
        (flex_int16_t const   )68,      (flex_int16_t const   )16,      (flex_int16_t const   )24,      (flex_int16_t const   )66, 
        (flex_int16_t const   )77,      (flex_int16_t const   )70,      (flex_int16_t const   )89,      (flex_int16_t const   )89, 
        (flex_int16_t const   )24,      (flex_int16_t const   )70,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )25, 
        (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )84,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )81, 
        (flex_int16_t const   )84,      (flex_int16_t const   )81,      (flex_int16_t const   )74,      (flex_int16_t const   )81, 
        (flex_int16_t const   )83,      (flex_int16_t const   )84,      (flex_int16_t const   )743,      (flex_int16_t const   )83, 
        (flex_int16_t const   )189,      (flex_int16_t const   )87,      (flex_int16_t const   )82,      (flex_int16_t const   )83, 
        (flex_int16_t const   )83,      (flex_int16_t const   )87,      (flex_int16_t const   )83,      (flex_int16_t const   )85, 
        (flex_int16_t const   )100,      (flex_int16_t const   )83,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )100,      (flex_int16_t const   )94,      (flex_int16_t const   )85,      (flex_int16_t const   )83, 
        (flex_int16_t const   )94,      (flex_int16_t const   )189,      (flex_int16_t const   )85,      (flex_int16_t const   )25, 
        (flex_int16_t const   )94,      (flex_int16_t const   )25,      (flex_int16_t const   )101,      (flex_int16_t const   )220, 
        (flex_int16_t const   )220,      (flex_int16_t const   )25,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )91, 
        (flex_int16_t const   )101,      (flex_int16_t const   )91,      (flex_int16_t const   )91,      (flex_int16_t const   )91, 
        (flex_int16_t const   )91,      (flex_int16_t const   )93,      (flex_int16_t const   )96,      (flex_int16_t const   )118, 
        (flex_int16_t const   )96,      (flex_int16_t const   )93,      (flex_int16_t const   )96,      (flex_int16_t const   )96, 
        (flex_int16_t const   )98,      (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )197, 
        (flex_int16_t const   )447,      (flex_int16_t const   )197,      (flex_int16_t const   )93,      (flex_int16_t const   )98, 
        (flex_int16_t const   )98,      (flex_int16_t const   )118,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )93,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41, 
        (flex_int16_t const   )98,      (flex_int16_t const   )179,      (flex_int16_t const   )97,      (flex_int16_t const   )205, 
        (flex_int16_t const   )447,      (flex_int16_t const   )179,      (flex_int16_t const   )41,      (flex_int16_t const   )202, 
        (flex_int16_t const   )97,      (flex_int16_t const   )202,      (flex_int16_t const   )41,      (flex_int16_t const   )217, 
        (flex_int16_t const   )41,      (flex_int16_t const   )97,      (flex_int16_t const   )41,      (flex_int16_t const   )120, 
        (flex_int16_t const   )41,      (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )95,      (flex_int16_t const   )205, 
        (flex_int16_t const   )217,      (flex_int16_t const   )120,      (flex_int16_t const   )95,      (flex_int16_t const   )230, 
        (flex_int16_t const   )120,      (flex_int16_t const   )95,      (flex_int16_t const   )95,      (flex_int16_t const   )230, 
        (flex_int16_t const   )744,      (flex_int16_t const   )95,      (flex_int16_t const   )163,      (flex_int16_t const   )163, 
        (flex_int16_t const   )163,      (flex_int16_t const   )163,      (flex_int16_t const   )95,      (flex_int16_t const   )95, 
        (flex_int16_t const   )126,      (flex_int16_t const   )126,      (flex_int16_t const   )126,      (flex_int16_t const   )126, 
        (flex_int16_t const   )126,      (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )745, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )139, 
        (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )139, 
        (flex_int16_t const   )192,      (flex_int16_t const   )45,      (flex_int16_t const   )223,      (flex_int16_t const   )238, 
        (flex_int16_t const   )240,      (flex_int16_t const   )45,      (flex_int16_t const   )253,      (flex_int16_t const   )45, 
        (flex_int16_t const   )238,      (flex_int16_t const   )45,      (flex_int16_t const   )192,      (flex_int16_t const   )45, 
        (flex_int16_t const   )223,      (flex_int16_t const   )240,      (flex_int16_t const   )246,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )489,      (flex_int16_t const   )376,      (flex_int16_t const   )246, 
        (flex_int16_t const   )394,      (flex_int16_t const   )747,      (flex_int16_t const   )394,      (flex_int16_t const   )253, 
        (flex_int16_t const   )748,      (flex_int16_t const   )248,      (flex_int16_t const   )489,      (flex_int16_t const   )749, 
        (flex_int16_t const   )248,      (flex_int16_t const   )376,      (flex_int16_t const   )248,      (flex_int16_t const   )281, 
        (flex_int16_t const   )281,      (flex_int16_t const   )281,      (flex_int16_t const   )281,      (flex_int16_t const   )281, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )399,      (flex_int16_t const   )431,      (flex_int16_t const   )431, 
        (flex_int16_t const   )431,      (flex_int16_t const   )431,      (flex_int16_t const   )520,      (flex_int16_t const   )520, 
        (flex_int16_t const   )399,      (flex_int16_t const   )399,      (flex_int16_t const   )486,      (flex_int16_t const   )750, 
        (flex_int16_t const   )523,      (flex_int16_t const   )753,      (flex_int16_t const   )754,      (flex_int16_t const   )755, 
        (flex_int16_t const   )756,      (flex_int16_t const   )757,      (flex_int16_t const   )758,      (flex_int16_t const   )759, 
        (flex_int16_t const   )399,      (flex_int16_t const   )523,      (flex_int16_t const   )399,      (flex_int16_t const   )399, 
        (flex_int16_t const   )399,      (flex_int16_t const   )760,      (flex_int16_t const   )486,      (flex_int16_t const   )761, 
        (flex_int16_t const   )764,      (flex_int16_t const   )765,      (flex_int16_t const   )766,      (flex_int16_t const   )767, 
        (flex_int16_t const   )768,      (flex_int16_t const   )769,      (flex_int16_t const   )770,      (flex_int16_t const   )771, 
        (flex_int16_t const   )772,      (flex_int16_t const   )773,      (flex_int16_t const   )774,      (flex_int16_t const   )775, 
        (flex_int16_t const   )777,      (flex_int16_t const   )780,      (flex_int16_t const   )781,      (flex_int16_t const   )782, 
        (flex_int16_t const   )784,      (flex_int16_t const   )785,      (flex_int16_t const   )786,      (flex_int16_t const   )787, 
        (flex_int16_t const   )788,      (flex_int16_t const   )789,      (flex_int16_t const   )790,      (flex_int16_t const   )792, 
        (flex_int16_t const   )793,      (flex_int16_t const   )794,      (flex_int16_t const   )796,      (flex_int16_t const   )797, 
        (flex_int16_t const   )798,      (flex_int16_t const   )799,      (flex_int16_t const   )800,      (flex_int16_t const   )802, 
        (flex_int16_t const   )803,      (flex_int16_t const   )807,      (flex_int16_t const   )808,      (flex_int16_t const   )809, 
        (flex_int16_t const   )810,      (flex_int16_t const   )811,      (flex_int16_t const   )812,      (flex_int16_t const   )815, 
        (flex_int16_t const   )818,      (flex_int16_t const   )819,      (flex_int16_t const   )820,      (flex_int16_t const   )824, 
        (flex_int16_t const   )825,      (flex_int16_t const   )826,      (flex_int16_t const   )829,      (flex_int16_t const   )830, 
        (flex_int16_t const   )831,      (flex_int16_t const   )833,      (flex_int16_t const   )837,      (flex_int16_t const   )838, 
        (flex_int16_t const   )840,      (flex_int16_t const   )844,      (flex_int16_t const   )845,      (flex_int16_t const   )846, 
        (flex_int16_t const   )847,      (flex_int16_t const   )848,      (flex_int16_t const   )849,      (flex_int16_t const   )851, 
        (flex_int16_t const   )852,      (flex_int16_t const   )853,      (flex_int16_t const   )854,      (flex_int16_t const   )855, 
        (flex_int16_t const   )857,      (flex_int16_t const   )858,      (flex_int16_t const   )859,      (flex_int16_t const   )863, 
        (flex_int16_t const   )864,      (flex_int16_t const   )865,      (flex_int16_t const   )866,      (flex_int16_t const   )867, 
        (flex_int16_t const   )869,      (flex_int16_t const   )870,      (flex_int16_t const   )872,      (flex_int16_t const   )873, 
        (flex_int16_t const   )875,      (flex_int16_t const   )876,      (flex_int16_t const   )877,      (flex_int16_t const   )879, 
        (flex_int16_t const   )880,      (flex_int16_t const   )881,      (flex_int16_t const   )882,      (flex_int16_t const   )883, 
        (flex_int16_t const   )884,      (flex_int16_t const   )885,      (flex_int16_t const   )887,      (flex_int16_t const   )892, 
        (flex_int16_t const   )893,      (flex_int16_t const   )894,      (flex_int16_t const   )895,      (flex_int16_t const   )901, 
        (flex_int16_t const   )901,      (flex_int16_t const   )901,      (flex_int16_t const   )901,      (flex_int16_t const   )901, 
        (flex_int16_t const   )901,      (flex_int16_t const   )901,      (flex_int16_t const   )902,      (flex_int16_t const   )902, 
        (flex_int16_t const   )902,      (flex_int16_t const   )902,      (flex_int16_t const   )902,      (flex_int16_t const   )902, 
        (flex_int16_t const   )902,      (flex_int16_t const   )903,      (flex_int16_t const   )909,      (flex_int16_t const   )910, 
        (flex_int16_t const   )911,      (flex_int16_t const   )912,      (flex_int16_t const   )903,      (flex_int16_t const   )903, 
        (flex_int16_t const   )904,      (flex_int16_t const   )904,      (flex_int16_t const   )740,      (flex_int16_t const   )904, 
        (flex_int16_t const   )904,      (flex_int16_t const   )904,      (flex_int16_t const   )904,      (flex_int16_t const   )905, 
        (flex_int16_t const   )905,      (flex_int16_t const   )737,      (flex_int16_t const   )735,      (flex_int16_t const   )905, 
        (flex_int16_t const   )905,      (flex_int16_t const   )906,      (flex_int16_t const   )906,      (flex_int16_t const   )734, 
        (flex_int16_t const   )906,      (flex_int16_t const   )906,      (flex_int16_t const   )906,      (flex_int16_t const   )906, 
        (flex_int16_t const   )907,      (flex_int16_t const   )907,      (flex_int16_t const   )732,      (flex_int16_t const   )907, 
        (flex_int16_t const   )731,      (flex_int16_t const   )907,      (flex_int16_t const   )908,      (flex_int16_t const   )908, 
        (flex_int16_t const   )730,      (flex_int16_t const   )908,      (flex_int16_t const   )908,      (flex_int16_t const   )908, 
        (flex_int16_t const   )908,      (flex_int16_t const   )729,      (flex_int16_t const   )727,      (flex_int16_t const   )723, 
        (flex_int16_t const   )722,      (flex_int16_t const   )721,      (flex_int16_t const   )720,      (flex_int16_t const   )719, 
        (flex_int16_t const   )718,      (flex_int16_t const   )717,      (flex_int16_t const   )716,      (flex_int16_t const   )715, 
        (flex_int16_t const   )713,      (flex_int16_t const   )712,      (flex_int16_t const   )711,      (flex_int16_t const   )710, 
        (flex_int16_t const   )709,      (flex_int16_t const   )708,      (flex_int16_t const   )706,      (flex_int16_t const   )705, 
        (flex_int16_t const   )704,      (flex_int16_t const   )703,      (flex_int16_t const   )702,      (flex_int16_t const   )701, 
        (flex_int16_t const   )700,      (flex_int16_t const   )699,      (flex_int16_t const   )698,      (flex_int16_t const   )697, 
        (flex_int16_t const   )696,      (flex_int16_t const   )695,      (flex_int16_t const   )693,      (flex_int16_t const   )691, 
        (flex_int16_t const   )689,      (flex_int16_t const   )687,      (flex_int16_t const   )686,      (flex_int16_t const   )683, 
        (flex_int16_t const   )682,      (flex_int16_t const   )679,      (flex_int16_t const   )675,      (flex_int16_t const   )674, 
        (flex_int16_t const   )673,      (flex_int16_t const   )672,      (flex_int16_t const   )671,      (flex_int16_t const   )670, 
        (flex_int16_t const   )669,      (flex_int16_t const   )666,      (flex_int16_t const   )665,      (flex_int16_t const   )664, 
        (flex_int16_t const   )663,      (flex_int16_t const   )662,      (flex_int16_t const   )661,      (flex_int16_t const   )659, 
        (flex_int16_t const   )658,      (flex_int16_t const   )657,      (flex_int16_t const   )656,      (flex_int16_t const   )655, 
        (flex_int16_t const   )654,      (flex_int16_t const   )653,      (flex_int16_t const   )652,      (flex_int16_t const   )651, 
        (flex_int16_t const   )650,      (flex_int16_t const   )649,      (flex_int16_t const   )648,      (flex_int16_t const   )646, 
        (flex_int16_t const   )645,      (flex_int16_t const   )644,      (flex_int16_t const   )643,      (flex_int16_t const   )642, 
        (flex_int16_t const   )641,      (flex_int16_t const   )640,      (flex_int16_t const   )639,      (flex_int16_t const   )638, 
        (flex_int16_t const   )637,      (flex_int16_t const   )635,      (flex_int16_t const   )634,      (flex_int16_t const   )633, 
        (flex_int16_t const   )632,      (flex_int16_t const   )630,      (flex_int16_t const   )629,      (flex_int16_t const   )628, 
        (flex_int16_t const   )627,      (flex_int16_t const   )626,      (flex_int16_t const   )625,      (flex_int16_t const   )624, 
        (flex_int16_t const   )621,      (flex_int16_t const   )620,      (flex_int16_t const   )619,      (flex_int16_t const   )618, 
        (flex_int16_t const   )617,      (flex_int16_t const   )615,      (flex_int16_t const   )614,      (flex_int16_t const   )613, 
        (flex_int16_t const   )611,      (flex_int16_t const   )610,      (flex_int16_t const   )609,      (flex_int16_t const   )607, 
        (flex_int16_t const   )606,      (flex_int16_t const   )604,      (flex_int16_t const   )602,      (flex_int16_t const   )601, 
        (flex_int16_t const   )599,      (flex_int16_t const   )598,      (flex_int16_t const   )597,      (flex_int16_t const   )594, 
        (flex_int16_t const   )593,      (flex_int16_t const   )590,      (flex_int16_t const   )588,      (flex_int16_t const   )587, 
        (flex_int16_t const   )586,      (flex_int16_t const   )584,      (flex_int16_t const   )583,      (flex_int16_t const   )582, 
        (flex_int16_t const   )581,      (flex_int16_t const   )579,      (flex_int16_t const   )578,      (flex_int16_t const   )577, 
        (flex_int16_t const   )576,      (flex_int16_t const   )575,      (flex_int16_t const   )571,      (flex_int16_t const   )570, 
        (flex_int16_t const   )567,      (flex_int16_t const   )566,      (flex_int16_t const   )564,      (flex_int16_t const   )563, 
        (flex_int16_t const   )562,      (flex_int16_t const   )559,      (flex_int16_t const   )558,      (flex_int16_t const   )553, 
        (flex_int16_t const   )552,      (flex_int16_t const   )551,      (flex_int16_t const   )546,      (flex_int16_t const   )545, 
        (flex_int16_t const   )544,      (flex_int16_t const   )542,      (flex_int16_t const   )541,      (flex_int16_t const   )539, 
        (flex_int16_t const   )538,      (flex_int16_t const   )537,      (flex_int16_t const   )536,      (flex_int16_t const   )535, 
        (flex_int16_t const   )534,      (flex_int16_t const   )533,      (flex_int16_t const   )532,      (flex_int16_t const   )530, 
        (flex_int16_t const   )529,      (flex_int16_t const   )528,      (flex_int16_t const   )527,      (flex_int16_t const   )526, 
        (flex_int16_t const   )524,      (flex_int16_t const   )522,      (flex_int16_t const   )521,      (flex_int16_t const   )519, 
        (flex_int16_t const   )518,      (flex_int16_t const   )517,      (flex_int16_t const   )516,      (flex_int16_t const   )515, 
        (flex_int16_t const   )514,      (flex_int16_t const   )513,      (flex_int16_t const   )512,      (flex_int16_t const   )511, 
        (flex_int16_t const   )509,      (flex_int16_t const   )508,      (flex_int16_t const   )507,      (flex_int16_t const   )506, 
        (flex_int16_t const   )505,      (flex_int16_t const   )504,      (flex_int16_t const   )503,      (flex_int16_t const   )502, 
        (flex_int16_t const   )501,      (flex_int16_t const   )500,      (flex_int16_t const   )499,      (flex_int16_t const   )498, 
        (flex_int16_t const   )496,      (flex_int16_t const   )494,      (flex_int16_t const   )493,      (flex_int16_t const   )492, 
        (flex_int16_t const   )491,      (flex_int16_t const   )490,      (flex_int16_t const   )488,      (flex_int16_t const   )487, 
        (flex_int16_t const   )485,      (flex_int16_t const   )484,      (flex_int16_t const   )483,      (flex_int16_t const   )482, 
        (flex_int16_t const   )481,      (flex_int16_t const   )479,      (flex_int16_t const   )478,      (flex_int16_t const   )477, 
        (flex_int16_t const   )476,      (flex_int16_t const   )475,      (flex_int16_t const   )474,      (flex_int16_t const   )473, 
        (flex_int16_t const   )472,      (flex_int16_t const   )471,      (flex_int16_t const   )470,      (flex_int16_t const   )469, 
        (flex_int16_t const   )468,      (flex_int16_t const   )467,      (flex_int16_t const   )465,      (flex_int16_t const   )462, 
        (flex_int16_t const   )461,      (flex_int16_t const   )459,      (flex_int16_t const   )458,      (flex_int16_t const   )457, 
        (flex_int16_t const   )456,      (flex_int16_t const   )454,      (flex_int16_t const   )453,      (flex_int16_t const   )452, 
        (flex_int16_t const   )451,      (flex_int16_t const   )450,      (flex_int16_t const   )449,      (flex_int16_t const   )448, 
        (flex_int16_t const   )446,      (flex_int16_t const   )445,      (flex_int16_t const   )443,      (flex_int16_t const   )442, 
        (flex_int16_t const   )441,      (flex_int16_t const   )440,      (flex_int16_t const   )438,      (flex_int16_t const   )437, 
        (flex_int16_t const   )436,      (flex_int16_t const   )434,      (flex_int16_t const   )433,      (flex_int16_t const   )432, 
        (flex_int16_t const   )429,      (flex_int16_t const   )428,      (flex_int16_t const   )427,      (flex_int16_t const   )426, 
        (flex_int16_t const   )421,      (flex_int16_t const   )420,      (flex_int16_t const   )419,      (flex_int16_t const   )418, 
        (flex_int16_t const   )417,      (flex_int16_t const   )416,      (flex_int16_t const   )415,      (flex_int16_t const   )414, 
        (flex_int16_t const   )413,      (flex_int16_t const   )412,      (flex_int16_t const   )411,      (flex_int16_t const   )410, 
        (flex_int16_t const   )409,      (flex_int16_t const   )408,      (flex_int16_t const   )407,      (flex_int16_t const   )405, 
        (flex_int16_t const   )404,      (flex_int16_t const   )402,      (flex_int16_t const   )401,      (flex_int16_t const   )398, 
        (flex_int16_t const   )397,      (flex_int16_t const   )396,      (flex_int16_t const   )395,      (flex_int16_t const   )392, 
        (flex_int16_t const   )391,      (flex_int16_t const   )389,      (flex_int16_t const   )388,      (flex_int16_t const   )387, 
        (flex_int16_t const   )385,      (flex_int16_t const   )384,      (flex_int16_t const   )382,      (flex_int16_t const   )381, 
        (flex_int16_t const   )380,      (flex_int16_t const   )379,      (flex_int16_t const   )378,      (flex_int16_t const   )375, 
        (flex_int16_t const   )373,      (flex_int16_t const   )372,      (flex_int16_t const   )371,      (flex_int16_t const   )370, 
        (flex_int16_t const   )369,      (flex_int16_t const   )368,      (flex_int16_t const   )367,      (flex_int16_t const   )365, 
        (flex_int16_t const   )364,      (flex_int16_t const   )362,      (flex_int16_t const   )361,      (flex_int16_t const   )360, 
        (flex_int16_t const   )359,      (flex_int16_t const   )358,      (flex_int16_t const   )357,      (flex_int16_t const   )356, 
        (flex_int16_t const   )354,      (flex_int16_t const   )353,      (flex_int16_t const   )351,      (flex_int16_t const   )350, 
        (flex_int16_t const   )349,      (flex_int16_t const   )348,      (flex_int16_t const   )346,      (flex_int16_t const   )345, 
        (flex_int16_t const   )344,      (flex_int16_t const   )343,      (flex_int16_t const   )341,      (flex_int16_t const   )340, 
        (flex_int16_t const   )338,      (flex_int16_t const   )337,      (flex_int16_t const   )336,      (flex_int16_t const   )335, 
        (flex_int16_t const   )333,      (flex_int16_t const   )332,      (flex_int16_t const   )330,      (flex_int16_t const   )329, 
        (flex_int16_t const   )328,      (flex_int16_t const   )327,      (flex_int16_t const   )326,      (flex_int16_t const   )325, 
        (flex_int16_t const   )324,      (flex_int16_t const   )323,      (flex_int16_t const   )322,      (flex_int16_t const   )321, 
        (flex_int16_t const   )319,      (flex_int16_t const   )318,      (flex_int16_t const   )314,      (flex_int16_t const   )313, 
        (flex_int16_t const   )312,      (flex_int16_t const   )311,      (flex_int16_t const   )310,      (flex_int16_t const   )309, 
        (flex_int16_t const   )308,      (flex_int16_t const   )306,      (flex_int16_t const   )305,      (flex_int16_t const   )304, 
        (flex_int16_t const   )302,      (flex_int16_t const   )301,      (flex_int16_t const   )296,      (flex_int16_t const   )295, 
        (flex_int16_t const   )294,      (flex_int16_t const   )293,      (flex_int16_t const   )292,      (flex_int16_t const   )291, 
        (flex_int16_t const   )290,      (flex_int16_t const   )289,      (flex_int16_t const   )288,      (flex_int16_t const   )287, 
        (flex_int16_t const   )286,      (flex_int16_t const   )285,      (flex_int16_t const   )280,      (flex_int16_t const   )279, 
        (flex_int16_t const   )278,      (flex_int16_t const   )277,      (flex_int16_t const   )276,      (flex_int16_t const   )275, 
        (flex_int16_t const   )274,      (flex_int16_t const   )273,      (flex_int16_t const   )272,      (flex_int16_t const   )271, 
        (flex_int16_t const   )270,      (flex_int16_t const   )269,      (flex_int16_t const   )268,      (flex_int16_t const   )266, 
        (flex_int16_t const   )265,      (flex_int16_t const   )264,      (flex_int16_t const   )262,      (flex_int16_t const   )261, 
        (flex_int16_t const   )260,      (flex_int16_t const   )259,      (flex_int16_t const   )256,      (flex_int16_t const   )255, 
        (flex_int16_t const   )254,      (flex_int16_t const   )252,      (flex_int16_t const   )251,      (flex_int16_t const   )250, 
        (flex_int16_t const   )249,      (flex_int16_t const   )247,      (flex_int16_t const   )245,      (flex_int16_t const   )244, 
        (flex_int16_t const   )243,      (flex_int16_t const   )242,      (flex_int16_t const   )241,      (flex_int16_t const   )239, 
        (flex_int16_t const   )235,      (flex_int16_t const   )234,      (flex_int16_t const   )233,      (flex_int16_t const   )232, 
        (flex_int16_t const   )231,      (flex_int16_t const   )228,      (flex_int16_t const   )227,      (flex_int16_t const   )226, 
        (flex_int16_t const   )224,      (flex_int16_t const   )222,      (flex_int16_t const   )221,      (flex_int16_t const   )219, 
        (flex_int16_t const   )218,      (flex_int16_t const   )216,      (flex_int16_t const   )215,      (flex_int16_t const   )214, 
        (flex_int16_t const   )213,      (flex_int16_t const   )212,      (flex_int16_t const   )211,      (flex_int16_t const   )210, 
        (flex_int16_t const   )209,      (flex_int16_t const   )208,      (flex_int16_t const   )207,      (flex_int16_t const   )206, 
        (flex_int16_t const   )204,      (flex_int16_t const   )203,      (flex_int16_t const   )201,      (flex_int16_t const   )200, 
        (flex_int16_t const   )199,      (flex_int16_t const   )198,      (flex_int16_t const   )196,      (flex_int16_t const   )195, 
        (flex_int16_t const   )194,      (flex_int16_t const   )193,      (flex_int16_t const   )191,      (flex_int16_t const   )188, 
        (flex_int16_t const   )187,      (flex_int16_t const   )186,      (flex_int16_t const   )185,      (flex_int16_t const   )184, 
        (flex_int16_t const   )182,      (flex_int16_t const   )180,      (flex_int16_t const   )176,      (flex_int16_t const   )175, 
        (flex_int16_t const   )174,      (flex_int16_t const   )173,      (flex_int16_t const   )171,      (flex_int16_t const   )170, 
        (flex_int16_t const   )169,      (flex_int16_t const   )168,      (flex_int16_t const   )167,      (flex_int16_t const   )166, 
        (flex_int16_t const   )165,      (flex_int16_t const   )164,      (flex_int16_t const   )162,      (flex_int16_t const   )161, 
        (flex_int16_t const   )160,      (flex_int16_t const   )159,      (flex_int16_t const   )158,      (flex_int16_t const   )157, 
        (flex_int16_t const   )156,      (flex_int16_t const   )155,      (flex_int16_t const   )154,      (flex_int16_t const   )153, 
        (flex_int16_t const   )152,      (flex_int16_t const   )151,      (flex_int16_t const   )123,      (flex_int16_t const   )122, 
        (flex_int16_t const   )121,      (flex_int16_t const   )119,      (flex_int16_t const   )117,      (flex_int16_t const   )115, 
        (flex_int16_t const   )114,      (flex_int16_t const   )113,      (flex_int16_t const   )112,      (flex_int16_t const   )111, 
        (flex_int16_t const   )110,      (flex_int16_t const   )109,      (flex_int16_t const   )107,      (flex_int16_t const   )106, 
        (flex_int16_t const   )105,      (flex_int16_t const   )104,      (flex_int16_t const   )103,      (flex_int16_t const   )102, 
        (flex_int16_t const   )99,      (flex_int16_t const   )92,      (flex_int16_t const   )90,      (flex_int16_t const   )88, 
        (flex_int16_t const   )80,      (flex_int16_t const   )79,      (flex_int16_t const   )78,      (flex_int16_t const   )76, 
        (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )71,      (flex_int16_t const   )69, 
        (flex_int16_t const   )67,      (flex_int16_t const   )64,      (flex_int16_t const   )63,      (flex_int16_t const   )62, 
        (flex_int16_t const   )60,      (flex_int16_t const   )59,      (flex_int16_t const   )58,      (flex_int16_t const   )57, 
        (flex_int16_t const   )56,      (flex_int16_t const   )55,      (flex_int16_t const   )53,      (flex_int16_t const   )52, 
        (flex_int16_t const   )51,      (flex_int16_t const   )49,      (flex_int16_t const   )37,      (flex_int16_t const   )36, 
        (flex_int16_t const   )34,      (flex_int16_t const   )33,      (flex_int16_t const   )32,      (flex_int16_t const   )30, 
        (flex_int16_t const   )28,      (flex_int16_t const   )26,      (flex_int16_t const   )23,      (flex_int16_t const   )21, 
        (flex_int16_t const   )20,      (flex_int16_t const   )19,      (flex_int16_t const   )18,      (flex_int16_t const   )14, 
        (flex_int16_t const   )7,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900, 
        (flex_int16_t const   )900,      (flex_int16_t const   )900,      (flex_int16_t const   )900};
#line 990 "lexssh.c"
static flex_int32_t const   yy_rule_can_match_eol___2[218]  = 
#line 990
  {      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )1, 
        (flex_int32_t const   )0,      (flex_int32_t const   )0};
#line 1004 "lexssh.c"
static yy_state_type yy_last_accepting_state___3  ;
#line 1005 "lexssh.c"
static char *yy_last_accepting_cpos___3  ;
#line 1007
int ssh_flex_debug ;
#line 1008 "lexssh.c"
int ssh_flex_debug  =    0;
#line 139 "parsessh.h"
YYSTYPE___0 sshlval ;
#line 40 "lexssh.l"
int strip_level ;
#line 44
int sshlex(void) ;
#line 45
void ssherror(char const   *msg ) ;
#line 48
void sshlex_initialize(void) ;
#line 51 "lexssh.l"
static struct obstack string_stack___1  ;
#line 54 "lexssh.l"
char const   *sshfilename  ;
#line 1102 "lexssh.c"
static int yy_init_globals___3(void) ;
#line 1112
int sshwrap(void) ;
#line 1233 "lexssh.c"
int sshlex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  int yyl ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  char *tmp___105 ;
  char *tmp___106 ;
  char *tmp___107 ;
  char *tmp___108 ;
  char *tmp___109 ;
  char *tmp___110 ;
  char *tmp___111 ;
  char *tmp___112 ;
  char *tmp___113 ;
  char *tmp___114 ;
  char *tmp___115 ;
  char *tmp___116 ;
  char *tmp___117 ;
  char *tmp___118 ;
  char *tmp___119 ;
  char *tmp___120 ;
  char *tmp___121 ;
  char *tmp___122 ;
  char *tmp___123 ;
  char *tmp___124 ;
  char *tmp___125 ;
  char *tmp___126 ;
  char *tmp___127 ;
  char *tmp___128 ;
  char *tmp___129 ;
  char *tmp___130 ;
  char *tmp___131 ;
  int value ;
  char *cursor ;
  char *tmp___132 ;
  char *tmp___133 ;
  unsigned char *string ;
  struct obstack *__o ;
  char *tmp___134 ;
  struct obstack *__o1 ;
  void *value___0 ;
  struct obstack *__o___0 ;
  void *__obj ;
  char *tmp___135 ;
  char *tmp___136 ;
  int value___1 ;
  char *cursor___0 ;
  char *tmp___137 ;
  struct obstack *__o___1 ;
  char *tmp___138 ;
  int value___2 ;
  char *cursor___1 ;
  char *tmp___139 ;
  char *tmp___140 ;
  char *tmp___141 ;
  struct obstack *__o___2 ;
  char *tmp___142 ;
  struct obstack *__o___3 ;
  char *tmp___143 ;
  struct obstack *__o___4 ;
  char *tmp___144 ;
  struct obstack *__o___5 ;
  char *tmp___145 ;
  struct obstack *__o___6 ;
  char *tmp___146 ;
  struct obstack *__o___7 ;
  char *tmp___147 ;
  struct obstack *__o___8 ;
  char *tmp___148 ;
  struct obstack *__o___9 ;
  char *tmp___149 ;
  struct obstack *__o___10 ;
  char *tmp___150 ;
  struct obstack *__o___11 ;
  char *tmp___151 ;
  struct obstack *__o___12 ;
  char *tmp___152 ;
  char *tmp___153 ;
  struct obstack *__o___13 ;
  int __len ;
  char *pattern ;
  int pattern_len ;
  struct obstack *__o___14 ;
  char *tmp___154 ;
  struct obstack *__o___15 ;
  struct obstack *__o1___0 ;
  void *value___3 ;
  struct obstack *__o___16 ;
  void *__obj___0 ;
  char *tmp___155 ;
  void *tmp___156 ;
  void *tmp___157 ;
  int value___4 ;
  char *cursor___2 ;
  char *tmp___158 ;
  struct obstack *__o___17 ;
  char *tmp___159 ;
  int value___5 ;
  char *cursor___3 ;
  char *tmp___160 ;
  char *tmp___161 ;
  char *tmp___162 ;
  struct obstack *__o___18 ;
  char *tmp___163 ;
  struct obstack *__o___19 ;
  char *tmp___164 ;
  struct obstack *__o___20 ;
  char *tmp___165 ;
  struct obstack *__o___21 ;
  char *tmp___166 ;
  struct obstack *__o___22 ;
  char *tmp___167 ;
  struct obstack *__o___23 ;
  char *tmp___168 ;
  struct obstack *__o___24 ;
  char *tmp___169 ;
  struct obstack *__o___25 ;
  char *tmp___170 ;
  struct obstack *__o___26 ;
  char *tmp___171 ;
  struct obstack *__o___27 ;
  char *tmp___172 ;
  struct obstack *__o___28 ;
  char *tmp___173 ;
  char *tmp___174 ;
  struct obstack *__o___29 ;
  int __len___0 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___175 ;
  int tmp___176 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;
  char *__cil_tmp273 ;
  char *__cil_tmp274 ;
  char *__cil_tmp275 ;
  char *__cil_tmp276 ;
  char *__cil_tmp277 ;
  char *__cil_tmp278 ;
  char *__cil_tmp279 ;
  char *__cil_tmp280 ;
  char *__cil_tmp281 ;
  char *__cil_tmp282 ;
  char *__cil_tmp283 ;
  char *__cil_tmp284 ;
  char *__cil_tmp285 ;
  char *__cil_tmp286 ;
  char *__cil_tmp287 ;
  char *__cil_tmp288 ;
  char *__cil_tmp289 ;
  char *__cil_tmp290 ;
  char *__cil_tmp291 ;
  char *__cil_tmp292 ;
  char *__cil_tmp293 ;
  char *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;

  {
#line 1244
  if (! yy_init___3) {
#line 1246
    yy_init___3 = 1;
#line 1252
    if (! yy_start___3) {
#line 1253
      yy_start___3 = 1;
    }
#line 1255
    if (! sshin) {
#line 1256
      sshin = stdin;
    }
#line 1258
    if (! sshout) {
#line 1259
      sshout = stdout;
    }
#line 1261
    if (yy_buffer_stack___3) {
#line 1261
      tmp = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
    } else {
#line 1261
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1261
    if (! tmp) {
      {
#line 1262
      sshensure_buffer_stack();
#line 1263
      *(yy_buffer_stack___3 + yy_buffer_stack_top___3) = ssh_create_buffer(sshin,
                                                                           16384);
      }
    }
    {
#line 1267
    ssh_load_buffer_state();
    }
  }
  {
#line 1270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1272
    yy_cp = yy_c_buf_p___3;
#line 1275
    *yy_cp = yy_hold_char___3;
#line 1280
    yy_bp = yy_cp;
#line 1282
    yy_current_state = yy_start___3;
    yy_match: 
    {
#line 1284
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1286
      yy_c = (YY_CHAR )yy_ec___3[(unsigned int )((unsigned char )*yy_cp)];
#line 1287
      if (yy_accept___3[yy_current_state]) {
#line 1289
        yy_last_accepting_state___3 = yy_current_state;
#line 1290
        yy_last_accepting_cpos___3 = yy_cp;
      }
      {
#line 1292
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1292
        if (! ((int const   )yy_chk___3[(int const   )yy_base___3[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1292
          goto while_break___1;
        }
#line 1294
        yy_current_state = (int )yy_def___3[yy_current_state];
#line 1295
        if (yy_current_state >= 901) {
#line 1296
          yy_c = (YY_CHAR )yy_meta___3[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1298
      yy_current_state = (yy_state_type )yy_nxt___3[(unsigned int )yy_base___3[yy_current_state] + (unsigned int )yy_c];
#line 1299
      yy_cp ++;
#line 1284
      if (! ((int const   )yy_base___3[yy_current_state] != 1013)) {
#line 1284
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 1304
    yy_act = (int )yy_accept___3[yy_current_state];
#line 1305
    if (yy_act == 0) {
#line 1307
      yy_cp = yy_last_accepting_cpos___3;
#line 1308
      yy_current_state = yy_last_accepting_state___3;
#line 1309
      yy_act = (int )yy_accept___3[yy_current_state];
    }
#line 1312
    sshtext = yy_bp;
#line 1312
    sshleng = (int )((size_t )(yy_cp - yy_bp));
#line 1312
    yy_hold_char___3 = *yy_cp;
#line 1312
    *yy_cp = (char )'\000';
#line 1312
    yy_c_buf_p___3 = yy_cp;
#line 1314
    if (yy_act != 218) {
#line 1314
      if (yy_rule_can_match_eol___2[yy_act]) {
#line 1317
        yyl = 0;
        {
#line 1317
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1317
          if (! (yyl < sshleng)) {
#line 1317
            goto while_break___2;
          }
#line 1318
          if ((int )*(sshtext + yyl) == 10) {
#line 1320
            sshlineno ++;
          }
#line 1317
          yyl ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
    do_action: 
    {
#line 1328
    if (yy_act == 0) {
#line 1328
      goto case_0;
    }
#line 1335
    if (yy_act == 1) {
#line 1335
      goto case_1;
    }
#line 82
    if (yy_act == 2) {
#line 82 "lexssh.l"
      goto case_2;
    }
#line 83
    if (yy_act == 3) {
#line 83
      goto case_3;
    }
#line 85
    if (yy_act == 4) {
#line 85
      goto case_4;
    }
#line 86
    if (yy_act == 5) {
#line 86
      goto case_5;
    }
#line 88
    if (yy_act == 6) {
#line 88
      goto case_6;
    }
#line 89
    if (yy_act == 7) {
#line 89
      goto case_7;
    }
#line 90
    if (yy_act == 8) {
#line 90
      goto case_8;
    }
#line 91
    if (yy_act == 9) {
#line 91
      goto case_9;
    }
#line 92
    if (yy_act == 10) {
#line 92
      goto case_10;
    }
#line 93
    if (yy_act == 11) {
#line 93
      goto case_11;
    }
#line 94
    if (yy_act == 12) {
#line 94
      goto case_12;
    }
#line 95
    if (yy_act == 13) {
#line 95
      goto case_13;
    }
#line 96
    if (yy_act == 14) {
#line 96
      goto case_14;
    }
#line 97
    if (yy_act == 15) {
#line 97
      goto case_15;
    }
#line 98
    if (yy_act == 16) {
#line 98
      goto case_16;
    }
#line 99
    if (yy_act == 17) {
#line 99
      goto case_17;
    }
#line 100
    if (yy_act == 18) {
#line 100
      goto case_18;
    }
#line 101
    if (yy_act == 19) {
#line 101
      goto case_19;
    }
#line 102
    if (yy_act == 20) {
#line 102
      goto case_20;
    }
#line 103
    if (yy_act == 21) {
#line 103
      goto case_21;
    }
#line 104
    if (yy_act == 22) {
#line 104
      goto case_22;
    }
#line 105
    if (yy_act == 23) {
#line 105
      goto case_23;
    }
#line 106
    if (yy_act == 24) {
#line 106
      goto case_24;
    }
#line 107
    if (yy_act == 25) {
#line 107
      goto case_25;
    }
#line 108
    if (yy_act == 26) {
#line 108
      goto case_26;
    }
#line 109
    if (yy_act == 27) {
#line 109
      goto case_27;
    }
#line 110
    if (yy_act == 28) {
#line 110
      goto case_28;
    }
#line 111
    if (yy_act == 29) {
#line 111
      goto case_29;
    }
#line 112
    if (yy_act == 30) {
#line 112
      goto case_30;
    }
#line 113
    if (yy_act == 31) {
#line 113
      goto case_31;
    }
#line 114
    if (yy_act == 32) {
#line 114
      goto case_32;
    }
#line 115
    if (yy_act == 33) {
#line 115
      goto case_33;
    }
#line 116
    if (yy_act == 34) {
#line 116
      goto case_34;
    }
#line 117
    if (yy_act == 35) {
#line 117
      goto case_35;
    }
#line 118
    if (yy_act == 36) {
#line 118
      goto case_36;
    }
#line 119
    if (yy_act == 37) {
#line 119
      goto case_37;
    }
#line 120
    if (yy_act == 38) {
#line 120
      goto case_38;
    }
#line 121
    if (yy_act == 39) {
#line 121
      goto case_39;
    }
#line 122
    if (yy_act == 40) {
#line 122
      goto case_40;
    }
#line 123
    if (yy_act == 41) {
#line 123
      goto case_41;
    }
#line 124
    if (yy_act == 42) {
#line 124
      goto case_42;
    }
#line 125
    if (yy_act == 43) {
#line 125
      goto case_43;
    }
#line 126
    if (yy_act == 44) {
#line 126
      goto case_44;
    }
#line 127
    if (yy_act == 45) {
#line 127
      goto case_45;
    }
#line 128
    if (yy_act == 46) {
#line 128
      goto case_46;
    }
#line 129
    if (yy_act == 47) {
#line 129
      goto case_47;
    }
#line 130
    if (yy_act == 48) {
#line 130
      goto case_48;
    }
#line 131
    if (yy_act == 49) {
#line 131
      goto case_49;
    }
#line 132
    if (yy_act == 50) {
#line 132
      goto case_50;
    }
#line 133
    if (yy_act == 51) {
#line 133
      goto case_51;
    }
#line 134
    if (yy_act == 52) {
#line 134
      goto case_52;
    }
#line 135
    if (yy_act == 53) {
#line 135
      goto case_53;
    }
#line 136
    if (yy_act == 54) {
#line 136
      goto case_54;
    }
#line 137
    if (yy_act == 55) {
#line 137
      goto case_55;
    }
#line 138
    if (yy_act == 56) {
#line 138
      goto case_56;
    }
#line 139
    if (yy_act == 57) {
#line 139
      goto case_57;
    }
#line 140
    if (yy_act == 58) {
#line 140
      goto case_58;
    }
#line 141
    if (yy_act == 59) {
#line 141
      goto case_59;
    }
#line 142
    if (yy_act == 60) {
#line 142
      goto case_60;
    }
#line 143
    if (yy_act == 61) {
#line 143
      goto case_61;
    }
#line 144
    if (yy_act == 62) {
#line 144
      goto case_62;
    }
#line 145
    if (yy_act == 63) {
#line 145
      goto case_63;
    }
#line 146
    if (yy_act == 64) {
#line 146
      goto case_64;
    }
#line 147
    if (yy_act == 65) {
#line 147
      goto case_65;
    }
#line 148
    if (yy_act == 66) {
#line 148
      goto case_66;
    }
#line 149
    if (yy_act == 67) {
#line 149
      goto case_67;
    }
#line 150
    if (yy_act == 68) {
#line 150
      goto case_68;
    }
#line 151
    if (yy_act == 69) {
#line 151
      goto case_69;
    }
#line 152
    if (yy_act == 70) {
#line 152
      goto case_70;
    }
#line 153
    if (yy_act == 71) {
#line 153
      goto case_71;
    }
#line 154
    if (yy_act == 72) {
#line 154
      goto case_72;
    }
#line 155
    if (yy_act == 73) {
#line 155
      goto case_73;
    }
#line 156
    if (yy_act == 74) {
#line 156
      goto case_74;
    }
#line 157
    if (yy_act == 75) {
#line 157
      goto case_75;
    }
#line 158
    if (yy_act == 76) {
#line 158
      goto case_76;
    }
#line 159
    if (yy_act == 77) {
#line 159
      goto case_77;
    }
#line 160
    if (yy_act == 78) {
#line 160
      goto case_78;
    }
#line 161
    if (yy_act == 79) {
#line 161
      goto case_79;
    }
#line 162
    if (yy_act == 80) {
#line 162
      goto case_80;
    }
#line 163
    if (yy_act == 81) {
#line 163
      goto case_81;
    }
#line 164
    if (yy_act == 82) {
#line 164
      goto case_82;
    }
#line 165
    if (yy_act == 83) {
#line 165
      goto case_83;
    }
#line 166
    if (yy_act == 84) {
#line 166
      goto case_84;
    }
#line 167
    if (yy_act == 85) {
#line 167
      goto case_85;
    }
#line 168
    if (yy_act == 86) {
#line 168
      goto case_86;
    }
#line 169
    if (yy_act == 87) {
#line 169
      goto case_87;
    }
#line 170
    if (yy_act == 88) {
#line 170
      goto case_88;
    }
#line 171
    if (yy_act == 89) {
#line 171
      goto case_89;
    }
#line 172
    if (yy_act == 90) {
#line 172
      goto case_90;
    }
#line 173
    if (yy_act == 91) {
#line 173
      goto case_91;
    }
#line 174
    if (yy_act == 92) {
#line 174
      goto case_92;
    }
#line 175
    if (yy_act == 93) {
#line 175
      goto case_93;
    }
#line 176
    if (yy_act == 94) {
#line 176
      goto case_94;
    }
#line 177
    if (yy_act == 95) {
#line 177
      goto case_95;
    }
#line 178
    if (yy_act == 96) {
#line 178
      goto case_96;
    }
#line 179
    if (yy_act == 97) {
#line 179
      goto case_97;
    }
#line 180
    if (yy_act == 98) {
#line 180
      goto case_98;
    }
#line 181
    if (yy_act == 99) {
#line 181
      goto case_99;
    }
#line 182
    if (yy_act == 100) {
#line 182
      goto case_100;
    }
#line 183
    if (yy_act == 101) {
#line 183
      goto case_101;
    }
#line 184
    if (yy_act == 102) {
#line 184
      goto case_102;
    }
#line 185
    if (yy_act == 103) {
#line 185
      goto case_103;
    }
#line 186
    if (yy_act == 104) {
#line 186
      goto case_104;
    }
#line 187
    if (yy_act == 105) {
#line 187
      goto case_105;
    }
#line 188
    if (yy_act == 106) {
#line 188
      goto case_106;
    }
#line 189
    if (yy_act == 107) {
#line 189
      goto case_107;
    }
#line 190
    if (yy_act == 108) {
#line 190
      goto case_108;
    }
#line 191
    if (yy_act == 109) {
#line 191
      goto case_109;
    }
#line 192
    if (yy_act == 110) {
#line 192
      goto case_110;
    }
#line 193
    if (yy_act == 111) {
#line 193
      goto case_111;
    }
#line 194
    if (yy_act == 112) {
#line 194
      goto case_112;
    }
#line 195
    if (yy_act == 113) {
#line 195
      goto case_113;
    }
#line 196
    if (yy_act == 114) {
#line 196
      goto case_114;
    }
#line 197
    if (yy_act == 115) {
#line 197
      goto case_115;
    }
#line 198
    if (yy_act == 116) {
#line 198
      goto case_116;
    }
#line 199
    if (yy_act == 117) {
#line 199
      goto case_117;
    }
#line 200
    if (yy_act == 118) {
#line 200
      goto case_118;
    }
#line 201
    if (yy_act == 119) {
#line 201
      goto case_119;
    }
#line 202
    if (yy_act == 120) {
#line 202
      goto case_120;
    }
#line 203
    if (yy_act == 121) {
#line 203
      goto case_121;
    }
#line 204
    if (yy_act == 122) {
#line 204
      goto case_122;
    }
#line 205
    if (yy_act == 123) {
#line 205
      goto case_123;
    }
#line 206
    if (yy_act == 124) {
#line 206
      goto case_124;
    }
#line 207
    if (yy_act == 125) {
#line 207
      goto case_125;
    }
#line 208
    if (yy_act == 126) {
#line 208
      goto case_126;
    }
#line 209
    if (yy_act == 127) {
#line 209
      goto case_127;
    }
#line 210
    if (yy_act == 128) {
#line 210
      goto case_128;
    }
#line 211
    if (yy_act == 129) {
#line 211
      goto case_129;
    }
#line 212
    if (yy_act == 130) {
#line 212
      goto case_130;
    }
#line 213
    if (yy_act == 131) {
#line 213
      goto case_131;
    }
#line 214
    if (yy_act == 132) {
#line 214
      goto case_132;
    }
#line 215
    if (yy_act == 133) {
#line 215
      goto case_133;
    }
#line 216
    if (yy_act == 134) {
#line 216
      goto case_134;
    }
#line 217
    if (yy_act == 135) {
#line 217
      goto case_135;
    }
#line 218
    if (yy_act == 136) {
#line 218
      goto case_136;
    }
#line 219
    if (yy_act == 137) {
#line 219
      goto case_137;
    }
#line 229
    if (yy_act == 138) {
#line 229
      goto case_138;
    }
#line 231
    if (yy_act == 139) {
#line 231
      goto case_139;
    }
#line 232
    if (yy_act == 140) {
#line 232
      goto case_140;
    }
#line 233
    if (yy_act == 141) {
#line 233
      goto case_141;
    }
#line 234
    if (yy_act == 142) {
#line 234
      goto case_142;
    }
#line 235
    if (yy_act == 143) {
#line 235
      goto case_143;
    }
#line 236
    if (yy_act == 144) {
#line 236
      goto case_144;
    }
#line 237
    if (yy_act == 145) {
#line 237
      goto case_145;
    }
#line 238
    if (yy_act == 146) {
#line 238
      goto case_146;
    }
#line 239
    if (yy_act == 147) {
#line 239
      goto case_147;
    }
#line 240
    if (yy_act == 148) {
#line 240
      goto case_148;
    }
#line 241
    if (yy_act == 149) {
#line 241
      goto case_149;
    }
#line 242
    if (yy_act == 150) {
#line 242
      goto case_150;
    }
#line 243
    if (yy_act == 151) {
#line 243
      goto case_151;
    }
#line 244
    if (yy_act == 152) {
#line 244
      goto case_152;
    }
#line 245
    if (yy_act == 153) {
#line 245
      goto case_153;
    }
#line 248
    if (yy_act == 154) {
#line 248
      goto case_154;
    }
#line 249
    if (yy_act == 155) {
#line 249
      goto case_155;
    }
#line 250
    if (yy_act == 156) {
#line 250
      goto case_156;
    }
#line 251
    if (yy_act == 157) {
#line 251
      goto case_157;
    }
#line 252
    if (yy_act == 158) {
#line 252
      goto case_158;
    }
#line 255
    if (yy_act == 159) {
#line 255
      goto case_159;
    }
#line 256
    if (yy_act == 160) {
#line 256
      goto case_160;
    }
#line 257
    if (yy_act == 161) {
#line 257
      goto case_161;
    }
#line 258
    if (yy_act == 162) {
#line 258
      goto case_162;
    }
#line 259
    if (yy_act == 163) {
#line 259
      goto case_163;
    }
#line 260
    if (yy_act == 164) {
#line 260
      goto case_164;
    }
#line 261
    if (yy_act == 165) {
#line 261
      goto case_165;
    }
#line 263
    if (yy_act == 166) {
#line 263
      goto case_166;
    }
#line 264
    if (yy_act == 167) {
#line 264
      goto case_167;
    }
#line 265
    if (yy_act == 168) {
#line 265
      goto case_168;
    }
#line 266
    if (yy_act == 169) {
#line 266
      goto case_169;
    }
#line 267
    if (yy_act == 170) {
#line 267
      goto case_170;
    }
#line 268
    if (yy_act == 171) {
#line 268
      goto case_171;
    }
#line 269
    if (yy_act == 172) {
#line 269
      goto case_172;
    }
#line 270
    if (yy_act == 173) {
#line 270
      goto case_173;
    }
#line 276
    if (yy_act == 174) {
#line 276
      goto case_174;
    }
#line 282
    if (yy_act == 175) {
#line 282
      goto case_175;
    }
#line 284
    if (yy_act == 176) {
#line 284
      goto case_176;
    }
#line 285
    if (yy_act == 177) {
#line 285
      goto case_177;
    }
#line 286
    if (yy_act == 178) {
#line 286
      goto case_178;
    }
#line 287
    if (yy_act == 179) {
#line 287
      goto case_179;
    }
#line 288
    if (yy_act == 180) {
#line 288
      goto case_180;
    }
#line 289
    if (yy_act == 181) {
#line 289
      goto case_181;
    }
#line 290
    if (yy_act == 182) {
#line 290
      goto case_182;
    }
#line 291
    if (yy_act == 183) {
#line 291
      goto case_183;
    }
#line 292
    if (yy_act == 184) {
#line 292
      goto case_184;
    }
#line 293
    if (yy_act == 185) {
#line 293
      goto case_185;
    }
#line 297
    if (yy_act == 186) {
#line 297
      goto case_186;
    }
#line 300
    if (yy_act == 187) {
#line 300
      goto case_187;
    }
#line 313
    if (yy_act == 188) {
#line 313
      goto case_188;
    }
#line 322
    if (yy_act == 189) {
#line 322
      goto case_189;
    }
#line 336
    if (yy_act == 190) {
#line 336
      goto case_190;
    }
#line 338
    if (yy_act == 191) {
#line 338
      goto case_191;
    }
#line 339
    if (yy_act == 192) {
#line 339
      goto case_192;
    }
#line 340
    if (yy_act == 193) {
#line 340
      goto case_193;
    }
#line 341
    if (yy_act == 194) {
#line 341
      goto case_194;
    }
#line 342
    if (yy_act == 195) {
#line 342
      goto case_195;
    }
#line 343
    if (yy_act == 196) {
#line 343
      goto case_196;
    }
#line 344
    if (yy_act == 197) {
#line 344
      goto case_197;
    }
#line 345
    if (yy_act == 198) {
#line 345
      goto case_198;
    }
#line 346
    if (yy_act == 199) {
#line 346
      goto case_199;
    }
#line 347
    if (yy_act == 200) {
#line 347
      goto case_200;
    }
#line 351
    if (yy_act == 201) {
#line 351
      goto case_201;
    }
#line 357
    if (yy_act == 202) {
#line 357
      goto case_202;
    }
#line 379
    if (yy_act == 203) {
#line 379
      goto case_203;
    }
#line 388
    if (yy_act == 204) {
#line 388
      goto case_204;
    }
#line 402
    if (yy_act == 205) {
#line 402
      goto case_205;
    }
#line 404
    if (yy_act == 206) {
#line 404
      goto case_206;
    }
#line 405
    if (yy_act == 207) {
#line 405
      goto case_207;
    }
#line 406
    if (yy_act == 208) {
#line 406
      goto case_208;
    }
#line 407
    if (yy_act == 209) {
#line 407
      goto case_209;
    }
#line 408
    if (yy_act == 210) {
#line 408
      goto case_210;
    }
#line 409
    if (yy_act == 211) {
#line 409
      goto case_211;
    }
#line 410
    if (yy_act == 212) {
#line 410
      goto case_212;
    }
#line 411
    if (yy_act == 213) {
#line 411
      goto case_213;
    }
#line 412
    if (yy_act == 214) {
#line 412
      goto case_214;
    }
#line 413
    if (yy_act == 215) {
#line 413
      goto case_215;
    }
#line 418
    if (yy_act == 216) {
#line 418
      goto case_216;
    }
#line 423
    if (yy_act == 217) {
#line 423
      goto case_217;
    }
#line 2532
    if (yy_act == 221) {
#line 2532 "lexssh.c"
      goto case_221;
    }
#line 2532
    if (yy_act == 220) {
#line 2532
      goto case_221;
    }
#line 2532
    if (yy_act == 219) {
#line 2532
      goto case_221;
    }
#line 2535
    if (yy_act == 218) {
#line 2535
      goto case_218;
    }
#line 2657
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1330
    *yy_cp = yy_hold_char___3;
#line 1331
    yy_cp = yy_last_accepting_cpos___3;
#line 1332
    yy_current_state = yy_last_accepting_state___3;
#line 1333
    goto yy_find_action;
    case_1: /* CIL Label */ ;
#line 81 "lexssh.l"
    goto switch_break;
    case_2: /* CIL Label */ ;
#line 82
    goto switch_break;
    case_3: /* CIL Label */ 
#line 83
    yy_start___3 = 3;
#line 84
    goto switch_break;
    case_4: /* CIL Label */ 
#line 84
    yy_start___3 = 5;
#line 85
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 86
    tmp___0 = xstrdup("\"");
#line 86
    sshlval.string = (unsigned char *)tmp___0;
    }
#line 86
    return (286);
#line 87
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 87
    tmp___1 = xstrdup("$");
#line 87
    sshlval.string = (unsigned char *)tmp___1;
    }
#line 87
    return (286);
#line 88
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 88
    tmp___2 = xstrdup("\'");
#line 88
    sshlval.string = (unsigned char *)tmp___2;
    }
#line 88
    return (286);
#line 89
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 89
    tmp___3 = xstrdup("@");
#line 89
    sshlval.string = (unsigned char *)tmp___3;
    }
#line 89
    return (286);
#line 90
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 90
    tmp___4 = xstrdup("A");
#line 90
    sshlval.string = (unsigned char *)tmp___4;
    }
#line 90
    return (286);
#line 91
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 91
    tmp___5 = xstrdup("B");
#line 91
    sshlval.string = (unsigned char *)tmp___5;
    }
#line 91
    return (286);
#line 92
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 92
    tmp___6 = xstrdup("C");
#line 92
    sshlval.string = (unsigned char *)tmp___6;
    }
#line 92
    return (286);
#line 93
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 93
    tmp___7 = xstrdup("D");
#line 93
    sshlval.string = (unsigned char *)tmp___7;
    }
#line 93
    return (286);
#line 94
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 94
    tmp___8 = xstrdup("E");
#line 94
    sshlval.string = (unsigned char *)tmp___8;
    }
#line 94
    return (286);
#line 95
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 95
    tmp___9 = xstrdup("F");
#line 95
    sshlval.string = (unsigned char *)tmp___9;
    }
#line 95
    return (286);
#line 96
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 96
    tmp___10 = xstrdup("G");
#line 96
    sshlval.string = (unsigned char *)tmp___10;
    }
#line 96
    return (286);
#line 97
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 97
    tmp___11 = xstrdup("H");
#line 97
    sshlval.string = (unsigned char *)tmp___11;
    }
#line 97
    return (286);
#line 98
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 98
    tmp___12 = xstrdup("I");
#line 98
    sshlval.string = (unsigned char *)tmp___12;
    }
#line 98
    return (286);
#line 99
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 99
    tmp___13 = xstrdup("J");
#line 99
    sshlval.string = (unsigned char *)tmp___13;
    }
#line 99
    return (286);
#line 100
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 100
    tmp___14 = xstrdup("K");
#line 100
    sshlval.string = (unsigned char *)tmp___14;
    }
#line 100
    return (286);
#line 101
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 101
    tmp___15 = xstrdup("L");
#line 101
    sshlval.string = (unsigned char *)tmp___15;
    }
#line 101
    return (286);
#line 102
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 102
    tmp___16 = xstrdup("M");
#line 102
    sshlval.string = (unsigned char *)tmp___16;
    }
#line 102
    return (286);
#line 103
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 103
    tmp___17 = xstrdup("N");
#line 103
    sshlval.string = (unsigned char *)tmp___17;
    }
#line 103
    return (286);
#line 104
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 104
    tmp___18 = xstrdup("O");
#line 104
    sshlval.string = (unsigned char *)tmp___18;
    }
#line 104
    return (286);
#line 105
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 105
    tmp___19 = xstrdup("P");
#line 105
    sshlval.string = (unsigned char *)tmp___19;
    }
#line 105
    return (286);
#line 106
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 106
    tmp___20 = xstrdup("Q");
#line 106
    sshlval.string = (unsigned char *)tmp___20;
    }
#line 106
    return (286);
#line 107
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 107
    tmp___21 = xstrdup("R");
#line 107
    sshlval.string = (unsigned char *)tmp___21;
    }
#line 107
    return (286);
#line 108
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 108
    tmp___22 = xstrdup("S");
#line 108
    sshlval.string = (unsigned char *)tmp___22;
    }
#line 108
    return (286);
#line 109
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 109
    tmp___23 = xstrdup("T");
#line 109
    sshlval.string = (unsigned char *)tmp___23;
    }
#line 109
    return (286);
#line 110
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 110
    tmp___24 = xstrdup("U");
#line 110
    sshlval.string = (unsigned char *)tmp___24;
    }
#line 110
    return (286);
#line 111
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 111
    tmp___25 = xstrdup("V");
#line 111
    sshlval.string = (unsigned char *)tmp___25;
    }
#line 111
    return (286);
#line 112
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 112
    tmp___26 = xstrdup("W");
#line 112
    sshlval.string = (unsigned char *)tmp___26;
    }
#line 112
    return (286);
#line 113
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 113
    tmp___27 = xstrdup("X");
#line 113
    sshlval.string = (unsigned char *)tmp___27;
    }
#line 113
    return (286);
#line 114
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 114
    tmp___28 = xstrdup("Y");
#line 114
    sshlval.string = (unsigned char *)tmp___28;
    }
#line 114
    return (286);
#line 115
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 115
    tmp___29 = xstrdup("Z");
#line 115
    sshlval.string = (unsigned char *)tmp___29;
    }
#line 115
    return (286);
#line 116
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 116
    tmp___30 = xstrdup("\\");
#line 116
    sshlval.string = (unsigned char *)tmp___30;
    }
#line 116
    return (286);
#line 117
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 117
    tmp___31 = xstrdup("^");
#line 117
    sshlval.string = (unsigned char *)tmp___31;
    }
#line 117
    return (286);
#line 118
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 118
    tmp___32 = xstrdup("`");
#line 118
    sshlval.string = (unsigned char *)tmp___32;
    }
#line 118
    return (286);
#line 119
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 119
    tmp___33 = xstrdup("a");
#line 119
    sshlval.string = (unsigned char *)tmp___33;
    }
#line 119
    return (286);
#line 120
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 120
    tmp___34 = xstrdup("b");
#line 120
    sshlval.string = (unsigned char *)tmp___34;
    }
#line 120
    return (286);
#line 121
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 121
    tmp___35 = xstrdup("c");
#line 121
    sshlval.string = (unsigned char *)tmp___35;
    }
#line 121
    return (286);
#line 122
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 122
    tmp___36 = xstrdup("d");
#line 122
    sshlval.string = (unsigned char *)tmp___36;
    }
#line 122
    return (286);
#line 123
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 123
    tmp___37 = xstrdup("e");
#line 123
    sshlval.string = (unsigned char *)tmp___37;
    }
#line 123
    return (286);
#line 124
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 124
    tmp___38 = xstrdup("f");
#line 124
    sshlval.string = (unsigned char *)tmp___38;
    }
#line 124
    return (286);
#line 125
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 125
    tmp___39 = xstrdup("g");
#line 125
    sshlval.string = (unsigned char *)tmp___39;
    }
#line 125
    return (286);
#line 126
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 126
    tmp___40 = xstrdup("h");
#line 126
    sshlval.string = (unsigned char *)tmp___40;
    }
#line 126
    return (286);
#line 127
    goto switch_break;
    case_46: /* CIL Label */ 
    {
#line 127
    tmp___41 = xstrdup("i");
#line 127
    sshlval.string = (unsigned char *)tmp___41;
    }
#line 127
    return (286);
#line 128
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 128
    tmp___42 = xstrdup("j");
#line 128
    sshlval.string = (unsigned char *)tmp___42;
    }
#line 128
    return (286);
#line 129
    goto switch_break;
    case_48: /* CIL Label */ 
    {
#line 129
    tmp___43 = xstrdup("k");
#line 129
    sshlval.string = (unsigned char *)tmp___43;
    }
#line 129
    return (286);
#line 130
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 130
    tmp___44 = xstrdup("l");
#line 130
    sshlval.string = (unsigned char *)tmp___44;
    }
#line 130
    return (286);
#line 131
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 131
    tmp___45 = xstrdup("m");
#line 131
    sshlval.string = (unsigned char *)tmp___45;
    }
#line 131
    return (286);
#line 132
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 132
    tmp___46 = xstrdup("n");
#line 132
    sshlval.string = (unsigned char *)tmp___46;
    }
#line 132
    return (286);
#line 133
    goto switch_break;
    case_52: /* CIL Label */ 
    {
#line 133
    tmp___47 = xstrdup("o");
#line 133
    sshlval.string = (unsigned char *)tmp___47;
    }
#line 133
    return (286);
#line 134
    goto switch_break;
    case_53: /* CIL Label */ 
    {
#line 134
    tmp___48 = xstrdup("p");
#line 134
    sshlval.string = (unsigned char *)tmp___48;
    }
#line 134
    return (286);
#line 135
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 135
    tmp___49 = xstrdup("q");
#line 135
    sshlval.string = (unsigned char *)tmp___49;
    }
#line 135
    return (286);
#line 136
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 136
    tmp___50 = xstrdup("r");
#line 136
    sshlval.string = (unsigned char *)tmp___50;
    }
#line 136
    return (286);
#line 137
    goto switch_break;
    case_56: /* CIL Label */ 
    {
#line 137
    tmp___51 = xstrdup("s");
#line 137
    sshlval.string = (unsigned char *)tmp___51;
    }
#line 137
    return (286);
#line 138
    goto switch_break;
    case_57: /* CIL Label */ 
    {
#line 138
    tmp___52 = xstrdup("t");
#line 138
    sshlval.string = (unsigned char *)tmp___52;
    }
#line 138
    return (286);
#line 139
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 139
    tmp___53 = xstrdup("u");
#line 139
    sshlval.string = (unsigned char *)tmp___53;
    }
#line 139
    return (286);
#line 140
    goto switch_break;
    case_59: /* CIL Label */ 
    {
#line 140
    tmp___54 = xstrdup("v");
#line 140
    sshlval.string = (unsigned char *)tmp___54;
    }
#line 140
    return (286);
#line 141
    goto switch_break;
    case_60: /* CIL Label */ 
    {
#line 141
    tmp___55 = xstrdup("w");
#line 141
    sshlval.string = (unsigned char *)tmp___55;
    }
#line 141
    return (286);
#line 142
    goto switch_break;
    case_61: /* CIL Label */ 
    {
#line 142
    tmp___56 = xstrdup("x");
#line 142
    sshlval.string = (unsigned char *)tmp___56;
    }
#line 142
    return (286);
#line 143
    goto switch_break;
    case_62: /* CIL Label */ 
    {
#line 143
    tmp___57 = xstrdup("y");
#line 143
    sshlval.string = (unsigned char *)tmp___57;
    }
#line 143
    return (286);
#line 144
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 144
    tmp___58 = xstrdup("z");
#line 144
    sshlval.string = (unsigned char *)tmp___58;
    }
#line 144
    return (286);
#line 145
    goto switch_break;
    case_64: /* CIL Label */ 
    {
#line 145
    tmp___59 = xstrdup("~");
#line 145
    sshlval.string = (unsigned char *)tmp___59;
    }
#line 145
    return (286);
#line 146
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 146
    tmp___60 = xstrdup("\241");
#line 146
    sshlval.string = (unsigned char *)tmp___60;
    }
#line 146
    return (286);
#line 147
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 147
    tmp___61 = xstrdup("\242");
#line 147
    sshlval.string = (unsigned char *)tmp___61;
    }
#line 147
    return (286);
#line 148
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 148
    tmp___62 = xstrdup("\243");
#line 148
    sshlval.string = (unsigned char *)tmp___62;
    }
#line 148
    return (286);
#line 149
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 149
    tmp___63 = xstrdup("\245");
#line 149
    sshlval.string = (unsigned char *)tmp___63;
    }
#line 149
    return (286);
#line 150
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 150
    tmp___64 = xstrdup("\246");
#line 150
    sshlval.string = (unsigned char *)tmp___64;
    }
#line 150
    return (286);
#line 151
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 151
    tmp___65 = xstrdup("\247");
#line 151
    sshlval.string = (unsigned char *)tmp___65;
    }
#line 151
    return (286);
#line 152
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 152
    tmp___66 = xstrdup("\250");
#line 152
    sshlval.string = (unsigned char *)tmp___66;
    }
#line 152
    return (286);
#line 153
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 153
    tmp___67 = xstrdup("\251");
#line 153
    sshlval.string = (unsigned char *)tmp___67;
    }
#line 153
    return (286);
#line 154
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 154
    tmp___68 = xstrdup("\252");
#line 154
    sshlval.string = (unsigned char *)tmp___68;
    }
#line 154
    return (286);
#line 155
    goto switch_break;
    case_74: /* CIL Label */ 
    {
#line 155
    tmp___69 = xstrdup("\253");
#line 155
    sshlval.string = (unsigned char *)tmp___69;
    }
#line 155
    return (286);
#line 156
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 156
    tmp___70 = xstrdup("\254");
#line 156
    sshlval.string = (unsigned char *)tmp___70;
    }
#line 156
    return (286);
#line 157
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 157
    tmp___71 = xstrdup("\255");
#line 157
    sshlval.string = (unsigned char *)tmp___71;
    }
#line 157
    return (286);
#line 158
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 158
    tmp___72 = xstrdup("\256");
#line 158
    sshlval.string = (unsigned char *)tmp___72;
    }
#line 158
    return (286);
#line 159
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 159
    tmp___73 = xstrdup("\257");
#line 159
    sshlval.string = (unsigned char *)tmp___73;
    }
#line 159
    return (286);
#line 160
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 160
    tmp___74 = xstrdup("\260");
#line 160
    sshlval.string = (unsigned char *)tmp___74;
    }
#line 160
    return (286);
#line 161
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 161
    tmp___75 = xstrdup("\261");
#line 161
    sshlval.string = (unsigned char *)tmp___75;
    }
#line 161
    return (286);
#line 162
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 162
    tmp___76 = xstrdup("\263");
#line 162
    sshlval.string = (unsigned char *)tmp___76;
    }
#line 162
    return (286);
#line 163
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 163
    tmp___77 = xstrdup("\264");
#line 163
    sshlval.string = (unsigned char *)tmp___77;
    }
#line 163
    return (286);
#line 164
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 164
    tmp___78 = xstrdup("\265");
#line 164
    sshlval.string = (unsigned char *)tmp___78;
    }
#line 164
    return (286);
#line 165
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 165
    tmp___79 = xstrdup("\266");
#line 165
    sshlval.string = (unsigned char *)tmp___79;
    }
#line 165
    return (286);
#line 166
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 166
    tmp___80 = xstrdup("\267");
#line 166
    sshlval.string = (unsigned char *)tmp___80;
    }
#line 166
    return (286);
#line 167
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 167
    tmp___81 = xstrdup("\270");
#line 167
    sshlval.string = (unsigned char *)tmp___81;
    }
#line 167
    return (286);
#line 168
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 168
    tmp___82 = xstrdup("\271");
#line 168
    sshlval.string = (unsigned char *)tmp___82;
    }
#line 168
    return (286);
#line 169
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 169
    tmp___83 = xstrdup("\272");
#line 169
    sshlval.string = (unsigned char *)tmp___83;
    }
#line 169
    return (286);
#line 170
    goto switch_break;
    case_89: /* CIL Label */ 
    {
#line 170
    tmp___84 = xstrdup("\273");
#line 170
    sshlval.string = (unsigned char *)tmp___84;
    }
#line 170
    return (286);
#line 171
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 171
    tmp___85 = xstrdup("\274");
#line 171
    sshlval.string = (unsigned char *)tmp___85;
    }
#line 171
    return (286);
#line 172
    goto switch_break;
    case_91: /* CIL Label */ 
    {
#line 172
    tmp___86 = xstrdup("\276");
#line 172
    sshlval.string = (unsigned char *)tmp___86;
    }
#line 172
    return (286);
#line 173
    goto switch_break;
    case_92: /* CIL Label */ 
    {
#line 173
    tmp___87 = xstrdup("\277");
#line 173
    sshlval.string = (unsigned char *)tmp___87;
    }
#line 173
    return (286);
#line 174
    goto switch_break;
    case_93: /* CIL Label */ 
    {
#line 174
    tmp___88 = xstrdup("\300");
#line 174
    sshlval.string = (unsigned char *)tmp___88;
    }
#line 174
    return (286);
#line 175
    goto switch_break;
    case_94: /* CIL Label */ 
    {
#line 175
    tmp___89 = xstrdup("\301");
#line 175
    sshlval.string = (unsigned char *)tmp___89;
    }
#line 175
    return (286);
#line 176
    goto switch_break;
    case_95: /* CIL Label */ 
    {
#line 176
    tmp___90 = xstrdup("\302");
#line 176
    sshlval.string = (unsigned char *)tmp___90;
    }
#line 176
    return (286);
#line 177
    goto switch_break;
    case_96: /* CIL Label */ 
    {
#line 177
    tmp___91 = xstrdup("\303");
#line 177
    sshlval.string = (unsigned char *)tmp___91;
    }
#line 177
    return (286);
#line 178
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 178
    tmp___92 = xstrdup("\304");
#line 178
    sshlval.string = (unsigned char *)tmp___92;
    }
#line 178
    return (286);
#line 179
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 179
    tmp___93 = xstrdup("\305");
#line 179
    sshlval.string = (unsigned char *)tmp___93;
    }
#line 179
    return (286);
#line 180
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 180
    tmp___94 = xstrdup("\306");
#line 180
    sshlval.string = (unsigned char *)tmp___94;
    }
#line 180
    return (286);
#line 181
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 181
    tmp___95 = xstrdup("\307");
#line 181
    sshlval.string = (unsigned char *)tmp___95;
    }
#line 181
    return (286);
#line 182
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 182
    tmp___96 = xstrdup("\310");
#line 182
    sshlval.string = (unsigned char *)tmp___96;
    }
#line 182
    return (286);
#line 183
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 183
    tmp___97 = xstrdup("\311");
#line 183
    sshlval.string = (unsigned char *)tmp___97;
    }
#line 183
    return (286);
#line 184
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 184
    tmp___98 = xstrdup("\312");
#line 184
    sshlval.string = (unsigned char *)tmp___98;
    }
#line 184
    return (286);
#line 185
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 185
    tmp___99 = xstrdup("\313");
#line 185
    sshlval.string = (unsigned char *)tmp___99;
    }
#line 185
    return (286);
#line 186
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 186
    tmp___100 = xstrdup("\314");
#line 186
    sshlval.string = (unsigned char *)tmp___100;
    }
#line 186
    return (286);
#line 187
    goto switch_break;
    case_106: /* CIL Label */ 
    {
#line 187
    tmp___101 = xstrdup("\315");
#line 187
    sshlval.string = (unsigned char *)tmp___101;
    }
#line 187
    return (286);
#line 188
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 188
    tmp___102 = xstrdup("\316");
#line 188
    sshlval.string = (unsigned char *)tmp___102;
    }
#line 188
    return (286);
#line 189
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 189
    tmp___103 = xstrdup("\317");
#line 189
    sshlval.string = (unsigned char *)tmp___103;
    }
#line 189
    return (286);
#line 190
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 190
    tmp___104 = xstrdup("\320");
#line 190
    sshlval.string = (unsigned char *)tmp___104;
    }
#line 190
    return (286);
#line 191
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 191
    tmp___105 = xstrdup("\321");
#line 191
    sshlval.string = (unsigned char *)tmp___105;
    }
#line 191
    return (286);
#line 192
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 192
    tmp___106 = xstrdup("\322");
#line 192
    sshlval.string = (unsigned char *)tmp___106;
    }
#line 192
    return (286);
#line 193
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 193
    tmp___107 = xstrdup("\324");
#line 193
    sshlval.string = (unsigned char *)tmp___107;
    }
#line 193
    return (286);
#line 194
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 194
    tmp___108 = xstrdup("\324");
#line 194
    sshlval.string = (unsigned char *)tmp___108;
    }
#line 194
    return (286);
#line 195
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 195
    tmp___109 = xstrdup("\325");
#line 195
    sshlval.string = (unsigned char *)tmp___109;
    }
#line 195
    return (286);
#line 196
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 196
    tmp___110 = xstrdup("\326");
#line 196
    sshlval.string = (unsigned char *)tmp___110;
    }
#line 196
    return (286);
#line 197
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 197
    tmp___111 = xstrdup("\327");
#line 197
    sshlval.string = (unsigned char *)tmp___111;
    }
#line 197
    return (286);
#line 198
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 198
    tmp___112 = xstrdup("\330");
#line 198
    sshlval.string = (unsigned char *)tmp___112;
    }
#line 198
    return (286);
#line 199
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 199
    tmp___113 = xstrdup("\331");
#line 199
    sshlval.string = (unsigned char *)tmp___113;
    }
#line 199
    return (286);
#line 200
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 200
    tmp___114 = xstrdup("\332");
#line 200
    sshlval.string = (unsigned char *)tmp___114;
    }
#line 200
    return (286);
#line 201
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 201
    tmp___115 = xstrdup("\333");
#line 201
    sshlval.string = (unsigned char *)tmp___115;
    }
#line 201
    return (286);
#line 202
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 202
    tmp___116 = xstrdup("\334");
#line 202
    sshlval.string = (unsigned char *)tmp___116;
    }
#line 202
    return (286);
#line 203
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 203
    tmp___117 = xstrdup("\335");
#line 203
    sshlval.string = (unsigned char *)tmp___117;
    }
#line 203
    return (286);
#line 204
    goto switch_break;
    case_123: /* CIL Label */ 
    {
#line 204
    tmp___118 = xstrdup("\336");
#line 204
    sshlval.string = (unsigned char *)tmp___118;
    }
#line 204
    return (286);
#line 205
    goto switch_break;
    case_124: /* CIL Label */ 
    {
#line 205
    tmp___119 = xstrdup("\337");
#line 205
    sshlval.string = (unsigned char *)tmp___119;
    }
#line 205
    return (286);
#line 206
    goto switch_break;
    case_125: /* CIL Label */ 
    {
#line 206
    tmp___120 = xstrdup("\340");
#line 206
    sshlval.string = (unsigned char *)tmp___120;
    }
#line 206
    return (286);
#line 207
    goto switch_break;
    case_126: /* CIL Label */ 
    {
#line 207
    tmp___121 = xstrdup("\341");
#line 207
    sshlval.string = (unsigned char *)tmp___121;
    }
#line 207
    return (286);
#line 208
    goto switch_break;
    case_127: /* CIL Label */ 
    {
#line 208
    tmp___122 = xstrdup("\342");
#line 208
    sshlval.string = (unsigned char *)tmp___122;
    }
#line 208
    return (286);
#line 209
    goto switch_break;
    case_128: /* CIL Label */ 
    {
#line 209
    tmp___123 = xstrdup("\342");
#line 209
    sshlval.string = (unsigned char *)tmp___123;
    }
#line 209
    return (286);
#line 210
    goto switch_break;
    case_129: /* CIL Label */ 
    {
#line 210
    tmp___124 = xstrdup("\344");
#line 210
    sshlval.string = (unsigned char *)tmp___124;
    }
#line 210
    return (286);
#line 211
    goto switch_break;
    case_130: /* CIL Label */ 
    {
#line 211
    tmp___125 = xstrdup("\345");
#line 211
    sshlval.string = (unsigned char *)tmp___125;
    }
#line 211
    return (286);
#line 212
    goto switch_break;
    case_131: /* CIL Label */ 
    {
#line 212
    tmp___126 = xstrdup("\351");
#line 212
    sshlval.string = (unsigned char *)tmp___126;
    }
#line 212
    return (286);
#line 213
    goto switch_break;
    case_132: /* CIL Label */ 
    {
#line 213
    tmp___127 = xstrdup("\353");
#line 213
    sshlval.string = (unsigned char *)tmp___127;
    }
#line 213
    return (286);
#line 214
    goto switch_break;
    case_133: /* CIL Label */ 
    {
#line 214
    tmp___128 = xstrdup("\361");
#line 214
    sshlval.string = (unsigned char *)tmp___128;
    }
#line 214
    return (286);
#line 215
    goto switch_break;
    case_134: /* CIL Label */ 
    {
#line 215
    tmp___129 = xstrdup("\362");
#line 215
    sshlval.string = (unsigned char *)tmp___129;
    }
#line 215
    return (286);
#line 216
    goto switch_break;
    case_135: /* CIL Label */ 
    {
#line 216
    tmp___130 = xstrdup("\371");
#line 216
    sshlval.string = (unsigned char *)tmp___130;
    }
#line 216
    return (286);
#line 217
    goto switch_break;
    case_136: /* CIL Label */ 
    {
#line 217
    tmp___131 = xstrdup("\373");
#line 217
    sshlval.string = (unsigned char *)tmp___131;
    }
#line 217
    return (286);
#line 218
    goto switch_break;
    case_137: /* CIL Label */ 
#line 220
    value = (int )*(sshtext + 1) - 48;
#line 221
    cursor = sshtext + 2;
    {
#line 223
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 223
      if (! *cursor) {
#line 223
        goto while_break___3;
      }
#line 224
      tmp___132 = cursor;
#line 224
      cursor ++;
#line 224
      value = (8 * value + (int )*tmp___132) - 48;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 225
    sshlval.integer = value;
#line 226
    return (289);
#line 228
    goto switch_break;
    case_138: /* CIL Label */ 
#line 229
    return (281);
#line 230
    goto switch_break;
    case_139: /* CIL Label */ 
#line 230
    return (268);
#line 231
    goto switch_break;
    case_140: /* CIL Label */ 
#line 231
    return (269);
#line 232
    goto switch_break;
    case_141: /* CIL Label */ 
#line 232
    return (282);
#line 233
    goto switch_break;
    case_142: /* CIL Label */ 
#line 233
    return (262);
#line 234
    goto switch_break;
    case_143: /* CIL Label */ 
#line 234
    return (278);
#line 235
    goto switch_break;
    case_144: /* CIL Label */ 
#line 235
    return (272);
#line 236
    goto switch_break;
    case_145: /* CIL Label */ 
#line 236
    return (276);
#line 237
    goto switch_break;
    case_146: /* CIL Label */ 
#line 237
    return (274);
#line 238
    goto switch_break;
    case_147: /* CIL Label */ 
#line 238
    return (273);
#line 239
    goto switch_break;
    case_148: /* CIL Label */ 
#line 239
    return (270);
#line 240
    goto switch_break;
    case_149: /* CIL Label */ 
#line 240
    return (260);
#line 241
    goto switch_break;
    case_150: /* CIL Label */ 
#line 241
    return (271);
#line 242
    goto switch_break;
    case_151: /* CIL Label */ 
#line 242
    return (266);
#line 243
    goto switch_break;
    case_152: /* CIL Label */ 
#line 243
    return (263);
#line 244
    goto switch_break;
    case_153: /* CIL Label */ 
#line 244
    sshlval.sensitiveness = (enum case_sensitiveness )1;
#line 245
    return (288);
#line 247
    goto switch_break;
    case_154: /* CIL Label */ 
#line 247
    return (259);
#line 248
    goto switch_break;
    case_155: /* CIL Label */ 
#line 248
    return (261);
#line 249
    goto switch_break;
    case_156: /* CIL Label */ 
#line 249
    return (280);
#line 250
    goto switch_break;
    case_157: /* CIL Label */ 
#line 250
    return (267);
#line 251
    goto switch_break;
    case_158: /* CIL Label */ 
#line 251
    sshlval.sensitiveness = (enum case_sensitiveness )0;
#line 252
    return (288);
#line 254
    goto switch_break;
    case_159: /* CIL Label */ 
#line 254
    return (264);
#line 255
    goto switch_break;
    case_160: /* CIL Label */ 
#line 255
    return (275);
#line 256
    goto switch_break;
    case_161: /* CIL Label */ 
#line 256
    return (265);
#line 257
    goto switch_break;
    case_162: /* CIL Label */ 
#line 257
    return (258);
#line 258
    goto switch_break;
    case_163: /* CIL Label */ 
#line 258
    return (279);
#line 259
    goto switch_break;
    case_164: /* CIL Label */ 
#line 259
    return (277);
#line 260
    goto switch_break;
    case_165: /* CIL Label */ 
#line 261
    sshlval.face = (enum face_e )0;
#line 261
    return (283);
#line 262
    goto switch_break;
    case_166: /* CIL Label */ 
#line 262
    sshlval.face = (enum face_e )1;
#line 262
    return (283);
#line 263
    goto switch_break;
    case_167: /* CIL Label */ 
#line 263
    sshlval.face = (enum face_e )2;
#line 263
    return (283);
#line 264
    goto switch_break;
    case_168: /* CIL Label */ 
#line 264
    sshlval.face = (enum face_e )7;
#line 264
    return (283);
#line 265
    goto switch_break;
    case_169: /* CIL Label */ 
#line 265
    sshlval.face = (enum face_e )3;
#line 265
    return (283);
#line 266
    goto switch_break;
    case_170: /* CIL Label */ 
#line 266
    sshlval.face = (enum face_e )4;
#line 266
    return (283);
#line 267
    goto switch_break;
    case_171: /* CIL Label */ 
#line 267
    sshlval.face = (enum face_e )5;
#line 267
    return (283);
#line 268
    goto switch_break;
    case_172: /* CIL Label */ 
#line 268
    sshlval.face = (enum face_e )6;
#line 268
    return (283);
#line 269
    goto switch_break;
    case_173: /* CIL Label */ 
#line 270
    if (strip_level == 1) {
#line 271
      sshlval.fflags = (enum fflag_e )1;
#line 271
      return (284);
    } else
#line 270
    if (strip_level == 3) {
#line 271
      sshlval.fflags = (enum fflag_e )1;
#line 271
      return (284);
    } else {
#line 273
      sshlval.face = (enum face_e )8;
#line 273
      return (283);
    }
#line 275
    goto switch_break;
    case_174: /* CIL Label */ 
#line 276
    if (strip_level == 2) {
#line 277
      sshlval.fflags = (enum fflag_e )1;
#line 277
      return (284);
    } else
#line 276
    if (strip_level == 3) {
#line 277
      sshlval.fflags = (enum fflag_e )1;
#line 277
      return (284);
    } else {
#line 279
      sshlval.face = (enum face_e )9;
#line 279
      return (283);
    }
#line 281
    goto switch_break;
    case_175: /* CIL Label */ 
#line 282
    sshlval.fflags = (enum fflag_e )2;
#line 282
    return (284);
#line 283
    goto switch_break;
    case_176: /* CIL Label */ 
#line 283
    sshlval.fflags = (enum fflag_e )4;
#line 283
    return (284);
#line 284
    goto switch_break;
    case_177: /* CIL Label */ 
#line 284
    sshlval.fflags = (enum fflag_e )8;
#line 284
    return (284);
#line 285
    goto switch_break;
    case_178: /* CIL Label */ 
#line 285
    sshlval.fflags = (enum fflag_e )16;
#line 285
    return (284);
#line 286
    goto switch_break;
    case_179: /* CIL Label */ 
#line 286
    sshlval.fflags = (enum fflag_e )32;
#line 286
    return (284);
#line 287
    goto switch_break;
    case_180: /* CIL Label */ 
#line 287
    sshlval.fflags = (enum fflag_e )64;
#line 287
    return (284);
#line 288
    goto switch_break;
    case_181: /* CIL Label */ 
#line 288
    sshlval.fflags = (enum fflag_e )128;
#line 288
    return (284);
#line 289
    goto switch_break;
    case_182: /* CIL Label */ 
#line 289
    sshlval.fflags = (enum fflag_e )256;
#line 289
    return (284);
#line 290
    goto switch_break;
    case_183: /* CIL Label */ 
#line 290
    sshlval.fflags = (enum fflag_e )512;
#line 290
    return (284);
#line 291
    goto switch_break;
    case_184: /* CIL Label */ 
#line 291
    sshlval.fflags = (enum fflag_e )1;
#line 291
    return (284);
#line 292
    goto switch_break;
    case_185: /* CIL Label */ 
    {
#line 293
    tmp___133 = xstrdup((char const   *)sshtext);
#line 293
    sshlval.string = (unsigned char *)tmp___133;
    }
#line 294
    return (285);
#line 296
    goto switch_break;
    case_186: /* CIL Label */ 
#line 297
    return ((int )*(sshtext + 0));
#line 298
    goto switch_break;
    case_187: /* CIL Label */ 
#line 303
    __o = & string_stack___1;
#line 303
    if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
      {
#line 303
      _obstack_newchunk(__o, 1);
      }
    }
#line 303
    tmp___134 = __o->next_free;
#line 303
    (__o->next_free) ++;
#line 303
    *tmp___134 = (char )'\000';
#line 304
    __o1 = & string_stack___1;
#line 304
    value___0 = (void *)__o1->object_base;
#line 304
    if ((unsigned long )__o1->next_free == (unsigned long )value___0) {
#line 304
      __o1->maybe_empty_object = 1U;
    }
#line 304
    __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 304
    if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 304
      __o1->next_free = __o1->chunk_limit;
    }
#line 304
    __o1->object_base = __o1->next_free;
#line 304
    string = (unsigned char *)value___0;
#line 306
    __o___0 = & string_stack___1;
#line 306
    __obj = (void *)string;
#line 306
    if ((unsigned long )__obj > (unsigned long )((void *)__o___0->chunk)) {
#line 306
      if ((unsigned long )__obj < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 306
        tmp___135 = (char *)__obj;
#line 306
        __o___0->object_base = tmp___135;
#line 306
        __o___0->next_free = tmp___135;
      } else {
        {
#line 306
        obstack_free(__o___0, __obj);
        }
      }
    } else {
      {
#line 306
      obstack_free(__o___0, __obj);
      }
    }
    {
#line 308
    yy_start___3 = 1;
#line 309
    tmp___136 = xstrdup((char const   *)string);
#line 309
    sshlval.string = (unsigned char *)tmp___136;
    }
#line 310
    return (285);
#line 312
    goto switch_break;
    case_188: /* CIL Label */ 
#line 314
    value___1 = (int )*(sshtext + 1) - 48;
#line 315
    cursor___0 = sshtext + 2;
    {
#line 317
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 317
      if (! *cursor___0) {
#line 317
        goto while_break___4;
      }
#line 318
      tmp___137 = cursor___0;
#line 318
      cursor___0 ++;
#line 318
      value___1 = (8 * value___1 + (int )*tmp___137) - 48;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 319
    __o___1 = & string_stack___1;
#line 319
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 319
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 319
    tmp___138 = __o___1->next_free;
#line 319
    (__o___1->next_free) ++;
#line 319
    *tmp___138 = (char )value___1;
#line 321
    goto switch_break;
    case_189: /* CIL Label */ 
#line 323
    value___2 = 0;
#line 324
    cursor___1 = sshtext + 2;
    {
#line 326
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 326
      if (! *cursor___1) {
#line 326
        goto while_break___5;
      }
#line 327
      if ((int )*cursor___1 >= 97) {
#line 327
        if ((int )*cursor___1 <= 102) {
#line 328
          tmp___139 = cursor___1;
#line 328
          cursor___1 ++;
#line 328
          value___2 = ((16 * value___2 + (int )*tmp___139) - 97) + 10;
        } else {
#line 327
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 329
      if ((int )*cursor___1 >= 65) {
#line 329
        if ((int )*cursor___1 <= 70) {
#line 330
          tmp___140 = cursor___1;
#line 330
          cursor___1 ++;
#line 330
          value___2 = ((16 * value___2 + (int )*tmp___140) - 65) + 10;
        } else {
#line 332
          tmp___141 = cursor___1;
#line 332
          cursor___1 ++;
#line 332
          value___2 = (16 * value___2 + (int )*tmp___141) - 48;
        }
      } else {
#line 332
        tmp___141 = cursor___1;
#line 332
        cursor___1 ++;
#line 332
        value___2 = (16 * value___2 + (int )*tmp___141) - 48;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 333
    __o___2 = & string_stack___1;
#line 333
    if ((unsigned long )(__o___2->next_free + 1) > (unsigned long )__o___2->chunk_limit) {
      {
#line 333
      _obstack_newchunk(__o___2, 1);
      }
    }
#line 333
    tmp___142 = __o___2->next_free;
#line 333
    (__o___2->next_free) ++;
#line 333
    *tmp___142 = (char )value___2;
#line 335
    goto switch_break;
    case_190: /* CIL Label */ 
#line 336
    __o___3 = & string_stack___1;
#line 336
    if ((unsigned long )(__o___3->next_free + 1) > (unsigned long )__o___3->chunk_limit) {
      {
#line 336
      _obstack_newchunk(__o___3, 1);
      }
    }
#line 336
    tmp___143 = __o___3->next_free;
#line 336
    (__o___3->next_free) ++;
#line 336
    *tmp___143 = (char )'\a';
#line 337
    goto switch_break;
    case_191: /* CIL Label */ 
#line 337
    __o___4 = & string_stack___1;
#line 337
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 337
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 337
    tmp___144 = __o___4->next_free;
#line 337
    (__o___4->next_free) ++;
#line 337
    *tmp___144 = (char )'\b';
#line 338
    goto switch_break;
    case_192: /* CIL Label */ 
#line 338
    __o___5 = & string_stack___1;
#line 338
    if ((unsigned long )(__o___5->next_free + 1) > (unsigned long )__o___5->chunk_limit) {
      {
#line 338
      _obstack_newchunk(__o___5, 1);
      }
    }
#line 338
    tmp___145 = __o___5->next_free;
#line 338
    (__o___5->next_free) ++;
#line 338
    *tmp___145 = (char)127;
#line 339
    goto switch_break;
    case_193: /* CIL Label */ 
#line 339
    __o___6 = & string_stack___1;
#line 339
    if ((unsigned long )(__o___6->next_free + 1) > (unsigned long )__o___6->chunk_limit) {
      {
#line 339
      _obstack_newchunk(__o___6, 1);
      }
    }
#line 339
    tmp___146 = __o___6->next_free;
#line 339
    (__o___6->next_free) ++;
#line 339
    *tmp___146 = (char)27;
#line 340
    goto switch_break;
    case_194: /* CIL Label */ 
#line 340
    __o___7 = & string_stack___1;
#line 340
    if ((unsigned long )(__o___7->next_free + 1) > (unsigned long )__o___7->chunk_limit) {
      {
#line 340
      _obstack_newchunk(__o___7, 1);
      }
    }
#line 340
    tmp___147 = __o___7->next_free;
#line 340
    (__o___7->next_free) ++;
#line 340
    *tmp___147 = (char )'\f';
#line 341
    goto switch_break;
    case_195: /* CIL Label */ 
#line 341
    __o___8 = & string_stack___1;
#line 341
    if ((unsigned long )(__o___8->next_free + 1) > (unsigned long )__o___8->chunk_limit) {
      {
#line 341
      _obstack_newchunk(__o___8, 1);
      }
    }
#line 341
    tmp___148 = __o___8->next_free;
#line 341
    (__o___8->next_free) ++;
#line 341
    *tmp___148 = (char )'\n';
#line 342
    goto switch_break;
    case_196: /* CIL Label */ 
#line 342
    __o___9 = & string_stack___1;
#line 342
    if ((unsigned long )(__o___9->next_free + 1) > (unsigned long )__o___9->chunk_limit) {
      {
#line 342
      _obstack_newchunk(__o___9, 1);
      }
    }
#line 342
    tmp___149 = __o___9->next_free;
#line 342
    (__o___9->next_free) ++;
#line 342
    *tmp___149 = (char )'\r';
#line 343
    goto switch_break;
    case_197: /* CIL Label */ 
#line 343
    __o___10 = & string_stack___1;
#line 343
    if ((unsigned long )(__o___10->next_free + 1) > (unsigned long )__o___10->chunk_limit) {
      {
#line 343
      _obstack_newchunk(__o___10, 1);
      }
    }
#line 343
    tmp___150 = __o___10->next_free;
#line 343
    (__o___10->next_free) ++;
#line 343
    *tmp___150 = (char )'\t';
#line 344
    goto switch_break;
    case_198: /* CIL Label */ 
#line 344
    __o___11 = & string_stack___1;
#line 344
    if ((unsigned long )(__o___11->next_free + 1) > (unsigned long )__o___11->chunk_limit) {
      {
#line 344
      _obstack_newchunk(__o___11, 1);
      }
    }
#line 344
    tmp___151 = __o___11->next_free;
#line 344
    (__o___11->next_free) ++;
#line 344
    *tmp___151 = (char )'\v';
#line 345
    goto switch_break;
    case_199: /* CIL Label */ 
#line 345
    __o___12 = & string_stack___1;
#line 345
    if ((unsigned long )(__o___12->next_free + 1) > (unsigned long )__o___12->chunk_limit) {
      {
#line 345
      _obstack_newchunk(__o___12, 1);
      }
    }
#line 345
    tmp___152 = __o___12->next_free;
#line 345
    (__o___12->next_free) ++;
#line 345
    *tmp___152 = *(sshtext + 1);
#line 346
    goto switch_break;
    case_200: /* CIL Label */ 
    {
#line 348
    tmp___153 = gettext("end-of-line in string constant");
#line 348
    ssherror((char const   *)tmp___153);
    }
#line 350
    goto switch_break;
    case_201: /* CIL Label */ 
#line 352
    __o___13 = & string_stack___1;
#line 352
    __len = sshleng;
#line 352
    if ((unsigned long )(__o___13->next_free + __len) > (unsigned long )__o___13->chunk_limit) {
      {
#line 352
      _obstack_newchunk(__o___13, __len);
      }
    }
    {
#line 352
    memcpy((void */* __restrict  */)__o___13->next_free, (void const   */* __restrict  */)sshtext,
           (size_t )__len);
#line 352
    __o___13->next_free += __len;
    }
#line 354
    goto switch_break;
    case_202: /* CIL Label */ 
#line 362
    __o___14 = & string_stack___1;
#line 362
    if ((unsigned long )(__o___14->next_free + 1) > (unsigned long )__o___14->chunk_limit) {
      {
#line 362
      _obstack_newchunk(__o___14, 1);
      }
    }
#line 362
    tmp___154 = __o___14->next_free;
#line 362
    (__o___14->next_free) ++;
#line 362
    *tmp___154 = (char )'\000';
#line 363
    __o___15 = & string_stack___1;
#line 363
    pattern_len = (int )((unsigned int )(__o___15->next_free - __o___15->object_base));
#line 364
    __o1___0 = & string_stack___1;
#line 364
    value___3 = (void *)__o1___0->object_base;
#line 364
    if ((unsigned long )__o1___0->next_free == (unsigned long )value___3) {
#line 364
      __o1___0->maybe_empty_object = 1U;
    }
#line 364
    __o1___0->next_free = (char *)0 + (((__o1___0->next_free - (char *)0) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 364
    if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 364
      __o1___0->next_free = __o1___0->chunk_limit;
    }
#line 364
    __o1___0->object_base = __o1___0->next_free;
#line 364
    pattern = (char *)value___3;
#line 365
    __o___16 = & string_stack___1;
#line 365
    __obj___0 = (void *)pattern;
#line 365
    if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___16->chunk)) {
#line 365
      if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___16->chunk_limit)) {
#line 365
        tmp___155 = (char *)__obj___0;
#line 365
        __o___16->object_base = tmp___155;
#line 365
        __o___16->next_free = tmp___155;
      } else {
        {
#line 365
        obstack_free(__o___16, __obj___0);
        }
      }
    } else {
      {
#line 365
      obstack_free(__o___16, __obj___0);
      }
    }
    {
#line 367
    tmp___156 = xmalloc((size_t )sizeof(struct pattern ));
#line 367
    sshlval.pattern = (struct pattern *)tmp___156;
#line 371
    (sshlval.pattern)->len = (size_t )(pattern_len - 1);
#line 372
    tmp___157 = xmalloc((size_t )(sizeof(char ) * (unsigned long )pattern_len));
#line 372
    (sshlval.pattern)->pattern = (char *)tmp___157;
#line 373
    memcpy((void */* __restrict  */)(sshlval.pattern)->pattern, (void const   */* __restrict  */)pattern,
           (size_t )pattern_len);
#line 375
    yy_start___3 = 1;
    }
#line 376
    return (287);
#line 378
    goto switch_break;
    case_203: /* CIL Label */ 
#line 380
    value___4 = (int )*(sshtext + 1) - 48;
#line 381
    cursor___2 = sshtext + 2;
    {
#line 383
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 383
      if (! *cursor___2) {
#line 383
        goto while_break___6;
      }
#line 384
      tmp___158 = cursor___2;
#line 384
      cursor___2 ++;
#line 384
      value___4 = (8 * value___4 + (int )*tmp___158) - 48;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 385
    __o___17 = & string_stack___1;
#line 385
    if ((unsigned long )(__o___17->next_free + 1) > (unsigned long )__o___17->chunk_limit) {
      {
#line 385
      _obstack_newchunk(__o___17, 1);
      }
    }
#line 385
    tmp___159 = __o___17->next_free;
#line 385
    (__o___17->next_free) ++;
#line 385
    *tmp___159 = (char )value___4;
#line 387
    goto switch_break;
    case_204: /* CIL Label */ 
#line 389
    value___5 = 0;
#line 390
    cursor___3 = sshtext + 2;
    {
#line 392
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 392
      if (! *cursor___3) {
#line 392
        goto while_break___7;
      }
#line 393
      if ((int )*cursor___3 >= 97) {
#line 393
        if ((int )*cursor___3 <= 102) {
#line 394
          tmp___160 = cursor___3;
#line 394
          cursor___3 ++;
#line 394
          value___5 = ((16 * value___5 + (int )*tmp___160) - 97) + 10;
        } else {
#line 393
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 395
      if ((int )*cursor___3 >= 65) {
#line 395
        if ((int )*cursor___3 <= 70) {
#line 396
          tmp___161 = cursor___3;
#line 396
          cursor___3 ++;
#line 396
          value___5 = ((16 * value___5 + (int )*tmp___161) - 65) + 10;
        } else {
#line 398
          tmp___162 = cursor___3;
#line 398
          cursor___3 ++;
#line 398
          value___5 = (16 * value___5 + (int )*tmp___162) - 48;
        }
      } else {
#line 398
        tmp___162 = cursor___3;
#line 398
        cursor___3 ++;
#line 398
        value___5 = (16 * value___5 + (int )*tmp___162) - 48;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 399
    __o___18 = & string_stack___1;
#line 399
    if ((unsigned long )(__o___18->next_free + 1) > (unsigned long )__o___18->chunk_limit) {
      {
#line 399
      _obstack_newchunk(__o___18, 1);
      }
    }
#line 399
    tmp___163 = __o___18->next_free;
#line 399
    (__o___18->next_free) ++;
#line 399
    *tmp___163 = (char )value___5;
#line 401
    goto switch_break;
    case_205: /* CIL Label */ 
#line 402
    __o___19 = & string_stack___1;
#line 402
    if ((unsigned long )(__o___19->next_free + 1) > (unsigned long )__o___19->chunk_limit) {
      {
#line 402
      _obstack_newchunk(__o___19, 1);
      }
    }
#line 402
    tmp___164 = __o___19->next_free;
#line 402
    (__o___19->next_free) ++;
#line 402
    *tmp___164 = (char )'\a';
#line 403
    goto switch_break;
    case_206: /* CIL Label */ 
#line 403
    __o___20 = & string_stack___1;
#line 403
    if ((unsigned long )(__o___20->next_free + 1) > (unsigned long )__o___20->chunk_limit) {
      {
#line 403
      _obstack_newchunk(__o___20, 1);
      }
    }
#line 403
    tmp___165 = __o___20->next_free;
#line 403
    (__o___20->next_free) ++;
#line 403
    *tmp___165 = (char )'\b';
#line 404
    goto switch_break;
    case_207: /* CIL Label */ 
#line 404
    __o___21 = & string_stack___1;
#line 404
    if ((unsigned long )(__o___21->next_free + 1) > (unsigned long )__o___21->chunk_limit) {
      {
#line 404
      _obstack_newchunk(__o___21, 1);
      }
    }
#line 404
    tmp___166 = __o___21->next_free;
#line 404
    (__o___21->next_free) ++;
#line 404
    *tmp___166 = (char)127;
#line 405
    goto switch_break;
    case_208: /* CIL Label */ 
#line 405
    __o___22 = & string_stack___1;
#line 405
    if ((unsigned long )(__o___22->next_free + 1) > (unsigned long )__o___22->chunk_limit) {
      {
#line 405
      _obstack_newchunk(__o___22, 1);
      }
    }
#line 405
    tmp___167 = __o___22->next_free;
#line 405
    (__o___22->next_free) ++;
#line 405
    *tmp___167 = (char)27;
#line 406
    goto switch_break;
    case_209: /* CIL Label */ 
#line 406
    __o___23 = & string_stack___1;
#line 406
    if ((unsigned long )(__o___23->next_free + 1) > (unsigned long )__o___23->chunk_limit) {
      {
#line 406
      _obstack_newchunk(__o___23, 1);
      }
    }
#line 406
    tmp___168 = __o___23->next_free;
#line 406
    (__o___23->next_free) ++;
#line 406
    *tmp___168 = (char )'\f';
#line 407
    goto switch_break;
    case_210: /* CIL Label */ 
#line 407
    __o___24 = & string_stack___1;
#line 407
    if ((unsigned long )(__o___24->next_free + 1) > (unsigned long )__o___24->chunk_limit) {
      {
#line 407
      _obstack_newchunk(__o___24, 1);
      }
    }
#line 407
    tmp___169 = __o___24->next_free;
#line 407
    (__o___24->next_free) ++;
#line 407
    *tmp___169 = (char )'\n';
#line 408
    goto switch_break;
    case_211: /* CIL Label */ 
#line 408
    __o___25 = & string_stack___1;
#line 408
    if ((unsigned long )(__o___25->next_free + 1) > (unsigned long )__o___25->chunk_limit) {
      {
#line 408
      _obstack_newchunk(__o___25, 1);
      }
    }
#line 408
    tmp___170 = __o___25->next_free;
#line 408
    (__o___25->next_free) ++;
#line 408
    *tmp___170 = (char )'\r';
#line 409
    goto switch_break;
    case_212: /* CIL Label */ 
#line 409
    __o___26 = & string_stack___1;
#line 409
    if ((unsigned long )(__o___26->next_free + 1) > (unsigned long )__o___26->chunk_limit) {
      {
#line 409
      _obstack_newchunk(__o___26, 1);
      }
    }
#line 409
    tmp___171 = __o___26->next_free;
#line 409
    (__o___26->next_free) ++;
#line 409
    *tmp___171 = (char )'\t';
#line 410
    goto switch_break;
    case_213: /* CIL Label */ 
#line 410
    __o___27 = & string_stack___1;
#line 410
    if ((unsigned long )(__o___27->next_free + 1) > (unsigned long )__o___27->chunk_limit) {
      {
#line 410
      _obstack_newchunk(__o___27, 1);
      }
    }
#line 410
    tmp___172 = __o___27->next_free;
#line 410
    (__o___27->next_free) ++;
#line 410
    *tmp___172 = (char )'\v';
#line 411
    goto switch_break;
    case_214: /* CIL Label */ 
#line 411
    __o___28 = & string_stack___1;
#line 411
    if ((unsigned long )(__o___28->next_free + 1) > (unsigned long )__o___28->chunk_limit) {
      {
#line 411
      _obstack_newchunk(__o___28, 1);
      }
    }
#line 411
    tmp___173 = __o___28->next_free;
#line 411
    (__o___28->next_free) ++;
#line 411
    *tmp___173 = *(sshtext + 1);
#line 412
    goto switch_break;
    case_215: /* CIL Label */ 
    {
#line 414
    tmp___174 = gettext("end of line inside a %s");
#line 414
    error_at_line(1, 0, sshfilename, (unsigned int )sshlineno, (char const   *)tmp___174,
                  "\"..\"");
    }
#line 417
    goto switch_break;
    case_216: /* CIL Label */ 
#line 419
    __o___29 = & string_stack___1;
#line 419
    __len___0 = sshleng;
#line 419
    if ((unsigned long )(__o___29->next_free + __len___0) > (unsigned long )__o___29->chunk_limit) {
      {
#line 419
      _obstack_newchunk(__o___29, __len___0);
      }
    }
    {
#line 419
    memcpy((void */* __restrict  */)__o___29->next_free, (void const   */* __restrict  */)sshtext,
           (size_t )__len___0);
#line 419
    __o___29->next_free += __len___0;
    }
#line 421
    goto switch_break;
    case_217: /* CIL Label */ 
    {
#line 423
    fwrite((void const   */* __restrict  */)sshtext, (size_t )sshleng, (size_t )1,
           (FILE */* __restrict  */)sshout);
    }
#line 424
    goto switch_break;
    case_221: /* CIL Label */ 
    case_220: /* CIL Label */ 
    case_219: /* CIL Label */ 
#line 2533 "lexssh.c"
    return (0);
    case_218: /* CIL Label */ 
#line 2538
    yy_amount_of_matched_text = (int )(yy_cp - sshtext) - 1;
#line 2541
    *yy_cp = yy_hold_char___3;
#line 2544
    if ((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_buffer_status == 0) {
#line 2555
      yy_n_chars___3 = (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_n_chars;
#line 2556
      (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_input_file = sshin;
#line 2557
      (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_buffer_status = 1;
    }
#line 2567
    if ((unsigned long )yy_c_buf_p___3 <= (unsigned long )((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_ch_buf + yy_n_chars___3)) {
      {
#line 2571
      yy_c_buf_p___3 = sshtext + yy_amount_of_matched_text;
#line 2573
      yy_current_state = yy_get_previous_state___3();
#line 2584
      yy_next_state = yy_try_NUL_trans___3(yy_current_state);
#line 2586
      yy_bp = sshtext + 0;
      }
#line 2588
      if (yy_next_state) {
#line 2591
        yy_c_buf_p___3 ++;
#line 2591
        yy_cp = yy_c_buf_p___3;
#line 2592
        yy_current_state = yy_next_state;
#line 2593
        goto yy_match;
      } else {
#line 2598
        yy_cp = yy_c_buf_p___3;
#line 2599
        goto yy_find_action;
      }
    } else {
      {
#line 2603
      tmp___175 = yy_get_next_buffer___3();
      }
      {
#line 2605
      if (tmp___175 == 1) {
#line 2605
        goto case_1___0;
      }
#line 2634
      if (tmp___175 == 0) {
#line 2634
        goto case_0___0;
      }
#line 2644
      if (tmp___175 == 2) {
#line 2644
        goto case_2___0;
      }
#line 2603
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 2607
      yy_did_buffer_switch_on_eof___3 = 0;
#line 2609
      tmp___176 = sshwrap();
      }
#line 2609
      if (tmp___176) {
#line 2620
        yy_c_buf_p___3 = sshtext + 0;
#line 2622
        yy_act = (218 + (yy_start___3 - 1) / 2) + 1;
#line 2623
        goto do_action;
      } else
#line 2628
      if (! yy_did_buffer_switch_on_eof___3) {
        {
#line 2629
        sshrestart(sshin);
        }
      }
#line 2631
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 2635
      yy_c_buf_p___3 = sshtext + yy_amount_of_matched_text;
#line 2638
      yy_current_state = yy_get_previous_state___3();
#line 2640
      yy_cp = yy_c_buf_p___3;
#line 2641
      yy_bp = sshtext + 0;
      }
#line 2642
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 2645
      yy_c_buf_p___3 = (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_ch_buf + yy_n_chars___3;
#line 2648
      yy_current_state = yy_get_previous_state___3();
#line 2650
      yy_cp = yy_c_buf_p___3;
#line 2651
      yy_bp = sshtext + 0;
      }
#line 2652
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 2654
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2658
    yy_fatal_error___3("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2671 "lexssh.c"
static int yy_get_next_buffer___3(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 2673
  dest = (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_ch_buf;
#line 2674
  source = sshtext;
#line 2678
  if ((unsigned long )yy_c_buf_p___3 > (unsigned long )((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_ch_buf + (yy_n_chars___3 + 1))) {
    {
#line 2679
    yy_fatal_error___3("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 2682
  if ((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_fill_buffer == 0) {
#line 2684
    if (yy_c_buf_p___3 - sshtext == 1L) {
#line 2689
      return (1);
    } else {
#line 2697
      return (2);
    }
  }
#line 2704
  number_to_move = (int )(yy_c_buf_p___3 - sshtext) - 1;
#line 2706
  i = 0;
  {
#line 2706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2706
    if (! (i < number_to_move)) {
#line 2706
      goto while_break;
    }
#line 2707
    tmp = dest;
#line 2707
    dest ++;
#line 2707
    tmp___0 = source;
#line 2707
    source ++;
#line 2707
    *tmp = *tmp___0;
#line 2706
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2709
  if ((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_buffer_status == 2) {
#line 2713
    yy_n_chars___3 = 0;
#line 2713
    (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_n_chars = yy_n_chars___3;
  } else {
#line 2717
    num_to_read = (int )(((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 2720
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2720
      if (! (num_to_read <= 0)) {
#line 2720
        goto while_break___0;
      }
#line 2724
      if (yy_buffer_stack___3) {
#line 2724
        tmp___1 = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
      } else {
#line 2724
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 2724
      b = tmp___1;
#line 2726
      yy_c_buf_p_offset = (int )(yy_c_buf_p___3 - b->yy_ch_buf);
#line 2729
      if (b->yy_is_our_buffer) {
#line 2731
        new_size = (int )(b->yy_buf_size * 2U);
#line 2733
        if (new_size <= 0) {
#line 2734
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 2736
          b->yy_buf_size *= 2U;
        }
        {
#line 2738
        tmp___2 = sshrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 2738
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 2744
        b->yy_ch_buf = (char *)0;
      }
#line 2746
      if (! b->yy_ch_buf) {
        {
#line 2747
        yy_fatal_error___3("fatal error - scanner input buffer overflow");
        }
      }
#line 2750
      yy_c_buf_p___3 = b->yy_ch_buf + yy_c_buf_p_offset;
#line 2752
      num_to_read = (int )(((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2757
    if (num_to_read > 8192) {
#line 2758
      num_to_read = 8192;
    }
#line 2761
    if ((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_is_interactive) {
#line 2761
      c = '*';
#line 2761
      n = (size_t )0;
      {
#line 2761
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2761
        if (n < (size_t )num_to_read) {
          {
#line 2761
          c = _IO_getc(sshin);
          }
#line 2761
          if (c != -1) {
#line 2761
            if (! (c != 10)) {
#line 2761
              goto while_break___1;
            }
          } else {
#line 2761
            goto while_break___1;
          }
        } else {
#line 2761
          goto while_break___1;
        }
#line 2761
        *(((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 2761
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2761
      if (c == 10) {
#line 2761
        tmp___3 = n;
#line 2761
        n ++;
#line 2761
        *(((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 2761
      if (c == -1) {
        {
#line 2761
        tmp___4 = ferror(sshin);
        }
#line 2761
        if (tmp___4) {
          {
#line 2761
          yy_fatal_error___3("input in flex scanner failed");
          }
        }
      }
#line 2761
      yy_n_chars___3 = (int )n;
    } else {
      {
#line 2761
      tmp___5 = __errno_location();
#line 2761
      *tmp___5 = 0;
      }
      {
#line 2761
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 2761
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)sshin);
#line 2761
        yy_n_chars___3 = (int )tmp___8;
        }
#line 2761
        if (yy_n_chars___3 == 0) {
          {
#line 2761
          tmp___9 = ferror(sshin);
          }
#line 2761
          if (! tmp___9) {
#line 2761
            goto while_break___2;
          }
        } else {
#line 2761
          goto while_break___2;
        }
        {
#line 2761
        tmp___6 = __errno_location();
        }
#line 2761
        if (*tmp___6 != 4) {
          {
#line 2761
          yy_fatal_error___3("input in flex scanner failed");
          }
#line 2761
          goto while_break___2;
        }
        {
#line 2761
        tmp___7 = __errno_location();
#line 2761
        *tmp___7 = 0;
#line 2761
        clearerr(sshin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 2764
    (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_n_chars = yy_n_chars___3;
  }
#line 2767
  if (yy_n_chars___3 == 0) {
#line 2769
    if (number_to_move == 0) {
      {
#line 2771
      ret_val = 1;
#line 2772
      sshrestart(sshin);
      }
    } else {
#line 2777
      ret_val = 2;
#line 2778
      (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_buffer_status = 2;
    }
  } else {
#line 2784
    ret_val = 0;
  }
#line 2786
  yy_n_chars___3 += number_to_move;
#line 2787
  *((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_ch_buf + yy_n_chars___3) = (char)0;
#line 2788
  *((*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_ch_buf + (yy_n_chars___3 + 1)) = (char)0;
#line 2790
  sshtext = (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_ch_buf + 0;
#line 2792
  return (ret_val);
}
}
#line 2797 "lexssh.c"
static yy_state_type yy_get_previous_state___3(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 2802
  yy_current_state = yy_start___3;
#line 2804
  yy_cp = sshtext + 0;
  {
#line 2804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2804
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p___3)) {
#line 2804
      goto while_break;
    }
#line 2806
    if (*yy_cp) {
#line 2806
      tmp = yy_ec___3[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 2806
      tmp = (flex_int32_t const   )1;
    }
#line 2806
    yy_c = (YY_CHAR )tmp;
#line 2807
    if (yy_accept___3[yy_current_state]) {
#line 2809
      yy_last_accepting_state___3 = yy_current_state;
#line 2810
      yy_last_accepting_cpos___3 = yy_cp;
    }
    {
#line 2812
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2812
      if (! ((int const   )yy_chk___3[(int const   )yy_base___3[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2812
        goto while_break___0;
      }
#line 2814
      yy_current_state = (int )yy_def___3[yy_current_state];
#line 2815
      if (yy_current_state >= 901) {
#line 2816
        yy_c = (YY_CHAR )yy_meta___3[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2818
    yy_current_state = (yy_state_type )yy_nxt___3[(unsigned int )yy_base___3[yy_current_state] + (unsigned int )yy_c];
#line 2804
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2821
  return (yy_current_state);
}
}
#line 2829 "lexssh.c"
static yy_state_type yy_try_NUL_trans___3(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 2832
  yy_cp = yy_c_buf_p___3;
#line 2834
  yy_c = (YY_CHAR )1;
#line 2835
  if (yy_accept___3[yy_current_state]) {
#line 2837
    yy_last_accepting_state___3 = yy_current_state;
#line 2838
    yy_last_accepting_cpos___3 = yy_cp;
  }
  {
#line 2840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2840
    if (! ((int const   )yy_chk___3[(int const   )yy_base___3[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2840
      goto while_break;
    }
#line 2842
    yy_current_state = (int )yy_def___3[yy_current_state];
#line 2843
    if (yy_current_state >= 901) {
#line 2844
      yy_c = (YY_CHAR )yy_meta___3[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2846
  yy_current_state = (yy_state_type )yy_nxt___3[(unsigned int )yy_base___3[yy_current_state] + (unsigned int )yy_c];
#line 2847
  yy_is_jam = yy_current_state == 900;
#line 2849
  if (yy_is_jam) {
#line 2849
    tmp = 0;
  } else {
#line 2849
    tmp = yy_current_state;
  }
#line 2849
  return (tmp);
}
}
#line 2977 "lexssh.c"
void sshrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2980
  if (yy_buffer_stack___3) {
#line 2980
    tmp = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 2980
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2980
  if (! tmp) {
    {
#line 2981
    sshensure_buffer_stack();
#line 2982
    *(yy_buffer_stack___3 + yy_buffer_stack_top___3) = ssh_create_buffer(sshin, 16384);
    }
  }
#line 2986
  if (yy_buffer_stack___3) {
#line 2986
    tmp___0 = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 2986
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2986
  ssh_init_buffer(tmp___0, input_file);
#line 2987
  ssh_load_buffer_state();
  }
#line 2988
  return;
}
}
#line 2994 "lexssh.c"
void ssh_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 3002
  sshensure_buffer_stack();
  }
#line 3003
  if (yy_buffer_stack___3) {
#line 3003
    tmp = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 3003
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3003
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 3004
    return;
  }
#line 3006
  if (yy_buffer_stack___3) {
#line 3006
    tmp___0 = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 3006
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 3006
  if (tmp___0) {
#line 3009
    *yy_c_buf_p___3 = yy_hold_char___3;
#line 3010
    (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_buf_pos = yy_c_buf_p___3;
#line 3011
    (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_n_chars = yy_n_chars___3;
  }
  {
#line 3014
  *(yy_buffer_stack___3 + yy_buffer_stack_top___3) = new_buffer;
#line 3015
  ssh_load_buffer_state();
#line 3022
  yy_did_buffer_switch_on_eof___3 = 1;
  }
#line 3023
  return;
}
}
#line 3025 "lexssh.c"
static void ssh_load_buffer_state(void) 
{ 


  {
#line 3027
  yy_n_chars___3 = (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_n_chars;
#line 3028
  yy_c_buf_p___3 = (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_buf_pos;
#line 3028
  sshtext = yy_c_buf_p___3;
#line 3029
  sshin = (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_input_file;
#line 3030
  yy_hold_char___3 = *yy_c_buf_p___3;
#line 3031
  return;
}
}
#line 3039 "lexssh.c"
YY_BUFFER_STATE ssh_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 3043
  tmp = sshalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 3043
  b = (YY_BUFFER_STATE )tmp;
  }
#line 3044
  if (! b) {
    {
#line 3045
    yy_fatal_error___3("out of dynamic memory in ssh_create_buffer()");
    }
  }
  {
#line 3047
  b->yy_buf_size = (yy_size_t )size;
#line 3052
  tmp___0 = sshalloc(b->yy_buf_size + 2U);
#line 3052
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 3053
  if (! b->yy_ch_buf) {
    {
#line 3054
    yy_fatal_error___3("out of dynamic memory in ssh_create_buffer()");
    }
  }
  {
#line 3056
  b->yy_is_our_buffer = 1;
#line 3058
  ssh_init_buffer(b, file);
  }
#line 3060
  return (b);
}
}
#line 3067 "lexssh.c"
void ssh_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 3070
  if (! b) {
#line 3071
    return;
  }
#line 3073
  if (yy_buffer_stack___3) {
#line 3073
    tmp = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 3073
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3073
  if ((unsigned long )b == (unsigned long )tmp) {
#line 3074
    *(yy_buffer_stack___3 + yy_buffer_stack_top___3) = (YY_BUFFER_STATE )0;
  }
#line 3076
  if (b->yy_is_our_buffer) {
    {
#line 3077
    sshfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 3079
  sshfree((void *)b);
  }
#line 3080
  return;
}
}
#line 3090 "lexssh.c"
static void ssh_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 3093
  tmp = __errno_location();
#line 3093
  oerrno = *tmp;
#line 3095
  ssh_flush_buffer(b);
#line 3097
  b->yy_input_file = file;
#line 3098
  b->yy_fill_buffer = 1;
  }
#line 3104
  if (yy_buffer_stack___3) {
#line 3104
    tmp___0 = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 3104
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 3104
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 3105
    b->yy_bs_lineno = 1;
#line 3106
    b->yy_bs_column = 0;
  }
#line 3109
  if (file) {
    {
#line 3109
    tmp___1 = fileno(file);
#line 3109
    tmp___2 = isatty(tmp___1);
#line 3109
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 3109
    b->yy_is_interactive = 0;
  }
  {
#line 3111
  tmp___3 = __errno_location();
#line 3111
  *tmp___3 = oerrno;
  }
#line 3112
  return;
}
}
#line 3118 "lexssh.c"
void ssh_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 3120
  if (! b) {
#line 3121
    return;
  }
#line 3123
  b->yy_n_chars = 0;
#line 3129
  *(b->yy_ch_buf + 0) = (char)0;
#line 3130
  *(b->yy_ch_buf + 1) = (char)0;
#line 3132
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 3134
  b->yy_at_bol = 1;
#line 3135
  b->yy_buffer_status = 0;
#line 3137
  if (yy_buffer_stack___3) {
#line 3137
    tmp = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 3137
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3137
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 3138
    ssh_load_buffer_state();
    }
  }
#line 3139
  return;
}
}
#line 3147 "lexssh.c"
void sshpush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 3149
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 3150
    return;
  }
  {
#line 3152
  sshensure_buffer_stack();
  }
#line 3155
  if (yy_buffer_stack___3) {
#line 3155
    tmp = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 3155
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3155
  if (tmp) {
#line 3158
    *yy_c_buf_p___3 = yy_hold_char___3;
#line 3159
    (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_buf_pos = yy_c_buf_p___3;
#line 3160
    (*(yy_buffer_stack___3 + yy_buffer_stack_top___3))->yy_n_chars = yy_n_chars___3;
  }
#line 3164
  if (yy_buffer_stack___3) {
#line 3164
    tmp___0 = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 3164
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 3164
  if (tmp___0) {
#line 3165
    yy_buffer_stack_top___3 ++;
  }
  {
#line 3166
  *(yy_buffer_stack___3 + yy_buffer_stack_top___3) = new_buffer;
#line 3169
  ssh_load_buffer_state();
#line 3170
  yy_did_buffer_switch_on_eof___3 = 1;
  }
#line 3171
  return;
}
}
#line 3177 "lexssh.c"
void sshpop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 3179
  if (yy_buffer_stack___3) {
#line 3179
    tmp = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 3179
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3179
  if (! tmp) {
#line 3180
    return;
  }
#line 3182
  if (yy_buffer_stack___3) {
#line 3182
    tmp___0 = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 3182
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 3182
  ssh_delete_buffer(tmp___0);
#line 3183
  *(yy_buffer_stack___3 + yy_buffer_stack_top___3) = (YY_BUFFER_STATE )((void *)0);
  }
#line 3184
  if (yy_buffer_stack_top___3 > 0U) {
#line 3185
    yy_buffer_stack_top___3 --;
  }
#line 3187
  if (yy_buffer_stack___3) {
#line 3187
    tmp___1 = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
  } else {
#line 3187
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 3187
  if (tmp___1) {
    {
#line 3188
    ssh_load_buffer_state();
#line 3189
    yy_did_buffer_switch_on_eof___3 = 1;
    }
  }
#line 3191
  return;
}
}
#line 3196 "lexssh.c"
static void sshensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 3200
  if (! yy_buffer_stack___3) {
    {
#line 3206
    num_to_alloc = 1;
#line 3207
    tmp = sshalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 3207
    yy_buffer_stack___3 = (struct yy_buffer_state **)tmp;
#line 3211
    memset((void *)yy_buffer_stack___3, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 3213
    yy_buffer_stack_max___3 = (size_t )num_to_alloc;
#line 3214
    yy_buffer_stack_top___3 = (size_t )0;
    }
#line 3215
    return;
  }
#line 3218
  if (yy_buffer_stack_top___3 >= yy_buffer_stack_max___3 - 1U) {
    {
#line 3221
    grow_size = 8;
#line 3223
    num_to_alloc = (int )(yy_buffer_stack_max___3 + (size_t )grow_size);
#line 3224
    tmp___0 = sshrealloc((void *)yy_buffer_stack___3, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 3224
    yy_buffer_stack___3 = (struct yy_buffer_state **)tmp___0;
#line 3230
    memset((void *)(yy_buffer_stack___3 + yy_buffer_stack_max___3), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 3231
    yy_buffer_stack_max___3 = (size_t )num_to_alloc;
    }
  }
#line 3233
  return;
}
}
#line 3241 "lexssh.c"
YY_BUFFER_STATE ssh_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 3245
  if (size < 2U) {
#line 3249
    return ((YY_BUFFER_STATE )0);
  } else
#line 3245
  if ((int )*(base + (size - 2U)) != 0) {
#line 3249
    return ((YY_BUFFER_STATE )0);
  } else
#line 3245
  if ((int )*(base + (size - 1U)) != 0) {
#line 3249
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 3251
  tmp = sshalloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 3251
  b = (YY_BUFFER_STATE )tmp;
  }
#line 3252
  if (! b) {
    {
#line 3253
    yy_fatal_error___3("out of dynamic memory in ssh_scan_buffer()");
    }
  }
  {
#line 3255
  b->yy_buf_size = size - 2U;
#line 3256
  tmp___0 = base;
#line 3256
  b->yy_ch_buf = tmp___0;
#line 3256
  b->yy_buf_pos = tmp___0;
#line 3257
  b->yy_is_our_buffer = 0;
#line 3258
  b->yy_input_file = (FILE *)0;
#line 3259
  b->yy_n_chars = (int )b->yy_buf_size;
#line 3260
  b->yy_is_interactive = 0;
#line 3261
  b->yy_at_bol = 1;
#line 3262
  b->yy_fill_buffer = 0;
#line 3263
  b->yy_buffer_status = 0;
#line 3265
  ssh_switch_to_buffer(b);
  }
#line 3267
  return (b);
}
}
#line 3278 "lexssh.c"
YY_BUFFER_STATE ssh_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 3281
  tmp = strlen(yystr);
#line 3281
  tmp___0 = ssh_scan_bytes(yystr, (int )tmp);
  }
#line 3281
  return (tmp___0);
}
}
#line 3291 "lexssh.c"
YY_BUFFER_STATE ssh_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___0 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 3299
  n = (yy_size_t )(_yybytes_len + 2);
#line 3300
  tmp = sshalloc(n);
#line 3300
  buf___0 = (char *)tmp;
  }
#line 3301
  if (! buf___0) {
    {
#line 3302
    yy_fatal_error___3("out of dynamic memory in ssh_scan_bytes()");
    }
  }
#line 3304
  i = 0;
  {
#line 3304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3304
    if (! (i < _yybytes_len)) {
#line 3304
      goto while_break;
    }
#line 3305
    *(buf___0 + i) = (char )*(yybytes + i);
#line 3304
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3307
  tmp___0 = (char)0;
#line 3307
  *(buf___0 + (_yybytes_len + 1)) = tmp___0;
#line 3307
  *(buf___0 + _yybytes_len) = tmp___0;
#line 3309
  b = ssh_scan_buffer(buf___0, n);
  }
#line 3310
  if (! b) {
    {
#line 3311
    yy_fatal_error___3("bad buffer in ssh_scan_bytes()");
    }
  }
#line 3316
  b->yy_is_our_buffer = 1;
#line 3318
  return (b);
}
}
#line 3325 "lexssh.c"
static void yy_fatal_error___3(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 3327
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 3328
  exit(2);
  }
}
}
#line 3353 "lexssh.c"
int sshget_lineno(void) 
{ 


  {
#line 3356
  return (sshlineno);
}
}
#line 3362 "lexssh.c"
FILE *sshget_in(void) 
{ 


  {
#line 3364
  return (sshin);
}
}
#line 3370 "lexssh.c"
FILE *sshget_out(void) 
{ 


  {
#line 3372
  return (sshout);
}
}
#line 3378 "lexssh.c"
int sshget_leng(void) 
{ 


  {
#line 3380
  return (sshleng);
}
}
#line 3387 "lexssh.c"
char *sshget_text(void) 
{ 


  {
#line 3389
  return (sshtext);
}
}
#line 3396 "lexssh.c"
void sshset_lineno(int line_number ) 
{ 


  {
#line 3399
  sshlineno = line_number;
#line 3400
  return;
}
}
#line 3408 "lexssh.c"
void sshset_in(FILE *in_str ) 
{ 


  {
#line 3410
  sshin = in_str;
#line 3411
  return;
}
}
#line 3413 "lexssh.c"
void sshset_out(FILE *out_str ) 
{ 


  {
#line 3415
  sshout = out_str;
#line 3416
  return;
}
}
#line 3418 "lexssh.c"
int sshget_debug(void) 
{ 


  {
#line 3420
  return (ssh_flex_debug);
}
}
#line 3423 "lexssh.c"
void sshset_debug(int bdebug ) 
{ 


  {
#line 3425
  ssh_flex_debug = bdebug;
#line 3426
  return;
}
}
#line 3428 "lexssh.c"
static int yy_init_globals___3(void) 
{ 


  {
#line 3435
  sshlineno = 1;
#line 3437
  yy_buffer_stack___3 = (YY_BUFFER_STATE *)0;
#line 3438
  yy_buffer_stack_top___3 = (size_t )0;
#line 3439
  yy_buffer_stack_max___3 = (size_t )0;
#line 3440
  yy_c_buf_p___3 = (char *)0;
#line 3441
  yy_init___3 = 0;
#line 3442
  yy_start___3 = 0;
#line 3449
  sshin = (FILE *)0;
#line 3450
  sshout = (FILE *)0;
#line 3456
  return (0);
}
}
#line 3460 "lexssh.c"
int sshlex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 3464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3464
    if (yy_buffer_stack___3) {
#line 3464
      tmp___0 = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
    } else {
#line 3464
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 3464
    if (! tmp___0) {
#line 3464
      goto while_break;
    }
#line 3465
    if (yy_buffer_stack___3) {
#line 3465
      tmp = *(yy_buffer_stack___3 + yy_buffer_stack_top___3);
    } else {
#line 3465
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 3465
    ssh_delete_buffer(tmp);
#line 3466
    *(yy_buffer_stack___3 + yy_buffer_stack_top___3) = (YY_BUFFER_STATE )((void *)0);
#line 3467
    sshpop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3471
  sshfree((void *)yy_buffer_stack___3);
#line 3472
  yy_buffer_stack___3 = (YY_BUFFER_STATE *)((void *)0);
#line 3476
  yy_init_globals___3();
  }
#line 3478
  return (0);
}
}
#line 3505 "lexssh.c"
void *sshalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 3507
  tmp = malloc(size);
  }
#line 3507
  return (tmp);
}
}
#line 3510 "lexssh.c"
void *sshrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 3519
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 3519
  return (tmp);
}
}
#line 3522 "lexssh.c"
void sshfree(void *ptr ) 
{ 


  {
  {
#line 3524
  free((void *)((char *)ptr));
  }
#line 3525
  return;
}
}
#line 426 "lexssh.l"
int sshwrap(void) 
{ 


  {
#line 429
  return (1);
}
}
#line 438 "lexssh.l"
static int first_time___3  =    1;
#line 435 "lexssh.l"
void sshlex_initialize(void) 
{ 


  {
#line 439
  if (first_time___3) {
    {
#line 441
    first_time___3 = 0;
#line 442
    _obstack_begin(& string_stack___1, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
    }
  }
#line 444
  return;
}
}
#line 69 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.h"
void fflag_self_print(enum fflag_e flags , FILE *stream ) ;
#line 121
struct fface_s Plain_fface ;
#line 122
struct fface_s Symbol_fface ;
#line 123
struct fface_s No_fface ;
#line 155 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.h"
struct faced_string *faced_string_new(unsigned char *string , int reg_ref , struct fface_s face ) ;
#line 161
void style_sheet_set_version(struct style_sheet *sheet , char const   *version_string ) ;
#line 163
int style_sheet_set_requirement(struct style_sheet *sheet , char const   *version_string ) ;
#line 169
struct darray *rhs_new(void) ;
#line 170
struct darray *rhs_new_single(unsigned char *string , int reg_ref , struct fface_s face ) ;
#line 172
void rhs_add(struct darray *dest , struct faced_string *str ) ;
#line 178
struct rule *rule_new(unsigned char *word , struct pattern *pattern , struct darray *rhs ,
                      char const   *filename , size_t line ) ;
#line 182
struct rule *keyword_rule_new(unsigned char *word , struct pattern *pattern , struct darray *rhs ,
                              char const   *filename , size_t line ) ;
#line 193
struct sequence *sequence_new(struct rule *Open , struct fface_s in_face , struct words *Close ,
                              struct words *exceptions ) ;
#line 198
void free_sequence(struct sequence *sequence___0 ) ;
#line 199
struct sequence *new_C_string_sequence(char const   *delimitor ) ;
#line 200
void sequence_self_print(struct sequence *tmp , FILE *stream ) ;
#line 206
struct words *words_new(char const   *name_strings , char const   *name_regexps ,
                        size_t size , size_t increment ) ;
#line 209
void words_free(struct words *words ) ;
#line 210
void words_add_string(struct words *words , struct rule *rule ) ;
#line 211
void words_add_regex(struct words *words , struct rule *rule ) ;
#line 212
void words_set_no_face(struct words *words , struct fface_s face ) ;
#line 213
void words_merge_rules_unique(struct words *words , struct words *new ) ;
#line 219
struct style_sheet *new_style_sheet(unsigned char const   *name ) ;
#line 221
void style_sheet_self_print(struct style_sheet *sheet , FILE *stream ) ;
#line 65 "parsessh.y"
static void yyprint___0(FILE *file , int type , YYSTYPE___0 value ) ;
#line 71
int highlight_level ;
#line 74
struct style_sheet *parse_style_sheet(char const   *filename ) ;
#line 77 "parsessh.y"
static struct style_sheet *parsed_style_sheet  =    (struct style_sheet *)((void *)0);
#line 506 "parsessh.c"
static yytype_uint8 const   yytranslate___0[290]  = 
#line 506 "parsessh.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )2,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34};
#line 542 "parsessh.c"
static yytype_uint16 const   yyprhs___0[93]  = 
#line 542
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )3,      (yytype_uint16 const   )5, 
        (yytype_uint16 const   )12,      (yytype_uint16 const   )13,      (yytype_uint16 const   )19,      (yytype_uint16 const   )24, 
        (yytype_uint16 const   )30,      (yytype_uint16 const   )35,      (yytype_uint16 const   )39,      (yytype_uint16 const   )42, 
        (yytype_uint16 const   )45,      (yytype_uint16 const   )50,      (yytype_uint16 const   )56,      (yytype_uint16 const   )62, 
        (yytype_uint16 const   )65,      (yytype_uint16 const   )68,      (yytype_uint16 const   )71,      (yytype_uint16 const   )74, 
        (yytype_uint16 const   )77,      (yytype_uint16 const   )81,      (yytype_uint16 const   )86,      (yytype_uint16 const   )92, 
        (yytype_uint16 const   )94,      (yytype_uint16 const   )97,      (yytype_uint16 const   )101,      (yytype_uint16 const   )105, 
        (yytype_uint16 const   )108,      (yytype_uint16 const   )114,      (yytype_uint16 const   )116,      (yytype_uint16 const   )120, 
        (yytype_uint16 const   )123,      (yytype_uint16 const   )125,      (yytype_uint16 const   )128,      (yytype_uint16 const   )130, 
        (yytype_uint16 const   )133,      (yytype_uint16 const   )135,      (yytype_uint16 const   )137,      (yytype_uint16 const   )140, 
        (yytype_uint16 const   )142,      (yytype_uint16 const   )144,      (yytype_uint16 const   )146,      (yytype_uint16 const   )150, 
        (yytype_uint16 const   )152,      (yytype_uint16 const   )154,      (yytype_uint16 const   )158,      (yytype_uint16 const   )160, 
        (yytype_uint16 const   )162,      (yytype_uint16 const   )166,      (yytype_uint16 const   )170,      (yytype_uint16 const   )173, 
        (yytype_uint16 const   )175,      (yytype_uint16 const   )180,      (yytype_uint16 const   )186,      (yytype_uint16 const   )190, 
        (yytype_uint16 const   )192,      (yytype_uint16 const   )194,      (yytype_uint16 const   )198,      (yytype_uint16 const   )202, 
        (yytype_uint16 const   )205,      (yytype_uint16 const   )207,      (yytype_uint16 const   )212,      (yytype_uint16 const   )218, 
        (yytype_uint16 const   )222,      (yytype_uint16 const   )224,      (yytype_uint16 const   )226,      (yytype_uint16 const   )230, 
        (yytype_uint16 const   )234,      (yytype_uint16 const   )237,      (yytype_uint16 const   )239,      (yytype_uint16 const   )244, 
        (yytype_uint16 const   )250,      (yytype_uint16 const   )252,      (yytype_uint16 const   )256,      (yytype_uint16 const   )262, 
        (yytype_uint16 const   )269,      (yytype_uint16 const   )275,      (yytype_uint16 const   )281,      (yytype_uint16 const   )286, 
        (yytype_uint16 const   )293,      (yytype_uint16 const   )299,      (yytype_uint16 const   )305,      (yytype_uint16 const   )310, 
        (yytype_uint16 const   )318,      (yytype_uint16 const   )326,      (yytype_uint16 const   )328,      (yytype_uint16 const   )330, 
        (yytype_uint16 const   )331,      (yytype_uint16 const   )333,      (yytype_uint16 const   )335,      (yytype_uint16 const   )339, 
        (yytype_uint16 const   )340};
#line 557 "parsessh.c"
static yytype_int8 const   yyrhs___0[344]  = 
#line 557
  {      (yytype_int8 const   )40,      (yytype_int8 const   )0,      (yytype_int8 const   )-1,      (yytype_int8 const   )41, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )3,      (yytype_int8 const   )30,      (yytype_int8 const   )4, 
        (yytype_int8 const   )42,      (yytype_int8 const   )5,      (yytype_int8 const   )3,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )42,      (yytype_int8 const   )20,      (yytype_int8 const   )6, 
        (yytype_int8 const   )58,      (yytype_int8 const   )6,      (yytype_int8 const   )-1,      (yytype_int8 const   )42, 
        (yytype_int8 const   )6,      (yytype_int8 const   )58,      (yytype_int8 const   )6,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )42,      (yytype_int8 const   )20,      (yytype_int8 const   )9,      (yytype_int8 const   )61, 
        (yytype_int8 const   )9,      (yytype_int8 const   )-1,      (yytype_int8 const   )42,      (yytype_int8 const   )9, 
        (yytype_int8 const   )61,      (yytype_int8 const   )9,      (yytype_int8 const   )-1,      (yytype_int8 const   )42, 
        (yytype_int8 const   )20,      (yytype_int8 const   )64,      (yytype_int8 const   )-1,      (yytype_int8 const   )42, 
        (yytype_int8 const   )64,      (yytype_int8 const   )-1,      (yytype_int8 const   )42,      (yytype_int8 const   )48, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )42,      (yytype_int8 const   )14,      (yytype_int8 const   )7, 
        (yytype_int8 const   )30,      (yytype_int8 const   )-1,      (yytype_int8 const   )42,      (yytype_int8 const   )11, 
        (yytype_int8 const   )13,      (yytype_int8 const   )4,      (yytype_int8 const   )30,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )42,      (yytype_int8 const   )12,      (yytype_int8 const   )13,      (yytype_int8 const   )4, 
        (yytype_int8 const   )30,      (yytype_int8 const   )-1,      (yytype_int8 const   )42,      (yytype_int8 const   )50, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )42,      (yytype_int8 const   )44,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )42,      (yytype_int8 const   )46,      (yytype_int8 const   )-1,      (yytype_int8 const   )42, 
        (yytype_int8 const   )47,      (yytype_int8 const   )-1,      (yytype_int8 const   )42,      (yytype_int8 const   )43, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )30, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )24, 
        (yytype_int8 const   )30,      (yytype_int8 const   )-1,      (yytype_int8 const   )15,      (yytype_int8 const   )4, 
        (yytype_int8 const   )45,      (yytype_int8 const   )5,      (yytype_int8 const   )15,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )30,      (yytype_int8 const   )-1,      (yytype_int8 const   )45,      (yytype_int8 const   )30, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )22,      (yytype_int8 const   )23,      (yytype_int8 const   )30, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )24,      (yytype_int8 const   )4,      (yytype_int8 const   )30, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )24,      (yytype_int8 const   )30,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )27,      (yytype_int8 const   )7,      (yytype_int8 const   )49,      (yytype_int8 const   )5, 
        (yytype_int8 const   )27,      (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )49,      (yytype_int8 const   )35,      (yytype_int8 const   )30,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )17,      (yytype_int8 const   )33,      (yytype_int8 const   )-1,      (yytype_int8 const   )32, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )32,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )53,      (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )55, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )-1,      (yytype_int8 const   )55, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )34,      (yytype_int8 const   )55,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )34,      (yytype_int8 const   )-1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )53,      (yytype_int8 const   )-1,      (yytype_int8 const   )54,      (yytype_int8 const   )35, 
        (yytype_int8 const   )53,      (yytype_int8 const   )-1,      (yytype_int8 const   )28,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )29,      (yytype_int8 const   )-1,      (yytype_int8 const   )36,      (yytype_int8 const   )56, 
        (yytype_int8 const   )37,      (yytype_int8 const   )-1,      (yytype_int8 const   )28,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )29,      (yytype_int8 const   )-1,      (yytype_int8 const   )56,      (yytype_int8 const   )38, 
        (yytype_int8 const   )28,      (yytype_int8 const   )-1,      (yytype_int8 const   )56,      (yytype_int8 const   )38, 
        (yytype_int8 const   )29,      (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )52, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )-1,      (yytype_int8 const   )36, 
        (yytype_int8 const   )30,      (yytype_int8 const   )54,      (yytype_int8 const   )37,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )8,      (yytype_int8 const   )55,      (yytype_int8 const   )7,      (yytype_int8 const   )59, 
        (yytype_int8 const   )5,      (yytype_int8 const   )-1,      (yytype_int8 const   )7,      (yytype_int8 const   )59, 
        (yytype_int8 const   )5,      (yytype_int8 const   )-1,      (yytype_int8 const   )57,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )60,      (yytype_int8 const   )-1,      (yytype_int8 const   )59,      (yytype_int8 const   )35, 
        (yytype_int8 const   )57,      (yytype_int8 const   )-1,      (yytype_int8 const   )59,      (yytype_int8 const   )35, 
        (yytype_int8 const   )60,      (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )52, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )-1,      (yytype_int8 const   )36, 
        (yytype_int8 const   )51,      (yytype_int8 const   )54,      (yytype_int8 const   )37,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )8,      (yytype_int8 const   )55,      (yytype_int8 const   )7,      (yytype_int8 const   )62, 
        (yytype_int8 const   )5,      (yytype_int8 const   )-1,      (yytype_int8 const   )7,      (yytype_int8 const   )62, 
        (yytype_int8 const   )5,      (yytype_int8 const   )-1,      (yytype_int8 const   )57,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )63,      (yytype_int8 const   )-1,      (yytype_int8 const   )62,      (yytype_int8 const   )35, 
        (yytype_int8 const   )57,      (yytype_int8 const   )-1,      (yytype_int8 const   )62,      (yytype_int8 const   )35, 
        (yytype_int8 const   )63,      (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )52, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )-1,      (yytype_int8 const   )36, 
        (yytype_int8 const   )51,      (yytype_int8 const   )54,      (yytype_int8 const   )37,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )10,      (yytype_int8 const   )7,      (yytype_int8 const   )65,      (yytype_int8 const   )5, 
        (yytype_int8 const   )10,      (yytype_int8 const   )-1,      (yytype_int8 const   )66,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )65,      (yytype_int8 const   )35,      (yytype_int8 const   )66,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )55,      (yytype_int8 const   )67, 
        (yytype_int8 const   )68,      (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )30, 
        (yytype_int8 const   )55,      (yytype_int8 const   )55,      (yytype_int8 const   )67,      (yytype_int8 const   )68, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )55,      (yytype_int8 const   )55, 
        (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )-1,      (yytype_int8 const   )30, 
        (yytype_int8 const   )30,      (yytype_int8 const   )55,      (yytype_int8 const   )67,      (yytype_int8 const   )68, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )55,      (yytype_int8 const   )67, 
        (yytype_int8 const   )68,      (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )30, 
        (yytype_int8 const   )55,      (yytype_int8 const   )55,      (yytype_int8 const   )67,      (yytype_int8 const   )68, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )55,      (yytype_int8 const   )55, 
        (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )-1,      (yytype_int8 const   )51, 
        (yytype_int8 const   )30,      (yytype_int8 const   )55,      (yytype_int8 const   )67,      (yytype_int8 const   )68, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )51,      (yytype_int8 const   )55,      (yytype_int8 const   )67, 
        (yytype_int8 const   )68,      (yytype_int8 const   )-1,      (yytype_int8 const   )36,      (yytype_int8 const   )30, 
        (yytype_int8 const   )54,      (yytype_int8 const   )37,      (yytype_int8 const   )55,      (yytype_int8 const   )67, 
        (yytype_int8 const   )68,      (yytype_int8 const   )-1,      (yytype_int8 const   )36,      (yytype_int8 const   )51, 
        (yytype_int8 const   )54,      (yytype_int8 const   )37,      (yytype_int8 const   )55,      (yytype_int8 const   )67, 
        (yytype_int8 const   )68,      (yytype_int8 const   )-1,      (yytype_int8 const   )18,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )19,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )57, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )63,      (yytype_int8 const   )-1,      (yytype_int8 const   )21, 
        (yytype_int8 const   )61,      (yytype_int8 const   )21,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )16,      (yytype_int8 const   )61,      (yytype_int8 const   )16,      (yytype_int8 const   )-1};
#line 597 "parsessh.c"
static yytype_uint16 const   yyrline___0[93]  = 
#line 597
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )129,      (yytype_uint16 const   )129,      (yytype_uint16 const   )136, 
        (yytype_uint16 const   )145,      (yytype_uint16 const   )148,      (yytype_uint16 const   )157,      (yytype_uint16 const   )163, 
        (yytype_uint16 const   )172,      (yytype_uint16 const   )178,      (yytype_uint16 const   )186,      (yytype_uint16 const   )191, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )204,      (yytype_uint16 const   )211,      (yytype_uint16 const   )218, 
        (yytype_uint16 const   )221,      (yytype_uint16 const   )224,      (yytype_uint16 const   )227,      (yytype_uint16 const   )230, 
        (yytype_uint16 const   )245,      (yytype_uint16 const   )246,      (yytype_uint16 const   )249,      (yytype_uint16 const   )251, 
        (yytype_uint16 const   )252,      (yytype_uint16 const   )267,      (yytype_uint16 const   )270,      (yytype_uint16 const   )271, 
        (yytype_uint16 const   )276,      (yytype_uint16 const   )283,      (yytype_uint16 const   )291,      (yytype_uint16 const   )298, 
        (yytype_uint16 const   )306,      (yytype_uint16 const   )310,      (yytype_uint16 const   )322,      (yytype_uint16 const   )330, 
        (yytype_uint16 const   )334,      (yytype_uint16 const   )338,      (yytype_uint16 const   )342,      (yytype_uint16 const   )346, 
        (yytype_uint16 const   )350,      (yytype_uint16 const   )357,      (yytype_uint16 const   )363,      (yytype_uint16 const   )374, 
        (yytype_uint16 const   )379,      (yytype_uint16 const   )386,      (yytype_uint16 const   )396,      (yytype_uint16 const   )401, 
        (yytype_uint16 const   )406,      (yytype_uint16 const   )412,      (yytype_uint16 const   )426,      (yytype_uint16 const   )431, 
        (yytype_uint16 const   )437,      (yytype_uint16 const   )449,      (yytype_uint16 const   )453,      (yytype_uint16 const   )460, 
        (yytype_uint16 const   )465,      (yytype_uint16 const   )470,      (yytype_uint16 const   )475,      (yytype_uint16 const   )487, 
        (yytype_uint16 const   )492,      (yytype_uint16 const   )499,      (yytype_uint16 const   )509,      (yytype_uint16 const   )513, 
        (yytype_uint16 const   )520,      (yytype_uint16 const   )526,      (yytype_uint16 const   )532,      (yytype_uint16 const   )537, 
        (yytype_uint16 const   )549,      (yytype_uint16 const   )554,      (yytype_uint16 const   )560,      (yytype_uint16 const   )570, 
        (yytype_uint16 const   )573,      (yytype_uint16 const   )579,      (yytype_uint16 const   )602,      (yytype_uint16 const   )610, 
        (yytype_uint16 const   )618,      (yytype_uint16 const   )626,      (yytype_uint16 const   )634,      (yytype_uint16 const   )642, 
        (yytype_uint16 const   )650,      (yytype_uint16 const   )658,      (yytype_uint16 const   )666,      (yytype_uint16 const   )674, 
        (yytype_uint16 const   )681,      (yytype_uint16 const   )689,      (yytype_uint16 const   )693,      (yytype_uint16 const   )701, 
        (yytype_uint16 const   )709,      (yytype_uint16 const   )715,      (yytype_uint16 const   )721,      (yytype_uint16 const   )730, 
        (yytype_uint16 const   )733};
#line 615 "parsessh.c"
static char const   * const  yytname___0[70]  = 
#line 615
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"tSTYLE", 
        (char const   */* const  */)"tIS",      (char const   */* const  */)"tEND",      (char const   */* const  */)"tKEYWORDS",      (char const   */* const  */)"tARE", 
        (char const   */* const  */)"tIN",      (char const   */* const  */)"tOPERATORS",      (char const   */* const  */)"tSEQUENCES",      (char const   */* const  */)"tFIRST", 
        (char const   */* const  */)"tSECOND",      (char const   */* const  */)"tALPHABET",      (char const   */* const  */)"tALPHABETS",      (char const   */* const  */)"tDOCUMENTATION", 
        (char const   */* const  */)"tEXCEPTIONS",      (char const   */* const  */)"tCASE",      (char const   */* const  */)"tCSTRING",      (char const   */* const  */)"tCCHAR", 
        (char const   */* const  */)"tOPTIONAL",      (char const   */* const  */)"tCLOSERS",      (char const   */* const  */)"tWRITTEN",      (char const   */* const  */)"tBY", 
        (char const   */* const  */)"tVERSION",      (char const   */* const  */)"tREQUIRES",      (char const   */* const  */)"tA2PS",      (char const   */* const  */)"tANCESTORS", 
        (char const   */* const  */)"tFACE",      (char const   */* const  */)"tFFLAGS",      (char const   */* const  */)"tSTRING",      (char const   */* const  */)"tLATEXSYMBOL", 
        (char const   */* const  */)"tREGEX",      (char const   */* const  */)"tSENSITIVENESS",      (char const   */* const  */)"tBACK_REF",      (char const   */* const  */)"\',\'", 
        (char const   */* const  */)"\'(\'",      (char const   */* const  */)"\')\'",      (char const   */* const  */)"\'+\'",      (char const   */* const  */)"$accept", 
        (char const   */* const  */)"file",      (char const   */* const  */)"style_sheet",      (char const   */* const  */)"definition_list",      (char const   */* const  */)"requirement", 
        (char const   */* const  */)"documentation",      (char const   */* const  */)"long_string",      (char const   */* const  */)"authors",      (char const   */* const  */)"version", 
        (char const   */* const  */)"ancestors_def",      (char const   */* const  */)"ancestors_list",      (char const   */* const  */)"case_def",      (char const   */* const  */)"regex", 
        (char const   */* const  */)"rhs",      (char const   */* const  */)"a_rhs",      (char const   */* const  */)"rhs_list",      (char const   */* const  */)"fface", 
        (char const   */* const  */)"fface_sxp",      (char const   */* const  */)"rule",      (char const   */* const  */)"keywords_def",      (char const   */* const  */)"keywords_rule_list", 
        (char const   */* const  */)"keyword_regex",      (char const   */* const  */)"operators_def",      (char const   */* const  */)"operators_rule_list",      (char const   */* const  */)"operator_regex", 
        (char const   */* const  */)"sequence_def",      (char const   */* const  */)"sequence_list",      (char const   */* const  */)"sequence",      (char const   */* const  */)"closers_opt", 
        (char const   */* const  */)"exception_def_opt",      (char const   */* const  */)0};
#line 636 "parsessh.c"
static yytype_uint16 const   yytoknum___0[39]  = 
#line 636
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )256,      (yytype_uint16 const   )257,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )259,      (yytype_uint16 const   )260,      (yytype_uint16 const   )261,      (yytype_uint16 const   )262, 
        (yytype_uint16 const   )263,      (yytype_uint16 const   )264,      (yytype_uint16 const   )265,      (yytype_uint16 const   )266, 
        (yytype_uint16 const   )267,      (yytype_uint16 const   )268,      (yytype_uint16 const   )269,      (yytype_uint16 const   )270, 
        (yytype_uint16 const   )271,      (yytype_uint16 const   )272,      (yytype_uint16 const   )273,      (yytype_uint16 const   )274, 
        (yytype_uint16 const   )275,      (yytype_uint16 const   )276,      (yytype_uint16 const   )277,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )279,      (yytype_uint16 const   )280,      (yytype_uint16 const   )281,      (yytype_uint16 const   )282, 
        (yytype_uint16 const   )283,      (yytype_uint16 const   )284,      (yytype_uint16 const   )285,      (yytype_uint16 const   )286, 
        (yytype_uint16 const   )287,      (yytype_uint16 const   )288,      (yytype_uint16 const   )289,      (yytype_uint16 const   )44, 
        (yytype_uint16 const   )40,      (yytype_uint16 const   )41,      (yytype_uint16 const   )43};
#line 646 "parsessh.c"
static yytype_uint8 const   sshr1[93]  = 
#line 646
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )53,      (yytype_uint8 const   )53,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )63,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68};
#line 661 "parsessh.c"
static yytype_uint8 const   sshr2[93]  = 
#line 661
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3};
#line 678 "parsessh.c"
static yytype_uint8 const   yydefact___0[200]  = 
#line 678
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )19,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )11,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )51,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )60,      (yytype_uint8 const   )55,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )0,      (yytype_uint8 const   )65,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )12,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )0,      (yytype_uint8 const   )20,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )40,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )34,      (yytype_uint8 const   )37,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )33,      (yytype_uint8 const   )59,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )68,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )0,      (yytype_uint8 const   )24,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )21,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )38,      (yytype_uint8 const   )41,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )0,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )91,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )91,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )22,      (yytype_uint8 const   )28,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )52,      (yytype_uint8 const   )61,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )53,      (yytype_uint8 const   )70,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )91,      (yytype_uint8 const   )91,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )0,      (yytype_uint8 const   )78,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )87,      (yytype_uint8 const   )91,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )42,      (yytype_uint8 const   )91,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )90,      (yytype_uint8 const   )76,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )91,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )75,      (yytype_uint8 const   )92,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )79,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84};
#line 703 "parsessh.c"
static yytype_int16 const   yydefgoto___0[30]  = 
#line 703
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )2,      (yytype_int16 const   )3,      (yytype_int16 const   )7, 
        (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )80,      (yytype_int16 const   )24, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )88,      (yytype_int16 const   )27, 
        (yytype_int16 const   )63,      (yytype_int16 const   )92,      (yytype_int16 const   )130,      (yytype_int16 const   )131, 
        (yytype_int16 const   )94,      (yytype_int16 const   )103,      (yytype_int16 const   )147,      (yytype_int16 const   )32, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )35,      (yytype_int16 const   )65, 
        (yytype_int16 const   )148,      (yytype_int16 const   )28,      (yytype_int16 const   )74,      (yytype_int16 const   )75, 
        (yytype_int16 const   )149,      (yytype_int16 const   )174};
#line 713 "parsessh.c"
static yytype_int16 const   sshpact[200]  = 
#line 713
  {      (yytype_int16 const   )11,      (yytype_int16 const   )-2,      (yytype_int16 const   )31,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )39,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )98, 
        (yytype_int16 const   )66,      (yytype_int16 const   )126,      (yytype_int16 const   )183,      (yytype_int16 const   )56, 
        (yytype_int16 const   )62,      (yytype_int16 const   )65,      (yytype_int16 const   )75,      (yytype_int16 const   )91, 
        (yytype_int16 const   )40,      (yytype_int16 const   )175,      (yytype_int16 const   )77,      (yytype_int16 const   )7, 
        (yytype_int16 const   )80,      (yytype_int16 const   )109,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )69,      (yytype_int16 const   )60, 
        (yytype_int16 const   )132,      (yytype_int16 const   )94,      (yytype_int16 const   )60,      (yytype_int16 const   )133, 
        (yytype_int16 const   )35,      (yytype_int16 const   )131,      (yytype_int16 const   )142,      (yytype_int16 const   )140, 
        (yytype_int16 const   )167,      (yytype_int16 const   )-150,      (yytype_int16 const   )126,      (yytype_int16 const   )183, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )168,      (yytype_int16 const   )169,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )8,      (yytype_int16 const   )170,      (yytype_int16 const   )129,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )18,      (yytype_int16 const   )120,      (yytype_int16 const   )-150,      (yytype_int16 const   )1, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )154, 
        (yytype_int16 const   )189,      (yytype_int16 const   )-150,      (yytype_int16 const   )18,      (yytype_int16 const   )120, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )4,      (yytype_int16 const   )-150,      (yytype_int16 const   )194, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )138, 
        (yytype_int16 const   )34,      (yytype_int16 const   )143,      (yytype_int16 const   )10,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )172,      (yytype_int16 const   )173,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )5,      (yytype_int16 const   )198,      (yytype_int16 const   )196,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )176,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )14,      (yytype_int16 const   )60,      (yytype_int16 const   )-150,      (yytype_int16 const   )60, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )129, 
        (yytype_int16 const   )120,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )69,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )155, 
        (yytype_int16 const   )69,      (yytype_int16 const   )120,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )94,      (yytype_int16 const   )94,      (yytype_int16 const   )60,      (yytype_int16 const   )60, 
        (yytype_int16 const   )111,      (yytype_int16 const   )129,      (yytype_int16 const   )120,      (yytype_int16 const   )60, 
        (yytype_int16 const   )111,      (yytype_int16 const   )197,      (yytype_int16 const   )35,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )146,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )181,      (yytype_int16 const   )179, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )92, 
        (yytype_int16 const   )118,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )166,      (yytype_int16 const   )21,      (yytype_int16 const   )127,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )22,      (yytype_int16 const   )111,      (yytype_int16 const   )38, 
        (yytype_int16 const   )183,      (yytype_int16 const   )148,      (yytype_int16 const   )38,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )195,      (yytype_int16 const   )151,      (yytype_int16 const   )152, 
        (yytype_int16 const   )111,      (yytype_int16 const   )38,      (yytype_int16 const   )195,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )129,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )38,      (yytype_int16 const   )195,      (yytype_int16 const   )195,      (yytype_int16 const   )191, 
        (yytype_int16 const   )195,      (yytype_int16 const   )183,      (yytype_int16 const   )-150,      (yytype_int16 const   )60, 
        (yytype_int16 const   )60,      (yytype_int16 const   )38,      (yytype_int16 const   )195,      (yytype_int16 const   )195, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )195,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )199, 
        (yytype_int16 const   )38,      (yytype_int16 const   )38,      (yytype_int16 const   )195,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )195, 
        (yytype_int16 const   )195,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150};
#line 738 "parsessh.c"
static yytype_int16 const   yypgoto___0[30]  = 
#line 738
  {      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150,      (yytype_int16 const   )-150, 
        (yytype_int16 const   )-28,      (yytype_int16 const   )-41,      (yytype_int16 const   )-46,      (yytype_int16 const   )23, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )-150,      (yytype_int16 const   )-17,      (yytype_int16 const   )171, 
        (yytype_int16 const   )106,      (yytype_int16 const   )114,      (yytype_int16 const   )-42,      (yytype_int16 const   )107, 
        (yytype_int16 const   )-15,      (yytype_int16 const   )200,      (yytype_int16 const   )-150,      (yytype_int16 const   )100, 
        (yytype_int16 const   )-91,      (yytype_int16 const   )-149};
#line 750 "parsessh.c"
static yytype_uint8 const   sshyytable[219]  = 
#line 750
  {      (yytype_uint8 const   )60,      (yytype_uint8 const   )82,      (yytype_uint8 const   )53,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )180,      (yytype_uint8 const   )99,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )107,      (yytype_uint8 const   )121,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )54,      (yytype_uint8 const   )1,      (yytype_uint8 const   )117, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )93,      (yytype_uint8 const   )66,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )183,      (yytype_uint8 const   )184,      (yytype_uint8 const   )106,      (yytype_uint8 const   )186, 
        (yytype_uint8 const   )96,      (yytype_uint8 const   )154,      (yytype_uint8 const   )165,      (yytype_uint8 const   )167, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )191,      (yytype_uint8 const   )192,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )193,      (yytype_uint8 const   )105,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )47,      (yytype_uint8 const   )86,      (yytype_uint8 const   )108, 
        (yytype_uint8 const   )112,      (yytype_uint8 const   )197,      (yytype_uint8 const   )116,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )114,      (yytype_uint8 const   )118,      (yytype_uint8 const   )198,      (yytype_uint8 const   )199, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )127,      (yytype_uint8 const   )51,      (yytype_uint8 const   )169, 
        (yytype_uint8 const   )170,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )172, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )108,      (yytype_uint8 const   )128,      (yytype_uint8 const   )144, 
        (yytype_uint8 const   )129,      (yytype_uint8 const   )178,      (yytype_uint8 const   )179,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )71,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )29,      (yytype_uint8 const   )51,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )41,      (yytype_uint8 const   )62,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )182,      (yytype_uint8 const   )38,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )143,      (yytype_uint8 const   )146,      (yytype_uint8 const   )39,      (yytype_uint8 const   )133, 
        (yytype_uint8 const   )152,      (yytype_uint8 const   )153,      (yytype_uint8 const   )190,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )73,      (yytype_uint8 const   )139, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )140,      (yytype_uint8 const   )66,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )195,      (yytype_uint8 const   )196,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )51,      (yytype_uint8 const   )171,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )52,      (yytype_uint8 const   )48,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )168, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )181,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )105,      (yytype_uint8 const   )17,      (yytype_uint8 const   )132, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )177,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )21,      (yytype_uint8 const   )51,      (yytype_uint8 const   )160, 
        (yytype_uint8 const   )138,      (yytype_uint8 const   )161,      (yytype_uint8 const   )62,      (yytype_uint8 const   )187, 
        (yytype_uint8 const   )144,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )150,      (yytype_uint8 const   )151,      (yytype_uint8 const   )61,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )50,      (yytype_uint8 const   )68,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )188,      (yytype_uint8 const   )189,      (yytype_uint8 const   )77,      (yytype_uint8 const   )145, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )89,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )160,      (yytype_uint8 const   )91,      (yytype_uint8 const   )162, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )157,      (yytype_uint8 const   )160,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )166,      (yytype_uint8 const   )59,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )110,      (yytype_uint8 const   )111,      (yytype_uint8 const   )78,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )115,      (yytype_uint8 const   )59,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )95,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )42,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )11,      (yytype_uint8 const   )160,      (yytype_uint8 const   )160, 
        (yytype_uint8 const   )175,      (yytype_uint8 const   )176,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )135,      (yytype_uint8 const   )136,      (yytype_uint8 const   )163,      (yytype_uint8 const   )164, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )79,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )109,      (yytype_uint8 const   )119,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )155, 
        (yytype_uint8 const   )158,      (yytype_uint8 const   )159,      (yytype_uint8 const   )137,      (yytype_uint8 const   )173, 
        (yytype_uint8 const   )185,      (yytype_uint8 const   )81,      (yytype_uint8 const   )134,      (yytype_uint8 const   )194, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )44,      (yytype_uint8 const   )156};
#line 776 "parsessh.c"
static yytype_uint8 const   sshyycheck[219]  = 
#line 776
  {      (yytype_uint8 const   )31,      (yytype_uint8 const   )43,      (yytype_uint8 const   )30,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )154,      (yytype_uint8 const   )5,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )30,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )63,      (yytype_uint8 const   )33,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )169,      (yytype_uint8 const   )170,      (yytype_uint8 const   )63,      (yytype_uint8 const   )172, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )116,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )178,      (yytype_uint8 const   )179,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )182,      (yytype_uint8 const   )62,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )190,      (yytype_uint8 const   )73,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )35,      (yytype_uint8 const   )195,      (yytype_uint8 const   )196, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )35,      (yytype_uint8 const   )32,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )143,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )146, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )89,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )152,      (yytype_uint8 const   )153,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )3,      (yytype_uint8 const   )32,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )33,      (yytype_uint8 const   )36,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )168,      (yytype_uint8 const   )13,      (yytype_uint8 const   )110, 
        (yytype_uint8 const   )111,      (yytype_uint8 const   )112,      (yytype_uint8 const   )7,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )116,      (yytype_uint8 const   )177,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )118,      (yytype_uint8 const   )108, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )188,      (yytype_uint8 const   )189,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )32,      (yytype_uint8 const   )144,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )36,      (yytype_uint8 const   )26,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )142, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )160,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )145,      (yytype_uint8 const   )20,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )152,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )27,      (yytype_uint8 const   )32,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )37,      (yytype_uint8 const   )36,      (yytype_uint8 const   )173, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )114,      (yytype_uint8 const   )6,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )9,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )175,      (yytype_uint8 const   )176,      (yytype_uint8 const   )4,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )35,      (yytype_uint8 const   )34,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )15,      (yytype_uint8 const   )35,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )36,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )30,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )36,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )6,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )7,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )9,      (yytype_uint8 const   )30,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )30,      (yytype_uint8 const   )104,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )42,      (yytype_uint8 const   )100,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )17,      (yytype_uint8 const   )118};
#line 804 "parsessh.c"
static yytype_uint8 const   yystos___0[200]  = 
#line 804
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )20,      (yytype_uint8 const   )22,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )27,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )3,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )13,      (yytype_uint8 const   )13,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )33,      (yytype_uint8 const   )6,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )23,      (yytype_uint8 const   )4,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )7,      (yytype_uint8 const   )30,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )51,      (yytype_uint8 const   )57,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )6,      (yytype_uint8 const   )36,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )51,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )58,      (yytype_uint8 const   )61,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )24,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )55,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )32,      (yytype_uint8 const   )52,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )7,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )30,      (yytype_uint8 const   )51,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )5,      (yytype_uint8 const   )35,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )5,      (yytype_uint8 const   )30,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )30,      (yytype_uint8 const   )5,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )55,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )57,      (yytype_uint8 const   )60,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )59,      (yytype_uint8 const   )54,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )62,      (yytype_uint8 const   )55,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )36,      (yytype_uint8 const   )55,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )67,      (yytype_uint8 const   )54,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )55,      (yytype_uint8 const   )67,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )15,      (yytype_uint8 const   )27,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )5,      (yytype_uint8 const   )37,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )16,      (yytype_uint8 const   )68,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )55,      (yytype_uint8 const   )67,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )53,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )21,      (yytype_uint8 const   )68,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )55,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )16,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68};
#line 951 "parsessh.c"
static void yy_symbol_value_print___0(FILE *yyoutput , int yytype , YYSTYPE___0 const   * const  yyvaluep ) 
{ 


  {
#line 961
  if (! yyvaluep) {
#line 962
    return;
  }
#line 964
  if (yytype < 39) {
    {
#line 965
    yyprint___0(yyoutput, (int const   )yytoknum___0[yytype], *yyvaluep);
    }
  }
  {
#line 971
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 972
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 974
  return;
}
}
#line 983 "parsessh.c"
static void yy_symbol_print___0(FILE *yyoutput , int yytype , YYSTYPE___0 const   * const  yyvaluep ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 993
  if (yytype < 39) {
    {
#line 994
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"token %s (",
            yytname___0[yytype]);
    }
  } else {
    {
#line 996
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"nterm %s (",
            yytname___0[yytype]);
    }
  }
  {
#line 998
  yy_symbol_value_print___0(yyoutput, yytype, yyvaluep);
#line 999
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)")");
  }
#line 1000
  return;
}
}
#line 1009 "parsessh.c"
static void yy_stack_print___0(yytype_int16 *bottom , yytype_int16 *top ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1018
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 1019
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1019
    if (! ((unsigned long )bottom <= (unsigned long )top)) {
#line 1019
      goto while_break;
    }
    {
#line 1020
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            (int )*bottom);
#line 1019
    bottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1021
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 1022
  return;
}
}
#line 1037 "parsessh.c"
static void yy_reduce_print___0(YYSTYPE___0 *yyvsp , int sshyyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1046
  yynrhs = (int )sshr2[sshyyrule];
#line 1048
  yylno = (unsigned long )yyrline___0[sshyyrule];
#line 1049
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          sshyyrule - 1, yylno);
#line 1052
  yyi = 0;
  }
  {
#line 1052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1052
    if (! (yyi < yynrhs)) {
#line 1052
      goto while_break;
    }
    {
#line 1054
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yyi + 1);
#line 1055
    yy_symbol_print___0(stderr, (int )yyrhs___0[(int const   )yyprhs___0[sshyyrule] + (int const   )yyi],
                        (YYSTYPE___0 const   */* const  */)(yyvsp + ((yyi + 1) - yynrhs)));
#line 1058
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1052
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1060
  return;
}
}
#line 1070 "parsessh.c"
int sshdebug  ;
#line 1130 "parsessh.c"
static char *yystpcpy___0(char *yydest , char const   *yysrc ) 
{ 
  char *yyd ;
  char const   *sshs ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1139
  yyd = yydest;
#line 1140
  sshs = yysrc;
  {
#line 1142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1142
    tmp = yyd;
#line 1142
    yyd ++;
#line 1142
    tmp___1 = sshs;
#line 1142
    sshs ++;
#line 1142
    tmp___0 = (char )*tmp___1;
#line 1142
    *tmp = tmp___0;
#line 1142
    if (! ((int )tmp___0 != 0)) {
#line 1142
      goto while_break;
    }
#line 1143
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 1145
  return (yyd - 1);
}
}
#line 1158 "parsessh.c"
static unsigned int yytnamerr___0(char *yyres , char const   *yystr ) 
{ 
  unsigned int yyn ;
  char const   *yyp ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 1161
  if ((int const   )*yystr == 34) {
#line 1163
    yyn = 0U;
#line 1164
    yyp = yystr;
    {
#line 1166
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1167
      yyp ++;
      {
#line 1170
      if ((int const   )*yyp == 44) {
#line 1170
        goto case_44;
      }
#line 1170
      if ((int const   )*yyp == 39) {
#line 1170
        goto case_44;
      }
#line 1173
      if ((int const   )*yyp == 92) {
#line 1173
        goto case_92;
      }
#line 1183
      if ((int const   )*yyp == 34) {
#line 1183
        goto case_34;
      }
#line 1177
      goto switch_default;
      case_44: /* CIL Label */ 
      case_39: /* CIL Label */ 
#line 1171
      goto do_not_strip_quotes;
      case_92: /* CIL Label */ 
#line 1174
      yyp ++;
#line 1174
      if ((int const   )*yyp != 92) {
#line 1175
        goto do_not_strip_quotes;
      }
      switch_default: /* CIL Label */ 
#line 1178
      if (yyres) {
#line 1179
        *(yyres + yyn) = (char )*yyp;
      }
#line 1180
      yyn ++;
#line 1181
      goto switch_break;
      case_34: /* CIL Label */ 
#line 1184
      if (yyres) {
#line 1185
        *(yyres + yyn) = (char )'\000';
      }
#line 1186
      return (yyn);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    do_not_strip_quotes: ;
  }
#line 1191
  if (! yyres) {
    {
#line 1192
    tmp = strlen(yystr);
    }
#line 1192
    return (tmp);
  }
  {
#line 1194
  tmp___0 = yystpcpy___0(yyres, yystr);
  }
#line 1194
  return ((unsigned int )(tmp___0 - yyres));
}
}
#line 1234
static unsigned int yysyntax_error___0(char *yyresult , int sshstate , int sshchar___0 ) ;
#line 1234 "parsessh.c"
static char const   yyunexpected___0[28]  = 
#line 1234
  {      (char const   )'s',      (char const   )'y',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'x',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )',',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1235 "parsessh.c"
static char const   yyexpecting___0[15]  = 
#line 1235
  {      (char const   )',',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1236 "parsessh.c"
static char const   yyor___0[7]  = {      (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1205 "parsessh.c"
static unsigned int yysyntax_error___0(char *yyresult , int sshstate , int sshchar___0 ) 
{ 
  int yyn ;
  int yytype ;
  int tmp ;
  unsigned int yysize0 ;
  unsigned int tmp___0 ;
  unsigned int yysize ;
  unsigned int yysize1 ;
  int yysize_overflow ;
  char const   *yyarg[5] ;
  int yyx ;
  char *yyfmt ;
  char const   *yyf ;
  char yyformat[((sizeof(yyunexpected___0) + sizeof(yyexpecting___0)) - 1UL) + 3UL * (sizeof(yyor___0) - 1UL)] ;
  char const   *yyprefix ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yycount ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  size_t tmp___5 ;
  char *yyp ;
  int yyi ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  char tmp___8 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
#line 1208
  yyn = (int )sshpact[sshstate];
#line 1210
  if (-150 < yyn) {
#line 1210
    if (yyn <= 218) {
#line 1214
      if ((unsigned int )sshchar___0 <= 289U) {
#line 1214
        tmp = (int const   )yytranslate___0[sshchar___0];
      } else {
#line 1214
        tmp = (int const   )2;
      }
      {
#line 1214
      yytype = (int )tmp;
#line 1215
      tmp___0 = yytnamerr___0((char *)0, (char const   *)yytname___0[yytype]);
#line 1215
      yysize0 = tmp___0;
#line 1216
      yysize = yysize0;
#line 1218
      yysize_overflow = 0;
#line 1241
      yyprefix = yyexpecting___0;
      }
#line 1245
      if (yyn < 0) {
#line 1245
        tmp___1 = - yyn;
      } else {
#line 1245
        tmp___1 = 0;
      }
#line 1245
      yyxbegin = tmp___1;
#line 1248
      yychecklim = (218 - yyn) + 1;
#line 1249
      if (yychecklim < 39) {
#line 1249
        tmp___2 = yychecklim;
      } else {
#line 1249
        tmp___2 = 39;
      }
      {
#line 1249
      yyxend = tmp___2;
#line 1250
      yycount = 1;
#line 1252
      yyarg[0] = (char const   *)yytname___0[yytype];
#line 1253
      yyfmt = yystpcpy___0(yyformat, yyunexpected___0);
#line 1255
      yyx = yyxbegin;
      }
      {
#line 1255
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1255
        if (! (yyx < yyxend)) {
#line 1255
          goto while_break;
        }
#line 1256
        if ((int const   )sshyycheck[yyx + yyn] == (int const   )yyx) {
#line 1256
          if (yyx != 1) {
#line 1258
            if (yycount == 5) {
#line 1260
              yycount = 1;
#line 1261
              yysize = yysize0;
#line 1262
              yyformat[sizeof(yyunexpected___0) - 1UL] = (char )'\000';
#line 1263
              goto while_break;
            }
            {
#line 1265
            tmp___3 = yycount;
#line 1265
            yycount ++;
#line 1265
            yyarg[tmp___3] = (char const   *)yytname___0[yyx];
#line 1266
            tmp___4 = yytnamerr___0((char *)0, (char const   *)yytname___0[yyx]);
#line 1266
            yysize1 = yysize + tmp___4;
#line 1267
            yysize_overflow |= yysize1 < yysize;
#line 1268
            yysize = yysize1;
#line 1269
            yyfmt = yystpcpy___0(yyfmt, yyprefix);
#line 1270
            yyprefix = yyor___0;
            }
          }
        }
#line 1255
        yyx ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1273
      yyf = (char const   *)(yyformat);
#line 1274
      tmp___5 = strlen(yyf);
#line 1274
      yysize1 = yysize + tmp___5;
#line 1275
      yysize_overflow |= yysize1 < yysize;
#line 1276
      yysize = yysize1;
      }
#line 1278
      if (yysize_overflow) {
#line 1279
        return (4294967295U);
      }
#line 1281
      if (yyresult) {
#line 1286
        yyp = yyresult;
#line 1287
        yyi = 0;
        {
#line 1288
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1288
          tmp___8 = (char )*yyf;
#line 1288
          *yyp = tmp___8;
#line 1288
          if (! ((int )tmp___8 != 0)) {
#line 1288
            goto while_break___0;
          }
#line 1290
          if ((int )*yyp == 37) {
#line 1290
            if ((int const   )*(yyf + 1) == 115) {
#line 1290
              if (yyi < yycount) {
                {
#line 1292
                tmp___6 = yyi;
#line 1292
                yyi ++;
#line 1292
                tmp___7 = yytnamerr___0(yyp, yyarg[tmp___6]);
#line 1292
                yyp += tmp___7;
#line 1293
                yyf += 2;
                }
              } else {
#line 1297
                yyp ++;
#line 1298
                yyf ++;
              }
            } else {
#line 1297
              yyp ++;
#line 1298
              yyf ++;
            }
          } else {
#line 1297
            yyp ++;
#line 1298
            yyf ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1302
      return (yysize);
    } else {
#line 1211
      return (0U);
    }
  } else {
#line 1211
    return (0U);
  }
}
}
#line 1315 "parsessh.c"
static void yydestruct___0(char const   *yymsg , int yytype , YYSTYPE___0 *yyvaluep ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1327
  if (! yymsg) {
#line 1328
    yymsg = "Deleting";
  }
  {
#line 1329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1329
    if (sshdebug) {
      {
#line 1329
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yymsg);
#line 1329
      yy_symbol_print___0(stderr, yytype, (YYSTYPE___0 const   */* const  */)yyvaluep);
#line 1329
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1329
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1334
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1335
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1337
  return;
}
}
#line 1350
int sshparse(void) ;
#line 1359 "parsessh.c"
int sshchar  ;
#line 1362 "parsessh.c"
YYSTYPE___0 sshlval  ;
#line 1365 "parsessh.c"
int sshnerrs  ;
#line 1386 "parsessh.c"
int sshparse(void) 
{ 
  int sshstate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned int yymsg_alloc ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE___0 yyvsa[200] ;
  YYSTYPE___0 *yyvs ;
  YYSTYPE___0 *yyvsp ;
  unsigned int yystacksize ;
  YYSTYPE___0 sshval ;
  int sshyylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc___0 *yyptr ;
  void *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t len1 ;
  size_t len2 ;
  void *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  struct darray *tmp___5 ;
  struct darray *tmp___6 ;
  struct darray *tmp___7 ;
  struct rule *open_rule ;
  struct darray *tmp___8 ;
  struct rule *open_rule___0 ;
  struct darray *tmp___9 ;
  struct rule *open_rule___1 ;
  struct darray *tmp___10 ;
  struct rule *open_rule___2 ;
  struct darray *tmp___11 ;
  struct rule *open_rule___3 ;
  struct darray *tmp___12 ;
  struct rule *open_rule___4 ;
  struct darray *tmp___13 ;
  struct rule *open_rule___5 ;
  struct darray *tmp___14 ;
  struct rule *open_rule___6 ;
  struct darray *tmp___15 ;
  struct rule *open_rule___7 ;
  struct darray *tmp___16 ;
  struct rule *open_rule___8 ;
  struct rule *open_rule___9 ;
  struct darray *tmp___17 ;
  char *tmp___18 ;
  struct rule *tmp___19 ;
  unsigned int yysize___0 ;
  unsigned int tmp___20 ;
  unsigned int yyalloc ;
  void *tmp___21 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;

  {
#line 1402
  yytoken = 0;
#line 1406
  yymsg = yymsgbuf;
#line 1407
  yymsg_alloc = (unsigned int )sizeof(yymsgbuf);
#line 1420
  yyss = yyssa;
#line 1425
  yyvs = yyvsa;
#line 1432
  yystacksize = 200U;
#line 1441
  sshyylen = 0;
  {
#line 1443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1443
    if (sshdebug) {
      {
#line 1443
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 1443
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1445
  sshstate = 0;
#line 1446
  yyerrstatus = 0;
#line 1447
  sshnerrs = 0;
#line 1448
  sshchar = -2;
#line 1455
  yyssp = yyss;
#line 1456
  yyvsp = yyvs;
#line 1458
  goto yysetstate;
  yynewstate: 
#line 1466
  yyssp ++;
  yysetstate: 
#line 1469
  *yyssp = (yytype_int16 )sshstate;
#line 1471
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1474
    yysize = (unsigned int )((yyssp - yyss) + 1L);
#line 1503
    if (10000U <= yystacksize) {
#line 1504
      goto yyexhaustedlab;
    }
#line 1505
    yystacksize *= 2U;
#line 1506
    if (10000U < yystacksize) {
#line 1507
      yystacksize = 10000U;
    }
    {
#line 1510
    yyss1 = yyss;
#line 1511
    tmp = malloc((size_t )((unsigned long )yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE___0 )) + (sizeof(union yyalloc___0 ) - 1UL)));
#line 1511
    yyptr = (union yyalloc___0 *)tmp;
    }
#line 1513
    if (! yyptr) {
#line 1514
      goto yyexhaustedlab;
    }
    {
#line 1515
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1515
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, (unsigned long )yysize * sizeof(*yyss));
#line 1515
      yyss = & yyptr->yyss;
#line 1515
      yynewbytes = (unsigned int )((unsigned long )yystacksize * sizeof(*yyss) + (sizeof(union yyalloc___0 ) - 1UL));
#line 1515
      yyptr += (unsigned long )yynewbytes / sizeof(*yyptr);
      }
#line 1515
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1516
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1516
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, (unsigned long )yysize * sizeof(*yyvs));
#line 1516
      yyvs = & yyptr->yyvs;
#line 1516
      yynewbytes___0 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc___0 ) - 1UL));
#line 1516
      yyptr += (unsigned long )yynewbytes___0 / sizeof(*yyptr);
      }
#line 1516
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1519
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1520
      free((void *)yyss1);
      }
    }
#line 1525
    yyssp = (yyss + yysize) - 1;
#line 1526
    yyvsp = (yyvs + yysize) - 1;
    {
#line 1529
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1529
      if (sshdebug) {
        {
#line 1529
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                (unsigned long )yystacksize);
        }
      }
#line 1529
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1532
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1533
      goto yyabortlab;
    }
  }
  {
#line 1536
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1536
    if (sshdebug) {
      {
#line 1536
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              sshstate);
      }
    }
#line 1536
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1538
  goto yybackup;
  yybackup: 
#line 1549
  yyn = (int )sshpact[sshstate];
#line 1550
  if (yyn == -150) {
#line 1551
    goto yydefault;
  }
#line 1556
  if (sshchar == -2) {
    {
#line 1558
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1558
      if (sshdebug) {
        {
#line 1558
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 1558
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1559
    sshchar = sshlex();
    }
  }
#line 1562
  if (sshchar <= 0) {
#line 1564
    yytoken = 0;
#line 1564
    sshchar = yytoken;
    {
#line 1565
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1565
      if (sshdebug) {
        {
#line 1565
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 1565
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 1569
    if ((unsigned int )sshchar <= 289U) {
#line 1569
      yytoken = (int )yytranslate___0[sshchar];
    } else {
#line 1569
      yytoken = 2;
    }
    {
#line 1570
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1570
      if (sshdebug) {
        {
#line 1570
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 1570
        yy_symbol_print___0(stderr, yytoken, (YYSTYPE___0 const   */* const  */)(& sshlval));
#line 1570
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 1570
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1575
  yyn += yytoken;
#line 1576
  if (yyn < 0) {
#line 1577
    goto yydefault;
  } else
#line 1576
  if (218 < yyn) {
#line 1577
    goto yydefault;
  } else
#line 1576
  if ((int const   )sshyycheck[yyn] != (int const   )yytoken) {
#line 1577
    goto yydefault;
  }
#line 1578
  yyn = (int )sshyytable[yyn];
#line 1579
  if (yyn <= 0) {
#line 1581
    if (yyn == 0) {
#line 1582
      goto yyerrlab;
    } else
#line 1581
    if (yyn == -1) {
#line 1582
      goto yyerrlab;
    }
#line 1583
    yyn = - yyn;
#line 1584
    goto yyreduce;
  }
#line 1587
  if (yyn == 5) {
#line 1588
    goto yyacceptlab;
  }
#line 1592
  if (yyerrstatus) {
#line 1593
    yyerrstatus --;
  }
  {
#line 1596
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1596
    if (sshdebug) {
      {
#line 1596
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1596
      yy_symbol_print___0(stderr, yytoken, (YYSTYPE___0 const   */* const  */)(& sshlval));
#line 1596
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1596
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1599
  if (sshchar != 0) {
#line 1600
    sshchar = -2;
  }
#line 1602
  sshstate = yyn;
#line 1603
  yyvsp ++;
#line 1603
  *yyvsp = sshlval;
#line 1605
  goto yynewstate;
  yydefault: 
#line 1612
  yyn = (int )yydefact___0[sshstate];
#line 1613
  if (yyn == 0) {
#line 1614
    goto yyerrlab;
  }
#line 1615
  goto yyreduce;
  yyreduce: 
#line 1623
  sshyylen = (int )sshr2[yyn];
#line 1633
  sshval = *(yyvsp + (1 - sshyylen));
  {
#line 1636
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1636
    if (sshdebug) {
      {
#line 1636
      yy_reduce_print___0(yyvsp, yyn);
      }
    }
#line 1636
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1639
  if (yyn == 2) {
#line 1639
    goto case_2;
  }
#line 135
  if (yyn == 3) {
#line 135 "parsessh.y"
    goto case_3;
  }
#line 144
  if (yyn == 4) {
#line 144
    goto case_4;
  }
#line 150
  if (yyn == 5) {
#line 150
    goto case_5;
  }
#line 159
  if (yyn == 6) {
#line 159
    goto case_6;
  }
#line 165
  if (yyn == 7) {
#line 165
    goto case_7;
  }
#line 174
  if (yyn == 8) {
#line 174
    goto case_8;
  }
#line 180
  if (yyn == 9) {
#line 180
    goto case_9;
  }
#line 188
  if (yyn == 10) {
#line 188
    goto case_10;
  }
#line 193
  if (yyn == 11) {
#line 193
    goto case_11;
  }
#line 198
  if (yyn == 12) {
#line 198
    goto case_12;
  }
#line 206
  if (yyn == 13) {
#line 206
    goto case_13;
  }
#line 213
  if (yyn == 14) {
#line 213
    goto case_14;
  }
#line 220
  if (yyn == 15) {
#line 220
    goto case_15;
  }
#line 223
  if (yyn == 16) {
#line 223
    goto case_16;
  }
#line 226
  if (yyn == 17) {
#line 226
    goto case_17;
  }
#line 229
  if (yyn == 18) {
#line 229
    goto case_18;
  }
#line 232
  if (yyn == 19) {
#line 232
    goto case_19;
  }
#line 241
  if (yyn == 20) {
#line 241
    goto case_20;
  }
#line 248
  if (yyn == 21) {
#line 248
    goto case_21;
  }
#line 249
  if (yyn == 22) {
#line 249
    goto case_22;
  }
#line 252
  if (yyn == 23) {
#line 252
    goto case_23;
  }
#line 254
  if (yyn == 24) {
#line 254
    goto case_24;
  }
#line 267
  if (yyn == 25) {
#line 267
    goto case_25;
  }
#line 270
  if (yyn == 26) {
#line 270
    goto case_26;
  }
#line 273
  if (yyn == 27) {
#line 273
    goto case_27;
  }
#line 274
  if (yyn == 28) {
#line 274
    goto case_28;
  }
#line 283
  if (yyn == 29) {
#line 283
    goto case_29;
  }
#line 293
  if (yyn == 30) {
#line 293
    goto case_30;
  }
#line 298
  if (yyn == 31) {
#line 298
    goto case_31;
  }
#line 301
  if (yyn == 32) {
#line 301
    goto case_32;
  }
#line 312
  if (yyn == 33) {
#line 312
    goto case_33;
  }
#line 321
  if (yyn == 34) {
#line 321
    goto case_34;
  }
#line 329
  if (yyn == 35) {
#line 329
    goto case_35;
  }
#line 336
  if (yyn == 36) {
#line 336
    goto case_36;
  }
#line 340
  if (yyn == 37) {
#line 340
    goto case_37;
  }
#line 344
  if (yyn == 38) {
#line 344
    goto case_38;
  }
#line 348
  if (yyn == 39) {
#line 348
    goto case_39;
  }
#line 352
  if (yyn == 40) {
#line 352
    goto case_40;
  }
#line 356
  if (yyn == 41) {
#line 356
    goto case_41;
  }
#line 364
  if (yyn == 42) {
#line 364
    goto case_42;
  }
#line 370
  if (yyn == 43) {
#line 370
    goto case_43;
  }
#line 381
  if (yyn == 44) {
#line 381
    goto case_44;
  }
#line 388
  if (yyn == 45) {
#line 388
    goto case_45;
  }
#line 395
  if (yyn == 46) {
#line 395
    goto case_46;
  }
#line 403
  if (yyn == 47) {
#line 403
    goto case_47;
  }
#line 408
  if (yyn == 48) {
#line 408
    goto case_48;
  }
#line 414
  if (yyn == 49) {
#line 414
    goto case_49;
  }
#line 419
  if (yyn == 50) {
#line 419
    goto case_50;
  }
#line 433
  if (yyn == 51) {
#line 433
    goto case_51;
  }
#line 439
  if (yyn == 52) {
#line 439
    goto case_52;
  }
#line 444
  if (yyn == 53) {
#line 444
    goto case_53;
  }
#line 455
  if (yyn == 54) {
#line 455
    goto case_54;
  }
#line 459
  if (yyn == 55) {
#line 459
    goto case_55;
  }
#line 467
  if (yyn == 56) {
#line 467
    goto case_56;
  }
#line 472
  if (yyn == 57) {
#line 472
    goto case_57;
  }
#line 477
  if (yyn == 58) {
#line 477
    goto case_58;
  }
#line 482
  if (yyn == 59) {
#line 482
    goto case_59;
  }
#line 494
  if (yyn == 60) {
#line 494
    goto case_60;
  }
#line 501
  if (yyn == 61) {
#line 501
    goto case_61;
  }
#line 506
  if (yyn == 62) {
#line 506
    goto case_62;
  }
#line 515
  if (yyn == 63) {
#line 515
    goto case_63;
  }
#line 519
  if (yyn == 64) {
#line 519
    goto case_64;
  }
#line 528
  if (yyn == 65) {
#line 528
    goto case_65;
  }
#line 534
  if (yyn == 66) {
#line 534
    goto case_66;
  }
#line 539
  if (yyn == 67) {
#line 539
    goto case_67;
  }
#line 544
  if (yyn == 68) {
#line 544
    goto case_68;
  }
#line 556
  if (yyn == 69) {
#line 556
    goto case_69;
  }
#line 562
  if (yyn == 70) {
#line 562
    goto case_70;
  }
#line 567
  if (yyn == 71) {
#line 567
    goto case_71;
  }
#line 573
  if (yyn == 72) {
#line 573
    goto case_72;
  }
#line 581
  if (yyn == 73) {
#line 581
    goto case_73;
  }
#line 585
  if (yyn == 74) {
#line 585
    goto case_74;
  }
#line 612
  if (yyn == 75) {
#line 612
    goto case_75;
  }
#line 620
  if (yyn == 76) {
#line 620
    goto case_76;
  }
#line 628
  if (yyn == 77) {
#line 628
    goto case_77;
  }
#line 636
  if (yyn == 78) {
#line 636
    goto case_78;
  }
#line 644
  if (yyn == 79) {
#line 644
    goto case_79;
  }
#line 652
  if (yyn == 80) {
#line 652
    goto case_80;
  }
#line 660
  if (yyn == 81) {
#line 660
    goto case_81;
  }
#line 668
  if (yyn == 82) {
#line 668
    goto case_82;
  }
#line 676
  if (yyn == 83) {
#line 676
    goto case_83;
  }
#line 683
  if (yyn == 84) {
#line 683
    goto case_84;
  }
#line 690
  if (yyn == 85) {
#line 690
    goto case_85;
  }
#line 695
  if (yyn == 86) {
#line 695
    goto case_86;
  }
#line 699
  if (yyn == 87) {
#line 699
    goto case_87;
  }
#line 711
  if (yyn == 88) {
#line 711
    goto case_88;
  }
#line 717
  if (yyn == 89) {
#line 717
    goto case_89;
  }
#line 723
  if (yyn == 90) {
#line 723
    goto case_90;
  }
#line 728
  if (yyn == 91) {
#line 728
    goto case_91;
  }
#line 735
  if (yyn == 92) {
#line 735
    goto case_92;
  }
#line 2423 "parsessh.c"
  goto switch_default;
  case_2: /* CIL Label */ 
#line 131 "parsessh.y"
  parsed_style_sheet = (yyvsp + 0)->sheet;
#line 133
  goto switch_break;
  case_3: /* CIL Label */ 
#line 138
  ((yyvsp + -2)->sheet)->name = (unsigned char const   *)(yyvsp + -4)->string;
#line 139
  ((yyvsp + -2)->sheet)->key = "<No key yet>";
#line 140
  sshval.sheet = (yyvsp + -2)->sheet;
#line 142
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 146
  sshval.sheet = new_style_sheet((unsigned char const   *)"<no name>");
  }
#line 148
  goto switch_break;
  case_5: /* CIL Label */ 
#line 150
  if (highlight_level == 2) {
    {
#line 151
    words_set_no_face((yyvsp + -1)->words, Plain_fface);
#line 152
    words_merge_rules_unique(((yyvsp + -4)->sheet)->keywords, (yyvsp + -1)->words);
    }
  } else {
    {
#line 154
    words_free((yyvsp + -1)->words);
    }
  }
#line 155
  sshval.sheet = (yyvsp + -4)->sheet;
#line 157
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 159
  words_set_no_face((yyvsp + -1)->words, Plain_fface);
#line 160
  words_merge_rules_unique(((yyvsp + -3)->sheet)->keywords, (yyvsp + -1)->words);
#line 161
  sshval.sheet = (yyvsp + -3)->sheet;
  }
#line 163
  goto switch_break;
  case_7: /* CIL Label */ 
#line 165
  if (highlight_level == 2) {
    {
#line 166
    words_set_no_face((yyvsp + -1)->words, Plain_fface);
#line 167
    words_merge_rules_unique(((yyvsp + -4)->sheet)->operators, (yyvsp + -1)->words);
    }
  } else {
    {
#line 169
    words_free((yyvsp + -1)->words);
    }
  }
#line 170
  sshval.sheet = (yyvsp + -4)->sheet;
#line 172
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 174
  words_set_no_face((yyvsp + -1)->words, Plain_fface);
#line 175
  words_merge_rules_unique(((yyvsp + -3)->sheet)->operators, (yyvsp + -1)->words);
#line 176
  sshval.sheet = (yyvsp + -3)->sheet;
  }
#line 178
  goto switch_break;
  case_9: /* CIL Label */ 
#line 179
  if (highlight_level == 2) {
    {
#line 180
    da_concat(((yyvsp + -2)->sheet)->sequences, (yyvsp + 0)->array);
#line 181
    da_erase((yyvsp + 0)->array);
    }
  } else {
    {
#line 183
    da_free((yyvsp + 0)->array, (void (*)(void * ))(& free_sequence));
    }
  }
#line 184
  sshval.sheet = (yyvsp + -2)->sheet;
#line 186
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 187
  da_concat(((yyvsp + -1)->sheet)->sequences, (yyvsp + 0)->array);
#line 188
  da_erase((yyvsp + 0)->array);
#line 189
  sshval.sheet = (yyvsp + -1)->sheet;
  }
#line 191
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 192
  da_concat(((yyvsp + -1)->sheet)->ancestors, (yyvsp + 0)->array);
#line 193
  da_erase((yyvsp + 0)->array);
#line 194
  sshval.sheet = (yyvsp + -1)->sheet;
  }
#line 196
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 197
  string_to_array((unsigned char *)(((yyvsp + -3)->sheet)->alpha1), (unsigned char const   *)(yyvsp + 0)->string);
#line 198
  string_to_array((unsigned char *)(((yyvsp + -3)->sheet)->alpha2), (unsigned char const   *)(yyvsp + 0)->string);
#line 200
  free((void *)(yyvsp + 0)->string);
#line 201
  (yyvsp + 0)->string = (unsigned char *)((void *)0);
#line 202
  sshval.sheet = (yyvsp + -3)->sheet;
  }
#line 204
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 205
  string_to_array((unsigned char *)(((yyvsp + -4)->sheet)->alpha1), (unsigned char const   *)(yyvsp + 0)->string);
#line 207
  free((void *)(yyvsp + 0)->string);
#line 208
  (yyvsp + 0)->string = (unsigned char *)((void *)0);
#line 209
  sshval.sheet = (yyvsp + -4)->sheet;
  }
#line 211
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 212
  string_to_array((unsigned char *)(((yyvsp + -4)->sheet)->alpha2), (unsigned char const   *)(yyvsp + 0)->string);
#line 214
  free((void *)(yyvsp + 0)->string);
#line 215
  (yyvsp + 0)->string = (unsigned char *)((void *)0);
#line 216
  sshval.sheet = (yyvsp + -4)->sheet;
  }
#line 218
  goto switch_break;
  case_15: /* CIL Label */ 
#line 219
  ((yyvsp + -1)->sheet)->sensitiveness = (yyvsp + 0)->sensitiveness;
#line 221
  goto switch_break;
  case_16: /* CIL Label */ 
#line 222
  ((yyvsp + -1)->sheet)->documentation = (unsigned char const   *)(yyvsp + 0)->string;
#line 224
  goto switch_break;
  case_17: /* CIL Label */ 
#line 225
  ((yyvsp + -1)->sheet)->author = (unsigned char const   *)(yyvsp + 0)->string;
#line 227
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 228
  style_sheet_set_version((yyvsp + -1)->sheet, (char const   *)(yyvsp + 0)->string);
  }
#line 230
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 234
  tmp___1 = style_sheet_set_requirement((yyvsp + -1)->sheet, (char const   *)(yyvsp + 0)->string);
  }
#line 234
  if (! tmp___1) {
    {
#line 235
    tmp___0 = gettext("cannot process `%s\' which requires a2ps version %s");
#line 235
    error(1, 0, (char const   *)tmp___0, sshfilename, (yyvsp + 0)->string);
    }
  }
#line 239
  goto switch_break;
  case_20: /* CIL Label */ 
#line 245
  sshval.string = (yyvsp + 0)->string;
#line 246
  goto switch_break;
  case_21: /* CIL Label */ 
#line 246
  sshval.string = (yyvsp + 0)->string;
#line 247
  goto switch_break;
  case_22: /* CIL Label */ 
#line 249
  sshval.string = (yyvsp + -2)->string;
#line 250
  goto switch_break;
  case_23: /* CIL Label */ 
#line 251
  sshval.string = (yyvsp + 0)->string;
#line 252
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 257
  len1 = strlen((char const   *)(yyvsp + -1)->string);
#line 258
  *((yyvsp + -1)->string + len1) = (unsigned char )'\n';
#line 259
  len2 = strlen((char const   *)(yyvsp + 0)->string);
#line 260
  tmp___2 = xmalloc((size_t )(sizeof(unsigned char ) * (unsigned long )((len1 + len2) + 2U)));
#line 260
  sshval.string = (unsigned char *)tmp___2;
#line 261
  tmp___3 = stpncpy((char */* __restrict  */)((char *)sshval.string), (char const   */* __restrict  */)((char const   *)(yyvsp + -1)->string),
                    len1 + 1U);
#line 261
  stpcpy((char */* __restrict  */)tmp___3, (char const   */* __restrict  */)((char const   *)(yyvsp + 0)->string));
#line 262
  free((void *)(yyvsp + -1)->string);
#line 263
  free((void *)(yyvsp + 0)->string);
  }
#line 265
  goto switch_break;
  case_25: /* CIL Label */ 
#line 267
  sshval.string = (yyvsp + 0)->string;
#line 268
  goto switch_break;
  case_26: /* CIL Label */ 
#line 270
  sshval.string = (yyvsp + 0)->string;
#line 271
  goto switch_break;
  case_27: /* CIL Label */ 
#line 271
  sshval.string = (yyvsp + 0)->string;
#line 272
  goto switch_break;
  case_28: /* CIL Label */ 
#line 279
  sshval.array = (yyvsp + -2)->array;
#line 281
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 286
  sshval.array = da_new("Ancestors tmp", (size_t )2, (enum da_growth )1, (size_t )2,
                        (void (*)(void const   * , FILE *stream ))(& da_str_print),
                        (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
#line 289
  da_append(sshval.array, (void *)(yyvsp + 0)->string);
  }
#line 291
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 293
  da_append((yyvsp + -2)->array, (void *)(yyvsp + 0)->string);
#line 294
  sshval.array = (yyvsp + -2)->array;
  }
#line 296
  goto switch_break;
  case_31: /* CIL Label */ 
#line 298
  sshval.sensitiveness = (yyvsp + 0)->sensitiveness;
#line 299
  goto switch_break;
  case_32: /* CIL Label */ 
#line 308
  sshval.pattern = (yyvsp + 0)->pattern;
#line 310
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 313
  sshval.pattern = (yyvsp + -1)->pattern;
#line 314
  tmp___4 = xrealloc((void *)(sshval.pattern)->pattern, (size_t )(sizeof(char ) * (unsigned long )((((yyvsp + -1)->pattern)->len + ((yyvsp + 0)->pattern)->len) + 1U)));
#line 314
  (sshval.pattern)->pattern = (char *)tmp___4;
#line 315
  strncpy((char */* __restrict  */)((sshval.pattern)->pattern + (sshval.pattern)->len),
          (char const   */* __restrict  */)((yyvsp + 0)->pattern)->pattern, ((yyvsp + 0)->pattern)->len);
#line 316
  (sshval.pattern)->len += ((yyvsp + 0)->pattern)->len;
#line 317
  free((void *)((yyvsp + 0)->pattern)->pattern);
  }
#line 319
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 324
  sshval.array = rhs_new();
#line 325
  rhs_add(sshval.array, (yyvsp + 0)->faced_string);
  }
#line 327
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 332
  sshval.faced_string = faced_string_new((yyvsp + -1)->string, 0, (yyvsp + 0)->fface);
  }
#line 334
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 336
  sshval.faced_string = faced_string_new((yyvsp + 0)->string, 0, No_fface);
  }
#line 338
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 340
  sshval.faced_string = faced_string_new((unsigned char *)((void *)0), 0, (yyvsp + 0)->fface);
  }
#line 342
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 344
  sshval.faced_string = faced_string_new((unsigned char *)((void *)0), (yyvsp + -1)->integer,
                                         (yyvsp + 0)->fface);
  }
#line 346
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 348
  sshval.faced_string = faced_string_new((unsigned char *)((void *)0), (yyvsp + 0)->integer,
                                         No_fface);
  }
#line 350
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 352
  sshval.faced_string = faced_string_new((yyvsp + 0)->string, 0, Symbol_fface);
  }
#line 354
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 359
  sshval.array = rhs_new();
#line 360
  rhs_add(sshval.array, (yyvsp + 0)->faced_string);
  }
#line 362
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 365
  rhs_add((yyvsp + -2)->array, (yyvsp + 0)->faced_string);
#line 366
  sshval.array = (yyvsp + -2)->array;
  }
#line 368
  goto switch_break;
  case_43: /* CIL Label */ 
#line 376
  sshval.fface.face = (yyvsp + 0)->face;
#line 377
  sshval.fface.flags = (enum fflag_e )0;
#line 379
  goto switch_break;
  case_44: /* CIL Label */ 
#line 381
  sshval.fface.face = (enum face_e )-1;
#line 382
  sshval.fface.flags = (yyvsp + 0)->fflags;
#line 384
  sshval.fface.flags = (enum fflag_e )((unsigned int )sshval.fface.flags | 1U);
#line 386
  goto switch_break;
  case_45: /* CIL Label */ 
#line 388
  sshval.fface = (yyvsp + -1)->fface;
#line 390
  if ((int )sshval.fface.face == -1) {
#line 391
    sshval.fface.flags = (enum fflag_e )((unsigned int )sshval.fface.flags | 1U);
  }
#line 393
  goto switch_break;
  case_46: /* CIL Label */ 
#line 398
  sshval.fface.face = (yyvsp + 0)->face;
#line 399
  sshval.fface.flags = (enum fflag_e )0;
#line 401
  goto switch_break;
  case_47: /* CIL Label */ 
#line 403
  sshval.fface.face = (enum face_e )-1;
#line 404
  sshval.fface.flags = (yyvsp + 0)->fflags;
#line 406
  goto switch_break;
  case_48: /* CIL Label */ 
#line 409
  sshval.fface = (yyvsp + -2)->fface;
#line 410
  sshval.fface.face = (yyvsp + 0)->face;
#line 412
  goto switch_break;
  case_49: /* CIL Label */ 
#line 414
  sshval.fface = (yyvsp + -2)->fface;
#line 415
  sshval.fface.flags = (enum fflag_e )((unsigned int )sshval.fface.flags | (unsigned int )(yyvsp + 0)->fflags);
#line 417
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 428
  sshval.rule = rule_new((yyvsp + -1)->string, (struct pattern *)((void *)0), (yyvsp + 0)->array,
                         sshfilename, (size_t )sshlineno);
  }
#line 431
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 433
  tmp___5 = rhs_new_single((unsigned char *)((void *)0), 0, No_fface);
#line 433
  sshval.rule = rule_new((yyvsp + 0)->string, (struct pattern *)((void *)0), tmp___5,
                         sshfilename, (size_t )sshlineno);
  }
#line 437
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 439
  sshval.rule = rule_new((yyvsp + -2)->string, (struct pattern *)((void *)0), (yyvsp + -1)->array,
                         sshfilename, (size_t )sshlineno);
  }
#line 442
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 450
  words_set_no_face((yyvsp + -1)->words, (yyvsp + -3)->fface);
#line 451
  sshval.words = (yyvsp + -1)->words;
  }
#line 453
  goto switch_break;
  case_54: /* CIL Label */ 
#line 455
  sshval.words = (yyvsp + -1)->words;
#line 457
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 462
  sshval.words = words_new("Keywords: Strings", "Keywords: Regexps", (size_t )100,
                           (size_t )100);
#line 463
  words_add_string(sshval.words, (yyvsp + 0)->rule);
  }
#line 465
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 467
  sshval.words = words_new("Keywords: Strings", "Keywords: Regexps", (size_t )100,
                           (size_t )100);
#line 468
  words_add_regex(sshval.words, (yyvsp + 0)->rule);
  }
#line 470
  goto switch_break;
  case_57: /* CIL Label */ 
  {
#line 472
  words_add_string((yyvsp + -2)->words, (yyvsp + 0)->rule);
#line 473
  sshval.words = (yyvsp + -2)->words;
  }
#line 475
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 477
  words_add_regex((yyvsp + -2)->words, (yyvsp + 0)->rule);
#line 478
  sshval.words = (yyvsp + -2)->words;
  }
#line 480
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 489
  sshval.rule = keyword_rule_new((unsigned char *)((void *)0), (yyvsp + -1)->pattern,
                                 (yyvsp + 0)->array, sshfilename, (size_t )sshlineno);
  }
#line 492
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 494
  tmp___6 = rhs_new_single((unsigned char *)((void *)0), 0, No_fface);
#line 494
  sshval.rule = keyword_rule_new((unsigned char *)((void *)0), (yyvsp + 0)->pattern,
                                 tmp___6, sshfilename, (size_t )sshlineno);
  }
#line 499
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 501
  sshval.rule = keyword_rule_new((unsigned char *)((void *)0), (yyvsp + -2)->pattern,
                                 (yyvsp + -1)->array, sshfilename, (size_t )sshlineno);
  }
#line 504
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 510
  words_set_no_face((yyvsp + -1)->words, (yyvsp + -3)->fface);
#line 511
  sshval.words = (yyvsp + -1)->words;
  }
#line 513
  goto switch_break;
  case_63: /* CIL Label */ 
#line 515
  sshval.words = (yyvsp + -1)->words;
#line 517
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 522
  sshval.words = words_new("Operators: Strings", "Operators: Regexps", (size_t )100,
                           (size_t )100);
#line 524
  words_add_string(sshval.words, (yyvsp + 0)->rule);
  }
#line 526
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 528
  sshval.words = words_new("Operators: Strings", "Operators: Regexps", (size_t )100,
                           (size_t )100);
#line 530
  words_add_regex(sshval.words, (yyvsp + 0)->rule);
  }
#line 532
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 534
  words_add_string((yyvsp + -2)->words, (yyvsp + 0)->rule);
#line 535
  sshval.words = (yyvsp + -2)->words;
  }
#line 537
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 539
  words_add_regex((yyvsp + -2)->words, (yyvsp + 0)->rule);
#line 540
  sshval.words = (yyvsp + -2)->words;
  }
#line 542
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 551
  sshval.rule = rule_new((unsigned char *)((void *)0), (yyvsp + -1)->pattern, (yyvsp + 0)->array,
                         sshfilename, (size_t )sshlineno);
  }
#line 554
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 556
  tmp___7 = rhs_new_single((unsigned char *)((void *)0), 0, No_fface);
#line 556
  sshval.rule = rule_new((unsigned char *)((void *)0), (yyvsp + 0)->pattern, tmp___7,
                         sshfilename, (size_t )sshlineno);
  }
#line 560
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 562
  sshval.rule = rule_new((unsigned char *)((void *)0), (yyvsp + -2)->pattern, (yyvsp + -1)->array,
                         sshfilename, (size_t )sshlineno);
  }
#line 565
  goto switch_break;
  case_71: /* CIL Label */ 
#line 570
  sshval.array = (yyvsp + -2)->array;
#line 571
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 574
  sshval.array = da_new("Sequence tmp", (size_t )100, (enum da_growth )1, (size_t )100,
                        (void (*)(void const   * , FILE *stream ))(& sequence_self_print),
                        (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
#line 577
  da_append(sshval.array, (void *)(yyvsp + 0)->sequence);
  }
#line 579
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 580
  da_append((yyvsp + -2)->array, (void *)(yyvsp + 0)->sequence);
#line 581
  sshval.array = (yyvsp + -2)->array;
  }
#line 583
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 605
  tmp___8 = rhs_new_single((yyvsp + -3)->string, 0, Symbol_fface);
#line 605
  open_rule = rule_new((yyvsp + -4)->string, (struct pattern *)((void *)0), tmp___8,
                       sshfilename, (size_t )sshlineno);
#line 608
  sshval.sequence = sequence_new(open_rule, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 610
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 613
  tmp___9 = rhs_new_single((yyvsp + -4)->string, 0, (yyvsp + -3)->fface);
#line 613
  open_rule___0 = rule_new((yyvsp + -5)->string, (struct pattern *)((void *)0), tmp___9,
                           sshfilename, (size_t )sshlineno);
#line 616
  sshval.sequence = sequence_new(open_rule___0, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 618
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 621
  tmp___10 = rhs_new_single((unsigned char *)((void *)0), 0, (yyvsp + -3)->fface);
#line 621
  open_rule___1 = rule_new((yyvsp + -4)->string, (struct pattern *)((void *)0), tmp___10,
                           sshfilename, (size_t )sshlineno);
#line 624
  sshval.sequence = sequence_new(open_rule___1, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 626
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 629
  tmp___11 = rhs_new_single((yyvsp + -3)->string, 0, (yyvsp + -2)->fface);
#line 629
  open_rule___2 = rule_new((yyvsp + -4)->string, (struct pattern *)((void *)0), tmp___11,
                           sshfilename, (size_t )sshlineno);
#line 632
  sshval.sequence = sequence_new(open_rule___2, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 634
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 637
  tmp___12 = rhs_new_single((unsigned char *)((void *)0), 0, (yyvsp + -2)->fface);
#line 637
  open_rule___3 = rule_new((yyvsp + -3)->string, (struct pattern *)((void *)0), tmp___12,
                           sshfilename, (size_t )sshlineno);
#line 640
  sshval.sequence = sequence_new(open_rule___3, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 642
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 645
  tmp___13 = rhs_new_single((yyvsp + -4)->string, 0, (yyvsp + -3)->fface);
#line 645
  open_rule___4 = rule_new((unsigned char *)((void *)0), (yyvsp + -5)->pattern, tmp___13,
                           sshfilename, (size_t )sshlineno);
#line 648
  sshval.sequence = sequence_new(open_rule___4, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 650
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 653
  tmp___14 = rhs_new_single((unsigned char *)((void *)0), 0, (yyvsp + -3)->fface);
#line 653
  open_rule___5 = rule_new((unsigned char *)((void *)0), (yyvsp + -4)->pattern, tmp___14,
                           sshfilename, (size_t )sshlineno);
#line 656
  sshval.sequence = sequence_new(open_rule___5, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 658
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 661
  tmp___15 = rhs_new_single((yyvsp + -3)->string, 0, (yyvsp + -2)->fface);
#line 661
  open_rule___6 = rule_new((unsigned char *)((void *)0), (yyvsp + -4)->pattern, tmp___15,
                           sshfilename, (size_t )sshlineno);
#line 664
  sshval.sequence = sequence_new(open_rule___6, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 666
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 669
  tmp___16 = rhs_new_single((unsigned char *)((void *)0), 0, No_fface);
#line 669
  open_rule___7 = rule_new((unsigned char *)((void *)0), (yyvsp + -3)->pattern, tmp___16,
                           sshfilename, (size_t )sshlineno);
#line 672
  sshval.sequence = sequence_new(open_rule___7, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 674
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 677
  open_rule___8 = rule_new((yyvsp + -5)->string, (struct pattern *)((void *)0), (yyvsp + -4)->array,
                           sshfilename, (size_t )sshlineno);
#line 679
  sshval.sequence = sequence_new(open_rule___8, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 681
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 684
  open_rule___9 = rule_new((unsigned char *)((void *)0), (yyvsp + -5)->pattern, (yyvsp + -4)->array,
                           sshfilename, (size_t )sshlineno);
#line 686
  sshval.sequence = sequence_new(open_rule___9, (yyvsp + -2)->fface, (yyvsp + -1)->words,
                                 (yyvsp + 0)->words);
  }
#line 688
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 691
  sshval.sequence = new_C_string_sequence("\"");
  }
#line 693
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 695
  sshval.sequence = new_C_string_sequence("\'");
  }
#line 697
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 703
  sshval.words = words_new("Closing: Strings", "Closing: Regexps", (size_t )2, (size_t )2);
#line 704
  tmp___17 = rhs_new_single((unsigned char *)((void *)0), 0, No_fface);
#line 704
  tmp___18 = xstrdup("\n");
#line 704
  tmp___19 = rule_new((unsigned char *)tmp___18, (struct pattern *)((void *)0), tmp___17,
                      sshfilename, (size_t )sshlineno);
#line 704
  words_add_string(sshval.words, tmp___19);
  }
#line 709
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 712
  sshval.words = words_new("Closing: Strings", "Closing: Regexps", (size_t )2, (size_t )2);
#line 713
  words_add_string(sshval.words, (yyvsp + 0)->rule);
  }
#line 715
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 718
  sshval.words = words_new("Closing: Strings", "Closing: Regexps", (size_t )2, (size_t )2);
#line 719
  words_add_regex(sshval.words, (yyvsp + 0)->rule);
  }
#line 721
  goto switch_break;
  case_90: /* CIL Label */ 
#line 724
  sshval.words = (yyvsp + -1)->words;
#line 726
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 731
  sshval.words = words_new("Exceptions: Strings", "Exceptions: Regexps", (size_t )1,
                           (size_t )1);
  }
#line 733
  goto switch_break;
  case_92: /* CIL Label */ 
#line 735
  sshval.words = (yyvsp + -1)->words;
#line 737
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2423 "parsessh.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2425
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2425
    if (sshdebug) {
      {
#line 2425
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 2425
      yy_symbol_print___0(stderr, (int )sshr1[yyn], (YYSTYPE___0 const   */* const  */)(& sshval));
#line 2425
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 2425
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2427
  yyvsp -= sshyylen;
#line 2427
  yyssp -= sshyylen;
#line 2428
  sshyylen = 0;
  {
#line 2429
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2429
    if (sshdebug) {
      {
#line 2429
      yy_stack_print___0(yyss, yyssp);
      }
    }
#line 2429
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2431
  yyvsp ++;
#line 2431
  *yyvsp = sshval;
#line 2438
  yyn = (int )sshr1[yyn];
#line 2440
  sshstate = (int )((int const   )yypgoto___0[yyn - 39] + (int const   )*yyssp);
#line 2441
  if (0 <= sshstate) {
#line 2441
    if (sshstate <= 218) {
#line 2441
      if ((int const   )sshyycheck[sshstate] == (int const   )*yyssp) {
#line 2442
        sshstate = (int )sshyytable[sshstate];
      } else {
#line 2444
        sshstate = (int )yydefgoto___0[yyn - 39];
      }
    } else {
#line 2444
      sshstate = (int )yydefgoto___0[yyn - 39];
    }
  } else {
#line 2444
    sshstate = (int )yydefgoto___0[yyn - 39];
  }
#line 2446
  goto yynewstate;
  yyerrlab: 
#line 2454
  if (! yyerrstatus) {
    {
#line 2456
    sshnerrs ++;
#line 2461
    tmp___20 = yysyntax_error___0((char *)0, sshstate, sshchar);
#line 2461
    yysize___0 = tmp___20;
    }
#line 2462
    if (yymsg_alloc < yysize___0) {
#line 2462
      if (yymsg_alloc < 4294967295U) {
#line 2464
        yyalloc = 2U * yysize___0;
#line 2465
        if (yysize___0 <= yyalloc) {
#line 2465
          if (! (yyalloc <= 4294967295U)) {
#line 2466
            yyalloc = 4294967295U;
          }
        } else {
#line 2466
          yyalloc = 4294967295U;
        }
#line 2467
        if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
          {
#line 2468
          free((void *)yymsg);
          }
        }
        {
#line 2469
        tmp___21 = malloc(yyalloc);
#line 2469
        yymsg = (char *)tmp___21;
        }
#line 2470
        if (yymsg) {
#line 2471
          yymsg_alloc = yyalloc;
        } else {
#line 2474
          yymsg = yymsgbuf;
#line 2475
          yymsg_alloc = (unsigned int )sizeof(yymsgbuf);
        }
      }
    }
#line 2479
    if (0U < yysize___0) {
#line 2479
      if (yysize___0 <= yymsg_alloc) {
        {
#line 2481
        yysyntax_error___0(yymsg, sshstate, sshchar);
#line 2482
        ssherror((char const   *)yymsg);
        }
      } else {
#line 2479
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2486
      ssherror("syntax error");
      }
#line 2487
      if (yysize___0 != 0U) {
#line 2488
        goto yyexhaustedlab;
      }
    }
  }
#line 2496
  if (yyerrstatus == 3) {
#line 2501
    if (sshchar <= 0) {
#line 2504
      if (sshchar == 0) {
#line 2505
        goto yyabortlab;
      }
    } else {
      {
#line 2509
      yydestruct___0("Error: discarding", yytoken, & sshlval);
#line 2511
      sshchar = -2;
      }
    }
  }
#line 2517
  goto yyerrlab1;
#line 2533
  yyvsp -= sshyylen;
#line 2533
  yyssp -= sshyylen;
#line 2534
  sshyylen = 0;
  {
#line 2535
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2535
    if (sshdebug) {
      {
#line 2535
      yy_stack_print___0(yyss, yyssp);
      }
    }
#line 2535
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 2536
  sshstate = (int )*yyssp;
#line 2537
  goto yyerrlab1;
  yyerrlab1: 
#line 2544
  yyerrstatus = 3;
  {
#line 2546
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2548
    yyn = (int )sshpact[sshstate];
#line 2549
    if (yyn != -150) {
#line 2551
      yyn ++;
#line 2552
      if (0 <= yyn) {
#line 2552
        if (yyn <= 218) {
#line 2552
          if ((int const   )sshyycheck[yyn] == 1) {
#line 2554
            yyn = (int )sshyytable[yyn];
#line 2555
            if (0 < yyn) {
#line 2556
              goto while_break___12;
            }
          }
        }
      }
    }
#line 2561
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2562
      goto yyabortlab;
    }
    {
#line 2565
    yydestruct___0("Error: popping", (int )yystos___0[sshstate], yyvsp);
#line 2567
    yyvsp --;
#line 2567
    yyssp --;
#line 2568
    sshstate = (int )*yyssp;
    }
    {
#line 2569
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 2569
      if (sshdebug) {
        {
#line 2569
        yy_stack_print___0(yyss, yyssp);
        }
      }
#line 2569
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2572
  if (yyn == 5) {
#line 2573
    goto yyacceptlab;
  }
#line 2575
  yyvsp ++;
#line 2575
  *yyvsp = sshlval;
  {
#line 2579
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 2579
    if (sshdebug) {
      {
#line 2579
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 2579
      yy_symbol_print___0(stderr, (int )yystos___0[yyn], (YYSTYPE___0 const   */* const  */)yyvsp);
#line 2579
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 2579
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 2581
  sshstate = yyn;
#line 2582
  goto yynewstate;
  yyacceptlab: 
#line 2589
  yyresult = 0;
#line 2590
  goto yyreturn;
  yyabortlab: 
#line 2596
  yyresult = 1;
#line 2597
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2604
  ssherror("memory exhausted");
#line 2605
  yyresult = 2;
  }
  yyreturn: 
#line 2610
  if (sshchar != 0) {
#line 2610
    if (sshchar != -2) {
      {
#line 2611
      yydestruct___0("Cleanup: discarding lookahead", yytoken, & sshlval);
      }
    }
  }
#line 2615
  yyvsp -= sshyylen;
#line 2615
  yyssp -= sshyylen;
  {
#line 2616
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 2616
    if (sshdebug) {
      {
#line 2616
      yy_stack_print___0(yyss, yyssp);
      }
    }
#line 2616
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 2617
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 2617
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2617
      goto while_break___16;
    }
    {
#line 2619
    yydestruct___0("Cleanup: popping", (int )yystos___0[*yyssp], yyvsp);
#line 2621
    yyvsp --;
#line 2621
    yyssp --;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 2624
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2625
    free((void *)yyss);
    }
  }
#line 2628
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    {
#line 2629
    free((void *)yymsg);
    }
  }
#line 2632
  return (yyresult);
}
}
#line 740 "parsessh.y"
void ssherror(char const   *msg ) 
{ 


  {
  {
#line 743
  error_at_line(1, 0, sshfilename, (unsigned int )sshlineno, msg);
  }
#line 744
  return;
}
}
#line 749 "parsessh.y"
static void yyprint___0(FILE *file , int type , YYSTYPE___0 value ) 
{ 
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 753
  if (type == 289) {
#line 753
    goto case_289;
  }
#line 757
  if (type == 284) {
#line 757
    goto case_284;
  }
#line 762
  if (type == 283) {
#line 762
    goto case_283;
  }
#line 766
  if (type == 287) {
#line 766
    goto case_287;
  }
#line 770
  if (type == 285) {
#line 770
    goto case_285;
  }
#line 752
  goto switch_break;
  case_289: /* CIL Label */ 
  {
#line 754
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" \\%d",
          value.integer);
  }
#line 755
  goto switch_break;
  case_284: /* CIL Label */ 
  {
#line 758
  _IO_putc(' ', file);
#line 759
  fflag_self_print(value.fflags, file);
  }
#line 760
  goto switch_break;
  case_283: /* CIL Label */ 
  {
#line 763
  tmp = face_to_string(value.face);
#line 763
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %s", tmp);
  }
#line 764
  goto switch_break;
  case_287: /* CIL Label */ 
  {
#line 767
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" /%s/",
          (value.pattern)->pattern);
  }
#line 768
  goto switch_break;
  case_285: /* CIL Label */ 
  {
#line 771
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" \"%s\"",
          value.string);
  }
#line 772
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 774
  return;
}
}
#line 776 "parsessh.y"
struct style_sheet *parse_style_sheet(char const   *filename ) 
{ 
  int res___2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 781
  sshfilename = filename;
#line 782
  sshlineno = 1;
#line 783
  sshin = xrfopen(sshfilename);
  }
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 785
    if ((unsigned int )(((1 << 6) | (1 << 2)) | (1 << 11)) & msg_verbosity) {
      {
#line 785
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing file `%s\'\n",
              sshfilename);
      }
    }
#line 785
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 788
  sshlex_initialize();
  }
#line 790
  if ((unsigned int )(1 << 11) & msg_verbosity) {
#line 791
    sshdebug = 1;
  }
  {
#line 792
  res___2 = sshparse();
  }
#line 794
  if ((unsigned int )(1 << 2) & msg_verbosity) {
    {
#line 795
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"---------- Right after parsing of %s\n",
            parsed_style_sheet->key);
#line 797
    style_sheet_self_print(parsed_style_sheet, stderr);
#line 798
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"---------- End of after parsing of %s\n",
            parsed_style_sheet->key);
    }
  }
  {
#line 802
  fclose(sshin);
  }
#line 803
  return (parsed_style_sheet);
}
}
#line 55 "../lib/getopt.h"
extern int opterr ;
#line 28 "/home/ysko/Works/test-src/a2ps-4.14/src/long-options.h"
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , char const   *authors , void (*usage_func)(int  ) ) ;
#line 33 "/home/ysko/Works/test-src/a2ps-4.14/src/version-etc.h"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version , char const   *authors ) ;
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/src/long-options.c"
static struct option  const  long_options___0[3]  = {      {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'v'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 47 "/home/ysko/Works/test-src/a2ps-4.14/src/long-options.c"
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , char const   *authors , void (*usage_func)(int  ) ) 
{ 
  int c ;
  int saved_opterr ;
  char *__cil_tmp10 ;

  {
#line 59
  saved_opterr = opterr;
#line 62
  opterr = 0;
#line 64
  if (argc == 2) {
    {
#line 64
    c = getopt_long(argc, (char * const  *)argv, "+", long_options___0, (int *)((void *)0));
    }
#line 64
    if (c != -1) {
      {
#line 69
      if (c == 104) {
#line 69
        goto case_104;
      }
#line 72
      if (c == 118) {
#line 72
        goto case_118;
      }
#line 78
      goto switch_default;
      case_104: /* CIL Label */ 
      {
#line 70
      (*usage_func)(0);
      }
      case_118: /* CIL Label */ 
      {
#line 73
      version_etc(stdout, command_name, package, version, authors);
#line 74
      close_stdout();
#line 76
      exit(0);
      }
      switch_default: /* CIL Label */ 
#line 80
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 85
  opterr = saved_opterr;
#line 89
  optind = 0;
#line 90
  return;
}
}
#line 31 "/home/ysko/Works/test-src/a2ps-4.14/src/version-etc.h"
char *version_etc_copyright ;
#line 37 "/home/ysko/Works/test-src/a2ps-4.14/src/version-etc.c"
char *version_etc_copyright  =    (char *)"Copyright (C) 1999 Free Software Foundation, Inc.";
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/src/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version , char const   *authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 56
  if (command_name) {
    {
#line 57
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 59
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 60
  tmp = gettext("Written by %s.\n");
#line 60
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp, authors);
#line 61
  _IO_putc('\n', stream);
#line 63
  tmp___0 = gettext((char const   *)version_etc_copyright);
#line 63
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 64
  _IO_putc('\n', stream);
#line 66
  tmp___1 = gettext("This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
#line 66
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stream);
  }
#line 70
  return;
}
}
#line 80 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.h"
void fface_self_print(struct fface_s fface , FILE *stream ) ;
#line 120
struct fface_s String_fface ;
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.c"
static struct fflag_and_name  const  fflag_and_name[11]  = 
#line 42 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.c"
  {      {"Invisible", (enum fflag_e )1}, 
        {"Tag1", (enum fflag_e )2}, 
        {"Tag2", (enum fflag_e )4}, 
        {"Tag3", (enum fflag_e )8}, 
        {"Tag4", (enum fflag_e )16}, 
        {"Index1", (enum fflag_e )32}, 
        {"Index2", (enum fflag_e )64}, 
        {"Index3", (enum fflag_e )128}, 
        {"Index4", (enum fflag_e )256}, 
        {"Encoding", (enum fflag_e )512}, 
        {(char const   *)((void *)0), (enum fflag_e )0}};
#line 59 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.c"
struct fface_s String_fface  =    {(enum face_e )5, (enum fflag_e )0};
#line 60 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.c"
struct fface_s Plain_fface  =    {(enum face_e )0, (enum fflag_e )0};
#line 61 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.c"
struct fface_s Symbol_fface  =    {(enum face_e )6, (enum fflag_e )0};
#line 62 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.c"
struct fface_s No_fface  =    {(enum face_e )-1, (enum fflag_e )0};
#line 68 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.c"
void fflag_self_print(enum fflag_e flags , FILE *stream ) 
{ 
  int i ;
  int first ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 72
  first = 1;
#line 74
  _IO_putc('(', stream);
  }
#line 76
  if ((unsigned int )flags == 0U) {
    {
#line 77
    fputs((char const   */* __restrict  */)"No_fflag", (FILE */* __restrict  */)stream);
    }
  } else {
#line 81
    i = 0;
    {
#line 81
    while (1) {
      while_continue: /* CIL Label */ ;
#line 81
      if (! fflag_and_name[i].flag) {
#line 81
        goto while_break;
      }
#line 82
      if ((unsigned int const   )fflag_and_name[i].flag & (unsigned int const   )flags) {
#line 83
        if (! first) {
          {
#line 84
          fputs((char const   */* __restrict  */)" + ", (FILE */* __restrict  */)stream);
          }
        } else {
#line 86
          first = 0;
        }
        {
#line 87
        fputs((char const   */* __restrict  */)fflag_and_name[i].name, (FILE */* __restrict  */)stream);
        }
      }
#line 81
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 91
  _IO_putc(')', stream);
  }
#line 92
  return;
}
}
#line 97 "/home/ysko/Works/test-src/a2ps-4.14/src/ffaces.c"
void fface_self_print(struct fface_s fface , FILE *stream ) 
{ 
  int i ;
  char *__cil_tmp4 ;

  {
#line 102
  if (fface.flags) {
    {
#line 103
    _IO_putc('(', stream);
#line 106
    face_self_print(fface.face, stream);
#line 109
    i = 0;
    }
    {
#line 109
    while (1) {
      while_continue: /* CIL Label */ ;
#line 109
      if (! fflag_and_name[i].flag) {
#line 109
        goto while_break;
      }
#line 110
      if ((unsigned int const   )fflag_and_name[i].flag & (unsigned int const   )fface.flags) {
        {
#line 111
        fputs((char const   */* __restrict  */)" + ", (FILE */* __restrict  */)stream);
#line 112
        fputs((char const   */* __restrict  */)fflag_and_name[i].name, (FILE */* __restrict  */)stream);
        }
      }
#line 109
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 115
    _IO_putc(')', stream);
    }
  } else {
    {
#line 119
    face_self_print(fface.face, stream);
    }
  }
#line 120
  return;
}
}
#line 35 "/home/ysko/Works/test-src/a2ps-4.14/src/versions.h"
void version_set_to_null(int *version ) ;
#line 37
_Bool version_null_p(int *version ) ;
#line 39
int version_cmp(int *v1 , int *v2 ) ;
#line 41
void version_cpy(int *d , int *s ) ;
#line 43
void version_self_print(int *version , FILE *stream ) ;
#line 46
int version_length(int *version ) ;
#line 48
void version_add(int *v1 , int *v2 ) ;
#line 50
void string_to_version(char const   *version_string , int *version ) ;
#line 34 "/home/ysko/Works/test-src/a2ps-4.14/src/versions.c"
void version_set_to_null(int *version ) 
{ 
  size_t n ;

  {
#line 39
  n = (size_t )0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! (n < 3U)) {
#line 39
      goto while_break;
    }
#line 40
    *(version + n) = 0;
#line 39
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 43 "/home/ysko/Works/test-src/a2ps-4.14/src/versions.c"
_Bool version_null_p(int *version ) 
{ 
  size_t n ;

  {
#line 48
  n = (size_t )0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (n < 3U)) {
#line 48
      goto while_break;
    }
#line 49
    if (*(version + n)) {
#line 50
      return ((_Bool)0);
    }
#line 48
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((_Bool)1);
}
}
#line 54 "/home/ysko/Works/test-src/a2ps-4.14/src/versions.c"
int version_cmp(int *v1 , int *v2 ) 
{ 
  int n ;

  {
#line 59
  n = 0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! (n < 3)) {
#line 59
      goto while_break;
    }
#line 60
    if (*(v1 + n) < *(v2 + n)) {
#line 61
      return (-1);
    } else
#line 62
    if (*(v1 + n) > *(v2 + n)) {
#line 63
      return (1);
    }
#line 59
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return (0);
}
}
#line 68 "/home/ysko/Works/test-src/a2ps-4.14/src/versions.c"
void version_cpy(int *d , int *s ) 
{ 


  {
  {
#line 71
  memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)s, (size_t )(3UL * sizeof(*(s + 0))));
  }
#line 72
  return;
}
}
#line 74 "/home/ysko/Works/test-src/a2ps-4.14/src/versions.c"
void version_self_print(int *version , FILE *stream ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 77
  if (*(version + 2)) {
    {
#line 78
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d.%d%c",
            *(version + 0), *(version + 1), *(version + 2));
    }
  } else {
    {
#line 81
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d.%d",
            *(version + 0), *(version + 1));
    }
  }
#line 83
  return;
}
}
#line 88 "/home/ysko/Works/test-src/a2ps-4.14/src/versions.c"
int version_length(int *version ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 92
  if (*(version + 2)) {
#line 93
    if (*(version + 0) < 10) {
#line 93
      tmp = 1;
    } else {
#line 93
      tmp = 2;
    }
#line 93
    if (*(version + 1) < 10) {
#line 93
      tmp___0 = 1;
    } else {
#line 93
      tmp___0 = 2;
    }
#line 93
    return (((2 + tmp) + tmp___0) + 1);
  } else {
#line 98
    if (*(version + 0) < 10) {
#line 98
      tmp___1 = 1;
    } else {
#line 98
      tmp___1 = 2;
    }
#line 98
    if (*(version + 1) < 10) {
#line 98
      tmp___2 = 1;
    } else {
#line 98
      tmp___2 = 2;
    }
#line 98
    return ((1 + tmp___1) + tmp___2);
  }
}
}
#line 103 "/home/ysko/Works/test-src/a2ps-4.14/src/versions.c"
void version_add(int *v1 , int *v2 ) 
{ 
  int n ;

  {
#line 108
  n = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (n < 3)) {
#line 108
      goto while_break;
    }
#line 109
    *(v1 + n) += *(v2 + n);
#line 108
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return;
}
}
#line 117 "/home/ysko/Works/test-src/a2ps-4.14/src/versions.c"
void string_to_version(char const   *version_string , int *version ) 
{ 
  char d ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 122
  tmp = sscanf((char const   */* __restrict  */)version_string, (char const   */* __restrict  */)"%d.%d%c",
               version + 0, version + 1, & d);
  }
  {
#line 125
  if (tmp == 2) {
#line 125
    goto case_2;
  }
#line 128
  if (tmp == 3) {
#line 128
    goto case_3;
  }
#line 131
  goto switch_default;
  case_2: /* CIL Label */ 
#line 126
  *(version + 2) = 0;
#line 127
  goto switch_break;
  case_3: /* CIL Label */ 
#line 129
  *(version + 2) = ((int )d - 97) + 1;
#line 130
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 132
  tmp___0 = quotearg(version_string);
#line 132
  tmp___1 = gettext("invalid version number `%s\'");
#line 132
  error(1, 0, (char const   *)tmp___1, tmp___0);
  }
#line 134
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 51 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.h"
char const   *eol_to_string(enum eol_e eol ) ;
#line 52
enum eol_e option_string_to_eol(char const   *option , char const   *arg ) ;
#line 83
void buffer_stream_set(buffer_t *buffer , FILE *stream , enum eol_e eol ) ;
#line 86
void buffer_pipe_set(buffer_t *buffer , FILE *stream , enum eol_e eol ) ;
#line 89
void buffer_string_set(buffer_t *buffer , unsigned char const   *string , enum eol_e eol ) ;
#line 92
void buffer_buffer_set(buffer_t *buffer , unsigned char const   *buf___0 , size_t bufsize ,
                       enum eol_e eol ) ;
#line 96
void buffer_set_lower_case(buffer_t *buffer , _Bool sensitive ) ;
#line 97
void buffer_self_print(buffer_t *buffer , FILE *stream ) ;
#line 99
void buffer_release(buffer_t *buffer ) ;
#line 101
void buffer_get(buffer_t *buffer ) ;
#line 103
void buffer_sample_get(buffer_t *buffer , char const   *filename ) ;
#line 104
void buffer_save(buffer_t *buffer , char const   *filename ) ;
#line 48 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
char const   *eol_to_string(enum eol_e eol ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 53
  if ((unsigned int )eol == 0U) {
#line 53
    goto case_0;
  }
#line 56
  if ((unsigned int )eol == 1U) {
#line 56
    goto case_1;
  }
#line 59
  if ((unsigned int )eol == 2U) {
#line 59
    goto case_2;
  }
#line 62
  if ((unsigned int )eol == 3U) {
#line 62
    goto case_3;
  }
#line 65
  if ((unsigned int )eol == 4U) {
#line 65
    goto case_4;
  }
#line 70
  goto switch_default;
  case_0: /* CIL Label */ 
#line 54
  return ("\\r");
  case_1: /* CIL Label */ 
#line 57
  return ("\\n");
  case_2: /* CIL Label */ 
#line 60
  return ("\\r\\n");
  case_3: /* CIL Label */ 
#line 63
  return ("\\n\\r");
  case_4: /* CIL Label */ 
  {
#line 68
  tmp = gettext("any type");
  }
#line 68
  return ((char const   *)tmp);
  switch_default: /* CIL Label */ 
  {
#line 71
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 73
  return ((char const   *)((void *)0));
}
}
#line 79 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
static char const   * const  eol_args[11]  = 
#line 79
  {      (char const   */* const  */)"r",      (char const   */* const  */)"mac",      (char const   */* const  */)"n",      (char const   */* const  */)"unix", 
        (char const   */* const  */)"nr",      (char const   */* const  */)"rn",      (char const   */* const  */)"pc",      (char const   */* const  */)"auto", 
        (char const   */* const  */)"any",      (char const   */* const  */)"4x4",      (char const   */* const  */)0};
#line 89 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
static enum eol_e  const  eol_types[10]  = 
#line 89
  {      (enum eol_e  const  )0,      (enum eol_e  const  )0,      (enum eol_e  const  )1,      (enum eol_e  const  )1, 
        (enum eol_e  const  )3,      (enum eol_e  const  )2,      (enum eol_e  const  )2,      (enum eol_e  const  )4, 
        (enum eol_e  const  )4,      (enum eol_e  const  )4};
#line 99 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
enum eol_e option_string_to_eol(char const   *option , char const   *arg ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 103
  if (! (sizeof(eol_args) / sizeof(eol_args[0]) == sizeof(eol_types) / sizeof(eol_types[0]) + 1UL)) {
    {
#line 103
    __assert_fail("(sizeof (((eol_args))) / sizeof (*((eol_args)))) == (sizeof (((eol_types))) / sizeof (*((eol_types)))) + 1",
                  "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c", 103U, "option_string_to_eol");
    }
  }
  {
#line 104
  tmp = __xargmatch_internal(option, arg, eol_args, (char const   *)(eol_types), (size_t )sizeof(eol_types[0]),
                             0, argmatch_die);
  }
#line 104
  return ((enum eol_e )eol_types[tmp]);
}
}
#line 110 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
__inline static void buffer_internal_set(buffer_t *buffer , FILE *stream , unsigned char const   *buf___0 ,
                                         size_t bufsize , _Bool pipe_p , enum eol_e eol ) 
{ 


  {
  {
#line 116
  buffer->buf = buf___0;
#line 117
  buffer->bufsize = bufsize;
#line 118
  buffer->bufoffset = (size_t )0;
#line 119
  buffer->stream = stream;
#line 120
  buffer->pipe_p = pipe_p;
#line 122
  buffer->content = (unsigned char *)((void *)0);
#line 123
  buffer->eol = eol;
#line 124
  buffer->lower_case = (_Bool)0;
#line 125
  buffer->value = (unsigned char *)((void *)0);
#line 126
  buffer->line = (size_t )0;
#line 127
  buffer->allocsize = (size_t )0;
#line 128
  buffer->len = (size_t )0;
#line 129
  buffer->curr = (size_t )0;
#line 130
  _obstack_begin(& buffer->obstack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
  }
#line 131
  return;
}
}
#line 133 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
void buffer_stream_set(buffer_t *buffer , FILE *stream , enum eol_e eol ) 
{ 


  {
  {
#line 136
  buffer_internal_set(buffer, stream, (unsigned char const   *)((void *)0), (size_t )0,
                      (_Bool)0, eol);
  }
#line 137
  return;
}
}
#line 139 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
void buffer_pipe_set(buffer_t *buffer , FILE *stream , enum eol_e eol ) 
{ 


  {
  {
#line 142
  buffer_internal_set(buffer, stream, (unsigned char const   *)((void *)0), (size_t )0,
                      (_Bool)1, eol);
  }
#line 143
  return;
}
}
#line 145 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
void buffer_string_set(buffer_t *buffer , unsigned char const   *string , enum eol_e eol ) 
{ 
  size_t tmp ;

  {
  {
#line 148
  tmp = strlen((char const   *)string);
#line 148
  buffer_internal_set(buffer, (FILE *)((void *)0), string, tmp, (_Bool)0, eol);
  }
#line 149
  return;
}
}
#line 151 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
void buffer_buffer_set(buffer_t *buffer , unsigned char const   *buf___0 , size_t bufsize ,
                       enum eol_e eol ) 
{ 


  {
  {
#line 155
  buffer_internal_set(buffer, (FILE *)((void *)0), buf___0, bufsize, (_Bool)0, eol);
  }
#line 156
  return;
}
}
#line 174 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
void buffer_self_print(buffer_t *buffer , FILE *stream ) 
{ 
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 177
  if (buffer->buf) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"A string buffer.  Bufoffset %u\n",
            buffer->bufoffset);
    }
  }
#line 180
  if (buffer->stream) {
#line 181
    if (buffer->pipe_p) {
#line 181
      tmp = "pipe";
    } else {
#line 181
      tmp = "file";
    }
    {
#line 181
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"A stream buffer (%s).\n",
            tmp);
    }
  }
  {
#line 183
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Len = %d, Lower case = %d, Line = %d\n",
          buffer->len, (int )buffer->lower_case, buffer->line);
  }
#line 185
  if (buffer->len) {
    {
#line 186
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Content = `%s\'\n",
            buffer->content);
    }
  }
#line 187
  return;
}
}
#line 192 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
void buffer_release(buffer_t *buffer ) 
{ 


  {
#line 196
  if (buffer->lower_case) {
    {
#line 197
    free((void *)buffer->value);
    }
  }
#line 200
  return;
}
}
#line 202 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
void buffer_set_lower_case(buffer_t *buffer , _Bool sensitive ) 
{ 


  {
#line 205
  buffer->lower_case = sensitive;
#line 206
  return;
}
}
#line 214 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
__inline static _Bool buffer_stream_get_line(buffer_t *buffer ) 
{ 
  register int c ;
  register int d ;
  struct obstack *__o ;
  char *tmp ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  char *tmp___1 ;

  {
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 219
    c = _IO_getc(buffer->stream);
    }
#line 219
    if (! (c != -1)) {
#line 219
      goto while_break;
    }
    {
#line 222
    if (c == 10) {
#line 222
      goto case_10;
    }
#line 254
    if (c == 13) {
#line 254
      goto case_13;
    }
#line 289
    goto stream_plain_char;
    case_10: /* CIL Label */ 
    {
#line 226
    if ((unsigned int )buffer->eol == 2U) {
#line 226
      goto case_2;
    }
#line 226
    if ((unsigned int )buffer->eol == 0U) {
#line 226
      goto case_2;
    }
#line 230
    if ((unsigned int )buffer->eol == 4U) {
#line 230
      goto case_4;
    }
#line 236
    if ((unsigned int )buffer->eol == 1U) {
#line 236
      goto case_1;
    }
#line 240
    if ((unsigned int )buffer->eol == 3U) {
#line 240
      goto case_3;
    }
#line 223
    goto switch_break___0;
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 228
    goto stream_plain_char;
    case_4: /* CIL Label */ 
    {
#line 232
    d = _IO_getc(buffer->stream);
    }
#line 232
    if (d != 13) {
      {
#line 233
      ungetc(d, buffer->stream);
      }
    }
#line 234
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 238
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 241
    d = _IO_getc(buffer->stream);
    }
#line 241
    if (d != 13) {
      {
#line 244
      ungetc(d, buffer->stream);
      }
#line 245
      goto stream_plain_char;
    }
#line 248
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 251
    __o = & buffer->obstack;
#line 251
    if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
      {
#line 251
      _obstack_newchunk(__o, 1);
      }
    }
#line 251
    tmp = __o->next_free;
#line 251
    (__o->next_free) ++;
#line 251
    *tmp = (char )c;
#line 252
    return ((_Bool)1);
    case_13: /* CIL Label */ 
    {
#line 258
    if ((unsigned int )buffer->eol == 3U) {
#line 258
      goto case_3___0;
    }
#line 258
    if ((unsigned int )buffer->eol == 1U) {
#line 258
      goto case_3___0;
    }
#line 262
    if ((unsigned int )buffer->eol == 0U) {
#line 262
      goto case_0___0;
    }
#line 267
    if ((unsigned int )buffer->eol == 4U) {
#line 267
      goto case_4___0;
    }
#line 274
    if ((unsigned int )buffer->eol == 2U) {
#line 274
      goto case_2___0;
    }
#line 255
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
#line 260
    goto stream_plain_char;
    case_0___0: /* CIL Label */ 
#line 264
    c = '\n';
#line 265
    goto switch_break___1;
    case_4___0: /* CIL Label */ 
    {
#line 269
    d = _IO_getc(buffer->stream);
    }
#line 269
    if (d != 10) {
      {
#line 270
      ungetc(d, buffer->stream);
      }
    }
#line 271
    c = '\n';
#line 272
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
    {
#line 275
    d = _IO_getc(buffer->stream);
    }
#line 275
    if (d != 10) {
      {
#line 278
      ungetc(d, buffer->stream);
      }
#line 279
      goto stream_plain_char;
    }
#line 282
    c = '\n';
#line 283
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 286
    __o___0 = & buffer->obstack;
#line 286
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 286
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 286
    tmp___0 = __o___0->next_free;
#line 286
    (__o___0->next_free) ++;
#line 286
    *tmp___0 = (char )c;
#line 287
    return ((_Bool)1);
    stream_plain_char: 
    switch_default: /* CIL Label */ 
#line 291
    __o___1 = & buffer->obstack;
#line 291
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 291
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 291
    tmp___1 = __o___1->next_free;
#line 291
    (__o___1->next_free) ++;
#line 291
    *tmp___1 = (char )c;
#line 292
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return ((_Bool)0);
}
}
#line 311 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
__inline static _Bool buffer_string_get_line(buffer_t *buffer ) 
{ 
  register int c ;
  register int d ;
  size_t tmp ;
  size_t tmp___0 ;
  struct obstack *__o ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  struct obstack *__o___0 ;
  char *tmp___4 ;
  struct obstack *__o___1 ;
  char *tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (buffer->bufoffset < buffer->bufsize) {
#line 316
      tmp___6 = buffer->bufoffset;
#line 316
      (buffer->bufoffset) ++;
#line 316
      c = (int )*(buffer->buf + tmp___6);
    } else {
#line 316
      (buffer->bufoffset) ++;
#line 316
      c = -1;
    }
#line 316
    if (! (c != -1)) {
#line 316
      goto while_break;
    }
    {
#line 319
    if (c == 10) {
#line 319
      goto case_10;
    }
#line 351
    if (c == 13) {
#line 351
      goto case_13;
    }
#line 386
    goto string_plain_char;
    case_10: /* CIL Label */ 
    {
#line 323
    if ((unsigned int )buffer->eol == 2U) {
#line 323
      goto case_2;
    }
#line 323
    if ((unsigned int )buffer->eol == 0U) {
#line 323
      goto case_2;
    }
#line 327
    if ((unsigned int )buffer->eol == 4U) {
#line 327
      goto case_4;
    }
#line 333
    if ((unsigned int )buffer->eol == 1U) {
#line 333
      goto case_1;
    }
#line 337
    if ((unsigned int )buffer->eol == 3U) {
#line 337
      goto case_3;
    }
#line 320
    goto switch_break___0;
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 325
    goto string_plain_char;
    case_4: /* CIL Label */ 
#line 329
    if (buffer->bufoffset < buffer->bufsize) {
#line 329
      tmp = buffer->bufoffset;
#line 329
      (buffer->bufoffset) ++;
#line 329
      d = (int )*(buffer->buf + tmp);
    } else {
#line 329
      (buffer->bufoffset) ++;
#line 329
      d = -1;
    }
#line 329
    if (d != 13) {
#line 330
      (buffer->bufoffset) --;
    }
#line 331
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 335
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 338
    if (buffer->bufoffset < buffer->bufsize) {
#line 338
      tmp___0 = buffer->bufoffset;
#line 338
      (buffer->bufoffset) ++;
#line 338
      d = (int )*(buffer->buf + tmp___0);
    } else {
#line 338
      (buffer->bufoffset) ++;
#line 338
      d = -1;
    }
#line 338
    if (d != 13) {
#line 341
      (buffer->bufoffset) --;
#line 342
      goto string_plain_char;
    }
#line 345
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 348
    __o = & buffer->obstack;
#line 348
    if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
      {
#line 348
      _obstack_newchunk(__o, 1);
      }
    }
#line 348
    tmp___1 = __o->next_free;
#line 348
    (__o->next_free) ++;
#line 348
    *tmp___1 = (char )c;
#line 349
    return ((_Bool)1);
    case_13: /* CIL Label */ 
    {
#line 355
    if ((unsigned int )buffer->eol == 3U) {
#line 355
      goto case_3___0;
    }
#line 355
    if ((unsigned int )buffer->eol == 1U) {
#line 355
      goto case_3___0;
    }
#line 359
    if ((unsigned int )buffer->eol == 0U) {
#line 359
      goto case_0___0;
    }
#line 364
    if ((unsigned int )buffer->eol == 4U) {
#line 364
      goto case_4___0;
    }
#line 371
    if ((unsigned int )buffer->eol == 2U) {
#line 371
      goto case_2___0;
    }
#line 352
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
#line 357
    goto string_plain_char;
    case_0___0: /* CIL Label */ 
#line 361
    c = '\n';
#line 362
    goto switch_break___1;
    case_4___0: /* CIL Label */ 
#line 366
    if (buffer->bufoffset < buffer->bufsize) {
#line 366
      tmp___2 = buffer->bufoffset;
#line 366
      (buffer->bufoffset) ++;
#line 366
      d = (int )*(buffer->buf + tmp___2);
    } else {
#line 366
      (buffer->bufoffset) ++;
#line 366
      d = -1;
    }
#line 366
    if (d != 10) {
#line 367
      (buffer->bufoffset) --;
    }
#line 368
    c = '\n';
#line 369
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
#line 372
    if (buffer->bufoffset < buffer->bufsize) {
#line 372
      tmp___3 = buffer->bufoffset;
#line 372
      (buffer->bufoffset) ++;
#line 372
      d = (int )*(buffer->buf + tmp___3);
    } else {
#line 372
      (buffer->bufoffset) ++;
#line 372
      d = -1;
    }
#line 372
    if (d != 10) {
#line 375
      (buffer->bufoffset) --;
#line 376
      goto string_plain_char;
    }
#line 379
    c = '\n';
#line 380
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 383
    __o___0 = & buffer->obstack;
#line 383
    if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
      {
#line 383
      _obstack_newchunk(__o___0, 1);
      }
    }
#line 383
    tmp___4 = __o___0->next_free;
#line 383
    (__o___0->next_free) ++;
#line 383
    *tmp___4 = (char )c;
#line 384
    return ((_Bool)1);
    string_plain_char: 
    switch_default: /* CIL Label */ 
#line 388
    __o___1 = & buffer->obstack;
#line 388
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
      {
#line 388
      _obstack_newchunk(__o___1, 1);
      }
    }
#line 388
    tmp___5 = __o___1->next_free;
#line 388
    (__o___1->next_free) ++;
#line 388
    *tmp___5 = (char )c;
#line 389
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return ((_Bool)0);
}
}
#line 402 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
void buffer_get(buffer_t *buffer ) 
{ 
  _Bool line_ended_p ;
  struct obstack *__o ;
  struct obstack *__o___0 ;
  char *tmp ;
  struct obstack *__o1 ;
  void *value ;
  size_t i ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 405
  line_ended_p = (_Bool)0;
#line 408
  if (buffer->buf) {
#line 408
    if (buffer->bufoffset < buffer->bufsize) {
      {
#line 409
      line_ended_p = buffer_string_get_line(buffer);
      }
    }
  }
#line 413
  if (buffer->stream) {
#line 413
    if (! line_ended_p) {
      {
#line 414
      line_ended_p = buffer_stream_get_line(buffer);
      }
    }
  }
#line 421
  __o = & buffer->obstack;
#line 421
  buffer->len = (unsigned int )(__o->next_free - __o->object_base);
#line 422
  __o___0 = & buffer->obstack;
#line 422
  if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
    {
#line 422
    _obstack_newchunk(__o___0, 1);
    }
  }
#line 422
  tmp = __o___0->next_free;
#line 422
  (__o___0->next_free) ++;
#line 422
  *tmp = (char )'\000';
#line 423
  __o1 = & buffer->obstack;
#line 423
  value = (void *)__o1->object_base;
#line 423
  if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 423
    __o1->maybe_empty_object = 1U;
  }
#line 423
  __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 423
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 423
    __o1->next_free = __o1->chunk_limit;
  }
#line 423
  __o1->object_base = __o1->next_free;
#line 423
  buffer->content = (unsigned char *)value;
#line 426
  (buffer->line) ++;
#line 430
  if (buffer->len >= 2U) {
#line 430
    if ((int )*(buffer->content + (buffer->len - 2U)) == 12) {
#line 433
      (buffer->len) --;
#line 433
      *(buffer->content + buffer->len) = (unsigned char )'\000';
    }
  }
#line 436
  if (buffer->lower_case) {
#line 439
    if (buffer->allocsize <= buffer->len) {
#line 440
      buffer->allocsize = buffer->len + 1U;
    }
    {
#line 442
    tmp___0 = xrealloc((void *)buffer->value, (size_t )(sizeof(unsigned char ) * (unsigned long )buffer->allocsize));
#line 442
    buffer->value = (unsigned char *)tmp___0;
#line 445
    i = (size_t )0;
    }
    {
#line 445
    while (1) {
      while_continue: /* CIL Label */ ;
#line 445
      if (! (i <= buffer->len)) {
#line 445
        goto while_break;
      }
      {
#line 446
      tmp___1 = tolower((int )*(buffer->content + i));
#line 446
      *(buffer->value + i) = (unsigned char )tmp___1;
#line 445
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 450
    buffer->value = buffer->content;
  }
#line 453
  buffer->curr = (size_t )0;
#line 454
  return;
}
}
#line 462 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
void buffer_sample_get(buffer_t *buffer , char const   *filename ) 
{ 
  FILE *out ;
  FILE *tmp ;
  size_t cur ;
  int c ;
  char *sample_buffer ;
  void *tmp___0 ;

  {
  {
#line 467
  tmp = xwfopen(filename);
#line 467
  out = tmp;
#line 468
  cur = (size_t )0;
#line 470
  tmp___0 = xmalloc((size_t )(sizeof(char ) * 512UL));
#line 470
  sample_buffer = (char *)tmp___0;
  }
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (cur < 512U) {
      {
#line 472
      c = _IO_getc(buffer->stream);
      }
#line 472
      if (! (c != -1)) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
    {
#line 474
    *(sample_buffer + cur) = (char )c;
#line 475
    _IO_putc(c, out);
#line 472
    cur ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 479
  buffer->buf = (unsigned char const   *)sample_buffer;
#line 480
  buffer->bufsize = cur;
#line 482
  fclose(out);
  }
#line 483
  return;
}
}
#line 494 "/home/ysko/Works/test-src/a2ps-4.14/src/buffer.c"
void buffer_save(buffer_t *buffer , char const   *filename ) 
{ 
  FILE *out ;
  FILE *tmp ;
  size_t cur ;

  {
  {
#line 497
  tmp = xwfopen(filename);
#line 497
  out = tmp;
  }
#line 499
  if (buffer->buf) {
#line 502
    cur = (size_t )0;
    {
#line 502
    while (1) {
      while_continue: /* CIL Label */ ;
#line 502
      if (! (cur < buffer->bufsize)) {
#line 502
        goto while_break;
      }
      {
#line 503
      _IO_putc((int )*(buffer->buf + cur), out);
#line 502
      cur ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 506
  if (buffer->stream) {
    {
#line 507
    streams_copy(buffer->stream, out);
    }
  }
  {
#line 509
  fclose(out);
  }
#line 510
  return;
}
}
#line 172 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
char *re_syntax_table ;
#line 167 "./regex.h"
reg_syntax_t re_syntax_options  ;
#line 444
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) ;
#line 449
char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
#line 457
int re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 465
int re_search(struct re_pattern_buffer *bufp , char const   *string , int size , int startpos ,
              int range , struct re_registers *regs ) ;
#line 472
int re_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                char const   *string2 , int size2 , int startpos , int range , struct re_registers *regs ,
                int stop ) ;
#line 480
int re_match(struct re_pattern_buffer *bufp , char const   *string , int size , int pos ,
             struct re_registers *regs ) ;
#line 486
int re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
               char const   *string2 , int size2 , int pos , struct re_registers *regs ,
               int stop ) ;
#line 504
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                      unsigned int num_regs , regoff_t *starts , regoff_t *ends ) ;
#line 517
int regcomp(regex_t *preg , char const   *pattern , int cflags ) ;
#line 520
int regexec(regex_t const   *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
            int eflags ) ;
#line 524
size_t regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) ;
#line 527
void regfree(regex_t *preg ) ;
#line 83 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 381 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static int re_match_2_internal(struct re_pattern_buffer *bufp , char const   *string1 ,
                               int size1 , char const   *string2 , int size2 , int pos ,
                               struct re_registers *regs , int stop ) ;
#line 992 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) 
{ 
  reg_syntax_t ret ;

  {
#line 996
  ret = re_syntax_options;
#line 998
  re_syntax_options = syntax;
#line 1005
  return (ret);
}
}
#line 1016 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static char const   *re_error_msgid[17]  = 
#line 1016
  {      "Success",      "No match",      "Invalid regular expression",      "Invalid collation character", 
        "Invalid character class name",      "Trailing backslash",      "Invalid back reference",      "Unmatched [ or [^", 
        "Unmatched ( or \\(",      "Unmatched \\{",      "Invalid content of \\{\\}",      "Invalid range end", 
        "Memory exhausted",      "Invalid preceding regular expression",      "Premature end of regular expression",      "Regular expression too big", 
        "Unmatched ) or \\)"};
#line 1122 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
int re_max_failures  =    20000;
#line 1497 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static char reg_unset_dummy  ;
#line 1503
static reg_errcode_t regex_compile(char const   *pattern , size_t size , reg_syntax_t syntax ,
                                   struct re_pattern_buffer *bufp ) ;
#line 1506
static void store_op1(re_opcode_t op , unsigned char *loc , int arg ) ;
#line 1507
static void store_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ) ;
#line 1509
static void insert_op1(re_opcode_t op , unsigned char *loc , int arg , unsigned char *end ) ;
#line 1511
static void insert_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ,
                       unsigned char *end ) ;
#line 1513
static boolean at_begline_loc_p(char const   *pattern , char const   *p , reg_syntax_t syntax ) ;
#line 1515
static boolean at_endline_loc_p(char const   *p , char const   *pend , reg_syntax_t syntax ) ;
#line 1517
static reg_errcode_t compile_range(char const   **p_ptr , char const   *pend , char *translate ,
                                   reg_syntax_t syntax , unsigned char *b ) ;
#line 1803
static boolean group_in_compile_stack(compile_stack_type compile_stack , regnum_t regnum ) ;
#line 1829 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static reg_errcode_t regex_compile(char const   *pattern , size_t size , reg_syntax_t syntax ,
                                   struct re_pattern_buffer *bufp ) 
{ 
  register unsigned char c ;
  register unsigned char c1 ;
  char const   *p1 ;
  register unsigned char *b ;
  compile_stack_type compile_stack ;
  char const   *p ;
  char const   *pend ;
  char *translate ;
  unsigned char *pending_exact ;
  unsigned char *laststart ;
  unsigned char *begalt ;
  char const   *beg_interval ;
  unsigned char *fixup_alt_jump ;
  regnum_t regnum ;
  void *tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  unsigned char *old_buffer ;
  void *tmp___4 ;
  unsigned char *tmp___5 ;
  boolean tmp___6 ;
  unsigned char *old_buffer___0 ;
  void *tmp___7 ;
  unsigned char *tmp___8 ;
  boolean tmp___9 ;
  boolean keep_string_p ;
  char zero_times_ok ;
  char many_times_ok ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  unsigned char *old_buffer___1 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char *old_buffer___2 ;
  void *tmp___17 ;
  int tmp___18 ;
  unsigned char *old_buffer___3 ;
  void *tmp___19 ;
  unsigned char *old_buffer___4 ;
  void *tmp___20 ;
  unsigned char *tmp___21 ;
  boolean had_char_class ;
  unsigned char *old_buffer___5 ;
  void *tmp___22 ;
  unsigned char *old_buffer___6 ;
  void *tmp___23 ;
  unsigned char *tmp___24 ;
  int tmp___25 ;
  unsigned char *old_buffer___7 ;
  void *tmp___26 ;
  unsigned char *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  reg_errcode_t ret ;
  reg_errcode_t tmp___30 ;
  reg_errcode_t ret___0 ;
  char const   *tmp___31 ;
  char str[7] ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  unsigned char tmp___34 ;
  int ch ;
  boolean is_alnum ;
  int tmp___35 ;
  boolean is_alpha ;
  int tmp___36 ;
  boolean is_blank ;
  int tmp___37 ;
  boolean is_cntrl ;
  int tmp___38 ;
  boolean is_digit ;
  int tmp___39 ;
  boolean is_graph ;
  int tmp___40 ;
  boolean is_lower ;
  int tmp___41 ;
  boolean is_print ;
  int tmp___42 ;
  boolean is_punct ;
  int tmp___43 ;
  boolean is_space ;
  int tmp___44 ;
  boolean is_upper ;
  int tmp___45 ;
  boolean is_xdigit ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  char const   *tmp___59 ;
  unsigned short const   **tmp___60 ;
  unsigned short const   **tmp___61 ;
  unsigned short const   **tmp___62 ;
  unsigned short const   **tmp___63 ;
  unsigned short const   **tmp___64 ;
  unsigned short const   **tmp___65 ;
  unsigned short const   **tmp___66 ;
  unsigned short const   **tmp___67 ;
  unsigned short const   **tmp___68 ;
  unsigned short const   **tmp___69 ;
  unsigned short const   **tmp___70 ;
  unsigned short const   **tmp___71 ;
  unsigned short const   **tmp___72 ;
  unsigned short const   **tmp___73 ;
  unsigned char tmp___74 ;
  char const   *tmp___75 ;
  void *tmp___76 ;
  unsigned char *old_buffer___8 ;
  void *tmp___77 ;
  unsigned char *tmp___78 ;
  unsigned char *tmp___79 ;
  unsigned char *tmp___80 ;
  unsigned char *old_buffer___9 ;
  void *tmp___81 ;
  unsigned char *tmp___82 ;
  regnum_t this_group_regnum ;
  unsigned char *inner_group_loc ;
  unsigned char *old_buffer___10 ;
  void *tmp___83 ;
  unsigned char *tmp___84 ;
  unsigned char *tmp___85 ;
  unsigned char *tmp___86 ;
  unsigned char *old_buffer___11 ;
  void *tmp___87 ;
  unsigned char *old_buffer___12 ;
  void *tmp___88 ;
  int lower_bound ;
  int upper_bound ;
  char const   *tmp___89 ;
  char const   *tmp___90 ;
  unsigned short const   **tmp___91 ;
  char const   *tmp___92 ;
  char const   *tmp___93 ;
  unsigned short const   **tmp___94 ;
  char const   *tmp___95 ;
  unsigned char *old_buffer___13 ;
  void *tmp___96 ;
  unsigned int nbytes ;
  unsigned char *old_buffer___14 ;
  void *tmp___97 ;
  char const   *tmp___98 ;
  unsigned char *old_buffer___15 ;
  void *tmp___99 ;
  unsigned char *tmp___100 ;
  unsigned char *old_buffer___16 ;
  void *tmp___101 ;
  unsigned char *tmp___102 ;
  unsigned char *old_buffer___17 ;
  void *tmp___103 ;
  unsigned char *tmp___104 ;
  unsigned char *old_buffer___18 ;
  void *tmp___105 ;
  unsigned char *tmp___106 ;
  unsigned char *old_buffer___19 ;
  void *tmp___107 ;
  unsigned char *tmp___108 ;
  unsigned char *old_buffer___20 ;
  void *tmp___109 ;
  unsigned char *tmp___110 ;
  unsigned char *old_buffer___21 ;
  void *tmp___111 ;
  unsigned char *tmp___112 ;
  unsigned char *old_buffer___22 ;
  void *tmp___113 ;
  unsigned char *tmp___114 ;
  boolean tmp___115 ;
  unsigned char *old_buffer___23 ;
  void *tmp___116 ;
  unsigned char *tmp___117 ;
  unsigned char *tmp___118 ;
  unsigned char *old_buffer___24 ;
  void *tmp___119 ;
  unsigned char *tmp___120 ;
  unsigned char *tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  unsigned char *old_buffer___25 ;
  void *tmp___127 ;
  unsigned char *tmp___128 ;
  unsigned char *old_buffer___26 ;
  void *tmp___129 ;
  unsigned char *tmp___130 ;
  void *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;

  {
  {
#line 1851
  p = pattern;
#line 1852
  pend = pattern + size;
#line 1855
  translate = bufp->translate;
#line 1861
  pending_exact = (unsigned char *)0;
#line 1866
  laststart = (unsigned char *)0;
#line 1878
  fixup_alt_jump = (unsigned char *)0;
#line 1883
  regnum = (regnum_t )0;
#line 1898
  tmp = malloc((size_t )(32UL * sizeof(compile_stack_elt_t )));
#line 1898
  compile_stack.stack = (compile_stack_elt_t *)tmp;
  }
#line 1899
  if ((unsigned long )compile_stack.stack == (unsigned long )((void *)0)) {
#line 1900
    return ((reg_errcode_t )12);
  }
#line 1902
  compile_stack.size = 32U;
#line 1903
  compile_stack.avail = 0U;
#line 1906
  bufp->syntax = syntax;
#line 1907
  bufp->fastmap_accurate = 0U;
#line 1908
  tmp___0 = 0U;
#line 1908
  bufp->not_eol = tmp___0;
#line 1908
  bufp->not_bol = tmp___0;
#line 1913
  bufp->used = 0UL;
#line 1916
  bufp->re_nsub = (size_t )0;
#line 1923
  if (bufp->allocated == 0UL) {
#line 1925
    if (bufp->buffer) {
      {
#line 1929
      tmp___1 = realloc((void *)bufp->buffer, (size_t )(32UL * sizeof(unsigned char )));
#line 1929
      bufp->buffer = (unsigned char *)tmp___1;
      }
    } else {
      {
#line 1933
      tmp___2 = malloc((size_t )(32UL * sizeof(unsigned char )));
#line 1933
      bufp->buffer = (unsigned char *)tmp___2;
      }
    }
#line 1935
    if (! bufp->buffer) {
      {
#line 1935
      free((void *)compile_stack.stack);
      }
#line 1935
      return ((reg_errcode_t )12);
    }
#line 1937
    bufp->allocated = 32UL;
  }
#line 1940
  b = bufp->buffer;
#line 1940
  begalt = b;
  {
#line 1943
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1943
    if (! ((unsigned long )p != (unsigned long )pend)) {
#line 1943
      goto while_break;
    }
    {
#line 1945
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1945
      if ((unsigned long )p == (unsigned long )pend) {
#line 1945
        return ((reg_errcode_t )14);
      }
#line 1945
      tmp___3 = p;
#line 1945
      p ++;
#line 1945
      c = (unsigned char )*tmp___3;
#line 1945
      if (translate) {
#line 1945
        c = (unsigned char )*(translate + c);
      }
#line 1945
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1949
    if ((int )c == 94) {
#line 1949
      goto case_94;
    }
#line 1964
    if ((int )c == 36) {
#line 1964
      goto case_36;
    }
#line 1980
    if ((int )c == 63) {
#line 1980
      goto case_63;
    }
#line 1980
    if ((int )c == 43) {
#line 1980
      goto case_63;
    }
#line 1985
    if ((int )c == 42) {
#line 1985
      goto handle_plus;
    }
#line 2112
    if ((int )c == 46) {
#line 2112
      goto case_46;
    }
#line 2118
    if ((int )c == 91) {
#line 2118
      goto case_91;
    }
#line 2342
    if ((int )c == 40) {
#line 2342
      goto case_40;
    }
#line 2349
    if ((int )c == 41) {
#line 2349
      goto case_41;
    }
#line 2356
    if ((int )c == 10) {
#line 2356
      goto case_10;
    }
#line 2363
    if ((int )c == 124) {
#line 2363
      goto case_124;
    }
#line 2370
    if ((int )c == 123) {
#line 2370
      goto case_123;
    }
#line 2377
    if ((int )c == 92) {
#line 2377
      goto case_92;
    }
#line 2830
    goto normal_char;
    case_94: /* CIL Label */ 
#line 1951
    if ((unsigned long )p == (unsigned long )(pattern + 1)) {
#line 1951
      goto _L;
    } else
#line 1951
    if (syntax & (((1UL << 1) << 1) << 1)) {
#line 1951
      goto _L;
    } else {
      {
#line 1951
      tmp___6 = at_begline_loc_p(pattern, p, syntax);
      }
#line 1951
      if (tmp___6) {
        _L: /* CIL Label */ 
        {
#line 1957
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1957
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1957
            if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 1957
              goto while_break___2;
            }
            {
#line 1957
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1957
              old_buffer = bufp->buffer;
#line 1957
              if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 1957
                return ((reg_errcode_t )15);
              }
#line 1957
              bufp->allocated <<= 1;
#line 1957
              if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 1957
                bufp->allocated = (unsigned long )(1L << 16);
              }
              {
#line 1957
              tmp___4 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 1957
              bufp->buffer = (unsigned char *)tmp___4;
              }
#line 1957
              if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 1957
                return ((reg_errcode_t )12);
              }
#line 1957
              if ((unsigned long )old_buffer != (unsigned long )bufp->buffer) {
#line 1957
                b = bufp->buffer + (b - old_buffer);
#line 1957
                begalt = bufp->buffer + (begalt - old_buffer);
#line 1957
                if (fixup_alt_jump) {
#line 1957
                  fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer);
                }
#line 1957
                if (laststart) {
#line 1957
                  laststart = bufp->buffer + (laststart - old_buffer);
                }
#line 1957
                if (pending_exact) {
#line 1957
                  pending_exact = bufp->buffer + (pending_exact - old_buffer);
                }
              }
#line 1957
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1957
          tmp___5 = b;
#line 1957
          b ++;
#line 1957
          *tmp___5 = (unsigned char)9;
#line 1957
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 1959
        goto normal_char;
      }
    }
#line 1961
    goto switch_break;
    case_36: /* CIL Label */ 
#line 1966
    if ((unsigned long )p == (unsigned long )pend) {
#line 1966
      goto _L___0;
    } else
#line 1966
    if (syntax & (((1UL << 1) << 1) << 1)) {
#line 1966
      goto _L___0;
    } else {
      {
#line 1966
      tmp___9 = at_endline_loc_p(p, pend, syntax);
      }
#line 1966
      if (tmp___9) {
        _L___0: /* CIL Label */ 
        {
#line 1972
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 1972
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1972
            if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 1972
              goto while_break___5;
            }
            {
#line 1972
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 1972
              old_buffer___0 = bufp->buffer;
#line 1972
              if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 1972
                return ((reg_errcode_t )15);
              }
#line 1972
              bufp->allocated <<= 1;
#line 1972
              if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 1972
                bufp->allocated = (unsigned long )(1L << 16);
              }
              {
#line 1972
              tmp___7 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 1972
              bufp->buffer = (unsigned char *)tmp___7;
              }
#line 1972
              if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 1972
                return ((reg_errcode_t )12);
              }
#line 1972
              if ((unsigned long )old_buffer___0 != (unsigned long )bufp->buffer) {
#line 1972
                b = bufp->buffer + (b - old_buffer___0);
#line 1972
                begalt = bufp->buffer + (begalt - old_buffer___0);
#line 1972
                if (fixup_alt_jump) {
#line 1972
                  fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___0);
                }
#line 1972
                if (laststart) {
#line 1972
                  laststart = bufp->buffer + (laststart - old_buffer___0);
                }
#line 1972
                if (pending_exact) {
#line 1972
                  pending_exact = bufp->buffer + (pending_exact - old_buffer___0);
                }
              }
#line 1972
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1972
          tmp___8 = b;
#line 1972
          b ++;
#line 1972
          *tmp___8 = (unsigned char)10;
#line 1972
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
#line 1974
        goto normal_char;
      }
    }
#line 1976
    goto switch_break;
    case_63: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 1981
    if (syntax & (1UL << 1)) {
#line 1983
      goto normal_char;
    } else
#line 1981
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1983
      goto normal_char;
    }
    handle_plus: 
    case_42: /* CIL Label */ 
#line 1987
    if (! laststart) {
#line 1989
      if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
        {
#line 1990
        free((void *)compile_stack.stack);
        }
#line 1990
        return ((reg_errcode_t )13);
      } else
#line 1991
      if (! (syntax & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1992
        goto normal_char;
      }
    }
#line 1997
    keep_string_p = (boolean )0;
#line 2000
    zero_times_ok = (char)0;
#line 2000
    many_times_ok = (char)0;
    {
#line 2007
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2009
      zero_times_ok = (char )((int )zero_times_ok | ((int )c != 43));
#line 2010
      many_times_ok = (char )((int )many_times_ok | ((int )c != 63));
#line 2012
      if ((unsigned long )p == (unsigned long )pend) {
#line 2013
        goto while_break___7;
      }
      {
#line 2015
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2015
        if ((unsigned long )p == (unsigned long )pend) {
#line 2015
          return ((reg_errcode_t )14);
        }
#line 2015
        tmp___10 = p;
#line 2015
        p ++;
#line 2015
        c = (unsigned char )*tmp___10;
#line 2015
        if (translate) {
#line 2015
          c = (unsigned char )*(translate + c);
        }
#line 2015
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2017
      if (! ((int )c == 42)) {
#line 2017
        if (! (syntax & (1UL << 1))) {
#line 2017
          if (! ((int )c == 43)) {
#line 2017
            if (! ((int )c == 63)) {
#line 2017
              goto _L___1;
            }
          }
        } else
        _L___1: /* CIL Label */ 
#line 2021
        if (syntax & (1UL << 1)) {
#line 2021
          if ((int )c == 92) {
#line 2023
            if ((unsigned long )p == (unsigned long )pend) {
              {
#line 2023
              free((void *)compile_stack.stack);
              }
#line 2023
              return ((reg_errcode_t )5);
            }
            {
#line 2025
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 2025
              if ((unsigned long )p == (unsigned long )pend) {
#line 2025
                return ((reg_errcode_t )14);
              }
#line 2025
              tmp___11 = p;
#line 2025
              p ++;
#line 2025
              c1 = (unsigned char )*tmp___11;
#line 2025
              if (translate) {
#line 2025
                c1 = (unsigned char )*(translate + c1);
              }
#line 2025
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
#line 2026
            if (! ((int )c1 == 43)) {
#line 2026
              if (! ((int )c1 == 63)) {
#line 2028
                p --;
#line 2029
                p --;
#line 2030
                goto while_break___7;
              }
            }
#line 2033
            c = c1;
          } else {
#line 2037
            p --;
#line 2038
            goto while_break___7;
          }
        } else {
#line 2037
          p --;
#line 2038
          goto while_break___7;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2046
    if (! laststart) {
#line 2047
      goto switch_break;
    }
#line 2051
    if (many_times_ok) {
      {
#line 2065
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 2065
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2065
          goto while_break___10;
        }
        {
#line 2065
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 2065
          old_buffer___1 = bufp->buffer;
#line 2065
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2065
            return ((reg_errcode_t )15);
          }
#line 2065
          bufp->allocated <<= 1;
#line 2065
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2065
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2065
          tmp___12 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2065
          bufp->buffer = (unsigned char *)tmp___12;
          }
#line 2065
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2065
            return ((reg_errcode_t )12);
          }
#line 2065
          if ((unsigned long )old_buffer___1 != (unsigned long )bufp->buffer) {
#line 2065
            b = bufp->buffer + (b - old_buffer___1);
#line 2065
            begalt = bufp->buffer + (begalt - old_buffer___1);
#line 2065
            if (fixup_alt_jump) {
#line 2065
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___1);
            }
#line 2065
            if (laststart) {
#line 2065
              laststart = bufp->buffer + (laststart - old_buffer___1);
            }
#line 2065
            if (pending_exact) {
#line 2065
              pending_exact = bufp->buffer + (pending_exact - old_buffer___1);
            }
          }
#line 2065
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 2072
      if (translate) {
#line 2072
        tmp___13 = (int )*(translate + (unsigned char )*(p - 2));
      } else {
#line 2072
        tmp___13 = (int )*(p - 2);
      }
#line 2072
      if (translate) {
#line 2072
        tmp___14 = (int )*(translate + (unsigned char )'.');
      } else {
#line 2072
        tmp___14 = '.';
      }
#line 2072
      if (tmp___13 == tmp___14) {
#line 2072
        if (zero_times_ok) {
#line 2072
          if ((unsigned long )p < (unsigned long )pend) {
#line 2072
            if (translate) {
#line 2072
              tmp___15 = (int )*(translate + (unsigned char )*p);
            } else {
#line 2072
              tmp___15 = (int )*p;
            }
#line 2072
            if (translate) {
#line 2072
              tmp___16 = (int )*(translate + (unsigned char )'\n');
            } else {
#line 2072
              tmp___16 = '\n';
            }
#line 2072
            if (tmp___15 == tmp___16) {
#line 2072
              if (! (syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
                {
#line 2077
                store_op1((re_opcode_t )13, b, (int )((laststart - b) - 3L));
#line 2078
                keep_string_p = (boolean )1;
                }
              } else {
                {
#line 2082
                store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
                }
              }
            } else {
              {
#line 2082
              store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
              }
            }
          } else {
            {
#line 2082
            store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
            }
          }
        } else {
          {
#line 2082
          store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
          }
        }
      } else {
        {
#line 2082
        store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
        }
      }
#line 2085
      b += 3;
    }
    {
#line 2090
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 2090
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2090
        goto while_break___12;
      }
      {
#line 2090
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 2090
        old_buffer___2 = bufp->buffer;
#line 2090
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2090
          return ((reg_errcode_t )15);
        }
#line 2090
        bufp->allocated <<= 1;
#line 2090
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2090
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 2090
        tmp___17 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2090
        bufp->buffer = (unsigned char *)tmp___17;
        }
#line 2090
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2090
          return ((reg_errcode_t )12);
        }
#line 2090
        if ((unsigned long )old_buffer___2 != (unsigned long )bufp->buffer) {
#line 2090
          b = bufp->buffer + (b - old_buffer___2);
#line 2090
          begalt = bufp->buffer + (begalt - old_buffer___2);
#line 2090
          if (fixup_alt_jump) {
#line 2090
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___2);
          }
#line 2090
          if (laststart) {
#line 2090
            laststart = bufp->buffer + (laststart - old_buffer___2);
          }
#line 2090
          if (pending_exact) {
#line 2090
            pending_exact = bufp->buffer + (pending_exact - old_buffer___2);
          }
        }
#line 2090
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 2091
    if (keep_string_p) {
#line 2091
      tmp___18 = 16;
    } else {
#line 2091
      tmp___18 = 15;
    }
    {
#line 2091
    insert_op1((re_opcode_t )tmp___18, laststart, (int )(((b + 3) - laststart) - 3L),
               b);
#line 2094
    pending_exact = (unsigned char *)0;
#line 2095
    b += 3;
    }
#line 2097
    if (! zero_times_ok) {
      {
#line 2104
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 2104
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2104
          goto while_break___14;
        }
        {
#line 2104
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 2104
          old_buffer___3 = bufp->buffer;
#line 2104
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2104
            return ((reg_errcode_t )15);
          }
#line 2104
          bufp->allocated <<= 1;
#line 2104
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2104
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2104
          tmp___19 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2104
          bufp->buffer = (unsigned char *)tmp___19;
          }
#line 2104
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2104
            return ((reg_errcode_t )12);
          }
#line 2104
          if ((unsigned long )old_buffer___3 != (unsigned long )bufp->buffer) {
#line 2104
            b = bufp->buffer + (b - old_buffer___3);
#line 2104
            begalt = bufp->buffer + (begalt - old_buffer___3);
#line 2104
            if (fixup_alt_jump) {
#line 2104
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___3);
            }
#line 2104
            if (laststart) {
#line 2104
              laststart = bufp->buffer + (laststart - old_buffer___3);
            }
#line 2104
            if (pending_exact) {
#line 2104
              pending_exact = bufp->buffer + (pending_exact - old_buffer___3);
            }
          }
#line 2104
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 2105
      insert_op1((re_opcode_t )19, laststart, (int )(((laststart + 6) - laststart) - 3L),
                 b);
#line 2106
      b += 3;
      }
    }
#line 2109
    goto switch_break;
    case_46: /* CIL Label */ 
#line 2113
    laststart = b;
    {
#line 2114
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 2114
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 2114
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2114
          goto while_break___17;
        }
        {
#line 2114
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 2114
          old_buffer___4 = bufp->buffer;
#line 2114
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2114
            return ((reg_errcode_t )15);
          }
#line 2114
          bufp->allocated <<= 1;
#line 2114
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2114
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2114
          tmp___20 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2114
          bufp->buffer = (unsigned char *)tmp___20;
          }
#line 2114
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2114
            return ((reg_errcode_t )12);
          }
#line 2114
          if ((unsigned long )old_buffer___4 != (unsigned long )bufp->buffer) {
#line 2114
            b = bufp->buffer + (b - old_buffer___4);
#line 2114
            begalt = bufp->buffer + (begalt - old_buffer___4);
#line 2114
            if (fixup_alt_jump) {
#line 2114
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___4);
            }
#line 2114
            if (laststart) {
#line 2114
              laststart = bufp->buffer + (laststart - old_buffer___4);
            }
#line 2114
            if (pending_exact) {
#line 2114
              pending_exact = bufp->buffer + (pending_exact - old_buffer___4);
            }
          }
#line 2114
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
#line 2114
      tmp___21 = b;
#line 2114
      b ++;
#line 2114
      *tmp___21 = (unsigned char)3;
#line 2114
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 2115
    goto switch_break;
    case_91: /* CIL Label */ 
#line 2120
    had_char_class = (boolean )0;
#line 2122
    if ((unsigned long )p == (unsigned long )pend) {
      {
#line 2122
      free((void *)compile_stack.stack);
      }
#line 2122
      return ((reg_errcode_t )7);
    }
    {
#line 2126
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 2126
      if (! ((unsigned long )((b - bufp->buffer) + 34L) > bufp->allocated)) {
#line 2126
        goto while_break___19;
      }
      {
#line 2126
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 2126
        old_buffer___5 = bufp->buffer;
#line 2126
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2126
          return ((reg_errcode_t )15);
        }
#line 2126
        bufp->allocated <<= 1;
#line 2126
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2126
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 2126
        tmp___22 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2126
        bufp->buffer = (unsigned char *)tmp___22;
        }
#line 2126
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2126
          return ((reg_errcode_t )12);
        }
#line 2126
        if ((unsigned long )old_buffer___5 != (unsigned long )bufp->buffer) {
#line 2126
          b = bufp->buffer + (b - old_buffer___5);
#line 2126
          begalt = bufp->buffer + (begalt - old_buffer___5);
#line 2126
          if (fixup_alt_jump) {
#line 2126
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___5);
          }
#line 2126
          if (laststart) {
#line 2126
            laststart = bufp->buffer + (laststart - old_buffer___5);
          }
#line 2126
          if (pending_exact) {
#line 2126
            pending_exact = bufp->buffer + (pending_exact - old_buffer___5);
          }
        }
#line 2126
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
#line 2128
    laststart = b;
    {
#line 2132
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 2132
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 2132
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2132
          goto while_break___22;
        }
        {
#line 2132
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 2132
          old_buffer___6 = bufp->buffer;
#line 2132
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2132
            return ((reg_errcode_t )15);
          }
#line 2132
          bufp->allocated <<= 1;
#line 2132
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2132
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2132
          tmp___23 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2132
          bufp->buffer = (unsigned char *)tmp___23;
          }
#line 2132
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2132
            return ((reg_errcode_t )12);
          }
#line 2132
          if ((unsigned long )old_buffer___6 != (unsigned long )bufp->buffer) {
#line 2132
            b = bufp->buffer + (b - old_buffer___6);
#line 2132
            begalt = bufp->buffer + (begalt - old_buffer___6);
#line 2132
            if (fixup_alt_jump) {
#line 2132
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___6);
            }
#line 2132
            if (laststart) {
#line 2132
              laststart = bufp->buffer + (laststart - old_buffer___6);
            }
#line 2132
            if (pending_exact) {
#line 2132
              pending_exact = bufp->buffer + (pending_exact - old_buffer___6);
            }
          }
#line 2132
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
#line 2132
      tmp___24 = b;
#line 2132
      b ++;
#line 2132
      if ((int const   )*p == 94) {
#line 2132
        tmp___25 = 5;
      } else {
#line 2132
        tmp___25 = 4;
      }
#line 2132
      *tmp___24 = (unsigned char )tmp___25;
#line 2132
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 2133
    if ((int const   )*p == 94) {
#line 2134
      p ++;
    }
#line 2137
    p1 = p;
    {
#line 2140
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
#line 2140
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 2140
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2140
          goto while_break___25;
        }
        {
#line 2140
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 2140
          old_buffer___7 = bufp->buffer;
#line 2140
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2140
            return ((reg_errcode_t )15);
          }
#line 2140
          bufp->allocated <<= 1;
#line 2140
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2140
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2140
          tmp___26 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2140
          bufp->buffer = (unsigned char *)tmp___26;
          }
#line 2140
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2140
            return ((reg_errcode_t )12);
          }
#line 2140
          if ((unsigned long )old_buffer___7 != (unsigned long )bufp->buffer) {
#line 2140
            b = bufp->buffer + (b - old_buffer___7);
#line 2140
            begalt = bufp->buffer + (begalt - old_buffer___7);
#line 2140
            if (fixup_alt_jump) {
#line 2140
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___7);
            }
#line 2140
            if (laststart) {
#line 2140
              laststart = bufp->buffer + (laststart - old_buffer___7);
            }
#line 2140
            if (pending_exact) {
#line 2140
              pending_exact = bufp->buffer + (pending_exact - old_buffer___7);
            }
          }
#line 2140
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
      }
      while_break___25: /* CIL Label */ ;
      }
#line 2140
      tmp___27 = b;
#line 2140
      b ++;
#line 2140
      *tmp___27 = (unsigned char )((1 << 8) / 8);
#line 2140
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 2143
    memset((void *)b, '\000', (size_t )((1 << 8) / 8));
    }
#line 2146
    if ((unsigned int )((re_opcode_t )*(b + -2)) == 5U) {
#line 2146
      if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2148
        *(b + 1) = (unsigned char )((int )*(b + 1) | (1 << 2));
      }
    }
    {
#line 2151
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 2153
      if ((unsigned long )p == (unsigned long )pend) {
        {
#line 2153
        free((void *)compile_stack.stack);
        }
#line 2153
        return ((reg_errcode_t )7);
      }
      {
#line 2155
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 2155
        if ((unsigned long )p == (unsigned long )pend) {
#line 2155
          return ((reg_errcode_t )14);
        }
#line 2155
        tmp___28 = p;
#line 2155
        p ++;
#line 2155
        c = (unsigned char )*tmp___28;
#line 2155
        if (translate) {
#line 2155
          c = (unsigned char )*(translate + c);
        }
#line 2155
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 2158
      if (syntax & 1UL) {
#line 2158
        if ((int )c == 92) {
#line 2160
          if ((unsigned long )p == (unsigned long )pend) {
            {
#line 2160
            free((void *)compile_stack.stack);
            }
#line 2160
            return ((reg_errcode_t )5);
          }
          {
#line 2162
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 2162
            if ((unsigned long )p == (unsigned long )pend) {
#line 2162
              return ((reg_errcode_t )14);
            }
#line 2162
            tmp___29 = p;
#line 2162
            p ++;
#line 2162
            c1 = (unsigned char )*tmp___29;
#line 2162
            if (translate) {
#line 2162
              c1 = (unsigned char )*(translate + c1);
            }
#line 2162
            goto while_break___29;
          }
          while_break___29: /* CIL Label */ ;
          }
#line 2163
          *(b + (int )c1 / 8) = (unsigned char )((int )*(b + (int )c1 / 8) | (1 << (int )c1 % 8));
#line 2164
          goto __Cont;
        }
      }
#line 2170
      if ((int )c == 93) {
#line 2170
        if ((unsigned long )p != (unsigned long )(p1 + 1)) {
#line 2171
          goto while_break___27;
        }
      }
#line 2175
      if (had_char_class) {
#line 2175
        if ((int )c == 45) {
#line 2175
          if ((int const   )*p != 93) {
            {
#line 2176
            free((void *)compile_stack.stack);
            }
#line 2176
            return ((reg_errcode_t )11);
          }
        }
      }
#line 2182
      if ((int )c == 45) {
#line 2182
        if ((unsigned long )(p - 2) >= (unsigned long )pattern) {
#line 2182
          if ((int const   )*(p + -2) == 91) {
#line 2182
            goto _L___19;
          } else {
#line 2182
            goto _L___20;
          }
        } else
        _L___20: /* CIL Label */ 
#line 2182
        if ((unsigned long )(p - 3) >= (unsigned long )pattern) {
#line 2182
          if ((int const   )*(p + -3) == 91) {
#line 2182
            if ((int const   )*(p + -2) == 94) {
#line 2182
              goto _L___19;
            } else {
#line 2182
              goto _L___18;
            }
          } else {
#line 2182
            goto _L___18;
          }
        } else
        _L___18: /* CIL Label */ 
#line 2182
        if ((int const   )*p != 93) {
          {
#line 2187
          tmp___30 = compile_range(& p, pend, translate, syntax, b);
#line 2187
          ret = tmp___30;
          }
#line 2189
          if ((int )ret != 0) {
            {
#line 2189
            free((void *)compile_stack.stack);
            }
#line 2189
            return (ret);
          }
        } else {
#line 2182
          goto _L___19;
        }
      } else
      _L___19: /* CIL Label */ 
#line 2192
      if ((int const   )*(p + 0) == 45) {
#line 2192
        if ((int const   )*(p + 1) != 93) {
          {
#line 2197
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 2197
            if ((unsigned long )p == (unsigned long )pend) {
#line 2197
              return ((reg_errcode_t )14);
            }
#line 2197
            tmp___31 = p;
#line 2197
            p ++;
#line 2197
            c1 = (unsigned char )*tmp___31;
#line 2197
            if (translate) {
#line 2197
              c1 = (unsigned char )*(translate + c1);
            }
#line 2197
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 2199
          ret___0 = compile_range(& p, pend, translate, syntax, b);
          }
#line 2200
          if ((int )ret___0 != 0) {
            {
#line 2200
            free((void *)compile_stack.stack);
            }
#line 2200
            return (ret___0);
          }
        } else {
#line 2192
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 2206
      if (syntax & ((1UL << 1) << 1)) {
#line 2206
        if ((int )c == 91) {
#line 2206
          if ((int const   )*p == 58) {
            {
#line 2210
            while (1) {
              while_continue___31: /* CIL Label */ ;
#line 2210
              if ((unsigned long )p == (unsigned long )pend) {
#line 2210
                return ((reg_errcode_t )14);
              }
#line 2210
              tmp___32 = p;
#line 2210
              p ++;
#line 2210
              c = (unsigned char )*tmp___32;
#line 2210
              if (translate) {
#line 2210
                c = (unsigned char )*(translate + c);
              }
#line 2210
              goto while_break___31;
            }
            while_break___31: /* CIL Label */ ;
            }
#line 2211
            c1 = (unsigned char)0;
#line 2214
            if ((unsigned long )p == (unsigned long )pend) {
              {
#line 2214
              free((void *)compile_stack.stack);
              }
#line 2214
              return ((reg_errcode_t )7);
            }
            {
#line 2216
            while (1) {
              while_continue___32: /* CIL Label */ ;
              {
#line 2218
              while (1) {
                while_continue___33: /* CIL Label */ ;
#line 2218
                if ((unsigned long )p == (unsigned long )pend) {
#line 2218
                  return ((reg_errcode_t )14);
                }
#line 2218
                tmp___33 = p;
#line 2218
                p ++;
#line 2218
                c = (unsigned char )*tmp___33;
#line 2218
                if (translate) {
#line 2218
                  c = (unsigned char )*(translate + c);
                }
#line 2218
                goto while_break___33;
              }
              while_break___33: /* CIL Label */ ;
              }
#line 2219
              if ((int )c == 58) {
#line 2219
                if ((int const   )*p == 93) {
#line 2220
                  goto while_break___32;
                } else {
#line 2219
                  goto _L___2;
                }
              } else
              _L___2: /* CIL Label */ 
#line 2219
              if ((unsigned long )p == (unsigned long )pend) {
#line 2220
                goto while_break___32;
              }
#line 2221
              if ((int )c1 < 6) {
#line 2222
                tmp___34 = c1;
#line 2222
                c1 = (unsigned char )((int )c1 + 1);
#line 2222
                str[tmp___34] = (char )c;
              } else {
#line 2225
                str[0] = (char )'\000';
              }
            }
            while_break___32: /* CIL Label */ ;
            }
#line 2227
            str[c1] = (char )'\000';
#line 2232
            if ((int )c == 58) {
#line 2232
              if ((int const   )*p == 93) {
                {
#line 2268
                tmp___35 = strcmp((char const   *)(str), "alnum");
#line 2268
                is_alnum = (boolean )(tmp___35 == 0);
#line 2269
                tmp___36 = strcmp((char const   *)(str), "alpha");
#line 2269
                is_alpha = (boolean )(tmp___36 == 0);
#line 2270
                tmp___37 = strcmp((char const   *)(str), "blank");
#line 2270
                is_blank = (boolean )(tmp___37 == 0);
#line 2271
                tmp___38 = strcmp((char const   *)(str), "cntrl");
#line 2271
                is_cntrl = (boolean )(tmp___38 == 0);
#line 2272
                tmp___39 = strcmp((char const   *)(str), "digit");
#line 2272
                is_digit = (boolean )(tmp___39 == 0);
#line 2273
                tmp___40 = strcmp((char const   *)(str), "graph");
#line 2273
                is_graph = (boolean )(tmp___40 == 0);
#line 2274
                tmp___41 = strcmp((char const   *)(str), "lower");
#line 2274
                is_lower = (boolean )(tmp___41 == 0);
#line 2275
                tmp___42 = strcmp((char const   *)(str), "print");
#line 2275
                is_print = (boolean )(tmp___42 == 0);
#line 2276
                tmp___43 = strcmp((char const   *)(str), "punct");
#line 2276
                is_punct = (boolean )(tmp___43 == 0);
#line 2277
                tmp___44 = strcmp((char const   *)(str), "space");
#line 2277
                is_space = (boolean )(tmp___44 == 0);
#line 2278
                tmp___45 = strcmp((char const   *)(str), "upper");
#line 2278
                is_upper = (boolean )(tmp___45 == 0);
#line 2279
                tmp___46 = strcmp((char const   *)(str), "xdigit");
#line 2279
                is_xdigit = (boolean )(tmp___46 == 0);
#line 2281
                tmp___47 = strcmp((char const   *)(str), "alpha");
                }
#line 2281
                if (! (tmp___47 == 0)) {
                  {
#line 2281
                  tmp___48 = strcmp((char const   *)(str), "upper");
                  }
#line 2281
                  if (! (tmp___48 == 0)) {
                    {
#line 2281
                    tmp___49 = strcmp((char const   *)(str), "lower");
                    }
#line 2281
                    if (! (tmp___49 == 0)) {
                      {
#line 2281
                      tmp___50 = strcmp((char const   *)(str), "digit");
                      }
#line 2281
                      if (! (tmp___50 == 0)) {
                        {
#line 2281
                        tmp___51 = strcmp((char const   *)(str), "alnum");
                        }
#line 2281
                        if (! (tmp___51 == 0)) {
                          {
#line 2281
                          tmp___52 = strcmp((char const   *)(str), "xdigit");
                          }
#line 2281
                          if (! (tmp___52 == 0)) {
                            {
#line 2281
                            tmp___53 = strcmp((char const   *)(str), "space");
                            }
#line 2281
                            if (! (tmp___53 == 0)) {
                              {
#line 2281
                              tmp___54 = strcmp((char const   *)(str), "print");
                              }
#line 2281
                              if (! (tmp___54 == 0)) {
                                {
#line 2281
                                tmp___55 = strcmp((char const   *)(str), "punct");
                                }
#line 2281
                                if (! (tmp___55 == 0)) {
                                  {
#line 2281
                                  tmp___56 = strcmp((char const   *)(str), "graph");
                                  }
#line 2281
                                  if (! (tmp___56 == 0)) {
                                    {
#line 2281
                                    tmp___57 = strcmp((char const   *)(str), "cntrl");
                                    }
#line 2281
                                    if (! (tmp___57 == 0)) {
                                      {
#line 2281
                                      tmp___58 = strcmp((char const   *)(str), "blank");
                                      }
#line 2281
                                      if (! (tmp___58 == 0)) {
                                        {
#line 2282
                                        free((void *)compile_stack.stack);
                                        }
#line 2282
                                        return ((reg_errcode_t )4);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                {
#line 2286
                while (1) {
                  while_continue___34: /* CIL Label */ ;
#line 2286
                  if ((unsigned long )p == (unsigned long )pend) {
#line 2286
                    return ((reg_errcode_t )14);
                  }
#line 2286
                  tmp___59 = p;
#line 2286
                  p ++;
#line 2286
                  c = (unsigned char )*tmp___59;
#line 2286
                  if (translate) {
#line 2286
                    c = (unsigned char )*(translate + c);
                  }
#line 2286
                  goto while_break___34;
                }
                while_break___34: /* CIL Label */ ;
                }
#line 2288
                if ((unsigned long )p == (unsigned long )pend) {
                  {
#line 2288
                  free((void *)compile_stack.stack);
                  }
#line 2288
                  return ((reg_errcode_t )7);
                }
#line 2290
                ch = 0;
                {
#line 2290
                while (1) {
                  while_continue___35: /* CIL Label */ ;
#line 2290
                  if (! (ch < 1 << 8)) {
#line 2290
                    goto while_break___35;
                  }
#line 2294
                  if (is_alnum) {
                    {
#line 2294
                    tmp___60 = __ctype_b_loc();
                    }
#line 2294
                    if ((int const   )*(*tmp___60 + ch) & 8) {
#line 2298
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 2294
                      goto _L___5;
                    }
                  } else
                  _L___5: /* CIL Label */ 
#line 2294
                  if (is_alpha) {
                    {
#line 2294
                    tmp___61 = __ctype_b_loc();
                    }
#line 2294
                    if ((int const   )*(*tmp___61 + ch) & 1024) {
#line 2298
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 2294
                      goto _L___4;
                    }
                  } else
                  _L___4: /* CIL Label */ 
#line 2294
                  if (is_blank) {
                    {
#line 2294
                    tmp___62 = __ctype_b_loc();
                    }
#line 2294
                    if ((int const   )*(*tmp___62 + ch) & 1) {
#line 2298
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 2294
                      goto _L___3;
                    }
                  } else
                  _L___3: /* CIL Label */ 
#line 2294
                  if (is_cntrl) {
                    {
#line 2294
                    tmp___63 = __ctype_b_loc();
                    }
#line 2294
                    if ((int const   )*(*tmp___63 + ch) & 2) {
#line 2298
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
#line 2299
                  if (is_digit) {
                    {
#line 2299
                    tmp___64 = __ctype_b_loc();
                    }
#line 2299
                    if ((int const   )*(*tmp___64 + ch) & 2048) {
#line 2303
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 2299
                      goto _L___8;
                    }
                  } else
                  _L___8: /* CIL Label */ 
#line 2299
                  if (is_graph) {
                    {
#line 2299
                    tmp___65 = __ctype_b_loc();
                    }
#line 2299
                    if ((int const   )*(*tmp___65 + ch) & 32768) {
#line 2303
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 2299
                      goto _L___7;
                    }
                  } else
                  _L___7: /* CIL Label */ 
#line 2299
                  if (is_lower) {
                    {
#line 2299
                    tmp___66 = __ctype_b_loc();
                    }
#line 2299
                    if ((int const   )*(*tmp___66 + ch) & 512) {
#line 2303
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 2299
                      goto _L___6;
                    }
                  } else
                  _L___6: /* CIL Label */ 
#line 2299
                  if (is_print) {
                    {
#line 2299
                    tmp___67 = __ctype_b_loc();
                    }
#line 2299
                    if ((int const   )*(*tmp___67 + ch) & 16384) {
#line 2303
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
#line 2304
                  if (is_punct) {
                    {
#line 2304
                    tmp___68 = __ctype_b_loc();
                    }
#line 2304
                    if ((int const   )*(*tmp___68 + ch) & 4) {
#line 2308
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 2304
                      goto _L___11;
                    }
                  } else
                  _L___11: /* CIL Label */ 
#line 2304
                  if (is_space) {
                    {
#line 2304
                    tmp___69 = __ctype_b_loc();
                    }
#line 2304
                    if ((int const   )*(*tmp___69 + ch) & 8192) {
#line 2308
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 2304
                      goto _L___10;
                    }
                  } else
                  _L___10: /* CIL Label */ 
#line 2304
                  if (is_upper) {
                    {
#line 2304
                    tmp___70 = __ctype_b_loc();
                    }
#line 2304
                    if ((int const   )*(*tmp___70 + ch) & 256) {
#line 2308
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 2304
                      goto _L___9;
                    }
                  } else
                  _L___9: /* CIL Label */ 
#line 2304
                  if (is_xdigit) {
                    {
#line 2304
                    tmp___71 = __ctype_b_loc();
                    }
#line 2304
                    if ((int const   )*(*tmp___71 + ch) & 4096) {
#line 2308
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
#line 2309
                  if (translate) {
#line 2309
                    if (is_upper) {
#line 2309
                      goto _L___12;
                    } else
#line 2309
                    if (is_lower) {
                      _L___12: /* CIL Label */ 
                      {
#line 2309
                      tmp___72 = __ctype_b_loc();
                      }
#line 2309
                      if ((int const   )*(*tmp___72 + ch) & 256) {
#line 2311
                        *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                      } else {
                        {
#line 2309
                        tmp___73 = __ctype_b_loc();
                        }
#line 2309
                        if ((int const   )*(*tmp___73 + ch) & 512) {
#line 2311
                          *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                        }
                      }
                    }
                  }
#line 2290
                  ch ++;
                }
                while_break___35: /* CIL Label */ ;
                }
#line 2313
                had_char_class = (boolean )1;
              } else {
#line 2232
                goto _L___13;
              }
            } else {
              _L___13: /* CIL Label */ 
#line 2318
              c1 = (unsigned char )((int )c1 + 1);
              {
#line 2319
              while (1) {
                while_continue___36: /* CIL Label */ ;
#line 2319
                tmp___74 = c1;
#line 2319
                c1 = (unsigned char )((int )c1 - 1);
#line 2319
                if (! tmp___74) {
#line 2319
                  goto while_break___36;
                }
#line 2320
                p --;
              }
              while_break___36: /* CIL Label */ ;
              }
#line 2321
              *(b + 11) = (unsigned char )((int )*(b + 11) | (1 << 3));
#line 2322
              *(b + 7) = (unsigned char )((int )*(b + 7) | (1 << 2));
#line 2323
              had_char_class = (boolean )0;
            }
          } else {
#line 2328
            had_char_class = (boolean )0;
#line 2329
            *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
          }
        } else {
#line 2328
          had_char_class = (boolean )0;
#line 2329
          *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
        }
      } else {
#line 2328
        had_char_class = (boolean )0;
#line 2329
        *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 2335
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 2335
      if ((int )*(b + -1) > 0) {
#line 2335
        if (! ((int )*(b + ((int )*(b + -1) - 1)) == 0)) {
#line 2335
          goto while_break___37;
        }
      } else {
#line 2335
        goto while_break___37;
      }
#line 2336
      *(b + -1) = (unsigned char )((int )*(b + -1) - 1);
    }
    while_break___37: /* CIL Label */ ;
    }
#line 2337
    b += (int )*(b + -1);
#line 2339
    goto switch_break;
    case_40: /* CIL Label */ 
#line 2343
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2344
      goto handle_open;
    } else {
#line 2346
      goto normal_char;
    }
    case_41: /* CIL Label */ 
#line 2350
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2351
      goto handle_close;
    } else {
#line 2353
      goto normal_char;
    }
    case_10: /* CIL Label */ 
#line 2357
    if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2358
      goto handle_alt;
    } else {
#line 2360
      goto normal_char;
    }
    case_124: /* CIL Label */ 
#line 2364
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2365
      goto handle_alt;
    } else {
#line 2367
      goto normal_char;
    }
    case_123: /* CIL Label */ 
#line 2371
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2371
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2372
        goto handle_interval;
      } else {
#line 2374
        goto normal_char;
      }
    } else {
#line 2374
      goto normal_char;
    }
    case_92: /* CIL Label */ 
#line 2378
    if ((unsigned long )p == (unsigned long )pend) {
      {
#line 2378
      free((void *)compile_stack.stack);
      }
#line 2378
      return ((reg_errcode_t )5);
    }
    {
#line 2383
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 2383
      if ((unsigned long )p == (unsigned long )pend) {
#line 2383
        return ((reg_errcode_t )14);
      }
#line 2383
      tmp___75 = p;
#line 2383
      p ++;
#line 2383
      c = (unsigned char )*tmp___75;
#line 2383
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 2387
    if ((int )c == 40) {
#line 2387
      goto case_40___0;
    }
#line 2436
    if ((int )c == 41) {
#line 2436
      goto case_41___0;
    }
#line 2506
    if ((int )c == 124) {
#line 2506
      goto case_124___0;
    }
#line 2551
    if ((int )c == 123) {
#line 2551
      goto case_123___0;
    }
#line 2741
    if ((int )c == 119) {
#line 2741
      goto case_119;
    }
#line 2749
    if ((int )c == 87) {
#line 2749
      goto case_87;
    }
#line 2757
    if ((int )c == 60) {
#line 2757
      goto case_60;
    }
#line 2763
    if ((int )c == 62) {
#line 2763
      goto case_62;
    }
#line 2769
    if ((int )c == 98) {
#line 2769
      goto case_98;
    }
#line 2775
    if ((int )c == 66) {
#line 2775
      goto case_66;
    }
#line 2781
    if ((int )c == 96) {
#line 2781
      goto case_96;
    }
#line 2787
    if ((int )c == 39) {
#line 2787
      goto case_39;
    }
#line 2794
    if ((int )c == 57) {
#line 2794
      goto case_57;
    }
#line 2794
    if ((int )c == 56) {
#line 2794
      goto case_57;
    }
#line 2794
    if ((int )c == 55) {
#line 2794
      goto case_57;
    }
#line 2794
    if ((int )c == 54) {
#line 2794
      goto case_57;
    }
#line 2794
    if ((int )c == 53) {
#line 2794
      goto case_57;
    }
#line 2794
    if ((int )c == 52) {
#line 2794
      goto case_57;
    }
#line 2794
    if ((int )c == 51) {
#line 2794
      goto case_57;
    }
#line 2794
    if ((int )c == 50) {
#line 2794
      goto case_57;
    }
#line 2794
    if ((int )c == 49) {
#line 2794
      goto case_57;
    }
#line 2813
    if ((int )c == 63) {
#line 2813
      goto case_63___0;
    }
#line 2813
    if ((int )c == 43) {
#line 2813
      goto case_63___0;
    }
#line 2819
    goto normal_backslash;
    case_40___0: /* CIL Label */ 
#line 2388
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2389
      goto normal_backslash;
    }
    handle_open: 
#line 2392
    (bufp->re_nsub) ++;
#line 2393
    regnum ++;
#line 2395
    if (compile_stack.avail == compile_stack.size) {
      {
#line 2397
      tmp___76 = realloc((void *)compile_stack.stack, (size_t )((unsigned long )(compile_stack.size << 1) * sizeof(compile_stack_elt_t )));
#line 2397
      compile_stack.stack = (compile_stack_elt_t *)tmp___76;
      }
#line 2399
      if ((unsigned long )compile_stack.stack == (unsigned long )((void *)0)) {
#line 2399
        return ((reg_errcode_t )12);
      }
#line 2401
      compile_stack.size <<= 1;
    }
#line 2408
    (compile_stack.stack + compile_stack.avail)->begalt_offset = begalt - bufp->buffer;
#line 2409
    if (fixup_alt_jump) {
#line 2409
      (compile_stack.stack + compile_stack.avail)->fixup_alt_jump = (fixup_alt_jump - bufp->buffer) + 1L;
    } else {
#line 2409
      (compile_stack.stack + compile_stack.avail)->fixup_alt_jump = (pattern_offset_t )0;
    }
#line 2411
    (compile_stack.stack + compile_stack.avail)->laststart_offset = b - bufp->buffer;
#line 2412
    (compile_stack.stack + compile_stack.avail)->regnum = regnum;
#line 2418
    if (regnum <= 255U) {
#line 2420
      (compile_stack.stack + compile_stack.avail)->inner_group_offset = (b - bufp->buffer) + 2L;
      {
#line 2421
      while (1) {
        while_continue___39: /* CIL Label */ ;
        {
#line 2421
        while (1) {
          while_continue___40: /* CIL Label */ ;
#line 2421
          if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2421
            goto while_break___40;
          }
          {
#line 2421
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 2421
            old_buffer___8 = bufp->buffer;
#line 2421
            if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2421
              return ((reg_errcode_t )15);
            }
#line 2421
            bufp->allocated <<= 1;
#line 2421
            if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2421
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
#line 2421
            tmp___77 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2421
            bufp->buffer = (unsigned char *)tmp___77;
            }
#line 2421
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2421
              return ((reg_errcode_t )12);
            }
#line 2421
            if ((unsigned long )old_buffer___8 != (unsigned long )bufp->buffer) {
#line 2421
              b = bufp->buffer + (b - old_buffer___8);
#line 2421
              begalt = bufp->buffer + (begalt - old_buffer___8);
#line 2421
              if (fixup_alt_jump) {
#line 2421
                fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___8);
              }
#line 2421
              if (laststart) {
#line 2421
                laststart = bufp->buffer + (laststart - old_buffer___8);
              }
#line 2421
              if (pending_exact) {
#line 2421
                pending_exact = bufp->buffer + (pending_exact - old_buffer___8);
              }
            }
#line 2421
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
        }
        while_break___40: /* CIL Label */ ;
        }
#line 2421
        tmp___78 = b;
#line 2421
        b ++;
#line 2421
        *tmp___78 = (unsigned char)6;
#line 2421
        tmp___79 = b;
#line 2421
        b ++;
#line 2421
        *tmp___79 = (unsigned char )regnum;
#line 2421
        tmp___80 = b;
#line 2421
        b ++;
#line 2421
        *tmp___80 = (unsigned char)0;
#line 2421
        goto while_break___39;
      }
      while_break___39: /* CIL Label */ ;
      }
    }
#line 2424
    (compile_stack.avail) ++;
#line 2426
    fixup_alt_jump = (unsigned char *)0;
#line 2427
    laststart = (unsigned char *)0;
#line 2428
    begalt = b;
#line 2432
    pending_exact = (unsigned char *)0;
#line 2433
    goto switch_break___0;
    case_41___0: /* CIL Label */ 
#line 2437
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2437
      goto normal_backslash;
    }
#line 2439
    if (compile_stack.avail == 0U) {
#line 2441
      if (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2442
        goto normal_backslash;
      } else {
        {
#line 2444
        free((void *)compile_stack.stack);
        }
#line 2444
        return ((reg_errcode_t )16);
      }
    }
    handle_close: 
#line 2448
    if (fixup_alt_jump) {
      {
#line 2453
      while (1) {
        while_continue___42: /* CIL Label */ ;
        {
#line 2453
        while (1) {
          while_continue___43: /* CIL Label */ ;
#line 2453
          if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2453
            goto while_break___43;
          }
          {
#line 2453
          while (1) {
            while_continue___44: /* CIL Label */ ;
#line 2453
            old_buffer___9 = bufp->buffer;
#line 2453
            if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2453
              return ((reg_errcode_t )15);
            }
#line 2453
            bufp->allocated <<= 1;
#line 2453
            if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2453
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
#line 2453
            tmp___81 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2453
            bufp->buffer = (unsigned char *)tmp___81;
            }
#line 2453
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2453
              return ((reg_errcode_t )12);
            }
#line 2453
            if ((unsigned long )old_buffer___9 != (unsigned long )bufp->buffer) {
#line 2453
              b = bufp->buffer + (b - old_buffer___9);
#line 2453
              begalt = bufp->buffer + (begalt - old_buffer___9);
#line 2453
              if (fixup_alt_jump) {
#line 2453
                fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___9);
              }
#line 2453
              if (laststart) {
#line 2453
                laststart = bufp->buffer + (laststart - old_buffer___9);
              }
#line 2453
              if (pending_exact) {
#line 2453
                pending_exact = bufp->buffer + (pending_exact - old_buffer___9);
              }
            }
#line 2453
            goto while_break___44;
          }
          while_break___44: /* CIL Label */ ;
          }
        }
        while_break___43: /* CIL Label */ ;
        }
#line 2453
        tmp___82 = b;
#line 2453
        b ++;
#line 2453
        *tmp___82 = (unsigned char)20;
#line 2453
        goto while_break___42;
      }
      while_break___42: /* CIL Label */ ;
      }
      {
#line 2457
      store_op1((re_opcode_t )14, fixup_alt_jump, (int )(((b - 1) - fixup_alt_jump) - 3L));
      }
    }
#line 2461
    if (compile_stack.avail == 0U) {
#line 2463
      if (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2464
        goto normal_char;
      } else {
        {
#line 2466
        free((void *)compile_stack.stack);
        }
#line 2466
        return ((reg_errcode_t )16);
      }
    }
#line 2478
    (compile_stack.avail) --;
#line 2479
    begalt = bufp->buffer + (compile_stack.stack + compile_stack.avail)->begalt_offset;
#line 2480
    if ((compile_stack.stack + compile_stack.avail)->fixup_alt_jump) {
#line 2480
      fixup_alt_jump = (bufp->buffer + (compile_stack.stack + compile_stack.avail)->fixup_alt_jump) - 1;
    } else {
#line 2480
      fixup_alt_jump = (unsigned char *)0;
    }
#line 2484
    laststart = bufp->buffer + (compile_stack.stack + compile_stack.avail)->laststart_offset;
#line 2485
    this_group_regnum = (compile_stack.stack + compile_stack.avail)->regnum;
#line 2489
    pending_exact = (unsigned char *)0;
#line 2493
    if (this_group_regnum <= 255U) {
#line 2495
      inner_group_loc = bufp->buffer + (compile_stack.stack + compile_stack.avail)->inner_group_offset;
#line 2498
      *inner_group_loc = (unsigned char )(regnum - this_group_regnum);
      {
#line 2499
      while (1) {
        while_continue___45: /* CIL Label */ ;
        {
#line 2499
        while (1) {
          while_continue___46: /* CIL Label */ ;
#line 2499
          if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2499
            goto while_break___46;
          }
          {
#line 2499
          while (1) {
            while_continue___47: /* CIL Label */ ;
#line 2499
            old_buffer___10 = bufp->buffer;
#line 2499
            if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2499
              return ((reg_errcode_t )15);
            }
#line 2499
            bufp->allocated <<= 1;
#line 2499
            if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2499
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
#line 2499
            tmp___83 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2499
            bufp->buffer = (unsigned char *)tmp___83;
            }
#line 2499
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2499
              return ((reg_errcode_t )12);
            }
#line 2499
            if ((unsigned long )old_buffer___10 != (unsigned long )bufp->buffer) {
#line 2499
              b = bufp->buffer + (b - old_buffer___10);
#line 2499
              begalt = bufp->buffer + (begalt - old_buffer___10);
#line 2499
              if (fixup_alt_jump) {
#line 2499
                fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___10);
              }
#line 2499
              if (laststart) {
#line 2499
                laststart = bufp->buffer + (laststart - old_buffer___10);
              }
#line 2499
              if (pending_exact) {
#line 2499
                pending_exact = bufp->buffer + (pending_exact - old_buffer___10);
              }
            }
#line 2499
            goto while_break___47;
          }
          while_break___47: /* CIL Label */ ;
          }
        }
        while_break___46: /* CIL Label */ ;
        }
#line 2499
        tmp___84 = b;
#line 2499
        b ++;
#line 2499
        *tmp___84 = (unsigned char)7;
#line 2499
        tmp___85 = b;
#line 2499
        b ++;
#line 2499
        *tmp___85 = (unsigned char )this_group_regnum;
#line 2499
        tmp___86 = b;
#line 2499
        b ++;
#line 2499
        *tmp___86 = (unsigned char )(regnum - this_group_regnum);
#line 2499
        goto while_break___45;
      }
      while_break___45: /* CIL Label */ ;
      }
    }
#line 2503
    goto switch_break___0;
    case_124___0: /* CIL Label */ 
#line 2507
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2508
      goto normal_backslash;
    } else
#line 2507
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2508
      goto normal_backslash;
    }
    handle_alt: 
#line 2510
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2511
      goto normal_char;
    }
    {
#line 2515
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 2515
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2515
        goto while_break___48;
      }
      {
#line 2515
      while (1) {
        while_continue___49: /* CIL Label */ ;
#line 2515
        old_buffer___11 = bufp->buffer;
#line 2515
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2515
          return ((reg_errcode_t )15);
        }
#line 2515
        bufp->allocated <<= 1;
#line 2515
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2515
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 2515
        tmp___87 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2515
        bufp->buffer = (unsigned char *)tmp___87;
        }
#line 2515
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2515
          return ((reg_errcode_t )12);
        }
#line 2515
        if ((unsigned long )old_buffer___11 != (unsigned long )bufp->buffer) {
#line 2515
          b = bufp->buffer + (b - old_buffer___11);
#line 2515
          begalt = bufp->buffer + (begalt - old_buffer___11);
#line 2515
          if (fixup_alt_jump) {
#line 2515
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___11);
          }
#line 2515
          if (laststart) {
#line 2515
            laststart = bufp->buffer + (laststart - old_buffer___11);
          }
#line 2515
          if (pending_exact) {
#line 2515
            pending_exact = bufp->buffer + (pending_exact - old_buffer___11);
          }
        }
#line 2515
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 2516
    insert_op1((re_opcode_t )15, begalt, (int )(((b + 6) - begalt) - 3L), b);
#line 2517
    pending_exact = (unsigned char *)0;
#line 2518
    b += 3;
    }
#line 2536
    if (fixup_alt_jump) {
      {
#line 2537
      store_op1((re_opcode_t )14, fixup_alt_jump, (int )((b - fixup_alt_jump) - 3L));
      }
    }
#line 2542
    fixup_alt_jump = b;
    {
#line 2543
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 2543
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2543
        goto while_break___50;
      }
      {
#line 2543
      while (1) {
        while_continue___51: /* CIL Label */ ;
#line 2543
        old_buffer___12 = bufp->buffer;
#line 2543
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2543
          return ((reg_errcode_t )15);
        }
#line 2543
        bufp->allocated <<= 1;
#line 2543
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2543
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 2543
        tmp___88 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2543
        bufp->buffer = (unsigned char *)tmp___88;
        }
#line 2543
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2543
          return ((reg_errcode_t )12);
        }
#line 2543
        if ((unsigned long )old_buffer___12 != (unsigned long )bufp->buffer) {
#line 2543
          b = bufp->buffer + (b - old_buffer___12);
#line 2543
          begalt = bufp->buffer + (begalt - old_buffer___12);
#line 2543
          if (fixup_alt_jump) {
#line 2543
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___12);
          }
#line 2543
          if (laststart) {
#line 2543
            laststart = bufp->buffer + (laststart - old_buffer___12);
          }
#line 2543
          if (pending_exact) {
#line 2543
            pending_exact = bufp->buffer + (pending_exact - old_buffer___12);
          }
        }
#line 2543
        goto while_break___51;
      }
      while_break___51: /* CIL Label */ ;
      }
    }
    while_break___50: /* CIL Label */ ;
    }
#line 2544
    b += 3;
#line 2546
    laststart = (unsigned char *)0;
#line 2547
    begalt = b;
#line 2548
    goto switch_break___0;
    case_123___0: /* CIL Label */ 
#line 2553
    if (! (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2558
      goto normal_backslash;
    } else
#line 2553
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2553
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2558
        goto normal_backslash;
      } else {
#line 2553
        goto _L___21;
      }
    } else
    _L___21: /* CIL Label */ 
#line 2553
    if ((unsigned long )(p - 2) == (unsigned long )pattern) {
#line 2553
      if ((unsigned long )p == (unsigned long )pend) {
#line 2558
        goto normal_backslash;
      }
    }
    handle_interval: 
#line 2565
    lower_bound = -1;
#line 2565
    upper_bound = -1;
#line 2567
    beg_interval = p - 1;
#line 2569
    if ((unsigned long )p == (unsigned long )pend) {
#line 2571
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2572
        goto unfetch_interval;
      } else {
        {
#line 2574
        free((void *)compile_stack.stack);
        }
#line 2574
        return ((reg_errcode_t )9);
      }
    }
#line 2577
    if ((unsigned long )p != (unsigned long )pend) {
      {
#line 2577
      while (1) {
        while_continue___52: /* CIL Label */ ;
#line 2577
        if ((unsigned long )p == (unsigned long )pend) {
#line 2577
          return ((reg_errcode_t )14);
        }
#line 2577
        tmp___89 = p;
#line 2577
        p ++;
#line 2577
        c = (unsigned char )*tmp___89;
#line 2577
        if (translate) {
#line 2577
          c = (unsigned char )*(translate + c);
        }
#line 2577
        goto while_break___52;
      }
      while_break___52: /* CIL Label */ ;
      }
      {
#line 2577
      while (1) {
        while_continue___53: /* CIL Label */ ;
        {
#line 2577
        tmp___91 = __ctype_b_loc();
        }
#line 2577
        if (! ((int const   )*(*tmp___91 + (int )c) & 2048)) {
#line 2577
          goto while_break___53;
        }
#line 2577
        if (lower_bound < 0) {
#line 2577
          lower_bound = 0;
        }
#line 2577
        lower_bound = (lower_bound * 10 + (int )c) - 48;
#line 2577
        if ((unsigned long )p == (unsigned long )pend) {
#line 2577
          goto while_break___53;
        }
        {
#line 2577
        while (1) {
          while_continue___54: /* CIL Label */ ;
#line 2577
          if ((unsigned long )p == (unsigned long )pend) {
#line 2577
            return ((reg_errcode_t )14);
          }
#line 2577
          tmp___90 = p;
#line 2577
          p ++;
#line 2577
          c = (unsigned char )*tmp___90;
#line 2577
          if (translate) {
#line 2577
            c = (unsigned char )*(translate + c);
          }
#line 2577
          goto while_break___54;
        }
        while_break___54: /* CIL Label */ ;
        }
      }
      while_break___53: /* CIL Label */ ;
      }
    }
#line 2579
    if ((int )c == 44) {
#line 2581
      if ((unsigned long )p != (unsigned long )pend) {
        {
#line 2581
        while (1) {
          while_continue___55: /* CIL Label */ ;
#line 2581
          if ((unsigned long )p == (unsigned long )pend) {
#line 2581
            return ((reg_errcode_t )14);
          }
#line 2581
          tmp___92 = p;
#line 2581
          p ++;
#line 2581
          c = (unsigned char )*tmp___92;
#line 2581
          if (translate) {
#line 2581
            c = (unsigned char )*(translate + c);
          }
#line 2581
          goto while_break___55;
        }
        while_break___55: /* CIL Label */ ;
        }
        {
#line 2581
        while (1) {
          while_continue___56: /* CIL Label */ ;
          {
#line 2581
          tmp___94 = __ctype_b_loc();
          }
#line 2581
          if (! ((int const   )*(*tmp___94 + (int )c) & 2048)) {
#line 2581
            goto while_break___56;
          }
#line 2581
          if (upper_bound < 0) {
#line 2581
            upper_bound = 0;
          }
#line 2581
          upper_bound = (upper_bound * 10 + (int )c) - 48;
#line 2581
          if ((unsigned long )p == (unsigned long )pend) {
#line 2581
            goto while_break___56;
          }
          {
#line 2581
          while (1) {
            while_continue___57: /* CIL Label */ ;
#line 2581
            if ((unsigned long )p == (unsigned long )pend) {
#line 2581
              return ((reg_errcode_t )14);
            }
#line 2581
            tmp___93 = p;
#line 2581
            p ++;
#line 2581
            c = (unsigned char )*tmp___93;
#line 2581
            if (translate) {
#line 2581
              c = (unsigned char )*(translate + c);
            }
#line 2581
            goto while_break___57;
          }
          while_break___57: /* CIL Label */ ;
          }
        }
        while_break___56: /* CIL Label */ ;
        }
      }
#line 2582
      if (upper_bound < 0) {
#line 2582
        upper_bound = 32767;
      }
    } else {
#line 2586
      upper_bound = lower_bound;
    }
#line 2588
    if (lower_bound < 0) {
#line 2588
      goto _L___22;
    } else
#line 2588
    if (upper_bound > 32767) {
#line 2588
      goto _L___22;
    } else
#line 2588
    if (lower_bound > upper_bound) {
      _L___22: /* CIL Label */ 
#line 2591
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2592
        goto unfetch_interval;
      } else {
        {
#line 2594
        free((void *)compile_stack.stack);
        }
#line 2594
        return ((reg_errcode_t )10);
      }
    }
#line 2597
    if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2599
      if ((int )c != 92) {
        {
#line 2599
        free((void *)compile_stack.stack);
        }
#line 2599
        return ((reg_errcode_t )9);
      }
      {
#line 2601
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 2601
        if ((unsigned long )p == (unsigned long )pend) {
#line 2601
          return ((reg_errcode_t )14);
        }
#line 2601
        tmp___95 = p;
#line 2601
        p ++;
#line 2601
        c = (unsigned char )*tmp___95;
#line 2601
        if (translate) {
#line 2601
          c = (unsigned char )*(translate + c);
        }
#line 2601
        goto while_break___58;
      }
      while_break___58: /* CIL Label */ ;
      }
    }
#line 2604
    if ((int )c != 125) {
#line 2606
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2607
        goto unfetch_interval;
      } else {
        {
#line 2609
        free((void *)compile_stack.stack);
        }
#line 2609
        return ((reg_errcode_t )10);
      }
    }
#line 2615
    if (! laststart) {
#line 2617
      if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
        {
#line 2618
        free((void *)compile_stack.stack);
        }
#line 2618
        return ((reg_errcode_t )13);
      } else
#line 2619
      if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
#line 2620
        laststart = b;
      } else {
#line 2622
        goto unfetch_interval;
      }
    }
#line 2628
    if (upper_bound == 0) {
      {
#line 2630
      while (1) {
        while_continue___59: /* CIL Label */ ;
#line 2630
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2630
          goto while_break___59;
        }
        {
#line 2630
        while (1) {
          while_continue___60: /* CIL Label */ ;
#line 2630
          old_buffer___13 = bufp->buffer;
#line 2630
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2630
            return ((reg_errcode_t )15);
          }
#line 2630
          bufp->allocated <<= 1;
#line 2630
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2630
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2630
          tmp___96 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2630
          bufp->buffer = (unsigned char *)tmp___96;
          }
#line 2630
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2630
            return ((reg_errcode_t )12);
          }
#line 2630
          if ((unsigned long )old_buffer___13 != (unsigned long )bufp->buffer) {
#line 2630
            b = bufp->buffer + (b - old_buffer___13);
#line 2630
            begalt = bufp->buffer + (begalt - old_buffer___13);
#line 2630
            if (fixup_alt_jump) {
#line 2630
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___13);
            }
#line 2630
            if (laststart) {
#line 2630
              laststart = bufp->buffer + (laststart - old_buffer___13);
            }
#line 2630
            if (pending_exact) {
#line 2630
              pending_exact = bufp->buffer + (pending_exact - old_buffer___13);
            }
          }
#line 2630
          goto while_break___60;
        }
        while_break___60: /* CIL Label */ ;
        }
      }
      while_break___59: /* CIL Label */ ;
      }
      {
#line 2631
      insert_op1((re_opcode_t )13, laststart, (int )(((b + 3) - laststart) - 3L),
                 b);
#line 2632
      b += 3;
      }
    } else {
#line 2647
      nbytes = (unsigned int )(10 + (upper_bound > 1) * 10);
      {
#line 2649
      while (1) {
        while_continue___61: /* CIL Label */ ;
#line 2649
        if (! ((unsigned long )((b - bufp->buffer) + (long )nbytes) > bufp->allocated)) {
#line 2649
          goto while_break___61;
        }
        {
#line 2649
        while (1) {
          while_continue___62: /* CIL Label */ ;
#line 2649
          old_buffer___14 = bufp->buffer;
#line 2649
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2649
            return ((reg_errcode_t )15);
          }
#line 2649
          bufp->allocated <<= 1;
#line 2649
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2649
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2649
          tmp___97 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2649
          bufp->buffer = (unsigned char *)tmp___97;
          }
#line 2649
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2649
            return ((reg_errcode_t )12);
          }
#line 2649
          if ((unsigned long )old_buffer___14 != (unsigned long )bufp->buffer) {
#line 2649
            b = bufp->buffer + (b - old_buffer___14);
#line 2649
            begalt = bufp->buffer + (begalt - old_buffer___14);
#line 2649
            if (fixup_alt_jump) {
#line 2649
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___14);
            }
#line 2649
            if (laststart) {
#line 2649
              laststart = bufp->buffer + (laststart - old_buffer___14);
            }
#line 2649
            if (pending_exact) {
#line 2649
              pending_exact = bufp->buffer + (pending_exact - old_buffer___14);
            }
          }
#line 2649
          goto while_break___62;
        }
        while_break___62: /* CIL Label */ ;
        }
      }
      while_break___61: /* CIL Label */ ;
      }
      {
#line 2656
      insert_op2((re_opcode_t )21, laststart, (int )((((b + 5) + (upper_bound > 1) * 5) - laststart) - 3L),
                 lower_bound, b);
#line 2659
      b += 5;
#line 2665
      insert_op2((re_opcode_t )23, laststart, 5, lower_bound, b);
#line 2666
      b += 5;
      }
#line 2668
      if (upper_bound > 1) {
        {
#line 2676
        store_op2((re_opcode_t )22, b, (int )(((laststart + 5) - b) - 3L), upper_bound - 1);
#line 2678
        b += 5;
#line 2694
        insert_op2((re_opcode_t )23, laststart, (int )(b - laststart), upper_bound - 1,
                   b);
#line 2696
        b += 5;
        }
      }
    }
#line 2699
    pending_exact = (unsigned char *)0;
#line 2700
    beg_interval = (char const   *)((void *)0);
#line 2702
    goto switch_break___0;
    unfetch_interval: 
#line 2707
    p = beg_interval;
#line 2708
    beg_interval = (char const   *)((void *)0);
    {
#line 2711
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 2711
      if ((unsigned long )p == (unsigned long )pend) {
#line 2711
        return ((reg_errcode_t )14);
      }
#line 2711
      tmp___98 = p;
#line 2711
      p ++;
#line 2711
      c = (unsigned char )*tmp___98;
#line 2711
      if (translate) {
#line 2711
        c = (unsigned char )*(translate + c);
      }
#line 2711
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 2713
    if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2715
      if ((unsigned long )p > (unsigned long )pattern) {
#line 2715
        if ((int const   )*(p + -1) == 92) {
#line 2716
          goto normal_backslash;
        }
      }
    }
#line 2718
    goto normal_char;
    case_119: /* CIL Label */ 
#line 2742
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2743
      goto normal_char;
    }
#line 2744
    laststart = b;
    {
#line 2745
    while (1) {
      while_continue___64: /* CIL Label */ ;
      {
#line 2745
      while (1) {
        while_continue___65: /* CIL Label */ ;
#line 2745
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2745
          goto while_break___65;
        }
        {
#line 2745
        while (1) {
          while_continue___66: /* CIL Label */ ;
#line 2745
          old_buffer___15 = bufp->buffer;
#line 2745
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2745
            return ((reg_errcode_t )15);
          }
#line 2745
          bufp->allocated <<= 1;
#line 2745
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2745
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2745
          tmp___99 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2745
          bufp->buffer = (unsigned char *)tmp___99;
          }
#line 2745
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2745
            return ((reg_errcode_t )12);
          }
#line 2745
          if ((unsigned long )old_buffer___15 != (unsigned long )bufp->buffer) {
#line 2745
            b = bufp->buffer + (b - old_buffer___15);
#line 2745
            begalt = bufp->buffer + (begalt - old_buffer___15);
#line 2745
            if (fixup_alt_jump) {
#line 2745
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___15);
            }
#line 2745
            if (laststart) {
#line 2745
              laststart = bufp->buffer + (laststart - old_buffer___15);
            }
#line 2745
            if (pending_exact) {
#line 2745
              pending_exact = bufp->buffer + (pending_exact - old_buffer___15);
            }
          }
#line 2745
          goto while_break___66;
        }
        while_break___66: /* CIL Label */ ;
        }
      }
      while_break___65: /* CIL Label */ ;
      }
#line 2745
      tmp___100 = b;
#line 2745
      b ++;
#line 2745
      *tmp___100 = (unsigned char)24;
#line 2745
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
#line 2746
    goto switch_break___0;
    case_87: /* CIL Label */ 
#line 2750
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2751
      goto normal_char;
    }
#line 2752
    laststart = b;
    {
#line 2753
    while (1) {
      while_continue___67: /* CIL Label */ ;
      {
#line 2753
      while (1) {
        while_continue___68: /* CIL Label */ ;
#line 2753
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2753
          goto while_break___68;
        }
        {
#line 2753
        while (1) {
          while_continue___69: /* CIL Label */ ;
#line 2753
          old_buffer___16 = bufp->buffer;
#line 2753
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2753
            return ((reg_errcode_t )15);
          }
#line 2753
          bufp->allocated <<= 1;
#line 2753
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2753
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2753
          tmp___101 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2753
          bufp->buffer = (unsigned char *)tmp___101;
          }
#line 2753
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2753
            return ((reg_errcode_t )12);
          }
#line 2753
          if ((unsigned long )old_buffer___16 != (unsigned long )bufp->buffer) {
#line 2753
            b = bufp->buffer + (b - old_buffer___16);
#line 2753
            begalt = bufp->buffer + (begalt - old_buffer___16);
#line 2753
            if (fixup_alt_jump) {
#line 2753
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___16);
            }
#line 2753
            if (laststart) {
#line 2753
              laststart = bufp->buffer + (laststart - old_buffer___16);
            }
#line 2753
            if (pending_exact) {
#line 2753
              pending_exact = bufp->buffer + (pending_exact - old_buffer___16);
            }
          }
#line 2753
          goto while_break___69;
        }
        while_break___69: /* CIL Label */ ;
        }
      }
      while_break___68: /* CIL Label */ ;
      }
#line 2753
      tmp___102 = b;
#line 2753
      b ++;
#line 2753
      *tmp___102 = (unsigned char)25;
#line 2753
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
#line 2754
    goto switch_break___0;
    case_60: /* CIL Label */ 
#line 2758
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2759
      goto normal_char;
    }
    {
#line 2760
    while (1) {
      while_continue___70: /* CIL Label */ ;
      {
#line 2760
      while (1) {
        while_continue___71: /* CIL Label */ ;
#line 2760
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2760
          goto while_break___71;
        }
        {
#line 2760
        while (1) {
          while_continue___72: /* CIL Label */ ;
#line 2760
          old_buffer___17 = bufp->buffer;
#line 2760
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2760
            return ((reg_errcode_t )15);
          }
#line 2760
          bufp->allocated <<= 1;
#line 2760
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2760
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2760
          tmp___103 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2760
          bufp->buffer = (unsigned char *)tmp___103;
          }
#line 2760
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2760
            return ((reg_errcode_t )12);
          }
#line 2760
          if ((unsigned long )old_buffer___17 != (unsigned long )bufp->buffer) {
#line 2760
            b = bufp->buffer + (b - old_buffer___17);
#line 2760
            begalt = bufp->buffer + (begalt - old_buffer___17);
#line 2760
            if (fixup_alt_jump) {
#line 2760
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___17);
            }
#line 2760
            if (laststart) {
#line 2760
              laststart = bufp->buffer + (laststart - old_buffer___17);
            }
#line 2760
            if (pending_exact) {
#line 2760
              pending_exact = bufp->buffer + (pending_exact - old_buffer___17);
            }
          }
#line 2760
          goto while_break___72;
        }
        while_break___72: /* CIL Label */ ;
        }
      }
      while_break___71: /* CIL Label */ ;
      }
#line 2760
      tmp___104 = b;
#line 2760
      b ++;
#line 2760
      *tmp___104 = (unsigned char)26;
#line 2760
      goto while_break___70;
    }
    while_break___70: /* CIL Label */ ;
    }
#line 2761
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 2764
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2765
      goto normal_char;
    }
    {
#line 2766
    while (1) {
      while_continue___73: /* CIL Label */ ;
      {
#line 2766
      while (1) {
        while_continue___74: /* CIL Label */ ;
#line 2766
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2766
          goto while_break___74;
        }
        {
#line 2766
        while (1) {
          while_continue___75: /* CIL Label */ ;
#line 2766
          old_buffer___18 = bufp->buffer;
#line 2766
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2766
            return ((reg_errcode_t )15);
          }
#line 2766
          bufp->allocated <<= 1;
#line 2766
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2766
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2766
          tmp___105 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2766
          bufp->buffer = (unsigned char *)tmp___105;
          }
#line 2766
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2766
            return ((reg_errcode_t )12);
          }
#line 2766
          if ((unsigned long )old_buffer___18 != (unsigned long )bufp->buffer) {
#line 2766
            b = bufp->buffer + (b - old_buffer___18);
#line 2766
            begalt = bufp->buffer + (begalt - old_buffer___18);
#line 2766
            if (fixup_alt_jump) {
#line 2766
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___18);
            }
#line 2766
            if (laststart) {
#line 2766
              laststart = bufp->buffer + (laststart - old_buffer___18);
            }
#line 2766
            if (pending_exact) {
#line 2766
              pending_exact = bufp->buffer + (pending_exact - old_buffer___18);
            }
          }
#line 2766
          goto while_break___75;
        }
        while_break___75: /* CIL Label */ ;
        }
      }
      while_break___74: /* CIL Label */ ;
      }
#line 2766
      tmp___106 = b;
#line 2766
      b ++;
#line 2766
      *tmp___106 = (unsigned char)27;
#line 2766
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
#line 2767
    goto switch_break___0;
    case_98: /* CIL Label */ 
#line 2770
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2771
      goto normal_char;
    }
    {
#line 2772
    while (1) {
      while_continue___76: /* CIL Label */ ;
      {
#line 2772
      while (1) {
        while_continue___77: /* CIL Label */ ;
#line 2772
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2772
          goto while_break___77;
        }
        {
#line 2772
        while (1) {
          while_continue___78: /* CIL Label */ ;
#line 2772
          old_buffer___19 = bufp->buffer;
#line 2772
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2772
            return ((reg_errcode_t )15);
          }
#line 2772
          bufp->allocated <<= 1;
#line 2772
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2772
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2772
          tmp___107 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2772
          bufp->buffer = (unsigned char *)tmp___107;
          }
#line 2772
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2772
            return ((reg_errcode_t )12);
          }
#line 2772
          if ((unsigned long )old_buffer___19 != (unsigned long )bufp->buffer) {
#line 2772
            b = bufp->buffer + (b - old_buffer___19);
#line 2772
            begalt = bufp->buffer + (begalt - old_buffer___19);
#line 2772
            if (fixup_alt_jump) {
#line 2772
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___19);
            }
#line 2772
            if (laststart) {
#line 2772
              laststart = bufp->buffer + (laststart - old_buffer___19);
            }
#line 2772
            if (pending_exact) {
#line 2772
              pending_exact = bufp->buffer + (pending_exact - old_buffer___19);
            }
          }
#line 2772
          goto while_break___78;
        }
        while_break___78: /* CIL Label */ ;
        }
      }
      while_break___77: /* CIL Label */ ;
      }
#line 2772
      tmp___108 = b;
#line 2772
      b ++;
#line 2772
      *tmp___108 = (unsigned char)28;
#line 2772
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
#line 2773
    goto switch_break___0;
    case_66: /* CIL Label */ 
#line 2776
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2777
      goto normal_char;
    }
    {
#line 2778
    while (1) {
      while_continue___79: /* CIL Label */ ;
      {
#line 2778
      while (1) {
        while_continue___80: /* CIL Label */ ;
#line 2778
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2778
          goto while_break___80;
        }
        {
#line 2778
        while (1) {
          while_continue___81: /* CIL Label */ ;
#line 2778
          old_buffer___20 = bufp->buffer;
#line 2778
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2778
            return ((reg_errcode_t )15);
          }
#line 2778
          bufp->allocated <<= 1;
#line 2778
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2778
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2778
          tmp___109 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2778
          bufp->buffer = (unsigned char *)tmp___109;
          }
#line 2778
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2778
            return ((reg_errcode_t )12);
          }
#line 2778
          if ((unsigned long )old_buffer___20 != (unsigned long )bufp->buffer) {
#line 2778
            b = bufp->buffer + (b - old_buffer___20);
#line 2778
            begalt = bufp->buffer + (begalt - old_buffer___20);
#line 2778
            if (fixup_alt_jump) {
#line 2778
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___20);
            }
#line 2778
            if (laststart) {
#line 2778
              laststart = bufp->buffer + (laststart - old_buffer___20);
            }
#line 2778
            if (pending_exact) {
#line 2778
              pending_exact = bufp->buffer + (pending_exact - old_buffer___20);
            }
          }
#line 2778
          goto while_break___81;
        }
        while_break___81: /* CIL Label */ ;
        }
      }
      while_break___80: /* CIL Label */ ;
      }
#line 2778
      tmp___110 = b;
#line 2778
      b ++;
#line 2778
      *tmp___110 = (unsigned char)29;
#line 2778
      goto while_break___79;
    }
    while_break___79: /* CIL Label */ ;
    }
#line 2779
    goto switch_break___0;
    case_96: /* CIL Label */ 
#line 2782
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2783
      goto normal_char;
    }
    {
#line 2784
    while (1) {
      while_continue___82: /* CIL Label */ ;
      {
#line 2784
      while (1) {
        while_continue___83: /* CIL Label */ ;
#line 2784
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2784
          goto while_break___83;
        }
        {
#line 2784
        while (1) {
          while_continue___84: /* CIL Label */ ;
#line 2784
          old_buffer___21 = bufp->buffer;
#line 2784
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2784
            return ((reg_errcode_t )15);
          }
#line 2784
          bufp->allocated <<= 1;
#line 2784
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2784
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2784
          tmp___111 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2784
          bufp->buffer = (unsigned char *)tmp___111;
          }
#line 2784
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2784
            return ((reg_errcode_t )12);
          }
#line 2784
          if ((unsigned long )old_buffer___21 != (unsigned long )bufp->buffer) {
#line 2784
            b = bufp->buffer + (b - old_buffer___21);
#line 2784
            begalt = bufp->buffer + (begalt - old_buffer___21);
#line 2784
            if (fixup_alt_jump) {
#line 2784
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___21);
            }
#line 2784
            if (laststart) {
#line 2784
              laststart = bufp->buffer + (laststart - old_buffer___21);
            }
#line 2784
            if (pending_exact) {
#line 2784
              pending_exact = bufp->buffer + (pending_exact - old_buffer___21);
            }
          }
#line 2784
          goto while_break___84;
        }
        while_break___84: /* CIL Label */ ;
        }
      }
      while_break___83: /* CIL Label */ ;
      }
#line 2784
      tmp___112 = b;
#line 2784
      b ++;
#line 2784
      *tmp___112 = (unsigned char)11;
#line 2784
      goto while_break___82;
    }
    while_break___82: /* CIL Label */ ;
    }
#line 2785
    goto switch_break___0;
    case_39: /* CIL Label */ 
#line 2788
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2789
      goto normal_char;
    }
    {
#line 2790
    while (1) {
      while_continue___85: /* CIL Label */ ;
      {
#line 2790
      while (1) {
        while_continue___86: /* CIL Label */ ;
#line 2790
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2790
          goto while_break___86;
        }
        {
#line 2790
        while (1) {
          while_continue___87: /* CIL Label */ ;
#line 2790
          old_buffer___22 = bufp->buffer;
#line 2790
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2790
            return ((reg_errcode_t )15);
          }
#line 2790
          bufp->allocated <<= 1;
#line 2790
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2790
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2790
          tmp___113 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2790
          bufp->buffer = (unsigned char *)tmp___113;
          }
#line 2790
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2790
            return ((reg_errcode_t )12);
          }
#line 2790
          if ((unsigned long )old_buffer___22 != (unsigned long )bufp->buffer) {
#line 2790
            b = bufp->buffer + (b - old_buffer___22);
#line 2790
            begalt = bufp->buffer + (begalt - old_buffer___22);
#line 2790
            if (fixup_alt_jump) {
#line 2790
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___22);
            }
#line 2790
            if (laststart) {
#line 2790
              laststart = bufp->buffer + (laststart - old_buffer___22);
            }
#line 2790
            if (pending_exact) {
#line 2790
              pending_exact = bufp->buffer + (pending_exact - old_buffer___22);
            }
          }
#line 2790
          goto while_break___87;
        }
        while_break___87: /* CIL Label */ ;
        }
      }
      while_break___86: /* CIL Label */ ;
      }
#line 2790
      tmp___114 = b;
#line 2790
      b ++;
#line 2790
      *tmp___114 = (unsigned char)12;
#line 2790
      goto while_break___85;
    }
    while_break___85: /* CIL Label */ ;
    }
#line 2791
    goto switch_break___0;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 2795
    if (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2796
      goto normal_char;
    }
#line 2798
    c1 = (unsigned char )((int )c - 48);
#line 2800
    if ((regnum_t )c1 > regnum) {
      {
#line 2801
      free((void *)compile_stack.stack);
      }
#line 2801
      return ((reg_errcode_t )6);
    }
    {
#line 2804
    tmp___115 = group_in_compile_stack(compile_stack, (regnum_t )c1);
    }
#line 2804
    if (tmp___115) {
#line 2805
      goto normal_char;
    }
#line 2807
    laststart = b;
    {
#line 2808
    while (1) {
      while_continue___88: /* CIL Label */ ;
      {
#line 2808
      while (1) {
        while_continue___89: /* CIL Label */ ;
#line 2808
        if (! ((unsigned long )((b - bufp->buffer) + 2L) > bufp->allocated)) {
#line 2808
          goto while_break___89;
        }
        {
#line 2808
        while (1) {
          while_continue___90: /* CIL Label */ ;
#line 2808
          old_buffer___23 = bufp->buffer;
#line 2808
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2808
            return ((reg_errcode_t )15);
          }
#line 2808
          bufp->allocated <<= 1;
#line 2808
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2808
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2808
          tmp___116 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2808
          bufp->buffer = (unsigned char *)tmp___116;
          }
#line 2808
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2808
            return ((reg_errcode_t )12);
          }
#line 2808
          if ((unsigned long )old_buffer___23 != (unsigned long )bufp->buffer) {
#line 2808
            b = bufp->buffer + (b - old_buffer___23);
#line 2808
            begalt = bufp->buffer + (begalt - old_buffer___23);
#line 2808
            if (fixup_alt_jump) {
#line 2808
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___23);
            }
#line 2808
            if (laststart) {
#line 2808
              laststart = bufp->buffer + (laststart - old_buffer___23);
            }
#line 2808
            if (pending_exact) {
#line 2808
              pending_exact = bufp->buffer + (pending_exact - old_buffer___23);
            }
          }
#line 2808
          goto while_break___90;
        }
        while_break___90: /* CIL Label */ ;
        }
      }
      while_break___89: /* CIL Label */ ;
      }
#line 2808
      tmp___117 = b;
#line 2808
      b ++;
#line 2808
      *tmp___117 = (unsigned char)8;
#line 2808
      tmp___118 = b;
#line 2808
      b ++;
#line 2808
      *tmp___118 = c1;
#line 2808
      goto while_break___88;
    }
    while_break___88: /* CIL Label */ ;
    }
#line 2809
    goto switch_break___0;
    case_63___0: /* CIL Label */ 
    case_43___0: /* CIL Label */ 
#line 2814
    if (syntax & (1UL << 1)) {
#line 2815
      goto handle_plus;
    }
    normal_backslash: 
    switch_default: /* CIL Label */ 
#line 2824
    if (translate) {
#line 2824
      c = (unsigned char )*(translate + c);
    } else {
#line 2824
      c = c;
    }
#line 2825
    goto normal_char;
    switch_break___0: /* CIL Label */ ;
    }
#line 2827
    goto switch_break;
    normal_char: 
    switch_default___0: /* CIL Label */ 
#line 2834
    if (! pending_exact) {
#line 2834
      goto _L___23;
    } else
#line 2834
    if ((unsigned long )((pending_exact + (int )*pending_exact) + 1) != (unsigned long )b) {
#line 2834
      goto _L___23;
    } else
#line 2834
    if ((int )*pending_exact == (1 << 8) - 1) {
#line 2834
      goto _L___23;
    } else
#line 2834
    if ((int const   )*p == 42) {
#line 2834
      goto _L___23;
    } else
#line 2834
    if ((int const   )*p == 94) {
#line 2834
      goto _L___23;
    } else {
#line 2834
      if (syntax & (1UL << 1)) {
#line 2834
        if ((int const   )*p == 92) {
#line 2834
          if ((int const   )*(p + 1) == 43) {
#line 2834
            tmp___122 = 1;
          } else
#line 2834
          if ((int const   )*(p + 1) == 63) {
#line 2834
            tmp___122 = 1;
          } else {
#line 2834
            tmp___122 = 0;
          }
        } else {
#line 2834
          tmp___122 = 0;
        }
#line 2834
        tmp___124 = tmp___122;
      } else {
#line 2834
        if ((int const   )*p == 43) {
#line 2834
          tmp___123 = 1;
        } else
#line 2834
        if ((int const   )*p == 63) {
#line 2834
          tmp___123 = 1;
        } else {
#line 2834
          tmp___123 = 0;
        }
#line 2834
        tmp___124 = tmp___123;
      }
#line 2834
      if (tmp___124) {
#line 2834
        goto _L___23;
      } else
#line 2834
      if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2834
        if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2834
          tmp___126 = (int const   )*p == 123;
        } else {
#line 2834
          if ((int const   )*(p + 0) == 92) {
#line 2834
            if ((int const   )*(p + 1) == 123) {
#line 2834
              tmp___125 = 1;
            } else {
#line 2834
              tmp___125 = 0;
            }
          } else {
#line 2834
            tmp___125 = 0;
          }
#line 2834
          tmp___126 = tmp___125;
        }
#line 2834
        if (tmp___126) {
          _L___23: /* CIL Label */ 
#line 2854
          laststart = b;
          {
#line 2856
          while (1) {
            while_continue___91: /* CIL Label */ ;
            {
#line 2856
            while (1) {
              while_continue___92: /* CIL Label */ ;
#line 2856
              if (! ((unsigned long )((b - bufp->buffer) + 2L) > bufp->allocated)) {
#line 2856
                goto while_break___92;
              }
              {
#line 2856
              while (1) {
                while_continue___93: /* CIL Label */ ;
#line 2856
                old_buffer___24 = bufp->buffer;
#line 2856
                if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2856
                  return ((reg_errcode_t )15);
                }
#line 2856
                bufp->allocated <<= 1;
#line 2856
                if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2856
                  bufp->allocated = (unsigned long )(1L << 16);
                }
                {
#line 2856
                tmp___119 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2856
                bufp->buffer = (unsigned char *)tmp___119;
                }
#line 2856
                if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2856
                  return ((reg_errcode_t )12);
                }
#line 2856
                if ((unsigned long )old_buffer___24 != (unsigned long )bufp->buffer) {
#line 2856
                  b = bufp->buffer + (b - old_buffer___24);
#line 2856
                  begalt = bufp->buffer + (begalt - old_buffer___24);
#line 2856
                  if (fixup_alt_jump) {
#line 2856
                    fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___24);
                  }
#line 2856
                  if (laststart) {
#line 2856
                    laststart = bufp->buffer + (laststart - old_buffer___24);
                  }
#line 2856
                  if (pending_exact) {
#line 2856
                    pending_exact = bufp->buffer + (pending_exact - old_buffer___24);
                  }
                }
#line 2856
                goto while_break___93;
              }
              while_break___93: /* CIL Label */ ;
              }
            }
            while_break___92: /* CIL Label */ ;
            }
#line 2856
            tmp___120 = b;
#line 2856
            b ++;
#line 2856
            *tmp___120 = (unsigned char)2;
#line 2856
            tmp___121 = b;
#line 2856
            b ++;
#line 2856
            *tmp___121 = (unsigned char)0;
#line 2856
            goto while_break___91;
          }
          while_break___91: /* CIL Label */ ;
          }
#line 2857
          pending_exact = b - 1;
        }
      }
    }
    {
#line 2860
    while (1) {
      while_continue___94: /* CIL Label */ ;
      {
#line 2860
      while (1) {
        while_continue___95: /* CIL Label */ ;
#line 2860
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2860
          goto while_break___95;
        }
        {
#line 2860
        while (1) {
          while_continue___96: /* CIL Label */ ;
#line 2860
          old_buffer___25 = bufp->buffer;
#line 2860
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2860
            return ((reg_errcode_t )15);
          }
#line 2860
          bufp->allocated <<= 1;
#line 2860
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2860
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2860
          tmp___127 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2860
          bufp->buffer = (unsigned char *)tmp___127;
          }
#line 2860
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2860
            return ((reg_errcode_t )12);
          }
#line 2860
          if ((unsigned long )old_buffer___25 != (unsigned long )bufp->buffer) {
#line 2860
            b = bufp->buffer + (b - old_buffer___25);
#line 2860
            begalt = bufp->buffer + (begalt - old_buffer___25);
#line 2860
            if (fixup_alt_jump) {
#line 2860
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___25);
            }
#line 2860
            if (laststart) {
#line 2860
              laststart = bufp->buffer + (laststart - old_buffer___25);
            }
#line 2860
            if (pending_exact) {
#line 2860
              pending_exact = bufp->buffer + (pending_exact - old_buffer___25);
            }
          }
#line 2860
          goto while_break___96;
        }
        while_break___96: /* CIL Label */ ;
        }
      }
      while_break___95: /* CIL Label */ ;
      }
#line 2860
      tmp___128 = b;
#line 2860
      b ++;
#line 2860
      *tmp___128 = c;
#line 2860
      goto while_break___94;
    }
    while_break___94: /* CIL Label */ ;
    }
#line 2861
    *pending_exact = (unsigned char )((int )*pending_exact + 1);
#line 2862
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2869
  if (fixup_alt_jump) {
    {
#line 2870
    store_op1((re_opcode_t )14, fixup_alt_jump, (int )((b - fixup_alt_jump) - 3L));
    }
  }
#line 2872
  if (! (compile_stack.avail == 0U)) {
    {
#line 2873
    free((void *)compile_stack.stack);
    }
#line 2873
    return ((reg_errcode_t )8);
  }
#line 2877
  if (syntax & ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    {
#line 2878
    while (1) {
      while_continue___97: /* CIL Label */ ;
      {
#line 2878
      while (1) {
        while_continue___98: /* CIL Label */ ;
#line 2878
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2878
          goto while_break___98;
        }
        {
#line 2878
        while (1) {
          while_continue___99: /* CIL Label */ ;
#line 2878
          old_buffer___26 = bufp->buffer;
#line 2878
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2878
            return ((reg_errcode_t )15);
          }
#line 2878
          bufp->allocated <<= 1;
#line 2878
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2878
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2878
          tmp___129 = realloc((void *)bufp->buffer, (size_t )bufp->allocated);
#line 2878
          bufp->buffer = (unsigned char *)tmp___129;
          }
#line 2878
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2878
            return ((reg_errcode_t )12);
          }
#line 2878
          if ((unsigned long )old_buffer___26 != (unsigned long )bufp->buffer) {
#line 2878
            b = bufp->buffer + (b - old_buffer___26);
#line 2878
            begalt = bufp->buffer + (begalt - old_buffer___26);
#line 2878
            if (fixup_alt_jump) {
#line 2878
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___26);
            }
#line 2878
            if (laststart) {
#line 2878
              laststart = bufp->buffer + (laststart - old_buffer___26);
            }
#line 2878
            if (pending_exact) {
#line 2878
              pending_exact = bufp->buffer + (pending_exact - old_buffer___26);
            }
          }
#line 2878
          goto while_break___99;
        }
        while_break___99: /* CIL Label */ ;
        }
      }
      while_break___98: /* CIL Label */ ;
      }
#line 2878
      tmp___130 = b;
#line 2878
      b ++;
#line 2878
      *tmp___130 = (unsigned char)1;
#line 2878
      goto while_break___97;
    }
    while_break___97: /* CIL Label */ ;
    }
  }
  {
#line 2880
  free((void *)compile_stack.stack);
#line 2883
  bufp->used = (unsigned long )(b - bufp->buffer);
  }
#line 2934
  return ((reg_errcode_t )0);
}
}
#line 2941 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static void store_op1(re_opcode_t op , unsigned char *loc , int arg ) 
{ 


  {
#line 2947
  *loc = (unsigned char )op;
  {
#line 2948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2948
    *((loc + 1) + 0) = (unsigned char )(arg & 255);
#line 2948
    *((loc + 1) + 1) = (unsigned char )(arg >> 8);
#line 2948
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2949
  return;
}
}
#line 2954 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static void store_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ) 
{ 


  {
#line 2960
  *loc = (unsigned char )op;
  {
#line 2961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2961
    *((loc + 1) + 0) = (unsigned char )(arg1 & 255);
#line 2961
    *((loc + 1) + 1) = (unsigned char )(arg1 >> 8);
#line 2961
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2962
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2962
    *((loc + 3) + 0) = (unsigned char )(arg2 & 255);
#line 2962
    *((loc + 3) + 1) = (unsigned char )(arg2 >> 8);
#line 2962
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2963
  return;
}
}
#line 2969 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static void insert_op1(re_opcode_t op , unsigned char *loc , int arg , unsigned char *end ) 
{ 
  register unsigned char *pfrom ;
  register unsigned char *pto ;

  {
#line 2976
  pfrom = end;
#line 2977
  pto = end + 3;
  {
#line 2979
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2979
    if (! ((unsigned long )pfrom != (unsigned long )loc)) {
#line 2979
      goto while_break;
    }
#line 2980
    pto --;
#line 2980
    pfrom --;
#line 2980
    *pto = *pfrom;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2982
  store_op1(op, loc, arg);
  }
#line 2983
  return;
}
}
#line 2988 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static void insert_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ,
                       unsigned char *end ) 
{ 
  register unsigned char *pfrom ;
  register unsigned char *pto ;

  {
#line 2995
  pfrom = end;
#line 2996
  pto = end + 5;
  {
#line 2998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2998
    if (! ((unsigned long )pfrom != (unsigned long )loc)) {
#line 2998
      goto while_break;
    }
#line 2999
    pto --;
#line 2999
    pfrom --;
#line 2999
    *pto = *pfrom;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3001
  store_op2(op, loc, arg1, arg2);
  }
#line 3002
  return;
}
}
#line 3009 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static boolean at_begline_loc_p(char const   *pattern , char const   *p , reg_syntax_t syntax ) 
{ 
  char const   *prev ;
  boolean prev_prev_backslash ;
  int tmp ;
  int tmp___0 ;

  {
#line 3014
  prev = p - 2;
#line 3015
  if ((unsigned long )prev > (unsigned long )pattern) {
#line 3015
    if ((int const   )*(prev + -1) == 92) {
#line 3015
      tmp = 1;
    } else {
#line 3015
      tmp = 0;
    }
  } else {
#line 3015
    tmp = 0;
  }
#line 3015
  prev_prev_backslash = (boolean )tmp;
#line 3017
  if ((int const   )*prev == 40) {
#line 3017
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3017
      tmp___0 = 1;
    } else
#line 3017
    if (prev_prev_backslash) {
#line 3017
      tmp___0 = 1;
    } else {
#line 3017
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3017
  if ((int const   )*prev == 124) {
#line 3017
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3017
      tmp___0 = 1;
    } else
#line 3017
    if (prev_prev_backslash) {
#line 3017
      tmp___0 = 1;
    } else {
#line 3017
      tmp___0 = 0;
    }
  } else {
#line 3017
    tmp___0 = 0;
  }
#line 3017
  return ((boolean )tmp___0);
}
}
#line 3028 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static boolean at_endline_loc_p(char const   *p , char const   *pend , reg_syntax_t syntax ) 
{ 
  char const   *next ;
  boolean next_backslash ;
  char const   *next_next ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3033
  next = p;
#line 3034
  next_backslash = (boolean )((int const   )*next == 92);
#line 3035
  if ((unsigned long )(p + 1) < (unsigned long )pend) {
#line 3035
    tmp = p + 1;
  } else {
#line 3035
    tmp = (char const   *)0;
  }
#line 3035
  next_next = tmp;
#line 3037
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3037
    tmp___1 = (int const   )*next == 41;
  } else {
#line 3037
    if (next_backslash) {
#line 3037
      if (next_next) {
#line 3037
        if ((int const   )*next_next == 41) {
#line 3037
          tmp___0 = 1;
        } else {
#line 3037
          tmp___0 = 0;
        }
      } else {
#line 3037
        tmp___0 = 0;
      }
    } else {
#line 3037
      tmp___0 = 0;
    }
#line 3037
    tmp___1 = tmp___0;
  }
#line 3037
  if (tmp___1) {
#line 3037
    tmp___4 = 1;
  } else {
#line 3037
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3037
      tmp___3 = (int const   )*next == 124;
    } else {
#line 3037
      if (next_backslash) {
#line 3037
        if (next_next) {
#line 3037
          if ((int const   )*next_next == 124) {
#line 3037
            tmp___2 = 1;
          } else {
#line 3037
            tmp___2 = 0;
          }
        } else {
#line 3037
          tmp___2 = 0;
        }
      } else {
#line 3037
        tmp___2 = 0;
      }
#line 3037
      tmp___3 = tmp___2;
    }
#line 3037
    if (tmp___3) {
#line 3037
      tmp___4 = 1;
    } else {
#line 3037
      tmp___4 = 0;
    }
  }
#line 3037
  return ((boolean )tmp___4);
}
}
#line 3050 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static boolean group_in_compile_stack(compile_stack_type compile_stack , regnum_t regnum ) 
{ 
  int this_element ;

  {
#line 3057
  this_element = (int )(compile_stack.avail - 1U);
  {
#line 3057
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3057
    if (! (this_element >= 0)) {
#line 3057
      goto while_break;
    }
#line 3060
    if ((compile_stack.stack + this_element)->regnum == regnum) {
#line 3061
      return ((boolean )1);
    }
#line 3057
    this_element --;
  }
  while_break: /* CIL Label */ ;
  }
#line 3063
  return ((boolean )0);
}
}
#line 3078 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static reg_errcode_t compile_range(char const   **p_ptr , char const   *pend , char *translate ,
                                   reg_syntax_t syntax , unsigned char *b ) 
{ 
  unsigned int this_char ;
  char const   *p ;
  unsigned int range_start ;
  unsigned int range_end ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 3087
  p = *p_ptr;
#line 3090
  if ((unsigned long )p == (unsigned long )pend) {
#line 3091
    return ((reg_errcode_t )11);
  }
#line 3101
  range_start = (unsigned int )*((unsigned char const   *)p + -2);
#line 3102
  range_end = (unsigned int )*((unsigned char const   *)p + 0);
#line 3106
  (*p_ptr) ++;
#line 3109
  if (range_start > range_end) {
#line 3110
    if (syntax & ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3110
      tmp = 11;
    } else {
#line 3110
      tmp = 0;
    }
#line 3110
    return ((reg_errcode_t )tmp);
  }
#line 3116
  this_char = range_start;
  {
#line 3116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3116
    if (! (this_char <= range_end)) {
#line 3116
      goto while_break;
    }
#line 3118
    if (translate) {
#line 3118
      tmp___0 = (unsigned int )*(translate + (unsigned char )this_char);
    } else {
#line 3118
      tmp___0 = this_char;
    }
#line 3118
    if (translate) {
#line 3118
      tmp___1 = (unsigned int )*(translate + (unsigned char )this_char);
    } else {
#line 3118
      tmp___1 = this_char;
    }
#line 3118
    *(b + (int )((unsigned char )tmp___0) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )tmp___0) / 8) | (1 << (int )((unsigned char )tmp___1) % 8));
#line 3116
    this_char ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3121
  return ((reg_errcode_t )0);
}
}
#line 3137 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
int re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  int j ;
  int k ;
  fail_stack_type fail_stack ;
  char *destination ;
  register char *fastmap ;
  unsigned char *pattern ;
  unsigned char *p ;
  register unsigned char *pend ;
  boolean path_can_be_null ;
  boolean succeed_n_p ;
  void *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  int fastmap_newline ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;

  {
#line 3149
  fastmap = bufp->fastmap;
#line 3150
  pattern = bufp->buffer;
#line 3151
  p = pattern;
#line 3152
  pend = pattern + bufp->used;
#line 3164
  path_can_be_null = (boolean )1;
#line 3167
  succeed_n_p = (boolean )0;
  {
#line 3171
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3171
    tmp = __builtin_alloca(5UL * sizeof(fail_stack_elt_t ));
#line 3171
    fail_stack.stack = (fail_stack_elt_t *)tmp;
    }
#line 3171
    if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 3171
      return (-2);
    }
#line 3171
    fail_stack.size = 5U;
#line 3171
    fail_stack.avail = 0U;
#line 3171
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3172
  memset((void *)fastmap, '\000', (size_t )(1 << 8));
#line 3173
  bufp->fastmap_accurate = 1U;
#line 3174
  bufp->can_be_null = 0U;
  }
  {
#line 3176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3178
    if ((unsigned long )p == (unsigned long )pend) {
#line 3178
      goto _L;
    } else
#line 3178
    if ((int )*p == 1) {
      _L: /* CIL Label */ 
#line 3181
      if (! (fail_stack.avail == 0U)) {
#line 3183
        bufp->can_be_null |= (unsigned int )path_can_be_null;
#line 3186
        path_can_be_null = (boolean )1;
#line 3188
        (fail_stack.avail) --;
#line 3188
        p = (fail_stack.stack + fail_stack.avail)->pointer;
#line 3190
        goto while_continue___0;
      } else {
#line 3193
        goto while_break___0;
      }
    }
#line 3199
    tmp___0 = p;
#line 3199
    p ++;
    {
#line 3207
    if ((unsigned int )((re_opcode_t )*tmp___0) == 8U) {
#line 3207
      goto case_8;
    }
#line 3215
    if ((unsigned int )((re_opcode_t )*tmp___0) == 2U) {
#line 3215
      goto case_2;
    }
#line 3220
    if ((unsigned int )((re_opcode_t )*tmp___0) == 4U) {
#line 3220
      goto case_4;
    }
#line 3227
    if ((unsigned int )((re_opcode_t )*tmp___0) == 5U) {
#line 3227
      goto case_5;
    }
#line 3238
    if ((unsigned int )((re_opcode_t )*tmp___0) == 24U) {
#line 3238
      goto case_24;
    }
#line 3245
    if ((unsigned int )((re_opcode_t )*tmp___0) == 25U) {
#line 3245
      goto case_25;
    }
#line 3252
    if ((unsigned int )((re_opcode_t )*tmp___0) == 3U) {
#line 3252
      goto case_3;
    }
#line 3310
    if ((unsigned int )((re_opcode_t )*tmp___0) == 20U) {
#line 3310
      goto case_20;
    }
#line 3310
    if ((unsigned int )((re_opcode_t )*tmp___0) == 27U) {
#line 3310
      goto case_20;
    }
#line 3310
    if ((unsigned int )((re_opcode_t )*tmp___0) == 26U) {
#line 3310
      goto case_20;
    }
#line 3310
    if ((unsigned int )((re_opcode_t )*tmp___0) == 29U) {
#line 3310
      goto case_20;
    }
#line 3310
    if ((unsigned int )((re_opcode_t )*tmp___0) == 28U) {
#line 3310
      goto case_20;
    }
#line 3310
    if ((unsigned int )((re_opcode_t )*tmp___0) == 12U) {
#line 3310
      goto case_20;
    }
#line 3310
    if ((unsigned int )((re_opcode_t )*tmp___0) == 11U) {
#line 3310
      goto case_20;
    }
#line 3310
    if ((unsigned int )((re_opcode_t )*tmp___0) == 10U) {
#line 3310
      goto case_20;
    }
#line 3310
    if ((unsigned int )((re_opcode_t )*tmp___0) == 9U) {
#line 3310
      goto case_20;
    }
#line 3310
    if ((unsigned int )((re_opcode_t )*tmp___0) == 0U) {
#line 3310
      goto case_20;
    }
#line 3319
    if ((unsigned int )((re_opcode_t )*tmp___0) == 19U) {
#line 3319
      goto case_19;
    }
#line 3319
    if ((unsigned int )((re_opcode_t )*tmp___0) == 14U) {
#line 3319
      goto case_19;
    }
#line 3319
    if ((unsigned int )((re_opcode_t )*tmp___0) == 13U) {
#line 3319
      goto case_19;
    }
#line 3319
    if ((unsigned int )((re_opcode_t )*tmp___0) == 18U) {
#line 3319
      goto case_19;
    }
#line 3319
    if ((unsigned int )((re_opcode_t )*tmp___0) == 17U) {
#line 3319
      goto case_19;
    }
#line 3319
    if ((unsigned int )((re_opcode_t )*tmp___0) == 22U) {
#line 3319
      goto case_19;
    }
#line 3347
    if ((unsigned int )((re_opcode_t )*tmp___0) == 16U) {
#line 3347
      goto handle_on_failure_jump;
    }
#line 3347
    if ((unsigned int )((re_opcode_t )*tmp___0) == 15U) {
#line 3347
      goto handle_on_failure_jump;
    }
#line 3378
    if ((unsigned int )((re_opcode_t )*tmp___0) == 21U) {
#line 3378
      goto case_21;
    }
#line 3393
    if ((unsigned int )((re_opcode_t )*tmp___0) == 23U) {
#line 3393
      goto case_23;
    }
#line 3399
    if ((unsigned int )((re_opcode_t )*tmp___0) == 7U) {
#line 3399
      goto case_7;
    }
#line 3399
    if ((unsigned int )((re_opcode_t )*tmp___0) == 6U) {
#line 3399
      goto case_7;
    }
#line 3404
    goto switch_default;
    case_8: /* CIL Label */ 
#line 3208
    bufp->can_be_null = 1U;
#line 3209
    goto done;
    case_2: /* CIL Label */ 
#line 3216
    *(fastmap + *(p + 1)) = (char)1;
#line 3217
    goto switch_break;
    case_4: /* CIL Label */ 
#line 3221
    tmp___1 = p;
#line 3221
    p ++;
#line 3221
    j = (int )*tmp___1 * 8 - 1;
    {
#line 3221
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3221
      if (! (j >= 0)) {
#line 3221
        goto while_break___1;
      }
#line 3222
      if ((int )*(p + j / 8) & (1 << j % 8)) {
#line 3223
        *(fastmap + j) = (char)1;
      }
#line 3221
      j --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3224
    goto switch_break;
    case_5: /* CIL Label */ 
#line 3229
    j = (int )*p * 8;
    {
#line 3229
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3229
      if (! (j < 1 << 8)) {
#line 3229
        goto while_break___2;
      }
#line 3230
      *(fastmap + j) = (char)1;
#line 3229
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3232
    tmp___2 = p;
#line 3232
    p ++;
#line 3232
    j = (int )*tmp___2 * 8 - 1;
    {
#line 3232
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3232
      if (! (j >= 0)) {
#line 3232
        goto while_break___3;
      }
#line 3233
      if (! ((int )*(p + j / 8) & (1 << j % 8))) {
#line 3234
        *(fastmap + j) = (char)1;
      }
#line 3232
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 3235
    goto switch_break;
    case_24: /* CIL Label */ 
#line 3239
    j = 0;
    {
#line 3239
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3239
      if (! (j < 1 << 8)) {
#line 3239
        goto while_break___4;
      }
#line 3240
      if ((int )*(re_syntax_table + j) == 1) {
#line 3241
        *(fastmap + j) = (char)1;
      }
#line 3239
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3242
    goto switch_break;
    case_25: /* CIL Label */ 
#line 3246
    j = 0;
    {
#line 3246
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3246
      if (! (j < 1 << 8)) {
#line 3246
        goto while_break___5;
      }
#line 3247
      if ((int )*(re_syntax_table + j) != 1) {
#line 3248
        *(fastmap + j) = (char)1;
      }
#line 3246
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 3249
    goto switch_break;
    case_3: /* CIL Label */ 
#line 3254
    fastmap_newline = (int )*(fastmap + '\n');
#line 3257
    j = 0;
    {
#line 3257
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3257
      if (! (j < 1 << 8)) {
#line 3257
        goto while_break___6;
      }
#line 3258
      *(fastmap + j) = (char)1;
#line 3257
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 3261
    if (! (bufp->syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3262
      *(fastmap + '\n') = (char )fastmap_newline;
    } else
#line 3266
    if (bufp->can_be_null) {
#line 3267
      goto done;
    }
#line 3270
    goto switch_break;
    case_20: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 3311
    goto while_continue___0;
    case_19: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_22: /* CIL Label */ 
    {
#line 3320
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 3320
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 3320
        j = (int )*p & 255;
#line 3320
        j += (int )((signed char )*(p + 1)) << 8;
#line 3320
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 3320
      p += 2;
#line 3320
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 3321
    p += j;
#line 3322
    if (j > 0) {
#line 3323
      goto while_continue___0;
    }
#line 3330
    if ((unsigned int )((re_opcode_t )*p) != 15U) {
#line 3330
      if ((unsigned int )((re_opcode_t )*p) != 21U) {
#line 3332
        goto while_continue___0;
      }
    }
#line 3334
    p ++;
    {
#line 3335
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 3335
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 3335
        j = (int )*p & 255;
#line 3335
        j += (int )((signed char )*(p + 1)) << 8;
#line 3335
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 3335
      p += 2;
#line 3335
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 3336
    p += j;
#line 3339
    if (! (fail_stack.avail == 0U)) {
#line 3339
      if ((unsigned long )(fail_stack.stack + (fail_stack.avail - 1U))->pointer == (unsigned long )p) {
#line 3341
        (fail_stack.avail) --;
      }
    }
#line 3343
    goto while_continue___0;
    handle_on_failure_jump: 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    {
#line 3349
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 3349
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 3349
        j = (int )*p & 255;
#line 3349
        j += (int )((signed char )*(p + 1)) << 8;
#line 3349
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 3349
      p += 2;
#line 3349
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 3358
    if ((unsigned long )(p + j) < (unsigned long )pend) {
#line 3360
      if (fail_stack.avail == fail_stack.size) {
#line 3360
        if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
#line 3360
          tmp___12 = 0;
        } else {
          {
#line 3360
          tmp___9 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
#line 3360
          destination = (char *)tmp___9;
#line 3360
          tmp___10 = memcpy((void */* __restrict  */)destination, (void const   */* __restrict  */)fail_stack.stack,
                            (size_t )((unsigned long )fail_stack.size * sizeof(fail_stack_elt_t )));
#line 3360
          fail_stack.stack = (fail_stack_elt_t *)tmp___10;
          }
#line 3360
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 3360
            tmp___11 = 0;
          } else {
#line 3360
            fail_stack.size <<= 1;
#line 3360
            tmp___11 = 1;
          }
#line 3360
          tmp___12 = tmp___11;
        }
#line 3360
        if (tmp___12) {
#line 3360
          tmp___7 = fail_stack.avail;
#line 3360
          (fail_stack.avail) ++;
#line 3360
          (fail_stack.stack + tmp___7)->pointer = p + j;
#line 3360
          tmp___8 = 1;
        } else {
#line 3360
          tmp___8 = 0;
        }
      } else {
#line 3360
        tmp___7 = fail_stack.avail;
#line 3360
        (fail_stack.avail) ++;
#line 3360
        (fail_stack.stack + tmp___7)->pointer = p + j;
#line 3360
        tmp___8 = 1;
      }
#line 3360
      if (! tmp___8) {
#line 3363
        return (-2);
      }
    } else {
#line 3367
      bufp->can_be_null = 1U;
    }
#line 3369
    if (succeed_n_p) {
      {
#line 3371
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 3371
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 3371
          k = (int )*p & 255;
#line 3371
          k += (int )((signed char )*(p + 1)) << 8;
#line 3371
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 3371
        p += 2;
#line 3371
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 3372
      succeed_n_p = (boolean )0;
    }
#line 3375
    goto while_continue___0;
    case_21: /* CIL Label */ 
#line 3380
    p += 2;
    {
#line 3383
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
#line 3383
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 3383
        k = (int )*p & 255;
#line 3383
        k += (int )((signed char )*(p + 1)) << 8;
#line 3383
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 3383
      p += 2;
#line 3383
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 3384
    if (k == 0) {
#line 3386
      p -= 4;
#line 3387
      succeed_n_p = (boolean )1;
#line 3388
      goto handle_on_failure_jump;
    }
#line 3390
    goto while_continue___0;
    case_23: /* CIL Label */ 
#line 3394
    p += 4;
#line 3395
    goto while_continue___0;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 3400
    p += 2;
#line 3401
    goto while_continue___0;
    switch_default: /* CIL Label */ 
    {
#line 3405
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 3414
    path_can_be_null = (boolean )0;
#line 3415
    p = pend;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3420
  bufp->can_be_null |= (unsigned int )path_can_be_null;
  done: ;
#line 3424
  return (0);
}
}
#line 3443 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                      unsigned int num_regs , regoff_t *starts , regoff_t *ends ) 
{ 
  regoff_t *tmp ;

  {
#line 3450
  if (num_regs) {
#line 3452
    bufp->regs_allocated = 1U;
#line 3453
    regs->num_regs = num_regs;
#line 3454
    regs->start = starts;
#line 3455
    regs->end = ends;
  } else {
#line 3459
    bufp->regs_allocated = 0U;
#line 3460
    regs->num_regs = 0U;
#line 3461
    tmp = (regoff_t *)0;
#line 3461
    regs->end = tmp;
#line 3461
    regs->start = tmp;
  }
#line 3463
  return;
}
}
#line 3473 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
int re_search(struct re_pattern_buffer *bufp , char const   *string , int size , int startpos ,
              int range , struct re_registers *regs ) 
{ 
  int tmp ;

  {
  {
#line 3480
  tmp = re_search_2(bufp, (char const   *)((void *)0), 0, string, size, startpos,
                    range, regs, size);
  }
#line 3480
  return (tmp);
}
}
#line 3509 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
int re_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                char const   *string2 , int size2 , int startpos , int range , struct re_registers *regs ,
                int stop ) 
{ 
  int val ;
  register char *fastmap ;
  register char *translate ;
  int total_size ;
  int endpos ;
  int tmp ;
  register char const   *d ;
  register int lim ;
  int irange ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  register char c ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3520
  fastmap = bufp->fastmap;
#line 3521
  translate = bufp->translate;
#line 3522
  total_size = size1 + size2;
#line 3523
  endpos = startpos + range;
#line 3526
  if (startpos < 0) {
#line 3527
    return (-1);
  } else
#line 3526
  if (startpos > total_size) {
#line 3527
    return (-1);
  }
#line 3532
  if (endpos < 0) {
#line 3533
    range = 0 - startpos;
  } else
#line 3534
  if (endpos > total_size) {
#line 3535
    range = total_size - startpos;
  }
#line 3539
  if (bufp->used > 0UL) {
#line 3539
    if (range > 0) {
#line 3539
      if ((unsigned int )((re_opcode_t )*(bufp->buffer + 0)) == 11U) {
#line 3539
        goto _L;
      } else
#line 3539
      if ((unsigned int )((re_opcode_t )*(bufp->buffer + 0)) == 9U) {
#line 3539
        if (! bufp->newline_anchor) {
          _L: /* CIL Label */ 
#line 3545
          if (startpos > 0) {
#line 3546
            return (-1);
          } else {
#line 3548
            range = 1;
          }
        }
      }
    }
  }
#line 3563
  if (fastmap) {
#line 3563
    if (! bufp->fastmap_accurate) {
      {
#line 3564
      tmp = re_compile_fastmap(bufp);
      }
#line 3564
      if (tmp == -2) {
#line 3565
        return (-2);
      }
    }
  }
  {
#line 3568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3574
    if (fastmap) {
#line 3574
      if (startpos < total_size) {
#line 3574
        if (! bufp->can_be_null) {
#line 3576
          if (range > 0) {
#line 3579
            lim = 0;
#line 3580
            irange = range;
#line 3582
            if (startpos < size1) {
#line 3582
              if (startpos + range >= size1) {
#line 3583
                lim = range - (size1 - startpos);
              }
            }
#line 3585
            if (startpos >= size1) {
#line 3585
              tmp___0 = string2 - size1;
            } else {
#line 3585
              tmp___0 = string1;
            }
#line 3585
            d = tmp___0 + startpos;
#line 3589
            if (translate) {
              {
#line 3590
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 3590
                if (range > lim) {
#line 3590
                  tmp___1 = d;
#line 3590
                  d ++;
#line 3590
                  if (*(fastmap + (unsigned char )*(translate + (unsigned char )*tmp___1))) {
#line 3590
                    goto while_break___0;
                  }
                } else {
#line 3590
                  goto while_break___0;
                }
#line 3593
                range --;
              }
              while_break___0: /* CIL Label */ ;
              }
            } else {
              {
#line 3595
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 3595
                if (range > lim) {
#line 3595
                  tmp___2 = d;
#line 3595
                  d ++;
#line 3595
                  if (*(fastmap + (unsigned char )*tmp___2)) {
#line 3595
                    goto while_break___1;
                  }
                } else {
#line 3595
                  goto while_break___1;
                }
#line 3596
                range --;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
#line 3598
            startpos += irange - range;
          } else {
#line 3602
            if (size1 == 0) {
#line 3602
              tmp___3 = (int const   )*(string2 + (startpos - size1));
            } else
#line 3602
            if (startpos >= size1) {
#line 3602
              tmp___3 = (int const   )*(string2 + (startpos - size1));
            } else {
#line 3602
              tmp___3 = (int const   )*(string1 + startpos);
            }
#line 3602
            c = (char )tmp___3;
#line 3606
            if (translate) {
#line 3606
              tmp___4 = (int )*(translate + (unsigned char )c);
            } else {
#line 3606
              tmp___4 = (int )c;
            }
#line 3606
            if (! *(fastmap + (unsigned char )tmp___4)) {
#line 3607
              goto advance;
            }
          }
        }
      }
    }
#line 3612
    if (range >= 0) {
#line 3612
      if (startpos == total_size) {
#line 3612
        if (fastmap) {
#line 3612
          if (! bufp->can_be_null) {
#line 3614
            return (-1);
          }
        }
      }
    }
    {
#line 3616
    val = re_match_2_internal(bufp, string1, size1, string2, size2, startpos, regs,
                              stop);
    }
#line 3624
    if (val >= 0) {
#line 3625
      return (startpos);
    }
#line 3627
    if (val == -2) {
#line 3628
      return (-2);
    }
    advance: 
#line 3631
    if (! range) {
#line 3632
      goto while_break;
    } else
#line 3633
    if (range > 0) {
#line 3635
      range --;
#line 3636
      startpos ++;
    } else {
#line 3640
      range ++;
#line 3641
      startpos --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3644
  return (-1);
}
}
#line 3734 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
int re_match(struct re_pattern_buffer *bufp , char const   *string , int size , int pos ,
             struct re_registers *regs ) 
{ 
  int result ;
  int tmp ;

  {
  {
#line 3741
  tmp = re_match_2_internal(bufp, (char const   *)((void *)0), 0, string, size, pos,
                            regs, size);
#line 3741
  result = tmp;
  }
#line 3748
  return (result);
}
}
#line 3755
static boolean group_match_null_string_p(unsigned char **p , unsigned char *end ,
                                         register_info_type *reg_info ) ;
#line 3758
static boolean alt_match_null_string_p(unsigned char *p , unsigned char *end , register_info_type *reg_info ) ;
#line 3761
static boolean common_op_match_null_string_p(unsigned char **p , unsigned char *end ,
                                             register_info_type *reg_info ) ;
#line 3764
static int bcmp_translate(char const   *s1 , char const   *s2 , int len , char *translate ) ;
#line 3780 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
int re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
               char const   *string2 , int size2 , int pos , struct re_registers *regs ,
               int stop ) 
{ 
  int result ;
  int tmp ;

  {
  {
#line 3789
  tmp = re_match_2_internal(bufp, string1, size1, string2, size2, pos, regs, stop);
#line 3789
  result = tmp;
  }
#line 3796
  return (result);
}
}
#line 3804 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static int re_match_2_internal(struct re_pattern_buffer *bufp , char const   *string1 ,
                               int size1 , char const   *string2 , int size2 , int pos ,
                               struct re_registers *regs , int stop ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  char const   *end1 ;
  char const   *end2 ;
  char const   *end_match_1 ;
  char const   *end_match_2 ;
  char const   *d ;
  char const   *dend ;
  unsigned char *p ;
  register unsigned char *pend ;
  unsigned char *just_past_start_mem ;
  char *translate ;
  fail_stack_type fail_stack ;
  size_t num_regs ;
  active_reg_t lowest_active_reg ;
  active_reg_t highest_active_reg ;
  char const   **regstart ;
  char const   **regend ;
  char const   **old_regstart ;
  char const   **old_regend ;
  register_info_type *reg_info ;
  unsigned int best_regs_set ;
  char const   **best_regstart ;
  char const   **best_regend ;
  char const   *match_end ;
  int set_regs_matched_done ;
  char const   **reg_dummy ;
  register_info_type *reg_info_dummy ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  boolean same_str_p ;
  int tmp___12 ;
  boolean best_match_p ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  regoff_t tmp___17 ;
  regoff_t tmp___18 ;
  regoff_t tmp___19 ;
  size_t tmp___20 ;
  regoff_t tmp___21 ;
  char const   *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  char const   *tmp___25 ;
  unsigned char *tmp___26 ;
  char const   *tmp___27 ;
  unsigned char *tmp___28 ;
  active_reg_t r ;
  unsigned int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  active_reg_t r___0 ;
  unsigned int tmp___32 ;
  register unsigned char c ;
  boolean not ;
  active_reg_t r___1 ;
  unsigned int tmp___33 ;
  boolean tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  unsigned char r___2 ;
  boolean is_a_jump_n ;
  unsigned char *tmp___37 ;
  unsigned int r___3 ;
  char *destination ;
  active_reg_t this_reg ;
  void *tmp___38 ;
  void *tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  register char const   *d2 ;
  register char const   *dend2 ;
  int regno ;
  unsigned char *tmp___49 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  active_reg_t r___4 ;
  unsigned int tmp___57 ;
  char const   *tmp___58 ;
  int tmp___59 ;
  char const   *tmp___60 ;
  char *destination___0 ;
  active_reg_t this_reg___0 ;
  void *tmp___61 ;
  void *tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  unsigned int tmp___65 ;
  unsigned int tmp___66 ;
  unsigned int tmp___67 ;
  unsigned int tmp___68 ;
  unsigned int tmp___69 ;
  unsigned int tmp___70 ;
  unsigned int tmp___71 ;
  char *destination___1 ;
  active_reg_t this_reg___1 ;
  void *tmp___72 ;
  void *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  unsigned int tmp___76 ;
  unsigned int tmp___77 ;
  unsigned int tmp___78 ;
  unsigned int tmp___79 ;
  unsigned int tmp___80 ;
  unsigned int tmp___81 ;
  unsigned int tmp___82 ;
  register unsigned char *p2 ;
  register unsigned char c___0 ;
  int tmp___83 ;
  int not___0 ;
  int idx ;
  int idx___0 ;
  active_reg_t dummy_low_reg ;
  active_reg_t dummy_high_reg ;
  unsigned char *pdummy ;
  char const   *sdummy ;
  active_reg_t this_reg___2 ;
  unsigned char const   *string_temp ;
  char *destination___2 ;
  active_reg_t this_reg___3 ;
  void *tmp___84 ;
  void *tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  unsigned int tmp___88 ;
  unsigned int tmp___89 ;
  unsigned int tmp___90 ;
  unsigned int tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  unsigned int tmp___94 ;
  char *destination___3 ;
  active_reg_t this_reg___4 ;
  void *tmp___95 ;
  void *tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  unsigned int tmp___99 ;
  unsigned int tmp___100 ;
  unsigned int tmp___101 ;
  unsigned int tmp___102 ;
  unsigned int tmp___103 ;
  unsigned int tmp___104 ;
  unsigned int tmp___105 ;
  boolean prevchar ;
  boolean thischar ;
  char const   *tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  boolean prevchar___0 ;
  boolean thischar___0 ;
  char const   *tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  char const   *tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  char const   *tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  active_reg_t r___5 ;
  unsigned int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  active_reg_t r___6 ;
  unsigned int tmp___131 ;
  active_reg_t this_reg___5 ;
  unsigned char const   *string_temp___0 ;
  boolean is_a_jump_n___0 ;
  void *__cil_tmp214 ;
  int __cil_tmp215 ;
  void *__cil_tmp216 ;
  int __cil_tmp217 ;
  void *__cil_tmp218 ;
  int __cil_tmp219 ;
  void *__cil_tmp220 ;
  int __cil_tmp221 ;
  void *__cil_tmp222 ;
  int __cil_tmp223 ;
  void *__cil_tmp224 ;
  int __cil_tmp225 ;
  void *__cil_tmp226 ;
  int __cil_tmp227 ;
  void *__cil_tmp228 ;
  int __cil_tmp229 ;

  {
#line 3828
  p = bufp->buffer;
#line 3829
  pend = p + bufp->used;
#line 3833
  just_past_start_mem = (unsigned char *)0;
#line 3836
  translate = bufp->translate;
#line 3864
  num_regs = bufp->re_nsub + 1U;
#line 3867
  lowest_active_reg = (active_reg_t )((1 << 8) + 1);
#line 3868
  highest_active_reg = (active_reg_t )(1 << 8);
#line 3904
  best_regs_set = 0U;
#line 3917
  match_end = (char const   *)((void *)0);
#line 3920
  set_regs_matched_done = 0;
  {
#line 3935
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3935
    tmp = __builtin_alloca(5UL * sizeof(fail_stack_elt_t ));
#line 3935
    fail_stack.stack = (fail_stack_elt_t *)tmp;
    }
#line 3935
    if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 3935
      return (-2);
    }
#line 3935
    fail_stack.size = 5U;
#line 3935
    fail_stack.avail = 0U;
#line 3935
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 3943
  if (bufp->re_nsub) {
    {
#line 3945
    tmp___0 = __builtin_alloca((unsigned long )num_regs * sizeof(char const   *));
#line 3945
    regstart = (char const   **)tmp___0;
#line 3946
    tmp___1 = __builtin_alloca((unsigned long )num_regs * sizeof(char const   *));
#line 3946
    regend = (char const   **)tmp___1;
#line 3947
    tmp___2 = __builtin_alloca((unsigned long )num_regs * sizeof(char const   *));
#line 3947
    old_regstart = (char const   **)tmp___2;
#line 3948
    tmp___3 = __builtin_alloca((unsigned long )num_regs * sizeof(char const   *));
#line 3948
    old_regend = (char const   **)tmp___3;
#line 3949
    tmp___4 = __builtin_alloca((unsigned long )num_regs * sizeof(char const   *));
#line 3949
    best_regstart = (char const   **)tmp___4;
#line 3950
    tmp___5 = __builtin_alloca((unsigned long )num_regs * sizeof(char const   *));
#line 3950
    best_regend = (char const   **)tmp___5;
#line 3951
    tmp___6 = __builtin_alloca((unsigned long )num_regs * sizeof(register_info_type ));
#line 3951
    reg_info = (register_info_type *)tmp___6;
#line 3952
    tmp___7 = __builtin_alloca((unsigned long )num_regs * sizeof(char const   *));
#line 3952
    reg_dummy = (char const   **)tmp___7;
#line 3953
    tmp___8 = __builtin_alloca((unsigned long )num_regs * sizeof(register_info_type ));
#line 3953
    reg_info_dummy = (register_info_type *)tmp___8;
    }
#line 3955
    if (regstart) {
#line 3955
      if (regend) {
#line 3955
        if (old_regstart) {
#line 3955
          if (old_regend) {
#line 3955
            if (reg_info) {
#line 3955
              if (best_regstart) {
#line 3955
                if (best_regend) {
#line 3955
                  if (reg_dummy) {
#line 3955
                    if (! reg_info_dummy) {
#line 3955
                      goto _L___6;
                    }
                  } else {
#line 3955
                    goto _L___6;
                  }
                } else {
#line 3955
                  goto _L___6;
                }
              } else {
#line 3955
                goto _L___6;
              }
            } else {
#line 3955
              goto _L___6;
            }
          } else {
#line 3955
            goto _L___6;
          }
        } else {
#line 3955
          goto _L___6;
        }
      } else {
#line 3955
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
      {
#line 3958
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3958
        regstart = (char const   **)((void *)0);
#line 3958
        regend = (char const   **)((void *)0);
#line 3958
        old_regstart = (char const   **)((void *)0);
#line 3958
        old_regend = (char const   **)((void *)0);
#line 3958
        best_regstart = (char const   **)((void *)0);
#line 3958
        best_regend = (char const   **)((void *)0);
#line 3958
        reg_info = (register_info_type *)((void *)0);
#line 3958
        reg_dummy = (char const   **)((void *)0);
#line 3958
        reg_info_dummy = (register_info_type *)((void *)0);
#line 3958
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3959
      return (-2);
    }
  } else {
#line 3966
    reg_dummy = (char const   **)((void *)0);
#line 3966
    best_regend = reg_dummy;
#line 3966
    best_regstart = best_regend;
#line 3966
    old_regend = best_regstart;
#line 3966
    old_regstart = old_regend;
#line 3966
    regend = old_regstart;
#line 3966
    regstart = regend;
#line 3968
    reg_info_dummy = (register_info_type *)((void *)0);
#line 3968
    reg_info = reg_info_dummy;
  }
#line 3973
  if (pos < 0) {
#line 3973
    goto _L___7;
  } else
#line 3973
  if (pos > size1 + size2) {
    _L___7: /* CIL Label */ 
    {
#line 3975
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3975
      regstart = (char const   **)((void *)0);
#line 3975
      regend = (char const   **)((void *)0);
#line 3975
      old_regstart = (char const   **)((void *)0);
#line 3975
      old_regend = (char const   **)((void *)0);
#line 3975
      best_regstart = (char const   **)((void *)0);
#line 3975
      best_regend = (char const   **)((void *)0);
#line 3975
      reg_info = (register_info_type *)((void *)0);
#line 3975
      reg_dummy = (char const   **)((void *)0);
#line 3975
      reg_info_dummy = (register_info_type *)((void *)0);
#line 3975
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3976
    return (-1);
  }
#line 3982
  mcnt = 1;
  {
#line 3982
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3982
    if (! ((unsigned int )mcnt < num_regs)) {
#line 3982
      goto while_break___2;
    }
#line 3984
    tmp___11 = (char const   *)(& reg_unset_dummy);
#line 3984
    *(old_regend + mcnt) = tmp___11;
#line 3984
    tmp___10 = tmp___11;
#line 3984
    *(old_regstart + mcnt) = tmp___10;
#line 3984
    tmp___9 = tmp___10;
#line 3984
    *(regend + mcnt) = tmp___9;
#line 3984
    *(regstart + mcnt) = tmp___9;
#line 3987
    (reg_info + mcnt)->bits.match_null_string_p = 3U;
#line 3988
    (reg_info + mcnt)->bits.is_active = 0U;
#line 3989
    (reg_info + mcnt)->bits.matched_something = 0U;
#line 3990
    (reg_info + mcnt)->bits.ever_matched_something = 0U;
#line 3982
    mcnt ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3995
  if (size2 == 0) {
#line 3995
    if ((unsigned long )string1 != (unsigned long )((void *)0)) {
#line 3997
      string2 = string1;
#line 3998
      size2 = size1;
#line 3999
      string1 = (char const   *)0;
#line 4000
      size1 = 0;
    }
  }
#line 4002
  end1 = string1 + size1;
#line 4003
  end2 = string2 + size2;
#line 4006
  if (stop <= size1) {
#line 4008
    end_match_1 = string1 + stop;
#line 4009
    end_match_2 = string2;
  } else {
#line 4013
    end_match_1 = end1;
#line 4014
    end_match_2 = (string2 + stop) - size1;
  }
#line 4023
  if (size1 > 0) {
#line 4023
    if (pos <= size1) {
#line 4025
      d = string1 + pos;
#line 4026
      dend = end_match_1;
    } else {
#line 4030
      d = (string2 + pos) - size1;
#line 4031
      dend = end_match_2;
    }
  } else {
#line 4030
    d = (string2 + pos) - size1;
#line 4031
    dend = end_match_2;
  }
  {
#line 4043
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 4051
    if ((unsigned long )p == (unsigned long )pend) {
#line 4057
      if ((unsigned long )d != (unsigned long )end_match_2) {
#line 4061
        if (size1) {
#line 4061
          if ((unsigned long )string1 <= (unsigned long )match_end) {
#line 4061
            if ((unsigned long )match_end <= (unsigned long )(string1 + size1)) {
#line 4061
              tmp___12 = 1;
            } else {
#line 4061
              tmp___12 = 0;
            }
          } else {
#line 4061
            tmp___12 = 0;
          }
        } else {
#line 4061
          tmp___12 = 0;
        }
#line 4061
        same_str_p = (boolean )(tmp___12 == ((unsigned long )dend == (unsigned long )end_match_1));
#line 4068
        if (same_str_p) {
#line 4069
          best_match_p = (boolean )((unsigned long )d > (unsigned long )match_end);
        } else {
#line 4071
          best_match_p = (boolean )(! ((unsigned long )dend == (unsigned long )end_match_1));
        }
#line 4075
        if (! (fail_stack.avail == 0U)) {
#line 4079
          if (! best_regs_set) {
#line 4079
            goto _L___8;
          } else
#line 4079
          if (best_match_p) {
            _L___8: /* CIL Label */ 
#line 4081
            best_regs_set = 1U;
#line 4082
            match_end = d;
#line 4086
            mcnt = 1;
            {
#line 4086
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 4086
              if (! ((unsigned int )mcnt < num_regs)) {
#line 4086
                goto while_break___4;
              }
#line 4088
              *(best_regstart + mcnt) = *(regstart + mcnt);
#line 4089
              *(best_regend + mcnt) = *(regend + mcnt);
#line 4086
              mcnt ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 4092
          goto fail;
        } else
#line 4098
        if (best_regs_set) {
#line 4098
          if (! best_match_p) {
            restore_best_regs: 
#line 4108
            d = match_end;
#line 4109
            if ((unsigned long )d >= (unsigned long )string1) {
#line 4109
              if ((unsigned long )d <= (unsigned long )end1) {
#line 4109
                dend = end_match_1;
              } else {
#line 4109
                dend = end_match_2;
              }
            } else {
#line 4109
              dend = end_match_2;
            }
#line 4112
            mcnt = 1;
            {
#line 4112
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 4112
              if (! ((unsigned int )mcnt < num_regs)) {
#line 4112
                goto while_break___5;
              }
#line 4114
              *(regstart + mcnt) = *(best_regstart + mcnt);
#line 4115
              *(regend + mcnt) = *(best_regend + mcnt);
#line 4112
              mcnt ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
      }
      succeed_label: ;
#line 4124
      if (regs) {
#line 4124
        if (! bufp->no_sub) {
#line 4127
          if (bufp->regs_allocated == 0U) {
#line 4131
            if (30U > num_regs + 1U) {
#line 4131
              regs->num_regs = 30U;
            } else {
#line 4131
              regs->num_regs = num_regs + 1U;
            }
            {
#line 4132
            tmp___13 = malloc((size_t )((unsigned long )regs->num_regs * sizeof(regoff_t )));
#line 4132
            regs->start = (regoff_t *)tmp___13;
#line 4133
            tmp___14 = malloc((size_t )((unsigned long )regs->num_regs * sizeof(regoff_t )));
#line 4133
            regs->end = (regoff_t *)tmp___14;
            }
#line 4134
            if ((unsigned long )regs->start == (unsigned long )((void *)0)) {
#line 4134
              goto _L___9;
            } else
#line 4134
            if ((unsigned long )regs->end == (unsigned long )((void *)0)) {
              _L___9: /* CIL Label */ 
              {
#line 4136
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 4136
                regstart = (char const   **)((void *)0);
#line 4136
                regend = (char const   **)((void *)0);
#line 4136
                old_regstart = (char const   **)((void *)0);
#line 4136
                old_regend = (char const   **)((void *)0);
#line 4136
                best_regstart = (char const   **)((void *)0);
#line 4136
                best_regend = (char const   **)((void *)0);
#line 4136
                reg_info = (register_info_type *)((void *)0);
#line 4136
                reg_dummy = (char const   **)((void *)0);
#line 4136
                reg_info_dummy = (register_info_type *)((void *)0);
#line 4136
                goto while_break___6;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 4137
              return (-2);
            }
#line 4139
            bufp->regs_allocated = 1U;
          } else
#line 4141
          if (bufp->regs_allocated == 1U) {
#line 4145
            if (regs->num_regs < num_regs + 1U) {
              {
#line 4147
              regs->num_regs = num_regs + 1U;
#line 4148
              tmp___15 = realloc((void *)regs->start, (size_t )((unsigned long )regs->num_regs * sizeof(regoff_t )));
#line 4148
              regs->start = (regoff_t *)tmp___15;
#line 4149
              tmp___16 = realloc((void *)regs->end, (size_t )((unsigned long )regs->num_regs * sizeof(regoff_t )));
#line 4149
              regs->end = (regoff_t *)tmp___16;
              }
#line 4150
              if ((unsigned long )regs->start == (unsigned long )((void *)0)) {
#line 4150
                goto _L___10;
              } else
#line 4150
              if ((unsigned long )regs->end == (unsigned long )((void *)0)) {
                _L___10: /* CIL Label */ 
                {
#line 4152
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 4152
                  regstart = (char const   **)((void *)0);
#line 4152
                  regend = (char const   **)((void *)0);
#line 4152
                  old_regstart = (char const   **)((void *)0);
#line 4152
                  old_regend = (char const   **)((void *)0);
#line 4152
                  best_regstart = (char const   **)((void *)0);
#line 4152
                  best_regend = (char const   **)((void *)0);
#line 4152
                  reg_info = (register_info_type *)((void *)0);
#line 4152
                  reg_dummy = (char const   **)((void *)0);
#line 4152
                  reg_info_dummy = (register_info_type *)((void *)0);
#line 4152
                  goto while_break___7;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 4153
                return (-2);
              }
            }
          }
#line 4167
          if (regs->num_regs > 0U) {
#line 4169
            *(regs->start + 0) = pos;
#line 4170
            if ((unsigned long )dend == (unsigned long )end_match_1) {
#line 4170
              *(regs->end + 0) = (regoff_t )(d - string1);
            } else {
#line 4170
              *(regs->end + 0) = (regoff_t )((d - string2) + (long )size1);
            }
          }
#line 4177
          mcnt = 1;
          {
#line 4177
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 4177
            if (num_regs < regs->num_regs) {
#line 4177
              tmp___20 = num_regs;
            } else {
#line 4177
              tmp___20 = regs->num_regs;
            }
#line 4177
            if (! ((unsigned int )mcnt < tmp___20)) {
#line 4177
              goto while_break___8;
            }
#line 4180
            if ((unsigned long )*(regstart + mcnt) == (unsigned long )(& reg_unset_dummy)) {
#line 4181
              tmp___17 = -1;
#line 4181
              *(regs->end + mcnt) = tmp___17;
#line 4181
              *(regs->start + mcnt) = tmp___17;
            } else
#line 4180
            if ((unsigned long )*(regend + mcnt) == (unsigned long )(& reg_unset_dummy)) {
#line 4181
              tmp___17 = -1;
#line 4181
              *(regs->end + mcnt) = tmp___17;
#line 4181
              *(regs->start + mcnt) = tmp___17;
            } else {
#line 4184
              if (size1) {
#line 4184
                if ((unsigned long )string1 <= (unsigned long )*(regstart + mcnt)) {
#line 4184
                  if ((unsigned long )*(regstart + mcnt) <= (unsigned long )(string1 + size1)) {
#line 4184
                    tmp___18 = (regoff_t )(*(regstart + mcnt) - string1);
                  } else {
#line 4184
                    tmp___18 = (regoff_t )((*(regstart + mcnt) - string2) + (long )size1);
                  }
                } else {
#line 4184
                  tmp___18 = (regoff_t )((*(regstart + mcnt) - string2) + (long )size1);
                }
              } else {
#line 4184
                tmp___18 = (regoff_t )((*(regstart + mcnt) - string2) + (long )size1);
              }
#line 4184
              *(regs->start + mcnt) = tmp___18;
#line 4186
              if (size1) {
#line 4186
                if ((unsigned long )string1 <= (unsigned long )*(regend + mcnt)) {
#line 4186
                  if ((unsigned long )*(regend + mcnt) <= (unsigned long )(string1 + size1)) {
#line 4186
                    tmp___19 = (regoff_t )(*(regend + mcnt) - string1);
                  } else {
#line 4186
                    tmp___19 = (regoff_t )((*(regend + mcnt) - string2) + (long )size1);
                  }
                } else {
#line 4186
                  tmp___19 = (regoff_t )((*(regend + mcnt) - string2) + (long )size1);
                }
              } else {
#line 4186
                tmp___19 = (regoff_t )((*(regend + mcnt) - string2) + (long )size1);
              }
#line 4186
              *(regs->end + mcnt) = tmp___19;
            }
#line 4177
            mcnt ++;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 4196
          mcnt = (int )num_regs;
          {
#line 4196
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 4196
            if (! ((unsigned int )mcnt < regs->num_regs)) {
#line 4196
              goto while_break___9;
            }
#line 4197
            tmp___21 = -1;
#line 4197
            *(regs->end + mcnt) = tmp___21;
#line 4197
            *(regs->start + mcnt) = tmp___21;
#line 4196
            mcnt ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
#line 4205
      if ((unsigned long )dend == (unsigned long )end_match_1) {
#line 4205
        tmp___22 = string1;
      } else {
#line 4205
        tmp___22 = string2 - size1;
      }
#line 4205
      mcnt = (int )((d - pos) - tmp___22);
      {
#line 4211
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 4211
        regstart = (char const   **)((void *)0);
#line 4211
        regend = (char const   **)((void *)0);
#line 4211
        old_regstart = (char const   **)((void *)0);
#line 4211
        old_regend = (char const   **)((void *)0);
#line 4211
        best_regstart = (char const   **)((void *)0);
#line 4211
        best_regend = (char const   **)((void *)0);
#line 4211
        reg_info = (register_info_type *)((void *)0);
#line 4211
        reg_dummy = (char const   **)((void *)0);
#line 4211
        reg_info_dummy = (register_info_type *)((void *)0);
#line 4211
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 4212
      return (mcnt);
    }
#line 4216
    tmp___23 = p;
#line 4216
    p ++;
    {
#line 4220
    if ((unsigned int )((re_opcode_t )*tmp___23) == 0U) {
#line 4220
      goto case_0;
    }
#line 4224
    if ((unsigned int )((re_opcode_t )*tmp___23) == 1U) {
#line 4224
      goto case_1;
    }
#line 4231
    if ((unsigned int )((re_opcode_t )*tmp___23) == 2U) {
#line 4231
      goto case_2;
    }
#line 4262
    if ((unsigned int )((re_opcode_t )*tmp___23) == 3U) {
#line 4262
      goto case_3;
    }
#line 4278
    if ((unsigned int )((re_opcode_t )*tmp___23) == 5U) {
#line 4278
      goto case_5;
    }
#line 4278
    if ((unsigned int )((re_opcode_t )*tmp___23) == 4U) {
#line 4278
      goto case_5;
    }
#line 4309
    if ((unsigned int )((re_opcode_t )*tmp___23) == 6U) {
#line 4309
      goto case_6;
    }
#line 4357
    if ((unsigned int )((re_opcode_t )*tmp___23) == 7U) {
#line 4357
      goto case_7;
    }
#line 4493
    if ((unsigned int )((re_opcode_t )*tmp___23) == 8U) {
#line 4493
      goto case_8;
    }
#line 4559
    if ((unsigned int )((re_opcode_t )*tmp___23) == 9U) {
#line 4559
      goto case_9;
    }
#line 4575
    if ((unsigned int )((re_opcode_t )*tmp___23) == 10U) {
#line 4575
      goto case_10;
    }
#line 4593
    if ((unsigned int )((re_opcode_t )*tmp___23) == 11U) {
#line 4593
      goto case_11;
    }
#line 4601
    if ((unsigned int )((re_opcode_t )*tmp___23) == 12U) {
#line 4601
      goto case_12;
    }
#line 4624
    if ((unsigned int )((re_opcode_t )*tmp___23) == 16U) {
#line 4624
      goto case_16;
    }
#line 4650
    if ((unsigned int )((re_opcode_t )*tmp___23) == 15U) {
#line 4650
      goto on_failure;
    }
#line 4697
    if ((unsigned int )((re_opcode_t )*tmp___23) == 18U) {
#line 4697
      goto case_18___0;
    }
#line 4856
    if ((unsigned int )((re_opcode_t )*tmp___23) == 17U) {
#line 4856
      goto case_17___0;
    }
#line 4883
    if ((unsigned int )((re_opcode_t )*tmp___23) == 13U) {
#line 4883
      goto case_13___0;
    }
#line 4897
    if ((unsigned int )((re_opcode_t )*tmp___23) == 14U) {
#line 4897
      goto case_14;
    }
#line 4907
    if ((unsigned int )((re_opcode_t )*tmp___23) == 19U) {
#line 4907
      goto case_19___0;
    }
#line 4920
    if ((unsigned int )((re_opcode_t )*tmp___23) == 20U) {
#line 4920
      goto case_20;
    }
#line 4929
    if ((unsigned int )((re_opcode_t )*tmp___23) == 21U) {
#line 4929
      goto case_21;
    }
#line 4959
    if ((unsigned int )((re_opcode_t )*tmp___23) == 22U) {
#line 4959
      goto case_22___0;
    }
#line 4980
    if ((unsigned int )((re_opcode_t )*tmp___23) == 23U) {
#line 4980
      goto case_23;
    }
#line 5014
    if ((unsigned int )((re_opcode_t )*tmp___23) == 28U) {
#line 5014
      goto case_28;
    }
#line 5029
    if ((unsigned int )((re_opcode_t )*tmp___23) == 29U) {
#line 5029
      goto case_29;
    }
#line 5045
    if ((unsigned int )((re_opcode_t )*tmp___23) == 26U) {
#line 5045
      goto case_26;
    }
#line 5051
    if ((unsigned int )((re_opcode_t )*tmp___23) == 27U) {
#line 5051
      goto case_27;
    }
#line 5112
    if ((unsigned int )((re_opcode_t )*tmp___23) == 24U) {
#line 5112
      goto case_24;
    }
#line 5121
    if ((unsigned int )((re_opcode_t )*tmp___23) == 25U) {
#line 5121
      goto case_25;
    }
#line 5131
    goto switch_default___0;
    case_0: /* CIL Label */ ;
#line 4222
    goto switch_break;
    case_1: /* CIL Label */ ;
#line 4226
    goto succeed_label;
    case_2: /* CIL Label */ 
#line 4232
    tmp___24 = p;
#line 4232
    p ++;
#line 4232
    mcnt = (int )*tmp___24;
#line 4237
    if (translate) {
      {
#line 4239
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 4241
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 4241
          if (! ((unsigned long )d == (unsigned long )dend)) {
#line 4241
            goto while_break___12;
          }
#line 4241
          if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 4241
            goto fail;
          }
#line 4241
          d = string2;
#line 4241
          dend = end_match_2;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 4242
        tmp___25 = d;
#line 4242
        d ++;
#line 4242
        tmp___26 = p;
#line 4242
        p ++;
#line 4242
        if ((int )((unsigned char )*(translate + (unsigned char )*tmp___25)) != (int )*tmp___26) {
#line 4244
          goto fail;
        }
#line 4239
        mcnt --;
#line 4239
        if (! mcnt) {
#line 4239
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
    } else {
      {
#line 4250
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 4252
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 4252
          if (! ((unsigned long )d == (unsigned long )dend)) {
#line 4252
            goto while_break___14;
          }
#line 4252
          if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 4252
            goto fail;
          }
#line 4252
          d = string2;
#line 4252
          dend = end_match_2;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 4253
        tmp___27 = d;
#line 4253
        d ++;
#line 4253
        tmp___28 = p;
#line 4253
        p ++;
#line 4253
        if ((int const   )*tmp___27 != (int const   )((char )*tmp___28)) {
#line 4253
          goto fail;
        }
#line 4250
        mcnt --;
#line 4250
        if (! mcnt) {
#line 4250
          goto while_break___13;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
    }
    {
#line 4257
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 4257
      if (! set_regs_matched_done) {
#line 4257
        set_regs_matched_done = 1;
#line 4257
        r = lowest_active_reg;
        {
#line 4257
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 4257
          if (! (r <= highest_active_reg)) {
#line 4257
            goto while_break___16;
          }
#line 4257
          tmp___29 = 1U;
#line 4257
          (reg_info + r)->bits.ever_matched_something = tmp___29;
#line 4257
          (reg_info + r)->bits.matched_something = tmp___29;
#line 4257
          r ++;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
#line 4257
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 4258
    goto switch_break;
    case_3: /* CIL Label */ ;
    {
#line 4265
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 4265
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 4265
        goto while_break___17;
      }
#line 4265
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 4265
        goto fail;
      }
#line 4265
      d = string2;
#line 4265
      dend = end_match_2;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 4267
    if (! (bufp->syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 4267
      if (translate) {
#line 4267
        tmp___30 = (int )*(translate + (unsigned char )*d);
      } else {
#line 4267
        tmp___30 = (int )*d;
      }
#line 4267
      if (tmp___30 == 10) {
#line 4269
        goto fail;
      } else {
#line 4267
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 4267
    if (bufp->syntax & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4267
      if (translate) {
#line 4267
        tmp___31 = (int )*(translate + (unsigned char )*d);
      } else {
#line 4267
        tmp___31 = (int )*d;
      }
#line 4267
      if (tmp___31 == 0) {
#line 4269
        goto fail;
      }
    }
    {
#line 4271
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 4271
      if (! set_regs_matched_done) {
#line 4271
        set_regs_matched_done = 1;
#line 4271
        r___0 = lowest_active_reg;
        {
#line 4271
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 4271
          if (! (r___0 <= highest_active_reg)) {
#line 4271
            goto while_break___19;
          }
#line 4271
          tmp___32 = 1U;
#line 4271
          (reg_info + r___0)->bits.ever_matched_something = tmp___32;
#line 4271
          (reg_info + r___0)->bits.matched_something = tmp___32;
#line 4271
          r___0 ++;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
#line 4271
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 4273
    d ++;
#line 4274
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 4281
    not = (boolean )((unsigned int )((re_opcode_t )*(p - 1)) == 5U);
    {
#line 4285
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 4285
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 4285
        goto while_break___20;
      }
#line 4285
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 4285
        goto fail;
      }
#line 4285
      d = string2;
#line 4285
      dend = end_match_2;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 4286
    if (translate) {
#line 4286
      c = (unsigned char )*(translate + (unsigned char )*d);
    } else {
#line 4286
      c = (unsigned char )*d;
    }
#line 4290
    if ((unsigned int )c < (unsigned int )((int )*p * 8)) {
#line 4290
      if ((int )*(p + (1 + (int )c / 8)) & (1 << (int )c % 8)) {
#line 4292
        not = (boolean )(! not);
      }
    }
#line 4294
    p += 1 + (int )*p;
#line 4296
    if (! not) {
#line 4296
      goto fail;
    }
    {
#line 4298
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 4298
      if (! set_regs_matched_done) {
#line 4298
        set_regs_matched_done = 1;
#line 4298
        r___1 = lowest_active_reg;
        {
#line 4298
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 4298
          if (! (r___1 <= highest_active_reg)) {
#line 4298
            goto while_break___22;
          }
#line 4298
          tmp___33 = 1U;
#line 4298
          (reg_info + r___1)->bits.ever_matched_something = tmp___33;
#line 4298
          (reg_info + r___1)->bits.matched_something = tmp___33;
#line 4298
          r___1 ++;
        }
        while_break___22: /* CIL Label */ ;
        }
      }
#line 4298
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 4299
    d ++;
#line 4300
    goto switch_break;
    case_6: /* CIL Label */ 
#line 4313
    p1 = p;
#line 4315
    if ((reg_info + *p)->bits.match_null_string_p == 3U) {
      {
#line 4316
      tmp___34 = group_match_null_string_p(& p1, pend, reg_info);
#line 4316
      (reg_info + *p)->bits.match_null_string_p = (unsigned int )tmp___34;
      }
    }
#line 4324
    if ((reg_info + *p)->bits.match_null_string_p) {
#line 4324
      if ((unsigned long )*(regstart + *p) == (unsigned long )(& reg_unset_dummy)) {
#line 4324
        tmp___35 = d;
      } else {
#line 4324
        tmp___35 = *(regstart + *p);
      }
#line 4324
      *(old_regstart + *p) = tmp___35;
    } else {
#line 4324
      *(old_regstart + *p) = *(regstart + *p);
    }
#line 4330
    *(regstart + *p) = d;
#line 4333
    (reg_info + *p)->bits.is_active = 1U;
#line 4334
    (reg_info + *p)->bits.matched_something = 0U;
#line 4337
    set_regs_matched_done = 0;
#line 4340
    highest_active_reg = (active_reg_t )*p;
#line 4344
    if (lowest_active_reg == (active_reg_t )((1 << 8) + 1)) {
#line 4345
      lowest_active_reg = (active_reg_t )*p;
    }
#line 4348
    p += 2;
#line 4349
    just_past_start_mem = p;
#line 4351
    goto switch_break;
    case_7: /* CIL Label */ ;
#line 4365
    if ((reg_info + *p)->bits.match_null_string_p) {
#line 4365
      if ((unsigned long )*(regend + *p) == (unsigned long )(& reg_unset_dummy)) {
#line 4365
        tmp___36 = d;
      } else {
#line 4365
        tmp___36 = *(regend + *p);
      }
#line 4365
      *(old_regend + *p) = tmp___36;
    } else {
#line 4365
      *(old_regend + *p) = *(regend + *p);
    }
#line 4371
    *(regend + *p) = d;
#line 4375
    (reg_info + *p)->bits.is_active = 0U;
#line 4378
    set_regs_matched_done = 0;
#line 4382
    if (lowest_active_reg == highest_active_reg) {
#line 4384
      lowest_active_reg = (active_reg_t )((1 << 8) + 1);
#line 4385
      highest_active_reg = (active_reg_t )(1 << 8);
    } else {
#line 4392
      r___2 = (unsigned char )((int )*p - 1);
      {
#line 4393
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 4393
        if ((int )r___2 > 0) {
#line 4393
          if (! (! (reg_info + r___2)->bits.is_active)) {
#line 4393
            goto while_break___23;
          }
        } else {
#line 4393
          goto while_break___23;
        }
#line 4394
        r___2 = (unsigned char )((int )r___2 - 1);
      }
      while_break___23: /* CIL Label */ ;
      }
#line 4403
      if ((int )r___2 == 0) {
#line 4405
        lowest_active_reg = (active_reg_t )((1 << 8) + 1);
#line 4406
        highest_active_reg = (active_reg_t )(1 << 8);
      } else {
#line 4409
        highest_active_reg = (active_reg_t )r___2;
      }
    }
#line 4417
    if (! (reg_info + *p)->bits.matched_something) {
#line 4417
      goto _L___12;
    } else
#line 4417
    if ((unsigned long )just_past_start_mem == (unsigned long )(p - 1)) {
      _L___12: /* CIL Label */ 
#line 4417
      if ((unsigned long )(p + 2) < (unsigned long )pend) {
#line 4421
        is_a_jump_n = (boolean )0;
#line 4423
        p1 = p + 2;
#line 4424
        mcnt = 0;
#line 4425
        tmp___37 = p1;
#line 4425
        p1 ++;
        {
#line 4427
        if ((unsigned int )((re_opcode_t )*tmp___37) == 22U) {
#line 4427
          goto case_22;
        }
#line 4432
        if ((unsigned int )((re_opcode_t )*tmp___37) == 19U) {
#line 4432
          goto case_19;
        }
#line 4432
        if ((unsigned int )((re_opcode_t )*tmp___37) == 13U) {
#line 4432
          goto case_19;
        }
#line 4432
        if ((unsigned int )((re_opcode_t )*tmp___37) == 18U) {
#line 4432
          goto case_19;
        }
#line 4432
        if ((unsigned int )((re_opcode_t )*tmp___37) == 17U) {
#line 4432
          goto case_19;
        }
#line 4438
        goto switch_default;
        case_22: /* CIL Label */ 
#line 4428
        is_a_jump_n = (boolean )1;
        case_19: /* CIL Label */ 
        case_13: /* CIL Label */ 
        case_18: /* CIL Label */ 
        case_17: /* CIL Label */ 
        {
#line 4433
        while (1) {
          while_continue___24: /* CIL Label */ ;
          {
#line 4433
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 4433
            mcnt = (int )*p1 & 255;
#line 4433
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 4433
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
#line 4433
          p1 += 2;
#line 4433
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
#line 4434
        if (is_a_jump_n) {
#line 4435
          p1 += 2;
        }
#line 4436
        goto switch_break___0;
        switch_default: /* CIL Label */ ;
        switch_break___0: /* CIL Label */ ;
        }
#line 4441
        p1 += mcnt;
#line 4448
        if (mcnt < 0) {
#line 4448
          if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 4448
            if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 6U) {
#line 4448
              if ((int )*(p1 + 4) == (int )*p) {
#line 4461
                if ((reg_info + *p)->bits.ever_matched_something) {
#line 4465
                  (reg_info + *p)->bits.ever_matched_something = 0U;
#line 4468
                  r___3 = (unsigned int )*p;
                  {
#line 4468
                  while (1) {
                    while_continue___26: /* CIL Label */ ;
#line 4468
                    if (! (r___3 < (unsigned int )*p + (unsigned int )*(p + 1))) {
#line 4468
                      goto while_break___26;
                    }
#line 4471
                    *(regstart + r___3) = *(old_regstart + r___3);
#line 4474
                    if ((unsigned long )*(old_regend + r___3) >= (unsigned long )*(regstart + r___3)) {
#line 4475
                      *(regend + r___3) = *(old_regend + r___3);
                    }
#line 4468
                    r___3 ++;
                  }
                  while_break___26: /* CIL Label */ ;
                  }
                }
#line 4478
                p1 ++;
                {
#line 4479
                while (1) {
                  while_continue___27: /* CIL Label */ ;
                  {
#line 4479
                  while (1) {
                    while_continue___28: /* CIL Label */ ;
#line 4479
                    mcnt = (int )*p1 & 255;
#line 4479
                    mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 4479
                    goto while_break___28;
                  }
                  while_break___28: /* CIL Label */ ;
                  }
#line 4479
                  p1 += 2;
#line 4479
                  goto while_break___27;
                }
                while_break___27: /* CIL Label */ ;
                }
                {
#line 4480
                while (1) {
                  while_continue___29: /* CIL Label */ ;
                  {
#line 4480
                  while (1) {
                    while_continue___30: /* CIL Label */ ;
#line 4480
                    if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 4480
                      goto while_break___30;
                    }
#line 4480
                    if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
#line 4480
                      tmp___41 = 0;
                    } else {
                      {
#line 4480
                      tmp___38 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
#line 4480
                      destination = (char *)tmp___38;
#line 4480
                      tmp___39 = memcpy((void */* __restrict  */)destination, (void const   */* __restrict  */)fail_stack.stack,
                                        (size_t )((unsigned long )fail_stack.size * sizeof(fail_stack_elt_t )));
#line 4480
                      fail_stack.stack = (fail_stack_elt_t *)tmp___39;
                      }
#line 4480
                      if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 4480
                        tmp___40 = 0;
                      } else {
#line 4480
                        fail_stack.size <<= 1;
#line 4480
                        tmp___40 = 1;
                      }
#line 4480
                      tmp___41 = tmp___40;
                    }
#line 4480
                    if (! tmp___41) {
#line 4480
                      return (-2);
                    }
                  }
                  while_break___30: /* CIL Label */ ;
                  }
#line 4480
                  this_reg = lowest_active_reg;
                  {
#line 4480
                  while (1) {
                    while_continue___31: /* CIL Label */ ;
#line 4480
                    if (! (this_reg <= highest_active_reg)) {
#line 4480
                      goto while_break___31;
                    }
#line 4480
                    tmp___42 = fail_stack.avail;
#line 4480
                    (fail_stack.avail) ++;
#line 4480
                    (fail_stack.stack + tmp___42)->pointer = (unsigned char *)*(regstart + this_reg);
#line 4480
                    tmp___43 = fail_stack.avail;
#line 4480
                    (fail_stack.avail) ++;
#line 4480
                    (fail_stack.stack + tmp___43)->pointer = (unsigned char *)*(regend + this_reg);
#line 4480
                    tmp___44 = fail_stack.avail;
#line 4480
                    (fail_stack.avail) ++;
#line 4480
                    *(fail_stack.stack + tmp___44) = (reg_info + this_reg)->word;
#line 4480
                    this_reg ++;
                  }
                  while_break___31: /* CIL Label */ ;
                  }
#line 4480
                  tmp___45 = fail_stack.avail;
#line 4480
                  (fail_stack.avail) ++;
#line 4480
                  (fail_stack.stack + tmp___45)->integer = (int )lowest_active_reg;
#line 4480
                  tmp___46 = fail_stack.avail;
#line 4480
                  (fail_stack.avail) ++;
#line 4480
                  (fail_stack.stack + tmp___46)->integer = (int )highest_active_reg;
#line 4480
                  tmp___47 = fail_stack.avail;
#line 4480
                  (fail_stack.avail) ++;
#line 4480
                  (fail_stack.stack + tmp___47)->pointer = p1 + mcnt;
#line 4480
                  tmp___48 = fail_stack.avail;
#line 4480
                  (fail_stack.avail) ++;
#line 4480
                  (fail_stack.stack + tmp___48)->pointer = (unsigned char *)d;
#line 4480
                  goto while_break___29;
                }
                while_break___29: /* CIL Label */ ;
                }
#line 4482
                goto fail;
              }
            }
          }
        }
      }
    }
#line 4487
    p += 2;
#line 4488
    goto switch_break;
    case_8: /* CIL Label */ 
#line 4496
    tmp___49 = p;
#line 4496
    p ++;
#line 4496
    regno = (int )*tmp___49;
#line 4500
    if ((unsigned long )*(regstart + regno) == (unsigned long )(& reg_unset_dummy)) {
#line 4501
      goto fail;
    } else
#line 4500
    if ((unsigned long )*(regend + regno) == (unsigned long )(& reg_unset_dummy)) {
#line 4501
      goto fail;
    }
#line 4504
    d2 = *(regstart + regno);
#line 4511
    if (size1) {
#line 4511
      if ((unsigned long )string1 <= (unsigned long )*(regstart + regno)) {
#line 4511
        if ((unsigned long )*(regstart + regno) <= (unsigned long )(string1 + size1)) {
#line 4511
          tmp___52 = 1;
        } else {
#line 4511
          tmp___52 = 0;
        }
      } else {
#line 4511
        tmp___52 = 0;
      }
    } else {
#line 4511
      tmp___52 = 0;
    }
#line 4511
    if (size1) {
#line 4511
      if ((unsigned long )string1 <= (unsigned long )*(regend + regno)) {
#line 4511
        if ((unsigned long )*(regend + regno) <= (unsigned long )(string1 + size1)) {
#line 4511
          tmp___53 = 1;
        } else {
#line 4511
          tmp___53 = 0;
        }
      } else {
#line 4511
        tmp___53 = 0;
      }
    } else {
#line 4511
      tmp___53 = 0;
    }
#line 4511
    if (tmp___52 == tmp___53) {
#line 4511
      dend2 = *(regend + regno);
    } else {
#line 4511
      dend2 = end_match_1;
    }
    {
#line 4514
    while (1) {
      while_continue___32: /* CIL Label */ ;
      {
#line 4518
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 4518
        if (! ((unsigned long )d2 == (unsigned long )dend2)) {
#line 4518
          goto while_break___33;
        }
#line 4520
        if ((unsigned long )dend2 == (unsigned long )end_match_2) {
#line 4520
          goto while_break___33;
        }
#line 4521
        if ((unsigned long )dend2 == (unsigned long )*(regend + regno)) {
#line 4521
          goto while_break___33;
        }
#line 4524
        d2 = string2;
#line 4525
        dend2 = *(regend + regno);
      }
      while_break___33: /* CIL Label */ ;
      }
#line 4528
      if ((unsigned long )d2 == (unsigned long )dend2) {
#line 4528
        goto while_break___32;
      }
      {
#line 4531
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 4531
        if (! ((unsigned long )d == (unsigned long )dend)) {
#line 4531
          goto while_break___34;
        }
#line 4531
        if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 4531
          goto fail;
        }
#line 4531
        d = string2;
#line 4531
        dend = end_match_2;
      }
      while_break___34: /* CIL Label */ ;
      }
#line 4534
      mcnt = (int )(dend - d);
#line 4538
      if ((long )mcnt > dend2 - d2) {
#line 4539
        mcnt = (int )(dend2 - d2);
      }
#line 4543
      if (translate) {
        {
#line 4543
        tmp___54 = bcmp_translate(d, d2, mcnt, translate);
#line 4543
        tmp___56 = tmp___54;
        }
      } else {
        {
#line 4543
        tmp___55 = memcmp((void const   *)d, (void const   *)d2, (size_t )mcnt);
#line 4543
        tmp___56 = tmp___55;
        }
      }
#line 4543
      if (tmp___56) {
#line 4546
        goto fail;
      }
#line 4547
      d += mcnt;
#line 4547
      d2 += mcnt;
      {
#line 4550
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 4550
        if (! set_regs_matched_done) {
#line 4550
          set_regs_matched_done = 1;
#line 4550
          r___4 = lowest_active_reg;
          {
#line 4550
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 4550
            if (! (r___4 <= highest_active_reg)) {
#line 4550
              goto while_break___36;
            }
#line 4550
            tmp___57 = 1U;
#line 4550
            (reg_info + r___4)->bits.ever_matched_something = tmp___57;
#line 4550
            (reg_info + r___4)->bits.matched_something = tmp___57;
#line 4550
            r___4 ++;
          }
          while_break___36: /* CIL Label */ ;
          }
        }
#line 4550
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
    }
    while_break___32: /* CIL Label */ ;
    }
#line 4553
    goto switch_break;
    case_9: /* CIL Label */ ;
#line 4562
    if (size1) {
#line 4562
      tmp___58 = string1;
    } else {
#line 4562
      tmp___58 = string2;
    }
#line 4562
    if ((unsigned long )d == (unsigned long )tmp___58) {
#line 4562
      goto _L___13;
    } else
#line 4562
    if (! size2) {
      _L___13: /* CIL Label */ 
#line 4564
      if (! bufp->not_bol) {
#line 4564
        goto switch_break;
      }
    } else
#line 4566
    if ((int const   )*(d + -1) == 10) {
#line 4566
      if (bufp->newline_anchor) {
#line 4568
        goto switch_break;
      }
    }
#line 4571
    goto fail;
    case_10: /* CIL Label */ ;
#line 4578
    if ((unsigned long )d == (unsigned long )end2) {
#line 4580
      if (! bufp->not_eol) {
#line 4580
        goto switch_break;
      }
    } else {
#line 4584
      if ((unsigned long )d == (unsigned long )end1) {
#line 4584
        tmp___59 = (int const   )*string2;
      } else {
#line 4584
        tmp___59 = (int const   )*d;
      }
#line 4584
      if (tmp___59 == 10) {
#line 4584
        if (bufp->newline_anchor) {
#line 4587
          goto switch_break;
        }
      }
    }
#line 4589
    goto fail;
    case_11: /* CIL Label */ ;
#line 4595
    if (size1) {
#line 4595
      tmp___60 = string1;
    } else {
#line 4595
      tmp___60 = string2;
    }
#line 4595
    if ((unsigned long )d == (unsigned long )tmp___60) {
#line 4596
      goto switch_break;
    } else
#line 4595
    if (! size2) {
#line 4596
      goto switch_break;
    }
#line 4597
    goto fail;
    case_12: /* CIL Label */ ;
#line 4603
    if ((unsigned long )d == (unsigned long )end2) {
#line 4604
      goto switch_break;
    }
#line 4605
    goto fail;
    case_16: /* CIL Label */ ;
    {
#line 4627
    while (1) {
      while_continue___37: /* CIL Label */ ;
      {
#line 4627
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 4627
        mcnt = (int )*p & 255;
#line 4627
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 4627
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 4627
      p += 2;
#line 4627
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 4634
    while (1) {
      while_continue___39: /* CIL Label */ ;
      {
#line 4634
      while (1) {
        while_continue___40: /* CIL Label */ ;
#line 4634
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 4634
          goto while_break___40;
        }
#line 4634
        if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
#line 4634
          tmp___64 = 0;
        } else {
          {
#line 4634
          tmp___61 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
#line 4634
          destination___0 = (char *)tmp___61;
#line 4634
          tmp___62 = memcpy((void */* __restrict  */)destination___0, (void const   */* __restrict  */)fail_stack.stack,
                            (size_t )((unsigned long )fail_stack.size * sizeof(fail_stack_elt_t )));
#line 4634
          fail_stack.stack = (fail_stack_elt_t *)tmp___62;
          }
#line 4634
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 4634
            tmp___63 = 0;
          } else {
#line 4634
            fail_stack.size <<= 1;
#line 4634
            tmp___63 = 1;
          }
#line 4634
          tmp___64 = tmp___63;
        }
#line 4634
        if (! tmp___64) {
#line 4634
          return (-2);
        }
      }
      while_break___40: /* CIL Label */ ;
      }
#line 4634
      this_reg___0 = lowest_active_reg;
      {
#line 4634
      while (1) {
        while_continue___41: /* CIL Label */ ;
#line 4634
        if (! (this_reg___0 <= highest_active_reg)) {
#line 4634
          goto while_break___41;
        }
#line 4634
        tmp___65 = fail_stack.avail;
#line 4634
        (fail_stack.avail) ++;
#line 4634
        (fail_stack.stack + tmp___65)->pointer = (unsigned char *)*(regstart + this_reg___0);
#line 4634
        tmp___66 = fail_stack.avail;
#line 4634
        (fail_stack.avail) ++;
#line 4634
        (fail_stack.stack + tmp___66)->pointer = (unsigned char *)*(regend + this_reg___0);
#line 4634
        tmp___67 = fail_stack.avail;
#line 4634
        (fail_stack.avail) ++;
#line 4634
        *(fail_stack.stack + tmp___67) = (reg_info + this_reg___0)->word;
#line 4634
        this_reg___0 ++;
      }
      while_break___41: /* CIL Label */ ;
      }
#line 4634
      tmp___68 = fail_stack.avail;
#line 4634
      (fail_stack.avail) ++;
#line 4634
      (fail_stack.stack + tmp___68)->integer = (int )lowest_active_reg;
#line 4634
      tmp___69 = fail_stack.avail;
#line 4634
      (fail_stack.avail) ++;
#line 4634
      (fail_stack.stack + tmp___69)->integer = (int )highest_active_reg;
#line 4634
      tmp___70 = fail_stack.avail;
#line 4634
      (fail_stack.avail) ++;
#line 4634
      (fail_stack.stack + tmp___70)->pointer = p + mcnt;
#line 4634
      tmp___71 = fail_stack.avail;
#line 4634
      (fail_stack.avail) ++;
#line 4634
      (fail_stack.stack + tmp___71)->pointer = (unsigned char *)((void *)0);
#line 4634
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
#line 4635
    goto switch_break;
    on_failure: 
    case_15: /* CIL Label */ ;
    {
#line 4654
    while (1) {
      while_continue___42: /* CIL Label */ ;
      {
#line 4654
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 4654
        mcnt = (int )*p & 255;
#line 4654
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 4654
        goto while_break___43;
      }
      while_break___43: /* CIL Label */ ;
      }
#line 4654
      p += 2;
#line 4654
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 4670
    p1 = p;
    {
#line 4676
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 4676
      if ((unsigned long )p1 < (unsigned long )pend) {
#line 4676
        if (! ((unsigned int )((re_opcode_t )*p1) == 0U)) {
#line 4676
          goto while_break___44;
        }
      } else {
#line 4676
        goto while_break___44;
      }
#line 4677
      p1 ++;
    }
    while_break___44: /* CIL Label */ ;
    }
#line 4679
    if ((unsigned long )p1 < (unsigned long )pend) {
#line 4679
      if ((unsigned int )((re_opcode_t )*p1) == 6U) {
#line 4685
        highest_active_reg = (active_reg_t )((int )*(p1 + 1) + (int )*(p1 + 2));
#line 4686
        if (lowest_active_reg == (active_reg_t )((1 << 8) + 1)) {
#line 4687
          lowest_active_reg = (active_reg_t )*(p1 + 1);
        }
      }
    }
    {
#line 4691
    while (1) {
      while_continue___45: /* CIL Label */ ;
      {
#line 4691
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 4691
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 4691
          goto while_break___46;
        }
#line 4691
        if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
#line 4691
          tmp___75 = 0;
        } else {
          {
#line 4691
          tmp___72 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
#line 4691
          destination___1 = (char *)tmp___72;
#line 4691
          tmp___73 = memcpy((void */* __restrict  */)destination___1, (void const   */* __restrict  */)fail_stack.stack,
                            (size_t )((unsigned long )fail_stack.size * sizeof(fail_stack_elt_t )));
#line 4691
          fail_stack.stack = (fail_stack_elt_t *)tmp___73;
          }
#line 4691
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 4691
            tmp___74 = 0;
          } else {
#line 4691
            fail_stack.size <<= 1;
#line 4691
            tmp___74 = 1;
          }
#line 4691
          tmp___75 = tmp___74;
        }
#line 4691
        if (! tmp___75) {
#line 4691
          return (-2);
        }
      }
      while_break___46: /* CIL Label */ ;
      }
#line 4691
      this_reg___1 = lowest_active_reg;
      {
#line 4691
      while (1) {
        while_continue___47: /* CIL Label */ ;
#line 4691
        if (! (this_reg___1 <= highest_active_reg)) {
#line 4691
          goto while_break___47;
        }
#line 4691
        tmp___76 = fail_stack.avail;
#line 4691
        (fail_stack.avail) ++;
#line 4691
        (fail_stack.stack + tmp___76)->pointer = (unsigned char *)*(regstart + this_reg___1);
#line 4691
        tmp___77 = fail_stack.avail;
#line 4691
        (fail_stack.avail) ++;
#line 4691
        (fail_stack.stack + tmp___77)->pointer = (unsigned char *)*(regend + this_reg___1);
#line 4691
        tmp___78 = fail_stack.avail;
#line 4691
        (fail_stack.avail) ++;
#line 4691
        *(fail_stack.stack + tmp___78) = (reg_info + this_reg___1)->word;
#line 4691
        this_reg___1 ++;
      }
      while_break___47: /* CIL Label */ ;
      }
#line 4691
      tmp___79 = fail_stack.avail;
#line 4691
      (fail_stack.avail) ++;
#line 4691
      (fail_stack.stack + tmp___79)->integer = (int )lowest_active_reg;
#line 4691
      tmp___80 = fail_stack.avail;
#line 4691
      (fail_stack.avail) ++;
#line 4691
      (fail_stack.stack + tmp___80)->integer = (int )highest_active_reg;
#line 4691
      tmp___81 = fail_stack.avail;
#line 4691
      (fail_stack.avail) ++;
#line 4691
      (fail_stack.stack + tmp___81)->pointer = p + mcnt;
#line 4691
      tmp___82 = fail_stack.avail;
#line 4691
      (fail_stack.avail) ++;
#line 4691
      (fail_stack.stack + tmp___82)->pointer = (unsigned char *)d;
#line 4691
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
#line 4692
    goto switch_break;
    case_18___0: /* CIL Label */ 
    {
#line 4698
    while (1) {
      while_continue___48: /* CIL Label */ ;
      {
#line 4698
      while (1) {
        while_continue___49: /* CIL Label */ ;
#line 4698
        mcnt = (int )*p & 255;
#line 4698
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 4698
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
#line 4698
      p += 2;
#line 4698
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
#line 4701
    p2 = p;
    {
#line 4720
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 4722
      if ((unsigned long )(p2 + 2) < (unsigned long )pend) {
#line 4722
        if ((unsigned int )((re_opcode_t )*p2) == 7U) {
#line 4725
          p2 += 3;
        } else
#line 4722
        if ((unsigned int )((re_opcode_t )*p2) == 6U) {
#line 4725
          p2 += 3;
        } else {
#line 4722
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 4726
      if ((unsigned long )(p2 + 6) < (unsigned long )pend) {
#line 4726
        if ((unsigned int )((re_opcode_t )*p2) == 19U) {
#line 4728
          p2 += 6;
        } else {
#line 4730
          goto while_break___50;
        }
      } else {
#line 4730
        goto while_break___50;
      }
    }
    while_break___50: /* CIL Label */ ;
    }
#line 4733
    p1 = p + mcnt;
#line 4739
    if ((unsigned long )p2 == (unsigned long )pend) {
#line 4744
      *(p + -3) = (unsigned char)17;
    } else
#line 4749
    if ((unsigned int )((re_opcode_t )*p2) == 2U) {
#line 4749
      goto _L___18;
    } else
#line 4749
    if (bufp->newline_anchor) {
#line 4749
      if ((unsigned int )((re_opcode_t )*p2) == 10U) {
        _L___18: /* CIL Label */ 
#line 4752
        if ((int )*p2 == 10) {
#line 4752
          tmp___83 = '\n';
        } else {
#line 4752
          tmp___83 = (int )*(p2 + 2);
        }
#line 4752
        c___0 = (unsigned char )tmp___83;
#line 4755
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 2U) {
#line 4755
          if ((int )*(p1 + 5) != (int )c___0) {
#line 4757
            *(p + -3) = (unsigned char)17;
          } else {
#line 4755
            goto _L___16;
          }
        } else
        _L___16: /* CIL Label */ 
#line 4762
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 4U) {
#line 4762
          goto _L___15;
        } else
#line 4762
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 5U) {
          _L___15: /* CIL Label */ 
#line 4765
          not___0 = (unsigned int )((re_opcode_t )*(p1 + 3)) == 5U;
#line 4767
          if ((int )c___0 < (int )((unsigned char )((int )*(p1 + 4) * 8))) {
#line 4767
            if ((int )*(p1 + (5 + (int )c___0 / 8)) & (1 << (int )c___0 % 8)) {
#line 4769
              not___0 = ! not___0;
            }
          }
#line 4773
          if (! not___0) {
#line 4775
            *(p + -3) = (unsigned char)17;
          }
        }
      } else {
#line 4749
        goto _L___19;
      }
    } else
    _L___19: /* CIL Label */ 
#line 4780
    if ((unsigned int )((re_opcode_t )*p2) == 4U) {
#line 4793
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 2U) {
#line 4793
        if ((int )*(p2 + 1) * 8 > (int )*(p1 + 4)) {
#line 4793
          if ((int )*(p2 + (2 + (int )*(p1 + 4) / 8)) & (1 << (int )*(p1 + 4) % 8)) {
#line 4793
            goto _L___17;
          } else {
#line 4799
            *(p + -3) = (unsigned char)17;
          }
        } else {
#line 4799
          *(p + -3) = (unsigned char)17;
        }
      } else
      _L___17: /* CIL Label */ 
#line 4804
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 5U) {
#line 4809
        idx = 0;
        {
#line 4809
        while (1) {
          while_continue___51: /* CIL Label */ ;
#line 4809
          if (! (idx < (int )*(p2 + 1))) {
#line 4809
            goto while_break___51;
          }
#line 4810
          if (! ((int )*(p2 + (2 + idx)) == 0)) {
#line 4810
            if (idx < (int )*(p1 + 4)) {
#line 4810
              if (! (((int )*(p2 + (2 + idx)) & ~ ((int )*(p1 + (5 + idx)))) == 0)) {
#line 4813
                goto while_break___51;
              }
            } else {
#line 4813
              goto while_break___51;
            }
          }
#line 4809
          idx ++;
        }
        while_break___51: /* CIL Label */ ;
        }
#line 4815
        if (idx == (int )*(p2 + 1)) {
#line 4817
          *(p + -3) = (unsigned char)17;
        }
      } else
#line 4821
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 4U) {
#line 4826
        idx___0 = 0;
        {
#line 4826
        while (1) {
          while_continue___52: /* CIL Label */ ;
#line 4826
          if (idx___0 < (int )*(p2 + 1)) {
#line 4826
            if (! (idx___0 < (int )*(p1 + 4))) {
#line 4826
              goto while_break___52;
            }
          } else {
#line 4826
            goto while_break___52;
          }
#line 4829
          if (((int )*(p2 + (2 + idx___0)) & (int )*(p1 + (5 + idx___0))) != 0) {
#line 4830
            goto while_break___52;
          }
#line 4826
          idx___0 ++;
        }
        while_break___52: /* CIL Label */ ;
        }
#line 4832
        if (idx___0 == (int )*(p2 + 1)) {
#line 4834
          *(p + -3) = (unsigned char)17;
        } else
#line 4832
        if (idx___0 == (int )*(p1 + 4)) {
#line 4834
          *(p + -3) = (unsigned char)17;
        }
      }
    }
#line 4840
    p -= 2;
#line 4841
    if ((unsigned int )((re_opcode_t )*(p + -1)) != 17U) {
#line 4843
      *(p + -1) = (unsigned char)13;
#line 4845
      goto unconditional_jump;
    }
    case_17___0: /* CIL Label */ 
#line 4868
    (fail_stack.avail) --;
#line 4868
    string_temp = (unsigned char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 4868
    if ((unsigned long )string_temp != (unsigned long )((void *)0)) {
#line 4868
      sdummy = (char const   *)string_temp;
    }
#line 4868
    (fail_stack.avail) --;
#line 4868
    pdummy = (fail_stack.stack + fail_stack.avail)->pointer;
#line 4868
    (fail_stack.avail) --;
#line 4868
    dummy_high_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 4868
    (fail_stack.avail) --;
#line 4868
    dummy_low_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 4868
    this_reg___2 = dummy_high_reg;
    {
#line 4868
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 4868
      if (! (this_reg___2 >= dummy_low_reg)) {
#line 4868
        goto while_break___53;
      }
#line 4868
      (fail_stack.avail) --;
#line 4868
      (reg_info_dummy + this_reg___2)->word = *(fail_stack.stack + fail_stack.avail);
#line 4868
      (fail_stack.avail) --;
#line 4868
      *(reg_dummy + this_reg___2) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 4868
      (fail_stack.avail) --;
#line 4868
      *(reg_dummy + this_reg___2) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 4868
      this_reg___2 --;
    }
    while_break___53: /* CIL Label */ ;
    }
#line 4868
    set_regs_matched_done = 0;
    unconditional_jump: ;
    case_13___0: /* CIL Label */ 
    {
#line 4884
    while (1) {
      while_continue___54: /* CIL Label */ ;
      {
#line 4884
      while (1) {
        while_continue___55: /* CIL Label */ ;
#line 4884
        mcnt = (int )*p & 255;
#line 4884
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 4884
        goto while_break___55;
      }
      while_break___55: /* CIL Label */ ;
      }
#line 4884
      p += 2;
#line 4884
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
#line 4886
    p += mcnt;
#line 4892
    goto switch_break;
    case_14: /* CIL Label */ ;
#line 4899
    goto unconditional_jump;
    case_19___0: /* CIL Label */ ;
    {
#line 4911
    while (1) {
      while_continue___56: /* CIL Label */ ;
      {
#line 4911
      while (1) {
        while_continue___57: /* CIL Label */ ;
#line 4911
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 4911
          goto while_break___57;
        }
#line 4911
        if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
#line 4911
          tmp___87 = 0;
        } else {
          {
#line 4911
          tmp___84 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
#line 4911
          destination___2 = (char *)tmp___84;
#line 4911
          tmp___85 = memcpy((void */* __restrict  */)destination___2, (void const   */* __restrict  */)fail_stack.stack,
                            (size_t )((unsigned long )fail_stack.size * sizeof(fail_stack_elt_t )));
#line 4911
          fail_stack.stack = (fail_stack_elt_t *)tmp___85;
          }
#line 4911
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 4911
            tmp___86 = 0;
          } else {
#line 4911
            fail_stack.size <<= 1;
#line 4911
            tmp___86 = 1;
          }
#line 4911
          tmp___87 = tmp___86;
        }
#line 4911
        if (! tmp___87) {
#line 4911
          return (-2);
        }
      }
      while_break___57: /* CIL Label */ ;
      }
#line 4911
      this_reg___3 = lowest_active_reg;
      {
#line 4911
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 4911
        if (! (this_reg___3 <= highest_active_reg)) {
#line 4911
          goto while_break___58;
        }
#line 4911
        tmp___88 = fail_stack.avail;
#line 4911
        (fail_stack.avail) ++;
#line 4911
        (fail_stack.stack + tmp___88)->pointer = (unsigned char *)*(regstart + this_reg___3);
#line 4911
        tmp___89 = fail_stack.avail;
#line 4911
        (fail_stack.avail) ++;
#line 4911
        (fail_stack.stack + tmp___89)->pointer = (unsigned char *)*(regend + this_reg___3);
#line 4911
        tmp___90 = fail_stack.avail;
#line 4911
        (fail_stack.avail) ++;
#line 4911
        *(fail_stack.stack + tmp___90) = (reg_info + this_reg___3)->word;
#line 4911
        this_reg___3 ++;
      }
      while_break___58: /* CIL Label */ ;
      }
#line 4911
      tmp___91 = fail_stack.avail;
#line 4911
      (fail_stack.avail) ++;
#line 4911
      (fail_stack.stack + tmp___91)->integer = (int )lowest_active_reg;
#line 4911
      tmp___92 = fail_stack.avail;
#line 4911
      (fail_stack.avail) ++;
#line 4911
      (fail_stack.stack + tmp___92)->integer = (int )highest_active_reg;
#line 4911
      tmp___93 = fail_stack.avail;
#line 4911
      (fail_stack.avail) ++;
#line 4911
      (fail_stack.stack + tmp___93)->pointer = (unsigned char *)((void *)0);
#line 4911
      tmp___94 = fail_stack.avail;
#line 4911
      (fail_stack.avail) ++;
#line 4911
      (fail_stack.stack + tmp___94)->pointer = (unsigned char *)((void *)0);
#line 4911
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
#line 4912
    goto unconditional_jump;
    case_20: /* CIL Label */ ;
    {
#line 4924
    while (1) {
      while_continue___59: /* CIL Label */ ;
      {
#line 4924
      while (1) {
        while_continue___60: /* CIL Label */ ;
#line 4924
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 4924
          goto while_break___60;
        }
#line 4924
        if (fail_stack.size > (unsigned int )(re_max_failures * 19)) {
#line 4924
          tmp___98 = 0;
        } else {
          {
#line 4924
          tmp___95 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
#line 4924
          destination___3 = (char *)tmp___95;
#line 4924
          tmp___96 = memcpy((void */* __restrict  */)destination___3, (void const   */* __restrict  */)fail_stack.stack,
                            (size_t )((unsigned long )fail_stack.size * sizeof(fail_stack_elt_t )));
#line 4924
          fail_stack.stack = (fail_stack_elt_t *)tmp___96;
          }
#line 4924
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 4924
            tmp___97 = 0;
          } else {
#line 4924
            fail_stack.size <<= 1;
#line 4924
            tmp___97 = 1;
          }
#line 4924
          tmp___98 = tmp___97;
        }
#line 4924
        if (! tmp___98) {
#line 4924
          return (-2);
        }
      }
      while_break___60: /* CIL Label */ ;
      }
#line 4924
      this_reg___4 = lowest_active_reg;
      {
#line 4924
      while (1) {
        while_continue___61: /* CIL Label */ ;
#line 4924
        if (! (this_reg___4 <= highest_active_reg)) {
#line 4924
          goto while_break___61;
        }
#line 4924
        tmp___99 = fail_stack.avail;
#line 4924
        (fail_stack.avail) ++;
#line 4924
        (fail_stack.stack + tmp___99)->pointer = (unsigned char *)*(regstart + this_reg___4);
#line 4924
        tmp___100 = fail_stack.avail;
#line 4924
        (fail_stack.avail) ++;
#line 4924
        (fail_stack.stack + tmp___100)->pointer = (unsigned char *)*(regend + this_reg___4);
#line 4924
        tmp___101 = fail_stack.avail;
#line 4924
        (fail_stack.avail) ++;
#line 4924
        *(fail_stack.stack + tmp___101) = (reg_info + this_reg___4)->word;
#line 4924
        this_reg___4 ++;
      }
      while_break___61: /* CIL Label */ ;
      }
#line 4924
      tmp___102 = fail_stack.avail;
#line 4924
      (fail_stack.avail) ++;
#line 4924
      (fail_stack.stack + tmp___102)->integer = (int )lowest_active_reg;
#line 4924
      tmp___103 = fail_stack.avail;
#line 4924
      (fail_stack.avail) ++;
#line 4924
      (fail_stack.stack + tmp___103)->integer = (int )highest_active_reg;
#line 4924
      tmp___104 = fail_stack.avail;
#line 4924
      (fail_stack.avail) ++;
#line 4924
      (fail_stack.stack + tmp___104)->pointer = (unsigned char *)((void *)0);
#line 4924
      tmp___105 = fail_stack.avail;
#line 4924
      (fail_stack.avail) ++;
#line 4924
      (fail_stack.stack + tmp___105)->pointer = (unsigned char *)((void *)0);
#line 4924
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
#line 4925
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 4930
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 4930
      mcnt = (int )*(p + 2) & 255;
#line 4930
      mcnt += (int )((signed char )*((p + 2) + 1)) << 8;
#line 4930
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
#line 4935
    if (mcnt > 0) {
#line 4937
      mcnt --;
#line 4938
      p += 2;
      {
#line 4939
      while (1) {
        while_continue___63: /* CIL Label */ ;
        {
#line 4939
        while (1) {
          while_continue___64: /* CIL Label */ ;
#line 4939
          *(p + 0) = (unsigned char )(mcnt & 255);
#line 4939
          *(p + 1) = (unsigned char )(mcnt >> 8);
#line 4939
          goto while_break___64;
        }
        while_break___64: /* CIL Label */ ;
        }
#line 4939
        p += 2;
#line 4939
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
    } else
#line 4946
    if (mcnt == 0) {
#line 4953
      *(p + 2) = (unsigned char)0;
#line 4954
      *(p + 3) = (unsigned char)0;
#line 4955
      goto on_failure;
    }
#line 4957
    goto switch_break;
    case_22___0: /* CIL Label */ 
    {
#line 4960
    while (1) {
      while_continue___65: /* CIL Label */ ;
#line 4960
      mcnt = (int )*(p + 2) & 255;
#line 4960
      mcnt += (int )((signed char )*((p + 2) + 1)) << 8;
#line 4960
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
#line 4964
    if (mcnt) {
#line 4966
      mcnt --;
      {
#line 4967
      while (1) {
        while_continue___66: /* CIL Label */ ;
#line 4967
        *((p + 2) + 0) = (unsigned char )(mcnt & 255);
#line 4967
        *((p + 2) + 1) = (unsigned char )(mcnt >> 8);
#line 4967
        goto while_break___66;
      }
      while_break___66: /* CIL Label */ ;
      }
#line 4973
      goto unconditional_jump;
    } else {
#line 4977
      p += 4;
    }
#line 4978
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 4984
    while (1) {
      while_continue___67: /* CIL Label */ ;
      {
#line 4984
      while (1) {
        while_continue___68: /* CIL Label */ ;
#line 4984
        mcnt = (int )*p & 255;
#line 4984
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 4984
        goto while_break___68;
      }
      while_break___68: /* CIL Label */ ;
      }
#line 4984
      p += 2;
#line 4984
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
#line 4985
    p1 = p + mcnt;
    {
#line 4986
    while (1) {
      while_continue___69: /* CIL Label */ ;
      {
#line 4986
      while (1) {
        while_continue___70: /* CIL Label */ ;
#line 4986
        mcnt = (int )*p & 255;
#line 4986
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 4986
        goto while_break___70;
      }
      while_break___70: /* CIL Label */ ;
      }
#line 4986
      p += 2;
#line 4986
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
#line 4992
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 4992
      *(p1 + 0) = (unsigned char )(mcnt & 255);
#line 4992
      *(p1 + 1) = (unsigned char )(mcnt >> 8);
#line 4992
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
#line 4993
    goto switch_break;
    case_28: /* CIL Label */ 
#line 5019
    if (size1) {
#line 5019
      tmp___106 = string1;
    } else {
#line 5019
      tmp___106 = string2;
    }
#line 5019
    if ((unsigned long )d == (unsigned long )tmp___106) {
#line 5020
      goto switch_break;
    } else
#line 5019
    if (! size2) {
#line 5020
      goto switch_break;
    } else
#line 5019
    if ((unsigned long )d == (unsigned long )end2) {
#line 5020
      goto switch_break;
    }
#line 5022
    if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 5022
      tmp___108 = (int const   )*string2;
    } else {
#line 5022
      if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 5022
        tmp___107 = (int const   )*(end1 - 1);
      } else {
#line 5022
        tmp___107 = (int const   )*(d - 1);
      }
#line 5022
      tmp___108 = tmp___107;
    }
#line 5022
    prevchar = (boolean )((int )*(re_syntax_table + tmp___108) == 1);
#line 5023
    if ((unsigned long )d == (unsigned long )end1) {
#line 5023
      tmp___110 = (int const   )*string2;
    } else {
#line 5023
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 5023
        tmp___109 = (int const   )*(end1 - 1);
      } else {
#line 5023
        tmp___109 = (int const   )*d;
      }
#line 5023
      tmp___110 = tmp___109;
    }
#line 5023
    thischar = (boolean )((int )*(re_syntax_table + tmp___110) == 1);
#line 5024
    if ((int )prevchar != (int )thischar) {
#line 5025
      goto switch_break;
    }
#line 5026
    goto fail;
    case_29: /* CIL Label */ 
#line 5034
    if (size1) {
#line 5034
      tmp___111 = string1;
    } else {
#line 5034
      tmp___111 = string2;
    }
#line 5034
    if ((unsigned long )d == (unsigned long )tmp___111) {
#line 5035
      goto fail;
    } else
#line 5034
    if (! size2) {
#line 5035
      goto fail;
    } else
#line 5034
    if ((unsigned long )d == (unsigned long )end2) {
#line 5035
      goto fail;
    }
#line 5037
    if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 5037
      tmp___113 = (int const   )*string2;
    } else {
#line 5037
      if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 5037
        tmp___112 = (int const   )*(end1 - 1);
      } else {
#line 5037
        tmp___112 = (int const   )*(d - 1);
      }
#line 5037
      tmp___113 = tmp___112;
    }
#line 5037
    prevchar___0 = (boolean )((int )*(re_syntax_table + tmp___113) == 1);
#line 5038
    if ((unsigned long )d == (unsigned long )end1) {
#line 5038
      tmp___115 = (int const   )*string2;
    } else {
#line 5038
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 5038
        tmp___114 = (int const   )*(end1 - 1);
      } else {
#line 5038
        tmp___114 = (int const   )*d;
      }
#line 5038
      tmp___115 = tmp___114;
    }
#line 5038
    thischar___0 = (boolean )((int )*(re_syntax_table + tmp___115) == 1);
#line 5039
    if ((int )prevchar___0 != (int )thischar___0) {
#line 5040
      goto fail;
    }
#line 5041
    goto switch_break;
    case_26: /* CIL Label */ ;
#line 5047
    if ((unsigned long )d == (unsigned long )end1) {
#line 5047
      tmp___117 = (int const   )*string2;
    } else {
#line 5047
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 5047
        tmp___116 = (int const   )*(end1 - 1);
      } else {
#line 5047
        tmp___116 = (int const   )*d;
      }
#line 5047
      tmp___117 = tmp___116;
    }
#line 5047
    if ((int )*(re_syntax_table + tmp___117) == 1) {
#line 5047
      if (size1) {
#line 5047
        tmp___118 = string1;
      } else {
#line 5047
        tmp___118 = string2;
      }
#line 5047
      if ((unsigned long )d == (unsigned long )tmp___118) {
#line 5048
        goto switch_break;
      } else
#line 5047
      if (! size2) {
#line 5048
        goto switch_break;
      } else {
#line 5047
        if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 5047
          tmp___120 = (int const   )*string2;
        } else {
#line 5047
          if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 5047
            tmp___119 = (int const   )*(end1 - 1);
          } else {
#line 5047
            tmp___119 = (int const   )*(d - 1);
          }
#line 5047
          tmp___120 = tmp___119;
        }
#line 5047
        if (! ((int )*(re_syntax_table + tmp___120) == 1)) {
#line 5048
          goto switch_break;
        }
      }
    }
#line 5049
    goto fail;
    case_27: /* CIL Label */ ;
#line 5053
    if (size1) {
#line 5053
      tmp___121 = string1;
    } else {
#line 5053
      tmp___121 = string2;
    }
#line 5053
    if (! ((unsigned long )d == (unsigned long )tmp___121)) {
#line 5053
      if (! (! size2)) {
#line 5053
        if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 5053
          tmp___123 = (int const   )*string2;
        } else {
#line 5053
          if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 5053
            tmp___122 = (int const   )*(end1 - 1);
          } else {
#line 5053
            tmp___122 = (int const   )*(d - 1);
          }
#line 5053
          tmp___123 = tmp___122;
        }
#line 5053
        if ((int )*(re_syntax_table + tmp___123) == 1) {
#line 5053
          if ((unsigned long )d == (unsigned long )end1) {
#line 5053
            tmp___125 = (int const   )*string2;
          } else {
#line 5053
            if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 5053
              tmp___124 = (int const   )*(end1 - 1);
            } else {
#line 5053
              tmp___124 = (int const   )*d;
            }
#line 5053
            tmp___125 = tmp___124;
          }
#line 5053
          if ((int )*(re_syntax_table + tmp___125) == 1) {
#line 5053
            if ((unsigned long )d == (unsigned long )end2) {
#line 5055
              goto switch_break;
            }
          } else {
#line 5055
            goto switch_break;
          }
        }
      }
    }
#line 5056
    goto fail;
    case_24: /* CIL Label */ ;
    {
#line 5114
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 5114
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 5114
        goto while_break___72;
      }
#line 5114
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 5114
        goto fail;
      }
#line 5114
      d = string2;
#line 5114
      dend = end_match_2;
    }
    while_break___72: /* CIL Label */ ;
    }
#line 5115
    if ((unsigned long )d == (unsigned long )end1) {
#line 5115
      tmp___127 = (int const   )*string2;
    } else {
#line 5115
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 5115
        tmp___126 = (int const   )*(end1 - 1);
      } else {
#line 5115
        tmp___126 = (int const   )*d;
      }
#line 5115
      tmp___127 = tmp___126;
    }
#line 5115
    if (! ((int )*(re_syntax_table + tmp___127) == 1)) {
#line 5116
      goto fail;
    }
    {
#line 5117
    while (1) {
      while_continue___73: /* CIL Label */ ;
#line 5117
      if (! set_regs_matched_done) {
#line 5117
        set_regs_matched_done = 1;
#line 5117
        r___5 = lowest_active_reg;
        {
#line 5117
        while (1) {
          while_continue___74: /* CIL Label */ ;
#line 5117
          if (! (r___5 <= highest_active_reg)) {
#line 5117
            goto while_break___74;
          }
#line 5117
          tmp___128 = 1U;
#line 5117
          (reg_info + r___5)->bits.ever_matched_something = tmp___128;
#line 5117
          (reg_info + r___5)->bits.matched_something = tmp___128;
#line 5117
          r___5 ++;
        }
        while_break___74: /* CIL Label */ ;
        }
      }
#line 5117
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
#line 5118
    d ++;
#line 5119
    goto switch_break;
    case_25: /* CIL Label */ ;
    {
#line 5123
    while (1) {
      while_continue___75: /* CIL Label */ ;
#line 5123
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 5123
        goto while_break___75;
      }
#line 5123
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 5123
        goto fail;
      }
#line 5123
      d = string2;
#line 5123
      dend = end_match_2;
    }
    while_break___75: /* CIL Label */ ;
    }
#line 5124
    if ((unsigned long )d == (unsigned long )end1) {
#line 5124
      tmp___130 = (int const   )*string2;
    } else {
#line 5124
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 5124
        tmp___129 = (int const   )*(end1 - 1);
      } else {
#line 5124
        tmp___129 = (int const   )*d;
      }
#line 5124
      tmp___130 = tmp___129;
    }
#line 5124
    if ((int )*(re_syntax_table + tmp___130) == 1) {
#line 5125
      goto fail;
    }
    {
#line 5126
    while (1) {
      while_continue___76: /* CIL Label */ ;
#line 5126
      if (! set_regs_matched_done) {
#line 5126
        set_regs_matched_done = 1;
#line 5126
        r___6 = lowest_active_reg;
        {
#line 5126
        while (1) {
          while_continue___77: /* CIL Label */ ;
#line 5126
          if (! (r___6 <= highest_active_reg)) {
#line 5126
            goto while_break___77;
          }
#line 5126
          tmp___131 = 1U;
#line 5126
          (reg_info + r___6)->bits.ever_matched_something = tmp___131;
#line 5126
          (reg_info + r___6)->bits.matched_something = tmp___131;
#line 5126
          r___6 ++;
        }
        while_break___77: /* CIL Label */ ;
        }
      }
#line 5126
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
#line 5127
    d ++;
#line 5128
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 5132
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 5134
    goto __Cont;
    fail: 
#line 5139
    if (! (fail_stack.avail == 0U)) {
#line 5142
      (fail_stack.avail) --;
#line 5142
      string_temp___0 = (unsigned char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 5142
      if ((unsigned long )string_temp___0 != (unsigned long )((void *)0)) {
#line 5142
        d = (char const   *)string_temp___0;
      }
#line 5142
      (fail_stack.avail) --;
#line 5142
      p = (fail_stack.stack + fail_stack.avail)->pointer;
#line 5142
      (fail_stack.avail) --;
#line 5142
      highest_active_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 5142
      (fail_stack.avail) --;
#line 5142
      lowest_active_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 5142
      this_reg___5 = highest_active_reg;
      {
#line 5142
      while (1) {
        while_continue___78: /* CIL Label */ ;
#line 5142
        if (! (this_reg___5 >= lowest_active_reg)) {
#line 5142
          goto while_break___78;
        }
#line 5142
        (fail_stack.avail) --;
#line 5142
        (reg_info + this_reg___5)->word = *(fail_stack.stack + fail_stack.avail);
#line 5142
        (fail_stack.avail) --;
#line 5142
        *(regend + this_reg___5) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 5142
        (fail_stack.avail) --;
#line 5142
        *(regstart + this_reg___5) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 5142
        this_reg___5 --;
      }
      while_break___78: /* CIL Label */ ;
      }
#line 5142
      set_regs_matched_done = 0;
#line 5147
      if (! p) {
#line 5148
        goto fail;
      }
#line 5152
      if ((unsigned long )p < (unsigned long )pend) {
#line 5154
        is_a_jump_n___0 = (boolean )0;
        {
#line 5160
        if ((unsigned int )((re_opcode_t )*p) == 22U) {
#line 5160
          goto case_22___1;
        }
#line 5164
        if ((unsigned int )((re_opcode_t )*p) == 13U) {
#line 5164
          goto case_13___1;
        }
#line 5164
        if ((unsigned int )((re_opcode_t )*p) == 17U) {
#line 5164
          goto case_13___1;
        }
#line 5164
        if ((unsigned int )((re_opcode_t )*p) == 18U) {
#line 5164
          goto case_13___1;
        }
#line 5174
        goto switch_default___1;
        case_22___1: /* CIL Label */ 
#line 5161
        is_a_jump_n___0 = (boolean )1;
        case_13___1: /* CIL Label */ 
        case_17___1: /* CIL Label */ 
        case_18___1: /* CIL Label */ 
#line 5165
        p1 = p + 1;
        {
#line 5166
        while (1) {
          while_continue___79: /* CIL Label */ ;
          {
#line 5166
          while (1) {
            while_continue___80: /* CIL Label */ ;
#line 5166
            mcnt = (int )*p1 & 255;
#line 5166
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 5166
            goto while_break___80;
          }
          while_break___80: /* CIL Label */ ;
          }
#line 5166
          p1 += 2;
#line 5166
          goto while_break___79;
        }
        while_break___79: /* CIL Label */ ;
        }
#line 5167
        p1 += mcnt;
#line 5169
        if (is_a_jump_n___0) {
#line 5169
          if ((unsigned int )((re_opcode_t )*p1) == 21U) {
#line 5172
            goto fail;
          } else {
#line 5169
            goto _L___20;
          }
        } else
        _L___20: /* CIL Label */ 
#line 5169
        if (! is_a_jump_n___0) {
#line 5169
          if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 5172
            goto fail;
          }
        }
#line 5173
        goto switch_break___1;
        switch_default___1: /* CIL Label */ ;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 5179
      if ((unsigned long )d >= (unsigned long )string1) {
#line 5179
        if ((unsigned long )d <= (unsigned long )end1) {
#line 5180
          dend = end_match_1;
        }
      }
    } else {
#line 5183
      goto while_break___3;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 5186
  if (best_regs_set) {
#line 5187
    goto restore_best_regs;
  }
  {
#line 5189
  while (1) {
    while_continue___81: /* CIL Label */ ;
#line 5189
    regstart = (char const   **)((void *)0);
#line 5189
    regend = (char const   **)((void *)0);
#line 5189
    old_regstart = (char const   **)((void *)0);
#line 5189
    old_regend = (char const   **)((void *)0);
#line 5189
    best_regstart = (char const   **)((void *)0);
#line 5189
    best_regend = (char const   **)((void *)0);
#line 5189
    reg_info = (register_info_type *)((void *)0);
#line 5189
    reg_dummy = (char const   **)((void *)0);
#line 5189
    reg_info_dummy = (register_info_type *)((void *)0);
#line 5189
    goto while_break___81;
  }
  while_break___81: /* CIL Label */ ;
  }
#line 5191
  return (-1);
}
}
#line 5207 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static boolean group_match_null_string_p(unsigned char **p , unsigned char *end ,
                                         register_info_type *reg_info ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  boolean tmp ;
  boolean tmp___0 ;
  boolean tmp___1 ;

  {
#line 5214
  p1 = *p + 2;
  {
#line 5216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5216
    if (! ((unsigned long )p1 < (unsigned long )end)) {
#line 5216
      goto while_break;
    }
    {
#line 5225
    if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 5225
      goto case_15;
    }
#line 5296
    if ((unsigned int )((re_opcode_t )*p1) == 7U) {
#line 5296
      goto case_7;
    }
#line 5302
    goto switch_default;
    case_15: /* CIL Label */ 
#line 5226
    p1 ++;
    {
#line 5227
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 5227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5227
        mcnt = (int )*p1 & 255;
#line 5227
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 5227
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5227
      p1 += 2;
#line 5227
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5232
    if (mcnt >= 0) {
      {
#line 5252
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5252
        if (! ((unsigned int )((re_opcode_t )*(p1 + (mcnt - 3))) == 14U)) {
#line 5252
          goto while_break___2;
        }
        {
#line 5258
        tmp = alt_match_null_string_p(p1, (p1 + mcnt) - 3, reg_info);
        }
#line 5258
        if (! tmp) {
#line 5260
          return ((boolean )0);
        }
#line 5264
        p1 += mcnt;
#line 5268
        if ((unsigned int )((re_opcode_t )*p1) != 15U) {
#line 5269
          goto while_break___2;
        }
#line 5273
        p1 ++;
        {
#line 5274
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 5274
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 5274
            mcnt = (int )*p1 & 255;
#line 5274
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 5274
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 5274
          p1 += 2;
#line 5274
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 5275
        if ((unsigned int )((re_opcode_t )*(p1 + (mcnt - 3))) != 14U) {
#line 5278
          p1 -= 3;
#line 5279
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 5286
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 5286
        mcnt = (int )*(p1 - 2) & 255;
#line 5286
        mcnt += (int )((signed char )*((p1 - 2) + 1)) << 8;
#line 5286
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 5288
      tmp___0 = alt_match_null_string_p(p1, p1 + mcnt, reg_info);
      }
#line 5288
      if (! tmp___0) {
#line 5289
        return ((boolean )0);
      }
#line 5291
      p1 += mcnt;
    }
#line 5293
    goto switch_break;
    case_7: /* CIL Label */ 
#line 5298
    *p = p1 + 2;
#line 5299
    return ((boolean )1);
    switch_default: /* CIL Label */ 
    {
#line 5303
    tmp___1 = common_op_match_null_string_p(& p1, end, reg_info);
    }
#line 5303
    if (! tmp___1) {
#line 5304
      return ((boolean )0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5308
  return ((boolean )0);
}
}
#line 5316 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static boolean alt_match_null_string_p(unsigned char *p , unsigned char *end , register_info_type *reg_info ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  boolean tmp ;

  {
#line 5322
  p1 = p;
  {
#line 5324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5324
    if (! ((unsigned long )p1 < (unsigned long )end)) {
#line 5324
      goto while_break;
    }
    {
#line 5332
    if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 5332
      goto case_15;
    }
#line 5338
    goto switch_default;
    case_15: /* CIL Label */ 
#line 5333
    p1 ++;
    {
#line 5334
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 5334
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5334
        mcnt = (int )*p1 & 255;
#line 5334
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 5334
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5334
      p1 += 2;
#line 5334
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5335
    p1 += mcnt;
#line 5336
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 5339
    tmp = common_op_match_null_string_p(& p1, end, reg_info);
    }
#line 5339
    if (! tmp) {
#line 5340
      return ((boolean )0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5344
  return ((boolean )1);
}
}
#line 5353 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static boolean common_op_match_null_string_p(unsigned char **p , unsigned char *end ,
                                             register_info_type *reg_info ) 
{ 
  int mcnt ;
  boolean ret ;
  int reg_no ;
  unsigned char *p1 ;
  unsigned char *tmp ;

  {
#line 5361
  p1 = *p;
#line 5363
  tmp = p1;
#line 5363
  p1 ++;
  {
#line 5373
  if ((unsigned int )((re_opcode_t )*tmp) == 29U) {
#line 5373
    goto case_29;
  }
#line 5373
  if ((unsigned int )((re_opcode_t )*tmp) == 28U) {
#line 5373
    goto case_29;
  }
#line 5373
  if ((unsigned int )((re_opcode_t )*tmp) == 27U) {
#line 5373
    goto case_29;
  }
#line 5373
  if ((unsigned int )((re_opcode_t )*tmp) == 26U) {
#line 5373
    goto case_29;
  }
#line 5373
  if ((unsigned int )((re_opcode_t )*tmp) == 12U) {
#line 5373
    goto case_29;
  }
#line 5373
  if ((unsigned int )((re_opcode_t )*tmp) == 11U) {
#line 5373
    goto case_29;
  }
#line 5373
  if ((unsigned int )((re_opcode_t )*tmp) == 10U) {
#line 5373
    goto case_29;
  }
#line 5373
  if ((unsigned int )((re_opcode_t )*tmp) == 9U) {
#line 5373
    goto case_29;
  }
#line 5373
  if ((unsigned int )((re_opcode_t )*tmp) == 0U) {
#line 5373
    goto case_29;
  }
#line 5381
  if ((unsigned int )((re_opcode_t )*tmp) == 6U) {
#line 5381
    goto case_6;
  }
#line 5397
  if ((unsigned int )((re_opcode_t )*tmp) == 13U) {
#line 5397
    goto case_13;
  }
#line 5405
  if ((unsigned int )((re_opcode_t )*tmp) == 21U) {
#line 5405
    goto case_21;
  }
#line 5420
  if ((unsigned int )((re_opcode_t )*tmp) == 8U) {
#line 5420
    goto case_8;
  }
#line 5425
  if ((unsigned int )((re_opcode_t )*tmp) == 23U) {
#line 5425
    goto case_23;
  }
#line 5428
  goto switch_default;
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 5379
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 5382
  reg_no = (int )*p1;
#line 5384
  ret = group_match_null_string_p(& p1, end, reg_info);
  }
#line 5389
  if ((reg_info + reg_no)->bits.match_null_string_p == 3U) {
#line 5390
    (reg_info + reg_no)->bits.match_null_string_p = (unsigned int )ret;
  }
#line 5392
  if (! ret) {
#line 5393
    return ((boolean )0);
  }
#line 5394
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 5398
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5398
      mcnt = (int )*p1 & 255;
#line 5398
      mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 5398
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5398
    p1 += 2;
#line 5398
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5399
  if (mcnt >= 0) {
#line 5400
    p1 += mcnt;
  } else {
#line 5402
    return ((boolean )0);
  }
#line 5403
  goto switch_break;
  case_21: /* CIL Label */ 
#line 5407
  p1 += 2;
  {
#line 5408
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 5408
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5408
      mcnt = (int )*p1 & 255;
#line 5408
      mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 5408
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 5408
    p1 += 2;
#line 5408
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 5410
  if (mcnt == 0) {
#line 5412
    p1 -= 4;
    {
#line 5413
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 5413
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 5413
        mcnt = (int )*p1 & 255;
#line 5413
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 5413
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 5413
      p1 += 2;
#line 5413
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 5414
    p1 += mcnt;
  } else {
#line 5417
    return ((boolean )0);
  }
#line 5418
  goto switch_break;
  case_8: /* CIL Label */ 
#line 5421
  if (! (reg_info + *p1)->bits.match_null_string_p) {
#line 5422
    return ((boolean )0);
  }
#line 5423
  goto switch_break;
  case_23: /* CIL Label */ 
#line 5426
  p1 += 4;
  switch_default: /* CIL Label */ 
#line 5430
  return ((boolean )0);
  switch_break: /* CIL Label */ ;
  }
#line 5433
  *p = p1;
#line 5434
  return ((boolean )1);
}
}
#line 5441 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
static int bcmp_translate(char const   *s1 , char const   *s2 , int len , char *translate ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;

  {
#line 5447
  p1 = (unsigned char const   *)s1;
#line 5448
  p2 = (unsigned char const   *)s2;
  {
#line 5449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5449
    if (! len) {
#line 5449
      goto while_break;
    }
#line 5451
    tmp = p1;
#line 5451
    p1 ++;
#line 5451
    tmp___0 = p2;
#line 5451
    p2 ++;
#line 5451
    if ((int )*(translate + *tmp) != (int )*(translate + *tmp___0)) {
#line 5451
      return (1);
    }
#line 5452
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 5454
  return (0);
}
}
#line 5468 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ 
  reg_errcode_t ret ;

  {
  {
#line 5478
  bufp->regs_allocated = 0U;
#line 5483
  bufp->no_sub = 0U;
#line 5486
  bufp->newline_anchor = 1U;
#line 5488
  ret = regex_compile(pattern, length, re_syntax_options, bufp);
  }
#line 5490
  if (! ret) {
#line 5491
    return ((char const   *)((void *)0));
  }
#line 5492
  return (re_error_msgid[(int )ret]);
}
}
#line 5606 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
int regcomp(regex_t *preg , char const   *pattern , int cflags ) 
{ 
  reg_errcode_t ret ;
  reg_syntax_t syntax ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned int i ;
  void *tmp___1 ;
  __int32_t const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 5613
  if (cflags & 1) {
#line 5613
    tmp = (((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 5613
    tmp = ((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1);
  }
  {
#line 5613
  syntax = tmp;
#line 5618
  preg->buffer = (unsigned char *)0;
#line 5619
  preg->allocated = 0UL;
#line 5620
  preg->used = 0UL;
#line 5623
  tmp___0 = malloc((size_t )(1 << 8));
#line 5623
  preg->fastmap = (char *)tmp___0;
  }
#line 5625
  if (cflags & (1 << 1)) {
    {
#line 5629
    tmp___1 = malloc((size_t )(256UL * sizeof(*((char *)0))));
#line 5629
    preg->translate = (char *)tmp___1;
    }
#line 5632
    if ((unsigned long )preg->translate == (unsigned long )((void *)0)) {
#line 5633
      return (12);
    }
#line 5636
    i = 0U;
    {
#line 5636
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5636
      if (! (i < 256U)) {
#line 5636
        goto while_break;
      }
      {
#line 5637
      tmp___4 = __ctype_b_loc();
      }
#line 5637
      if ((int const   )*(*tmp___4 + (int )i) & 256) {
        {
#line 5637
        tmp___3 = __ctype_tolower_loc();
#line 5637
        *(preg->translate + i) = (char )((int )*(*tmp___3 + (int )i));
        }
      } else {
#line 5637
        *(preg->translate + i) = (char )i;
      }
#line 5636
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 5640
    preg->translate = (char *)((void *)0);
  }
#line 5643
  if (cflags & ((1 << 1) << 1)) {
#line 5645
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
#line 5646
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
#line 5648
    preg->newline_anchor = 1U;
  } else {
#line 5651
    preg->newline_anchor = 0U;
  }
  {
#line 5653
  preg->no_sub = (unsigned int )(! (! (cflags & (((1 << 1) << 1) << 1))));
#line 5657
  tmp___5 = strlen(pattern);
#line 5657
  ret = regex_compile(pattern, tmp___5, syntax, preg);
  }
#line 5661
  if ((int )ret == 16) {
#line 5661
    ret = (reg_errcode_t )8;
  }
#line 5663
  if ((int )ret == 0) {
#line 5663
    if (preg->fastmap) {
      {
#line 5667
      tmp___6 = re_compile_fastmap(preg);
      }
#line 5667
      if (tmp___6 == -2) {
        {
#line 5671
        free((void *)preg->fastmap);
#line 5672
        preg->fastmap = (char *)((void *)0);
        }
      }
    }
  }
#line 5676
  return ((int )ret);
}
}
#line 5697 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
int regexec(regex_t const   *preg , char const   *string , size_t nmatch , regmatch_t *pmatch ,
            int eflags ) 
{ 
  int ret ;
  struct re_registers regs ;
  regex_t private_preg ;
  int len ;
  size_t tmp ;
  boolean want_reg_info ;
  int tmp___0 ;
  void *tmp___1 ;
  struct re_registers *tmp___2 ;
  unsigned int r ;
  int tmp___3 ;

  {
  {
#line 5708
  tmp = strlen(string);
#line 5708
  len = (int )tmp;
  }
#line 5709
  if (! preg->no_sub) {
#line 5709
    if (nmatch > 0U) {
#line 5709
      tmp___0 = 1;
    } else {
#line 5709
      tmp___0 = 0;
    }
  } else {
#line 5709
    tmp___0 = 0;
  }
#line 5709
  want_reg_info = (boolean )tmp___0;
#line 5711
  private_preg = (regex_t )*preg;
#line 5713
  private_preg.not_bol = (unsigned int )(! (! (eflags & 1)));
#line 5714
  private_preg.not_eol = (unsigned int )(! (! (eflags & (1 << 1))));
#line 5719
  private_preg.regs_allocated = 2U;
#line 5721
  if (want_reg_info) {
    {
#line 5723
    regs.num_regs = nmatch;
#line 5724
    tmp___1 = malloc((size_t )((unsigned long )(nmatch * 2U) * sizeof(regoff_t )));
#line 5724
    regs.start = (regoff_t *)tmp___1;
    }
#line 5725
    if ((unsigned long )regs.start == (unsigned long )((void *)0)) {
#line 5726
      return (1);
    }
#line 5727
    regs.end = regs.start + nmatch;
  }
#line 5731
  if (want_reg_info) {
#line 5731
    tmp___2 = & regs;
  } else {
#line 5731
    tmp___2 = (struct re_registers *)0;
  }
  {
#line 5731
  ret = re_search(& private_preg, string, len, 0, len, tmp___2);
  }
#line 5736
  if (want_reg_info) {
#line 5738
    if (ret >= 0) {
#line 5742
      r = 0U;
      {
#line 5742
      while (1) {
        while_continue: /* CIL Label */ ;
#line 5742
        if (! (r < nmatch)) {
#line 5742
          goto while_break;
        }
#line 5744
        (pmatch + r)->rm_so = *(regs.start + r);
#line 5745
        (pmatch + r)->rm_eo = *(regs.end + r);
#line 5742
        r ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 5750
    free((void *)regs.start);
    }
  }
#line 5754
  if (ret >= 0) {
#line 5754
    tmp___3 = 0;
  } else {
#line 5754
    tmp___3 = 1;
  }
#line 5754
  return (tmp___3);
}
}
#line 5764 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
size_t regerror(int errcode , regex_t const   *preg , char *errbuf , size_t errbuf_size ) 
{ 
  char const   *msg ;
  size_t msg_size ;
  size_t tmp ;

  {
#line 5774
  if (errcode < 0) {
    {
#line 5781
    abort();
    }
  } else
#line 5774
  if (errcode >= (int )(sizeof(re_error_msgid) / sizeof(re_error_msgid[0]))) {
    {
#line 5781
    abort();
    }
  }
  {
#line 5783
  msg = re_error_msgid[errcode];
#line 5785
  tmp = strlen(msg);
#line 5785
  msg_size = tmp + 1U;
  }
#line 5787
  if (errbuf_size != 0U) {
#line 5789
    if (msg_size > errbuf_size) {
      {
#line 5794
      memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg,
             errbuf_size - 1U);
#line 5795
      *(errbuf + (errbuf_size - 1U)) = (char)0;
      }
    } else {
      {
#line 5799
      memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg,
             msg_size);
      }
    }
  }
#line 5802
  return (msg_size);
}
}
#line 5811 "/home/ysko/Works/test-src/a2ps-4.14/src/regex.c"
void regfree(regex_t *preg ) 
{ 


  {
#line 5815
  if ((unsigned long )preg->buffer != (unsigned long )((void *)0)) {
    {
#line 5816
    free((void *)preg->buffer);
    }
  }
#line 5817
  preg->buffer = (unsigned char *)((void *)0);
#line 5819
  preg->allocated = 0UL;
#line 5820
  preg->used = 0UL;
#line 5822
  if ((unsigned long )preg->fastmap != (unsigned long )((void *)0)) {
    {
#line 5823
    free((void *)preg->fastmap);
    }
  }
#line 5824
  preg->fastmap = (char *)((void *)0);
#line 5825
  preg->fastmap_accurate = 0U;
#line 5827
  if ((unsigned long )preg->translate != (unsigned long )((void *)0)) {
    {
#line 5828
    free((void *)preg->translate);
    }
  }
#line 5829
  preg->translate = (char *)((void *)0);
#line 5830
  return;
}
}
#line 49 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.h"
struct hash_table_s *delegation_table_new(void) ;
#line 50
void delegation_table_free(struct hash_table_s *table ) ;
#line 52
void add_delegation(char const   *filename , int line , char *contract_line ) ;
#line 54
struct delegation *get_subcontract(char const   *src_type , char const   *dest_type ) ;
#line 56
char *get_delegate_command(struct delegation *contract , struct file_job *file , int evaluate ) ;
#line 60
int subcontract(struct file_job *fjob , buffer_t *buffer , struct delegation *contractor ) ;
#line 65
void delegations_list_long(struct hash_table_s *contracts , FILE *stream ) ;
#line 67
void delegations_list_short(struct hash_table_s *contracts , FILE *stream ) ;
#line 44 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
struct hash_table_s *delegation_table ;
#line 53 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
static unsigned long delegate_hash_1(void const   *key ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    result = 0UL;
    {
#line 56
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 56
      kk = (unsigned char const   *)((struct delegation  const  *)key)->contract - 1;
      {
#line 56
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 56
        kk ++;
#line 56
        if (! *kk) {
#line 56
          goto while_break___1;
        }
#line 56
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 56
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 56
    return (result);
#line 56
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (0UL);
}
}
#line 59 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
static unsigned long delegate_hash_2(void const   *key ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    result = 0UL;
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      kk = (unsigned char const   *)((struct delegation  const  *)key)->contract - 1;
      {
#line 62
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 62
        kk ++;
#line 62
        if (! *kk) {
#line 62
          goto while_break___1;
        }
#line 62
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 62
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 62
    return (result);
#line 62
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (0UL);
}
}
#line 65 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
static int delegate_hash_cmp(void const   *x , void const   *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 68
      xx = (unsigned char const   *)((struct delegation  const  *)x)->contract - 1;
#line 68
      yy = (unsigned char const   *)((struct delegation  const  *)y)->contract - 1;
      {
#line 68
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 68
        xx ++;
#line 68
        if ((int const   )*xx == 0) {
#line 68
          yy ++;
#line 68
          goto while_break___1;
        }
#line 68
        yy ++;
#line 68
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 68
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 68
      result = (int )((int const   )*xx - (int const   )*yy);
#line 68
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 68
    return (result);
#line 68
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return (0);
}
}
#line 72 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
static int delegate_hash_qcmp(struct delegation  const  **x , struct delegation  const  **y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 76
      xx = (unsigned char const   *)(*x)->name - 1;
#line 76
      yy = (unsigned char const   *)(*y)->name - 1;
      {
#line 76
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 76
        xx ++;
#line 76
        if ((int const   )*xx == 0) {
#line 76
          yy ++;
#line 76
          goto while_break___1;
        }
#line 76
        yy ++;
#line 76
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 76
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 76
      result = (int )((int const   )*xx - (int const   )*yy);
#line 76
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 76
    return (result);
#line 76
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return (0);
}
}
#line 79 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
static size_t delegate_name_len(struct delegation *delegation ) 
{ 
  size_t tmp ;

  {
  {
#line 82
  tmp = strlen((char const   *)delegation->name);
  }
#line 82
  return (tmp);
}
}
#line 85 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
static void delegate_name_fputs(struct delegation *delegation , FILE *stream ) 
{ 


  {
  {
#line 88
  fputs((char const   */* __restrict  */)delegation->name, (FILE */* __restrict  */)stream);
  }
#line 89
  return;
}
}
#line 91 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
static void delegate_free(struct delegation *delegation ) 
{ 


  {
  {
#line 94
  free((void *)delegation->name);
#line 95
  free((void *)delegation->contract);
#line 96
  free((void *)delegation->command);
#line 97
  free((void *)delegation);
  }
#line 98
  return;
}
}
#line 103 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
struct hash_table_s *delegation_table_new(void) 
{ 
  struct hash_table_s *res___2 ;
  void *tmp ;

  {
  {
#line 106
  tmp = xmalloc((size_t )sizeof(struct hash_table_s ));
#line 106
  res___2 = (struct hash_table_s *)tmp;
#line 107
  hash_init(res___2, 8UL, & delegate_hash_1, & delegate_hash_2, & delegate_hash_cmp);
  }
#line 109
  return (res___2);
}
}
#line 115 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
void delegation_table_free(struct hash_table_s *table ) 
{ 


  {
  {
#line 118
  hash_free(table, (void (*)(void const   *item ))(& delegate_free));
#line 119
  free((void *)table);
  }
#line 120
  return;
}
}
#line 139 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
void add_delegation(char const   *filename , int line , char *contract_line ) 
{ 
  char *cp ;
  char *cp2 ;
  struct delegation *contract ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 146
  tmp = xmalloc((size_t )sizeof(struct delegation ));
#line 146
  contract = (struct delegation *)tmp;
#line 150
  cp = strtok((char */* __restrict  */)contract_line, (char const   */* __restrict  */)" \t\n");
  }
#line 151
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 151
    tmp___0 = quotearg((char const   *)contract_line);
#line 151
    tmp___1 = gettext("missing argument for `%s\'");
#line 151
    error_at_line(1, 0, filename, (unsigned int )line, (char const   *)tmp___1, tmp___0);
    }
  }
  {
#line 152
  contract->name = xstrdup((char const   *)cp);
#line 154
  cp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n:");
  }
#line 155
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 155
    tmp___2 = quotearg((char const   *)contract_line);
#line 155
    tmp___3 = gettext("missing argument for `%s\'");
#line 155
    error_at_line(1, 0, filename, (unsigned int )line, (char const   *)tmp___3, tmp___2);
    }
  }
  {
#line 156
  cp2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
  }
#line 157
  if ((unsigned long )cp2 == (unsigned long )((void *)0)) {
    {
#line 157
    tmp___4 = quotearg((char const   *)contract_line);
#line 157
    tmp___5 = gettext("missing argument for `%s\'");
#line 157
    error_at_line(1, 0, filename, (unsigned int )line, (char const   *)tmp___5, tmp___4);
    }
  }
  {
#line 158
  tmp___6 = strlen((char const   *)cp);
#line 158
  tmp___7 = strlen((char const   *)cp2);
#line 158
  tmp___8 = xmalloc((size_t )(sizeof(char ) * (unsigned long )((tmp___6 + tmp___7) + 2U)));
#line 158
  contract->contract = (char *)tmp___8;
#line 159
  sprintf((char */* __restrict  */)contract->contract, (char const   */* __restrict  */)"%s:%s",
          cp, cp2);
#line 161
  cp = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
  }
#line 162
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 162
    tmp___9 = quotearg((char const   *)contract_line);
#line 162
    tmp___10 = gettext("missing argument for `%s\'");
#line 162
    error_at_line(1, 0, filename, (unsigned int )line, (char const   *)tmp___10, tmp___9);
    }
  }
  {
#line 163
  tmp___11 = strspn((char const   *)cp, "\t ");
#line 163
  contract->command = xstrdup((char const   *)(cp + tmp___11));
#line 166
  hash_insert(delegation_table, (void *)contract);
  }
#line 167
  return;
}
}
#line 173 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
struct delegation *get_subcontract(char const   *src_type , char const   *dest_type ) 
{ 
  struct delegation token___1 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp8 ;

  {
  {
#line 178
  tmp = strlen(src_type);
#line 178
  tmp___0 = strlen(dest_type);
#line 178
  tmp___1 = __builtin_alloca(sizeof(char ) * (unsigned long )((tmp + tmp___0) + 2U));
#line 178
  token___1.contract = (char *)tmp___1;
#line 179
  sprintf((char */* __restrict  */)token___1.contract, (char const   */* __restrict  */)"%s:%s",
          src_type, dest_type);
#line 181
  tmp___2 = hash_find_item(delegation_table, (void const   *)(& token___1));
  }
#line 181
  return ((struct delegation *)tmp___2);
}
}
#line 190 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
char *get_delegate_command(struct delegation *contract , struct file_job *file , int evaluate ) 
{ 
  unsigned char *tmp ;
  char *__cil_tmp5 ;

  {
#line 195
  if (evaluate) {
    {
#line 196
    tmp = expand_user_string(job, file, (unsigned char const   *)"delegating command",
                             (unsigned char const   *)contract->command);
    }
#line 196
    return ((char *)tmp);
  } else {
#line 200
    return (contract->command);
  }
}
}
#line 214 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
int subcontract(struct file_job *fjob , buffer_t *buffer , struct delegation *contractor ) 
{ 
  char *command ;
  char *stdin_content_filename ;
  FILE *in_stream ;
  FILE *out_stream ;
  int lines_read ;
  char buf___0[512] ;
  enum continuation_e continuation ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *value ;
  char *res___2 ;
  char *buf_copy ;
  char const   *_tmp_ ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  char *value___0 ;
  char *res___3 ;
  char *buf_copy___0 ;
  char const   *_tmp____0 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int saved_redirection_of_output ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 218
  stdin_content_filename = (char *)((void *)0);
#line 220
  lines_read = 0;
#line 225
  continuation = (enum continuation_e )0;
#line 230
  if ((unsigned long )fjob->name == (unsigned long )job->stdin_filename) {
    {
#line 233
    while (1) {
      while_continue: /* CIL Label */ ;
#line 233
      if (fjob->stdin_tmpname) {
#line 233
        fjob->stdin_tmpname = fjob->stdin_tmpname;
      } else {
        {
#line 233
        tmp = tempnam((char const   *)((void *)0), "a2_");
#line 233
        fjob->stdin_tmpname = tmp;
        }
      }
#line 233
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 234
    stdin_content_filename = fjob->stdin_tmpname;
#line 235
    buffer_save(buffer, (char const   *)stdin_content_filename);
#line 240
    fjob->name = (unsigned char *)stdin_content_filename;
#line 241
    command = get_delegate_command(contractor, fjob, 1);
#line 242
    fjob->name = job->stdin_filename;
    }
  } else {
    {
#line 246
    command = get_delegate_command(contractor, fjob, 1);
    }
  }
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 250
    if ((unsigned int )(1 << 6) & msg_verbosity) {
      {
#line 250
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Delegating `%s\' to `%s\' (%s)\n",
              fjob->name, contractor->name, command);
      }
    }
#line 250
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 256
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 256
    if (fjob->delegation_tmpname) {
#line 256
      fjob->delegation_tmpname = fjob->delegation_tmpname;
    } else {
      {
#line 256
      tmp___0 = tempnam((char const   *)((void *)0), "a2_");
#line 256
      fjob->delegation_tmpname = tmp___0;
      }
    }
#line 256
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 257
  out_stream = fopen((char const   */* __restrict  */)fjob->delegation_tmpname, (char const   */* __restrict  */)"w");
  }
#line 258
  if (! out_stream) {
    {
#line 260
    tmp___1 = quotearg((char const   *)fjob->delegation_tmpname);
#line 260
    tmp___2 = gettext("cannot create file `%s\'");
#line 260
    tmp___3 = __errno_location();
#line 260
    error(0, *tmp___3, (char const   *)tmp___2, tmp___1);
    }
#line 262
    return (0);
  }
  {
#line 265
  in_stream = popen((char const   *)command, "r");
  }
#line 266
  if (! in_stream) {
    {
#line 268
    fclose(out_stream);
#line 269
    tmp___4 = quotearg((char const   *)command);
#line 269
    tmp___5 = gettext("cannot open a pipe on `%s\'");
#line 269
    tmp___6 = __errno_location();
#line 269
    error(0, *tmp___6, (char const   *)tmp___5, tmp___4);
    }
#line 271
    return (0);
  }
  {
#line 275
  file_job_synchronize_sheets(job);
#line 276
  file_job_synchronize_pages(job);
  }
  {
#line 280
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 280
    tmp___19 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)in_stream);
    }
#line 280
    if (! tmp___19) {
#line 280
      goto while_break___2;
    }
    {
#line 285
    lines_read ++;
#line 287
    tmp___17 = strlen("%%Page: ");
#line 287
    tmp___18 = strncmp("%%Page: ", (char const   *)(buf___0), tmp___17);
    }
#line 287
    if (tmp___18) {
      {
#line 297
      tmp___15 = strlen("%%DocumentNeededResources: ");
#line 297
      tmp___16 = strncmp("%%DocumentNeededResources: ", (char const   *)(buf___0),
                         tmp___15);
      }
#line 297
      if (tmp___16) {
        {
#line 314
        tmp___13 = strlen("%%+ ");
#line 314
        tmp___14 = strncmp("%%+ ", (char const   *)(buf___0), tmp___13);
        }
#line 314
        if (! tmp___14) {
          {
#line 318
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 318
            tmp___10 = strlen("%%+ ");
#line 318
            _tmp____0 = (char const   *)(buf___0 + tmp___10);
#line 318
            tmp___11 = strlen(_tmp____0);
#line 318
            tmp___12 = __builtin_alloca(sizeof(char ) * (unsigned long )(tmp___11 + 1U));
#line 318
            buf_copy___0 = (char *)tmp___12;
#line 318
            strcpy((char */* __restrict  */)buf_copy___0, (char const   */* __restrict  */)_tmp____0);
            }
#line 318
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 319
          res___3 = strtok((char */* __restrict  */)buf_copy___0, (char const   */* __restrict  */)" \n\t");
          }
          {
#line 320
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 320
            value___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \n\t");
            }
#line 320
            if (! value___0) {
#line 320
              goto while_break___4;
            }
            {
#line 323
            if ((unsigned int )continuation == 1U) {
#line 323
              goto case_1;
            }
#line 327
            goto switch_default;
            case_1: /* CIL Label */ 
            {
#line 324
            add_needed_resource(job, (char const   *)res___3, (char const   *)value___0);
            }
#line 325
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 328
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      } else {
#line 303
        continuation = (enum continuation_e )1;
        {
#line 304
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 304
          tmp___7 = strlen("%%DocumentNeededResources: ");
#line 304
          _tmp_ = (char const   *)(buf___0 + tmp___7);
#line 304
          tmp___8 = strlen(_tmp_);
#line 304
          tmp___9 = __builtin_alloca(sizeof(char ) * (unsigned long )(tmp___8 + 1U));
#line 304
          buf_copy = (char *)tmp___9;
#line 304
          strcpy((char */* __restrict  */)buf_copy, (char const   */* __restrict  */)_tmp_);
          }
#line 304
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 305
        res___2 = strtok((char */* __restrict  */)buf_copy, (char const   */* __restrict  */)" \n\t");
        }
        {
#line 310
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 310
          value = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \n\t");
          }
#line 310
          if (! value) {
#line 310
            goto while_break___6;
          }
          {
#line 311
          add_needed_resource(job, (char const   *)res___2, (char const   *)value);
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 291
      job->pages += job->rows * job->columns;
#line 292
      (job->sheets) ++;
#line 293
      file_job_synchronize_sheets(job);
#line 294
      file_job_synchronize_pages(job);
      }
    }
    {
#line 333
    fputs((char const   */* __restrict  */)(buf___0), (FILE */* __restrict  */)out_stream);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 336
  pclose(in_stream);
#line 337
  fclose(out_stream);
  }
#line 340
  if (stdin_content_filename) {
    {
#line 341
    unlink((char const   *)stdin_content_filename);
    }
  }
#line 344
  if (lines_read == 0) {
#line 345
    return (0);
  }
  {
#line 350
  saved_redirection_of_output = output_is_to_void(job->divertion);
#line 351
  output_to_void(job->divertion, 0);
#line 354
  output(job->divertion, "BeginInclude\n");
#line 355
  output(job->divertion, "%%%%BeginDocument: %s\n", fjob->name);
#line 356
  output_delayed_routine(job->divertion, (void (*)(FILE *stream , void *arg ))(& stream_dump),
                         (void *)fjob->delegation_tmpname);
#line 360
  output_delayed_routine(job->divertion, (void (*)(FILE *stream , void *arg ))(& unlink2),
                         (void *)fjob->delegation_tmpname);
#line 363
  output(job->divertion, "%%%%EndDocument\n");
#line 364
  output(job->divertion, "EndInclude\n");
#line 366
  output_to_void(job->divertion, saved_redirection_of_output);
#line 370
  (job->status)->page_are_ordered = 0;
  }
#line 371
  return (1);
}
}
#line 380 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
static void dump_contract(FILE *stream , struct delegation *contract ) 
{ 
  char *cp ;
  char *cp2 ;
  char *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 384
  cp = xstrdup((char const   *)contract->contract);
#line 385
  cp = strtok((char */* __restrict  */)cp, (char const   */* __restrict  */)":");
#line 386
  cp2 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
#line 389
  tmp = gettext("Delegation `%s\', from %s to %s\n");
#line 389
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp, contract->name,
          cp, cp2);
#line 391
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t%s\n",
          contract->command);
#line 392
  free((void *)cp);
  }
#line 393
  return;
}
}
#line 398 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
void delegations_list_long(struct hash_table_s *contracts , FILE *stream ) 
{ 
  int i ;
  struct delegation **ordered_contracts ;
  void **tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 404
  tmp = hash_dump(contracts, (void **)((void *)0), (int (*)(void const   * , void const   * ))(& delegate_hash_qcmp));
#line 404
  ordered_contracts = (struct delegation **)tmp;
#line 408
  tmp___0 = gettext("Applications configured for delegation");
#line 408
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 409
  _IO_putc('\n', stream);
#line 411
  i = 0;
  }
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! *(ordered_contracts + i)) {
#line 411
      goto while_break;
    }
    {
#line 412
    dump_contract(stream, *(ordered_contracts + i));
#line 411
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  _IO_putc('\n', stream);
#line 415
  free((void *)ordered_contracts);
  }
#line 416
  return;
}
}
#line 421 "/home/ysko/Works/test-src/a2ps-4.14/src/delegate.c"
void delegations_list_short(struct hash_table_s *contracts , FILE *stream ) 
{ 
  struct delegation **ordered_contracts ;
  void **tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 426
  tmp = hash_dump(contracts, (void **)((void *)0), (int (*)(void const   * , void const   * ))(& delegate_hash_qcmp));
#line 426
  ordered_contracts = (struct delegation **)tmp;
#line 430
  tmp___0 = gettext("Applications configured for delegation");
#line 430
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 431
  _IO_putc('\n', stream);
#line 433
  lister_fprint_vertical((struct lister *)((void *)0), stream, (void **)((void *)ordered_contracts),
                         (size_t )-1, (size_t (*)(void const   *item ))(& delegate_name_len),
                         (void (*)(void const   *item , FILE *stream ))(& delegate_name_fputs));
#line 437
  free((void *)ordered_contracts);
  }
#line 438
  return;
}
}
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 29 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.h"
void print(unsigned char *filename , int *native_jobs , int *delegated_jobs ) ;
#line 30
void print_toc(unsigned char const   *name , unsigned char const   *value , int *native_jobs ) ;
#line 33
void msg_job_pages_printed(a2ps_job *Job ) ;
#line 34
void msg_nothing_printed(void) ;
#line 36
void guess(unsigned char *filename ) ;
#line 228 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.h"
struct style_sheet *get_style_sheet(char const   *key ) ;
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.h"
void ssh_print_postscript(struct a2ps_job *Job , buffer_t *buffer , struct style_sheet *sheet ) ;
#line 36 "/home/ysko/Works/test-src/a2ps-4.14/src/read.h"
void plain_print_postscript(struct a2ps_job *Job , buffer_t *buffer ) ;
#line 54 "/home/ysko/Works/test-src/a2ps-4.14/src/select.h"
char const   *get_command(unsigned char const   *name_to_match , unsigned char const   *name_to_file ) ;
#line 64 "/home/ysko/Works/test-src/a2ps-4.14/src/main.h"
_Bool delegate_p ;
#line 70
char *style_request ;
#line 73
enum eol_e end_of_line ;
#line 78
char *sample_tmpname ;
#line 31 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
char *sample_tmpname  =    (char *)((void *)0);
#line 41 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
static enum style_kind_e string_to_style_kind(char const   *string ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 44
  tmp___2 = strcmp(string, "binary");
  }
#line 44
  if (tmp___2 == 0) {
#line 45
    return ((enum style_kind_e )1);
  } else {
    {
#line 46
    tmp___1 = strcmp(string, "UNPRINTABLE");
    }
#line 46
    if (tmp___1 == 0) {
#line 47
      return ((enum style_kind_e )3);
    } else {
      {
#line 48
      tmp___0 = strcmp(string, "plain");
      }
#line 48
      if (tmp___0 == 0) {
#line 49
        return ((enum style_kind_e )0);
      } else {
        {
#line 50
        tmp = strcmp(string, "delegate");
        }
#line 50
        if (tmp == 0) {
#line 51
          return ((enum style_kind_e )4);
        }
      }
    }
  }
#line 52
  return ((enum style_kind_e )2);
}
}
#line 57 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
static buffer_t *input_new(unsigned char *name ) 
{ 
  buffer_t *res___2 ;
  void *tmp ;
  struct file_job *file_job ;
  struct stat statbuf ;
  struct tm *tm ;
  char *tmp___0 ;
  FILE *input_stream ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  time_t tim ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned char *tmp___12 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 60
  tmp = xmalloc((size_t )sizeof(buffer_t ));
#line 60
  res___2 = (buffer_t *)tmp;
#line 65
  a2ps_open_input_session(job, name);
#line 66
  file_job = (struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U));
  }
#line 69
  if ((unsigned long )((char const   *)name) == (unsigned long )((void *)0)) {
#line 69
    goto _L;
  } else
#line 69
  if ((int )*name == 0) {
#line 69
    goto _L;
  } else {
    {
#line 69
    tmp___11 = strcmp((char const   *)name, "-");
    }
#line 69
    if (tmp___11) {
      {
#line 83
      file_job->is_stdin = (_Bool)0;
#line 86
      tmp___3 = isdir((char const   *)((char *)name));
      }
#line 86
      if (tmp___3) {
        {
#line 88
        tmp___1 = quotearg((char const   *)((char *)name));
#line 88
        tmp___2 = gettext("`%s\' is a directory");
#line 88
        error(0, 0, (char const   *)tmp___2, tmp___1);
#line 89
        file_job->printable = (_Bool)0;
        }
      }
      {
#line 92
      file_job->name = name;
#line 93
      input_stream = fopen((char const   */* __restrict  */)((char *)name), (char const   */* __restrict  */)"r");
      }
#line 93
      if ((unsigned long )input_stream == (unsigned long )((void *)0)) {
        {
#line 95
        tmp___4 = quotearg((char const   *)((char *)name));
#line 95
        tmp___5 = gettext("cannot open file `%s\'");
#line 95
        tmp___6 = __errno_location();
#line 95
        error(0, *tmp___6, (char const   *)tmp___5, tmp___4);
#line 97
        file_job->printable = (_Bool)0;
        }
      } else {
        {
#line 99
        tmp___10 = stat((char const   */* __restrict  */)((char *)name), (struct stat */* __restrict  */)(& statbuf));
        }
#line 99
        if (tmp___10 == -1) {
          {
#line 101
          tmp___7 = quotearg((char const   *)((char *)name));
#line 101
          tmp___8 = gettext("cannot get informations on file `%s\'");
#line 101
          tmp___9 = __errno_location();
#line 101
          error(0, *tmp___9, (char const   *)tmp___8, tmp___7);
#line 103
          file_job->printable = (_Bool)0;
          }
        } else {
          {
#line 107
          tim = statbuf.st_mtim.tv_sec;
#line 108
          tm = localtime((time_t const   *)(& tim));
#line 109
          memcpy((void */* __restrict  */)(& file_job->mod_tm), (void const   */* __restrict  */)tm,
                 (size_t )sizeof(*tm));
          }
        }
      }
      {
#line 112
      buffer_stream_set(res___2, input_stream, end_of_line);
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 71
      file_job->is_stdin = (_Bool)1;
#line 72
      file_job->name = job->stdin_filename;
#line 74
      buffer_stream_set(res___2, stdin, end_of_line);
      }
      {
#line 76
      while (1) {
        while_continue: /* CIL Label */ ;
#line 76
        if (sample_tmpname) {
#line 76
          sample_tmpname = sample_tmpname;
        } else {
          {
#line 76
          tmp___0 = tempnam((char const   *)((void *)0), "a2_");
#line 76
          sample_tmpname = tmp___0;
          }
        }
#line 76
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 77
      buffer_sample_get(res___2, (char const   *)sample_tmpname);
      }
    }
  }
#line 123
  if (! file_job->printable) {
#line 124
    file_job->type = "UNPRINTABLE";
  } else
#line 125
  if ((unsigned long )((char const   *)style_request) == (unsigned long )((void *)0)) {
#line 125
    goto _L___0;
  } else
#line 125
  if ((int )*style_request == 0) {
    _L___0: /* CIL Label */ 
#line 128
    if (sample_tmpname) {
#line 128
      tmp___12 = (unsigned char *)sample_tmpname;
    } else {
#line 128
      tmp___12 = file_job->name;
    }
    {
#line 128
    file_job->type = get_command((unsigned char const   *)file_job->name, (unsigned char const   *)tmp___12);
    }
  } else {
#line 126
    file_job->type = (char const   *)style_request;
  }
#line 134
  if (sample_tmpname) {
    {
#line 135
    unlink((char const   *)sample_tmpname);
    }
  }
#line 136
  return (res___2);
}
}
#line 139 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
static void input_end(buffer_t *buffer ) 
{ 


  {
#line 142
  if (buffer->stream) {
#line 142
    if ((unsigned long )buffer->stream != (unsigned long )stdin) {
      {
#line 143
      fclose(buffer->stream);
      }
    }
  }
  {
#line 144
  buffer_release(buffer);
#line 145
  free((void *)buffer);
#line 147
  a2ps_close_input_session(job);
  }
#line 148
  return;
}
}
#line 156 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
static void msg_file_pages_printed(a2ps_job *Job , char const   *stylename ) 
{ 
  int sheets ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 161
  sheets = ((struct file_job *)*((Job->jobs)->content + ((Job->jobs)->len - 1U)))->sheets;
#line 162
  if (Job->duplex) {
#line 163
    sheets = (sheets + 1) / 2;
  }
#line 165
  if (((struct file_job *)*((Job->jobs)->content + ((Job->jobs)->len - 1U)))->pages == 1) {
    {
#line 167
    while (1) {
      while_continue: /* CIL Label */ ;
#line 167
      if ((unsigned int )(1 << 1) & msg_verbosity) {
        {
#line 167
        tmp = gettext("[%s (%s): 1 page on 1 sheet]\n");
#line 167
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                ((struct file_job *)*((Job->jobs)->content + ((Job->jobs)->len - 1U)))->name,
                stylename);
        }
      }
#line 167
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 171
  if (sheets == 1) {
    {
#line 173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 173
      if ((unsigned int )(1 << 1) & msg_verbosity) {
        {
#line 173
        tmp___0 = gettext("[%s (%s): %d pages on 1 sheet]\n");
#line 173
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
                ((struct file_job *)*((Job->jobs)->content + ((Job->jobs)->len - 1U)))->name,
                stylename, ((struct file_job *)*((Job->jobs)->content + ((Job->jobs)->len - 1U)))->pages);
        }
      }
#line 173
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 180
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 180
      if ((unsigned int )(1 << 1) & msg_verbosity) {
        {
#line 180
        tmp___1 = gettext("[%s (%s): %d pages on %d sheets]\n");
#line 180
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                ((struct file_job *)*((Job->jobs)->content + ((Job->jobs)->len - 1U)))->name,
                stylename, ((struct file_job *)*((Job->jobs)->content + ((Job->jobs)->len - 1U)))->pages,
                sheets);
        }
      }
#line 180
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 186
  return;
}
}
#line 191 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
void msg_job_pages_printed(a2ps_job *Job ) 
{ 
  int sheets ;
  unsigned char *ucp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 197
  sheets = Job->sheets;
#line 198
  if (Job->duplex) {
#line 199
    sheets = (sheets + 1) / 2;
  }
  {
#line 202
  ucp = a2ps_destination_to_string(Job);
  }
#line 205
  if (Job->pages == 1) {
    {
#line 207
    while (1) {
      while_continue: /* CIL Label */ ;
#line 207
      if ((unsigned int )((1 << 1) | 1) & msg_verbosity) {
        {
#line 207
        tmp = gettext("[Total: 1 page on 1 sheet] %s\n");
#line 207
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                ucp);
        }
      }
#line 207
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 209
  if (sheets == 1) {
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 211
      if ((unsigned int )((1 << 1) | 1) & msg_verbosity) {
        {
#line 211
        tmp___0 = gettext("[Total: %d pages on 1 sheet] %s\n");
#line 211
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
                Job->pages, ucp);
        }
      }
#line 211
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 216
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 216
      if ((unsigned int )((1 << 1) | 1) & msg_verbosity) {
        {
#line 216
        tmp___1 = gettext("[Total: %d pages on %d sheets] %s\n");
#line 216
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                Job->pages, sheets, ucp);
        }
      }
#line 216
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 221
  tmp___4 = macro_meta_sequence_get(Job, "cfg.wrapped");
  }
#line 221
  if (tmp___4) {
#line 221
    if (Job->lines_folded) {
#line 224
      if (Job->lines_folded == 1) {
        {
#line 225
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 225
          if ((unsigned int )((1 << 1) | 1) & msg_verbosity) {
            {
#line 225
            tmp___2 = gettext("[1 line wrapped]\n");
#line 225
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2);
            }
          }
#line 225
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 228
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 228
          if ((unsigned int )((1 << 1) | 1) & msg_verbosity) {
            {
#line 228
            tmp___3 = gettext("[%d lines wrapped]\n");
#line 228
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
                    Job->lines_folded);
            }
          }
#line 228
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 233
  free((void *)ucp);
  }
#line 234
  return;
}
}
#line 238 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
void msg_nothing_printed(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if ((unsigned int )((1 << 1) | 1) & msg_verbosity) {
      {
#line 241
      tmp = gettext("[No output produced]\n");
#line 241
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
      }
    }
#line 241
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 245 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
void print_toc(unsigned char const   *name , unsigned char const   *value , int *native_jobs ) 
{ 
  buffer_t toc_buffer ;
  unsigned char *toc_content ;
  char *tmp ;
  unsigned char const   *_tmp_ ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  struct style_sheet *tmp___3 ;
  char *__cil_tmp12 ;

  {
  {
#line 252
  tmp = xstrdup((char const   *)name);
#line 252
  a2ps_open_input_session(job, (unsigned char *)tmp);
#line 255
  ((struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)))->is_toc = (_Bool)1;
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 257
    tmp___0 = expand_user_string(job, (struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)),
                                 name, value);
#line 257
    _tmp_ = (unsigned char const   *)tmp___0;
#line 257
    tmp___1 = strlen((char const   *)_tmp_);
#line 257
    tmp___2 = __builtin_alloca(sizeof(unsigned char ) * (unsigned long )(tmp___1 + 1U));
#line 257
    toc_content = (unsigned char *)tmp___2;
#line 257
    strcpy((char */* __restrict  */)((char *)toc_content), (char const   */* __restrict  */)((char const   *)_tmp_));
    }
#line 257
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 260
  buffer_string_set(& toc_buffer, (unsigned char const   *)toc_content, end_of_line);
#line 263
  tmp___3 = get_style_sheet("pre");
#line 263
  ssh_print_postscript(job, & toc_buffer, tmp___3);
#line 264
  (*native_jobs) ++;
#line 266
  a2ps_close_input_session(job);
  }
#line 267
  return;
}
}
#line 274 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
void print(unsigned char *filename , int *native_jobs , int *delegated_jobs ) 
{ 
  char buf___0[512] ;
  struct delegation *contract ;
  struct style_sheet *sheet ;
  buffer_t *input_buffer ;
  enum style_kind_e style_kind ;
  struct file_job *file_job ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 278
  contract = (struct delegation *)((void *)0);
#line 289
  input_buffer = input_new(filename);
#line 292
  file_job = (struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U));
  }
#line 294
  if (delegate_p) {
    {
#line 294
    tmp = output_format_to_key(job->output_format);
#line 294
    contract = get_subcontract(file_job->type, tmp);
    }
#line 294
    if (contract) {
#line 298
      style_kind = (enum style_kind_e )4;
    } else {
      {
#line 300
      style_kind = string_to_style_kind(file_job->type);
      }
    }
  } else {
    {
#line 300
    style_kind = string_to_style_kind(file_job->type);
    }
  }
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if ((unsigned int )(1 << 6) & msg_verbosity) {
      {
#line 302
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Getting ready to print file `%s\', with command `%s\'\n",
              file_job->name, file_job->type);
      }
    }
#line 302
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  if ((unsigned int )style_kind == 4U) {
#line 311
    goto case_4;
  }
#line 326
  if ((unsigned int )style_kind == 3U) {
#line 326
    goto case_3;
  }
#line 333
  if ((unsigned int )style_kind == 1U) {
#line 333
    goto case_1;
  }
#line 342
  if ((unsigned int )style_kind == 2U) {
#line 342
    goto case_2;
  }
#line 358
  if ((unsigned int )style_kind == 0U) {
#line 358
    goto plain_print;
  }
#line 309
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 313
  page_flush(job);
#line 314
  tmp___0 = gettext("%s, delegated to %s");
#line 314
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)tmp___0,
          file_job->type, contract->name);
#line 316
  tmp___2 = subcontract(file_job, input_buffer, contract);
  }
#line 316
  if (tmp___2) {
    {
#line 318
    (*delegated_jobs) ++;
#line 319
    msg_file_pages_printed(job, (char const   *)(buf___0));
    }
  } else {
    {
#line 322
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 322
      if ((unsigned int )(1 << 1) & msg_verbosity) {
        {
#line 322
        tmp___1 = gettext("[%s (%s): failed.  Ignored]\n");
#line 322
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                file_job->name, buf___0);
        }
      }
#line 322
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 324
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 328
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 328
    if ((unsigned int )(1 << 1) & msg_verbosity) {
      {
#line 328
      tmp___3 = gettext("[%s (unprintable): ignored]\n");
#line 328
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              file_job->name);
      }
    }
#line 328
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 331
  goto switch_break;
  case_1: /* CIL Label */ 
#line 334
  if (job->print_binaries) {
#line 335
    goto plain_print;
  }
  {
#line 337
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 337
    if ((unsigned int )(1 << 1) & msg_verbosity) {
      {
#line 337
      tmp___4 = gettext("[%s (binary): ignored]\n");
#line 337
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              file_job->name);
      }
    }
#line 337
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 340
  goto switch_break;
  case_2: /* CIL Label */ 
#line 344
  if (highlight_level == 0) {
#line 345
    goto plain_print;
  }
  {
#line 346
  sheet = get_style_sheet(file_job->type);
  }
#line 347
  if (! sheet) {
#line 348
    goto plain_print;
  }
  {
#line 350
  buffer_set_lower_case(input_buffer, (_Bool )((unsigned int )sheet->sensitiveness == 1U));
#line 352
  ssh_print_postscript(job, input_buffer, sheet);
#line 353
  msg_file_pages_printed(job, (char const   *)sheet->name);
#line 354
  (*native_jobs) ++;
  }
#line 355
  goto switch_break;
  plain_print: 
  case_0: /* CIL Label */ 
  {
#line 359
  plain_print_postscript(job, input_buffer);
#line 360
  tmp___5 = gettext("plain");
#line 360
  msg_file_pages_printed(job, (char const   *)tmp___5);
#line 361
  (*native_jobs) ++;
  }
#line 362
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 365
  input_end(input_buffer);
  }
#line 366
  return;
}
}
#line 373 "/home/ysko/Works/test-src/a2ps-4.14/src/generate.c"
void guess(unsigned char *filename ) 
{ 
  buffer_t *buffer ;
  struct file_job *file_job ;
  char *__cil_tmp4 ;

  {
  {
#line 379
  buffer = input_new(filename);
#line 380
  file_job = (struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U));
#line 381
  printf((char const   */* __restrict  */)"[%s (%s)]\n", file_job->name, file_job->type);
  }
#line 384
  if (buffer->stream) {
#line 384
    if ((unsigned long )buffer->stream != (unsigned long )stdin) {
      {
#line 385
      fclose(buffer->stream);
      }
    }
  }
#line 386
  return;
}
}
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/src/select.h"
void set_requested_style(char const   *arg ) ;
#line 46
struct darray *sheets_map_new(void) ;
#line 57
struct pattern_rule *pattern_rule_new(char const   *pattern , int on_file_verdict ,
                                      _Bool insensitive_p___0 , char const   *command ) ;
#line 43 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
struct darray *sheets_map ;
#line 49 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
void set_requested_style(char const   *arg ) 
{ 
  char const   *my_s2 ;
  char *tmp ;

  {
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    my_s2 = arg;
    {
#line 52
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      if (style_request) {
        {
#line 52
        free((void *)style_request);
        }
      }
#line 52
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 52
    if ((unsigned long )my_s2 == (unsigned long )((void *)0)) {
#line 52
      style_request = (char *)((void *)0);
    } else
#line 52
    if ((int const   )*my_s2 == 0) {
#line 52
      style_request = (char *)((void *)0);
    } else {
      {
#line 52
      tmp = xstrdup(my_s2);
#line 52
      style_request = tmp;
      }
    }
#line 52
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return;
}
}
#line 69 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
struct pattern_rule *pattern_rule_new(char const   *pattern , int on_file_verdict ,
                                      _Bool insensitive_p___0 , char const   *command ) 
{ 
  struct pattern_rule *res___2 ;
  void *tmp ;

  {
  {
#line 73
  tmp = xmalloc((size_t )sizeof(struct pattern_rule ));
#line 73
  res___2 = (struct pattern_rule *)tmp;
#line 75
  res___2->pattern = pattern;
#line 76
  res___2->on_file_verdict = on_file_verdict;
#line 77
  res___2->command = command;
#line 78
  res___2->insensitive_p = insensitive_p___0;
  }
#line 80
  return (res___2);
}
}
#line 83 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
static void pattern_rule_self_print(struct pattern_rule *item , FILE *stream ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 86
  if (item->insensitive_p) {
#line 86
    tmp = "i";
  } else {
#line 86
    tmp = "";
  }
#line 86
  if (item->on_file_verdict) {
#line 86
    tmp___0 = "file";
  } else {
#line 86
    tmp___0 = "name";
  }
  {
#line 86
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s/%s: %s/%s\n",
          tmp___0, item->pattern, item->command, tmp);
  }
#line 91
  return;
}
}
#line 93 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
struct darray *sheets_map_new(void) 
{ 
  struct darray *tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 96
  tmp = da_new("Sheets map", (size_t )200, (enum da_growth )1, (size_t )20, (void (*)(void const   * ,
                                                                                      FILE *stream ))(& pattern_rule_self_print),
               (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
  }
#line 96
  return (tmp);
}
}
#line 101 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
void sheets_map_add(char const   *pattern , int on_file_verdict , _Bool insensitive_p___0 ,
                    char const   *key ) 
{ 
  struct pattern_rule *tmp ;

  {
  {
#line 105
  tmp = pattern_rule_new(pattern, on_file_verdict, insensitive_p___0, key);
#line 105
  da_append(sheets_map, (void *)tmp);
  }
#line 107
  return;
}
}
#line 113 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
static int sheets_map_load_main(void) 
{ 
  char *file ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 119
  file = pw_find_file((char * const  *)job->common.path, "sheets.map", (char const   *)((void *)0));
  }
#line 120
  if (! file) {
    {
#line 122
    tmp = gettext("cannot find file `%s\'");
#line 122
    tmp___0 = __errno_location();
#line 122
    error(0, *tmp___0, (char const   *)tmp, "sheets.map");
#line 124
    tmp___1 = gettext("automatic style selection cancelled");
#line 124
    error(0, 0, (char const   *)tmp___1);
    }
#line 125
    return (0);
  }
  {
#line 128
  sheets_map_load((char const   *)file);
#line 130
  free((void *)file);
  }
#line 131
  return (1);
}
}
#line 136 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
char *shell_escape(char const   *fn ) 
{ 
  size_t len ;
  char const   *inp ;
  char *retval ;
  char *outp ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 139
  len = (size_t )0;
#line 143
  inp = fn;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! *inp) {
#line 143
      goto while_break;
    }
    {
#line 146
    if ((int const   )*inp == 39) {
#line 146
      goto case_39;
    }
#line 147
    goto switch_default;
    case_39: /* CIL Label */ 
#line 146
    len += 4U;
#line 146
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 147
    len ++;
#line 147
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 143
    inp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  tmp = malloc(len + 1U);
#line 150
  retval = (char *)tmp;
#line 150
  outp = retval;
  }
#line 151
  if (! outp) {
#line 152
    return ((char *)((void *)0));
  }
#line 153
  inp = fn;
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 153
    if (! *inp) {
#line 153
      goto while_break___0;
    }
    {
#line 156
    if ((int const   )*inp == 39) {
#line 156
      goto case_39___0;
    }
#line 157
    goto switch_default___0;
    case_39___0: /* CIL Label */ 
#line 156
    tmp___0 = outp;
#line 156
    outp ++;
#line 156
    *tmp___0 = (char )'\'';
#line 156
    tmp___1 = outp;
#line 156
    outp ++;
#line 156
    *tmp___1 = (char )'\\';
#line 156
    tmp___2 = outp;
#line 156
    outp ++;
#line 156
    *tmp___2 = (char )'\'';
#line 156
    tmp___3 = outp;
#line 156
    outp ++;
#line 156
    *tmp___3 = (char )'\'';
#line 156
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 157
    tmp___4 = outp;
#line 157
    outp ++;
#line 157
    *tmp___4 = (char )*inp;
#line 157
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 153
    inp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 159
  *outp = (char)0;
#line 161
  return (retval);
}
}
#line 167 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
static char *file_verdict_on(unsigned char const   *filename ) 
{ 
  char *cp ;
  char *command ;
  char buf___0[1024] ;
  FILE *file_out ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 170
  cp = (char *)((void *)0);
#line 174
  if ((unsigned long )((char const   *)job->file_command) == (unsigned long )((void *)0)) {
#line 175
    return ((char *)((void *)0));
  } else
#line 174
  if ((int )*(job->file_command) == 0) {
#line 175
    return ((char *)((void *)0));
  }
  {
#line 177
  tmp = shell_escape((char const   *)filename);
#line 177
  filename = (unsigned char const   *)tmp;
  }
#line 178
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 179
    return ((char *)((void *)0));
  }
  {
#line 181
  tmp___0 = strlen((char const   *)job->file_command);
#line 181
  tmp___1 = strlen((char const   *)filename);
#line 181
  tmp___2 = __builtin_alloca(sizeof(char ) * (unsigned long )((4U + tmp___0) + tmp___1));
#line 181
  command = (char *)tmp___2;
#line 184
  sprintf((char */* __restrict  */)command, (char const   */* __restrict  */)"%s \'%s\'",
          job->file_command, (char const   *)filename);
#line 185
  free((void *)filename);
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if ((unsigned int )(1 << 7) & msg_verbosity) {
      {
#line 186
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading pipe: `%s\'\n",
              command);
      }
    }
#line 186
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  file_out = popen((char const   *)command, "r");
  }
#line 190
  if (! file_out) {
#line 192
    if ((unsigned int )(1 << 7) & msg_verbosity) {
      {
#line 193
      tmp___3 = quotearg((char const   *)command);
#line 193
      tmp___4 = gettext("cannot open a pipe on `%s\'");
#line 193
      tmp___5 = __errno_location();
#line 193
      error(0, *tmp___5, (char const   *)tmp___4, tmp___3);
      }
    }
#line 195
    return ((char *)((void *)0));
  }
  {
#line 199
  fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)file_out);
#line 200
  pclose(file_out);
  }
  {
#line 201
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 201
    if ((unsigned int )(1 << 7) & msg_verbosity) {
      {
#line 201
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file(1): %s",
              buf___0);
      }
    }
#line 201
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  cp = buf___0;
  {
#line 206
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 206
    if (*cp) {
#line 206
      if (! ((int )*cp != 58)) {
#line 206
        goto while_break___1;
      }
    } else {
#line 206
      goto while_break___1;
    }
#line 207
    cp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 208
  cp ++;
  {
#line 209
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 209
    if (*cp) {
#line 209
      if (! ((int )*cp == 32)) {
#line 209
        if (! ((int )*cp == 9)) {
#line 209
          goto while_break___2;
        }
      }
    } else {
#line 209
      goto while_break___2;
    }
#line 210
    cp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 212
  if (*cp) {
#line 214
    if (cp) {
      {
#line 215
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 215
        if ((unsigned int )(1 << 7) & msg_verbosity) {
          {
#line 215
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File\'s verdict: %s",
                  cp);
          }
        }
#line 215
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 217
    tmp___6 = strlen((char const   *)cp);
#line 217
    tmp___7 = xstrndup((char const   *)cp, tmp___6 - 1U);
    }
#line 217
    return (tmp___7);
  }
#line 219
  return ((char *)((void *)0));
}
}
#line 227 "/home/ysko/Works/test-src/a2ps-4.14/src/select.c"
char const   *get_command(unsigned char const   *name_to_match , unsigned char const   *name_to_file ) 
{ 
  int i ;
  char *file_verdict ;
  unsigned char *name_to_match_lc ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned char const   *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;

  {
#line 237
  if (sheets_map->len == 0U) {
    {
#line 238
    sheets_map_load_main();
    }
  }
  {
#line 243
  file_verdict = file_verdict_on(name_to_file);
  }
#line 244
  if (name_to_match) {
    {
#line 246
    tmp = strlen((char const   *)name_to_match);
#line 246
    tmp___0 = __builtin_alloca(sizeof(char ) * (unsigned long )(tmp + 1U));
#line 246
    name_to_match_lc = (unsigned char *)((char *)tmp___0);
#line 247
    strcpylc(name_to_match_lc, name_to_match);
    }
  }
#line 256
  i = (int )(sheets_map->len - 1U);
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (i >= 0)) {
#line 256
      goto while_break;
    }
#line 257
    if (((struct pattern_rule *)*(sheets_map->content + i))->on_file_verdict) {
#line 260
      if (file_verdict) {
        {
#line 260
        tmp___1 = fnmatch(((struct pattern_rule *)*(sheets_map->content + i))->pattern,
                          (char const   *)file_verdict, 0);
        }
#line 260
        if (! tmp___1) {
          {
#line 263
          free((void *)file_verdict);
          }
#line 264
          return (((struct pattern_rule *)*(sheets_map->content + i))->command);
        }
      }
    } else
#line 270
    if (name_to_match) {
#line 270
      if (((struct pattern_rule *)*(sheets_map->content + i))->insensitive_p) {
#line 270
        tmp___2 = (unsigned char const   *)name_to_match_lc;
      } else {
#line 270
        tmp___2 = name_to_match;
      }
      {
#line 270
      tmp___3 = fnmatch(((struct pattern_rule *)*(sheets_map->content + i))->pattern,
                        (char const   *)((char *)tmp___2), 0);
      }
#line 270
      if (! tmp___3) {
        {
#line 276
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 276
          if (file_verdict) {
            {
#line 276
            free((void *)file_verdict);
            }
          }
#line 276
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 277
        return (((struct pattern_rule *)*(sheets_map->content + i))->command);
      }
    }
#line 256
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 280
    if (file_verdict) {
      {
#line 280
      free((void *)file_verdict);
      }
    }
#line 280
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 282
  return ("plain");
}
}
#line 555 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 173 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.h"
void rhs_self_print(struct darray *rhs , FILE *stream ) ;
#line 190
struct pattern *new_pattern(char *pattern , size_t len ) ;
#line 220
void style_sheet_finalize(struct style_sheet *sheet ) ;
#line 227
struct hash_table_s *new_style_sheets(void) ;
#line 236
void list_style_sheets_short(FILE *stream ) ;
#line 237
void list_style_sheets_long(FILE *stream ) ;
#line 238
void list_style_sheets_html(FILE *stream ) ;
#line 239
void list_style_sheets_texinfo(FILE *stream ) ;
#line 48 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct hash_table_s *style_sheets ;
#line 59
__inline static void style_sheets_versions(struct darray *keys , int *sum , int *requirement ) ;
#line 64
static _Bool style_sheet_check(struct style_sheet *sheet ) ;
#line 82 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void alphabet_self_print(char *a , FILE *s ) 
{ 
  int c ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 85
  if ((int )*(a + 0) == 127) {
    {
#line 86
    fputs((char const   */* __restrict  */)"<undefined>\n", (FILE */* __restrict  */)s);
    }
  } else {
    {
#line 91
    fputc('\"', s);
#line 92
    c = 0;
    }
    {
#line 92
    while (1) {
      while_continue: /* CIL Label */ ;
#line 92
      if (! (c < 256)) {
#line 92
        goto while_break;
      }
#line 93
      if (*(a + c)) {
        {
#line 94
        fputc(c, s);
        }
      }
#line 92
      c ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 95
    fputs((char const   */* __restrict  */)"\"\n", (FILE */* __restrict  */)s);
    }
  }
#line 97
  return;
}
}
#line 101 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct pattern *new_pattern(char *pattern , size_t len ) 
{ 
  struct pattern *res___2 ;
  void *tmp ;

  {
  {
#line 104
  tmp = xmalloc((size_t )sizeof(struct pattern ));
#line 104
  res___2 = (struct pattern *)tmp;
#line 105
  res___2->pattern = pattern;
#line 106
  res___2->len = len;
  }
#line 107
  return (res___2);
}
}
#line 113 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct faced_string *faced_string_new(unsigned char *string , int reg_ref , struct fface_s face ) 
{ 
  struct faced_string *res___2 ;
  void *tmp ;

  {
  {
#line 116
  tmp = xmalloc((size_t )sizeof(struct faced_string ));
#line 116
  res___2 = (struct faced_string *)tmp;
#line 117
  res___2->string = string;
#line 118
  res___2->reg_ref = reg_ref;
#line 119
  res___2->face = face;
  }
#line 120
  return (res___2);
}
}
#line 126 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void faced_string_self_print(struct faced_string *faced_string , FILE *stream ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 129
  if (faced_string->string) {
    {
#line 130
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\"%s\": ",
            faced_string->string);
    }
  } else {
    {
#line 132
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\\%d: ",
            faced_string->reg_ref);
    }
  }
  {
#line 134
  fface_self_print(faced_string->face, stream);
  }
#line 135
  return;
}
}
#line 137 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
__inline static void faced_string_free(struct faced_string *faced_string ) 
{ 


  {
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (faced_string->string) {
      {
#line 140
      free((void *)faced_string->string);
      }
    }
#line 140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  free((void *)faced_string);
  }
#line 142
  return;
}
}
#line 157 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void style_sheet_set_version(struct style_sheet *sheet , char const   *version_string ) 
{ 


  {
  {
#line 161
  string_to_version(version_string, (int *)(sheet->version));
  }
#line 162
  return;
}
}
#line 168 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
int style_sheet_set_requirement(struct style_sheet *sheet , char const   *version_string ) 
{ 
  int a2ps_version[4] ;
  int tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 174
  string_to_version(version_string, (int *)(sheet->requirement));
#line 175
  string_to_version("4.14", (int *)(a2ps_version));
#line 177
  tmp = version_cmp((int *)(sheet->requirement), (int *)(a2ps_version));
  }
#line 177
  if (tmp > 0) {
#line 178
    return (0);
  }
#line 180
  return (1);
}
}
#line 189 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct darray *rhs_new(void) 
{ 
  struct darray *res___2 ;
  char *__cil_tmp2 ;

  {
  {
#line 193
  res___2 = da_new("Rhs", (size_t )2, (enum da_growth )2, (size_t )2, (void (*)(void const   * ,
                                                                                FILE *stream ))(& faced_string_self_print),
                   (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
  }
#line 195
  return (res___2);
}
}
#line 201 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct darray *rhs_new_single(unsigned char *string , int reg_ref , struct fface_s face ) 
{ 
  struct darray *res___2 ;
  struct faced_string *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 205
  res___2 = da_new("Rhs", (size_t )2, (enum da_growth )2, (size_t )2, (void (*)(void const   * ,
                                                                                FILE *stream ))(& faced_string_self_print),
                   (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
#line 207
  tmp = faced_string_new(string, reg_ref, face);
#line 207
  da_append(res___2, (void *)tmp);
  }
#line 208
  return (res___2);
}
}
#line 214 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
__inline static void rhs_set_no_face(struct darray *dest , struct fface_s face ) 
{ 
  size_t i ;

  {
#line 219
  i = (size_t )0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (i < dest->len)) {
#line 219
      goto while_break;
    }
#line 220
    if ((int )((struct faced_string *)*(dest->content + i))->face.face == (int )No_fface.face) {
#line 220
      if ((unsigned int )((struct faced_string *)*(dest->content + i))->face.flags == (unsigned int )No_fface.flags) {
#line 222
        ((struct faced_string *)*(dest->content + i))->face = face;
      }
    }
#line 219
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 230 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void rhs_add(struct darray *dest , struct faced_string *str ) 
{ 


  {
  {
#line 233
  da_append(dest, (void *)str);
  }
#line 234
  return;
}
}
#line 239 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void rhs_self_print(struct darray *rhs , FILE *stream ) 
{ 
  size_t i ;

  {
  {
#line 244
  _IO_putc('(', stream);
#line 245
  i = (size_t )0;
  }
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! (i < rhs->len)) {
#line 245
      goto while_break;
    }
    {
#line 246
    faced_string_self_print((struct faced_string *)*(rhs->content + i), stream);
#line 245
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  _IO_putc(')', stream);
  }
#line 248
  return;
}
}
#line 256 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
__inline static struct rule *rule_new_internal_word(unsigned char *word , struct darray *rhs ) 
{ 
  struct rule *res___2 ;
  void *tmp ;

  {
  {
#line 260
  tmp = xmalloc((size_t )sizeof(struct rule ));
#line 260
  res___2 = (struct rule *)tmp;
#line 262
  res___2->word = word;
#line 263
  res___2->regex = (struct re_pattern_buffer *)((void *)0);
#line 264
  res___2->rhs = rhs;
  }
#line 265
  return (res___2);
}
}
#line 271 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
__inline static struct rule *rule_new_internal_regexp(struct pattern *pattern , char *regexp ,
                                                      int regexp_len , struct darray *rhs ,
                                                      char const   *filename , size_t line ) 
{ 
  struct rule *res___2 ;
  void *tmp ;
  char const   *error_msg ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp12 ;

  {
  {
#line 277
  tmp = xmalloc((size_t )sizeof(struct rule ));
#line 277
  res___2 = (struct rule *)tmp;
#line 282
  res___2->word = (unsigned char *)pattern->pattern;
#line 285
  tmp___0 = xmalloc((size_t )sizeof(struct re_pattern_buffer ));
#line 285
  res___2->regex = (struct re_pattern_buffer *)tmp___0;
#line 286
  (res___2->regex)->translate = (char *)((void *)0);
#line 287
  (res___2->regex)->fastmap = (char *)((void *)0);
#line 288
  (res___2->regex)->buffer = (unsigned char *)((void *)0);
#line 289
  (res___2->regex)->allocated = 0UL;
#line 291
  error_msg = re_compile_pattern((char const   *)regexp, (size_t )regexp_len, res___2->regex);
  }
#line 293
  if (error_msg) {
    {
#line 294
    tmp___1 = gettext("cannot compile regular expression `%s\': %s");
#line 294
    error_at_line(1, 0, filename, line, (char const   *)tmp___1, regexp, error_msg);
    }
  }
  {
#line 297
  free((void *)pattern);
#line 298
  res___2->rhs = rhs;
  }
#line 299
  return (res___2);
}
}
#line 305 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct rule *rule_new(unsigned char *word , struct pattern *pattern , struct darray *rhs ,
                      char const   *filename , size_t line ) 
{ 
  struct rule *tmp ;
  struct rule *tmp___0 ;

  {
#line 310
  if (pattern) {
    {
#line 311
    tmp = rule_new_internal_regexp(pattern, pattern->pattern, (int )pattern->len,
                                   rhs, filename, line);
    }
#line 311
    return (tmp);
  } else {
    {
#line 316
    tmp___0 = rule_new_internal_word(word, rhs);
    }
#line 316
    return (tmp___0);
  }
}
}
#line 329 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct rule *keyword_rule_new(unsigned char *word , struct pattern *pattern , struct darray *rhs ,
                              char const   *filename , size_t line ) 
{ 
  int pattern_len ;
  char *pattern_to_compile ;
  size_t tmp ;
  void *tmp___0 ;
  struct rule *tmp___1 ;
  struct rule *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 334
  pattern_len = 0;
#line 335
  pattern_to_compile = (char *)((void *)0);
#line 337
  if (pattern) {
    {
#line 339
    tmp = strlen("\\b()\\b");
#line 339
    pattern_len = (int )(pattern->len + tmp);
#line 340
    tmp___0 = __builtin_alloca(sizeof(char ) * (unsigned long )(pattern_len + 1));
#line 340
    pattern_to_compile = (char *)tmp___0;
#line 341
    sprintf((char */* __restrict  */)pattern_to_compile, (char const   */* __restrict  */)"\\b(%s)\\b",
            pattern->pattern);
#line 342
    tmp___1 = rule_new_internal_regexp(pattern, pattern_to_compile, pattern_len, rhs,
                                       filename, line);
    }
#line 342
    return (tmp___1);
  } else {
    {
#line 348
    tmp___2 = rule_new_internal_word(word, rhs);
    }
#line 348
    return (tmp___2);
  }
}
}
#line 357 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void free_rule(struct rule *rule ) 
{ 


  {
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (rule->word) {
      {
#line 360
      free((void *)rule->word);
      }
    }
#line 360
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  if (rule->regex) {
    {
#line 363
    regfree(rule->regex);
#line 364
    free((void *)rule->regex);
    }
  }
  {
#line 366
  da_free(rule->rhs, (void (*)(void * ))(& faced_string_free));
#line 367
  free((void *)rule);
  }
#line 368
  return;
}
}
#line 374 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static int rule_cmp(struct rule *k1 , struct rule *k2 ) 
{ 
  int tmp ;

  {
  {
#line 377
  tmp = strcmp((char const   *)k1->word, (char const   *)k2->word);
  }
#line 377
  return (tmp);
}
}
#line 380 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void rule_self_print(struct rule *rule , FILE *stream ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 383
  if (rule->regex) {
    {
#line 384
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"/%s/ -> ",
            rule->word);
    }
  } else {
    {
#line 386
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\"%s\" -> ",
            rule->word);
    }
  }
  {
#line 387
  rhs_self_print(rule->rhs, stream);
  }
#line 388
  return;
}
}
#line 394 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
__inline static void rule_set_no_face(struct rule *rule , struct fface_s face ) 
{ 


  {
  {
#line 397
  rhs_set_no_face(rule->rhs, face);
  }
#line 398
  return;
}
}
#line 400 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void rules_set_no_faces(struct darray *arr , struct fface_s face ) 
{ 
  size_t i ;

  {
#line 405
  i = (size_t )0;
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! (i < arr->len)) {
#line 405
      goto while_break;
    }
    {
#line 406
    rule_set_no_face((struct rule *)*(arr->content + i), face);
#line 405
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 417 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct words *words_new(char const   *name_strings , char const   *name_regexps ,
                        size_t size , size_t increment ) 
{ 
  int c ;
  struct words *res___2 ;
  void *tmp ;
  struct rule **tmp___0 ;

  {
  {
#line 423
  tmp = xmalloc((size_t )sizeof(struct words ));
#line 423
  res___2 = (struct words *)tmp;
#line 426
  res___2->strings = da_new(name_strings, size, (enum da_growth )1, increment, (void (*)(void const   * ,
                                                                                         FILE *stream ))(& rule_self_print),
                            (int (*)(void const   *k1 , void const   *k2 ))(& rule_cmp));
#line 432
  res___2->regexps = da_new(name_regexps, size, (enum da_growth )1, increment, (void (*)(void const   * ,
                                                                                         FILE *stream ))(& rule_self_print),
                            (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
#line 438
  c = 0;
  }
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (! (c < 256)) {
#line 438
      goto while_break;
    }
#line 439
    tmp___0 = (struct rule **)((void *)0);
#line 439
    res___2->max[c] = tmp___0;
#line 439
    res___2->min[c] = tmp___0;
#line 438
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  return (res___2);
}
}
#line 444 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
__inline static void words_erase(struct words *words ) 
{ 


  {
  {
#line 448
  da_erase(words->strings);
#line 449
  da_erase(words->regexps);
#line 451
  free((void *)words);
  }
#line 452
  return;
}
}
#line 454 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void words_free(struct words *words ) 
{ 


  {
  {
#line 457
  da_free(words->strings, (void (*)(void * ))(& free_rule));
#line 458
  da_free(words->regexps, (void (*)(void * ))(& free_rule));
#line 459
  free((void *)words);
  }
#line 460
  return;
}
}
#line 462 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void words_self_print(struct words *words , FILE *stream ) 
{ 


  {
#line 465
  if ((words->regexps)->len) {
    {
#line 466
    da_self_print(words->regexps, stream);
    }
  }
#line 467
  if ((words->strings)->len) {
    {
#line 468
    da_self_print(words->strings, stream);
    }
  }
#line 469
  return;
}
}
#line 471 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void words_add_string(struct words *words , struct rule *rule ) 
{ 


  {
  {
#line 474
  da_append(words->strings, (void *)rule);
  }
#line 475
  return;
}
}
#line 477 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void words_add_regex(struct words *words , struct rule *rule ) 
{ 


  {
  {
#line 480
  da_append(words->regexps, (void *)rule);
  }
#line 481
  return;
}
}
#line 483 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void words_set_no_face(struct words *words , struct fface_s face ) 
{ 


  {
  {
#line 486
  rules_set_no_faces(words->strings, face);
#line 487
  rules_set_no_faces(words->regexps, face);
  }
#line 488
  return;
}
}
#line 497 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void words_merge_rules_unique(struct words *words , struct words *new ) 
{ 


  {
  {
#line 501
  da_concat(words->regexps, new->regexps);
#line 504
  da_qsort(new->strings);
#line 505
  da_merge(words->strings, new->strings, (void (*)(void * ))(& free_rule), (enum da_include_policy )1);
#line 510
  words_erase(new);
  }
#line 511
  return;
}
}
#line 516 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void words_finalize(struct words *list ) 
{ 
  size_t i ;
  struct rule **content ;

  {
  {
#line 523
  da_qsort(list->strings);
#line 527
  content = (struct rule **)(list->strings)->content;
#line 528
  i = (size_t )0;
  }
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i < (list->strings)->len)) {
#line 528
      goto while_break;
    }
#line 529
    if ((unsigned long )list->min[*((*(content + i))->word + 0)] == (unsigned long )((void *)0)) {
#line 530
      list->min[*((*(content + i))->word + 0)] = content + i;
    }
#line 531
    list->max[*((*(content + i))->word + 0)] = content + i;
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  return;
}
}
#line 538 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static struct darray *ancestors_new(void) 
{ 
  struct darray *tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 541
  tmp = da_new("Ancestors", (size_t )2, (enum da_growth )1, (size_t )2, (void (*)(void const   * ,
                                                                                  FILE *stream ))(& da_str_print),
               (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
  }
#line 541
  return (tmp);
}
}
#line 546 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void ancestors_finalize(struct style_sheet *sheet ) 
{ 
  int i ;
  struct style_sheet *ancestor ;

  {
#line 550
  ancestor = (struct style_sheet *)((void *)0);
#line 552
  if ((sheet->ancestors)->len == 0U) {
#line 553
    return;
  }
#line 557
  i = 0;
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 557
    if (! (i < (int )(sheet->ancestors)->len)) {
#line 557
      goto while_break;
    }
    {
#line 559
    ancestor = get_style_sheet((char const   *)((char *)*((sheet->ancestors)->content + i)));
    }
#line 561
    if (! ancestor) {
#line 562
      goto __Cont;
    }
    {
#line 568
    da_merge((sheet->keywords)->strings, (ancestor->keywords)->strings, (void (*)(void * ))((void *)0),
             (enum da_include_policy )0);
#line 571
    da_merge((sheet->operators)->strings, (ancestor->operators)->strings, (void (*)(void * ))((void *)0),
             (enum da_include_policy )0);
    }
    __Cont: /* CIL Label */ 
#line 557
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 582
  i = (int )(sheet->ancestors)->len - 1;
  {
#line 582
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 582
    if (! (i >= 0)) {
#line 582
      goto while_break___0;
    }
    {
#line 584
    ancestor = get_style_sheet((char const   *)((char *)*((sheet->ancestors)->content + i)));
    }
#line 585
    if (! ancestor) {
#line 586
      goto __Cont___0;
    }
#line 590
    if ((int )sheet->alpha1[0] == 127) {
      {
#line 591
      memcpy((void */* __restrict  */)(sheet->alpha1), (void const   */* __restrict  */)(ancestor->alpha1),
             (size_t )(sizeof(unsigned char ) * 256UL));
      }
    }
#line 592
    if ((int )sheet->alpha2[0] == 127) {
      {
#line 593
      memcpy((void */* __restrict  */)(sheet->alpha2), (void const   */* __restrict  */)(ancestor->alpha2),
             (size_t )(sizeof(unsigned char ) * 256UL));
      }
    }
#line 596
    if ((unsigned int )sheet->sensitiveness == 2U) {
#line 597
      sheet->sensitiveness = ancestor->sensitiveness;
    }
    {
#line 600
    da_prefix((sheet->keywords)->regexps, (ancestor->keywords)->regexps);
#line 604
    da_prefix((sheet->operators)->regexps, (ancestor->operators)->regexps);
#line 609
    da_prefix(sheet->sequences, ancestor->sequences);
    }
    __Cont___0: /* CIL Label */ 
#line 582
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 611
  return;
}
}
#line 619 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct sequence *sequence_new(struct rule *Open , struct fface_s in_face , struct words *Close ,
                              struct words *exceptions ) 
{ 
  struct sequence *res___2 ;
  void *tmp ;

  {
  {
#line 625
  tmp = xmalloc((size_t )sizeof(struct sequence ));
#line 625
  res___2 = (struct sequence *)tmp;
#line 628
  rule_set_no_face(Open, in_face);
#line 629
  res___2->open = Open;
#line 631
  res___2->face = in_face;
#line 633
  words_set_no_face(exceptions, in_face);
#line 634
  words_finalize(exceptions);
#line 635
  res___2->exceptions = exceptions;
#line 637
  words_set_no_face(Close, in_face);
#line 638
  words_finalize(Close);
#line 639
  res___2->close = Close;
  }
#line 640
  return (res___2);
}
}
#line 646 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void free_sequence(struct sequence *sequence___0 ) 
{ 


  {
  {
#line 649
  free_rule(sequence___0->open);
#line 650
  words_free(sequence___0->close);
#line 651
  words_free(sequence___0->exceptions);
#line 652
  free((void *)sequence___0);
  }
#line 653
  return;
}
}
#line 664 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static struct words *new_C_exceptions(void) 
{ 
  struct words *res___2 ;
  char *tmp ;
  struct darray *tmp___0 ;
  char *tmp___1 ;
  struct rule *tmp___2 ;
  char *tmp___3 ;
  struct darray *tmp___4 ;
  char *tmp___5 ;
  struct rule *tmp___6 ;
  char *tmp___7 ;
  struct darray *tmp___8 ;
  char *tmp___9 ;
  struct rule *tmp___10 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 669
  res___2 = words_new("C usual exceptions: strings", "C usual exceptions: regexps",
                      (size_t )3, (size_t )3);
#line 672
  tmp = xstrdup("\\\'");
#line 672
  tmp___0 = rhs_new_single((unsigned char *)tmp, 0, String_fface);
#line 672
  tmp___1 = xstrdup("\\\'");
#line 672
  tmp___2 = rule_new((unsigned char *)tmp___1, (struct pattern *)((void *)0), tmp___0,
                     "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c", (size_t )672);
#line 672
  words_add_string(res___2, tmp___2);
#line 673
  tmp___3 = xstrdup("\\\\");
#line 673
  tmp___4 = rhs_new_single((unsigned char *)tmp___3, 0, String_fface);
#line 673
  tmp___5 = xstrdup("\\\\");
#line 673
  tmp___6 = rule_new((unsigned char *)tmp___5, (struct pattern *)((void *)0), tmp___4,
                     "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c", (size_t )673);
#line 673
  words_add_string(res___2, tmp___6);
#line 674
  tmp___7 = xstrdup("\\\"");
#line 674
  tmp___8 = rhs_new_single((unsigned char *)tmp___7, 0, String_fface);
#line 674
  tmp___9 = xstrdup("\\\"");
#line 674
  tmp___10 = rule_new((unsigned char *)tmp___9, (struct pattern *)((void *)0), tmp___8,
                      "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c", (size_t )674);
#line 674
  words_add_string(res___2, tmp___10);
#line 676
  words_finalize(res___2);
  }
#line 677
  return (res___2);
}
}
#line 680 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct sequence *new_C_string_sequence(char const   *delimitor ) 
{ 
  struct sequence *res___2 ;
  void *tmp ;
  struct darray *tmp___0 ;
  char *tmp___1 ;
  struct darray *tmp___2 ;
  char *tmp___3 ;
  struct rule *tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 683
  tmp = xmalloc((size_t )sizeof(struct sequence ));
#line 683
  res___2 = (struct sequence *)tmp;
#line 684
  tmp___0 = rhs_new_single((unsigned char *)((void *)0), 0, Plain_fface);
#line 684
  tmp___1 = xstrdup(delimitor);
#line 684
  res___2->open = rule_new((unsigned char *)tmp___1, (struct pattern *)((void *)0),
                           tmp___0, "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c",
                           (size_t )686);
#line 687
  res___2->face = String_fface;
#line 688
  res___2->exceptions = new_C_exceptions();
#line 689
  res___2->close = words_new("C Close: strings", "C Close: regex", (size_t )5, (size_t )5);
#line 690
  tmp___2 = rhs_new_single((unsigned char *)((void *)0), 0, Plain_fface);
#line 690
  tmp___3 = xstrdup(delimitor);
#line 690
  tmp___4 = rule_new((unsigned char *)tmp___3, (struct pattern *)((void *)0), tmp___2,
                     "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c", (size_t )693);
#line 690
  words_add_string(res___2->close, tmp___4);
#line 694
  words_finalize(res___2->close);
  }
#line 695
  return (res___2);
}
}
#line 698 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void sequence_self_print(struct sequence *tmp , FILE *stream ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 701
  rule_self_print(tmp->open, stream);
#line 702
  fputs((char const   */* __restrict  */)" ->", (FILE */* __restrict  */)stream);
#line 703
  fface_self_print(tmp->face, stream);
#line 704
  fputs((char const   */* __restrict  */)":\n", (FILE */* __restrict  */)stream);
#line 705
  words_self_print(tmp->exceptions, stream);
#line 706
  words_self_print(tmp->close, stream);
  }
#line 707
  return;
}
}
#line 715 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct style_sheet *new_style_sheet(unsigned char const   *name ) 
{ 
  struct style_sheet *res___2 ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 718
  tmp = xmalloc((size_t )sizeof(struct style_sheet ));
#line 718
  res___2 = (struct style_sheet *)tmp;
#line 720
  res___2->name = name;
#line 721
  res___2->author = (unsigned char const   *)((unsigned char *)((void *)0));
#line 722
  version_set_to_null((int *)(res___2->version));
#line 723
  res___2->documentation = (unsigned char const   *)((unsigned char *)((void *)0));
#line 724
  version_set_to_null((int *)(res___2->requirement));
#line 725
  res___2->ancestors = ancestors_new();
#line 726
  res___2->sensitiveness = (enum case_sensitiveness )2;
#line 728
  res___2->alpha1[0] = (unsigned char)127;
#line 729
  res___2->alpha2[0] = (unsigned char)127;
#line 731
  res___2->keywords = words_new("Keywords: Strings", "Keywords: Regexps", (size_t )100,
                                (size_t )100);
#line 733
  res___2->operators = words_new("Operators: Strings", "Operators: Regexps", (size_t )100,
                                 (size_t )100);
#line 736
  res___2->sequences = da_new("Sequences", (size_t )100, (enum da_growth )1, (size_t )100,
                              (void (*)(void const   * , FILE *stream ))(& sequence_self_print),
                              (int (*)(void const   *k1 , void const   *k2 ))((void *)0));
  }
#line 740
  return (res___2);
}
}
#line 748 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static char *style_sheet_mixed_new(unsigned char const   *ancestors ) 
{ 
  struct style_sheet *sheet ;
  struct style_sheet *ancestor ;
  char *ancestor_key ;
  char *key ;
  char *cp ;
  char *ancestors_keys ;
  struct darray *ancestors_array ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *_tmp_ ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 757
  tmp = strlen((char const   *)ancestors);
#line 757
  tmp___0 = __builtin_alloca(sizeof(char ) * (unsigned long )(tmp + 1U));
#line 757
  key = (char *)tmp___0;
  }
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 758
    _tmp_ = (char const   *)ancestors;
#line 758
    tmp___1 = strlen(_tmp_);
#line 758
    tmp___2 = __builtin_alloca(sizeof(char ) * (unsigned long )(tmp___1 + 1U));
#line 758
    ancestors_keys = (char *)tmp___2;
#line 758
    strcpy((char */* __restrict  */)ancestors_keys, (char const   */* __restrict  */)_tmp_);
    }
#line 758
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 761
  ancestors_array = ancestors_new();
#line 762
  ancestor_key = strtok((char */* __restrict  */)ancestors_keys, (char const   */* __restrict  */)",;+");
#line 763
  da_append(ancestors_array, (void *)ancestor_key);
#line 764
  ancestor = get_style_sheet((char const   *)ancestor_key);
#line 765
  cp = stpcpy((char */* __restrict  */)key, (char const   */* __restrict  */)ancestor->key);
  }
  {
#line 767
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 767
    ancestor_key = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",;+");
    }
#line 767
    if (! ancestor_key) {
#line 767
      goto while_break___0;
    }
    {
#line 769
    da_append(ancestors_array, (void *)ancestor_key);
#line 770
    ancestor = get_style_sheet((char const   *)ancestor_key);
#line 771
    tmp___3 = cp;
#line 771
    cp ++;
#line 771
    *tmp___3 = (char )',';
#line 772
    cp = stpcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)ancestor->key);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 774
  *cp = (char )'\000';
#line 775
  key = xstrdup((char const   *)key);
  }
  {
#line 778
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 778
    if ((unsigned int )(1 << 2) & msg_verbosity) {
      {
#line 778
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Creating a mixed style sheet \"%s\"\n",
              key);
      }
    }
#line 778
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 781
  sheet = new_style_sheet((unsigned char const   *)((unsigned char *)key));
#line 782
  tmp___4 = strdup((char const   *)key);
#line 782
  sheet->key = (char const   *)tmp___4;
#line 783
  da_concat(sheet->ancestors, ancestors_array);
#line 784
  da_erase(ancestors_array);
#line 785
  style_sheet_finalize(sheet);
  }
#line 787
  return (key);
}
}
#line 797 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void style_sheet_finalize(struct style_sheet *sheet ) 
{ 
  _Bool tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    if ((unsigned int )(1 << 2) & msg_verbosity) {
      {
#line 800
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Finalizing style sheet \"%s\" (%s)\n",
              sheet->name, sheet->key);
      }
    }
#line 800
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 804
  ancestors_finalize(sheet);
  }
#line 807
  if ((int )sheet->alpha1[0] == 127) {
    {
#line 808
    string_to_array((unsigned char *)(sheet->alpha1), (unsigned char const   *)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_");
    }
  }
#line 809
  if ((int )sheet->alpha2[0] == 127) {
    {
#line 810
    string_to_array((unsigned char *)(sheet->alpha2), (unsigned char const   *)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789");
    }
  }
#line 813
  if ((unsigned int )sheet->sensitiveness == 2U) {
#line 814
    sheet->sensitiveness = (enum case_sensitiveness )1;
  }
  {
#line 816
  words_finalize(sheet->keywords);
#line 817
  words_finalize(sheet->operators);
  }
#line 818
  if ((unsigned int )(1 << 2) & msg_verbosity) {
    {
#line 820
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"---------- After Finalization of %s\n",
            sheet->key);
#line 821
    style_sheet_self_print(sheet, stderr);
    }
    {
#line 823
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 823
      if ((unsigned int )(1 << 2) & msg_verbosity) {
        {
#line 823
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Checking coherence of \"%s\" (%s)\n",
                sheet->name, sheet->key);
        }
      }
#line 823
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 826
    tmp = style_sheet_check(sheet);
    }
#line 826
    if (tmp) {
      {
#line 827
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 827
        if ((unsigned int )(1 << 2) & msg_verbosity) {
          {
#line 827
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"%s\" (%s) is sane.\n",
                  sheet->name, sheet->key);
          }
        }
#line 827
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 830
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 830
        if ((unsigned int )(1 << 2) & msg_verbosity) {
          {
#line 830
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"%s\" (%s) is corrupted.\n",
                  sheet->name, sheet->key);
          }
        }
#line 830
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 832
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"---------- End of Finalization of %s\n",
            sheet->key);
    }
  }
  {
#line 836
  hash_insert(style_sheets, (void *)sheet);
  }
#line 837
  return;
}
}
#line 843 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static struct style_sheet *load_style_sheet(char const   *pseudo_key ) 
{ 
  struct style_sheet *res___2 ;
  char *path ;
  char *tmp ;
  char *file ;
  char const   *_tmp1_ ;
  char const   *_tmp2_ ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 849
  tmp___13 = strlen(pseudo_key);
#line 849
  tmp___14 = strlen(".ssh");
  }
#line 849
  if (tmp___13 < tmp___14) {
#line 849
    tmp___12 = 0;
  } else {
    {
#line 849
    tmp___8 = strlen(pseudo_key);
#line 849
    tmp___9 = strlen(".ssh");
#line 849
    tmp___10 = strcmp((pseudo_key + tmp___8) - tmp___9, ".ssh");
    }
#line 849
    if (tmp___10) {
#line 849
      tmp___11 = 0;
    } else {
#line 849
      tmp___11 = 1;
    }
#line 849
    tmp___12 = tmp___11;
  }
#line 849
  if (tmp___12) {
    {
#line 856
    res___2 = parse_style_sheet(pseudo_key);
    }
  } else {
    {
#line 861
    tmp = pw_find_file((char * const  *)job->common.path, pseudo_key, ".ssh");
#line 861
    path = tmp;
    }
#line 862
    if (! path) {
      {
#line 865
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 865
        _tmp1_ = pseudo_key;
#line 865
        _tmp2_ = ".ssh";
#line 865
        tmp___0 = strlen(_tmp1_);
#line 865
        tmp___1 = strlen(_tmp2_);
#line 865
        tmp___2 = __builtin_alloca(sizeof(char ) * (unsigned long )((tmp___0 + tmp___1) + 1U));
#line 865
        file = (char *)tmp___2;
        }
        {
#line 865
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 865
          tmp___3 = stpcpy((char */* __restrict  */)file, (char const   */* __restrict  */)pseudo_key);
#line 865
          stpcpy((char */* __restrict  */)tmp___3, (char const   */* __restrict  */)".ssh");
          }
#line 865
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 865
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 866
      tmp___4 = quotearg((char const   *)file);
#line 866
      tmp___5 = gettext("cannot find file `%s\'");
#line 866
      error(0, 0, (char const   *)tmp___5, tmp___4);
      }
#line 867
      return ((struct style_sheet *)((void *)0));
    }
    {
#line 869
    res___2 = parse_style_sheet((char const   *)path);
#line 870
    free((void *)path);
    }
  }
  {
#line 874
  tmp___15 = strdup(pseudo_key);
#line 874
  res___2->key = (char const   *)tmp___15;
#line 875
  style_sheet_finalize(res___2);
  }
#line 877
  return (res___2);
}
}
#line 886 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static int sheet_name_cmp(char const   *key1 , char const   *key2 ) 
{ 
  struct style_sheet *tmp ;
  struct style_sheet *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 889
  tmp = get_style_sheet(key2);
#line 889
  tmp___0 = get_style_sheet(key1);
#line 889
  tmp___1 = strcasecmp((char const   *)tmp___0->name, (char const   *)tmp->name);
  }
#line 889
  return (tmp___1);
}
}
#line 896 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void style_sheet_self_print(struct style_sheet *sheet , FILE *stream ) 
{ 
  size_t i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 899
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Style sheet \"%s\" (%s), version ",
          sheet->name, sheet->key);
#line 901
  version_self_print((int *)(sheet->version), stream);
#line 902
  _IO_putc('\n', stream);
  }
#line 903
  if (! ((unsigned long )((char const   *)sheet->author) == (unsigned long )((void *)0))) {
#line 903
    if (! ((int const   )*(sheet->author) == 0)) {
      {
#line 904
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Written by %s\n",
              sheet->author);
      }
    }
  }
#line 905
  if ((sheet->ancestors)->len > 0U) {
    {
#line 908
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"It inherits from: ");
#line 909
    i = (size_t )0;
    }
    {
#line 909
    while (1) {
      while_continue: /* CIL Label */ ;
#line 909
      if (! (i < (sheet->ancestors)->len)) {
#line 909
        goto while_break;
      }
#line 910
      if (i) {
#line 910
        tmp = ", ";
      } else {
#line 910
        tmp = "";
      }
      {
#line 910
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s%s",
              tmp, (char *)*((sheet->ancestors)->content + i));
#line 909
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 913
    fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stream);
    }
  }
#line 916
  if ((unsigned int )sheet->sensitiveness == 1U) {
#line 916
    tmp___0 = "in";
  } else {
#line 916
    tmp___0 = "";
  }
  {
#line 916
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Case %ssensitive\n",
          tmp___0);
#line 920
  fputs((char const   */* __restrict  */)"First alphabet is ", (FILE */* __restrict  */)stream);
#line 921
  alphabet_self_print((char *)(sheet->alpha1), stream);
#line 922
  fputs((char const   */* __restrict  */)"Second alphabet is ", (FILE */* __restrict  */)stream);
#line 923
  alphabet_self_print((char *)(sheet->alpha2), stream);
#line 925
  words_self_print(sheet->keywords, stream);
#line 926
  words_self_print(sheet->operators, stream);
  }
#line 927
  if (! ((sheet->sequences)->len == 0U)) {
    {
#line 928
    da_self_print(sheet->sequences, stream);
    }
  }
#line 929
  return;
}
}
#line 934 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void style_sheet_print_signature(FILE *stream , struct style_sheet *sheet ) 
{ 
  int i ;
  int title_bar_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  _Bool tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 939
  tmp___6 = version_null_p((int *)(sheet->version));
  }
#line 939
  if (tmp___6) {
    {
#line 952
    tmp___3 = strlen(" (.ssh)");
#line 952
    tmp___4 = strlen((char const   *)sheet->name);
#line 952
    tmp___5 = strlen(sheet->key);
#line 952
    title_bar_len = (int )((tmp___3 + tmp___4) + tmp___5);
#line 955
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s.ssh)\n",
            sheet->name, sheet->key);
    }
  } else {
    {
#line 941
    tmp = strlen(" (.ssh version )");
#line 941
    tmp___0 = strlen((char const   *)sheet->name);
#line 941
    tmp___1 = strlen(sheet->key);
#line 941
    tmp___2 = version_length((int *)(sheet->version));
#line 941
    title_bar_len = (int )(((tmp + tmp___0) + tmp___1) + (size_t )tmp___2);
#line 945
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s.ssh version ",
            sheet->name, sheet->key);
#line 947
    version_self_print((int *)(sheet->version), stream);
#line 948
    fputs((char const   */* __restrict  */)")\n", (FILE */* __restrict  */)stream);
    }
  }
#line 958
  i = 0;
  {
#line 958
  while (1) {
    while_continue: /* CIL Label */ ;
#line 958
    if (! (i < title_bar_len)) {
#line 958
      goto while_break;
    }
    {
#line 959
    _IO_putc('-', stream);
#line 958
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 960
  _IO_putc('\n', stream);
#line 962
  authors_print_plain(sheet->author, stream, "Written by ");
#line 964
  documentation_print_plain(sheet->documentation, "%s\n", stream);
#line 965
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stream);
  }
#line 966
  return;
}
}
#line 971 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void list_style_sheets_short(FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 974
  tmp = gettext("Known Style Sheets");
#line 974
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
#line 975
  _IO_putc('\n', stream);
#line 976
  pw_lister_on_suffix(stream, (char * const  *)job->common.path, ".ssh");
  }
#line 977
  return;
}
}
#line 982 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void list_style_sheets_long(FILE *stream ) 
{ 
  struct style_sheet *sheet ;
  struct darray *entries ;
  size_t i ;
  char *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 989
  entries = pw_glob_on_suffix((char * const  *)job->common.path, ".ssh");
#line 992
  entries->cmp = (int (*)(void const   *k1 , void const   *k2 ))(& sheet_name_cmp);
#line 993
  da_qsort(entries);
#line 995
  tmp = gettext("Known Style Sheets");
#line 995
  title(stream, (char )'=', 1, (char const   *)tmp);
#line 996
  _IO_putc('\n', stream);
#line 998
  i = (size_t )0;
  }
  {
#line 998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 998
    if (! (i < entries->len)) {
#line 998
      goto while_break;
    }
    {
#line 1000
    sheet = get_style_sheet((char const   *)((char *)*(entries->content + i)));
#line 1001
    style_sheet_print_signature(stream, sheet);
#line 998
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1003
  da_free(entries, & free);
  }
#line 1004
  return;
}
}
#line 1013 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void style_sheet_html_print_signature(FILE *stream , struct style_sheet *sheet ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  size_t i ;
  char const   *tmp___1 ;
  _Bool tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 1016
  tmp = version_null_p((int *)(sheet->version));
  }
#line 1016
  if (tmp) {
    {
#line 1017
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"<li><p><strong><a href=\"%s.ssh\" name=\"%s\">%s</a></strong>.</p>\n",
            sheet->key, sheet->key, sheet->name);
    }
  } else {
    {
#line 1022
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"<li><p><strong><a href=\"%s.ssh\" name=\"%s\">%s</a></strong> version ",
            sheet->key, sheet->key, sheet->name);
#line 1025
    version_self_print((int *)(sheet->version), stream);
#line 1026
    fputs((char const   */* __restrict  */)".</p>\n", (FILE */* __restrict  */)stream);
    }
  }
#line 1029
  if ((unsigned long )((char const   *)sheet->author) == (unsigned long )((void *)0)) {
#line 1029
    goto _L___0;
  } else
#line 1029
  if ((int const   )*(sheet->author) == 0) {
    _L___0: /* CIL Label */ 
    {
#line 1029
    tmp___2 = version_null_p((int *)(sheet->requirement));
    }
#line 1029
    if (tmp___2) {
#line 1029
      if ((sheet->ancestors)->len > 0U) {
        _L: /* CIL Label */ 
        {
#line 1033
        fputs((char const   */* __restrict  */)"<p>", (FILE */* __restrict  */)stream);
#line 1034
        authors_print_html(sheet->author, stream, "Written by ");
#line 1035
        tmp___0 = version_null_p((int *)(sheet->requirement));
        }
#line 1035
        if (! tmp___0) {
          {
#line 1037
          fputs((char const   */* __restrict  */)"It requires a2ps version ", (FILE */* __restrict  */)stream);
#line 1038
          version_self_print((int *)(sheet->requirement), stream);
#line 1039
          fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stream);
          }
        }
#line 1041
        if ((sheet->ancestors)->len > 0U) {
          {
#line 1044
          fputs((char const   */* __restrict  */)"It inherits from: ", (FILE */* __restrict  */)stream);
#line 1045
          i = (size_t )0;
          }
          {
#line 1045
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1045
            if (! (i < (sheet->ancestors)->len)) {
#line 1045
              goto while_break;
            }
#line 1046
            if (i) {
#line 1046
              tmp___1 = ", ";
            } else {
#line 1046
              tmp___1 = "";
            }
            {
#line 1046
            fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s<a href=\"#%s\">%s.ssh</a>",
                    tmp___1, (char *)*((sheet->ancestors)->content + i), (char *)*((sheet->ancestors)->content + i));
#line 1045
            i ++;
            }
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 1050
          fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stream);
          }
        }
        {
#line 1052
        fputs((char const   */* __restrict  */)"</p>", (FILE */* __restrict  */)stream);
        }
      }
    } else {
#line 1029
      goto _L;
    }
  } else {
#line 1029
    goto _L;
  }
  {
#line 1055
  documentation_print_html(sheet->documentation, "<p>%s</p>\n", stream);
#line 1056
  fputs((char const   */* __restrict  */)"</li>\n\n", (FILE */* __restrict  */)stream);
  }
#line 1057
  return;
}
}
#line 1064 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void list_style_sheets_html(FILE *stream ) 
{ 
  struct style_sheet *sheet ;
  struct darray *entries ;
  size_t i ;
  version_t version_index ;
  version_t requirement ;
  int rows ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 1073
  entries = pw_glob_on_suffix((char * const  *)job->common.path, ".ssh");
#line 1075
  style_sheets_versions(entries, (int *)(version_index), (int *)(requirement));
#line 1078
  entries->cmp = (int (*)(void const   *k1 , void const   *k2 ))(& sheet_name_cmp);
#line 1079
  da_qsort(entries);
#line 1084
  tmp = expand_user_string(job, (struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)),
                           (unsigned char const   *)"sheets.html generation", (unsigned char const   *)"<html>\n#{html.begin.hook}\n<head>\n   <title>#{html.title:-GNU a2ps language support}</title>\n</head>\n\n<h1 align=\\\"CENTER\\\">\n#{html.title.1:-GNU a2ps language support}\n</h1>\n#{html.hline:-<hline>}\n<h2>Current <a href=\"sheets.mp\">sheets.map</a></h2>\n<p>It is the list of rules to decide what style sheet to use.</p>\n");
#line 1084
  fputs((char const   */* __restrict  */)((char *)tmp), (FILE */* __restrict  */)stream);
#line 1103
  tmp___0 = expand_user_string(job, (struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)),
                               (unsigned char const   *)"sheets.html generation",
                               (unsigned char const   *)"#{html.hline:-<hline>}\n<h2>Sumary of current style sheets</h2>\n<p>There is a <a href=\"sheets.tar.gz\">package</a> which contains them all.  Its index (sum of the style sheets version number) is <strong>");
#line 1103
  fputs((char const   */* __restrict  */)((char *)tmp___0), (FILE */* __restrict  */)stream);
#line 1112
  version_self_print((int *)(version_index), stream);
#line 1113
  fputs((char const   */* __restrict  */)"</strong>, and the highest requirement is a2ps version ",
        (FILE */* __restrict  */)stream);
#line 1114
  version_self_print((int *)(requirement), stream);
#line 1115
  fputs((char const   */* __restrict  */)".  Links point to their detailed exposure.</p>\n",
        (FILE */* __restrict  */)stream);
#line 1118
  rows = (int )(entries->len / 3U + 1U);
#line 1120
  fputs((char const   */* __restrict  */)"<table border=\"0\" cellpadding=\"0\"><tr>\n",
        (FILE */* __restrict  */)stream);
#line 1121
  i = (size_t )0;
  }
  {
#line 1121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1121
    if (! (i < entries->len)) {
#line 1121
      goto while_break;
    }
    {
#line 1123
    fputs((char const   */* __restrict  */)"<td valign=\"top\"><ul>\n", (FILE */* __restrict  */)stream);
    }
    {
#line 1124
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1126
      sheet = get_style_sheet((char const   *)((char *)*(entries->content + i)));
#line 1127
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"<li><a href=\"#%s\">%s <code>",
              sheet->key, sheet->name);
#line 1129
      version_self_print((int *)(sheet->version), stream);
#line 1130
      fputs((char const   */* __restrict  */)"</a></code></li>\n", (FILE */* __restrict  */)stream);
#line 1124
      i ++;
      }
#line 1124
      if (i % (unsigned int )rows) {
#line 1124
        if (! (i < entries->len)) {
#line 1124
          goto while_break___0;
        }
      } else {
#line 1124
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1133
    fputs((char const   */* __restrict  */)"</ul></td>\n", (FILE */* __restrict  */)stream);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1135
  fputs((char const   */* __restrict  */)"</tr></table>\n", (FILE */* __restrict  */)stream);
#line 1140
  tmp___1 = expand_user_string(job, (struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)),
                               (unsigned char const   *)"sheets.html generation",
                               (unsigned char const   *)"#{html.hline:-<hline>}\n<h2>Detailed list of current style sheets</h2>\n");
#line 1140
  fputs((char const   */* __restrict  */)((char *)tmp___1), (FILE */* __restrict  */)stream);
#line 1146
  fputs((char const   */* __restrict  */)"Links point to their files.</p>\n", (FILE */* __restrict  */)stream);
#line 1148
  fputs((char const   */* __restrict  */)"<ul>\n", (FILE */* __restrict  */)stream);
#line 1149
  i = (size_t )0;
  }
  {
#line 1149
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1149
    if (! (i < entries->len)) {
#line 1149
      goto while_break___1;
    }
    {
#line 1151
    sheet = get_style_sheet((char const   *)((char *)*(entries->content + i)));
#line 1152
    style_sheet_html_print_signature(stream, sheet);
#line 1149
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1154
  fputs((char const   */* __restrict  */)"</ul>\n", (FILE */* __restrict  */)stream);
#line 1156
  tmp___2 = expand_user_string(job, (struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)),
                               (unsigned char const   *)"sheets.html generation",
                               (unsigned char const   *)"#{html.end.hook}\n</body>\n</html>\n");
#line 1156
  fputs((char const   */* __restrict  */)((char *)tmp___2), (FILE */* __restrict  */)stream);
#line 1164
  da_free(entries, & free);
  }
#line 1165
  return;
}
}
#line 1174 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void style_sheet_texinfo_print_signature(FILE *stream , struct style_sheet *sheet ) 
{ 
  _Bool tmp ;
  size_t i ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1178
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"@deftp {Style Sheet} {%s} (@file{%s.ssh})\n",
          sheet->name, sheet->key);
  }
#line 1184
  if ((unsigned long )((char const   *)sheet->author) == (unsigned long )((void *)0)) {
#line 1184
    goto _L___1;
  } else
#line 1184
  if ((int const   )*(sheet->author) == 0) {
    _L___1: /* CIL Label */ 
#line 1184
    if ((unsigned int )(1 << 2) & msg_verbosity) {
      {
#line 1184
      tmp___1 = version_null_p((int *)(sheet->requirement));
      }
#line 1184
      if (tmp___1) {
#line 1184
        if ((sheet->ancestors)->len > 0U) {
          _L___0: /* CIL Label */ 
          {
#line 1189
          authors_print_texinfo(sheet->author, stream, "Written by ");
          }
#line 1190
          if ((unsigned int )(1 << 2) & msg_verbosity) {
            {
#line 1192
            tmp = version_null_p((int *)(sheet->requirement));
            }
#line 1192
            if (! tmp) {
              {
#line 1194
              fputs((char const   */* __restrict  */)"It requires @code{a2ps} version ",
                    (FILE */* __restrict  */)stream);
#line 1195
              version_self_print((int *)(sheet->requirement), stream);
#line 1196
              fputs((char const   */* __restrict  */)".  \n", (FILE */* __restrict  */)stream);
              }
            }
#line 1198
            if ((sheet->ancestors)->len > 0U) {
              {
#line 1201
              fputs((char const   */* __restrict  */)"It inherits from: ", (FILE */* __restrict  */)stream);
#line 1202
              i = (size_t )0;
              }
              {
#line 1202
              while (1) {
                while_continue: /* CIL Label */ ;
#line 1202
                if (! (i < (sheet->ancestors)->len)) {
#line 1202
                  goto while_break;
                }
#line 1203
                if (i) {
#line 1203
                  tmp___0 = ", ";
                } else {
#line 1203
                  tmp___0 = "";
                }
                {
#line 1203
                fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s@file{%s.ssh}",
                        tmp___0, (char *)*((sheet->ancestors)->content + i));
#line 1202
                i ++;
                }
              }
              while_break: /* CIL Label */ ;
              }
              {
#line 1206
              fputs((char const   */* __restrict  */)".  \n", (FILE */* __restrict  */)stream);
              }
            }
          }
        }
      } else {
#line 1184
        goto _L___0;
      }
    }
  } else {
#line 1184
    goto _L___0;
  }
  {
#line 1211
  documentation_print_texinfo(sheet->documentation, "%s\n", stream);
#line 1213
  fputs((char const   */* __restrict  */)"@end deftp\n\n", (FILE */* __restrict  */)stream);
  }
#line 1214
  return;
}
}
#line 1219 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
void list_style_sheets_texinfo(FILE *stream ) 
{ 
  struct style_sheet *sheet ;
  struct darray *entries ;
  size_t i ;
  version_t version_index ;
  version_t requirement ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1227
  entries = pw_glob_on_suffix((char * const  *)job->common.path, ".ssh");
#line 1230
  entries->cmp = (int (*)(void const   *k1 , void const   *k2 ))(& sheet_name_cmp);
#line 1231
  da_qsort(entries);
#line 1233
  style_sheets_versions(entries, (int *)(version_index), (int *)(requirement));
  }
#line 1237
  if ((unsigned int )(1 << 2) & msg_verbosity) {
    {
#line 1239
    fputs((char const   */* __restrict  */)"The current index (sum of all the style sheets version number) is ",
          (FILE */* __restrict  */)stream);
#line 1241
    version_self_print((int *)(version_index), stream);
#line 1242
    fputs((char const   */* __restrict  */)" and the highest requirement is a2ps version ",
          (FILE */* __restrict  */)stream);
#line 1243
    version_self_print((int *)(requirement), stream);
#line 1244
    fputs((char const   */* __restrict  */)".\n", (FILE */* __restrict  */)stream);
    }
  }
#line 1248
  i = (size_t )0;
  {
#line 1248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1248
    if (! (i < entries->len)) {
#line 1248
      goto while_break;
    }
    {
#line 1249
    sheet = get_style_sheet((char const   *)((char *)*(entries->content + i)));
#line 1250
    style_sheet_texinfo_print_signature(stream, sheet);
#line 1248
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1253
  da_free(entries, & free);
  }
#line 1254
  return;
}
}
#line 1263 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static _Bool check_rules_lower_case(char const   *name , struct darray *rules ) 
{ 
  size_t i ;
  _Bool res___2 ;
  int tmp ;
  char *__cil_tmp6 ;

  {
#line 1267
  res___2 = (_Bool)1;
#line 1269
  i = (size_t )0;
  {
#line 1269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1269
    if (! (i < rules->len)) {
#line 1269
      goto while_break;
    }
    {
#line 1270
    tmp = is_strlower((unsigned char const   *)((struct rule *)*(rules->content + i))->word);
    }
#line 1270
    if (! tmp) {
      {
#line 1271
      error(0, 0, "%s.ssh:`%s\' uses upper case characters", name, ((struct rule *)*(rules->content + i))->word);
#line 1274
      res___2 = (_Bool)0;
      }
    }
#line 1269
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1276
  return (res___2);
}
}
#line 1282 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static _Bool check_words_lower_case(char const   *name , struct words *words ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1285
  tmp = check_rules_lower_case(name, words->strings);
  }
#line 1285
  if (tmp) {
    {
#line 1285
    tmp___0 = check_rules_lower_case(name, words->regexps);
    }
#line 1285
    if (tmp___0) {
#line 1285
      tmp___1 = 1;
    } else {
#line 1285
      tmp___1 = 0;
    }
  } else {
#line 1285
    tmp___1 = 0;
  }
#line 1285
  return ((_Bool )tmp___1);
}
}
#line 1292 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static _Bool check_sequence_lower_case(char const   *name , struct sequence *sequence___0 ) 
{ 
  _Bool res___2 ;
  int tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 1295
  res___2 = (_Bool)1;
#line 1297
  tmp = is_strlower((unsigned char const   *)(sequence___0->open)->word);
  }
#line 1297
  if (! tmp) {
    {
#line 1298
    error(0, 0, "%s.ssh:`%s\' uses upper case characters", name, (sequence___0->open)->word);
#line 1301
    res___2 = (_Bool)0;
    }
  }
  {
#line 1304
  tmp___0 = check_words_lower_case(name, sequence___0->exceptions);
#line 1304
  res___2 = (_Bool )((int )res___2 & (int )tmp___0);
#line 1305
  tmp___1 = check_words_lower_case(name, sequence___0->close);
#line 1305
  res___2 = (_Bool )((int )res___2 & (int )tmp___1);
  }
#line 1307
  return (res___2);
}
}
#line 1310 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static _Bool check_sequences_lower_case(char const   *name , struct darray *sequences ) 
{ 
  size_t i ;
  _Bool res___2 ;
  _Bool tmp ;

  {
#line 1314
  res___2 = (_Bool)1;
#line 1316
  i = (size_t )0;
  {
#line 1316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1316
    if (! (i < sequences->len)) {
#line 1316
      goto while_break;
    }
    {
#line 1317
    tmp = check_sequence_lower_case(name, (struct sequence *)*(sequences->content + i));
#line 1317
    res___2 = (_Bool )((int )res___2 & (int )tmp);
#line 1316
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1320
  return (res___2);
}
}
#line 1327 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static _Bool check_sensitivity(struct style_sheet *sheet ) 
{ 
  _Bool res___2 ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1330
  res___2 = (_Bool)1;
#line 1332
  if ((unsigned int )sheet->sensitiveness == 0U) {
#line 1333
    return ((_Bool)1);
  }
  {
#line 1340
  tmp = check_words_lower_case(sheet->key, sheet->keywords);
#line 1340
  res___2 = (_Bool )((int )res___2 & (int )tmp);
#line 1341
  tmp___0 = check_words_lower_case(sheet->key, sheet->operators);
#line 1341
  res___2 = (_Bool )((int )res___2 & (int )tmp___0);
#line 1342
  tmp___1 = check_sequences_lower_case(sheet->key, sheet->sequences);
#line 1342
  res___2 = (_Bool )((int )res___2 & (int )tmp___1);
  }
#line 1344
  return (res___2);
}
}
#line 1348 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static _Bool check_rules_doubles(char const   *name , struct darray *rules ) 
{ 
  size_t i ;
  _Bool res___2 ;
  int tmp ;
  char *__cil_tmp6 ;

  {
#line 1352
  res___2 = (_Bool)1;
#line 1354
  i = (size_t )1;
  {
#line 1354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1354
    if (! (i < rules->len)) {
#line 1354
      goto while_break;
    }
    {
#line 1355
    tmp = strcmp((char const   *)((struct rule *)*(rules->content + (i - 1U)))->word,
                 (char const   *)((struct rule *)*(rules->content + i))->word);
    }
#line 1355
    if (! tmp) {
      {
#line 1358
      res___2 = (_Bool)0;
#line 1359
      error(0, 0, "%s.ssh:`%s\' is defined twice", name, ((struct rule *)*(rules->content + i))->word);
      }
    }
#line 1354
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1362
  return (res___2);
}
}
#line 1366 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static _Bool check_words_doubles(char const   *name , struct words *words ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1369
  tmp = check_rules_doubles(name, words->strings);
  }
#line 1369
  if (tmp) {
    {
#line 1369
    tmp___0 = check_rules_doubles(name, words->regexps);
    }
#line 1369
    if (tmp___0) {
#line 1369
      tmp___1 = 1;
    } else {
#line 1369
      tmp___1 = 0;
    }
  } else {
#line 1369
    tmp___1 = 0;
  }
#line 1369
  return ((_Bool )tmp___1);
}
}
#line 1376 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static _Bool check_doubles(struct style_sheet *sheet ) 
{ 
  _Bool res___2 ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1379
  res___2 = (_Bool)1;
#line 1381
  tmp = check_words_doubles(sheet->key, sheet->keywords);
#line 1381
  res___2 = (_Bool )((int )res___2 & (int )tmp);
#line 1382
  tmp___0 = check_words_doubles(sheet->key, sheet->operators);
#line 1382
  res___2 = (_Bool )((int )res___2 & (int )tmp___0);
  }
#line 1384
  return (res___2);
}
}
#line 1391 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static _Bool style_sheet_check(struct style_sheet *sheet ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1394
  tmp = check_doubles(sheet);
  }
#line 1394
  if (tmp) {
    {
#line 1394
    tmp___0 = check_sensitivity(sheet);
    }
#line 1394
    if (tmp___0) {
#line 1394
      tmp___1 = 1;
    } else {
#line 1394
      tmp___1 = 0;
    }
  } else {
#line 1394
    tmp___1 = 0;
  }
#line 1394
  return ((_Bool )tmp___1);
}
}
#line 1404 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static unsigned long sheet_hash_1(void const   *key ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 1407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1407
    result = 0UL;
    {
#line 1407
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1407
      kk = (unsigned char const   *)((struct style_sheet  const  *)key)->key - 1;
      {
#line 1407
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1407
        kk ++;
#line 1407
        if (! *kk) {
#line 1407
          goto while_break___1;
        }
#line 1407
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 15));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1407
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1407
    return (result);
#line 1407
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1408
  return (0UL);
}
}
#line 1410 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static unsigned long sheet_hash_2(void const   *key ) 
{ 
  unsigned long result ;
  unsigned char const   *kk ;

  {
  {
#line 1413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1413
    result = 0UL;
    {
#line 1413
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1413
      kk = (unsigned char const   *)((struct style_sheet  const  *)key)->key - 1;
      {
#line 1413
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1413
        kk ++;
#line 1413
        if (! *kk) {
#line 1413
          goto while_break___1;
        }
#line 1413
        result += (unsigned long )((int const   )*kk << ((int const   )*(kk + 1) & 7));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1413
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1413
    return (result);
#line 1413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1414
  return (0UL);
}
}
#line 1416 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static int sheet_hash_cmp(void const   *x , void const   *y ) 
{ 
  int result ;
  unsigned char const   *xx ;
  unsigned char const   *yy ;

  {
  {
#line 1419
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1419
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1419
      xx = (unsigned char const   *)((struct style_sheet  const  *)x)->key - 1;
#line 1419
      yy = (unsigned char const   *)((struct style_sheet  const  *)y)->key - 1;
      {
#line 1419
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1419
        xx ++;
#line 1419
        if ((int const   )*xx == 0) {
#line 1419
          yy ++;
#line 1419
          goto while_break___1;
        }
#line 1419
        yy ++;
#line 1419
        if (! ((int const   )*xx == (int const   )*yy)) {
#line 1419
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1419
      result = (int )((int const   )*xx - (int const   )*yy);
#line 1419
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1419
    return (result);
#line 1419
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1421
  return (0);
}
}
#line 1426 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct hash_table_s *new_style_sheets(void) 
{ 
  struct hash_table_s *res___2 ;
  void *tmp ;

  {
  {
#line 1430
  tmp = xmalloc((size_t )sizeof(hash_table ));
#line 1430
  res___2 = (hash_table *)tmp;
#line 1431
  hash_init(res___2, 8UL, & sheet_hash_1, & sheet_hash_2, & sheet_hash_cmp);
  }
#line 1433
  return (res___2);
}
}
#line 1439 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
static void require_style_sheet(char const   *key ) 
{ 
  struct style_sheet *item ;
  struct style_sheet token___1 ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1445
  tmp = strcmp(key, "plain");
  }
#line 1445
  if (tmp == 0) {
#line 1446
    return;
  }
  {
#line 1448
  token___1.key = (char const   *)((char *)key);
#line 1449
  tmp___0 = hash_find_item(style_sheets, (void const   *)(& token___1));
#line 1449
  item = (struct style_sheet *)tmp___0;
  }
#line 1451
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    {
#line 1457
    item = load_style_sheet(key);
    }
#line 1459
    if ((unsigned long )item == (unsigned long )((void *)0)) {
      {
#line 1460
      tmp___1 = gettext("cannot find style sheet `%s\': using plain style");
#line 1460
      error(0, 0, (char const   *)tmp___1, key);
      }
    }
  }
#line 1464
  return;
}
}
#line 1472 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
struct style_sheet *get_style_sheet(char const   *key ) 
{ 
  struct style_sheet *item ;
  struct style_sheet token___1 ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1478
  tmp = strcmp(key, "plain");
  }
#line 1478
  if (tmp == 0) {
#line 1479
    return ((struct style_sheet *)((void *)0));
  }
  {
#line 1489
  tmp___1 = strpbrk(key, ",;+");
  }
#line 1489
  if (tmp___1) {
    {
#line 1490
    tmp___0 = style_sheet_mixed_new((unsigned char const   *)key);
#line 1490
    key = (char const   *)tmp___0;
    }
  } else {
    {
#line 1493
    require_style_sheet(key);
    }
  }
  {
#line 1495
  token___1.key = (char const   *)((char *)key);
#line 1496
  tmp___2 = hash_find_item(style_sheets, (void const   *)(& token___1));
#line 1496
  item = (struct style_sheet *)tmp___2;
  }
#line 1498
  if (! item) {
#line 1499
    return ((struct style_sheet *)((void *)0));
  }
#line 1504
  re_syntax_table = (char *)(item->alpha1);
#line 1506
  return (item);
}
}
#line 1513 "/home/ysko/Works/test-src/a2ps-4.14/src/ssheet.c"
__inline static void style_sheets_versions(struct darray *keys , int *sum , int *requirement ) 
{ 
  size_t i ;
  struct style_sheet *sheet ;
  int tmp ;

  {
  {
#line 1520
  version_set_to_null((int *)sum);
#line 1521
  version_set_to_null((int *)requirement);
#line 1522
  i = (size_t )0;
  }
  {
#line 1522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1522
    if (! (i < keys->len)) {
#line 1522
      goto while_break;
    }
    {
#line 1524
    sheet = get_style_sheet((char const   *)((char *)*(keys->content + i)));
#line 1525
    version_add((int *)sum, (int *)(sheet->version));
#line 1526
    tmp = version_cmp((int *)(sheet->requirement), (int *)requirement);
    }
#line 1526
    if (tmp > 0) {
      {
#line 1527
      version_cpy((int *)requirement, (int *)(sheet->requirement));
      }
    }
#line 1522
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1529
  return;
}
}
#line 138 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 78 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
__inline static struct token *token_new(void) 
{ 
  struct token *res___2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 81
  tmp = xmalloc((size_t )sizeof(struct token ));
#line 81
  res___2 = (struct token *)tmp;
#line 82
  tmp___0 = xmalloc((size_t )sizeof(struct re_registers ));
#line 82
  res___2->registers = (struct re_registers *)tmp___0;
#line 83
  tmp___1 = xmalloc((size_t )(sizeof(regoff_t ) * 30UL));
#line 83
  (res___2->registers)->start = (regoff_t *)tmp___1;
#line 84
  tmp___2 = xmalloc((size_t )(sizeof(regoff_t ) * 30UL));
#line 84
  (res___2->registers)->end = (regoff_t *)tmp___2;
  }
#line 85
  return (res___2);
}
}
#line 88 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
__inline static struct darray *rhs_plain_new(void) 
{ 
  struct darray *tmp ;

  {
  {
#line 91
  tmp = rhs_new_single((unsigned char *)((void *)0), 0, Plain_fface);
  }
#line 91
  return (tmp);
}
}
#line 101 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
static struct token *token___0  =    (struct token *)((void *)0);
#line 114 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
static struct darray *plain_rhs  =    (struct darray *)((void *)0);
#line 123 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
__inline static void match_word(buffer_t *buffer , struct style_sheet *sheet ) 
{ 
  int start ;

  {
#line 126
  start = (int )buffer->curr;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    (buffer->curr) ++;
#line 128
    if (sheet->alpha2[*(buffer->content + buffer->curr)]) {
#line 128
      if (! (! (buffer->curr >= buffer->len))) {
#line 128
        goto while_break;
      }
    } else {
#line 128
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  token___0->rhs = plain_rhs;
#line 134
  ((struct faced_string *)*((token___0->rhs)->content + 0))->face = Plain_fface;
#line 135
  *((token___0->registers)->start + 0) = start;
#line 136
  *((token___0->registers)->end + 0) = (regoff_t )buffer->curr;
#line 137
  return;
}
}
#line 148 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
__inline static int match_keyword(buffer_t *buffer , struct words *words , unsigned char *alphabet ) 
{ 
  struct rule **key ;
  unsigned char *string ;
  int i ;
  int res___2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp13 ;

  {
#line 154
  string = buffer->value + buffer->curr;
#line 159
  if (words->min[*string]) {
#line 160
    key = words->max[*string];
    {
#line 160
    while (1) {
      while_continue: /* CIL Label */ ;
#line 160
      if (! ((unsigned long )words->min[*string] <= (unsigned long )key)) {
#line 160
        goto while_break;
      }
      {
#line 164
      tmp___1 = strlen((char const   *)(*key)->word);
#line 164
      tmp___2 = strncmp((char const   *)(*key)->word, (char const   *)string, tmp___1);
      }
#line 164
      if (! tmp___2) {
        {
#line 164
        tmp___3 = strlen((char const   *)(*key)->word);
        }
#line 164
        if (! *(alphabet + *(string + tmp___3))) {
#line 167
          token___0->rhs = (*key)->rhs;
          {
#line 168
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 168
            *((token___0->registers)->start + 0) = (regoff_t )buffer->curr;
#line 168
            tmp = strlen((char const   *)(*key)->word);
#line 168
            *((token___0->registers)->end + 0) = (regoff_t )(buffer->curr + tmp);
            }
#line 168
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 169
          tmp___0 = strlen((char const   *)(*key)->word);
#line 169
          buffer->curr += tmp___0;
          }
#line 170
          return (1);
        }
      }
#line 160
      key --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 176
  i = (int )(words->regexps)->len - 1;
  {
#line 176
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 176
    if (! (i >= 0)) {
#line 176
      goto while_break___1;
    }
    {
#line 178
    res___2 = re_match(((struct rule *)*((words->regexps)->content + i))->regex, (char const   *)((char *)buffer->value),
                       (int )buffer->len, (int )buffer->curr, token___0->registers);
    }
    {
#line 181
    if (res___2 == -2) {
#line 181
      goto case_neg_2;
    }
#line 184
    if (res___2 == -1) {
#line 184
      goto case_neg_1;
    }
#line 186
    goto switch_default;
    case_neg_2: /* CIL Label */ 
    {
#line 182
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"An error occured while matching\n");
    }
#line 183
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 185
    goto __Cont;
    switch_default: /* CIL Label */ 
#line 187
    token___0->rhs = ((struct rule *)*((words->regexps)->content + i))->rhs;
#line 188
    buffer->curr += (size_t )res___2;
#line 189
    return (1);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 176
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 194
  return (0);
}
}
#line 201 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
__inline static int match_operator(buffer_t *buffer , struct words *words ) 
{ 
  struct rule **key ;
  unsigned char *string ;
  int i ;
  int res___2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 206
  string = buffer->value + buffer->curr;
#line 211
  if (words->min[*string]) {
#line 212
    key = words->max[*string];
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! ((unsigned long )words->min[*string] <= (unsigned long )key)) {
#line 212
        goto while_break;
      }
      {
#line 216
      tmp___1 = strlen((char const   *)(*key)->word);
#line 216
      tmp___2 = strncmp((char const   *)(*key)->word, (char const   *)string, tmp___1);
      }
#line 216
      if (! tmp___2) {
#line 218
        token___0->rhs = (*key)->rhs;
        {
#line 219
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 219
          *((token___0->registers)->start + 0) = (regoff_t )buffer->curr;
#line 219
          tmp = strlen((char const   *)(*key)->word);
#line 219
          *((token___0->registers)->end + 0) = (regoff_t )(buffer->curr + tmp);
          }
#line 219
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 220
        tmp___0 = strlen((char const   *)(*key)->word);
#line 220
        buffer->curr += tmp___0;
        }
#line 221
        return (1);
      }
#line 212
      key --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 227
  i = (int )(words->regexps)->len - 1;
  {
#line 227
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 227
    if (! (i >= 0)) {
#line 227
      goto while_break___1;
    }
    {
#line 229
    res___2 = re_match(((struct rule *)*((words->regexps)->content + i))->regex, (char const   *)((char *)buffer->value),
                       (int )buffer->len, (int )buffer->curr, token___0->registers);
    }
    {
#line 232
    if (res___2 == -2) {
#line 232
      goto case_neg_2;
    }
#line 235
    if (res___2 == -1) {
#line 235
      goto case_neg_1;
    }
#line 237
    goto switch_default;
    case_neg_2: /* CIL Label */ 
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"An error occured while matching\n");
    }
#line 234
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 236
    goto __Cont;
    switch_default: /* CIL Label */ 
#line 238
    token___0->rhs = ((struct rule *)*((words->regexps)->content + i))->rhs;
#line 239
    buffer->curr += (size_t )res___2;
#line 240
    return (1);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 227
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 245
  return (0);
}
}
#line 257 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
__inline static struct sequence *match_sequence(buffer_t *buffer , struct style_sheet *sheet ) 
{ 
  int i ;
  int res___2 ;
  unsigned char *string ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;

  {
#line 262
  string = buffer->value + buffer->curr;
#line 265
  i = (int )(sheet->sequences)->len - 1;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (i >= 0)) {
#line 265
      goto while_break;
    }
#line 267
    if ((((struct sequence *)*((sheet->sequences)->content + i))->open)->regex) {
      {
#line 270
      res___2 = re_match((((struct sequence *)*((sheet->sequences)->content + i))->open)->regex,
                         (char const   *)((char *)buffer->value), (int )buffer->len,
                         (int )buffer->curr, token___0->registers);
      }
      {
#line 273
      if (res___2 == -2) {
#line 273
        goto case_neg_2;
      }
#line 276
      if (res___2 == -1) {
#line 276
        goto case_neg_1;
      }
#line 278
      goto switch_default;
      case_neg_2: /* CIL Label */ 
      {
#line 274
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"An error occured while matching\n");
      }
#line 275
      goto switch_break;
      case_neg_1: /* CIL Label */ 
#line 277
      goto __Cont;
      switch_default: /* CIL Label */ 
#line 279
      token___0->rhs = (((struct sequence *)*((sheet->sequences)->content + i))->open)->rhs;
#line 280
      buffer->curr += (size_t )res___2;
#line 281
      return ((struct sequence *)*((sheet->sequences)->content + i));
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 287
      tmp___1 = strlen((char const   *)(((struct sequence *)*((sheet->sequences)->content + i))->open)->word);
#line 287
      tmp___2 = strncmp((char const   *)(((struct sequence *)*((sheet->sequences)->content + i))->open)->word,
                        (char const   *)string, tmp___1);
      }
#line 287
      if (! tmp___2) {
        {
#line 289
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 289
          *((token___0->registers)->start + 0) = (regoff_t )buffer->curr;
#line 289
          tmp = strlen((char const   *)(((struct sequence *)*((sheet->sequences)->content + i))->open)->word);
#line 289
          *((token___0->registers)->end + 0) = (regoff_t )(buffer->curr + tmp);
          }
#line 289
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 290
        token___0->rhs = (((struct sequence *)*((sheet->sequences)->content + i))->open)->rhs;
#line 291
        tmp___0 = strlen((char const   *)(((struct sequence *)*((sheet->sequences)->content + i))->open)->word);
#line 291
        buffer->curr += tmp___0;
        }
#line 292
        return ((struct sequence *)*((sheet->sequences)->content + i));
      }
    }
    __Cont: /* CIL Label */ 
#line 265
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return ((struct sequence *)((void *)0));
}
}
#line 306
__inline static int ssh_get_token(buffer_t *buffer , struct style_sheet *sheet ) ;
#line 306 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
static int return_to_plain  =    0;
#line 308 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
static struct sequence *sequence  =    (struct sequence *)((void *)0);
#line 303 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
__inline static int ssh_get_token(buffer_t *buffer , struct style_sheet *sheet ) 
{ 
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
#line 310
  if (buffer->curr >= buffer->len) {
    {
#line 312
    buffer_get(buffer);
#line 318
    ((struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)))->lines = (int )buffer->line;
    }
#line 320
    if (buffer->len == 0U) {
#line 325
      sequence = (struct sequence *)((void *)0);
#line 326
      return_to_plain = 0;
#line 327
      return (0);
    }
  }
#line 331
  if (return_to_plain) {
#line 333
    return_to_plain = 0;
#line 334
    token___0->rhs = plain_rhs;
#line 335
    ((struct faced_string *)*((token___0->rhs)->content + 0))->face = Plain_fface;
  }
#line 338
  if (sequence) {
    {
#line 341
    tmp = match_operator(buffer, sequence->exceptions);
    }
#line 341
    if (tmp) {
#line 342
      return (1);
    }
    {
#line 344
    tmp___0 = match_operator(buffer, sequence->close);
    }
#line 344
    if (tmp___0) {
#line 346
      return_to_plain = 1;
#line 347
      sequence = (struct sequence *)((void *)0);
#line 348
      return (1);
    }
#line 352
    token___0->rhs = plain_rhs;
#line 353
    ((struct faced_string *)*((token___0->rhs)->content + 0))->face = sequence->face;
#line 354
    tmp___1 = buffer->curr;
#line 354
    (buffer->curr) ++;
#line 354
    *((token___0->registers)->start + 0) = (regoff_t )tmp___1;
#line 355
    *((token___0->registers)->end + 0) = (regoff_t )buffer->curr;
#line 356
    return (1);
  } else {
    {
#line 360
    sequence = match_sequence(buffer, sheet);
    }
#line 360
    if (sequence) {
#line 361
      return (1);
    } else
#line 362
    if (sheet->alpha1[*(buffer->content + buffer->curr)]) {
      {
#line 366
      tmp___2 = match_keyword(buffer, sheet->keywords, sheet->alpha2);
      }
#line 366
      if (tmp___2) {
#line 369
        return_to_plain = 1;
#line 370
        return (1);
      } else {
        {
#line 366
        tmp___3 = match_operator(buffer, sheet->operators);
        }
#line 366
        if (tmp___3) {
#line 369
          return_to_plain = 1;
#line 370
          return (1);
        } else {
          {
#line 379
          match_word(buffer, sheet);
          }
#line 380
          return (1);
        }
      }
    } else {
      {
#line 383
      tmp___4 = match_operator(buffer, sheet->operators);
      }
#line 383
      if (tmp___4) {
#line 385
        return_to_plain = 1;
#line 386
        return (1);
      }
    }
  }
#line 391
  token___0->rhs = plain_rhs;
#line 392
  tmp___5 = buffer->curr;
#line 392
  (buffer->curr) ++;
#line 392
  *((token___0->registers)->start + 0) = (regoff_t )tmp___5;
#line 393
  *((token___0->registers)->end + 0) = (regoff_t )buffer->curr;
#line 394
  return (1);
}
}
#line 407 "/home/ysko/Works/test-src/a2ps-4.14/src/sshread.c"
void ssh_print_postscript(struct a2ps_job *Job , buffer_t *buffer , struct style_sheet *sheet ) 
{ 
  struct fface_s fface ;
  unsigned char bufenc[512] ;
  int grabbing_encoding ;
  size_t i ;
  struct encoding *newenc ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 415
  grabbing_encoding = 0;
#line 418
  bufenc[0] = (unsigned char )'\000';
#line 419
  fface = Plain_fface;
#line 424
  if (! token___0) {
    {
#line 426
    token___0 = token_new();
#line 427
    plain_rhs = rhs_plain_new();
    }
  }
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 430
    tmp___1 = ssh_get_token(buffer, sheet);
    }
#line 430
    if (! (tmp___1 != 0)) {
#line 430
      goto while_break;
    }
#line 431
    i = (size_t )0;
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 431
      if (! (i < (token___0->rhs)->len)) {
#line 431
        goto while_break___0;
      }
#line 434
      if ((int )fface.face == (int )((struct faced_string *)*((token___0->rhs)->content + i))->face.face) {
#line 434
        if (! ((unsigned int )fface.flags == (unsigned int )((struct faced_string *)*((token___0->rhs)->content + i))->face.flags)) {
#line 434
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 437
        if ((unsigned int )((struct faced_string *)*((token___0->rhs)->content + i))->face.flags & 2U) {
#line 438
          Job->tag1[0] = (unsigned char )'\000';
        }
#line 439
        if ((unsigned int )((struct faced_string *)*((token___0->rhs)->content + i))->face.flags & 4U) {
#line 440
          Job->tag2[0] = (unsigned char )'\000';
        }
#line 441
        if ((unsigned int )((struct faced_string *)*((token___0->rhs)->content + i))->face.flags & 8U) {
#line 442
          Job->tag3[0] = (unsigned char )'\000';
        }
#line 443
        if ((unsigned int )((struct faced_string *)*((token___0->rhs)->content + i))->face.flags & 16U) {
#line 444
          Job->tag4[0] = (unsigned char )'\000';
        }
#line 445
        if (grabbing_encoding) {
#line 445
          if (! ((unsigned int )((struct faced_string *)*((token___0->rhs)->content + i))->face.flags & 512U)) {
            {
#line 450
            newenc = get_encoding_by_alias(job, (char *)(bufenc));
            }
#line 452
            if (! newenc) {
              {
#line 453
              tmp = quotearg((char const   *)((char *)(bufenc)));
#line 453
              tmp___0 = gettext("unknown encoding `%s\', ignored");
#line 453
              error(0, 0, (char const   *)tmp___0, tmp);
              }
            } else {
              {
#line 456
              ps_switch_encoding(Job, newenc);
              }
            }
#line 457
            bufenc[0] = (unsigned char )'\000';
#line 458
            grabbing_encoding = 0;
          }
        }
#line 460
        fface = ((struct faced_string *)*((token___0->rhs)->content + i))->face;
      }
#line 464
      if (((struct faced_string *)*((token___0->rhs)->content + i))->string) {
#line 466
        if ((unsigned int )fface.flags & 2U) {
          {
#line 467
          strcat((char */* __restrict  */)((char *)(Job->tag1)), (char const   */* __restrict  */)((char const   *)((struct faced_string *)*((token___0->rhs)->content + i))->string));
          }
        }
#line 468
        if ((unsigned int )fface.flags & 4U) {
          {
#line 469
          strcat((char */* __restrict  */)((char *)(Job->tag2)), (char const   */* __restrict  */)((char const   *)((struct faced_string *)*((token___0->rhs)->content + i))->string));
          }
        }
#line 470
        if ((unsigned int )fface.flags & 8U) {
          {
#line 471
          strcat((char */* __restrict  */)((char *)(Job->tag3)), (char const   */* __restrict  */)((char const   *)((struct faced_string *)*((token___0->rhs)->content + i))->string));
          }
        }
#line 472
        if ((unsigned int )fface.flags & 16U) {
          {
#line 473
          strcat((char */* __restrict  */)((char *)(Job->tag4)), (char const   */* __restrict  */)((char const   *)((struct faced_string *)*((token___0->rhs)->content + i))->string));
          }
        }
#line 475
        if ((unsigned int )fface.flags & 512U) {
          {
#line 477
          grabbing_encoding = 1;
#line 478
          strcat((char */* __restrict  */)((char *)(bufenc)), (char const   */* __restrict  */)((char const   *)((struct faced_string *)*((token___0->rhs)->content + i))->string));
          }
        }
      } else {
#line 483
        if ((unsigned int )fface.flags & 2U) {
          {
#line 484
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 484
            strncat((char */* __restrict  */)((char *)(Job->tag1)), (char const   */* __restrict  */)((char const   *)buffer->content + *((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref)),
                    (size_t )(*((token___0->registers)->end + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref) - *((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref)));
            }
#line 484
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 485
        if ((unsigned int )fface.flags & 4U) {
          {
#line 486
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 486
            strncat((char */* __restrict  */)((char *)(Job->tag2)), (char const   */* __restrict  */)((char const   *)buffer->content + *((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref)),
                    (size_t )(*((token___0->registers)->end + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref) - *((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref)));
            }
#line 486
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 487
        if ((unsigned int )fface.flags & 8U) {
          {
#line 488
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 488
            strncat((char */* __restrict  */)((char *)(Job->tag3)), (char const   */* __restrict  */)((char const   *)buffer->content + *((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref)),
                    (size_t )(*((token___0->registers)->end + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref) - *((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref)));
            }
#line 488
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 489
        if ((unsigned int )fface.flags & 16U) {
          {
#line 490
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 490
            strncat((char */* __restrict  */)((char *)(Job->tag4)), (char const   */* __restrict  */)((char const   *)buffer->content + *((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref)),
                    (size_t )(*((token___0->registers)->end + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref) - *((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref)));
            }
#line 490
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 492
        if ((unsigned int )fface.flags & 512U) {
#line 494
          grabbing_encoding = 1;
          {
#line 495
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 495
            strncat((char */* __restrict  */)((char *)(bufenc)), (char const   */* __restrict  */)((char const   *)buffer->content + *((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref)),
                    (size_t )(*((token___0->registers)->end + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref) - *((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref)));
            }
#line 495
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
#line 502
      if (! ((unsigned int )fface.flags & 1U)) {
#line 504
        if (((struct faced_string *)*((token___0->rhs)->content + i))->string) {
          {
#line 505
          ps_print_string(Job, ((struct faced_string *)*((token___0->rhs)->content + i))->string,
                          fface.face);
          }
        } else {
          {
#line 508
          ps_print_buffer(Job, (unsigned char const   *)buffer->content, (size_t )*((token___0->registers)->start + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref),
                          (size_t )*((token___0->registers)->end + ((struct faced_string *)*((token___0->rhs)->content + i))->reg_ref),
                          fface.face);
          }
        }
      }
#line 431
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return;
}
}
#line 38 "/home/ysko/Works/test-src/a2ps-4.14/src/read.c"
static int plain_getc(buffer_t *buffer , enum face_e *face ) 
{ 
  unsigned char c ;
  size_t tmp ;
  unsigned char const   *input ;
  char c2 ;

  {
#line 43
  if (buffer->curr >= buffer->len) {
    {
#line 45
    buffer_get(buffer);
#line 51
    ((struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)))->lines = (int )buffer->line;
    }
#line 53
    if (buffer->len == 0U) {
#line 54
      return (-1);
    }
  }
#line 57
  *face = (enum face_e )0;
#line 58
  tmp = buffer->curr;
#line 58
  (buffer->curr) ++;
#line 58
  c = *(buffer->content + tmp);
#line 61
  if ((int )*(buffer->content + buffer->curr) == 8) {
#line 64
    input = (unsigned char const   *)((buffer->content + buffer->curr) + 1);
#line 71
    if ((int )c == (int )*(input + 0)) {
#line 71
      if (8 == (int )*(input + 1)) {
#line 71
        if ((int )c == (int )*(input + 2)) {
#line 71
          if (8 == (int )*(input + 3)) {
#line 71
            if ((int )c == (int )*(input + 4)) {
#line 71
              if (8 == (int )*(input + 5)) {
#line 71
                if ((int )c == (int )*(input + 6)) {
#line 79
                  *face = (enum face_e )4;
#line 80
                  buffer->curr += 8U;
                } else {
#line 71
                  goto _L___20;
                }
              } else {
#line 71
                goto _L___20;
              }
            } else {
#line 71
              goto _L___20;
            }
          } else {
#line 71
            goto _L___20;
          }
        } else {
#line 71
          goto _L___20;
        }
      } else {
#line 71
        goto _L___20;
      }
    } else
    _L___20: /* CIL Label */ 
#line 82
    if ((int )c == (int )*(input + 0)) {
#line 82
      if (8 == (int )*(input + 1)) {
#line 82
        if ((int )c == (int )*(input + 2)) {
#line 82
          if (8 == (int )*(input + 3)) {
#line 82
            if ((int )c == (int )*(input + 4)) {
#line 88
              *face = (enum face_e )2;
#line 89
              buffer->curr += 6U;
            } else {
#line 82
              goto _L___14;
            }
          } else {
#line 82
            goto _L___14;
          }
        } else {
#line 82
          goto _L___14;
        }
      } else {
#line 82
        goto _L___14;
      }
    } else
    _L___14: /* CIL Label */ 
#line 91
    if ((int )c == (int )*(input + 0)) {
#line 91
      if (8 == (int )*(input + 1)) {
#line 91
        if ((int )c == (int )*(input + 2)) {
#line 95
          *face = (enum face_e )2;
#line 96
          buffer->curr += 4U;
        } else {
#line 91
          goto _L___10;
        }
      } else {
#line 91
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 98
    if ((int )c == (int )*(input + 0)) {
#line 100
      *face = (enum face_e )2;
#line 101
      buffer->curr += 2U;
    } else
#line 105
    if ((int )c == 95) {
#line 107
      c2 = (char )*(input + 0);
#line 110
      if (8 == (int )*(input + 1)) {
#line 110
        if ((int )c2 == (int )*(input + 2)) {
#line 110
          if (8 == (int )*(input + 3)) {
#line 110
            if ((int )c2 == (int )*(input + 4)) {
#line 110
              if (8 == (int )*(input + 5)) {
#line 110
                if ((int )c2 == (int )*(input + 6)) {
#line 117
                  *face = (enum face_e )4;
#line 118
                  c = (unsigned char )c2;
#line 119
                  buffer->curr += 8U;
                } else {
#line 123
                  *face = (enum face_e )1;
#line 124
                  c = (unsigned char )*(input + 0);
#line 125
                  buffer->curr += 2U;
                }
              } else {
#line 123
                *face = (enum face_e )1;
#line 124
                c = (unsigned char )*(input + 0);
#line 125
                buffer->curr += 2U;
              }
            } else {
#line 123
              *face = (enum face_e )1;
#line 124
              c = (unsigned char )*(input + 0);
#line 125
              buffer->curr += 2U;
            }
          } else {
#line 123
            *face = (enum face_e )1;
#line 124
            c = (unsigned char )*(input + 0);
#line 125
            buffer->curr += 2U;
          }
        } else {
#line 123
          *face = (enum face_e )1;
#line 124
          c = (unsigned char )*(input + 0);
#line 125
          buffer->curr += 2U;
        }
      } else {
#line 123
        *face = (enum face_e )1;
#line 124
        c = (unsigned char )*(input + 0);
#line 125
        buffer->curr += 2U;
      }
    } else
#line 130
    if (111 == (int )c) {
#line 130
      if (43 == (int )*(input + 0)) {
#line 135
        *face = (enum face_e )6;
#line 136
        buffer->curr += 2U;
#line 137
        c = (unsigned char)197;
      } else {
#line 130
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 130
    if (43 == (int )c) {
#line 130
      if (111 == (int )*(input + 0)) {
#line 135
        *face = (enum face_e )6;
#line 136
        buffer->curr += 2U;
#line 137
        c = (unsigned char)197;
      } else {
#line 130
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 140
    if (99 == (int )c) {
#line 140
      if (79 == (int )*(input + 0)) {
#line 143
        *face = (enum face_e )6;
#line 144
        buffer->curr += 2U;
#line 145
        c = (unsigned char)227;
      } else {
#line 140
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 148
    if (43 == (int )c) {
#line 148
      if (95 == (int )*(input + 0)) {
#line 151
        *face = (enum face_e )6;
#line 152
        buffer->curr += 2U;
#line 153
        c = (unsigned char)177;
      } else {
#line 148
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 156
    if (126 == (int )c) {
#line 156
      if (62 == (int )*(input + 0)) {
#line 156
        if (8 == (int )*(input + 1)) {
#line 156
          if (95 == (int )*(input + 2)) {
#line 161
            *face = (enum face_e )6;
#line 162
            buffer->curr += 4U;
#line 163
            c = (unsigned char)179;
          } else {
#line 156
            goto _L___4;
          }
        } else {
#line 156
          goto _L___4;
        }
      } else {
#line 156
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 166
    if (126 == (int )c) {
#line 166
      if (60 == (int )*(input + 0)) {
#line 166
        if (8 == (int )*(input + 1)) {
#line 166
          if (95 == (int )*(input + 2)) {
#line 171
            *face = (enum face_e )6;
#line 172
            buffer->curr += 4U;
#line 173
            c = (unsigned char)163;
          } else {
#line 166
            goto _L___1;
          }
        } else {
#line 166
          goto _L___1;
        }
      } else {
#line 166
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 177
    if (95 == (int )*(input + 0)) {
#line 179
      *face = (enum face_e )1;
#line 180
      buffer->curr += 2U;
    } else
#line 185
    if ((((struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)))->lines + 3) % 66 == 0) {
#line 188
      buffer->curr += 2U;
    } else
#line 185
    if ((((struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)))->lines - 4) % 66 == 0) {
#line 188
      buffer->curr += 2U;
    }
  }
#line 192
  return ((int )c);
}
}
#line 198 "/home/ysko/Works/test-src/a2ps-4.14/src/read.c"
void plain_print_postscript(struct a2ps_job *Job , buffer_t *buffer ) 
{ 
  enum face_e face ;
  int c ;

  {
#line 201
  face = (enum face_e )0;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 204
    c = plain_getc(buffer, & face);
    }
#line 204
    if (! (c != -1)) {
#line 204
      goto while_break;
    }
    {
#line 205
    ps_print_char(Job, c, face);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 517 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
#line 564 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 101 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
enum behavior behavior  =    (enum behavior )0;
#line 106 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
char const   *program_name  ;
#line 107 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
char const   *program_invocation_name  ;
#line 111 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
struct a2ps_job *job  =    (struct a2ps_job *)((void *)0);
#line 116 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
char *re_syntax_table  =    (char *)((void *)0);
#line 137 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
struct hash_table_s *delegation_table  ;
#line 142 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
struct darray *sheets_map  =    (struct darray *)((void *)0);
#line 147 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
struct hash_table_s *style_sheets  =    (struct hash_table_s *)((void *)0);
#line 155 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
_Bool delegate_p  =    (_Bool)1;
#line 160 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
unsigned char *toc  =    (unsigned char *)((void *)0);
#line 165 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
char *style_request  =    (char *)((void *)0);
#line 170 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
int highlight_level  =    1;
#line 175 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
int strip_level  =    0;
#line 181 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
enum eol_e end_of_line  =    (enum eol_e )4;
#line 189 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static void exit_handler(void) 
{ 


  {
#line 192
  if (job) {
    {
#line 193
    a2ps_job_unlink_tmpfiles(job);
    }
  }
#line 194
  if (sample_tmpname) {
    {
#line 195
    unlink((char const   *)sample_tmpname);
    }
  }
#line 196
  return;
}
}
#line 198 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static void signal_handler(int signum ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 202
  tmp = strsignal(signum);
#line 202
  tmp___0 = gettext("received signal %d: %s");
#line 202
  error(1, 0, (char const   *)tmp___0, signum, tmp);
  }
#line 204
  return;
}
}
#line 209 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static char const   * const  highlight_level_args[10]  = 
#line 209
  {      (char const   */* const  */)"none",      (char const   */* const  */)"off",      (char const   */* const  */)"0",      (char const   */* const  */)"normal", 
        (char const   */* const  */)"light",      (char const   */* const  */)"1",      (char const   */* const  */)"heavy",      (char const   */* const  */)"symbols", 
        (char const   */* const  */)"2",      (char const   */* const  */)0};
#line 217 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static int const   highlight_level_types[9]  = 
#line 217
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )2,      (int const   )2, 
        (int const   )2};
#line 227 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static int get_highlight_level(char const   *option , char const   *arg ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 230
  if (! (sizeof(highlight_level_args) / sizeof(highlight_level_args[0]) == sizeof(highlight_level_types) / sizeof(highlight_level_types[0]) + 1UL)) {
    {
#line 230
    __assert_fail("(sizeof (((highlight_level_args))) / sizeof (*((highlight_level_args)))) == (sizeof (((highlight_level_types))) / sizeof (*((highlight_level_types)))) + 1",
                  "/home/ysko/Works/test-src/a2ps-4.14/src/main.c", 230U, "get_highlight_level");
    }
  }
  {
#line 231
  tmp = __xargmatch_internal(option, arg, highlight_level_args, (char const   *)(highlight_level_types),
                             (size_t )sizeof(highlight_level_types[0]), 0, argmatch_die);
  }
#line 231
  return ((int )highlight_level_types[tmp]);
}
}
#line 235 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static char *highlight_level_to_string(int level ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 240
  if (level == 2) {
#line 240
    goto case_2;
  }
#line 244
  if (level == 1) {
#line 244
    goto case_1;
  }
#line 248
  if (level == 0) {
#line 248
    goto case_0;
  }
#line 238
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 242
  tmp = gettext("heavy");
  }
#line 242
  return (tmp);
  case_1: /* CIL Label */ 
  {
#line 246
  tmp___0 = gettext("normal");
  }
#line 246
  return (tmp___0);
  case_0: /* CIL Label */ 
  {
#line 250
  tmp___1 = gettext("none");
  }
#line 250
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
#line 252
  return ((char *)((void *)0));
}
}
#line 258 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static char const   * const  behavior_args[37]  = 
#line 258
  {      (char const   */* const  */)"defaults",      (char const   */* const  */)"options",      (char const   */* const  */)"settings",      (char const   */* const  */)"features", 
        (char const   */* const  */)"plugins",      (char const   */* const  */)"delegations",      (char const   */* const  */)"encodings",      (char const   */* const  */)"charsets", 
        (char const   */* const  */)"variables",      (char const   */* const  */)"macro-meta-sequences",      (char const   */* const  */)"media",      (char const   */* const  */)"printers", 
        (char const   */* const  */)"outputs",      (char const   */* const  */)"style-sheets",      (char const   */* const  */)"languages",      (char const   */* const  */)"user-options", 
        (char const   */* const  */)"shortcuts",      (char const   */* const  */)"prologues",      (char const   */* const  */)"texinfo-style-sheets",      (char const   */* const  */)"ssh-texi", 
        (char const   */* const  */)"html-style-sheets",      (char const   */* const  */)"ssh-html",      (char const   */* const  */)"texinfo-encodings",      (char const   */* const  */)"edf-texi", 
        (char const   */* const  */)"texinfo-prologues",      (char const   */* const  */)"pro-texi",      (char const   */* const  */)"ppd",      (char const   */* const  */)"version", 
        (char const   */* const  */)"release",      (char const   */* const  */)"help",      (char const   */* const  */)"usage",      (char const   */* const  */)"expand", 
        (char const   */* const  */)"which",      (char const   */* const  */)"find",      (char const   */* const  */)"glob",      (char const   */* const  */)"ps", 
        (char const   */* const  */)((void *)0)};
#line 284 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static enum behavior  const  behavior_types[36]  = 
#line 284
  {      (enum behavior  const  )7,      (enum behavior  const  )7,      (enum behavior  const  )7,      (enum behavior  const  )8, 
        (enum behavior  const  )8,      (enum behavior  const  )14,      (enum behavior  const  )16,      (enum behavior  const  )16, 
        (enum behavior  const  )15,      (enum behavior  const  )15,      (enum behavior  const  )9,      (enum behavior  const  )13, 
        (enum behavior  const  )13,      (enum behavior  const  )10,      (enum behavior  const  )10,      (enum behavior  const  )18, 
        (enum behavior  const  )18,      (enum behavior  const  )19,      (enum behavior  const  )12,      (enum behavior  const  )12, 
        (enum behavior  const  )11,      (enum behavior  const  )11,      (enum behavior  const  )17,      (enum behavior  const  )17, 
        (enum behavior  const  )20,      (enum behavior  const  )20,      (enum behavior  const  )21,      (enum behavior  const  )3, 
        (enum behavior  const  )3,      (enum behavior  const  )2,      (enum behavior  const  )2,      (enum behavior  const  )4, 
        (enum behavior  const  )5,      (enum behavior  const  )5,      (enum behavior  const  )6,      (enum behavior  const  )0};
#line 319 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static void list_options(struct a2ps_job *a_job , FILE *stream ) 
{ 
  unsigned char buf___0[256] ;
  unsigned char buf2[256] ;
  char const   *cp ;
  unsigned char *ucp ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___10 ;
  _Bool tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char const   *tmp___39 ;
  char const   *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char const   *tmp___59 ;
  char const   *tmp___60 ;
  char const   *tmp___61 ;
  char *tmp___62 ;
  char const   *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char const   *tmp___71 ;
  char *tmp___72 ;
  void *__cil_tmp81 ;
  void *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;

  {
  {
#line 330
  cp = (char const   *)((void *)0);
#line 331
  ucp = (unsigned char *)((void *)0);
#line 334
  tmp = gettext("Configuration status of %s %s\n");
#line 334
  title(stream, (char )'=', 1, (char const   *)tmp, program_invocation_name, "4.14");
#line 337
  _IO_putc('\n', stream);
#line 339
  tmp___0 = gettext("Sheets:\n");
#line 339
  title(stream, (char )'-', 0, (char const   *)tmp___0);
#line 340
  tmp___1 = file_align_to_string(a_job->file_align);
  }
#line 340
  if (a_job->border) {
    {
#line 340
    tmp___2 = gettext("yes");
#line 340
    tmp___4 = tmp___2;
    }
  } else {
    {
#line 340
    tmp___3 = gettext("no");
#line 340
    tmp___4 = tmp___3;
    }
  }
  {
#line 340
  tmp___5 = madir_to_string(a_job->madir);
  }
#line 340
  if ((unsigned int )a_job->orientation == 0U) {
    {
#line 340
    tmp___6 = gettext("portrait");
#line 340
    tmp___8 = tmp___6;
    }
  } else {
    {
#line 340
    tmp___7 = gettext("landscape");
#line 340
    tmp___8 = tmp___7;
    }
  }
  {
#line 340
  tmp___11 = a2ps_medium_libpaper_p(job, (char const   *)job->medium_request);
  }
#line 340
  if (tmp___11) {
#line 340
    tmp___10 = " (libpaper)";
  } else {
#line 340
    tmp___10 = "";
  }
  {
#line 340
  tmp___12 = gettext("  medium          = %s%s, %s\n  page layout     = %d x %d, %s\n  borders         = %s\n  file alignment  = %s\n  interior margin = %d\n");
#line 340
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___12,
          (a_job->medium)->name, tmp___10, tmp___8, a_job->columns, a_job->rows, tmp___5,
          tmp___4, tmp___1, a_job->margin);
#line 355
  _IO_putc('\n', stream);
  }
#line 357
  if (a_job->columns_requested > 0) {
    {
#line 358
    tmp___13 = gettext("%d characters per line");
#line 358
    sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)tmp___13,
            a_job->columns_requested);
    }
  } else
#line 360
  if (a_job->lines_requested > 0) {
    {
#line 361
    tmp___14 = gettext("%d lines per page");
#line 361
    sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)tmp___14,
            a_job->lines_requested);
    }
  } else {
    {
#line 364
    tmp___15 = gettext("font size is %gpt");
#line 364
    sprintf((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)tmp___15,
            (double )a_job->fontsize);
    }
  }
  {
#line 368
  if (a_job->numbering == 0) {
#line 368
    goto case_0;
  }
#line 371
  if (a_job->numbering == 1) {
#line 371
    goto case_1;
  }
#line 375
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 369
  tmp___16 = gettext("no");
#line 369
  strcpy((char */* __restrict  */)((char *)(buf2)), (char const   */* __restrict  */)((char const   *)tmp___16));
  }
#line 370
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 373
  tmp___17 = gettext("each line");
#line 373
  strcpy((char */* __restrict  */)((char *)(buf2)), (char const   */* __restrict  */)((char const   *)tmp___17));
  }
#line 374
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 377
  tmp___18 = gettext("each %d lines");
#line 377
  sprintf((char */* __restrict  */)((char *)(buf2)), (char const   */* __restrict  */)tmp___18,
          a_job->numbering);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 380
  tmp___19 = gettext("Virtual pages:\n");
#line 380
  title(stream, (char )'-', 0, (char const   *)tmp___19);
#line 381
  tmp___20 = unprintable_format_to_string(a_job->unprintable_format);
#line 381
  tmp___21 = gettext("  number lines         = %s\n  format               = %s\n  tabulation size      = %d\n  non printable format = %s\n");
#line 381
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___21,
          buf2, buf___0, a_job->tabsize, tmp___20);
#line 390
  _IO_putc('\n', stream);
#line 392
  tmp___22 = gettext("Headers:\n");
#line 392
  title(stream, (char )'-', 0, (char const   *)tmp___22);
  }
#line 393
  if ((unsigned long )((void const   *)a_job->water) == (unsigned long )((void *)0)) {
#line 393
    tmp___23 = "";
  } else {
#line 393
    tmp___23 = (char const   *)a_job->water;
  }
#line 393
  if ((unsigned long )((void const   *)a_job->right_title) == (unsigned long )((void *)0)) {
#line 393
    tmp___24 = "";
  } else {
#line 393
    tmp___24 = (char const   *)a_job->right_title;
  }
#line 393
  if ((unsigned long )((void const   *)a_job->center_title) == (unsigned long )((void *)0)) {
#line 393
    tmp___25 = "";
  } else {
#line 393
    tmp___25 = (char const   *)a_job->center_title;
  }
#line 393
  if ((unsigned long )((void const   *)a_job->left_title) == (unsigned long )((void *)0)) {
#line 393
    tmp___26 = "";
  } else {
#line 393
    tmp___26 = (char const   *)a_job->left_title;
  }
#line 393
  if ((unsigned long )((void const   *)a_job->right_footer) == (unsigned long )((void *)0)) {
#line 393
    tmp___27 = "";
  } else {
#line 393
    tmp___27 = (char const   *)a_job->right_footer;
  }
#line 393
  if ((unsigned long )((void const   *)a_job->footer) == (unsigned long )((void *)0)) {
#line 393
    tmp___28 = "";
  } else {
#line 393
    tmp___28 = (char const   *)a_job->footer;
  }
#line 393
  if ((unsigned long )((void const   *)a_job->left_footer) == (unsigned long )((void *)0)) {
#line 393
    tmp___29 = "";
  } else {
#line 393
    tmp___29 = (char const   *)a_job->left_footer;
  }
#line 393
  if ((unsigned long )((void const   *)a_job->header) == (unsigned long )((void *)0)) {
#line 393
    tmp___30 = "";
  } else {
#line 393
    tmp___30 = (char const   *)a_job->header;
  }
  {
#line 393
  tmp___31 = gettext("  header       = %s\n  left footer  = %s\n  footer       = %s\n  right footer = %s\n  left title   = %s\n  center title = %s\n  right title  = %s\n  under lay    = %s\n");
#line 393
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___31,
          tmp___30, tmp___29, tmp___28, tmp___27, tmp___26, tmp___25, tmp___24, tmp___23);
#line 410
  _IO_putc('\n', stream);
#line 412
  tmp___32 = gettext("Input:\n");
#line 412
  title(stream, (char )'-', 0, (char const   *)tmp___32);
  }
#line 413
  if (delegate_p) {
    {
#line 413
    tmp___33 = gettext("yes");
#line 413
    tmp___35 = tmp___33;
    }
  } else {
    {
#line 413
    tmp___34 = gettext("no");
#line 413
    tmp___35 = tmp___34;
    }
  }
#line 413
  if (a_job->print_binaries) {
    {
#line 413
    tmp___36 = gettext("yes");
#line 413
    tmp___38 = tmp___36;
    }
  } else {
    {
#line 413
    tmp___37 = gettext("no");
#line 413
    tmp___38 = tmp___37;
    }
  }
  {
#line 413
  tmp___39 = encoding_get_name(a_job->requested_encoding);
#line 413
  tmp___40 = eol_to_string(end_of_line);
  }
#line 413
  if (a_job->interpret) {
    {
#line 413
    tmp___41 = gettext("yes");
#line 413
    tmp___43 = tmp___41;
    }
  } else {
    {
#line 413
    tmp___42 = gettext("no");
#line 413
    tmp___43 = tmp___42;
    }
  }
#line 413
  if (! a_job->folding) {
    {
#line 413
    tmp___44 = gettext("yes");
#line 413
    tmp___46 = tmp___44;
    }
  } else {
    {
#line 413
    tmp___45 = gettext("no");
#line 413
    tmp___46 = tmp___45;
    }
  }
  {
#line 413
  tmp___47 = gettext("  truncate lines = %s\n  interpret      = %s\n  end of line    = %s\n  encoding       = %s\n  document title = %s\n  prologue       = %s\n  print anyway   = %s\n  delegating     = %s\n");
#line 413
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___47,
          tmp___46, tmp___43, tmp___40, tmp___39, a_job->title, a_job->prolog, tmp___38,
          tmp___35);
#line 430
  _IO_putc('\n', stream);
  }
#line 435
  if ((unsigned long )((char const   *)style_request) == (unsigned long )((void *)0)) {
    {
#line 438
    tmp___48 = gettext("selected automatically");
#line 438
    strcpy((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)((char const   *)tmp___48));
    }
  } else
#line 435
  if ((int )*style_request == 0) {
    {
#line 438
    tmp___48 = gettext("selected automatically");
#line 438
    strcpy((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)((char const   *)tmp___48));
    }
  } else {
    {
#line 440
    strcpy((char */* __restrict  */)((char *)(buf___0)), (char const   */* __restrict  */)((char const   *)style_request));
    }
  }
  {
#line 441
  tmp___49 = gettext("Pretty-printing:\n");
#line 441
  title(stream, (char )'-', 0, (char const   *)tmp___49);
#line 442
  tmp___50 = highlight_level_to_string(highlight_level);
#line 442
  tmp___51 = gettext("  style sheet     = %s\n  highlight level = %s\n  strip level     = %d\n");
#line 442
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___51,
          buf___0, tmp___50, strip_level);
#line 449
  _IO_putc('\n', stream);
#line 456
  ucp = a2ps_flag_destination_to_string(a_job);
  }
  {
#line 461
  if ((unsigned int )a_job->backup_type == 0U) {
#line 461
    goto case_0___0;
  }
#line 465
  if ((unsigned int )a_job->backup_type == 1U) {
#line 465
    goto case_1___0;
  }
#line 469
  if ((unsigned int )a_job->backup_type == 2U) {
#line 469
    goto case_2;
  }
#line 475
  if ((unsigned int )a_job->backup_type == 3U) {
#line 475
    goto case_3;
  }
#line 459
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 462
  tmp___52 = gettext("never make backups");
#line 462
  cp = (char const   *)tmp___52;
  }
#line 463
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 466
  tmp___53 = gettext("simple backups of every file");
#line 466
  cp = (char const   *)tmp___53;
  }
#line 467
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 471
  tmp___54 = gettext("numbered backups of files already numbered,\n                            and simple of others");
#line 471
  cp = (char const   *)tmp___54;
  }
#line 473
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 476
  tmp___55 = gettext("numbered backups of every file");
#line 476
  cp = (char const   *)tmp___55;
  }
#line 477
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 480
  tmp___56 = gettext("Output:\n");
#line 480
  title(stream, (char )'-', 0, (char const   *)tmp___56);
#line 481
  tmp___57 = gettext("  destination     = %s\n  version control = %s\n  backup suffix   = %s\n");
#line 481
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___57,
          ucp, cp, simple_backup_suffix);
#line 486
  _IO_putc('\n', stream);
#line 487
  free((void *)ucp);
#line 493
  cp = a2ps_printers_request_ppdkey_get(a_job->printers);
#line 494
  tmp___58 = gettext("PostScript:\n");
#line 494
  title(stream, (char )'-', 0, (char const   *)tmp___58);
  }
#line 495
  if ((unsigned int )a_job->duplex == 0U) {
#line 495
    tmp___60 = "Simplex";
  } else {
#line 495
    if ((unsigned int )a_job->duplex == 1U) {
#line 495
      tmp___59 = "Duplex";
    } else {
#line 495
      tmp___59 = "DuplexTumble";
    }
#line 495
    tmp___60 = tmp___59;
  }
  {
#line 495
  tmp___61 = a2ps_printers_default_ppdkey_get(a_job->printers);
  }
#line 495
  if (cp) {
#line 495
    tmp___63 = cp;
  } else {
    {
#line 495
    tmp___62 = gettext("selected automatically");
#line 495
    tmp___63 = (char const   *)tmp___62;
    }
  }
  {
#line 495
  tmp___64 = gettext("  magic number              = %s\n  Printer Description (PPD) = %s\n  default PPD               = %s\n  page label format         = %s\n  number of copies          = %d\n  sides per sheet           = %s\n  page device definitions   = ");
#line 495
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___64,
          (a_job->status)->magic_number, tmp___63, tmp___61, (a_job->status)->page_label_format,
          a_job->copies, tmp___60);
#line 514
  list_pagedevice(a_job, stream);
#line 515
  tmp___65 = gettext("  statusdict definitions    = ");
#line 515
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___65);
#line 517
  list_statusdict(a_job, stream);
  }
#line 518
  if (a_job->page_prefeed) {
    {
#line 518
    tmp___66 = gettext("yes");
#line 518
    tmp___68 = tmp___66;
    }
  } else {
    {
#line 518
    tmp___67 = gettext("no");
#line 518
    tmp___68 = tmp___67;
    }
  }
  {
#line 518
  tmp___69 = gettext("  page prefeed              = %s\n");
#line 518
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___69,
          tmp___68);
#line 521
  _IO_putc('\n', stream);
#line 527
  tmp___70 = gettext("Internals:\n");
#line 527
  title(stream, (char )'-', 0, (char const   *)tmp___70);
  }
#line 528
  if ((unsigned long )((void const   *)a_job->file_command) == (unsigned long )((void *)0)) {
#line 528
    tmp___71 = "";
  } else {
#line 528
    tmp___71 = (char const   *)a_job->file_command;
  }
  {
#line 528
  tmp___72 = gettext("  verbosity level     = %d\n  file command        = %s\n  library path        = \n");
#line 528
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___72,
          msg_verbosity, tmp___71);
#line 534
  pw_fprintf_path(stream, "\t%s\n", (char * const  *)a_job->common.path);
  }
#line 535
  return;
}
}
#line 546 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static void spy_user(struct a2ps_job *a_job , FILE *stream ) 
{ 
  FILE *spy ;
  char *spyname ;
  char buf___0[8192] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  unsigned char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (job->tmp_filenames[0]) {
#line 556
      job->tmp_filenames[0] = job->tmp_filenames[0];
    } else {
      {
#line 556
      tmp = tempnam((char const   *)((void *)0), "a2_");
#line 556
      job->tmp_filenames[0] = tmp;
      }
    }
#line 556
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 557
  spyname = job->tmp_filenames[0];
#line 558
  spy = fopen((char const   */* __restrict  */)spyname, (char const   */* __restrict  */)"w");
  }
#line 559
  if (! spy) {
    {
#line 560
    tmp___0 = quotearg((char const   *)spyname);
#line 560
    tmp___1 = gettext("cannot open file `%s\'");
#line 560
    tmp___2 = __errno_location();
#line 560
    error(1, *tmp___2, (char const   *)tmp___1, tmp___0);
    }
  }
  {
#line 566
  fputs((char const   */* __restrict  */)"SPY-BEGIN\n", (FILE */* __restrict  */)spy);
#line 567
  tmp___3 = expand_user_string(job, (struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U)),
                               (unsigned char const   *)"Debugging info", (unsigned char const   *)"%V was called with #!$|| |\n\n");
#line 567
  fputs((char const   */* __restrict  */)((char *)tmp___3), (FILE */* __restrict  */)spy);
#line 572
  list_options(a_job, spy);
#line 573
  _IO_putc('\n', spy);
#line 574
  macro_meta_sequences_list_long(a_job, spy);
#line 575
  fputs((char const   */* __restrict  */)"SPY-END\n", (FILE */* __restrict  */)spy);
#line 579
  fclose(spy);
#line 580
  fopen((char const   */* __restrict  */)spyname, (char const   */* __restrict  */)"r");
  }
#line 581
  if (! spy) {
    {
#line 582
    tmp___4 = quotearg((char const   *)spyname);
#line 582
    tmp___5 = gettext("cannot open file `%s\'");
#line 582
    tmp___6 = __errno_location();
#line 582
    error(1, *tmp___6, (char const   *)tmp___5, tmp___4);
    }
  }
  {
#line 584
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 584
    tmp___7 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)spy);
    }
#line 584
    if (! tmp___7) {
#line 584
      goto while_break___0;
    }
    {
#line 586
    fputs((char const   */* __restrict  */)"% ", (FILE */* __restrict  */)stream);
#line 587
    fputs((char const   */* __restrict  */)(buf___0), (FILE */* __restrict  */)stream);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 589
  fputs((char const   */* __restrict  */)"% ", (FILE */* __restrict  */)stream);
#line 590
  _IO_putc('\n', stream);
#line 591
  fclose(spy);
#line 592
  unlink((char const   *)spyname);
  }
#line 593
  return;
}
}
#line 600 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static void list_features(struct a2ps_job *a_job , FILE *stream ) 
{ 


  {
  {
#line 604
  list_style_sheets_short(stream);
#line 605
  _IO_putc('\n', stream);
#line 608
  list_encodings_short(a_job, stream);
#line 609
  _IO_putc('\n', stream);
#line 612
  list_media_short(a_job, stream);
#line 613
  _IO_putc('\n', stream);
#line 616
  prologues_list_short(a_job, stream);
#line 617
  _IO_putc('\n', stream);
#line 620
  a2ps_ppd_list_short(a_job, stream);
#line 621
  _IO_putc('\n', stream);
#line 624
  a2ps_printers_list_short(a_job, stream);
#line 625
  _IO_putc('\n', stream);
#line 628
  delegations_list_short(delegation_table, stream);
#line 629
  _IO_putc('\n', stream);
#line 632
  user_options_list_short(a_job, stream);
#line 633
  _IO_putc('\n', stream);
#line 636
  macro_meta_sequences_list_short(a_job, stream);
  }
#line 637
  return;
}
}
#line 646 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static void usage(int status ) 
{ 
  FILE *stream ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
  {
#line 651
  stream = stdout;
#line 653
  tmp = gettext("Usage: %s [OPTION]... [FILE]...\n\nConvert FILE(s) or standard input to PostScript.  By default, the output\nis sent to the default printer.  An output file may be specified with -o.\n\nMandatory arguments to long options are mandatory for short options too.\nLong options marked with * require a yes/no argument, corresponding\nshort options stand for `yes\'.\n");
#line 653
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp, program_invocation_name);
#line 667
  _IO_putc('\n', stream);
#line 668
  tmp___0 = gettext("Tasks:\n");
#line 668
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 669
  tmp___1 = gettext("  --version        display version\n  --help           display this help\n  --guess          report guessed types of FILES\n  --which          report the full path of library files named FILES\n  --glob           report the full path of library files matching FILES\n  --list=defaults  display default settings and parameters\n  --list=TOPIC     detailed list on TOPIC (delegations, encodings, features,\n                   variables, media, ppd, printers, prologues, style-sheets,\n                   user-options)\n");
#line 669
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stream);
#line 679
  _IO_putc('\n', stream);
#line 680
  tmp___2 = gettext("After having performed the task, exit successfully.  Detailed lists may\nprovide additional help on specific features.\n");
#line 680
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stream);
#line 687
  _IO_putc('\n', stream);
#line 688
  tmp___3 = gettext("Global:\n");
#line 688
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)stream);
#line 689
  tmp___4 = gettext("  -q, --quiet, --silent      be really quiet\n  -v, --verbose[=LEVEL]      set verbosity on, or to LEVEL\n  -=, --user-option=OPTION   use the user defined shortcut OPTION\n      --debug                enable debugging features\n  -D, --define=KEY[:VALUE]   unset variable KEY or set to VALUE\n");
#line 689
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)stream);
#line 696
  _IO_putc('\n', stream);
#line 697
  tmp___5 = gettext("Sheets:\n");
#line 697
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)stream);
#line 698
  tmp___6 = gettext("  -M, --medium=NAME      use output medium NAME\n  -r, --landscape        print in landscape mode\n  -R, --portrait         print in portrait mode\n      --columns=NUM      number of columns per sheet\n      --rows=NUM         number of rows per sheet\n      --major=DIRECTION  first fill (DIRECTION=) rows, or columns\n  -1, -2, ..., -9        predefined font sizes and layouts for 1.. 9 virtuals\n  -A, --file-align=MODE  align separate files according to MODE (fill, rank\n                         page, sheet, or a number)\n  -j, --borders*         print borders around columns\n      --margin[=NUM]     define an interior margin of size NUM\n");
#line 698
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)stream);
#line 710
  _IO_putc('\n', stream);
#line 711
  tmp___7 = gettext("The options -1.. -9 affect several primitive parameters to set up predefined\nlayouts with 80 columns.  Therefore the order matters: `-R -f40 -2\' is\nequivalent to `-2\'.  To modify the layout, use `-2Rf40\', or compose primitive\noptions (`--columns\', `--font-size\' etc.).\n");
#line 711
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)stream);
#line 717
  _IO_putc('\n', stream);
#line 718
  tmp___8 = gettext("Virtual pages:\n");
#line 718
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)stream);
#line 719
  tmp___9 = gettext("      --line-numbers=NUM     precede each NUM lines with its line number\n  -C                         alias for --line-numbers=5\n  -f, --font-size=SIZE       use font SIZE (float) for the body text\n  -L, --lines-per-page=NUM   scale the font to print NUM lines per virtual\n  -l, --chars-per-line=NUM   scale the font to print NUM columns per virtual\n  -m, --catman               process FILE as a man page (same as -L66)\n  -T, --tabsize=NUM          set tabulator size to NUM\n  --non-printable-format=FMT specify how non-printable chars are printed\n");
#line 719
  fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)stream);
#line 729
  _IO_putc('\n', stream);
#line 730
  tmp___10 = gettext("Headings:\n");
#line 730
  fputs((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)stream);
#line 732
  tmp___11 = gettext("  -B, --no-header        no page headers at all\n  -b, --header[=TEXT]    set page header\n  -u, --underlay[=TEXT]  print TEXT under every page\n  --center-title[=TEXT]  set page title to TITLE\n  --left-title[=TEXT]    set left and right page title to TEXT\n  --right-title[=TEXT]\n  --left-footer[=TEXT]   set sheet footers to TEXT\n  --footer[=TEXT]\n  --right-footer[=TEXT]\n");
#line 732
  fputs((char const   */* __restrict  */)tmp___11, (FILE */* __restrict  */)stream);
#line 742
  _IO_putc('\n', stream);
#line 743
  tmp___12 = gettext("The TEXTs may use special escapes.\n");
#line 743
  fputs((char const   */* __restrict  */)tmp___12, (FILE */* __restrict  */)stream);
#line 746
  _IO_putc('\n', stream);
#line 747
  tmp___13 = gettext("Input:\n");
#line 747
  fputs((char const   */* __restrict  */)tmp___13, (FILE */* __restrict  */)stream);
#line 748
  tmp___14 = gettext("  -a, --pages[=RANGE]        select the pages to print\n  -c, --truncate-lines*      cut long lines\n  -i, --interpret*           interpret tab, bs and ff chars\n      --end-of-line=TYPE     specify the eol char (TYPE: r, n, nr, rn, any)\n  -X, --encoding=NAME        use input encoding NAME\n  -t, --title=NAME           set the name of the job\n      --stdin=NAME           set the name of the input file stdin\n      --print-anyway*        force binary printing\n  -Z, --delegate*            delegate files to another application\n      --toc[=TEXT]           generate a table of content\n");
#line 748
  fputs((char const   */* __restrict  */)tmp___14, (FILE */* __restrict  */)stream);
#line 759
  _IO_putc('\n', stream);
#line 760
  tmp___15 = gettext("When delegations are enabled, a2ps may use other applications to handle the\nprocessing of files that should not be printed as raw information, e.g., HTML\nPostScript, PDF etc.\n");
#line 760
  fputs((char const   */* __restrict  */)tmp___15, (FILE */* __restrict  */)stream);
#line 765
  _IO_putc('\n', stream);
#line 766
  tmp___16 = gettext("Pretty-printing:\n");
#line 766
  fputs((char const   */* __restrict  */)tmp___16, (FILE */* __restrict  */)stream);
#line 767
  tmp___17 = gettext("  -E, --pretty-print[=LANG]  enable pretty-printing (set style to LANG)\n  --highlight-level=LEVEL    set pretty printing highlight LEVEL\n                             LEVEL can be none, normal or heavy\n  -g                         alias for --highlight-level=heavy\n  --strip-level=NUM          level of comments stripping\n");
#line 767
  fputs((char const   */* __restrict  */)tmp___17, (FILE */* __restrict  */)stream);
#line 774
  _IO_putc('\n', stream);
#line 775
  tmp___18 = gettext("Output:\n");
#line 775
  fputs((char const   */* __restrict  */)tmp___18, (FILE */* __restrict  */)stream);
#line 776
  tmp___19 = gettext("  -o, --output=FILE          leave output to file FILE.  If FILE is `-\',\n                             leave output to stdout.\n  --version-control=WORD     override the usual version control\n  --suffix=SUFFIX            override the usual backup suffix\n  -P, --printer=NAME         send output to printer NAME\n  -d                         send output to the default printer\n                             (this is the default behavior)\n");
#line 776
  fputs((char const   */* __restrict  */)tmp___19, (FILE */* __restrict  */)stream);
#line 785
  _IO_putc('\n', stream);
#line 786
  tmp___20 = gettext("PostScript:\n");
#line 786
  fputs((char const   */* __restrict  */)tmp___20, (FILE */* __restrict  */)stream);
#line 787
  tmp___21 = gettext("      --prologue=FILE        include FILE.pro as PostScript prologue\n      --ppd[=KEY]            automatic PPD selection or set to KEY\n  -n, --copies=NUM           print NUM copies of each page\n  -s, --sides=MODE           set the duplex MODE (`1\' or `simplex\',\n                             `2\' or `duplex\', `tumble\')\n  -S, --setpagedevice=K[:V]  pass a page device definition to output\n      --statusdict=K[:[:]V]  pass a statusdict definition to the output\n  -k, --page-prefeed         enable page prefeed\n  -K, --no-page-prefeed      disable page prefeed\n");
#line 787
  fputs((char const   */* __restrict  */)tmp___21, (FILE */* __restrict  */)stream);
#line 800
  _IO_putc('\n', stream);
#line 801
  tmp___22 = gettext("By default a2ps is tuned to do what you want to, so trust it.  To pretty\nprint the content of the `src\' directory and a table of content, and send the\nresult to the printer `lw\',\n\n    $ a2ps -P lw --toc src/*\n\nTo process the files `sample.ps\' and `sample.html\' and display the result,\n\n    $ a2ps -P display sample.ps sample.html\n\nTo process a mailbox in 4 up,\n\n    $ a2ps -=mail -4 mailbox\n\nTo print as a booklet on the default printer, which is Duplex capable,\n\n    $ a2ps -=book paper.dvi.gz -d\n");
#line 801
  fputs((char const   */* __restrict  */)tmp___22, (FILE */* __restrict  */)stream);
#line 821
  _IO_putc('\n', stream);
#line 822
  tmp___23 = gettext("News, updates and documentation: visit http://www.gnu.org/software/a2ps/.\n");
#line 822
  fputs((char const   */* __restrict  */)tmp___23, (FILE */* __restrict  */)stream);
#line 824
  tmp___24 = gettext("Report bugs to <bug-a2ps@gnu.org>.\n");
#line 824
  fputs((char const   */* __restrict  */)tmp___24, (FILE */* __restrict  */)stream);
#line 826
  exit(status);
  }
}
}
#line 835 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
static int handle_a2ps_option(int option , char *optional_arg ) 
{ 
  char const   *my_s2 ;
  char *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  unsigned char const   *my_s2___0 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 840
  if (option == 69) {
#line 840
    goto case_69;
  }
#line 844
  if (option == 103) {
#line 844
    goto case_103;
  }
#line 848
  if (option == 154) {
#line 848
    goto case_154;
  }
#line 853
  if (option == 173) {
#line 853
    goto case_173;
  }
#line 858
  if (option == 104) {
#line 858
    goto case_104;
  }
#line 862
  if (option == 86) {
#line 862
    goto case_86;
  }
#line 866
  if (option == 90) {
#line 866
    goto case_90;
  }
#line 870
  if (option == 138) {
#line 870
    goto case_138;
  }
#line 874
  if (option == 137) {
#line 874
    goto case_137;
  }
#line 878
  if (option == 150) {
#line 878
    goto case_150;
  }
#line 882
  if (option == 139) {
#line 882
    goto case_139;
  }
#line 886
  if (option == 145) {
#line 886
    goto case_145;
  }
#line 892
  if (option == 148) {
#line 892
    goto case_148;
  }
#line 898
  if (option == 160) {
#line 898
    goto case_160;
  }
#line 902
  if (option == 161) {
#line 902
    goto case_161;
  }
#line 906
  if (option == 162) {
#line 906
    goto case_162;
  }
#line 910
  if (option == 167) {
#line 910
    goto case_167;
  }
#line 915
  if (option == 169) {
#line 915
    goto case_169;
  }
#line 919
  goto switch_default;
  case_69: /* CIL Label */ 
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;
#line 841
    my_s2 = (char const   *)optional_arg;
    {
#line 841
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 841
      if (style_request) {
        {
#line 841
        free((void *)style_request);
        }
      }
#line 841
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 841
    if ((unsigned long )my_s2 == (unsigned long )((void *)0)) {
#line 841
      style_request = (char *)((void *)0);
    } else
#line 841
    if ((int const   )*my_s2 == 0) {
#line 841
      style_request = (char *)((void *)0);
    } else {
      {
#line 841
      tmp = xstrdup(my_s2);
#line 841
      style_request = tmp;
      }
    }
#line 841
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 842
  goto switch_break;
  case_103: /* CIL Label */ 
#line 845
  highlight_level = 2;
#line 846
  goto switch_break;
  case_154: /* CIL Label */ 
  {
#line 849
  tmp___0 = a2ps_get_bool("--graphic-symbols", (char const   *)optional_arg);
#line 849
  highlight_level = (int )tmp___0;
  }
#line 851
  goto switch_break;
  case_173: /* CIL Label */ 
  {
#line 854
  highlight_level = get_highlight_level("--highlight-level", (char const   *)optional_arg);
  }
#line 856
  goto switch_break;
  case_104: /* CIL Label */ 
#line 859
  behavior = (enum behavior )2;
#line 860
  goto switch_break;
  case_86: /* CIL Label */ 
#line 863
  behavior = (enum behavior )3;
#line 864
  goto switch_break;
  case_90: /* CIL Label */ 
#line 867
  delegate_p = (_Bool)1;
#line 868
  goto switch_break;
  case_138: /* CIL Label */ 
#line 871
  behavior = (enum behavior )1;
#line 872
  goto switch_break;
  case_137: /* CIL Label */ 
#line 875
  behavior = (enum behavior )5;
#line 876
  goto switch_break;
  case_150: /* CIL Label */ 
#line 879
  behavior = (enum behavior )6;
#line 880
  goto switch_break;
  case_139: /* CIL Label */ 
#line 883
  behavior = (enum behavior )7;
#line 884
  goto switch_break;
  case_145: /* CIL Label */ 
#line 887
  if (! (sizeof(behavior_args) / sizeof(behavior_args[0]) == sizeof(behavior_types) / sizeof(behavior_types[0]) + 1UL)) {
    {
#line 887
    __assert_fail("(sizeof (((behavior_args))) / sizeof (*((behavior_args)))) == (sizeof (((behavior_types))) / sizeof (*((behavior_types)))) + 1",
                  "/home/ysko/Works/test-src/a2ps-4.14/src/main.c", 887U, "handle_a2ps_option");
    }
  }
  {
#line 888
  tmp___1 = __xargmatch_internal("--list", (char const   *)optional_arg, behavior_args,
                                 (char const   *)(behavior_types), (size_t )sizeof(behavior_types[0]),
                                 0, argmatch_die);
#line 888
  behavior = (enum behavior )behavior_types[tmp___1];
  }
#line 890
  goto switch_break;
  case_148: /* CIL Label */ 
  {
#line 893
  strip_level = get_integer_in_range("--strip-level", (char const   *)optional_arg,
                                     0, 3, (enum range_type_e )5);
  }
#line 896
  goto switch_break;
  case_160: /* CIL Label */ 
  {
#line 899
  delegate_p = a2ps_get_bool("--delegate", (char const   *)optional_arg);
  }
#line 900
  goto switch_break;
  case_161: /* CIL Label */ 
#line 903
  behavior = (enum behavior )9;
#line 904
  goto switch_break;
  case_162: /* CIL Label */ 
#line 907
  behavior = (enum behavior )10;
#line 908
  goto switch_break;
  case_167: /* CIL Label */ 
  {
#line 912
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 912
    if (optional_arg) {
#line 912
      tmp___2 = (char const   *)optional_arg;
    } else {
#line 912
      tmp___2 = "#{toc}";
    }
#line 912
    my_s2___0 = (unsigned char const   *)((unsigned char *)tmp___2);
    {
#line 912
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 912
      if (toc) {
        {
#line 912
        free((void *)toc);
        }
      }
#line 912
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 912
    if ((unsigned long )((char const   *)my_s2___0) == (unsigned long )((void *)0)) {
#line 912
      toc = (unsigned char *)((void *)0);
    } else
#line 912
    if ((int const   )*my_s2___0 == 0) {
#line 912
      toc = (unsigned char *)((void *)0);
    } else {
      {
#line 912
      tmp___3 = xstrdup((char const   *)my_s2___0);
#line 912
      toc = (unsigned char *)tmp___3;
      }
    }
#line 912
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 913
  goto switch_break;
  case_169: /* CIL Label */ 
  {
#line 916
  end_of_line = option_string_to_eol("--end-of-line", (char const   *)optional_arg);
  }
#line 917
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 920
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 922
  return (1);
}
}
#line 928 "/home/ysko/Works/test-src/a2ps-4.14/src/main.c"
int main(int argc , char **argv ) 
{ 
  int argn ;
  char *tmp ;
  __sighandler_t tmp___0 ;
  __sighandler_t tmp___1 ;
  __sighandler_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned char *tmp___5 ;
  char *cp ;
  int delegated_jobs ;
  int native_jobs ;
  char *tmp___6 ;
  struct file_job *file_job ;
  size_t len ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 940
  program_name = (char const   *)base_name((char const   *)*(argv + 0));
#line 941
  tmp = xstrdup((char const   *)program_name);
#line 941
  program_invocation_name = (char const   *)tmp;
#line 942
  version_etc_copyright = (char *)"Copyright (c) 1988-1993 Miguel Santana\nCopyright (c) 1995-2000 Akim Demaille, Miguel Santana\nCopyright (c) 2007- Akim Demaille, Miguel Santana and Masayuki Hatta";
#line 948
  setlocale(2, "");
#line 952
  setlocale(0, "");
#line 954
  bindtextdomain("a2ps", "/usr/local/share/locale");
#line 955
  textdomain("a2ps");
#line 959
  parse_long_options(argc, argv, (char const   *)((void *)0), "GNU a2ps", "4.14",
                     "Akim Demaille, Miguel Santana", & usage);
#line 969
  atexit(& exit_handler);
#line 970
  signame_init();
  }
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 978
    tmp___0 = signal(2, & signal_handler);
    }
#line 978
    if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))1)) {
      {
#line 978
      signal(2, (void (*)(int  ))1);
      }
    }
#line 978
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 980
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 980
    tmp___1 = signal(1, & signal_handler);
    }
#line 980
    if ((unsigned long )tmp___1 == (unsigned long )((void (*)(int  ))1)) {
      {
#line 980
      signal(1, (void (*)(int  ))1);
      }
    }
#line 980
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 982
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 982
    tmp___2 = signal(15, & signal_handler);
    }
#line 982
    if ((unsigned long )tmp___2 == (unsigned long )((void (*)(int  ))1)) {
      {
#line 982
      signal(15, (void (*)(int  ))1);
      }
    }
#line 982
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 984
  signal(13, & signal_handler);
#line 988
  delegation_hook = & add_delegation;
#line 991
  handle_option_hook = & handle_a2ps_option;
#line 994
  delegation_table = delegation_table_new();
#line 997
  re_set_syntax((((((((1UL << 1) << 1) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 1000
  job = a2ps_job_new();
#line 1003
  a2_read_sys_config(job);
#line 1007
  tmp___4 = getenv("NO_HOME_CONF");
  }
#line 1007
  if (! tmp___4) {
    {
#line 1009
    tmp___3 = macro_meta_sequence_get(job, "user.home");
#line 1009
    a2_read_config(job, (char const   *)tmp___3, ".a2ps/a2psrc");
    }
  }
  {
#line 1014
  a2_read_config(job, ".", ".a2psrc");
#line 1018
  sheets_map = sheets_map_new();
#line 1019
  style_sheets = new_style_sheets();
#line 1022
  argn = a2ps_handle_options(job, argc, argv);
#line 1025
  a2ps_job_finalize(job);
  }
#line 1029
  if (job->debug) {
#line 1030
    ps_comment_hook = & spy_user;
  }
#line 1033
  job->argv = argv;
#line 1034
  job->argc = (size_t )argc;
  {
#line 1038
  if ((unsigned int )behavior == 1U) {
#line 1038
    goto case_1;
  }
#line 1051
  if ((unsigned int )behavior == 4U) {
#line 1051
    goto case_4;
  }
#line 1062
  if ((unsigned int )behavior == 5U) {
#line 1062
    goto case_5;
  }
#line 1077
  if ((unsigned int )behavior == 6U) {
#line 1077
    goto case_6;
  }
#line 1084
  if ((unsigned int )behavior == 3U) {
#line 1084
    goto case_3;
  }
#line 1089
  if ((unsigned int )behavior == 2U) {
#line 1089
    goto case_2;
  }
#line 1093
  if ((unsigned int )behavior == 7U) {
#line 1093
    goto case_7;
  }
#line 1097
  if ((unsigned int )behavior == 8U) {
#line 1097
    goto case_8;
  }
#line 1101
  if ((unsigned int )behavior == 9U) {
#line 1101
    goto case_9;
  }
#line 1105
  if ((unsigned int )behavior == 10U) {
#line 1105
    goto case_10;
  }
#line 1109
  if ((unsigned int )behavior == 11U) {
#line 1109
    goto case_11;
  }
#line 1114
  if ((unsigned int )behavior == 12U) {
#line 1114
    goto case_12;
  }
#line 1119
  if ((unsigned int )behavior == 13U) {
#line 1119
    goto case_13;
  }
#line 1123
  if ((unsigned int )behavior == 14U) {
#line 1123
    goto case_14;
  }
#line 1127
  if ((unsigned int )behavior == 15U) {
#line 1127
    goto case_15;
  }
#line 1131
  if ((unsigned int )behavior == 16U) {
#line 1131
    goto case_16;
  }
#line 1135
  if ((unsigned int )behavior == 17U) {
#line 1135
    goto case_17;
  }
#line 1139
  if ((unsigned int )behavior == 18U) {
#line 1139
    goto case_18;
  }
#line 1143
  if ((unsigned int )behavior == 19U) {
#line 1143
    goto case_19;
  }
#line 1147
  if ((unsigned int )behavior == 20U) {
#line 1147
    goto case_20;
  }
#line 1151
  if ((unsigned int )behavior == 21U) {
#line 1151
    goto case_21;
  }
#line 1159
  if ((unsigned int )behavior == 0U) {
#line 1159
    goto case_0;
  }
#line 1220
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1040
  if (argn < argc) {
    {
#line 1041
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1041
      if (! (argn < argc)) {
#line 1041
        goto while_break___2;
      }
      {
#line 1042
      guess((unsigned char *)*(argv + argn));
#line 1041
      argn ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 1045
    guess((unsigned char *)((void *)0));
    }
  }
#line 1046
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1053
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1053
    if (! (argn < argc)) {
#line 1053
      goto while_break___3;
    }
    {
#line 1055
    tmp___5 = expand_user_string(job, (struct file_job *)*((job->jobs)->content + 0),
                                 (unsigned char const   *)"--list=expand", (unsigned char const   *)((unsigned char *)*(argv + argn)));
#line 1055
    fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)stdout);
#line 1058
    _IO_putc('\n', stdout);
#line 1053
    argn ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1060
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1065
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1065
    if (! (argn < argc)) {
#line 1065
      goto while_break___4;
    }
    {
#line 1068
    cp = pw_find_file((char * const  *)job->common.path, (char const   *)((unsigned char *)*(argv + argn)),
                      (char const   *)((void *)0));
    }
#line 1069
    if (cp) {
      {
#line 1071
      fputs((char const   */* __restrict  */)cp, (FILE */* __restrict  */)stdout);
#line 1072
      _IO_putc('\n', stdout);
      }
    }
#line 1065
    argn ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1075
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1080
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1080
    if (! (argn < argc)) {
#line 1080
      goto while_break___5;
    }
    {
#line 1081
    pw_glob_print((char * const  *)job->common.path, (char const   *)((unsigned char *)*(argv + argn)),
                  stdout);
#line 1080
    argn ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1082
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1085
  version_etc(stdout, (char const   *)((void *)0), "GNU a2ps", "4.14", "Akim Demaille, Miguel Santana");
  }
#line 1087
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1090
  usage(0);
  }
#line 1091
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1094
  list_options(job, stdout);
  }
#line 1095
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1098
  list_features(job, stdout);
  }
#line 1099
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1102
  list_media_long(job, stdout);
  }
#line 1103
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 1106
  list_style_sheets_long(stdout);
  }
#line 1107
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 1111
  list_style_sheets_html(stdout);
  }
#line 1112
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1116
  list_style_sheets_texinfo(stdout);
  }
#line 1117
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1120
  a2ps_printers_list_long(job, stdout);
  }
#line 1121
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 1124
  delegations_list_long(delegation_table, stdout);
  }
#line 1125
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 1128
  macro_meta_sequences_list_long(job, stdout);
  }
#line 1129
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 1132
  list_encodings_long(job, stdout);
  }
#line 1133
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 1136
  list_texinfo_encodings_long(job, stdout);
  }
#line 1137
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 1140
  user_options_list_long(job, stdout);
  }
#line 1141
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 1144
  prologues_list_long(job, stdout);
  }
#line 1145
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 1148
  prologues_list_texinfo(job, stdout);
  }
#line 1149
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 1153
  a2ps_ppd_list_long(job, stdout);
  }
#line 1154
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1162
  delegated_jobs = 0;
#line 1162
  native_jobs = 0;
#line 1164
  a2ps_open_output_session(job);
  }
#line 1166
  if (argn == argc) {
    {
#line 1167
    print((unsigned char *)((void *)0), & native_jobs, & delegated_jobs);
    }
  } else {
    {
#line 1169
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1169
      if (! (argn < argc)) {
#line 1169
        goto while_break___6;
      }
      {
#line 1170
      print((unsigned char *)*(argv + argn), & native_jobs, & delegated_jobs);
#line 1169
      argn ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1172
  if (! ((unsigned long )((char const   *)toc) == (unsigned long )((void *)0))) {
#line 1172
    if (! ((int )*toc == 0)) {
      {
#line 1173
      tmp___6 = gettext("Table of Content");
#line 1173
      print_toc((unsigned char const   *)((unsigned char *)tmp___6), (unsigned char const   *)toc,
                & native_jobs);
      }
    }
  }
#line 1175
  if (native_jobs == 0) {
#line 1175
    if (delegated_jobs == 1) {
#line 1190
      file_job = (struct file_job *)*((job->jobs)->content + ((job->jobs)->len - 1U));
#line 1191
      len = (job->jobs)->len;
      {
#line 1192
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1192
        if (! (! file_job->delegation_tmpname)) {
#line 1192
          goto while_break___7;
        }
#line 1194
        len --;
#line 1195
        file_job = (struct file_job *)*((job->jobs)->content + (len - 1U));
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1198
      a2ps_open_output_stream(job);
#line 1199
      pslex_dump((job->output_stream)->fp, (char const   *)file_job->delegation_tmpname);
#line 1200
      unlink((char const   *)file_job->delegation_tmpname);
#line 1201
      a2ps_close_output_stream(job);
#line 1202
      msg_job_pages_printed(job);
      }
    } else {
#line 1175
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1204
  if (native_jobs) {
    {
#line 1207
    a2ps_close_output_session(job);
#line 1208
    msg_job_pages_printed(job);
    }
  } else
#line 1204
  if (delegated_jobs) {
    {
#line 1207
    a2ps_close_output_session(job);
#line 1208
    msg_job_pages_printed(job);
    }
  } else {
    {
#line 1215
    msg_nothing_printed();
    }
  }
#line 1218
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1222
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1225
  a2ps_job_free(job);
#line 1226
  job = (struct a2ps_job *)((void *)0);
  }
#line 1228
  return (0);
}
}

/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

unsigned short *szptr  ;
#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 55 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
struct spec_fd_t {
   int limit ;
   int len ;
   int pos ;
   unsigned char *buf ;
};
#line 2010 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
struct __anonstruct_StackElem_39 {
   int ll ;
   int hh ;
   int dd ;
};
#line 2010 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
typedef struct __anonstruct_StackElem_39 StackElem;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 144 "/usr/include/stdlib.h"
extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 556
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 612
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void)  __attribute__((__const__)) ;
#line 72 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...) ;
#line 38 "/usr/include/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 58
extern void *memset(void *__s , int __c , size_t __n ) ;
#line 243
extern char *strerror(int __errnum ) ;
#line 18 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
unsigned char uncompressStream(int zStream , int stream ) ;
#line 19
void compressStream(int stream , int zStream ) ;
#line 20
void allocateCompressStructures(void) ;
#line 22
void spec_initbufs(void) ;
#line 23
void spec_compress(int in , int out , int lev ) ;
#line 24
void spec_uncompress(int in , int out , int lev ) ;
#line 25
int spec_init(void) ;
#line 26
int spec_random_load(int fd ) ;
#line 27
int spec_load(int num , char *filename , int size ) ;
#line 28
int spec_read(int fd , unsigned char *buf , int size ) ;
#line 29
int spec_getc(int fd ) ;
#line 30
int spec_ungetc(unsigned char ch , int fd ) ;
#line 31
int spec_rewind(int fd ) ;
#line 32
int spec_reset(int fd ) ;
#line 33
int spec_write(int fd , unsigned char *buf , int size ) ;
#line 34
int spec_putc(unsigned char ch , int fd ) ;
#line 35
int debug_time(void) ;
#line 40 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int dbglvl  =    4;
#line 55 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
struct spec_fd_t spec_fd[3]  ;
#line 62 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
long seedi  ;
#line 63 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
double ran(void) 
{ 
  long lo ;
  long hi ;
  long test ;

  {
#line 78
  hi = seedi / 127773L;
#line 79
  lo = seedi % 127773L;
#line 80
  test = 16807L * lo - 2836L * hi;
#line 81
  if (test > 0L) {
#line 82
    seedi = test;
  } else {
#line 84
    seedi = test + 2147483647L;
  }
#line 86
  return ((double )((float )seedi / (float )2147483647L));
}
}
#line 90 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int spec_init(void) 
{ 
  int i ;
  int j ;
  int limit___0 ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 92
  if (3 < dbglvl) {
    {
    {
#line 92
    printf((char const   */* __restrict  */)"spec_init\n");
    }
    }
  }
#line 97
  i = 0;
  {
  {
#line 97
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < 3)) {
#line 97
      goto while_break;
    }
    {
#line 98
    limit___0 = spec_fd[i].limit;
    {
#line 99
    memset((void *)(& spec_fd[i]), 0, (size_t )sizeof(spec_fd[0]));
    }
#line 100
    spec_fd[i].limit = limit___0;
    {
#line 101
    tmp = malloc((size_t )(limit___0 + 102400));
    }
#line 101
    spec_fd[i].buf = (unsigned char *)tmp;
    }
#line 102
    if ((unsigned long )spec_fd[i].buf == (unsigned long )((void *)0)) {
      {
      {
#line 103
      printf((char const   */* __restrict  */)"spec_init: Error mallocing memory!\n");
      }
      {
#line 104
      exit(1);
      }
      }
    }
#line 106
    j = 0;
    {
    {
#line 106
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! (j < limit___0)) {
#line 106
        goto while_break___0;
      }
#line 107
      *(spec_fd[i].buf + j) = (unsigned char)0;
#line 106
      j += 1024;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 97
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (0);
}
}
#line 113 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int spec_random_load(int fd ) 
{ 
  int i ;
  int j ;
  char random_text[32][131072] ;
  double tmp ;
  double tmp___0 ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 123
  if (4 < dbglvl) {
    {
    {
#line 123
    printf((char const   */* __restrict  */)"Creating Chunks\n");
    }
    }
  }
#line 124
  i = 0;
  {
  {
#line 124
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < 32)) {
#line 124
      goto while_break;
    }
#line 125
    if (5 < dbglvl) {
      {
      {
#line 125
      printf((char const   */* __restrict  */)"Creating Chunk %d\n", i);
      }
      }
    }
#line 126
    j = 0;
    {
    {
#line 126
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 126
      if (! (j < 131072)) {
#line 126
        goto while_break___0;
      }
      {
      {
#line 127
      tmp = ran();
      }
#line 127
      random_text[i][j] = (char )((int )(tmp * (double )256));
#line 126
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 124
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (4 < dbglvl) {
    {
    {
#line 131
    printf((char const   */* __restrict  */)"Filling input file\n");
    }
    }
  }
#line 133
  i = 0;
  {
  {
#line 133
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 133
    if (! (i < spec_fd[fd].limit)) {
#line 133
      goto while_break___1;
    }
    {
    {
#line 134
    tmp___0 = ran();
    }
    {
#line 134
    memcpy((void */* __restrict  */)(spec_fd[fd].buf + i), (void const   */* __restrict  */)(random_text[(int )(tmp___0 * (double )32)]),
           (size_t )131072);
    }
#line 133
    i += 131072;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 138
  spec_fd[fd].len = 1048576;
#line 139
  return (0);
}
}
#line 155
extern int ( /* missing proto */  read)() ;
#line 163
extern int ( /* missing proto */  close)() ;
#line 142 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int spec_load(int num , char *filename , int size ) 
{ 
  int fd ;
  int rc ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 148
  fd = open((char const   *)filename, 0);
  }
  }
#line 149
  if (fd < 0) {
    {
    {
#line 150
    tmp = __errno_location();
    }
    {
#line 150
    tmp___0 = strerror(*tmp);
    }
    {
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open file %s: %s\n",
            filename, tmp___0);
    }
    {
#line 151
    exit(1);
    }
    }
  }
#line 153
  tmp___1 = 0;
#line 153
  spec_fd[num].len = tmp___1;
#line 153
  spec_fd[num].pos = tmp___1;
#line 154
  i = 0;
  {
  {
#line 154
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < size)) {
#line 154
      goto while_break;
    }
    {
    {
#line 155
    rc = read(fd, spec_fd[num].buf + i, 131072);
    }
    }
#line 156
    if (rc == 0) {
#line 156
      goto while_break;
    }
#line 157
    if (rc < 0) {
      {
      {
#line 158
      tmp___2 = __errno_location();
      }
      {
#line 158
      tmp___3 = strerror(*tmp___2);
      }
      {
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading from %s: %s\n",
              filename, tmp___3);
      }
      {
#line 159
      exit(1);
      }
      }
    }
#line 161
    spec_fd[num].len += rc;
#line 154
    i += rc;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 163
  close(fd);
  }
  }
  {
  {
#line 164
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 164
    if (! (spec_fd[num].len < size)) {
#line 164
      goto while_break___0;
    }
#line 165
    tmp___4 = size - spec_fd[num].len;
#line 166
    if (tmp___4 > spec_fd[num].len) {
#line 166
      tmp___4 = spec_fd[num].len;
    }
#line 167
    if (3 < dbglvl) {
      {
      {
#line 167
      printf((char const   */* __restrict  */)"Duplicating %d bytes\n", tmp___4);
      }
      }
    }
    {
    {
#line 168
    memcpy((void */* __restrict  */)(spec_fd[num].buf + spec_fd[num].len), (void const   */* __restrict  */)spec_fd[num].buf,
           (size_t )tmp___4);
    }
#line 169
    spec_fd[num].len += tmp___4;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 171
  return (0);
}
}
#line 174 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int spec_read(int fd , unsigned char *buf , int size ) 
{ 
  int rc ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 175
  rc = 0;
#line 176
  if (4 < dbglvl) {
    {
    {
#line 176
    printf((char const   */* __restrict  */)"spec_read: %d, %p, %d = ", fd, (void *)buf,
           size);
    }
    }
  }
#line 177
  if (fd > 3) {
    {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spec_read: fd=%d, > MAX_SPEC_FD!\n",
            fd);
    }
    {
#line 179
    exit(1);
    }
    }
  }
#line 181
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 182
    if (4 < dbglvl) {
      {
      {
#line 182
      printf((char const   */* __restrict  */)"EOF\n");
      }
      }
    }
#line 183
    return (-1);
  }
#line 185
  if (spec_fd[fd].pos + size >= spec_fd[fd].len) {
#line 186
    rc = spec_fd[fd].len - spec_fd[fd].pos;
  } else {
#line 188
    rc = size;
  }
  {
  {
#line 190
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(spec_fd[fd].buf + spec_fd[fd].pos),
         (size_t )rc);
  }
#line 191
  spec_fd[fd].pos += rc;
  }
#line 192
  if (4 < dbglvl) {
    {
    {
#line 192
    printf((char const   */* __restrict  */)"%d\n", rc);
    }
    }
  }
#line 193
  return (rc);
}
}
#line 195 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int spec_getc(int fd ) 
{ 
  int rc ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 196
  rc = 0;
#line 197
  if (4 < dbglvl) {
    {
    {
#line 197
    printf((char const   */* __restrict  */)"spec_getc: %d = ", fd);
    }
    }
  }
#line 198
  if (fd > 3) {
    {
    {
#line 199
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spec_read: fd=%d, > MAX_SPEC_FD!\n",
            fd);
    }
    {
#line 200
    exit(1);
    }
    }
  }
#line 202
  if (spec_fd[fd].pos >= spec_fd[fd].len) {
#line 203
    if (4 < dbglvl) {
      {
      {
#line 203
      printf((char const   */* __restrict  */)"EOF\n");
      }
      }
    }
#line 204
    return (-1);
  }
#line 206
  tmp = spec_fd[fd].pos;
#line 206
  (spec_fd[fd].pos) ++;
#line 206
  rc = (int )*(spec_fd[fd].buf + tmp);
#line 207
  if (4 < dbglvl) {
    {
    {
#line 207
    printf((char const   */* __restrict  */)"%d\n", rc);
    }
    }
  }
#line 208
  return (rc);
}
}
#line 210 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int spec_ungetc(unsigned char ch , int fd ) 
{ 
  int rc ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 211
  rc = 0;
#line 212
  if (4 < dbglvl) {
    {
    {
#line 212
    printf((char const   */* __restrict  */)"spec_ungetc: %d = ", fd);
    }
    }
  }
#line 213
  if (fd > 3) {
    {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spec_read: fd=%d, > MAX_SPEC_FD!\n",
            fd);
    }
    {
#line 215
    exit(1);
    }
    }
  }
#line 217
  if (spec_fd[fd].pos <= 0) {
    {
    {
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spec_ungetc: pos %d <= 0\n",
            spec_fd[fd].pos);
    }
    {
#line 219
    exit(1);
    }
    }
  }
#line 221
  (spec_fd[fd].pos) --;
#line 221
  if ((int )*(spec_fd[fd].buf + spec_fd[fd].pos) != (int )ch) {
    {
    {
#line 222
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spec_ungetc: can\'t unget something that wasn\'t what was in the buffer!\n");
    }
    {
#line 223
    exit(1);
    }
    }
  }
#line 225
  if (4 < dbglvl) {
    {
    {
#line 225
    printf((char const   */* __restrict  */)"%d\n", rc);
    }
    }
  }
#line 226
  return ((int )ch);
}
}
#line 228 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int spec_rewind(int fd ) 
{ 


  {
#line 229
  spec_fd[fd].pos = 0;
#line 230
  return (0);
}
}
#line 232 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int spec_reset(int fd ) 
{ 
  int tmp ;

  {
  {
  {
#line 233
  memset((void *)spec_fd[fd].buf, 0, (size_t )spec_fd[fd].len);
  }
#line 234
  tmp = 0;
#line 234
  spec_fd[fd].len = tmp;
#line 234
  spec_fd[fd].pos = tmp;
  }
#line 235
  return (0);
}
}
#line 238 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int spec_write(int fd , unsigned char *buf , int size ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 239
  if (4 < dbglvl) {
    {
    {
#line 239
    printf((char const   */* __restrict  */)"spec_write: %d, %p, %d = ", fd, (void *)buf,
           size);
    }
    }
  }
#line 240
  if (fd > 3) {
    {
    {
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spec_write: fd=%d, > MAX_SPEC_FD!\n",
            fd);
    }
    {
#line 242
    exit(1);
    }
    }
  }
  {
  {
#line 244
  memcpy((void */* __restrict  */)(spec_fd[fd].buf + spec_fd[fd].pos), (void const   */* __restrict  */)buf,
         (size_t )size);
  }
#line 245
  spec_fd[fd].len += size;
#line 246
  spec_fd[fd].pos += size;
  }
#line 247
  if (4 < dbglvl) {
    {
    {
#line 247
    printf((char const   */* __restrict  */)"%d\n", size);
    }
    }
  }
#line 248
  return (size);
}
}
#line 250 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int spec_putc(unsigned char ch , int fd ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 251
  if (4 < dbglvl) {
    {
    {
#line 251
    printf((char const   */* __restrict  */)"spec_putc: %d, %d = ", (int )ch, fd);
    }
    }
  }
#line 252
  if (fd > 3) {
    {
    {
#line 253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"spec_write: fd=%d, > MAX_SPEC_FD!\n",
            fd);
    }
    {
#line 254
    exit(1);
    }
    }
  }
#line 256
  tmp = spec_fd[fd].pos;
#line 256
  (spec_fd[fd].pos) ++;
#line 256
  *(spec_fd[fd].buf + tmp) = ch;
#line 257
  (spec_fd[fd].len) ++;
#line 258
  return ((int )ch);
}
}
#line 263 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int level ;
  int input_size ;
  int compressed_size ;
  char *input_name ;
  unsigned char *validate_array ;
  void *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 265
  input_size = 64;
#line 266
  input_name = (char *)"input.combined";
#line 268
  seedi = 10L;
#line 270
  if (argc > 1) {
#line 270
    input_name = *(argv + 1);
  }
#line 271
  if (argc > 2) {
    {
    {
#line 271
    input_size = atoi((char const   *)*(argv + 2));
    }
    }
  }
#line 272
  if (argc > 3) {
    {
    {
#line 273
    compressed_size = atoi((char const   *)*(argv + 3));
    }
    }
  } else {
#line 275
    compressed_size = input_size;
  }
  {
#line 277
  spec_fd[0].limit = input_size * 1048576;
#line 278
  spec_fd[1].limit = compressed_size * 1048576;
#line 279
  spec_fd[2].limit = input_size * 1048576;
  {
#line 280
  spec_init();
  }
  {
#line 282
  debug_time();
  }
  }
#line 283
  if (2 < dbglvl) {
    {
    {
#line 283
    printf((char const   */* __restrict  */)"Loading Input Data\n");
    }
    }
  }
  {
  {
#line 284
  spec_load(0, input_name, input_size * 1048576);
  }
  }
#line 285
  if (3 < dbglvl) {
    {
    {
#line 285
    printf((char const   */* __restrict  */)"Input data %d bytes in length\n", spec_fd[0].len);
    }
    }
  }
  {
  {
#line 287
  tmp = malloc((size_t )((input_size * 1048576) / 1024));
  }
#line 287
  validate_array = (unsigned char *)tmp;
  }
#line 288
  if ((unsigned long )validate_array == (unsigned long )((void *)0)) {
    {
    {
#line 289
    printf((char const   */* __restrict  */)"main: Error mallocing memory!\n");
    }
    {
#line 290
    exit(1);
    }
    }
  }
#line 293
  i = 0;
  {
  {
#line 293
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 293
    if (! (i * 1027 < input_size * 1048576)) {
#line 293
      goto while_break;
    }
#line 294
    *(validate_array + i) = *(spec_fd[0].buf + i * 1027);
#line 293
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 304
  spec_initbufs();
  }
#line 306
  level = 7;
  }
  {
  {
#line 306
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 306
    if (! (level <= 9)) {
#line 306
      goto while_break___0;
    }
    {
    {
#line 307
    debug_time();
    }
    }
#line 308
    if (2 < dbglvl) {
      {
      {
#line 308
      printf((char const   */* __restrict  */)"Compressing Input Data, level %d\n",
             level);
      }
      }
    }
    {
    {
#line 310
    spec_compress(0, 1, level);
    }
    {
#line 312
    debug_time();
    }
    }
#line 313
    if (3 < dbglvl) {
      {
      {
#line 313
      printf((char const   */* __restrict  */)"Compressed data %d bytes in length\n",
             spec_fd[1].len);
      }
      }
    }
    {
    {
#line 325
    spec_reset(0);
    }
    {
#line 326
    spec_rewind(1);
    }
    {
#line 328
    debug_time();
    }
    }
#line 329
    if (2 < dbglvl) {
      {
      {
#line 329
      printf((char const   */* __restrict  */)"Uncompressing Data\n");
      }
      }
    }
    {
    {
#line 330
    spec_uncompress(1, 0, level);
    }
    {
#line 331
    debug_time();
    }
    }
#line 332
    if (3 < dbglvl) {
      {
      {
#line 332
      printf((char const   */* __restrict  */)"Uncompressed data %d bytes in length\n",
             spec_fd[0].len);
      }
      }
    }
#line 344
    i = 0;
    {
    {
#line 344
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 344
      if (! (i * 1027 < input_size * 1048576)) {
#line 344
        goto while_break___1;
      }
#line 345
      if ((int )*(validate_array + i) != (int )*(spec_fd[0].buf + i * 1027)) {
        {
        {
#line 346
        printf((char const   */* __restrict  */)"Tested %dMB buffer: Miscompared!!\n",
               input_size);
        }
        {
#line 347
        exit(1);
        }
        }
      }
#line 344
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 350
    debug_time();
    }
    }
#line 351
    if (3 < dbglvl) {
      {
      {
#line 351
      printf((char const   */* __restrict  */)"Uncompressed data compared correctly\n");
      }
      }
    }
    {
    {
#line 352
    spec_reset(1);
    }
    {
#line 353
    spec_rewind(0);
    }
#line 306
    level += 2;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 355
  printf((char const   */* __restrict  */)"Tested %dMB buffer: OK!\n", input_size);
  }
  }
#line 357
  return (0);
}
}
#line 361
unsigned char smallMode ;
#line 362
int verbosity ;
#line 363
int bsStream ;
#line 364
int workFactor ;
#line 364
int blockSize100k ;
#line 365 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
void spec_initbufs(void) 
{ 


  {
  {
#line 366
  smallMode = (unsigned char)0;
#line 367
  verbosity = 0;
#line 368
  blockSize100k = 9;
#line 369
  bsStream = 0;
#line 370
  workFactor = 30;
  {
#line 371
  allocateCompressStructures();
  }
  }
#line 372
  return;
}
}
#line 373 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
void spec_compress(int in , int out , int lev ) 
{ 


  {
  {
#line 374
  blockSize100k = lev;
  {
#line 375
  compressStream(in, out);
  }
  }
#line 376
  return;
}
}
#line 377 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
void spec_uncompress(int in , int out , int lev ) 
{ 


  {
  {
#line 378
  blockSize100k = 0;
  {
#line 379
  uncompressStream(in, out);
  }
  }
#line 380
  return;
}
}
#line 385 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/spec.c"
int debug_time(void) 
{ 


  {
#line 393
  return (0);
}
}
#line 152 "/usr/include/stdio.h"
extern int remove(char const   *__filename ) ;
#line 740
extern void perror(char const   *__s ) ;
#line 569 "/usr/include/stdlib.h"
extern void free(void *__ptr ) ;
#line 442 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned int bytesIn  ;
#line 442 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned int bytesOut  ;
#line 444 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int verbosity  ;
#line 448 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char keepInputFiles  ;
#line 448 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char smallMode  ;
#line 448 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char testFailsExist  ;
#line 449 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned int globalCrc  ;
#line 450 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int numFileNames  =    0;
#line 450 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int numFilesProcessed  =    0;
#line 463 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int opMode  ;
#line 464 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int srcMode  ;
#line 467 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int longestFileName  ;
#line 468 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
char inName[1024]  ;
#line 469 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
char outName[1024]  ;
#line 470 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
char *progName  ;
#line 471 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
char progNameReally[1024]  ;
#line 473 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int outputHandleJustInCase  ;
#line 478
void panic(char *s ) ;
#line 479
void ioError(void) ;
#line 480
void compressOutOfMemory(int draw , int blockSize ) ;
#line 481
void uncompressOutOfMemory(int draw , int blockSize ) ;
#line 482
void blockOverrun(void) ;
#line 483
void badBlockHeader(void) ;
#line 484
void badBGLengths(void) ;
#line 485
void crcError(unsigned int crcStored , unsigned int crcComputed ) ;
#line 486
void bitStreamEOF(void) ;
#line 487
void cleanUpAndFail(int ec ) ;
#line 488
void compressedStreamEOF(void) ;
#line 525 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char *block  ;
#line 526 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned short *quadrant  ;
#line 527 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int *zptr  ;
#line 528 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"

#line 529 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int *ftab  ;
#line 531 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned short *ll16  ;
#line 532 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char *ll4  ;
#line 534 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int *tt  ;
#line 535 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char *ll8  ;
#line 542 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int unzftab[256]  ;
#line 549 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int last  ;
#line 555 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int origPtr  ;
#line 565 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int blockSize100k  ;
#line 578 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int workFactor  ;
#line 580 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int workDone  ;
#line 581 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int workLimit  ;
#line 582 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char blockRandomised  ;
#line 583 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char firstAttempt  ;
#line 584 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int nBlocksRandomised  ;
#line 604 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char inUse[256]  ;
#line 605 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int nInUse  ;
#line 607 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char seqToUnseq[256]  ;
#line 608 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char unseqToSeq[256]  ;
#line 610 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char selector[18002]  ;
#line 611 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char selectorMtf[18002]  ;
#line 613 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int nMTF  ;
#line 615 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int mtfFreq[258]  ;
#line 617 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char len[6][258]  ;
#line 620 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int limit[6][258]  ;
#line 621 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int base[6][258]  ;
#line 622 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int perm[6][258]  ;
#line 623 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int minLens[6]  ;
#line 626 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int code[6][258]  ;
#line 627 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int rfreq[6][258]  ;
#line 641 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned int crc32Table[256]  = 
#line 641
  {      0U,      79764919U,      159529838U,      222504665U, 
        319059676U,      398814059U,      445009330U,      507990021U, 
        638119352U,      583659535U,      797628118U,      726387553U, 
        890018660U,      835552979U,      1015980042U,      944750013U, 
        1276238704U,      1221641927U,      1167319070U,      1095957929U, 
        1595256236U,      1540665371U,      1452775106U,      1381403509U, 
        1780037320U,      1859660671U,      1671105958U,      1733955601U, 
        2031960084U,      2111593891U,      1889500026U,      1952343757U, 
        2552477408U,      2632100695U,      2443283854U,      2506133561U, 
        2334638140U,      2414271883U,      2191915858U,      2254759653U, 
        3190512472U,      3135915759U,      3081330742U,      3009969537U, 
        2905550212U,      2850959411U,      2762807018U,      2691435357U, 
        3560074640U,      3505614887U,      3719321342U,      3648080713U, 
        3342211916U,      3287746299U,      3467911202U,      3396681109U, 
        4063920168U,      4143685023U,      4223187782U,      4286162673U, 
        3779000052U,      3858754371U,      3904687514U,      3967668269U, 
        881225847U,      809987520U,      1023691545U,      969234094U, 
        662832811U,      591600412U,      771767749U,      717299826U, 
        311336399U,      374308984U,      453813921U,      533576470U, 
        25881363U,      88864420U,      134795389U,      214552010U, 
        2023205639U,      2086057648U,      1897238633U,      1976864222U, 
        1804852699U,      1867694188U,      1645340341U,      1724971778U, 
        1587496639U,      1516133128U,      1461550545U,      1406951526U, 
        1302016099U,      1230646740U,      1142491917U,      1087903418U, 
        2896545431U,      2825181984U,      2770861561U,      2716262478U, 
        3215044683U,      3143675388U,      3055782693U,      3001194130U, 
        2326604591U,      2389456536U,      2200899649U,      2280525302U, 
        2578013683U,      2640855108U,      2418763421U,      2498394922U, 
        3769900519U,      3832873040U,      3912640137U,      3992402750U, 
        4088425275U,      4151408268U,      4197601365U,      4277358050U, 
        3334271071U,      3263032808U,      3476998961U,      3422541446U, 
        3585640067U,      3514407732U,      3694837229U,      3640369242U, 
        1762451694U,      1842216281U,      1619975040U,      1682949687U, 
        2047383090U,      2127137669U,      1938468188U,      2001449195U, 
        1325665622U,      1271206113U,      1183200824U,      1111960463U, 
        1543535498U,      1489069629U,      1434599652U,      1363369299U, 
        622672798U,      568075817U,      748617968U,      677256519U, 
        907627842U,      853037301U,      1067152940U,      995781531U, 
        51762726U,      131386257U,      177728840U,      240578815U, 
        269590778U,      349224269U,      429104020U,      491947555U, 
        4046411278U,      4126034873U,      4172115296U,      4234965207U, 
        3794477266U,      3874110821U,      3953728444U,      4016571915U, 
        3609705398U,      3555108353U,      3735388376U,      3664026991U, 
        3290680682U,      3236090077U,      3449943556U,      3378572211U, 
        3174993278U,      3120533705U,      3032266256U,      2961025959U, 
        2923101090U,      2868635157U,      2813903052U,      2742672763U, 
        2604032198U,      2683796849U,      2461293480U,      2524268063U, 
        2284983834U,      2364738477U,      2175806836U,      2238787779U, 
        1569362073U,      1498123566U,      1409854455U,      1355396672U, 
        1317987909U,      1246755826U,      1192025387U,      1137557660U, 
        2072149281U,      2135122070U,      1912620623U,      1992383480U, 
        1753615357U,      1816598090U,      1627664531U,      1707420964U, 
        295390185U,      358241886U,      404320391U,      483945776U, 
        43990325U,      106832002U,      186451547U,      266083308U, 
        932423249U,      861060070U,      1041341759U,      986742920U, 
        613929101U,      542559546U,      756411363U,      701822548U, 
        3316196985U,      3244833742U,      3425377559U,      3370778784U, 
        3601682597U,      3530312978U,      3744426955U,      3689838204U, 
        3819031489U,      3881883254U,      3928223919U,      4007849240U, 
        4037393693U,      4100235434U,      4180117107U,      4259748804U, 
        2310601993U,      2373574846U,      2151335527U,      2231098320U, 
        2596047829U,      2659030626U,      2470359227U,      2550115596U, 
        2947551409U,      2876312838U,      2788305887U,      2733848168U, 
        3165939309U,      3094707162U,      3040238851U,      2985771188U};
#line 713 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void initialiseCRC(void) 
{ 


  {
#line 715
  globalCrc = 4294967295U;
#line 716
  return;
}
}
#line 720 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned int getFinalCRC(void) 
{ 


  {
#line 722
  return (~ globalCrc);
}
}
#line 727 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned int getGlobalCRC(void) 
{ 


  {
#line 729
  return (globalCrc);
}
}
#line 734 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void setGlobalCRC(unsigned int newCrc ) 
{ 


  {
#line 736
  globalCrc = newCrc;
#line 737
  return;
}
}
#line 754 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned int bsBuff  ;
#line 755 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int bsLive  ;
#line 757 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int bsStream  ;
#line 761 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char bsWriting  ;
#line 766 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void bsSetStream(int f , unsigned char wr ) 
{ 


  {
#line 774
  bsStream = f;
#line 775
  bsLive = 0;
#line 776
  bsBuff = 0U;
#line 777
  bytesOut = 0U;
#line 778
  bytesIn = 0U;
#line 779
  bsWriting = wr;
#line 780
  return;
}
}
#line 784 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void bsFinishedWithStream(void) 
{ 


  {
#line 786
  if (bsWriting) {
    {
    {
#line 787
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 787
      if (! (bsLive > 0)) {
#line 787
        goto while_break;
      }
      {
      {
#line 788
      spec_putc((unsigned char )(bsBuff >> 24), bsStream);
      }
#line 789
      bsBuff <<= 8;
#line 790
      bsLive -= 8;
#line 791
      bytesOut ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 795
  bsStream = 0;
#line 799
  return;
}
}
#line 837 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned int bsR(int n ) 
{ 
  unsigned int v ;
  int zzi ;
  int tmp ;

  {
  {
  {
#line 840
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 840
    if (! (bsLive < n)) {
#line 840
      goto while_break;
    }
    {
    {
#line 840
    tmp = spec_getc(bsStream);
    }
#line 840
    zzi = tmp;
    }
#line 840
    if (zzi == -1) {
      {
      {
#line 840
      compressedStreamEOF();
      }
      }
    }
#line 840
    bsBuff = (unsigned int )((long )(bsBuff << 8) | ((long )zzi & 255L));
#line 840
    bsLive += 8;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 841
  v = (bsBuff >> (bsLive - n)) & (unsigned int )((1 << n) - 1);
#line 842
  bsLive -= n;
#line 843
  return (v);
}
}
#line 848 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void bsW(int n , unsigned int v ) 
{ 


  {
  {
  {
#line 850
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 850
    if (! (bsLive >= 8)) {
#line 850
      goto while_break;
    }
    {
    {
#line 850
    spec_putc((unsigned char )(bsBuff >> 24), bsStream);
    }
#line 850
    bsBuff <<= 8;
#line 850
    bsLive -= 8;
#line 850
    bytesOut ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 851
  bsBuff |= v << ((32 - bsLive) - n);
#line 852
  bsLive += n;
#line 853
  return;
}
}
#line 857 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char bsGetUChar(void) 
{ 
  unsigned int tmp ;

  {
  {
  {
#line 859
  tmp = bsR(8);
  }
  }
#line 859
  return ((unsigned char )tmp);
}
}
#line 864 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void bsPutUChar(unsigned char c ) 
{ 


  {
  {
  {
#line 866
  bsW(8, (unsigned int )c);
  }
  }
#line 867
  return;
}
}
#line 871 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int bsGetUInt32(void) 
{ 
  unsigned int u ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 874
  u = 0U;
  {
#line 875
  tmp = bsR(8);
  }
#line 875
  u = (u << 8) | tmp;
  {
#line 876
  tmp___0 = bsR(8);
  }
#line 876
  u = (u << 8) | tmp___0;
  {
#line 877
  tmp___1 = bsR(8);
  }
#line 877
  u = (u << 8) | tmp___1;
  {
#line 878
  tmp___2 = bsR(8);
  }
#line 878
  u = (u << 8) | tmp___2;
  }
#line 879
  return ((int )u);
}
}
#line 884 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned int bsGetIntVS(unsigned int numBits ) 
{ 
  unsigned int tmp ;

  {
  {
  {
#line 886
  tmp = bsR((int )numBits);
  }
  }
#line 886
  return (tmp);
}
}
#line 891 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned int bsGetInt32(void) 
{ 
  int tmp ;

  {
  {
  {
#line 893
  tmp = bsGetUInt32();
  }
  }
#line 893
  return ((unsigned int )tmp);
}
}
#line 898 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void bsPutUInt32(unsigned int u ) 
{ 


  {
  {
  {
#line 900
  bsW(8, (unsigned int )((long )(u >> 24) & 255L));
  }
  {
#line 901
  bsW(8, (unsigned int )((long )(u >> 16) & 255L));
  }
  {
#line 902
  bsW(8, (unsigned int )((long )(u >> 8) & 255L));
  }
  {
#line 903
  bsW(8, (unsigned int )((long )u & 255L));
  }
  }
#line 904
  return;
}
}
#line 908 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void bsPutInt32(int c ) 
{ 


  {
  {
  {
#line 910
  bsPutUInt32((unsigned int )c);
  }
  }
#line 911
  return;
}
}
#line 915 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void bsPutIntVS(int numBits , unsigned int c ) 
{ 


  {
  {
  {
#line 917
  bsW(numBits, c);
  }
  }
#line 918
  return;
}
}
#line 963 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void hbMakeCodeLengths(unsigned char *len___0 , int *freq , int alphaSize , int maxLen ) 
{ 
  int nNodes ;
  int nHeap ;
  int n1 ;
  int n2 ;
  int i ;
  int j ;
  int k ;
  unsigned char tooLong ;
  int heap[260] ;
  int weight[516] ;
  int parent[516] ;
  int tmp ;
  int zz ;
  int tmp___0 ;
  int zz___0 ;
  int yy ;
  int tmp___1 ;
  int zz___1 ;
  int yy___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int zz___2 ;
  int tmp___5 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 979
  i = 0;
  {
  {
#line 979
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 979
    if (! (i < alphaSize)) {
#line 979
      goto while_break;
    }
#line 980
    if (*(freq + i) == 0) {
#line 980
      tmp = 1;
    } else {
#line 980
      tmp = *(freq + i);
    }
#line 980
    weight[i + 1] = tmp << 8;
#line 979
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 982
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 984
    nNodes = alphaSize;
#line 985
    nHeap = 0;
#line 987
    heap[0] = 0;
#line 988
    weight[0] = 0;
#line 989
    parent[0] = -2;
#line 991
    i = 1;
    {
    {
#line 991
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 991
      if (! (i <= alphaSize)) {
#line 991
        goto while_break___1;
      }
#line 992
      parent[i] = -1;
#line 993
      nHeap ++;
#line 994
      heap[nHeap] = i;
#line 995
      zz = nHeap;
#line 995
      tmp___0 = heap[zz];
      {
      {
#line 995
      while (1) {
        while_continue___13: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 995
        if (! (weight[tmp___0] < weight[heap[zz >> 1]])) {
#line 995
          goto while_break___2;
        }
#line 995
        heap[zz] = heap[zz >> 1];
#line 995
        zz >>= 1;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 995
      heap[zz] = tmp___0;
#line 991
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 997
    if (! (nHeap < 260)) {
      {
      {
#line 998
      panic((char *)"hbMakeCodeLengths(1)");
      }
      }
    }
    {
    {
#line 1000
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 1000
      if (! (nHeap > 1)) {
#line 1000
        goto while_break___3;
      }
#line 1001
      n1 = heap[1];
#line 1001
      heap[1] = heap[nHeap];
#line 1001
      nHeap --;
#line 1001
      zz___0 = 1;
#line 1001
      tmp___1 = heap[zz___0];
      {
      {
#line 1001
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 1001
        yy = zz___0 << 1;
#line 1001
        if (yy > nHeap) {
#line 1001
          goto while_break___4;
        }
#line 1001
        if (yy < nHeap) {
#line 1001
          if (weight[heap[yy + 1]] < weight[heap[yy]]) {
#line 1001
            yy ++;
          }
        }
#line 1001
        if (weight[tmp___1] < weight[heap[yy]]) {
#line 1001
          goto while_break___4;
        }
#line 1001
        heap[zz___0] = heap[yy];
#line 1001
        zz___0 = yy;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1001
      heap[zz___0] = tmp___1;
#line 1002
      n2 = heap[1];
#line 1002
      heap[1] = heap[nHeap];
#line 1002
      nHeap --;
#line 1002
      zz___1 = 1;
#line 1002
      tmp___2 = heap[zz___1];
      {
      {
#line 1002
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 1002
        yy___0 = zz___1 << 1;
#line 1002
        if (yy___0 > nHeap) {
#line 1002
          goto while_break___5;
        }
#line 1002
        if (yy___0 < nHeap) {
#line 1002
          if (weight[heap[yy___0 + 1]] < weight[heap[yy___0]]) {
#line 1002
            yy___0 ++;
          }
        }
#line 1002
        if (weight[tmp___2] < weight[heap[yy___0]]) {
#line 1002
          goto while_break___5;
        }
#line 1002
        heap[zz___1] = heap[yy___0];
#line 1002
        zz___1 = yy___0;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1002
      heap[zz___1] = tmp___2;
#line 1003
      nNodes ++;
#line 1004
      tmp___3 = nNodes;
#line 1004
      parent[n2] = tmp___3;
#line 1004
      parent[n1] = tmp___3;
#line 1005
      if ((weight[n1] & 255) > (weight[n2] & 255)) {
#line 1005
        tmp___4 = weight[n1] & 255;
      } else {
#line 1005
        tmp___4 = weight[n2] & 255;
      }
#line 1005
      weight[nNodes] = (int )((((unsigned int )weight[n1] & 4294967040U) + ((unsigned int )weight[n2] & 4294967040U)) | (unsigned int )(1 + tmp___4));
#line 1006
      parent[nNodes] = -1;
#line 1007
      nHeap ++;
#line 1008
      heap[nHeap] = nNodes;
#line 1009
      zz___2 = nHeap;
#line 1009
      tmp___5 = heap[zz___2];
      {
      {
#line 1009
      while (1) {
        while_continue___17: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 1009
        if (! (weight[tmp___5] < weight[heap[zz___2 >> 1]])) {
#line 1009
          goto while_break___6;
        }
#line 1009
        heap[zz___2] = heap[zz___2 >> 1];
#line 1009
        zz___2 >>= 1;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1009
      heap[zz___2] = tmp___5;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1011
    if (! (nNodes < 516)) {
      {
      {
#line 1012
      panic((char *)"hbMakeCodeLengths(2)");
      }
      }
    }
#line 1014
    tooLong = (unsigned char)0;
#line 1015
    i = 1;
    {
    {
#line 1015
    while (1) {
      while_continue___18: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 1015
      if (! (i <= alphaSize)) {
#line 1015
        goto while_break___7;
      }
#line 1016
      j = 0;
#line 1017
      k = i;
      {
      {
#line 1018
      while (1) {
        while_continue___19: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
#line 1018
        if (! (parent[k] >= 0)) {
#line 1018
          goto while_break___8;
        }
#line 1018
        k = parent[k];
#line 1018
        j ++;
      }
      while_break___19: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1019
      *(len___0 + (i - 1)) = (unsigned char )j;
#line 1020
      if (j > maxLen) {
#line 1020
        tooLong = (unsigned char)1;
      }
#line 1015
      i ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1023
    if (! tooLong) {
#line 1023
      goto while_break___0;
    }
#line 1025
    i = 1;
    {
    {
#line 1025
    while (1) {
      while_continue___20: /* CIL Label */ ;
      while_continue___9: /* CIL Label */ ;
#line 1025
      if (! (i < alphaSize)) {
#line 1025
        goto while_break___9;
      }
#line 1026
      j = weight[i] >> 8;
#line 1027
      j = 1 + j / 2;
#line 1028
      weight[i] = j << 8;
#line 1025
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1031
  return;
}
}
#line 1035 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void hbAssignCodes(int *code___0 , unsigned char *length , int minLen , int maxLen ,
                   int alphaSize ) 
{ 
  int n ;
  int vec ;
  int i ;

  {
#line 1043
  vec = 0;
#line 1044
  n = minLen;
  {
  {
#line 1044
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1044
    if (! (n <= maxLen)) {
#line 1044
      goto while_break;
    }
#line 1045
    i = 0;
    {
    {
#line 1045
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1045
      if (! (i < alphaSize)) {
#line 1045
        goto while_break___0;
      }
#line 1046
      if ((int )*(length + i) == n) {
#line 1046
        *(code___0 + i) = vec;
#line 1046
        vec ++;
      }
#line 1045
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1047
    vec <<= 1;
#line 1044
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  return;
}
}
#line 1053 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void hbCreateDecodeTables(int *limit___0 , int *base___0 , int *perm___0 , unsigned char *length ,
                          int minLen , int maxLen , int alphaSize ) 
{ 
  int pp ;
  int i ;
  int j ;
  int vec ;

  {
#line 1063
  pp = 0;
#line 1064
  i = minLen;
  {
  {
#line 1064
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1064
    if (! (i <= maxLen)) {
#line 1064
      goto while_break;
    }
#line 1065
    j = 0;
    {
    {
#line 1065
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1065
      if (! (j < alphaSize)) {
#line 1065
        goto while_break___0;
      }
#line 1066
      if ((int )*(length + j) == i) {
#line 1066
        *(perm___0 + pp) = j;
#line 1066
        pp ++;
      }
#line 1065
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1064
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1068
  i = 0;
  {
  {
#line 1068
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1068
    if (! (i < 23)) {
#line 1068
      goto while_break___1;
    }
#line 1068
    *(base___0 + i) = 0;
#line 1068
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1069
  i = 0;
  {
  {
#line 1069
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 1069
    if (! (i < alphaSize)) {
#line 1069
      goto while_break___2;
    }
#line 1069
    (*(base___0 + ((int )*(length + i) + 1))) ++;
#line 1069
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1071
  i = 1;
  {
  {
#line 1071
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 1071
    if (! (i < 23)) {
#line 1071
      goto while_break___3;
    }
#line 1071
    *(base___0 + i) += *(base___0 + (i - 1));
#line 1071
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1073
  i = 0;
  {
  {
#line 1073
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 1073
    if (! (i < 23)) {
#line 1073
      goto while_break___4;
    }
#line 1073
    *(limit___0 + i) = 0;
#line 1073
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1074
  vec = 0;
#line 1076
  i = minLen;
  {
  {
#line 1076
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 1076
    if (! (i <= maxLen)) {
#line 1076
      goto while_break___5;
    }
#line 1077
    vec += *(base___0 + (i + 1)) - *(base___0 + i);   // BUG
#line 1078
    *(limit___0 + i) = vec - 1;                       // BUG
#line 1079
    vec <<= 1;
#line 1076
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1081
  i = minLen + 1;
  {
  {
#line 1081
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 1081
    if (! (i <= maxLen)) {
#line 1081
      goto while_break___6;
    }
#line 1082 
    *(base___0 + i) = ((*(limit___0 + (i - 1)) + 1) << 1) - *(base___0 + i);    // BUG
#line 1081
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1083
  return;
}
}
#line 1127 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void allocateCompressStructures(void) 
{ 
  int n ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int totalDraw ;

  {
  {
#line 1129
  n = 100000 * blockSize100k;
  {
#line 1130
  tmp = malloc((size_t )((unsigned long )((n + 1) + 20) * sizeof(unsigned char )));
  }
#line 1130
  block = (unsigned char *)tmp;
  {
#line 1131
  tmp___0 = malloc((size_t )((unsigned long )(n + 20) * sizeof(short )));
  }
#line 1131
  quadrant = (unsigned short *)tmp___0;
  {
#line 1132
  tmp___1 = malloc((size_t )((unsigned long )n * sizeof(int )));
  }
#line 1132
  zptr = (int *)tmp___1;
  {
#line 1133
  tmp___2 = malloc((size_t )(65537UL * sizeof(int )));
  }
#line 1133
  ftab = (int *)tmp___2;
  }
#line 1135
  if ((unsigned long )block == (unsigned long )((void *)0)) {
    {
#line 1137
    totalDraw = (int )((((unsigned long )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned long )(n + 20) * sizeof(short )) + (unsigned long )n * sizeof(int )) + 65537UL * sizeof(int ));
    {
#line 1143
    compressOutOfMemory(totalDraw, n);
    }
    }
  } else
#line 1135
  if ((unsigned long )quadrant == (unsigned long )((void *)0)) {
    {
#line 1137
    totalDraw = (int )((((unsigned long )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned long )(n + 20) * sizeof(short )) + (unsigned long )n * sizeof(int )) + 65537UL * sizeof(int ));
    {
#line 1143
    compressOutOfMemory(totalDraw, n);
    }
    }
  } else
#line 1135
  if ((unsigned long )zptr == (unsigned long )((void *)0)) {
    {
#line 1137
    totalDraw = (int )((((unsigned long )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned long )(n + 20) * sizeof(short )) + (unsigned long )n * sizeof(int )) + 65537UL * sizeof(int ));
    {
#line 1143
    compressOutOfMemory(totalDraw, n);
    }
    }
  } else
#line 1135
  if ((unsigned long )ftab == (unsigned long )((void *)0)) {
    {
#line 1137
    totalDraw = (int )((((unsigned long )((n + 1) + 20) * sizeof(unsigned char ) + (unsigned long )(n + 20) * sizeof(short )) + (unsigned long )n * sizeof(int )) + 65537UL * sizeof(int ));
    {
#line 1143
    compressOutOfMemory(totalDraw, n);
    }
    }
  }
#line 1151
  block ++;
#line 1163
  szptr = (unsigned short *)zptr;
#line 1164
  return;
}
}
#line 1168 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void setDecompressStructureSizes(int newSize100k ) 
{ 
  int n ;
  void *tmp ;
  void *tmp___0 ;
  int totalDraw ;
  int n___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int totalDraw___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1170
  if (0 <= newSize100k) {
#line 1170
    if (newSize100k <= 9) {
#line 1170
      if (0 <= blockSize100k) {
#line 1170
        if (! (blockSize100k <= 9)) {
          {
          {
#line 1172
          panic((char *)"setDecompressStructureSizes");
          }
          }
        }
      } else {
        {
        {
#line 1172
        panic((char *)"setDecompressStructureSizes");
        }
        }
      }
    } else {
      {
      {
#line 1172
      panic((char *)"setDecompressStructureSizes");
      }
      }
    }
  } else {
    {
    {
#line 1172
    panic((char *)"setDecompressStructureSizes");
    }
    }
  }
#line 1174
  if (newSize100k == blockSize100k) {
#line 1174
    return;
  }
#line 1176
  blockSize100k = newSize100k;
#line 1178
  if ((unsigned long )ll16 != (unsigned long )((void *)0)) {
    {
    {
#line 1178
    free((void *)ll16);
    }
    }
  }
#line 1179
  if ((unsigned long )ll4 != (unsigned long )((void *)0)) {
    {
    {
#line 1179
    free((void *)ll4);
    }
    }
  }
#line 1180
  if ((unsigned long )ll8 != (unsigned long )((void *)0)) {
    {
    {
#line 1180
    free((void *)ll8);
    }
    }
  }
#line 1181
  if ((unsigned long )tt != (unsigned long )((void *)0)) {
    {
    {
#line 1181
    free((void *)tt);
    }
    }
  }
#line 1183
  if (newSize100k == 0) {
#line 1183
    return;
  }
#line 1185
  if (smallMode) {
    {
#line 1187
    n = 100000 * newSize100k;
    {
#line 1188
    tmp = malloc((size_t )((unsigned long )n * sizeof(unsigned short )));
    }
#line 1188
    ll16 = (unsigned short *)tmp;
    {
#line 1189
    tmp___0 = malloc((size_t )((unsigned long )((n + 1) >> 1) * sizeof(unsigned char )));
    }
#line 1189
    ll4 = (unsigned char *)tmp___0;
    }
#line 1191
    if ((unsigned long )ll4 == (unsigned long )((void *)0)) {
      {
#line 1192
      totalDraw = (int )((unsigned long )n * sizeof(short ) + (unsigned long )((n + 1) >> 1) * sizeof(unsigned char ));
      {
#line 1194
      uncompressOutOfMemory(totalDraw, n);
      }
      }
    } else
#line 1191
    if ((unsigned long )ll16 == (unsigned long )((void *)0)) {
      {
#line 1192
      totalDraw = (int )((unsigned long )n * sizeof(short ) + (unsigned long )((n + 1) >> 1) * sizeof(unsigned char ));
      {
#line 1194
      uncompressOutOfMemory(totalDraw, n);
      }
      }
    }
  } else {
    {
#line 1199
    n___0 = 100000 * newSize100k;
    {
#line 1200
    tmp___1 = malloc((size_t )((unsigned long )n___0 * sizeof(unsigned char )));
    }
#line 1200
    ll8 = (unsigned char *)tmp___1;
    {
#line 1201
    tmp___2 = malloc((size_t )((unsigned long )n___0 * sizeof(int )));
    }
#line 1201
    tt = (int *)tmp___2;
    }
#line 1203
    if ((unsigned long )ll8 == (unsigned long )((void *)0)) {
      {
#line 1204
      totalDraw___0 = (int )((unsigned long )n___0 * sizeof(unsigned char ) + (unsigned long )n___0 * sizeof(unsigned int ));
      {
#line 1206
      uncompressOutOfMemory(totalDraw___0, n___0);
      }
      }
    } else
#line 1203
    if ((unsigned long )tt == (unsigned long )((void *)0)) {
      {
#line 1204
      totalDraw___0 = (int )((unsigned long )n___0 * sizeof(unsigned char ) + (unsigned long )n___0 * sizeof(unsigned int ));
      {
#line 1206
      uncompressOutOfMemory(totalDraw___0, n___0);
      }
      }
    }
  }
#line 1210
  return;
}
}
#line 1219 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void makeMaps(void) 
{ 
  int i ;

  {
#line 1222
  nInUse = 0;
#line 1223
  i = 0;
  {
  {
#line 1223
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1223
    if (! (i < 256)) {
#line 1223
      goto while_break;
    }
#line 1224
    if (inUse[i]) {
#line 1225
      seqToUnseq[nInUse] = (unsigned char )i;
#line 1226
      unseqToSeq[i] = (unsigned char )nInUse;
#line 1227
      nInUse ++;
    }
#line 1223
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  return;
}
}
#line 1233 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void generateMTFValues(void) 
{ 
  unsigned char yy[256] ;
  int i ;
  int j ;
  unsigned char tmp ;
  unsigned char tmp2 ;
  int zPend ;
  int wr ;
  int EOB ;
  unsigned char ll_i ;
  void *__cil_tmp10 ;

  {
  {
  {
#line 1243
  makeMaps();
  }
#line 1244
  EOB = nInUse + 1;
#line 1246
  i = 0;
  }
  {
  {
#line 1246
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1246
    if (! (i <= EOB)) {
#line 1246
      goto while_break;
    }
#line 1246
    mtfFreq[i] = 0;
#line 1246
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1248
  wr = 0;
#line 1249
  zPend = 0;
#line 1250
  i = 0;
  {
  {
#line 1250
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1250
    if (! (i < nInUse)) {
#line 1250
      goto while_break___0;
    }
#line 1250
    yy[i] = (unsigned char )i;
#line 1250
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1253
  i = 0;
  {
  {
#line 1253
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1253
    if (! (i <= last)) {
#line 1253
      goto while_break___1;
    }
#line 1260
    ll_i = unseqToSeq[*(block + (*(zptr + i) - 1))];
#line 1265
    j = 0;
#line 1266
    tmp = yy[j];
    {
    {
#line 1267
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 1267
      if (! ((int )ll_i != (int )tmp)) {
#line 1267
        goto while_break___2;
      }
#line 1268
      j ++;
#line 1269
      tmp2 = tmp;
#line 1270
      tmp = yy[j];
#line 1271
      yy[j] = tmp2;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1273
    yy[0] = tmp;
#line 1275
    if (j == 0) {
#line 1276
      zPend ++;
    } else {
#line 1278
      if (zPend > 0) {
#line 1279
        zPend --;
        {
        {
#line 1280
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
          {
#line 1282
          if (zPend % 2 == 0) {
#line 1282
            goto case_0;
          }
#line 1283
          if (zPend % 2 == 1) {
#line 1283
            goto case_1;
          }
#line 1281
          goto switch_break;
          case_0: /* CIL Label */ 
#line 1282
          *(szptr + wr) = (unsigned short)0;
#line 1282
          wr ++;
#line 1282
          (mtfFreq[0]) ++;
#line 1282
          goto switch_break;
          case_1: /* CIL Label */ 
#line 1283
          *(szptr + wr) = (unsigned short)1;
#line 1283
          wr ++;
#line 1283
          (mtfFreq[1]) ++;
#line 1283
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 1285
          if (zPend < 2) {
#line 1285
            goto while_break___3;
          }
#line 1286
          zPend = (zPend - 2) / 2;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1288
        zPend = 0;
      }
#line 1290
      *(szptr + wr) = (unsigned short )(j + 1);
#line 1290
      wr ++;
#line 1290
      (mtfFreq[j + 1]) ++;
    }
#line 1253
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1294
  if (zPend > 0) {
#line 1295
    zPend --;
    {
    {
#line 1296
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
      {
#line 1298
      if (zPend % 2 == 0) {
#line 1298
        goto case_0___0;
      }
#line 1299
      if (zPend % 2 == 1) {
#line 1299
        goto case_1___0;
      }
#line 1297
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 1298
      *(szptr + wr) = (unsigned short)0;
#line 1298
      wr ++;
#line 1298
      (mtfFreq[0]) ++;
#line 1298
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1299
      *(szptr + wr) = (unsigned short)1;
#line 1299
      wr ++;
#line 1299
      (mtfFreq[1]) ++;
#line 1299
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1301
      if (zPend < 2) {
#line 1301
        goto while_break___4;
      }
#line 1302
      zPend = (zPend - 2) / 2;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1306
  *(szptr + wr) = (unsigned short )EOB;
#line 1306
  wr ++;
#line 1306
  (mtfFreq[EOB]) ++;
#line 1308
  nMTF = wr;
#line 1309
  return;
}
}
#line 1316 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void sendMTFValues(void) 
{ 
  int v ;
  int t ;
  int i ;
  int j ;
  int gs ;
  int ge ;
  int totc ;
  int bt ;
  int bc ;
  int iter ;
  int nSelectors ;
  int alphaSize ;
  int minLen ;
  int maxLen ;
  int selCtr ;
  int nGroups ;
  int nBytes ;
  unsigned short cost[6] ;
  int fave[6] ;
  int nPart ;
  int remF ;
  int tFreq ;
  int aFreq ;
  register unsigned short cost0 ;
  register unsigned short cost1 ;
  register unsigned short cost2 ;
  register unsigned short cost3 ;
  register unsigned short cost4 ;
  register unsigned short cost5 ;
  unsigned short icv ;
  unsigned short icv___0 ;
  unsigned char pos[6] ;
  unsigned char ll_i ;
  unsigned char tmp2 ;
  unsigned char tmp ;
  unsigned char inUse16[16] ;
  int curr ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  {
#line 1336
  if (verbosity >= 3) {
    {
    {
#line 1337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      %d in block, %d after MTF & 1-2 coding, %d+2 syms in use\n",
            last + 1, nMTF, nInUse);
    }
    }
  }
#line 1341
  alphaSize = nInUse + 2;
#line 1342
  t = 0;
  {
  {
#line 1342
  while (1) {
    while_continue___35: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1342
    if (! (t < 6)) {
#line 1342
      goto while_break;
    }
#line 1343
    v = 0;
    {
    {
#line 1343
    while (1) {
      while_continue___36: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1343
      if (! (v < alphaSize)) {
#line 1343
        goto while_break___0;
      }
#line 1344
      len[t][v] = (unsigned char)15;
#line 1343
      v ++;
    }
    while_break___36: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1342
    t ++;
  }
  while_break___35: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1347
  if (nMTF <= 0) {
    {
    {
#line 1347
    panic((char *)"sendMTFValues(0)");
    }
    }
  }
#line 1348
  if (nMTF < 200) {
#line 1348
    nGroups = 2;
  } else
#line 1349
  if (nMTF < 800) {
#line 1349
    nGroups = 4;
  } else {
#line 1350
    nGroups = 6;
  }
#line 1356
  nPart = nGroups;
#line 1357
  remF = nMTF;
#line 1358
  gs = 0;
  {
  {
#line 1359
  while (1) {
    while_continue___37: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1359
    if (! (nPart > 0)) {
#line 1359
      goto while_break___1;
    }
#line 1360
    tFreq = remF / nPart;
#line 1361
    ge = gs - 1;
#line 1362
    aFreq = 0;
    {
    {
#line 1363
    while (1) {
      while_continue___38: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 1363
      if (aFreq < tFreq) {
#line 1363
        if (! (ge < alphaSize - 1)) {
#line 1363
          goto while_break___2;
        }
      } else {
#line 1363
        goto while_break___2;
      }
#line 1364
      ge ++;
#line 1365
      aFreq += mtfFreq[ge];
    }
    while_break___38: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1368
    if (ge > gs) {
#line 1368
      if (nPart != nGroups) {
#line 1368
        if (nPart != 1) {
#line 1368
          if ((nGroups - nPart) % 2 == 1) {
#line 1371
            aFreq -= mtfFreq[ge];
#line 1372
            ge --;
          }
        }
      }
    }
#line 1375
    if (verbosity >= 3) {
      {
      {
#line 1376
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      initial group %d, [%d .. %d], has %d syms (%4.1f%%)\n",
              nPart, gs, ge, aFreq, (100.0 * (double )((float )aFreq)) / (double )((float )nMTF));
      }
      }
    }
#line 1381
    v = 0;
    {
    {
#line 1381
    while (1) {
      while_continue___39: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 1381
      if (! (v < alphaSize)) {
#line 1381
        goto while_break___3;
      }
#line 1382
      if (v >= gs) {
#line 1382
        if (v <= ge) {
#line 1383
          len[nPart - 1][v] = (unsigned char)0;
        } else {
#line 1384
          len[nPart - 1][v] = (unsigned char)15;
        }
      } else {
#line 1384
        len[nPart - 1][v] = (unsigned char)15;
      }
#line 1381
      v ++;
    }
    while_break___39: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1386
    nPart --;
#line 1387
    gs = ge + 1;
#line 1388
    remF -= aFreq;
  }
  while_break___37: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1395
  iter = 0;
  {
  {
#line 1395
  while (1) {
    while_continue___40: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 1395
    if (! (iter < 4)) {
#line 1395
      goto while_break___4;
    }
#line 1397
    t = 0;
    {
    {
#line 1397
    while (1) {
      while_continue___41: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 1397
      if (! (t < nGroups)) {
#line 1397
        goto while_break___5;
      }
#line 1397
      fave[t] = 0;
#line 1397
      t ++;
    }
    while_break___41: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1399
    t = 0;
    {
    {
#line 1399
    while (1) {
      while_continue___42: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 1399
      if (! (t < nGroups)) {
#line 1399
        goto while_break___6;
      }
#line 1400
      v = 0;
      {
      {
#line 1400
      while (1) {
        while_continue___43: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 1400
        if (! (v < alphaSize)) {
#line 1400
          goto while_break___7;
        }
#line 1401
        rfreq[t][v] = 0;
#line 1400
        v ++;
      }
      while_break___43: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1399
      t ++;
    }
    while_break___42: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1403
    nSelectors = 0;
#line 1404
    totc = 0;
#line 1405
    gs = 0;
    {
    {
#line 1406
    while (1) {
      while_continue___44: /* CIL Label */ ;
      while_continue___8: /* CIL Label */ ;
#line 1409
      if (gs >= nMTF) {
#line 1409
        goto while_break___8;
      }
#line 1410
      ge = (gs + 50) - 1;
#line 1411
      if (ge >= nMTF) {
#line 1411
        ge = nMTF - 1;
      }
#line 1417
      t = 0;
      {
      {
#line 1417
      while (1) {
        while_continue___45: /* CIL Label */ ;
        while_continue___9: /* CIL Label */ ;
#line 1417
        if (! (t < nGroups)) {
#line 1417
          goto while_break___9;
        }
#line 1417
        cost[t] = (unsigned short)0;
#line 1417
        t ++;
      }
      while_break___45: /* CIL Label */ ;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1419
      if (nGroups == 6) {
#line 1421
        cost5 = (unsigned short)0;
#line 1421
        cost4 = cost5;
#line 1421
        cost3 = cost4;
#line 1421
        cost2 = cost3;
#line 1421
        cost1 = cost2;
#line 1421
        cost0 = cost1;
#line 1422
        i = gs;
        {
        {
#line 1422
        while (1) {
          while_continue___46: /* CIL Label */ ;
          while_continue___10: /* CIL Label */ ;
#line 1422
          if (! (i <= ge)) {
#line 1422
            goto while_break___10;
          }
#line 1423
          icv = *(szptr + i);
#line 1424
          cost0 = (unsigned short )((int )cost0 + (int )len[0][icv]);
#line 1425
          cost1 = (unsigned short )((int )cost1 + (int )len[1][icv]);
#line 1426
          cost2 = (unsigned short )((int )cost2 + (int )len[2][icv]);
#line 1427
          cost3 = (unsigned short )((int )cost3 + (int )len[3][icv]);
#line 1428
          cost4 = (unsigned short )((int )cost4 + (int )len[4][icv]);
#line 1429
          cost5 = (unsigned short )((int )cost5 + (int )len[5][icv]);
#line 1422
          i ++;
        }
        while_break___46: /* CIL Label */ ;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1431
        cost[0] = cost0;
#line 1431
        cost[1] = cost1;
#line 1431
        cost[2] = cost2;
#line 1432
        cost[3] = cost3;
#line 1432
        cost[4] = cost4;
#line 1432
        cost[5] = cost5;
      } else {
#line 1434
        i = gs;
        {
        {
#line 1434
        while (1) {
          while_continue___47: /* CIL Label */ ;
          while_continue___11: /* CIL Label */ ;
#line 1434
          if (! (i <= ge)) {
#line 1434
            goto while_break___11;
          }
#line 1435
          icv___0 = *(szptr + i);
#line 1436
          t = 0;
          {
          {
#line 1436
          while (1) {
            while_continue___48: /* CIL Label */ ;
            while_continue___12: /* CIL Label */ ;
#line 1436
            if (! (t < nGroups)) {
#line 1436
              goto while_break___12;
            }
#line 1436
            cost[t] = (unsigned short )((int )cost[t] + (int )len[t][icv___0]);
#line 1436
            t ++;
          }
          while_break___48: /* CIL Label */ ;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 1434
          i ++;
        }
        while_break___47: /* CIL Label */ ;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 1444
      bc = 999999999;
#line 1444
      bt = -1;
#line 1445
      t = 0;
      {
      {
#line 1445
      while (1) {
        while_continue___49: /* CIL Label */ ;
        while_continue___13: /* CIL Label */ ;
#line 1445
        if (! (t < nGroups)) {
#line 1445
          goto while_break___13;
        }
#line 1446
        if ((int )cost[t] < bc) {
#line 1446
          bc = (int )cost[t];
#line 1446
          bt = t;
        }
#line 1445
        t ++;
      }
      while_break___49: /* CIL Label */ ;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 1447
      totc += bc;
#line 1448
      (fave[bt]) ++;
#line 1449
      selector[nSelectors] = (unsigned char )bt;
#line 1450
      nSelectors ++;
#line 1455
      i = gs;
      {
      {
#line 1455
      while (1) {
        while_continue___50: /* CIL Label */ ;
        while_continue___14: /* CIL Label */ ;
#line 1455
        if (! (i <= ge)) {
#line 1455
          goto while_break___14;
        }
#line 1456
        (rfreq[bt][*(szptr + i)]) ++;
#line 1455
        i ++;
      }
      while_break___50: /* CIL Label */ ;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 1458
      gs = ge + 1;
    }
    while_break___44: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1460
    if (verbosity >= 3) {
      {
      {
#line 1461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      pass %d: size is %d, grp uses are ",
              iter + 1, totc / 8);
      }
#line 1464
      t = 0;
      }
      {
      {
#line 1464
      while (1) {
        while_continue___51: /* CIL Label */ ;
        while_continue___15: /* CIL Label */ ;
#line 1464
        if (! (t < nGroups)) {
#line 1464
          goto while_break___15;
        }
        {
        {
#line 1465
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d ",
                fave[t]);
        }
#line 1464
        t ++;
        }
      }
      while_break___51: /* CIL Label */ ;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
      {
#line 1466
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
      }
    }
#line 1472
    t = 0;
    {
    {
#line 1472
    while (1) {
      while_continue___52: /* CIL Label */ ;
      while_continue___16: /* CIL Label */ ;
#line 1472
      if (! (t < nGroups)) {
#line 1472
        goto while_break___16;
      }
      {
      {
#line 1473
      hbMakeCodeLengths(len[t],  rfreq[t], alphaSize, 20);
      }
#line 1472
      t ++;
      }
    }
    while_break___52: /* CIL Label */ ;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1395
    iter ++;
  }
  while_break___40: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1477
  if (! (nGroups < 8)) {
    {
    {
#line 1477
    panic((char *)"sendMTFValues(1)");
    }
    }
  }
#line 1478
  if (nSelectors < 32768) {
#line 1478
    if (! (nSelectors <= 18002)) {
      {
      {
#line 1480
      panic((char *)"sendMTFValues(2)");
      }
      }
    }
  } else {
    {
    {
#line 1480
    panic((char *)"sendMTFValues(2)");
    }
    }
  }
#line 1486
  i = 0;
  {
  {
#line 1486
  while (1) {
    while_continue___53: /* CIL Label */ ;
    while_continue___17: /* CIL Label */ ;
#line 1486
    if (! (i < nGroups)) {
#line 1486
      goto while_break___17;
    }
#line 1486
    pos[i] = (unsigned char )i;
#line 1486
    i ++;
  }
  while_break___53: /* CIL Label */ ;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 1487
  i = 0;
  {
  {
#line 1487
  while (1) {
    while_continue___54: /* CIL Label */ ;
    while_continue___18: /* CIL Label */ ;
#line 1487
    if (! (i < nSelectors)) {
#line 1487
      goto while_break___18;
    }
#line 1488
    ll_i = selector[i];
#line 1489
    j = 0;
#line 1490
    tmp = pos[j];
    {
    {
#line 1491
    while (1) {
      while_continue___55: /* CIL Label */ ;
      while_continue___19: /* CIL Label */ ;
#line 1491
      if (! ((int )ll_i != (int )tmp)) {
#line 1491
        goto while_break___19;
      }
#line 1492
      j ++;
#line 1493
      tmp2 = tmp;
#line 1494
      tmp = pos[j];
#line 1495
      pos[j] = tmp2;
    }
    while_break___55: /* CIL Label */ ;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1497
    pos[0] = tmp;
#line 1498
    selectorMtf[i] = (unsigned char )j;
#line 1487
    i ++;
  }
  while_break___54: /* CIL Label */ ;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 1503
  t = 0;
  {
  {
#line 1503
  while (1) {
    while_continue___56: /* CIL Label */ ;
    while_continue___20: /* CIL Label */ ;
#line 1503
    if (! (t < nGroups)) {
#line 1503
      goto while_break___20;
    }
#line 1504
    minLen = 32;
#line 1505
    maxLen = 0;
#line 1506
    i = 0;
    {
    {
#line 1506
    while (1) {
      while_continue___57: /* CIL Label */ ;
      while_continue___21: /* CIL Label */ ;
#line 1506
      if (! (i < alphaSize)) {
#line 1506
        goto while_break___21;
      }
#line 1507
      if ((int )len[t][i] > maxLen) {
#line 1507
        maxLen = (int )len[t][i];
      }
#line 1508
      if ((int )len[t][i] < minLen) {
#line 1508
        minLen = (int )len[t][i];
      }
#line 1506
      i ++;
    }
    while_break___57: /* CIL Label */ ;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 1510
    if (maxLen > 20) {
      {
      {
#line 1510
      panic((char *)"sendMTFValues(3)");
      }
      }
    }
#line 1511
    if (minLen < 1) {
      {
      {
#line 1511
      panic((char *)"sendMTFValues(4)");
      }
      }
    }
    {
    {
#line 1512
    hbAssignCodes(& code[t][0], & len[t][0], minLen, maxLen, alphaSize);
    }
#line 1503
    t ++;
    }
  }
  while_break___56: /* CIL Label */ ;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 1519
  i = 0;
  {
  {
#line 1519
  while (1) {
    while_continue___58: /* CIL Label */ ;
    while_continue___22: /* CIL Label */ ;
#line 1519
    if (! (i < 16)) {
#line 1519
      goto while_break___22;
    }
#line 1520
    inUse16[i] = (unsigned char)0;
#line 1521
    j = 0;
    {
    {
#line 1521
    while (1) {
      while_continue___59: /* CIL Label */ ;
      while_continue___23: /* CIL Label */ ;
#line 1521
      if (! (j < 16)) {
#line 1521
        goto while_break___23;
      }
#line 1522
      if (inUse[i * 16 + j]) {
#line 1522
        inUse16[i] = (unsigned char)1;
      }
#line 1521
      j ++;
    }
    while_break___59: /* CIL Label */ ;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 1519
    i ++;
  }
  while_break___58: /* CIL Label */ ;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 1525
  nBytes = (int )bytesOut;
#line 1526
  i = 0;
  {
  {
#line 1526
  while (1) {
    while_continue___60: /* CIL Label */ ;
    while_continue___24: /* CIL Label */ ;
#line 1526
    if (! (i < 16)) {
#line 1526
      goto while_break___24;
    }
#line 1527
    if (inUse16[i]) {
      {
      {
#line 1527
      bsW(1, 1U);
      }
      }
    } else {
      {
      {
#line 1527
      bsW(1, 0U);
      }
      }
    }
#line 1526
    i ++;
  }
  while_break___60: /* CIL Label */ ;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 1529
  i = 0;
  {
  {
#line 1529
  while (1) {
    while_continue___61: /* CIL Label */ ;
    while_continue___25: /* CIL Label */ ;
#line 1529
    if (! (i < 16)) {
#line 1529
      goto while_break___25;
    }
#line 1530
    if (inUse16[i]) {
#line 1531
      j = 0;
      {
      {
#line 1531
      while (1) {
        while_continue___62: /* CIL Label */ ;
        while_continue___26: /* CIL Label */ ;
#line 1531
        if (! (j < 16)) {
#line 1531
          goto while_break___26;
        }
#line 1532
        if (inUse[i * 16 + j]) {
          {
          {
#line 1533
          bsW(1, 1U);
          }
          }
        } else {
          {
          {
#line 1535
          bsW(1, 0U);
          }
          }
        }
#line 1531
        j ++;
      }
      while_break___62: /* CIL Label */ ;
      }
      while_break___26: /* CIL Label */ ;
      }
    }
#line 1529
    i ++;
  }
  while_break___61: /* CIL Label */ ;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 1540
  if (verbosity >= 3) {
    {
    {
#line 1541
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      bytes: mapping %d, ",
            bytesOut - (unsigned int )nBytes);
    }
    }
  }
  {
#line 1545
  nBytes = (int )bytesOut;
  {
#line 1546
  bsW(3, (unsigned int )nGroups);
  }
  {
#line 1547
  bsW(15, (unsigned int )nSelectors);
  }
#line 1548
  i = 0;
  }
  {
  {
#line 1548
  while (1) {
    while_continue___63: /* CIL Label */ ;
    while_continue___27: /* CIL Label */ ;
#line 1548
    if (! (i < nSelectors)) {
#line 1548
      goto while_break___27;
    }
#line 1549
    j = 0;
    {
    {
#line 1549
    while (1) {
      while_continue___64: /* CIL Label */ ;
      while_continue___28: /* CIL Label */ ;
#line 1549
      if (! (j < (int )selectorMtf[i])) {
#line 1549
        goto while_break___28;
      }
      {
      {
#line 1549
      bsW(1, 1U);
      }
#line 1549
      j ++;
      }
    }
    while_break___64: /* CIL Label */ ;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
    {
#line 1550
    bsW(1, 0U);
    }
#line 1548
    i ++;
    }
  }
  while_break___63: /* CIL Label */ ;
  }
  while_break___27: /* CIL Label */ ;
  }
#line 1552
  if (verbosity >= 3) {
    {
    {
#line 1553
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"selectors %d, ",
            bytesOut - (unsigned int )nBytes);
    }
    }
  }
#line 1556
  nBytes = (int )bytesOut;
#line 1558
  t = 0;
  {
  {
#line 1558
  while (1) {
    while_continue___65: /* CIL Label */ ;
    while_continue___29: /* CIL Label */ ;
#line 1558
    if (! (t < nGroups)) {
#line 1558
      goto while_break___29;
    }
    {
#line 1559
    curr = (int )len[t][0];
    {
#line 1560
    bsW(5, (unsigned int )curr);
    }
#line 1561
    i = 0;
    }
    {
    {
#line 1561
    while (1) {
      while_continue___66: /* CIL Label */ ;
      while_continue___30: /* CIL Label */ ;
#line 1561
      if (! (i < alphaSize)) {
#line 1561
        goto while_break___30;
      }
      {
      {
#line 1562
      while (1) {
        while_continue___67: /* CIL Label */ ;
        while_continue___31: /* CIL Label */ ;
#line 1562
        if (! (curr < (int )len[t][i])) {
#line 1562
          goto while_break___31;
        }
        {
        {
#line 1562
        bsW(2, 2U);
        }
#line 1562
        curr ++;
        }
      }
      while_break___67: /* CIL Label */ ;
      }
      while_break___31: /* CIL Label */ ;
      }
      {
      {
#line 1563
      while (1) {
        while_continue___68: /* CIL Label */ ;
        while_continue___32: /* CIL Label */ ;
#line 1563
        if (! (curr > (int )len[t][i])) {
#line 1563
          goto while_break___32;
        }
        {
        {
#line 1563
        bsW(2, 3U);
        }
#line 1563
        curr --;
        }
      }
      while_break___68: /* CIL Label */ ;
      }
      while_break___32: /* CIL Label */ ;
      }
      {
      {
#line 1564
      bsW(1, 0U);
      }
#line 1561
      i ++;
      }
    }
    while_break___66: /* CIL Label */ ;
    }
    while_break___30: /* CIL Label */ ;
    }
#line 1558
    t ++;
  }
  while_break___65: /* CIL Label */ ;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 1568
  if (verbosity >= 3) {
    {
    {
#line 1569
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"code lengths %d, ",
            bytesOut - (unsigned int )nBytes);
    }
    }
  }
#line 1572
  nBytes = (int )bytesOut;
#line 1573
  selCtr = 0;
#line 1574
  gs = 0;
  {
  {
#line 1575
  while (1) {
    while_continue___69: /* CIL Label */ ;
    while_continue___33: /* CIL Label */ ;
#line 1576
    if (gs >= nMTF) {
#line 1576
      goto while_break___33;
    }
#line 1577
    ge = (gs + 50) - 1;
#line 1578
    if (ge >= nMTF) {
#line 1578
      ge = nMTF - 1;
    }
#line 1579
    i = gs;
    {
    {
#line 1579
    while (1) {
      while_continue___70: /* CIL Label */ ;
      while_continue___34: /* CIL Label */ ;
#line 1579
      if (! (i <= ge)) {
#line 1579
        goto while_break___34;
      }
      {
      {
#line 1583
      bsW((int )len[selector[selCtr]][*(szptr + i)], (unsigned int )code[selector[selCtr]][*(szptr + i)]);
      }
#line 1579
      i ++;
      }
    }
    while_break___70: /* CIL Label */ ;
    }
    while_break___34: /* CIL Label */ ;
    }
#line 1587
    gs = ge + 1;
#line 1588
    selCtr ++;
  }
  while_break___69: /* CIL Label */ ;
  }
  while_break___33: /* CIL Label */ ;
  }
#line 1590
  if (! (selCtr == nSelectors)) {
    {
    {
#line 1590
    panic((char *)"sendMTFValues(5)");
    }
    }
  }
#line 1592
  if (verbosity >= 3) {
    {
    {
#line 1593
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"codes %d\n",
            bytesOut - (unsigned int )nBytes);
    }
    }
  }
#line 1594
  return;
}
}
#line 1598 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void moveToFrontCodeAndSend(void) 
{ 


  {
  {
  {
#line 1600
  bsPutIntVS(24, (unsigned int )origPtr);
  }
  {
#line 1601
  generateMTFValues();
  }
  {
#line 1602
  sendMTFValues();
  }
  }
#line 1603
  return;
}
}
#line 1607 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void recvDecodingTables(void) 
{ 
  int i ;
  int j ;
  int t ;
  int nGroups ;
  int nSelectors ;
  int alphaSize ;
  int minLen ;
  int maxLen ;
  unsigned char inUse16[16] ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned char pos[6] ;
  unsigned char tmp___4 ;
  unsigned char v ;
  int curr ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;

  {
#line 1614
  i = 0;
  {
  {
#line 1614
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1614
    if (! (i < 16)) {
#line 1614
      goto while_break;
    }
    {
    {
#line 1615
    tmp = bsR(1);
    }
    }
#line 1615
    if (tmp == 1U) {
#line 1616
      inUse16[i] = (unsigned char)1;
    } else {
#line 1617
      inUse16[i] = (unsigned char)0;
    }
#line 1614
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1619
  i = 0;
  {
  {
#line 1619
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1619
    if (! (i < 256)) {
#line 1619
      goto while_break___0;
    }
#line 1619
    inUse[i] = (unsigned char)0;
#line 1619
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1621
  i = 0;
  {
  {
#line 1621
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1621
    if (! (i < 16)) {
#line 1621
      goto while_break___1;
    }
#line 1622
    if (inUse16[i]) {
#line 1623
      j = 0;
      {
      {
#line 1623
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 1623
        if (! (j < 16)) {
#line 1623
          goto while_break___2;
        }
        {
        {
#line 1624
        tmp___0 = bsR(1);
        }
        }
#line 1624
        if (tmp___0 == 1U) {
#line 1624
          inUse[i * 16 + j] = (unsigned char)1;
        }
#line 1623
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1621
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 1626
  makeMaps();
  }
#line 1627
  alphaSize = nInUse + 2;
  {
#line 1630
  tmp___1 = bsR(3);
  }
#line 1630
  nGroups = (int )tmp___1;
  {
#line 1631
  tmp___2 = bsR(15);
  }
#line 1631
  nSelectors = (int )tmp___2;
#line 1632
  i = 0;
  }
  {
  {
#line 1632
  while (1) {
    while_continue___17: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 1632
    if (! (i < nSelectors)) {
#line 1632
      goto while_break___3;
    }
#line 1633
    j = 0;
    {
    {
#line 1634
    while (1) {
      while_continue___18: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
      {
      {
#line 1634
      tmp___3 = bsR(1);
      }
      }
#line 1634
      if (! (tmp___3 == 1U)) {
#line 1634
        goto while_break___4;
      }
#line 1634
      j ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1635
    selectorMtf[i] = (unsigned char )j;
#line 1632
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1641
  v = (unsigned char)0;
  {
  {
#line 1641
  while (1) {
    while_continue___19: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 1641
    if (! ((int )v < nGroups)) {
#line 1641
      goto while_break___5;
    }
#line 1641
    pos[v] = v;
#line 1641
    v = (unsigned char )((int )v + 1);
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1643
  i = 0;
  {
  {
#line 1643
  while (1) {
    while_continue___20: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 1643
    if (! (i < nSelectors)) {
#line 1643
      goto while_break___6;
    }
#line 1644
    v = selectorMtf[i];
#line 1645
    tmp___4 = pos[v];
    {
    {
#line 1646
    while (1) {
      while_continue___21: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 1646
      if (! ((int )v > 0)) {
#line 1646
        goto while_break___7;
      }
#line 1646
      pos[v] = pos[(int )v - 1];
#line 1646
      v = (unsigned char )((int )v - 1);
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1647
    pos[0] = tmp___4;
#line 1648
    selector[i] = tmp___4;
#line 1643
    i ++;
  }
  while_break___20: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1653
  t = 0;
  {
  {
#line 1653
  while (1) {
    while_continue___22: /* CIL Label */ ;
    while_continue___8: /* CIL Label */ ;
#line 1653
    if (! (t < nGroups)) {
#line 1653
      goto while_break___8;
    }
    {
    {
#line 1654
    tmp___5 = bsR(5);
    }
#line 1654
    curr = (int )tmp___5;
#line 1655
    i = 0;
    }
    {
    {
#line 1655
    while (1) {
      while_continue___23: /* CIL Label */ ;
      while_continue___9: /* CIL Label */ ;
#line 1655
      if (! (i < alphaSize)) {
#line 1655
        goto while_break___9;
      }
      {
      {
#line 1656
      while (1) {
        while_continue___24: /* CIL Label */ ;
        while_continue___10: /* CIL Label */ ;
        {
        {
#line 1656
        tmp___7 = bsR(1);
        }
        }
#line 1656
        if (! (tmp___7 == 1U)) {
#line 1656
          goto while_break___10;
        }
        {
        {
#line 1657
        tmp___6 = bsR(1);
        }
        }
#line 1657
        if (tmp___6 == 0U) {
#line 1657
          curr ++;
        } else {
#line 1657
          curr --;
        }
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1659
      len[t][i] = (unsigned char )curr;
#line 1655
      i ++;
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1653
    t ++;
  }
  while_break___22: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1664
  t = 0;
  {
  {
#line 1664
  while (1) {
    while_continue___25: /* CIL Label */ ;
    while_continue___11: /* CIL Label */ ;
#line 1664
    if (! (t < nGroups)) {
#line 1664
      goto while_break___11;
    }
#line 1665
    minLen = 32;
#line 1666
    maxLen = 0;
#line 1667
    i = 0;
    {
    {
#line 1667
    while (1) {
      while_continue___26: /* CIL Label */ ;
      while_continue___12: /* CIL Label */ ;
#line 1667
      if (! (i < alphaSize)) {
#line 1667
        goto while_break___12;
      }
#line 1668
      if ((int )len[t][i] > maxLen) {
#line 1668
        maxLen = (int )len[t][i];
      }
#line 1669
      if ((int )len[t][i] < minLen) {
#line 1669
        minLen = (int )len[t][i];
      }
#line 1667
      i ++;
    }
    while_break___26: /* CIL Label */ ;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
    { 
#line 1671
    hbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,
                         maxLen, alphaSize);
    }
#line 1675
    minLens[t] = minLen;
#line 1664
    t ++;
    }
  }
  while_break___25: /* CIL Label */ ;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1677
  return;
}
}
#line 1701 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void getAndMoveToFrontDecode(void) 
{ 
  unsigned char yy[256] ;
  int i ;
  int j ;
  int nextSym ;
  int limitLast ;
  int EOB ;
  int groupNo ;
  int groupPos ;
  unsigned int tmp ;
  int zt ;
  int zn ;
  int zvec ;
  int zj ;
  unsigned int tmp___0 ;
  int zzi ;
  int tmp___1 ;
  unsigned char ch ;
  int s ;
  int N ;
  int zt___0 ;
  int zn___0 ;
  int zvec___0 ;
  int zj___0 ;
  unsigned int tmp___2 ;
  int zzi___0 ;
  int tmp___3 ;
  unsigned char tmp___4 ;
  int zt___1 ;
  int zn___1 ;
  int zvec___1 ;
  int zj___1 ;
  unsigned int tmp___5 ;
  int zzi___1 ;
  int tmp___6 ;
  void *__cil_tmp35 ;

  {
  {
#line 1707
  limitLast = 100000 * blockSize100k;
  {
#line 1708
  tmp = bsGetIntVS(24U);
  }
#line 1708
  origPtr = (int )tmp;
  {
#line 1710
  recvDecodingTables();
  }
#line 1711
  EOB = nInUse + 1;
#line 1712
  groupNo = -1;
#line 1713
  groupPos = 0;
#line 1721
  i = 0;
  }
  {
  {
#line 1721
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1721
    if (! (i <= 255)) {
#line 1721
      goto while_break;
    }
#line 1721
    unzftab[i] = 0;
#line 1721
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1723
  i = 0;
  {
  {
#line 1723
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1723
    if (! (i <= 255)) {
#line 1723
      goto while_break___0;
    }
#line 1723
    yy[i] = (unsigned char )i;
#line 1723
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1725
  last = -1;
#line 1727
  if (groupPos == 0) {
#line 1727
    groupNo ++;
#line 1727
    groupPos = 50;
  }
  {
#line 1727
  groupPos --;
#line 1727
  zt = (int )selector[groupNo];
#line 1727
  zn = minLens[zt];
  {
#line 1727
  tmp___0 = bsR(zn);
  }
#line 1727
  zvec = (int )tmp___0;
  }
  {
  {
#line 1727
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1727
    if (! (zvec > limit[zt][zn])) {
#line 1727
      goto while_break___1;
    }
#line 1727
    zn ++;
    {
    {
#line 1727
    while (1) {
      while_continue___16: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 1727
      if (! (bsLive < 1)) {
#line 1727
        goto while_break___2;
      }
      {
      {
#line 1727
      tmp___1 = spec_getc(bsStream);
      }
#line 1727
      zzi = tmp___1;
      }
#line 1727
      if (zzi == -1) {
        {
        {
#line 1727
        compressedStreamEOF();
        }
        }
      }
#line 1727
      bsBuff = (unsigned int )((long )(bsBuff << 8) | ((long )zzi & 255L));
#line 1727
      bsLive += 8;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1727
    zj = (int )((bsBuff >> (bsLive - 1)) & 1U);
#line 1727
    bsLive --;
#line 1727
    zvec = (zvec << 1) | zj;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1727
  nextSym = perm[zt][zvec - base[zt][zn]];
  {
  {
#line 1729
  while (1) {
    while_continue___17: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 1731
    if (nextSym == EOB) {
#line 1731
      goto while_break___3;
    }
#line 1733
    if (nextSym == 0) {
#line 1733
      goto _L;
    } else
#line 1733
    if (nextSym == 1) {
      _L: /* CIL Label */ 
#line 1735
      s = -1;
#line 1736
      N = 1;
      {
      {
#line 1737
      while (1) {
        while_continue___18: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 1738
        if (nextSym == 0) {
#line 1738
          s += N;
        } else
#line 1739
        if (nextSym == 1) {
#line 1739
          s += 2 * N;
        }
#line 1740
        N *= 2;
#line 1741
        if (groupPos == 0) {
#line 1741
          groupNo ++;
#line 1741
          groupPos = 50;
        }
        {
#line 1741
        groupPos --;
#line 1741
        zt___0 = (int )selector[groupNo];
#line 1741
        zn___0 = minLens[zt___0];
        {
#line 1741
        tmp___2 = bsR(zn___0);
        }
#line 1741
        zvec___0 = (int )tmp___2;
        }
        {
        {
#line 1741
        while (1) {
          while_continue___19: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 1741
          if (! (zvec___0 > limit[zt___0][zn___0])) {
#line 1741
            goto while_break___5;
          }
#line 1741
          zn___0 ++;
          {
          {
#line 1741
          while (1) {
            while_continue___20: /* CIL Label */ ;
            while_continue___6: /* CIL Label */ ;
#line 1741
            if (! (bsLive < 1)) {
#line 1741
              goto while_break___6;
            }
            {
            {
#line 1741
            tmp___3 = spec_getc(bsStream);
            }
#line 1741
            zzi___0 = tmp___3;
            }
#line 1741
            if (zzi___0 == -1) {
              {
              {
#line 1741
              compressedStreamEOF();
              }
              }
            }
#line 1741
            bsBuff = (unsigned int )((long )(bsBuff << 8) | ((long )zzi___0 & 255L));
#line 1741
            bsLive += 8;
          }
          while_break___20: /* CIL Label */ ;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1741
          zj___0 = (int )((bsBuff >> (bsLive - 1)) & 1U);
#line 1741
          bsLive --;
#line 1741
          zvec___0 = (zvec___0 << 1) | zj___0;
        }
        while_break___19: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1741
        nextSym = perm[zt___0][zvec___0 - base[zt___0][zn___0]];
#line 1737
        if (! (nextSym == 0)) {
#line 1737
          if (! (nextSym == 1)) {
#line 1737
            goto while_break___4;
          }
        }
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1745
      s ++;
#line 1746
      ch = seqToUnseq[yy[0]];
#line 1747
      unzftab[ch] += s;
#line 1749
      if (smallMode) {
        {
        {
#line 1750
        while (1) {
          while_continue___21: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 1750
          if (! (s > 0)) {
#line 1750
            goto while_break___7;
          }
#line 1751
          last ++;
#line 1752
          *(ll16 + last) = (unsigned short )ch;
#line 1753
          s --;
        }
        while_break___21: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 1756
        while (1) {
          while_continue___22: /* CIL Label */ ;
          while_continue___8: /* CIL Label */ ;
#line 1756
          if (! (s > 0)) {
#line 1756
            goto while_break___8;
          }
#line 1757
          last ++;
#line 1758
          *(ll8 + last) = ch;
#line 1759
          s --;
        }
        while_break___22: /* CIL Label */ ;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 1762
      if (last >= limitLast) {
        {
        {
#line 1762
        blockOverrun();
        }
        }
      }
#line 1763
      goto while_continue___3;
    } else {
#line 1768
      last ++;
#line 1768
      if (last >= limitLast) {
        {
        {
#line 1768
        blockOverrun();
        }
        }
      }
#line 1770
      tmp___4 = yy[nextSym - 1];
#line 1771
      (unzftab[seqToUnseq[tmp___4]]) ++;
#line 1772
      if (smallMode) {
#line 1773
        *(ll16 + last) = (unsigned short )seqToUnseq[tmp___4];
      } else {
#line 1774
        *(ll8 + last) = seqToUnseq[tmp___4];
      }
#line 1783
      j = nextSym - 1;
      {
      {
#line 1784
      while (1) {
        while_continue___23: /* CIL Label */ ;
        while_continue___9: /* CIL Label */ ;
#line 1784
        if (! (j > 3)) {
#line 1784
          goto while_break___9;
        }
#line 1785
        yy[j] = yy[j - 1];
#line 1786
        yy[j - 1] = yy[j - 2];
#line 1787
        yy[j - 2] = yy[j - 3];
#line 1788
        yy[j - 3] = yy[j - 4];
#line 1784
        j -= 4;
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
      {
#line 1790
      while (1) {
        while_continue___24: /* CIL Label */ ;
        while_continue___10: /* CIL Label */ ;
#line 1790
        if (! (j > 0)) {
#line 1790
          goto while_break___10;
        }
#line 1790
        yy[j] = yy[j - 1];
#line 1790
        j --;
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1792
      yy[0] = tmp___4;
#line 1793
      if (groupPos == 0) {
#line 1793
        groupNo ++;
#line 1793
        groupPos = 50;
      }
      {
#line 1793
      groupPos --;
#line 1793
      zt___1 = (int )selector[groupNo];
#line 1793
      zn___1 = minLens[zt___1];
      {
#line 1793
      tmp___5 = bsR(zn___1);
      }
#line 1793
      zvec___1 = (int )tmp___5;
      }
      {
      {
#line 1793
      while (1) {
        while_continue___25: /* CIL Label */ ;
        while_continue___11: /* CIL Label */ ;
#line 1793
        if (! (zvec___1 > limit[zt___1][zn___1])) {
#line 1793
          goto while_break___11;
        }
#line 1793
        zn___1 ++;
        {
        {
#line 1793
        while (1) {
          while_continue___26: /* CIL Label */ ;
          while_continue___12: /* CIL Label */ ;
#line 1793
          if (! (bsLive < 1)) {
#line 1793
            goto while_break___12;
          }
          {
          {
#line 1793
          tmp___6 = spec_getc(bsStream);
          }
#line 1793
          zzi___1 = tmp___6;
          }
#line 1793
          if (zzi___1 == -1) {
            {
            {
#line 1793
            compressedStreamEOF();
            }
            }
          }
#line 1793
          bsBuff = (unsigned int )((long )(bsBuff << 8) | ((long )zzi___1 & 255L));
#line 1793
          bsLive += 8;
        }
        while_break___26: /* CIL Label */ ;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1793
        zj___1 = (int )((bsBuff >> (bsLive - 1)) & 1U);
#line 1793
        bsLive --;
#line 1793
        zvec___1 = (zvec___1 << 1) | zj___1;
      }
      while_break___25: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1793
      nextSym = perm[zt___1][zvec___1 - base[zt___1][zn___1]];
#line 1794
      goto while_continue___3;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1797
  return;
}
}
#line 1814 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char fullGtU(int i1 , int i2 ) 
{ 
  int k ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned short s1 ;
  unsigned short s2 ;

  {
#line 1828
  c1 = *(block + i1);
#line 1829
  c2 = *(block + i2);
#line 1830
  if ((int )c1 != (int )c2) {
#line 1830
    return ((unsigned char )((int )c1 > (int )c2));
  }
#line 1831
  i1 ++;
#line 1831
  i2 ++;
#line 1833
  c1 = *(block + i1);
#line 1834
  c2 = *(block + i2);
#line 1835
  if ((int )c1 != (int )c2) {
#line 1835
    return ((unsigned char )((int )c1 > (int )c2));
  }
#line 1836
  i1 ++;
#line 1836
  i2 ++;
#line 1838
  c1 = *(block + i1);
#line 1839
  c2 = *(block + i2);
#line 1840
  if ((int )c1 != (int )c2) {
#line 1840
    return ((unsigned char )((int )c1 > (int )c2));
  }
#line 1841
  i1 ++;
#line 1841
  i2 ++;
#line 1843
  c1 = *(block + i1);
#line 1844
  c2 = *(block + i2);
#line 1845
  if ((int )c1 != (int )c2) {
#line 1845
    return ((unsigned char )((int )c1 > (int )c2));
  }
#line 1846
  i1 ++;
#line 1846
  i2 ++;
#line 1848
  c1 = *(block + i1);
#line 1849
  c2 = *(block + i2);
#line 1850
  if ((int )c1 != (int )c2) {
#line 1850
    return ((unsigned char )((int )c1 > (int )c2));
  }
#line 1851
  i1 ++;
#line 1851
  i2 ++;
#line 1853
  c1 = *(block + i1);
#line 1854
  c2 = *(block + i2);
#line 1855
  if ((int )c1 != (int )c2) {
#line 1855
    return ((unsigned char )((int )c1 > (int )c2));
  }
#line 1856
  i1 ++;
#line 1856
  i2 ++;
#line 1858
  k = last + 1;
  {
  {
#line 1860
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1862
    c1 = *(block + i1);
#line 1863
    c2 = *(block + i2);
#line 1864
    if ((int )c1 != (int )c2) {
#line 1864
      return ((unsigned char )((int )c1 > (int )c2));
    }
#line 1865
    s1 = *(quadrant + i1);
#line 1866
    s2 = *(quadrant + i2);
#line 1867
    if ((int )s1 != (int )s2) {
#line 1867
      return ((unsigned char )((int )s1 > (int )s2));
    }
#line 1868
    i1 ++;
#line 1868
    i2 ++;
#line 1870
    c1 = *(block + i1);
#line 1871
    c2 = *(block + i2);
#line 1872
    if ((int )c1 != (int )c2) {
#line 1872
      return ((unsigned char )((int )c1 > (int )c2));
    }
#line 1873
    s1 = *(quadrant + i1);
#line 1874
    s2 = *(quadrant + i2);
#line 1875
    if ((int )s1 != (int )s2) {
#line 1875
      return ((unsigned char )((int )s1 > (int )s2));
    }
#line 1876
    i1 ++;
#line 1876
    i2 ++;
#line 1878
    c1 = *(block + i1);
#line 1879
    c2 = *(block + i2);
#line 1880
    if ((int )c1 != (int )c2) {
#line 1880
      return ((unsigned char )((int )c1 > (int )c2));
    }
#line 1881
    s1 = *(quadrant + i1);
#line 1882
    s2 = *(quadrant + i2);
#line 1883
    if ((int )s1 != (int )s2) {
#line 1883
      return ((unsigned char )((int )s1 > (int )s2));
    }
#line 1884
    i1 ++;
#line 1884
    i2 ++;
#line 1886
    c1 = *(block + i1);
#line 1887
    c2 = *(block + i2);
#line 1888
    if ((int )c1 != (int )c2) {
#line 1888
      return ((unsigned char )((int )c1 > (int )c2));
    }
#line 1889
    s1 = *(quadrant + i1);
#line 1890
    s2 = *(quadrant + i2);
#line 1891
    if ((int )s1 != (int )s2) {
#line 1891
      return ((unsigned char )((int )s1 > (int )s2));
    }
#line 1892
    i1 ++;
#line 1892
    i2 ++;
#line 1894
    if (i1 > last) {
#line 1894
      i1 -= last;
#line 1894
      i1 --;
    }
#line 1895
    if (i2 > last) {
#line 1895
      i2 -= last;
#line 1895
      i2 --;
    }
#line 1897
    k -= 4;
#line 1898
    workDone ++;
#line 1860
    if (! (k >= 0)) {
#line 1860
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1902
  return ((unsigned char)0);
}
}
#line 1912 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int incs[14]  = 
#line 1912
  {      1,      4,      13,      40, 
        121,      364,      1093,      3280, 
        9841,      29524,      88573,      265720, 
        797161,      2391484};
#line 1916 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void simpleSort(int lo , int hi , int d ) 
{ 
  int i ;
  int j ;
  int h ;
  int bigN ;
  int hp ;
  int v ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  char *__cil_tmp13 ;

  {
#line 1921
  bigN = (hi - lo) + 1;
#line 1922
  if (bigN < 2) {
#line 1922
    return;
  }
#line 1924
  hp = 0;
  {
  {
#line 1925
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1925
    if (! (incs[hp] < bigN)) {
#line 1925
      goto while_break;
    }
#line 1925
    hp ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1926
  hp --;
  {
  {
#line 1928
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1928
    if (! (hp >= 0)) {
#line 1928
      goto while_break___0;
    }
#line 1929
    h = incs[hp];
#line 1930
    if (verbosity >= 5) {
      {
      {
#line 1931
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"          shell increment %d\n",
              h);
      }
      }
    }
#line 1933
    i = lo + h;
    {
    {
#line 1934
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1937
      if (i > hi) {
#line 1937
        goto while_break___1;
      }
#line 1938
      v = *(zptr + i);
#line 1939
      j = i;
      {
      {
#line 1940
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
        {
        {
#line 1940
        tmp = fullGtU(*(zptr + (j - h)) + d, v + d);
        }
        }
#line 1940
        if (! tmp) {
#line 1940
          goto while_break___2;
        }
#line 1941
        *(zptr + j) = *(zptr + (j - h));
#line 1942
        j -= h;
#line 1943
        if (j <= (lo + h) - 1) {
#line 1943
          goto while_break___2;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1945
      *(zptr + j) = v;
#line 1946
      i ++;
#line 1949
      if (i > hi) {
#line 1949
        goto while_break___1;
      }
#line 1950
      v = *(zptr + i);
#line 1951
      j = i;
      {
      {
#line 1952
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
        {
        {
#line 1952
        tmp___0 = fullGtU(*(zptr + (j - h)) + d, v + d);
        }
        }
#line 1952
        if (! tmp___0) {
#line 1952
          goto while_break___3;
        }
#line 1953
        *(zptr + j) = *(zptr + (j - h));
#line 1954
        j -= h;
#line 1955
        if (j <= (lo + h) - 1) {
#line 1955
          goto while_break___3;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1957
      *(zptr + j) = v;
#line 1958
      i ++;
#line 1961
      if (i > hi) {
#line 1961
        goto while_break___1;
      }
#line 1962
      v = *(zptr + i);
#line 1963
      j = i;
      {
      {
#line 1964
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
        {
        {
#line 1964
        tmp___1 = fullGtU(*(zptr + (j - h)) + d, v + d);
        }
        }
#line 1964
        if (! tmp___1) {
#line 1964
          goto while_break___4;
        }
#line 1965
        *(zptr + j) = *(zptr + (j - h));
#line 1966
        j -= h;
#line 1967
        if (j <= (lo + h) - 1) {
#line 1967
          goto while_break___4;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1969
      *(zptr + j) = v;
#line 1970
      i ++;
#line 1972
      if (workDone > workLimit) {
#line 1972
        if (firstAttempt) {
#line 1972
          return;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1928
    hp --;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1975
  return;
}
}
#line 1990 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void vswap(int p1 , int p2 , int n ) 
{ 
  int tmp ;

  {
  {
  {
#line 1992
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1992
    if (! (n > 0)) {
#line 1992
      goto while_break;
    }
#line 1993
    tmp = *(zptr + p1);
#line 1993
    *(zptr + p1) = *(zptr + p2);
#line 1993
    *(zptr + p2) = tmp;
#line 1994
    p1 ++;
#line 1994
    p2 ++;
#line 1994
    n --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1996
  return;
}
}
#line 1998 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char med3(unsigned char a , unsigned char b , unsigned char c ) 
{ 
  unsigned char t ;

  {
#line 2001
  if ((int )a > (int )b) {
#line 2001
    t = a;
#line 2001
    a = b;
#line 2001
    b = t;
  }
#line 2002
  if ((int )b > (int )c) {
#line 2002
    t = b;
#line 2002
    b = c;
#line 2002
    c = t;
  }
#line 2003
  if ((int )a > (int )b) {
#line 2003
    b = a;
  }
#line 2004
  return (b);
}
}
#line 2038 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void qSort3(int loSt , int hiSt , int dSt ) 
{ 
  int unLo ;
  int unHi ;
  int ltLo ;
  int gtHi ;
  int med ;
  int n ;
  int m ;
  int sp ;
  int lo ;
  int hi ;
  int d ;
  StackElem stack[1000] ;
  unsigned char tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 2044
  sp = 0;
#line 2045
  stack[sp].ll = loSt;
#line 2045
  stack[sp].hh = hiSt;
#line 2045
  stack[sp].dd = dSt;
#line 2045
  sp ++;
  {
  {
#line 2047
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2047
    if (! (sp > 0)) {
#line 2047
      goto while_break;
    }
#line 2049
    if (sp >= 1000) {
      {
      {
#line 2049
      panic((char *)"stack overflow in qSort3");
      }
      }
    }
#line 2051
    sp --;
#line 2051
    lo = stack[sp].ll;
#line 2051
    hi = stack[sp].hh;
#line 2051
    d = stack[sp].dd;
#line 2053
    if (hi - lo < 20) {
#line 2053
      goto _L;
    } else
#line 2053
    if (d > 10) {
      _L: /* CIL Label */ 
      {
      {
#line 2054
      simpleSort(lo, hi, d);
      }
      }
#line 2055
      if (workDone > workLimit) {
#line 2055
        if (firstAttempt) {
#line 2055
          return;
        }
      }
#line 2056
      goto while_continue;
    }
    {
    {
#line 2059
    tmp = med3(*(block + (*(zptr + lo) + d)), *(block + (*(zptr + hi) + d)), *(block + (*(zptr + ((lo + hi) >> 1)) + d)));
    }
#line 2059
    med = (int )tmp;
#line 2063
    ltLo = lo;
#line 2063
    unLo = ltLo;
#line 2064
    gtHi = hi;
#line 2064
    unHi = gtHi;
    }
    {
    {
#line 2066
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 2067
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 2068
        if (unLo > unHi) {
#line 2068
          goto while_break___1;
        }
#line 2069
        n = (int )*(block + (*(zptr + unLo) + d)) - med;
#line 2070
        if (n == 0) {
#line 2070
          tmp___0 = *(zptr + unLo);
#line 2070
          *(zptr + unLo) = *(zptr + ltLo);
#line 2070
          *(zptr + ltLo) = tmp___0;
#line 2070
          ltLo ++;
#line 2070
          unLo ++;
#line 2070
          goto while_continue___1;
        }
#line 2071
        if (n > 0) {
#line 2071
          goto while_break___1;
        }
#line 2072
        unLo ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 2074
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 2075
        if (unLo > unHi) {
#line 2075
          goto while_break___2;
        }
#line 2076
        n = (int )*(block + (*(zptr + unHi) + d)) - med;
#line 2077
        if (n == 0) {
#line 2077
          tmp___1 = *(zptr + unHi);
#line 2077
          *(zptr + unHi) = *(zptr + gtHi);
#line 2077
          *(zptr + gtHi) = tmp___1;
#line 2077
          gtHi --;
#line 2077
          unHi --;
#line 2077
          goto while_continue___2;
        }
#line 2078
        if (n < 0) {
#line 2078
          goto while_break___2;
        }
#line 2079
        unHi --;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2081
      if (unLo > unHi) {
#line 2081
        goto while_break___0;
      }
#line 2082
      tmp___2 = *(zptr + unLo);
#line 2082
      *(zptr + unLo) = *(zptr + unHi);
#line 2082
      *(zptr + unHi) = tmp___2;
#line 2082
      unLo ++;
#line 2082
      unHi --;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2088
    if (gtHi < ltLo) {
#line 2089
      stack[sp].ll = lo;
#line 2089
      stack[sp].hh = hi;
#line 2089
      stack[sp].dd = d + 1;
#line 2089
      sp ++;
#line 2090
      goto while_continue;
    }
#line 2093
    if (ltLo - lo < unLo - ltLo) {
#line 2093
      n = ltLo - lo;
    } else {
#line 2093
      n = unLo - ltLo;
    }
    {
    {
#line 2093
    vswap(lo, unLo - n, n);
    }
    }
#line 2094
    if (hi - gtHi < gtHi - unHi) {
#line 2094
      m = hi - gtHi;
    } else {
#line 2094
      m = gtHi - unHi;
    }
    {
    {
#line 2094
    vswap(unLo, (hi - m) + 1, m);
    }
#line 2096
    n = ((lo + unLo) - ltLo) - 1;
#line 2097
    m = (hi - (gtHi - unHi)) + 1;
#line 2099
    stack[sp].ll = lo;
#line 2099
    stack[sp].hh = n;
#line 2099
    stack[sp].dd = d;
#line 2099
    sp ++;
#line 2100
    stack[sp].ll = n + 1;
#line 2100
    stack[sp].hh = m - 1;
#line 2100
    stack[sp].dd = d + 1;
#line 2100
    sp ++;
#line 2101
    stack[sp].ll = m;
#line 2101
    stack[sp].hh = hi;
#line 2101
    stack[sp].dd = d;
#line 2101
    sp ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2103
  return;
}
}
#line 2113 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void sortIt(void) 
{ 
  int i ;
  int j ;
  int ss ;
  int sb ;
  int runningOrder[256] ;
  int copy[256] ;
  unsigned char bigDone[256] ;
  unsigned char c1 ;
  unsigned char c2 ;
  int numQSorted ;
  int vv ;
  int h ;
  int lo ;
  int hi ;
  int bbStart ;
  int bbSize ;
  int shifts ;
  int a2update ;
  unsigned short qVal ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 2128
  if (verbosity >= 4) {
    {
    {
#line 2128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        sort initialise ...\n");
    }
    }
  }
#line 2129
  i = 0;
  {
  {
#line 2129
  while (1) {
    while_continue___19: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2129
    if (! (i < 20)) {
#line 2129
      goto while_break;
    }
#line 2130
    *(block + ((last + i) + 1)) = *(block + i % (last + 1));
#line 2129
    i ++;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2131
  i = 0;
  {
  {
#line 2131
  while (1) {
    while_continue___20: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2131
    if (! (i <= last + 20)) {
#line 2131
      goto while_break___0;
    }
#line 2132
    *(quadrant + i) = (unsigned short)0;
#line 2131
    i ++;
  }
  while_break___20: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2134
  *(block + -1) = *(block + last);
#line 2136
  if (last < 4000) {
#line 2142
    if (verbosity >= 4) {
      {
      {
#line 2142
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        simpleSort ...\n");
      }
      }
    }
#line 2143
    i = 0;
    {
    {
#line 2143
    while (1) {
      while_continue___21: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 2143
      if (! (i <= last)) {
#line 2143
        goto while_break___1;
      }
#line 2143
      *(zptr + i) = i;
#line 2143
      i ++;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2144
    firstAttempt = (unsigned char)0;
#line 2145
    workLimit = 0;
#line 2145
    workDone = workLimit;
    {
#line 2146
    simpleSort(0, last, 0);
    }
    }
#line 2147
    if (verbosity >= 4) {
      {
      {
#line 2147
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        simpleSort done.\n");
      }
      }
    }
  } else {
#line 2151
    numQSorted = 0;
#line 2152
    i = 0;
    {
    {
#line 2152
    while (1) {
      while_continue___22: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 2152
      if (! (i <= 255)) {
#line 2152
        goto while_break___2;
      }
#line 2152
      bigDone[i] = (unsigned char)0;
#line 2152
      i ++;
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2154
    if (verbosity >= 4) {
      {
      {
#line 2154
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        bucket sorting ...\n");
      }
      }
    }
#line 2156
    i = 0;
    {
    {
#line 2156
    while (1) {
      while_continue___23: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 2156
      if (! (i <= 65536)) {
#line 2156
        goto while_break___3;
      }
#line 2156
      *(ftab + i) = 0;
#line 2156
      i ++;
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 2158
    c1 = *(block + -1);
#line 2159
    i = 0;
    {
    {
#line 2159
    while (1) {
      while_continue___24: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 2159
      if (! (i <= last)) {
#line 2159
        goto while_break___4;
      }
#line 2160
      c2 = *(block + i);
#line 2161
      (*(ftab + (((int )c1 << 8) + (int )c2))) ++;
#line 2162
      c1 = c2;
#line 2159
      i ++;
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2165
    i = 1;
    {
    {
#line 2165
    while (1) {
      while_continue___25: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 2165
      if (! (i <= 65536)) {
#line 2165
        goto while_break___5;
      }
#line 2165
      *(ftab + i) += *(ftab + (i - 1));
#line 2165
      i ++;
    }
    while_break___25: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2167
    c1 = *(block + 0);
#line 2168
    i = 0;
    {
    {
#line 2168
    while (1) {
      while_continue___26: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 2168
      if (! (i < last)) {
#line 2168
        goto while_break___6;
      }
#line 2169
      c2 = *(block + (i + 1));
#line 2170
      j = ((int )c1 << 8) + (int )c2;
#line 2171
      c1 = c2;
#line 2172
      (*(ftab + j)) --;
#line 2173
      *(zptr + *(ftab + j)) = i;
#line 2168
      i ++;
    }
    while_break___26: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2175
    j = ((int )*(block + last) << 8) + (int )*(block + 0);
#line 2176
    (*(ftab + j)) --;
#line 2177
    *(zptr + *(ftab + j)) = last;
#line 2185
    i = 0;
    {
    {
#line 2185
    while (1) {
      while_continue___27: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 2185
      if (! (i <= 255)) {
#line 2185
        goto while_break___7;
      }
#line 2185
      runningOrder[i] = i;
#line 2185
      i ++;
    }
    while_break___27: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2189
    h = 1;
    {
    {
#line 2190
    while (1) {
      while_continue___28: /* CIL Label */ ;
      while_continue___8: /* CIL Label */ ;
#line 2190
      h = 3 * h + 1;
#line 2190
      if (! (h <= 256)) {
#line 2190
        goto while_break___8;
      }
    }
    while_break___28: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
    {
#line 2191
    while (1) {
      while_continue___29: /* CIL Label */ ;
      while_continue___9: /* CIL Label */ ;
#line 2192
      h /= 3;
#line 2193
      i = h;
      {
      {
#line 2193
      while (1) {
        while_continue___30: /* CIL Label */ ;
        while_continue___10: /* CIL Label */ ;
#line 2193
        if (! (i <= 255)) {
#line 2193
          goto while_break___10;
        }
#line 2194
        vv = runningOrder[i];
#line 2195
        j = i;
        {
        {
#line 2196
        while (1) {
          while_continue___31: /* CIL Label */ ;
          while_continue___11: /* CIL Label */ ;
#line 2196
          if (! (*(ftab + ((runningOrder[j - h] + 1) << 8)) - *(ftab + (runningOrder[j - h] << 8)) > *(ftab + ((vv + 1) << 8)) - *(ftab + (vv << 8)))) {
#line 2196
            goto while_break___11;
          }
#line 2197
          runningOrder[j] = runningOrder[j - h];
#line 2198
          j -= h;
#line 2199
          if (j <= h - 1) {
#line 2199
            goto zero;
          }
        }
        while_break___31: /* CIL Label */ ;
        }
        while_break___11: /* CIL Label */ ;
        }
        zero: 
#line 2202
        runningOrder[j] = vv;
#line 2193
        i ++;
      }
      while_break___30: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 2191
      if (! (h != 1)) {
#line 2191
        goto while_break___9;
      }
    }
    while_break___29: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2211
    i = 0;
    {
    {
#line 2211
    while (1) {
      while_continue___32: /* CIL Label */ ;
      while_continue___12: /* CIL Label */ ;
#line 2211
      if (! (i <= 255)) {
#line 2211
        goto while_break___12;
      }
#line 2216
      ss = runningOrder[i];
#line 2225
      j = 0;
      {
      {
#line 2225
      while (1) {
        while_continue___33: /* CIL Label */ ;
        while_continue___13: /* CIL Label */ ;
#line 2225
        if (! (j <= 255)) {
#line 2225
          goto while_break___13;
        }
#line 2226
        sb = (ss << 8) + j;
#line 2227
        if (! (*(ftab + sb) & (1 << 21))) {
#line 2228
          lo = *(ftab + sb) & ~ (1 << 21);
#line 2229
          hi = (*(ftab + (sb + 1)) & ~ (1 << 21)) - 1;
#line 2230
          if (hi > lo) {
#line 2231
            if (verbosity >= 4) {
              {
              {
#line 2232
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        qsort [0x%x, 0x%x]   done %d   this %d\n",
                      ss, j, numQSorted, (hi - lo) + 1);
              }
              }
            }
            {
            {
#line 2235
            qSort3(lo, hi, 2);
            }
#line 2236
            numQSorted += (hi - lo) + 1;
            }
#line 2237
            if (workDone > workLimit) {
#line 2237
              if (firstAttempt) {
#line 2237
                return;
              }
            }
          }
#line 2239
          *(ftab + sb) |= 1 << 21;
        }
#line 2225
        j ++;
      }
      while_break___33: /* CIL Label */ ;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 2251
      bigDone[ss] = (unsigned char)1;
#line 2253
      if (i < 255) {
#line 2254
        bbStart = *(ftab + (ss << 8)) & ~ (1 << 21);
#line 2255
        bbSize = (*(ftab + ((ss + 1) << 8)) & ~ (1 << 21)) - bbStart;
#line 2256
        shifts = 0;
        {
        {
#line 2258
        while (1) {
          while_continue___34: /* CIL Label */ ;
          while_continue___14: /* CIL Label */ ;
#line 2258
          if (! (bbSize >> shifts > 65534)) {
#line 2258
            goto while_break___14;
          }
#line 2258
          shifts ++;
        }
        while_break___34: /* CIL Label */ ;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 2260
        j = 0;
        {
        {
#line 2260
        while (1) {
          while_continue___35: /* CIL Label */ ;
          while_continue___15: /* CIL Label */ ;
#line 2260
          if (! (j < bbSize)) {
#line 2260
            goto while_break___15;
          }
#line 2261
          a2update = *(zptr + (bbStart + j));
#line 2262
          qVal = (unsigned short )(j >> shifts);
#line 2263
          *(quadrant + a2update) = qVal;
#line 2264
          if (a2update < 20) {
#line 2265
            *(quadrant + ((a2update + last) + 1)) = qVal;
          }
#line 2260
          j ++;
        }
        while_break___35: /* CIL Label */ ;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 2268
        if (! ((bbSize - 1) >> shifts <= 65535)) {
          {
          {
#line 2268
          panic((char *)"sortIt");
          }
          }
        }
      }
#line 2275
      j = 0;
      {
      {
#line 2275
      while (1) {
        while_continue___36: /* CIL Label */ ;
        while_continue___16: /* CIL Label */ ;
#line 2275
        if (! (j <= 255)) {
#line 2275
          goto while_break___16;
        }
#line 2276
        copy[j] = *(ftab + ((j << 8) + ss)) & ~ (1 << 21);
#line 2275
        j ++;
      }
      while_break___36: /* CIL Label */ ;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 2278
      j = *(ftab + (ss << 8)) & ~ (1 << 21);
      {
      {
#line 2278
      while (1) {
        while_continue___37: /* CIL Label */ ;
        while_continue___17: /* CIL Label */ ;
#line 2278
        if (! (j < (*(ftab + ((ss + 1) << 8)) & ~ (1 << 21)))) {
#line 2278
          goto while_break___17;
        }
#line 2281
        c1 = *(block + (*(zptr + j) - 1));
#line 2282
        if (! bigDone[c1]) {
#line 2283
          if (*(zptr + j) == 0) {
#line 2283
            *(zptr + copy[c1]) = last;
          } else {
#line 2283
            *(zptr + copy[c1]) = *(zptr + j) - 1;
          }
#line 2284
          (copy[c1]) ++;
        }
#line 2278
        j ++;
      }
      while_break___37: /* CIL Label */ ;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 2288
      j = 0;
      {
      {
#line 2288
      while (1) {
        while_continue___38: /* CIL Label */ ;
        while_continue___18: /* CIL Label */ ;
#line 2288
        if (! (j <= 255)) {
#line 2288
          goto while_break___18;
        }
#line 2288
        *(ftab + ((j << 8) + ss)) |= 1 << 21;
#line 2288
        j ++;
      }
      while_break___38: /* CIL Label */ ;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 2211
      i ++;
    }
    while_break___32: /* CIL Label */ ;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 2290
    if (verbosity >= 4) {
      {
      {
#line 2291
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        %d pointers, %d sorted, %d scanned\n",
              last + 1, numQSorted, (last + 1) - numQSorted);
      }
      }
    }
  }
#line 2294
  return;
}
}
#line 2302 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int rNums[512]  = 
#line 2302
  {      619,      720,      127,      481, 
        931,      816,      813,      233, 
        566,      247,      985,      724, 
        205,      454,      863,      491, 
        741,      242,      949,      214, 
        733,      859,      335,      708, 
        621,      574,      73,      654, 
        730,      472,      419,      436, 
        278,      496,      867,      210, 
        399,      680,      480,      51, 
        878,      465,      811,      169, 
        869,      675,      611,      697, 
        867,      561,      862,      687, 
        507,      283,      482,      129, 
        807,      591,      733,      623, 
        150,      238,      59,      379, 
        684,      877,      625,      169, 
        643,      105,      170,      607, 
        520,      932,      727,      476, 
        693,      425,      174,      647, 
        73,      122,      335,      530, 
        442,      853,      695,      249, 
        445,      515,      909,      545, 
        703,      919,      874,      474, 
        882,      500,      594,      612, 
        641,      801,      220,      162, 
        819,      984,      589,      513, 
        495,      799,      161,      604, 
        958,      533,      221,      400, 
        386,      867,      600,      782, 
        382,      596,      414,      171, 
        516,      375,      682,      485, 
        911,      276,      98,      553, 
        163,      354,      666,      933, 
        424,      341,      533,      870, 
        227,      730,      475,      186, 
        263,      647,      537,      686, 
        600,      224,      469,      68, 
        770,      919,      190,      373, 
        294,      822,      808,      206, 
        184,      943,      795,      384, 
        383,      461,      404,      758, 
        839,      887,      715,      67, 
        618,      276,      204,      918, 
        873,      777,      604,      560, 
        951,      160,      578,      722, 
        79,      804,      96,      409, 
        713,      940,      652,      934, 
        970,      447,      318,      353, 
        859,      672,      112,      785, 
        645,      863,      803,      350, 
        139,      93,      354,      99, 
        820,      908,      609,      772, 
        154,      274,      580,      184, 
        79,      626,      630,      742, 
        653,      282,      762,      623, 
        680,      81,      927,      626, 
        789,      125,      411,      521, 
        938,      300,      821,      78, 
        343,      175,      128,      250, 
        170,      774,      972,      275, 
        999,      639,      495,      78, 
        352,      126,      857,      956, 
        358,      619,      580,      124, 
        737,      594,      701,      612, 
        669,      112,      134,      694, 
        363,      992,      809,      743, 
        168,      974,      944,      375, 
        748,      52,      600,      747, 
        642,      182,      862,      81, 
        344,      805,      988,      739, 
        511,      655,      814,      334, 
        249,      515,      897,      955, 
        664,      981,      649,      113, 
        974,      459,      893,      228, 
        433,      837,      553,      268, 
        926,      240,      102,      654, 
        459,      51,      686,      754, 
        806,      760,      493,      403, 
        415,      394,      687,      700, 
        946,      670,      656,      610, 
        738,      392,      760,      799, 
        887,      653,      978,      321, 
        576,      617,      626,      502, 
        894,      679,      243,      440, 
        680,      879,      194,      572, 
        640,      724,      926,      56, 
        204,      700,      707,      151, 
        457,      449,      797,      195, 
        791,      558,      945,      679, 
        297,      59,      87,      824, 
        713,      663,      412,      693, 
        342,      606,      134,      108, 
        571,      364,      631,      212, 
        174,      643,      304,      329, 
        343,      97,      430,      751, 
        497,      314,      983,      374, 
        822,      928,      140,      206, 
        73,      263,      980,      736, 
        876,      478,      430,      305, 
        170,      514,      364,      692, 
        829,      82,      855,      953, 
        676,      246,      369,      970, 
        294,      750,      807,      827, 
        150,      790,      288,      923, 
        804,      378,      215,      828, 
        592,      281,      565,      555, 
        710,      82,      896,      831, 
        547,      261,      524,      462, 
        293,      465,      502,      56, 
        661,      821,      976,      991, 
        658,      869,      905,      758, 
        745,      193,      768,      550, 
        608,      933,      378,      286, 
        215,      979,      792,      961, 
        61,      688,      793,      644, 
        986,      403,      106,      366, 
        905,      644,      372,      567, 
        466,      434,      645,      210, 
        389,      550,      919,      135, 
        780,      773,      635,      389, 
        707,      100,      626,      958, 
        165,      504,      920,      176, 
        193,      713,      857,      265, 
        203,      50,      668,      108, 
        645,      990,      626,      197, 
        510,      357,      358,      850, 
        858,      364,      936,      638};
#line 2378 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void randomiseBlock(void) 
{ 
  int i ;
  int rNToGo ;
  int rTPos ;
  int tmp ;

  {
#line 2381
  rNToGo = 0;
#line 2381
  rTPos = 0;
#line 2382
  i = 0;
  {
  {
#line 2382
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2382
    if (! (i < 256)) {
#line 2382
      goto while_break;
    }
#line 2382
    inUse[i] = (unsigned char)0;
#line 2382
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2384
  i = 0;
  {
  {
#line 2384
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2384
    if (! (i <= last)) {
#line 2384
      goto while_break___0;
    }
#line 2385
    if (rNToGo == 0) {
#line 2385
      rNToGo = rNums[rTPos];
#line 2385
      rTPos ++;
#line 2385
      if (rTPos == 512) {
#line 2385
        rTPos = 0;
      }
    }
#line 2385
    rNToGo --;
#line 2386
    if (rNToGo == 1) {
#line 2386
      tmp = 1;
    } else {
#line 2386
      tmp = 0;
    }
#line 2386
    *(block + i) = (unsigned char )((int )*(block + i) ^ tmp);
#line 2387
    inUse[*(block + i)] = (unsigned char)1;
#line 2384
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2389
  return;
}
}
#line 2393 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void doReversibleTransformation(void) 
{ 
  int i ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2397
  if (verbosity >= 2) {
    {
    {
#line 2397
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
    }
  }
  {
#line 2399
  workLimit = workFactor * last;
#line 2400
  workDone = 0;
#line 2401
  blockRandomised = (unsigned char)0;
#line 2402
  firstAttempt = (unsigned char)1;
  {
#line 2404
  sortIt();
  }
  }
#line 2406
  if (verbosity >= 3) {
    {
    {
#line 2407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      %d work, %d block, ratio %5.2f\n",
            workDone, last, (double )((float )workDone / (float )last));
    }
    }
  }
#line 2410
  if (workDone > workLimit) {
#line 2410
    if (firstAttempt) {
#line 2411
      if (verbosity >= 2) {
        {
        {
#line 2412
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    sorting aborted; randomising block\n");
        }
        }
      }
      {
      {
#line 2413
      randomiseBlock();
      }
#line 2414
      workDone = 0;
#line 2414
      workLimit = workDone;
#line 2415
      blockRandomised = (unsigned char)1;
#line 2416
      firstAttempt = (unsigned char)0;
      {
#line 2417
      sortIt();
      }
      }
#line 2418
      if (verbosity >= 3) {
        {
        {
#line 2419
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      %d work, %d block, ratio %f\n",
                workDone, last, (double )((float )workDone / (float )last));
        }
        }
      }
    }
  }
#line 2423
  origPtr = -1;
#line 2424
  i = 0;
  {
  {
#line 2424
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2424
    if (! (i <= last)) {
#line 2424
      goto while_break;
    }
#line 2425
    if (*(zptr + i) == 0) {
#line 2426
      origPtr = i;
#line 2426
      goto while_break;
    }
#line 2424
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2428
  if (origPtr == -1) {
    {
    {
#line 2428
    panic((char *)"doReversibleTransformation");
    }
    }
  }
#line 2429
  return;
}
}
#line 2434 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int indexIntoF(int indx , int *cftab ) 
{ 
  int nb ;
  int na ;
  int mid ;

  {
#line 2437
  nb = 0;
#line 2438
  na = 256;
  {
  {
#line 2439
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2440
    mid = (nb + na) >> 1;
#line 2441
    if (indx >= *(cftab + mid)) {
#line 2441
      nb = mid;
    } else {
#line 2441
      na = mid;
    }
#line 2439
    if (! (na - nb != 1)) {
#line 2439
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2444
  return (nb);
}
}
#line 2455 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void undoReversibleTransformation_small(int dst ) 
{ 
  int cftab[257] ;
  int cftabAlso[257] ;
  int i ;
  int j ;
  int tmp ;
  int tPos ;
  unsigned char ch ;
  int retVal ;
  int i2 ;
  int count ;
  int chPrev ;
  int ch2 ;
  unsigned int localCrc ;
  int rNToGo ;
  int rTPos ;
  int tmp___0 ;
  int j2 ;
  unsigned char z ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;

  {
#line 2471
  cftab[0] = 0;
#line 2472
  i = 1;
  {
  {
#line 2472
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2472
    if (! (i <= 256)) {
#line 2472
      goto while_break;
    }
#line 2472
    cftab[i] = unzftab[i - 1];
#line 2472
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2473
  i = 1;
  {
  {
#line 2473
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2473
    if (! (i <= 256)) {
#line 2473
      goto while_break___0;
    }
#line 2473
    cftab[i] += cftab[i - 1];
#line 2473
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2476
  i = 0;
  {
  {
#line 2476
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 2476
    if (! (i <= 256)) {
#line 2476
      goto while_break___1;
    }
#line 2476
    cftabAlso[i] = cftab[i];
#line 2476
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2479
  i = 0;
  {
  {
#line 2479
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 2479
    if (! (i <= last)) {
#line 2479
      goto while_break___2;
    }
#line 2480
    ch = (unsigned char )*(ll16 + i);
#line 2481
    *(ll16 + i) = (unsigned short )(cftabAlso[ch] & 65535);
#line 2481
    if ((i & 1) == 0) {
#line 2481
      *(ll4 + (i >> 1)) = (unsigned char )(((int )*(ll4 + (i >> 1)) & 240) | (cftabAlso[ch] >> 16));
    } else {
#line 2481
      *(ll4 + (i >> 1)) = (unsigned char )(((int )*(ll4 + (i >> 1)) & 15) | ((cftabAlso[ch] >> 16) << 4));
    }
#line 2482
    (cftabAlso[ch]) ++;
#line 2479
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2502
  i = origPtr;
#line 2503
  j = (int )((unsigned int )*(ll16 + i) | ((((unsigned int )*(ll4 + (i >> 1)) >> ((i << 2) & 4)) & 15U) << 16));
  {
  {
#line 2504
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 2505
    tmp = (int )((unsigned int )*(ll16 + j) | ((((unsigned int )*(ll4 + (j >> 1)) >> ((j << 2) & 4)) & 15U) << 16));
#line 2506
    *(ll16 + j) = (unsigned short )(i & 65535);
#line 2506
    if ((j & 1) == 0) {
#line 2506
      *(ll4 + (j >> 1)) = (unsigned char )(((int )*(ll4 + (j >> 1)) & 240) | (i >> 16));
    } else {
#line 2506
      *(ll4 + (j >> 1)) = (unsigned char )(((int )*(ll4 + (j >> 1)) & 15) | ((i >> 16) << 4));
    }
#line 2507
    i = j;
#line 2508
    j = tmp;
#line 2504
    if (! (i != origPtr)) {
#line 2504
      goto while_break___3;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2518
  tPos = origPtr;
#line 2538
  count = 0;
#line 2539
  i2 = 0;
#line 2540
  ch2 = 256;
  {
#line 2541
  localCrc = getGlobalCRC();
  }
#line 2544
  rNToGo = 0;
#line 2544
  rTPos = 0;
  }
  {
  {
#line 2545
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 2545
    if (! (i2 <= last)) {
#line 2545
      goto while_break___4;
    }
    {
#line 2546
    chPrev = ch2;
    {
#line 2547
    ch2 = indexIntoF(tPos, cftab);
    }
#line 2547
    tPos = (int )((unsigned int )*(ll16 + tPos) | ((((unsigned int )*(ll4 + (tPos >> 1)) >> ((tPos << 2) & 4)) & 15U) << 16));
    }
#line 2548
    if (blockRandomised) {
#line 2549
      if (rNToGo == 0) {
#line 2549
        rNToGo = rNums[rTPos];
#line 2549
        rTPos ++;
#line 2549
        if (rTPos == 512) {
#line 2549
          rTPos = 0;
        }
      }
#line 2549
      rNToGo --;
#line 2550
      if (rNToGo == 1) {
#line 2550
        tmp___0 = 1;
      } else {
#line 2550
        tmp___0 = 0;
      }
#line 2550
      ch2 = (int )((unsigned int )ch2 ^ (unsigned int )tmp___0);
    }
#line 2552
    i2 ++;
#line 2554
    if (dst) {
      {
      {
#line 2555
      retVal = spec_putc((unsigned char )ch2, dst);
      }
      }
    }
#line 2557
    localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
#line 2559
    if (ch2 != chPrev) {
#line 2560
      count = 1;
    } else {
#line 2562
      count ++;
#line 2563
      if (count >= 4) {
        {
        {
#line 2566
        tmp___1 = indexIntoF(tPos, cftab);
        }
#line 2566
        z = (unsigned char )tmp___1;
#line 2566
        tPos = (int )((unsigned int )*(ll16 + tPos) | ((((unsigned int )*(ll4 + (tPos >> 1)) >> ((tPos << 2) & 4)) & 15U) << 16));
        }
#line 2567
        if (blockRandomised) {
#line 2568
          if (rNToGo == 0) {
#line 2568
            rNToGo = rNums[rTPos];
#line 2568
            rTPos ++;
#line 2568
            if (rTPos == 512) {
#line 2568
              rTPos = 0;
            }
          }
#line 2568
          rNToGo --;
#line 2569
          if (rNToGo == 1) {
#line 2569
            tmp___2 = 1;
          } else {
#line 2569
            tmp___2 = 0;
          }
#line 2569
          z = (unsigned char )((int )z ^ tmp___2);
        }
#line 2571
        j2 = 0;
        {
        {
#line 2571
        while (1) {
          while_continue___12: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 2571
          if (! (j2 < (int )z)) {
#line 2571
            goto while_break___5;
          }
#line 2572
          if (dst) {
            {
            {
#line 2572
            retVal = spec_putc((unsigned char )ch2, dst);
            }
            }
          }
#line 2573
          localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
#line 2571
          j2 ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2575
        i2 ++;
#line 2576
        count = 0;
      }
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
  {
#line 2582
  setGlobalCRC(localCrc);
  }
  }
#line 2585
  return;
}
}
#line 2598 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void undoReversibleTransformation_fast(int dst ) 
{ 
  int cftab[257] ;
  int i ;
  int tPos ;
  unsigned char ch ;
  int retVal ;
  int i2 ;
  int count ;
  int chPrev ;
  int ch2 ;
  unsigned int localCrc ;
  int rNToGo ;
  int rTPos ;
  int tmp ;
  int j2 ;
  unsigned char z ;
  int tmp___0 ;
  int j2___0 ;
  unsigned char z___0 ;
  void *__cil_tmp20 ;

  {
#line 2614
  cftab[0] = 0;
#line 2615
  i = 1;
  {
  {
#line 2615
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2615
    if (! (i <= 256)) {
#line 2615
      goto while_break;
    }
#line 2615
    cftab[i] = unzftab[i - 1];
#line 2615
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2616
  i = 1;
  {
  {
#line 2616
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2616
    if (! (i <= 256)) {
#line 2616
      goto while_break___0;
    }
#line 2616
    cftab[i] += cftab[i - 1];
#line 2616
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2619
  i = 0;
  {
  {
#line 2619
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 2619
    if (! (i <= last)) {
#line 2619
      goto while_break___1;
    }
#line 2620
    ch = *(ll8 + i);
#line 2621
    *(tt + cftab[ch]) = i;
#line 2622
    (cftab[ch]) ++;
#line 2619
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2631
  tPos = *(tt + origPtr);
#line 2647
  count = 0;
#line 2648
  i2 = 0;
#line 2649
  ch2 = 256;
  {
#line 2650
  localCrc = getGlobalCRC();
  }
  }
#line 2652
  if (blockRandomised) {
#line 2653
    rNToGo = 0;
#line 2653
    rTPos = 0;
    {
    {
#line 2654
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 2654
      if (! (i2 <= last)) {
#line 2654
        goto while_break___2;
      }
#line 2655
      chPrev = ch2;
#line 2656
      ch2 = (int )*(ll8 + tPos);
#line 2656
      tPos = *(tt + tPos);
#line 2657
      if (rNToGo == 0) {
#line 2657
        rNToGo = rNums[rTPos];
#line 2657
        rTPos ++;
#line 2657
        if (rTPos == 512) {
#line 2657
          rTPos = 0;
        }
      }
#line 2657
      rNToGo --;
#line 2658
      if (rNToGo == 1) {
#line 2658
        tmp = 1;
      } else {
#line 2658
        tmp = 0;
      }
      {
#line 2658
      ch2 = (int )((unsigned int )ch2 ^ (unsigned int )tmp);
#line 2659
      i2 ++;
      {
#line 2661
      retVal = spec_putc((unsigned char )ch2, dst);
      }
#line 2662
      localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
      }
#line 2664
      if (ch2 != chPrev) {
#line 2665
        count = 1;
      } else {
#line 2667
        count ++;
#line 2668
        if (count >= 4) {
#line 2671
          z = *(ll8 + tPos);
#line 2671
          tPos = *(tt + tPos);
#line 2672
          if (rNToGo == 0) {
#line 2672
            rNToGo = rNums[rTPos];
#line 2672
            rTPos ++;
#line 2672
            if (rTPos == 512) {
#line 2672
              rTPos = 0;
            }
          }
#line 2672
          rNToGo --;
#line 2673
          if (rNToGo == 1) {
#line 2673
            tmp___0 = 1;
          } else {
#line 2673
            tmp___0 = 0;
          }
#line 2673
          z = (unsigned char )((int )z ^ tmp___0);
#line 2674
          j2 = 0;
          {
          {
#line 2674
          while (1) {
            while_continue___10: /* CIL Label */ ;
            while_continue___3: /* CIL Label */ ;
#line 2674
            if (! (j2 < (int )z)) {
#line 2674
              goto while_break___3;
            }
            {
            {
#line 2675
            retVal = spec_putc((unsigned char )ch2, dst);
            }
#line 2676
            localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
#line 2674
            j2 ++;
            }
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2678
          i2 ++;
#line 2679
          count = 0;
        }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 2686
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 2686
      if (! (i2 <= last)) {
#line 2686
        goto while_break___4;
      }
      {
#line 2687
      chPrev = ch2;
#line 2688
      ch2 = (int )*(ll8 + tPos);
#line 2688
      tPos = *(tt + tPos);
#line 2689
      i2 ++;
      {
#line 2691
      retVal = spec_putc((unsigned char )ch2, dst);
      }
#line 2692
      localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
      }
#line 2694
      if (ch2 != chPrev) {
#line 2695
        count = 1;
      } else {
#line 2697
        count ++;
#line 2698
        if (count >= 4) {
#line 2701
          z___0 = *(ll8 + tPos);
#line 2701
          tPos = *(tt + tPos);
#line 2702
          j2___0 = 0;
          {
          {
#line 2702
          while (1) {
            while_continue___12: /* CIL Label */ ;
            while_continue___5: /* CIL Label */ ;
#line 2702
            if (! (j2___0 < (int )z___0)) {
#line 2702
              goto while_break___5;
            }
            {
            {
#line 2703
            retVal = spec_putc((unsigned char )ch2, dst);
            }
#line 2704
            localCrc = (localCrc << 8) ^ crc32Table[(localCrc >> 24) ^ (unsigned int )((unsigned char )ch2)];
#line 2702
            j2___0 ++;
            }
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 2706
          i2 ++;
#line 2707
          count = 0;
        }
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
  {
#line 2714
  setGlobalCRC(localCrc);
  }
  }
#line 2717
  return;
}
}
#line 2733 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
int getRLEpair(int src ) 
{ 
  int runLength ;
  int ch ;
  int chLatest ;
  int tmp ;
  int i ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 2741
  ch = spec_getc(src);
  }
  }
#line 2744
  if (ch == -1) {
#line 2746
    return ((1 << 16) | 257);
  }
#line 2749
  runLength = 0;
  {
  {
#line 2750
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 2751
    chLatest = spec_getc(src);
    }
#line 2752
    runLength ++;
#line 2753
    bytesIn ++;
    }
#line 2750
    if (ch == chLatest) {
#line 2750
      if (! (runLength < 255)) {
#line 2750
        goto while_break;
      }
    } else {
#line 2750
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2757
  if (chLatest != -1) {
    {
    {
#line 2758
    tmp = spec_ungetc((unsigned char )chLatest, src);
    }
    }
#line 2758
    if (tmp == -1) {
      {
      {
#line 2759
      panic((char *)"getRLEpair: ungetc failed");
      }
      }
    }
  }
#line 2765
  if (runLength == 1) {
#line 2766
    globalCrc = (globalCrc << 8) ^ crc32Table[(globalCrc >> 24) ^ (unsigned int )((unsigned char )ch)];
#line 2767
    return ((1 << 16) | ch);
  } else {
#line 2770
    i = 1;
    {
    {
#line 2770
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 2770
      if (! (i <= runLength)) {
#line 2770
        goto while_break___0;
      }
#line 2771
      globalCrc = (globalCrc << 8) ^ crc32Table[(globalCrc >> 24) ^ (unsigned int )((unsigned char )ch)];
#line 2770
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2772
    return ((runLength << 16) | ch);
  }
}
}
#line 2779 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void loadAndRLEsource(int src ) 
{ 
  int ch ;
  int allowableBlockSize ;
  int i ;
  int rlePair ;
  int runLen ;

  {
#line 2786
  last = -1;
#line 2787
  ch = 0;
#line 2789
  i = 0;
  {
  {
#line 2789
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2789
    if (! (i < 256)) {
#line 2789
      goto while_break;
    }
#line 2789
    inUse[i] = (unsigned char)0;
#line 2789
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2792
  allowableBlockSize = 100000 * blockSize100k - 20;
  {
  {
#line 2794
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2794
    if (last < allowableBlockSize) {
#line 2794
      if (! (ch != 257)) {
#line 2794
        goto while_break___0;
      }
    } else {
#line 2794
      goto while_break___0;
    }
    {
    {
#line 2796
    rlePair = getRLEpair(src);
    }
#line 2797
    ch = rlePair & 65535;
#line 2798
    runLen = (int )((unsigned int )rlePair >> 16);
    }
#line 2804
    if (ch != 257) {
#line 2805
      inUse[ch] = (unsigned char)1;
      {
#line 2807
      if (runLen == 1) {
#line 2807
        goto case_1;
      }
#line 2809
      if (runLen == 2) {
#line 2809
        goto case_2;
      }
#line 2812
      if (runLen == 3) {
#line 2812
        goto case_3;
      }
#line 2816
      goto switch_default;
      case_1: /* CIL Label */ 
#line 2808
      last ++;
#line 2808
      *(block + last) = (unsigned char )ch;
#line 2808
      goto switch_break;
      case_2: /* CIL Label */ 
#line 2810
      last ++;
#line 2810
      *(block + last) = (unsigned char )ch;
#line 2811
      last ++;
#line 2811
      *(block + last) = (unsigned char )ch;
#line 2811
      goto switch_break;
      case_3: /* CIL Label */ 
#line 2813
      last ++;
#line 2813
      *(block + last) = (unsigned char )ch;
#line 2814
      last ++;
#line 2814
      *(block + last) = (unsigned char )ch;
#line 2815
      last ++;
#line 2815
      *(block + last) = (unsigned char )ch;
#line 2815
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2817
      inUse[runLen - 4] = (unsigned char)1;
#line 2818
      last ++;
#line 2818
      *(block + last) = (unsigned char )ch;
#line 2819
      last ++;
#line 2819
      *(block + last) = (unsigned char )ch;
#line 2820
      last ++;
#line 2820
      *(block + last) = (unsigned char )ch;
#line 2821
      last ++;
#line 2821
      *(block + last) = (unsigned char )ch;
#line 2822
      last ++;
#line 2822
      *(block + last) = (unsigned char )(runLen - 4);
#line 2822
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2826
  return;
}
}
#line 2835 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void compressStream(int stream , int zStream ) 
{ 
  int retVal ;
  unsigned int blockCRC ;
  unsigned int combinedCRC ;
  int blockNo ;
  char const   *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 2844
  blockNo = 0;
#line 2845
  bytesIn = 0U;
#line 2846
  bytesOut = 0U;
#line 2847
  nBlocksRandomised = 0;
  {
#line 2855
  bsSetStream(zStream, (unsigned char)1);
  }
  {
#line 2861
  bsPutUChar((unsigned char )'B');
  }
  {
#line 2862
  bsPutUChar((unsigned char )'Z');
  }
  {
#line 2863
  bsPutUChar((unsigned char )'h');
  }
  {
#line 2864
  bsPutUChar((unsigned char )(48 + blockSize100k));
  }
#line 2866
  combinedCRC = 0U;
  }
#line 2868
  if (verbosity >= 2) {
    {
    {
#line 2868
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
    }
  }
  {
  {
#line 2870
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 2872
    blockNo ++;
    {
#line 2873
    initialiseCRC();
    }
    {
#line 2874
    loadAndRLEsource(stream);
    }
    }
#line 2876
    if (last == -1) {
#line 2876
      goto while_break;
    }
    {
    {
#line 2878
    blockCRC = getFinalCRC();
    }
#line 2879
    combinedCRC = (combinedCRC << 1) | (combinedCRC >> 31);
#line 2880
    combinedCRC ^= blockCRC;
    }
#line 2882
    if (verbosity >= 2) {
      {
      {
#line 2883
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    block %d: crc = 0x%8x, combined CRC = 0x%8x, size = %d",
              blockNo, blockCRC, combinedCRC, last + 1);
      }
      }
    }
    {
    {
#line 2887
    doReversibleTransformation();
    }
    {
#line 2902
    bsPutUChar((unsigned char)49);
    }
    {
#line 2902
    bsPutUChar((unsigned char)65);
    }
    {
#line 2903
    bsPutUChar((unsigned char)89);
    }
    {
#line 2903
    bsPutUChar((unsigned char)38);
    }
    {
#line 2904
    bsPutUChar((unsigned char)83);
    }
    {
#line 2904
    bsPutUChar((unsigned char)89);
    }
    {
#line 2907
    bsPutUInt32(blockCRC);
    }
    }
#line 2910
    if (blockRandomised) {
      {
      {
#line 2911
      bsW(1, 1U);
      }
#line 2911
      nBlocksRandomised ++;
      }
    } else {
      {
      {
#line 2913
      bsW(1, 0U);
      }
      }
    }
    {
    {
#line 2916
    moveToFrontCodeAndSend();
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2921
  if (verbosity >= 2) {
#line 2921
    if (nBlocksRandomised > 0) {
#line 2922
      if (nBlocksRandomised == 1) {
#line 2922
        tmp = "";
      } else {
#line 2922
        tmp = "s";
      }
      {
      {
#line 2922
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %d block%s needed randomisation\n",
              nBlocksRandomised, tmp);
      }
      }
    }
  }
  {
  {
#line 2934
  bsPutUChar((unsigned char)23);
  }
  {
#line 2934
  bsPutUChar((unsigned char)114);
  }
  {
#line 2935
  bsPutUChar((unsigned char)69);
  }
  {
#line 2935
  bsPutUChar((unsigned char)56);
  }
  {
#line 2936
  bsPutUChar((unsigned char)80);
  }
  {
#line 2936
  bsPutUChar((unsigned char)144);
  }
  {
#line 2938
  bsPutUInt32(combinedCRC);
  }
  }
#line 2939
  if (verbosity >= 2) {
    {
    {
#line 2940
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    final combined CRC = 0x%x\n   ",
            combinedCRC);
    }
    }
  }
  {
  {
#line 2943
  bsFinishedWithStream();
  }
#line 2946
  retVal = 0;
  }
#line 2947
  if (retVal == -1) {
    {
    {
#line 2947
    ioError();
    }
    }
  }
#line 2948
  retVal = 0;
#line 2949
  if (retVal == -1) {
    {
    {
#line 2949
    ioError();
    }
    }
  }
#line 2952
  retVal = 0;
#line 2953
  if (retVal == -1) {
    {
    {
#line 2953
    ioError();
    }
    }
  }
#line 2955
  if (bytesIn == 0U) {
#line 2955
    bytesIn = 1U;
  }
#line 2956
  if (bytesOut == 0U) {
#line 2956
    bytesOut = 1U;
  }
#line 2958
  if (verbosity >= 1) {
    {
    {
#line 2959
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%6.3f:1, %6.3f bits/byte, %5.2f%% saved, %d in, %d out.\n",
            (double )((float )bytesIn / (float )bytesOut), (8.0 * (double )((float )bytesOut)) / (double )((float )bytesIn),
            100.0 * (1.0 - (double )((float )bytesOut / (float )bytesIn)), bytesIn,
            bytesOut);
    }
    }
  }
#line 2967
  return;
}
}
#line 2973 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char uncompressStream(int zStream , int stream ) 
{ 
  unsigned char magic1 ;
  unsigned char magic2 ;
  unsigned char magic3 ;
  unsigned char magic4 ;
  unsigned char magic5 ;
  unsigned char magic6 ;
  unsigned int storedBlockCRC ;
  unsigned int storedCombinedCRC ;
  unsigned int computedBlockCRC ;
  unsigned int computedCombinedCRC ;
  int currBlockNo ;
  int retVal ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 2991
  bsSetStream(zStream, (unsigned char)0);
  }
  {
#line 2997
  magic1 = bsGetUChar();
  }
  {
#line 2998
  magic2 = bsGetUChar();
  }
  {
#line 2999
  magic3 = bsGetUChar();
  }
  {
#line 3000
  magic4 = bsGetUChar();
  }
  }
#line 3001
  if ((int )magic1 != 66) {
#line 3001
    goto _L;
  } else
#line 3001
  if ((int )magic2 != 90) {
#line 3001
    goto _L;
  } else
#line 3001
  if ((int )magic3 != 104) {
#line 3001
    goto _L;
  } else
#line 3001
  if ((int )magic4 < 49) {
#line 3001
    goto _L;
  } else
#line 3001
  if ((int )magic4 > 57) {
    _L: /* CIL Label */ 
    {
    {
#line 3006
    bsFinishedWithStream();
    }
#line 3007
    retVal = 0;
    }
#line 3008
    if (retVal == -1) {
      {
      {
#line 3008
      ioError();
      }
      }
    }
#line 3009
    return ((unsigned char)0);
  }
  {
  {
#line 3012
  setDecompressStructureSizes((int )magic4 - 48);
  }
#line 3013
  computedCombinedCRC = 0U;
  }
#line 3015
  if (verbosity >= 2) {
    {
    {
#line 3015
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    ");
    }
    }
  }
#line 3016
  currBlockNo = 0;
  {
  {
#line 3018
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 3019
    magic1 = bsGetUChar();
    }
    {
#line 3020
    magic2 = bsGetUChar();
    }
    {
#line 3021
    magic3 = bsGetUChar();
    }
    {
#line 3022
    magic4 = bsGetUChar();
    }
    {
#line 3023
    magic5 = bsGetUChar();
    }
    {
#line 3024
    magic6 = bsGetUChar();
    }
    }
#line 3025
    if ((int )magic1 == 23) {
#line 3025
      if ((int )magic2 == 114) {
#line 3025
        if ((int )magic3 == 69) {
#line 3025
          if ((int )magic4 == 56) {
#line 3025
            if ((int )magic5 == 80) {
#line 3025
              if ((int )magic6 == 144) {
#line 3027
                goto while_break;
              }
            }
          }
        }
      }
    }
#line 3029
    if ((int )magic1 != 49) {
      {
      {
#line 3031
      badBlockHeader();
      }
      }
    } else
#line 3029
    if ((int )magic2 != 65) {
      {
      {
#line 3031
      badBlockHeader();
      }
      }
    } else
#line 3029
    if ((int )magic3 != 89) {
      {
      {
#line 3031
      badBlockHeader();
      }
      }
    } else
#line 3029
    if ((int )magic4 != 38) {
      {
      {
#line 3031
      badBlockHeader();
      }
      }
    } else
#line 3029
    if ((int )magic5 != 83) {
      {
      {
#line 3031
      badBlockHeader();
      }
      }
    } else
#line 3029
    if ((int )magic6 != 89) {
      {
      {
#line 3031
      badBlockHeader();
      }
      }
    }
    {
    {
#line 3033
    tmp = bsGetUInt32();
    }
#line 3033
    storedBlockCRC = (unsigned int )tmp;
    {
#line 3035
    tmp___0 = bsR(1);
    }
    }
#line 3035
    if (tmp___0 == 1U) {
#line 3036
      blockRandomised = (unsigned char)1;
    } else {
#line 3037
      blockRandomised = (unsigned char)0;
    }
#line 3039
    currBlockNo ++;
#line 3040
    if (verbosity >= 2) {
      {
      {
#line 3041
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%d: huff+mtf ",
              currBlockNo);
      }
      }
    }
    {
    {
#line 3042
    getAndMoveToFrontDecode();
    }
    {
#line 3045
    initialiseCRC();
    }
    }
#line 3046
    if (verbosity >= 2) {
      {
      {
#line 3046
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rt+rld");
      }
      }
    }
#line 3047
    if (smallMode) {
      {
      {
#line 3048
      undoReversibleTransformation_small(stream);
      }
      }
    } else {
      {
      {
#line 3050
      undoReversibleTransformation_fast(stream);
      }
      }
    }
    {
    {
#line 3054
    computedBlockCRC = getFinalCRC();
    }
    }
#line 3055
    if (verbosity >= 3) {
      {
      {
#line 3056
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" {0x%x, 0x%x}",
              storedBlockCRC, computedBlockCRC);
      }
      }
    }
#line 3057
    if (verbosity >= 2) {
      {
      {
#line 3057
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"] ");
      }
      }
    }
#line 3060
    if (storedBlockCRC != computedBlockCRC) {
      {
      {
#line 3061
      crcError(storedBlockCRC, computedBlockCRC);
      }
      }
    }
#line 3063
    computedCombinedCRC = (computedCombinedCRC << 1) | (computedCombinedCRC >> 31);
#line 3064
    computedCombinedCRC ^= computedBlockCRC;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3067
  if (verbosity >= 2) {
    {
    {
#line 3067
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n    ");
    }
    }
  }
  {
  {
#line 3069
  tmp___1 = bsGetUInt32();
  }
#line 3069
  storedCombinedCRC = (unsigned int )tmp___1;
  }
#line 3070
  if (verbosity >= 2) {
    {
    {
#line 3071
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"combined CRCs: stored = 0x%x, computed = 0x%x\n    ",
            storedCombinedCRC, computedCombinedCRC);
    }
    }
  }
#line 3074
  if (storedCombinedCRC != computedCombinedCRC) {
    {
    {
#line 3075
    crcError(storedCombinedCRC, computedCombinedCRC);
    }
    }
  }
  {
  {
#line 3078
  bsFinishedWithStream();
  }
#line 3080
  retVal = 0;
  }
#line 3081
  if (retVal == -1) {
    {
    {
#line 3081
    ioError();
    }
    }
  }
#line 3084
  retVal = 0;
#line 3085
  if (retVal != 0) {
    {
    {
#line 3085
    ioError();
    }
    }
  }
#line 3092
  return ((unsigned char)1);
}
}
#line 3098 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
unsigned char testStream(int zStream ) 
{ 
  unsigned char magic1 ;
  unsigned char magic2 ;
  unsigned char magic3 ;
  unsigned char magic4 ;
  unsigned char magic5 ;
  unsigned char magic6 ;
  unsigned int storedBlockCRC ;
  unsigned int storedCombinedCRC ;
  unsigned int computedBlockCRC ;
  unsigned int computedCombinedCRC ;
  int currBlockNo ;
  int retVal ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
  {
#line 3113
  bsSetStream(zStream, (unsigned char)0);
  }
  {
#line 3115
  magic1 = bsGetUChar();
  }
  {
#line 3116
  magic2 = bsGetUChar();
  }
  {
#line 3117
  magic3 = bsGetUChar();
  }
  {
#line 3118
  magic4 = bsGetUChar();
  }
  }
#line 3119
  if ((int )magic1 != 66) {
    {
    {
#line 3124
    bsFinishedWithStream();
    }
    {
#line 3126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: bad magic number (ie, not created by bzip2)\n",
            inName);
    }
    }
#line 3128
    return ((unsigned char)0);
  } else
#line 3119
  if ((int )magic2 != 90) {
    {
    {
#line 3124
    bsFinishedWithStream();
    }
    {
#line 3126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: bad magic number (ie, not created by bzip2)\n",
            inName);
    }
    }
#line 3128
    return ((unsigned char)0);
  } else
#line 3119
  if ((int )magic3 != 104) {
    {
    {
#line 3124
    bsFinishedWithStream();
    }
    {
#line 3126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: bad magic number (ie, not created by bzip2)\n",
            inName);
    }
    }
#line 3128
    return ((unsigned char)0);
  } else
#line 3119
  if ((int )magic4 < 49) {
    {
    {
#line 3124
    bsFinishedWithStream();
    }
    {
#line 3126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: bad magic number (ie, not created by bzip2)\n",
            inName);
    }
    }
#line 3128
    return ((unsigned char)0);
  } else
#line 3119
  if ((int )magic4 > 57) {
    {
    {
#line 3124
    bsFinishedWithStream();
    }
    {
#line 3126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: bad magic number (ie, not created by bzip2)\n",
            inName);
    }
    }
#line 3128
    return ((unsigned char)0);
  }
  {
#line 3131
  smallMode = (unsigned char)1;
  {
#line 3132
  setDecompressStructureSizes((int )magic4 - 48);
  }
#line 3133
  computedCombinedCRC = 0U;
  }
#line 3135
  if (verbosity >= 2) {
    {
    {
#line 3135
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
    }
  }
#line 3136
  currBlockNo = 0;
  {
  {
#line 3138
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 3139
    magic1 = bsGetUChar();
    }
    {
#line 3140
    magic2 = bsGetUChar();
    }
    {
#line 3141
    magic3 = bsGetUChar();
    }
    {
#line 3142
    magic4 = bsGetUChar();
    }
    {
#line 3143
    magic5 = bsGetUChar();
    }
    {
#line 3144
    magic6 = bsGetUChar();
    }
    }
#line 3145
    if ((int )magic1 == 23) {
#line 3145
      if ((int )magic2 == 114) {
#line 3145
        if ((int )magic3 == 69) {
#line 3145
          if ((int )magic4 == 56) {
#line 3145
            if ((int )magic5 == 80) {
#line 3145
              if ((int )magic6 == 144) {
#line 3147
                goto while_break;
              }
            }
          }
        }
      }
    }
#line 3149
    currBlockNo ++;
#line 3150
    if ((int )magic1 != 49) {
      {
      {
#line 3153
      bsFinishedWithStream();
      }
      {
#line 3155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s, block %d: bad header (not == 0x314159265359)\n",
              inName, currBlockNo);
      }
      }
#line 3158
      return ((unsigned char)0);
    } else
#line 3150
    if ((int )magic2 != 65) {
      {
      {
#line 3153
      bsFinishedWithStream();
      }
      {
#line 3155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s, block %d: bad header (not == 0x314159265359)\n",
              inName, currBlockNo);
      }
      }
#line 3158
      return ((unsigned char)0);
    } else
#line 3150
    if ((int )magic3 != 89) {
      {
      {
#line 3153
      bsFinishedWithStream();
      }
      {
#line 3155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s, block %d: bad header (not == 0x314159265359)\n",
              inName, currBlockNo);
      }
      }
#line 3158
      return ((unsigned char)0);
    } else
#line 3150
    if ((int )magic4 != 38) {
      {
      {
#line 3153
      bsFinishedWithStream();
      }
      {
#line 3155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s, block %d: bad header (not == 0x314159265359)\n",
              inName, currBlockNo);
      }
      }
#line 3158
      return ((unsigned char)0);
    } else
#line 3150
    if ((int )magic5 != 83) {
      {
      {
#line 3153
      bsFinishedWithStream();
      }
      {
#line 3155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s, block %d: bad header (not == 0x314159265359)\n",
              inName, currBlockNo);
      }
      }
#line 3158
      return ((unsigned char)0);
    } else
#line 3150
    if ((int )magic6 != 89) {
      {
      {
#line 3153
      bsFinishedWithStream();
      }
      {
#line 3155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s, block %d: bad header (not == 0x314159265359)\n",
              inName, currBlockNo);
      }
      }
#line 3158
      return ((unsigned char)0);
    }
    {
    {
#line 3160
    tmp = bsGetUInt32();
    }
#line 3160
    storedBlockCRC = (unsigned int )tmp;
    {
#line 3162
    tmp___0 = bsR(1);
    }
    }
#line 3162
    if (tmp___0 == 1U) {
#line 3163
      blockRandomised = (unsigned char)1;
    } else {
#line 3164
      blockRandomised = (unsigned char)0;
    }
#line 3166
    if (verbosity >= 2) {
      {
      {
#line 3167
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    block [%d: huff+mtf ",
              currBlockNo);
      }
      }
    }
    {
    {
#line 3168
    getAndMoveToFrontDecode();
    }
    {
#line 3171
    initialiseCRC();
    }
    }
#line 3172
    if (verbosity >= 2) {
      {
      {
#line 3172
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rt+rld");
      }
      }
    }
    {
    {
#line 3174
    undoReversibleTransformation_small(0);
    }
    {
#line 3179
    computedBlockCRC = getFinalCRC();
    }
    }
#line 3180
    if (verbosity >= 3) {
      {
      {
#line 3181
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" {0x%x, 0x%x}",
              storedBlockCRC, computedBlockCRC);
      }
      }
    }
#line 3182
    if (verbosity >= 2) {
      {
      {
#line 3182
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"] ");
      }
      }
    }
#line 3184
    if (storedBlockCRC != computedBlockCRC) {
      {
      {
#line 3185
      bsFinishedWithStream();
      }
      {
#line 3187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s, block %d: computed CRC does not match stored one\n",
              inName, currBlockNo);
      }
      }
#line 3189
      return ((unsigned char)0);
    }
#line 3192
    if (verbosity >= 2) {
      {
      {
#line 3192
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ok\n");
      }
      }
    }
#line 3193
    computedCombinedCRC = (computedCombinedCRC << 1) | (computedCombinedCRC >> 31);
#line 3194
    computedCombinedCRC ^= computedBlockCRC;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 3197
  tmp___1 = bsGetUInt32();
  }
#line 3197
  storedCombinedCRC = (unsigned int )tmp___1;
  }
#line 3198
  if (verbosity >= 2) {
    {
    {
#line 3199
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    combined CRCs: stored = 0x%x, computed = 0x%x\n    ",
            storedCombinedCRC, computedCombinedCRC);
    }
    }
  }
#line 3202
  if (storedCombinedCRC != computedCombinedCRC) {
    {
    {
#line 3203
    bsFinishedWithStream();
    }
    {
#line 3205
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: computed CRC does not match stored one\n",
            inName);
    }
    }
#line 3207
    return ((unsigned char)0);
  }
  {
  {
#line 3210
  bsFinishedWithStream();
  }
#line 3212
  retVal = 0;
  }
#line 3213
  if (retVal == -1) {
    {
    {
#line 3213
    ioError();
    }
    }
  }
#line 3214
  return ((unsigned char)1);
}
}
#line 3224 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void cadvise(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 3226
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nIt is possible that the compressed file(s) have become corrupted.\nYou can use the -tvv option to test integrity of such files.\n\nYou can use the `bzip2recover\' program to *attempt* to recover\ndata from undamaged sections of corrupted files.\n\n");
  }
  }
#line 3233
  return;
}
}
#line 3237 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void showFileNames(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 3239
  if ((unsigned long )(outName) == (unsigned long )((void *)0)) {
#line 3239
    tmp = "(null)";
  } else {
#line 3239
    tmp = (char const   *)(outName);
  }
#line 3239
  if ((unsigned long )(inName) == (unsigned long )((void *)0)) {
#line 3239
    tmp___0 = "(null)";
  } else {
#line 3239
    tmp___0 = (char const   *)(inName);
  }
  {
  {
#line 3239
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tInput file = %s, output file = %s\n",
          tmp___0, tmp);
  }
  }
#line 3245
  return;
}
}
#line 3249 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void cleanUpAndFail(int ec ) 
{ 
  int retVal ;
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 3253
  if (srcMode == 3) {
#line 3253
    if (opMode != 3) {
#line 3254
      if ((unsigned long )(outName) == (unsigned long )((void *)0)) {
#line 3254
        tmp = "(null)";
      } else {
#line 3254
        tmp = (char const   *)(outName);
      }
      {
      {
#line 3254
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Deleting output file %s, if it exists.\n",
              progName, tmp);
      }
      {
#line 3261
      retVal = remove((char const   *)(outName));
      }
      }
#line 3262
      if (retVal != 0) {
        {
        {
#line 3263
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: WARNING: deletion of output file (apparently) failed.\n",
                progName);
        }
        }
      }
    }
  }
#line 3267
  if (numFileNames > 0) {
#line 3267
    if (numFilesProcessed < numFileNames) {
      {
      {
#line 3268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: WARNING: some files have not been processed:\n\t%d specified on command line, %d not processed yet.\n\n",
              progName, numFileNames, numFileNames - numFilesProcessed);
      }
      }
    }
  }
  {
  {
#line 3274
  exit(ec);
  }
  }
}
}
#line 3279 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void panic(char *s ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 3281
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: PANIC -- internal consistency error:\n\t%s\n\tThis is a BUG.  Please report it to me at:\n\tjseward@acm.org\n",
          progName, s);
  }
  {
#line 3287
  showFileNames();
  }
  {
#line 3288
  cleanUpAndFail(3);
  }
  }
#line 3289
  return;
}
}
#line 3293 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void badBGLengths(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 3295
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: error when reading background model code lengths,\n\twhich probably means the compressed file is corrupted.\n",
          progName);
  }
  {
#line 3299
  showFileNames();
  }
  {
#line 3300
  cadvise();
  }
  {
#line 3301
  cleanUpAndFail(2);
  }
  }
#line 3302
  return;
}
}
#line 3306 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void crcError(unsigned int crcStored , unsigned int crcComputed ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 3308
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Data integrity error when decompressing.\n\tStored CRC = 0x%x, computed CRC = 0x%x\n",
          progName, crcStored, crcComputed);
  }
  {
#line 3312
  showFileNames();
  }
  {
#line 3313
  cadvise();
  }
  {
#line 3314
  cleanUpAndFail(2);
  }
  }
#line 3315
  return;
}
}
#line 3319 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void compressedStreamEOF(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 3321
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Compressed file ends unexpectedly;\n\tperhaps it is corrupted?  *Possible* reason follows.\n",
          progName);
  }
  {
#line 3325
  perror((char const   *)progName);
  }
  {
#line 3326
  showFileNames();
  }
  {
#line 3327
  cadvise();
  }
  {
#line 3328
  cleanUpAndFail(2);
  }
  }
#line 3329
  return;
}
}
#line 3333 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void ioError(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 3335
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: I/O or other error, bailing out.  Possible reason follows.\n",
          progName);
  }
  {
#line 3338
  perror((char const   *)progName);
  }
  {
#line 3339
  showFileNames();
  }
  {
#line 3340
  cleanUpAndFail(1);
  }
  }
#line 3341
  return;
}
}
#line 3345 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void blockOverrun(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 3347
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: block overrun during decompression,\n\twhich probably means the compressed file\n\tis corrupted.\n",
          progName);
  }
  {
#line 3352
  showFileNames();
  }
  {
#line 3353
  cadvise();
  }
  {
#line 3354
  cleanUpAndFail(2);
  }
  }
#line 3355
  return;
}
}
#line 3359 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void badBlockHeader(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 3361
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: bad block header in the compressed file,\n\twhich probably means it is corrupted.\n",
          progName);
  }
  {
#line 3365
  showFileNames();
  }
  {
#line 3366
  cadvise();
  }
  {
#line 3367
  cleanUpAndFail(2);
  }
  }
#line 3368
  return;
}
}
#line 3372 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void bitStreamEOF(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 3374
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: read past the end of compressed data,\n\twhich probably means it is corrupted.\n",
          progName);
  }
  {
#line 3378
  showFileNames();
  }
  {
#line 3379
  cadvise();
  }
  {
#line 3380
  cleanUpAndFail(2);
  }
  }
#line 3381
  return;
}
}
#line 3385 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void mySignalCatcher(int n ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 3387
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Control-C (or similar) caught, quitting.\n",
          progName);
  }
  {
#line 3390
  cleanUpAndFail(1);
  }
  }
#line 3391
  return;
}
}
#line 3395 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void mySIGSEGVorSIGBUScatcher(int n ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 3397
  if (opMode == 1) {
    {
    {
#line 3398
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Caught a SIGSEGV or SIGBUS whilst compressing,\n\twhich probably indicates a bug in bzip2.  Please\n\treport it to me at: jseward@acm.org\n",
            progName);
    }
    }
  } else {
    {
    {
#line 3404
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing,\n\twhich probably indicates that the compressed data\n\tis corrupted.\n",
            progName);
    }
    }
  }
  {
  {
#line 3410
  showFileNames();
  }
  }
#line 3411
  if (opMode == 1) {
    {
    {
#line 3412
    cleanUpAndFail(3);
    }
    }
  } else {
    {
    {
#line 3413
    cadvise();
    }
    {
#line 3413
    cleanUpAndFail(2);
    }
    }
  }
#line 3414
  return;
}
}
#line 3418 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void uncompressOutOfMemory(int draw , int blockSize ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 3420
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Can\'t allocate enough memory for decompression.\n\tRequested %d bytes for a block size of %d.\n\tTry selecting space-economic decompress (with flag -s)\n\tand failing that, find a machine with more memory.\n",
          progName, draw, blockSize);
  }
  {
#line 3426
  showFileNames();
  }
  {
#line 3427
  cleanUpAndFail(1);
  }
  }
#line 3428
  return;
}
}
#line 3432 "/local/sparrow_test/test/SPEC2000/CINT2000/256.bzip2/src/bzip2.c"
void compressOutOfMemory(int draw , int blockSize ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 3434
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: Can\'t allocate enough memory for compression.\n\tRequested %d bytes for a block size of %d.\n\tTry selecting a small block size (with flag -s).\n",
          progName, draw, blockSize);
  }
  {
#line 3439
  showFileNames();
  }
  {
#line 3440
  cleanUpAndFail(1);
  }
  }
#line 3441
  return;
}
}

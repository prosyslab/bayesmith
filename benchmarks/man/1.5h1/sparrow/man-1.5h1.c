/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 176 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 182 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 267 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 1 "manfile.h"
struct manpage {
   struct manpage *next ;
   char *filename ;
   int type ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 136 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 171 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 20 "defs.h"
struct dirs {
   struct dirs *nxt ;
   char mandir[4096] ;
   char catdir[4096] ;
   char bindir[4096] ;
   int mandatory ;
};
#line 14 "paths.h"
struct paths {
   char *name ;
   char *path ;
};
#line 128 "man-config.c"
struct xp {
   char *extension ;
   char *expander ;
   struct xp *nxt ;
};
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 10 "different.c"
struct filelist {
   char *pathname ;
   struct filelist *next ;
};
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 34 "/usr/include/nl_types.h"
typedef void *nl_catd;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 323 "glob.c"
struct globval {
   struct globval *next ;
   char *name ;
};
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 62 "/usr/include/sys/wait.h"
union wait;
#line 62
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_40 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_41 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_40 __wait_terminated ;
   struct __anonstruct___wait_stopped_41 __wait_stopped ;
};
#line 174 "util.c"
union __anonunion___u_48 {
   int __in ;
   int __i ;
};
#line 174 "util.c"
union __anonunion___u_49 {
   int __in ;
   int __i ;
};
#line 187 "util.c"
union __anonunion___u_52 {
   int __in ;
   int __i ;
};
#line 187 "util.c"
union __anonunion___u_53 {
   int __in ;
   int __i ;
};
#line 197 "util.c"
union __anonunion___u_54 {
   int __in ;
   int __i ;
};
#line 196 "util.c"
union __anonunion___u_55 {
   int __in ;
   int __i ;
};
#line 196 "util.c"
union __anonunion___u_56 {
   int __in ;
   int __i ;
};
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 1 "man.o"
/* #pragma merger(0,"./man.i","-Wall,-Wstrict-prototypes,-Wmissing-prototypes") */
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 144
extern struct _IO_FILE *stderr ;
#line 206
extern int fclose(FILE *__stream ) ;
#line 211
extern int fflush(FILE *__stream ) ;
#line 241
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 329
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 442
extern int getchar(void) ;
#line 526
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 740
extern void perror(char const   *__s ) ;
#line 773
extern int pclose(FILE *__stream ) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 84 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 92
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 99
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 102
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 167
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 242
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 303
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) index)(char const   *__s ,
                                                                                    int __c )  __attribute__((__pure__)) ;
#line 307
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) rindex)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 597
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 640
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 654
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 256 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 38 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 256 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 448
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 717
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 744
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 73 "/usr/include/getopt.h"
extern int optind ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 3 "gripes.h"
void gripe(int n  , ...) ;
#line 1 "man.h"
int debug  ;
#line 2
int do_compress ;
#line 3 "man.h"
int fhs  ;
#line 4 "man.h"
int fsstnd  ;
#line 5 "man.h"
int findall  ;
#line 6 "man.h"
int nocats  ;
#line 7 "man.h"
int preformat  ;
#line 8 "man.h"
int do_troff  ;
#line 9 "man.h"
int apropos  ;
#line 10 "man.h"
int whatis  ;
#line 11 "man.h"
int print_where  ;
#line 12 "man.h"
int one_per_line  ;
#line 13 "man.h"
int do_irix  ;
#line 14
char *dohp ;
#line 15 "man.h"
char *progname  ;
#line 16 "man.h"
char *pager  ;
#line 17 "man.h"
char *colon_sep_section_list  ;
#line 18 "man.h"
char *roff_directive  ;
#line 25 "manfile.h"
struct manpage *manfile(char *name , char *section , int flags , char **sectionlist ,
                        char **manpath , char *(*tocat)(char *man_filename , char *ext ,
                                                        int flags ) ) ;
#line 2 "manpath.h"
void prmanpath(void) ;
#line 3
void init_manpath(void) ;
#line 5 "manpath.h"
char **mandirlist  ;
#line 1 "man-config.h"
char *getval(char *cmd ) ;
#line 2
char *get_expander(char *file ) ;
#line 1 "man-getopt.h"
void man_getopt(int argc , char **argv ) ;
#line 3
int global_apropos ;
#line 1 "to_cat.h"
char *mandir_of(char *name ) ;
#line 2
char *convert_to_cat(char *name0 , char *ext , int standards___0 ) ;
#line 3 "util.h"
void get_permissions(void) ;
#line 6
char *my_strdup(char *s ) ;
#line 7
char *mkprogname(char *s ) ;
#line 8
int is_newer(char *fa , char *fb ) ;
#line 9
int do_system_command(char *command , int silent ) ;
#line 10
FILE *my_popen(char const   *command , char const   *type ) ;
#line 11
char *my_xsprintf(char *format  , ...) ;
#line 13 "util.h"
int ruid  ;
#line 13 "util.h"
int rgid  ;
#line 13 "util.h"
int euid  ;
#line 13 "util.h"
int egid  ;
#line 13 "util.h"
int suid  ;
#line 1 "glob.h"
char **glob_filename(char *pathname ) ;
#line 1 "different.h"
int different_cat_file(char *file ) ;
#line 2
int different_man_file(char *file ) ;
#line 57 "man.c"
char *dohp  =    (char *)0;
#line 65 "man.c"
int can_use_cache  ;
#line 77 "man.c"
static char **section_list  ;
#line 80 "man.c"
int do_compress  =    1;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 96 "man.c"
int line_length  =    80;
#line 97 "man.c"
int ll  =    0;
#line 99 "man.c"
static void get_line_length(void) 
{ 
  char *cp ;
  int width ;
  struct winsize wsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 104
  if (preformat) {
#line 105
    line_length = 80;
#line 106
    return;
  }
  {
  {
#line 108
  cp = getenv("MANWIDTH");
  }
  }
#line 108
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    {
    {
#line 108
    width = atoi((char const   *)cp);
    }
    }
#line 108
    if (width > 0) {
#line 109
      line_length = width;
#line 110
      return;
    }
  }
  {
  {
#line 113
  tmp___0 = isatty(0);
  }
  }
#line 113
  if (tmp___0) {
    {
    {
#line 113
    tmp___1 = isatty(1);
    }
    }
#line 113
    if (tmp___1) {
      {
      {
#line 116
      tmp = ioctl(0, 21523UL, & wsz);
      }
      }
#line 116
      if (tmp) {
        {
        {
#line 117
        perror("TIOCGWINSZ failed\n");
        }
        }
      } else
#line 118
      if (wsz.ws_col) {
#line 119
        line_length = (int )wsz.ws_col;
#line 120
        return;
      }
    }
  }
  {
  {
#line 124
  cp = getenv("COLUMNS");
  }
  }
#line 124
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
    {
    {
#line 124
    width = atoi((char const   *)cp);
    }
    }
#line 124
    if (width > 0) {
#line 125
      line_length = width;
    } else {
#line 127
      line_length = 80;
    }
  } else {
#line 127
    line_length = 80;
  }
#line 128
  return;
}
}
#line 130 "man.c"
static int setll(void) 
{ 
  int tmp ;

  {
#line 132
  if (! do_troff) {
#line 132
    if (line_length < 66) {
#line 132
      tmp = (line_length * 9) / 10;
    } else
#line 132
    if (line_length > 80) {
#line 132
      tmp = (line_length * 9) / 10;
    } else {
#line 132
      tmp = 0;
    }
  } else {
#line 132
    tmp = 0;
  }
#line 132
  return (tmp);
}
}
#line 142 "man.c"
static char *setpl(void) 
{ 
  char *pl ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 145
  if (do_troff) {
#line 146
    return ((char *)((void *)0));
  }
#line 147
  if (preformat) {
#line 148
    pl = (char *)"1100i";
  } else {
    {
    {
#line 150
    pl = getenv("MANPL");
    }
    }
#line 150
    if ((unsigned int )pl == (unsigned int )((char *)0)) {
      {
      {
#line 151
      tmp = isatty(0);
      }
      }
#line 151
      if (tmp) {
        {
        {
#line 151
        tmp___0 = isatty(1);
        }
        }
#line 151
        if (tmp___0) {
#line 152
          pl = (char *)"1100i";
        } else {
#line 154
          pl = (char *)"11i";
        }
      } else {
#line 154
        pl = (char *)"11i";
      }
    }
  }
#line 156
  return (pl);
}
}
#line 166 "man.c"
static char *is_section(char *name ) 
{ 
  char **vs ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 171
  tmp___0 = __ctype_b_loc();
  }
  }
#line 171
  if ((int const   )*(*tmp___0 + (int )*(name + 0)) & 2048) {
    {
    {
#line 171
    tmp___1 = __ctype_b_loc();
    }
    }
#line 171
    if (! ((int const   )*(*tmp___1 + (int )*(name + 1)) & 2048)) {
      {
      {
#line 171
      tmp___2 = strlen((char const   *)name);
      }
      }
#line 171
      if (tmp___2 < 5U) {
        {
        {
#line 172
        tmp = my_strdup(name);
        }
        }
#line 172
        return (tmp);
      }
    }
  }
#line 174
  vs = section_list;
  {
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned int )*vs != (unsigned int )((void *)0))) { // ZOO_BUG
#line 174
      goto while_break;
    }
    {
    {
#line 175
    tmp___4 = strcmp((char const   *)*vs, (char const   *)name); // ZOO_BUG
    }
    }
#line 175
    if (tmp___4 == 0) {
      {
      {
#line 176
      tmp___3 = my_strdup(name);
      }
      }
#line 176
      return (tmp___3);
    }
#line 174
    vs ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return ((char *)((void *)0));
}
}
#line 182 "man.c"
static void remove_file(char *file ) 
{ 
  int i ;

  {
  {
  {
#line 186
  i = unlink((char const   *)file);
  }
  }
#line 188
  if (debug) {
#line 189
    if (i) {
      {
      {
#line 190
      perror((char const   *)file);
      }
      }
    } else {
      {
      {
#line 192
      gripe(25, file);
      }
      }
    }
  }
#line 194
  return;
}
}
#line 196 "man.c"
static void remove_other_catfiles(char *catfile ) 
{ 
  char *pathname ;
  char *t ;
  char **gf ;
  int offset ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 203
  pathname = my_strdup(catfile);
  }
  {
#line 204
  t = rindex((char const   *)pathname, '.');
  }
  }
#line 205
  if ((unsigned int )t == (unsigned int )((void *)0)) {
#line 206
    return;
  } else {
    {
    {
#line 205
    tmp = getval((char *)"COMPRESS_EXT");
    }
    {
#line 205
    tmp___0 = strcmp((char const   *)t, (char const   *)tmp);
    }
    }
#line 205
    if (tmp___0) {
#line 206
      return;
    }
  }
  {
#line 207
  offset = (int )(t - pathname);
  {
#line 208
  strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)"*");
  }
  {
#line 209
  gf = glob_filename(pathname);
  }
  }
#line 211
  if ((unsigned int )gf != (unsigned int )((char **)-1)) {
#line 211
    if ((unsigned int )gf != (unsigned int )((void *)0)) {
      {
      {
#line 212
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 212
        if (! *gf) {
#line 212
          goto while_break;
        }
        {
        {
#line 218
        tmp___2 = strlen((char const   *)*gf);
        }
        }
#line 218
        if (tmp___2 <= (size_t )offset) {
          {
          {
#line 219
          tmp___1 = strlen((char const   *)*gf);
          }
          }
#line 219
          if (tmp___1 == (size_t )offset) {
            {
            {
#line 220
            remove_file(*gf);
            }
            }
          }
#line 222
          goto __Cont;
        }
        {
        {
#line 224
        tmp___3 = getval((char *)"COMPRESS_EXT");
        }
        {
#line 224
        tmp___4 = strcmp((char const   *)(*gf + offset), (char const   *)tmp___3);
        }
        }
#line 224
        if (! tmp___4) {
#line 225
          goto __Cont;
        }
        {
        {
#line 227
        tmp___5 = get_expander(*gf);
        }
        }
#line 227
        if ((unsigned int )tmp___5 != (unsigned int )((void *)0)) {
          {
          {
#line 228
          remove_file(*gf);
          }
          }
        }
        __Cont: 
#line 212
        gf ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 231
  return;
}
}
#line 236 "man.c"
static int display_cat_file(char *file ) 
{ 
  int found ;
  char *command ;
  char *expander ;
  char *tmp ;
  int tmp___0 ;
  char *cat ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 240
  if (preformat) {
#line 241
    return (1);
  }
  {
#line 243
  found = 0;
  {
#line 245
  tmp___6 = access((char const   *)file, 4);
  }
  }
#line 245
  if (tmp___6 == 0) {
    {
    {
#line 245
    tmp___7 = different_cat_file(file);
    }
    }
#line 245
    if (tmp___7) {
      {
#line 246
      command = (char *)((void *)0);
      {
#line 247
      tmp = get_expander(file);
      }
#line 247
      expander = tmp;
      }
#line 249
      if ((unsigned int )expander != (unsigned int )((void *)0)) {
#line 249
        if ((int )*(expander + 0) != 0) {
          {
          {
#line 250
          tmp___0 = isatty(1);
          }
          }
#line 250
          if (tmp___0) {
            {
            {
#line 251
            command = my_xsprintf((char *)"%s %s | %s", expander, file, pager);
            }
            }
          } else {
            {
            {
#line 253
            command = my_xsprintf((char *)"%s %s", expander, file);
            }
            }
          }
        } else {
#line 256
          goto _L;
        }
      } else {
        _L: 
        {
        {
#line 255
        tmp___3 = isatty(1);
        }
        }
#line 255
        if (tmp___3) {
          {
          {
#line 256
          command = my_xsprintf((char *)"%s %s", pager, file);
          }
          }
        } else {
          {
          {
#line 258
          tmp___1 = getval((char *)"CAT");
          }
#line 258
          cat = tmp___1;
          }
#line 259
          if (*(cat + 0)) {
#line 259
            tmp___2 = (char const   *)cat;
          } else {
#line 259
            tmp___2 = "cat";
          }
          {
          {
#line 259
          command = my_xsprintf((char *)"%s %s", tmp___2, file);
          }
          }
        }
      }
      {
      {
#line 262
      tmp___4 = do_system_command(command, 0);
      }
      }
#line 262
      if (tmp___4) {
#line 262
        tmp___5 = 0;
      } else {
#line 262
        tmp___5 = 1;
      }
#line 262
      found = tmp___5;
    }
  }
#line 264
  return (found);
}
}
#line 294 "man.c"
static char ultname[8192]  ;
#line 283 "man.c"
static char *ultimate_source(char *name0 ) 
{ 
  FILE *fp ;
  char *name ;
  char *expander ;
  int expfl ;
  char *fgr ;
  char *beg ;
  char *end ;
  char *cp ;
  char buf___0[8192] ;
  char *command ;
  char *extp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 288
  expfl = 0;
  {
#line 296
  name = my_strdup(name0);
  }
  }
  again: 
  {
  {
#line 299
  expander = get_expander(name);
  }
  }
#line 300
  if (expander) {
#line 300
    if (*expander) {
      {
      {
#line 303
      command = my_xsprintf((char *)"%s %s", expander, name);
      }
      {
#line 304
      fp = my_popen((char const   *)command, "r");
      }
      }
#line 305
      if ((unsigned int )fp == (unsigned int )((void *)0)) {
        {
        {
#line 306
        perror("popen");
        }
        {
#line 307
        gripe(27, command);
        }
        }
#line 308
        return ((char *)((void *)0));
      }
      {
      {
#line 310
      fgr = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
      }
      {
#line 311
      pclose(fp);
      }
#line 312
      expfl = 1;
      }
    } else {
#line 314
      goto _L___0;
    }
  } else {
    _L___0: 
    {
    {
#line 314
    fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
    }
    }
#line 315
    if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 315
      if (expfl) {
        {
        {
#line 316
        tmp = rindex((char const   *)name0, '.');
        }
#line 316
        extp = tmp;
        }
#line 317
        if (extp) {
#line 317
          if (*extp) {
            {
            {
#line 318
            strcat((char */* __restrict  */)name, (char const   */* __restrict  */)extp);
            }
            {
#line 319
            fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
            }
            }
          }
        }
      } else {
#line 323
        goto _L;
      }
    } else
    _L: 
#line 327
    if ((unsigned int )fp == (unsigned int )((void *)0)) {
      {
      {
#line 327
      tmp___0 = get_expander((char *)".gz");
      }
      }
#line 327
      if (tmp___0) {
        {
        {
#line 328
        strcat((char */* __restrict  */)name, (char const   */* __restrict  */)".gz");
        }
        {
#line 329
        fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
        }
        }
      }
    }
#line 332
    if ((unsigned int )fp == (unsigned int )((void *)0)) {
      {
      {
#line 333
      perror("fopen");
      }
      {
#line 334
      gripe(28, name);
      }
      }
#line 335
      return ((char *)((void *)0));
    }
    {
    {
#line 337
    fgr = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
    {
#line 338
    fclose(fp);
    }
    }
  }
#line 341
  if ((unsigned int )fgr == (unsigned int )((void *)0)) {
    {
    {
#line 342
    perror("fgets");
    }
    {
#line 343
    gripe(29, name);
    }
    }
#line 344
    return ((char *)((void *)0));
  }
  {
  {
#line 347
  tmp___1 = strncmp((char const   *)(buf___0), ".so", 3U);
  }
  }
#line 347
  if (tmp___1) {
#line 348
    return (name);
  }
#line 350
  beg = buf___0 + 3;
  {
  {
#line 351
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 351
    if (! ((int )*beg == 32)) { 
#line 351
      if (! ((int )*beg == 9)) {
#line 351
        goto while_break;
      }
    }
#line 352
    beg ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  end = beg;
  {
  {
#line 355
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 355
    if ((int )*end != 32) {
#line 355
      if ((int )*end != 9) {
#line 355
        if ((int )*end != 10) {
#line 355
          if (! ((int )*end != 0)) {
#line 355
            goto while_break___0;
          }
        } else {
#line 355
          goto while_break___0;
        }
      } else {
#line 355
        goto while_break___0;
      }
    } else {
#line 355
      goto while_break___0;
    }
#line 356
    end ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 358
  *end = (char )'\000';
#line 360
  if ((unsigned int )name != (unsigned int )(ultname)) {
    {
    {
#line 361
    strcpy((char */* __restrict  */)(ultname), (char const   */* __restrict  */)name);
    }
#line 362
    name = ultname;
    }
  }
  {
  {
#line 367
  cp = rindex((char const   *)name, '/');
  }
  }
#line 367
  if ((unsigned int )cp == (unsigned int )((void *)0)) {
#line 368
    return ((char *)0);
  }
  {
#line 369
  *cp = (char)0;
  {
#line 370
  tmp___3 = index((char const   *)beg, '/');
  }
  }
#line 370
  if (tmp___3) {
    {
    {
#line 375
    cp = rindex((char const   *)name, '/');
    }
    }
#line 375
    if ((unsigned int )cp != (unsigned int )((void *)0)) {
      {
      {
#line 375
      tmp___2 = strncmp((char const   *)(cp + 1), "man", 3U);
      }
      }
#line 375
      if (tmp___2) {
#line 376
        goto _L___1;
      } else {
        {
        {
#line 376
        strcpy((char */* __restrict  */)(cp + 1), (char const   */* __restrict  */)beg);
        }
        }
      }
    } else {
      _L___1: 
      {
      {
#line 377
      cp = rindex((char const   *)beg, '/');
      }
      }
#line 377
      if ((unsigned int )cp != (unsigned int )((void *)0)) {
        {
        {
#line 378
        strcat((char */* __restrict  */)name, (char const   */* __restrict  */)cp);
        }
        }
      } else {
        {
        {
#line 380
        strcat((char */* __restrict  */)name, (char const   */* __restrict  */)"/");
        }
        {
#line 381
        strcat((char */* __restrict  */)name, (char const   */* __restrict  */)beg);
        }
        }
      }
    }
  } else {
    {
    {
#line 372
    strcat((char */* __restrict  */)name, (char const   */* __restrict  */)"/");
    }
    {
#line 373
    strcat((char */* __restrict  */)name, (char const   */* __restrict  */)beg);
    }
    }
  }
#line 375
  goto again;
}
}
#line 387 "man.c"
static void add_directive(char *d , char *file , char *buf___0 , int buflen ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 389
  d = getval(d);
  }
  }
#line 389
  if ((unsigned int )d != (unsigned int )((char *)0)) {
#line 389
    if (*d) {
#line 390
      if ((int )*buf___0 == 0) {
        {
        {
#line 391
        tmp = strlen((char const   *)d);
        }
        {
#line 391
        tmp___0 = strlen((char const   *)file);
        }
        }
#line 391
        if ((tmp + tmp___0) + 2U > (size_t )buflen) {
#line 392
          return;
        }
        {
        {
#line 393
        strcpy((char */* __restrict  */)buf___0, (char const   */* __restrict  */)d);
        }
        {
#line 394
        strcat((char */* __restrict  */)buf___0, (char const   */* __restrict  */)" ");
        }
        {
#line 395
        strcat((char */* __restrict  */)buf___0, (char const   */* __restrict  */)file);
        }
        }
      } else {
        {
        {
#line 397
        tmp___1 = strlen((char const   *)d);
        }
        {
#line 397
        tmp___2 = strlen((char const   *)buf___0);
        }
        }
#line 397
        if ((tmp___1 + tmp___2) + 4U > (size_t )buflen) {
#line 398
          return;
        }
        {
        {
#line 399
        strcat((char */* __restrict  */)buf___0, (char const   */* __restrict  */)" | ");
        }
        {
#line 400
        strcat((char */* __restrict  */)buf___0, (char const   */* __restrict  */)d);
        }
        }
      }
    }
  }
#line 403
  return;
}
}
#line 405 "man.c"
static int parse_roff_directive(char *cp , char *file , char *buf___0 , int buflen ) 
{ 
  char c ;
  int tbl_found ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 408
  tbl_found = 0;
  {
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 410
    tmp___0 = cp;
#line 410
    cp ++;
#line 410
    c = *tmp___0;
#line 410
    if (! ((int )c != 0)) {
#line 410
      goto while_break;
    }
    {
#line 412
    if ((int )c == 101) {
#line 412
      goto case_101;
    }
#line 417
    if ((int )c == 103) {
#line 417
      goto case_103;
    }
#line 423
    if ((int )c == 112) {
#line 423
      goto case_112;
    }
#line 429
    if ((int )c == 116) {
#line 429
      goto case_116;
    }
#line 436
    if ((int )c == 118) {
#line 436
      goto case_118;
    }
#line 442
    if ((int )c == 114) {
#line 442
      goto case_114;
    }
#line 450
    if ((int )c == 10) {
#line 450
      goto case_10;
    }
#line 450
    if ((int )c == 9) {
#line 450
      goto case_10;
    }
#line 450
    if ((int )c == 32) {
#line 450
      goto case_10;
    }
#line 452
    goto switch_default;
    case_101: /* CIL Label */ 
#line 413
    if (debug) {
      {
      {
#line 414
      gripe(30);
      }
      }
    }
#line 415
    if (do_troff) {
#line 415
      tmp = "EQN";
    } else {
#line 415
      tmp = "NEQN";
    }
    {
    {
#line 415
    add_directive((char *)tmp, file, buf___0, buflen);
    }
    }
#line 416
    goto switch_break;
    case_103: /* CIL Label */ 
#line 419
    if (debug) {
      {
      {
#line 420
      gripe(31);
      }
      }
    }
    {
    {
#line 421
    add_directive((char *)"GRAP", file, buf___0, buflen);
    }
    }
#line 422
    goto switch_break;
    case_112: /* CIL Label */ 
#line 425
    if (debug) {
      {
      {
#line 426
      gripe(32);
      }
      }
    }
    {
    {
#line 427
    add_directive((char *)"PIC", file, buf___0, buflen);
    }
    }
#line 428
    goto switch_break;
    case_116: /* CIL Label */ 
#line 431
    if (debug) {
      {
      {
#line 432
      gripe(33);
      }
      }
    }
    {
#line 433
    tbl_found ++;
    {
#line 434
    add_directive((char *)"TBL", file, buf___0, buflen);
    }
    }
#line 435
    goto switch_break;
    case_118: /* CIL Label */ 
#line 438
    if (debug) {
      {
      {
#line 439
      gripe(34);
      }
      }
    }
    {
    {
#line 440
    add_directive((char *)"VGRIND", file, buf___0, buflen);
    }
    }
#line 441
    goto switch_break;
    case_114: /* CIL Label */ 
#line 444
    if (debug) {
      {
      {
#line 445
      gripe(35);
      }
      }
    }
    {
    {
#line 446
    add_directive((char *)"REFER", file, buf___0, buflen);
    }
    }
#line 447
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 451
    goto done;
    switch_default: /* CIL Label */ ;
#line 455
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 460
  if ((int )*buf___0 == 0) {
#line 461
    return (1);
  }
#line 463
  if (do_troff) {
#line 463
    tmp___1 = "TROFF";
  } else {
#line 463
    tmp___1 = "NROFF";
  }
  {
  {
#line 463
  add_directive((char *)tmp___1, (char *)"", buf___0, buflen);
  }
  }
#line 465
  if (tbl_found) {
#line 465
    if (! do_troff) {
      {
      {
#line 465
      tmp___2 = getval((char *)"COL");
      }
      }
#line 465
      if (*tmp___2) {
        {
        {
#line 466
        add_directive((char *)"COL", (char *)"", buf___0, buflen);
        }
        }
      }
    }
  }
#line 468
  return (0);
}
}
#line 471 "man.c"
static char *eos(char *s ) 
{ 


  {
  {
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 473
    if (! *s) {
#line 473
      goto while_break;
    }
#line 473
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  return (s);
}
}
#line 480 "man.c"
static char buf[8192]  ;
#line 477 "man.c"
static char *make_roff_command(char *file ) 
{ 
  FILE *fp ;
  char line[8192] ;
  char bufh[8192] ;
  char buft[8192] ;
  int status ;
  int ll___0 ;
  char *cp ;
  char *expander ;
  char *fgr ;
  char *pl ;
  char *command ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *cat ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  char *cmd ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
#line 484
  command = (char *)"";
  {
#line 488
  ll___0 = setll();
  }
  {
#line 489
  pl = setpl();
  }
  {
#line 491
  expander = get_expander(file);
  }
#line 494
  bufh[0] = (char)0;
  }
#line 495
  if (ll___0) {
#line 496
    goto _L;
  } else
#line 495
  if (pl) {
    _L: 
    {
    {
#line 496
    strcat((char */* __restrict  */)(bufh), (char const   */* __restrict  */)"(echo -e \"");
    }
    }
#line 497
    if (ll___0) {
      {
      {
#line 498
      tmp = eos(bufh);
      }
      {
#line 498
      sprintf((char */* __restrict  */)tmp, (char const   */* __restrict  */)".ll %d.%di",
              ll___0 / 10, ll___0 % 10);
      }
      }
    }
#line 499
    if (ll___0) {
#line 499
      if (pl) {
        {
        {
#line 500
        tmp___0 = eos(bufh);
        }
        {
#line 500
        sprintf((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)"\\n");
        }
        }
      }
    }
#line 501
    if (pl) {
      {
      {
#line 502
      tmp___1 = eos(bufh);
      }
      {
#line 502
//      sprintf((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)".pl %s",pl);
      strcpy(tmp___1,pl);       // ZOO_BUG
      }
      }
    }
    {
    {
#line 503
    strcat((char */* __restrict  */)(bufh), (char const   */* __restrict  */)"\"; ");
    }
    }
  }
#line 507
  buft[0] = (char)0;
#line 508
  if (ll___0) {
#line 509
    goto _L___0;
  } else
#line 508
  if (pl) {
    _L___0: 
#line 509
    if (pl) {
      {
      {
#line 509
      tmp___2 = strcmp((char const   *)pl, "1100i");
      }
      }
#line 509
      if (! tmp___2) {
        {
        {
#line 514
        strcat((char */* __restrict  */)(buft), (char const   */* __restrict  */)"; echo \".pl \\n(nlu+10\"");
        }
        }
      }
    }
    {
    {
#line 522
    strcat((char */* __restrict  */)(buft), (char const   */* __restrict  */)")");
    }
    }
  }
#line 525
  if (expander) {
#line 525
    if (*expander) {
      {
      {
#line 526
      command = my_xsprintf((char *)"%s%s %s%s", bufh, expander, file, buft);
      }
      }
    } else {
#line 528
      goto _L___2;
    }
  } else
  _L___2: 
#line 527
  if (ll___0) {
#line 528
    goto _L___1;
  } else
#line 527
  if (pl) {
    _L___1: 
    {
    {
#line 528
    tmp___3 = getval((char *)"CAT");
    }
#line 528
    cat = tmp___3;
    }
#line 530
    if (*(cat + 0)) {
#line 530
      tmp___4 = (char const   *)cat;
    } else {
#line 530
      tmp___4 = "cat";
    }
    {
    {
#line 530
    command = my_xsprintf((char *)"%s%s %s%s", bufh, tmp___4, file, buft);
    }
    }
  }
  {
  {
#line 534
  tmp___5 = strlen((char const   *)command);
  }
  }
#line 534
  if ((unsigned long )tmp___5 >= sizeof(buf)) {
    {
    {
#line 535
    exit(1);
    }
    }
  }
  {
  {
#line 536
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)command);
  }
  }
#line 538
  if ((unsigned int )roff_directive != (unsigned int )((void *)0)) {
#line 539
    if (debug) {
      {
      {
#line 540
      gripe(36);
      }
      }
    }
    {
    {
#line 542
    status = parse_roff_directive(roff_directive, file, buf, (int )sizeof(buf));
    }
    }
#line 545
    if (status == 0) {
#line 546
      return (buf);
    }
#line 548
    if (status == -1) {
      {
      {
#line 549
      gripe(17);
      }
      }
    }
  }
#line 552
  if (expander) {
#line 552
    if (*expander) {
      {
      {
#line 553
      tmp___6 = my_xsprintf((char *)"%s %s", expander, file);
      }
#line 553
      cmd = tmp___6;
      {
#line 554
      fp = my_popen((char const   *)cmd, "r");
      }
      }
#line 555
      if ((unsigned int )fp == (unsigned int )((void *)0)) {
        {
        {
#line 556
        perror("popen");
        }
        {
#line 557
        gripe(27, cmd);
        }
        }
#line 558
        return ((char *)((void *)0));
      }
      {
      {
#line 560
      fgr = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
      }
      {
#line 561
      pclose(fp);
      }
      }
    } else {
#line 563
      goto _L___3;
    }
  } else {
    _L___3: 
    {
    {
#line 563
    fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
    }
    }
#line 564
    if ((unsigned int )fp == (unsigned int )((void *)0)) {
      {
      {
#line 565
      perror("fopen");
      }
      {
#line 566
      gripe(28, file);
      }
      }
#line 567
      return ((char *)((void *)0));
    }
    {
    {
#line 569
    fgr = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
    }
    {
#line 570
    fclose(fp);
    }
    }
  }
#line 573
  if ((unsigned int )fgr == (unsigned int )((void *)0)) {
    {
    {
#line 574
    perror("fgets");
    }
    {
#line 575
    gripe(29, file);
    }
    }
#line 576
    return ((char *)((void *)0));
  }
#line 579
  cp = line;
#line 580
  tmp___7 = cp;
#line 580
  cp ++;
#line 580
  if ((int )*tmp___7 == 39) {
#line 580
    tmp___8 = cp;
#line 580
    cp ++;
#line 580
    if ((int )*tmp___8 == 92) {
#line 580
      tmp___9 = cp;
#line 580
      cp ++;
#line 580
      if ((int )*tmp___9 == 34) {
#line 580
        tmp___10 = cp;
#line 580
        cp ++;
#line 580
        if ((int )*tmp___10 == 32) {
#line 581
          if (debug) {
            {
            {
#line 582
            gripe(37, file);
            }
            }
          }
          {
          {
#line 584
          status = parse_roff_directive(cp, file, buf, (int )sizeof(buf));
          }
          }
#line 586
          if (status == 0) {
#line 587
            return (buf);
          }
#line 589
          if (status == -1) {
            {
            {
#line 590
            gripe(15, file);
            }
            }
          }
        }
      }
    }
  }
  {
  {
#line 593
  cp = getenv("MANROFFSEQ");
  }
  }
#line 593
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 594
    if (debug) {
      {
      {
#line 595
      gripe(38);
      }
      }
    }
    {
    {
#line 597
    status = parse_roff_directive(cp, file, buf, (int )sizeof(buf));
    }
    }
#line 599
    if (status == 0) {
#line 600
      return (buf);
    }
#line 602
    if (status == -1) {
      {
      {
#line 603
      gripe(16);
      }
      }
    }
  }
#line 606
  if (debug) {
    {
    {
#line 607
    gripe(39);
    }
    }
  }
  {
  {
#line 609
  parse_roff_directive((char *)"t", file, buf, (int )sizeof(buf));
  }
  }
#line 611
  return (buf);
}
}
#line 618 "man.c"
static int make_cat_file(char *path , char *man_file , char *cat_file ) 
{ 
  int mode ;
  FILE *fp ;
  char *roff_command ;
  char *command ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 623
  command = (char *)((void *)0);
  {
#line 629
  fp = fopen((char const   */* __restrict  */)cat_file, (char const   */* __restrict  */)"w");
  }
  }
#line 629
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
    {
    {
#line 630
    tmp = __errno_location();
    }
    }
#line 630
    if (*tmp == 2) {
#line 631
      return (0);
    }
    {
    {
#line 634
    tmp___2 = unlink((char const   *)cat_file);
    }
    }
#line 634
    if (tmp___2 != 0) {
#line 635
      goto _L;
    } else {
      {
      {
#line 634
      fp = fopen((char const   */* __restrict  */)cat_file, (char const   */* __restrict  */)"w");
      }
      }
#line 634
      if ((unsigned int )fp == (unsigned int )((void *)0)) {
        _L: 
        {
        {
#line 635
        tmp___0 = __errno_location();
        }
        }
#line 635
        if (*tmp___0 == 30) {
#line 636
          return (0);
        }
#line 637
        if (debug) {
          {
          {
#line 638
          gripe(42, cat_file);
          }
          }
        }
#line 639
        if (! suid) {
#line 640
          return (0);
        }
        {
        {
#line 644
        command = my_xsprintf((char *)"cp /dev/null %s 2>/dev/null", cat_file);
        }
        {
#line 645
        tmp___1 = do_system_command(command, 1);
        }
        }
#line 645
        if (tmp___1) {
#line 646
          if (debug) {
            {
            {
#line 647
            gripe(67);
            }
            }
          }
#line 648
          return (0);
        }
#line 650
        if (debug) {
          {
          {
#line 651
          gripe(68);
          }
          }
        }
      }
    }
  } else {
    {
    {
#line 655
    fclose(fp);
    }
    }
#line 659
    if (suid) {
      {
      {
#line 660
      tmp___4 = chmod((char const   *)cat_file, 438U);
      }
      }
#line 660
      if (tmp___4) {
        {
        {
#line 663
        tmp___3 = unlink((char const   *)cat_file);
        }
        }
#line 663
        if (tmp___3 != 0) {
          {
          {
#line 664
          command = my_xsprintf((char *)"rm %s", cat_file);
          }
          {
#line 665
          do_system_command(command, 1);
          }
          }
        }
        {
        {
#line 667
        fp = fopen((char const   */* __restrict  */)cat_file, (char const   */* __restrict  */)"w");
        }
        }
#line 667
        if ((unsigned int )fp != (unsigned int )((void *)0)) {
          {
          {
#line 668
          fclose(fp);
          }
          }
        }
      }
    }
  }
  {
  {
#line 673
  roff_command = make_roff_command(man_file);
  }
  }
#line 674
  if ((unsigned int )roff_command == (unsigned int )((void *)0)) {
#line 675
    return (0);
  }
#line 676
  if (do_compress) {
    {
    {
#line 682
    tmp___5 = getval((char *)"COMPRESS");
    }
    {
#line 682
    command = my_xsprintf((char *)"(cd %s ; %s | %s > %s)", path, roff_command, tmp___5,
                          cat_file);
    }
    }
  } else {
    {
    {
#line 685
    command = my_xsprintf((char *)"(cd %s ; %s > %s)", path, roff_command, cat_file);
    }
    }
  }
  {
  {
#line 692
  signal(2, (void (*)(int  ))1);
  }
  {
#line 694
  gripe(40);
  }
  {
#line 696
  tmp___9 = do_system_command(command, 0);
  }
  }
#line 696
  if (tmp___9) {
    {
    {
#line 708
    tmp___8 = unlink((char const   *)cat_file);
    }
    }
#line 708
    if (tmp___8 != 0) {
#line 708
      if (suid) {
        {
        {
#line 709
        command = my_xsprintf((char *)"rm %s", cat_file);
        }
        {
#line 710
        do_system_command(command, 1);
        }
        }
      }
    }
  } else {
#line 698
    if (ruid != euid) {
#line 698
      mode = 420;
    } else
#line 698
    if (rgid != egid) {
#line 698
      mode = 308;
    } else {
#line 698
      mode = 292;
    }
    {
    {
#line 699
    tmp___7 = chmod((char const   *)cat_file, (unsigned int )mode);
    }
    }
#line 699
    if (tmp___7 != 0) {
#line 699
      if (suid) {
        {
        {
#line 700
        command = my_xsprintf((char *)"chmod 0%o %s", mode, cat_file);
        }
        {
#line 701
        do_system_command(command, 1);
        }
        }
      }
    }
#line 704
    if (debug) {
      {
      {
#line 705
      gripe(41, cat_file, mode);
      }
      }
    }
  }
  {
  {
#line 714
  signal(2, (void (*)(int  ))0);
  }
  }
#line 716
  return (1);
}
}
#line 719 "man.c"
static int display_man_file(char *path , char *man_file ) 
{ 
  char *roff_command ;
  char *command ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 724
  tmp = different_man_file(man_file);
  }
  }
#line 724
  if (! tmp) {
#line 725
    return (0);
  }
  {
  {
#line 726
  roff_command = make_roff_command(man_file);
  }
  }
#line 727
  if ((unsigned int )roff_command == (unsigned int )((void *)0)) {
#line 728
    return (0);
  }
#line 729
  if (do_troff) {
    {
    {
#line 730
    command = my_xsprintf((char *)"(cd %s ; %s)", path, roff_command);
    }
    }
  } else {
    {
    {
#line 732
    command = my_xsprintf((char *)"(cd %s ; %s | %s)", path, roff_command, pager);
    }
    }
  }
  {
  {
#line 735
  tmp___0 = do_system_command(command, 0);
  }
  }
#line 735
  if (tmp___0) {
#line 735
    tmp___1 = 0;
  } else {
#line 735
    tmp___1 = 1;
  }
#line 735
  return (tmp___1);
}
}
#line 741 "man.c"
static int make_and_display_cat_file(char *path , char *man_file ) 
{ 
  char *cat_file ;
  char *ext ;
  int status ;
  int standards___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 748
  if (do_compress) {
    {
    {
#line 748
    ext = getval((char *)"COMPRESS_EXT");
    }
    }
  } else {
#line 748
    ext = (char *)0;
  }
#line 749
  if (fhs) {
#line 749
    tmp___0 = 64;
  } else {
#line 749
    tmp___0 = 0;
  }
#line 749
  if (fsstnd) {
#line 749
    tmp___1 = 32;
  } else {
#line 749
    tmp___1 = 0;
  }
#line 749
  if (dohp) {
#line 749
    tmp___2 = 128;
  } else {
#line 749
    tmp___2 = 0;
  }
  {
#line 749
  standards___0 = (tmp___0 | tmp___1) | tmp___2;
  {
#line 751
  cat_file = convert_to_cat(man_file, ext, standards___0);
  }
  }
#line 751
  if ((unsigned int )cat_file == (unsigned int )((void *)0)) {
#line 752
    return (0);
  }
#line 754
  if (debug) {
    {
    {
#line 755
    gripe(43, cat_file);
    }
    }
  }
#line 763
  if (nocats | preformat) {
#line 763
    status = -2;
  } else {
    {
    {
#line 763
    status = is_newer(man_file, cat_file);
    }
    }
  }
#line 764
  if (debug) {
    {
    {
#line 765
    gripe(44, status);
    }
    }
  }
#line 766
  if (status == -1) {
    {
    {
#line 768
    gripe(48, man_file);
    }
    }
#line 769
    return (0);
  } else
#line 766
  if (status == -3) {
    {
    {
#line 768
    gripe(48, man_file);
    }
    }
#line 769
    return (0);
  }
#line 772
  if (status != 0) {
#line 773
    goto _L;
  } else {
    {
    {
#line 772
    tmp___5 = access((char const   *)cat_file, 4);
    }
    }
#line 772
    if (tmp___5 != 0) {
      _L: 
#line 778
      if (print_where) {
        {
        {
#line 779
        printf((char const   */* __restrict  */)"%s\n", man_file);
        }
        }
#line 780
        return (1);
      }
      {
      {
#line 783
      tmp___4 = make_cat_file(path, man_file, cat_file);
      }
      }
#line 783
      if (! tmp___4) {
#line 784
        return (0);
      }
#line 789
      if (status == -2) {
#line 789
        if (do_compress) {
          {
          {
#line 790
          remove_other_catfiles(cat_file);
          }
          }
        }
      }
    } else
#line 796
    if (print_where) {
#line 797
      if (one_per_line) {
        {
        {
#line 799
        printf((char const   */* __restrict  */)"%s\n", cat_file);
        }
        {
#line 800
        printf((char const   */* __restrict  */)"%s\n", man_file);
        }
        }
      } else {
        {
        {
#line 802
        printf((char const   */* __restrict  */)"%s (<-- %s)\n", cat_file, man_file);
        }
        }
      }
#line 803
      return (1);
    }
  }
  {
  {
#line 806
  display_cat_file(cat_file);
  }
  }
#line 807
  return (1);
}
}
#line 815 "man.c"
static int format_and_display(char *man_file ) 
{ 
  char *path ;
  int tmp ;
  char *command ;
  char *roff_command ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 819
  tmp = access((char const   *)man_file, 4);
  }
  }
#line 819
  if (tmp != 0) {
#line 820
    return (0);
  }
  {
  {
#line 822
  path = mandir_of(man_file);
  }
  }
#line 823
  if ((unsigned int )path == (unsigned int )((void *)0)) {
#line 824
    return (0);
  }
  {
  {
#line 829
  man_file = ultimate_source(man_file);
  }
  }
#line 830
  if ((unsigned int )man_file == (unsigned int )((void *)0)) {
#line 831
    return (0);
  }
#line 833
  if (do_troff) {
    {
    {
#line 835
    tmp___0 = make_roff_command(man_file);
    }
#line 835
    roff_command = tmp___0;
    }
#line 837
    if ((unsigned int )roff_command == (unsigned int )((void *)0)) {
#line 838
      return (0);
    }
    {
    {
#line 840
    command = my_xsprintf((char *)"(cd %s ; %s)", path, roff_command);
    }
    {
#line 841
    tmp___1 = do_system_command(command, 0);
    }
    }
#line 841
    if (tmp___1) {
#line 841
      tmp___2 = 0;
    } else {
#line 841
      tmp___2 = 1;
    }
#line 841
    return (tmp___2);
  }
#line 844
  if (can_use_cache) {
    {
    {
#line 844
    tmp___3 = make_and_display_cat_file(path, man_file);
    }
    }
#line 844
    if (tmp___3) {
#line 845
      return (1);
    }
  }
#line 848
  if (print_where) {
    {
    {
#line 849
    printf((char const   */* __restrict  */)"%s\n", man_file);
    }
    }
#line 850
    return (1);
  }
  {
  {
#line 853
  tmp___4 = display_man_file(path, man_file);
  }
  }
#line 853
  return (tmp___4);
}
}
#line 873 "man.c"
static int man(char *name , char *section ) 
{ 
  int found ;
  int type ;
  int flags ;
  struct manpage *mp ;
  char fullname[8192] ;
  char fullpath[8192] ;
  char *path ;
  char *cp ;
  FILE *fp ;
  FILE *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *t ;
  char *tmp___10 ;
  char *n ;
  char *tmp___11 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 878
  found = 0;
  {
#line 881
  tmp___5 = index((char const   *)name, '/');
  }
  }
#line 881
  if (tmp___5) {
    {
    {
#line 886
    tmp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
    }
#line 886
    fp = tmp;
    }
#line 888
    if (! fp) {
      {
      {
#line 889
      perror((char const   *)name);
      }
      }
#line 890
      return (0);
    }
    {
    {
#line 892
    fclose(fp);
    }
    }
#line 893
    if ((int )*name != 47) {
      {
      {
#line 893
      tmp___1 = getcwd(fullname, (size_t )sizeof(fullname));
      }
      }
#line 893
      if (tmp___1) {
        {
        {
#line 893
        tmp___2 = strlen((char const   *)(fullname));
        }
        {
#line 893
        tmp___3 = strlen((char const   *)name);
        }
        }
#line 893
        if ((unsigned long )((tmp___2 + tmp___3) + 3U) < sizeof(fullname)) {
          {
          {
#line 895
          strcat((char */* __restrict  */)(fullname), (char const   */* __restrict  */)"/");
          }
          {
#line 896
          strcat((char */* __restrict  */)(fullname), (char const   */* __restrict  */)name);
          }
          }
        } else {
#line 898
          goto _L___0;
        }
      } else {
#line 901
        goto _L___0;
      }
    } else {
      _L___0: 
      {
      {
#line 897
      tmp___0 = strlen((char const   *)name);
      }
      }
#line 897
      if ((unsigned long )(tmp___0 + 2U) < sizeof(fullname)) {
        {
        {
#line 898
        strcpy((char */* __restrict  */)(fullname), (char const   */* __restrict  */)name);
        }
        }
      } else {
        {
        {
#line 900
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: name too long\n",
                name);
        }
        }
#line 901
        return (0);
      }
    }
    {
    {
#line 904
    strcpy((char */* __restrict  */)(fullpath), (char const   */* __restrict  */)(fullname));
    }
    {
#line 905
    cp = rindex((char const   *)(fullpath), '/');
    }
    }
#line 905
    if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 905
      if ((unsigned long )((unsigned int )((cp - fullpath) + 4L)) < sizeof(fullpath)) {
        {
        {
#line 907
        strcpy((char */* __restrict  */)(cp + 1), (char const   */* __restrict  */)"..");
        }
#line 908
        path = fullpath;
        }
      } else {
#line 910
        path = (char *)".";
      }
    } else {
#line 910
      path = (char *)".";
    }
    {
    {
#line 912
    name = ultimate_source(fullname);
    }
    }
#line 913
    if (! name) {
#line 914
      return (0);
    }
#line 916
    if (print_where) {
      {
      {
#line 917
      printf((char const   */* __restrict  */)"%s\n", name);
      }
      }
#line 918
      return (1);
    }
    {
    {
#line 920
    tmp___4 = display_man_file(path, name);
    }
    }
#line 920
    return (tmp___4);
  }
  {
  {
#line 923
  fflush(stdout);
  }
  {
#line 924
  init_manpath();
  }
  }
#line 926
  if (preformat) {
#line 926
    tmp___9 = 1;
  } else {
    {
    {
#line 926
    tmp___6 = isatty(0);
    }
    }
#line 926
    if (tmp___6) {
      {
      {
#line 926
      tmp___7 = isatty(1);
      }
      }
#line 926
      if (tmp___7) {
        {
        {
#line 926
        tmp___8 = setll();
        }
        }
#line 926
        if (tmp___8) {
#line 926
          tmp___9 = 0;
        } else {
#line 926
          tmp___9 = 1;
        }
      } else {
#line 926
        tmp___9 = 0;
      }
    } else {
#line 926
      tmp___9 = 0;
    }
  }
#line 926
  can_use_cache = tmp___9;
#line 928
  if (do_troff) {
    {
    {
#line 929
    tmp___10 = getval((char *)"TROFF");
    }
#line 929
    t = tmp___10;
    }
#line 930
    if (! t) {
#line 931
      return (0);
    } else
#line 930
    if (! *t) {
#line 931
      return (0);
    }
#line 932
    type = 1;
  } else {
    {
    {
#line 934
    tmp___11 = getval((char *)"NROFF");
    }
#line 934
    n = tmp___11;
#line 935
    type = 0;
    }
#line 936
    if (can_use_cache) {
#line 937
      type |= 2;
    }
#line 938
    if (n) {
#line 938
      if (*n) {
#line 939
        type |= 1;
      }
    }
#line 940
    if (fhs) {
#line 941
      type |= 4;
    } else
#line 940
    if (fsstnd) {
#line 941
      type |= 4;
    }
  }
#line 944
  flags = type;
#line 945
  if (! findall) {
#line 946
    flags |= 24;
  }
#line 947
  if (fsstnd) {
#line 948
    flags |= 32;
  } else
#line 949
  if (fhs) {
#line 950
    flags |= 64;
  }
#line 951
  if (dohp) {
#line 952
    flags |= 128;
  }
#line 953
  if (do_irix) {
#line 954
    flags |= 256;
  }
  {
  {
#line 956
  mp = manfile(name, section, flags, section_list, mandirlist, & convert_to_cat);
  }
#line 958
  found = 0;
  }
  {
  {
#line 959
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 959
    if (! mp) {
#line 959
      goto while_break;
    }
#line 960
    if (mp->type == 1) {
      {
      {
#line 961
      found = format_and_display(mp->filename);
      }
      }
    } else
#line 962
    if (mp->type == 2) {
#line 963
      goto _L___1;
    } else
#line 962
    if (mp->type == 4) {
      _L___1: 
#line 963
      if (print_where) {
        {
        {
#line 964
        printf((char const   */* __restrict  */)"%s\n", mp->filename);
        }
#line 965
        found = 1;
        }
      } else {
        {
        {
#line 967
        found = display_cat_file(mp->filename);
        }
        }
      }
    } else {
#line 970
      goto while_break;
    }
#line 971
    if (found) {
#line 971
      if (! findall) {
#line 972
        goto while_break;
      }
    }
#line 973
    mp = mp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 975
  return (found);
}
}
#line 983 "man.c"
static char *tmp_section_list[100]  ;
#line 978 "man.c"
static char **get_section_list(void) 
{ 
  int i ;
  char *p ;
  char *end ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 985
  if ((unsigned int )colon_sep_section_list == (unsigned int )((void *)0)) {
    {
    {
#line 986
    p = getenv("MANSECT");
    }
    }
#line 986
    if ((unsigned int )p == (unsigned int )((void *)0)) {
      {
      {
#line 987
      p = getval((char *)"MANSECT");
      }
      }
    }
    {
    {
#line 988
    colon_sep_section_list = my_strdup(p);
    }
    }
  }
#line 991
  i = 0;
#line 992
  p = colon_sep_section_list;
  {
  {
#line 992
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 993
    end = strchr((char const   *)p, ':');
    }
    }
#line 993
    if ((unsigned int )end != (unsigned int )((void *)0)) {
#line 994
      *end = (char )'\000';
    }
    {
#line 996
    tmp = i;
#line 996
    i ++;
    {
#line 996
    tmp_section_list[tmp] = my_strdup(p); // ZOO_BUG
    }
    }
#line 998
    if ((unsigned int )end == (unsigned int )((void *)0)) {
#line 999
      goto while_break;
    } else
#line 998
    if ((unsigned long )((unsigned int )(i + 1)) == sizeof(tmp_section_list)) {
#line 999
      goto while_break;
    }
#line 992
    p = end + 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1002
  tmp_section_list[i] = (char *)((void *)0); // ZOO_BUG
#line 1003
  return (tmp_section_list);
}
}
#line 1006 "man.c"
static void do_global_apropos(char *name , char *section ) 
{ 
  char **dp ;
  char **gf ;
  char *pathname ;
  char *command ;
  int res ;
  char const   *tmp ;
  char *expander ;
  char *tmp___0 ;
  int answer ;
  int c ;
  char path[8192] ;
  char *tmp___1 ;
  char *ri ;
  char *tmp___2 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
  {
#line 1018
  init_manpath();
  }
  }
#line 1019
  if (mandirlist) {
#line 1020
    dp = mandirlist;
    {
    {
#line 1020
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1020
      if (! *dp) {
#line 1020
        goto while_break;
      }
#line 1021
      if (debug) {
        {
        {
#line 1022
        gripe(46, *dp);
        }
        }
      }
#line 1023
      if (section) {
#line 1023
        tmp = (char const   *)section;
      } else {
#line 1023
        tmp = "*";
      }
      {
      {
#line 1023
      pathname = my_xsprintf((char *)"%s/man%s/*", *dp, tmp);
      }
      {
#line 1024
      gf = glob_filename(pathname);
      }
      {
#line 1025
      free((void *)pathname);
      }
      }
#line 1027
      if ((unsigned int )gf != (unsigned int )((char **)-1)) {
#line 1027
        if ((unsigned int )gf != (unsigned int )((void *)0)) {
          {
          {
#line 1028
          while (1) {
            while_continue___3: /* CIL Label */ ;
            while_continue___0: /* CIL Label */ ;
#line 1028
            if (! *gf) {
#line 1028
              goto while_break___0;
            }
            {
            {
#line 1029
            tmp___0 = get_expander(*gf);
            }
#line 1029
            expander = tmp___0;
            }
#line 1030
            if (expander) {
              {
              {
#line 1031
              command = my_xsprintf((char *)"%s %s | grep -%c \'%s\'", expander, *gf,
                                    'q', name);
              }
              }
            } else {
              {
              {
#line 1034
              command = my_xsprintf((char *)"grep -%c \'%s\' %s", 'q', name, *gf);
              }
              }
            }
            {
            {
#line 1036
            res = do_system_command(command, 1);
            }
            {
#line 1037
            free((void *)command);
            }
            }
#line 1038
            if (res == 0) {
#line 1039
              if (print_where) {
                {
                {
#line 1040
                printf((char const   */* __restrict  */)"%s\n", *gf);
                }
                }
              } else {
                {
                {
#line 1047
                printf((char const   */* __restrict  */)"%s? [ynq] ", *gf);
                }
                {
#line 1048
                fflush(stdout);
                }
                {
#line 1049
                c = getchar();
                }
#line 1049
                answer = c;
                }
                {
                {
#line 1050
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  while_continue___1: /* CIL Label */ ;
#line 1050
                  if (c != 10) {
#line 1050
                    if (! (c != -1)) {
#line 1050
                      goto while_break___1;
                    }
                  } else {
#line 1050
                    goto while_break___1;
                  }
                  {
                  {
#line 1051
                  c = getchar();
                  }
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
                while_break___1: /* CIL Label */ ;
                }
                {
                {
#line 1052
                tmp___1 = index("QqXx", answer);
                }
                }
#line 1052
                if (tmp___1) {
                  {
                  {
#line 1053
                  exit(0);
                  }
                  }
                }
                {
                {
#line 1054
                tmp___2 = index("YyJj", answer);
                }
                }
#line 1054
                if (tmp___2) {
                  {
                  {
#line 1057
                  strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)*gf);
                  }
                  {
#line 1058
                  ri = rindex((char const   *)(path), '/');
                  }
                  }
#line 1059
                  if (ri) {
#line 1060
                    *ri = (char)0;
                  }
                  {
                  {
#line 1061
                  format_and_display(*gf);
                  }
                  }
                }
              }
            }
#line 1028
            gf ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 1020
      dp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1068
  return;
}
}
#line 1073 "man.c"
static void do_apropos(char *name ) 
{ 
  char *command ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 1077
  tmp = getval((char *)"APROPOS");
  }
  {
#line 1077
  command = my_xsprintf((char *)"%s %s", tmp, name);
  }
  {
#line 1078
  do_system_command(command, 0);
  }
  {
#line 1079
  free((void *)command);
  }
  }
#line 1080
  return;
}
}
#line 1085 "man.c"
static void do_whatis(char *name ) 
{ 
  char *command ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 1089
  tmp = getval((char *)"WHATIS");
  }
  {
#line 1089
  command = my_xsprintf((char *)"%s %s", tmp, name);
  }
  {
#line 1090
  do_system_command(command, 0);
  }
  {
#line 1091
  free((void *)command);
  }
  }
#line 1092
  return;
}
}
#line 1094 "man.c"
int main(int argc , char **argv ) 
{ 
  int status ;
  char *nextarg ;
  char *tmp ;
  char *section ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 1096
  status = 0;
#line 1099
  section = (char *)0;
  {
#line 1107
  setlocale(5, "");
  }
  {
#line 1111
  dohp = getenv("MAN_HP_DIREXT");
  }
  {
#line 1114
  tmp___0 = getenv("MAN_IRIX_CATNAMES");
  }
  }
#line 1114
  if (tmp___0) {
#line 1115
    do_irix = 1;
  }
  {
  {
#line 1117
  progname = mkprogname(*(argv + 0));
  }
  {
#line 1119
  get_permissions();
  }
  {
#line 1120
  get_line_length();
  }
  {
#line 1125
  man_getopt(argc, argv);
  }
  {
#line 1130
  tmp___1 = strcmp((char const   *)progname, "manpath");
  }
  }
#line 1130
  if (tmp___1) {
#line 1130
    if (optind == argc) {
#line 1130
      if (print_where) {
        {
        {
#line 1131
        init_manpath();
        }
        {
#line 1132
        prmanpath();
        }
        {
#line 1133
        exit(0);
        }
        }
      }
    }
  } else {
    {
    {
#line 1131
    init_manpath();
    }
    {
#line 1132
    prmanpath();
    }
    {
#line 1133
    exit(0);
    }
    }
  }
#line 1136
  if (optind == argc) {
    {
    {
#line 1137
    gripe(8);
    }
    }
  }
  {
  {
#line 1139
  section_list = get_section_list();
  }
  }
  {
  {
#line 1141
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1141
    if (! (optind < argc)) {
#line 1141
      goto while_break;
    }
    {
#line 1142
    tmp___2 = optind;
#line 1142
    optind ++;
#line 1142
    nextarg = *(argv + tmp___2);
    {
#line 1144
    tmp = is_section(nextarg);
    }
    }
#line 1145
    if (tmp) {
#line 1146
      if (optind < argc) {
#line 1147
        section = tmp;
#line 1148
        if (debug) {
          {
          {
#line 1149
          gripe(24, section);
          }
          }
        }
      } else {
        {
        {
#line 1151
        gripe(7, tmp);
        }
        }
      }
#line 1153
      goto while_continue;
    }
#line 1156
    if (global_apropos) {
      {
      {
#line 1157
      do_global_apropos(nextarg, section);
      }
      }
    } else
#line 1158
    if (apropos) {
      {
      {
#line 1159
      do_apropos(nextarg);
      }
      }
    } else
#line 1160
    if (whatis) {
      {
      {
#line 1161
      do_whatis(nextarg);
      }
      }
    } else {
      {
      {
#line 1163
      status = man(nextarg, section);
      }
      }
#line 1165
      if (status == 0) {
#line 1166
        if (section) {
          {
          {
#line 1167
          gripe(9, nextarg, section);
          }
          }
        } else {
          {
          {
#line 1169
          gripe(10, nextarg);
          }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1173
  return (! status);
}
}
#line 1 "manfile.o"
/* #pragma merger(0,"./manfile.i","-Wall,-Wstrict-prototypes,-Wmissing-prototypes") */
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 14 "manfile.c"
static int standards  ;
#line 15 "manfile.c"
static char *(*to_cat_filename)(char *man_filename , char *ext , int flags )  ;
#line 20 "manfile.c"
static void append(struct manpage **head , struct manpage *a ) 
{ 
  struct manpage *p ;

  {
#line 24
  if (a) {
#line 25
    if (*head) {
#line 26
      p = *head;
      {
      {
#line 27
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 27
        if (! p->next) {
#line 27
          goto while_break;
        }
#line 28
        p = p->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 29
      p->next = a;
    } else {
#line 31
      *head = a;
    }
  }
#line 33
  return;
}
}
#line 35 "manfile.c"
static int my_lth(char *s ) 
{ 
  size_t tmp___0 ;

  {
#line 37
  if (s) {
    {
    {
#line 37
    tmp___0 = strlen((char const   *)s);
    }
    }
  } else {
#line 37
    tmp___0 = 0U;
  }
#line 37
  return ((int )tmp___0);
}
}
#line 52 "manfile.c"
static char **glob_for_file_ext_glob(char *dir , char *sec , char *name , char *ext ,
                                     char *hpx , int glob , int type ) 
{ 
  char *pathname ;
  char *p ;
  char **names ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
  {
#line 60
  tmp = my_lth(dir);
  }
  {
#line 60
  tmp___0 = my_lth(sec);
  }
  {
#line 60
  tmp___1 = my_lth(hpx);
  }
  {
#line 60
  tmp___2 = my_lth(name);
  }
  {
#line 60
  tmp___3 = my_lth(ext);
  }
#line 60
  len = ((((tmp + tmp___0) + tmp___1) + tmp___2) + tmp___3) + 8;
  {
#line 62
  tmp___4 = malloc((unsigned int )len);
  }
#line 62
  pathname = (char *)tmp___4;
  }
#line 63
  if (! pathname) {
#line 64
    return ((char **)0);
  }
#line 66
  if (glob) {
#line 66
    tmp___5 = "*";
  } else {
#line 66
    tmp___5 = "";
  }
#line 66
  if (type == 4) {
#line 66
    tmp___6 = "cat";
  } else {
#line 66
    tmp___6 = "man";
  }
  {
  {
#line 66
  sprintf((char */* __restrict  */)pathname, (char const   */* __restrict  */)"%s/%s%s%s/%s.%s%s",
          dir, tmp___6, sec, hpx, name, ext, tmp___5);
  }
  }
#line 70
  if (type == 2) {
    {
    {
#line 71
    p = (*to_cat_filename)(pathname, (char *)0, standards);
    }
    }
#line 72
    if (p) {
      {
      {
#line 73
      free((void *)pathname);
      }
#line 74
      pathname = p;
      }
    } else {
#line 76
      if (glob) {
#line 76
        tmp___7 = "*";
      } else {
#line 76
        tmp___7 = "";
      }
      {
      {
#line 76
      sprintf((char */* __restrict  */)pathname, (char const   */* __restrict  */)"%s/cat%s%s/%s.%s%s",
              dir, sec, hpx, name, ext, tmp___7);
      }
      }
    }
  }
  {
  {
#line 81
  names = glob_filename(pathname);
  }
  }
#line 82
  if ((unsigned int )names == (unsigned int )((char **)-1)) {
#line 83
    names = (char **)0;
  }
#line 84
  return (names);
}
}
#line 87 "manfile.c"
static char **glob_for_file_ext(char *dir , char *sec , char *name , char *ext , int type ) 
{ 
  char **names ;
  char **namesglob ;
  char *hpx ;
  char const   *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 90
  if (standards & 128) {
#line 90
    tmp = ".Z";
  } else {
#line 90
    tmp = "";
  }
  {
#line 90
  hpx = (char *)tmp;
  {
#line 92
  namesglob = glob_for_file_ext_glob(dir, sec, name, ext, hpx, 1, type);
  }
  }
#line 93
  if (! namesglob) {
#line 93
    if (*hpx) {
      {
#line 94
      hpx = (char *)"";
      {
#line 95
      namesglob = glob_for_file_ext_glob(dir, sec, name, ext, hpx, 1, type);
      }
      }
    }
  }
#line 97
  if (! namesglob) {
#line 98
    return ((char **)0);
  }
#line 99
  if (*namesglob) {
    {
    {
#line 101
    names = glob_for_file_ext_glob(dir, sec, name, ext, hpx, 0, type);
    }
    }
#line 102
    if (names) {
#line 102
      if (*names) {
#line 103
        namesglob = names;
      }
    }
  }
#line 105
  return (namesglob);
}
}
#line 111 "manfile.c"
static char **glob_for_file(char *dir , char *sec , char *name , int type ) 
{ 
  char **names ;
  char **tmp ;
  char ext[2] ;
  unsigned short const   **tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 115
  if (standards & 256) {
    {
    {
#line 118
    tmp = glob_for_file_ext(dir, sec, name, (char *)"", type);
    }
    }
#line 118
    return (tmp);
  }
  {
  {
#line 122
  names = glob_for_file_ext(dir, sec, name, sec, type);
  }
  }
#line 124
  if (! names) {
#line 125
    return ((char **)0);
  }
#line 128
  if (! *names) {
    {
    {
#line 128
    tmp___0 = __ctype_b_loc();
    }
    }
#line 128
    if ((int const   )*(*tmp___0 + (int )*(sec + 0)) & 2048) {
#line 128
      if ((int )*(sec + 1) != 0) {
        {
#line 130
        ext[0] = *(sec + 0);
#line 131
        ext[1] = (char)0;
        {
#line 132
        names = glob_for_file_ext(dir, sec, name, ext, type);
        }
        }
      }
    }
  }
#line 135
  if (! names) {
#line 136
    return ((char **)0);
  }
#line 139
  if (! *names) {
    {
    {
#line 140
    names = glob_for_file_ext(dir, sec, name, (char *)"man", type);
    }
    }
  }
#line 142
  return (names);
}
}
#line 150 "manfile.c"
static struct manpage *manfile_from_sec_and_dir(char *dir , char *sec , char *name ,
                                                int flags ) 
{ 
  struct manpage *res ;
  struct manpage *p ;
  char **names ;
  char **np ;
  int types[3] ;
  int i ;
  int type ;
  void *tmp ;
  void *__cil_tmp13 ;

  {
#line 152
  res = (struct manpage *)0;
#line 155
  types[0] = 1;
#line 155
  types[1] = 2;
#line 155
  types[2] = 4;
#line 158
  i = 0;
  {
  {
#line 158
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i < 3)) {
#line 158
      goto while_break;
    }
#line 159
    type = types[i];
#line 163
    if (type == 2) {
#line 163
      if (flags & 4) {
#line 163
        if (! standards) {
#line 164
          goto __Cont;
        }
      }
    }
#line 166
    if (flags & type) {
      {
      {
#line 167
      names = glob_for_file(dir, sec, name, type);
      }
      }
#line 168
      if (names) {
#line 169
        np = names;
        {
        {
#line 169
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 169
          if (! *np) {
#line 169
            goto while_break___0;
          }
          {
          {
#line 170
          tmp = malloc((size_t )sizeof(*p));
          }
#line 170
          p = (struct manpage *)tmp;
          }
#line 171
          if (! p) {
#line 172
            goto while_break___0;
          }
          {
#line 173
          p->filename = *np;
#line 174
          p->type = type;
#line 175
          p->next = (struct manpage *)0;
          {
#line 176
          append(& res, p);
          }
          }
#line 177
          if (res) {
#line 177
            if (flags & 8) {
#line 178
              goto while_break___0;
            }
          }
#line 169
          np ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 180
        free((void *)names);
        }
        }
      }
    }
#line 184
    if (res) {
#line 185
      return (res);
    }
    __Cont: 
#line 158
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (res);
}
}
#line 195 "manfile.c"
static struct manpage *manfile_from_section(char *name , char *section , int flags ,
                                            char **manpath ) 
{ 
  char **mp ;
  struct manpage *res ;
  struct manpage *tmp ;
  char sec[2] ;
  struct manpage *tmp___0 ;
  unsigned short const   **tmp___1 ;
  void *__cil_tmp11 ;

  {
#line 198
  res = (struct manpage *)0;
#line 200
  mp = manpath;
  {
  {
#line 200
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 200
    if (! *mp) {
#line 200
      goto while_break;
    }
    {
    {
#line 201
    tmp = manfile_from_sec_and_dir(*mp, section, name, flags);
    }
    {
#line 201
    append(& res, tmp);
    }
    }
#line 202
    if (res) {
#line 202
      if (flags & 8) {
#line 203
        goto while_break;
      }
    }
#line 200
    mp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  if ((unsigned int )res == (unsigned int )((void *)0)) {
    {
    {
#line 205
    tmp___1 = __ctype_b_loc();
    }
    }
#line 205
    if ((int const   )*(*tmp___1 + (int )*(section + 0)) & 2048) {
#line 205
      if (*(section + 1)) {
#line 208
        sec[0] = *(section + 0);
#line 209
        sec[1] = (char)0;
#line 210
        mp = manpath;
        {
        {
#line 210
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 210
          if (! *mp) {
#line 210
            goto while_break___0;
          }
          {
          {
#line 211
          tmp___0 = manfile_from_sec_and_dir(*mp, sec, name, flags);
          }
          {
#line 211
          append(& res, tmp___0);
          }
          }
#line 212
          if (res) {
#line 212
            if (flags & 8) {
#line 213
              goto while_break___0;
            }
          }
#line 210
          mp ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 216
  return (res);
}
}
#line 227 "manfile.c"
struct manpage *manfile(char *name , char *section , int flags , char **sectionlist ,
                        char **manpath , char *(*tocat)(char *man_filename , char *ext ,
                                                        int flags ) ) 
{ 
  char **sl ;
  struct manpage *res ;
  struct manpage *tmp ;

  {
#line 234
  standards = flags & 480;
#line 235
  to_cat_filename = tocat;
#line 237
  if (! name) {
#line 238
    res = (struct manpage *)0;
  } else
#line 237
  if (! manpath) {
#line 238
    res = (struct manpage *)0;
  } else
#line 239
  if (section) {
    {
    {
#line 240
    res = manfile_from_section(name, section, flags, manpath);
    }
    }
  } else
#line 241
  if (sectionlist) {
#line 242
    res = (struct manpage *)0;
#line 243
    sl = sectionlist;
    {
    {
#line 243
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 243
      if (! *sl) {
#line 243
        goto while_break;
      }
      {
      {
#line 244
      tmp = manfile_from_section(name, *sl, flags, manpath);
      }
      {
#line 244
      append(& res, tmp);
      }
      }
#line 245
      if (res) {
#line 245
        if (flags & 24) {
#line 246
          goto while_break;
        }
      }
#line 243
      sl ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 249
  return (res);
}
}
#line 1 "manpath.o"
/* #pragma merger(0,"./manpath.i","-Wall,-Wstrict-prototypes,-Wmissing-prototypes") */
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 87
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 207 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                                                            struct stat * __restrict  __statbuf ) ;
#line 326
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
#line 363
__inline static  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                                                            struct stat * __restrict  __statbuf ) ;
#line 363 "/usr/include/sys/stat.h"
__inline static int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 366
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
  }
#line 366
  return (tmp);
}
}
#line 5 "man-config.h"
struct dirs cfdirlist  ;
#line 4 "man-getopt.h"
int alt_system  ;
#line 5 "man-getopt.h"
char *alt_system_name  ;
#line 6 "man-getopt.h"
char *opt_manpath  ;
#line 5 "util.h"
char *my_malloc(int n ) ;
#line 43 "manpath.c"
static int mandirlistlth  =    0;
#line 44 "manpath.c"
static int mandirlistmax  =    0;
#line 50 "manpath.c"
static void split(char *string , void (*fn)(char * , int  ) , int perrs ) 
{ 
  char *p ;
  char *q ;
  char *r ;

  {
#line 54
  if (string) {
    {
    {
#line 55
    p = my_strdup(string);
    }
#line 56
    q = p;
    }
    {
    {
#line 56
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 57
      r = index((char const   *)q, ':');
      }
      }
#line 58
      if (r) {
        {
#line 59
        *r = (char)0;
        {
#line 60
        (*fn)(q, perrs);
        }
#line 61
        q = r + 1;
        }
      } else {
        {
        {
#line 63
        (*fn)(q, perrs);
        }
        }
#line 64
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 67
    free((void *)p);
    }
    }
  }
#line 69
  return;
}
}
#line 71 "manpath.c"
static void split2(char *s , char *string , void (*fn)(char * , char * , int  ) ,
                   int perrs ) 
{ 
  char *p ;
  char *q ;
  char *r ;

  {
#line 75
  if (string) {
    {
    {
#line 76
    p = my_strdup(string);
    }
#line 77
    q = p;
    }
    {
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 78
      r = index((char const   *)q, ':');
      }
      }
#line 79
      if (r) {
        {
#line 80
        *r = (char)0;
        {
#line 81
        (*fn)(s, q, perrs);
        }
#line 82
        q = r + 1;
        }
      } else {
        {
        {
#line 84
        (*fn)(s, q, perrs);
        }
        }
#line 85
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 88
    free((void *)p);
    }
    }
  }
#line 90
  return;
}
}
#line 96 "manpath.c"
static int is_directory(char *path ) 
{ 
  struct stat sb ;
  int tmp ;

  {
  {
  {
#line 100
  tmp = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& sb));
  }
  }
#line 100
  if (tmp != 0) {
#line 101
    return (-1);
  }
#line 103
  return ((sb.st_mode & 16384U) == 16384U);
}
}
#line 110 "manpath.c"
static char *find_man_subdir(char *p ) 
{ 
  int len ;
  char *t ;
  char *sp ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 115
  tmp = strlen((char const   *)p);
  }
#line 115
  len = (int )tmp;
  {
#line 117
  t = my_malloc((int )((unsigned int )len + 20U));
  }
  {
#line 119
  memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)p, (unsigned int )len);
  }
  {
#line 120
  strcpy((char */* __restrict  */)(t + len), (char const   */* __restrict  */)"/man");
  }
  {
#line 122
  tmp___0 = is_directory(t);
  }
  }
#line 122
  if (tmp___0 == 1) {
#line 123
    return (t);
  }
  {
  {
#line 125
  strcpy((char */* __restrict  */)(t + len), (char const   */* __restrict  */)"/MAN");
  }
  {
#line 127
  tmp___1 = is_directory(t);
  }
  }
#line 127
  if (tmp___1 == 1) {
#line 128
    return (t);
  }
  {
#line 131
  *(t + len) = (char)0;
  {
#line 132
  sp = rindex((char const   *)t, '/');
  }
  }
#line 132
  if ((unsigned int )sp != (unsigned int )((void *)0)) {
#line 133
    *sp = (char)0;
#line 134
    len = (int )(sp - t);
  } else {
    {
    {
#line 136
    strcpy((char */* __restrict  */)(t + len), (char const   */* __restrict  */)"/..");
    }
#line 137
    len += 3;
    }
  }
  {
  {
#line 141
  strcpy((char */* __restrict  */)(t + len), (char const   */* __restrict  */)"/man");
  }
  {
#line 143
  tmp___2 = is_directory(t);
  }
  }
#line 143
  if (tmp___2 == 1) {
#line 144
    return (t);
  }
  {
  {
#line 148
  strcpy((char */* __restrict  */)(t + len), (char const   */* __restrict  */)"/man1");
  }
  {
#line 150
  tmp___3 = is_directory(t);
  }
  }
#line 150
  if (tmp___3 == 1) {
#line 151
    *(t + len) = (char)0;
#line 152
    return (t);
  }
  {
  {
#line 155
  strcpy((char */* __restrict  */)(t + len), (char const   */* __restrict  */)"/man8");
  }
  {
#line 157
  tmp___4 = is_directory(t);
  }
  }
#line 157
  if (tmp___4 == 1) {
#line 158
    *(t + len) = (char)0;
#line 159
    return (t);
  }
  {
  {
#line 162
  free((void *)t);
  }
  }
#line 163
  return ((char *)((void *)0));
}
}
#line 169 "manpath.c"
static void add_to_list(char *dir , char *lang , int perrs ) 
{ 
  int status ;
  char cwd[8192] ;
  char **dp ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int i ;
  int ct ;
  char **p ;
  char *tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 175
  if (! lang) {
#line 176
    lang = (char *)"";
  }
#line 179
  if ((int )*dir != 47) {
    {
    {
#line 180
    tmp = getcwd(cwd, (size_t )sizeof(cwd));
    }
    }
#line 180
    if (! tmp) {
#line 181
      return;
    }
    {
    {
#line 182
    tmp___0 = strlen((char const   *)dir);
    }
    {
#line 182
    tmp___1 = strlen((char const   *)lang);
    }
    {
#line 182
    tmp___2 = strlen((char const   *)(cwd));
    }
    }
#line 182
    if ((unsigned long )(((tmp___0 + tmp___1) + tmp___2) + 3U) > sizeof(cwd)) {
#line 183
      return;
    }
    {
    {
#line 184
    tmp___3 = strncmp((char const   *)dir, "./", 2U);
    }
    }
#line 184
    if (! tmp___3) {
#line 185
      dir += 2;
    }
    {
    {
#line 186
    tmp___5 = strncmp((char const   *)dir, "../", 3U);
    }
    }
#line 186
    if (! tmp___5) {
      {
#line 187
      dir += 3;
      {
#line 188
      tmp___4 = rindex((char const   *)(cwd), '/');
      }
#line 188
      *tmp___4 = (char)0;
      }
    }
    {
    {
#line 190
    strcat((char */* __restrict  */)(cwd), (char const   */* __restrict  */)"/");
    }
    {
#line 191
    strcat((char */* __restrict  */)(cwd), (char const   */* __restrict  */)dir);
    }
    }
#line 192
    if (*lang) {
      {
      {
#line 193
      strcat((char */* __restrict  */)(cwd), (char const   */* __restrict  */)"/");
      }
      {
#line 194
      strcat((char */* __restrict  */)(cwd), (char const   */* __restrict  */)lang);
      }
      }
    }
#line 196
    dir = cwd;
  } else
#line 197
  if (*lang) {
    {
    {
#line 198
    tmp___6 = strlen((char const   *)dir);
    }
    {
#line 198
    tmp___7 = strlen((char const   *)lang);
    }
    }
#line 198
    if ((unsigned long )((tmp___6 + tmp___7) + 2U) > sizeof(cwd)) {
#line 199
      return;
    }
    {
    {
#line 200
    strcpy((char */* __restrict  */)(cwd), (char const   */* __restrict  */)dir);
    }
    {
#line 201
    strcat((char */* __restrict  */)(cwd), (char const   */* __restrict  */)"/");
    }
    {
#line 202
    strcat((char */* __restrict  */)(cwd), (char const   */* __restrict  */)lang);
    }
#line 203
    dir = cwd;
    }
  }
#line 206
  if (mandirlist) {
#line 207
    dp = mandirlist;
    {
    {
#line 207
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 207
      if (! *dp) {
#line 207
        goto while_break;
      }
      {
      {
#line 208
      tmp___8 = strcmp((char const   *)*dp, (char const   *)dir);
      }
      }
#line 208
      if (! tmp___8) {
#line 209
        return;
      }
#line 207
      dp ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 216
  status = is_directory(dir);
  }
  }
#line 218
  if (status < 0) {
#line 218
    if (perrs) {
      {
      {
#line 219
      gripe(48, dir);
      }
      }
    } else {
#line 221
      goto _L___1;
    }
  } else
  _L___1: 
#line 220
  if (status == 0) {
#line 220
    if (perrs) {
      {
      {
#line 221
      gripe(49, dir);
      }
      }
    } else {
#line 223
      goto _L___0;
    }
  } else
  _L___0: 
#line 222
  if (status == 1) {
#line 223
    if (debug) {
      {
      {
#line 224
      gripe(50, dir);
      }
      }
    }
#line 226
    if (! mandirlist) {
#line 227
      goto _L;
    } else
#line 226
    if (mandirlistlth + 1 >= mandirlistmax) {
      _L: 
      {
#line 227
      ct = mandirlistmax + 100;
      {
#line 228
      tmp___9 = my_malloc((int )((unsigned long )((unsigned int )ct) * sizeof(char *)));
      }
#line 228
      p = (char **)tmp___9;
      }
#line 230
      if (mandirlist) {
#line 231
        i = 0;
        {
        {
#line 231
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 231
          if (! (i < mandirlistlth)) {
#line 231
            goto while_break___0;
          }
#line 232
          *(p + i) = *(mandirlist + i);
#line 231
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 233
        free((void *)mandirlist);
        }
        }
      }
#line 235
      mandirlistmax = ct;
#line 236
      mandirlist = p;
    }
    {
#line 238
    tmp___10 = mandirlistlth;
#line 238
    mandirlistlth ++;
    {
#line 238
    *(mandirlist + tmp___10) = my_strdup(dir);
    }
#line 239
    *(mandirlist + mandirlistlth) = (char *)0;
    }
  }
#line 241
  return;
}
}
#line 243 "manpath.c"
static void add_to_mandirlist_x(char *dir , char *lang , int perrs ) 
{ 
  char lang2[3] ;
  size_t tmp ;
  void *__cil_tmp6 ;

  {
#line 245
  if (lang) {
    {
    {
#line 245
    tmp = strlen((char const   *)lang);
    }
    }
#line 245
    if (tmp > 2U) {
      {
      {
#line 248
      strncpy((char */* __restrict  */)(lang2), (char const   */* __restrict  */)lang,
              2U);
      }
#line 249
      lang2[2] = (char)0;
      {
#line 250
      add_to_list(dir, lang2, perrs);
      }
      }
    }
  }
  {
  {
#line 252
  add_to_list(dir, lang, perrs);
  }
  }
#line 253
  return;
}
}
#line 255 "manpath.c"
static void add_to_mandirlist(char *dir , int perrs ) 
{ 
  char *lang ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 259
  if (alt_system) {
    {
    {
#line 260
    add_to_list(dir, alt_system_name, perrs);
    }
    }
  } else {
    {
    {
#line 262
    lang = getenv("LANG");
    }
    }
#line 262
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
      {
      {
#line 263
      split2(dir, lang, & add_to_mandirlist_x, perrs);
      }
      }
    }
    {
    {
#line 264
    lang = getenv("LANGUAGE");
    }
    }
#line 264
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
      {
      {
#line 265
      split2(dir, lang, & add_to_mandirlist_x, perrs);
      }
      }
    }
    {
    {
#line 266
    lang = getenv("LC_MESSAGES");
    }
    }
#line 266
    if ((unsigned int )lang != (unsigned int )((void *)0)) {
      {
      {
#line 267
      split2(dir, lang, & add_to_mandirlist_x, perrs);
      }
      }
    }
    {
    {
#line 268
    add_to_mandirlist_x(dir, (char *)0, perrs);
    }
    }
  }
#line 270
  return;
}
}
#line 285 "manpath.c"
static void get_manpath_from_pathdir(char *dir , int perrs ) 
{ 
  char *t ;
  struct dirs *dlp ;
  int tmp ;

  {
#line 290
  if (debug) {
    {
    {
#line 291
    gripe(51, dir);
    }
    }
  }
#line 297
  if (*dir) {
#line 298
    dlp = cfdirlist.nxt;
    {
    {
#line 298
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 298
      if (! dlp) {
#line 298
        goto while_break;
      }
      {
      {
#line 299
      tmp = strcmp((char const   *)dir, (char const   *)(dlp->bindir));
      }
      }
#line 299
      if (! tmp) {
#line 300
        if (debug) {
          {
          {
#line 301
          gripe(52);
          }
          }
        }
        {
        {
#line 303
        add_to_mandirlist(dlp->mandir, perrs);
        }
        }
#line 304
        return;
      }
#line 298
      dlp = dlp->nxt;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 315
  if (debug) {
    {
    {
#line 316
    gripe(53);
    }
    }
  }
  {
  {
#line 318
  t = find_man_subdir(dir);
  }
  }
#line 319
  if ((unsigned int )t != (unsigned int )((void *)0)) {
#line 320
    if (debug) {
      {
      {
#line 321
      gripe(54);
      }
      }
    }
    {
    {
#line 323
    add_to_mandirlist(t, perrs);
    }
    {
#line 324
    free((void *)t);
    }
    }
  } else
#line 326
  if (debug) {
    {
    {
#line 327
    gripe(55);
    }
    }
  }
#line 329
  return;
}
}
#line 331 "manpath.c"
static void add_default_manpath(int perrs ) 
{ 
  struct dirs *dlp ;

  {
#line 335
  if (debug) {
    {
    {
#line 336
    gripe(56);
    }
    }
  }
#line 338
  dlp = cfdirlist.nxt;
  {
  {
#line 338
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 338
    if (! dlp) {
#line 338
      goto while_break;
    }
#line 339
    if (dlp->mandatory) {
      {
      {
#line 340
      add_to_mandirlist(dlp->mandir, perrs);
      }
      }
    }
#line 338
    dlp = dlp->nxt;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return;
}
}
#line 343 "manpath.c"
static void to_mandirlist(char *s , int perrs ) 
{ 
  char *path ;
  char *__cil_tmp4 ;

  {
#line 347
  if (*s) {
    {
    {
#line 348
    add_to_mandirlist(s, perrs);
    }
    }
  } else {
    {
    {
#line 351
    path = getenv("PATH");
    }
    }
#line 351
    if ((unsigned int )path != (unsigned int )((void *)0)) {
      {
      {
#line 352
      split(path, & get_manpath_from_pathdir, perrs);
      }
      }
    }
    {
    {
#line 353
    add_default_manpath(perrs);
    }
    }
  }
#line 355
  return;
}
}
#line 359 "manpath.c"
static int done  =    0;
#line 357 "manpath.c"
void init_manpath(void) 
{ 
  char *manp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 361
  if (! done) {
#line 364
    manp = opt_manpath;
#line 364
    if ((unsigned int )manp == (unsigned int )((void *)0)) {
      {
      {
#line 364
      manp = getenv("MANPATH");
      }
      }
#line 364
      if ((unsigned int )manp == (unsigned int )((void *)0)) {
#line 366
        manp = (char *)"";
      }
    }
    {
    {
#line 367
    split(manp, & to_mandirlist, 0);
    }
#line 368
    done = 1;
    }
  }
#line 370
  return;
}
}
#line 372 "manpath.c"
void prmanpath(void) 
{ 
  char **dp ;
  char **dp0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 376
  if (mandirlist) {
#line 377
    dp = mandirlist;
#line 377
    dp0 = dp;
    {
    {
#line 377
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 377
      if (! *dp) {
#line 377
        goto while_break;
      }
#line 378
      if ((unsigned int )dp != (unsigned int )dp0) {
        {
        {
#line 379
        printf((char const   */* __restrict  */)":");
        }
        }
      }
      {
      {
#line 380
      printf((char const   */* __restrict  */)"%s", *dp);
      }
#line 377
      dp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 383
  printf((char const   */* __restrict  */)"\n");
  }
  }
#line 384
  return;
}
}
#line 1 "man-config.o"
/* #pragma merger(0,"./man-config.i","-Wall,-Wstrict-prototypes,-Wmissing-prototypes") */
#line 3 "man-config.h"
void read_config_file(char *cf ) ;
#line 6
char *configuration_file ;
#line 14 "paths.h"
static struct paths paths[20]  = 
#line 14 "paths.h"
  {      {(char *)"MANBIN", (char *)""}, 
        {(char *)"APROPOS", (char *)"/usr/bin/apropos"}, 
        {(char *)"WHATIS", (char *)"/usr/bin/whatis"}, 
        {(char *)"TROFF", (char *)"/usr/bin/X11/groff -Tps -mandoc"}, 
        {(char *)"NROFF", (char *)"/usr/bin/X11/groff -Tlatin1 -mandoc"}, 
        {(char *)"EQN", (char *)"/usr/bin/X11/geqn -Tps"}, 
        {(char *)"NEQN", (char *)"/usr/bin/X11/geqn -Tlatin1"}, 
        {(char *)"TBL", (char *)"/usr/bin/X11/gtbl"}, 
        {(char *)"COL", (char *)""}, 
        {(char *)"REFER", (char *)""}, 
        {(char *)"PIC", (char *)"/usr/bin/X11/gpic"}, 
        {(char *)"VGRIND", (char *)""}, 
        {(char *)"GRAP", (char *)""}, 
        {(char *)"PAGER", (char *)"/usr/bin/X11/less -is"}, 
        {(char *)"CMP", (char *)"/usr/bin/X11/cmp -s"}, 
        {(char *)"CAT", (char *)"/bin/cat"}, 
        {(char *)"COMPRESS", (char *)"/bin/gzip"}, 
        {(char *)"COMPRESS_EXT", (char *)".gz"}, 
        {(char *)"DECOMPRESS", (char *)"/bin/gunzip -c"}, 
        {(char *)"MANSECT", (char *)"1:8:2:3:4:5:6:7:9:tcl:n:l:p:o"}};
#line 37 "man-config.c"
static void addval(char *buf___0 ) 
{ 
  int i ;
  int len ;
  char *bp ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 42
  i = 0;
  {
  {
#line 42
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 42
    if (! ((unsigned long )((unsigned int )i) < sizeof(paths) / sizeof(paths[0]))) {
#line 42
      goto while_break;
    }
    {
    {
#line 43
    tmp = strlen((char const   *)paths[i].name);
    }
#line 43
    len = (int )tmp;
#line 44
    bp = buf___0 + len;
    {
#line 45
    tmp___0 = strncmp((char const   *)buf___0, (char const   *)paths[i].name, (unsigned int )len);
    }
    }
#line 45
    if (! tmp___0) {
#line 45
      if (! *bp) {
#line 46
        goto _L___0;
      } else
#line 45
      if ((int )*bp == 32) {
#line 46
        goto _L___0;
      } else
#line 45
      if ((int )*bp == 9) {
        _L___0: 
        {
        {
#line 46
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 46
          if (! ((int )*bp == 32)) {
#line 46
            if (! ((int )*bp == 9)) {
#line 46
              goto while_break___0;
            }
          }
#line 47
          bp ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 48
        paths[i].path = my_strdup(bp);
        }
        }
#line 49
        return;
      }
    }
#line 42
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 52
  gripe(18, buf___0);
  }
  }
#line 53
  return;
}
}
#line 55 "man-config.c"
char *getval(char *cmd ) 
{ 
  int i ;
  int tmp ;
  char *__cil_tmp4 ;

  {
#line 59
  i = 0;
  {
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )((unsigned int )i) < sizeof(paths) / sizeof(paths[0]))) {
#line 59
      goto while_break;
    }
    {
    {
#line 60
    tmp = strcmp((char const   *)cmd, (char const   *)paths[i].name);
    }
    }
#line 60
    if (! tmp) {
#line 61
      return (paths[i].path);
    }
#line 59
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 62
  gripe(19, cmd);
  }
  }
#line 63
  return ((char *)"");
}
}
#line 66 "man-config.c"
static void adddir(char *bp , int mandatory ) 
{ 
  int i ;
  struct dirs *dlp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 71
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 71
    if (! ((int )*bp == 32)) {
#line 71
      if (! ((int )*bp == 9)) {
#line 71
        goto while_break;
      }
    }
#line 72
    bp ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if ((int )*bp == 0) {
    {
    {
#line 74
    gripe(3);
    }
    }
  }
#line 76
  dlp = & cfdirlist;
  {
  {
#line 77
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 77
    if (! dlp->nxt) {
#line 77
      goto while_break___0;
    }
#line 78
    dlp = dlp->nxt;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 79
  tmp = my_malloc((int )sizeof(struct dirs ));
  }
#line 79
  dlp->nxt = (struct dirs *)tmp;
#line 80
  dlp = dlp->nxt;
#line 81
  dlp->mandatory = mandatory;
#line 82
  dlp->nxt = (struct dirs *)0;
  }
#line 84
  if (! mandatory) {
#line 85
    i = 0;
    {
    {
#line 86
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 86
      if (*bp) {
#line 86
        if ((int )*bp == 32) {
#line 86
          goto while_break___1;
        } else
#line 86
        if ((int )*bp == 9) {
#line 86
          goto while_break___1;
        }
      } else {
#line 86
        goto while_break___1;
      }
#line 87
      if (i < 4095) {
#line 88
        tmp___0 = i;
#line 88
        i ++;
#line 88
        dlp->bindir[tmp___0] = *bp;
      }
#line 89
      bp ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 91
    dlp->bindir[i] = (char)0;
    {
    {
#line 93
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 93
      if (! ((int )*bp == 32)) {
#line 93
        if (! ((int )*bp == 9)) {
#line 93
          goto while_break___2;
        }
      }
#line 94
      bp ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 96
    dlp->bindir[0] = (char)0;
  }
#line 99
  i = 0;
  {
  {
#line 100
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 100
    if (*bp) {
#line 100
      if ((int )*bp == 32) {
#line 100
        goto while_break___3;
      } else
#line 100
      if ((int )*bp == 9) {
#line 100
        goto while_break___3;
      }
    } else {
#line 100
      goto while_break___3;
    }
#line 101
    if (i < 4095) {
#line 102
      tmp___1 = i;
#line 102
      i ++;
#line 102
      dlp->mandir[tmp___1] = *bp;
    }
#line 103
    bp ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 105
  dlp->mandir[i] = (char)0;
  {
  {
#line 107
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 107
    if (! ((int )*bp == 32)) {
#line 107
      if (! ((int )*bp == 9)) {
#line 107
        goto while_break___4;
      }
    }
#line 108
    bp ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 110
  i = 0;
  {
  {
#line 111
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 111
    if (*bp) {
#line 111
      if ((int )*bp == 32) {
#line 111
        goto while_break___5;
      } else
#line 111
      if ((int )*bp == 9) {
#line 111
        goto while_break___5;
      }
    } else {
#line 111
      goto while_break___5;
    }
#line 112
    if (i < 4095) {
#line 113
      tmp___2 = i;
#line 113
      i ++;
#line 113
      dlp->catdir[tmp___2] = *bp;
    }
#line 114
    bp ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 116
  dlp->catdir[i] = (char)0;
#line 118
  if (debug) {
#line 119
    if (dlp->mandatory) {
      {
      {
#line 120
      gripe(20, dlp->mandir);
      }
      }
    } else {
      {
      {
#line 122
      gripe(21, dlp->bindir, dlp->mandir);
      }
      }
    }
#line 123
    if (dlp->catdir[0]) {
      {
      {
#line 124
      gripe(22, dlp->catdir);
      }
      }
    }
  }
#line 126
  return;
}
}
#line 128 "man-config.c"
static struct xp uncompressors  ;
#line 134 "man-config.c"
static void addext(char *bp ) 
{ 
  char *p ;
  char csv ;
  struct xp *xpp ;
  char *tmp ;

  {
#line 139
  xpp = & uncompressors;
  {
  {
#line 140
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 140
    if (! xpp->nxt) {
#line 140
      goto while_break;
    }
#line 141
    xpp = xpp->nxt;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 142
  tmp = my_malloc((int )sizeof(struct xp ));
  }
#line 142
  xpp->nxt = (struct xp *)tmp;
#line 143
  xpp = xpp->nxt;
#line 144
  xpp->nxt = (struct xp *)0;
#line 146
  p = bp;
  }
  {
  {
#line 147
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 147
    if (*p) {
#line 147
      if ((int )*p == 32) {
#line 147
        goto while_break___0;
      } else
#line 147
      if ((int )*p == 9) {
#line 147
        goto while_break___0;
      }
    } else {
#line 147
      goto while_break___0;
    }
#line 148
    p ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 149
  csv = *p;
#line 150
  *p = (char)0;
  {
#line 151
  xpp->extension = my_strdup(bp);
  }
#line 153
  *p = csv;
  }
  {
  {
#line 154
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 154
    if (! ((int )*p == 32)) {
#line 154
      if (! ((int )*p == 9)) {
#line 154
        goto while_break___1;
      }
    }
#line 155
    p ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 156
  xpp->expander = my_strdup(p);
  }
  }
#line 157
  return;
}
}
#line 159 "man-config.c"
char *get_expander(char *file ) 
{ 
  struct xp *xp ;
  char *extp ;
  int len ;
  size_t tmp ;
  char *dirname_end ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 162
  extp = (char *)((void *)0);
#line 164
  if (dohp) {
    {
    {
#line 168
    tmp = strlen((char const   *)dohp);
    }
#line 168
    len = (int )tmp;
    {
#line 169
    tmp___0 = rindex((char const   *)file, '/');
    }
#line 169
    dirname_end = tmp___0;
    }
#line 170
    if (dirname_end) {
      {
      {
#line 170
      tmp___1 = strncmp((char const   *)(dirname_end - len), (char const   *)dohp,
                        (unsigned int )len);
      }
      }
#line 170
      if (! tmp___1) {
#line 171
        extp = dohp;
      }
    }
  } else {
    {
    {
#line 173
    extp = rindex((char const   *)file, '.');
    }
    }
  }
#line 174
  if ((unsigned int )extp != (unsigned int )((void *)0)) {
#line 175
    if (uncompressors.nxt) {
#line 176
      xp = uncompressors.nxt;
      {
      {
#line 176
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 176
        if (! xp) {
#line 176
          goto while_break;
        }
        {
        {
#line 177
        tmp___2 = strcmp((char const   *)extp, (char const   *)xp->extension);
        }
        }
#line 177
        if (! tmp___2) {
#line 178
          return (xp->expander);
        }
#line 176
        xp = xp->nxt;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 179
      tmp___4 = getval((char *)"COMPRESS_EXT");
      }
      {
#line 179
      tmp___5 = strcmp((char const   *)extp, (char const   *)tmp___4);
      }
      }
#line 179
      if (! tmp___5) {
        {
        {
#line 180
        tmp___3 = getval((char *)"DECOMPRESS");
        }
        }
#line 180
        return (tmp___3);
      }
    }
  }
#line 183
  return ((char *)((void *)0));
}
}
#line 186 "man-config.c"
char *configuration_file  =    (char *)"[no configuration file]";
#line 188 "man-config.c"
char *default_config_files[7]  = {      (char *)"/usr/lib/man.conf",      (char *)"/usr/lib/man.config",      (char *)"/usr/lib/man.conf",      (char *)"/etc/man.config", 
        (char *)"/etc/man.conf",      (char *)"/usr/share/misc/man.config",      (char *)"/usr/share/misc/man.conf"};
#line 197 "man-config.c"
void read_config_file(char *cf ) 
{ 
  char *bp ;
  char *p ;
  char buf___0[4096] ;
  FILE *config ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 202
  config = (FILE *)((void *)0);
#line 204
  if (cf) {
    {
    {
#line 206
    config = fopen((char const   */* __restrict  */)cf, (char const   */* __restrict  */)"r");
    }
    }
#line 206
    if ((unsigned int )config == (unsigned int )((void *)0)) {
      {
      {
#line 207
      perror((char const   *)cf);
      }
      {
#line 208
      gripe(2, cf);
      }
      }
#line 209
      return;
    }
  } else {
#line 216
    i = 0;
    {
    {
#line 216
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 216
      if (! ((unsigned long )((unsigned int )i) < sizeof(default_config_files) / sizeof(default_config_files[0]))) {
#line 216
        goto while_break;
      }
      {
#line 217
      cf = default_config_files[i];
      {
#line 218
      config = fopen((char const   */* __restrict  */)cf, (char const   */* __restrict  */)"r");
      }
      }
#line 218
      if ((unsigned int )config != (unsigned int )((void *)0)) {
#line 219
        goto while_break;
      }
#line 216
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 222
    if ((unsigned int )config == (unsigned int )((void *)0)) {
      {
      {
#line 223
      gripe(2, "/usr/lib/man.conf");
      }
      }
#line 224
      return;
    }
  }
#line 228
  if (debug) {
    {
    {
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading config file %s\n",
            cf);
    }
    }
  }
#line 230
  configuration_file = cf;
  {
  {
#line 232
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 232
    bp = fgets((char */* __restrict  */)(buf___0), 4096, (FILE */* __restrict  */)config);
    }
    }
#line 232
    if (! ((unsigned int )bp != (unsigned int )((void *)0))) {
#line 232
      goto while_break___0;
    }
    {
    {
#line 233
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 233
      if (! ((int )*bp == 32)) {
#line 233
        if (! ((int )*bp == 9)) {
#line 233
          goto while_break___1;
        }
      }
#line 234
      bp ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 236
    p = bp;
    {
    {
#line 236
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 236
      if (*p) {
#line 236
        if ((int )*p != 35) {
#line 236
          if (! ((int )*p != 10)) {
#line 236
            goto while_break___2;
          }
        } else {
#line 236
          goto while_break___2;
        }
      } else {
#line 236
        goto while_break___2;
      }
#line 236
      p ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 237
    if (! *p) {
      {
      {
#line 238
      gripe(23);
      }
      {
#line 239
      gripe(1, cf);
      }
      }
#line 240
      return;
    }
    {
    {
#line 242
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 242
      if ((unsigned int )p > (unsigned int )bp) {
#line 242
        if (! ((int )*(p + -1) == 32)) {
#line 242
          if (! ((int )*(p + -1) == 9)) {
#line 242
            goto while_break___3;
          }
        }
      } else {
#line 242
        goto while_break___3;
      }
#line 243
      p --;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 244
    *p = (char)0;
#line 246
    if ((int )*bp == 0) {
#line 247
      goto while_continue___0;
    }
    {
    {
#line 249
    tmp___3 = strncmp("MANPATH_MAP", (char const   *)bp, 11U);
    }
    }
#line 249
    if (tmp___3) {
      {
      {
#line 251
      tmp___2 = strncmp("MANPATH", (char const   *)bp, 7U);
      }
      }
#line 251
      if (tmp___2) {
        {
        {
#line 253
        tmp___1 = strncmp("MANDATORY_MANPATH", (char const   *)bp, 17U);
        }
        }
#line 253
        if (tmp___1) {
          {
          {
#line 255
          tmp___0 = strncmp("FHS", (char const   *)bp, 3U);
          }
          }
#line 255
          if (tmp___0) {
            {
            {
#line 257
            tmp = strncmp("FSSTND", (char const   *)bp, 6U);
            }
            }
#line 257
            if (tmp) {
#line 259
              if ((int )*bp == 46) {
                {
                {
#line 260
                addext(bp);
                }
                }
              } else {
                {
                {
#line 262
                addval(bp);
                }
                }
              }
            } else {
#line 258
              fsstnd = 1;
            }
          } else {
#line 256
            fhs = 1;
          }
        } else {
          {
          {
#line 254
          adddir(bp + 17, 1);
          }
          }
        }
      } else {
        {
        {
#line 252
        adddir(bp + 7, 1);
        }
        }
      }
    } else {
      {
      {
#line 250
      adddir(bp + 11, 0);
      }
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 264
  return;
}
}
#line 1 "man-getopt.o"
/* #pragma merger(0,"./man-getopt.i","-Wall,-Wstrict-prototypes,-Wmissing-prototypes") */
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 4 "gripes.h"
void fatal(int n  , ...) ;
#line 4 "util.h"
void no_privileges(void) ;
#line 1 "version.h"
static char version[5]  = {      (char )'1',      (char )'.',      (char )'5',      (char )'h', 
        (char )'\000'};
#line 16 "man-getopt.c"
int global_apropos  =    0;
#line 18 "man-getopt.c"
static void print_version(void) 
{ 


  {
  {
  {
#line 20
  gripe(13, progname, version);
  }
  }
#line 21
  return;
}
}
#line 23 "man-getopt.c"
static void usage(void) 
{ 


  {
  {
  {
#line 25
  print_version();
  }
  {
#line 26
  gripe(59, progname);
  }
  {
#line 28
  gripe(60);
  }
  {
#line 30
  gripe(61);
  }
  {
#line 31
  gripe(62);
  }
  {
#line 32
  gripe(63);
  }
  {
#line 33
  gripe(64);
  }
  {
#line 35
  gripe(65);
  }
  {
#line 37
  gripe(66);
  }
  {
#line 38
  exit(1);
  }
  }
}
}
#line 41 "man-getopt.c"
static char short_opts[28]  = 
#line 41
  {      (char )'C',      (char )':',      (char )'M',      (char )':', 
        (char )'P',      (char )':',      (char )'S',      (char )':', 
        (char )'a',      (char )'c',      (char )'d',      (char )'D', 
        (char )'f',      (char )'F',      (char )'h',      (char )'k', 
        (char )'K',      (char )'m',      (char )':',      (char )'p', 
        (char )':',      (char )'t',      (char )'v',      (char )'V', 
        (char )'w',      (char )'W',      (char )'?',      (char )'\000'};
#line 159 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 47 "man-getopt.c"
static struct option  const  long_opts[5]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"path", 0, (int *)((void *)0), 'w'}, 
        {"preformat", 0, (int *)((void *)0), 'F'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 61 "man-getopt.c"
void man_getopt(int argc , char **argv ) 
{ 
  int c ;
  char *config_file ;
  char *manp ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 64
  config_file = (char *)((void *)0);
#line 65
  manp = (char *)((void *)0);
  {
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 68
    c = getopt_long(argc, (char * const  *)argv, (char const   *)(short_opts), long_opts,
                    (int *)((void *)0));
    }
    }
#line 68
    if (! (c != -1)) {
#line 68
      goto while_break;
    }
    {
#line 73
    if (c == 67) {
#line 73
      goto case_67;
    }
#line 77
    if (c == 70) {
#line 77
      goto case_70;
    }
#line 80
    if (c == 77) {
#line 80
      goto case_77;
    }
#line 83
    if (c == 80) {
#line 83
      goto case_80;
    }
#line 86
    if (c == 83) {
#line 86
      goto case_83;
    }
#line 89
    if (c == 97) {
#line 89
      goto case_97;
    }
#line 92
    if (c == 99) {
#line 92
      goto case_99;
    }
#line 95
    if (c == 68) {
#line 95
      goto case_68;
    }
#line 97
    if (c == 100) {
#line 97
      goto case_100;
    }
#line 100
    if (c == 102) {
#line 100
      goto case_102;
    }
#line 109
    if (c == 107) {
#line 109
      goto case_107;
    }
#line 118
    if (c == 75) {
#line 118
      goto case_75;
    }
#line 121
    if (c == 109) {
#line 121
      goto case_109;
    }
#line 125
    if (c == 112) {
#line 125
      goto case_112;
    }
#line 129
    if (c == 116) {
#line 129
      goto case_116;
    }
#line 139
    if (c == 86) {
#line 139
      goto case_86;
    }
#line 139
    if (c == 118) {
#line 139
      goto case_86;
    }
#line 142
    if (c == 87) {
#line 142
      goto case_87;
    }
#line 144
    if (c == 119) {
#line 144
      goto case_119;
    }
#line 156
    goto switch_default;
    case_67: /* CIL Label */ 
    {
    {
#line 74
    no_privileges();
    }
    {
#line 75
    config_file = my_strdup(optarg);
    }
    }
#line 76
    goto switch_break;
    case_70: /* CIL Label */ 
#line 78
    preformat = 1;
#line 79
    goto switch_break;
    case_77: /* CIL Label */ 
    {
    {
#line 81
    manp = my_strdup(optarg);
    }
    }
#line 82
    goto switch_break;
    case_80: /* CIL Label */ 
    {
    {
#line 84
    pager = my_strdup(optarg);
    }
    }
#line 85
    goto switch_break;
    case_83: /* CIL Label */ 
    {
    {
#line 87
    colon_sep_section_list = my_strdup(optarg);
    }
    }
#line 88
    goto switch_break;
    case_97: /* CIL Label */ 
#line 90
    findall ++;
#line 91
    goto switch_break;
    case_99: /* CIL Label */ 
#line 93
    nocats ++;
#line 94
    goto switch_break;
    case_68: /* CIL Label */ 
#line 96
    debug ++;
    case_100: /* CIL Label */ 
#line 98
    debug ++;
#line 99
    goto switch_break;
    case_102: /* CIL Label */ 
#line 101
    if (do_troff) {
      {
      {
#line 102
      fatal(4, "-f", "-t");
      }
      }
    }
#line 103
    if (apropos) {
      {
      {
#line 104
      fatal(4, "-f", "-k");
      }
      }
    }
#line 105
    if (print_where) {
      {
      {
#line 106
      fatal(4, "-f", "-w");
      }
      }
    }
#line 107
    whatis ++;
#line 108
    goto switch_break;
    case_107: /* CIL Label */ 
#line 110
    if (do_troff) {
      {
      {
#line 111
      fatal(4, "-k", "-t");
      }
      }
    }
#line 112
    if (whatis) {
      {
      {
#line 113
      fatal(4, "-k", "-f");
      }
      }
    }
#line 114
    if (print_where) {
      {
      {
#line 115
      fatal(4, "-k", "-w");
      }
      }
    }
#line 116
    apropos ++;
#line 117
    goto switch_break;
    case_75: /* CIL Label */ 
#line 119
    global_apropos ++;
#line 120
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 122
    alt_system ++;
    {
#line 123
    alt_system_name = my_strdup(optarg);
    }
    }
#line 124
    goto switch_break;
    case_112: /* CIL Label */ 
    {
    {
#line 127
    roff_directive = my_strdup(optarg);
    }
    }
#line 128
    goto switch_break;
    case_116: /* CIL Label */ 
#line 130
    if (apropos) {
      {
      {
#line 131
      fatal(4, "-t", "-k");
      }
      }
    }
#line 132
    if (whatis) {
      {
      {
#line 133
      fatal(4, "-t", "-f");
      }
      }
    }
#line 134
    if (print_where) {
      {
      {
#line 135
      fatal(4, "-t", "-w");
      }
      }
    }
#line 136
    do_troff ++;
#line 137
    goto switch_break;
    case_86: /* CIL Label */ 
    case_118: /* CIL Label */ 
    {
    {
#line 140
    print_version();
    }
    {
#line 141
    exit(0);
    }
    }
    case_87: /* CIL Label */ 
#line 143
    one_per_line ++;
    case_119: /* CIL Label */ 
#line 146
    if (apropos) {
      {
      {
#line 147
      fatal(4, "-w", "-k");
      }
      }
    }
#line 148
    if (whatis) {
      {
      {
#line 149
      fatal(4, "-w", "-f");
      }
      }
    }
#line 150
    if (do_troff) {
      {
      {
#line 151
      fatal(4, "-w", "-t");
      }
      }
    }
#line 152
    print_where ++;
#line 153
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 157
    usage();
    }
    }
#line 158
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 162
  read_config_file(config_file);
  }
  }
#line 164
  if ((unsigned int )pager == (unsigned int )((void *)0)) {
#line 165
    goto _L;
  } else
#line 164
  if ((int )*pager == 0) {
    _L: 
    {
    {
#line 165
    pager = getenv("MANPAGER");
    }
    }
#line 165
    if ((unsigned int )pager == (unsigned int )((void *)0)) {
      {
      {
#line 166
      pager = getenv("PAGER");
      }
      }
#line 166
      if ((unsigned int )pager == (unsigned int )((void *)0)) {
        {
        {
#line 167
        pager = getval((char *)"PAGER");
        }
        }
      }
    }
  }
#line 169
  if (debug) {
    {
    {
#line 170
    gripe(11, pager);
    }
    }
  }
#line 172
  if (do_compress) {
    {
    {
#line 172
    tmp = getval((char *)"COMPRESS");
    }
    }
#line 172
    if (! *tmp) {
#line 173
      if (debug) {
        {
        {
#line 174
        gripe(6);
        }
        }
      }
#line 175
      do_compress = 0;
    }
  }
#line 178
  if (do_troff) {
    {
    {
#line 178
    tmp___0 = getval((char *)"TROFF");
    }
    }
#line 178
    if (! *tmp___0) {
      {
      {
#line 179
      gripe(75, configuration_file);
      }
      {
#line 180
      exit(1);
      }
      }
    }
  }
#line 183
  opt_manpath = manp;
#line 186
  if ((unsigned int )alt_system_name == (unsigned int )((void *)0)) {
#line 187
    goto _L___0;
  } else
#line 186
  if ((int )*alt_system_name == 0) {
    _L___0: 
    {
    {
#line 187
    alt_system_name = getenv("SYSTEM");
    }
    }
#line 187
    if ((unsigned int )alt_system_name != (unsigned int )((void *)0)) {
      {
      {
#line 188
      alt_system_name = my_strdup(alt_system_name);
      }
      }
    }
  }
#line 190
  return;
}
}
#line 1 "to_cat.o"
/* #pragma merger(0,"./to_cat.i","-Wall,-Wstrict-prototypes,-Wmissing-prototypes") */
#line 17 "to_cat.c"
static char *mantail_of(char *name ) 
{ 
  char *s1 ;
  char *s2 ;

  {
  {
#line 21
  s2 = (char *)0;
  {
#line 22
  s1 = rindex((char const   *)name, '/');
  }
  }
#line 23
  if (s1) {
    {
#line 24
    *s1 = (char)0;
    {
#line 25
    s2 = rindex((char const   *)name, '/');
    }
#line 26
    *s1 = (char )'/';
    }
  }
#line 28
  return (s2);
}
}
#line 35 "to_cat.c"
char *mandir_of(char *name ) 
{ 
  char *p ;
  char *q ;

  {
  {
#line 39
  q = (char *)0;
  {
#line 40
  p = mantail_of(name);
  }
  }
#line 41
  if (p) {
    {
#line 42
    *p = (char)0;
    {
#line 43
    q = my_strdup(name);
    }
#line 44
    *p = (char )'/';
    }
  }
#line 46
  return (q);
}
}
#line 61 "to_cat.c"
char *convert_to_cat(char *name0 , char *ext , int standards___0 ) 
{ 
  char *name ;
  char *freename ;
  char *cat_name ;
  char *t0 ;
  char *t2 ;
  char *t3 ;
  char *t4 ;
  struct dirs *dlp ;
  int len ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
  {
#line 63
  cat_name = (char *)0;
  {
#line 68
  name = my_strdup(name0);
  }
#line 68
  freename = name;
  {
#line 70
  t0 = rindex((char const   *)name, '.');
  }
  }
#line 71
  if (t0) {
    {
    {
#line 71
    tmp = get_expander(t0);
    }
    }
#line 71
    if (tmp) {
#line 72
      *t0 = (char)0;
    }
  }
  {
  {
#line 74
  t2 = mantail_of(name);
  }
  }
#line 75
  if ((unsigned int )t2 == (unsigned int )((void *)0)) {
#line 76
    return ((char *)0);
  }
  {
#line 77
  *t2 = (char)0;
  {
#line 79
  tmp___0 = strncmp((char const   *)(t2 + 1), "man", 3U);
  }
  }
#line 79
  if (tmp___0 != 0) {
#line 80
    return ((char *)0);
  }
#line 81
  *(t2 + 1) = (char )'c';
#line 82
  *(t2 + 3) = (char )'t';
#line 84
  if (ext) {
    {
    {
#line 84
    tmp___2 = strlen((char const   *)ext);
    }
#line 84
    len = (int )tmp___2;
    }
  } else {
#line 84
    len = 0;
  }
#line 87
  dlp = cfdirlist.nxt;
  {
  {
#line 87
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 87
    if (! dlp) {
#line 87
      goto while_break;
    }
    {
    {
#line 88
    tmp___6 = strcmp((char const   *)name, (char const   *)(dlp->mandir));
    }
    }
#line 88
    if (! tmp___6) {
#line 89
      if (! dlp->catdir[0]) {
#line 90
        goto while_break;
      }
      {
#line 91
      *t2 = (char )'/';
      {
#line 92
      tmp___3 = strlen((char const   *)(dlp->catdir));
      }
      {
#line 92
      tmp___4 = strlen((char const   *)t2);
      }
#line 92
      len = (int )((size_t )len + ((tmp___3 + tmp___4) + 1U));
      {
#line 93
      tmp___5 = my_malloc(len);
      }
#line 93
      cat_name = tmp___5;
      {
#line 94
      strcpy((char */* __restrict  */)cat_name, (char const   */* __restrict  */)(dlp->catdir));
      }
      {
#line 95
      strcat((char */* __restrict  */)cat_name, (char const   */* __restrict  */)t2);
      }
      }
#line 96
      goto gotit;
    }
#line 87
    dlp = dlp->nxt;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  if (standards___0 & 64) {
#line 101
    if ((int )*name != 47) {
#line 102
      return ((char *)0);
    }
    {
#line 105
    t3 = t2;
    {
#line 106
    t4 = rindex((char const   *)name, '/');
    }
    }
#line 106
    if ((unsigned int )t4 != (unsigned int )((void *)0)) {
      {
      {
#line 106
      tmp___7 = strcmp((char const   *)t4, "/man");
      }
      }
#line 106
      if (tmp___7) {
#line 107
        *t3 = (char )'/';
#line 108
        t3 = t4;
#line 109
        *t3 = (char)0;
      }
    }
#line 112
    if (t3 - name >= 4L) {
      {
      {
#line 112
      tmp___14 = strcmp((char const   *)(t3 - 4), "/man");
      }
      }
#line 112
      if (! tmp___14) {
        {
        {
#line 114
        tmp___8 = strncmp((char const   *)name, "/usr/", 5U);
        }
        }
#line 114
        if (! tmp___8) {
#line 115
          name += 4;
        }
#line 116
        t4 = t3 - 4;
#line 117
        *t4 = (char)0;
#line 118
        if (t4 - name >= 6L) {
          {
          {
#line 118
          tmp___9 = strcmp((char const   *)(t4 - 6), "/share");
          }
          }
#line 118
          if (! tmp___9) {
#line 119
            *(t4 + -6) = (char)0;
          }
        }
        {
#line 120
        *t3 = (char )'/';
        {
#line 122
        tmp___10 = strlen("/var/cache/man");
        }
        {
#line 122
        tmp___11 = strlen((char const   *)name);
        }
        {
#line 122
        tmp___12 = strlen((char const   *)t3);
        }
#line 122
        len = (int )((size_t )len + (((tmp___10 + tmp___11) + tmp___12) + 1U));
        {
#line 123
        tmp___13 = my_malloc(len);
        }
#line 123
        cat_name = tmp___13;
        {
#line 124
        strcpy((char */* __restrict  */)cat_name, (char const   */* __restrict  */)"/var/cache/man");
        }
        {
#line 125
        strcat((char */* __restrict  */)cat_name, (char const   */* __restrict  */)name);
        }
        {
#line 126
        strcat((char */* __restrict  */)cat_name, (char const   */* __restrict  */)t3);
        }
        }
#line 127
        goto gotit;
      }
    }
#line 130
    return ((char *)0);
  }
#line 133
  if (standards___0 & 32) {
    {
    {
#line 133
    tmp___20 = strncmp((char const   *)name, "/usr/", 5U);
    }
    }
#line 133
    if (tmp___20) {
#line 152
      *t2 = (char )'/';
    } else {
#line 135
      t3 = t2;
      {
      {
#line 136
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 136
        t4 = rindex((char const   *)name, '/');
        }
        }
#line 136
        if ((unsigned int )t4 != (unsigned int )((void *)0)) {
          {
          {
#line 136
          tmp___15 = strcmp((char const   *)t4, "/man");
          }
          }
#line 136
          if (! tmp___15) {
#line 136
            goto while_break___0;
          }
        } else {
#line 136
          goto while_break___0;
        }
#line 137
        *t3 = (char )'/';
#line 138
        t3 = t4;
#line 139
        *t3 = (char)0;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 141
      *t3 = (char )'/';
#line 142
      if (t4) {
        {
#line 143
        *t4 = (char)0;
        {
#line 144
        tmp___16 = strlen("/var/catman");
        }
        {
#line 144
        tmp___17 = strlen((char const   *)(name + 4));
        }
        {
#line 144
        tmp___18 = strlen((char const   *)t3);
        }
#line 144
        len = (int )((size_t )len + (((tmp___16 + tmp___17) + tmp___18) + 1U));
        {
#line 145
        tmp___19 = my_malloc(len);
        }
#line 145
        cat_name = tmp___19;
        {
#line 146
        strcpy((char */* __restrict  */)cat_name, (char const   */* __restrict  */)"/var/catman");
        }
        {
#line 147
        strcat((char */* __restrict  */)cat_name, (char const   */* __restrict  */)(name + 4));
        }
        {
#line 148
        strcat((char */* __restrict  */)cat_name, (char const   */* __restrict  */)t3);
        }
        }
#line 149
        goto gotit;
      }
    }
  } else {
#line 152
    *t2 = (char )'/';
  }
#line 154
  if (ext) {
    {
    {
#line 155
    tmp___21 = strlen((char const   *)name);
    }
#line 155
    len = (int )((size_t )len + (tmp___21 + 1U));
    {
#line 156
    tmp___22 = my_malloc(len);
    }
#line 156
    cat_name = tmp___22;
    {
#line 157
    strcpy((char */* __restrict  */)cat_name, (char const   */* __restrict  */)name);
    }
    }
  } else {
#line 159
    cat_name = name;
  }
  gotit: 
#line 163
  if (standards___0 & 128) {
    {
    {
#line 163
    tmp___23 = get_expander(cat_name);
    }
    }
#line 163
    if (! tmp___23) {
#line 164
      goto _L;
    }
  } else
  _L: 
#line 165
  if (ext) {
    {
    {
#line 166
    strcat((char */* __restrict  */)cat_name, (char const   */* __restrict  */)ext);
    }
    }
  }
#line 168
  if ((unsigned int )name != (unsigned int )cat_name) {
    {
    {
#line 169
    free((void *)freename);
    }
    }
  }
#line 171
  return (cat_name);
}
}
#line 1 "different.o"
/* #pragma merger(0,"./different.i","-Wall,-Wstrict-prototypes,-Wmissing-prototypes") */
#line 10 "different.c"
static struct filelist cat_list  ;
#line 10 "different.c"
static struct filelist man_list  ;
#line 15 "different.c"
static int is_different(char *file , struct filelist *p ) 
{ 
  char *command ;
  char *cmp ;
  char *tmp ;
  int ret ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 18
  tmp = getval((char *)"CMP");
  }
#line 18
  cmp = tmp;
  }
#line 21
  if (cmp) {
    {
    {
#line 22
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 22
      if (! p->next) {
#line 22
        goto while_break;
      }
      {
      {
#line 23
      command = my_xsprintf((char *)"%s %s %s\n", cmp, file, p->pathname);
      }
      {
#line 24
      ret = do_system_command(command, 1);
      }
      {
#line 25
      free((void *)command);
      }
      }
#line 26
      if (ret == 0) {
        {
        {
#line 27
        gripe(73, file, p->pathname);
        }
        }
#line 28
        return (0);
      }
#line 30
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 32
    tmp___0 = my_malloc((int )sizeof(struct filelist ));
    }
#line 32
    p->next = (struct filelist *)tmp___0;
    {
#line 33
    p->pathname = my_strdup(file);
    }
#line 34
    (p->next)->next = (struct filelist *)0;
    }
  }
#line 36
  return (1);
}
}
#line 39 "different.c"
int different_cat_file(char *file ) 
{ 
  int tmp ;

  {
  {
  {
#line 41
  tmp = is_different(file, & cat_list);
  }
  }
#line 41
  return (tmp);
}
}
#line 44 "different.c"
int different_man_file(char *file ) 
{ 
  int tmp ;

  {
  {
  {
#line 46
  tmp = is_different(file, & man_list);
  }
  }
#line 46
  return (tmp);
}
}
#line 1 "gripes.o"
/* #pragma merger(0,"./gripes.i","-Wall,-Wstrict-prototypes,-Wmissing-prototypes") */
#line 336 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 8 "gripes.c"
char *msg[77] ;
#line 10 "gripes.c"
static char *mantexts  =    (char *)"man";
#line 43 "/usr/include/nl_types.h"
extern nl_catd ( __attribute__((__nonnull__(1))) catopen)(char const   *__cat_name ,
                                                          int __flag ) ;
#line 47
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) catgets)(nl_catd __catalog ,
                                                                                      int __set ,
                                                                                      int __number ,
                                                                                      char const   *__string ) ;
#line 305 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 72 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 14 "../catopen/catopen.c"
static nl_catd my_catopenpath(char *name , char *nlspath ) ;
#line 16 "../catopen/catopen.c"
static nl_catd my_catopen(char *name , int oflag ) 
{ 
  nl_catd fd ;
  char *nlspath ;
  char *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 21
  fd = catopen((char const   *)name, oflag);
  }
  }
#line 23
  if ((unsigned int )fd == (unsigned int )((void *)-1)) {
#line 34
    if (oflag) {
#line 35
      return (fd);
    }
    {
    {
#line 40
    tmp = index((char const   *)name, '/');
    }
    }
#line 40
    if (tmp) {
#line 43
      return (fd);
    }
    {
    {
#line 56
    nlspath = getenv("NLSPATH");
    }
    }
#line 57
    if (nlspath) {
      {
      {
#line 58
      fd = my_catopenpath(name, nlspath);
      }
      }
    }
#line 59
    if ((unsigned int )fd == (unsigned int )((void *)-1)) {
      {
      {
#line 60
      fd = my_catopenpath(name, (char *)"/usr/lib/locale/%N/%L");
      }
      }
    }
  }
#line 62
  return (fd);
}
}
#line 81 "../catopen/catopen.c"
static nl_catd my_catopenpath(char *name , char *nlspath ) 
{ 
  int fd ;
  nl_catd cfd ;
  char *path0 ;
  char *path ;
  char *s ;
  char *file ;
  char *lang ;
  char *lang_l ;
  char *lang_t ;
  char *lang_c ;
  int langsz ;
  int namesz ;
  int sz ;
  int lang_l_sz ;
  int lang_t_sz ;
  int lang_c_sz ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 84
  cfd = (void *)-1;
  {
#line 88
  tmp = strlen((char const   *)name);
  }
#line 88
  namesz = (int )tmp;
  {
#line 90
  lang = getenv("LANG");
  }
  }
#line 91
  if (! lang) {
#line 92
    lang = (char *)"";
  }
  {
  {
#line 93
  tmp___0 = strlen((char const   *)lang);
  }
#line 93
  langsz = (int )tmp___0;
#line 95
  lang_l = lang;
  {
#line 96
  s = index((char const   *)lang_l, '_');
  }
  }
#line 97
  if (! s) {
#line 98
    lang_c = (char *)"";
#line 98
    lang_t = lang_c;
#line 99
    lang_l_sz = langsz;
#line 100
    lang_c_sz = 0;
#line 100
    lang_t_sz = lang_c_sz;
  } else {
    {
#line 102
    lang_l_sz = (int )(s - lang_l);
#line 103
    lang_t = s + 1;
    {
#line 104
    s = index((char const   *)lang_t, '.');
    }
    }
#line 105
    if (! s) {
#line 106
      lang_c = (char *)"";
#line 107
      lang_t_sz = (langsz - lang_l_sz) - 1;
#line 108
      lang_c_sz = 0;
    } else {
#line 110
      lang_t_sz = (int )(s - lang_t);
#line 111
      lang_c = s + 1;
#line 112
      lang_c_sz = ((langsz - lang_l_sz) - lang_t_sz) - 2;
    }
  }
#line 117
  sz = 0;
#line 118
  s = nlspath;
  {
  {
#line 119
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 119
    if (! *s) {
#line 119
      goto while_break;
    }
#line 120
    if ((int )*s == 37) {
#line 121
      s ++;
      {
#line 123
      if ((int )*s == 37) {
#line 123
        goto case_37;
      }
#line 125
      if ((int )*s == 78) {
#line 125
        goto case_78;
      }
#line 127
      if ((int )*s == 76) {
#line 127
        goto case_76;
      }
#line 129
      if ((int )*s == 108) {
#line 129
        goto case_108;
      }
#line 131
      if ((int )*s == 116) {
#line 131
        goto case_116;
      }
#line 133
      if ((int )*s == 99) {
#line 133
        goto case_99;
      }
#line 135
      goto switch_default;
      case_37: /* CIL Label */ 
#line 124
      sz ++;
#line 124
      goto switch_break;
      case_78: /* CIL Label */ 
#line 126
      sz += namesz;
#line 126
      goto switch_break;
      case_76: /* CIL Label */ 
#line 128
      sz += langsz;
#line 128
      goto switch_break;
      case_108: /* CIL Label */ 
#line 130
      sz += lang_l_sz;
#line 130
      goto switch_break;
      case_116: /* CIL Label */ 
#line 132
      sz += lang_t_sz;
#line 132
      goto switch_break;
      case_99: /* CIL Label */ 
#line 134
      sz += lang_c_sz;
#line 134
      goto switch_break;
      switch_default: /* CIL Label */ ;
#line 136
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 138
    if ((int )*s == 58) {
#line 138
      if ((unsigned int )s == (unsigned int )nlspath) {
#line 139
        sz += namesz + 1;
      } else
#line 138
      if ((int )*(s + -1) == 58) {
#line 139
        sz += namesz + 1;
      } else {
#line 141
        sz ++;
      }
    } else {
#line 141
      sz ++;
    }
#line 142
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 146
  path0 = my_malloc(sz + 1);
  }
#line 147
  path = path0;
#line 148
  s = nlspath;
  }
  {
  {
#line 149
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 149
    if (! *s) {
#line 149
      goto while_break___0;
    }
#line 150
    if ((int )*s == 37) {
#line 151
      s ++;
      {
#line 153
      if ((int )*s == 37) {
#line 153
        goto case_37___0;
      }
#line 155
      if ((int )*s == 78) {
#line 155
        goto case_78___0;
      }
#line 157
      if ((int )*s == 76) {
#line 157
        goto case_76___0;
      }
#line 159
      if ((int )*s == 108) {
#line 159
        goto case_108___0;
      }
#line 161
      if ((int )*s == 116) {
#line 161
        goto case_116___0;
      }
#line 163
      if ((int )*s == 99) {
#line 163
        goto case_99___0;
      }
#line 165
      goto switch_default___0;
      case_37___0: /* CIL Label */ 
#line 154
      tmp___1 = path;
#line 154
      path ++;
#line 154
      *tmp___1 = (char )'%';
#line 154
      goto switch_break___0;
      case_78___0: /* CIL Label */ 
      {
      {
#line 156
      strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)name,
              (unsigned int )namesz);
      }
#line 156
      path += namesz;
      }
#line 156
      goto switch_break___0;
      case_76___0: /* CIL Label */ 
      {
      {
#line 158
      strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)lang,
              (unsigned int )langsz);
      }
#line 158
      path += langsz;
      }
#line 158
      goto switch_break___0;
      case_108___0: /* CIL Label */ 
      {
      {
#line 160
      strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)lang_l,
              (unsigned int )lang_l_sz);
      }
#line 160
      path += lang_l_sz;
      }
#line 160
      goto switch_break___0;
      case_116___0: /* CIL Label */ 
      {
      {
#line 162
      strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)lang_t,
              (unsigned int )lang_t_sz);
      }
#line 162
      path += lang_t_sz;
      }
#line 162
      goto switch_break___0;
      case_99___0: /* CIL Label */ 
      {
      {
#line 164
      strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)lang_c,
              (unsigned int )lang_c_sz);
      }
#line 164
      path += lang_c_sz;
      }
#line 164
      goto switch_break___0;
      switch_default___0: /* CIL Label */ ;
#line 166
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else
#line 168
    if ((int )*s == 58) {
#line 168
      if ((unsigned int )s == (unsigned int )nlspath) {
        {
        {
#line 169
        strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)name,
                (unsigned int )namesz);
        }
#line 169
        path += namesz;
#line 170
        tmp___2 = path;
#line 170
        path ++;
#line 170
        *tmp___2 = (char )':';
        }
      } else
#line 168
      if ((int )*(s + -1) == 58) {
        {
        {
#line 169
        strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)name,
                (unsigned int )namesz);
        }
#line 169
        path += namesz;
#line 170
        tmp___2 = path;
#line 170
        path ++;
#line 170
        *tmp___2 = (char )':';
        }
      } else {
#line 172
        tmp___3 = path;
#line 172
        path ++;
#line 172
        *tmp___3 = *s;
      }
    } else {
#line 172
      tmp___3 = path;
#line 172
      path ++;
#line 172
      *tmp___3 = *s;
    }
#line 173
    s ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  *path = (char)0;
#line 177
  path = path0;
  {
  {
#line 178
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 178
    if (! path) {
#line 178
      goto while_break___1;
    }
    {
#line 179
    file = path;
    {
#line 180
    s = index((char const   *)path, ':');
    }
    }
#line 181
    if (s) {
#line 182
      *s = (char)0;
#line 183
      path = s + 1;
    } else {
#line 185
      path = (char *)0;
    }
    {
    {
#line 186
    fd = open((char const   *)file, 0);
    }
    }
#line 187
    if (fd != -1) {
      {
      {
#line 190
      close(fd);
      }
      {
#line 191
      cfd = catopen((char const   *)file, 0);
      }
      }
#line 192
      goto while_break___1;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 196
  free((void *)path0);
  }
  }
#line 197
  return (cfd);
}
}
#line 32 "gripes.c"
nl_catd catfd  =    (void *)-1;
#line 33 "gripes.c"
int cat_is_open  =    0;
#line 35 "gripes.c"
static void catinit(void) 
{ 
  char *s ;
  char *lg ;
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 37
  if (! cat_is_open) {
    {
    {
#line 38
    catfd = my_catopen(mantexts, 0);
    }
    }
#line 39
    if ((unsigned int )catfd == (unsigned int )((void *)-1)) {
      {
      {
#line 43
      s = getenv("NLSPATH");
      }
      {
#line 44
      lg = getenv("LANG");
      }
      }
#line 45
      if (s) {
#line 46
        goto _L___1;
      } else
#line 45
      if (lg) {
        _L___1: 
#line 45
        if (! lg) {
#line 46
          goto _L___0;
        } else {
          {
          {
#line 45
          tmp___0 = strcmp((char const   *)lg, "en");
          }
          }
#line 45
          if (tmp___0) {
            _L___0: 
            {
            {
#line 46
            perror((char const   *)mantexts);
            }
            }
#line 47
            if (s) {
#line 47
              tmp = (char const   *)s;
            } else {
#line 47
              tmp = "<none>";
            }
            {
            {
#line 47
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open the message catalog %s on the path NLSPATH=%s\n\n",
                    mantexts, tmp);
            }
            }
          } else {
#line 50
            goto _L;
          }
        }
      } else
      _L: 
#line 50
      if (debug) {
        {
        {
#line 51
        perror((char const   *)mantexts);
        }
        {
#line 52
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Looked whether there exists a message catalog %s, but there is none\n(and for English messages none is needed)\n\n",
                mantexts);
        }
        }
      }
    }
  }
#line 58
  cat_is_open = 1;
#line 59
  return;
}
}
#line 61 "gripes.c"
static char *getmsg(int n ) 
{ 
  char *s ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 65
  catinit();
  }
  }
#line 66
  if ((unsigned int )catfd == (unsigned int )((void *)-1)) {
#line 67
    goto _L;
  } else {
    {
    {
#line 66
    s = catgets(catfd, 1, n, "");
    }
    }
#line 66
    if (! *s) {
      _L: 
#line 67
      if (0 < n) {
#line 67
        if (n <= 76) {
#line 68
          s = msg[n];
        } else {
          {
          {
#line 70
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"man: internal error - cannot find message %d\n",
                  n);
          }
          {
#line 71
          exit(1);
          }
          }
        }
      } else {
        {
        {
#line 70
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"man: internal error - cannot find message %d\n",
                n);
        }
        {
#line 71
        exit(1);
        }
        }
      }
    }
  }
#line 74
  return (s);
}
}
#line 79 "gripes.c"
void gripe(int n  , ...) 
{ 
  va_list p ;
  char *tmp ;

  {
  {
  {
#line 83
  __builtin_va_start(p, n);
  }
  {
#line 84
  tmp = getmsg(n);
  }
  {
#line 84
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
           p);
  }
  {
#line 85
  __builtin_va_end(p);
  }
  {
#line 86
  fflush(stderr);
  }
  }
#line 87
  return;
}
}
#line 89 "gripes.c"
void fatal(int n  , ...) 
{ 
  va_list p ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 92
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname);
  }
  {
#line 93
  __builtin_va_start(p, n);
  }
  {
#line 94
  tmp = getmsg(n);
  }
  {
#line 94
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
           p);
  }
  {
#line 95
  __builtin_va_end(p);
  }
  {
#line 96
  exit(1);
  }
  }
}
}
#line 1 "glob.o"
/* #pragma merger(0,"./glob.i","-Wall") */
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 142
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 155
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 595 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 170 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 112 "glob.c"
int noglob_dot_filenames  =    1;
#line 114
static int glob_match_after_star(char *pattern , char *text ) ;
#line 118 "glob.c"
int glob_pattern_p(char *pattern ) 
{ 
  register char *p ;
  register char c ;
  int open___0 ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 122
  p = pattern;
#line 124
  open___0 = 0;
  {
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 126
    tmp___0 = p;
#line 126
    p ++;
#line 126
    c = *tmp___0;
#line 126
    if (! ((int )c != 0)) {
#line 126
      goto while_break;
    }
    {
#line 129
    if ((int )c == 42) {
#line 129
      goto case_42;
    }
#line 129
    if ((int )c == 63) {
#line 129
      goto case_42;
    }
#line 132
    if ((int )c == 91) {
#line 132
      goto case_91;
    }
#line 136
    if ((int )c == 93) {
#line 136
      goto case_93;
    }
#line 140
    if ((int )c == 92) {
#line 140
      goto case_92;
    }
#line 127
    goto switch_break;
    case_42: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 131
    return (1);
    case_91: /* CIL Label */ 
#line 134
    open___0 ++;
#line 135
    goto while_continue;
    case_93: /* CIL Label */ 
#line 137
    if (open___0) {
#line 138
      return (1);
    }
#line 139
    goto while_continue;
    case_92: /* CIL Label */ 
#line 142
    tmp = p;
#line 142
    p ++;
#line 142
    if ((int )*tmp == 0) {
#line 143
      return (0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return (0);
}
}
#line 170 "glob.c"
int glob_match(char *pattern , char *text , int dot_special ) 
{ 
  register char *p ;
  register char *t ;
  register char c ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  register char c1 ;
  char *tmp___2 ;
  int invert ;
  char *tmp___3 ;
  register char cstart ;
  register char cend ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 175
  p = pattern;
#line 175
  t = text;
  {
  {
#line 178
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 178
    tmp___11 = p;
#line 178
    p ++;
#line 178
    c = *tmp___11;
#line 178
    if (! ((int )c != 0)) {
#line 178
      goto while_break;
    }
    {
#line 180
    if ((int )c == 63) {
#line 180
      goto case_63;
    }
#line 187
    if ((int )c == 92) {
#line 187
      goto case_92;
    }
#line 192
    if ((int )c == 42) {
#line 192
      goto case_42;
    }
#line 197
    if ((int )c == 91) {
#line 197
      goto case_91;
    }
#line 260
    goto switch_default;
    case_63: /* CIL Label */ 
#line 182
    if ((int )*t == 0) {
#line 183
      return (0);
    } else
#line 182
    if (dot_special) {
#line 182
      if ((unsigned int )t == (unsigned int )text) {
#line 182
        if ((int )*t == 46) {
#line 183
          return (0);
        } else {
#line 185
          t ++;
        }
      } else {
#line 185
        t ++;
      }
    } else {
#line 185
      t ++;
    }
#line 186
    goto switch_break;
    case_92: /* CIL Label */ 
#line 189
    tmp = p;
#line 189
    p ++;
#line 189
    tmp___0 = t;
#line 189
    t ++;
#line 189
    if ((int )*tmp != (int )*tmp___0) {
#line 190
      return (0);
    }
#line 191
    goto switch_break;
    case_42: /* CIL Label */ 
#line 194
    if (dot_special) {
#line 194
      if ((unsigned int )t == (unsigned int )text) {
#line 194
        if ((int )*t == 46) {
#line 195
          return (0);
        }
      }
    }
    {
    {
#line 196
    tmp___1 = glob_match_after_star(p, t);
    }
    }
#line 196
    return (tmp___1);
    case_91: /* CIL Label */ 
#line 200
    tmp___2 = t;
#line 200
    t ++;
#line 200
    c1 = *tmp___2;
#line 203
    if ((int )c1 == 0) {
#line 204
      return (0);
    }
#line 206
    invert = (int )*p == 33;
#line 208
    if (invert) {
#line 209
      p ++;
    }
#line 211
    tmp___3 = p;
#line 211
    p ++;
#line 211
    c = *tmp___3;
    {
    {
#line 212
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 214
      cstart = c;
#line 214
      cend = c;
#line 216
      if ((int )c == 92) {
#line 218
        tmp___4 = p;
#line 218
        p ++;
#line 218
        cstart = *tmp___4;
#line 219
        cend = cstart;
      }
#line 222
      if ((int )cstart == 0) {
#line 223
        return (0);
      }
#line 225
      tmp___5 = p;
#line 225
      p ++;
#line 225
      c = *tmp___5;
#line 227
      if ((int )c == 45) {
#line 229
        tmp___6 = p;
#line 229
        p ++;
#line 229
        cend = *tmp___6;
#line 230
        if ((int )cend == 92) {
#line 231
          tmp___7 = p;
#line 231
          p ++;
#line 231
          cend = *tmp___7;
        }
#line 232
        if ((int )cend == 0) {
#line 233
          return (0);
        }
#line 234
        tmp___8 = p;
#line 234
        p ++;
#line 234
        c = *tmp___8;
      }
#line 236
      if ((int )c1 >= (int )cstart) {
#line 236
        if ((int )c1 <= (int )cend) {
#line 237
          goto match;
        }
      }
#line 238
      if ((int )c == 93) {
#line 239
        goto while_break___0;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 241
    if (! invert) {
#line 242
      return (0);
    }
#line 243
    goto switch_break;
    match: 
    {
    {
#line 247
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 247
      if (! ((int )c != 93)) {
#line 247
        goto while_break___1;
      }
#line 249
      if ((int )c == 0) {
#line 250
        return (0);
      }
#line 251
      tmp___9 = p;
#line 251
      p ++;
#line 251
      c = *tmp___9;
#line 252
      if ((int )c == 0) {
#line 253
        return (0);
      }
#line 254
      if ((int )c == 92) {
#line 255
        p ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 257
    if (invert) {
#line 258
      return (0);
    }
#line 259
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 263
    tmp___10 = t;
#line 263
    t ++;
#line 263
    if ((int )c != (int )*tmp___10) {
#line 264
      return (0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  return ((int )*t == 0);
}
}
#line 272 "glob.c"
static int glob_match_after_star(char *pattern , char *text ) 
{ 
  register char *p ;
  register char *t ;
  register char c ;
  register char c1 ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 276
  p = pattern;
#line 276
  t = text;
  {
  {
#line 279
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 279
    tmp___0 = p;
#line 279
    p ++;
#line 279
    c = *tmp___0;
#line 279
    if (! ((int )c == 63)) {
#line 279
      if (! ((int )c == 42)) {
#line 279
        goto while_break;
      }
    }
#line 280
    if ((int )c == 63) {
#line 280
      tmp = t;
#line 280
      t ++;
#line 280
      if ((int )*tmp == 0) {
#line 281
        return (0);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  if ((int )c == 0) {
#line 284
    return (1);
  }
#line 286
  if ((int )c == 92) {
#line 287
    c1 = *p;
  } else {
#line 289
    c1 = c;
  }
#line 291
  p --;
  {
  {
#line 292
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 294
    if ((int )c == 91) {
#line 295
      goto _L;
    } else
#line 294
    if ((int )*t == (int )c1) {
      _L: 
      {
      {
#line 294
      tmp___1 = glob_match(p, t, 0);
      }
      }
#line 294
      if (tmp___1) {
#line 295
        return (1);
      }
    }
#line 296
    tmp___2 = t;
#line 296
    t ++;
#line 296
    if ((int )*tmp___2 == 0) {
#line 297
      return (0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 318 "glob.c"
char **glob_vector(char *pat , char *dir ) 
{ 
  DIR *d ;
  register struct dirent *dp ;
  struct globval *lastlink ;
  register struct globval *nextlink ;
  register char *nextname ;
  unsigned int count ;
  int lose ;
  register char **name_vector ;
  register unsigned int i ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
  {
#line 342
  d = opendir((char const   *)dir);
  }
  }
#line 343
  if ((unsigned int )d == (unsigned int )((void *)0)) {
#line 344
    return ((char **)-1);
  }
#line 346
  lastlink = (struct globval *)((void *)0);
#line 347
  count = 0U;
#line 348
  lose = 0;
  {
  {
#line 354
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 368
    dp = readdir(d);
    }
    }
#line 369
    if ((unsigned int )dp == (unsigned int )((void *)0)) {
#line 370
      goto while_break;
    }
    {
    {
#line 371
    tmp___2 = glob_match(pat, dp->d_name, noglob_dot_filenames);
    }
    }
#line 371
    if (tmp___2) {
      {
      {
#line 377
      tmp = __builtin_alloca(sizeof(struct globval ));
      }
#line 377
      nextlink = (struct globval *)tmp;
#line 379
      nextlink->next = lastlink;
      {
#line 380
      tmp___0 = strlen((char const   *)(dp->d_name));
      }
#line 380
      i = tmp___0 + 1U;
      {
#line 381
      tmp___1 = malloc(i);
      }
#line 381
      nextname = (char *)tmp___1;
      }
#line 382
      if ((unsigned int )nextname == (unsigned int )((void *)0)) {
#line 384
        lose = 1;
#line 385
        goto while_break;
      }
      {
#line 387
      lastlink = nextlink;
#line 388
      nextlink->name = nextname;
      {
#line 389
      memcpy((void */* __restrict  */)nextname, (void const   */* __restrict  */)(dp->d_name),
             i);
      }
#line 390
      count ++;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 393
  closedir(d);
  }
  }
#line 395
  if (! lose) {
    {
    {
#line 397
    tmp___3 = malloc((size_t )((unsigned long )(count + 1U) * sizeof(char *)));
    }
#line 397
    name_vector = (char **)tmp___3;
#line 398
    lose |= (unsigned int )name_vector == (unsigned int )((void *)0);
    }
  }
#line 405
  if (lose) {
    {
    {
#line 408
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 408
      if (! lastlink) {
#line 408
        goto while_break___0;
      }
      {
      {
#line 410
      free((void *)lastlink->name);
      }
#line 416
      lastlink = lastlink->next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 419
    return ((char **)((void *)0));
  }
#line 423
  i = 0U;
  {
  {
#line 423
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 423
    if (! (i < count)) {
#line 423
      goto while_break___1;
    }
#line 425
    *(name_vector + i) = lastlink->name;
#line 431
    lastlink = lastlink->next;
#line 423
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 435
  *(name_vector + count) = (char *)((void *)0);
#line 436
  return (name_vector);
}
}
#line 443 "glob.c"
static char **glob_dir_to_array(char *dir , char **array ) 
{ 
  register unsigned int i ;
  register unsigned int l ;
  int add_slash ;
  char **result ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 448
  add_slash = 0;
  {
#line 451
  l = strlen((char const   *)dir);
  }
  }
#line 452
  if (l == 0U) {
#line 453
    return (array);
  }
#line 455
  if ((int )*(dir + (l - 1U)) != 47) {
#line 456
    add_slash ++;
  }
#line 458
  i = 0U;
  {
  {
#line 458
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 458
    if (! ((unsigned int )*(array + i) != (unsigned int )((void *)0))) {
#line 458
      goto while_break;
    }
#line 458
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 461
  tmp = malloc((size_t )((unsigned long )(i + 1U) * sizeof(char *)));
  }
#line 461
  result = (char **)tmp;
  }
#line 462
  if ((unsigned int )result == (unsigned int )((void *)0)) {
#line 463
    return ((char **)((void *)0));
  }
#line 465
  i = 0U;
  {
  {
#line 465
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 465
    if (! ((unsigned int )*(array + i) != (unsigned int )((void *)0))) {
#line 465
      goto while_break___0;
    }
    {
    {
#line 467
    tmp___0 = strlen((char const   *)*(array + i));
    }
    {
#line 467
    tmp___1 = malloc(((1U + l) + (unsigned int )add_slash) + tmp___0);
    }
#line 467
    *(result + i) = (char *)tmp___1;
    }
#line 468
    if ((unsigned int )*(result + i) == (unsigned int )((void *)0)) {
#line 469
      return ((char **)((void *)0));
    }
    {
    {
#line 470
    strcpy((char */* __restrict  */)*(result + i), (char const   */* __restrict  */)dir);
    }
    }
#line 471
    if (add_slash) {
#line 472
      *(*(result + i) + l) = (char )'/';
    }
    {
    {
#line 473
    strcpy((char */* __restrict  */)((*(result + i) + l) + add_slash), (char const   */* __restrict  */)*(array + i));
    }
#line 465
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 475
  *(result + i) = (char *)((void *)0);
#line 478
  i = 0U;
  {
  {
#line 478
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 478
    if (! ((unsigned int )*(array + i) != (unsigned int )((void *)0))) {
#line 478
      goto while_break___1;
    }
    {
    {
#line 479
    free((void *)*(array + i));
    }
#line 478
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 480
  free((void *)((char *)array));
  }
  }
#line 481
  return (result);
}
}
#line 493 "glob.c"
char **glob_filename(char *pathname ) 
{ 
  char **result ;
  unsigned int result_size ;
  char *directory_name ;
  char *filename ;
  unsigned int directory_len ;
  void *tmp ;
  void *tmp___0 ;
  char **directories ;
  register unsigned int i ;
  char **temp_results ;
  char **tmp___1 ;
  char **array ;
  char **tmp___2 ;
  register unsigned int l ;
  void *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  char **temp_results___0 ;
  char const   *tmp___8 ;
  char **tmp___9 ;
  register unsigned int i___0 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 502
  tmp = malloc((size_t )sizeof(char *));
  }
#line 502
  result = (char **)tmp;
#line 503
  result_size = 1U;
  }
#line 504
  if ((unsigned int )result == (unsigned int )((void *)0)) {
#line 505
    return ((char **)((void *)0));
  }
  {
#line 507
  *(result + 0) = (char *)((void *)0);
  {
#line 510
  filename = strrchr((char const   *)pathname, '/');
  }
  }
#line 511
  if ((unsigned int )filename == (unsigned int )((void *)0)) {
#line 513
    filename = pathname;
#line 514
    directory_name = (char *)"";
#line 515
    directory_len = 0U;
  } else {
    {
#line 519
    directory_len = (unsigned int )((filename - pathname) + 1L);
    {
#line 523
    tmp___0 = __builtin_alloca((unsigned long )(directory_len + 1U));
    }
#line 523
    directory_name = (char *)tmp___0;
    {
#line 525
    memcpy((void */* __restrict  */)directory_name, (void const   */* __restrict  */)pathname,
           directory_len);
    }
#line 526
    *(directory_name + directory_len) = (char )'\000';
#line 527
    filename ++;
    }
  }
  {
  {
#line 532
  tmp___5 = glob_pattern_p(directory_name);
  }
  }
#line 532
  if (tmp___5) {
#line 537
    if ((int )*(directory_name + (directory_len - 1U)) == 47) {
#line 538
      *(directory_name + (directory_len - 1U)) = (char )'\000';
    }
    {
    {
#line 540
    directories = glob_filename(directory_name);
    }
    }
#line 544
    if ((unsigned int )directories == (unsigned int )((void *)0)) {
#line 545
      goto memory_error;
    } else
#line 546
    if ((unsigned int )directories == (unsigned int )((char **)-1)) {
#line 547
      return ((char **)-1);
    } else
#line 548
    if ((unsigned int )*directories == (unsigned int )((void *)0)) {
      {
      {
#line 550
      free((void *)((char *)directories));
      }
      }
#line 551
      return ((char **)-1);
    }
#line 557
    i = 0U;
    {
    {
#line 557
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 557
      if (! ((unsigned int )*(directories + i) != (unsigned int )((void *)0))) {
#line 557
        goto while_break;
      }
      {
      {
#line 559
      tmp___1 = glob_vector(filename, *(directories + i));
      }
#line 559
      temp_results = tmp___1;
      }
#line 560
      if ((unsigned int )temp_results == (unsigned int )((void *)0)) {
#line 561
        goto memory_error;
      } else
#line 562
      if (! ((unsigned int )temp_results == (unsigned int )((char **)-1))) {
        {
        {
#line 567
        tmp___2 = glob_dir_to_array(*(directories + i), temp_results);
        }
#line 567
        array = tmp___2;
#line 570
        l = 0U;
        }
        {
        {
#line 571
        while (1) {
          while_continue___5: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 571
          if (! ((unsigned int )*(array + l) != (unsigned int )((void *)0))) {
#line 571
            goto while_break___0;
          }
#line 572
          l ++;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 574
        tmp___3 = realloc((void *)result, (size_t )((unsigned long )(result_size + l) * sizeof(char *)));
        }
#line 574
        result = (char **)tmp___3;
        }
#line 576
        if ((unsigned int )result == (unsigned int )((void *)0)) {
#line 577
          goto memory_error;
        }
#line 579
        l = 0U;
        {
        {
#line 579
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 579
          if (! ((unsigned int )*(array + l) != (unsigned int )((void *)0))) {
#line 579
            goto while_break___1;
          }
#line 580
          tmp___4 = result_size;
#line 580
          result_size ++;
#line 580
          *(result + (tmp___4 - 1U)) = *(array + l);
#line 579
          l ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 581
        *(result + (result_size - 1U)) = (char *)((void *)0);
        {
#line 582
        free((void *)((char *)array));
        }
        }
      }
#line 557
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 586
    i = 0U;
    {
    {
#line 586
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 586
      if (! ((unsigned int )*(directories + i) != (unsigned int )((void *)0))) {
#line 586
        goto while_break___2;
      }
      {
      {
#line 587
      free((void *)*(directories + i));
      }
#line 586
      i ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 588
    free((void *)((char *)directories));
    }
    }
#line 590
    return (result);
  }
#line 594
  if ((int )*filename == 0) {
    {
    {
#line 596
    tmp___6 = realloc((void *)((char *)result), (size_t )(2UL * sizeof(char *)));
    }
#line 596
    result = (char **)tmp___6;
    }
#line 597
    if ((unsigned int )result != (unsigned int )((void *)0)) {
      {
      {
#line 599
      tmp___7 = malloc(directory_len + 1U);
      }
#line 599
      *(result + 0) = (char *)tmp___7;
      }
#line 600
      if ((unsigned int )*(result + 0) == (unsigned int )((void *)0)) {
#line 601
        goto memory_error;
      }
      {
      {
#line 607
      memcpy((void */* __restrict  */)*(result + 0), (void const   */* __restrict  */)directory_name,
             directory_len + 1U);
      }
#line 608
      *(result + 1) = (char *)((void *)0);
      }
    }
#line 613
    return (result);
  } else {
#line 619
    if (directory_len == 0U) {
#line 619
      tmp___8 = ".";
    } else {
#line 619
      tmp___8 = (char const   *)directory_name;
    }
    {
    {
#line 619
    tmp___9 = glob_vector(filename, (char *)tmp___8);
    }
#line 619
    temp_results___0 = tmp___9;
    }
#line 623
    if ((unsigned int )temp_results___0 == (unsigned int )((void *)0)) {
#line 628
      return (temp_results___0);
    } else
#line 623
    if ((unsigned int )temp_results___0 == (unsigned int )((char **)-1)) {
#line 628
      return (temp_results___0);
    }
    {
    {
#line 631
    temp_results___0 = glob_dir_to_array(directory_name, temp_results___0);
    }
    }
#line 635
    return (temp_results___0);
  }
  memory_error: 
#line 641
  if ((unsigned int )result != (unsigned int )((void *)0)) {
#line 644
    i___0 = 0U;
    {
    {
#line 644
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 644
      if (! ((unsigned int )*(result + i___0) != (unsigned int )((void *)0))) {
#line 644
        goto while_break___3;
      }
      {
      {
#line 645
      free((void *)*(result + i___0));
      }
#line 644
      i___0 ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
    {
#line 646
    free((void *)((char *)result));
    }
    }
  }
#line 656
  return ((char **)((void *)0));
}
}
#line 1 "util.o"
/* #pragma merger(0,"./util.i","-Wall,-Wstrict-prototypes,-Wmissing-prototypes") */
#line 344 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 767
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 115 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 492 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execv)(char const   *__path ,
                                                                                  char * const  *__argv ) ;
#line 618
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 621
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 624
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 627
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 643
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 648
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 660
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 665
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 695
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 35 "util.c"
char *mkprogname(char *s ) 
{ 
  char *t ;
  char *tmp ;

  {
  {
  {
#line 39
  t = strrchr((char const   *)s, '/');
  }
  }
#line 40
  if ((unsigned int )t == (unsigned int )((char *)((void *)0))) {
#line 41
    t = s;
  } else {
#line 43
    t ++;
  }
  {
  {
#line 45
  tmp = my_strdup(t);
  }
  }
#line 45
  return (tmp);
}
}
#line 59 "util.c"
int is_newer(char *fa , char *fb ) 
{ 
  struct stat fa_sb ;
  struct stat fb_sb ;
  register int fa_stat ;
  register int fb_stat ;
  register int status ;

  {
  {
#line 65
  status = 0;
  {
#line 67
  fa_stat = stat((char const   */* __restrict  */)fa, (struct stat */* __restrict  */)(& fa_sb));
  }
  }
#line 68
  if (fa_stat != 0) {
#line 69
    status = 1;
  } else
#line 68
  if (fa_sb.st_size == 0L) {
#line 69
    status = 1;
  }
  {
  {
#line 71
  fb_stat = stat((char const   */* __restrict  */)fb, (struct stat */* __restrict  */)(& fb_sb));
  }
  }
#line 72
  if (fb_stat != 0) {
#line 73
    status |= 2;
  } else
#line 72
  if (fb_sb.st_size == 0L) {
#line 73
    status |= 2;
  }
#line 75
  if (status != 0) {
#line 76
    return (- status);
  }
#line 78
  return (fa_sb.st_mtim.tv_sec > fb_sb.st_mtim.tv_sec);
}
}
#line 83 "util.c"
void get_permissions(void) 
{ 
  __uid_t tmp ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __gid_t tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 85
  tmp = getuid();
  }
#line 85
  ruid = (int )tmp;
  {
#line 86
  tmp___0 = geteuid();
  }
#line 86
  euid = (int )tmp___0;
  {
#line 87
  tmp___1 = getgid();
  }
#line 87
  rgid = (int )tmp___1;
  {
#line 88
  tmp___2 = getegid();
  }
#line 88
  egid = (int )tmp___2;
  }
#line 89
  if (ruid != euid) {
#line 89
    tmp___3 = 1;
  } else
#line 89
  if (rgid != egid) {
#line 89
    tmp___3 = 1;
  } else {
#line 89
    tmp___3 = 0;
  }
#line 89
  suid = tmp___3;
#line 90
  return;
}
}
#line 92 "util.c"
void no_privileges(void) 
{ 


  {
#line 94
  if (suid) {
    {
    {
#line 96
    setreuid((unsigned int )ruid, (unsigned int )ruid);
    }
    {
#line 97
    setregid((unsigned int )rgid, (unsigned int )rgid);
    }
#line 99
    suid = 0;
    }
  }
#line 101
  return;
}
}
#line 109 "util.c"
static int system0(char *command ) 
{ 
  int pid ;
  int pid2 ;
  int status ;
  char *argv[4] ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 113
  pid = fork();
  }
  }
#line 114
  if (pid == -1) {
    {
    {
#line 115
    perror((char const   *)progname);
    }
    {
#line 116
    fatal(69, command);
    }
    }
  }
#line 118
  if (pid == 0) {
    {
#line 120
    argv[0] = (char *)"sh";
#line 121
    argv[1] = (char *)"-c";
#line 122
    argv[2] = command;
#line 123
    argv[3] = (char *)0;
    {
#line 124
    execv("/bin/sh", (char * const  *)(argv));
    }
    {
#line 125
    exit(127);
    }
    }
  }
  {
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 128
    pid2 = wait((union wait *)(& status));
    }
    }
#line 129
    if (pid2 == -1) {
#line 130
      return (-1);
    }
#line 127
    if (! (pid2 != pid)) {
#line 127
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return (status);
}
}
#line 144 "util.c"
static int interrupted  =    0;
#line 145 "util.c"
static void catch_int(int a ) 
{ 


  {
#line 146
  interrupted = 1;
#line 147
  return;
}
}
#line 149 "util.c"
static int system1(char *command ) 
{ 
  void (*prev_handler)(int  ) ;
  void (*tmp)(int  ) ;
  int ret ;
  int tmp___0 ;

  {
  {
  {
#line 151
  tmp = signal(2, & catch_int);
  }
#line 151
  prev_handler = tmp;
  {
#line 152
  tmp___0 = system0(command);
  }
#line 152
  ret = tmp___0;
  }
#line 153
  if (interrupted) {
    {
    {
#line 154
    exit(1);
    }
    }
  }
  {
  {
#line 155
  signal(2, prev_handler);
  }
  }
#line 156
  return (ret);
}
}
#line 159 "util.c"
static int my_system(char *command ) 
{ 
  int pid ;
  int pid2 ;
  int status ;
  int stat___0 ;
  int tmp ;
  int tmp___0 ;
  union __anonunion___u_48 __u___1 ;
  union __anonunion___u_49 __u___2 ;
  int tmp___1 ;
  union __anonunion___u_52 __u___5 ;
  union __anonunion___u_53 __u___6 ;
  union __anonunion___u_54 __u___7 ;
  union __anonunion___u_55 __u___8 ;
  union __anonunion___u_56 __u___9 ;

  {
#line 163
  if (! suid) {
    {
    {
#line 164
    tmp = system1(command);
    }
    }
#line 164
    return (tmp);
  }
  {
  {
#line 169
  setuid((unsigned int )ruid);
  }
  {
#line 170
  setgid((unsigned int )rgid);
  }
  {
#line 171
  status = system1(command);
  }
  {
#line 172
  setuid((unsigned int )euid);
  }
  {
#line 173
  setgid((unsigned int )egid);
  }
#line 174
  __u___2.__in = status;
  }
#line 174
  if ((__u___2.__i & 127) == 0) {
#line 174
    __u___1.__in = status;
#line 174
    tmp___0 = (__u___1.__i & 65280) >> 8;
  } else {
#line 174
    tmp___0 = 127;
  }
#line 174
  return (tmp___0);
  {
  {
#line 177
  fflush(stdout);
  }
  {
#line 177
  fflush(stderr);
  }
  {
#line 178
  pid = fork();
  }
  }
#line 179
  if (pid == -1) {
    {
    {
#line 180
    perror((char const   *)progname);
    }
    {
#line 181
    fatal(69, command);
    }
    }
  }
#line 183
  if (pid == 0) {
    {
    {
#line 184
    setuid((unsigned int )ruid);
    }
    {
#line 185
    setgid((unsigned int )rgid);
    }
    {
#line 186
    status = system1(command);
    }
#line 187
    __u___6.__in = status;
    }
#line 187
    if ((__u___6.__i & 127) == 0) {
#line 187
      __u___5.__in = status;
#line 187
      tmp___1 = (__u___5.__i & 65280) >> 8;
    } else {
#line 187
      tmp___1 = 127;
    }
    {
    {
#line 187
    exit(tmp___1);
    }
    }
  }
  {
  {
#line 189
  pid2 = wait((union wait *)(& stat___0));
  }
  }
#line 190
  if (pid2 == -1) {
    {
    {
#line 191
    perror((char const   *)progname);
    }
    {
#line 192
    fatal(70, command);
    }
    }
  }
#line 194
  if (pid2 != pid) {
    {
    {
#line 195
    fatal(71);
    }
    }
  }
#line 196
  __u___8.__in = stat___0;
#line 196
  if ((__u___8.__i & 127) == 0) {
#line 196
    __u___9.__in = stat___0;
#line 196
    if ((__u___9.__i & 65280) >> 8 != 127) {
#line 197
      __u___7.__in = stat___0;
#line 197
      return ((__u___7.__i & 65280) >> 8);
    }
  }
  {
  {
#line 198
  fatal(72, command);
  }
  }
#line 199
  return (-1);
}
}
#line 202 "util.c"
FILE *my_popen(char const   *command , char const   *type ) 
{ 
  FILE *r ;
  FILE *tmp ;
  FILE *tmp___0 ;

  {
#line 206
  if (! suid) {
    {
    {
#line 207
    tmp = popen(command, type);
    }
    }
#line 207
    return (tmp);
  }
  {
  {
#line 210
  setuid((unsigned int )ruid);
  }
  {
#line 211
  setgid((unsigned int )rgid);
  }
  {
#line 212
  r = popen(command, type);
  }
  {
#line 213
  setuid((unsigned int )euid);
  }
  {
#line 214
  setgid((unsigned int )egid);
  }
  }
#line 215
  return (r);
  {
  {
#line 218
  no_privileges();
  }
  {
#line 219
  tmp___0 = popen(command, type);
  }
  }
#line 219
  return (tmp___0);
}
}
#line 225 "util.c"
int do_system_command(char *command , int silent ) 
{ 
  int status ;

  {
#line 227
  status = 0;
#line 232
  if (debug & 1) {
    {
    {
#line 233
    gripe(58, command);
    }
    }
  } else {
    {
    {
#line 235
    status = my_system(command);
    }
    }
  }
#line 237
  if (status) {
#line 237
    if (! silent) {
      {
      {
#line 238
      gripe(12, command, status);
      }
      }
    }
  }
#line 240
  return (status);
}
}
#line 243 "util.c"
char *my_malloc(int n ) 
{ 
  char *s ;
  void *tmp ;

  {
  {
  {
#line 245
  tmp = malloc((unsigned int )n);
  }
#line 245
  s = (char *)tmp;
  }
#line 246
  if (! s) {
    {
    {
#line 247
    fatal(14, n);
    }
    }
  }
#line 248
  return (s);
}
}
#line 251 "util.c"
char *my_strdup(char *s ) 
{ 
  char *t ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
  {
#line 253
  tmp = strlen((char const   *)s);
  }
  {
#line 253
  tmp___0 = my_malloc((int )(tmp + 1U));
  }
#line 253
  t = tmp___0;
  {
#line 254
  strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)s);
  }
  }
#line 255
  return (t);
}
}
#line 263 "util.c"
static void nothing(int x ) 
{ 


  {
#line 264
  return;
}
}
#line 266 "util.c"
char *my_xsprintf(char *format  , ...) 
{ 
  int len ;
  size_t tmp ;
  char *s ;
  va_list p ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 275
  tmp = strlen((char const   *)format);
  }
#line 276
  len = (int )(tmp + 1U);
  {
#line 277
  __builtin_va_start(p, format);
  }
#line 278
  s = format;
  }
  {
  {
#line 279
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 279
    if (! *s) {
#line 279
      goto while_break;
    }
#line 280
    if ((int )*s == 37) {
      {
#line 282
      if ((int )*(s + 1) == 115) {
#line 282
        goto case_115;
      }
#line 289
      if ((int )*(s + 1) == 99) {
#line 289
        goto case_99;
      }
#line 289
      if ((int )*(s + 1) == 111) {
#line 289
        goto case_99;
      }
#line 289
      if ((int )*(s + 1) == 100) {
#line 289
        goto case_99;
      }
#line 294
      goto switch_default;
      case_115: /* CIL Label */ 
      {
      {
#line 283
      tmp___3 = __builtin_va_arg(p, char *);
      }
#line 283
      tmp___0 = tmp___3;
      {
#line 284
      tmp___1 = strlen((char const   *)tmp___0);
      }
#line 285
      len = (int )((size_t )len + tmp___1);
      }
#line 286
      goto switch_break;
      case_99: /* CIL Label */ 
      case_111: /* CIL Label */ 
      case_100: /* CIL Label */ 
      {
#line 290
      len += 20;
      {
#line 291
      tmp___4 = __builtin_va_arg(p, int );
      }
#line 291
      tmp___2 = tmp___4;
      {
#line 292
      nothing(tmp___2);
      }
      }
#line 293
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 295
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"my_xsprintf called with %s\n",
              format);
      }
      {
#line 297
      exit(1);
      }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 300
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 302
  __builtin_va_end(p);
  }
  {
#line 303
  s = my_malloc(len);
  }
  {
#line 304
  __builtin_va_start(p, format);
  }
  {
#line 305
  vsprintf((char */* __restrict  */)s, (char const   */* __restrict  */)format, p);
  }
  {
#line 306
  __builtin_va_end(p);
  }
  }
#line 307
  return (s);
}
}
#line 1 "msg.o"
/* #pragma merger(0,"./msg.i","-Wall,-Wstrict-prototypes,-Wmissing-prototypes") */
#line 1 "msg.c"
char *msg[77]  = 
#line 1 "msg.c"
  {      (char *)"",      (char *)"unable to make sense of the file %s\n",      (char *)"Warning: cannot open configuration file %s\n",      (char *)"Error parsing config file\n", 
        (char *)"incompatible options %s and %s\n",      (char *)"Sorry - no support for alternate systems compiled in\n",      (char *)"Man was compiled with automatic cat page compression,\nbut the configuration file does not define COMPRESS.\n",      (char *)"What manual page do you want from section %s?\n", 
        (char *)"What manual page do you want?\n",      (char *)"No entry for %s in section %s of the manual\n",      (char *)"No manual entry for %s\n",      (char *)"\nusing %s as pager\n", 
        (char *)"Error executing formatting or display command.\nSystem command %s exited with status %d.\n",      (char *)"%s, version %s\n\n",      (char *)"Out of memory - can\'t malloc %d bytes\n",      (char *)"Error parsing *roff command from file %s\n", 
        (char *)"Error parsing MANROFFSEQ.  Using system defaults.\n",      (char *)"Error parsing *roff command from command line.\n",      (char *)"Unrecognized line in config file (ignored)\n%s\n",      (char *)"man-config.c: internal error: string %s not found\n", 
        (char *)"found man directory %s\n",      (char *)"found manpath map %s --> %s\n",      (char *)"corresponding catdir is %s\n",      (char *)"Line too long in config file\n", 
        (char *)"\nsection: %s\n",      (char *)"unlinked %s\n",      (char *)"globbing %s\n",      (char *)"Attempt [%s] to expand man page failed\n", 
        (char *)"Cannot open man page %s\n",      (char *)"Error reading man page %s\n",      (char *)"found eqn(1) directive\n",      (char *)"found grap(1) directive\n", 
        (char *)"found pic(1) directive\n",      (char *)"found tbl(1) directive\n",      (char *)"found vgrind(1) directive\n",      (char *)"found refer(1) directive\n", 
        (char *)"parsing directive from command line\n",      (char *)"parsing directive from file %s\n",      (char *)"parsing directive from environment\n",      (char *)"using default preprocessor sequence\n", 
        (char *)"Formatting page, please wait...\n",      (char *)"changed mode of %s to %o\n",      (char *)"Couldn\'t open %s for writing.\n",      (char *)"will try to write %s if needed\n", 
        (char *)"status from is_newer() = %d\n",      (char *)"trying section %s\n",      (char *)"\nsearching in %s\n",      (char *)"but %s is already in the manpath\n", 
        (char *)"Warning: cannot stat file %s!\n",      (char *)"Warning: %s isn\'t a directory!\n",      (char *)"adding %s to manpath\n",      (char *)"\npath directory %s ", 
        (char *)"is in the config file\n",      (char *)"is not in the config file\n",      (char *)"but there is a man directory nearby\n",      (char *)"and we found no man directory nearby\n", 
        (char *)"\nadding mandatory man directories\n\n",      (char *)"cat_name in convert_to_cat () is: %s\n",      (char *)"\nnot executing command:\n  %s\n",      (char *)"usage: %s [-adfhktwW] [section] [-M path] [-P pager] [-S list]\n\t", 
        (char *)"[-m system] ",      (char *)"[-p string] name ...\n\n",      (char *)"  a : find all matching entries\n  c : do not use cat file\n  d : print gobs of debugging information\n  D : as for -d, but also display the pages\n  f : same as whatis(1)\n  h : print this help message\n  k : same as apropos(1)\n  K : search for a string in all pages\n",      (char *)"  t : use troff to format pages for printing\n", 
        (char *)"  w : print location of man page(s) that would be displayed\n      (if no name given: print directories that would be searched)\n  W : as for -w, but display filenames only\n\n  C file   : use `file\' as configuration file\n  M path   : set search path for manual pages to `path\'\n  P pager  : use program `pager\' to display pages\n  S list   : colon separated section list\n",      (char *)"  m system : search for alternate system\'s man pages\n",      (char *)"  p string : string tells which preprocessors to run\n               e - [n]eqn(1)   p - pic(1)    t - tbl(1)\n               g - grap(1)     r - refer(1)  v - vgrind(1)\n",      (char *)"and the real user cannot open the cat file either\n", 
        (char *)"but the real user can open the cat file\n",      (char *)"failed to fork off the command _%s_\n",      (char *)"error while waiting for child _%s_\n",      (char *)"very strange ..., got wrong pid while waiting for my child\n", 
        (char *)"fatal error: the command _%s_ terminated abnormally\n",      (char *)"Man page %s is identical to %s\n",      (char *)"Found the man page(s):\n",      (char *)"error: no TROFF command specified in %s\n", 
        (char *)"no cat page stored because of nonstandard line length\n"};

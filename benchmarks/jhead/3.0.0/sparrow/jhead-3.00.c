/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 74 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
struct __anonstruct_JfifHeader_31 {
   char Present ;
   char ResolutionUnits ;
   short XDensity ;
   short YDensity ;
};
#line 74 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
struct __anonstruct_ImageInfo_t_30 {
   char FileName[4097] ;
   time_t FileDateTime ;
   struct __anonstruct_JfifHeader_31 JfifHeader ;
   unsigned int FileSize ;
   char CameraMake[32] ;
   char CameraModel[40] ;
   char DateTime[20] ;
   unsigned int Height ;
   unsigned int Width ;
   int Orientation ;
   int IsColor ;
   int Process ;
   int FlashUsed ;
   float FocalLength ;
   float ExposureTime ;
   float ApertureFNumber ;
   float Distance ;
   float CCDWidth ;
   float ExposureBias ;
   float DigitalZoomRatio ;
   int FocalLength35mmEquiv ;
   int Whitebalance ;
   int MeteringMode ;
   int ExposureProgram ;
   int ExposureMode ;
   int ISOequivalent ;
   int LightSource ;
   int DistanceRange ;
   float xResolution ;
   float yResolution ;
   int ResolutionUnit ;
   char Comments[16000] ;
   int CommentWidthchars ;
   unsigned int ThumbnailOffset ;
   unsigned int ThumbnailSize ;
   unsigned int LargestExifOffset ;
   char ThumbnailAtEnd ;
   int ThumbnailSizeOffset ;
   int DateTimeOffsets[10] ;
   int numDateTimeTags ;
   int GpsInfoPresent ;
   char GpsLat[31] ;
   char GpsLong[31] ;
   char GpsAlt[20] ;
   int QualityGuess ;
};
#line 74 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
typedef struct __anonstruct_ImageInfo_t_30 ImageInfo_t;
#line 36 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
typedef unsigned char uchar;
#line 58 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
struct __anonstruct_Section_t_29 {
   uchar *Data ;
   int Type ;
   unsigned int Size ;
};
#line 58 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
typedef struct __anonstruct_Section_t_29 Section_t;
#line 145
enum __anonenum_ReadMode_t_32 {
    READ_METADATA = 1,
    READ_IMAGE = 2,
    READ_ALL = 3,
    READ_ANY = 5
} ;
#line 145 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
typedef enum __anonenum_ReadMode_t_32 ReadMode_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 24 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
struct __anonstruct_TagTable_t_35 {
   unsigned short Tag ;
   char *Desc ;
};
#line 24 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
typedef struct __anonstruct_TagTable_t_35 TagTable_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 210 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
int EnsurePathExists(char const   *FileName ) ;
#line 211
void CatPath(char *BasePath , char const   *FilePath ) ;
#line 24 "/home/khheo/project/cve/benchmark/jhead-3.00/paths.c"
int EnsurePathExists(char const   *FileName ) 
{ 
  char NewPath[8192] ;
  int a ;
  int LastSlash ;
  size_t tmp ;
  struct stat dummy ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 28
  LastSlash = 0;
#line 33
  strcpy((char */* __restrict  */)(NewPath), (char const   */* __restrict  */)FileName);
#line 34
  tmp = strlen((char const   *)(NewPath));
#line 34
  a = (int )tmp;
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    a --;
#line 37
    if (a == 0) {
#line 38
      NewPath[0] = (char)0;
#line 39
      goto while_break;
    }
#line 41
    if ((int )NewPath[a] == 47) {
      {
#line 43
      NewPath[a] = (char)0;
#line 44
      tmp___0 = stat((char const   */* __restrict  */)(NewPath), (struct stat */* __restrict  */)(& dummy));
      }
#line 44
      if (tmp___0 == 0) {
#line 45
        if ((dummy.st_mode & 61440U) == 16384U) {
#line 48
          if (LastSlash == 0) {
#line 50
            return (1);
          }
#line 52
          goto while_break;
        } else {
          {
#line 55
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t create path \'%s\' due to file conflict\n",
                  NewPath);
          }
#line 56
          return (0);
        }
      }
#line 59
      if (LastSlash == 0) {
#line 59
        LastSlash = a;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 66
    if (! *(FileName + a)) {
#line 66
      goto while_break___0;
    }
#line 67
    if ((int const   )*(FileName + a) == 47) {
#line 67
      goto _L;
    } else
#line 67
    if (a == 0) {
      _L: /* CIL Label */ 
#line 68
      if (a == LastSlash) {
#line 68
        goto while_break___0;
      }
      {
#line 69
      NewPath[a] = (char )*(FileName + a);
#line 74
      tmp___1 = mkdir((char const   *)(NewPath), (__mode_t )511);
      }
#line 74
      if (tmp___1) {
        {
#line 75
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not create directory \'%s\'\n",
                NewPath);
        }
#line 77
        return (0);
      }
    }
#line 66
    a ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 81
  return (1);
}
}
#line 88 "/home/khheo/project/cve/benchmark/jhead-3.00/paths.c"
void CatPath(char *BasePath , char const   *FilePath ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 91
  tmp = strlen((char const   *)BasePath);
#line 91
  l = (int )tmp;
  }
#line 93
  if ((int const   )*(FilePath + 1) == 58) {
#line 95
    l = 0;
  }
#line 98
  if ((int const   )*(FilePath + 0) == 47) {
    {
#line 100
    strcpy((char */* __restrict  */)BasePath, (char const   */* __restrict  */)FilePath);
    }
#line 101
    return;
  } else
#line 98
  if ((int const   )*(FilePath + 0) == 46) {
    {
#line 100
    strcpy((char */* __restrict  */)BasePath, (char const   */* __restrict  */)FilePath);
    }
#line 101
    return;
  } else
#line 98
  if (l == 0) {
    {
#line 100
    strcpy((char */* __restrict  */)BasePath, (char const   */* __restrict  */)FilePath);
    }
#line 101
    return;
  }
#line 104
  if ((int )*(BasePath + (l - 1)) != 47) {
#line 105
    tmp___0 = l;
#line 105
    l ++;
#line 105
    *(BasePath + tmp___0) = (char )'/';
#line 106
    *(BasePath + l) = (char)0;
  }
  {
#line 109
  strcat((char */* __restrict  */)BasePath, (char const   */* __restrict  */)FilePath);
  }
#line 113
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 66 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
int DumpExifMap ;
#line 155
void ErrNonfatal(char const   *msg , int a1 , int a2 ) ;
#line 164
void PrintFormatNumber(void *ValuePtr , int Format , int ByteCount ) ;
#line 166
int Get16u(void *Short ) ;
#line 167
unsigned int Get32u(void *Long ) ;
#line 174
int const   BytesPerFormat[13] ;
#line 192
void ProcessMakerNote(unsigned char *ValuePtr , int ByteCount , unsigned char *OffsetBase ,
                      unsigned int ExifLength ) ;
#line 232
ImageInfo_t ImageInfo ;
#line 233
int ShowTags ;
#line 7 "/home/khheo/project/cve/benchmark/jhead-3.00/makernote.c"
int MotorolaOrder ;
#line 12 "/home/khheo/project/cve/benchmark/jhead-3.00/makernote.c"
static void ProcessCanonMakerNoteDir(unsigned char *DirStart , unsigned char *OffsetBase ,
                                     unsigned int ExifLength ) 
{ 
  int de ;
  int a ;
  int NumDirEntries ;
  unsigned char *DirEnd ;
  int Tag ;
  int Format ;
  int Components ;
  unsigned char *ValuePtr ;
  int ByteCount ;
  unsigned char *DirEntry ;
  unsigned int tmp ;
  unsigned int OffsetVal ;
  int ZeroSkipped ;
  int IsoCode ;
  int tmp___0 ;
  int WhiteBalance ;
  int tmp___1 ;
  int temp_dist ;
  int tmp___2 ;

  {
  {
#line 19
  NumDirEntries = Get16u((void *)DirStart);
#line 24
  DirEnd = (DirStart + 2) + 12 * NumDirEntries;
  }
#line 25
  if ((unsigned long )DirEnd > (unsigned long )(OffsetBase + ExifLength)) {
    {
#line 26
    ErrNonfatal("Illegally sized Exif makernote subdir (%d entries)", NumDirEntries,
                0);
    }
#line 27
    return;
  }
#line 30
  if (DumpExifMap) {
    {
#line 31
    printf((char const   */* __restrict  */)"Map: %05u-%05u: Directory (makernote)\n",
           (int )(DirStart - OffsetBase), (int )(DirEnd - OffsetBase));
    }
  }
#line 35
  if (ShowTags) {
    {
#line 36
    printf((char const   */* __restrict  */)"(dir has %d entries)\n", NumDirEntries);
    }
  }
#line 39
  de = 0;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! (de < NumDirEntries)) {
#line 39
      goto while_break;
    }
    {
#line 44
    DirEntry = (DirStart + 2) + 12 * de;
#line 46
    Tag = Get16u((void *)DirEntry);
#line 47
    Format = Get16u((void *)(DirEntry + 2));
#line 48
    tmp = Get32u((void *)(DirEntry + 4));
#line 48
    Components = (int )tmp;
    }
#line 50
    if (Format - 1 >= 12) {
      {
#line 52
      ErrNonfatal("Illegal Exif number format %d for maker tag %04x", Format, Tag);
      }
#line 53
      goto __Cont;
    }
#line 56
    if ((unsigned int )Components > 65536U) {
      {
#line 57
      ErrNonfatal("Too many components (%d) for Exif maker tag %04x", Components,
                  Tag);
      }
#line 58
      goto __Cont;
    }
#line 61
    ByteCount = Components * (int )BytesPerFormat[Format];
#line 63
    if (ByteCount > 4) {
      {
#line 65
      OffsetVal = Get32u((void *)(DirEntry + 8));
      }
#line 67
      if (OffsetVal + (unsigned int )ByteCount > ExifLength) {
        {
#line 69
        ErrNonfatal("Illegal value pointer for Exif maker tag %04x", Tag, 0);
        }
#line 70
        goto __Cont;
      }
#line 72
      ValuePtr = OffsetBase + OffsetVal;
#line 74
      if (DumpExifMap) {
        {
#line 75
        printf((char const   */* __restrict  */)"Map: %05d-%05d:   Data for makernote tag %04x\n",
               OffsetVal, OffsetVal + (unsigned int )ByteCount, Tag);
        }
      }
    } else {
#line 79
      ValuePtr = DirEntry + 8;
    }
#line 82
    if (ShowTags) {
      {
#line 84
      printf((char const   */* __restrict  */)"            Canon maker tag %04x Value = ",
             Tag);
      }
    }
    {
#line 93
    if (Format == 2) {
#line 93
      goto case_2;
    }
#line 93
    if (Format == 7) {
#line 93
      goto case_2;
    }
#line 115
    goto switch_default;
    case_2: /* CIL Label */ 
    case_7: /* CIL Label */ 
#line 95
    if (ShowTags) {
      {
#line 96
      printf((char const   */* __restrict  */)"\"");
#line 97
      a = 0;
      }
      {
#line 97
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 97
        if (! (a < ByteCount)) {
#line 97
          goto while_break___0;
        }
#line 98
        ZeroSkipped = 0;
#line 99
        if ((int )*(ValuePtr + a) >= 32) {
#line 100
          if (ZeroSkipped) {
            {
#line 101
            printf((char const   */* __restrict  */)"?");
#line 102
            ZeroSkipped = 0;
            }
          }
          {
#line 104
          putchar((int )*(ValuePtr + a));
          }
        } else
#line 106
        if ((int )*(ValuePtr + a) == 0) {
#line 107
          ZeroSkipped = 1;
        }
#line 97
        a ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 111
      printf((char const   */* __restrict  */)"\"\n");
      }
    }
#line 113
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 116
    if (ShowTags) {
      {
#line 117
      PrintFormatNumber((void *)ValuePtr, Format, ByteCount);
#line 118
      printf((char const   */* __restrict  */)"\n");
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 121
    if (Tag == 1) {
#line 121
      if (Components > 16) {
        {
#line 122
        tmp___0 = Get16u((void *)(ValuePtr + 16UL * sizeof(unsigned short )));
#line 122
        IsoCode = tmp___0;
        }
#line 123
        if (IsoCode >= 16) {
#line 123
          if (IsoCode <= 24) {
#line 124
            ImageInfo.ISOequivalent = 50 << (IsoCode - 16);
          }
        }
      }
    }
#line 128
    if (Tag == 4) {
#line 128
      if (Format == 3) {
#line 129
        if (Components > 7) {
          {
#line 130
          tmp___1 = Get16u((void *)(ValuePtr + 7UL * sizeof(unsigned short )));
#line 130
          WhiteBalance = tmp___1;
          }
          {
#line 133
          if (WhiteBalance == 1) {
#line 133
            goto case_1;
          }
#line 134
          if (WhiteBalance == 2) {
#line 134
            goto case_2___0;
          }
#line 135
          if (WhiteBalance == 3) {
#line 135
            goto case_3;
          }
#line 136
          if (WhiteBalance == 4) {
#line 136
            goto case_4;
          }
#line 137
          if (WhiteBalance == 5) {
#line 137
            goto case_5;
          }
#line 131
          goto switch_break___0;
          case_1: /* CIL Label */ 
#line 133
          ImageInfo.LightSource = 1;
#line 133
          goto switch_break___0;
          case_2___0: /* CIL Label */ 
#line 134
          ImageInfo.LightSource = 1;
#line 134
          goto switch_break___0;
          case_3: /* CIL Label */ 
#line 135
          ImageInfo.LightSource = 3;
#line 135
          goto switch_break___0;
          case_4: /* CIL Label */ 
#line 136
          ImageInfo.LightSource = 2;
#line 136
          goto switch_break___0;
          case_5: /* CIL Label */ 
#line 137
          ImageInfo.LightSource = 4;
#line 137
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
        }
#line 140
        if (Components > 19) {
#line 140
          if (ImageInfo.Distance <= (float )0) {
            {
#line 143
            tmp___2 = Get16u((void *)(ValuePtr + 19UL * sizeof(unsigned short )));
#line 143
            temp_dist = tmp___2;
            }
#line 144
            if (temp_dist != 65535) {
#line 145
              ImageInfo.Distance = (float )temp_dist / (float )100;
            } else {
#line 147
              ImageInfo.Distance = (float )-1;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 39
    de ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return;
}
}
#line 157 "/home/khheo/project/cve/benchmark/jhead-3.00/makernote.c"
static void ShowMakerNoteGeneric(unsigned char *ValuePtr , int ByteCount ) 
{ 
  int a ;

  {
#line 160
  a = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (a < ByteCount)) {
#line 160
      goto while_break;
    }
#line 161
    if (a > 10) {
      {
#line 162
      printf((char const   */* __restrict  */)"...");
      }
#line 163
      goto while_break;
    }
    {
#line 165
    printf((char const   */* __restrict  */)" %02x", (int )*(ValuePtr + a));
#line 160
    a ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  printf((char const   */* __restrict  */)" (%d bytes)", ByteCount);
#line 168
  printf((char const   */* __restrict  */)"\n");
  }
#line 169
  return;
}
}
#line 180 "/home/khheo/project/cve/benchmark/jhead-3.00/makernote.c"
static int MotorolaOrderSave  ;
#line 174 "/home/khheo/project/cve/benchmark/jhead-3.00/makernote.c"
void ProcessMakerNote(unsigned char *ValuePtr , int ByteCount , unsigned char *OffsetBase ,
                      unsigned int ExifLength ) 
{ 
  char *tmp ;

  {
  {
#line 177
  tmp = strstr((char const   *)(ImageInfo.CameraMake), "Canon");
  }
#line 177
  if (tmp) {
    {
#line 181
    MotorolaOrderSave = MotorolaOrder;
#line 182
    MotorolaOrder = 0;
#line 183
    ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
#line 184
    MotorolaOrder = MotorolaOrderSave;
    }
  } else
#line 186
  if (ShowTags) {
    {
#line 187
    ShowMakerNoteGeneric(ValuePtr, ByteCount);
    }
  }
#line 190
  return;
}
}
#line 228 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
void process_DQT(uchar const   *Data , int length ) ;
#line 229
void process_DHT(uchar const   *Data , int length ) ;
#line 18 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgqguess.c"
static int std_luminance_quant_tbl[64]  = 
#line 18 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgqguess.c"
  {      16,      11,      12,      14, 
        12,      10,      16,      14, 
        13,      14,      18,      17, 
        16,      19,      24,      40, 
        26,      24,      22,      22, 
        24,      49,      35,      37, 
        29,      40,      58,      51, 
        61,      60,      57,      51, 
        56,      55,      64,      72, 
        92,      78,      64,      68, 
        87,      69,      55,      56, 
        80,      109,      81,      87, 
        95,      98,      103,      104, 
        103,      62,      77,      113, 
        121,      112,      100,      120, 
        92,      101,      103,      99};
#line 29 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgqguess.c"
static int std_chrominance_quant_tbl[64]  = 
#line 29
  {      17,      18,      18,      24, 
        21,      24,      47,      26, 
        26,      47,      99,      66, 
        56,      66,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99, 
        99,      99,      99,      99};
#line 40 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgqguess.c"
static int *deftabs[2]  = {      std_luminance_quant_tbl,      std_chrominance_quant_tbl};
#line 46 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgqguess.c"
static int jpeg_zigzag_order[64]  = 
#line 46
  {      0,      1,      5,      6, 
        14,      15,      27,      28, 
        2,      4,      7,      13, 
        16,      26,      29,      42, 
        3,      8,      12,      17, 
        25,      30,      41,      43, 
        9,      11,      18,      24, 
        31,      40,      44,      53, 
        10,      19,      23,      32, 
        39,      45,      52,      54, 
        20,      22,      33,      38, 
        46,      51,      55,      60, 
        21,      34,      37,      47, 
        50,      56,      59,      61, 
        35,      36,      48,      49, 
        57,      58,      62,      63};
#line 81 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgqguess.c"
void process_DQT(uchar const   *Data , int length ) 
{ 
  int a ;
  int c ;
  int tableindex ;
  int coefindex ;
  int row ;
  int col ;
  unsigned int table[64] ;
  int *reftable ;
  double cumsf ;
  double cumsf2 ;
  int allones ;
  int tmp ;
  int tmp___0 ;
  unsigned int val ;
  register unsigned int temp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double x ;
  double qual ;
  double var ;

  {
#line 87
  reftable = (int *)((void *)0);
#line 88
  cumsf = 0.0;
#line 88
  cumsf2 = 0.0;
#line 89
  allones = 1;
#line 91
  a = 2;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (a < length)) {
#line 92
      goto while_break;
    }
#line 94
    tmp = a;
#line 94
    a ++;
#line 94
    c = (int )*(Data + tmp);
#line 95
    tableindex = c & 15;
#line 96
    if (ShowTags > 1) {
#line 97
      if (c >> 4) {
#line 97
        tmp___0 = 16;
      } else {
#line 97
        tmp___0 = 8;
      }
      {
#line 97
      printf((char const   */* __restrict  */)"DQT:  table %d precision %d\n", tableindex,
             tmp___0);
      }
    }
#line 99
    if (tableindex < 2) {
#line 100
      reftable = deftabs[tableindex];
    }
#line 104
    coefindex = 0;
    {
#line 104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 104
      if (! (coefindex < 64)) {
#line 104
        goto while_break___0;
      }
#line 106
      if (c >> 4) {
#line 108
        tmp___1 = a;
#line 108
        a ++;
#line 108
        temp = (unsigned int )*(Data + tmp___1);
#line 109
        temp *= 256U;
#line 110
        tmp___2 = a;
#line 110
        a ++;
#line 110
        val = (unsigned int )*(Data + tmp___2) + temp;
      } else {
#line 112
        tmp___3 = a;
#line 112
        a ++;
#line 112
        val = (unsigned int )*(Data + tmp___3);
      }
#line 114
      table[coefindex] = val;
#line 115
      if (reftable) {
#line 118
        x = (100.0 * (double )val) / (double )*(reftable + coefindex);
#line 119
        cumsf += x;
#line 120
        cumsf2 += x * x;
#line 122
        if (val != 1U) {
#line 122
          allones = 0;
        }
      }
#line 104
      coefindex ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 126
    if (ShowTags > 2) {
#line 127
      row = 0;
      {
#line 127
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 127
        if (! (row < 8)) {
#line 127
          goto while_break___1;
        }
        {
#line 128
        printf((char const   */* __restrict  */)"    ");
#line 129
        col = 0;
        }
        {
#line 129
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 129
          if (! (col < 8)) {
#line 129
            goto while_break___2;
          }
          {
#line 130
          printf((char const   */* __restrict  */)"%5u ", table[jpeg_zigzag_order[row * 8 + col]]);
#line 129
          col ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 132
        printf((char const   */* __restrict  */)"\n");
#line 127
        row ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 136
    if (reftable) {
#line 138
      cumsf /= 64.0;
#line 139
      cumsf2 /= 64.0;
#line 140
      var = cumsf2 - cumsf * cumsf;
#line 141
      if (allones) {
#line 142
        qual = 100.0;
      } else
#line 143
      if (cumsf <= 100.0) {
#line 144
        qual = (200.0 - cumsf) / 2.0;
      } else {
#line 146
        qual = 5000.0 / cumsf;
      }
#line 148
      if (ShowTags > 1) {
        {
#line 148
        printf((char const   */* __restrict  */)"  ");
        }
      }
#line 150
      if (ShowTags) {
        {
#line 151
        printf((char const   */* __restrict  */)"Approximate quality factor for qtable %d: %.0f (scale %.2f, var %.2f)\n",
               tableindex, qual, cumsf, var);
        }
      } else
#line 154
      if (tableindex == 0) {
#line 155
        ImageInfo.QualityGuess = (int )(qual + 0.5);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 170 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgqguess.c"
void process_DHT(uchar const   *Data , int length ) 
{ 
  int a ;
  int i ;
  int c ;
  int c2 ;
  unsigned char huff[16] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char tmp___2 ;

  {
#line 176
  if (ShowTags > 1) {
    {
#line 177
    printf((char const   */* __restrict  */)"DHT (length %d bytes)\n", length);
    }
  }
#line 180
  a = 2;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (a < length)) {
#line 181
      goto while_break;
    }
#line 183
    tmp = a;
#line 183
    a ++;
#line 183
    c = (int )*(Data + tmp);
#line 184
    if (ShowTags > 1) {
      {
#line 185
      printf((char const   */* __restrict  */)"  table %d\n", c);
      }
    }
#line 187
    i = 0;
    {
#line 187
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 187
      if (! (i < 16)) {
#line 187
        goto while_break___0;
      }
#line 188
      tmp___0 = a;
#line 188
      a ++;
#line 188
      huff[i] = (unsigned char )*(Data + tmp___0);
#line 187
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 190
    i = 0;
    {
#line 190
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 190
      if (! (i < 16)) {
#line 190
        goto while_break___1;
      }
#line 191
      if (ShowTags > 2) {
        {
#line 192
        printf((char const   */* __restrict  */)"  bits %2d (codes=%3u) ", i + 1,
               (unsigned int )huff[i]);
        }
      }
      {
#line 194
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 194
        tmp___2 = huff[i];
#line 194
        huff[i] = (unsigned char )((int )huff[i] - 1);
#line 194
        if (! tmp___2) {
#line 194
          goto while_break___2;
        }
#line 195
        tmp___1 = a;
#line 195
        a ++;
#line 195
        c2 = (int )*(Data + tmp___1);
#line 196
        if (ShowTags > 2) {
          {
#line 197
          printf((char const   */* __restrict  */)"  $%02x ", c2);
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 200
      if (ShowTags > 2) {
        {
#line 201
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 190
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 154 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
void ErrFatal(char const   *msg ) ;
#line 160
void process_EXIF(unsigned char *ExifSection , unsigned int length ) ;
#line 169
void Put32u(void *Value , unsigned int PutValue ) ;
#line 201
void ShowXmp(Section_t XmpSection ) ;
#line 214
int ReadJpegSections(FILE *infile , ReadMode_t ReadMode ) ;
#line 215
void DiscardData(void) ;
#line 216
void DiscardAllButExif(void) ;
#line 217
int ReadJpegFile(char const   *FileName , ReadMode_t ReadMode ) ;
#line 218
int ReplaceThumbnail(char const   *ThumbFileName ) ;
#line 219
int SaveThumbnail(char *ThumbFileName ) ;
#line 220
int RemoveSectionType(int SectionType ) ;
#line 221
int RemoveUnknownSections(void) ;
#line 222
void WriteJpegFile(char const   *FileName ) ;
#line 223
Section_t *FindSection(int SectionType ) ;
#line 224
Section_t *CreateSection(int SectionType , unsigned char *Data , int Size ) ;
#line 225
void ResetJpgfile(void) ;
#line 232 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
ImageInfo_t ImageInfo  ;
#line 15 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
static Section_t *Sections  =    (Section_t *)((void *)0);
#line 16 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
static int SectionsAllocated  ;
#line 17 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
static int SectionsRead  ;
#line 18 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
static int HaveAll  ;
#line 26 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
static int Get16m(void const   *Short ) 
{ 


  {
#line 28
  return (((int )*((uchar *)Short + 0) << 8) | (int )*((uchar *)Short + 1));
}
}
#line 37 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
static void process_COM(uchar const   *Data , int length ) 
{ 
  int ch ;
  char Comment[16001] ;
  int nch ;
  int a ;
  int tmp ;
  int tmp___0 ;

  {
#line 44
  nch = 0;
#line 46
  if (length > 16000) {
#line 46
    length = 16000;
  }
#line 48
  a = 2;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (a < length)) {
#line 48
      goto while_break;
    }
#line 49
    ch = (int )*(Data + a);
#line 51
    if (ch == 13) {
#line 51
      if ((int const   )*(Data + (a + 1)) == 10) {
#line 51
        goto __Cont;
      }
    }
#line 53
    if (ch >= 32) {
#line 54
      tmp = nch;
#line 54
      nch ++;
#line 54
      Comment[tmp] = (char )ch;
    } else
#line 53
    if (ch == 10) {
#line 54
      tmp = nch;
#line 54
      nch ++;
#line 54
      Comment[tmp] = (char )ch;
    } else
#line 53
    if (ch == 9) {
#line 54
      tmp = nch;
#line 54
      nch ++;
#line 54
      Comment[tmp] = (char )ch;
    } else {
#line 56
      tmp___0 = nch;
#line 56
      nch ++;
#line 56
      Comment[tmp___0] = (char )'?';
    }
    __Cont: /* CIL Label */ 
#line 48
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  Comment[nch] = (char )'\000';
#line 62
  if (ShowTags) {
    {
#line 63
    printf((char const   */* __restrict  */)"COM marker comment: %s\n", Comment);
    }
  }
  {
#line 66
  strcpy((char */* __restrict  */)(ImageInfo.Comments), (char const   */* __restrict  */)(Comment));
#line 67
  ImageInfo.CommentWidthchars = 0;
  }
#line 68
  return;
}
}
#line 74 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
static void process_SOFn(uchar const   *Data , int marker ) 
{ 
  int data_precision ;
  int num_components ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 78
  data_precision = (int )*(Data + 2);
#line 79
  tmp = Get16m((void const   *)(Data + 3));
#line 79
  ImageInfo.Height = (unsigned int )tmp;
#line 80
  tmp___0 = Get16m((void const   *)(Data + 5));
#line 80
  ImageInfo.Width = (unsigned int )tmp___0;
#line 81
  num_components = (int )*(Data + 7);
  }
#line 83
  if (num_components == 3) {
#line 84
    ImageInfo.IsColor = 1;
  } else {
#line 86
    ImageInfo.IsColor = 0;
  }
#line 89
  ImageInfo.Process = marker;
#line 91
  if (ShowTags) {
    {
#line 92
    printf((char const   */* __restrict  */)"JPEG image is %uw * %uh, %d color components, %d bits per sample\n",
           ImageInfo.Width, ImageInfo.Height, num_components, data_precision);
    }
  }
#line 95
  return;
}
}
#line 101 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
static void CheckSectionsAllocated(void) 
{ 
  void *tmp ;

  {
#line 103
  if (SectionsRead > SectionsAllocated) {
    {
#line 104
    ErrFatal("allocation screwup");
    }
  }
#line 106
  if (SectionsRead >= SectionsAllocated) {
    {
#line 107
    SectionsAllocated += SectionsAllocated / 2;
#line 108
    tmp = realloc((void *)Sections, sizeof(Section_t ) * (unsigned long )SectionsAllocated);
#line 108
    Sections = (Section_t *)tmp;
    }
#line 109
    if ((unsigned long )Sections == (unsigned long )((void *)0)) {
      {
#line 110
      ErrFatal("could not allocate data for entire image");
      }
    }
  }
#line 113
  return;
}
}
#line 119 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
int ReadJpegSections(FILE *infile , ReadMode_t ReadMode ) 
{ 
  int a ;
  int HaveCom ;
  int tmp ;
  int itemlen ;
  int prev ;
  int marker ;
  int ll ;
  int lh ;
  int got ;
  uchar *Data ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int cp ;
  int ep ;
  int size ;
  long tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 122
  HaveCom = 0;
#line 124
  a = fgetc(infile);
  }
#line 126
  if (a != 255) {
#line 127
    return (0);
  } else {
    {
#line 126
    tmp = fgetc(infile);
    }
#line 126
    if (tmp != 216) {
#line 127
      return (0);
    }
  }
#line 130
  ImageInfo.JfifHeader.YDensity = (short)300;
#line 130
  ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity;
#line 131
  ImageInfo.JfifHeader.ResolutionUnits = (char)1;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 136
    marker = 0;
#line 140
    CheckSectionsAllocated();
#line 142
    prev = 0;
#line 143
    a = 0;
    }
    {
#line 143
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 144
      marker = fgetc(infile);
      }
#line 145
      if (marker != 255) {
#line 145
        if (prev == 255) {
#line 145
          goto while_break___0;
        }
      }
#line 146
      if (marker == -1) {
        {
#line 147
        ErrFatal("Unexpected end of file");
        }
      }
#line 149
      prev = marker;
#line 143
      a ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 152
    if (a > 10) {
      {
#line 153
      ErrNonfatal("Extraneous %d padding bytes before section %02X", a - 1, marker);
      }
    }
    {
#line 156
    (Sections + SectionsRead)->Type = marker;
#line 159
    lh = fgetc(infile);
#line 160
    ll = fgetc(infile);
    }
#line 161
    if (lh == -1) {
      {
#line 162
      ErrFatal("Unexpected end of file");
      }
    } else
#line 161
    if (ll == -1) {
      {
#line 162
      ErrFatal("Unexpected end of file");
      }
    }
#line 165
    itemlen = (lh << 8) | ll;
#line 167
    if (itemlen < 2) {
      {
#line 168
      ErrFatal("invalid marker");
      }
    }
    {
#line 171
    (Sections + SectionsRead)->Size = (unsigned int )itemlen;
#line 173
    tmp___0 = malloc((size_t )itemlen);
#line 173
    Data = (uchar *)tmp___0;
    }
#line 174
    if ((unsigned long )Data == (unsigned long )((void *)0)) {
      {
#line 175
      ErrFatal("Could not allocate memory");
      }
    }
    {
#line 177
    (Sections + SectionsRead)->Data = Data;
#line 180
    *(Data + 0) = (uchar )lh;
#line 181
    *(Data + 1) = (uchar )ll;
#line 183
    tmp___1 = fread((void */* __restrict  */)(Data + 2), (size_t )1, (size_t )(itemlen - 2),
                    (FILE */* __restrict  */)infile);
#line 183
    got = (int )tmp___1;
    }
#line 184
    if (got != itemlen - 2) {
      {
#line 185
      ErrFatal("Premature end of file?");
      }
    }
#line 187
    SectionsRead ++;
    {
#line 191
    if (marker == 218) {
#line 191
      goto case_218;
    }
#line 221
    if (marker == 219) {
#line 221
      goto case_219;
    }
#line 226
    if (marker == 196) {
#line 226
      goto case_196;
    }
#line 232
    if (marker == 217) {
#line 232
      goto case_217;
    }
#line 236
    if (marker == 254) {
#line 236
      goto case_254;
    }
#line 246
    if (marker == 224) {
#line 246
      goto case_224;
    }
#line 283
    if (marker == 225) {
#line 283
      goto case_225;
    }
#line 304
    if (marker == 237) {
#line 304
      goto case_237;
    }
#line 328
    if (marker == 207) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 206) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 205) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 203) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 202) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 201) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 199) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 198) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 197) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 195) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 194) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 193) {
#line 328
      goto case_207;
    }
#line 328
    if (marker == 192) {
#line 328
      goto case_207;
    }
#line 331
    goto switch_default___0;
    case_218: /* CIL Label */ 
#line 193
    if ((unsigned int )ReadMode & 2U) {
      {
#line 196
      tmp___2 = ftell(infile);
#line 196
      cp = (int )tmp___2;
#line 197
      fseek(infile, 0L, 2);
#line 198
      tmp___3 = ftell(infile);
#line 198
      ep = (int )tmp___3;
#line 199
      fseek(infile, (long )cp, 0);
#line 201
      size = ep - cp;
#line 202
      tmp___4 = malloc((size_t )size);
#line 202
      Data = (uchar *)tmp___4;
      }
#line 203
      if ((unsigned long )Data == (unsigned long )((void *)0)) {
        {
#line 204
        ErrFatal("could not allocate data for entire image");
        }
      }
      {
#line 207
      tmp___5 = fread((void */* __restrict  */)Data, (size_t )1, (size_t )size, (FILE */* __restrict  */)infile);
#line 207
      got = (int )tmp___5;
      }
#line 208
      if (got != size) {
        {
#line 209
        ErrFatal("could not read the rest of the image");
        }
      }
      {
#line 212
      CheckSectionsAllocated();
#line 213
      (Sections + SectionsRead)->Data = Data;
#line 214
      (Sections + SectionsRead)->Size = (unsigned int )size;
#line 215
      (Sections + SectionsRead)->Type = 291;
#line 216
      SectionsRead ++;
#line 217
      HaveAll = 1;
      }
    }
#line 219
    return (1);
    case_219: /* CIL Label */ 
    {
#line 223
    process_DQT((uchar const   *)Data, itemlen);
    }
#line 224
    goto switch_break;
    case_196: /* CIL Label */ 
    {
#line 228
    process_DHT((uchar const   *)Data, itemlen);
    }
#line 229
    goto switch_break;
    case_217: /* CIL Label */ 
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No image in jpeg!\n");
    }
#line 234
    return (0);
    case_254: /* CIL Label */ 
#line 237
    if (HaveCom) {
      {
#line 239
      SectionsRead --;
#line 239
      free((void *)(Sections + SectionsRead)->Data);
      }
    } else
#line 237
    if (((unsigned int )ReadMode & 1U) == 0U) {
      {
#line 239
      SectionsRead --;
#line 239
      free((void *)(Sections + SectionsRead)->Data);
      }
    } else {
      {
#line 241
      process_COM((uchar const   *)Data, itemlen);
#line 242
      HaveCom = 1;
      }
    }
#line 244
    goto switch_break;
    case_224: /* CIL Label */ 
    {
#line 251
    tmp___6 = memcmp((void const   *)(Data + 2), (void const   *)"JFIF\000", (size_t )5);
    }
#line 251
    if (tmp___6) {
      {
#line 252
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Header missing JFIF marker\n");
      }
    }
#line 254
    if (itemlen < 16) {
      {
#line 255
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Jfif header too short\n");
      }
#line 256
      goto ignore;
    }
#line 259
    ImageInfo.JfifHeader.Present = (char)1;
#line 260
    ImageInfo.JfifHeader.ResolutionUnits = (char )*(Data + 9);
#line 261
    ImageInfo.JfifHeader.XDensity = (short )(((int )*(Data + 10) << 8) | (int )*(Data + 11));
#line 262
    ImageInfo.JfifHeader.YDensity = (short )(((int )*(Data + 12) << 8) | (int )*(Data + 13));
#line 263
    if (ShowTags) {
      {
#line 264
      printf((char const   */* __restrict  */)"JFIF SOI marker: Units: %d ", (int )ImageInfo.JfifHeader.ResolutionUnits);
      }
      {
#line 266
      if ((int )ImageInfo.JfifHeader.ResolutionUnits == 0) {
#line 266
        goto case_0;
      }
#line 267
      if ((int )ImageInfo.JfifHeader.ResolutionUnits == 1) {
#line 267
        goto case_1;
      }
#line 268
      if ((int )ImageInfo.JfifHeader.ResolutionUnits == 2) {
#line 268
        goto case_2;
      }
#line 269
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 266
      printf((char const   */* __restrict  */)"(aspect ratio)");
      }
#line 266
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 267
      printf((char const   */* __restrict  */)"(dots per inch)");
      }
#line 267
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 268
      printf((char const   */* __restrict  */)"(dots per cm)");
      }
#line 268
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 269
      printf((char const   */* __restrict  */)"(unknown)");
      }
#line 269
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 271
      printf((char const   */* __restrict  */)"  X-density=%d Y-density=%d\n", (int )ImageInfo.JfifHeader.XDensity,
             (int )ImageInfo.JfifHeader.YDensity);
      }
#line 273
      if (*(Data + 14)) {
        {
#line 274
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring jfif header thumbnail\n");
        }
      } else
#line 273
      if (*(Data + 15)) {
        {
#line 274
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring jfif header thumbnail\n");
        }
      }
    }
    ignore: 
    {
#line 280
    SectionsRead --;
#line 280
    free((void *)(Sections + SectionsRead)->Data);
    }
#line 281
    goto switch_break;
    case_225: /* CIL Label */ 
#line 285
    if ((unsigned int )ReadMode & 1U) {
      {
#line 286
      tmp___8 = memcmp((void const   *)(Data + 2), (void const   *)"Exif", (size_t )4);
      }
#line 286
      if (tmp___8 == 0) {
        {
#line 287
        process_EXIF(Data, (unsigned int )itemlen);
        }
#line 288
        goto switch_break;
      } else {
        {
#line 289
        tmp___7 = memcmp((void const   *)(Data + 2), (void const   *)"http:", (size_t )5);
        }
#line 289
        if (tmp___7 == 0) {
#line 290
          (Sections + (SectionsRead - 1))->Type = 4321;
#line 291
          if (ShowTags) {
            {
#line 292
            printf((char const   */* __restrict  */)"Image cotains XMP section, %d bytes long\n",
                   itemlen);
            }
#line 293
            if (ShowTags) {
              {
#line 294
              ShowXmp(*(Sections + (SectionsRead - 1)));
              }
            }
          }
#line 297
          goto switch_break;
        }
      }
    }
    {
#line 301
    SectionsRead --;
#line 301
    free((void *)(Sections + SectionsRead)->Data);
    }
#line 302
    goto switch_break;
    case_237: /* CIL Label */ 
#line 305
    if ((unsigned int )ReadMode & 1U) {
#line 306
      if (ShowTags) {
        {
#line 307
        printf((char const   */* __restrict  */)"Image cotains IPTC section, %d bytes long\n",
               itemlen);
        }
      }
    } else {
      {
#line 312
      SectionsRead --;
#line 312
      free((void *)(Sections + SectionsRead)->Data);
      }
    }
#line 314
    goto switch_break;
    case_207: /* CIL Label */ 
    case_206: /* CIL Label */ 
    case_205: /* CIL Label */ 
    case_203: /* CIL Label */ 
    case_202: /* CIL Label */ 
    case_201: /* CIL Label */ 
    case_199: /* CIL Label */ 
    case_198: /* CIL Label */ 
    case_197: /* CIL Label */ 
    case_195: /* CIL Label */ 
    case_194: /* CIL Label */ 
    case_193: /* CIL Label */ 
    case_192: /* CIL Label */ 
    {
#line 329
    process_SOFn((uchar const   *)Data, marker);
    }
#line 330
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 333
    if (ShowTags) {
      {
#line 334
      printf((char const   */* __restrict  */)"Jpeg section marker 0x%02x size %d\n",
             marker, itemlen);
      }
    }
#line 336
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return (1);
}
}
#line 345 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
void DiscardData(void) 
{ 
  int a ;

  {
#line 349
  a = 0;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! (a < SectionsRead)) {
#line 349
      goto while_break;
    }
    {
#line 350
    free((void *)(Sections + a)->Data);
#line 349
    a ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 353
  memset((void *)(& ImageInfo), 0, sizeof(ImageInfo));
#line 354
  SectionsRead = 0;
#line 355
  HaveAll = 0;
  }
#line 356
  return;
}
}
#line 361 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
int ReadJpegFile(char const   *FileName , ReadMode_t ReadMode ) 
{ 
  FILE *infile ;
  int ret ;

  {
  {
#line 366
  infile = fopen((char const   */* __restrict  */)FileName, (char const   */* __restrict  */)"rb");
  }
#line 368
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t open \'%s\'\n",
            FileName);
    }
#line 370
    return (0);
  }
  {
#line 375
  ret = ReadJpegSections(infile, ReadMode);
  }
#line 376
  if (! ret) {
#line 377
    if ((unsigned int )ReadMode == 5U) {
#line 380
      ret = 1;
    } else {
      {
#line 382
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not JPEG: %s\n",
              FileName);
      }
    }
  }
  {
#line 386
  fclose(infile);
  }
#line 388
  if (ret == 0) {
    {
#line 389
    DiscardData();
    }
  }
#line 391
  return (ret);
}
}
#line 398 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
int SaveThumbnail(char *ThumbFileName ) 
{ 
  FILE *ThumbnailFile ;
  int tmp ;
  uchar *ThumbnailPointer ;
  Section_t *ExifSection ;

  {
#line 402
  if (ImageInfo.ThumbnailOffset == 0U) {
    {
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Image contains no thumbnail\n");
    }
#line 404
    return (0);
  } else
#line 402
  if (ImageInfo.ThumbnailSize == 0U) {
    {
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Image contains no thumbnail\n");
    }
#line 404
    return (0);
  }
  {
#line 407
  tmp = strcmp((char const   *)ThumbFileName, "-");
  }
#line 407
  if (tmp == 0) {
#line 410
    ThumbnailFile = stdout;
  } else {
    {
#line 412
    ThumbnailFile = fopen((char const   */* __restrict  */)ThumbFileName, (char const   */* __restrict  */)"wb");
    }
  }
#line 415
  if (ThumbnailFile) {
    {
#line 418
    ExifSection = FindSection(225);
#line 419
    ThumbnailPointer = (ExifSection->Data + ImageInfo.ThumbnailOffset) + 8;
#line 421
    fwrite((void const   */* __restrict  */)ThumbnailPointer, (size_t )ImageInfo.ThumbnailSize,
           (size_t )1, (FILE */* __restrict  */)ThumbnailFile);
#line 422
    fclose(ThumbnailFile);
    }
#line 423
    return (1);
  } else {
    {
#line 425
    ErrFatal("Could not write thumbnail file");
    }
#line 426
    return (0);
  }
}
}
#line 433 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
int ReplaceThumbnail(char const   *ThumbFileName ) 
{ 
  FILE *ThumbnailFile ;
  int ThumbLen ;
  int NewExifSize ;
  Section_t *ExifSection ;
  uchar *ThumbnailPointer ;
  long tmp ;
  void *tmp___0 ;

  {
#line 440
  if (ImageInfo.ThumbnailOffset == 0U) {
#line 440
    goto _L;
  } else
#line 440
  if ((int )ImageInfo.ThumbnailAtEnd == 0) {
    _L: /* CIL Label */ 
#line 441
    if ((unsigned long )ThumbFileName == (unsigned long )((void *)0)) {
#line 444
      return (0);
    }
    {
#line 449
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Image contains no thumbnail to replace - add is not possible\n");
    }
#line 450
    return (0);
  }
#line 453
  if (ThumbFileName) {
    {
#line 454
    ThumbnailFile = fopen((char const   */* __restrict  */)ThumbFileName, (char const   */* __restrict  */)"rb");
    }
#line 456
    if ((unsigned long )ThumbnailFile == (unsigned long )((void *)0)) {
      {
#line 457
      ErrFatal("Could not read thumbnail file");
      }
#line 458
      return (0);
    }
    {
#line 462
    fseek(ThumbnailFile, 0L, 2);
#line 464
    tmp = ftell(ThumbnailFile);
#line 464
    ThumbLen = (int )tmp;
#line 465
    fseek(ThumbnailFile, 0L, 0);
    }
#line 467
    if ((unsigned int )ThumbLen + ImageInfo.ThumbnailOffset > 65516U) {
      {
#line 468
      ErrFatal("Thumbnail is too large to insert into exif header");
      }
    }
  } else {
#line 471
    if (ImageInfo.ThumbnailSize == 0U) {
#line 472
      return (0);
    }
#line 475
    ThumbLen = 0;
#line 476
    ThumbnailFile = (FILE *)((void *)0);
  }
  {
#line 479
  ExifSection = FindSection(225);
#line 481
  NewExifSize = (int )((ImageInfo.ThumbnailOffset + 8U) + (unsigned int )ThumbLen);
#line 482
  tmp___0 = realloc((void *)ExifSection->Data, (size_t )NewExifSize);
#line 482
  ExifSection->Data = (uchar *)tmp___0;
#line 484
  ThumbnailPointer = (ExifSection->Data + ImageInfo.ThumbnailOffset) + 8;
  }
#line 486
  if (ThumbnailFile) {
    {
#line 487
    fread((void */* __restrict  */)ThumbnailPointer, (size_t )ThumbLen, (size_t )1,
          (FILE */* __restrict  */)ThumbnailFile);
#line 488
    fclose(ThumbnailFile);
    }
  }
  {
#line 491
  ImageInfo.ThumbnailSize = (unsigned int )ThumbLen;
#line 493
  Put32u((void *)((ExifSection->Data + ImageInfo.ThumbnailSizeOffset) + 8), (unsigned int )ThumbLen);
#line 495
  *(ExifSection->Data + 0) = (uchar )(NewExifSize >> 8);
#line 496
  *(ExifSection->Data + 1) = (uchar )NewExifSize;
#line 497
  ExifSection->Size = (unsigned int )NewExifSize;
  }
#line 499
  return (1);
}
}
#line 506 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
void DiscardAllButExif(void) 
{ 
  Section_t ExifKeeper ;
  Section_t CommentKeeper ;
  Section_t IptcKeeper ;
  Section_t XmpKeeper ;
  int a ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 514
  memset((void *)(& ExifKeeper), 0, sizeof(ExifKeeper));
#line 515
  memset((void *)(& CommentKeeper), 0, sizeof(CommentKeeper));
#line 516
  memset((void *)(& IptcKeeper), 0, sizeof(IptcKeeper));
#line 517
  memset((void *)(& XmpKeeper), 0, sizeof(IptcKeeper));
#line 519
  a = 0;
  }
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if (! (a < SectionsRead)) {
#line 519
      goto while_break;
    }
#line 520
    if ((Sections + a)->Type == 225) {
#line 520
      if (ExifKeeper.Type == 0) {
#line 521
        ExifKeeper = *(Sections + a);
      } else {
#line 520
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 522
    if ((Sections + a)->Type == 4321) {
#line 522
      if (XmpKeeper.Type == 0) {
#line 523
        XmpKeeper = *(Sections + a);
      } else {
#line 522
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 524
    if ((Sections + a)->Type == 254) {
#line 524
      if (CommentKeeper.Type == 0) {
#line 525
        CommentKeeper = *(Sections + a);
      } else {
#line 524
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 526
    if ((Sections + a)->Type == 237) {
#line 526
      if (IptcKeeper.Type == 0) {
#line 527
        IptcKeeper = *(Sections + a);
      } else {
        {
#line 529
        free((void *)(Sections + a)->Data);
        }
      }
    } else {
      {
#line 529
      free((void *)(Sections + a)->Data);
      }
    }
#line 519
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  SectionsRead = 0;
#line 533
  if (ExifKeeper.Type) {
    {
#line 534
    CheckSectionsAllocated();
#line 535
    tmp = SectionsRead;
#line 535
    SectionsRead ++;
#line 535
    *(Sections + tmp) = ExifKeeper;
    }
  }
#line 537
  if (CommentKeeper.Type) {
    {
#line 538
    CheckSectionsAllocated();
#line 539
    tmp___0 = SectionsRead;
#line 539
    SectionsRead ++;
#line 539
    *(Sections + tmp___0) = CommentKeeper;
    }
  }
#line 541
  if (IptcKeeper.Type) {
    {
#line 542
    CheckSectionsAllocated();
#line 543
    tmp___1 = SectionsRead;
#line 543
    SectionsRead ++;
#line 543
    *(Sections + tmp___1) = IptcKeeper;
    }
  }
#line 546
  if (XmpKeeper.Type) {
    {
#line 547
    CheckSectionsAllocated();
#line 548
    tmp___2 = SectionsRead;
#line 548
    SectionsRead ++;
#line 548
    *(Sections + tmp___2) = XmpKeeper;
    }
  }
#line 550
  return;
}
}
#line 575 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
static uchar JfifHead[18]  = 
#line 575
  {      (uchar )255,      (uchar )224,      (uchar )0,      (uchar )16, 
        (uchar )'J',      (uchar )'F',      (uchar )'I',      (uchar )'F', 
        (uchar )0,      (uchar )1,      (uchar )1,      (uchar )1, 
        (uchar )1,      (uchar )44,      (uchar )1,      (uchar )44, 
        (uchar )0,      (uchar )0};
#line 555 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
void WriteJpegFile(char const   *FileName ) 
{ 
  FILE *outfile ;
  int a ;

  {
#line 560
  if (! HaveAll) {
    {
#line 561
    ErrFatal("Can\'t write back - didn\'t read all");
    }
  }
  {
#line 564
  outfile = fopen((char const   */* __restrict  */)FileName, (char const   */* __restrict  */)"wb");
  }
#line 565
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 566
    ErrFatal("Could not open file for write");
    }
  }
  {
#line 570
  fputc(255, outfile);
#line 571
  fputc(216, outfile);
  }
#line 573
  if ((Sections + 0)->Type != 225) {
#line 573
    if ((Sections + 0)->Type != 224) {
#line 581
      if (ImageInfo.ResolutionUnit == 2) {
#line 586
        ImageInfo.JfifHeader.ResolutionUnits = (char )(ImageInfo.ResolutionUnit - 1);
#line 588
        ImageInfo.JfifHeader.XDensity = (short )((int )ImageInfo.xResolution);
#line 589
        ImageInfo.JfifHeader.YDensity = (short )((int )ImageInfo.yResolution);
      } else
#line 581
      if (ImageInfo.ResolutionUnit == 3) {
#line 586
        ImageInfo.JfifHeader.ResolutionUnits = (char )(ImageInfo.ResolutionUnit - 1);
#line 588
        ImageInfo.JfifHeader.XDensity = (short )((int )ImageInfo.xResolution);
#line 589
        ImageInfo.JfifHeader.YDensity = (short )((int )ImageInfo.yResolution);
      }
      {
#line 592
      JfifHead[11] = (uchar )ImageInfo.JfifHeader.ResolutionUnits;
#line 593
      JfifHead[12] = (uchar )((int )ImageInfo.JfifHeader.XDensity >> 8);
#line 594
      JfifHead[13] = (uchar )ImageInfo.JfifHeader.XDensity;
#line 595
      JfifHead[14] = (uchar )((int )ImageInfo.JfifHeader.YDensity >> 8);
#line 596
      JfifHead[15] = (uchar )ImageInfo.JfifHeader.YDensity;
#line 599
      fwrite((void const   */* __restrict  */)(JfifHead), (size_t )18, (size_t )1,
             (FILE */* __restrict  */)outfile);
      }
#line 602
      if (ImageInfo.ResolutionUnit != 0) {
#line 604
        JfifHead[11] = (uchar )((int )((uchar )ImageInfo.ResolutionUnit) - 1);
      }
#line 606
      if ((double )ImageInfo.xResolution > 0.0) {
#line 606
        if ((double )ImageInfo.yResolution > 0.0) {
#line 607
          JfifHead[12] = (uchar )((int )ImageInfo.xResolution >> 8);
#line 608
          JfifHead[13] = (uchar )((int )ImageInfo.xResolution);
#line 610
          JfifHead[14] = (uchar )((int )ImageInfo.yResolution >> 8);
#line 611
          JfifHead[15] = (uchar )((int )ImageInfo.yResolution);
        }
      }
    }
  }
#line 617
  a = 0;
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! (a < SectionsRead - 1)) {
#line 617
      goto while_break;
    }
    {
#line 618
    fputc(255, outfile);
#line 619
    fputc((int )((unsigned char )(Sections + a)->Type), outfile);
#line 620
    fwrite((void const   */* __restrict  */)(Sections + a)->Data, (size_t )(Sections + a)->Size,
           (size_t )1, (FILE */* __restrict  */)outfile);
#line 617
    a ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 624
  fwrite((void const   */* __restrict  */)(Sections + a)->Data, (size_t )(Sections + a)->Size,
         (size_t )1, (FILE */* __restrict  */)outfile);
#line 626
  fclose(outfile);
  }
#line 627
  return;
}
}
#line 633 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
Section_t *FindSection(int SectionType ) 
{ 
  int a ;

  {
#line 637
  a = 0;
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! (a < SectionsRead)) {
#line 637
      goto while_break;
    }
#line 638
    if ((Sections + a)->Type == SectionType) {
#line 639
      return (Sections + a);
    }
#line 637
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 643
  return ((Section_t *)((void *)0));
}
}
#line 649 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
int RemoveSectionType(int SectionType ) 
{ 
  int a ;

  {
#line 652
  a = 0;
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    if (! (a < SectionsRead - 1)) {
#line 652
      goto while_break;
    }
#line 653
    if ((Sections + a)->Type == SectionType) {
      {
#line 655
      free((void *)(Sections + a)->Data);
#line 657
      memmove((void *)(Sections + a), (void const   *)((Sections + a) + 1), sizeof(Section_t ) * (unsigned long )(SectionsRead - a));
#line 658
      SectionsRead --;
      }
#line 659
      return (1);
    }
#line 652
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  return (0);
}
}
#line 668 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
int RemoveUnknownSections(void) 
{ 
  int a ;
  int Modified ;

  {
#line 671
  Modified = 0;
#line 672
  a = 0;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! (a < SectionsRead - 1)) {
#line 672
      goto while_break;
    }
    {
#line 697
    if ((Sections + a)->Type == 237) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 221) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 196) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 219) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 254) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 4321) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 225) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 224) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 218) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 217) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 216) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 207) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 206) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 205) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 203) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 202) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 201) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 199) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 198) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 197) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 195) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 194) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 193) {
#line 697
      goto case_237;
    }
#line 697
    if ((Sections + a)->Type == 192) {
#line 697
      goto case_237;
    }
#line 701
    goto switch_default;
    case_237: /* CIL Label */ 
    case_221: /* CIL Label */ 
    case_196: /* CIL Label */ 
    case_219: /* CIL Label */ 
    case_254: /* CIL Label */ 
    case_4321: /* CIL Label */ 
    case_225: /* CIL Label */ 
    case_224: /* CIL Label */ 
    case_218: /* CIL Label */ 
    case_217: /* CIL Label */ 
    case_216: /* CIL Label */ 
    case_207: /* CIL Label */ 
    case_206: /* CIL Label */ 
    case_205: /* CIL Label */ 
    case_203: /* CIL Label */ 
    case_202: /* CIL Label */ 
    case_201: /* CIL Label */ 
    case_199: /* CIL Label */ 
    case_198: /* CIL Label */ 
    case_197: /* CIL Label */ 
    case_195: /* CIL Label */ 
    case_194: /* CIL Label */ 
    case_193: /* CIL Label */ 
    case_192: /* CIL Label */ 
#line 699
    a ++;
#line 700
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 703
    free((void *)(Sections + a)->Data);
#line 705
    memmove((void *)(Sections + a), (void const   *)((Sections + a) + 1), sizeof(Section_t ) * (unsigned long )(SectionsRead - a));
#line 706
    SectionsRead --;
#line 707
    Modified = 1;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  return (Modified);
}
}
#line 717 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
Section_t *CreateSection(int SectionType , unsigned char *Data , int Size ) 
{ 
  Section_t *NewSection ;
  int a ;
  int NewIndex ;

  {
#line 723
  NewIndex = 0;
#line 724
  if (! (SectionType == 225)) {
    {
#line 727
    while (1) {
      while_continue: /* CIL Label */ ;
#line 727
      if (! (NewIndex < 3)) {
#line 727
        goto while_break;
      }
#line 728
      if ((Sections + NewIndex)->Type == 224) {
#line 728
        goto __Cont;
      }
#line 729
      if ((Sections + NewIndex)->Type == 225) {
#line 729
        goto __Cont;
      }
#line 730
      goto while_break;
      __Cont: /* CIL Label */ 
#line 727
      NewIndex ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 734
  if (SectionsRead < NewIndex) {
    {
#line 735
    ErrFatal("Too few sections!");
    }
  }
  {
#line 738
  CheckSectionsAllocated();
#line 739
  a = SectionsRead;
  }
  {
#line 739
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 739
    if (! (a > NewIndex)) {
#line 739
      goto while_break___0;
    }
#line 740
    *(Sections + a) = *(Sections + (a - 1));
#line 739
    a --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 742
  SectionsRead ++;
#line 744
  NewSection = Sections + NewIndex;
#line 746
  NewSection->Type = SectionType;
#line 747
  NewSection->Size = (unsigned int )Size;
#line 748
  NewSection->Data = Data;
#line 750
  return (NewSection);
}
}
#line 757 "/home/khheo/project/cve/benchmark/jhead-3.00/jpgfile.c"
void ResetJpgfile(void) 
{ 
  void *tmp ;

  {
#line 759
  if ((unsigned long )Sections == (unsigned long )((void *)0)) {
    {
#line 760
    tmp = malloc(sizeof(Section_t ) * 5UL);
#line 760
    Sections = (Section_t *)tmp;
#line 761
    SectionsAllocated = 5;
    }
  }
#line 764
  SectionsRead = 0;
#line 765
  HaveAll = 0;
#line 766
  return;
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 606
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template ) ;
#line 717
extern int system(char const   *__command ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 156 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
void FileTimeAsString(char *TimeStr ) ;
#line 159
int Exif2tm(struct tm *timeptr , char *ExifTime ) ;
#line 161
void ShowImageInfo(int ShowFileInfo___0 ) ;
#line 162
void ShowConciseImageInfo(void) ;
#line 163
char const   *ClearOrientation(void) ;
#line 170
void create_EXIF(void) ;
#line 200
void show_IPTC(unsigned char *Data , unsigned int itemlen ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 35 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int DoModify  =    0;
#line 38 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int FilesMatched  ;
#line 39 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int FileSequence  ;
#line 41 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char const   *CurrentFile  ;
#line 43 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char const   *progname  ;
#line 47 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int TrimExif  =    0;
#line 48 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int RenameToDate  =    0;
#line 52 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char *strftime_args  =    (char *)((void *)0);
#line 53 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int Exif2FileTime  =    0;
#line 54 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
int ShowTags  =    0;
#line 55 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int Quiet  =    0;
#line 56 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
int DumpExifMap  =    0;
#line 57 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int ShowConcise  =    0;
#line 58 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int CreateExifSection  =    0;
#line 59 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int TrimExifTrailingZeroes  =    0;
#line 60 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char *ApplyCommand  =    (char *)((void *)0);
#line 61 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char *FilterModel  =    (char *)((void *)0);
#line 62 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int ExifOnly  =    0;
#line 63 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int PortraitOnly  =    0;
#line 64 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static time_t ExifTimeAdjust  =    (time_t )0;
#line 65 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static time_t ExifTimeSet  =    (time_t )0;
#line 66 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char DateSet[11]  ;
#line 67 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static unsigned int DateSetChars  =    0U;
#line 68 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static unsigned int FileTimeToExif  =    0U;
#line 70 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int DeleteComments  =    0;
#line 71 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int DeleteExif  =    0;
#line 72 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int DeleteIptc  =    0;
#line 73 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int DeleteXmp  =    0;
#line 74 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int DeleteUnknown  =    0;
#line 75 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char *ThumbSaveName  =    (char *)((void *)0);
#line 78 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char *ThumbInsertName  =    (char *)((void *)0);
#line 81 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int RegenThumbnail  =    0;
#line 83 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char *ExifXferScrFile  =    (char *)((void *)0);
#line 86 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int EditComment  =    0;
#line 87 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int SupressNonFatalErrors  =    0;
#line 89 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char *CommentSavefileName  =    (char *)((void *)0);
#line 90 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char *CommentInsertfileName  =    (char *)((void *)0);
#line 91 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static char *CommentInsertLiteral  =    (char *)((void *)0);
#line 93 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int AutoRotate  =    0;
#line 94 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int ZeroRotateTagOnly  =    0;
#line 96 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int ShowFileInfo  =    1;
#line 113 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
void ErrFatal(char const   *msg ) 
{ 


  {
  {
#line 115
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nError : %s\n",
          msg);
  }
#line 116
  if (CurrentFile) {
    {
#line 116
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in file \'%s\'\n",
            CurrentFile);
    }
  }
  {
#line 117
  exit(1);
  }
}
}
#line 124 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
void ErrNonfatal(char const   *msg , int a1 , int a2 ) 
{ 


  {
#line 126
  if (SupressNonFatalErrors) {
#line 126
    return;
  }
  {
#line 128
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nNonfatal Error : ");
  }
#line 129
  if (CurrentFile) {
    {
#line 129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'%s\' ",
            CurrentFile);
    }
  }
  {
#line 130
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg, a1,
          a2);
#line 131
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 132
  return;
}
}
#line 138 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int FileEditComment(char *TempFileName , char *Comment , int CommentSize ) 
{ 
  FILE *file ;
  int a ;
  char QuotedPath[4106] ;
  char *Editor ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 144
  file = fopen((char const   */* __restrict  */)TempFileName, (char const   */* __restrict  */)"w");
  }
#line 145
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t create file \'%s\'\n",
            TempFileName);
#line 147
    ErrFatal("could not create temporary file");
    }
  }
  {
#line 149
  fwrite((void const   */* __restrict  */)Comment, (size_t )CommentSize, (size_t )1,
         (FILE */* __restrict  */)file);
#line 151
  fclose(file);
#line 153
  fflush(stdout);
#line 157
  Editor = getenv("EDITOR");
  }
#line 158
  if ((unsigned long )Editor == (unsigned long )((void *)0)) {
#line 162
    Editor = (char *)"vi";
  }
  {
#line 165
  tmp = strlen((char const   *)Editor);
  }
#line 165
  if (tmp > 4096UL) {
    {
#line 165
    ErrFatal("env too long");
    }
  }
  {
#line 167
  sprintf((char */* __restrict  */)(QuotedPath), (char const   */* __restrict  */)"%s \"%s\"",
          Editor, TempFileName);
#line 168
  a = system((char const   *)(QuotedPath));
  }
#line 171
  if (a != 0) {
    {
#line 172
    perror("Editor failed to launch");
#line 173
    exit(-1);
    }
  }
  {
#line 176
  file = fopen((char const   */* __restrict  */)TempFileName, (char const   */* __restrict  */)"r");
  }
#line 177
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 178
    ErrFatal("could not open temp file for read");
    }
  }
  {
#line 182
  tmp___0 = fread((void */* __restrict  */)Comment, (size_t )1, (size_t )16000, (FILE */* __restrict  */)file);
#line 182
  CommentSize = (int )tmp___0;
#line 184
  fclose(file);
#line 186
  unlink((char const   *)TempFileName);
  }
#line 188
  return (CommentSize);
}
}
#line 319 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int shellescape(char *to , char const   *from ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 322
  j = 0;
#line 322
  i = j;
#line 326
  tmp = j;
#line 326
  j ++;
#line 326
  *(to + tmp) = (char )'\"';
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! *(from + i)) {
#line 327
      goto while_break;
    }
    {
#line 339
    if ((int const   )*(from + i) == 92) {
#line 339
      goto case_92;
    }
#line 339
    if ((int const   )*(from + i) == 96) {
#line 339
      goto case_92;
    }
#line 339
    if ((int const   )*(from + i) == 36) {
#line 339
      goto case_92;
    }
#line 339
    if ((int const   )*(from + i) == 34) {
#line 339
      goto case_92;
    }
#line 342
    goto switch_default;
    case_92: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
#line 340
    tmp___0 = j;
#line 340
    j ++;
#line 340
    *(to + tmp___0) = (char )'\\';
    switch_default: /* CIL Label */ 
#line 343
    tmp___1 = j;
#line 343
    j ++;
#line 343
    tmp___2 = i;
#line 343
    i ++;
#line 343
    *(to + tmp___1) = (char )*(from + tmp___2);
    switch_break: /* CIL Label */ ;
    }
#line 346
    if (j >= 4096) {
      {
#line 346
      ErrFatal("max path exceeded");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  tmp___3 = j;
#line 348
  j ++;
#line 348
  *(to + tmp___3) = (char )'\"';
#line 349
  return (j);
}
}
#line 356 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static void DoCommand(char const   *FileName , int ShowIt ) 
{ 
  int a ;
  int e ;
  char ExecString[12288] ;
  char TempName[4106] ;
  int TempUsed ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  struct stat dummy ;
  struct stat buf ;
  int stat_result ;
  int tmp___6 ;
  struct utimbuf mtime ;
  int tmp___7 ;

  {
  {
#line 361
  TempUsed = 0;
#line 363
  e = 0;
#line 367
  tmp = strlen(FileName);
#line 367
  a = (int )(tmp - 1UL);
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (a > 0) {
#line 368
      if (! ((int const   )*(FileName + (a - 1)) != 47)) {
#line 368
        goto while_break;
      }
    } else {
#line 368
      goto while_break;
    }
#line 368
    a --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 369
  memcpy((void */* __restrict  */)(TempName), (void const   */* __restrict  */)FileName,
         (size_t )a);
#line 370
  strcpy((char */* __restrict  */)(TempName + a), (char const   */* __restrict  */)"XXXXXX");
#line 378
  mktemp(TempName);
  }
#line 381
  if (! TempName[0]) {
    {
#line 382
    ErrFatal("Cannot find available temporary file name");
    }
  }
#line 387
  a = 0;
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 388
    if ((int )*(ApplyCommand + a) == 38) {
#line 389
      if ((int )*(ApplyCommand + (a + 1)) == 105) {
        {
#line 391
        tmp___0 = shellescape(ExecString + e, FileName);
#line 391
        e += tmp___0;
#line 392
        a ++;
        }
#line 393
        goto __Cont;
      }
#line 395
      if ((int )*(ApplyCommand + (a + 1)) == 111) {
        {
#line 397
        tmp___1 = shellescape(ExecString + e, (char const   *)(TempName));
#line 397
        e += tmp___1;
#line 398
        a ++;
#line 399
        TempUsed = 1;
        }
#line 400
        goto __Cont;
      }
    }
#line 403
    tmp___2 = e;
#line 403
    e ++;
#line 403
    ExecString[tmp___2] = *(ApplyCommand + a);
#line 404
    if ((int )*(ApplyCommand + a) == 0) {
#line 404
      goto while_break___0;
    }
    __Cont: /* CIL Label */ 
#line 387
    a ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 407
  if (ShowIt) {
    {
#line 407
    printf((char const   */* __restrict  */)"Cmd:%s\n", ExecString);
    }
  }
  {
#line 409
  tmp___3 = __errno_location();
#line 409
  *tmp___3 = 0;
#line 410
  a = system((char const   *)(ExecString));
  }
#line 412
  if (a) {
#line 412
    goto _L;
  } else {
    {
#line 412
    tmp___5 = __errno_location();
    }
#line 412
    if (*tmp___5) {
      _L: /* CIL Label */ 
      {
#line 414
      tmp___4 = __errno_location();
      }
#line 414
      if (*tmp___4) {
        {
#line 414
        perror("system");
        }
      }
      {
#line 415
      ErrFatal("Problem executing specified command");
      }
    }
  }
#line 418
  if (TempUsed) {
    {
#line 421
    tmp___7 = stat((char const   */* __restrict  */)(TempName), (struct stat */* __restrict  */)(& dummy));
    }
#line 421
    if (tmp___7 == 0) {
      {
#line 423
      tmp___6 = stat((char const   */* __restrict  */)FileName, (struct stat */* __restrict  */)(& buf));
#line 423
      stat_result = tmp___6;
#line 425
      unlink(FileName);
#line 426
      rename((char const   *)(TempName), FileName);
      }
#line 427
      if (stat_result == 0) {
        {
#line 430
        chmod(FileName, buf.st_mode);
#line 432
        mtime.actime = buf.st_atim.tv_sec;
#line 433
        mtime.modtime = buf.st_mtim.tv_sec;
#line 435
        utime(FileName, (struct utimbuf  const  *)(& mtime));
        }
      }
    } else {
      {
#line 438
      ErrFatal("specified command did not produce expected output file");
      }
    }
  }
#line 441
  return;
}
}
#line 446 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int CheckFileSkip(void) 
{ 
  char *tmp ;
  Section_t *tmp___0 ;

  {
#line 451
  if (FilterModel) {
    {
#line 455
    tmp = strstr((char const   *)(ImageInfo.CameraModel), (char const   *)FilterModel);
    }
#line 455
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 457
      return (1);
    }
  }
#line 461
  if (ExifOnly) {
    {
#line 463
    tmp___0 = FindSection(225);
    }
#line 463
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 464
      return (1);
    }
  }
#line 468
  if (PortraitOnly == 1) {
#line 469
    if (ImageInfo.Width > ImageInfo.Height) {
#line 469
      return (1);
    }
  }
#line 472
  if (PortraitOnly == -1) {
#line 473
    if (ImageInfo.Width < ImageInfo.Height) {
#line 473
      return (1);
    }
  }
#line 476
  return (0);
}
}
#line 483 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static void RelativeName(char *OutFileName , char const   *NamePattern , char const   *OrigName ) 
{ 
  char *Subst ;

  {
  {
#line 489
  Subst = strstr(NamePattern, "&i");
  }
#line 490
  if (Subst) {
    {
#line 491
    strncpy((char */* __restrict  */)OutFileName, (char const   */* __restrict  */)NamePattern,
            (size_t )(Subst - (char *)NamePattern));
#line 492
    *(OutFileName + (Subst - (char *)NamePattern)) = (char)0;
#line 493
    strncat((char */* __restrict  */)OutFileName, (char const   */* __restrict  */)OrigName,
            (size_t )4096);
#line 494
    strncat((char */* __restrict  */)OutFileName, (char const   */* __restrict  */)(Subst + 2),
            (size_t )4096);
    }
  } else {
    {
#line 496
    strncpy((char */* __restrict  */)OutFileName, (char const   */* __restrict  */)NamePattern,
            (size_t )4096);
    }
  }
#line 498
  return;
}
}
#line 561 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static void DoFileRenaming(char const   *FileName ) 
{ 
  int PrefixPart ;
  int ExtensionPart ;
  int a ;
  struct tm tm ;
  char NewBaseName[8192] ;
  int AddLetter ;
  char NewName[4098] ;
  size_t tmp ;
  struct tm *tmp___0 ;
  int tmp___1 ;
  time_t UnixTime ;
  char *s ;
  char pattern[4116] ;
  int n ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int ppos ;
  char pat[8] ;
  char num[16] ;
  int l ;
  int nl ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  size_t tmp___8 ;
  char NewName___0[4106] ;
  char NameExtra[3] ;
  struct stat dummy ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 563
  PrefixPart = 0;
#line 568
  AddLetter = 0;
#line 571
  tmp = strlen(FileName);
#line 571
  ExtensionPart = (int )tmp;
#line 572
  a = 0;
  }
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    if (! *(FileName + a)) {
#line 572
      goto while_break;
    }
#line 573
    if ((int const   )*(FileName + a) == 47) {
#line 575
      PrefixPart = a + 1;
    }
#line 578
    if ((int const   )*(FileName + a) == 46) {
#line 578
      ExtensionPart = a;
    }
#line 572
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 581
  tmp___1 = Exif2tm(& tm, ImageInfo.DateTime);
  }
#line 581
  if (! tmp___1) {
    {
#line 582
    printf((char const   */* __restrict  */)"File \'%s\' contains no exif date stamp.  Using file date\n",
           FileName);
#line 584
    tmp___0 = localtime((time_t const   *)(& ImageInfo.FileDateTime));
#line 584
    tm = *tmp___0;
    }
  }
  {
#line 588
  strncpy((char */* __restrict  */)(NewBaseName), (char const   */* __restrict  */)FileName,
          (size_t )4096);
  }
#line 590
  if (strftime_args) {
    {
#line 596
    n = ExtensionPart - PrefixPart;
#line 599
    UnixTime = mktime(& tm);
    }
#line 600
    if ((int )UnixTime == -1) {
      {
#line 601
      printf((char const   */* __restrict  */)"Could not convert %s to unix time",
             ImageInfo.DateTime);
      }
#line 602
      return;
    }
    {
#line 606
    pattern[4095] = (char)0;
#line 607
    strncpy((char */* __restrict  */)(pattern), (char const   */* __restrict  */)strftime_args,
            (size_t )4095);
    }
    {
#line 608
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 608
      s = strstr((char const   *)(pattern), "%f");
      }
#line 608
      if (s) {
        {
#line 608
        tmp___3 = strlen((char const   *)(pattern));
        }
#line 608
        if (! (tmp___3 + (size_t )n < 4095UL)) {
#line 608
          goto while_break___0;
        }
      } else {
#line 608
        goto while_break___0;
      }
      {
#line 609
      tmp___2 = strlen((char const   *)(s + 2));
#line 609
      memmove((void *)(s + n), (void const   *)(s + 2), tmp___2 + 1UL);
#line 610
      memmove((void *)s, (void const   *)(FileName + PrefixPart), (size_t )n);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 616
    ppos = -1;
#line 617
    a = 0;
    {
#line 617
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 617
      if (! pattern[a]) {
#line 617
        goto while_break___1;
      }
#line 618
      if ((int )pattern[a] == 37) {
#line 619
        ppos = a;
      } else
#line 620
      if ((int )pattern[a] == 105) {
#line 621
        if (ppos >= 0) {
#line 621
          if (a < ppos + 4) {
            {
#line 625
            memcpy((void */* __restrict  */)(pat), (void const   */* __restrict  */)(pattern + ppos),
                   (size_t )4);
#line 626
            pat[a - ppos] = (char )'d';
#line 627
            pat[(a - ppos) + 1] = (char )'\000';
#line 628
            sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)(pat),
                    FileSequence);
#line 629
            tmp___4 = strlen((char const   *)(num));
#line 629
            nl = (int )tmp___4;
#line 630
            tmp___5 = strlen((char const   *)((pattern + a) + 1));
#line 630
            l = (int )tmp___5;
            }
#line 631
            if (((ppos + nl) + l) + 1 >= 4096) {
              {
#line 631
              ErrFatal("str overflow");
              }
            }
            {
#line 632
            memmove((void *)((pattern + ppos) + nl), (void const   *)((pattern + a) + 1),
                    (size_t )(l + 1));
#line 633
            memcpy((void */* __restrict  */)(pattern + ppos), (void const   */* __restrict  */)(num),
                   (size_t )nl);
            }
#line 634
            goto while_break___1;
          }
        }
      } else {
        {
#line 636
        tmp___6 = __ctype_b_loc();
        }
#line 636
        if (! ((int const   )*(*tmp___6 + (int )pattern[a]) & 2048)) {
#line 637
          ppos = -1;
        }
      }
#line 617
      a ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 641
    strftime((char */* __restrict  */)(NewName), (size_t )4096, (char const   */* __restrict  */)(pattern),
             (struct tm  const  */* __restrict  */)(& tm));
    }
  } else {
    {
#line 644
    sprintf((char */* __restrict  */)(NewName), (char const   */* __restrict  */)"%02d%02d-%02d%02d%02d",
            tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
    }
  }
  {
#line 648
  NewBaseName[PrefixPart] = (char)0;
#line 649
  CatPath(NewBaseName, (char const   *)(NewName));
#line 651
  tmp___7 = __ctype_b_loc();
#line 651
  tmp___8 = strlen((char const   *)(NewBaseName));
#line 651
  AddLetter = (int )((int const   )*(*tmp___7 + (int )NewBaseName[tmp___8 - 1UL]) & 2048);
#line 652
  a = 0;
  }
  {
#line 652
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 657
    if (a) {
#line 663
      if (AddLetter) {
#line 664
        NameExtra[0] = (char )(96 + a);
      } else {
#line 666
        NameExtra[0] = (char )(47 + a);
      }
#line 668
      NameExtra[1] = (char)0;
    } else {
#line 670
      NameExtra[0] = (char)0;
    }
    {
#line 673
    sprintf((char */* __restrict  */)(NewName___0), (char const   */* __restrict  */)"%s%s.jpg",
            NewBaseName, NameExtra);
#line 675
    tmp___9 = strcmp(FileName, (char const   *)(NewName___0));
    }
#line 675
    if (! tmp___9) {
#line 675
      goto while_break___2;
    }
    {
#line 677
    tmp___10 = EnsurePathExists((char const   *)(NewBaseName));
    }
#line 677
    if (! tmp___10) {
#line 678
      goto while_break___2;
    }
    {
#line 682
    tmp___12 = stat((char const   */* __restrict  */)(NewName___0), (struct stat */* __restrict  */)(& dummy));
    }
#line 682
    if (tmp___12) {
      {
#line 684
      tmp___11 = rename(FileName, (char const   *)(NewName___0));
      }
#line 684
      if (tmp___11 == 0) {
        {
#line 685
        printf((char const   */* __restrict  */)"%s --> %s\n", FileName, NewName___0);
        }
      } else {
        {
#line 693
        printf((char const   */* __restrict  */)"Error: Couldn\'t rename \'%s\' to \'%s\'\n",
               FileName, NewName___0);
        }
      }
#line 695
      goto while_break___2;
    }
#line 699
    if (a > 25) {
      {
#line 700
      printf((char const   */* __restrict  */)"Possible new names for for \'%s\' already exist\n",
             FileName);
      }
#line 701
      goto while_break___2;
    } else
#line 699
    if (! AddLetter) {
#line 699
      if (a > 9) {
        {
#line 700
        printf((char const   */* __restrict  */)"Possible new names for for \'%s\' already exist\n",
               FileName);
        }
#line 701
        goto while_break___2;
      }
    }
#line 652
    a ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 704
  return;
}
}
#line 709 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int DoAutoRotate(char const   *FileName ) 
{ 
  char const   *Argument ;
  char RotateCommand[8242] ;
  char ThumbTempName_in[4101] ;
  char ThumbTempName_out[4101] ;
  int tmp ;

  {
#line 711
  if (ImageInfo.Orientation != 1) {
    {
#line 713
    Argument = ClearOrientation();
    }
#line 715
    if (! ZeroRotateTagOnly) {
#line 717
      if ((unsigned long )Argument == (unsigned long )((void *)0)) {
        {
#line 718
        ErrNonfatal("Unknown orientation tag", 0, 0);
        }
#line 719
        return (1);
      }
      {
#line 721
      sprintf((char */* __restrict  */)(RotateCommand), (char const   */* __restrict  */)"jpegtran -trim -%s -outfile &o &i",
              Argument);
#line 722
      ApplyCommand = RotateCommand;
#line 723
      DoCommand(FileName, 0);
#line 724
      ApplyCommand = (char *)((void *)0);
      }
#line 727
      if (ImageInfo.ThumbnailOffset) {
#line 727
        if (ImageInfo.ThumbnailSize) {
#line 727
          if (ImageInfo.ThumbnailAtEnd) {
            {
#line 735
            strcpy((char */* __restrict  */)(ThumbTempName_in), (char const   */* __restrict  */)FileName);
#line 736
            strcat((char */* __restrict  */)(ThumbTempName_in), (char const   */* __restrict  */)".thi");
#line 737
            strcpy((char */* __restrict  */)(ThumbTempName_out), (char const   */* __restrict  */)FileName);
#line 738
            strcat((char */* __restrict  */)(ThumbTempName_out), (char const   */* __restrict  */)".tho");
#line 739
            SaveThumbnail(ThumbTempName_in);
#line 740
            sprintf((char */* __restrict  */)(RotateCommand), (char const   */* __restrict  */)"jpegtran -trim -%s -outfile \"%s\" \"%s\"",
                    Argument, ThumbTempName_out, ThumbTempName_in);
#line 743
            tmp = system((char const   *)(RotateCommand));
            }
#line 743
            if (tmp == 0) {
              {
#line 745
              ReplaceThumbnail((char const   *)(ThumbTempName_out));
              }
            }
            {
#line 748
            unlink((char const   *)(ThumbTempName_in));
#line 749
            unlink((char const   *)(ThumbTempName_out));
            }
          }
        }
      }
    }
#line 752
    return (1);
  }
#line 754
  return (0);
}
}
#line 760 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static int RegenerateThumbnail(char const   *FileName ) 
{ 
  char ThumbnailGenCommand[8242] ;
  int tmp ;
  int tmp___0 ;

  {
#line 763
  if (ImageInfo.ThumbnailOffset == 0U) {
#line 765
    return (0);
  } else
#line 763
  if ((int )ImageInfo.ThumbnailAtEnd == 0) {
#line 765
    return (0);
  }
  {
#line 768
  sprintf((char */* __restrict  */)(ThumbnailGenCommand), (char const   */* __restrict  */)"mogrify -thumbnail %dx%d \"%s\"",
          RegenThumbnail, RegenThumbnail, FileName);
#line 771
  tmp___0 = system((char const   *)(ThumbnailGenCommand));
  }
#line 771
  if (tmp___0 == 0) {
    {
#line 773
    tmp = ReplaceThumbnail(FileName);
    }
#line 773
    return (tmp);
  } else {
    {
#line 775
    ErrFatal("Unable to run \'mogrify\' command");
    }
#line 776
    return (0);
  }
}
}
#line 783 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
void FileTimeAsString(char *TimeStr ) 
{ 
  struct tm ts ;
  struct tm *tmp ;

  {
  {
#line 786
  tmp = localtime((time_t const   *)(& ImageInfo.FileDateTime));
#line 786
  ts = *tmp;
#line 787
  strftime((char */* __restrict  */)TimeStr, (size_t )20, (char const   */* __restrict  */)"%Y:%m:%d %H:%M:%S",
           (struct tm  const  */* __restrict  */)(& ts));
  }
#line 788
  return;
}
}
#line 793 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static void ProcessFile(char const   *FileName ) 
{ 
  int Modified ;
  ReadMode_t ReadMode ;
  size_t tmp ;
  struct stat st ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct stat dummy ;
  int tmp___5 ;
  int tmp___6 ;
  char RelativeExifName[4097] ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  Section_t *ExifSection ;
  int NumRedundant ;
  int WasRedundant ;
  unsigned char *StartRedundant ;
  int NewExifSize ;
  Section_t *IptcSection ;
  char OutFileName[4097] ;
  int tmp___10 ;
  int tmp___11 ;
  char ThumbFileName[4097] ;
  int tmp___12 ;
  int tmp___13 ;
  Section_t *CommentSec ;
  char Comment[16001] ;
  int CommentSize ;
  unsigned char *DummyData ;
  void *tmp___14 ;
  char CommentFileName[4097] ;
  FILE *CommentFile ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  char EditFileName[4101] ;
  int size ;
  void *tmp___17 ;
  int tmp___18 ;
  Section_t *CommentSec___0 ;
  char OutFileName___0[4097] ;
  FILE *CommentFile___0 ;
  struct tm tm ;
  time_t UnixTime ;
  char TempBuf[50] ;
  int a ;
  Section_t *ExifSection___0 ;
  int tmp___19 ;
  struct tm *tmp___20 ;
  uchar *Pointer ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char BackupName[4101] ;
  struct stat buf ;
  struct utimbuf mtime ;
  int tmp___26 ;
  struct tm tm___0 ;
  time_t UnixTime___0 ;
  struct utimbuf mtime___0 ;
  int tmp___27 ;
  int tmp___28 ;

  {
  {
#line 795
  Modified = 0;
#line 798
  tmp = strlen(FileName);
  }
#line 798
  if (tmp >= 4095UL) {
    {
#line 800
    ErrFatal("filename too long");
    }
  }
  {
#line 803
  ReadMode = (ReadMode_t )1;
#line 804
  CurrentFile = FileName;
#line 805
  FilesMatched = 1;
#line 807
  ResetJpgfile();
#line 810
  memset((void *)(& ImageInfo), 0, sizeof(ImageInfo));
#line 811
  ImageInfo.FlashUsed = -1;
#line 812
  ImageInfo.MeteringMode = -1;
#line 813
  ImageInfo.Whitebalance = -1;
#line 818
  tmp___0 = stat((char const   */* __restrict  */)FileName, (struct stat */* __restrict  */)(& st));
  }
#line 818
  if (tmp___0 >= 0) {
#line 819
    ImageInfo.FileDateTime = st.st_mtim.tv_sec;
#line 820
    ImageInfo.FileSize = (unsigned int )st.st_size;
  } else {
    {
#line 822
    ErrFatal("No such file");
    }
  }
#line 826
  if (DoModify & 1) {
#line 826
    goto _L;
  } else
#line 826
  if (RenameToDate) {
#line 826
    goto _L;
  } else
#line 826
  if (Exif2FileTime) {
    _L: /* CIL Label */ 
    {
#line 827
    tmp___1 = access(FileName, 2);
    }
#line 827
    if (tmp___1) {
      {
#line 828
      printf((char const   */* __restrict  */)"Skipping readonly file \'%s\'\n", FileName);
      }
#line 829
      return;
    }
  }
  {
#line 833
  strncpy((char */* __restrict  */)(ImageInfo.FileName), (char const   */* __restrict  */)FileName,
          (size_t )4096);
  }
#line 836
  if (ApplyCommand) {
#line 836
    goto _L___0;
  } else
#line 836
  if (AutoRotate) {
    _L___0: /* CIL Label */ 
    {
#line 840
    tmp___2 = ReadJpegFile(FileName, (ReadMode_t )1);
    }
#line 840
    if (! tmp___2) {
#line 840
      return;
    }
    {
#line 853
    tmp___3 = CheckFileSkip();
    }
#line 853
    if (tmp___3) {
      {
#line 854
      DiscardData();
      }
#line 855
      return;
    }
    {
#line 858
    DiscardAllButExif();
    }
#line 860
    if (AutoRotate) {
      {
#line 861
      tmp___4 = DoAutoRotate(FileName);
      }
#line 861
      if (tmp___4) {
#line 862
        Modified = 1;
      }
    } else {
#line 866
      if (Quiet) {
#line 866
        tmp___5 = 0;
      } else {
#line 866
        tmp___5 = 1;
      }
      {
#line 866
      DoCommand(FileName, tmp___5);
#line 868
      tmp___6 = stat((char const   */* __restrict  */)FileName, (struct stat */* __restrict  */)(& dummy));
      }
#line 868
      if (tmp___6) {
#line 871
        return;
      }
#line 873
      Modified = 1;
    }
#line 875
    ReadMode = (ReadMode_t )2;
  }
#line 878
  if (ExifXferScrFile) {
    {
#line 882
    RelativeName(RelativeExifName, (char const   *)ExifXferScrFile, FileName);
#line 884
    tmp___7 = ReadJpegFile((char const   *)(RelativeExifName), (ReadMode_t )1);
    }
#line 884
    if (! tmp___7) {
#line 884
      return;
    }
    {
#line 886
    DiscardAllButExif();
#line 888
    Modified = 1;
#line 889
    ReadMode = (ReadMode_t )2;
    }
  }
#line 892
  if (DoModify) {
#line 893
    ReadMode = (ReadMode_t )((unsigned int )ReadMode | 2U);
  }
  {
#line 896
  tmp___8 = ReadJpegFile(FileName, ReadMode);
  }
#line 896
  if (! tmp___8) {
#line 896
    return;
  }
  {
#line 898
  tmp___9 = CheckFileSkip();
  }
#line 898
  if (tmp___9) {
    {
#line 899
    DiscardData();
    }
#line 900
    return;
  }
#line 903
  if (TrimExifTrailingZeroes) {
#line 904
    if (ImageInfo.ThumbnailAtEnd) {
      {
#line 909
      ExifSection = FindSection(225);
#line 911
      StartRedundant = ((ExifSection->Data + 8) + ImageInfo.ThumbnailOffset) + ImageInfo.ThumbnailSize;
#line 912
      NumRedundant = (int )(ExifSection->Size - ((ImageInfo.ThumbnailOffset + ImageInfo.ThumbnailSize) + 8U));
#line 912
      WasRedundant = NumRedundant;
      }
      {
#line 916
      while (1) {
        while_continue: /* CIL Label */ ;
#line 916
        if (NumRedundant > 0) {
#line 916
          if (! ((int )*(StartRedundant + (NumRedundant - 1)) == 0)) {
#line 916
            goto while_break;
          }
        } else {
#line 916
          goto while_break;
        }
#line 916
        NumRedundant --;
      }
      while_break: /* CIL Label */ ;
      }
#line 918
      if (NumRedundant != WasRedundant) {
        {
#line 920
        printf((char const   */* __restrict  */)"Trimming %d bytes from exif in %s\n",
               WasRedundant - NumRedundant, FileName);
#line 921
        NewExifSize = (int )(((ImageInfo.ThumbnailOffset + ImageInfo.ThumbnailSize) + 8U) + (unsigned int )NumRedundant);
#line 922
        *(ExifSection->Data + 0) = (uchar )(NewExifSize >> 8);
#line 923
        *(ExifSection->Data + 1) = (uchar )NewExifSize;
#line 924
        ExifSection->Size = (unsigned int )NewExifSize;
#line 925
        Modified = 1;
        }
      }
    }
  }
#line 932
  FileSequence ++;
#line 934
  if (ShowConcise) {
    {
#line 935
    ShowConciseImageInfo();
    }
  } else
#line 937
  if (! DoModify) {
#line 937
    goto _L___1;
  } else
#line 937
  if (ShowTags) {
    _L___1: /* CIL Label */ 
    {
#line 938
    ShowImageInfo(ShowFileInfo);
#line 943
    IptcSection = FindSection(237);
    }
#line 945
    if (IptcSection) {
      {
#line 946
      show_IPTC(IptcSection->Data, IptcSection->Size);
      }
    }
    {
#line 949
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 953
  if (ThumbSaveName) {
    {
#line 956
    RelativeName(OutFileName, (char const   *)ThumbSaveName, FileName);
#line 958
    tmp___10 = SaveThumbnail(OutFileName);
    }
#line 958
    if (tmp___10) {
      {
#line 959
      printf((char const   */* __restrict  */)"Created: \'%s\'\n", OutFileName);
      }
    }
  }
#line 963
  if (CreateExifSection) {
    {
#line 965
    create_EXIF();
#line 966
    Modified = 1;
    }
  }
#line 969
  if (RegenThumbnail) {
    {
#line 970
    tmp___11 = RegenerateThumbnail(FileName);
    }
#line 970
    if (tmp___11) {
#line 971
      Modified = 1;
    }
  }
#line 975
  if (ThumbInsertName) {
    {
#line 978
    RelativeName(ThumbFileName, (char const   *)ThumbInsertName, FileName);
#line 980
    tmp___12 = ReplaceThumbnail((char const   *)(ThumbFileName));
    }
#line 980
    if (tmp___12) {
#line 981
      Modified = 1;
    }
  } else
#line 983
  if (TrimExif) {
    {
#line 985
    tmp___13 = ReplaceThumbnail((char const   *)((void *)0));
    }
#line 985
    if (tmp___13) {
#line 986
      Modified = 1;
    }
  }
#line 990
  if (EditComment) {
#line 990
    goto _L___2;
  } else
#line 990
  if (CommentInsertfileName) {
#line 990
    goto _L___2;
  } else
#line 990
  if (CommentInsertLiteral) {
    _L___2: /* CIL Label */ 
    {
#line 1000
    CommentSec = FindSection(254);
    }
#line 1002
    if ((unsigned long )CommentSec == (unsigned long )((void *)0)) {
      {
#line 1005
      tmp___14 = malloc((size_t )3);
#line 1005
      DummyData = (uchar *)tmp___14;
#line 1006
      *(DummyData + 0) = (unsigned char)0;
#line 1007
      *(DummyData + 1) = (unsigned char)2;
#line 1008
      *(DummyData + 2) = (unsigned char)0;
#line 1009
      CommentSec = CreateSection(254, DummyData, 2);
      }
    }
#line 1012
    CommentSize = (int )(CommentSec->Size - 2U);
#line 1013
    if (CommentSize > 16000) {
      {
#line 1014
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Truncating comment at %d chars\n",
              16000);
#line 1015
      CommentSize = 16000;
      }
    }
#line 1018
    if (CommentInsertfileName) {
      {
#line 1024
      RelativeName(CommentFileName, (char const   *)CommentInsertfileName, FileName);
#line 1026
      CommentFile = fopen((char const   */* __restrict  */)(CommentFileName), (char const   */* __restrict  */)"r");
      }
#line 1027
      if ((unsigned long )CommentFile == (unsigned long )((void *)0)) {
        {
#line 1028
        printf((char const   */* __restrict  */)"Could not open \'%s\'\n", CommentFileName);
        }
      } else {
        {
#line 1032
        tmp___15 = fread((void */* __restrict  */)(Comment), (size_t )1, (size_t )16000,
                         (FILE */* __restrict  */)CommentFile);
#line 1032
        CommentSize = (int )tmp___15;
#line 1033
        fclose(CommentFile);
        }
#line 1034
        if (CommentSize < 0) {
#line 1034
          CommentSize = 0;
        }
      }
    } else
#line 1036
    if (CommentInsertLiteral) {
      {
#line 1037
      strncpy((char */* __restrict  */)(Comment), (char const   */* __restrict  */)CommentInsertLiteral,
              (size_t )16000);
#line 1038
      tmp___16 = strlen((char const   *)(Comment));
#line 1038
      CommentSize = (int )tmp___16;
      }
    } else {
      {
#line 1050
      memcpy((void */* __restrict  */)(Comment), (void const   */* __restrict  */)((char *)CommentSec->Data + 2),
             (size_t )CommentSize);
#line 1054
      strcpy((char */* __restrict  */)(EditFileName), (char const   */* __restrict  */)FileName);
#line 1055
      strcat((char */* __restrict  */)(EditFileName), (char const   */* __restrict  */)".txt");
#line 1057
      CommentSize = FileEditComment(EditFileName, Comment, CommentSize);
      }
    }
    {
#line 1061
    tmp___18 = strcmp((char const   *)(Comment), (char const   *)((char *)CommentSec->Data + 2));
    }
#line 1061
    if (tmp___18) {
      {
#line 1064
      size = CommentSize + 2;
#line 1065
      free((void *)CommentSec->Data);
#line 1066
      CommentSec->Size = (unsigned int )size;
#line 1067
      tmp___17 = malloc((size_t )size);
#line 1067
      CommentSec->Data = (uchar *)tmp___17;
#line 1068
      *(CommentSec->Data + 0) = (uchar )(size >> 8);
#line 1069
      *(CommentSec->Data + 1) = (uchar )size;
#line 1070
      memcpy((void */* __restrict  */)(CommentSec->Data + 2), (void const   */* __restrict  */)(Comment),
             (size_t )(size - 2));
#line 1071
      Modified = 1;
      }
    }
#line 1073
    if (! Modified) {
      {
#line 1074
      printf((char const   */* __restrict  */)"Comment not modified\n");
      }
    }
  }
#line 1079
  if (CommentSavefileName) {
    {
#line 1081
    CommentSec___0 = FindSection(254);
    }
#line 1083
    if ((unsigned long )CommentSec___0 != (unsigned long )((void *)0)) {
      {
#line 1088
      RelativeName(OutFileName___0, (char const   *)CommentSavefileName, FileName);
#line 1090
      CommentFile___0 = fopen((char const   */* __restrict  */)(OutFileName___0),
                              (char const   */* __restrict  */)"w");
      }
#line 1091
      if (CommentFile___0) {
        {
#line 1092
        fwrite((void const   */* __restrict  */)((char *)CommentSec___0->Data + 2),
               (size_t )(CommentSec___0->Size - 2U), (size_t )1, (FILE */* __restrict  */)CommentFile___0);
#line 1093
        fclose(CommentFile___0);
        }
      } else {
        {
#line 1095
        ErrFatal("Could not write comment file");
        }
      }
    } else {
      {
#line 1098
      printf((char const   */* __restrict  */)"File \'%s\' contains no comment section\n",
             FileName);
      }
    }
  }
#line 1102
  if (ExifTimeAdjust) {
#line 1102
    goto _L___3;
  } else
#line 1102
  if (ExifTimeSet) {
#line 1102
    goto _L___3;
  } else
#line 1102
  if (DateSetChars) {
#line 1102
    goto _L___3;
  } else
#line 1102
  if (FileTimeToExif) {
    _L___3: /* CIL Label */ 
#line 1103
    if (ImageInfo.numDateTimeTags) {
#line 1109
      if (ExifTimeSet) {
#line 1111
        UnixTime = ExifTimeSet;
      } else {
#line 1113
        if (FileTimeToExif) {
          {
#line 1114
          FileTimeAsString(ImageInfo.DateTime);
          }
        }
#line 1116
        if (DateSetChars) {
          {
#line 1117
          memcpy((void */* __restrict  */)(ImageInfo.DateTime), (void const   */* __restrict  */)(DateSet),
                 (size_t )DateSetChars);
#line 1118
          a = 1970;
#line 1119
          sscanf((char const   */* __restrict  */)(DateSet), (char const   */* __restrict  */)"%d",
                 & a);
          }
#line 1120
          if (a < 1970) {
            {
#line 1121
            strcpy((char */* __restrict  */)(TempBuf), (char const   */* __restrict  */)(ImageInfo.DateTime));
            }
#line 1122
            goto skip_unixtime;
          }
        }
        {
#line 1126
        tmp___19 = Exif2tm(& tm, ImageInfo.DateTime);
        }
#line 1126
        if (! tmp___19) {
#line 1126
          goto badtime;
        }
        {
#line 1129
        UnixTime = mktime(& tm);
        }
#line 1130
        if ((int )UnixTime == -1) {
#line 1130
          goto badtime;
        }
#line 1131
        UnixTime += ExifTimeAdjust;
      }
      {
#line 1133
      tmp___20 = localtime((time_t const   *)(& UnixTime));
#line 1133
      tm = *tmp___20;
#line 1137
      sprintf((char */* __restrict  */)(TempBuf), (char const   */* __restrict  */)"%04d:%02d:%02d %02d:%02d:%02d",
              tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min,
              tm.tm_sec);
      }
      skip_unixtime: 
      {
#line 1142
      ExifSection___0 = FindSection(225);
#line 1144
      a = 0;
      }
      {
#line 1144
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1144
        if (! (a < ImageInfo.numDateTimeTags)) {
#line 1144
          goto while_break___0;
        }
        {
#line 1146
        Pointer = (ExifSection___0->Data + ImageInfo.DateTimeOffsets[a]) + 8;
#line 1147
        memcpy((void */* __restrict  */)Pointer, (void const   */* __restrict  */)(TempBuf),
               (size_t )19);
#line 1144
        a ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1149
      memcpy((void */* __restrict  */)(ImageInfo.DateTime), (void const   */* __restrict  */)(TempBuf),
             (size_t )19);
#line 1151
      Modified = 1;
      }
    } else {
      {
#line 1153
      printf((char const   */* __restrict  */)"File \'%s\' contains no Exif timestamp to change\n",
             FileName);
      }
    }
  }
#line 1157
  if (DeleteComments) {
    {
#line 1158
    tmp___21 = RemoveSectionType(254);
    }
#line 1158
    if (tmp___21) {
#line 1158
      Modified = 1;
    }
  }
#line 1160
  if (DeleteExif) {
    {
#line 1161
    tmp___22 = RemoveSectionType(225);
    }
#line 1161
    if (tmp___22) {
#line 1161
      Modified = 1;
    }
  }
#line 1163
  if (DeleteIptc) {
    {
#line 1164
    tmp___23 = RemoveSectionType(237);
    }
#line 1164
    if (tmp___23) {
#line 1164
      Modified = 1;
    }
  }
#line 1166
  if (DeleteXmp) {
    {
#line 1167
    tmp___24 = RemoveSectionType(4321);
    }
#line 1167
    if (tmp___24) {
#line 1167
      Modified = 1;
    }
  }
#line 1169
  if (DeleteUnknown) {
    {
#line 1170
    tmp___25 = RemoveUnknownSections();
    }
#line 1170
    if (tmp___25) {
#line 1170
      Modified = 1;
    }
  }
#line 1174
  if (Modified) {
#line 1178
    if (! Quiet) {
      {
#line 1178
      printf((char const   */* __restrict  */)"Modified: %s\n", FileName);
      }
    }
    {
#line 1180
    strcpy((char */* __restrict  */)(BackupName), (char const   */* __restrict  */)FileName);
#line 1181
    strcat((char */* __restrict  */)(BackupName), (char const   */* __restrict  */)".t");
#line 1184
    unlink((char const   *)(BackupName));
#line 1187
    rename(FileName, (char const   *)(BackupName));
#line 1190
    WriteJpegFile(FileName);
#line 1193
    tmp___26 = stat((char const   */* __restrict  */)(BackupName), (struct stat */* __restrict  */)(& buf));
    }
#line 1193
    if (tmp___26 == 0) {
      {
#line 1196
      chmod(FileName, buf.st_mode);
#line 1198
      mtime.actime = buf.st_mtim.tv_sec;
#line 1199
      mtime.modtime = buf.st_mtim.tv_sec;
#line 1201
      utime(FileName, (struct utimbuf  const  *)(& mtime));
      }
    }
    {
#line 1205
    unlink((char const   *)(BackupName));
    }
  }
#line 1209
  if (Exif2FileTime) {
#line 1211
    if (ImageInfo.numDateTimeTags) {
      {
#line 1216
      tmp___27 = Exif2tm(& tm___0, ImageInfo.DateTime);
      }
#line 1216
      if (! tmp___27) {
#line 1216
        goto badtime;
      }
      {
#line 1217
      UnixTime___0 = mktime(& tm___0);
      }
#line 1218
      if ((int )UnixTime___0 == -1) {
#line 1219
        goto badtime;
      }
      {
#line 1221
      mtime___0.actime = UnixTime___0;
#line 1222
      mtime___0.modtime = UnixTime___0;
#line 1224
      tmp___28 = utime(FileName, (struct utimbuf  const  *)(& mtime___0));
      }
#line 1224
      if (tmp___28 != 0) {
        {
#line 1225
        printf((char const   */* __restrict  */)"Error: Could not change time of file \'%s\'\n",
               FileName);
        }
      } else
#line 1227
      if (! Quiet) {
        {
#line 1227
        printf((char const   */* __restrict  */)"%s\n", FileName);
        }
      }
    } else {
      {
#line 1230
      printf((char const   */* __restrict  */)"File \'%s\' contains no Exif timestamp\n",
             FileName);
      }
    }
  }
#line 1237
  if (RenameToDate) {
    {
#line 1238
    DoFileRenaming(FileName);
    }
  }
  {
#line 1240
  DiscardData();
  }
#line 1241
  return;
  badtime: 
  {
#line 1243
  printf((char const   */* __restrict  */)"Error: Time \'%s\': cannot convert to Unix time\n",
         ImageInfo.DateTime);
#line 1244
  DiscardData();
  }
#line 1245
  return;
}
}
#line 1250 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static void Usage(void) 
{ 


  {
  {
#line 1252
  printf((char const   */* __restrict  */)"Jhead is a program for manipulating settings and thumbnails in Exif jpeg headers\nused by most Digital Cameras.  v3.00 Matthias Wandel, Jan 30 2013.\nhttp://www.sentex.net/~mwandel/jhead\n\n");
#line 1257
  printf((char const   */* __restrict  */)"Usage: %s [options] files\n", progname);
#line 1258
  printf((char const   */* __restrict  */)"Where:\n files       path/filenames with or without wildcards\n[options] are:\n\nGENERAL METADATA:\n  -te <name> Transfer exif header from another image file <name>\n             Uses same name mangling as \'-st\' option\n  -dc        Delete comment field (as left by progs like Photoshop & Compupic)\n  -de        Strip Exif section (smaller JPEG file, but lose digicam info)\n  -di        Delete IPTC section (from Photoshop, or Picasa)\n  -dx        Deletex XMP section\n  -du        Delete non image sections except for Exif and comment sections\n  -purejpg   Strip all unnecessary data from jpeg (combines -dc -de and -du)\n  -mkexif    Create new minimal exif section (overwrites pre-existing exif)\n  -ce        Edit comment field.  Uses environment variable \'editor\' to\n             determine which editor to use.  If editor not set, uses VI\n             under Unix and notepad with windows\n  -cs <name> Save comment section to a file\n  -ci <name> Insert comment section from a file.  -cs and -ci use same naming\n             scheme as used by the -st option\n  -cl string Insert literal comment string\n  -zt        Trim exif header trailing zeroes (Nikon 1 wastes 30k that way)\n\nDATE / TIME MANIPULATION:\n  -ft        Set file modification time to Exif time\n  -dsft      Set Exif time to file modification time\n  -n[format-string]\n             Rename files according to date.  Uses exif date if present, file\n             date otherwise.  If the optional format-string is not supplied,\n             the format is mmdd-hhmmss.  If a format-string is given, it is\n             is passed to the \'strftime\' function for formatting\n             %%d Day of month    %%H Hour (24-hour)\n             %%m Month number    %%M Minute    %%S Second\n             %%y Year (2 digit 00 - 99)        %%Y Year (4 digit 1980-2036)\n             For more arguments, look up the \'strftime\' function.\n             In addition to strftime format codes:\n             \'%%f\' as part of the string will include the original file name\n             \'%%i\' will include a sequence number, starting from 1. You can\n             You can specify \'%%03i\' for example to get leading zeros.\n             This feature is useful for ordering files from multiple digicams to\n             sequence of taking.  Only renames files whose names are mostly\n             numerical (as assigned by digicam)\n             The \'.jpg\' is automatically added to the end of the name.  If the\n             destination name already exists, a letter or digit is added to \n             the end of the name to make it unique.\n             The new name may include a path as part of the name.  If this path\n             does not exist, it will be created\n  -a         (Windows only) Rename files with same name but different extension\n             Use together with -n to rename .AVI files from exif in .THM files\n             for example\n  -ta<+|->h[:mm[:ss]]\n             Adjust time by h:mm forwards or backwards.  Useful when having\n             taken pictures with the wrong time set on the camera, such as when\n             traveling across time zones or DST changes. Dates can be adjusted\n             by offsetting by 24 hours or more.  For large date adjustments,\n             use the -da option\n  -da<date>-<date>\n             Adjust date by large amounts.  This is used to fix photos from\n             cameras where the date got set back to the default camera date\n             by accident or battery removal.\n             To deal with different months and years having different numbers of\n             days, a simple date-month-year offset would result in unexpected\n             results.  Instead, the difference is specified as desired date\n             minus original date.  Date is specified as yyyy:mm:dd or as date\n             and time in the format yyyy:mm:dd/hh:mm:ss\n  -ts<time>  Set the Exif internal time to <time>.  <time> is in the format\n             yyyy:mm:dd-hh:mm:ss\n  -ds<date>  Set the Exif internal date.  <date> is in the format YYYY:MM:DD\n             or YYYY:MM or YYYY\n\nTHUMBNAIL MANIPULATION:\n  -dt        Remove exif integral thumbnails.   Typically trims 10k\n  -st <name> Save Exif thumbnail, if there is one, in file <name>\n             If output file name contains the substring \"&i\" then the\n             image file name is substitute for the &i.  Note that quotes around\n             the argument are required for the \'&\' to be passed to the program.\n             An output name of \'-\' causes thumbnail to be written to stdout\n  -rt <name> Replace Exif thumbnail.  Can only be done with headers that\n             already contain a thumbnail.\n  -rgt[size] Regnerate exif thumbnail.  Only works if image already\n             contains a thumbail.  size specifies maximum height or width of\n             thumbnail.  Relies on \'mogrify\' programs to be on path\n\nROTATION TAG MANIPULATION:\n  -autorot   Invoke jpegtran to rotate images according to Exif orientation tag\n             Note: Windows users must get jpegtran for this to work\n  -norot     Zero out the rotation tag.  This to avoid some browsers from\n             rotating the image again after you rotated it but neglected to\n             clear the rotation tag\n\nOUTPUT VERBOSITY CONTROL:\n  -h         help (this text)\n  -v         even more verbose output\n  -q         Quiet (no messages on success, like Unix)\n  -V         Show jhead version\n  -exifmap   Dump header bytes, annotate.  Pipe thru sort for better viewing\n  -se        Supress error messages relating to corrupt exif header structure\n  -c         concise output\n  -nofinfo   Don\'t show file info (name/size/date)\n\nFILE MATCHING AND SELECTION:\n  -model model\n             Only process files from digicam containing model substring in\n             camera model description\n  -exonly    Skip all files that don\'t have an exif header (skip all jpegs that\n             were not created by digicam)\n  -cmd command\n             Apply \'command\' to every file, then re-insert exif and command\n             sections into the image. &i will be substituted for the input file\n             name, and &o (if &o is used). Use quotes around the command string\n             This is most useful in conjunction with the free ImageMagick tool. \n             For example, with my Canon S100, which suboptimally compresses\n             jpegs I can specify\n                jhead -cmd \"mogrify -quality 80 &i\" *.jpg\n             to re-compress a lot of images using ImageMagick to half the size,\n             and no visible loss of quality while keeping the exif header\n             Another invocation I like to use is jpegtran (hard to find for\n             windows).  I type:\n                jhead -cmd \"jpegtran -progressive &i &o\" *.jpg\n             to convert jpegs to progressive jpegs (Unix jpegtran syntax\n             differs slightly)\n  -orp       Only operate on \'portrait\' aspect ratio images\n  -orl       Only operate on \'landscape\' aspect ratio images\n");
#line 1402
  exit(1);
  }
}
}
#line 1409 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
static time_t ParseCmdDate(char *DateSpecified ) 
{ 
  int a ;
  struct tm tm ;
  time_t UnixTime ;

  {
  {
#line 1415
  tm.tm_wday = -1;
#line 1416
  tm.tm_sec = 0;
#line 1416
  tm.tm_min = tm.tm_sec;
#line 1416
  tm.tm_hour = tm.tm_min;
#line 1418
  a = sscanf((char const   */* __restrict  */)DateSpecified, (char const   */* __restrict  */)"%d:%d:%d/%d:%d:%d",
             & tm.tm_year, & tm.tm_mon, & tm.tm_mday, & tm.tm_hour, & tm.tm_min, & tm.tm_sec);
  }
#line 1422
  if (a != 3) {
#line 1422
    if (a < 5) {
      {
#line 1425
      ErrFatal("Could not parse specified date");
      }
    }
  }
  {
#line 1427
  tm.tm_isdst = -1;
#line 1428
  (tm.tm_mon) --;
#line 1429
  tm.tm_year -= 1900;
#line 1431
  UnixTime = mktime(& tm);
  }
#line 1432
  if (UnixTime == -1L) {
    {
#line 1433
    ErrFatal("Specified time is invalid or out of range");
    }
  }
#line 1436
  return (UnixTime);
}
}
#line 1442 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.c"
int main(int argc , char **argv ) 
{ 
  int argn ;
  char *arg ;
  int hours ;
  int minutes ;
  int seconds ;
  int n ;
  time_t NewDate ;
  time_t OldDate ;
  char *pOldDate ;
  int a ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *c ;
  struct tm tm ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;

  {
#line 1446
  progname = (char const   *)*(argv + 0);
#line 1448
  argn = 1;
  {
#line 1448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1448
    if (! (argn < argc)) {
#line 1448
      goto while_break;
    }
#line 1449
    arg = *(argv + argn);
#line 1450
    if ((int )*(arg + 0) != 45) {
#line 1450
      goto while_break;
    }
    {
#line 1453
    tmp___41 = strcmp((char const   *)arg, "-te");
    }
#line 1453
    if (tmp___41) {
      {
#line 1456
      tmp___40 = strcmp((char const   *)arg, "-dc");
      }
#line 1456
      if (tmp___40) {
        {
#line 1459
        tmp___39 = strcmp((char const   *)arg, "-de");
        }
#line 1459
        if (tmp___39) {
          {
#line 1462
          tmp___38 = strcmp((char const   *)arg, "-di");
          }
#line 1462
          if (tmp___38) {
            {
#line 1465
            tmp___37 = strcmp((char const   *)arg, "-dx");
            }
#line 1465
            if (tmp___37) {
              {
#line 1468
              tmp___36 = strcmp((char const   *)arg, "-du");
              }
#line 1468
              if (tmp___36) {
                {
#line 1471
                tmp___35 = strcmp((char const   *)arg, "-purejpg");
                }
#line 1471
                if (tmp___35) {
                  {
#line 1478
                  tmp___34 = strcmp((char const   *)arg, "-ce");
                  }
#line 1478
                  if (tmp___34) {
                    {
#line 1481
                    tmp___33 = strcmp((char const   *)arg, "-cs");
                    }
#line 1481
                    if (tmp___33) {
                      {
#line 1483
                      tmp___32 = strcmp((char const   *)arg, "-ci");
                      }
#line 1483
                      if (tmp___32) {
                        {
#line 1486
                        tmp___31 = strcmp((char const   *)arg, "-cl");
                        }
#line 1486
                        if (tmp___31) {
                          {
#line 1489
                          tmp___30 = strcmp((char const   *)arg, "-zt");
                          }
#line 1489
                          if (tmp___30) {
                            {
#line 1492
                            tmp___29 = strcmp((char const   *)arg, "-mkexif");
                            }
#line 1492
                            if (tmp___29) {
                              {
#line 1496
                              tmp___28 = strcmp((char const   *)arg, "-h");
                              }
#line 1496
                              if (tmp___28) {
                                {
#line 1498
                                tmp___27 = strcmp((char const   *)arg, "-v");
                                }
#line 1498
                                if (tmp___27) {
                                  {
#line 1500
                                  tmp___26 = strcmp((char const   *)arg, "-q");
                                  }
#line 1500
                                  if (tmp___26) {
                                    {
#line 1502
                                    tmp___25 = strcmp((char const   *)arg, "-V");
                                    }
#line 1502
                                    if (tmp___25) {
                                      {
#line 1505
                                      tmp___24 = strcmp((char const   *)arg, "-exifmap");
                                      }
#line 1505
                                      if (tmp___24) {
                                        {
#line 1507
                                        tmp___23 = strcmp((char const   *)arg, "-se");
                                        }
#line 1507
                                        if (tmp___23) {
                                          {
#line 1509
                                          tmp___22 = strcmp((char const   *)arg, "-c");
                                          }
#line 1509
                                          if (tmp___22) {
                                            {
#line 1511
                                            tmp___21 = strcmp((char const   *)arg,
                                                              "-nofinfo");
                                            }
#line 1511
                                            if (tmp___21) {
                                              {
#line 1515
                                              tmp___20 = strcmp((char const   *)arg,
                                                                "-dt");
                                              }
#line 1515
                                              if (tmp___20) {
                                                {
#line 1518
                                                tmp___19 = strcmp((char const   *)arg,
                                                                  "-st");
                                                }
#line 1518
                                                if (tmp___19) {
                                                  {
#line 1521
                                                  tmp___18 = strcmp((char const   *)arg,
                                                                    "-rt");
                                                  }
#line 1521
                                                  if (tmp___18) {
                                                    {
#line 1524
                                                    tmp___17 = memcmp((void const   *)arg,
                                                                      (void const   *)"-rgt",
                                                                      (size_t )4);
                                                    }
#line 1524
                                                    if (tmp___17) {
                                                      {
#line 1533
                                                      tmp___16 = strcmp((char const   *)arg,
                                                                        "-autorot");
                                                      }
#line 1533
                                                      if (tmp___16) {
                                                        {
#line 1536
                                                        tmp___15 = strcmp((char const   *)arg,
                                                                          "-norot");
                                                        }
#line 1536
                                                        if (tmp___15) {
                                                          {
#line 1542
                                                          tmp___14 = memcmp((void const   *)arg,
                                                                            (void const   *)"-n",
                                                                            (size_t )2);
                                                          }
#line 1542
                                                          if (tmp___14) {
                                                            {
#line 1558
                                                            tmp___13 = strcmp((char const   *)arg,
                                                                              "-a");
                                                            }
#line 1558
                                                            if (tmp___13) {
                                                              {
#line 1564
                                                              tmp___12 = strcmp((char const   *)arg,
                                                                                "-ft");
                                                              }
#line 1564
                                                              if (tmp___12) {
                                                                {
#line 1567
                                                                tmp___11 = memcmp((void const   *)arg,
                                                                                  (void const   *)"-ta",
                                                                                  (size_t )3);
                                                                }
#line 1567
                                                                if (tmp___11) {
                                                                  {
#line 1583
                                                                  tmp___10 = memcmp((void const   *)arg,
                                                                                    (void const   *)"-da",
                                                                                    (size_t )3);
                                                                  }
#line 1583
                                                                  if (tmp___10) {
                                                                    {
#line 1597
                                                                    tmp___9 = memcmp((void const   *)arg,
                                                                                     (void const   *)"-dsft",
                                                                                     (size_t )5);
                                                                    }
#line 1597
                                                                    if (tmp___9) {
                                                                      {
#line 1601
                                                                      tmp___8 = memcmp((void const   *)arg,
                                                                                       (void const   *)"-ds",
                                                                                       (size_t )3);
                                                                      }
#line 1601
                                                                      if (tmp___8) {
                                                                        {
#line 1625
                                                                        tmp___7 = memcmp((void const   *)arg,
                                                                                         (void const   *)"-ts",
                                                                                         (size_t )3);
                                                                        }
#line 1625
                                                                        if (tmp___7) {
                                                                          {
#line 1645
                                                                          tmp___6 = strcmp((char const   *)arg,
                                                                                           "-model");
                                                                          }
#line 1645
                                                                          if (tmp___6) {
                                                                            {
#line 1648
                                                                            tmp___5 = strcmp((char const   *)arg,
                                                                                             "-exonly");
                                                                            }
#line 1648
                                                                            if (tmp___5) {
                                                                              {
#line 1650
                                                                              tmp___4 = strcmp((char const   *)arg,
                                                                                               "-orp");
                                                                              }
#line 1650
                                                                              if (tmp___4) {
                                                                                {
#line 1652
                                                                                tmp___3 = strcmp((char const   *)arg,
                                                                                                 "-orl");
                                                                                }
#line 1652
                                                                                if (tmp___3) {
                                                                                  {
#line 1654
                                                                                  tmp___2 = strcmp((char const   *)arg,
                                                                                                   "-cmd");
                                                                                  }
#line 1654
                                                                                  if (tmp___2) {
                                                                                    {
#line 1675
                                                                                    printf((char const   */* __restrict  */)"Argument \'%s\' not understood\n",
                                                                                           arg);
#line 1676
                                                                                    printf((char const   */* __restrict  */)"Use jhead -h for list of arguments\n");
#line 1677
                                                                                    exit(-1);
                                                                                    }
                                                                                  } else {
#line 1655
                                                                                    if (argn + 1 >= argc) {
                                                                                      {
#line 1655
                                                                                      Usage();
                                                                                      }
                                                                                    }
#line 1656
                                                                                    argn ++;
#line 1656
                                                                                    ApplyCommand = *(argv + argn);
#line 1657
                                                                                    DoModify |= 1;
                                                                                  }
                                                                                } else {
#line 1653
                                                                                  PortraitOnly = -1;
                                                                                }
                                                                              } else {
#line 1651
                                                                                PortraitOnly = 1;
                                                                              }
                                                                            } else {
#line 1649
                                                                              ExifOnly = 1;
                                                                            }
                                                                          } else {
#line 1646
                                                                            if (argn + 1 >= argc) {
                                                                              {
#line 1646
                                                                              Usage();
                                                                              }
                                                                            }
#line 1647
                                                                            argn ++;
#line 1647
                                                                            FilterModel = *(argv + argn);
                                                                          }
                                                                        } else {
                                                                          {
#line 1631
                                                                          c = strstr((char const   *)(arg + 1),
                                                                                     "-");
                                                                          }
#line 1632
                                                                          if (c) {
#line 1632
                                                                            *c = (char )' ';
                                                                          }
                                                                          {
#line 1634
                                                                          tmp___1 = Exif2tm(& tm,
                                                                                            arg + 3);
                                                                          }
#line 1634
                                                                          if (! tmp___1) {
                                                                            {
#line 1635
                                                                            ErrFatal("-ts option must be followed by time in format yyyy:mm:dd-hh:mm:ss\nExample: jhead -ts2001:01:01-12:00:00 foo.jpg");
                                                                            }
                                                                          }
                                                                          {
#line 1639
                                                                          ExifTimeSet = mktime(& tm);
                                                                          }
#line 1641
                                                                          if ((int )ExifTimeSet == -1) {
                                                                            {
#line 1641
                                                                            ErrFatal("Time specified is out of range");
                                                                            }
                                                                          }
#line 1642
                                                                          DoModify |= 5;
                                                                        }
                                                                      } else {
                                                                        {
#line 1605
                                                                        strcpy((char */* __restrict  */)(DateSet),
                                                                               (char const   */* __restrict  */)"0000:01:01");
#line 1606
                                                                        a = 0;
                                                                        }
                                                                        {
#line 1606
                                                                        while (1) {
                                                                          while_continue___0: /* CIL Label */ ;
#line 1606
                                                                          if (! *(arg + (a + 3))) {
#line 1606
                                                                            goto while_break___0;
                                                                          }
                                                                          {
#line 1607
                                                                          tmp___0 = __ctype_b_loc();
                                                                          }
#line 1607
                                                                          if ((int const   )*(*tmp___0 + (int )DateSet[a]) & 2048) {
                                                                            {
#line 1608
                                                                            tmp = __ctype_b_loc();
                                                                            }
#line 1608
                                                                            if (! ((int const   )*(*tmp + (int )*(arg + (a + 3))) & 2048)) {
#line 1609
                                                                              a = 0;
#line 1610
                                                                              goto while_break___0;
                                                                            }
                                                                          } else
#line 1613
                                                                          if ((int )*(arg + (a + 3)) != 58) {
#line 1614
                                                                            a = 0;
#line 1615
                                                                            goto while_break___0;
                                                                          }
#line 1618
                                                                          DateSet[a] = *(arg + (a + 3));
#line 1606
                                                                          a ++;
                                                                        }
                                                                        while_break___0: /* CIL Label */ ;
                                                                        }
#line 1620
                                                                        if (a < 4) {
                                                                          {
#line 1621
                                                                          ErrFatal("Date must be in format YYYY, YYYY:MM, or YYYY:MM:DD");
                                                                          }
                                                                        } else
#line 1620
                                                                        if (a > 10) {
                                                                          {
#line 1621
                                                                          ErrFatal("Date must be in format YYYY, YYYY:MM, or YYYY:MM:DD");
                                                                          }
                                                                        }
#line 1623
                                                                        DateSetChars = (unsigned int )a;
#line 1624
                                                                        DoModify |= 5;
                                                                      }
                                                                    } else {
#line 1599
                                                                      FileTimeToExif = 1U;
#line 1600
                                                                      DoModify |= 5;
                                                                    }
                                                                  } else {
                                                                    {
#line 1585
                                                                    OldDate = (time_t )0;
#line 1587
                                                                    NewDate = ParseCmdDate(arg + 3);
#line 1588
                                                                    pOldDate = strstr((char const   *)(arg + 1),
                                                                                      "-");
                                                                    }
#line 1589
                                                                    if (pOldDate) {
                                                                      {
#line 1590
                                                                      OldDate = ParseCmdDate(pOldDate + 1);
                                                                      }
                                                                    } else {
                                                                      {
#line 1592
                                                                      ErrFatal("Must specifiy second date for -da option");
                                                                      }
                                                                    }
#line 1594
                                                                    if (ExifTimeAdjust) {
                                                                      {
#line 1594
                                                                      ErrFatal("Can only use one of -da or -ta options at once");
                                                                      }
                                                                    }
#line 1595
                                                                    ExifTimeAdjust = NewDate - OldDate;
#line 1596
                                                                    DoModify |= 5;
                                                                  }
                                                                } else {
#line 1570
                                                                  seconds = 0;
#line 1570
                                                                  minutes = seconds;
#line 1571
                                                                  if ((int )*(arg + 3) != 45) {
#line 1571
                                                                    if ((int )*(arg + 3) != 43) {
                                                                      {
#line 1572
                                                                      ErrFatal("Error: -ta must be followed by +/- and a time");
                                                                      }
                                                                    }
                                                                  }
                                                                  {
#line 1574
                                                                  n = sscanf((char const   */* __restrict  */)(arg + 4),
                                                                             (char const   */* __restrict  */)"%d:%d:%d",
                                                                             & hours,
                                                                             & minutes,
                                                                             & seconds);
                                                                  }
#line 1576
                                                                  if (n < 1) {
                                                                    {
#line 1577
                                                                    ErrFatal("Error: -ta must be immediately followed by time");
                                                                    }
                                                                  }
#line 1579
                                                                  if (ExifTimeAdjust) {
                                                                    {
#line 1579
                                                                    ErrFatal("Can only use one of -da or -ta options at once");
                                                                    }
                                                                  }
#line 1580
                                                                  ExifTimeAdjust = (time_t )((hours * 3600 + minutes * 60) + seconds);
#line 1581
                                                                  if ((int )*(arg + 3) == 45) {
#line 1581
                                                                    ExifTimeAdjust = - ExifTimeAdjust;
                                                                  }
#line 1582
                                                                  DoModify |= 5;
                                                                }
                                                              } else {
#line 1565
                                                                Exif2FileTime = 1;
#line 1566
                                                                DoModify |= 1;
                                                              }
                                                            } else {
                                                              {
#line 1560
                                                              ErrFatal("Error: -a only supported in Windows version");
                                                              }
                                                            }
                                                          } else {
#line 1543
                                                            RenameToDate = 1;
#line 1544
                                                            DoModify |= 6;
#line 1545
                                                            arg += 2;
#line 1546
                                                            if ((int )*arg == 102) {
#line 1548
                                                              arg ++;
                                                            }
#line 1550
                                                            if (*arg) {
#line 1552
                                                              strftime_args = arg;
                                                            }
                                                          }
                                                        } else {
#line 1537
                                                          AutoRotate = 1;
#line 1538
                                                          ZeroRotateTagOnly = 1;
#line 1539
                                                          DoModify |= 5;
                                                        }
                                                      } else {
#line 1534
                                                        AutoRotate = 1;
#line 1535
                                                        DoModify |= 5;
                                                      }
                                                    } else {
                                                      {
#line 1525
                                                      RegenThumbnail = 160;
#line 1526
                                                      sscanf((char const   */* __restrict  */)(arg + 4),
                                                             (char const   */* __restrict  */)"%d",
                                                             & RegenThumbnail);
                                                      }
#line 1527
                                                      if (RegenThumbnail > 320) {
                                                        {
#line 1528
                                                        ErrFatal("Specified thumbnail geometry too big!");
                                                        }
                                                      }
#line 1530
                                                      DoModify |= 5;
                                                    }
                                                  } else {
#line 1522
                                                    argn ++;
#line 1522
                                                    ThumbInsertName = *(argv + argn);
#line 1523
                                                    DoModify |= 5;
                                                  }
                                                } else {
#line 1519
                                                  argn ++;
#line 1519
                                                  ThumbSaveName = *(argv + argn);
#line 1520
                                                  DoModify |= 6;
                                                }
                                              } else {
#line 1516
                                                TrimExif = 1;
#line 1517
                                                DoModify |= 5;
                                              }
                                            } else {
#line 1512
                                              ShowFileInfo = 0;
                                            }
                                          } else {
#line 1510
                                            ShowConcise = 1;
                                          }
                                        } else {
#line 1508
                                          SupressNonFatalErrors = 1;
                                        }
                                      } else {
#line 1506
                                        DumpExifMap = 1;
                                      }
                                    } else {
                                      {
#line 1503
                                      printf((char const   */* __restrict  */)"Jhead version: 3.00   Compiled: May 30 2018\n");
#line 1504
                                      exit(0);
                                      }
                                    }
                                  } else {
#line 1501
                                    Quiet = 1;
                                  }
                                } else {
#line 1499
                                  ShowTags = 1;
                                }
                              } else {
                                {
#line 1497
                                Usage();
                                }
                              }
                            } else {
#line 1493
                              CreateExifSection = 1;
#line 1494
                              DoModify |= 5;
                            }
                          } else {
#line 1490
                            TrimExifTrailingZeroes = 1;
#line 1491
                            DoModify |= 5;
                          }
                        } else {
#line 1487
                          argn ++;
#line 1487
                          CommentInsertLiteral = *(argv + argn);
#line 1488
                          DoModify |= 5;
                        }
                      } else {
#line 1484
                        argn ++;
#line 1484
                        CommentInsertfileName = *(argv + argn);
#line 1485
                        DoModify |= 5;
                      }
                    } else {
#line 1482
                      argn ++;
#line 1482
                      CommentSavefileName = *(argv + argn);
                    }
                  } else {
#line 1479
                    EditComment = 1;
#line 1480
                    DoModify |= 5;
                  }
                } else {
#line 1472
                  DeleteExif = 1;
#line 1473
                  DeleteComments = 1;
#line 1474
                  DeleteIptc = 1;
#line 1475
                  DeleteUnknown = 1;
#line 1476
                  DeleteXmp = 1;
#line 1477
                  DoModify |= 5;
                }
              } else {
#line 1469
                DeleteUnknown = 1;
#line 1470
                DoModify |= 5;
              }
            } else {
#line 1466
              DeleteXmp = 1;
#line 1467
              DoModify |= 5;
            }
          } else {
#line 1463
            DeleteIptc = 1;
#line 1464
            DoModify |= 5;
          }
        } else {
#line 1460
          DeleteExif = 1;
#line 1461
          DoModify |= 5;
        }
      } else {
#line 1457
        DeleteComments = 1;
#line 1458
        DoModify |= 5;
      }
    } else {
#line 1454
      argn ++;
#line 1454
      ExifXferScrFile = *(argv + argn);
#line 1455
      DoModify |= 5;
    }
#line 1679
    if (argn >= argc) {
      {
#line 1682
      ErrFatal("Extra argument required");
      }
    }
#line 1448
    argn ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1685
  if (argn == argc) {
    {
#line 1686
    ErrFatal("No files to process.  Use -h for help");
    }
  }
#line 1689
  if ((unsigned long )ThumbSaveName != (unsigned long )((void *)0)) {
    {
#line 1689
    tmp___42 = strcmp((char const   *)ThumbSaveName, "&i");
    }
#line 1689
    if (tmp___42 == 0) {
      {
#line 1690
      printf((char const   */* __restrict  */)"Error: By specifying \"&i\" for the thumbail name, your original file\n       will be overwitten.  If this is what you really want,\n       specify  -st \"./&i\"  to override this check\n");
#line 1693
      exit(0);
      }
    }
  }
#line 1696
  if (RegenThumbnail) {
#line 1697
    if (ThumbSaveName) {
      {
#line 1698
      printf((char const   */* __restrict  */)"Error: Cannot regen and save or insert thumbnail in same run\n");
#line 1699
      exit(0);
      }
    } else
#line 1697
    if (ThumbInsertName) {
      {
#line 1698
      printf((char const   */* __restrict  */)"Error: Cannot regen and save or insert thumbnail in same run\n");
#line 1699
      exit(0);
      }
    }
  }
#line 1703
  if (EditComment) {
#line 1704
    if ((unsigned long )CommentSavefileName != (unsigned long )((void *)0)) {
      {
#line 1705
      printf((char const   */* __restrict  */)"Error: Cannot use -ce option in combination with -cs or -ci\n");
#line 1706
      exit(0);
      }
    } else
#line 1704
    if ((unsigned long )CommentInsertfileName != (unsigned long )((void *)0)) {
      {
#line 1705
      printf((char const   */* __restrict  */)"Error: Cannot use -ce option in combination with -cs or -ci\n");
#line 1706
      exit(0);
      }
    }
  }
#line 1711
  if (ExifXferScrFile) {
#line 1712
    if (FilterModel) {
      {
#line 1713
      ErrFatal("Error: Filter by model and/or applying command to files\n   invalid while transferring Exif headers");
      }
    } else
#line 1712
    if (ApplyCommand) {
      {
#line 1713
      ErrFatal("Error: Filter by model and/or applying command to files\n   invalid while transferring Exif headers");
      }
    }
  }
#line 1718
  FileSequence = 0;
  {
#line 1719
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1719
    if (! (argn < argc)) {
#line 1719
      goto while_break___1;
    }
    {
#line 1720
    FilesMatched = 0;
#line 1730
    ProcessFile((char const   *)*(argv + argn));
    }
#line 1733
    if (! FilesMatched) {
      {
#line 1734
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: No files matched \'%s\'\n",
              *(argv + argn));
      }
    }
#line 1719
    argn ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1738
  if (FileSequence == 0) {
#line 1739
    return (1);
  } else {
#line 1741
    return (0);
  }
}
}
#line 695 "/usr/include/stdio.h"
extern int puts(char const   *__s ) ;
#line 52 "/home/khheo/project/cve/benchmark/jhead-3.00/iptc.c"
void show_IPTC(unsigned char *Data , unsigned int itemlen ) 
{ 
  char IptcSig1[14] ;
  char IptcSig2[5] ;
  char IptcSig3[2] ;
  unsigned char *pos ;
  unsigned char *maxpos ;
  unsigned char headerLen ;
  unsigned char dataLen ;
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned char *tmp___4 ;
  short signature ;
  unsigned char type ;
  short length ;
  char const   *description ;
  unsigned char *tmp___5 ;
  char TempBuf[32] ;
  size_t tmp___6 ;

  {
#line 54
  IptcSig1[0] = (char )'P';
#line 54
  IptcSig1[1] = (char )'h';
#line 54
  IptcSig1[2] = (char )'o';
#line 54
  IptcSig1[3] = (char )'t';
#line 54
  IptcSig1[4] = (char )'o';
#line 54
  IptcSig1[5] = (char )'s';
#line 54
  IptcSig1[6] = (char )'h';
#line 54
  IptcSig1[7] = (char )'o';
#line 54
  IptcSig1[8] = (char )'p';
#line 54
  IptcSig1[9] = (char )' ';
#line 54
  IptcSig1[10] = (char )'3';
#line 54
  IptcSig1[11] = (char )'.';
#line 54
  IptcSig1[12] = (char )'0';
#line 54
  IptcSig1[13] = (char )'\000';
#line 55
  IptcSig2[0] = (char )'8';
#line 55
  IptcSig2[1] = (char )'B';
#line 55
  IptcSig2[2] = (char )'I';
#line 55
  IptcSig2[3] = (char )'M';
#line 55
  IptcSig2[4] = (char )'\000';
#line 56
  IptcSig3[0] = (char)4;
#line 56
  IptcSig3[1] = (char)4;
#line 58
  pos = Data + sizeof(short );
#line 59
  maxpos = Data + itemlen;
#line 60
  headerLen = (unsigned char)0;
#line 61
  dataLen = (unsigned char)0;
#line 63
  if (itemlen < 25U) {
#line 63
    goto corrupt;
  }
  {
#line 66
  tmp = memcmp((void const   *)pos, (void const   *)(IptcSig1), sizeof(IptcSig1) - 1UL);
  }
#line 66
  if (tmp != 0) {
#line 66
    goto badsig;
  }
  {
#line 67
  pos += sizeof(IptcSig1);
#line 69
  tmp___0 = memcmp((void const   *)pos, (void const   *)(IptcSig2), sizeof(IptcSig2) - 1UL);
  }
#line 69
  if (tmp___0 != 0) {
#line 69
    goto badsig;
  }
#line 70
  pos += sizeof(IptcSig2) - 1UL;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 73
    tmp___3 = memcmp((void const   *)pos, (void const   *)(IptcSig3), sizeof(IptcSig3));
    }
#line 73
    if (! (tmp___3 != 0)) {
#line 73
      goto while_break;
    }
    {
#line 75
    pos += sizeof(IptcSig3);
#line 77
    headerLen = *pos;
#line 78
    pos += ((int )headerLen & 254) + 2;
#line 80
    pos += 3;
#line 82
    tmp___1 = pos;
#line 82
    pos ++;
#line 82
    dataLen = *tmp___1;
#line 83
    pos += (int )dataLen;
#line 85
    tmp___2 = memcmp((void const   *)pos, (void const   *)(IptcSig2), sizeof(IptcSig2) - 1UL);
    }
#line 85
    if (tmp___2 != 0) {
      badsig: 
#line 86
      if (ShowTags) {
        {
#line 87
        ErrNonfatal("IPTC type signature mismatch\n", 0, 0);
        }
      }
#line 89
      return;
    }
#line 91
    pos += sizeof(IptcSig2) - 1UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  pos += sizeof(IptcSig3);
#line 96
  if ((unsigned long )pos >= (unsigned long )maxpos) {
#line 96
    goto corrupt;
  }
#line 101
  tmp___4 = pos;
#line 101
  pos ++;
#line 101
  headerLen = *tmp___4;
#line 102
  pos += ((int )headerLen + 1) - (int )headerLen % 2;
#line 104
  if ((unsigned long )(pos + 4) >= (unsigned long )maxpos) {
#line 104
    goto corrupt;
  }
  {
#line 109
  pos += 4;
#line 111
  printf((char const   */* __restrict  */)"======= IPTC data: =======\n");
  }
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 114
    if (! ((unsigned long )pos < (unsigned long )((Data + itemlen) - 5))) {
#line 114
      goto while_break___0;
    }
#line 116
    type = (unsigned char)0;
#line 117
    length = (short)0;
#line 118
    description = (char const   *)((void *)0);
#line 120
    if ((unsigned long )(pos + 5) > (unsigned long )maxpos) {
#line 120
      goto corrupt;
    }
#line 122
    signature = (short )(((int )*pos << 8) + (int )*(pos + 1));
#line 123
    pos += 2;
#line 125
    if ((int )signature != 7169) {
#line 125
      if ((int )signature != 7170) {
#line 125
        goto while_break___0;
      }
    }
#line 127
    tmp___5 = pos;
#line 127
    pos ++;
#line 127
    type = *tmp___5;
#line 128
    length = (short )(((int )*pos << 8) + (int )*(pos + 1));
#line 129
    pos += 2;
#line 131
    if ((unsigned long )(pos + (int )length) > (unsigned long )maxpos) {
#line 131
      goto corrupt;
    }
    {
#line 134
    if ((int )type == 0) {
#line 134
      goto case_0;
    }
#line 138
    if ((int )type == 20) {
#line 138
      goto case_20;
    }
#line 139
    if ((int )type == 25) {
#line 139
      goto case_25;
    }
#line 140
    if ((int )type == 120) {
#line 140
      goto case_120;
    }
#line 141
    if ((int )type == 122) {
#line 141
      goto case_122;
    }
#line 142
    if ((int )type == 105) {
#line 142
      goto case_105;
    }
#line 143
    if ((int )type == 40) {
#line 143
      goto case_40;
    }
#line 144
    if ((int )type == 15) {
#line 144
      goto case_15;
    }
#line 145
    if ((int )type == 80) {
#line 145
      goto case_80;
    }
#line 146
    if ((int )type == 85) {
#line 146
      goto case_85;
    }
#line 147
    if ((int )type == 110) {
#line 147
      goto case_110;
    }
#line 148
    if ((int )type == 115) {
#line 148
      goto case_115;
    }
#line 149
    if ((int )type == 116) {
#line 149
      goto case_116;
    }
#line 150
    if ((int )type == 5) {
#line 150
      goto case_5;
    }
#line 151
    if ((int )type == 90) {
#line 151
      goto case_90;
    }
#line 152
    if ((int )type == 95) {
#line 152
      goto case_95;
    }
#line 153
    if ((int )type == 101) {
#line 153
      goto case_101;
    }
#line 154
    if ((int )type == 103) {
#line 154
      goto case_103;
    }
#line 155
    if ((int )type == 55) {
#line 155
      goto case_55;
    }
#line 156
    if ((int )type == 10) {
#line 156
      goto case_10;
    }
#line 157
    if ((int )type == 45) {
#line 157
      goto case_45;
    }
#line 158
    if ((int )type == 100) {
#line 158
      goto case_100;
    }
#line 159
    if ((int )type == 60) {
#line 159
      goto case_60;
    }
#line 160
    if ((int )type == 92) {
#line 160
      goto case_92;
    }
#line 161
    if ((int )type == 130) {
#line 161
      goto case_130;
    }
#line 163
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 135
    printf((char const   */* __restrict  */)"Record vers.  : %d\n", ((int )*pos << 8) + (int )*(pos + 1));
    }
#line 136
    goto switch_break;
    case_20: /* CIL Label */ 
#line 138
    description = "SuplementalCategories";
#line 138
    goto switch_break;
    case_25: /* CIL Label */ 
#line 139
    description = "Keywords";
#line 139
    goto switch_break;
    case_120: /* CIL Label */ 
#line 140
    description = "Caption";
#line 140
    goto switch_break;
    case_122: /* CIL Label */ 
#line 141
    description = "Author";
#line 141
    goto switch_break;
    case_105: /* CIL Label */ 
#line 142
    description = "Headline";
#line 142
    goto switch_break;
    case_40: /* CIL Label */ 
#line 143
    description = "Spec. Instr.";
#line 143
    goto switch_break;
    case_15: /* CIL Label */ 
#line 144
    description = "Category";
#line 144
    goto switch_break;
    case_80: /* CIL Label */ 
#line 145
    description = "Byline";
#line 145
    goto switch_break;
    case_85: /* CIL Label */ 
#line 146
    description = "Byline Title";
#line 146
    goto switch_break;
    case_110: /* CIL Label */ 
#line 147
    description = "Credit";
#line 147
    goto switch_break;
    case_115: /* CIL Label */ 
#line 148
    description = "Source";
#line 148
    goto switch_break;
    case_116: /* CIL Label */ 
#line 149
    description = "(C)Notice";
#line 149
    goto switch_break;
    case_5: /* CIL Label */ 
#line 150
    description = "Object Name";
#line 150
    goto switch_break;
    case_90: /* CIL Label */ 
#line 151
    description = "City";
#line 151
    goto switch_break;
    case_95: /* CIL Label */ 
#line 152
    description = "State";
#line 152
    goto switch_break;
    case_101: /* CIL Label */ 
#line 153
    description = "Country";
#line 153
    goto switch_break;
    case_103: /* CIL Label */ 
#line 154
    description = "OriginalTransmissionReference";
#line 154
    goto switch_break;
    case_55: /* CIL Label */ 
#line 155
    description = "DateCreated";
#line 155
    goto switch_break;
    case_10: /* CIL Label */ 
#line 156
    description = "(C)Flag";
#line 156
    goto switch_break;
    case_45: /* CIL Label */ 
#line 157
    description = "Country Code";
#line 157
    goto switch_break;
    case_100: /* CIL Label */ 
#line 158
    description = "Ref. Service";
#line 158
    goto switch_break;
    case_60: /* CIL Label */ 
#line 159
    description = "Time Created";
#line 159
    goto switch_break;
    case_92: /* CIL Label */ 
#line 160
    description = "Sub Location";
#line 160
    goto switch_break;
    case_130: /* CIL Label */ 
#line 161
    description = "Image type";
#line 161
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 164
    if (ShowTags) {
      {
#line 165
      printf((char const   */* __restrict  */)"Unrecognised IPTC tag: %d\n", (int )type);
      }
    }
#line 167
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 169
    if ((unsigned long )description != (unsigned long )((void *)0)) {
      {
#line 171
      memset((void *)(TempBuf), 0, sizeof(TempBuf));
#line 172
      memset((void *)(TempBuf), ' ', (size_t )14);
#line 173
      tmp___6 = strlen(description);
#line 173
      memcpy((void */* __restrict  */)(TempBuf), (void const   */* __restrict  */)description,
             tmp___6);
#line 174
      strcat((char */* __restrict  */)(TempBuf), (char const   */* __restrict  */)":");
#line 175
      printf((char const   */* __restrict  */)"%s %*.*s\n", TempBuf, (int )length,
             (int )length, pos);
      }
    }
#line 177
    pos += (int )length;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 179
  return;
  corrupt: 
  {
#line 181
  ErrNonfatal("Pointer corruption in IPTC\n", 0, 0);
  }
#line 182
  return;
}
}
#line 189 "/home/khheo/project/cve/benchmark/jhead-3.00/iptc.c"
void ShowXmp(Section_t XmpSection ) 
{ 
  unsigned char *Data ;
  char OutLine[101] ;
  int OutLineChars ;
  int NonBlank ;
  unsigned int a ;
  int tmp ;
  int tmp___0 ;

  {
#line 196
  NonBlank = 0;
#line 197
  Data = XmpSection.Data;
#line 198
  OutLineChars = 0;
#line 201
  a = 0U;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (a < XmpSection.Size)) {
#line 201
      goto while_break;
    }
#line 202
    if ((int )*(Data + a) >= 32) {
#line 202
      if ((int )*(Data + a) < 128) {
#line 203
        tmp = OutLineChars;
#line 203
        OutLineChars ++;
#line 203
        OutLine[tmp] = (char )*(Data + a);
#line 204
        if ((int )*(Data + a) != 32) {
#line 204
          NonBlank |= 1;
        }
      } else {
#line 202
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 206
    if ((int )*(Data + a) != 10) {
#line 207
      tmp___0 = OutLineChars;
#line 207
      OutLineChars ++;
#line 207
      OutLine[tmp___0] = (char )'?';
    }
#line 210
    if ((int )*(Data + a) == 10) {
#line 210
      goto _L___0;
    } else
#line 210
    if (OutLineChars >= 100) {
      _L___0: /* CIL Label */ 
#line 211
      OutLine[OutLineChars] = (char)0;
#line 212
      if (NonBlank) {
        {
#line 213
        puts((char const   *)(OutLine));
        }
      }
#line 215
      NonBlank = (NonBlank & 1) << 1;
#line 216
      OutLineChars = 0;
    }
#line 201
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return;
}
}
#line 165 "/home/khheo/project/cve/benchmark/jhead-3.00/jhead.h"
double ConvertAnyFormat(void *ValuePtr , int Format ) ;
#line 168
int Get32s(void *Long ) ;
#line 196
void ProcessGpsInfo(unsigned char *DirStart , unsigned char *OffsetBase , unsigned int ExifLength ) ;
#line 19 "/home/khheo/project/cve/benchmark/jhead-3.00/gpsinfo.c"
static char const   *GpsTags[31]  = 
#line 19 "/home/khheo/project/cve/benchmark/jhead-3.00/gpsinfo.c"
  {      "VersionID       ",      "LatitudeRef     ",      "Latitude        ",      "LongitudeRef    ", 
        "Longitude       ",      "AltitudeRef     ",      "Altitude        ",      "TimeStamp       ", 
        "Satellites      ",      "Status          ",      "MeasureMode     ",      "DOP             ", 
        "SpeedRef        ",      "Speed           ",      "TrackRef        ",      "Track           ", 
        "ImgDirectionRef ",      "ImgDirection    ",      "MapDatum        ",      "DestLatitudeRef ", 
        "DestLatitude    ",      "DestLongitudeRef",      "DestLongitude   ",      "DestBearingRef  ", 
        "DestBearing     ",      "DestDistanceRef ",      "DestDistance    ",      "ProcessingMethod", 
        "AreaInformation ",      "DateStamp       ",      "Differential    "};
#line 56 "/home/khheo/project/cve/benchmark/jhead-3.00/gpsinfo.c"
void ProcessGpsInfo(unsigned char *DirStart , unsigned char *OffsetBase , unsigned int ExifLength ) 
{ 
  int de ;
  unsigned int a ;
  int NumDirEntries ;
  unsigned int Tag ;
  unsigned int Format ;
  unsigned int Components ;
  unsigned char *ValuePtr ;
  int ComponentSize ;
  unsigned int ByteCount ;
  unsigned char *DirEntry ;
  int tmp ;
  int tmp___0 ;
  unsigned int OffsetVal ;
  char FmtString[21] ;
  char TempString[50] ;
  double Values[3] ;
  int den ;
  int digits ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int ZeroSkipped ;

  {
  {
#line 62
  NumDirEntries = Get16u((void *)DirStart);
  }
#line 65
  if (ShowTags) {
    {
#line 66
    printf((char const   */* __restrict  */)"(dir has %d entries)\n", NumDirEntries);
    }
  }
  {
#line 69
  ImageInfo.GpsInfoPresent = 1;
#line 70
  strcpy((char */* __restrict  */)(ImageInfo.GpsLat), (char const   */* __restrict  */)"? ?");
#line 71
  strcpy((char */* __restrict  */)(ImageInfo.GpsLong), (char const   */* __restrict  */)"? ?");
#line 72
  ImageInfo.GpsAlt[0] = (char)0;
#line 74
  de = 0;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (de < NumDirEntries)) {
#line 74
      goto while_break;
    }
#line 80
    DirEntry = (DirStart + 2) + 12 * de;
#line 82
    if ((unsigned long )(DirEntry + 12) > (unsigned long )(OffsetBase + ExifLength)) {
      {
#line 83
      ErrNonfatal("GPS info directory goes past end of exif", 0, 0);
      }
#line 84
      return;
    }
    {
#line 87
    tmp = Get16u((void *)DirEntry);
#line 87
    Tag = (unsigned int )tmp;
#line 88
    tmp___0 = Get16u((void *)(DirEntry + 2));
#line 88
    Format = (unsigned int )tmp___0;
#line 89
    Components = Get32u((void *)(DirEntry + 4));
    }
#line 91
    if (Format - 1U >= 12U) {
      {
#line 93
      ErrNonfatal("Illegal number format %d for Exif gps tag %04x", (int )Format,
                  (int )Tag);
      }
#line 94
      goto __Cont;
    }
#line 97
    ComponentSize = (int )BytesPerFormat[Format];
#line 98
    ByteCount = Components * (unsigned int )ComponentSize;
#line 100
    if (ByteCount > 4U) {
      {
#line 102
      OffsetVal = Get32u((void *)(DirEntry + 8));
      }
#line 104
      if (OffsetVal + ByteCount > ExifLength) {
        {
#line 106
        ErrNonfatal("Illegal value pointer for Exif gps tag %04x", (int )Tag, 0);
        }
#line 107
        goto __Cont;
      }
#line 109
      ValuePtr = OffsetBase + OffsetVal;
    } else {
#line 112
      ValuePtr = DirEntry + 8;
    }
    {
#line 120
    if (Tag == 1U) {
#line 120
      goto case_1;
    }
#line 124
    if (Tag == 3U) {
#line 124
      goto case_3;
    }
#line 129
    if (Tag == 4U) {
#line 129
      goto case_4;
    }
#line 129
    if (Tag == 2U) {
#line 129
      goto case_4;
    }
#line 159
    if (Tag == 5U) {
#line 159
      goto case_5;
    }
#line 163
    if (Tag == 6U) {
#line 163
      goto case_6;
    }
#line 115
    goto switch_break;
    case_1: /* CIL Label */ 
#line 121
    ImageInfo.GpsLat[0] = (char )*(ValuePtr + 0);
#line 122
    goto switch_break;
    case_3: /* CIL Label */ 
#line 125
    ImageInfo.GpsLong[0] = (char )*(ValuePtr + 0);
#line 126
    goto switch_break;
    case_4: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 130
    if (Format != 5U) {
      {
#line 131
      ErrNonfatal("Inappropriate format (%d) for Exif GPS coordinates!", (int )Format,
                  0);
      }
    }
    {
#line 133
    strcpy((char */* __restrict  */)(FmtString), (char const   */* __restrict  */)"%0.0fd %0.0fm %0.0fs");
#line 134
    a = 0U;
    }
    {
#line 134
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 134
      if (! (a < 3U)) {
#line 134
        goto while_break___0;
      }
      {
#line 137
      den = Get32s((void *)((ValuePtr + 4) + a * (unsigned int )ComponentSize));
#line 138
      digits = 0;
      }
      {
#line 139
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 139
        if (den > 1) {
#line 139
          if (! (digits <= 6)) {
#line 139
            goto while_break___1;
          }
        } else {
#line 139
          goto while_break___1;
        }
#line 140
        den /= 10;
#line 141
        digits ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 143
      if (digits > 6) {
#line 143
        digits = 6;
      }
#line 144
      if (digits) {
#line 144
        tmp___1 = 1;
      } else {
#line 144
        tmp___1 = 0;
      }
      {
#line 144
      FmtString[1U + a * 7U] = (char )((50 + digits) + tmp___1);
#line 145
      FmtString[3U + a * 7U] = (char )(48 + digits);
#line 147
      Values[a] = ConvertAnyFormat((void *)(ValuePtr + a * (unsigned int )ComponentSize),
                                   (int )Format);
#line 134
      a ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 150
    sprintf((char */* __restrict  */)(TempString), (char const   */* __restrict  */)(FmtString),
            Values[0], Values[1], Values[2]);
    }
#line 152
    if (Tag == 2U) {
      {
#line 153
      strncpy((char */* __restrict  */)(ImageInfo.GpsLat + 2), (char const   */* __restrict  */)(TempString),
              (size_t )29);
      }
    } else {
      {
#line 155
      strncpy((char */* __restrict  */)(ImageInfo.GpsLong + 2), (char const   */* __restrict  */)(TempString),
              (size_t )29);
      }
    }
#line 157
    goto switch_break;
    case_5: /* CIL Label */ 
#line 160
    if (*(ValuePtr + 0)) {
#line 160
      tmp___2 = '-';
    } else {
#line 160
      tmp___2 = ' ';
    }
#line 160
    ImageInfo.GpsAlt[0] = (char )tmp___2;
#line 161
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 164
    tmp___3 = ConvertAnyFormat((void *)ValuePtr, (int )Format);
#line 164
    sprintf((char */* __restrict  */)(ImageInfo.GpsAlt + 1), (char const   */* __restrict  */)"%.2fm",
            tmp___3);
    }
#line 166
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 169
    if (ShowTags) {
#line 171
      if (Tag < 30U) {
        {
#line 172
        printf((char const   */* __restrict  */)"        GPS%s =", GpsTags[Tag]);
        }
      } else {
        {
#line 175
        printf((char const   */* __restrict  */)"        Illegal GPS tag %04x=", Tag);
        }
      }
      {
#line 182
      if (Format == 2U) {
#line 182
        goto case_2___0;
      }
#line 182
      if (Format == 7U) {
#line 182
        goto case_2___0;
      }
#line 204
      goto switch_default;
      case_2___0: /* CIL Label */ 
      case_7: /* CIL Label */ 
      {
#line 185
      printf((char const   */* __restrict  */)"\"");
#line 186
      a = 0U;
      }
      {
#line 186
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 186
        if (! (a < ByteCount)) {
#line 186
          goto while_break___2;
        }
#line 187
        ZeroSkipped = 0;
#line 188
        if ((int )*(ValuePtr + a) >= 32) {
#line 189
          if (ZeroSkipped) {
            {
#line 190
            printf((char const   */* __restrict  */)"?");
#line 191
            ZeroSkipped = 0;
            }
          }
          {
#line 193
          putchar((int )*(ValuePtr + a));
          }
        } else
#line 195
        if ((int )*(ValuePtr + a) == 0) {
#line 196
          ZeroSkipped = 1;
        }
#line 186
        a ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 200
      printf((char const   */* __restrict  */)"\"\n");
      }
#line 202
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 206
      a = 0U;
      {
#line 206
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 207
        PrintFormatNumber((void *)(ValuePtr + a * (unsigned int )ComponentSize), (int )Format,
                          (int )ByteCount);
#line 208
        a ++;
        }
#line 208
        if (a >= Components) {
#line 208
          goto while_break___3;
        }
        {
#line 209
        printf((char const   */* __restrict  */)", ");
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 211
      printf((char const   */* __restrict  */)"\n");
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 74
    de ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 109
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 13 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static unsigned char *DirWithThumbnailPtrs  ;
#line 14 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static double FocalplaneXRes  ;
#line 15 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static double FocalplaneUnits  ;
#line 16 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static int ExifImageWidth  ;
#line 17 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
int MotorolaOrder  =    0;
#line 20 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static void *OrientationPtr[2]  ;
#line 21 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static int OrientationNumFormat[2]  ;
#line 22 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
int NumOrientations  =    0;
#line 32 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static TagTable_t const   ProcessTable[13]  = 
#line 32
  {      {(unsigned short)192, (char *)"Baseline"}, 
        {(unsigned short)193, (char *)"Extended sequential"}, 
        {(unsigned short)194, (char *)"Progressive"}, 
        {(unsigned short)195, (char *)"Lossless"}, 
        {(unsigned short)197, (char *)"Differential sequential"}, 
        {(unsigned short)198, (char *)"Differential progressive"}, 
        {(unsigned short)199, (char *)"Differential lossless"}, 
        {(unsigned short)201, (char *)"Extended sequential, arithmetic coding"}, 
        {(unsigned short)202, (char *)"Progressive, arithmetic coding"}, 
        {(unsigned short)203, (char *)"Lossless, arithmetic coding"}, 
        {(unsigned short)205, (char *)"Differential sequential, arithmetic coding"}, 
        {(unsigned short)206, (char *)"Differential progressive, arithmetic coding"}, 
        {(unsigned short)207,
      (char *)"Differential lossless, arithmetic coding"}};
#line 63 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static char const   *OrientTab[9]  = 
#line 63
  {      "Undefined",      "Normal",      "flip horizontal",      "rotate 180", 
        "flip vertical",      "transpose",      "rotate 90",      "transverse", 
        "rotate 270"};
#line 75 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
int const   BytesPerFormat[13]  = 
#line 75
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )4,      (int const   )8,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )4,      (int const   )8,      (int const   )4, 
        (int const   )8};
#line 189 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static TagTable_t const   TagTable[106]  = 
#line 189
  {      {(unsigned short)1, (char *)"InteropIndex"}, 
        {(unsigned short)2, (char *)"InteropVersion"}, 
        {(unsigned short)256, (char *)"ImageWidth"}, 
        {(unsigned short)257, (char *)"ImageLength"}, 
        {(unsigned short)258, (char *)"BitsPerSample"}, 
        {(unsigned short)259, (char *)"Compression"}, 
        {(unsigned short)262, (char *)"PhotometricInterpretation"}, 
        {(unsigned short)266, (char *)"FillOrder"}, 
        {(unsigned short)269, (char *)"DocumentName"}, 
        {(unsigned short)270, (char *)"ImageDescription"}, 
        {(unsigned short)271, (char *)"Make"}, 
        {(unsigned short)272, (char *)"Model"}, 
        {(unsigned short)273, (char *)"StripOffsets"}, 
        {(unsigned short)274, (char *)"Orientation"}, 
        {(unsigned short)277, (char *)"SamplesPerPixel"}, 
        {(unsigned short)278, (char *)"RowsPerStrip"}, 
        {(unsigned short)279, (char *)"StripByteCounts"}, 
        {(unsigned short)282, (char *)"XResolution"}, 
        {(unsigned short)283, (char *)"YResolution"}, 
        {(unsigned short)284, (char *)"PlanarConfiguration"}, 
        {(unsigned short)296, (char *)"ResolutionUnit"}, 
        {(unsigned short)301, (char *)"TransferFunction"}, 
        {(unsigned short)305, (char *)"Software"}, 
        {(unsigned short)306, (char *)"DateTime"}, 
        {(unsigned short)315, (char *)"Artist"}, 
        {(unsigned short)318, (char *)"WhitePoint"}, 
        {(unsigned short)319, (char *)"PrimaryChromaticities"}, 
        {(unsigned short)342, (char *)"TransferRange"}, 
        {(unsigned short)512, (char *)"JPEGProc"}, 
        {(unsigned short)513, (char *)"ThumbnailOffset"}, 
        {(unsigned short)514, (char *)"ThumbnailLength"}, 
        {(unsigned short)529, (char *)"YCbCrCoefficients"}, 
        {(unsigned short)530, (char *)"YCbCrSubSampling"}, 
        {(unsigned short)531, (char *)"YCbCrPositioning"}, 
        {(unsigned short)532, (char *)"ReferenceBlackWhite"}, 
        {(unsigned short)4097, (char *)"RelatedImageWidth"}, 
        {(unsigned short)4098, (char *)"RelatedImageLength"}, 
        {(unsigned short)33421, (char *)"CFARepeatPatternDim"}, 
        {(unsigned short)33422, (char *)"CFAPattern"}, 
        {(unsigned short)33423, (char *)"BatteryLevel"}, 
        {(unsigned short)33432, (char *)"Copyright"}, 
        {(unsigned short)33434, (char *)"ExposureTime"}, 
        {(unsigned short)33437, (char *)"FNumber"}, 
        {(unsigned short)33723, (char *)"IPTC/NAA"}, 
        {(unsigned short)34665, (char *)"ExifOffset"}, 
        {(unsigned short)34675, (char *)"InterColorProfile"}, 
        {(unsigned short)34850, (char *)"ExposureProgram"}, 
        {(unsigned short)34852, (char *)"SpectralSensitivity"}, 
        {(unsigned short)34853, (char *)"GPS Dir offset"}, 
        {(unsigned short)34855, (char *)"ISOSpeedRatings"}, 
        {(unsigned short)34856, (char *)"OECF"}, 
        {(unsigned short)36864, (char *)"ExifVersion"}, 
        {(unsigned short)36867, (char *)"DateTimeOriginal"}, 
        {(unsigned short)36868, (char *)"DateTimeDigitized"}, 
        {(unsigned short)37121, (char *)"ComponentsConfiguration"}, 
        {(unsigned short)37122, (char *)"CompressedBitsPerPixel"}, 
        {(unsigned short)37377, (char *)"ShutterSpeedValue"}, 
        {(unsigned short)37378, (char *)"ApertureValue"}, 
        {(unsigned short)37379, (char *)"BrightnessValue"}, 
        {(unsigned short)37380, (char *)"ExposureBiasValue"}, 
        {(unsigned short)37381, (char *)"MaxApertureValue"}, 
        {(unsigned short)37382, (char *)"SubjectDistance"}, 
        {(unsigned short)37383, (char *)"MeteringMode"}, 
        {(unsigned short)37384, (char *)"LightSource"}, 
        {(unsigned short)37385, (char *)"Flash"}, 
        {(unsigned short)37386, (char *)"FocalLength"}, 
        {(unsigned short)37500, (char *)"MakerNote"}, 
        {(unsigned short)37510, (char *)"UserComment"}, 
        {(unsigned short)37520, (char *)"SubSecTime"}, 
        {(unsigned short)37521, (char *)"SubSecTimeOriginal"}, 
        {(unsigned short)37522, (char *)"SubSecTimeDigitized"}, 
        {(unsigned short)40091, (char *)"Windows-XP Title"}, 
        {(unsigned short)40092, (char *)"Windows-XP comment"}, 
        {(unsigned short)40093, (char *)"Windows-XP author"}, 
        {(unsigned short)40094, (char *)"Windows-XP keywords"}, 
        {(unsigned short)40095, (char *)"Windows-XP subject"}, 
        {(unsigned short)40960, (char *)"FlashPixVersion"}, 
        {(unsigned short)40961, (char *)"ColorSpace"}, 
        {(unsigned short)40962, (char *)"ExifImageWidth"}, 
        {(unsigned short)40963, (char *)"ExifImageLength"}, 
        {(unsigned short)40964, (char *)"RelatedAudioFile"}, 
        {(unsigned short)40965, (char *)"InteroperabilityOffset"}, 
        {(unsigned short)41483, (char *)"FlashEnergy"}, 
        {(unsigned short)41484, (char *)"SpatialFrequencyResponse"}, 
        {(unsigned short)41486, (char *)"FocalPlaneXResolution"}, 
        {(unsigned short)41487, (char *)"FocalPlaneYResolution"}, 
        {(unsigned short)41488, (char *)"FocalPlaneResolutionUnit"}, 
        {(unsigned short)41492, (char *)"SubjectLocation"}, 
        {(unsigned short)41493, (char *)"ExposureIndex"}, 
        {(unsigned short)41495, (char *)"SensingMethod"}, 
        {(unsigned short)41728, (char *)"FileSource"}, 
        {(unsigned short)41729, (char *)"SceneType"}, 
        {(unsigned short)41730, (char *)"CFA Pattern"}, 
        {(unsigned short)41985, (char *)"CustomRendered"}, 
        {(unsigned short)41986, (char *)"ExposureMode"}, 
        {(unsigned short)41987, (char *)"WhiteBalance"}, 
        {(unsigned short)41988, (char *)"DigitalZoomRatio"}, 
        {(unsigned short)41989, (char *)"FocalLengthIn35mmFilm"}, 
        {(unsigned short)37396, (char *)"SubjectArea"}, 
        {(unsigned short)41990, (char *)"SceneCaptureType"}, 
        {(unsigned short)41991, (char *)"GainControl"}, 
        {(unsigned short)41992, (char *)"Contrast"}, 
        {(unsigned short)41993, (char *)"Saturation"}, 
        {(unsigned short)41994, (char *)"Sharpness"}, 
        {(unsigned short)41996, (char *)"SubjectDistanceRange"}, 
        {(unsigned short)42016, (char *)"ImageUniqueId"}};
#line 304 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static void Put16u(void *Short , unsigned short PutValue ) 
{ 


  {
#line 306
  if (MotorolaOrder) {
#line 307
    *((uchar *)Short + 0) = (uchar )((int )PutValue >> 8);
#line 308
    *((uchar *)Short + 1) = (uchar )PutValue;
  } else {
#line 310
    *((uchar *)Short + 0) = (uchar )PutValue;
#line 311
    *((uchar *)Short + 1) = (uchar )((int )PutValue >> 8);
  }
#line 313
  return;
}
}
#line 318 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
int Get16u(void *Short ) 
{ 


  {
#line 320
  if (MotorolaOrder) {
#line 321
    return (((int )*((uchar *)Short + 0) << 8) | (int )*((uchar *)Short + 1));
  } else {
#line 323
    return (((int )*((uchar *)Short + 1) << 8) | (int )*((uchar *)Short + 0));
  }
}
}
#line 330 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
int Get32s(void *Long ) 
{ 


  {
#line 332
  if (MotorolaOrder) {
#line 333
    return (((((int )*((char *)Long + 0) << 24) | ((int )*((uchar *)Long + 1) << 16)) | ((int )*((uchar *)Long + 2) << 8)) | (int )*((uchar *)Long + 3));
  } else {
#line 336
    return (((((int )*((char *)Long + 3) << 24) | ((int )*((uchar *)Long + 2) << 16)) | ((int )*((uchar *)Long + 1) << 8)) | (int )*((uchar *)Long + 0));
  }
}
}
#line 344 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
void Put32u(void *Value , unsigned int PutValue ) 
{ 


  {
#line 346
  if (MotorolaOrder) {
#line 347
    *((uchar *)Value + 0) = (uchar )(PutValue >> 24);
#line 348
    *((uchar *)Value + 1) = (uchar )(PutValue >> 16);
#line 349
    *((uchar *)Value + 2) = (uchar )(PutValue >> 8);
#line 350
    *((uchar *)Value + 3) = (uchar )PutValue;
  } else {
#line 352
    *((uchar *)Value + 0) = (uchar )PutValue;
#line 353
    *((uchar *)Value + 1) = (uchar )(PutValue >> 8);
#line 354
    *((uchar *)Value + 2) = (uchar )(PutValue >> 16);
#line 355
    *((uchar *)Value + 3) = (uchar )(PutValue >> 24);
  }
#line 357
  return;
}
}
#line 362 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
unsigned int Get32u(void *Long ) 
{ 
  int tmp ;

  {
  {
#line 364
  tmp = Get32s(Long);
  }
#line 364
  return ((unsigned int )tmp & 4294967295U);
}
}
#line 370 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
void PrintFormatNumber(void *ValuePtr , int Format , int ByteCount ) 
{ 
  int s ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 374
  n = 0;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (n < 16)) {
#line 374
      goto while_break;
    }
    {
#line 377
    if (Format == 1) {
#line 377
      goto case_1;
    }
#line 377
    if (Format == 6) {
#line 377
      goto case_1;
    }
#line 378
    if (Format == 3) {
#line 378
      goto case_3;
    }
#line 380
    if (Format == 9) {
#line 380
      goto case_9;
    }
#line 380
    if (Format == 4) {
#line 380
      goto case_9;
    }
#line 381
    if (Format == 8) {
#line 381
      goto case_8;
    }
#line 382
    if (Format == 5) {
#line 382
      goto case_5;
    }
#line 387
    if (Format == 10) {
#line 387
      goto case_10;
    }
#line 392
    if (Format == 11) {
#line 392
      goto case_11;
    }
#line 393
    if (Format == 12) {
#line 393
      goto case_12;
    }
#line 394
    goto switch_default;
    case_1: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 377
    printf((char const   */* __restrict  */)"%02x", (int )*((uchar *)ValuePtr));
#line 377
    s = 1;
    }
#line 377
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 378
    tmp = Get16u(ValuePtr);
#line 378
    printf((char const   */* __restrict  */)"%d", tmp);
#line 378
    s = 2;
    }
#line 378
    goto switch_break;
    case_9: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 380
    tmp___0 = Get32s(ValuePtr);
#line 380
    printf((char const   */* __restrict  */)"%d", tmp___0);
#line 380
    s = 4;
    }
#line 380
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 381
    tmp___1 = Get16u(ValuePtr);
#line 381
    printf((char const   */* __restrict  */)"%hd", (int )((short )tmp___1));
#line 381
    s = 2;
    }
#line 381
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 383
    tmp___2 = Get32s((void *)((char *)ValuePtr + 4));
#line 383
    tmp___3 = Get32s(ValuePtr);
#line 383
    printf((char const   */* __restrict  */)"%u/%u", tmp___3, tmp___2);
#line 384
    s = 8;
    }
#line 385
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 388
    tmp___4 = Get32s((void *)((char *)ValuePtr + 4));
#line 388
    tmp___5 = Get32s(ValuePtr);
#line 388
    printf((char const   */* __restrict  */)"%d/%d", tmp___5, tmp___4);
#line 389
    s = 8;
    }
#line 390
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 392
    printf((char const   */* __restrict  */)"%f", (double )*((float *)ValuePtr));
#line 392
    s = 8;
    }
#line 392
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 393
    printf((char const   */* __restrict  */)"%f", *((double *)ValuePtr));
#line 393
    s = 8;
    }
#line 393
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 395
    printf((char const   */* __restrict  */)"Unknown format %d:", Format);
    }
#line 396
    return;
    switch_break: /* CIL Label */ ;
    }
#line 398
    ByteCount -= s;
#line 399
    if (ByteCount <= 0) {
#line 399
      goto while_break;
    }
    {
#line 400
    printf((char const   */* __restrict  */)", ");
#line 401
    ValuePtr = (void *)((char *)ValuePtr + s);
#line 374
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  if (n >= 16) {
    {
#line 404
    printf((char const   */* __restrict  */)"...");
    }
  }
#line 405
  return;
}
}
#line 411 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
double ConvertAnyFormat(void *ValuePtr , int Format ) 
{ 
  double Value ;
  int tmp ;
  unsigned int tmp___0 ;
  int Num ;
  int Den ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 414
  Value = (double )0;
  {
#line 417
  if (Format == 6) {
#line 417
    goto case_6;
  }
#line 418
  if (Format == 1) {
#line 418
    goto case_1;
  }
#line 420
  if (Format == 3) {
#line 420
    goto case_3;
  }
#line 421
  if (Format == 4) {
#line 421
    goto case_4;
  }
#line 424
  if (Format == 10) {
#line 424
    goto case_10;
  }
#line 424
  if (Format == 5) {
#line 424
    goto case_10;
  }
#line 441
  if (Format == 8) {
#line 441
    goto case_8;
  }
#line 442
  if (Format == 9) {
#line 442
    goto case_9;
  }
#line 445
  if (Format == 11) {
#line 445
    goto case_11;
  }
#line 446
  if (Format == 12) {
#line 446
    goto case_12;
  }
#line 448
  goto switch_default;
  case_6: /* CIL Label */ 
#line 417
  Value = (double )*((signed char *)ValuePtr);
#line 417
  goto switch_break;
  case_1: /* CIL Label */ 
#line 418
  Value = (double )*((uchar *)ValuePtr);
#line 418
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 420
  tmp = Get16u(ValuePtr);
#line 420
  Value = (double )tmp;
  }
#line 420
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 421
  tmp___0 = Get32u(ValuePtr);
#line 421
  Value = (double )tmp___0;
  }
#line 421
  goto switch_break;
  case_10: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 427
  Num = Get32s(ValuePtr);
#line 428
  Den = Get32s((void *)((char *)ValuePtr + 4));
  }
#line 429
  if (Den == 0) {
#line 430
    Value = (double )0;
  } else
#line 432
  if (Format == 10) {
#line 433
    Value = (double )Num / (double )Den;
  } else {
#line 435
    Value = (double )((unsigned int )Num) / (double )((unsigned int )Den);
  }
#line 438
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 441
  tmp___1 = Get16u(ValuePtr);
#line 441
  Value = (double )((short )tmp___1);
  }
#line 441
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 442
  tmp___2 = Get32s(ValuePtr);
#line 442
  Value = (double )tmp___2;
  }
#line 442
  goto switch_break;
  case_11: /* CIL Label */ 
#line 445
  Value = (double )*((float *)ValuePtr);
#line 445
  goto switch_break;
  case_12: /* CIL Label */ 
#line 446
  Value = *((double *)ValuePtr);
#line 446
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 449
  ErrNonfatal("Illegal format code %d in Exif header", Format, 0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 451
  return (Value);
}
}
#line 457 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static void ProcessExifDir(unsigned char *DirStart , unsigned char *OffsetBase , unsigned int ExifLength ,
                           int NestingLevel ) 
{ 
  int de ;
  int a ;
  int NumDirEntries ;
  unsigned int ThumbnailOffset ;
  unsigned int ThumbnailSize ;
  char IndentString[25] ;
  unsigned char *DirEnd ;
  int Tag ;
  int Format ;
  int Components ;
  unsigned char *ValuePtr ;
  int ByteCount ;
  unsigned char *DirEntry ;
  unsigned int tmp ;
  unsigned int OffsetVal ;
  int NoPrint ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int msiz ;
  int c ;
  int tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___27 ;
  double tmp___28 ;
  double tmp___29 ;
  unsigned char *SubdirStart ;
  unsigned int tmp___30 ;
  unsigned char *SubdirStart___0 ;
  unsigned int tmp___31 ;
  double tmp___32 ;
  double tmp___33 ;
  double tmp___34 ;
  double tmp___35 ;
  double tmp___36 ;
  unsigned char *SubdirStart___1 ;
  unsigned int Offset ;

  {
#line 463
  ThumbnailOffset = 0U;
#line 464
  ThumbnailSize = 0U;
#line 467
  if (NestingLevel > 4) {
    {
#line 468
    ErrNonfatal("Maximum Exif directory nesting exceeded (corrupt Exif header)", 0,
                0);
    }
#line 469
    return;
  }
  {
#line 472
  memset((void *)(IndentString), ' ', (size_t )25);
#line 473
  IndentString[NestingLevel * 4] = (char )'\000';
#line 476
  NumDirEntries = Get16u((void *)DirStart);
#line 481
  DirEnd = (DirStart + 2) + 12 * NumDirEntries;
  }
#line 482
  if ((unsigned long )(DirEnd + 4) > (unsigned long )(OffsetBase + ExifLength)) {
#line 483
    if (! ((unsigned long )(DirEnd + 2) == (unsigned long )(OffsetBase + ExifLength))) {
#line 483
      if (! ((unsigned long )DirEnd == (unsigned long )(OffsetBase + ExifLength))) {
        {
#line 487
        ErrNonfatal("Illegally sized Exif subdirectory (%d entries)", NumDirEntries,
                    0);
        }
#line 488
        return;
      }
    }
  }
#line 491
  if (DumpExifMap) {
    {
#line 492
    printf((char const   */* __restrict  */)"Map: %05u-%05u: Directory\n", (int )(DirStart - OffsetBase),
           (int )((DirEnd + 4) - OffsetBase));
    }
  }
#line 498
  if (ShowTags) {
    {
#line 499
    printf((char const   */* __restrict  */)"(dir has %d entries)\n", NumDirEntries);
    }
  }
#line 502
  de = 0;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! (de < NumDirEntries)) {
#line 502
      goto while_break;
    }
    {
#line 507
    DirEntry = (DirStart + 2) + 12 * de;
#line 509
    Tag = Get16u((void *)DirEntry);
#line 510
    Format = Get16u((void *)(DirEntry + 2));
#line 511
    tmp = Get32u((void *)(DirEntry + 4));
#line 511
    Components = (int )tmp;
    }
#line 513
    if (Format - 1 >= 12) {
      {
#line 515
      ErrNonfatal("Illegal number format %d for tag %04x in Exif", Format, Tag);
      }
#line 516
      goto __Cont;
    }
#line 519
    if ((unsigned int )Components > 65536U) {
      {
#line 520
      ErrNonfatal("Too many components %d for tag %04x in Exif", Components, Tag);
      }
#line 521
      goto __Cont;
    }
#line 524
    ByteCount = Components * (int )BytesPerFormat[Format];
#line 526
    if (ByteCount > 4) {
      {
#line 528
      OffsetVal = Get32u((void *)(DirEntry + 8));
      }
#line 530
      if (OffsetVal + (unsigned int )ByteCount > ExifLength) {
        {
#line 532
        ErrNonfatal("Illegal value pointer for tag %04x in Exif", Tag, 0);
        }
#line 533
        goto __Cont;
      }
#line 535
      ValuePtr = OffsetBase + OffsetVal;
#line 537
      if (OffsetVal > ImageInfo.LargestExifOffset) {
#line 538
        ImageInfo.LargestExifOffset = OffsetVal;
      }
#line 541
      if (DumpExifMap) {
        {
#line 542
        printf((char const   */* __restrict  */)"Map: %05u-%05u:   Data for tag %04x\n",
               OffsetVal, OffsetVal + (unsigned int )ByteCount, Tag);
        }
      }
    } else {
#line 546
      ValuePtr = DirEntry + 8;
    }
#line 549
    if (Tag == 37500) {
#line 550
      if (ShowTags) {
        {
#line 551
        printf((char const   */* __restrict  */)"%s    Maker note: ", IndentString);
        }
      }
      {
#line 553
      ProcessMakerNote(ValuePtr, ByteCount, OffsetBase, ExifLength);
      }
#line 554
      goto __Cont;
    }
#line 557
    if (ShowTags) {
#line 559
      a = 0;
      {
#line 559
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 560
        if ((unsigned long )a >= sizeof(TagTable) / sizeof(TagTable_t )) {
          {
#line 561
          printf((char const   */* __restrict  */)"%s    Unknown Tag %04x Value = ",
                 IndentString, Tag);
          }
#line 562
          goto while_break___0;
        }
#line 564
        if ((int const   )TagTable[a].Tag == (int const   )Tag) {
          {
#line 565
          printf((char const   */* __restrict  */)"%s    %s = ", IndentString, TagTable[a].Desc);
          }
#line 566
          goto while_break___0;
        }
#line 559
        a ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 572
      if (Format == 1) {
#line 572
        goto case_1;
      }
#line 584
      if (Format == 2) {
#line 584
        goto case_2;
      }
#line 584
      if (Format == 7) {
#line 584
        goto case_2;
      }
#line 606
      goto switch_default;
      case_1: /* CIL Label */ 
#line 573
      if (ByteCount > 1) {
        {
#line 574
        printf((char const   */* __restrict  */)"%.*ls\n", ByteCount / 2, (wchar_t *)ValuePtr);
        }
      } else {
        {
#line 576
        PrintFormatNumber((void *)ValuePtr, Format, ByteCount);
#line 577
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 579
      goto switch_break;
      case_2: /* CIL Label */ 
      case_7: /* CIL Label */ 
      {
#line 587
      NoPrint = 0;
#line 588
      printf((char const   */* __restrict  */)"\"");
#line 589
      a = 0;
      }
      {
#line 589
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 589
        if (! (a < ByteCount)) {
#line 589
          goto while_break___1;
        }
#line 590
        if ((int )*(ValuePtr + a) >= 32) {
          {
#line 591
          putchar((int )*(ValuePtr + a));
#line 592
          NoPrint = 0;
          }
        } else
#line 596
        if (! NoPrint) {
#line 596
          if (a != ByteCount - 1) {
            {
#line 597
            putchar('?');
#line 598
            NoPrint = 1;
            }
          }
        }
#line 589
        a ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 602
      printf((char const   */* __restrict  */)"\"\n");
      }
#line 604
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 608
      PrintFormatNumber((void *)ValuePtr, Format, ByteCount);
#line 609
      printf((char const   */* __restrict  */)"\n");
      }
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 616
    if (Tag == 271) {
#line 616
      goto case_271;
    }
#line 620
    if (Tag == 272) {
#line 620
      goto case_272;
    }
#line 624
    if (Tag == 36867) {
#line 624
      goto case_36867;
    }
#line 630
    if (Tag == 306) {
#line 630
      goto case_306;
    }
#line 630
    if (Tag == 36868) {
#line 630
      goto case_306;
    }
#line 645
    if (Tag == 40092) {
#line 645
      goto case_40092;
    }
#line 659
    if (Tag == 37510) {
#line 659
      goto case_37510;
    }
#line 696
    if (Tag == 33437) {
#line 696
      goto case_33437;
    }
#line 703
    if (Tag == 37381) {
#line 703
      goto case_37381;
    }
#line 703
    if (Tag == 37378) {
#line 703
      goto case_37381;
    }
#line 712
    if (Tag == 37386) {
#line 712
      goto case_37386;
    }
#line 718
    if (Tag == 37382) {
#line 718
      goto case_37382;
    }
#line 724
    if (Tag == 33434) {
#line 724
      goto case_33434;
    }
#line 730
    if (Tag == 37377) {
#line 730
      goto case_37377;
    }
#line 740
    if (Tag == 37385) {
#line 740
      goto case_37385;
    }
#line 744
    if (Tag == 274) {
#line 744
      goto case_274;
    }
#line 763
    if (Tag == 40962) {
#line 763
      goto case_40962;
    }
#line 763
    if (Tag == 40963) {
#line 763
      goto case_40962;
    }
#line 770
    if (Tag == 41486) {
#line 770
      goto case_41486;
    }
#line 774
    if (Tag == 41488) {
#line 774
      goto case_41488;
    }
#line 790
    if (Tag == 37380) {
#line 790
      goto case_37380;
    }
#line 794
    if (Tag == 41987) {
#line 794
      goto case_41987;
    }
#line 798
    if (Tag == 37384) {
#line 798
      goto case_37384;
    }
#line 802
    if (Tag == 37383) {
#line 802
      goto case_37383;
    }
#line 806
    if (Tag == 34850) {
#line 806
      goto case_34850;
    }
#line 810
    if (Tag == 41493) {
#line 810
      goto case_41493;
    }
#line 819
    if (Tag == 41986) {
#line 819
      goto case_41986;
    }
#line 823
    if (Tag == 34855) {
#line 823
      goto case_34855;
    }
#line 827
    if (Tag == 41988) {
#line 827
      goto case_41988;
    }
#line 831
    if (Tag == 513) {
#line 831
      goto case_513;
    }
#line 836
    if (Tag == 514) {
#line 836
      goto case_514;
    }
#line 841
    if (Tag == 34665) {
#line 841
      goto case_34665;
    }
#line 844
    if (Tag == 40965) {
#line 844
      goto case_40965;
    }
#line 858
    if (Tag == 34853) {
#line 858
      goto case_34853;
    }
#line 872
    if (Tag == 41989) {
#line 872
      goto case_41989;
    }
#line 879
    if (Tag == 41996) {
#line 879
      goto case_41996;
    }
#line 887
    if (Tag == 282) {
#line 887
      goto case_282;
    }
#line 895
    if (Tag == 283) {
#line 895
      goto case_283;
    }
#line 903
    if (Tag == 296) {
#line 903
      goto case_296;
    }
#line 614
    goto switch_break___0;
    case_271: /* CIL Label */ 
#line 617
    if (ByteCount < 31) {
#line 617
      tmp___0 = ByteCount;
    } else {
#line 617
      tmp___0 = 31;
    }
    {
#line 617
    strncpy((char */* __restrict  */)(ImageInfo.CameraMake), (char const   */* __restrict  */)((char *)ValuePtr),
            (size_t )tmp___0);
    }
#line 618
    goto switch_break___0;
    case_272: /* CIL Label */ 
#line 621
    if (ByteCount < 39) {
#line 621
      tmp___1 = ByteCount;
    } else {
#line 621
      tmp___1 = 39;
    }
    {
#line 621
    strncpy((char */* __restrict  */)(ImageInfo.CameraModel), (char const   */* __restrict  */)((char *)ValuePtr),
            (size_t )tmp___1);
    }
#line 622
    goto switch_break___0;
    case_36867: /* CIL Label */ 
    {
#line 626
    strncpy((char */* __restrict  */)(ImageInfo.DateTime), (char const   */* __restrict  */)((char *)ValuePtr),
            (size_t )19);
    }
    case_306: /* CIL Label */ 
    case_36868: /* CIL Label */ 
    {
#line 631
    tmp___2 = __ctype_b_loc();
    }
#line 631
    if (! ((int const   )*(*tmp___2 + (int )ImageInfo.DateTime[0]) & 2048)) {
      {
#line 634
      strncpy((char */* __restrict  */)(ImageInfo.DateTime), (char const   */* __restrict  */)((char *)ValuePtr),
              (size_t )19);
      }
    }
#line 637
    if (ImageInfo.numDateTimeTags >= 10) {
      {
#line 638
      ErrNonfatal("More than %d date fields in Exif.  This is nuts", 10, 0);
      }
#line 639
      goto switch_break___0;
    }
#line 641
    tmp___3 = ImageInfo.numDateTimeTags;
#line 641
    (ImageInfo.numDateTimeTags) ++;
#line 641
    ImageInfo.DateTimeOffsets[tmp___3] = (int )((char *)ValuePtr - (char *)OffsetBase);
#line 643
    goto switch_break___0;
    case_40092: /* CIL Label */ 
#line 646
    if (ImageInfo.Comments[0]) {
#line 648
      if (ShowTags) {
        {
#line 648
        printf((char const   */* __restrict  */)"Windows XP commend and other comment in header\n");
        }
      }
#line 649
      goto switch_break___0;
    }
#line 652
    if (ByteCount > 1) {
#line 653
      if (ByteCount > 16000) {
#line 653
        ByteCount = 16000;
      }
      {
#line 654
      memcpy((void */* __restrict  */)(ImageInfo.Comments), (void const   */* __restrict  */)ValuePtr,
             (size_t )ByteCount);
#line 655
      ImageInfo.CommentWidthchars = ByteCount / 2;
      }
    }
#line 657
    goto switch_break___0;
    case_37510: /* CIL Label */ 
#line 660
    if (ImageInfo.Comments[0]) {
#line 662
      if (ShowTags) {
        {
#line 662
        printf((char const   */* __restrict  */)"Multiple comments in exif header\n");
        }
      }
#line 663
      goto switch_break___0;
    }
#line 667
    a = ByteCount;
    {
#line 667
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 668
      a --;
#line 669
      if ((int )*(ValuePtr + a) == 32) {
#line 670
        *(ValuePtr + a) = (unsigned char )'\000';
      } else {
#line 672
        goto while_break___2;
      }
#line 674
      if (a == 0) {
#line 674
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 679
    msiz = (int )((long )ExifLength - (ValuePtr - OffsetBase));
#line 680
    if (msiz > ByteCount) {
#line 680
      msiz = ByteCount;
    }
#line 681
    if (msiz > 15999) {
#line 681
      msiz = 15999;
    }
#line 682
    if (msiz > 5) {
      {
#line 682
      tmp___4 = memcmp((void const   *)ValuePtr, (void const   *)"ASCII", (size_t )5);
      }
#line 682
      if (tmp___4 == 0) {
#line 683
        a = 5;
        {
#line 683
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 683
          if (a < 10) {
#line 683
            if (! (a < msiz)) {
#line 683
              goto while_break___3;
            }
          } else {
#line 683
            goto while_break___3;
          }
#line 684
          c = (int )*(ValuePtr + a);
#line 685
          if (c != 0) {
#line 685
            if (c != 32) {
              {
#line 686
              strncpy((char */* __restrict  */)(ImageInfo.Comments), (char const   */* __restrict  */)((char *)ValuePtr + a),
                      (size_t )(msiz - a));
              }
#line 687
              goto while_break___3;
            }
          }
#line 683
          a ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
        {
#line 691
        strncpy((char */* __restrict  */)(ImageInfo.Comments), (char const   */* __restrict  */)((char *)ValuePtr),
                (size_t )msiz);
        }
      }
    } else {
      {
#line 691
      strncpy((char */* __restrict  */)(ImageInfo.Comments), (char const   */* __restrict  */)((char *)ValuePtr),
              (size_t )msiz);
      }
    }
#line 694
    goto switch_break___0;
    case_33437: /* CIL Label */ 
    {
#line 699
    tmp___5 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 699
    ImageInfo.ApertureFNumber = (float )tmp___5;
    }
#line 700
    goto switch_break___0;
    case_37381: /* CIL Label */ 
    case_37378: /* CIL Label */ 
#line 706
    if (ImageInfo.ApertureFNumber == (float )0) {
      {
#line 707
      tmp___6 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 707
      tmp___7 = log((double )2);
#line 707
      tmp___8 = exp((tmp___6 * tmp___7) * 0.5);
#line 707
      ImageInfo.ApertureFNumber = (float )tmp___8;
      }
    }
#line 710
    goto switch_break___0;
    case_37386: /* CIL Label */ 
    {
#line 715
    tmp___9 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 715
    ImageInfo.FocalLength = (float )tmp___9;
    }
#line 716
    goto switch_break___0;
    case_37382: /* CIL Label */ 
    {
#line 721
    tmp___10 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 721
    ImageInfo.Distance = (float )tmp___10;
    }
#line 722
    goto switch_break___0;
    case_33434: /* CIL Label */ 
    {
#line 727
    tmp___11 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 727
    ImageInfo.ExposureTime = (float )tmp___11;
    }
#line 728
    goto switch_break___0;
    case_37377: /* CIL Label */ 
#line 733
    if (ImageInfo.ExposureTime == (float )0) {
      {
#line 734
      tmp___12 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 734
      tmp___13 = log((double )2);
#line 734
      tmp___14 = exp(tmp___12 * tmp___13);
#line 734
      ImageInfo.ExposureTime = (float )((double )1 / tmp___14);
      }
    }
#line 737
    goto switch_break___0;
    case_37385: /* CIL Label */ 
    {
#line 741
    tmp___15 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 741
    ImageInfo.FlashUsed = (int )tmp___15;
    }
#line 742
    goto switch_break___0;
    case_274: /* CIL Label */ 
#line 745
    if (NumOrientations >= 2) {
      {
#line 748
      ErrNonfatal("More than two orientation in Exif", 0, 0);
      }
#line 749
      goto switch_break___0;
    }
#line 751
    OrientationPtr[NumOrientations] = (void *)ValuePtr;
#line 752
    OrientationNumFormat[NumOrientations] = Format;
#line 753
    if (NumOrientations == 0) {
      {
#line 754
      tmp___16 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 754
      ImageInfo.Orientation = (int )tmp___16;
      }
    }
#line 756
    if (ImageInfo.Orientation < 0) {
      {
#line 757
      ErrNonfatal("Undefined rotation value %d in Exif", ImageInfo.Orientation, 0);
      }
    } else
#line 756
    if (ImageInfo.Orientation > 8) {
      {
#line 757
      ErrNonfatal("Undefined rotation value %d in Exif", ImageInfo.Orientation, 0);
      }
    }
#line 759
    NumOrientations ++;
#line 760
    goto switch_break___0;
    case_40962: /* CIL Label */ 
    case_40963: /* CIL Label */ 
    {
#line 766
    tmp___17 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 766
    a = (int )tmp___17;
    }
#line 767
    if (ExifImageWidth < a) {
#line 767
      ExifImageWidth = a;
    }
#line 768
    goto switch_break___0;
    case_41486: /* CIL Label */ 
    {
#line 771
    FocalplaneXRes = ConvertAnyFormat((void *)ValuePtr, Format);
    }
#line 772
    goto switch_break___0;
    case_41488: /* CIL Label */ 
    {
#line 775
    tmp___18 = ConvertAnyFormat((void *)ValuePtr, Format);
    }
    {
#line 776
    if ((int )tmp___18 == 1) {
#line 776
      goto case_1___0;
    }
#line 777
    if ((int )tmp___18 == 2) {
#line 777
      goto case_2___0;
    }
#line 784
    if ((int )tmp___18 == 3) {
#line 784
      goto case_3;
    }
#line 785
    if ((int )tmp___18 == 4) {
#line 785
      goto case_4;
    }
#line 786
    if ((int )tmp___18 == 5) {
#line 786
      goto case_5;
    }
#line 775
    goto switch_break___1;
    case_1___0: /* CIL Label */ 
#line 776
    FocalplaneUnits = 25.4;
#line 776
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
#line 781
    FocalplaneUnits = 25.4;
#line 782
    goto switch_break___1;
    case_3: /* CIL Label */ 
#line 784
    FocalplaneUnits = (double )10;
#line 784
    goto switch_break___1;
    case_4: /* CIL Label */ 
#line 785
    FocalplaneUnits = (double )1;
#line 785
    goto switch_break___1;
    case_5: /* CIL Label */ 
#line 786
    FocalplaneUnits = .001;
#line 786
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 788
    goto switch_break___0;
    case_37380: /* CIL Label */ 
    {
#line 791
    tmp___19 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 791
    ImageInfo.ExposureBias = (float )tmp___19;
    }
#line 792
    goto switch_break___0;
    case_41987: /* CIL Label */ 
    {
#line 795
    tmp___20 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 795
    ImageInfo.Whitebalance = (int )tmp___20;
    }
#line 796
    goto switch_break___0;
    case_37384: /* CIL Label */ 
    {
#line 799
    tmp___21 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 799
    ImageInfo.LightSource = (int )tmp___21;
    }
#line 800
    goto switch_break___0;
    case_37383: /* CIL Label */ 
    {
#line 803
    tmp___22 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 803
    ImageInfo.MeteringMode = (int )tmp___22;
    }
#line 804
    goto switch_break___0;
    case_34850: /* CIL Label */ 
    {
#line 807
    tmp___23 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 807
    ImageInfo.ExposureProgram = (int )tmp___23;
    }
#line 808
    goto switch_break___0;
    case_41493: /* CIL Label */ 
#line 811
    if (ImageInfo.ISOequivalent == 0) {
      {
#line 815
      tmp___24 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 815
      ImageInfo.ISOequivalent = (int )tmp___24;
      }
    }
#line 817
    goto switch_break___0;
    case_41986: /* CIL Label */ 
    {
#line 820
    tmp___25 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 820
    ImageInfo.ExposureMode = (int )tmp___25;
    }
#line 821
    goto switch_break___0;
    case_34855: /* CIL Label */ 
    {
#line 824
    tmp___26 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 824
    ImageInfo.ISOequivalent = (int )tmp___26;
    }
#line 825
    goto switch_break___0;
    case_41988: /* CIL Label */ 
    {
#line 828
    tmp___27 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 828
    ImageInfo.DigitalZoomRatio = (float )tmp___27;
    }
#line 829
    goto switch_break___0;
    case_513: /* CIL Label */ 
    {
#line 832
    tmp___28 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 832
    ThumbnailOffset = (unsigned int )tmp___28;
#line 833
    DirWithThumbnailPtrs = DirStart;
    }
#line 834
    goto switch_break___0;
    case_514: /* CIL Label */ 
    {
#line 837
    tmp___29 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 837
    ThumbnailSize = (unsigned int )tmp___29;
#line 838
    ImageInfo.ThumbnailSizeOffset = (int )(ValuePtr - OffsetBase);
    }
#line 839
    goto switch_break___0;
    case_34665: /* CIL Label */ 
#line 842
    if (ShowTags) {
      {
#line 842
      printf((char const   */* __restrict  */)"%s    Exif Dir:", IndentString);
      }
    }
    case_40965: /* CIL Label */ 
#line 845
    if (Tag == 40965) {
#line 845
      if (ShowTags) {
        {
#line 845
        printf((char const   */* __restrict  */)"%s    Interop Dir:", IndentString);
        }
      }
    }
    {
#line 848
    tmp___30 = Get32u((void *)ValuePtr);
#line 848
    SubdirStart = OffsetBase + tmp___30;
    }
#line 849
    if ((unsigned long )SubdirStart < (unsigned long )OffsetBase) {
      {
#line 850
      ErrNonfatal("Illegal Exif or interop ofset directory link", 0, 0);
      }
    } else
#line 849
    if ((unsigned long )SubdirStart > (unsigned long )(OffsetBase + ExifLength)) {
      {
#line 850
      ErrNonfatal("Illegal Exif or interop ofset directory link", 0, 0);
      }
    } else {
      {
#line 852
      ProcessExifDir(SubdirStart, OffsetBase, ExifLength, NestingLevel + 1);
      }
    }
#line 854
    goto __Cont;
#line 856
    goto switch_break___0;
    case_34853: /* CIL Label */ 
#line 859
    if (ShowTags) {
      {
#line 859
      printf((char const   */* __restrict  */)"%s    GPS info dir:", IndentString);
      }
    }
    {
#line 862
    tmp___31 = Get32u((void *)ValuePtr);
#line 862
    SubdirStart___0 = OffsetBase + tmp___31;
    }
#line 863
    if ((unsigned long )SubdirStart___0 < (unsigned long )OffsetBase) {
      {
#line 864
      ErrNonfatal("Illegal GPS directory link in Exif", 0, 0);
      }
    } else
#line 863
    if ((unsigned long )SubdirStart___0 > (unsigned long )(OffsetBase + ExifLength)) {
      {
#line 864
      ErrNonfatal("Illegal GPS directory link in Exif", 0, 0);
      }
    } else {
      {
#line 866
      ProcessGpsInfo(SubdirStart___0, OffsetBase, ExifLength);
      }
    }
#line 868
    goto __Cont;
#line 870
    goto switch_break___0;
    case_41989: /* CIL Label */ 
    {
#line 876
    tmp___32 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 876
    ImageInfo.FocalLength35mmEquiv = (int )((unsigned int )tmp___32);
    }
#line 877
    goto switch_break___0;
    case_41996: /* CIL Label */ 
    {
#line 882
    tmp___33 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 882
    ImageInfo.DistanceRange = (int )tmp___33;
    }
#line 883
    goto switch_break___0;
    case_282: /* CIL Label */ 
#line 888
    if (NestingLevel == 0) {
      {
#line 889
      tmp___34 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 889
      ImageInfo.xResolution = (float )tmp___34;
      }
#line 891
      if ((double )ImageInfo.yResolution == 0.0) {
#line 891
        ImageInfo.yResolution = ImageInfo.xResolution;
      }
    }
#line 893
    goto switch_break___0;
    case_283: /* CIL Label */ 
#line 896
    if (NestingLevel == 0) {
      {
#line 897
      tmp___35 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 897
      ImageInfo.yResolution = (float )tmp___35;
      }
#line 899
      if ((double )ImageInfo.xResolution == 0.0) {
#line 899
        ImageInfo.xResolution = ImageInfo.yResolution;
      }
    }
#line 901
    goto switch_break___0;
    case_296: /* CIL Label */ 
#line 904
    if (NestingLevel == 0) {
      {
#line 905
      tmp___36 = ConvertAnyFormat((void *)ValuePtr, Format);
#line 905
      ImageInfo.ResolutionUnit = (int )tmp___36;
      }
    }
#line 907
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 502
    de ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  if ((unsigned long )(((DirStart + 2) + 12 * NumDirEntries) + 4) <= (unsigned long )(OffsetBase + ExifLength)) {
    {
#line 921
    Offset = Get32u((void *)((DirStart + 2) + 12 * NumDirEntries));
    }
#line 922
    if (Offset) {
#line 923
      SubdirStart___1 = OffsetBase + Offset;
#line 924
      if ((unsigned long )SubdirStart___1 > (unsigned long )(OffsetBase + ExifLength)) {
#line 924
        goto _L;
      } else
#line 924
      if ((unsigned long )SubdirStart___1 < (unsigned long )OffsetBase) {
        _L: /* CIL Label */ 
#line 925
        if ((unsigned long )SubdirStart___1 > (unsigned long )OffsetBase) {
#line 925
          if ((unsigned long )SubdirStart___1 < (unsigned long )((OffsetBase + ExifLength) + 20)) {
#line 929
            if (ShowTags) {
              {
#line 929
              printf((char const   */* __restrict  */)"Thumbnail removed with Jhead 1.3 or earlier\n");
              }
            }
          } else {
            {
#line 931
            ErrNonfatal("Illegal subdirectory link in Exif header", 0, 0);
            }
          }
        } else {
          {
#line 931
          ErrNonfatal("Illegal subdirectory link in Exif header", 0, 0);
          }
        }
      } else
#line 934
      if ((unsigned long )SubdirStart___1 <= (unsigned long )(OffsetBase + ExifLength)) {
#line 935
        if (ShowTags) {
          {
#line 935
          printf((char const   */* __restrict  */)"%s    Continued directory ", IndentString);
          }
        }
        {
#line 936
        ProcessExifDir(SubdirStart___1, OffsetBase, ExifLength, NestingLevel + 1);
        }
      }
#line 939
      if (Offset > ImageInfo.LargestExifOffset) {
#line 940
        ImageInfo.LargestExifOffset = Offset;
      }
    }
  }
#line 948
  if (ThumbnailOffset) {
#line 949
    ImageInfo.ThumbnailAtEnd = (char)0;
#line 951
    if (DumpExifMap) {
      {
#line 952
      printf((char const   */* __restrict  */)"Map: %05d-%05d: Thumbnail\n", ThumbnailOffset,
             ThumbnailOffset + ThumbnailSize);
      }
    }
#line 955
    if (ThumbnailOffset <= ExifLength) {
#line 956
      if (ThumbnailSize > ExifLength - ThumbnailOffset) {
#line 960
        ThumbnailSize = ExifLength - ThumbnailOffset;
#line 961
        if (ShowTags) {
          {
#line 961
          printf((char const   */* __restrict  */)"Thumbnail incorrectly placed in header\n");
          }
        }
      }
#line 965
      ImageInfo.ThumbnailOffset = ThumbnailOffset;
#line 966
      ImageInfo.ThumbnailSize = ThumbnailSize;
#line 968
      if (ShowTags) {
        {
#line 969
        printf((char const   */* __restrict  */)"Thumbnail size: %u bytes\n", ThumbnailSize);
        }
      }
    }
  }
#line 973
  return;
}
}
#line 994 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
static uchar ExifHeader[7]  = {      (uchar )'E',      (uchar )'x',      (uchar )'i',      (uchar )'f', 
        (uchar )'\000',      (uchar )'\000',      (uchar )'\000'};
#line 980 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
void process_EXIF(unsigned char *ExifSection , unsigned int length ) 
{ 
  unsigned int FirstOffset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int a ;
  unsigned int b ;

  {
#line 984
  FocalplaneXRes = (double )0;
#line 985
  FocalplaneUnits = (double )0;
#line 986
  ExifImageWidth = 0;
#line 987
  NumOrientations = 0;
#line 989
  if (ShowTags) {
    {
#line 990
    printf((char const   */* __restrict  */)"Exif header %u bytes long\n", length);
    }
  }
  {
#line 995
  tmp = memcmp((void const   *)(ExifSection + 2), (void const   *)(ExifHeader), (size_t )6);
  }
#line 995
  if (tmp) {
    {
#line 996
    ErrNonfatal("Incorrect Exif header", 0, 0);
    }
#line 997
    return;
  }
  {
#line 1001
  tmp___1 = memcmp((void const   *)(ExifSection + 8), (void const   *)"II", (size_t )2);
  }
#line 1001
  if (tmp___1 == 0) {
#line 1002
    if (ShowTags) {
      {
#line 1002
      printf((char const   */* __restrict  */)"Exif section in Intel order\n");
      }
    }
#line 1003
    MotorolaOrder = 0;
  } else {
    {
#line 1005
    tmp___0 = memcmp((void const   *)(ExifSection + 8), (void const   *)"MM", (size_t )2);
    }
#line 1005
    if (tmp___0 == 0) {
#line 1006
      if (ShowTags) {
        {
#line 1006
        printf((char const   */* __restrict  */)"Exif section in Motorola order\n");
        }
      }
#line 1007
      MotorolaOrder = 1;
    } else {
      {
#line 1009
      ErrNonfatal("Invalid Exif alignment marker.", 0, 0);
      }
#line 1010
      return;
    }
  }
  {
#line 1015
  tmp___2 = Get16u((void *)(ExifSection + 10));
  }
#line 1015
  if (tmp___2 != 42) {
    {
#line 1016
    ErrNonfatal("Invalid Exif start (1)", 0, 0);
    }
#line 1017
    return;
  }
  {
#line 1020
  FirstOffset = Get32u((void *)(ExifSection + 12));
  }
#line 1021
  if (FirstOffset < 8U) {
#line 1021
    goto _L;
  } else
#line 1021
  if (FirstOffset > 16U) {
    _L: /* CIL Label */ 
#line 1022
    if (FirstOffset < 16U) {
      {
#line 1023
      ErrNonfatal("invalid offset for first Exif IFD value", 0, 0);
      }
#line 1024
      return;
    } else
#line 1022
    if (FirstOffset > length - 16U) {
      {
#line 1023
      ErrNonfatal("invalid offset for first Exif IFD value", 0, 0);
      }
#line 1024
      return;
    }
    {
#line 1027
    ErrNonfatal("Suspicious offset of first Exif IFD value", 0, 0);
    }
  }
  {
#line 1030
  DirWithThumbnailPtrs = (unsigned char *)((void *)0);
#line 1034
  ProcessExifDir((ExifSection + 8) + FirstOffset, ExifSection + 8, length - 8U, 0);
  }
#line 1036
  if (ImageInfo.ThumbnailOffset >= ImageInfo.LargestExifOffset) {
#line 1036
    ImageInfo.ThumbnailAtEnd = (char)1;
  } else {
#line 1036
    ImageInfo.ThumbnailAtEnd = (char)0;
  }
#line 1038
  if (DumpExifMap) {
    {
#line 1040
    printf((char const   */* __restrict  */)"Map: %05d- End of exif\n", length - 8U);
#line 1041
    a = 0U;
    }
    {
#line 1041
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1041
      if (! (a < length - 8U)) {
#line 1041
        goto while_break;
      }
      {
#line 1042
      printf((char const   */* __restrict  */)"Map: %05d ", a);
#line 1043
      b = 0U;
      }
      {
#line 1043
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1043
        if (! (b < 10U)) {
#line 1043
          goto while_break___0;
        }
        {
#line 1043
        printf((char const   */* __restrict  */)" %02x", (int )*(((ExifSection + 8) + a) + b));
#line 1043
        b ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1044
      printf((char const   */* __restrict  */)"\n");
#line 1041
      a += 10U;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1050
  if (FocalplaneXRes != (double )0) {
#line 1050
    if (ExifImageWidth != 0) {
#line 1055
      ImageInfo.CCDWidth = (float )(((double )ExifImageWidth * FocalplaneUnits) / FocalplaneXRes);
#line 1057
      if (ImageInfo.FocalLength) {
#line 1057
        if (ImageInfo.FocalLength35mmEquiv == 0) {
#line 1060
          ImageInfo.FocalLength35mmEquiv = (int )((double )((ImageInfo.FocalLength / ImageInfo.CCDWidth) * (float )36) + 0.5);
        }
      }
    }
  }
#line 1063
  return;
}
}
#line 1070 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
void create_EXIF(void) 
{ 
  char Buffer[256] ;
  unsigned short NumEntries ;
  int DataWriteIndex ;
  int DateIndex ;
  int DirIndex ;
  int DirContinuation ;
  unsigned char *NewBuf ;
  void *tmp ;

  {
  {
#line 1080
  MotorolaOrder = 0;
#line 1082
  memcpy((void */* __restrict  */)(Buffer + 2), (void const   */* __restrict  */)"Exif\000\000II",
         (size_t )8);
#line 1083
  Put16u((void *)(Buffer + 10), (unsigned short)42);
#line 1085
  DataWriteIndex = 16;
#line 1086
  Put32u((void *)(Buffer + 12), (unsigned int )(DataWriteIndex - 8));
#line 1089
  DirIndex = DataWriteIndex;
#line 1090
  NumEntries = (unsigned short)2;
#line 1091
  DataWriteIndex += (2 + (int )NumEntries * 12) + 4;
#line 1093
  Put16u((void *)(Buffer + DirIndex), NumEntries);
#line 1094
  DirIndex += 2;
#line 1099
  Put16u((void *)(Buffer + DirIndex), (unsigned short)306);
#line 1100
  Put16u((void *)((Buffer + DirIndex) + 2), (unsigned short)2);
#line 1101
  Put32u((void *)((Buffer + DirIndex) + 4), 20U);
#line 1102
  Put32u((void *)((Buffer + DirIndex) + 8), (unsigned int )(DataWriteIndex - 8));
#line 1103
  DirIndex += 12;
#line 1105
  DateIndex = DataWriteIndex;
  }
#line 1106
  if (ImageInfo.numDateTimeTags) {
    {
#line 1108
    memcpy((void */* __restrict  */)(Buffer + DataWriteIndex), (void const   */* __restrict  */)(ImageInfo.DateTime),
           (size_t )19);
#line 1109
    Buffer[DataWriteIndex + 19] = (char )'\000';
    }
  } else {
    {
#line 1112
    FileTimeAsString(Buffer + DataWriteIndex);
    }
  }
  {
#line 1114
  DataWriteIndex += 20;
#line 1117
  Put16u((void *)(Buffer + DirIndex), (unsigned short)34665);
#line 1118
  Put16u((void *)((Buffer + DirIndex) + 2), (unsigned short)4);
#line 1119
  Put32u((void *)((Buffer + DirIndex) + 4), 1U);
#line 1120
  Put32u((void *)((Buffer + DirIndex) + 8), (unsigned int )(DataWriteIndex - 8));
#line 1121
  DirIndex += 12;
#line 1125
  DirContinuation = DirIndex;
#line 1129
  DirIndex = DataWriteIndex;
#line 1130
  NumEntries = (unsigned short)1;
#line 1131
  DataWriteIndex += (2 + (int )NumEntries * 12) + 4;
#line 1133
  Put16u((void *)(Buffer + DirIndex), NumEntries);
#line 1134
  DirIndex += 2;
#line 1137
  Put16u((void *)(Buffer + DirIndex), (unsigned short)36867);
#line 1138
  Put16u((void *)((Buffer + DirIndex) + 2), (unsigned short)2);
#line 1139
  Put32u((void *)((Buffer + DirIndex) + 4), 20U);
#line 1140
  Put32u((void *)((Buffer + DirIndex) + 8), (unsigned int )(DataWriteIndex - 8));
#line 1141
  DirIndex += 12;
#line 1143
  memcpy((void */* __restrict  */)(Buffer + DataWriteIndex), (void const   */* __restrict  */)(Buffer + DateIndex),
         (size_t )20);
#line 1144
  DataWriteIndex += 20;
#line 1147
  Put32u((void *)(Buffer + DirIndex), 0U);
#line 1152
  Put32u((void *)(Buffer + DirContinuation), (unsigned int )(DataWriteIndex - 8));
#line 1153
  DirIndex = DataWriteIndex;
#line 1154
  NumEntries = (unsigned short)2;
#line 1155
  DataWriteIndex += (2 + (int )NumEntries * 12) + 4;
#line 1157
  Put16u((void *)(Buffer + DirIndex), NumEntries);
#line 1158
  DirIndex += 2;
#line 1161
  Put16u((void *)(Buffer + DirIndex), (unsigned short)513);
#line 1162
  Put16u((void *)((Buffer + DirIndex) + 2), (unsigned short)4);
#line 1163
  Put32u((void *)((Buffer + DirIndex) + 4), 1U);
#line 1164
  Put32u((void *)((Buffer + DirIndex) + 8), (unsigned int )(DataWriteIndex - 8));
#line 1165
  DirIndex += 12;
#line 1170
  Put16u((void *)(Buffer + DirIndex), (unsigned short)514);
#line 1171
  Put16u((void *)((Buffer + DirIndex) + 2), (unsigned short)4);
#line 1172
  Put32u((void *)((Buffer + DirIndex) + 4), 1U);
#line 1173
  Put32u((void *)((Buffer + DirIndex) + 8), 0U);
#line 1174
  DirIndex += 12;
#line 1178
  Put32u((void *)(Buffer + DirIndex), 0U);
#line 1182
  Buffer[0] = (char )((unsigned char )(DataWriteIndex >> 8));
#line 1183
  Buffer[1] = (char )((unsigned char )DataWriteIndex);
#line 1186
  RemoveSectionType(225);
#line 1191
  tmp = malloc((size_t )DataWriteIndex);
#line 1191
  NewBuf = (unsigned char *)tmp;
  }
#line 1192
  if ((unsigned long )NewBuf == (unsigned long )((void *)0)) {
    {
#line 1193
    ErrFatal("Could not allocate memory");
    }
  }
  {
#line 1195
  memcpy((void */* __restrict  */)NewBuf, (void const   */* __restrict  */)(Buffer),
         (size_t )DataWriteIndex);
#line 1197
  CreateSection(225, NewBuf, DataWriteIndex);
#line 1201
  process_EXIF(NewBuf, (unsigned int )DataWriteIndex);
  }
#line 1203
  return;
}
}
#line 1208 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
char const   *ClearOrientation(void) 
{ 
  int a ;

  {
#line 1211
  if (NumOrientations == 0) {
#line 1211
    return ((char const   *)((void *)0));
  }
#line 1213
  a = 0;
  {
#line 1213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1213
    if (! (a < NumOrientations)) {
#line 1213
      goto while_break;
    }
    {
#line 1216
    if (OrientationNumFormat[a] == 1) {
#line 1216
      goto case_1;
    }
#line 1216
    if (OrientationNumFormat[a] == 6) {
#line 1216
      goto case_1;
    }
#line 1220
    if (OrientationNumFormat[a] == 3) {
#line 1220
      goto case_3;
    }
#line 1225
    if (OrientationNumFormat[a] == 9) {
#line 1225
      goto case_9;
    }
#line 1225
    if (OrientationNumFormat[a] == 4) {
#line 1225
      goto case_9;
    }
#line 1235
    goto switch_default;
    case_1: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 1217
    *((uchar *)OrientationPtr[a]) = (uchar )1;
#line 1218
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1221
    Put16u(OrientationPtr[a], (unsigned short)1);
    }
#line 1222
    goto switch_break;
    case_9: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 1226
    memset(OrientationPtr[a], 0, (size_t )4);
    }
#line 1228
    if (MotorolaOrder) {
#line 1229
      *((uchar *)OrientationPtr[a] + 3) = (uchar )1;
    } else {
#line 1231
      *((uchar *)OrientationPtr[a] + 0) = (uchar )1;
    }
#line 1233
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1236
    return ((char const   *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
#line 1213
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1240
  if (ImageInfo.Orientation >= 1) {
#line 1240
    if (ImageInfo.Orientation <= 8) {
#line 1241
      return (OrientTab[ImageInfo.Orientation]);
    } else {
#line 1243
      return ((char const   *)((void *)0));
    }
  } else {
#line 1243
    return ((char const   *)((void *)0));
  }
}
}
#line 1250 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
int Exif2tm(struct tm *timeptr , char *ExifTime ) 
{ 
  int a ;
  int tmp ;

  {
  {
#line 1254
  timeptr->tm_wday = -1;
#line 1259
  timeptr->tm_sec = 0;
#line 1260
  a = sscanf((char const   */* __restrict  */)ExifTime, (char const   */* __restrict  */)"%d%*c%d%*c%d%*c%d:%d:%d",
             & timeptr->tm_year, & timeptr->tm_mon, & timeptr->tm_mday, & timeptr->tm_hour,
             & timeptr->tm_min, & timeptr->tm_sec);
  }
#line 1264
  if (a >= 5) {
#line 1265
    if (timeptr->tm_year <= 12) {
#line 1265
      if (timeptr->tm_mday > 2000) {
#line 1265
        if ((int )*(ExifTime + 2) == 46) {
#line 1270
          tmp = timeptr->tm_year;
#line 1271
          timeptr->tm_year = timeptr->tm_mday;
#line 1272
          timeptr->tm_mday = timeptr->tm_mon;
#line 1273
          timeptr->tm_mon = tmp;
        }
      }
    }
#line 1277
    timeptr->tm_isdst = -1;
#line 1278
    (timeptr->tm_mon) --;
#line 1279
    timeptr->tm_year -= 1900;
#line 1280
    return (1);
  }
#line 1283
  return (0);
}
}
#line 1291 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
void ShowImageInfo(int ShowFileInfo___0 ) 
{ 
  char Temp[20] ;
  unsigned int a ;
  int a___0 ;
  int c ;

  {
#line 1293
  if (ShowFileInfo___0) {
    {
#line 1294
    printf((char const   */* __restrict  */)"File name    : %s\n", ImageInfo.FileName);
#line 1295
    printf((char const   */* __restrict  */)"File size    : %d bytes\n", ImageInfo.FileSize);
#line 1299
    FileTimeAsString(Temp);
#line 1300
    printf((char const   */* __restrict  */)"File date    : %s\n", Temp);
    }
  }
#line 1304
  if (ImageInfo.CameraMake[0]) {
    {
#line 1305
    printf((char const   */* __restrict  */)"Camera make  : %s\n", ImageInfo.CameraMake);
#line 1306
    printf((char const   */* __restrict  */)"Camera model : %s\n", ImageInfo.CameraModel);
    }
  }
#line 1308
  if (ImageInfo.DateTime[0]) {
    {
#line 1309
    printf((char const   */* __restrict  */)"Date/Time    : %s\n", ImageInfo.DateTime);
    }
  }
  {
#line 1311
  printf((char const   */* __restrict  */)"Resolution   : %d x %d\n", ImageInfo.Width,
         ImageInfo.Height);
  }
#line 1313
  if (ImageInfo.Orientation > 1) {
#line 1313
    if (ImageInfo.Orientation <= 8) {
      {
#line 1315
      printf((char const   */* __restrict  */)"Orientation  : %s\n", OrientTab[ImageInfo.Orientation]);
      }
    }
  }
#line 1318
  if (ImageInfo.IsColor == 0) {
    {
#line 1319
    printf((char const   */* __restrict  */)"Color/bw     : Black and white\n");
    }
  }
#line 1322
  if (ImageInfo.FlashUsed >= 0) {
#line 1323
    if (ImageInfo.FlashUsed & 1) {
      {
#line 1324
      printf((char const   */* __restrict  */)"Flash used   : Yes");
      }
      {
#line 1326
      if (ImageInfo.FlashUsed == 5) {
#line 1326
        goto case_5;
      }
#line 1327
      if (ImageInfo.FlashUsed == 7) {
#line 1327
        goto case_7;
      }
#line 1328
      if (ImageInfo.FlashUsed == 9) {
#line 1328
        goto case_9;
      }
#line 1329
      if (ImageInfo.FlashUsed == 13) {
#line 1329
        goto case_13;
      }
#line 1330
      if (ImageInfo.FlashUsed == 15) {
#line 1330
        goto case_15;
      }
#line 1331
      if (ImageInfo.FlashUsed == 25) {
#line 1331
        goto case_25;
      }
#line 1332
      if (ImageInfo.FlashUsed == 29) {
#line 1332
        goto case_29;
      }
#line 1333
      if (ImageInfo.FlashUsed == 31) {
#line 1333
        goto case_31;
      }
#line 1334
      if (ImageInfo.FlashUsed == 65) {
#line 1334
        goto case_65;
      }
#line 1335
      if (ImageInfo.FlashUsed == 69) {
#line 1335
        goto case_69;
      }
#line 1336
      if (ImageInfo.FlashUsed == 71) {
#line 1336
        goto case_71;
      }
#line 1337
      if (ImageInfo.FlashUsed == 73) {
#line 1337
        goto case_73;
      }
#line 1338
      if (ImageInfo.FlashUsed == 77) {
#line 1338
        goto case_77;
      }
#line 1339
      if (ImageInfo.FlashUsed == 79) {
#line 1339
        goto case_79;
      }
#line 1340
      if (ImageInfo.FlashUsed == 89) {
#line 1340
        goto case_89;
      }
#line 1341
      if (ImageInfo.FlashUsed == 93) {
#line 1341
        goto case_93;
      }
#line 1342
      if (ImageInfo.FlashUsed == 95) {
#line 1342
        goto case_95;
      }
#line 1325
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 1326
      printf((char const   */* __restrict  */)" (Strobe light not detected)");
      }
#line 1326
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 1327
      printf((char const   */* __restrict  */)" (Strobe light detected) ");
      }
#line 1327
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 1328
      printf((char const   */* __restrict  */)" (manual)");
      }
#line 1328
      goto switch_break;
      case_13: /* CIL Label */ 
      {
#line 1329
      printf((char const   */* __restrict  */)" (manual, return light not detected)");
      }
#line 1329
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 1330
      printf((char const   */* __restrict  */)" (manual, return light  detected)");
      }
#line 1330
      goto switch_break;
      case_25: /* CIL Label */ 
      {
#line 1331
      printf((char const   */* __restrict  */)" (auto)");
      }
#line 1331
      goto switch_break;
      case_29: /* CIL Label */ 
      {
#line 1332
      printf((char const   */* __restrict  */)" (auto, return light not detected)");
      }
#line 1332
      goto switch_break;
      case_31: /* CIL Label */ 
      {
#line 1333
      printf((char const   */* __restrict  */)" (auto, return light detected)");
      }
#line 1333
      goto switch_break;
      case_65: /* CIL Label */ 
      {
#line 1334
      printf((char const   */* __restrict  */)" (red eye reduction mode)");
      }
#line 1334
      goto switch_break;
      case_69: /* CIL Label */ 
      {
#line 1335
      printf((char const   */* __restrict  */)" (red eye reduction mode return light not detected)");
      }
#line 1335
      goto switch_break;
      case_71: /* CIL Label */ 
      {
#line 1336
      printf((char const   */* __restrict  */)" (red eye reduction mode return light  detected)");
      }
#line 1336
      goto switch_break;
      case_73: /* CIL Label */ 
      {
#line 1337
      printf((char const   */* __restrict  */)" (manual, red eye reduction mode)");
      }
#line 1337
      goto switch_break;
      case_77: /* CIL Label */ 
      {
#line 1338
      printf((char const   */* __restrict  */)" (manual, red eye reduction mode, return light not detected)");
      }
#line 1338
      goto switch_break;
      case_79: /* CIL Label */ 
      {
#line 1339
      printf((char const   */* __restrict  */)" (red eye reduction mode, return light detected)");
      }
#line 1339
      goto switch_break;
      case_89: /* CIL Label */ 
      {
#line 1340
      printf((char const   */* __restrict  */)" (auto, red eye reduction mode)");
      }
#line 1340
      goto switch_break;
      case_93: /* CIL Label */ 
      {
#line 1341
      printf((char const   */* __restrict  */)" (auto, red eye reduction mode, return light not detected)");
      }
#line 1341
      goto switch_break;
      case_95: /* CIL Label */ 
      {
#line 1342
      printf((char const   */* __restrict  */)" (auto, red eye reduction mode, return light detected)");
      }
#line 1342
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1345
      printf((char const   */* __restrict  */)"Flash used   : No");
      }
      {
#line 1347
      if (ImageInfo.FlashUsed == 24) {
#line 1347
        goto case_24;
      }
#line 1346
      goto switch_break___0;
      case_24: /* CIL Label */ 
      {
#line 1347
      printf((char const   */* __restrict  */)" (auto)");
      }
#line 1347
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1350
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1354
  if (ImageInfo.FocalLength) {
    {
#line 1355
    printf((char const   */* __restrict  */)"Focal length : %4.1fmm", (double )ImageInfo.FocalLength);
    }
#line 1356
    if (ImageInfo.FocalLength35mmEquiv) {
      {
#line 1357
      printf((char const   */* __restrict  */)"  (35mm equivalent: %dmm)", ImageInfo.FocalLength35mmEquiv);
      }
    }
    {
#line 1359
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1362
  if (ImageInfo.DigitalZoomRatio > (float )1) {
    {
#line 1364
    printf((char const   */* __restrict  */)"Digital Zoom : %1.3fx\n", (double )ImageInfo.DigitalZoomRatio);
    }
  }
#line 1367
  if (ImageInfo.CCDWidth) {
    {
#line 1368
    printf((char const   */* __restrict  */)"CCD width    : %4.2fmm\n", (double )ImageInfo.CCDWidth);
    }
  }
#line 1371
  if (ImageInfo.ExposureTime) {
#line 1372
    if ((double )ImageInfo.ExposureTime < 0.010) {
      {
#line 1373
      printf((char const   */* __restrict  */)"Exposure time: %6.4f s ", (double )ImageInfo.ExposureTime);
      }
    } else {
      {
#line 1375
      printf((char const   */* __restrict  */)"Exposure time: %5.3f s ", (double )ImageInfo.ExposureTime);
      }
    }
#line 1377
    if ((double )ImageInfo.ExposureTime <= 0.5) {
      {
#line 1378
      printf((char const   */* __restrict  */)" (1/%d)", (int )(0.5 + (double )((float )1 / ImageInfo.ExposureTime)));
      }
    }
    {
#line 1380
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1382
  if (ImageInfo.ApertureFNumber) {
    {
#line 1383
    printf((char const   */* __restrict  */)"Aperture     : f/%3.1f\n", (double )ImageInfo.ApertureFNumber);
    }
  }
#line 1385
  if (ImageInfo.Distance) {
#line 1386
    if (ImageInfo.Distance < (float )0) {
      {
#line 1387
      printf((char const   */* __restrict  */)"Focus dist.  : Infinite\n");
      }
    } else {
      {
#line 1389
      printf((char const   */* __restrict  */)"Focus dist.  : %4.2fm\n", (double )ImageInfo.Distance);
      }
    }
  }
#line 1393
  if (ImageInfo.ISOequivalent) {
    {
#line 1394
    printf((char const   */* __restrict  */)"ISO equiv.   : %2d\n", ImageInfo.ISOequivalent);
    }
  }
#line 1397
  if (ImageInfo.ExposureBias) {
    {
#line 1400
    printf((char const   */* __restrict  */)"Exposure bias: %4.2f\n", (double )ImageInfo.ExposureBias);
    }
  }
  {
#line 1404
  if (ImageInfo.Whitebalance == 1) {
#line 1404
    goto case_1;
  }
#line 1407
  if (ImageInfo.Whitebalance == 0) {
#line 1407
    goto case_0;
  }
#line 1403
  goto switch_break___1;
  case_1: /* CIL Label */ 
  {
#line 1405
  printf((char const   */* __restrict  */)"Whitebalance : Manual\n");
  }
#line 1406
  goto switch_break___1;
  case_0: /* CIL Label */ 
  {
#line 1408
  printf((char const   */* __restrict  */)"Whitebalance : Auto\n");
  }
#line 1409
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 1414
  if (ImageInfo.LightSource == 1) {
#line 1414
    goto case_1___0;
  }
#line 1417
  if (ImageInfo.LightSource == 2) {
#line 1417
    goto case_2;
  }
#line 1420
  if (ImageInfo.LightSource == 3) {
#line 1420
    goto case_3;
  }
#line 1423
  if (ImageInfo.LightSource == 4) {
#line 1423
    goto case_4;
  }
#line 1426
  if (ImageInfo.LightSource == 9) {
#line 1426
    goto case_9___0;
  }
#line 1429
  if (ImageInfo.LightSource == 11) {
#line 1429
    goto case_11;
  }
#line 1432
  goto switch_default;
  case_1___0: /* CIL Label */ 
  {
#line 1415
  printf((char const   */* __restrict  */)"Light Source : Daylight\n");
  }
#line 1416
  goto switch_break___2;
  case_2: /* CIL Label */ 
  {
#line 1418
  printf((char const   */* __restrict  */)"Light Source : Fluorescent\n");
  }
#line 1419
  goto switch_break___2;
  case_3: /* CIL Label */ 
  {
#line 1421
  printf((char const   */* __restrict  */)"Light Source : Incandescent\n");
  }
#line 1422
  goto switch_break___2;
  case_4: /* CIL Label */ 
  {
#line 1424
  printf((char const   */* __restrict  */)"Light Source : Flash\n");
  }
#line 1425
  goto switch_break___2;
  case_9___0: /* CIL Label */ 
  {
#line 1427
  printf((char const   */* __restrict  */)"Light Source : Fine weather\n");
  }
#line 1428
  goto switch_break___2;
  case_11: /* CIL Label */ 
  {
#line 1430
  printf((char const   */* __restrict  */)"Light Source : Shade\n");
  }
#line 1431
  goto switch_break___2;
  switch_default: /* CIL Label */ ;
  switch_break___2: /* CIL Label */ ;
  }
#line 1437
  if (ImageInfo.MeteringMode > 0) {
    {
#line 1438
    printf((char const   */* __restrict  */)"Metering Mode: ");
    }
    {
#line 1440
    if (ImageInfo.MeteringMode == 1) {
#line 1440
      goto case_1___1;
    }
#line 1441
    if (ImageInfo.MeteringMode == 2) {
#line 1441
      goto case_2___0;
    }
#line 1442
    if (ImageInfo.MeteringMode == 3) {
#line 1442
      goto case_3___0;
    }
#line 1443
    if (ImageInfo.MeteringMode == 4) {
#line 1443
      goto case_4___0;
    }
#line 1444
    if (ImageInfo.MeteringMode == 5) {
#line 1444
      goto case_5___0;
    }
#line 1445
    if (ImageInfo.MeteringMode == 6) {
#line 1445
      goto case_6;
    }
#line 1446
    if (ImageInfo.MeteringMode == 255) {
#line 1446
      goto case_255;
    }
#line 1447
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
    {
#line 1440
    printf((char const   */* __restrict  */)"average\n");
    }
#line 1440
    goto switch_break___3;
    case_2___0: /* CIL Label */ 
    {
#line 1441
    printf((char const   */* __restrict  */)"center weight\n");
    }
#line 1441
    goto switch_break___3;
    case_3___0: /* CIL Label */ 
    {
#line 1442
    printf((char const   */* __restrict  */)"spot\n");
    }
#line 1442
    goto switch_break___3;
    case_4___0: /* CIL Label */ 
    {
#line 1443
    printf((char const   */* __restrict  */)"multi spot\n");
    }
#line 1443
    goto switch_break___3;
    case_5___0: /* CIL Label */ 
    {
#line 1444
    printf((char const   */* __restrict  */)"pattern\n");
    }
#line 1444
    goto switch_break___3;
    case_6: /* CIL Label */ 
    {
#line 1445
    printf((char const   */* __restrict  */)"partial\n");
    }
#line 1445
    goto switch_break___3;
    case_255: /* CIL Label */ 
    {
#line 1446
    printf((char const   */* __restrict  */)"other\n");
    }
#line 1446
    goto switch_break___3;
    switch_default___0: /* CIL Label */ 
    {
#line 1447
    printf((char const   */* __restrict  */)"unknown (%d)\n", ImageInfo.MeteringMode);
    }
#line 1447
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  }
#line 1451
  if (ImageInfo.ExposureProgram) {
    {
#line 1453
    if (ImageInfo.ExposureProgram == 1) {
#line 1453
      goto case_1___2;
    }
#line 1456
    if (ImageInfo.ExposureProgram == 2) {
#line 1456
      goto case_2___1;
    }
#line 1459
    if (ImageInfo.ExposureProgram == 3) {
#line 1459
      goto case_3___1;
    }
#line 1462
    if (ImageInfo.ExposureProgram == 4) {
#line 1462
      goto case_4___1;
    }
#line 1465
    if (ImageInfo.ExposureProgram == 5) {
#line 1465
      goto case_5___1;
    }
#line 1468
    if (ImageInfo.ExposureProgram == 6) {
#line 1468
      goto case_6___0;
    }
#line 1471
    if (ImageInfo.ExposureProgram == 7) {
#line 1471
      goto case_7___0;
    }
#line 1474
    if (ImageInfo.ExposureProgram == 8) {
#line 1474
      goto case_8;
    }
#line 1477
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
    {
#line 1454
    printf((char const   */* __restrict  */)"Exposure     : Manual\n");
    }
#line 1455
    goto switch_break___4;
    case_2___1: /* CIL Label */ 
    {
#line 1457
    printf((char const   */* __restrict  */)"Exposure     : program (auto)\n");
    }
#line 1458
    goto switch_break___4;
    case_3___1: /* CIL Label */ 
    {
#line 1460
    printf((char const   */* __restrict  */)"Exposure     : aperture priority (semi-auto)\n");
    }
#line 1461
    goto switch_break___4;
    case_4___1: /* CIL Label */ 
    {
#line 1463
    printf((char const   */* __restrict  */)"Exposure     : shutter priority (semi-auto)\n");
    }
#line 1464
    goto switch_break___4;
    case_5___1: /* CIL Label */ 
    {
#line 1466
    printf((char const   */* __restrict  */)"Exposure     : Creative Program (based towards depth of field)\n");
    }
#line 1467
    goto switch_break___4;
    case_6___0: /* CIL Label */ 
    {
#line 1469
    printf((char const   */* __restrict  */)"Exposure     : Action program (based towards fast shutter speed)\n");
    }
#line 1470
    goto switch_break___4;
    case_7___0: /* CIL Label */ 
    {
#line 1472
    printf((char const   */* __restrict  */)"Exposure     : Portrait Mode\n");
    }
#line 1473
    goto switch_break___4;
    case_8: /* CIL Label */ 
    {
#line 1475
    printf((char const   */* __restrict  */)"Exposure     : LandscapeMode \n");
    }
#line 1476
    goto switch_break___4;
    switch_default___1: /* CIL Label */ 
#line 1478
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1482
  if (ImageInfo.ExposureMode == 0) {
#line 1482
    goto case_0___0;
  }
#line 1484
  if (ImageInfo.ExposureMode == 1) {
#line 1484
    goto case_1___3;
  }
#line 1486
  if (ImageInfo.ExposureMode == 2) {
#line 1486
    goto case_2___2;
  }
#line 1481
  goto switch_break___5;
  case_0___0: /* CIL Label */ 
#line 1483
  goto switch_break___5;
  case_1___3: /* CIL Label */ 
  {
#line 1484
  printf((char const   */* __restrict  */)"Exposure Mode: Manual\n");
  }
#line 1485
  goto switch_break___5;
  case_2___2: /* CIL Label */ 
  {
#line 1486
  printf((char const   */* __restrict  */)"Exposure Mode: Auto bracketing\n");
  }
#line 1487
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 1490
  if (ImageInfo.DistanceRange) {
    {
#line 1491
    printf((char const   */* __restrict  */)"Focus range  : ");
    }
    {
#line 1493
    if (ImageInfo.DistanceRange == 1) {
#line 1493
      goto case_1___4;
    }
#line 1496
    if (ImageInfo.DistanceRange == 2) {
#line 1496
      goto case_2___3;
    }
#line 1499
    if (ImageInfo.DistanceRange == 3) {
#line 1499
      goto case_3___2;
    }
#line 1492
    goto switch_break___6;
    case_1___4: /* CIL Label */ 
    {
#line 1494
    printf((char const   */* __restrict  */)"macro");
    }
#line 1495
    goto switch_break___6;
    case_2___3: /* CIL Label */ 
    {
#line 1497
    printf((char const   */* __restrict  */)"close");
    }
#line 1498
    goto switch_break___6;
    case_3___2: /* CIL Label */ 
    {
#line 1500
    printf((char const   */* __restrict  */)"distant");
    }
#line 1501
    goto switch_break___6;
    switch_break___6: /* CIL Label */ ;
    }
    {
#line 1503
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1508
  if (ImageInfo.Process != 192) {
#line 1512
    a = 0U;
    {
#line 1512
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1513
      if ((unsigned long )a >= sizeof(ProcessTable) / sizeof(TagTable_t )) {
        {
#line 1515
        printf((char const   */* __restrict  */)"Jpeg process : Unknown\n");
        }
#line 1516
        goto while_break;
      }
#line 1518
      if ((int const   )ProcessTable[a].Tag == (int const   )ImageInfo.Process) {
        {
#line 1519
        printf((char const   */* __restrict  */)"Jpeg process : %s\n", ProcessTable[a].Desc);
        }
#line 1520
        goto while_break;
      }
#line 1512
      a ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1525
  if (ImageInfo.GpsInfoPresent) {
    {
#line 1526
    printf((char const   */* __restrict  */)"GPS Latitude : %s\n", ImageInfo.GpsLat);
#line 1527
    printf((char const   */* __restrict  */)"GPS Longitude: %s\n", ImageInfo.GpsLong);
    }
#line 1528
    if (ImageInfo.GpsAlt[0]) {
      {
#line 1528
      printf((char const   */* __restrict  */)"GPS Altitude : %s\n", ImageInfo.GpsAlt);
      }
    }
  }
#line 1531
  if (ImageInfo.QualityGuess) {
    {
#line 1532
    printf((char const   */* __restrict  */)"JPEG Quality : %d\n", ImageInfo.QualityGuess);
    }
  }
#line 1536
  if (ImageInfo.Comments[0]) {
    {
#line 1538
    printf((char const   */* __restrict  */)"Comment      : ");
    }
#line 1539
    if (! ImageInfo.CommentWidthchars) {
#line 1540
      a___0 = 0;
      {
#line 1540
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1540
        if (! (a___0 < 16000)) {
#line 1540
          goto while_break___0;
        }
#line 1541
        c = (int )ImageInfo.Comments[a___0];
#line 1542
        if (c == 0) {
#line 1542
          goto while_break___0;
        }
#line 1543
        if (c == 10) {
#line 1545
          if ((int )ImageInfo.Comments[a___0 + 1] != 0) {
            {
#line 1546
            printf((char const   */* __restrict  */)"\nComment      : ");
            }
          } else {
            {
#line 1548
            printf((char const   */* __restrict  */)"\n");
            }
          }
        } else {
          {
#line 1551
          putchar(c);
          }
        }
#line 1540
        a___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1554
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 1556
      printf((char const   */* __restrict  */)"%.*ls\n", ImageInfo.CommentWidthchars,
             (wchar_t *)(ImageInfo.Comments));
      }
    }
  }
#line 1559
  return;
}
}
#line 1565 "/home/khheo/project/cve/benchmark/jhead-3.00/exif.c"
void ShowConciseImageInfo(void) 
{ 


  {
  {
#line 1567
  printf((char const   */* __restrict  */)"\"%s\"", ImageInfo.FileName);
#line 1569
  printf((char const   */* __restrict  */)" %dx%d", ImageInfo.Width, ImageInfo.Height);
  }
#line 1571
  if (ImageInfo.ExposureTime) {
#line 1572
    if ((double )ImageInfo.ExposureTime <= 0.5) {
      {
#line 1573
      printf((char const   */* __restrict  */)" (1/%d)", (int )(0.5 + (double )((float )1 / ImageInfo.ExposureTime)));
      }
    } else {
      {
#line 1575
      printf((char const   */* __restrict  */)" (%1.1f)", (double )ImageInfo.ExposureTime);
      }
    }
  }
#line 1579
  if (ImageInfo.ApertureFNumber) {
    {
#line 1580
    printf((char const   */* __restrict  */)" f/%3.1f", (double )ImageInfo.ApertureFNumber);
    }
  }
#line 1583
  if (ImageInfo.FocalLength35mmEquiv) {
    {
#line 1584
    printf((char const   */* __restrict  */)" f(35)=%dmm", ImageInfo.FocalLength35mmEquiv);
    }
  }
#line 1587
  if (ImageInfo.FlashUsed >= 0) {
#line 1587
    if (ImageInfo.FlashUsed & 1) {
      {
#line 1588
      printf((char const   */* __restrict  */)" (flash)");
      }
    }
  }
#line 1591
  if (ImageInfo.IsColor == 0) {
    {
#line 1592
    printf((char const   */* __restrict  */)" (bw)");
    }
  }
  {
#line 1595
  printf((char const   */* __restrict  */)"\n");
  }
#line 1596
  return;
}
}

/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 55 "libltdl/slist.h"
struct slist {
   struct slist *next ;
   void const   *userdata ;
};
#line 55 "libltdl/slist.h"
typedef struct slist SList;
#line 60 "libltdl/slist.h"
typedef void *SListCallback(SList *item , void *userdata );
#line 61 "libltdl/slist.h"
typedef int SListCompare(SList const   *item1 , SList const   *item2 , void *userdata );
#line 39 "./libltdl/lt_dlloader.h"
typedef void *lt_module;
#line 40 "./libltdl/lt_dlloader.h"
typedef void *lt_user_data;
#line 41
struct lt__advise;
#line 41 "./libltdl/lt_dlloader.h"
typedef struct lt__advise *lt_dladvise;
#line 44 "./libltdl/lt_dlloader.h"
typedef lt_module lt_module_open(lt_user_data data , char const   *filename , lt_dladvise advise );
#line 47 "./libltdl/lt_dlloader.h"
typedef int lt_module_close(lt_user_data data , lt_module module );
#line 49 "./libltdl/lt_dlloader.h"
typedef void *lt_find_sym(lt_user_data data , lt_module module , char const   *symbolname );
#line 51 "./libltdl/lt_dlloader.h"
typedef int lt_dlloader_init(lt_user_data data );
#line 52 "./libltdl/lt_dlloader.h"
typedef int lt_dlloader_exit(lt_user_data data );
#line 55
enum __anonenum_lt_dlloader_priority_33 {
    LT_DLLOADER_PREPEND = 0,
    LT_DLLOADER_APPEND = 1
} ;
#line 55 "./libltdl/lt_dlloader.h"
typedef enum __anonenum_lt_dlloader_priority_33 lt_dlloader_priority;
#line 61 "./libltdl/lt_dlloader.h"
struct __anonstruct_lt_dlvtable_34 {
   char const   *name ;
   char const   *sym_prefix ;
   lt_module_open *module_open ;
   lt_module_close *module_close ;
   lt_find_sym *find_sym ;
   lt_dlloader_init *dlloader_init ;
   lt_dlloader_exit *dlloader_exit ;
   lt_user_data dlloader_data ;
   lt_dlloader_priority priority ;
};
#line 61 "./libltdl/lt_dlloader.h"
typedef struct __anonstruct_lt_dlvtable_34 lt_dlvtable;
#line 50 "./ltdl.h"
struct lt__handle;
#line 50 "./ltdl.h"
typedef struct lt__handle *lt_dlhandle;
#line 91 "./ltdl.h"
struct __anonstruct_lt_dlsymlist_35 {
   char const   *name ;
   void *address ;
};
#line 91 "./ltdl.h"
typedef struct __anonstruct_lt_dlsymlist_35 lt_dlsymlist;
#line 96 "./ltdl.h"
typedef int lt_dlpreload_callback_func(lt_dlhandle handle );
#line 116 "./ltdl.h"
typedef void *lt_dlinterface_id;
#line 129 "./ltdl.h"
struct __anonstruct_lt_dlinfo_36 {
   char *filename ;
   char *name ;
   int ref_count ;
   unsigned int is_resident : 1 ;
   unsigned int is_symglobal : 1 ;
   unsigned int is_symlocal : 1 ;
};
#line 129 "./ltdl.h"
typedef struct __anonstruct_lt_dlinfo_36 lt_dlinfo;
#line 105 "libltdl/lt__private.h"
struct __anonstruct_lt_interface_data_37 {
   lt_dlinterface_id key ;
   void *data ;
};
#line 105 "libltdl/lt__private.h"
typedef struct __anonstruct_lt_interface_data_37 lt_interface_data;
#line 110 "libltdl/lt__private.h"
struct lt__handle {
   lt_dlhandle next ;
   lt_dlvtable const   *vtable ;
   lt_dlinfo info ;
   int depcount ;
   lt_dlhandle *deplibs ;
   lt_module module ;
   void *system ;
   lt_interface_data *interface_data ;
   int flags ;
};
#line 122 "libltdl/lt__private.h"
struct lt__advise {
   unsigned int try_ext : 1 ;
   unsigned int is_resident : 1 ;
   unsigned int is_symglobal : 1 ;
   unsigned int is_symlocal : 1 ;
};
#line 97 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
struct symlist_chain {
   struct symlist_chain *next ;
   lt_dlsymlist const   *symlist ;
};
#line 97 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
typedef struct symlist_chain symlist_chain;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 69 "/usr/include/errno.h"
typedef int error_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 38 "./libltdl/lt_dlloader.h"
typedef void *lt_dlloader;
#line 82 "./libltdl/lt_dlloader.h"
typedef lt_dlvtable const   *lt_get_vtable(lt_user_data data );
#line 117 "./ltdl.h"
typedef int lt_dlhandle_interface(lt_dlhandle handle , char const   *id_string );
#line 84 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
typedef int foreach_callback_func(char *filename , void *data1 , void *data2 );
#line 87 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
typedef int file_worker_func(char const   *filename , void *data );
#line 2211 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
struct __anonstruct_lt__interface_id_38 {
   char const   *id_string ;
   lt_dlhandle_interface *iface ;
};
#line 2211 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
typedef struct __anonstruct_lt__interface_id_38 lt__interface_id;
#line 44 "../include/dico/types.h"
struct dico_list;
#line 44 "../include/dico/types.h"
typedef struct dico_list *dico_list_t;
#line 26 "../include/dico/utf8.h"
struct utf8_iterator {
   char *string ;
   char *curptr ;
   unsigned int curwidth ;
};
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
struct unicase_info_st {
   unsigned int toupper ;
   unsigned int tolower ;
   unsigned int sort ;
};
#line 32 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
typedef struct unicase_info_st MY_UNICASE_INFO;
#line 1694 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
struct tstring {
   unsigned char *ptr ;
   size_t len ;
};
#line 45 "../include/dico/types.h"
struct dico_assoc_list;
#line 45 "../include/dico/types.h"
typedef struct dico_assoc_list *dico_assoc_list_t;
#line 25 "../include/dico/url.h"
struct dico_request {
   int type ;
   char *word ;
   char *database ;
   char *strategy ;
   unsigned long n ;
};
#line 33 "../include/dico/url.h"
struct dico_url {
   char *string ;
   char *proto ;
   char *host ;
   int port ;
   char *path ;
   char *user ;
   char *passwd ;
   dico_assoc_list_t args ;
   struct dico_request req ;
};
#line 45 "../include/dico/url.h"
typedef struct dico_url *dico_url_t;
#line 21 "../include/dico/xlat.h"
struct xlat_tab {
   char *string ;
   int num ;
};
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 43 "../include/dico/types.h"
struct dico_stream;
#line 43 "../include/dico/types.h"
typedef struct dico_stream *dico_stream_t;
#line 23 "../include/dico/stream.h"
enum dico_buffer_type {
    dico_buffer_none = 0,
    dico_buffer_line = 1,
    dico_buffer_full = 2
} ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
struct dico_stream {
   enum dico_buffer_type buftype ;
   size_t bufsize ;
   char *buffer ;
   size_t level ;
   char *cur ;
   int flags ;
   off_t bytes_in ;
   off_t bytes_out ;
   int last_err ;
   int (*read)(void * , char * , size_t  , size_t * ) ;
   int (*write)(void * , char const   * , size_t  , size_t * ) ;
   int (*flush)(void * ) ;
   int (*open)(void * , int  ) ;
   int (*close)(void * ) ;
   int (*destroy)(void * ) ;
   int (*seek)(void * , off_t  , int  , off_t * ) ;
   int (*size)(void * , off_t * ) ;
   int (*ctl)(void * , int  , void * ) ;
   char const   *(*error_string)(void * , int  ) ;
   void *data ;
};
#line 46 "../include/dico/types.h"
struct iterator;
#line 46 "../include/dico/types.h"
typedef struct iterator *dico_iterator_t;
#line 54
struct dico_strategy;
#line 54 "../include/dico/types.h"
typedef struct dico_strategy *dico_strategy_t;
#line 26 "../include/dico/list.h"
typedef int (*dico_list_comp_t)(void const   * , void * );
#line 23 "../include/dico/strat.h"
struct dico_strategy {
   char *name ;
   char *descr ;
   int (*sel)(int  , char const   * , char const   * , void * ) ;
   void *closure ;
   int is_default ;
   dico_list_t stratcl ;
};
#line 22 "../include/dico/parseopt.h"
enum dico_opt_type {
    dico_opt_null = 0,
    dico_opt_bool = 1,
    dico_opt_bitmask = 2,
    dico_opt_bitmask_rev = 3,
    dico_opt_long = 4,
    dico_opt_string = 5,
    dico_opt_enum = 6,
    dico_opt_const = 7,
    dico_opt_const_string = 8
} ;
#line 34 "../include/dico/parseopt.h"
union __anonunion_v_28 {
   long value ;
   char const   **enumstr ;
};
#line 34 "../include/dico/parseopt.h"
struct dico_option {
   char const   *name ;
   size_t len ;
   enum dico_opt_type type ;
   void *data ;
   union __anonunion_v_28 v ;
   int (*func)(struct dico_option * , char const   * ) ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
struct _mapfile_stream {
   char *filename ;
   int fd ;
   int flags ;
   char *start ;
   size_t size ;
   off_t offset ;
};
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/lib/logstream.c"
struct log_stream {
   int level ;
};
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
struct list_entry {
   struct list_entry *next ;
   void *data ;
};
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
struct dico_list {
   size_t count ;
   struct list_entry *head ;
   struct list_entry *tail ;
   struct iterator *itr ;
   int (*comp)(void const   * , void * ) ;
   int (*free_item)(void *item , void *data ) ;
   void *free_data ;
};
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
struct iterator {
   struct iterator *next ;
   dico_list_t list ;
   struct list_entry *cur ;
   int advanced ;
};
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
struct _iostr {
   dico_stream_t in ;
   dico_stream_t out ;
   dico_stream_t last_err ;
};
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/header.c"
struct hdr_buf {
   char *base ;
   size_t size ;
   size_t level ;
};
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
struct filter_stream {
   dico_stream_t transport ;
   char buf[2048] ;
   size_t level ;
   size_t min_level ;
   size_t max_line_length ;
   size_t line_length ;
   int (*xcode)(char const   * , size_t  , char * , size_t  , size_t * ) ;
   char *inbuf ;
   size_t inlevel ;
};
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
struct _stream {
   int fd ;
};
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
struct dbg_stream {
   dico_stream_t transport ;
   char const   *file ;
   unsigned int line ;
   int ts ;
};
#line 24 "../include/dico/assoc.h"
struct dico_assoc {
   char const   *key ;
   char *value ;
};
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
struct dico_assoc_list {
   int flags ;
   dico_list_t list ;
};
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
struct find_closure {
   size_t count ;
   char const   *str ;
};
#line 32 "../include/dico/argcv.h"
enum dico_argcv_quoting_style {
    dico_argcv_quoting_octal = 0,
    dico_argcv_quoting_hex = 1
} ;
#line 59 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
struct argcv_info {
   int len ;
   char const   *command ;
   char const   *delim ;
   char const   *comment ;
   int flags ;
   int start ;
   int end ;
   int save ;
   int finish_pos ;
};
#line 323 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef int wchar_t;
#line 352 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int wint_t;
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
enum __anonenum_arg_type_28 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
typedef enum __anonenum_arg_type_28 arg_type;
#line 93 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
union __anonunion_a_30 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 93 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
struct __anonstruct_argument_29 {
   arg_type type ;
   union __anonunion_a_30 a ;
};
#line 93 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
typedef struct __anonstruct_argument_29 argument;
#line 140 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
struct __anonstruct_arguments_31 {
   size_t count ;
   argument *arg ;
};
#line 140 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
typedef struct __anonstruct_arguments_31 arguments;
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.h"
struct __anonstruct_char_directive_32 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.h"
typedef struct __anonstruct_char_directive_32 char_directive;
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.h"
struct __anonstruct_char_directives_33 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
};
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.h"
typedef struct __anonstruct_char_directives_33 char_directives;
#line 141 "/usr/include/stdint.h"
typedef unsigned long long uintmax_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 149 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef int ptrdiff_t;
#line 34 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7
} ;
#line 194
struct quoting_options;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_25 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_24 {
   int __count ;
   union __anonunion___value_25 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_24 __mbstate_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
};
#line 627 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 139 "/usr/include/stdint.h"
typedef long long intmax_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 60 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.h"
struct md5_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
#line 254 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
struct __anonstruct_28 {
   char c ;
   uint32_t x ;
};
#line 37 "/usr/include/nl_types.h"
typedef int nl_item;
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.h"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 56
struct hash_table;
#line 58 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.h"
typedef struct hash_table Hash_table;
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.h"
struct __anonstruct_gl_des_ctx_1 {
   uint32_t encrypt_subkeys[32] ;
   uint32_t decrypt_subkeys[32] ;
};
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.h"
typedef struct __anonstruct_gl_des_ctx_1 gl_des_ctx;
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.h"
struct __anonstruct_gl_3des_ctx_2 {
   uint32_t encrypt_subkeys[96] ;
   uint32_t decrypt_subkeys[96] ;
};
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.h"
typedef struct __anonstruct_gl_3des_ctx_2 gl_3des_ctx;
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
struct transcript_stream {
   int flags ;
   dico_stream_t transport ;
   dico_stream_t logstr ;
   char *prefix[2] ;
};
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 869 "/usr/include/stdio.h"
struct obstack;
#line 88 "../include/xdico.h"
struct xdico_input;
#line 88 "../include/xdico.h"
typedef struct xdico_input *xdico_input_t;
#line 144 "../gnu/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 151 "../gnu/obstack.h"
union __anonunion_temp_30 {
   int tempint ;
   void *tempptr ;
};
#line 151 "../gnu/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_30 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
struct xdico_input {
   struct obstack stk ;
   char *rootptr ;
   int argc ;
   char **argv ;
};
#line 66 "../include/xdico.h"
struct timer_slot;
#line 66 "../include/xdico.h"
typedef struct timer_slot *xdico_timer_t;
#line 154 "/usr/include/bits/resource.h"
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1,
    RUSAGE_THREAD = 1
} ;
#line 178 "/usr/include/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
#line 40 "/usr/include/sys/resource.h"
typedef enum __rusage_who __rusage_who_t;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
struct timer_slot {
   char *name ;
   double real ;
   double self_user ;
   double self_system ;
   double children_user ;
   double children_system ;
   struct timeval real_mark ;
   struct rusage self_mark ;
   struct rusage children_mark ;
};
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
typedef unsigned char uchar;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
struct cvt_tab {
   uchar in1 ;
   uchar in2_range[2] ;
   uchar out1 ;
   uchar out2 ;
};
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 92 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 92
struct sockaddr_un;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 256 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 25 "../include/xdico.h"
typedef unsigned long UINT4;
#line 26 "../include/xdico.h"
typedef UINT4 IPADDR;
#line 326 "./dicod.h"
struct dicod_command {
   char *keyword ;
   int minparam ;
   int maxparam ;
   char *param ;
   char *help ;
   void (*handler)(dico_stream_t str , int argc , char **argv ) ;
};
#line 373 "./dicod.h"
struct udb_def {
   char const   *proto ;
   int (*_db_open)(void ** , dico_url_t  ) ;
   int (*_db_close)(void * ) ;
   int (*_db_get_password)(void * , char const   * , char const   * , char ** ) ;
   int (*_db_get_groups)(void * , char const   * , char const   * , dico_list_t * ) ;
};
#line 129 "./dicod.h"
struct __anonstruct_dicod_locus_t_69 {
   char *file ;
   int line ;
};
#line 129 "./dicod.h"
typedef struct __anonstruct_dicod_locus_t_69 dicod_locus_t;
#line 383
struct dicod_user_db;
#line 383 "./dicod.h"
typedef struct dicod_user_db *dicod_user_db_t;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/udb.c"
struct dicod_user_db {
   void *handle ;
   dico_url_t url ;
   char const   *qpw ;
   char const   *qgrp ;
   int (*_db_open)(void ** , dico_url_t url ) ;
   int (*_db_close)(void * ) ;
   int (*_db_get_password)(void * , char const   * , char const   * , char ** ) ;
   int (*_db_get_groups)(void * , char const   * , char const   * , dico_list_t * ) ;
};
#line 488 "./dicod.h"
enum cmp_op {
    cmp_eq = 0,
    cmp_ne = 1,
    cmp_lt = 2,
    cmp_le = 3,
    cmp_gt = 4,
    cmp_ge = 5
} ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stratcl.c"
struct word_length {
   enum cmp_op op ;
   size_t len ;
};
#line 24
enum stratcl_type {
    stratcl_all = 0,
    stratcl_word = 1,
    stratcl_length = 2
} ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stratcl.c"
union __anonunion_v_73 {
   char *word ;
   struct word_length wl ;
};
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stratcl.c"
struct stratcl {
   enum stratcl_type type ;
   union __anonunion_v_73 v ;
};
#line 65 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stratcl.c"
struct stratcl_check {
   char const   *word ;
   size_t len ;
   int res ;
};
#line 103 "./dicod.h"
struct dico_stat {
   unsigned long defines ;
   unsigned long matches ;
   unsigned long compares ;
};
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 275 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 210 "./dicod.h"
union __anonunion_sockaddr_union_t_72 {
   struct sockaddr s ;
   struct sockaddr_in s_in ;
   struct sockaddr_un s_un ;
};
#line 210 "./dicod.h"
typedef union __anonunion_sockaddr_union_t_72 sockaddr_union_t;
#line 247
struct dicod_acl;
#line 247 "./dicod.h"
typedef struct dicod_acl *dicod_acl_t;
#line 21 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
struct dicod_server {
   int fd ;
   struct sockaddr *addr ;
   int addrlen ;
};
#line 195 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_74 {
   int __in ;
   int __i ;
};
#line 190 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_75 {
   int __in ;
   int __i ;
};
#line 202 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 206 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_77 {
   int __in ;
   int __i ;
};
#line 210 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_78 {
   int __in ;
   int __i ;
};
#line 214 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 209 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 199 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 189 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 444 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 443 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 77 "../gnu/regex.h"
typedef int regoff_t;
#line 80 "../gnu/regex.h"
typedef unsigned long __re_long_size_t;
#line 96 "../gnu/regex.h"
typedef unsigned long reg_syntax_t;
#line 452 "../gnu/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 520 "../gnu/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 543 "../gnu/regex.h"
struct __anonstruct_regmatch_t_74 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 543 "../gnu/regex.h"
typedef struct __anonstruct_regmatch_t_74 regmatch_t;
#line 20 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/regex.c"
struct regex_closure {
   int flags ;
   regex_t reg ;
};
#line 50 "/usr/include/sys/types.h"
typedef __ino_t ino_t;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
struct input_file_ident {
   ino_t i_node ;
   dev_t device ;
};
#line 28 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
struct buffer_ctx {
   struct buffer_ctx *prev ;
   dicod_locus_t locus ;
   size_t namelen ;
   size_t xlines ;
   struct input_file_ident id ;
   FILE *infile ;
};
#line 206 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
struct file_data {
   char const   *name ;
   size_t namelen ;
   char *buf ;
   size_t buflen ;
   int found ;
};
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ostream.c"
struct ostream {
   dico_stream_t transport ;
   int flags ;
   dico_assoc_list_t headers ;
};
#line 48 "../include/dico/types.h"
struct dico_handle_struct;
#line 48 "../include/dico/types.h"
typedef struct dico_handle_struct *dico_handle_t;
#line 49
struct dico_result_struct;
#line 49 "../include/dico/types.h"
typedef struct dico_result_struct *dico_result_t;
#line 61 "../include/dico/types.h"
struct dico_database_module {
   unsigned int dico_version ;
   unsigned int dico_capabilities ;
   int (*dico_init)(int argc , char **argv ) ;
   dico_handle_t (*dico_init_db)(char const   *db , int argc , char **argv ) ;
   int (*dico_free_db)(dico_handle_t hp ) ;
   int (*dico_open)(dico_handle_t hp ) ;
   int (*dico_close)(dico_handle_t hp ) ;
   char *(*dico_db_info)(dico_handle_t hp ) ;
   char *(*dico_db_descr)(dico_handle_t hp ) ;
   int (*dico_db_lang)(dico_handle_t hp , dico_list_t *list ) ;
   dico_result_t (*dico_match)(dico_handle_t hp , dico_strategy_t const   strat ,
                               char const   *word ) ;
   dico_result_t (*dico_define)(dico_handle_t hp , char const   *word ) ;
   int (*dico_output_result)(dico_result_t rp , size_t n , dico_stream_t str ) ;
   size_t (*dico_result_count)(dico_result_t rp ) ;
   size_t (*dico_compare_count)(dico_result_t rp ) ;
   void (*dico_free_result)(dico_result_t rp ) ;
   int (*dico_result_headers)(dico_result_t rp , dico_assoc_list_t hdr ) ;
};
#line 123 "./dicod.h"
struct dicod_conf_override {
   int transcript ;
};
#line 139
enum config_data_type {
    cfg_void = 0,
    cfg_string = 1,
    cfg_short = 2,
    cfg_ushort = 3,
    cfg_int = 4,
    cfg_uint = 5,
    cfg_long = 6,
    cfg_ulong = 7,
    cfg_size = 8,
    cfg_uintmax = 9,
    cfg_intmax = 10,
    cfg_time = 11,
    cfg_bool = 12,
    cfg_ipv4 = 13,
    cfg_cidr = 14,
    cfg_host = 15,
    cfg_sockaddr = 16,
    cfg_section = 17
} ;
#line 166
enum cfg_callback_command {
    callback_section_begin = 0,
    callback_section_end = 1,
    callback_set_value = 2
} ;
#line 176 "./dicod.h"
struct __anonstruct_arg_71 {
   size_t c ;
   struct config_value *v ;
};
#line 176 "./dicod.h"
union __anonunion_v_70 {
   dico_list_t list ;
   char const   *string ;
   struct __anonstruct_arg_71 arg ;
};
#line 176 "./dicod.h"
struct config_value {
   int type ;
   union __anonunion_v_70 v ;
};
#line 176 "./dicod.h"
typedef struct config_value config_value_t;
#line 196 "./dicod.h"
struct config_keyword {
   char const   *ident ;
   char const   *argname ;
   char const   *docstring ;
   enum config_data_type type ;
   void *varptr ;
   size_t offset ;
   int (*callback)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
                   void * ) ;
   void *callback_data ;
   struct config_keyword *kwd ;
};
#line 263 "./dicod.h"
struct dicod_module_instance {
   char *ident ;
   char *command ;
   struct dico_database_module *module ;
   lt_dlhandle handle ;
};
#line 263 "./dicod.h"
typedef struct dicod_module_instance dicod_module_instance_t;
#line 272 "./dicod.h"
struct dicod_database {
   int flags ;
   char *name ;
   char *descr ;
   char *info ;
   dico_list_t langlist[2] ;
   dicod_acl_t acl ;
   int visible ;
   dico_handle_t mod_handle ;
   dico_assoc_list_t mime_headers ;
   dicod_module_instance_t *instance ;
   int argc ;
   char **argv ;
   char *command ;
};
#line 272 "./dicod.h"
typedef struct dicod_database dicod_database_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 659 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
struct user_db_conf {
   char *url ;
   char *get_pw ;
   char *get_groups ;
};
#line 868 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
struct compile_pattern_closure {
   dico_list_t list ;
   dicod_locus_t *locus ;
};
#line 1267 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
struct __anonstruct_loglevels_73 {
   char *prefix ;
   int priority ;
};
#line 329 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
struct dbres {
   dicod_database_t *db ;
   dico_result_t res ;
   size_t count ;
};
#line 189 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
struct ident_info {
   uint32_t checksum ;
   uint16_t random ;
   uint16_t uid ;
   uint32_t date ;
   uint32_t ip_local ;
   uint32_t ip_remote ;
   uint16_t port_local ;
   uint16_t port_remote ;
};
#line 201 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
union ident_data {
   struct ident_info fields ;
   unsigned long longs[6] ;
   unsigned char chars[24] ;
};
#line 268 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
struct io_buffer {
   size_t size ;
   size_t level ;
   char *buffer ;
};
#line 306
enum socket_io_retval {
    socket_io_ok = 0,
    socket_io_failure = 1,
    socket_io_connect = 2,
    socket_io_noreply = 3,
    socket_io_error = 4
} ;
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
struct capa_print {
   size_t num ;
   dico_stream_t stream ;
};
#line 99 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
struct yy_buffer_state;
#line 99 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 141 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
typedef unsigned int yy_size_t;
#line 144 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 266 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
typedef unsigned char YY_CHAR;
#line 268 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
typedef int yy_state_type;
#line 58 "./config-gram.h"
union YYSTYPE {
   char *string ;
   config_value_t value ;
   dico_list_t list ;
   struct config_keyword *kw ;
};
#line 58 "./config-gram.h"
typedef union YYSTYPE YYSTYPE;
#line 170 "config-gram.c"
typedef unsigned char yytype_uint8;
#line 177 "config-gram.c"
typedef signed char yytype_int8;
#line 191 "config-gram.c"
typedef short yytype_int16;
#line 322 "config-gram.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 49 "/usr/include/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 294 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
struct locate_data {
   int argc ;
   char **argv ;
};
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 139 "cmdline.opt"
struct opthelp {
   char const   *opt ;
   char const   *arg ;
   int is_optional ;
   char const   *descr ;
};
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/capa.c"
struct dicod_capa {
   char const   *name ;
   struct dicod_command *cmd ;
   int (*init)(void * ) ;
   void *closure ;
   int enabled ;
};
#line 85 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/capa.c"
struct iter_data {
   int (*fun)(char const   * , int  , void * ) ;
   void *closure ;
};
#line 20 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/alias.c"
struct alias {
   char *kw ;
   int argc ;
   char **argv ;
   dicod_locus_t locus ;
};
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
struct dicod_sockaddr {
   unsigned int netmask ;
   int salen ;
   struct sockaddr sa ;
};
#line 33 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
struct acl_entry {
   dicod_locus_t locus ;
   int allow ;
   int authenticated ;
   dicod_acl_t acl ;
   dico_list_t groups ;
   dico_list_t sockaddrs ;
};
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
struct dicod_acl {
   char *name ;
   dicod_locus_t locus ;
   dico_list_t list ;
};
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
struct alog_instr;
#line 78 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
struct alog_instr {
   void (*prt)(FILE *fp , struct alog_instr *instr , int argc , char **argv ) ;
   char *arg ;
   char *cache ;
};
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
struct alog_tab {
   int ch ;
   void (*prt)(FILE *fp , struct alog_instr *instr , int argc , char **argv ) ;
   int allow_fmt ;
};
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 45 "libltdl/lt__strl.h"
size_t lt_strlcat(char *dst , char const   *src , size_t const   dstsize ) ;
#line 50
size_t lt_strlcpy(char *dst , char const   *src , size_t const   dstsize ) ;
#line 50 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c"
size_t lt_strlcat(char *dst , char const   *src , size_t const   dstsize ) 
{ 
  size_t length ;
  char *p ;
  char const   *q ;
  char const   *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 57
  if (! ((unsigned long )dst != (unsigned long )((void *)0))) {
    {
#line 57
    __assert_fail("dst != ((void *)0)", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  57U, "lt_strlcat");
    }
  }
#line 58
  if (! ((unsigned long )src != (unsigned long )((char const   *)((void *)0)))) {
    {
#line 58
    __assert_fail("src != (const char *) ((void *)0)", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  58U, "lt_strlcat");
    }
  }
#line 59
  if (! (dstsize >= 1U)) {
    {
#line 59
    __assert_fail("dstsize >= 1", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  59U, "lt_strlcat");
    }
  }
  {
#line 61
  length = strlen((char const   *)dst);
#line 67
  p = dst + length;
#line 67
  q = src;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if ((int const   )*q != 0) {
#line 67
      if (! (length < (size_t )(dstsize - 1U))) {
#line 67
        goto while_break;
      }
    } else {
#line 67
      goto while_break;
    }
#line 70
    *p = (char )*q;
#line 67
    length ++;
#line 67
    p ++;
#line 67
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  *(dst + length) = (char )'\000';
  {
#line 77
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 77
    tmp = q;
#line 77
    q ++;
#line 77
    if (! *tmp) {
#line 77
      goto while_break___0;
    }
#line 78
    length ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 80
  return (length);
}
}
#line 98 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c"
size_t lt_strlcpy(char *dst , char const   *src , size_t const   dstsize ) 
{ 
  size_t length ;
  char *p ;
  char const   *q ;
  char const   *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 101
  length = (size_t )0;
#line 105
  if (! ((unsigned long )dst != (unsigned long )((void *)0))) {
    {
#line 105
    __assert_fail("dst != ((void *)0)", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  105U, "lt_strlcpy");
    }
  }
#line 106
  if (! ((unsigned long )src != (unsigned long )((char const   *)((void *)0)))) {
    {
#line 106
    __assert_fail("src != (const char *) ((void *)0)", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  106U, "lt_strlcpy");
    }
  }
#line 107
  if (! (dstsize >= 1U)) {
    {
#line 107
    __assert_fail("dstsize >= 1", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__strl.c",
                  107U, "lt_strlcpy");
    }
  }
#line 112
  p = dst;
#line 112
  q = src;
#line 112
  length = (size_t )0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if ((int const   )*q != 0) {
#line 112
      if (! (length < (size_t )(dstsize - 1U))) {
#line 112
        goto while_break;
      }
    } else {
#line 112
      goto while_break;
    }
#line 115
    *p = (char )*q;
#line 112
    length ++;
#line 112
    p ++;
#line 112
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  *(dst + length) = (char )'\000';
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    tmp = q;
#line 122
    q ++;
#line 122
    if (! *tmp) {
#line 122
      goto while_break___0;
    }
#line 123
    length ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 125
  return (length);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 64 "libltdl/slist.h"
SList *lt__slist_concat(SList *head , SList *tail ) ;
#line 65
SList *lt__slist_cons(SList *item , SList *slist ) ;
#line 67
SList *lt__slist_delete(SList *head , void (*delete_fct)(void *item ) ) ;
#line 68
void *lt__slist_remove(SList **phead , SListCallback *find , void *matchdata ) ;
#line 70
SList *lt__slist_reverse(SList *slist ) ;
#line 71
SList *lt__slist_sort(SList *slist , SListCompare *compare , void *userdata ) ;
#line 74
SList *lt__slist_tail(SList *slist ) ;
#line 75
SList *lt__slist_nth(SList *slist , size_t n ) ;
#line 76
void *lt__slist_find(SList *slist , SListCallback *find , void *matchdata ) ;
#line 78
size_t lt__slist_length(SList *slist ) ;
#line 80
void *lt__slist_foreach(SList *slist , SListCallback *foreach , void *userdata ) ;
#line 83
SList *lt__slist_box(void const   *userdata ) ;
#line 84
void *lt__slist_unbox(SList *item ) ;
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
static SList *slist_sort_merge(SList *left , SList *right , SListCompare *compare ,
                               void *userdata ) ;
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_delete(SList *head , void (*delete_fct)(void *item ) ) 
{ 
  SList *next ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 55
  if (! delete_fct) {
    {
#line 55
    __assert_fail("delete_fct", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c",
                  55U, "lt__slist_delete");
    }
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! head) {
#line 57
      goto while_break;
    }
    {
#line 59
    next = head->next;
#line 60
    (*delete_fct)((void *)head);
#line 61
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return ((SList *)0);
}
}
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
void *lt__slist_remove(SList **phead , SListCallback *find , void *matchdata ) 
{ 
  SList *stale ;
  void *result ;
  SList *head ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 79
  stale = (SList *)0;
#line 80
  result = (void *)0;
#line 82
  if (! find) {
    {
#line 82
    __assert_fail("find", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c",
                  82U, "lt__slist_remove");
    }
  }
#line 84
  if (! phead) {
#line 85
    return ((void *)0);
  } else
#line 84
  if (! *phead) {
#line 85
    return ((void *)0);
  }
  {
#line 88
  result = (*find)(*phead, matchdata);
  }
#line 89
  if (result) {
#line 91
    stale = *phead;
#line 92
    *phead = stale->next;
  } else {
#line 98
    head = *phead;
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 98
      if (! head->next) {
#line 98
        goto while_break;
      }
      {
#line 100
      result = (*find)(head->next, matchdata);
      }
#line 101
      if (result) {
#line 103
        stale = head->next;
#line 104
        head->next = stale->next;
#line 105
        goto while_break;
      }
#line 98
      head = head->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 110
  return (result);
}
}
#line 116 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
void *lt__slist_find(SList *slist , SListCallback *find , void *matchdata ) 
{ 
  void *result ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 119
  result = (void *)0;
#line 121
  if (! find) {
    {
#line 121
    __assert_fail("find", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c",
                  121U, "lt__slist_find");
    }
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! slist) {
#line 123
      goto while_break;
    }
    {
#line 125
    result = (*find)(slist, matchdata);
    }
#line 126
    if (result) {
#line 127
      goto while_break;
    }
#line 123
    slist = slist->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return (result);
}
}
#line 140 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_concat(SList *head , SList *tail ) 
{ 
  SList *last ;

  {
#line 145
  if (! head) {
#line 147
    return (tail);
  }
#line 150
  last = head;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! last->next) {
#line 151
      goto while_break;
    }
#line 152
    last = last->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  last->next = tail;
#line 156
  return (head);
}
}
#line 166 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_cons(SList *item , SList *slist ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 169
  if (! item) {
#line 171
    return (slist);
  }
#line 174
  if (! (! item->next)) {
    {
#line 174
    __assert_fail("!item->next", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c",
                  174U, "lt__slist_cons");
    }
  }
#line 176
  item->next = slist;
#line 177
  return (item);
}
}
#line 181 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_tail(SList *slist ) 
{ 
  struct slist *tmp ;

  {
#line 184
  if (slist) {
#line 184
    tmp = slist->next;
  } else {
#line 184
    tmp = (struct slist *)((void *)0);
  }
#line 184
  return (tmp);
}
}
#line 192 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_nth(SList *slist , size_t n ) 
{ 


  {
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (n > 1U) {
#line 195
      if (! slist) {
#line 195
        goto while_break;
      }
    } else {
#line 195
      goto while_break;
    }
#line 196
    slist = slist->next;
#line 195
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (slist);
}
}
#line 203 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
size_t lt__slist_length(SList *slist ) 
{ 
  size_t n ;

  {
#line 208
  n = (size_t )0;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! slist) {
#line 208
      goto while_break;
    }
#line 209
    slist = slist->next;
#line 208
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (n);
}
}
#line 221 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_reverse(SList *slist ) 
{ 
  SList *result ;
  SList *next ;

  {
#line 224
  result = (SList *)0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! slist) {
#line 227
      goto while_break;
    }
#line 229
    next = slist->next;
#line 230
    slist->next = result;
#line 231
    result = slist;
#line 232
    slist = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return (result);
}
}
#line 240 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
void *lt__slist_foreach(SList *slist , SListCallback *foreach , void *userdata ) 
{ 
  void *result ;
  SList *next ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 243
  result = (void *)0;
#line 245
  if (! foreach) {
    {
#line 245
    __assert_fail("foreach", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c",
                  245U, "lt__slist_foreach");
    }
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! slist) {
#line 247
      goto while_break;
    }
    {
#line 249
    next = slist->next;
#line 250
    result = (*foreach)(slist, userdata);
    }
#line 252
    if (result) {
#line 253
      goto while_break;
    }
#line 255
    slist = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return (result);
}
}
#line 271 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
static SList *slist_sort_merge(SList *left , SList *right , SListCompare *compare ,
                               void *userdata ) 
{ 
  SList merged ;
  SList *insert ;
  struct slist *tmp ;
  struct slist *tmp___0 ;
  int tmp___1 ;

  {
#line 277
  insert = & merged;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (left) {
#line 279
      if (! right) {
#line 279
        goto while_break;
      }
    } else {
#line 279
      goto while_break;
    }
    {
#line 281
    tmp___1 = (*compare)((SList const   *)left, (SList const   *)right, userdata);
    }
#line 281
    if (tmp___1 <= 0) {
#line 283
      tmp = left;
#line 283
      insert->next = tmp;
#line 283
      insert = tmp;
#line 284
      left = left->next;
    } else {
#line 288
      tmp___0 = right;
#line 288
      insert->next = tmp___0;
#line 288
      insert = tmp___0;
#line 289
      right = right->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  if (left) {
#line 293
    insert->next = left;
  } else {
#line 293
    insert->next = right;
  }
#line 295
  return (merged.next);
}
}
#line 305 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_sort(SList *slist , SListCompare *compare , void *userdata ) 
{ 
  SList *left ;
  SList *right ;
  SList *tmp ;
  SList *tmp___0 ;
  SList *tmp___1 ;

  {
#line 310
  if (! slist) {
#line 311
    return (slist);
  }
#line 314
  left = slist;
#line 315
  right = slist->next;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (right) {
#line 319
      right = right->next;
#line 319
      if (! right) {
#line 319
        goto while_break;
      }
    } else {
#line 319
      goto while_break;
    }
#line 321
    if (! right) {
#line 322
      goto while_break;
    } else {
#line 321
      right = right->next;
#line 321
      if (! right) {
#line 322
        goto while_break;
      }
    }
#line 323
    slist = slist->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 325
  right = slist->next;
#line 326
  slist->next = (struct slist *)0;
#line 329
  tmp = lt__slist_sort(right, compare, userdata);
#line 329
  tmp___0 = lt__slist_sort(left, compare, userdata);
#line 329
  tmp___1 = slist_sort_merge(tmp___0, tmp, compare, userdata);
  }
#line 329
  return (tmp___1);
}
}
#line 346 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
SList *lt__slist_box(void const   *userdata ) 
{ 
  SList *item ;
  void *tmp ;

  {
  {
#line 349
  tmp = malloc((size_t )sizeof(*item));
#line 349
  item = (SList *)tmp;
  }
#line 351
  if (item) {
#line 353
    item->next = (struct slist *)0;
#line 354
    item->userdata = userdata;
  }
#line 357
  return (item);
}
}
#line 361 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/slist.c"
void *lt__slist_unbox(SList *item ) 
{ 
  void *userdata ;

  {
#line 364
  userdata = (void *)0;
#line 366
  if (item) {
    {
#line 370
    userdata = (void *)item->userdata;
#line 371
    free((void *)item);
    }
  }
#line 374
  return (userdata);
}
}
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 50 "libltdl/lt__alloc.h"
void *lt__zalloc(size_t n ) ;
#line 76 "./ltdl.h"
lt_dlhandle lt_dlopen(char const   *filename ) ;
#line 98
int lt_dlpreload(lt_dlsymlist const   *preloaded ) ;
#line 99
int lt_dlpreload_default(lt_dlsymlist const   *preloaded ) ;
#line 100
int lt_dlpreload_open(char const   *originator , lt_dlpreload_callback_func *func ) ;
#line 142 "libltdl/lt__private.h"
char const   *lt__error_string(int errorcode ) ;
#line 144
char const   *lt__set_last_error(char const   *errormsg ) ;
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
lt_dlvtable const   *preopen_LTX_get_vtable(lt_user_data loader_data ) ;
#line 48
static int vl_init(lt_user_data loader_data  __attribute__((__unused__)) ) ;
#line 49
static int vl_exit(lt_user_data loader_data  __attribute__((__unused__)) ) ;
#line 50
static lt_module vm_open(lt_user_data loader_data  __attribute__((__unused__)) , char const   *filename ,
                         lt_dladvise advise  __attribute__((__unused__)) ) ;
#line 52
static int vm_close(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module  __attribute__((__unused__)) ) ;
#line 53
static void *vm_sym(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ,
                    char const   *name ) ;
#line 56 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static lt_dlvtable *vtable  =    (lt_dlvtable *)0;
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
lt_dlvtable const   *preopen_LTX_get_vtable(lt_user_data loader_data ) 
{ 
  void *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 64
  if (! vtable) {
    {
#line 66
    tmp = lt__zalloc((size_t )sizeof(*vtable));
#line 66
    vtable = (lt_dlvtable *)tmp;
    }
  }
#line 69
  if (vtable) {
#line 69
    if (! vtable->name) {
#line 71
      vtable->name = "lt_preopen";
#line 72
      vtable->sym_prefix = (char const   *)0;
#line 73
      vtable->module_open = & vm_open;
#line 74
      vtable->module_close = & vm_close;
#line 75
      vtable->find_sym = & vm_sym;
#line 76
      vtable->dlloader_init = & vl_init;
#line 77
      vtable->dlloader_exit = & vl_exit;
#line 78
      vtable->dlloader_data = loader_data;
#line 79
      vtable->priority = (lt_dlloader_priority )0;
    }
  }
#line 82
  if (vtable) {
#line 82
    if ((unsigned long )vtable->dlloader_data != (unsigned long )loader_data) {
      {
#line 84
      tmp___0 = lt__error_string(3);
#line 84
      lt__set_last_error(tmp___0);
      }
#line 85
      return ((lt_dlvtable *)0);
    }
  }
#line 88
  return (vtable);
}
}
#line 104
static int add_symlist(lt_dlsymlist const   *symlist ) ;
#line 105
static int free_symlists(void) ;
#line 108 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static symlist_chain *preloaded_symlists  =    (symlist_chain *)0;
#line 111 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static lt_dlsymlist const   *default_preloaded_symbols  =    (lt_dlsymlist const   *)0;
#line 115 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static int vl_init(lt_user_data loader_data  __attribute__((__unused__)) ) 
{ 
  int errors ;

  {
#line 118
  errors = 0;
#line 120
  preloaded_symlists = (symlist_chain *)0;
#line 121
  if (default_preloaded_symbols) {
    {
#line 123
    errors = lt_dlpreload(default_preloaded_symbols);
    }
  }
#line 126
  return (errors);
}
}
#line 132 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static int vl_exit(lt_user_data loader_data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 135
  vtable = (lt_dlvtable *)((void *)0);
#line 136
  free_symlists();
  }
#line 137
  return (0);
}
}
#line 144 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static lt_module vm_open(lt_user_data loader_data  __attribute__((__unused__)) , char const   *filename ,
                         lt_dladvise advise  __attribute__((__unused__)) ) 
{ 
  symlist_chain *lists ;
  lt_module module ;
  char const   *tmp ;
  lt_dlsymlist const   *symbol ;
  lt_dlsymlist const   *next_symbol ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp11 ;

  {
#line 149
  module = (lt_module )0;
#line 151
  if (! preloaded_symlists) {
    {
#line 153
    tmp = lt__error_string(7);
#line 153
    lt__set_last_error(tmp);
    }
#line 154
    goto done;
  }
#line 161
  if (! filename) {
#line 163
    filename = "@PROGRAM@";
  }
#line 166
  lists = preloaded_symlists;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! lists) {
#line 166
      goto while_break;
    }
#line 169
    symbol = lists->symlist;
    {
#line 169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 169
      if (! symbol->name) {
#line 169
        goto while_break___0;
      }
#line 171
      if (! symbol->address) {
        {
#line 171
        tmp___0 = strcmp((char const   *)symbol->name, filename);
        }
#line 171
        if (! tmp___0) {
#line 178
          next_symbol = symbol + 1;
#line 179
          if (next_symbol->address) {
#line 179
            if (next_symbol->name) {
#line 181
              module = (lt_module )lists->symlist;
#line 182
              goto done;
            }
          }
        }
      }
#line 169
      symbol ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    lists = lists->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  tmp___1 = lt__error_string(5);
#line 188
  lt__set_last_error(tmp___1);
  }
  done: 
#line 191
  return (module);
}
}
#line 197 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static int vm_close(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module  __attribute__((__unused__)) ) 
{ 


  {
#line 201
  module = (lt_module )0;
#line 202
  return (0);
}
}
#line 208 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static void *vm_sym(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ,
                    char const   *name ) 
{ 
  lt_dlsymlist *symbol ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 211
  symbol = (lt_dlsymlist *)module;
#line 213
  symbol += 2;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! symbol->name) {
#line 215
      goto while_break;
    }
    {
#line 217
    tmp = strcmp(symbol->name, name);
    }
#line 217
    if (! tmp) {
#line 219
      return (symbol->address);
    }
#line 222
    symbol ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  tmp___0 = lt__error_string(10);
#line 225
  lt__set_last_error(tmp___0);
  }
#line 227
  return ((void *)0);
}
}
#line 237 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static int free_symlists(void) 
{ 
  symlist_chain *lists ;
  symlist_chain *next ;

  {
#line 242
  lists = preloaded_symlists;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! lists) {
#line 243
      goto while_break;
    }
#line 245
    next = lists->next;
#line 246
    if (lists) {
      {
#line 246
      free((void *)lists);
#line 246
      lists = (symlist_chain *)((void *)0);
      }
    }
#line 247
    lists = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  preloaded_symlists = (symlist_chain *)0;
#line 251
  return (0);
}
}
#line 255 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
static int add_symlist(lt_dlsymlist const   *symlist ) 
{ 
  symlist_chain *lists ;
  int errors ;
  symlist_chain *tmp ;
  void *tmp___0 ;

  {
#line 259
  errors = 0;
#line 262
  lists = preloaded_symlists;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (lists) {
#line 262
      if (! ((unsigned long )lists->symlist != (unsigned long )symlist)) {
#line 262
        goto while_break;
      }
    } else {
#line 262
      goto while_break;
    }
#line 262
    lists = lists->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if (! lists) {
    {
#line 269
    tmp___0 = lt__zalloc((size_t )sizeof(*tmp));
#line 269
    tmp = (symlist_chain *)tmp___0;
    }
#line 271
    if (tmp) {
#line 273
      tmp->symlist = symlist;
#line 274
      tmp->next = preloaded_symlists;
#line 275
      preloaded_symlists = tmp;
    } else {
#line 279
      errors ++;
    }
  }
#line 283
  return (errors);
}
}
#line 292 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
int lt_dlpreload_default(lt_dlsymlist const   *preloaded ) 
{ 


  {
#line 295
  default_preloaded_symbols = preloaded;
#line 296
  return (0);
}
}
#line 302 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
int lt_dlpreload(lt_dlsymlist const   *preloaded ) 
{ 
  int errors ;

  {
#line 305
  errors = 0;
#line 307
  if (preloaded) {
    {
#line 309
    errors = add_symlist(preloaded);
    }
  } else {
    {
#line 313
    free_symlists();
    }
#line 315
    if (default_preloaded_symbols) {
      {
#line 317
      errors = lt_dlpreload(default_preloaded_symbols);
      }
    }
  }
#line 321
  return (errors);
}
}
#line 328 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/preopen.c"
int lt_dlpreload_open(char const   *originator , lt_dlpreload_callback_func *func ) 
{ 
  symlist_chain *list ;
  int errors ;
  int found ;
  lt_dlsymlist const   *symbol ;
  unsigned int idx ;
  lt_dlhandle handle ;
  lt_dlhandle tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 332
  errors = 0;
#line 333
  found = 0;
#line 336
  list = preloaded_symlists;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! list) {
#line 336
      goto while_break;
    }
#line 339
    if (originator) {
      {
#line 339
      tmp___2 = strcmp((char const   *)(list->symlist)->name, originator);
      }
#line 339
      if (tmp___2) {
#line 339
        goto _L___0;
      } else {
#line 339
        goto _L;
      }
    } else
    _L___0: /* CIL Label */ 
#line 339
    if (! originator) {
      {
#line 339
      tmp___3 = strcmp((char const   *)(list->symlist)->name, "@PROGRAM@");
      }
#line 339
      if (! tmp___3) {
        _L: /* CIL Label */ 
#line 343
        idx = 0U;
#line 345
        found ++;
        {
#line 349
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 349
          idx ++;
#line 349
          symbol = list->symlist + idx;
#line 349
          if (! ((unsigned long )symbol->name != (unsigned long )((char const   */* const  */)0))) {
#line 349
            goto while_break___0;
          }
#line 351
          if ((unsigned long )symbol->address == (unsigned long )((void */* const  */)0)) {
            {
#line 351
            tmp___1 = strcmp((char const   *)symbol->name, "@PROGRAM@");
            }
#line 351
            if (tmp___1 != 0) {
              {
#line 354
              tmp = lt_dlopen((char const   *)symbol->name);
#line 354
              handle = tmp;
              }
#line 355
              if ((unsigned long )handle == (unsigned long )((lt_dlhandle )0)) {
#line 357
                errors ++;
              } else {
                {
#line 361
                tmp___0 = (*func)(handle);
#line 361
                errors += tmp___0;
                }
              }
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 336
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  if (! found) {
    {
#line 370
    tmp___4 = lt__error_string(8);
#line 370
    lt__set_last_error(tmp___4);
#line 371
    errors ++;
    }
  }
#line 374
  return (errors);
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 127
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 138
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 47 "libltdl/lt__alloc.h"
void (*lt__alloc_die)(void) ;
#line 49
void *lt__malloc(size_t n ) ;
#line 51
void *lt__realloc(void *mem , size_t n ) ;
#line 54
char *lt__strdup(char const   *string ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 55 "/usr/include/argz.h"
extern  __attribute__((__nothrow__)) error_t argz_create_sep(char const   * __restrict  __string ,
                                                             int __sep , char ** __restrict  __argz ,
                                                             size_t * __restrict  __len ) ;
#line 75
extern  __attribute__((__nothrow__)) void argz_stringify(char *__argz , size_t __len ,
                                                         int __sep ) ;
#line 82
extern  __attribute__((__nothrow__)) error_t argz_append(char ** __restrict  __argz ,
                                                         size_t * __restrict  __argz_len ,
                                                         char const   * __restrict  __buf ,
                                                         size_t __buf_len ) ;
#line 124
extern  __attribute__((__nothrow__)) error_t argz_insert(char ** __restrict  __argz ,
                                                         size_t * __restrict  __argz_len ,
                                                         char * __restrict  __before ,
                                                         char const   * __restrict  __entry ) ;
#line 159
extern  __attribute__((__nothrow__)) char *argz_next(char const   * __restrict  __argz ,
                                                     size_t __argz_len , char const   * __restrict  __entry ) ;
#line 73 "./libltdl/lt_dlloader.h"
int lt_dlloader_add(lt_dlvtable const   *vtable___1 ) ;
#line 74
lt_dlloader lt_dlloader_next(lt_dlloader const   loader ) ;
#line 76
lt_dlvtable *lt_dlloader_remove(char *name ) ;
#line 77
lt_dlvtable const   *lt_dlloader_find(char *name ) ;
#line 78
lt_dlvtable const   *lt_dlloader_get(lt_dlloader loader ) ;
#line 53 "./ltdl.h"
int lt_dlinit(void) ;
#line 54
int lt_dlexit(void) ;
#line 57
int lt_dladdsearchdir(char const   *search_dir ) ;
#line 58
int lt_dlinsertsearchdir(char const   *before , char const   *search_dir ) ;
#line 60
int lt_dlsetsearchpath(char const   *search_path ) ;
#line 61
char const   *lt_dlgetsearchpath(void) ;
#line 62
int lt_dlforeachfile(char const   *search_path , int (*func)(char const   *filename ,
                                                             void *data ) , void *data ) ;
#line 68
int lt_dladvise_init(lt_dladvise *padvise ) ;
#line 69
int lt_dladvise_destroy(lt_dladvise *padvise ) ;
#line 70
int lt_dladvise_ext(lt_dladvise *padvise ) ;
#line 71
int lt_dladvise_resident(lt_dladvise *padvise ) ;
#line 72
int lt_dladvise_local(lt_dladvise *padvise ) ;
#line 73
int lt_dladvise_global(lt_dladvise *padvise ) ;
#line 77
lt_dlhandle lt_dlopenext(char const   *filename ) ;
#line 78
lt_dlhandle lt_dlopenadvise(char const   *filename , lt_dladvise advise ) ;
#line 80
void *lt_dlsym(lt_dlhandle place , char const   *symbol ) ;
#line 81
char const   *lt_dlerror(void) ;
#line 82
int lt_dlclose(lt_dlhandle handle ) ;
#line 119
lt_dlinterface_id lt_dlinterface_register(char const   *id_string___0 , lt_dlhandle_interface *iface ) ;
#line 121
void lt_dlinterface_free(lt_dlinterface_id key ) ;
#line 122
void *lt_dlcaller_set_data(lt_dlinterface_id key , lt_dlhandle handle , void *data ) ;
#line 124
void *lt_dlcaller_get_data(lt_dlinterface_id key , lt_dlhandle handle ) ;
#line 141
lt_dlinfo const   *lt_dlgetinfo(lt_dlhandle handle ) ;
#line 143
lt_dlhandle lt_dlhandle_iterate(lt_dlinterface_id iface , lt_dlhandle place ) ;
#line 145
lt_dlhandle lt_dlhandle_fetch(lt_dlinterface_id iface , char const   *module_name ) ;
#line 147
int lt_dlhandle_map(lt_dlinterface_id iface , int (*func)(lt_dlhandle handle , void *data ) ,
                    void *data ) ;
#line 154
int lt_dlmakeresident(lt_dlhandle handle ) ;
#line 155
int lt_dlisresident(lt_dlhandle handle ) ;
#line 93 "libltdl/lt__private.h"
void lt__alloc_die_callback(void) ;
#line 143
char const   *lt__get_last_error(void) ;
#line 68 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static char const   objdir[7]  = {      (char const   )'.',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'s',      (char const   )'/',      (char const   )'\000'};
#line 69 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static char const   archive_ext[4]  = {      (char const   )'.',      (char const   )'l',      (char const   )'a',      (char const   )'\000'};
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static char const   shlib_ext[4]  = {      (char const   )'.',      (char const   )'s',      (char const   )'o',      (char const   )'\000'};
#line 74 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static char const   sys_dlsearch_path[105]  = 
#line 74
  {      (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )':',      (char const   )'/',      (char const   )'u',      (char const   )'s', 
        (char const   )'r',      (char const   )'/',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'i',      (char const   )'b',      (char const   )'/',      (char const   )'m', 
        (char const   )'e',      (char const   )'s',      (char const   )'a',      (char const   )':', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'/',      (char const   )'i',      (char const   )'4',      (char const   )'8', 
        (char const   )'6',      (char const   )'-',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'u',      (char const   )'x',      (char const   )'-', 
        (char const   )'g',      (char const   )'n',      (char const   )'u',      (char const   )':', 
        (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'/',      (char const   )'i',      (char const   )'4',      (char const   )'8', 
        (char const   )'6',      (char const   )'-',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'u',      (char const   )'x',      (char const   )'-', 
        (char const   )'g',      (char const   )'n',      (char const   )'u',      (char const   )':', 
        (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'/',      (char const   )'a',      (char const   )'l',      (char const   )'s', 
        (char const   )'a',      (char const   )'-',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'o',      (char const   )'c',      (char const   )'a',      (char const   )'l', 
        (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'\000'};
#line 90
static int foreach_dirinpath(char const   *search_path , char const   *base_name ,
                             foreach_callback_func *func , void *data1 , void *data2 ) ;
#line 94
static int find_file_callback(char *filename , void *data1 , void *data2 ) ;
#line 96
static int find_handle_callback(char *filename , void *data , void *data2 ) ;
#line 98
static int foreachfile_callback(char *dirname , void *data1 , void *data2 ) ;
#line 102
static int canonicalize_path(char const   *path , char **pcanonical ) ;
#line 103
static int argzize_path(char const   *path , char **pargz , size_t *pargz_len ) ;
#line 105
static FILE *find_file(char const   *search_path , char const   *base_name , char **pdir ) ;
#line 107
static lt_dlhandle *find_handle(char const   *search_path , char const   *base_name ,
                                lt_dlhandle *phandle , lt_dladvise advise ) ;
#line 111
static int find_module(lt_dlhandle *handle , char const   *dir , char const   *libdir ,
                       char const   *dlname , char const   *old_name , int installed ,
                       lt_dladvise advise ) ;
#line 115
static int has_library_ext(char const   *filename ) ;
#line 116
static int load_deplibs(lt_dlhandle handle , char *deplibs  __attribute__((__unused__)) ) ;
#line 117
static int trim(char **dest , char const   *str ) ;
#line 118
static int try_dlopen(lt_dlhandle *phandle , char const   *filename , char const   *ext ,
                      lt_dladvise advise ) ;
#line 121
static int tryall_dlopen(lt_dlhandle *phandle , char const   *filename , lt_dladvise advise ,
                         lt_dlvtable const   *vtable___1 ) ;
#line 125
static int unload_deplibs(lt_dlhandle handle ) ;
#line 126
static int lt_argz_insert(char **pargz , size_t *pargz_len , char *before , char const   *entry ) ;
#line 128
static int lt_argz_insertinorder(char **pargz , size_t *pargz_len , char const   *entry ) ;
#line 130
static int lt_argz_insertdir(char **pargz , size_t *pargz_len , char const   *dirnam ,
                             struct dirent *dp ) ;
#line 132
static int lt_dlpath_insertdir(char **ppath , char *before , char const   *dir ) ;
#line 134
static int list_files_by_dir(char const   *dirnam , char **pargz , size_t *pargz_len ) ;
#line 136
static int file_not_found(void) ;
#line 139
static int loader_init_callback(lt_dlhandle handle ) ;
#line 142
static int loader_init(lt_get_vtable *vtable_func , lt_user_data data ) ;
#line 145 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static char *user_search_path  =    (char *)0;
#line 146 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static lt_dlhandle handles  =    (lt_dlhandle )0;
#line 147 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int initialized  =    0;
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
void lt__alloc_die_callback(void) 
{ 
  char const   *tmp ;

  {
  {
#line 155
  tmp = lt__error_string(11);
#line 155
  lt__set_last_error(tmp);
  }
#line 156
  return;
}
}
#line 162 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int loader_init_callback(lt_dlhandle handle ) 
{ 
  lt_get_vtable *vtable_func ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 165
  tmp = lt_dlsym(handle, "get_vtable");
#line 165
  vtable_func = (lt_get_vtable *)tmp;
#line 166
  tmp___0 = loader_init(vtable_func, (lt_user_data )0);
  }
#line 166
  return (tmp___0);
}
}
#line 170 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int loader_init(lt_get_vtable *vtable_func , lt_user_data data ) 
{ 
  lt_dlvtable const   *vtable___1 ;
  int errors ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 173
  vtable___1 = (lt_dlvtable const   *)0;
#line 174
  errors = 0;
#line 176
  if (vtable_func) {
    {
#line 178
    vtable___1 = (*vtable_func)(data);
    }
  }
  {
#line 182
  tmp = lt_dlloader_add(vtable___1);
#line 182
  errors += tmp;
  }
#line 184
  if (! errors) {
#line 184
    if (! vtable___1) {
      {
#line 184
      __assert_fail("errors || vtable", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    184U, "loader_init");
      }
    }
  }
#line 186
  if (! errors) {
#line 186
    if (vtable___1->dlloader_init) {
      {
#line 188
      tmp___1 = (*(vtable___1->dlloader_init))((lt_user_data )vtable___1->dlloader_data);
      }
#line 188
      if (tmp___1) {
        {
#line 190
        tmp___0 = lt__error_string(3);
#line 190
        lt__set_last_error(tmp___0);
#line 191
        errors ++;
        }
      }
    }
  }
#line 195
  return (errors);
}
}
#line 206
extern lt_dlsymlist lt_libltdlc_LTX_preloaded_symbols ;
#line 210 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlinit(void) 
{ 
  int errors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;

  {
#line 213
  errors = 0;
#line 216
  initialized ++;
#line 216
  if (initialized == 1) {
    {
#line 218
    lt__alloc_die = & lt__alloc_die_callback;
#line 219
    handles = (lt_dlhandle )0;
#line 220
    user_search_path = (char *)0;
#line 225
    tmp = loader_init(& preopen_LTX_get_vtable, (lt_user_data )0);
#line 225
    errors += tmp;
    }
#line 230
    if (! errors) {
      {
#line 232
      tmp___0 = lt_dlpreload((lt_dlsymlist const   *)(& lt_libltdlc_LTX_preloaded_symbols));
#line 232
      errors += tmp___0;
      }
    }
#line 235
    if (! errors) {
      {
#line 237
      tmp___1 = lt_dlpreload_open("libltdlc", & loader_init_callback);
#line 237
      errors += tmp___1;
      }
    }
  }
#line 246
  return (errors);
}
}
#line 249 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlexit(void) 
{ 
  lt_dlloader *loader ;
  lt_dlhandle handle ;
  int errors ;
  char const   *tmp ;
  int level ;
  lt_dlhandle cur ;
  int saw_nonresident ;
  lt_dlhandle tmp___0 ;
  int tmp___1 ;
  lt_dlloader tmp___2 ;
  lt_dlloader *next ;
  lt_dlloader tmp___3 ;
  lt_dlvtable *vtable___1 ;
  lt_dlvtable const   *tmp___4 ;
  char const   *err ;

  {
#line 253
  loader = (lt_dlloader *)0;
#line 254
  handle = handles;
#line 255
  errors = 0;
#line 257
  if (! initialized) {
    {
#line 259
    tmp = lt__error_string(15);
#line 259
    lt__set_last_error(tmp);
#line 260
    errors ++;
    }
#line 261
    goto done;
  }
#line 265
  initialized --;
#line 265
  if (initialized == 0) {
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      if (handles) {
#line 269
        if (! handles->info.is_resident) {
#line 269
          goto while_break;
        }
      } else {
#line 269
        goto while_break;
      }
#line 271
      handles = handles->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 275
    level = 1;
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! handle) {
#line 275
        goto while_break___0;
      }
#line 277
      cur = handles;
#line 278
      saw_nonresident = 0;
      {
#line 280
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 280
        if (! cur) {
#line 280
          goto while_break___1;
        }
#line 282
        tmp___0 = cur;
#line 283
        cur = cur->next;
#line 284
        if (! tmp___0->info.is_resident) {
#line 286
          saw_nonresident = 1;
#line 287
          if (tmp___0->info.ref_count <= level) {
            {
#line 289
            tmp___1 = lt_dlclose(tmp___0);
            }
#line 289
            if (tmp___1) {
#line 291
              errors ++;
            }
#line 297
            if (cur) {
#line 299
              tmp___0 = handles;
              {
#line 299
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 299
                if (! tmp___0) {
#line 299
                  goto while_break___2;
                }
#line 300
                if ((unsigned long )tmp___0 == (unsigned long )cur) {
#line 301
                  goto while_break___2;
                }
#line 299
                tmp___0 = tmp___0->next;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 302
              if (! tmp___0) {
#line 303
                cur = handles;
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 309
      if (! saw_nonresident) {
#line 310
        goto while_break___0;
      }
#line 275
      level ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 316
    if (! errors) {
      {
#line 317
      lt__set_last_error((char const   *)0);
      }
    }
    {
#line 320
    tmp___2 = lt_dlloader_next((lt_dlloader const   )((void *)0));
#line 320
    loader = (lt_dlloader *)tmp___2;
    }
    {
#line 320
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 320
      if (! loader) {
#line 320
        goto while_break___3;
      }
      {
#line 322
      tmp___3 = lt_dlloader_next((lt_dlloader const   )loader);
#line 322
      next = (lt_dlloader *)tmp___3;
#line 323
      tmp___4 = lt_dlloader_get((lt_dlloader )loader);
#line 323
      vtable___1 = (lt_dlvtable *)tmp___4;
#line 325
      vtable___1 = lt_dlloader_remove((char *)vtable___1->name);
      }
#line 325
      if (vtable___1) {
#line 327
        if (vtable___1) {
          {
#line 327
          free((void *)vtable___1);
#line 327
          vtable___1 = (lt_dlvtable *)((void *)0);
          }
        }
      } else {
        {
#line 333
        err = lt__get_last_error();
        }
#line 334
        if (err) {
#line 335
          errors ++;
        }
      }
#line 338
      loader = next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 341
    if (user_search_path) {
      {
#line 341
      free((void *)user_search_path);
#line 341
      user_search_path = (char *)((void *)0);
      }
    }
  }
  done: 
#line 345
  return (errors);
}
}
#line 352 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int tryall_dlopen(lt_dlhandle *phandle , char const   *filename , lt_dladvise advise ,
                         lt_dlvtable const   *vtable___1 ) 
{ 
  lt_dlhandle handle ;
  char const   *saved_error ;
  int errors ;
  int tmp ;
  lt_dlloader loader ;
  lt_dlloader tmp___0 ;
  lt_dlvtable const   *loader_vtable ;

  {
  {
#line 356
  handle = handles;
#line 357
  saved_error = (char const   *)0;
#line 358
  errors = 0;
#line 366
  saved_error = lt__get_last_error();
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! handle) {
#line 369
      goto while_break;
    }
#line 371
    if ((unsigned long )handle->info.filename == (unsigned long )filename) {
#line 375
      goto while_break;
    } else
#line 371
    if (handle->info.filename) {
#line 371
      if (filename) {
        {
#line 371
        tmp = strcmp((char const   *)handle->info.filename, filename);
        }
#line 371
        if (! tmp) {
#line 375
          goto while_break;
        }
      }
    }
#line 369
    handle = handle->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  if (handle) {
#line 381
    (handle->info.ref_count) ++;
#line 382
    *phandle = handle;
#line 383
    goto done;
  }
#line 386
  handle = *phandle;
#line 387
  if (filename) {
    {
#line 401
    handle->info.filename = lt__strdup(filename);
    }
#line 402
    if (! handle->info.filename) {
#line 404
      errors ++;
#line 405
      goto done;
    }
  } else {
#line 410
    handle->info.filename = (char *)0;
  }
  {
#line 414
  tmp___0 = lt_dlloader_next((lt_dlloader const   )0);
#line 414
  loader = tmp___0;
  }
  {
#line 417
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 419
    if (vtable___1) {
#line 420
      loader_vtable = vtable___1;
    } else {
      {
#line 422
      loader_vtable = lt_dlloader_get(loader);
      }
    }
    {
#line 429
    handle->module = (*(loader_vtable->module_open))((lt_user_data )loader_vtable->dlloader_data,
                                                     filename, advise);
    }
#line 436
    if ((unsigned long )handle->module != (unsigned long )((lt_module )0)) {
#line 438
      if (advise) {
#line 440
        handle->info.is_resident = advise->is_resident;
#line 441
        handle->info.is_symglobal = advise->is_symglobal;
#line 442
        handle->info.is_symlocal = advise->is_symlocal;
      }
#line 444
      goto while_break___0;
    }
#line 417
    if (! vtable___1) {
      {
#line 417
      loader = lt_dlloader_next((lt_dlloader const   )loader);
      }
#line 417
      if (! loader) {
#line 417
        goto while_break___0;
      }
    } else {
#line 417
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 452
  if (vtable___1) {
#line 452
    if (! handle->module) {
#line 452
      goto _L;
    } else {
#line 452
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 452
  if (! vtable___1) {
#line 452
    if (! loader) {
      _L: /* CIL Label */ 
#line 455
      if (handle->info.filename) {
        {
#line 455
        free((void *)handle->info.filename);
#line 455
        handle->info.filename = (char *)((void *)0);
        }
      }
#line 456
      errors ++;
#line 457
      goto done;
    }
  }
  {
#line 460
  handle->vtable = loader_vtable;
#line 463
  lt__set_last_error(saved_error);
  }
  done: 
#line 466
  return (errors);
}
}
#line 470 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int tryall_dlopen_module(lt_dlhandle *handle , char const   *prefix___0 , char const   *dirname ,
                                char const   *dlname , lt_dladvise advise ) 
{ 
  int error ;
  char *filename ;
  size_t filename_len ;
  size_t dirname_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 475
  error = 0;
#line 476
  filename = (char *)0;
#line 477
  filename_len = (size_t )0;
#line 478
  if (dirname) {
#line 478
    if (*(dirname + 0)) {
      {
#line 478
      tmp = strlen(dirname);
#line 478
      tmp___0 = tmp;
      }
    } else {
#line 478
      tmp___0 = (size_t )0;
    }
  } else {
#line 478
    tmp___0 = (size_t )0;
  }
#line 478
  dirname_len = tmp___0;
#line 480
  if (! handle) {
    {
#line 480
    __assert_fail("handle", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  480U, "tryall_dlopen_module");
    }
  }
#line 481
  if (! dirname) {
    {
#line 481
    __assert_fail("dirname", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  481U, "tryall_dlopen_module");
    }
  }
#line 482
  if (! dlname) {
    {
#line 482
    __assert_fail("dlname", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  482U, "tryall_dlopen_module");
    }
  }
#line 489
  if (dirname_len > 0U) {
#line 490
    if ((int const   )*(dirname + (dirname_len - 1U)) == 47) {
#line 491
      dirname_len --;
    }
  }
#line 492
  if (dlname) {
#line 492
    if (*(dlname + 0)) {
      {
#line 492
      tmp___1 = strlen(dlname);
#line 492
      tmp___2 = tmp___1;
      }
    } else {
#line 492
      tmp___2 = (size_t )0;
    }
  } else {
#line 492
    tmp___2 = (size_t )0;
  }
  {
#line 492
  filename_len = (dirname_len + 1U) + tmp___2;
#line 496
  tmp___3 = lt__malloc((size_t )((unsigned long )(filename_len + 1U) * sizeof(char )));
#line 496
  filename = (char *)tmp___3;
  }
#line 497
  if (! filename) {
#line 498
    return (1);
  }
  {
#line 500
  sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%.*s/%s",
          (int )dirname_len, dirname, dlname);
  }
#line 505
  if (prefix___0) {
    {
#line 507
    tmp___4 = tryall_dlopen_module(handle, (char const   *)0, prefix___0, (char const   *)filename,
                                   advise);
#line 507
    error += tmp___4;
    }
  } else {
    {
#line 510
    tmp___5 = tryall_dlopen(handle, (char const   *)filename, advise, (lt_dlvtable const   *)0);
    }
#line 510
    if (tmp___5 != 0) {
#line 512
      error ++;
    }
  }
#line 515
  if (filename) {
    {
#line 515
    free((void *)filename);
#line 515
    filename = (char *)((void *)0);
    }
  }
#line 516
  return (error);
}
}
#line 519 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int find_module(lt_dlhandle *handle , char const   *dir , char const   *libdir ,
                       char const   *dlname , char const   *old_name , int installed ,
                       lt_dladvise advise ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 527
  if (old_name) {
    {
#line 527
    tmp = tryall_dlopen(handle, old_name, advise, (lt_dlvtable const   *)0);
    }
#line 527
    if (tmp == 0) {
#line 529
      return (0);
    }
  }
#line 533
  if (dlname) {
#line 536
    if (installed) {
#line 536
      if (libdir) {
        {
#line 538
        tmp___0 = tryall_dlopen_module(handle, (char const   *)0, libdir, dlname,
                                       advise);
        }
#line 538
        if (tmp___0 == 0) {
#line 540
          return (0);
        }
      }
    }
#line 544
    if (! installed) {
      {
#line 546
      tmp___1 = tryall_dlopen_module(handle, dir, objdir, dlname, advise);
      }
#line 546
      if (tmp___1 == 0) {
#line 548
        return (0);
      }
    }
#line 553
    if (dir) {
      {
#line 553
      tmp___2 = tryall_dlopen_module(handle, (char const   *)0, dir, dlname, advise);
      }
#line 553
      if (tmp___2 == 0) {
#line 555
        return (0);
      }
    }
  }
#line 559
  return (1);
}
}
#line 563 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int canonicalize_path(char const   *path , char **pcanonical ) 
{ 
  char *canonical ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t dest ;
  size_t src ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 566
  canonical = (char *)0;
#line 568
  if (path) {
#line 568
    if (! *path) {
      {
#line 568
      __assert_fail("path && *path", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    568U, "canonicalize_path");
      }
    }
  } else {
    {
#line 568
    __assert_fail("path && *path", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  568U, "canonicalize_path");
    }
  }
#line 569
  if (! pcanonical) {
    {
#line 569
    __assert_fail("pcanonical", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  569U, "canonicalize_path");
    }
  }
#line 571
  if (path) {
#line 571
    if (*(path + 0)) {
      {
#line 571
      tmp = strlen(path);
#line 571
      tmp___0 = tmp;
      }
    } else {
#line 571
      tmp___0 = (size_t )0;
    }
  } else {
#line 571
    tmp___0 = (size_t )0;
  }
  {
#line 571
  tmp___1 = lt__malloc((size_t )((unsigned long )(1U + tmp___0) * sizeof(char )));
#line 571
  canonical = (char *)tmp___1;
  }
#line 572
  if (! canonical) {
#line 573
    return (1);
  }
#line 576
  dest = (size_t )0;
#line 578
  src = (size_t )0;
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 578
    if (! ((int const   )*(path + src) != 0)) {
#line 578
      goto while_break;
    }
#line 583
    if ((int const   )*(path + src) == 58) {
#line 585
      if (dest == 0U) {
#line 588
        goto __Cont;
      } else
#line 585
      if ((int const   )*(path + (1U + src)) == 58) {
#line 588
        goto __Cont;
      } else
#line 585
      if ((int const   )*(path + (1U + src)) == 0) {
#line 588
        goto __Cont;
      }
    }
#line 592
    if ((int const   )*(path + src) != 47) {
#line 598
      tmp___2 = dest;
#line 598
      dest ++;
#line 598
      *(canonical + tmp___2) = (char )*(path + src);
    } else
#line 603
    if ((int const   )*(path + (1U + src)) != 58) {
#line 603
      if ((int const   )*(path + (1U + src)) != 0) {
#line 603
        if ((int const   )*(path + (1U + src)) != 47) {
#line 610
          tmp___3 = dest;
#line 610
          dest ++;
#line 610
          *(canonical + tmp___3) = (char )'/';
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 578
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 615
  *(canonical + dest) = (char )'\000';
#line 619
  *pcanonical = canonical;
#line 621
  return (0);
}
}
#line 624 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int argzize_path(char const   *path , char **pargz , size_t *pargz_len ) 
{ 
  error_t error ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 629
  if (! path) {
    {
#line 629
    __assert_fail("path", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  629U, "argzize_path");
    }
  }
#line 630
  if (! pargz) {
    {
#line 630
    __assert_fail("pargz", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  630U, "argzize_path");
    }
  }
#line 631
  if (! pargz_len) {
    {
#line 631
    __assert_fail("pargz_len", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  631U, "argzize_path");
    }
  }
  {
#line 633
  error = argz_create_sep((char const   */* __restrict  */)path, ':', (char **/* __restrict  */)pargz,
                          (size_t */* __restrict  */)pargz_len);
  }
#line 633
  if (error) {
    {
#line 637
    if (error == 12) {
#line 637
      goto case_12;
    }
#line 640
    goto switch_default;
    case_12: /* CIL Label */ 
    {
#line 638
    tmp = lt__error_string(11);
#line 638
    lt__set_last_error(tmp);
    }
#line 639
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 641
    tmp___0 = lt__error_string(0);
#line 641
    lt__set_last_error(tmp___0);
    }
#line 642
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 645
    return (1);
  }
#line 648
  return (0);
}
}
#line 655 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int foreach_dirinpath(char const   *search_path , char const   *base_name ,
                             foreach_callback_func *func , void *data1 , void *data2 ) 
{ 
  int result ;
  size_t filenamesize ;
  size_t lenbase ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t argz_len ;
  char *argz ;
  char *filename ;
  char *canonical ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *dir_name ;
  size_t lendir ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 659
  result = 0;
#line 660
  filenamesize = (size_t )0;
#line 661
  if (base_name) {
#line 661
    if (*(base_name + 0)) {
      {
#line 661
      tmp = strlen(base_name);
#line 661
      tmp___0 = tmp;
      }
    } else {
#line 661
      tmp___0 = (size_t )0;
    }
  } else {
#line 661
    tmp___0 = (size_t )0;
  }
#line 661
  lenbase = tmp___0;
#line 662
  argz_len = (size_t )0;
#line 663
  argz = (char *)0;
#line 664
  filename = (char *)0;
#line 665
  canonical = (char *)0;
#line 667
  if (! search_path) {
    {
#line 669
    tmp___1 = lt__error_string(5);
#line 669
    lt__set_last_error(tmp___1);
    }
#line 670
    goto cleanup;
  } else
#line 667
  if (! *search_path) {
    {
#line 669
    tmp___1 = lt__error_string(5);
#line 669
    lt__set_last_error(tmp___1);
    }
#line 670
    goto cleanup;
  }
  {
#line 673
  tmp___2 = canonicalize_path(search_path, & canonical);
  }
#line 673
  if (tmp___2 != 0) {
#line 674
    goto cleanup;
  }
  {
#line 676
  tmp___3 = argzize_path((char const   *)canonical, & argz, & argz_len);
  }
#line 676
  if (tmp___3 != 0) {
#line 677
    goto cleanup;
  }
#line 680
  dir_name = (char *)0;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 681
    dir_name = argz_next((char const   */* __restrict  */)argz, argz_len, (char const   */* __restrict  */)dir_name);
    }
#line 681
    if (! dir_name) {
#line 681
      goto while_break;
    }
#line 683
    if (dir_name) {
#line 683
      if (*(dir_name + 0)) {
        {
#line 683
        tmp___4 = strlen((char const   *)dir_name);
#line 683
        tmp___5 = tmp___4;
        }
      } else {
#line 683
        tmp___5 = (size_t )0;
      }
    } else {
#line 683
      tmp___5 = (size_t )0;
    }
#line 683
    lendir = tmp___5;
#line 685
    if ((1U + lendir) + lenbase >= filenamesize) {
#line 687
      if (filename) {
        {
#line 687
        free((void *)filename);
#line 687
        filename = (char *)((void *)0);
        }
      }
      {
#line 688
      filenamesize = ((1U + lendir) + 1U) + lenbase;
#line 689
      tmp___6 = lt__malloc((size_t )((unsigned long )filenamesize * sizeof(char )));
#line 689
      filename = (char *)tmp___6;
      }
#line 690
      if (! filename) {
#line 691
        goto cleanup;
      }
    }
#line 694
    if (! (filenamesize > lendir)) {
      {
#line 694
      __assert_fail("filenamesize > lendir", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    694U, "foreach_dirinpath");
      }
    }
    {
#line 695
    strcpy((char */* __restrict  */)filename, (char const   */* __restrict  */)dir_name);
    }
#line 697
    if (base_name) {
#line 697
      if (*base_name) {
#line 699
        if ((int )*(filename + (lendir - 1U)) != 47) {
#line 700
          tmp___7 = lendir;
#line 700
          lendir ++;
#line 700
          *(filename + tmp___7) = (char )'/';
        }
        {
#line 701
        strcpy((char */* __restrict  */)(filename + lendir), (char const   */* __restrict  */)base_name);
        }
      }
    }
    {
#line 704
    result = (*func)(filename, data1, data2);
    }
#line 704
    if (result) {
#line 706
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 712
  if (argz) {
    {
#line 712
    free((void *)argz);
#line 712
    argz = (char *)((void *)0);
    }
  }
#line 713
  if (canonical) {
    {
#line 713
    free((void *)canonical);
#line 713
    canonical = (char *)((void *)0);
    }
  }
#line 714
  if (filename) {
    {
#line 714
    free((void *)filename);
#line 714
    filename = (char *)((void *)0);
    }
  }
#line 716
  return (result);
}
}
#line 722 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int find_file_callback(char *filename , void *data1 , void *data2 ) 
{ 
  char **pdir ;
  FILE **pfile ;
  int is_done ;
  char *dirend ;
  char *tmp ;
  FILE *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 725
  pdir = (char **)data1;
#line 726
  pfile = (FILE **)data2;
#line 727
  is_done = 0;
#line 729
  if (filename) {
#line 729
    if (! *filename) {
      {
#line 729
      __assert_fail("filename && *filename", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    729U, "find_file_callback");
      }
    }
  } else {
    {
#line 729
    __assert_fail("filename && *filename", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  729U, "find_file_callback");
    }
  }
#line 730
  if (! pdir) {
    {
#line 730
    __assert_fail("pdir", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  730U, "find_file_callback");
    }
  }
#line 731
  if (! pfile) {
    {
#line 731
    __assert_fail("pfile", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  731U, "find_file_callback");
    }
  }
  {
#line 733
  tmp___0 = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
#line 733
  *pfile = tmp___0;
  }
#line 733
  if (tmp___0) {
    {
#line 735
    tmp = strrchr((char const   *)filename, '/');
#line 735
    dirend = tmp;
    }
#line 737
    if ((unsigned long )dirend > (unsigned long )filename) {
#line 738
      *dirend = (char )'\000';
    }
#line 740
    if (*pdir) {
      {
#line 740
      free((void *)*pdir);
#line 740
      *pdir = (char *)((void *)0);
      }
    }
    {
#line 741
    *pdir = lt__strdup((char const   *)filename);
    }
#line 742
    if ((unsigned long )*pdir == (unsigned long )((char *)0)) {
#line 742
      is_done = -1;
    } else {
#line 742
      is_done = 1;
    }
  }
#line 745
  return (is_done);
}
}
#line 748 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static FILE *find_file(char const   *search_path , char const   *base_name , char **pdir ) 
{ 
  FILE *file ;

  {
  {
#line 751
  file = (FILE *)0;
#line 753
  foreach_dirinpath(search_path, base_name, & find_file_callback, (void *)pdir, (void *)(& file));
  }
#line 755
  return (file);
}
}
#line 758 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int find_handle_callback(char *filename , void *data , void *data2 ) 
{ 
  lt_dlhandle *phandle ;
  int notfound ;
  int tmp ;
  lt_dladvise advise ;
  int tmp___0 ;

  {
  {
#line 761
  phandle = (lt_dlhandle *)data;
#line 762
  tmp = access((char const   *)filename, 4);
#line 762
  notfound = tmp;
#line 763
  advise = (lt_dladvise )data2;
  }
#line 766
  if (notfound) {
#line 767
    return (0);
  }
  {
#line 771
  tmp___0 = tryall_dlopen(phandle, (char const   *)filename, advise, (lt_dlvtable const   *)0);
  }
#line 771
  if (tmp___0 != 0) {
#line 772
    *phandle = (lt_dlhandle )0;
  }
#line 774
  return (1);
}
}
#line 779 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static lt_dlhandle *find_handle(char const   *search_path , char const   *base_name ,
                                lt_dlhandle *phandle , lt_dladvise advise ) 
{ 
  int tmp ;

  {
#line 783
  if (! search_path) {
#line 784
    return ((lt_dlhandle *)0);
  }
  {
#line 786
  tmp = foreach_dirinpath(search_path, base_name, & find_handle_callback, (void *)phandle,
                          (void *)advise);
  }
#line 786
  if (! tmp) {
#line 788
    return ((lt_dlhandle *)0);
  }
#line 790
  return (phandle);
}
}
#line 794 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int load_deplibs(lt_dlhandle handle , char *deplibs  __attribute__((__unused__)) ) 
{ 


  {
#line 797
  handle->depcount = 0;
#line 798
  return (0);
}
}
#line 958 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int unload_deplibs(lt_dlhandle handle ) 
{ 
  int i ;
  int errors ;
  lt_dlhandle cur ;
  int tmp ;

  {
#line 962
  errors = 0;
#line 963
  cur = handle;
#line 965
  if (cur->depcount) {
#line 967
    i = 0;
    {
#line 967
    while (1) {
      while_continue: /* CIL Label */ ;
#line 967
      if (! (i < cur->depcount)) {
#line 967
        goto while_break;
      }
#line 969
      if (! (*(cur->deplibs + i))->info.is_resident) {
        {
#line 971
        tmp = lt_dlclose(*(cur->deplibs + i));
#line 971
        errors += tmp;
        }
      }
#line 967
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 974
    if (cur->deplibs) {
      {
#line 974
      free((void *)cur->deplibs);
#line 974
      cur->deplibs = (lt_dlhandle *)((void *)0);
      }
    }
  }
#line 977
  return (errors);
}
}
#line 980 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int trim(char **dest , char const   *str ) 
{ 
  char const   *end ;
  char *tmp ;
  size_t len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 985
  tmp = strrchr(str, '\'');
#line 985
  end = (char const   *)tmp;
  }
#line 986
  if (str) {
#line 986
    if (*(str + 0)) {
      {
#line 986
      tmp___0 = strlen(str);
#line 986
      tmp___1 = tmp___0;
      }
    } else {
#line 986
      tmp___1 = (size_t )0;
    }
  } else {
#line 986
    tmp___1 = (size_t )0;
  }
#line 986
  len = tmp___1;
#line 989
  if (*dest) {
    {
#line 989
    free((void *)*dest);
#line 989
    *dest = (char *)((void *)0);
    }
  }
#line 991
  if (! end) {
#line 992
    return (1);
  }
#line 994
  if (len > 3U) {
#line 994
    if ((int const   )*(str + 0) == 39) {
      {
#line 996
      tmp___3 = lt__malloc((size_t )((unsigned long )(end - str) * sizeof(char )));
#line 996
      tmp___2 = (char *)tmp___3;
      }
#line 997
      if (! tmp___2) {
#line 998
        return (1);
      }
      {
#line 1000
      memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)(str + 1),
             (size_t )((end - str) - 1L));
#line 1001
      *(tmp___2 + ((end - str) - 1L)) = (char )'\000';
#line 1002
      *dest = tmp___2;
      }
    } else {
#line 1006
      *dest = (char *)0;
    }
  } else {
#line 1006
    *dest = (char *)0;
  }
#line 1009
  return (0);
}
}
#line 1013 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int parse_dotla_file(FILE *file , char **dlname , char **libdir , char **deplibs ,
                            char **old_name , int *installed ) 
{ 
  int errors ;
  size_t line_len ;
  char *line ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *last_libname ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
#line 1017
  errors = 0;
#line 1018
  line_len = (size_t )2048;
#line 1019
  tmp = lt__malloc((size_t )((unsigned long )line_len * sizeof(char )));
#line 1019
  line = (char *)tmp;
  }
#line 1021
  if (! line) {
    {
#line 1023
    tmp___0 = lt__error_string(5);
#line 1023
    lt__set_last_error(tmp___0);
    }
#line 1024
    return (1);
  }
  {
#line 1027
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1027
    tmp___17 = feof(file);
    }
#line 1027
    if (tmp___17) {
#line 1027
      goto while_break;
    }
    {
#line 1029
    *(line + (line_len - 2U)) = (char )'\000';
#line 1030
    tmp___1 = fgets((char */* __restrict  */)line, (int )line_len, (FILE */* __restrict  */)file);
    }
#line 1030
    if (! tmp___1) {
#line 1032
      goto while_break;
    }
    {
#line 1038
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1038
      if ((int )*(line + (line_len - 2U)) != 0) {
#line 1038
        if ((int )*(line + (line_len - 2U)) != 10) {
          {
#line 1038
          tmp___4 = feof(file);
          }
#line 1038
          if (tmp___4) {
#line 1038
            goto while_break___0;
          }
        } else {
#line 1038
          goto while_break___0;
        }
      } else {
#line 1038
        goto while_break___0;
      }
      {
#line 1040
      tmp___2 = lt__realloc((void *)line, (size_t )((unsigned long )(line_len * 2U) * sizeof(char )));
#line 1040
      line = (char *)tmp___2;
      }
#line 1041
      if (! line) {
#line 1043
        errors ++;
#line 1044
        goto cleanup;
      }
      {
#line 1046
      *(line + (line_len * 2U - 2U)) = (char )'\000';
#line 1047
      tmp___3 = fgets((char */* __restrict  */)(line + (line_len - 1U)), (int )line_len + 1,
                      (FILE */* __restrict  */)file);
      }
#line 1047
      if (! tmp___3) {
#line 1049
        goto while_break___0;
      }
#line 1051
      line_len *= 2U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1054
    if ((int )*(line + 0) == 10) {
#line 1056
      goto while_continue;
    } else
#line 1054
    if ((int )*(line + 0) == 35) {
#line 1056
      goto while_continue;
    }
    {
#line 1061
    tmp___16 = strncmp((char const   *)line, "dlname=", (size_t )(sizeof("dlname=") - 1UL));
    }
#line 1061
    if (tmp___16 == 0) {
      {
#line 1063
      tmp___5 = trim(dlname, (char const   *)(line + (sizeof("dlname=") - 1UL)));
#line 1063
      errors += tmp___5;
      }
    } else {
      {
#line 1068
      tmp___15 = strncmp((char const   *)line, "old_library=", (size_t )(sizeof("old_library=") - 1UL));
      }
#line 1068
      if (tmp___15 == 0) {
        {
#line 1071
        tmp___6 = trim(old_name, (char const   *)(line + (sizeof("old_library=") - 1UL)));
#line 1071
        errors += tmp___6;
        }
      } else {
        {
#line 1075
        tmp___14 = strncmp((char const   *)line, "libdir=", (size_t )(sizeof("libdir=") - 1UL));
        }
#line 1075
        if (tmp___14 == 0) {
          {
#line 1077
          tmp___7 = trim(libdir, (char const   *)(line + (sizeof("libdir=") - 1UL)));
#line 1077
          errors += tmp___7;
          }
        } else {
          {
#line 1082
          tmp___13 = strncmp((char const   *)line, "dependency_libs=", (size_t )(sizeof("dependency_libs=") - 1UL));
          }
#line 1082
          if (tmp___13 == 0) {
            {
#line 1085
            tmp___8 = trim(deplibs, (char const   *)(line + (sizeof("dependency_libs=") - 1UL)));
#line 1085
            errors += tmp___8;
            }
          } else {
            {
#line 1087
            tmp___12 = strcmp((char const   *)line, "installed=yes\n");
            }
#line 1087
            if (tmp___12) {
              {
#line 1091
              tmp___11 = strcmp((char const   *)line, "installed=no\n");
              }
#line 1091
              if (tmp___11) {
#line 1098
                if (! *dlname) {
                  {
#line 1098
                  tmp___10 = strncmp((char const   *)line, "library_names=", (size_t )(sizeof("library_names=") - 1UL));
                  }
#line 1098
                  if (tmp___10 == 0) {
                    {
#line 1102
                    tmp___9 = trim(dlname, (char const   *)(line + (sizeof("library_names=") - 1UL)));
#line 1102
                    errors += tmp___9;
                    }
#line 1103
                    if (! errors) {
#line 1103
                      if (*dlname) {
                        {
#line 1103
                        last_libname = strrchr((char const   *)*dlname, ' ');
                        }
#line 1103
                        if ((unsigned long )last_libname != (unsigned long )((char *)0)) {
                          {
#line 1107
                          last_libname = lt__strdup((char const   *)(last_libname + 1));
                          }
#line 1108
                          if (! last_libname) {
#line 1110
                            errors ++;
#line 1111
                            goto cleanup;
                          }
#line 1113
                          if ((unsigned long )*dlname != (unsigned long )last_libname) {
#line 1113
                            if (*dlname) {
                              {
#line 1113
                              free((void *)*dlname);
                              }
                            }
#line 1113
                            *dlname = last_libname;
#line 1113
                            last_libname = (char *)0;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
#line 1093
                *installed = 0;
              }
            } else {
#line 1089
              *installed = 1;
            }
          }
        }
      }
    }
#line 1117
    if (errors) {
#line 1118
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 1121
  if (line) {
    {
#line 1121
    free((void *)line);
#line 1121
    line = (char *)((void *)0);
    }
  }
#line 1122
  return (errors);
}
}
#line 1127 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int try_dlopen(lt_dlhandle *phandle , char const   *filename , char const   *ext ,
                      lt_dladvise advise ) 
{ 
  char const   *saved_error ;
  char *canonical ;
  char *base_name ;
  char *dir ;
  char *name ;
  char *attempt ;
  int errors ;
  lt_dlhandle newhandle ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  size_t dirlen ;
  void *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  int i ;
  unsigned short const   **tmp___12 ;
  lt_dlvtable const   *vtable___1 ;
  lt_dlvtable const   *tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  FILE *file ;
  char *dlname ;
  char *old_name ;
  char *libdir ;
  char *deplibs ;
  int installed ;
  char const   *search_path ;
  char *tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  void *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;
  lt_dlhandle *tmp___25 ;
  char *tmp___26 ;
  lt_dlhandle *tmp___27 ;
  char *tmp___28 ;
  lt_dlhandle *tmp___29 ;
  lt_dlhandle *tmp___30 ;
  int tmp___31 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;

  {
#line 1131
  saved_error = (char const   *)0;
#line 1132
  canonical = (char *)0;
#line 1133
  base_name = (char *)0;
#line 1134
  dir = (char *)0;
#line 1135
  name = (char *)0;
#line 1136
  attempt = (char *)0;
#line 1137
  errors = 0;
#line 1140
  if (! phandle) {
    {
#line 1140
    __assert_fail("phandle", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1140U, "try_dlopen");
    }
  }
#line 1141
  if (! ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0))) {
    {
#line 1141
    __assert_fail("*phandle == 0", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1141U, "try_dlopen");
    }
  }
  {
#line 1149
  saved_error = lt__get_last_error();
  }
#line 1152
  if (! filename) {
    {
#line 1154
    tmp = lt__zalloc((size_t )sizeof(struct lt__handle ));
#line 1154
    *phandle = (lt_dlhandle )tmp;
    }
#line 1155
    if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 1156
      return (1);
    }
    {
#line 1158
    newhandle = *phandle;
#line 1161
    newhandle->info.is_resident = 1U;
#line 1163
    tmp___0 = tryall_dlopen(& newhandle, (char const   *)0, advise, (lt_dlvtable const   *)0);
    }
#line 1163
    if (tmp___0 != 0) {
#line 1165
      if (*phandle) {
        {
#line 1165
        free((void *)*phandle);
#line 1165
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 1166
      return (1);
    }
#line 1169
    goto register_handle;
  }
#line 1172
  if (filename) {
#line 1172
    if (! *filename) {
      {
#line 1172
      __assert_fail("filename && *filename", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1172U, "try_dlopen");
      }
    }
  } else {
    {
#line 1172
    __assert_fail("filename && *filename", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1172U, "try_dlopen");
    }
  }
#line 1174
  if (ext) {
#line 1176
    if (filename) {
#line 1176
      if (*(filename + 0)) {
        {
#line 1176
        tmp___1 = strlen(filename);
#line 1176
        tmp___2 = tmp___1;
        }
      } else {
#line 1176
        tmp___2 = (size_t )0;
      }
    } else {
#line 1176
      tmp___2 = (size_t )0;
    }
#line 1176
    if (ext) {
#line 1176
      if (*(ext + 0)) {
        {
#line 1176
        tmp___3 = strlen(ext);
#line 1176
        tmp___4 = tmp___3;
        }
      } else {
#line 1176
        tmp___4 = (size_t )0;
      }
    } else {
#line 1176
      tmp___4 = (size_t )0;
    }
    {
#line 1176
    tmp___5 = lt__malloc((size_t )((unsigned long )((tmp___2 + tmp___4) + 1U) * sizeof(char )));
#line 1176
    attempt = (char *)tmp___5;
    }
#line 1177
    if (! attempt) {
#line 1178
      return (1);
    }
    {
#line 1180
    sprintf((char */* __restrict  */)attempt, (char const   */* __restrict  */)"%s%s",
            filename, ext);
    }
  } else {
    {
#line 1184
    attempt = lt__strdup(filename);
    }
#line 1185
    if (! attempt) {
#line 1186
      return (1);
    }
  }
  {
#line 1191
  tmp___6 = canonicalize_path((char const   *)attempt, & canonical);
  }
#line 1191
  if (tmp___6 != 0) {
#line 1193
    errors ++;
#line 1194
    goto cleanup;
  }
  {
#line 1199
  base_name = strrchr((char const   *)canonical, '/');
  }
#line 1200
  if (base_name) {
    {
#line 1202
    dirlen = (size_t )((base_name + 1) - canonical);
#line 1204
    tmp___7 = lt__malloc((size_t )((unsigned long )(1U + dirlen) * sizeof(char )));
#line 1204
    dir = (char *)tmp___7;
    }
#line 1205
    if (! dir) {
#line 1207
      errors ++;
#line 1208
      goto cleanup;
    }
    {
#line 1211
    strncpy((char */* __restrict  */)dir, (char const   */* __restrict  */)canonical,
            dirlen);
#line 1212
    *(dir + dirlen) = (char )'\000';
#line 1214
    base_name ++;
    }
  } else
#line 1217
  if ((unsigned long )base_name != (unsigned long )canonical) {
#line 1217
    if (base_name) {
      {
#line 1217
      free((void *)base_name);
      }
    }
#line 1217
    base_name = canonical;
#line 1217
    canonical = (char *)0;
  }
#line 1219
  if (base_name) {
#line 1219
    if (! *base_name) {
      {
#line 1219
      __assert_fail("base_name && *base_name", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1219U, "try_dlopen");
      }
    }
  } else {
    {
#line 1219
    __assert_fail("base_name && *base_name", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1219U, "try_dlopen");
    }
  }
  {
#line 1221
  tmp___8 = strrchr((char const   *)base_name, '.');
#line 1221
  ext = (char const   *)tmp___8;
  }
#line 1222
  if (! ext) {
#line 1224
    if (base_name) {
#line 1224
      if (*(base_name + 0)) {
        {
#line 1224
        tmp___9 = strlen((char const   *)base_name);
#line 1224
        tmp___10 = tmp___9;
        }
      } else {
#line 1224
        tmp___10 = (size_t )0;
      }
    } else {
#line 1224
      tmp___10 = (size_t )0;
    }
#line 1224
    ext = (char const   *)(base_name + tmp___10);
  }
  {
#line 1228
  tmp___11 = lt__malloc((size_t )((unsigned long )((ext - (char const   *)base_name) + 1L) * sizeof(char )));
#line 1228
  name = (char *)tmp___11;
  }
#line 1229
  if (! name) {
#line 1231
    errors ++;
#line 1232
    goto cleanup;
  }
#line 1238
  i = 0;
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1238
    if (! ((long )i < ext - (char const   *)base_name)) {
#line 1238
      goto while_break;
    }
    {
#line 1240
    tmp___12 = __ctype_b_loc();
    }
#line 1240
    if ((int const   )*(*tmp___12 + (int )((unsigned char )*(base_name + i))) & 8) {
#line 1242
      *(name + i) = *(base_name + i);
    } else {
#line 1246
      *(name + i) = (char )'_';
    }
#line 1238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1249
  *(name + (ext - (char const   *)base_name)) = (char )'\000';
#line 1254
  if (! dir) {
    {
#line 1256
    tmp___13 = lt_dlloader_find((char *)"lt_preopen");
#line 1256
    vtable___1 = tmp___13;
    }
#line 1258
    if (vtable___1) {
      {
#line 1260
      tmp___14 = lt__zalloc((size_t )sizeof(struct lt__handle ));
#line 1260
      *phandle = (lt_dlhandle )tmp___14;
      }
#line 1262
      if ((unsigned long )*phandle == (unsigned long )((void *)0)) {
#line 1264
        errors ++;
#line 1265
        goto cleanup;
      }
      {
#line 1267
      newhandle = *phandle;
#line 1269
      tmp___15 = tryall_dlopen(& newhandle, (char const   *)attempt, advise, vtable___1);
      }
#line 1269
      if (tmp___15 == 0) {
#line 1271
        goto register_handle;
      }
#line 1276
      if (*phandle) {
        {
#line 1276
        free((void *)*phandle);
#line 1276
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 1277
      newhandle = (lt_dlhandle )((void *)0);
    }
  }
#line 1282
  if (ext) {
    {
#line 1282
    tmp___31 = strcmp(ext, archive_ext);
    }
#line 1282
    if (tmp___31) {
#line 1282
      goto _L___0;
    } else {
#line 1285
      file = (FILE *)0;
#line 1286
      dlname = (char *)0;
#line 1287
      old_name = (char *)0;
#line 1288
      libdir = (char *)0;
#line 1289
      deplibs = (char *)0;
#line 1294
      installed = 1;
#line 1300
      if (! dir) {
#line 1302
        search_path = (char const   *)user_search_path;
#line 1304
        if (search_path) {
          {
#line 1305
          file = find_file((char const   *)user_search_path, (char const   *)base_name,
                           & dir);
          }
        }
#line 1307
        if (! file) {
          {
#line 1309
          tmp___16 = getenv("LTDL_LIBRARY_PATH");
#line 1309
          search_path = (char const   *)tmp___16;
          }
#line 1310
          if (search_path) {
            {
#line 1311
            file = find_file(search_path, (char const   *)base_name, & dir);
            }
          }
        }
#line 1315
        if (! file) {
          {
#line 1317
          tmp___17 = getenv("LD_LIBRARY_PATH");
#line 1317
          search_path = (char const   *)tmp___17;
          }
#line 1318
          if (search_path) {
            {
#line 1319
            file = find_file(search_path, (char const   *)base_name, & dir);
            }
          }
        }
#line 1323
        if (! file) {
#line 1323
          if (sys_dlsearch_path[0]) {
            {
#line 1325
            file = find_file(sys_dlsearch_path, (char const   *)base_name, & dir);
            }
          }
        }
      }
#line 1329
      if (! file) {
        {
#line 1331
        file = fopen((char const   */* __restrict  */)attempt, (char const   */* __restrict  */)"r");
        }
      }
#line 1336
      if (! file) {
        {
#line 1338
        tmp___18 = lt__error_string(5);
#line 1338
        lt__set_last_error(tmp___18);
#line 1339
        errors ++;
        }
#line 1340
        goto cleanup;
      }
      {
#line 1344
      tmp___19 = parse_dotla_file(file, & dlname, & libdir, & deplibs, & old_name,
                                  & installed);
      }
#line 1344
      if (tmp___19 != 0) {
#line 1346
        errors ++;
      }
      {
#line 1348
      fclose(file);
#line 1351
      tmp___20 = lt__zalloc((size_t )sizeof(struct lt__handle ));
#line 1351
      *phandle = (lt_dlhandle )tmp___20;
      }
#line 1352
      if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 1353
        errors ++;
      }
#line 1355
      if (errors) {
#line 1357
        if (dlname) {
          {
#line 1357
          free((void *)dlname);
#line 1357
          dlname = (char *)((void *)0);
          }
        }
#line 1358
        if (old_name) {
          {
#line 1358
          free((void *)old_name);
#line 1358
          old_name = (char *)((void *)0);
          }
        }
#line 1359
        if (libdir) {
          {
#line 1359
          free((void *)libdir);
#line 1359
          libdir = (char *)((void *)0);
          }
        }
#line 1360
        if (deplibs) {
          {
#line 1360
          free((void *)deplibs);
#line 1360
          deplibs = (char *)((void *)0);
          }
        }
#line 1361
        if (*phandle) {
          {
#line 1361
          free((void *)*phandle);
#line 1361
          *phandle = (lt_dlhandle )((void *)0);
          }
        }
#line 1362
        goto cleanup;
      }
#line 1365
      if (! *phandle) {
        {
#line 1365
        __assert_fail("*phandle", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                      1365U, "try_dlopen");
        }
      }
      {
#line 1367
      tmp___22 = load_deplibs(*phandle, deplibs);
      }
#line 1367
      if (tmp___22 == 0) {
        {
#line 1369
        newhandle = *phandle;
#line 1371
        tmp___21 = find_module(& newhandle, (char const   *)dir, (char const   *)libdir,
                               (char const   *)dlname, (char const   *)old_name, installed,
                               advise);
        }
#line 1371
        if (tmp___21) {
          {
#line 1374
          unload_deplibs(*phandle);
#line 1375
          errors ++;
          }
        }
      } else {
#line 1380
        errors ++;
      }
#line 1383
      if (dlname) {
        {
#line 1383
        free((void *)dlname);
#line 1383
        dlname = (char *)((void *)0);
        }
      }
#line 1384
      if (old_name) {
        {
#line 1384
        free((void *)old_name);
#line 1384
        old_name = (char *)((void *)0);
        }
      }
#line 1385
      if (libdir) {
        {
#line 1385
        free((void *)libdir);
#line 1385
        libdir = (char *)((void *)0);
        }
      }
#line 1386
      if (deplibs) {
        {
#line 1386
        free((void *)deplibs);
#line 1386
        deplibs = (char *)((void *)0);
        }
      }
#line 1388
      if (errors) {
#line 1390
        if (*phandle) {
          {
#line 1390
          free((void *)*phandle);
#line 1390
          *phandle = (lt_dlhandle )((void *)0);
          }
        }
#line 1391
        goto cleanup;
      }
#line 1394
      if ((unsigned long )*phandle != (unsigned long )newhandle) {
        {
#line 1396
        unload_deplibs(*phandle);
        }
      }
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 1402
    tmp___23 = lt__zalloc((size_t )sizeof(struct lt__handle ));
#line 1402
    *phandle = (lt_dlhandle )tmp___23;
    }
#line 1403
    if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 1405
      errors ++;
#line 1406
      goto cleanup;
    }
#line 1409
    newhandle = *phandle;
#line 1415
    if (dir) {
#line 1415
      goto _L;
    } else {
      {
#line 1415
      tmp___25 = find_handle((char const   *)user_search_path, (char const   *)base_name,
                             & newhandle, advise);
      }
#line 1415
      if (! tmp___25) {
        {
#line 1415
        tmp___26 = getenv("LTDL_LIBRARY_PATH");
#line 1415
        tmp___27 = find_handle((char const   *)tmp___26, (char const   *)base_name,
                               & newhandle, advise);
        }
#line 1415
        if (! tmp___27) {
          {
#line 1415
          tmp___28 = getenv("LD_LIBRARY_PATH");
#line 1415
          tmp___29 = find_handle((char const   *)tmp___28, (char const   *)base_name,
                                 & newhandle, advise);
          }
#line 1415
          if (! tmp___29) {
            {
#line 1415
            tmp___30 = find_handle(sys_dlsearch_path, (char const   *)base_name, & newhandle,
                                   advise);
            }
#line 1415
            if (! tmp___30) {
              _L: /* CIL Label */ 
              {
#line 1429
              tmp___24 = tryall_dlopen(& newhandle, (char const   *)attempt, advise,
                                       (lt_dlvtable const   *)0);
              }
#line 1429
              if (tmp___24 != 0) {
#line 1431
                newhandle = (lt_dlhandle )((void *)0);
              }
            }
          }
        }
      }
    }
#line 1435
    if (! newhandle) {
#line 1437
      if (*phandle) {
        {
#line 1437
        free((void *)*phandle);
#line 1437
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 1438
      errors ++;
#line 1439
      goto cleanup;
    }
  }
  register_handle: 
#line 1444
  if ((unsigned long )*phandle != (unsigned long )newhandle) {
#line 1444
    if (*phandle) {
      {
#line 1444
      free((void *)*phandle);
      }
    }
#line 1444
    *phandle = newhandle;
#line 1444
    newhandle = (lt_dlhandle )0;
  }
#line 1446
  if ((*phandle)->info.ref_count == 0) {
#line 1448
    (*phandle)->info.ref_count = 1;
#line 1449
    if ((unsigned long )(*phandle)->info.name != (unsigned long )name) {
#line 1449
      if ((*phandle)->info.name) {
        {
#line 1449
        free((void *)(*phandle)->info.name);
        }
      }
#line 1449
      (*phandle)->info.name = name;
#line 1449
      name = (char *)0;
    }
#line 1451
    (*phandle)->next = handles;
#line 1452
    handles = *phandle;
  }
  {
#line 1455
  lt__set_last_error(saved_error);
  }
  cleanup: 
#line 1458
  if (dir) {
    {
#line 1458
    free((void *)dir);
#line 1458
    dir = (char *)((void *)0);
    }
  }
#line 1459
  if (attempt) {
    {
#line 1459
    free((void *)attempt);
#line 1459
    attempt = (char *)((void *)0);
    }
  }
#line 1460
  if (name) {
    {
#line 1460
    free((void *)name);
#line 1460
    name = (char *)((void *)0);
    }
  }
#line 1461
  if (! canonical) {
#line 1462
    if (base_name) {
      {
#line 1462
      free((void *)base_name);
#line 1462
      base_name = (char *)((void *)0);
      }
    }
  }
#line 1463
  if (canonical) {
    {
#line 1463
    free((void *)canonical);
#line 1463
    canonical = (char *)((void *)0);
    }
  }
#line 1465
  return (errors);
}
}
#line 1471 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int file_not_found(void) 
{ 
  char const   *error ;
  char const   *tmp ;

  {
  {
#line 1474
  error = (char const   *)0;
#line 1476
  error = lt__get_last_error();
#line 1477
  tmp = lt__error_string(5);
  }
#line 1477
  if ((unsigned long )error == (unsigned long )tmp) {
#line 1478
    return (1);
  }
#line 1480
  return (0);
}
}
#line 1486 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int has_library_ext(char const   *filename ) 
{ 
  char *ext ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1489
  ext = (char *)0;
#line 1491
  if (! filename) {
    {
#line 1491
    __assert_fail("filename", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1491U, "has_library_ext");
    }
  }
  {
#line 1493
  ext = strrchr(filename, '.');
  }
#line 1495
  if (ext) {
    {
#line 1495
    tmp = strcmp((char const   *)ext, archive_ext);
    }
#line 1495
    if (tmp) {
      {
#line 1495
      tmp___0 = strcmp((char const   *)ext, shlib_ext);
      }
#line 1495
      if (! tmp___0) {
#line 1501
        return (1);
      }
    } else {
#line 1501
      return (1);
    }
  }
#line 1504
  return (0);
}
}
#line 1510 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_init(lt_dladvise *padvise ) 
{ 
  lt_dladvise advise ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1513
  tmp = lt__zalloc((size_t )sizeof(struct lt__advise ));
#line 1513
  advise = (lt_dladvise )tmp;
#line 1514
  *padvise = advise;
  }
#line 1515
  if (advise) {
#line 1515
    tmp___0 = 0;
  } else {
#line 1515
    tmp___0 = 1;
  }
#line 1515
  return (tmp___0);
}
}
#line 1518 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_destroy(lt_dladvise *padvise ) 
{ 


  {
#line 1521
  if (padvise) {
#line 1522
    if (*padvise) {
      {
#line 1522
      free((void *)*padvise);
#line 1522
      *padvise = (lt_dladvise )((void *)0);
      }
    }
  }
#line 1523
  return (0);
}
}
#line 1526 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_ext(lt_dladvise *padvise ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1529
  if (padvise) {
#line 1529
    if (! *padvise) {
      {
#line 1529
      __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1529U, "lt_dladvise_ext");
      }
    }
  } else {
    {
#line 1529
    __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1529U, "lt_dladvise_ext");
    }
  }
#line 1530
  (*padvise)->try_ext = 1U;
#line 1531
  return (0);
}
}
#line 1534 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_resident(lt_dladvise *padvise ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1537
  if (padvise) {
#line 1537
    if (! *padvise) {
      {
#line 1537
      __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1537U, "lt_dladvise_resident");
      }
    }
  } else {
    {
#line 1537
    __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1537U, "lt_dladvise_resident");
    }
  }
#line 1538
  (*padvise)->is_resident = 1U;
#line 1539
  return (0);
}
}
#line 1542 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_local(lt_dladvise *padvise ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1545
  if (padvise) {
#line 1545
    if (! *padvise) {
      {
#line 1545
      __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1545U, "lt_dladvise_local");
      }
    }
  } else {
    {
#line 1545
    __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1545U, "lt_dladvise_local");
    }
  }
#line 1546
  (*padvise)->is_symlocal = 1U;
#line 1547
  return (0);
}
}
#line 1550 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladvise_global(lt_dladvise *padvise ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1553
  if (padvise) {
#line 1553
    if (! *padvise) {
      {
#line 1553
      __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1553U, "lt_dladvise_global");
      }
    }
  } else {
    {
#line 1553
    __assert_fail("padvise && *padvise", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1553U, "lt_dladvise_global");
    }
  }
#line 1554
  (*padvise)->is_symglobal = 1U;
#line 1555
  return (0);
}
}
#line 1559 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlhandle lt_dlopen(char const   *filename ) 
{ 
  lt_dlhandle tmp ;

  {
  {
#line 1562
  tmp = lt_dlopenadvise(filename, (lt_dladvise )((void *)0));
  }
#line 1562
  return (tmp);
}
}
#line 1570 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlhandle lt_dlopenext(char const   *filename ) 
{ 
  lt_dlhandle handle ;
  lt_dladvise advise ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1573
  handle = (lt_dlhandle )0;
#line 1576
  tmp = lt_dladvise_init(& advise);
  }
#line 1576
  if (! tmp) {
    {
#line 1576
    tmp___0 = lt_dladvise_ext(& advise);
    }
#line 1576
    if (! tmp___0) {
      {
#line 1577
      handle = lt_dlopenadvise(filename, advise);
      }
    }
  }
  {
#line 1579
  lt_dladvise_destroy(& advise);
  }
#line 1580
  return (handle);
}
}
#line 1584 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlhandle lt_dlopenadvise(char const   *filename , lt_dladvise advise ) 
{ 
  lt_dlhandle handle ;
  int errors ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
#line 1587
  handle = (lt_dlhandle )0;
#line 1588
  errors = 0;
#line 1591
  if (advise) {
#line 1591
    if (advise->is_symlocal) {
#line 1591
      if (advise->is_symglobal) {
        {
#line 1593
        tmp = lt__error_string(19);
#line 1593
        lt__set_last_error(tmp);
        }
#line 1594
        return ((lt_dlhandle )0);
      }
    }
  }
#line 1597
  if (! filename) {
#line 1597
    goto _L;
  } else
#line 1597
  if (! advise) {
#line 1597
    goto _L;
  } else
#line 1597
  if (! advise->try_ext) {
#line 1597
    goto _L;
  } else {
    {
#line 1597
    tmp___4 = has_library_ext(filename);
    }
#line 1597
    if (tmp___4) {
      _L: /* CIL Label */ 
      {
#line 1604
      tmp___0 = try_dlopen(& handle, filename, (char const   *)((void *)0), advise);
      }
#line 1604
      if (tmp___0 != 0) {
#line 1605
        return ((lt_dlhandle )0);
      }
#line 1607
      return (handle);
    } else
#line 1609
    if (filename) {
#line 1609
      if (*filename) {
        {
#line 1613
        tmp___1 = try_dlopen(& handle, filename, archive_ext, advise);
#line 1613
        errors += tmp___1;
        }
#line 1620
        if (handle) {
#line 1621
          return (handle);
        } else
#line 1620
        if (errors > 0) {
          {
#line 1620
          tmp___2 = file_not_found();
          }
#line 1620
          if (! tmp___2) {
#line 1621
            return (handle);
          }
        }
        {
#line 1625
        errors = try_dlopen(& handle, filename, shlib_ext, advise);
        }
#line 1629
        if (handle) {
#line 1630
          return (handle);
        } else
#line 1629
        if (errors > 0) {
          {
#line 1629
          tmp___3 = file_not_found();
          }
#line 1629
          if (! tmp___3) {
#line 1630
            return (handle);
          }
        }
      }
    }
  }
  {
#line 1636
  tmp___5 = lt__error_string(5);
#line 1636
  lt__set_last_error(tmp___5);
  }
#line 1637
  return ((lt_dlhandle )0);
}
}
#line 1641 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int lt_argz_insert(char **pargz , size_t *pargz_len , char *before , char const   *entry ) 
{ 
  error_t error ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1649
  if (before) {
    {
#line 1650
    error = argz_insert((char **/* __restrict  */)pargz, (size_t */* __restrict  */)pargz_len,
                        (char */* __restrict  */)before, (char const   */* __restrict  */)entry);
    }
  } else {
    {
#line 1652
    tmp = strlen(entry);
#line 1652
    error = argz_append((char **/* __restrict  */)pargz, (size_t */* __restrict  */)pargz_len,
                        (char const   */* __restrict  */)entry, 1U + tmp);
    }
  }
#line 1654
  if (error) {
    {
#line 1658
    if (error == 12) {
#line 1658
      goto case_12;
    }
#line 1661
    goto switch_default;
    case_12: /* CIL Label */ 
    {
#line 1659
    tmp___0 = lt__error_string(11);
#line 1659
    lt__set_last_error(tmp___0);
    }
#line 1660
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1662
    tmp___1 = lt__error_string(0);
#line 1662
    lt__set_last_error(tmp___1);
    }
#line 1663
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1665
    return (1);
  }
#line 1668
  return (0);
}
}
#line 1671 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int lt_argz_insertinorder(char **pargz , size_t *pargz_len , char const   *entry ) 
{ 
  char *before ;
  int cmp ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1674
  before = (char *)0;
#line 1676
  if (! pargz) {
    {
#line 1676
    __assert_fail("pargz", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1676U, "lt_argz_insertinorder");
    }
  }
#line 1677
  if (! pargz_len) {
    {
#line 1677
    __assert_fail("pargz_len", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1677U, "lt_argz_insertinorder");
    }
  }
#line 1678
  if (entry) {
#line 1678
    if (! *entry) {
      {
#line 1678
      __assert_fail("entry && *entry", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1678U, "lt_argz_insertinorder");
      }
    }
  } else {
    {
#line 1678
    __assert_fail("entry && *entry", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1678U, "lt_argz_insertinorder");
    }
  }
#line 1680
  if (*pargz) {
    {
#line 1681
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1681
      before = argz_next((char const   */* __restrict  */)*pargz, *pargz_len, (char const   */* __restrict  */)before);
      }
#line 1681
      if (! before) {
#line 1681
        goto while_break;
      }
      {
#line 1683
      tmp = strcmp(entry, (char const   *)before);
#line 1683
      cmp = tmp;
      }
#line 1685
      if (cmp < 0) {
#line 1685
        goto while_break;
      }
#line 1686
      if (cmp == 0) {
#line 1686
        return (0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1689
  tmp___0 = lt_argz_insert(pargz, pargz_len, before, entry);
  }
#line 1689
  return (tmp___0);
}
}
#line 1692 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int lt_argz_insertdir(char **pargz , size_t *pargz_len , char const   *dirnam ,
                             struct dirent *dp ) 
{ 
  char *buf___1 ;
  size_t buf_len ;
  char *end ;
  size_t end_offset ;
  size_t dir_len ;
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  char *p ;
  char *tmp___1 ;
  char *p___0 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 1696
  buf___1 = (char *)0;
#line 1697
  buf_len = (size_t )0;
#line 1698
  end = (char *)0;
#line 1699
  end_offset = (size_t )0;
#line 1700
  dir_len = (size_t )0;
#line 1701
  errors = 0;
#line 1703
  if (! pargz) {
    {
#line 1703
    __assert_fail("pargz", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1703U, "lt_argz_insertdir");
    }
  }
#line 1704
  if (! pargz_len) {
    {
#line 1704
    __assert_fail("pargz_len", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1704U, "lt_argz_insertdir");
    }
  }
#line 1705
  if (! dp) {
    {
#line 1705
    __assert_fail("dp", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1705U, "lt_argz_insertdir");
    }
  }
#line 1707
  if (dirnam) {
#line 1707
    if (*(dirnam + 0)) {
      {
#line 1707
      tmp = strlen(dirnam);
#line 1707
      dir_len = tmp;
      }
    } else {
#line 1707
      dir_len = (size_t )0;
    }
  } else {
#line 1707
    dir_len = (size_t )0;
  }
  {
#line 1708
  tmp___0 = strlen((char const   *)(dp->d_name));
#line 1708
  end = dp->d_name + tmp___0;
#line 1713
  p = end;
  }
  {
#line 1713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1713
    if (! ((unsigned long )(p - 1) > (unsigned long )(dp->d_name))) {
#line 1713
      goto while_break;
    }
    {
#line 1714
    tmp___1 = strchr(".0123456789", (int )*(p + -1));
    }
#line 1714
    if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
#line 1715
      goto while_break;
    }
#line 1713
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1717
  if ((int )*p == 46) {
#line 1718
    end = p;
  }
#line 1724
  p___0 = end - 1;
  {
#line 1724
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1724
    if (! ((unsigned long )p___0 > (unsigned long )(dp->d_name))) {
#line 1724
      goto while_break___0;
    }
#line 1725
    if ((int )*p___0 == 46) {
#line 1727
      end = p___0;
#line 1728
      goto while_break___0;
    }
#line 1724
    p___0 --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1733
  end_offset = (size_t )(end - dp->d_name);
#line 1734
  buf_len = (dir_len + 1U) + end_offset;
#line 1735
  tmp___2 = lt__malloc((size_t )((unsigned long )(1U + buf_len) * sizeof(char )));
#line 1735
  buf___1 = (char *)tmp___2;
  }
#line 1736
  if (! buf___1) {
#line 1737
    errors ++;
#line 1737
    return (errors);
  }
#line 1739
  if (! buf___1) {
    {
#line 1739
    __assert_fail("buf", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1739U, "lt_argz_insertdir");
    }
  }
  {
#line 1741
  strcpy((char */* __restrict  */)buf___1, (char const   */* __restrict  */)dirnam);
#line 1742
  strcat((char */* __restrict  */)buf___1, (char const   */* __restrict  */)"/");
#line 1743
  strncat((char */* __restrict  */)buf___1, (char const   */* __restrict  */)(dp->d_name),
          end_offset);
#line 1744
  *(buf___1 + buf_len) = (char )'\000';
#line 1747
  tmp___3 = lt_argz_insertinorder(pargz, pargz_len, (char const   *)buf___1);
  }
#line 1747
  if (tmp___3 != 0) {
#line 1748
    errors ++;
  }
#line 1750
  if (buf___1) {
    {
#line 1750
    free((void *)buf___1);
#line 1750
    buf___1 = (char *)((void *)0);
    }
  }
#line 1752
  return (errors);
}
}
#line 1755 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int list_files_by_dir(char const   *dirnam , char **pargz , size_t *pargz_len ) 
{ 
  DIR *dirp ;
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  struct dirent *dp ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 1758
  dirp = (DIR *)0;
#line 1759
  errors = 0;
#line 1761
  if (dirnam) {
#line 1761
    if (! *dirnam) {
      {
#line 1761
      __assert_fail("dirnam && *dirnam", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    1761U, "list_files_by_dir");
      }
    }
  } else {
    {
#line 1761
    __assert_fail("dirnam && *dirnam", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1761U, "list_files_by_dir");
    }
  }
#line 1762
  if (! pargz) {
    {
#line 1762
    __assert_fail("pargz", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1762U, "list_files_by_dir");
    }
  }
#line 1763
  if (! pargz_len) {
    {
#line 1763
    __assert_fail("pargz_len", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  1763U, "list_files_by_dir");
    }
  }
#line 1764
  if (dirnam) {
#line 1764
    if (*(dirnam + 0)) {
      {
#line 1764
      tmp = strlen(dirnam);
#line 1764
      tmp___0 = tmp;
      }
    } else {
#line 1764
      tmp___0 = (size_t )0;
    }
  } else {
#line 1764
    tmp___0 = (size_t )0;
  }
#line 1764
  if (! ((int const   )*(dirnam + (tmp___0 - 1U)) != 47)) {
    {
#line 1764
    __assert_fail("dirnam[(((dirnam) && (dirnam)[0]) ? strlen (dirnam) : 0) -1] != \'/\'",
                  "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c", 1764U,
                  "list_files_by_dir");
    }
  }
  {
#line 1766
  dirp = opendir(dirnam);
  }
#line 1767
  if (dirp) {
#line 1769
    dp = (struct dirent *)0;
    {
#line 1771
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1771
      dp = readdir(dirp);
      }
#line 1771
      if (! dp) {
#line 1771
        goto while_break;
      }
#line 1772
      if ((int )dp->d_name[0] != 46) {
        {
#line 1773
        tmp___1 = lt_argz_insertdir(pargz, pargz_len, dirnam, dp);
        }
#line 1773
        if (tmp___1) {
#line 1775
          errors ++;
#line 1776
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1779
    closedir(dirp);
    }
  } else {
#line 1782
    errors ++;
  }
#line 1784
  return (errors);
}
}
#line 1790 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int foreachfile_callback(char *dirname , void *data1 , void *data2 ) 
{ 
  file_worker_func *func ;
  int is_done ;
  char *argz ;
  size_t argz_len ;
  int tmp ;
  char *filename ;

  {
  {
#line 1793
  func = *((file_worker_func **)data1);
#line 1795
  is_done = 0;
#line 1796
  argz = (char *)0;
#line 1797
  argz_len = (size_t )0;
#line 1799
  tmp = list_files_by_dir((char const   *)dirname, & argz, & argz_len);
  }
#line 1799
  if (tmp != 0) {
#line 1800
    goto cleanup;
  }
#line 1801
  if (! argz) {
#line 1802
    goto cleanup;
  }
#line 1805
  filename = (char *)0;
  {
#line 1806
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1806
    filename = argz_next((char const   */* __restrict  */)argz, argz_len, (char const   */* __restrict  */)filename);
    }
#line 1806
    if (! filename) {
#line 1806
      goto while_break;
    }
    {
#line 1807
    is_done = (*func)((char const   *)filename, data2);
    }
#line 1807
    if (is_done) {
#line 1808
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 1812
  if (argz) {
    {
#line 1812
    free((void *)argz);
#line 1812
    argz = (char *)((void *)0);
    }
  }
#line 1814
  return (is_done);
}
}
#line 1824 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlforeachfile(char const   *search_path , int (*func)(char const   *filename ,
                                                             void *data ) , void *data ) 
{ 
  int is_done ;
  file_worker_func **fpptr ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1829
  is_done = 0;
#line 1830
  fpptr = & func;
#line 1832
  if (search_path) {
    {
#line 1836
    is_done = foreach_dirinpath(search_path, (char const   *)0, & foreachfile_callback,
                                (void *)fpptr, data);
    }
  } else {
    {
#line 1842
    is_done = foreach_dirinpath((char const   *)user_search_path, (char const   *)0,
                                & foreachfile_callback, (void *)fpptr, data);
    }
#line 1844
    if (! is_done) {
      {
#line 1846
      tmp = getenv("LTDL_LIBRARY_PATH");
#line 1846
      is_done = foreach_dirinpath((char const   *)tmp, (char const   *)0, & foreachfile_callback,
                                  (void *)fpptr, data);
      }
    }
#line 1851
    if (! is_done) {
      {
#line 1853
      tmp___0 = getenv("LD_LIBRARY_PATH");
#line 1853
      is_done = foreach_dirinpath((char const   *)tmp___0, (char const   *)0, & foreachfile_callback,
                                  (void *)fpptr, data);
      }
    }
#line 1858
    if (! is_done) {
#line 1858
      if (sys_dlsearch_path[0]) {
        {
#line 1860
        is_done = foreach_dirinpath(sys_dlsearch_path, (char const   *)0, & foreachfile_callback,
                                    (void *)fpptr, data);
        }
      }
    }
  }
#line 1866
  return (is_done);
}
}
#line 1869 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlclose(lt_dlhandle handle ) 
{ 
  lt_dlhandle cur ;
  lt_dlhandle last ;
  int errors ;
  char const   *tmp ;
  lt_user_data data ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1873
  errors = 0;
#line 1876
  cur = handles;
#line 1876
  last = cur;
  {
#line 1877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1877
    if (cur) {
#line 1877
      if (! ((unsigned long )handle != (unsigned long )cur)) {
#line 1877
        goto while_break;
      }
    } else {
#line 1877
      goto while_break;
    }
#line 1879
    last = cur;
#line 1880
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1883
  if (! cur) {
    {
#line 1885
    tmp = lt__error_string(12);
#line 1885
    lt__set_last_error(tmp);
#line 1886
    errors ++;
    }
#line 1887
    goto done;
  }
#line 1890
  cur = handle;
#line 1891
  (cur->info.ref_count) --;
#line 1897
  if (cur->info.ref_count <= 0) {
#line 1897
    if (! cur->info.is_resident) {
#line 1899
      data = (lt_user_data )(cur->vtable)->dlloader_data;
#line 1901
      if ((unsigned long )cur != (unsigned long )handles) {
#line 1903
        last->next = cur->next;
      } else {
#line 1907
        handles = cur->next;
      }
      {
#line 1910
      tmp___0 = (*((cur->vtable)->module_close))(data, cur->module);
#line 1910
      errors += tmp___0;
#line 1911
      tmp___1 = unload_deplibs(handle);
#line 1911
      errors += tmp___1;
      }
#line 1914
      if (cur->interface_data) {
        {
#line 1914
        free((void *)cur->interface_data);
#line 1914
        cur->interface_data = (lt_interface_data *)((void *)0);
        }
      }
#line 1916
      if (cur->info.filename) {
        {
#line 1916
        free((void *)cur->info.filename);
#line 1916
        cur->info.filename = (char *)((void *)0);
        }
      }
#line 1917
      if (cur->info.name) {
        {
#line 1917
        free((void *)cur->info.name);
#line 1917
        cur->info.name = (char *)((void *)0);
        }
      }
#line 1918
      if (cur) {
        {
#line 1918
        free((void *)cur);
#line 1918
        cur = (lt_dlhandle )((void *)0);
        }
      }
#line 1920
      goto done;
    }
  }
#line 1923
  if (handle->info.is_resident) {
    {
#line 1925
    tmp___2 = lt__error_string(16);
#line 1925
    lt__set_last_error(tmp___2);
#line 1926
    errors ++;
    }
  }
  done: 
#line 1930
  return (errors);
}
}
#line 1933 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
void *lt_dlsym(lt_dlhandle place , char const   *symbol ) 
{ 
  size_t lensym ;
  char lsym[128] ;
  char *sym ;
  void *address ;
  lt_user_data data ;
  lt_dlhandle handle ;
  char const   *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char const   *tmp___8 ;
  char const   *saved_error ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 1943
  if (! place) {
    {
#line 1945
    tmp = lt__error_string(12);
#line 1945
    lt__set_last_error(tmp);
    }
#line 1946
    return ((void *)0);
  }
#line 1949
  handle = place;
#line 1951
  if (! symbol) {
    {
#line 1953
    tmp___0 = lt__error_string(10);
#line 1953
    lt__set_last_error(tmp___0);
    }
#line 1954
    return ((void *)0);
  }
#line 1957
  if (symbol) {
#line 1957
    if (*(symbol + 0)) {
      {
#line 1957
      tmp___1 = strlen(symbol);
#line 1957
      tmp___2 = tmp___1;
      }
    } else {
#line 1957
      tmp___2 = (size_t )0;
    }
  } else {
#line 1957
    tmp___2 = (size_t )0;
  }
#line 1957
  if ((handle->vtable)->sym_prefix) {
#line 1957
    if (*((handle->vtable)->sym_prefix + 0)) {
      {
#line 1957
      tmp___3 = strlen((char const   *)(handle->vtable)->sym_prefix);
#line 1957
      tmp___4 = tmp___3;
      }
    } else {
#line 1957
      tmp___4 = (size_t )0;
    }
  } else {
#line 1957
    tmp___4 = (size_t )0;
  }
#line 1957
  if (handle->info.name) {
#line 1957
    if (*(handle->info.name + 0)) {
      {
#line 1957
      tmp___5 = strlen((char const   *)handle->info.name);
#line 1957
      tmp___6 = tmp___5;
      }
    } else {
#line 1957
      tmp___6 = (size_t )0;
    }
  } else {
#line 1957
    tmp___6 = (size_t )0;
  }
#line 1957
  lensym = (tmp___2 + tmp___4) + tmp___6;
#line 1960
  if (lensym + 5U < 128U) {
#line 1962
    sym = lsym;
  } else {
    {
#line 1966
    tmp___7 = lt__malloc((size_t )((unsigned long )((lensym + 5U) + 1U) * sizeof(char )));
#line 1966
    sym = (char *)tmp___7;
    }
#line 1967
    if (! sym) {
      {
#line 1969
      tmp___8 = lt__error_string(13);
#line 1969
      lt__set_last_error(tmp___8);
      }
#line 1970
      return ((void *)0);
    }
  }
#line 1974
  data = (lt_user_data )(handle->vtable)->dlloader_data;
#line 1975
  if (handle->info.name) {
    {
#line 1979
    saved_error = lt__get_last_error();
    }
#line 1982
    if ((handle->vtable)->sym_prefix) {
      {
#line 1984
      strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)(handle->vtable)->sym_prefix);
#line 1985
      strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)handle->info.name);
      }
    } else {
      {
#line 1989
      strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)handle->info.name);
      }
    }
    {
#line 1992
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)"_LTX_");
#line 1993
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
#line 1996
    address = (*((handle->vtable)->find_sym))(data, handle->module, (char const   *)sym);
    }
#line 1997
    if (address) {
#line 1999
      if ((unsigned long )sym != (unsigned long )(lsym)) {
#line 2001
        if (sym) {
          {
#line 2001
          free((void *)sym);
#line 2001
          sym = (char *)((void *)0);
          }
        }
      }
#line 2003
      return (address);
    }
    {
#line 2005
    lt__set_last_error(saved_error);
    }
  }
#line 2009
  if ((handle->vtable)->sym_prefix) {
    {
#line 2011
    strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)(handle->vtable)->sym_prefix);
#line 2012
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
    }
  } else {
    {
#line 2016
    strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
    }
  }
  {
#line 2019
  address = (*((handle->vtable)->find_sym))(data, handle->module, (char const   *)sym);
  }
#line 2020
  if ((unsigned long )sym != (unsigned long )(lsym)) {
#line 2022
    if (sym) {
      {
#line 2022
      free((void *)sym);
#line 2022
      sym = (char *)((void *)0);
      }
    }
  }
#line 2025
  return (address);
}
}
#line 2028 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
char const   *lt_dlerror(void) 
{ 
  char const   *error ;
  char const   *tmp ;

  {
  {
#line 2033
  error = lt__get_last_error();
#line 2034
  lt__set_last_error((char const   *)0);
  }
#line 2036
  if (error) {
#line 2036
    tmp = error;
  } else {
#line 2036
    tmp = (char const   *)((void *)0);
  }
#line 2036
  return (tmp);
}
}
#line 2039 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
static int lt_dlpath_insertdir(char **ppath , char *before , char const   *dir ) 
{ 
  int errors ;
  char *canonical ;
  char *argz ;
  size_t argz_len ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 2042
  errors = 0;
#line 2043
  canonical = (char *)0;
#line 2044
  argz = (char *)0;
#line 2045
  argz_len = (size_t )0;
#line 2047
  if (! ppath) {
    {
#line 2047
    __assert_fail("ppath", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2047U, "lt_dlpath_insertdir");
    }
  }
#line 2048
  if (dir) {
#line 2048
    if (! *dir) {
      {
#line 2048
      __assert_fail("dir && *dir", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2048U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 2048
    __assert_fail("dir && *dir", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2048U, "lt_dlpath_insertdir");
    }
  }
  {
#line 2050
  tmp = canonicalize_path(dir, & canonical);
  }
#line 2050
  if (tmp != 0) {
#line 2052
    errors ++;
#line 2053
    goto cleanup;
  }
#line 2056
  if (canonical) {
#line 2056
    if (! *canonical) {
      {
#line 2056
      __assert_fail("canonical && *canonical", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2056U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 2056
    __assert_fail("canonical && *canonical", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2056U, "lt_dlpath_insertdir");
    }
  }
#line 2059
  if ((unsigned long )*ppath == (unsigned long )((char *)0)) {
#line 2061
    if (! (! before)) {
      {
#line 2061
      __assert_fail("!before", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2061U, "lt_dlpath_insertdir");
      }
    }
#line 2062
    if (! dir) {
      {
#line 2062
      __assert_fail("dir", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2062U, "lt_dlpath_insertdir");
      }
    }
    {
#line 2064
    *ppath = lt__strdup(dir);
    }
#line 2065
    if ((unsigned long )*ppath == (unsigned long )((char *)0)) {
#line 2066
      errors ++;
    }
#line 2068
    goto cleanup;
  }
#line 2071
  if (ppath) {
#line 2071
    if (! *ppath) {
      {
#line 2071
      __assert_fail("ppath && *ppath", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2071U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 2071
    __assert_fail("ppath && *ppath", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2071U, "lt_dlpath_insertdir");
    }
  }
  {
#line 2073
  tmp___0 = argzize_path((char const   *)*ppath, & argz, & argz_len);
  }
#line 2073
  if (tmp___0 != 0) {
#line 2075
    errors ++;
#line 2076
    goto cleanup;
  }
#line 2084
  if (before) {
#line 2086
    if (! ((unsigned long )*ppath <= (unsigned long )before)) {
      {
#line 2086
      __assert_fail("*ppath <= before", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2086U, "lt_dlpath_insertdir");
      }
    }
    {
#line 2087
    tmp___1 = strlen((char const   *)*ppath);
    }
#line 2087
    if (! ((int )(before - *ppath) <= (int )tmp___1)) {
      {
#line 2087
      __assert_fail("(int) (before - *ppath) <= (int) strlen (*ppath)", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                    2087U, "lt_dlpath_insertdir");
      }
    }
#line 2089
    before = argz + (before - *ppath);
  }
  {
#line 2092
  tmp___2 = lt_argz_insert(& argz, & argz_len, before, dir);
  }
#line 2092
  if (tmp___2 != 0) {
#line 2094
    errors ++;
#line 2095
    goto cleanup;
  }
  {
#line 2098
  argz_stringify(argz, argz_len, ':');
  }
#line 2099
  if ((unsigned long )*ppath != (unsigned long )argz) {
#line 2099
    if (*ppath) {
      {
#line 2099
      free((void *)*ppath);
      }
    }
#line 2099
    *ppath = argz;
#line 2099
    argz = (char *)0;
  }
  cleanup: 
#line 2102
  if (argz) {
    {
#line 2102
    free((void *)argz);
#line 2102
    argz = (char *)((void *)0);
    }
  }
#line 2103
  if (canonical) {
    {
#line 2103
    free((void *)canonical);
#line 2103
    canonical = (char *)((void *)0);
    }
  }
#line 2105
  return (errors);
}
}
#line 2108 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dladdsearchdir(char const   *search_dir ) 
{ 
  int errors ;
  int tmp ;

  {
#line 2111
  errors = 0;
#line 2113
  if (search_dir) {
#line 2113
    if (*search_dir) {
      {
#line 2115
      tmp = lt_dlpath_insertdir(& user_search_path, (char *)0, search_dir);
      }
#line 2115
      if (tmp != 0) {
#line 2116
        errors ++;
      }
    }
  }
#line 2119
  return (errors);
}
}
#line 2122 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlinsertsearchdir(char const   *before , char const   *search_dir ) 
{ 
  int errors ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 2125
  errors = 0;
#line 2127
  if (before) {
#line 2129
    if ((unsigned long )before < (unsigned long )user_search_path) {
      {
#line 2132
      tmp = lt__error_string(18);
#line 2132
      lt__set_last_error(tmp);
      }
#line 2133
      return (1);
    } else {
#line 2129
      if (user_search_path) {
#line 2129
        if (*(user_search_path + 0)) {
          {
#line 2129
          tmp___0 = strlen((char const   *)user_search_path);
#line 2129
          tmp___1 = tmp___0;
          }
        } else {
#line 2129
          tmp___1 = (size_t )0;
        }
      } else {
#line 2129
        tmp___1 = (size_t )0;
      }
#line 2129
      if ((unsigned long )before >= (unsigned long )(user_search_path + tmp___1)) {
        {
#line 2132
        tmp = lt__error_string(18);
#line 2132
        lt__set_last_error(tmp);
        }
#line 2133
        return (1);
      }
    }
  }
#line 2137
  if (search_dir) {
#line 2137
    if (*search_dir) {
      {
#line 2139
      tmp___2 = lt_dlpath_insertdir(& user_search_path, (char *)before, search_dir);
      }
#line 2139
      if (tmp___2 != 0) {
#line 2142
        errors ++;
      }
    }
  }
#line 2146
  return (errors);
}
}
#line 2149 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlsetsearchpath(char const   *search_path ) 
{ 
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 2152
  errors = 0;
#line 2154
  if (user_search_path) {
    {
#line 2154
    free((void *)user_search_path);
#line 2154
    user_search_path = (char *)((void *)0);
    }
  }
#line 2156
  if (! search_path) {
#line 2158
    return (errors);
  } else {
#line 2156
    if (search_path) {
#line 2156
      if (*(search_path + 0)) {
        {
#line 2156
        tmp = strlen(search_path);
#line 2156
        tmp___0 = tmp;
        }
      } else {
#line 2156
        tmp___0 = (size_t )0;
      }
    } else {
#line 2156
      tmp___0 = (size_t )0;
    }
#line 2156
    if (! tmp___0) {
#line 2158
      return (errors);
    }
  }
  {
#line 2161
  tmp___1 = canonicalize_path(search_path, & user_search_path);
  }
#line 2161
  if (tmp___1 != 0) {
#line 2162
    errors ++;
  }
#line 2164
  return (errors);
}
}
#line 2167 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
char const   *lt_dlgetsearchpath(void) 
{ 
  char const   *saved_path ;

  {
#line 2172
  saved_path = (char const   *)user_search_path;
#line 2174
  return (saved_path);
}
}
#line 2177 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlmakeresident(lt_dlhandle handle ) 
{ 
  int errors ;
  char const   *tmp ;

  {
#line 2180
  errors = 0;
#line 2182
  if (! handle) {
    {
#line 2184
    tmp = lt__error_string(12);
#line 2184
    lt__set_last_error(tmp);
#line 2185
    errors ++;
    }
  } else {
#line 2189
    handle->info.is_resident = 1U;
  }
#line 2192
  return (errors);
}
}
#line 2195 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlisresident(lt_dlhandle handle ) 
{ 
  char const   *tmp ;

  {
#line 2198
  if (! handle) {
    {
#line 2200
    tmp = lt__error_string(12);
#line 2200
    lt__set_last_error(tmp);
    }
#line 2201
    return (-1);
  }
#line 2204
  return ((int )handle->info.is_resident);
}
}
#line 2216 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlinterface_id lt_dlinterface_register(char const   *id_string___0 , lt_dlhandle_interface *iface ) 
{ 
  lt__interface_id *interface_id ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 2219
  tmp = lt__malloc((size_t )sizeof(*interface_id));
#line 2219
  interface_id = (lt__interface_id *)tmp;
  }
#line 2223
  if (interface_id) {
    {
#line 2225
    tmp___0 = lt__strdup(id_string___0);
#line 2225
    interface_id->id_string = (char const   *)tmp___0;
    }
#line 2226
    if (! interface_id->id_string) {
#line 2227
      if (interface_id) {
        {
#line 2227
        free((void *)interface_id);
#line 2227
        interface_id = (lt__interface_id *)((void *)0);
        }
      }
    } else {
#line 2229
      interface_id->iface = iface;
    }
  }
#line 2232
  return ((lt_dlinterface_id )interface_id);
}
}
#line 2235 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
void lt_dlinterface_free(lt_dlinterface_id key ) 
{ 
  lt__interface_id *interface_id ;

  {
#line 2237
  interface_id = (lt__interface_id *)key;
#line 2238
  if (interface_id->id_string) {
    {
#line 2238
    free((void *)interface_id->id_string);
#line 2238
    interface_id->id_string = (char const   *)((void *)0);
    }
  }
#line 2239
  if (interface_id) {
    {
#line 2239
    free((void *)interface_id);
#line 2239
    interface_id = (lt__interface_id *)((void *)0);
    }
  }
#line 2240
  return;
}
}
#line 2242 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
void *lt_dlcaller_set_data(lt_dlinterface_id key , lt_dlhandle handle , void *data ) 
{ 
  int n_elements ;
  void *stale ;
  lt_dlhandle cur ;
  int i ;
  lt_interface_data *temp ;
  void *tmp ;

  {
#line 2245
  n_elements = 0;
#line 2246
  stale = (void *)0;
#line 2247
  cur = handle;
#line 2250
  if (cur->interface_data) {
    {
#line 2251
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2251
      if (! (cur->interface_data + n_elements)->key) {
#line 2251
        goto while_break;
      }
#line 2252
      n_elements ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2254
  i = 0;
  {
#line 2254
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2254
    if (! (i < n_elements)) {
#line 2254
      goto while_break___0;
    }
#line 2256
    if ((unsigned long )(cur->interface_data + i)->key == (unsigned long )key) {
#line 2258
      stale = (cur->interface_data + i)->data;
#line 2259
      goto while_break___0;
    }
#line 2254
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2265
  if (i == n_elements) {
    {
#line 2267
    tmp = lt__realloc((void *)cur->interface_data, (size_t )((unsigned long )(2 + n_elements) * sizeof(lt_interface_data )));
#line 2267
    temp = (lt_interface_data *)tmp;
    }
#line 2270
    if (! temp) {
#line 2272
      stale = (void *)0;
#line 2273
      goto done;
    }
#line 2276
    cur->interface_data = temp;
#line 2279
    (cur->interface_data + i)->key = key;
#line 2280
    (cur->interface_data + (1 + i))->key = (lt_dlinterface_id )0;
  }
#line 2283
  (cur->interface_data + i)->data = data;
  done: 
#line 2286
  return (stale);
}
}
#line 2289 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
void *lt_dlcaller_get_data(lt_dlinterface_id key , lt_dlhandle handle ) 
{ 
  void *result ;
  lt_dlhandle cur ;
  int i ;

  {
#line 2292
  result = (void *)0;
#line 2293
  cur = handle;
#line 2296
  if (cur->interface_data) {
#line 2299
    i = 0;
    {
#line 2299
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2299
      if (! (cur->interface_data + i)->key) {
#line 2299
        goto while_break;
      }
#line 2301
      if ((unsigned long )(cur->interface_data + i)->key == (unsigned long )key) {
#line 2303
        result = (cur->interface_data + i)->data;
#line 2304
        goto while_break;
      }
#line 2299
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2309
  return (result);
}
}
#line 2312 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlinfo const   *lt_dlgetinfo(lt_dlhandle handle ) 
{ 
  char const   *tmp ;

  {
#line 2315
  if (! handle) {
    {
#line 2317
    tmp = lt__error_string(12);
#line 2317
    lt__set_last_error(tmp);
    }
#line 2318
    return ((lt_dlinfo const   *)0);
  }
#line 2321
  return ((lt_dlinfo const   *)(& handle->info));
}
}
#line 2325 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlhandle lt_dlhandle_iterate(lt_dlinterface_id iface , lt_dlhandle place ) 
{ 
  lt_dlhandle handle ;
  lt__interface_id *iterator ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2328
  handle = place;
#line 2329
  iterator = (lt__interface_id *)iface;
#line 2331
  if (! iface) {
    {
#line 2331
    __assert_fail("iface", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2331U, "lt_dlhandle_iterate");
    }
  }
#line 2333
  if (! handle) {
#line 2334
    handle = handles;
  } else {
#line 2336
    handle = handle->next;
  }
  {
#line 2339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2339
    if (handle) {
#line 2339
      if (iterator->iface) {
        {
#line 2339
        tmp = (*(iterator->iface))(handle, iterator->id_string);
        }
#line 2339
        if (! (tmp != 0)) {
#line 2339
          goto while_break;
        }
      } else {
#line 2339
        goto while_break;
      }
    } else {
#line 2339
      goto while_break;
    }
#line 2342
    handle = handle->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2345
  return (handle);
}
}
#line 2349 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
lt_dlhandle lt_dlhandle_fetch(lt_dlinterface_id iface , char const   *module_name ) 
{ 
  lt_dlhandle handle ;
  lt_dlhandle cur ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2352
  handle = (lt_dlhandle )0;
#line 2354
  if (! iface) {
    {
#line 2354
    __assert_fail("iface", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2354U, "lt_dlhandle_fetch");
    }
  }
  {
#line 2356
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2356
    handle = lt_dlhandle_iterate(iface, handle);
    }
#line 2356
    if (! handle) {
#line 2356
      goto while_break;
    }
#line 2358
    cur = handle;
#line 2359
    if (cur) {
#line 2359
      if (cur->info.name) {
        {
#line 2359
        tmp = strcmp((char const   *)cur->info.name, module_name);
        }
#line 2359
        if (! tmp) {
#line 2360
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2363
  return (handle);
}
}
#line 2367 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c"
int lt_dlhandle_map(lt_dlinterface_id iface , int (*func)(lt_dlhandle handle , void *data ) ,
                    void *data ) 
{ 
  lt__interface_id *iterator ;
  lt_dlhandle cur ;
  int errorcode ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 2371
  iterator = (lt__interface_id *)iface;
#line 2372
  cur = handles;
#line 2374
  if (! iface) {
    {
#line 2374
    __assert_fail("iface", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/ltdl.c",
                  2374U, "lt_dlhandle_map");
    }
  }
  {
#line 2376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2376
    if (! cur) {
#line 2376
      goto while_break;
    }
#line 2378
    errorcode = 0;
    {
#line 2381
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2381
      if (cur) {
#line 2381
        if (iterator->iface) {
          {
#line 2381
          tmp = (*(iterator->iface))(cur, iterator->id_string);
          }
#line 2381
          if (! (tmp != 0)) {
#line 2381
            goto while_break___0;
          }
        } else {
#line 2381
          goto while_break___0;
        }
      } else {
#line 2381
        goto while_break___0;
      }
#line 2384
      cur = cur->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2387
    errorcode = (*func)(cur, data);
    }
#line 2387
    if (errorcode != 0) {
#line 2388
      return (errorcode);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2391
  return (0);
}
}
#line 79 "./libltdl/lt_error.h"
int lt_dladderror(char const   *diagnostic ) ;
#line 80
int lt_dlseterror(int errindex ) ;
#line 34 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
static char const   *last_error  =    (char const   *)0;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
static char const   error_strings[20][42]  = 
#line 35
  { {        (char const   )'u',        (char const   )'n',        (char const   )'k',        (char const   )'n', 
            (char const   )'o',        (char const   )'w',        (char const   )'n',        (char const   )' ', 
            (char const   )'e',        (char const   )'r',        (char const   )'r',        (char const   )'o', 
            (char const   )'r',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'d',        (char const   )'l',        (char const   )'o',        (char const   )'p', 
            (char const   )'e',        (char const   )'n',        (char const   )' ',        (char const   )'s', 
            (char const   )'u',        (char const   )'p',        (char const   )'p',        (char const   )'o', 
            (char const   )'r',        (char const   )'t',        (char const   )' ',        (char const   )'n', 
            (char const   )'o',        (char const   )'t',        (char const   )' ',        (char const   )'a', 
            (char const   )'v',        (char const   )'a',        (char const   )'i',        (char const   )'l', 
            (char const   )'a',        (char const   )'b',        (char const   )'l',        (char const   )'e', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'l',        (char const   )'o',        (char const   )'a',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'o',        (char const   )'a',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )' ',        (char const   )'i', 
            (char const   )'n',        (char const   )'i',        (char const   )'t',        (char const   )'i', 
            (char const   )'a',        (char const   )'l',        (char const   )'i',        (char const   )'z', 
            (char const   )'a',        (char const   )'t',        (char const   )'i',        (char const   )'o', 
            (char const   )'n',        (char const   )' ',        (char const   )'f',        (char const   )'a', 
            (char const   )'i',        (char const   )'l',        (char const   )'e',        (char const   )'d', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'o',        (char const   )'a',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )' ',        (char const   )'r', 
            (char const   )'e',        (char const   )'m',        (char const   )'o',        (char const   )'v', 
            (char const   )'a',        (char const   )'l',        (char const   )' ',        (char const   )'f', 
            (char const   )'a',        (char const   )'i',        (char const   )'l',        (char const   )'e', 
            (char const   )'d',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'f',        (char const   )'i',        (char const   )'l',        (char const   )'e', 
            (char const   )' ',        (char const   )'n',        (char const   )'o',        (char const   )'t', 
            (char const   )' ',        (char const   )'f',        (char const   )'o',        (char const   )'u', 
            (char const   )'n',        (char const   )'d',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'d',        (char const   )'e',        (char const   )'p',        (char const   )'e', 
            (char const   )'n',        (char const   )'d',        (char const   )'e',        (char const   )'n', 
            (char const   )'c',        (char const   )'y',        (char const   )' ',        (char const   )'l', 
            (char const   )'i',        (char const   )'b',        (char const   )'r',        (char const   )'a', 
            (char const   )'r',        (char const   )'y',        (char const   )' ',        (char const   )'n', 
            (char const   )'o',        (char const   )'t',        (char const   )' ',        (char const   )'f', 
            (char const   )'o',        (char const   )'u',        (char const   )'n',        (char const   )'d', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'n',        (char const   )'o',        (char const   )' ',        (char const   )'s', 
            (char const   )'y',        (char const   )'m',        (char const   )'b',        (char const   )'o', 
            (char const   )'l',        (char const   )'s',        (char const   )' ',        (char const   )'d', 
            (char const   )'e',        (char const   )'f',        (char const   )'i',        (char const   )'n', 
            (char const   )'e',        (char const   )'d',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'c',        (char const   )'a',        (char const   )'n',        (char const   )'\'', 
            (char const   )'t',        (char const   )' ',        (char const   )'o',        (char const   )'p', 
            (char const   )'e',        (char const   )'n',        (char const   )' ',        (char const   )'t', 
            (char const   )'h',        (char const   )'e',        (char const   )' ',        (char const   )'m', 
            (char const   )'o',        (char const   )'d',        (char const   )'u',        (char const   )'l', 
            (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'c',        (char const   )'a',        (char const   )'n',        (char const   )'\'', 
            (char const   )'t',        (char const   )' ',        (char const   )'c',        (char const   )'l', 
            (char const   )'o',        (char const   )'s',        (char const   )'e',        (char const   )' ', 
            (char const   )'t',        (char const   )'h',        (char const   )'e',        (char const   )' ', 
            (char const   )'m',        (char const   )'o',        (char const   )'d',        (char const   )'u', 
            (char const   )'l',        (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'s',        (char const   )'y',        (char const   )'m',        (char const   )'b', 
            (char const   )'o',        (char const   )'l',        (char const   )' ',        (char const   )'n', 
            (char const   )'o',        (char const   )'t',        (char const   )' ',        (char const   )'f', 
            (char const   )'o',        (char const   )'u',        (char const   )'n',        (char const   )'d', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'n',        (char const   )'o',        (char const   )'t',        (char const   )' ', 
            (char const   )'e',        (char const   )'n',        (char const   )'o',        (char const   )'u', 
            (char const   )'g',        (char const   )'h',        (char const   )' ',        (char const   )'m', 
            (char const   )'e',        (char const   )'m',        (char const   )'o',        (char const   )'r', 
            (char const   )'y',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'m',        (char const   )'o',        (char const   )'d',        (char const   )'u', 
            (char const   )'l',        (char const   )'e',        (char const   )' ',        (char const   )'h', 
            (char const   )'a',        (char const   )'n',        (char const   )'d',        (char const   )'l', 
            (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'t',        (char const   )'e', 
            (char const   )'r',        (char const   )'n',        (char const   )'a',        (char const   )'l', 
            (char const   )' ',        (char const   )'b',        (char const   )'u',        (char const   )'f', 
            (char const   )'f',        (char const   )'e',        (char const   )'r',        (char const   )' ', 
            (char const   )'o',        (char const   )'v',        (char const   )'e',        (char const   )'r', 
            (char const   )'f',        (char const   )'l',        (char const   )'o',        (char const   )'w', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'e',        (char const   )'r',        (char const   )'r',        (char const   )'o', 
            (char const   )'r',        (char const   )'c',        (char const   )'o',        (char const   )'d', 
            (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'b',        (char const   )'r', 
            (char const   )'a',        (char const   )'r',        (char const   )'y',        (char const   )' ', 
            (char const   )'a',        (char const   )'l',        (char const   )'r',        (char const   )'e', 
            (char const   )'a',        (char const   )'d',        (char const   )'y',        (char const   )' ', 
            (char const   )'s',        (char const   )'h',        (char const   )'u',        (char const   )'t', 
            (char const   )'d',        (char const   )'o',        (char const   )'w',        (char const   )'n', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'c',        (char const   )'a',        (char const   )'n',        (char const   )'\'', 
            (char const   )'t',        (char const   )' ',        (char const   )'c',        (char const   )'l', 
            (char const   )'o',        (char const   )'s',        (char const   )'e',        (char const   )' ', 
            (char const   )'r',        (char const   )'e',        (char const   )'s',        (char const   )'i', 
            (char const   )'d',        (char const   )'e',        (char const   )'n',        (char const   )'t', 
            (char const   )' ',        (char const   )'m',        (char const   )'o',        (char const   )'d', 
            (char const   )'u',        (char const   )'l',        (char const   )'e',        (char const   )'\000', 
            (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'t',        (char const   )'e', 
            (char const   )'r',        (char const   )'n',        (char const   )'a',        (char const   )'l', 
            (char const   )' ',        (char const   )'e',        (char const   )'r',        (char const   )'r', 
            (char const   )'o',        (char const   )'r',        (char const   )' ',        (char const   )'(', 
            (char const   )'c',        (char const   )'o',        (char const   )'d',        (char const   )'e', 
            (char const   )' ',        (char const   )'w',        (char const   )'i',        (char const   )'t', 
            (char const   )'h',        (char const   )'d',        (char const   )'r',        (char const   )'a', 
            (char const   )'w',        (char const   )'n',        (char const   )')',        (char const   )'\000', 
            (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'s',        (char const   )'e',        (char const   )'a',        (char const   )'r', 
            (char const   )'c',        (char const   )'h',        (char const   )' ',        (char const   )'p', 
            (char const   )'a',        (char const   )'t',        (char const   )'h',        (char const   )' ', 
            (char const   )'i',        (char const   )'n',        (char const   )'s',        (char const   )'e', 
            (char const   )'r',        (char const   )'t',        (char const   )' ',        (char const   )'p', 
            (char const   )'o',        (char const   )'s',        (char const   )'i',        (char const   )'t', 
            (char const   )'i',        (char const   )'o',        (char const   )'n',        (char const   )'\000', 
            (char const   )'\000'}, 
   {        (char const   )'s',        (char const   )'y',        (char const   )'m',        (char const   )'b', 
            (char const   )'o',        (char const   )'l',        (char const   )' ',        (char const   )'v', 
            (char const   )'i',        (char const   )'s',        (char const   )'i',        (char const   )'b', 
            (char const   )'i',        (char const   )'l',        (char const   )'i',        (char const   )'t', 
            (char const   )'y',        (char const   )' ',        (char const   )'c',        (char const   )'a', 
            (char const   )'n',        (char const   )' ',        (char const   )'b',        (char const   )'e', 
            (char const   )' ',        (char const   )'g',        (char const   )'l',        (char const   )'o', 
            (char const   )'b',        (char const   )'a',        (char const   )'l',        (char const   )' ', 
            (char const   )'o',        (char const   )'r',        (char const   )' ',        (char const   )'l', 
            (char const   )'o',        (char const   )'c',        (char const   )'a',        (char const   )'l', 
            (char const   )'\000',        (char const   )'\000'}};
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
static char const   **user_error_strings  =    (char const   **)0;
#line 43 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
static int errorcount  =    20;
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
int lt_dladderror(char const   *diagnostic ) 
{ 
  int errindex ;
  int result ;
  char const   **temp ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 48
  errindex = 0;
#line 49
  result = -1;
#line 50
  temp = (char const   **)0;
#line 52
  if (! diagnostic) {
    {
#line 52
    __assert_fail("diagnostic", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c",
                  52U, "lt_dladderror");
    }
  }
  {
#line 54
  errindex = errorcount - 20;
#line 55
  tmp = lt__realloc((void *)user_error_strings, (size_t )((unsigned long )(1 + errindex) * sizeof(char const   *)));
#line 55
  temp = (char const   **)tmp;
  }
#line 56
  if (temp) {
#line 58
    user_error_strings = temp;
#line 59
    *(user_error_strings + errindex) = diagnostic;
#line 60
    tmp___0 = errorcount;
#line 60
    errorcount ++;
#line 60
    result = tmp___0;
  }
#line 63
  return (result);
}
}
#line 66 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
int lt_dlseterror(int errindex ) 
{ 
  int errors ;
  char const   *tmp ;

  {
#line 69
  errors = 0;
#line 71
  if (errindex >= errorcount) {
    {
#line 74
    tmp = lt__error_string(14);
#line 74
    lt__set_last_error(tmp);
#line 75
    errors ++;
    }
  } else
#line 71
  if (errindex < 0) {
    {
#line 74
    tmp = lt__error_string(14);
#line 74
    lt__set_last_error(tmp);
#line 75
    errors ++;
    }
  } else
#line 77
  if (errindex < 20) {
    {
#line 80
    lt__set_last_error(error_strings[errindex]);
    }
  } else {
    {
#line 85
    lt__set_last_error(*(user_error_strings + (errindex - 20)));
    }
  }
#line 88
  return (errors);
}
}
#line 91 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
char const   *lt__error_string(int errorcode ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 94
  if (! (errorcode >= 0)) {
    {
#line 94
    __assert_fail("errorcode >= 0", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c",
                  94U, "lt__error_string");
    }
  }
#line 95
  if (! (errorcode < 20)) {
    {
#line 95
    __assert_fail("errorcode < LT_ERROR_MAX", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c",
                  95U, "lt__error_string");
    }
  }
#line 97
  return (error_strings[errorcode]);
}
}
#line 100 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
char const   *lt__get_last_error(void) 
{ 


  {
#line 103
  return (last_error);
}
}
#line 106 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_error.c"
char const   *lt__set_last_error(char const   *errormsg ) 
{ 


  {
#line 109
  last_error = errormsg;
#line 109
  return (last_error);
}
}
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
static void *loader_callback(SList *item , void *userdata ) ;
#line 41 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
static SList *loaders  =    (SList *)0;
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
static void *loader_callback(SList *item , void *userdata ) 
{ 
  lt_dlvtable const   *vtable___1 ;
  char const   *name ;
  void *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 50
  vtable___1 = (lt_dlvtable const   *)item->userdata;
#line 51
  name = (char const   *)userdata;
#line 53
  if (! vtable___1) {
    {
#line 53
    __assert_fail("vtable", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c",
                  53U, "loader_callback");
    }
  }
  {
#line 55
  tmp___1 = strcmp((char const   *)vtable___1->name, name);
  }
#line 55
  if (tmp___1) {
#line 55
    tmp___0 = (void *)0;
  } else {
#line 55
    tmp___0 = (void *)item;
  }
#line 55
  return (tmp___0);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
int lt_dlloader_add(lt_dlvtable const   *vtable___1 ) 
{ 
  SList *item ;
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 66
  if ((unsigned long )vtable___1 == (unsigned long )((lt_dlvtable const   *)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned long )vtable___1->module_open == (unsigned long )((lt_module_open */* const  */)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned long )vtable___1->module_close == (unsigned long )((lt_module_close */* const  */)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned long )vtable___1->find_sym == (unsigned long )((lt_find_sym */* const  */)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned int const   )vtable___1->priority != 0U) {
#line 66
    if ((unsigned int const   )vtable___1->priority != 1U) {
      {
#line 73
      tmp = lt__error_string(2);
#line 73
      lt__set_last_error(tmp);
      }
#line 74
      return (1);
    }
  }
  {
#line 77
  item = lt__slist_box((void const   *)vtable___1);
  }
#line 78
  if (! item) {
    {
#line 80
    (*lt__alloc_die)();
    }
#line 84
    return (1);
  }
#line 87
  if ((unsigned int const   )vtable___1->priority == 0U) {
    {
#line 89
    loaders = lt__slist_cons(item, loaders);
    }
  } else {
#line 93
    if (! ((unsigned int const   )vtable___1->priority == 1U)) {
      {
#line 93
      __assert_fail("vtable->priority == LT_DLLOADER_APPEND", "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c",
                    93U, "lt_dlloader_add");
      }
    }
    {
#line 94
    loaders = lt__slist_concat(loaders, item);
    }
  }
#line 97
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
lt_dlloader lt_dlloader_next(lt_dlloader const   loader ) 
{ 
  SList *item ;
  struct slist *tmp ;

  {
#line 133
  item = (SList *)loader;
#line 134
  if (item) {
#line 134
    tmp = item->next;
  } else {
#line 134
    tmp = loaders;
  }
#line 134
  return ((lt_dlloader )tmp);
}
}
#line 139 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
lt_dlvtable const   *lt_dlloader_get(lt_dlloader loader ) 
{ 
  void const   *tmp ;

  {
#line 142
  if (loader) {
#line 142
    tmp = ((SList *)loader)->userdata;
  } else {
#line 142
    tmp = (void const   *)((void *)0);
  }
#line 142
  return ((lt_dlvtable const   *)tmp);
}
}
#line 156 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
static char const   id_string[19]  = 
#line 156
  {      (char const   )'l',      (char const   )'t',      (char const   )'_',      (char const   )'d', 
        (char const   )'l',      (char const   )'l',      (char const   )'o',      (char const   )'a', 
        (char const   )'d',      (char const   )'e',      (char const   )'r',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )'\000'};
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
lt_dlvtable *lt_dlloader_remove(char *name ) 
{ 
  lt_dlvtable const   *vtable___1 ;
  lt_dlvtable const   *tmp ;
  lt_dlinterface_id iface ;
  lt_dlhandle handle ;
  int in_use ;
  int in_use_by_resident ;
  char const   *tmp___0 ;
  lt_dlhandle cur ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 155
  tmp = lt_dlloader_find(name);
#line 155
  vtable___1 = tmp;
#line 158
  handle = (lt_dlhandle )0;
#line 159
  in_use = 0;
#line 160
  in_use_by_resident = 0;
  }
#line 162
  if (! vtable___1) {
    {
#line 164
    tmp___0 = lt__error_string(2);
#line 164
    lt__set_last_error(tmp___0);
    }
#line 165
    return ((lt_dlvtable *)0);
  }
  {
#line 169
  iface = lt_dlinterface_register(id_string, (lt_dlhandle_interface *)((void *)0));
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    handle = lt_dlhandle_iterate(iface, handle);
    }
#line 170
    if (! handle) {
#line 170
      goto while_break;
    }
#line 172
    cur = handle;
#line 173
    if ((unsigned long )cur->vtable == (unsigned long )vtable___1) {
      {
#line 175
      in_use = 1;
#line 176
      tmp___1 = lt_dlisresident(handle);
      }
#line 176
      if (tmp___1) {
#line 177
        in_use_by_resident = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  lt_dlinterface_free(iface);
  }
#line 181
  if (in_use) {
#line 183
    if (! in_use_by_resident) {
      {
#line 184
      tmp___2 = lt__error_string(4);
#line 184
      lt__set_last_error(tmp___2);
      }
    }
#line 185
    return ((lt_dlvtable *)0);
  }
#line 189
  if (vtable___1) {
#line 189
    if (vtable___1->dlloader_exit) {
      {
#line 191
      tmp___3 = (*(vtable___1->dlloader_exit))((lt_user_data )vtable___1->dlloader_data);
      }
#line 191
      if (tmp___3 != 0) {
#line 196
        return ((lt_dlvtable *)0);
      }
    }
  }
  {
#line 201
  tmp___4 = lt__slist_remove(& loaders, & loader_callback, (void *)name);
#line 201
  tmp___5 = lt__slist_unbox((SList *)tmp___4);
  }
#line 201
  return ((lt_dlvtable *)tmp___5);
}
}
#line 206 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt_dlloader.c"
lt_dlvtable const   *lt_dlloader_find(char *name ) 
{ 
  void *tmp ;
  lt_dlvtable const   *tmp___0 ;

  {
  {
#line 209
  tmp = lt__slist_find(loaders, & loader_callback, (void *)name);
#line 209
  tmp___0 = lt_dlloader_get(tmp);
  }
#line 209
  return (tmp___0);
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 52 "libltdl/lt__alloc.h"
void *lt__memdup(void const   *mem , size_t n ) ;
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
static void alloc_die_default(void) ;
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
void (*lt__alloc_die)(void)  =    & alloc_die_default;
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
static void alloc_die_default(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 45
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 46
  exit(1);
  }
}
}
#line 49 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
void *lt__malloc(size_t n ) 
{ 
  void *mem ;

  {
  {
#line 54
  mem = malloc(n);
  }
#line 54
  if (! mem) {
    {
#line 55
    (*lt__alloc_die)();
    }
  }
#line 57
  return (mem);
}
}
#line 60 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
void *lt__zalloc(size_t n ) 
{ 
  void *mem ;

  {
  {
#line 65
  mem = lt__malloc(n);
  }
#line 65
  if (mem) {
    {
#line 66
    memset(mem, 0, n);
    }
  }
#line 68
  return (mem);
}
}
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
void *lt__realloc(void *mem , size_t n ) 
{ 


  {
  {
#line 74
  mem = realloc(mem, n);
  }
#line 74
  if (! mem) {
    {
#line 75
    (*lt__alloc_die)();
    }
  }
#line 77
  return (mem);
}
}
#line 80 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
void *lt__memdup(void const   *mem , size_t n ) 
{ 
  void *newmem ;
  void *tmp ;

  {
  {
#line 85
  newmem = lt__malloc(n);
  }
#line 85
  if (newmem) {
    {
#line 86
    tmp = memcpy((void */* __restrict  */)newmem, (void const   */* __restrict  */)mem,
                 n);
    }
#line 86
    return (tmp);
  }
#line 88
  return ((void *)0);
}
}
#line 91 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/lt__alloc.c"
char *lt__strdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 94
  tmp = strlen(string);
#line 94
  tmp___0 = lt__memdup((void const   *)string, tmp + 1U);
  }
#line 94
  return ((char *)tmp___0);
}
}
#line 9 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/.libs/libltdlcS.c"
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/.libs/libltdlcS.c"
#line 20 "../include/dico/util.h"
char *dico_full_file_name(char const   *dir , char const   *file ) ;
#line 21
size_t dico_trim_nl(char *buf___1 ) ;
#line 22
size_t dico_trim_ws(char *buf___1 ) ;
#line 22 "../include/dico/markup.h"
char const   *dico_markup_type  ;
#line 23 "../include/dico/markup.h"
dico_list_t dico_markup_list  ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
size_t dico_string_trim(char *buf___1 , size_t len , int (*pred)(int c ) ) 
{ 
  int tmp ;

  {
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (len > 0U) {
      {
#line 29
      tmp = (*pred)((int )*(buf___1 + (len - 1U)));
      }
#line 29
      if (! tmp) {
#line 29
        goto while_break;
      }
    } else {
#line 29
      goto while_break;
    }
#line 30
    len --;
#line 30
    *(buf___1 + len) = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 31
  return (len);
}
}
#line 34 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
static int _is_nl(int c ) 
{ 
  int tmp ;

  {
#line 37
  if (c == 13) {
#line 37
    tmp = 1;
  } else
#line 37
  if (c == 10) {
#line 37
    tmp = 1;
  } else {
#line 37
    tmp = 0;
  }
#line 37
  return (tmp);
}
}
#line 40 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
size_t dico_trim_nl(char *buf___1 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 43
  tmp = strlen((char const   *)buf___1);
#line 43
  tmp___0 = dico_string_trim(buf___1, tmp, & _is_nl);
  }
#line 43
  return (tmp___0);
}
}
#line 46 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
static int _is_ws(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 49
  tmp = __ctype_b_loc();
  }
#line 49
  return ((int )((int const   )*(*tmp + c) & 8192));
}
}
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
size_t dico_trim_ws(char *buf___1 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 55
  tmp = strlen((char const   *)buf___1);
#line 55
  tmp___0 = dico_string_trim(buf___1, tmp, & _is_ws);
  }
#line 55
  return (tmp___0);
}
}
#line 58 "/home/wslee/benchmarks/textformat/dico-2.0/lib/util.c"
char *dico_full_file_name(char const   *dir , char const   *file ) 
{ 
  size_t dirlen ;
  size_t tmp ;
  int need_slash ;
  int tmp___0 ;
  size_t size ;
  size_t tmp___1 ;
  char *buf___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp12 ;

  {
  {
#line 61
  tmp = strlen(dir);
#line 61
  dirlen = tmp;
  }
#line 62
  if (dirlen) {
#line 62
    if ((int const   )*(dir + (dirlen - 1U)) == 47) {
#line 62
      tmp___0 = 0;
    } else {
#line 62
      tmp___0 = 1;
    }
  } else {
#line 62
    tmp___0 = 1;
  }
  {
#line 62
  need_slash = tmp___0;
#line 63
  tmp___1 = strlen(file);
#line 63
  size = (((dirlen + (size_t )need_slash) + 1U) + tmp___1) + 1U;
#line 64
  tmp___2 = malloc(size);
#line 64
  buf___1 = (char *)tmp___2;
  }
#line 66
  if (! buf___1) {
#line 67
    return ((char *)((void *)0));
  }
  {
#line 69
  strcpy((char */* __restrict  */)buf___1, (char const   */* __restrict  */)dir);
  }
#line 70
  if (need_slash) {
    {
#line 71
    tmp___3 = dirlen;
#line 71
    dirlen ++;
#line 71
    strcpy((char */* __restrict  */)(buf___1 + tmp___3), (char const   */* __restrict  */)"/");
    }
  } else {
    {
#line 73
    while (1) {
      while_continue: /* CIL Label */ ;
#line 73
      if (dirlen > 0U) {
#line 73
        if (! ((int )*(buf___1 + (dirlen - 1U)) == 47)) {
#line 73
          goto while_break;
        }
      } else {
#line 73
        goto while_break;
      }
#line 74
      dirlen --;
    }
    while_break: /* CIL Label */ ;
    }
#line 75
    dirlen ++;
  }
  {
#line 77
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 77
    if (! ((int const   )*file == 47)) {
#line 77
      goto while_break___0;
    }
#line 78
    file ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 79
  strcpy((char */* __restrict  */)(buf___1 + dirlen), (char const   */* __restrict  */)file);
  }
#line 80
  return (buf___1);
}
}
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 22 "../include/dico/utf8.h"
size_t utf8_char_width(unsigned char const   *p ) ;
#line 23
size_t utf8_strlen(char const   *s ) ;
#line 35
int utf8_iter_end_p(struct utf8_iterator *itr ) ;
#line 36
int utf8_iter_first(struct utf8_iterator *itr , unsigned char *ptr ) ;
#line 37
int utf8_iter_next(struct utf8_iterator *itr ) ;
#line 39
int utf8_mbtowc_internal(void *data , int (*read___0)(void * ) , unsigned int *pwc ) ;
#line 40
int utf8_wctomb(unsigned char *r , unsigned int wc ) ;
#line 42
int utf8_symcmp(unsigned char *a , unsigned char *b ) ;
#line 44
int utf8_strcasecmp(unsigned char *a , unsigned char *b ) ;
#line 45
int utf8_strncasecmp(unsigned char *a , unsigned char *b , size_t maxlen ) ;
#line 47
unsigned int utf8_wc_toupper(unsigned int wc ) ;
#line 48
int utf8_toupper(char *s , size_t len ) ;
#line 49
unsigned int utf8_wc_tolower(unsigned int wc ) ;
#line 50
int utf8_tolower(char *s , size_t len ) ;
#line 51
size_t utf8_wc_strlen(unsigned int const   *s ) ;
#line 52
unsigned int *utf8_wc_strdup(unsigned int const   *s ) ;
#line 53
size_t utf8_wc_hash_string(unsigned int const   *ws , size_t n_buckets ) ;
#line 54
int utf8_wc_strcmp(unsigned int const   *a , unsigned int const   *b ) ;
#line 55
int utf8_wc_to_mbstr(unsigned int const   *wordbuf , size_t wordlen , char **sptr ) ;
#line 57
int utf8_mbstr_to_wc(char const   *str , unsigned int **wptr ) ;
#line 58
int utf8_mbstr_to_norm_wc(char const   *str , unsigned int **nptr ) ;
#line 60
int utf8_quote(char const   *str , char **sptr ) ;
#line 61
unsigned int *utf8_wc_quote(unsigned int const   *s ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane00[256]  = 
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
  {      {0U, 0U, 0U}, 
        {1U, 1U, 1U}, 
        {2U, 2U, 2U}, 
        {3U, 3U, 3U}, 
        {4U, 4U, 4U}, 
        {5U, 5U, 5U}, 
        {6U, 6U, 6U}, 
        {7U, 7U, 7U}, 
        {8U, 8U, 8U}, 
        {9U, 9U, 9U}, 
        {10U, 10U, 10U}, 
        {11U, 11U, 11U}, 
        {12U, 12U, 12U}, 
        {13U, 13U, 13U}, 
        {14U, 14U, 14U}, 
        {15U, 15U, 15U}, 
        {16U, 16U, 16U}, 
        {17U, 17U, 17U}, 
        {18U, 18U, 18U}, 
        {19U, 19U, 19U}, 
        {20U, 20U, 20U}, 
        {21U, 21U, 21U}, 
        {22U, 22U, 22U}, 
        {23U, 23U, 23U}, 
        {24U, 24U, 24U}, 
        {25U, 25U, 25U}, 
        {26U, 26U, 26U}, 
        {27U, 27U, 27U}, 
        {28U, 28U, 28U}, 
        {29U, 29U, 29U}, 
        {30U, 30U, 30U}, 
        {31U, 31U, 31U}, 
        {32U, 32U, 32U}, 
        {33U, 33U, 33U}, 
        {34U, 34U, 34U}, 
        {35U, 35U, 35U}, 
        {36U, 36U, 36U}, 
        {37U, 37U, 37U}, 
        {38U, 38U, 38U}, 
        {39U, 39U, 39U}, 
        {40U, 40U, 40U}, 
        {41U, 41U, 41U}, 
        {42U, 42U, 42U}, 
        {43U, 43U, 43U}, 
        {44U, 44U, 44U}, 
        {45U, 45U, 45U}, 
        {46U, 46U, 46U}, 
        {47U, 47U, 47U}, 
        {48U, 48U, 48U}, 
        {49U, 49U, 49U}, 
        {50U, 50U, 50U}, 
        {51U, 51U, 51U}, 
        {52U, 52U, 52U}, 
        {53U, 53U, 53U}, 
        {54U, 54U, 54U}, 
        {55U, 55U, 55U}, 
        {56U, 56U, 56U}, 
        {57U, 57U, 57U}, 
        {58U, 58U, 58U}, 
        {59U, 59U, 59U}, 
        {60U, 60U, 60U}, 
        {61U, 61U, 61U}, 
        {62U, 62U, 62U}, 
        {63U, 63U, 63U}, 
        {64U, 64U, 64U}, 
        {65U, 97U, 65U}, 
        {66U, 98U, 66U}, 
        {67U, 99U, 67U}, 
        {68U, 100U, 68U}, 
        {69U, 101U, 69U}, 
        {70U, 102U, 70U}, 
        {71U, 103U, 71U}, 
        {72U, 104U, 72U}, 
        {73U, 105U, 73U}, 
        {74U, 106U, 74U}, 
        {75U, 107U, 75U}, 
        {76U, 108U, 76U}, 
        {77U, 109U, 77U}, 
        {78U, 110U, 78U}, 
        {79U, 111U, 79U}, 
        {80U, 112U, 80U}, 
        {81U, 113U, 81U}, 
        {82U, 114U, 82U}, 
        {83U, 115U, 83U}, 
        {84U, 116U, 84U}, 
        {85U, 117U, 85U}, 
        {86U, 118U, 86U}, 
        {87U, 119U, 87U}, 
        {88U, 120U, 88U}, 
        {89U, 121U, 89U}, 
        {90U, 122U, 90U}, 
        {91U, 91U, 91U}, 
        {92U, 92U, 92U}, 
        {93U, 93U, 93U}, 
        {94U, 94U, 94U}, 
        {95U, 95U, 95U}, 
        {96U, 96U, 96U}, 
        {65U, 97U, 65U}, 
        {66U, 98U, 66U}, 
        {67U, 99U, 67U}, 
        {68U, 100U, 68U}, 
        {69U, 101U, 69U}, 
        {70U, 102U, 70U}, 
        {71U, 103U, 71U}, 
        {72U, 104U, 72U}, 
        {73U, 105U, 73U}, 
        {74U, 106U, 74U}, 
        {75U, 107U, 75U}, 
        {76U, 108U, 76U}, 
        {77U, 109U, 77U}, 
        {78U, 110U, 78U}, 
        {79U, 111U, 79U}, 
        {80U, 112U, 80U}, 
        {81U, 113U, 81U}, 
        {82U, 114U, 82U}, 
        {83U, 115U, 83U}, 
        {84U, 116U, 84U}, 
        {85U, 117U, 85U}, 
        {86U, 118U, 86U}, 
        {87U, 119U, 87U}, 
        {88U, 120U, 88U}, 
        {89U, 121U, 89U}, 
        {90U, 122U, 90U}, 
        {123U, 123U, 123U}, 
        {124U, 124U, 124U}, 
        {125U, 125U, 125U}, 
        {126U, 126U, 126U}, 
        {127U, 127U, 127U}, 
        {128U, 128U, 128U}, 
        {129U, 129U, 129U}, 
        {130U, 130U, 130U}, 
        {131U, 131U, 131U}, 
        {132U, 132U, 132U}, 
        {133U, 133U, 133U}, 
        {134U, 134U, 134U}, 
        {135U, 135U, 135U}, 
        {136U, 136U, 136U}, 
        {137U, 137U, 137U}, 
        {138U, 138U, 138U}, 
        {139U, 139U, 139U}, 
        {140U, 140U, 140U}, 
        {141U, 141U, 141U}, 
        {142U, 142U, 142U}, 
        {143U, 143U, 143U}, 
        {144U, 144U, 144U}, 
        {145U, 145U, 145U}, 
        {146U, 146U, 146U}, 
        {147U, 147U, 147U}, 
        {148U, 148U, 148U}, 
        {149U, 149U, 149U}, 
        {150U, 150U, 150U}, 
        {151U, 151U, 151U}, 
        {152U, 152U, 152U}, 
        {153U, 153U, 153U}, 
        {154U, 154U, 154U}, 
        {155U, 155U, 155U}, 
        {156U, 156U, 156U}, 
        {157U, 157U, 157U}, 
        {158U, 158U, 158U}, 
        {159U, 159U, 159U}, 
        {160U, 160U, 160U}, 
        {161U, 161U, 161U}, 
        {162U, 162U, 162U}, 
        {163U, 163U, 163U}, 
        {164U, 164U, 164U}, 
        {165U, 165U, 165U}, 
        {166U, 166U, 166U}, 
        {167U, 167U, 167U}, 
        {168U, 168U, 168U}, 
        {169U, 169U, 169U}, 
        {170U, 170U, 170U}, 
        {171U, 171U, 171U}, 
        {172U, 172U, 172U}, 
        {173U, 173U, 173U}, 
        {174U, 174U, 174U}, 
        {175U, 175U, 175U}, 
        {176U, 176U, 176U}, 
        {177U, 177U, 177U}, 
        {178U, 178U, 178U}, 
        {179U, 179U, 179U}, 
        {180U, 180U, 180U}, 
        {924U, 181U, 924U}, 
        {182U, 182U, 182U}, 
        {183U, 183U, 183U}, 
        {184U, 184U, 184U}, 
        {185U, 185U, 185U}, 
        {186U, 186U, 186U}, 
        {187U, 187U, 187U}, 
        {188U, 188U, 188U}, 
        {189U, 189U, 189U}, 
        {190U, 190U, 190U}, 
        {191U, 191U, 191U}, 
        {192U, 224U, 65U}, 
        {193U, 225U, 65U}, 
        {194U, 226U, 65U}, 
        {195U, 227U, 65U}, 
        {196U, 228U, 65U}, 
        {197U, 229U, 65U}, 
        {198U, 230U, 198U}, 
        {199U, 231U, 67U}, 
        {200U, 232U, 69U}, 
        {201U, 233U, 69U}, 
        {202U, 234U, 69U}, 
        {203U, 235U, 69U}, 
        {204U, 236U, 73U}, 
        {205U, 237U, 73U}, 
        {206U, 238U, 73U}, 
        {207U, 239U, 73U}, 
        {208U, 240U, 208U}, 
        {209U, 241U, 78U}, 
        {210U, 242U, 79U}, 
        {211U, 243U, 79U}, 
        {212U, 244U, 79U}, 
        {213U, 245U, 79U}, 
        {214U, 246U, 79U}, 
        {215U, 215U, 215U}, 
        {216U, 248U, 216U}, 
        {217U, 249U, 85U}, 
        {218U, 250U, 85U}, 
        {219U, 251U, 85U}, 
        {220U, 252U, 85U}, 
        {221U, 253U, 89U}, 
        {222U, 254U, 222U}, 
        {223U, 223U, 223U}, 
        {192U, 224U, 65U}, 
        {193U, 225U, 65U}, 
        {194U, 226U, 65U}, 
        {195U, 227U, 65U}, 
        {196U, 228U, 65U}, 
        {197U, 229U, 65U}, 
        {198U, 230U, 198U}, 
        {199U, 231U, 67U}, 
        {200U, 232U, 69U}, 
        {201U, 233U, 69U}, 
        {202U, 234U, 69U}, 
        {203U, 235U, 69U}, 
        {204U, 236U, 73U}, 
        {205U, 237U, 73U}, 
        {206U, 238U, 73U}, 
        {207U, 239U, 73U}, 
        {208U, 240U, 208U}, 
        {209U, 241U, 78U}, 
        {210U, 242U, 79U}, 
        {211U, 243U, 79U}, 
        {212U, 244U, 79U}, 
        {213U, 245U, 79U}, 
        {214U, 246U, 79U}, 
        {247U, 247U, 247U}, 
        {216U, 248U, 216U}, 
        {217U, 249U, 85U}, 
        {218U, 250U, 85U}, 
        {219U, 251U, 85U}, 
        {220U, 252U, 85U}, 
        {221U, 253U, 89U}, 
        {222U, 254U, 222U}, 
        {376U, 255U, 89U}};
#line 166 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane01[256]  = 
#line 166
  {      {256U, 257U, 65U}, 
        {256U, 257U, 65U}, 
        {258U, 259U, 65U}, 
        {258U, 259U, 65U}, 
        {260U, 261U, 65U}, 
        {260U, 261U, 65U}, 
        {262U, 263U, 67U}, 
        {262U, 263U, 67U}, 
        {264U, 265U, 67U}, 
        {264U, 265U, 67U}, 
        {266U, 267U, 67U}, 
        {266U, 267U, 67U}, 
        {268U, 269U, 67U}, 
        {268U, 269U, 67U}, 
        {270U, 271U, 68U}, 
        {270U, 271U, 68U}, 
        {272U, 273U, 272U}, 
        {272U, 273U, 272U}, 
        {274U, 275U, 69U}, 
        {274U, 275U, 69U}, 
        {276U, 277U, 69U}, 
        {276U, 277U, 69U}, 
        {278U, 279U, 69U}, 
        {278U, 279U, 69U}, 
        {280U, 281U, 69U}, 
        {280U, 281U, 69U}, 
        {282U, 283U, 69U}, 
        {282U, 283U, 69U}, 
        {284U, 285U, 71U}, 
        {284U, 285U, 71U}, 
        {286U, 287U, 71U}, 
        {286U, 287U, 71U}, 
        {288U, 289U, 71U}, 
        {288U, 289U, 71U}, 
        {290U, 291U, 71U}, 
        {290U, 291U, 71U}, 
        {292U, 293U, 72U}, 
        {292U, 293U, 72U}, 
        {294U, 295U, 294U}, 
        {294U, 295U, 294U}, 
        {296U, 297U, 73U}, 
        {296U, 297U, 73U}, 
        {298U, 299U, 73U}, 
        {298U, 299U, 73U}, 
        {300U, 301U, 73U}, 
        {300U, 301U, 73U}, 
        {302U, 303U, 73U}, 
        {302U, 303U, 73U}, 
        {304U, 105U, 73U}, 
        {73U, 305U, 73U}, 
        {306U, 307U, 306U}, 
        {306U, 307U, 306U}, 
        {308U, 309U, 74U}, 
        {308U, 309U, 74U}, 
        {310U, 311U, 75U}, 
        {310U, 311U, 75U}, 
        {312U, 312U, 312U}, 
        {313U, 314U, 76U}, 
        {313U, 314U, 76U}, 
        {315U, 316U, 76U}, 
        {315U, 316U, 76U}, 
        {317U, 318U, 76U}, 
        {317U, 318U, 76U}, 
        {319U, 320U, 319U}, 
        {319U, 320U, 319U}, 
        {321U, 322U, 321U}, 
        {321U, 322U, 321U}, 
        {323U, 324U, 78U}, 
        {323U, 324U, 78U}, 
        {325U, 326U, 78U}, 
        {325U, 326U, 78U}, 
        {327U, 328U, 78U}, 
        {327U, 328U, 78U}, 
        {329U, 329U, 329U}, 
        {330U, 331U, 330U}, 
        {330U, 331U, 330U}, 
        {332U, 333U, 79U}, 
        {332U, 333U, 79U}, 
        {334U, 335U, 79U}, 
        {334U, 335U, 79U}, 
        {336U, 337U, 79U}, 
        {336U, 337U, 79U}, 
        {338U, 339U, 338U}, 
        {338U, 339U, 338U}, 
        {340U, 341U, 82U}, 
        {340U, 341U, 82U}, 
        {342U, 343U, 82U}, 
        {342U, 343U, 82U}, 
        {344U, 345U, 82U}, 
        {344U, 345U, 82U}, 
        {346U, 347U, 83U}, 
        {346U, 347U, 83U}, 
        {348U, 349U, 83U}, 
        {348U, 349U, 83U}, 
        {350U, 351U, 83U}, 
        {350U, 351U, 83U}, 
        {352U, 353U, 83U}, 
        {352U, 353U, 83U}, 
        {354U, 355U, 84U}, 
        {354U, 355U, 84U}, 
        {356U, 357U, 84U}, 
        {356U, 357U, 84U}, 
        {358U, 359U, 358U}, 
        {358U, 359U, 358U}, 
        {360U, 361U, 85U}, 
        {360U, 361U, 85U}, 
        {362U, 363U, 85U}, 
        {362U, 363U, 85U}, 
        {364U, 365U, 85U}, 
        {364U, 365U, 85U}, 
        {366U, 367U, 85U}, 
        {366U, 367U, 85U}, 
        {368U, 369U, 85U}, 
        {368U, 369U, 85U}, 
        {370U, 371U, 85U}, 
        {370U, 371U, 85U}, 
        {372U, 373U, 87U}, 
        {372U, 373U, 87U}, 
        {374U, 375U, 89U}, 
        {374U, 375U, 89U}, 
        {376U, 255U, 89U}, 
        {377U, 378U, 90U}, 
        {377U, 378U, 90U}, 
        {379U, 380U, 90U}, 
        {379U, 380U, 90U}, 
        {381U, 382U, 90U}, 
        {381U, 382U, 90U}, 
        {83U, 383U, 83U}, 
        {384U, 384U, 384U}, 
        {385U, 595U, 385U}, 
        {386U, 387U, 386U}, 
        {386U, 387U, 386U}, 
        {388U, 389U, 388U}, 
        {388U, 389U, 388U}, 
        {390U, 596U, 390U}, 
        {391U, 392U, 391U}, 
        {391U, 392U, 391U}, 
        {393U, 598U, 393U}, 
        {394U, 599U, 394U}, 
        {395U, 396U, 395U}, 
        {395U, 396U, 395U}, 
        {397U, 397U, 397U}, 
        {398U, 477U, 398U}, 
        {399U, 601U, 399U}, 
        {400U, 603U, 400U}, 
        {401U, 402U, 401U}, 
        {401U, 402U, 401U}, 
        {403U, 608U, 403U}, 
        {404U, 611U, 404U}, 
        {502U, 405U, 502U}, 
        {406U, 617U, 406U}, 
        {407U, 616U, 407U}, 
        {408U, 409U, 408U}, 
        {408U, 409U, 408U}, 
        {410U, 410U, 410U}, 
        {411U, 411U, 411U}, 
        {412U, 623U, 412U}, 
        {413U, 626U, 413U}, 
        {414U, 414U, 414U}, 
        {415U, 629U, 415U}, 
        {416U, 417U, 79U}, 
        {416U, 417U, 79U}, 
        {418U, 419U, 418U}, 
        {418U, 419U, 418U}, 
        {420U, 421U, 420U}, 
        {420U, 421U, 420U}, 
        {422U, 640U, 422U}, 
        {423U, 424U, 423U}, 
        {423U, 424U, 423U}, 
        {425U, 643U, 425U}, 
        {426U, 426U, 426U}, 
        {427U, 427U, 427U}, 
        {428U, 429U, 428U}, 
        {428U, 429U, 428U}, 
        {430U, 648U, 430U}, 
        {431U, 432U, 85U}, 
        {431U, 432U, 85U}, 
        {433U, 650U, 433U}, 
        {434U, 651U, 434U}, 
        {435U, 436U, 435U}, 
        {435U, 436U, 435U}, 
        {437U, 438U, 437U}, 
        {437U, 438U, 437U}, 
        {439U, 658U, 439U}, 
        {440U, 441U, 440U}, 
        {440U, 441U, 440U}, 
        {442U, 442U, 442U}, 
        {443U, 443U, 443U}, 
        {444U, 445U, 444U}, 
        {444U, 445U, 444U}, 
        {446U, 446U, 446U}, 
        {503U, 447U, 503U}, 
        {448U, 448U, 448U}, 
        {449U, 449U, 449U}, 
        {450U, 450U, 450U}, 
        {451U, 451U, 451U}, 
        {452U, 454U, 452U}, 
        {452U, 454U, 452U}, 
        {452U, 454U, 452U}, 
        {455U, 457U, 455U}, 
        {455U, 457U, 455U}, 
        {455U, 457U, 455U}, 
        {458U, 460U, 458U}, 
        {458U, 460U, 458U}, 
        {458U, 460U, 458U}, 
        {461U, 462U, 65U}, 
        {461U, 462U, 65U}, 
        {463U, 464U, 73U}, 
        {463U, 464U, 73U}, 
        {465U, 466U, 79U}, 
        {465U, 466U, 79U}, 
        {467U, 468U, 85U}, 
        {467U, 468U, 85U}, 
        {469U, 470U, 85U}, 
        {469U, 470U, 85U}, 
        {471U, 472U, 85U}, 
        {471U, 472U, 85U}, 
        {473U, 474U, 85U}, 
        {473U, 474U, 85U}, 
        {475U, 476U, 85U}, 
        {475U, 476U, 85U}, 
        {398U, 477U, 398U}, 
        {478U, 479U, 65U}, 
        {478U, 479U, 65U}, 
        {480U, 481U, 65U}, 
        {480U, 481U, 65U}, 
        {482U, 483U, 198U}, 
        {482U, 483U, 198U}, 
        {484U, 485U, 484U}, 
        {484U, 485U, 484U}, 
        {486U, 487U, 71U}, 
        {486U, 487U, 71U}, 
        {488U, 489U, 75U}, 
        {488U, 489U, 75U}, 
        {490U, 491U, 79U}, 
        {490U, 491U, 79U}, 
        {492U, 493U, 79U}, 
        {492U, 493U, 79U}, 
        {494U, 495U, 439U}, 
        {494U, 495U, 439U}, 
        {496U, 496U, 74U}, 
        {497U, 499U, 497U}, 
        {497U, 499U, 497U}, 
        {497U, 499U, 497U}, 
        {500U, 501U, 71U}, 
        {500U, 501U, 71U}, 
        {502U, 405U, 502U}, 
        {503U, 447U, 503U}, 
        {504U, 505U, 78U}, 
        {504U, 505U, 78U}, 
        {506U, 507U, 65U}, 
        {506U, 507U, 65U}, 
        {508U, 509U, 198U}, 
        {508U, 509U, 198U}, 
        {510U, 511U, 216U}, 
        {510U, 511U, 216U}};
#line 297 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane02[256]  = 
#line 297
  {      {512U, 513U, 65U}, 
        {512U, 513U, 65U}, 
        {514U, 515U, 65U}, 
        {514U, 515U, 65U}, 
        {516U, 517U, 69U}, 
        {516U, 517U, 69U}, 
        {518U, 519U, 69U}, 
        {518U, 519U, 69U}, 
        {520U, 521U, 73U}, 
        {520U, 521U, 73U}, 
        {522U, 523U, 73U}, 
        {522U, 523U, 73U}, 
        {524U, 525U, 79U}, 
        {524U, 525U, 79U}, 
        {526U, 527U, 79U}, 
        {526U, 527U, 79U}, 
        {528U, 529U, 82U}, 
        {528U, 529U, 82U}, 
        {530U, 531U, 82U}, 
        {530U, 531U, 82U}, 
        {532U, 533U, 85U}, 
        {532U, 533U, 85U}, 
        {534U, 535U, 85U}, 
        {534U, 535U, 85U}, 
        {536U, 537U, 83U}, 
        {536U, 537U, 83U}, 
        {538U, 539U, 84U}, 
        {538U, 539U, 84U}, 
        {540U, 541U, 540U}, 
        {540U, 541U, 540U}, 
        {542U, 543U, 72U}, 
        {542U, 543U, 72U}, 
        {544U, 544U, 544U}, 
        {545U, 545U, 545U}, 
        {546U, 547U, 546U}, 
        {546U, 547U, 546U}, 
        {548U, 549U, 548U}, 
        {548U, 549U, 548U}, 
        {550U, 551U, 65U}, 
        {550U, 551U, 65U}, 
        {552U, 553U, 69U}, 
        {552U, 553U, 69U}, 
        {554U, 555U, 79U}, 
        {554U, 555U, 79U}, 
        {556U, 557U, 79U}, 
        {556U, 557U, 79U}, 
        {558U, 559U, 79U}, 
        {558U, 559U, 79U}, 
        {560U, 561U, 79U}, 
        {560U, 561U, 79U}, 
        {562U, 563U, 89U}, 
        {562U, 563U, 89U}, 
        {564U, 564U, 564U}, 
        {565U, 565U, 565U}, 
        {566U, 566U, 566U}, 
        {567U, 567U, 567U}, 
        {568U, 568U, 568U}, 
        {569U, 569U, 569U}, 
        {570U, 570U, 570U}, 
        {571U, 571U, 571U}, 
        {572U, 572U, 572U}, 
        {573U, 573U, 573U}, 
        {574U, 574U, 574U}, 
        {575U, 575U, 575U}, 
        {576U, 576U, 576U}, 
        {577U, 577U, 577U}, 
        {578U, 578U, 578U}, 
        {579U, 579U, 579U}, 
        {580U, 580U, 580U}, 
        {581U, 581U, 581U}, 
        {582U, 582U, 582U}, 
        {583U, 583U, 583U}, 
        {584U, 584U, 584U}, 
        {585U, 585U, 585U}, 
        {586U, 586U, 586U}, 
        {587U, 587U, 587U}, 
        {588U, 588U, 588U}, 
        {589U, 589U, 589U}, 
        {590U, 590U, 590U}, 
        {591U, 591U, 591U}, 
        {592U, 592U, 592U}, 
        {593U, 593U, 593U}, 
        {594U, 594U, 594U}, 
        {385U, 595U, 385U}, 
        {390U, 596U, 390U}, 
        {597U, 597U, 597U}, 
        {393U, 598U, 393U}, 
        {394U, 599U, 394U}, 
        {600U, 600U, 600U}, 
        {399U, 601U, 399U}, 
        {602U, 602U, 602U}, 
        {400U, 603U, 400U}, 
        {604U, 604U, 604U}, 
        {605U, 605U, 605U}, 
        {606U, 606U, 606U}, 
        {607U, 607U, 607U}, 
        {403U, 608U, 403U}, 
        {609U, 609U, 609U}, 
        {610U, 610U, 610U}, 
        {404U, 611U, 404U}, 
        {612U, 612U, 612U}, 
        {613U, 613U, 613U}, 
        {614U, 614U, 614U}, 
        {615U, 615U, 615U}, 
        {407U, 616U, 407U}, 
        {406U, 617U, 406U}, 
        {618U, 618U, 618U}, 
        {619U, 619U, 619U}, 
        {620U, 620U, 620U}, 
        {621U, 621U, 621U}, 
        {622U, 622U, 622U}, 
        {412U, 623U, 412U}, 
        {624U, 624U, 624U}, 
        {625U, 625U, 625U}, 
        {413U, 626U, 413U}, 
        {627U, 627U, 627U}, 
        {628U, 628U, 628U}, 
        {415U, 629U, 415U}, 
        {630U, 630U, 630U}, 
        {631U, 631U, 631U}, 
        {632U, 632U, 632U}, 
        {633U, 633U, 633U}, 
        {634U, 634U, 634U}, 
        {635U, 635U, 635U}, 
        {636U, 636U, 636U}, 
        {637U, 637U, 637U}, 
        {638U, 638U, 638U}, 
        {639U, 639U, 639U}, 
        {422U, 640U, 422U}, 
        {641U, 641U, 641U}, 
        {642U, 642U, 642U}, 
        {425U, 643U, 425U}, 
        {644U, 644U, 644U}, 
        {645U, 645U, 645U}, 
        {646U, 646U, 646U}, 
        {647U, 647U, 647U}, 
        {430U, 648U, 430U}, 
        {649U, 649U, 649U}, 
        {433U, 650U, 433U}, 
        {434U, 651U, 434U}, 
        {652U, 652U, 652U}, 
        {653U, 653U, 653U}, 
        {654U, 654U, 654U}, 
        {655U, 655U, 655U}, 
        {656U, 656U, 656U}, 
        {657U, 657U, 657U}, 
        {439U, 658U, 439U}, 
        {659U, 659U, 659U}, 
        {660U, 660U, 660U}, 
        {661U, 661U, 661U}, 
        {662U, 662U, 662U}, 
        {663U, 663U, 663U}, 
        {664U, 664U, 664U}, 
        {665U, 665U, 665U}, 
        {666U, 666U, 666U}, 
        {667U, 667U, 667U}, 
        {668U, 668U, 668U}, 
        {669U, 669U, 669U}, 
        {670U, 670U, 670U}, 
        {671U, 671U, 671U}, 
        {672U, 672U, 672U}, 
        {673U, 673U, 673U}, 
        {674U, 674U, 674U}, 
        {675U, 675U, 675U}, 
        {676U, 676U, 676U}, 
        {677U, 677U, 677U}, 
        {678U, 678U, 678U}, 
        {679U, 679U, 679U}, 
        {680U, 680U, 680U}, 
        {681U, 681U, 681U}, 
        {682U, 682U, 682U}, 
        {683U, 683U, 683U}, 
        {684U, 684U, 684U}, 
        {685U, 685U, 685U}, 
        {686U, 686U, 686U}, 
        {687U, 687U, 687U}, 
        {688U, 688U, 688U}, 
        {689U, 689U, 689U}, 
        {690U, 690U, 690U}, 
        {691U, 691U, 691U}, 
        {692U, 692U, 692U}, 
        {693U, 693U, 693U}, 
        {694U, 694U, 694U}, 
        {695U, 695U, 695U}, 
        {696U, 696U, 696U}, 
        {697U, 697U, 697U}, 
        {698U, 698U, 698U}, 
        {699U, 699U, 699U}, 
        {700U, 700U, 700U}, 
        {701U, 701U, 701U}, 
        {702U, 702U, 702U}, 
        {703U, 703U, 703U}, 
        {704U, 704U, 704U}, 
        {705U, 705U, 705U}, 
        {706U, 706U, 706U}, 
        {707U, 707U, 707U}, 
        {708U, 708U, 708U}, 
        {709U, 709U, 709U}, 
        {710U, 710U, 710U}, 
        {711U, 711U, 711U}, 
        {712U, 712U, 712U}, 
        {713U, 713U, 713U}, 
        {714U, 714U, 714U}, 
        {715U, 715U, 715U}, 
        {716U, 716U, 716U}, 
        {717U, 717U, 717U}, 
        {718U, 718U, 718U}, 
        {719U, 719U, 719U}, 
        {720U, 720U, 720U}, 
        {721U, 721U, 721U}, 
        {722U, 722U, 722U}, 
        {723U, 723U, 723U}, 
        {724U, 724U, 724U}, 
        {725U, 725U, 725U}, 
        {726U, 726U, 726U}, 
        {727U, 727U, 727U}, 
        {728U, 728U, 728U}, 
        {729U, 729U, 729U}, 
        {730U, 730U, 730U}, 
        {731U, 731U, 731U}, 
        {732U, 732U, 732U}, 
        {733U, 733U, 733U}, 
        {734U, 734U, 734U}, 
        {735U, 735U, 735U}, 
        {736U, 736U, 736U}, 
        {737U, 737U, 737U}, 
        {738U, 738U, 738U}, 
        {739U, 739U, 739U}, 
        {740U, 740U, 740U}, 
        {741U, 741U, 741U}, 
        {742U, 742U, 742U}, 
        {743U, 743U, 743U}, 
        {744U, 744U, 744U}, 
        {745U, 745U, 745U}, 
        {746U, 746U, 746U}, 
        {747U, 747U, 747U}, 
        {748U, 748U, 748U}, 
        {749U, 749U, 749U}, 
        {750U, 750U, 750U}, 
        {751U, 751U, 751U}, 
        {752U, 752U, 752U}, 
        {753U, 753U, 753U}, 
        {754U, 754U, 754U}, 
        {755U, 755U, 755U}, 
        {756U, 756U, 756U}, 
        {757U, 757U, 757U}, 
        {758U, 758U, 758U}, 
        {759U, 759U, 759U}, 
        {760U, 760U, 760U}, 
        {761U, 761U, 761U}, 
        {762U, 762U, 762U}, 
        {763U, 763U, 763U}, 
        {764U, 764U, 764U}, 
        {765U, 765U, 765U}, 
        {766U, 766U, 766U}, 
        {767U, 767U, 767U}};
#line 428 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane03[256]  = 
#line 428
  {      {768U, 768U, 768U}, 
        {769U, 769U, 769U}, 
        {770U, 770U, 770U}, 
        {771U, 771U, 771U}, 
        {772U, 772U, 772U}, 
        {773U, 773U, 773U}, 
        {774U, 774U, 774U}, 
        {775U, 775U, 775U}, 
        {776U, 776U, 776U}, 
        {777U, 777U, 777U}, 
        {778U, 778U, 778U}, 
        {779U, 779U, 779U}, 
        {780U, 780U, 780U}, 
        {781U, 781U, 781U}, 
        {782U, 782U, 782U}, 
        {783U, 783U, 783U}, 
        {784U, 784U, 784U}, 
        {785U, 785U, 785U}, 
        {786U, 786U, 786U}, 
        {787U, 787U, 787U}, 
        {788U, 788U, 788U}, 
        {789U, 789U, 789U}, 
        {790U, 790U, 790U}, 
        {791U, 791U, 791U}, 
        {792U, 792U, 792U}, 
        {793U, 793U, 793U}, 
        {794U, 794U, 794U}, 
        {795U, 795U, 795U}, 
        {796U, 796U, 796U}, 
        {797U, 797U, 797U}, 
        {798U, 798U, 798U}, 
        {799U, 799U, 799U}, 
        {800U, 800U, 800U}, 
        {801U, 801U, 801U}, 
        {802U, 802U, 802U}, 
        {803U, 803U, 803U}, 
        {804U, 804U, 804U}, 
        {805U, 805U, 805U}, 
        {806U, 806U, 806U}, 
        {807U, 807U, 807U}, 
        {808U, 808U, 808U}, 
        {809U, 809U, 809U}, 
        {810U, 810U, 810U}, 
        {811U, 811U, 811U}, 
        {812U, 812U, 812U}, 
        {813U, 813U, 813U}, 
        {814U, 814U, 814U}, 
        {815U, 815U, 815U}, 
        {816U, 816U, 816U}, 
        {817U, 817U, 817U}, 
        {818U, 818U, 818U}, 
        {819U, 819U, 819U}, 
        {820U, 820U, 820U}, 
        {821U, 821U, 821U}, 
        {822U, 822U, 822U}, 
        {823U, 823U, 823U}, 
        {824U, 824U, 824U}, 
        {825U, 825U, 825U}, 
        {826U, 826U, 826U}, 
        {827U, 827U, 827U}, 
        {828U, 828U, 828U}, 
        {829U, 829U, 829U}, 
        {830U, 830U, 830U}, 
        {831U, 831U, 831U}, 
        {832U, 832U, 832U}, 
        {833U, 833U, 833U}, 
        {834U, 834U, 834U}, 
        {835U, 835U, 835U}, 
        {836U, 836U, 836U}, 
        {921U, 837U, 921U}, 
        {838U, 838U, 838U}, 
        {839U, 839U, 839U}, 
        {840U, 840U, 840U}, 
        {841U, 841U, 841U}, 
        {842U, 842U, 842U}, 
        {843U, 843U, 843U}, 
        {844U, 844U, 844U}, 
        {845U, 845U, 845U}, 
        {846U, 846U, 846U}, 
        {847U, 847U, 847U}, 
        {848U, 848U, 848U}, 
        {849U, 849U, 849U}, 
        {850U, 850U, 850U}, 
        {851U, 851U, 851U}, 
        {852U, 852U, 852U}, 
        {853U, 853U, 853U}, 
        {854U, 854U, 854U}, 
        {855U, 855U, 855U}, 
        {856U, 856U, 856U}, 
        {857U, 857U, 857U}, 
        {858U, 858U, 858U}, 
        {859U, 859U, 859U}, 
        {860U, 860U, 860U}, 
        {861U, 861U, 861U}, 
        {862U, 862U, 862U}, 
        {863U, 863U, 863U}, 
        {864U, 864U, 864U}, 
        {865U, 865U, 865U}, 
        {866U, 866U, 866U}, 
        {867U, 867U, 867U}, 
        {868U, 868U, 868U}, 
        {869U, 869U, 869U}, 
        {870U, 870U, 870U}, 
        {871U, 871U, 871U}, 
        {872U, 872U, 872U}, 
        {873U, 873U, 873U}, 
        {874U, 874U, 874U}, 
        {875U, 875U, 875U}, 
        {876U, 876U, 876U}, 
        {877U, 877U, 877U}, 
        {878U, 878U, 878U}, 
        {879U, 879U, 879U}, 
        {880U, 880U, 880U}, 
        {881U, 881U, 881U}, 
        {882U, 882U, 882U}, 
        {883U, 883U, 883U}, 
        {884U, 884U, 884U}, 
        {885U, 885U, 885U}, 
        {886U, 886U, 886U}, 
        {887U, 887U, 887U}, 
        {888U, 888U, 888U}, 
        {889U, 889U, 889U}, 
        {890U, 890U, 890U}, 
        {891U, 891U, 891U}, 
        {892U, 892U, 892U}, 
        {893U, 893U, 893U}, 
        {894U, 894U, 894U}, 
        {895U, 895U, 895U}, 
        {896U, 896U, 896U}, 
        {897U, 897U, 897U}, 
        {898U, 898U, 898U}, 
        {899U, 899U, 899U}, 
        {900U, 900U, 900U}, 
        {901U, 901U, 901U}, 
        {902U, 940U, 913U}, 
        {903U, 903U, 903U}, 
        {904U, 941U, 917U}, 
        {905U, 942U, 919U}, 
        {906U, 943U, 921U}, 
        {907U, 907U, 907U}, 
        {908U, 972U, 927U}, 
        {909U, 909U, 909U}, 
        {910U, 973U, 933U}, 
        {911U, 974U, 937U}, 
        {912U, 912U, 921U}, 
        {913U, 945U, 913U}, 
        {914U, 946U, 914U}, 
        {915U, 947U, 915U}, 
        {916U, 948U, 916U}, 
        {917U, 949U, 917U}, 
        {918U, 950U, 918U}, 
        {919U, 951U, 919U}, 
        {920U, 952U, 920U}, 
        {921U, 953U, 921U}, 
        {922U, 954U, 922U}, 
        {923U, 955U, 923U}, 
        {924U, 956U, 924U}, 
        {925U, 957U, 925U}, 
        {926U, 958U, 926U}, 
        {927U, 959U, 927U}, 
        {928U, 960U, 928U}, 
        {929U, 961U, 929U}, 
        {930U, 930U, 930U}, 
        {931U, 963U, 931U}, 
        {932U, 964U, 932U}, 
        {933U, 965U, 933U}, 
        {934U, 966U, 934U}, 
        {935U, 967U, 935U}, 
        {936U, 968U, 936U}, 
        {937U, 969U, 937U}, 
        {938U, 970U, 921U}, 
        {939U, 971U, 933U}, 
        {902U, 940U, 913U}, 
        {904U, 941U, 917U}, 
        {905U, 942U, 919U}, 
        {906U, 943U, 921U}, 
        {944U, 944U, 933U}, 
        {913U, 945U, 913U}, 
        {914U, 946U, 914U}, 
        {915U, 947U, 915U}, 
        {916U, 948U, 916U}, 
        {917U, 949U, 917U}, 
        {918U, 950U, 918U}, 
        {919U, 951U, 919U}, 
        {920U, 952U, 920U}, 
        {921U, 953U, 921U}, 
        {922U, 954U, 922U}, 
        {923U, 955U, 923U}, 
        {924U, 956U, 924U}, 
        {925U, 957U, 925U}, 
        {926U, 958U, 926U}, 
        {927U, 959U, 927U}, 
        {928U, 960U, 928U}, 
        {929U, 961U, 929U}, 
        {931U, 962U, 931U}, 
        {931U, 963U, 931U}, 
        {932U, 964U, 932U}, 
        {933U, 965U, 933U}, 
        {934U, 966U, 934U}, 
        {935U, 967U, 935U}, 
        {936U, 968U, 936U}, 
        {937U, 969U, 937U}, 
        {938U, 970U, 921U}, 
        {939U, 971U, 933U}, 
        {908U, 972U, 927U}, 
        {910U, 973U, 933U}, 
        {911U, 974U, 937U}, 
        {975U, 975U, 975U}, 
        {914U, 976U, 914U}, 
        {920U, 977U, 920U}, 
        {978U, 978U, 978U}, 
        {979U, 979U, 978U}, 
        {980U, 980U, 978U}, 
        {934U, 981U, 934U}, 
        {928U, 982U, 928U}, 
        {983U, 983U, 983U}, 
        {984U, 984U, 984U}, 
        {985U, 985U, 985U}, 
        {986U, 987U, 986U}, 
        {986U, 987U, 986U}, 
        {988U, 989U, 988U}, 
        {988U, 989U, 988U}, 
        {990U, 991U, 990U}, 
        {990U, 991U, 990U}, 
        {992U, 993U, 992U}, 
        {992U, 993U, 992U}, 
        {994U, 995U, 994U}, 
        {994U, 995U, 994U}, 
        {996U, 997U, 996U}, 
        {996U, 997U, 996U}, 
        {998U, 999U, 998U}, 
        {998U, 999U, 998U}, 
        {1000U, 1001U, 1000U}, 
        {1000U, 1001U, 1000U}, 
        {1002U, 1003U, 1002U}, 
        {1002U, 1003U, 1002U}, 
        {1004U, 1005U, 1004U}, 
        {1004U, 1005U, 1004U}, 
        {1006U, 1007U, 1006U}, 
        {1006U, 1007U, 1006U}, 
        {922U, 1008U, 922U}, 
        {929U, 1009U, 929U}, 
        {931U, 1010U, 931U}, 
        {1011U, 1011U, 1011U}, 
        {1012U, 1012U, 1012U}, 
        {1013U, 1013U, 1013U}, 
        {1014U, 1014U, 1014U}, 
        {1015U, 1015U, 1015U}, 
        {1016U, 1016U, 1016U}, 
        {1017U, 1017U, 1017U}, 
        {1018U, 1018U, 1018U}, 
        {1019U, 1019U, 1019U}, 
        {1020U, 1020U, 1020U}, 
        {1021U, 1021U, 1021U}, 
        {1022U, 1022U, 1022U}, 
        {1023U, 1023U, 1023U}};
#line 559 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane04[256]  = 
#line 559
  {      {1024U, 1104U, 1045U}, 
        {1025U, 1105U, 1045U}, 
        {1026U, 1106U, 1026U}, 
        {1027U, 1107U, 1043U}, 
        {1028U, 1108U, 1028U}, 
        {1029U, 1109U, 1029U}, 
        {1030U, 1110U, 1030U}, 
        {1031U, 1111U, 1030U}, 
        {1032U, 1112U, 1032U}, 
        {1033U, 1113U, 1033U}, 
        {1034U, 1114U, 1034U}, 
        {1035U, 1115U, 1035U}, 
        {1036U, 1116U, 1050U}, 
        {1037U, 1117U, 1048U}, 
        {1038U, 1118U, 1059U}, 
        {1039U, 1119U, 1039U}, 
        {1040U, 1072U, 1040U}, 
        {1041U, 1073U, 1041U}, 
        {1042U, 1074U, 1042U}, 
        {1043U, 1075U, 1043U}, 
        {1044U, 1076U, 1044U}, 
        {1045U, 1077U, 1045U}, 
        {1046U, 1078U, 1046U}, 
        {1047U, 1079U, 1047U}, 
        {1048U, 1080U, 1048U}, 
        {1049U, 1081U, 1048U}, 
        {1050U, 1082U, 1050U}, 
        {1051U, 1083U, 1051U}, 
        {1052U, 1084U, 1052U}, 
        {1053U, 1085U, 1053U}, 
        {1054U, 1086U, 1054U}, 
        {1055U, 1087U, 1055U}, 
        {1056U, 1088U, 1056U}, 
        {1057U, 1089U, 1057U}, 
        {1058U, 1090U, 1058U}, 
        {1059U, 1091U, 1059U}, 
        {1060U, 1092U, 1060U}, 
        {1061U, 1093U, 1061U}, 
        {1062U, 1094U, 1062U}, 
        {1063U, 1095U, 1063U}, 
        {1064U, 1096U, 1064U}, 
        {1065U, 1097U, 1065U}, 
        {1066U, 1098U, 1066U}, 
        {1067U, 1099U, 1067U}, 
        {1068U, 1100U, 1068U}, 
        {1069U, 1101U, 1069U}, 
        {1070U, 1102U, 1070U}, 
        {1071U, 1103U, 1071U}, 
        {1040U, 1072U, 1040U}, 
        {1041U, 1073U, 1041U}, 
        {1042U, 1074U, 1042U}, 
        {1043U, 1075U, 1043U}, 
        {1044U, 1076U, 1044U}, 
        {1045U, 1077U, 1045U}, 
        {1046U, 1078U, 1046U}, 
        {1047U, 1079U, 1047U}, 
        {1048U, 1080U, 1048U}, 
        {1049U, 1081U, 1048U}, 
        {1050U, 1082U, 1050U}, 
        {1051U, 1083U, 1051U}, 
        {1052U, 1084U, 1052U}, 
        {1053U, 1085U, 1053U}, 
        {1054U, 1086U, 1054U}, 
        {1055U, 1087U, 1055U}, 
        {1056U, 1088U, 1056U}, 
        {1057U, 1089U, 1057U}, 
        {1058U, 1090U, 1058U}, 
        {1059U, 1091U, 1059U}, 
        {1060U, 1092U, 1060U}, 
        {1061U, 1093U, 1061U}, 
        {1062U, 1094U, 1062U}, 
        {1063U, 1095U, 1063U}, 
        {1064U, 1096U, 1064U}, 
        {1065U, 1097U, 1065U}, 
        {1066U, 1098U, 1066U}, 
        {1067U, 1099U, 1067U}, 
        {1068U, 1100U, 1068U}, 
        {1069U, 1101U, 1069U}, 
        {1070U, 1102U, 1070U}, 
        {1071U, 1103U, 1071U}, 
        {1024U, 1104U, 1045U}, 
        {1025U, 1105U, 1045U}, 
        {1026U, 1106U, 1026U}, 
        {1027U, 1107U, 1043U}, 
        {1028U, 1108U, 1028U}, 
        {1029U, 1109U, 1029U}, 
        {1030U, 1110U, 1030U}, 
        {1031U, 1111U, 1030U}, 
        {1032U, 1112U, 1032U}, 
        {1033U, 1113U, 1033U}, 
        {1034U, 1114U, 1034U}, 
        {1035U, 1115U, 1035U}, 
        {1036U, 1116U, 1050U}, 
        {1037U, 1117U, 1048U}, 
        {1038U, 1118U, 1059U}, 
        {1039U, 1119U, 1039U}, 
        {1120U, 1121U, 1120U}, 
        {1120U, 1121U, 1120U}, 
        {1122U, 1123U, 1122U}, 
        {1122U, 1123U, 1122U}, 
        {1124U, 1125U, 1124U}, 
        {1124U, 1125U, 1124U}, 
        {1126U, 1127U, 1126U}, 
        {1126U, 1127U, 1126U}, 
        {1128U, 1129U, 1128U}, 
        {1128U, 1129U, 1128U}, 
        {1130U, 1131U, 1130U}, 
        {1130U, 1131U, 1130U}, 
        {1132U, 1133U, 1132U}, 
        {1132U, 1133U, 1132U}, 
        {1134U, 1135U, 1134U}, 
        {1134U, 1135U, 1134U}, 
        {1136U, 1137U, 1136U}, 
        {1136U, 1137U, 1136U}, 
        {1138U, 1139U, 1138U}, 
        {1138U, 1139U, 1138U}, 
        {1140U, 1141U, 1140U}, 
        {1140U, 1141U, 1140U}, 
        {1142U, 1143U, 1140U}, 
        {1142U, 1143U, 1140U}, 
        {1144U, 1145U, 1144U}, 
        {1144U, 1145U, 1144U}, 
        {1146U, 1147U, 1146U}, 
        {1146U, 1147U, 1146U}, 
        {1148U, 1149U, 1148U}, 
        {1148U, 1149U, 1148U}, 
        {1150U, 1151U, 1150U}, 
        {1150U, 1151U, 1150U}, 
        {1152U, 1153U, 1152U}, 
        {1152U, 1153U, 1152U}, 
        {1154U, 1154U, 1154U}, 
        {1155U, 1155U, 1155U}, 
        {1156U, 1156U, 1156U}, 
        {1157U, 1157U, 1157U}, 
        {1158U, 1158U, 1158U}, 
        {1159U, 1159U, 1159U}, 
        {1160U, 1160U, 1160U}, 
        {1161U, 1161U, 1161U}, 
        {1162U, 1162U, 1162U}, 
        {1163U, 1163U, 1163U}, 
        {1164U, 1165U, 1164U}, 
        {1164U, 1165U, 1164U}, 
        {1166U, 1167U, 1166U}, 
        {1166U, 1167U, 1166U}, 
        {1168U, 1169U, 1168U}, 
        {1168U, 1169U, 1168U}, 
        {1170U, 1171U, 1170U}, 
        {1170U, 1171U, 1170U}, 
        {1172U, 1173U, 1172U}, 
        {1172U, 1173U, 1172U}, 
        {1174U, 1175U, 1174U}, 
        {1174U, 1175U, 1174U}, 
        {1176U, 1177U, 1176U}, 
        {1176U, 1177U, 1176U}, 
        {1178U, 1179U, 1178U}, 
        {1178U, 1179U, 1178U}, 
        {1180U, 1181U, 1180U}, 
        {1180U, 1181U, 1180U}, 
        {1182U, 1183U, 1182U}, 
        {1182U, 1183U, 1182U}, 
        {1184U, 1185U, 1184U}, 
        {1184U, 1185U, 1184U}, 
        {1186U, 1187U, 1186U}, 
        {1186U, 1187U, 1186U}, 
        {1188U, 1189U, 1188U}, 
        {1188U, 1189U, 1188U}, 
        {1190U, 1191U, 1190U}, 
        {1190U, 1191U, 1190U}, 
        {1192U, 1193U, 1192U}, 
        {1192U, 1193U, 1192U}, 
        {1194U, 1195U, 1194U}, 
        {1194U, 1195U, 1194U}, 
        {1196U, 1197U, 1196U}, 
        {1196U, 1197U, 1196U}, 
        {1198U, 1199U, 1198U}, 
        {1198U, 1199U, 1198U}, 
        {1200U, 1201U, 1200U}, 
        {1200U, 1201U, 1200U}, 
        {1202U, 1203U, 1202U}, 
        {1202U, 1203U, 1202U}, 
        {1204U, 1205U, 1204U}, 
        {1204U, 1205U, 1204U}, 
        {1206U, 1207U, 1206U}, 
        {1206U, 1207U, 1206U}, 
        {1208U, 1209U, 1208U}, 
        {1208U, 1209U, 1208U}, 
        {1210U, 1211U, 1210U}, 
        {1210U, 1211U, 1210U}, 
        {1212U, 1213U, 1212U}, 
        {1212U, 1213U, 1212U}, 
        {1214U, 1215U, 1214U}, 
        {1214U, 1215U, 1214U}, 
        {1216U, 1216U, 1216U}, 
        {1217U, 1218U, 1046U}, 
        {1217U, 1218U, 1046U}, 
        {1219U, 1220U, 1219U}, 
        {1219U, 1220U, 1219U}, 
        {1221U, 1221U, 1221U}, 
        {1222U, 1222U, 1222U}, 
        {1223U, 1224U, 1223U}, 
        {1223U, 1224U, 1223U}, 
        {1225U, 1225U, 1225U}, 
        {1226U, 1226U, 1226U}, 
        {1227U, 1228U, 1227U}, 
        {1227U, 1228U, 1227U}, 
        {1229U, 1229U, 1229U}, 
        {1230U, 1230U, 1230U}, 
        {1231U, 1231U, 1231U}, 
        {1232U, 1233U, 1040U}, 
        {1232U, 1233U, 1040U}, 
        {1234U, 1235U, 1040U}, 
        {1234U, 1235U, 1040U}, 
        {1236U, 1237U, 1236U}, 
        {1236U, 1237U, 1236U}, 
        {1238U, 1239U, 1045U}, 
        {1238U, 1239U, 1045U}, 
        {1240U, 1241U, 1240U}, 
        {1240U, 1241U, 1240U}, 
        {1242U, 1243U, 1240U}, 
        {1242U, 1243U, 1240U}, 
        {1244U, 1245U, 1046U}, 
        {1244U, 1245U, 1046U}, 
        {1246U, 1247U, 1047U}, 
        {1246U, 1247U, 1047U}, 
        {1248U, 1249U, 1248U}, 
        {1248U, 1249U, 1248U}, 
        {1250U, 1251U, 1048U}, 
        {1250U, 1251U, 1048U}, 
        {1252U, 1253U, 1048U}, 
        {1252U, 1253U, 1048U}, 
        {1254U, 1255U, 1054U}, 
        {1254U, 1255U, 1054U}, 
        {1256U, 1257U, 1256U}, 
        {1256U, 1257U, 1256U}, 
        {1258U, 1259U, 1256U}, 
        {1258U, 1259U, 1256U}, 
        {1260U, 1261U, 1069U}, 
        {1260U, 1261U, 1069U}, 
        {1262U, 1263U, 1059U}, 
        {1262U, 1263U, 1059U}, 
        {1264U, 1265U, 1059U}, 
        {1264U, 1265U, 1059U}, 
        {1266U, 1267U, 1059U}, 
        {1266U, 1267U, 1059U}, 
        {1268U, 1269U, 1063U}, 
        {1268U, 1269U, 1063U}, 
        {1270U, 1270U, 1270U}, 
        {1271U, 1271U, 1271U}, 
        {1272U, 1273U, 1067U}, 
        {1272U, 1273U, 1067U}, 
        {1274U, 1274U, 1274U}, 
        {1275U, 1275U, 1275U}, 
        {1276U, 1276U, 1276U}, 
        {1277U, 1277U, 1277U}, 
        {1278U, 1278U, 1278U}, 
        {1279U, 1279U, 1279U}};
#line 690 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane05[256]  = 
#line 690
  {      {1280U, 1280U, 1280U}, 
        {1281U, 1281U, 1281U}, 
        {1282U, 1282U, 1282U}, 
        {1283U, 1283U, 1283U}, 
        {1284U, 1284U, 1284U}, 
        {1285U, 1285U, 1285U}, 
        {1286U, 1286U, 1286U}, 
        {1287U, 1287U, 1287U}, 
        {1288U, 1288U, 1288U}, 
        {1289U, 1289U, 1289U}, 
        {1290U, 1290U, 1290U}, 
        {1291U, 1291U, 1291U}, 
        {1292U, 1292U, 1292U}, 
        {1293U, 1293U, 1293U}, 
        {1294U, 1294U, 1294U}, 
        {1295U, 1295U, 1295U}, 
        {1296U, 1296U, 1296U}, 
        {1297U, 1297U, 1297U}, 
        {1298U, 1298U, 1298U}, 
        {1299U, 1299U, 1299U}, 
        {1300U, 1300U, 1300U}, 
        {1301U, 1301U, 1301U}, 
        {1302U, 1302U, 1302U}, 
        {1303U, 1303U, 1303U}, 
        {1304U, 1304U, 1304U}, 
        {1305U, 1305U, 1305U}, 
        {1306U, 1306U, 1306U}, 
        {1307U, 1307U, 1307U}, 
        {1308U, 1308U, 1308U}, 
        {1309U, 1309U, 1309U}, 
        {1310U, 1310U, 1310U}, 
        {1311U, 1311U, 1311U}, 
        {1312U, 1312U, 1312U}, 
        {1313U, 1313U, 1313U}, 
        {1314U, 1314U, 1314U}, 
        {1315U, 1315U, 1315U}, 
        {1316U, 1316U, 1316U}, 
        {1317U, 1317U, 1317U}, 
        {1318U, 1318U, 1318U}, 
        {1319U, 1319U, 1319U}, 
        {1320U, 1320U, 1320U}, 
        {1321U, 1321U, 1321U}, 
        {1322U, 1322U, 1322U}, 
        {1323U, 1323U, 1323U}, 
        {1324U, 1324U, 1324U}, 
        {1325U, 1325U, 1325U}, 
        {1326U, 1326U, 1326U}, 
        {1327U, 1327U, 1327U}, 
        {1328U, 1328U, 1328U}, 
        {1329U, 1377U, 1329U}, 
        {1330U, 1378U, 1330U}, 
        {1331U, 1379U, 1331U}, 
        {1332U, 1380U, 1332U}, 
        {1333U, 1381U, 1333U}, 
        {1334U, 1382U, 1334U}, 
        {1335U, 1383U, 1335U}, 
        {1336U, 1384U, 1336U}, 
        {1337U, 1385U, 1337U}, 
        {1338U, 1386U, 1338U}, 
        {1339U, 1387U, 1339U}, 
        {1340U, 1388U, 1340U}, 
        {1341U, 1389U, 1341U}, 
        {1342U, 1390U, 1342U}, 
        {1343U, 1391U, 1343U}, 
        {1344U, 1392U, 1344U}, 
        {1345U, 1393U, 1345U}, 
        {1346U, 1394U, 1346U}, 
        {1347U, 1395U, 1347U}, 
        {1348U, 1396U, 1348U}, 
        {1349U, 1397U, 1349U}, 
        {1350U, 1398U, 1350U}, 
        {1351U, 1399U, 1351U}, 
        {1352U, 1400U, 1352U}, 
        {1353U, 1401U, 1353U}, 
        {1354U, 1402U, 1354U}, 
        {1355U, 1403U, 1355U}, 
        {1356U, 1404U, 1356U}, 
        {1357U, 1405U, 1357U}, 
        {1358U, 1406U, 1358U}, 
        {1359U, 1407U, 1359U}, 
        {1360U, 1408U, 1360U}, 
        {1361U, 1409U, 1361U}, 
        {1362U, 1410U, 1362U}, 
        {1363U, 1411U, 1363U}, 
        {1364U, 1412U, 1364U}, 
        {1365U, 1413U, 1365U}, 
        {1366U, 1414U, 1366U}, 
        {1367U, 1367U, 1367U}, 
        {1368U, 1368U, 1368U}, 
        {1369U, 1369U, 1369U}, 
        {1370U, 1370U, 1370U}, 
        {1371U, 1371U, 1371U}, 
        {1372U, 1372U, 1372U}, 
        {1373U, 1373U, 1373U}, 
        {1374U, 1374U, 1374U}, 
        {1375U, 1375U, 1375U}, 
        {1376U, 1376U, 1376U}, 
        {1329U, 1377U, 1329U}, 
        {1330U, 1378U, 1330U}, 
        {1331U, 1379U, 1331U}, 
        {1332U, 1380U, 1332U}, 
        {1333U, 1381U, 1333U}, 
        {1334U, 1382U, 1334U}, 
        {1335U, 1383U, 1335U}, 
        {1336U, 1384U, 1336U}, 
        {1337U, 1385U, 1337U}, 
        {1338U, 1386U, 1338U}, 
        {1339U, 1387U, 1339U}, 
        {1340U, 1388U, 1340U}, 
        {1341U, 1389U, 1341U}, 
        {1342U, 1390U, 1342U}, 
        {1343U, 1391U, 1343U}, 
        {1344U, 1392U, 1344U}, 
        {1345U, 1393U, 1345U}, 
        {1346U, 1394U, 1346U}, 
        {1347U, 1395U, 1347U}, 
        {1348U, 1396U, 1348U}, 
        {1349U, 1397U, 1349U}, 
        {1350U, 1398U, 1350U}, 
        {1351U, 1399U, 1351U}, 
        {1352U, 1400U, 1352U}, 
        {1353U, 1401U, 1353U}, 
        {1354U, 1402U, 1354U}, 
        {1355U, 1403U, 1355U}, 
        {1356U, 1404U, 1356U}, 
        {1357U, 1405U, 1357U}, 
        {1358U, 1406U, 1358U}, 
        {1359U, 1407U, 1359U}, 
        {1360U, 1408U, 1360U}, 
        {1361U, 1409U, 1361U}, 
        {1362U, 1410U, 1362U}, 
        {1363U, 1411U, 1363U}, 
        {1364U, 1412U, 1364U}, 
        {1365U, 1413U, 1365U}, 
        {1366U, 1414U, 1366U}, 
        {1415U, 1415U, 1415U}, 
        {1416U, 1416U, 1416U}, 
        {1417U, 1417U, 1417U}, 
        {1418U, 1418U, 1418U}, 
        {1419U, 1419U, 1419U}, 
        {1420U, 1420U, 1420U}, 
        {1421U, 1421U, 1421U}, 
        {1422U, 1422U, 1422U}, 
        {1423U, 1423U, 1423U}, 
        {1424U, 1424U, 1424U}, 
        {1425U, 1425U, 1425U}, 
        {1426U, 1426U, 1426U}, 
        {1427U, 1427U, 1427U}, 
        {1428U, 1428U, 1428U}, 
        {1429U, 1429U, 1429U}, 
        {1430U, 1430U, 1430U}, 
        {1431U, 1431U, 1431U}, 
        {1432U, 1432U, 1432U}, 
        {1433U, 1433U, 1433U}, 
        {1434U, 1434U, 1434U}, 
        {1435U, 1435U, 1435U}, 
        {1436U, 1436U, 1436U}, 
        {1437U, 1437U, 1437U}, 
        {1438U, 1438U, 1438U}, 
        {1439U, 1439U, 1439U}, 
        {1440U, 1440U, 1440U}, 
        {1441U, 1441U, 1441U}, 
        {1442U, 1442U, 1442U}, 
        {1443U, 1443U, 1443U}, 
        {1444U, 1444U, 1444U}, 
        {1445U, 1445U, 1445U}, 
        {1446U, 1446U, 1446U}, 
        {1447U, 1447U, 1447U}, 
        {1448U, 1448U, 1448U}, 
        {1449U, 1449U, 1449U}, 
        {1450U, 1450U, 1450U}, 
        {1451U, 1451U, 1451U}, 
        {1452U, 1452U, 1452U}, 
        {1453U, 1453U, 1453U}, 
        {1454U, 1454U, 1454U}, 
        {1455U, 1455U, 1455U}, 
        {1456U, 1456U, 1456U}, 
        {1457U, 1457U, 1457U}, 
        {1458U, 1458U, 1458U}, 
        {1459U, 1459U, 1459U}, 
        {1460U, 1460U, 1460U}, 
        {1461U, 1461U, 1461U}, 
        {1462U, 1462U, 1462U}, 
        {1463U, 1463U, 1463U}, 
        {1464U, 1464U, 1464U}, 
        {1465U, 1465U, 1465U}, 
        {1466U, 1466U, 1466U}, 
        {1467U, 1467U, 1467U}, 
        {1468U, 1468U, 1468U}, 
        {1469U, 1469U, 1469U}, 
        {1470U, 1470U, 1470U}, 
        {1471U, 1471U, 1471U}, 
        {1472U, 1472U, 1472U}, 
        {1473U, 1473U, 1473U}, 
        {1474U, 1474U, 1474U}, 
        {1475U, 1475U, 1475U}, 
        {1476U, 1476U, 1476U}, 
        {1477U, 1477U, 1477U}, 
        {1478U, 1478U, 1478U}, 
        {1479U, 1479U, 1479U}, 
        {1480U, 1480U, 1480U}, 
        {1481U, 1481U, 1481U}, 
        {1482U, 1482U, 1482U}, 
        {1483U, 1483U, 1483U}, 
        {1484U, 1484U, 1484U}, 
        {1485U, 1485U, 1485U}, 
        {1486U, 1486U, 1486U}, 
        {1487U, 1487U, 1487U}, 
        {1488U, 1488U, 1488U}, 
        {1489U, 1489U, 1489U}, 
        {1490U, 1490U, 1490U}, 
        {1491U, 1491U, 1491U}, 
        {1492U, 1492U, 1492U}, 
        {1493U, 1493U, 1493U}, 
        {1494U, 1494U, 1494U}, 
        {1495U, 1495U, 1495U}, 
        {1496U, 1496U, 1496U}, 
        {1497U, 1497U, 1497U}, 
        {1498U, 1498U, 1498U}, 
        {1499U, 1499U, 1499U}, 
        {1500U, 1500U, 1500U}, 
        {1501U, 1501U, 1501U}, 
        {1502U, 1502U, 1502U}, 
        {1503U, 1503U, 1503U}, 
        {1504U, 1504U, 1504U}, 
        {1505U, 1505U, 1505U}, 
        {1506U, 1506U, 1506U}, 
        {1507U, 1507U, 1507U}, 
        {1508U, 1508U, 1508U}, 
        {1509U, 1509U, 1509U}, 
        {1510U, 1510U, 1510U}, 
        {1511U, 1511U, 1511U}, 
        {1512U, 1512U, 1512U}, 
        {1513U, 1513U, 1513U}, 
        {1514U, 1514U, 1514U}, 
        {1515U, 1515U, 1515U}, 
        {1516U, 1516U, 1516U}, 
        {1517U, 1517U, 1517U}, 
        {1518U, 1518U, 1518U}, 
        {1519U, 1519U, 1519U}, 
        {1520U, 1520U, 1520U}, 
        {1521U, 1521U, 1521U}, 
        {1522U, 1522U, 1522U}, 
        {1523U, 1523U, 1523U}, 
        {1524U, 1524U, 1524U}, 
        {1525U, 1525U, 1525U}, 
        {1526U, 1526U, 1526U}, 
        {1527U, 1527U, 1527U}, 
        {1528U, 1528U, 1528U}, 
        {1529U, 1529U, 1529U}, 
        {1530U, 1530U, 1530U}, 
        {1531U, 1531U, 1531U}, 
        {1532U, 1532U, 1532U}, 
        {1533U, 1533U, 1533U}, 
        {1534U, 1534U, 1534U}, 
        {1535U, 1535U, 1535U}};
#line 821 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane1E[256]  = 
#line 821
  {      {7680U, 7681U, 65U}, 
        {7680U, 7681U, 65U}, 
        {7682U, 7683U, 66U}, 
        {7682U, 7683U, 66U}, 
        {7684U, 7685U, 66U}, 
        {7684U, 7685U, 66U}, 
        {7686U, 7687U, 66U}, 
        {7686U, 7687U, 66U}, 
        {7688U, 7689U, 67U}, 
        {7688U, 7689U, 67U}, 
        {7690U, 7691U, 68U}, 
        {7690U, 7691U, 68U}, 
        {7692U, 7693U, 68U}, 
        {7692U, 7693U, 68U}, 
        {7694U, 7695U, 68U}, 
        {7694U, 7695U, 68U}, 
        {7696U, 7697U, 68U}, 
        {7696U, 7697U, 68U}, 
        {7698U, 7699U, 68U}, 
        {7698U, 7699U, 68U}, 
        {7700U, 7701U, 69U}, 
        {7700U, 7701U, 69U}, 
        {7702U, 7703U, 69U}, 
        {7702U, 7703U, 69U}, 
        {7704U, 7705U, 69U}, 
        {7704U, 7705U, 69U}, 
        {7706U, 7707U, 69U}, 
        {7706U, 7707U, 69U}, 
        {7708U, 7709U, 69U}, 
        {7708U, 7709U, 69U}, 
        {7710U, 7711U, 70U}, 
        {7710U, 7711U, 70U}, 
        {7712U, 7713U, 71U}, 
        {7712U, 7713U, 71U}, 
        {7714U, 7715U, 72U}, 
        {7714U, 7715U, 72U}, 
        {7716U, 7717U, 72U}, 
        {7716U, 7717U, 72U}, 
        {7718U, 7719U, 72U}, 
        {7718U, 7719U, 72U}, 
        {7720U, 7721U, 72U}, 
        {7720U, 7721U, 72U}, 
        {7722U, 7723U, 72U}, 
        {7722U, 7723U, 72U}, 
        {7724U, 7725U, 73U}, 
        {7724U, 7725U, 73U}, 
        {7726U, 7727U, 73U}, 
        {7726U, 7727U, 73U}, 
        {7728U, 7729U, 75U}, 
        {7728U, 7729U, 75U}, 
        {7730U, 7731U, 75U}, 
        {7730U, 7731U, 75U}, 
        {7732U, 7733U, 75U}, 
        {7732U, 7733U, 75U}, 
        {7734U, 7735U, 76U}, 
        {7734U, 7735U, 76U}, 
        {7736U, 7737U, 76U}, 
        {7736U, 7737U, 76U}, 
        {7738U, 7739U, 76U}, 
        {7738U, 7739U, 76U}, 
        {7740U, 7741U, 76U}, 
        {7740U, 7741U, 76U}, 
        {7742U, 7743U, 77U}, 
        {7742U, 7743U, 77U}, 
        {7744U, 7745U, 77U}, 
        {7744U, 7745U, 77U}, 
        {7746U, 7747U, 77U}, 
        {7746U, 7747U, 77U}, 
        {7748U, 7749U, 78U}, 
        {7748U, 7749U, 78U}, 
        {7750U, 7751U, 78U}, 
        {7750U, 7751U, 78U}, 
        {7752U, 7753U, 78U}, 
        {7752U, 7753U, 78U}, 
        {7754U, 7755U, 78U}, 
        {7754U, 7755U, 78U}, 
        {7756U, 7757U, 79U}, 
        {7756U, 7757U, 79U}, 
        {7758U, 7759U, 79U}, 
        {7758U, 7759U, 79U}, 
        {7760U, 7761U, 79U}, 
        {7760U, 7761U, 79U}, 
        {7762U, 7763U, 79U}, 
        {7762U, 7763U, 79U}, 
        {7764U, 7765U, 80U}, 
        {7764U, 7765U, 80U}, 
        {7766U, 7767U, 80U}, 
        {7766U, 7767U, 80U}, 
        {7768U, 7769U, 82U}, 
        {7768U, 7769U, 82U}, 
        {7770U, 7771U, 82U}, 
        {7770U, 7771U, 82U}, 
        {7772U, 7773U, 82U}, 
        {7772U, 7773U, 82U}, 
        {7774U, 7775U, 82U}, 
        {7774U, 7775U, 82U}, 
        {7776U, 7777U, 83U}, 
        {7776U, 7777U, 83U}, 
        {7778U, 7779U, 83U}, 
        {7778U, 7779U, 83U}, 
        {7780U, 7781U, 83U}, 
        {7780U, 7781U, 83U}, 
        {7782U, 7783U, 83U}, 
        {7782U, 7783U, 83U}, 
        {7784U, 7785U, 83U}, 
        {7784U, 7785U, 83U}, 
        {7786U, 7787U, 84U}, 
        {7786U, 7787U, 84U}, 
        {7788U, 7789U, 84U}, 
        {7788U, 7789U, 84U}, 
        {7790U, 7791U, 84U}, 
        {7790U, 7791U, 84U}, 
        {7792U, 7793U, 84U}, 
        {7792U, 7793U, 84U}, 
        {7794U, 7795U, 85U}, 
        {7794U, 7795U, 85U}, 
        {7796U, 7797U, 85U}, 
        {7796U, 7797U, 85U}, 
        {7798U, 7799U, 85U}, 
        {7798U, 7799U, 85U}, 
        {7800U, 7801U, 85U}, 
        {7800U, 7801U, 85U}, 
        {7802U, 7803U, 85U}, 
        {7802U, 7803U, 85U}, 
        {7804U, 7805U, 86U}, 
        {7804U, 7805U, 86U}, 
        {7806U, 7807U, 86U}, 
        {7806U, 7807U, 86U}, 
        {7808U, 7809U, 87U}, 
        {7808U, 7809U, 87U}, 
        {7810U, 7811U, 87U}, 
        {7810U, 7811U, 87U}, 
        {7812U, 7813U, 87U}, 
        {7812U, 7813U, 87U}, 
        {7814U, 7815U, 87U}, 
        {7814U, 7815U, 87U}, 
        {7816U, 7817U, 87U}, 
        {7816U, 7817U, 87U}, 
        {7818U, 7819U, 88U}, 
        {7818U, 7819U, 88U}, 
        {7820U, 7821U, 88U}, 
        {7820U, 7821U, 88U}, 
        {7822U, 7823U, 89U}, 
        {7822U, 7823U, 89U}, 
        {7824U, 7825U, 90U}, 
        {7824U, 7825U, 90U}, 
        {7826U, 7827U, 90U}, 
        {7826U, 7827U, 90U}, 
        {7828U, 7829U, 90U}, 
        {7828U, 7829U, 90U}, 
        {7830U, 7830U, 72U}, 
        {7831U, 7831U, 84U}, 
        {7832U, 7832U, 87U}, 
        {7833U, 7833U, 89U}, 
        {7834U, 7834U, 7834U}, 
        {7776U, 7835U, 83U}, 
        {7836U, 7836U, 7836U}, 
        {7837U, 7837U, 7837U}, 
        {7838U, 7838U, 7838U}, 
        {7839U, 7839U, 7839U}, 
        {7840U, 7841U, 65U}, 
        {7840U, 7841U, 65U}, 
        {7842U, 7843U, 65U}, 
        {7842U, 7843U, 65U}, 
        {7844U, 7845U, 65U}, 
        {7844U, 7845U, 65U}, 
        {7846U, 7847U, 65U}, 
        {7846U, 7847U, 65U}, 
        {7848U, 7849U, 65U}, 
        {7848U, 7849U, 65U}, 
        {7850U, 7851U, 65U}, 
        {7850U, 7851U, 65U}, 
        {7852U, 7853U, 65U}, 
        {7852U, 7853U, 65U}, 
        {7854U, 7855U, 65U}, 
        {7854U, 7855U, 65U}, 
        {7856U, 7857U, 65U}, 
        {7856U, 7857U, 65U}, 
        {7858U, 7859U, 65U}, 
        {7858U, 7859U, 65U}, 
        {7860U, 7861U, 65U}, 
        {7860U, 7861U, 65U}, 
        {7862U, 7863U, 65U}, 
        {7862U, 7863U, 65U}, 
        {7864U, 7865U, 69U}, 
        {7864U, 7865U, 69U}, 
        {7866U, 7867U, 69U}, 
        {7866U, 7867U, 69U}, 
        {7868U, 7869U, 69U}, 
        {7868U, 7869U, 69U}, 
        {7870U, 7871U, 69U}, 
        {7870U, 7871U, 69U}, 
        {7872U, 7873U, 69U}, 
        {7872U, 7873U, 69U}, 
        {7874U, 7875U, 69U}, 
        {7874U, 7875U, 69U}, 
        {7876U, 7877U, 69U}, 
        {7876U, 7877U, 69U}, 
        {7878U, 7879U, 69U}, 
        {7878U, 7879U, 69U}, 
        {7880U, 7881U, 73U}, 
        {7880U, 7881U, 73U}, 
        {7882U, 7883U, 73U}, 
        {7882U, 7883U, 73U}, 
        {7884U, 7885U, 79U}, 
        {7884U, 7885U, 79U}, 
        {7886U, 7887U, 79U}, 
        {7886U, 7887U, 79U}, 
        {7888U, 7889U, 79U}, 
        {7888U, 7889U, 79U}, 
        {7890U, 7891U, 79U}, 
        {7890U, 7891U, 79U}, 
        {7892U, 7893U, 79U}, 
        {7892U, 7893U, 79U}, 
        {7894U, 7895U, 79U}, 
        {7894U, 7895U, 79U}, 
        {7896U, 7897U, 79U}, 
        {7896U, 7897U, 79U}, 
        {7898U, 7899U, 79U}, 
        {7898U, 7899U, 79U}, 
        {7900U, 7901U, 79U}, 
        {7900U, 7901U, 79U}, 
        {7902U, 7903U, 79U}, 
        {7902U, 7903U, 79U}, 
        {7904U, 7905U, 79U}, 
        {7904U, 7905U, 79U}, 
        {7906U, 7907U, 79U}, 
        {7906U, 7907U, 79U}, 
        {7908U, 7909U, 85U}, 
        {7908U, 7909U, 85U}, 
        {7910U, 7911U, 85U}, 
        {7910U, 7911U, 85U}, 
        {7912U, 7913U, 85U}, 
        {7912U, 7913U, 85U}, 
        {7914U, 7915U, 85U}, 
        {7914U, 7915U, 85U}, 
        {7916U, 7917U, 85U}, 
        {7916U, 7917U, 85U}, 
        {7918U, 7919U, 85U}, 
        {7918U, 7919U, 85U}, 
        {7920U, 7921U, 85U}, 
        {7920U, 7921U, 85U}, 
        {7922U, 7923U, 89U}, 
        {7922U, 7923U, 89U}, 
        {7924U, 7925U, 89U}, 
        {7924U, 7925U, 89U}, 
        {7926U, 7927U, 89U}, 
        {7926U, 7927U, 89U}, 
        {7928U, 7929U, 89U}, 
        {7928U, 7929U, 89U}, 
        {7930U, 7930U, 7930U}, 
        {7931U, 7931U, 7931U}, 
        {7932U, 7932U, 7932U}, 
        {7933U, 7933U, 7933U}, 
        {7934U, 7934U, 7934U}, 
        {7935U, 7935U, 7935U}};
#line 952 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane1F[256]  = 
#line 952
  {      {7944U, 7936U, 913U}, 
        {7945U, 7937U, 913U}, 
        {7946U, 7938U, 913U}, 
        {7947U, 7939U, 913U}, 
        {7948U, 7940U, 913U}, 
        {7949U, 7941U, 913U}, 
        {7950U, 7942U, 913U}, 
        {7951U, 7943U, 913U}, 
        {7944U, 7936U, 913U}, 
        {7945U, 7937U, 913U}, 
        {7946U, 7938U, 913U}, 
        {7947U, 7939U, 913U}, 
        {7948U, 7940U, 913U}, 
        {7949U, 7941U, 913U}, 
        {7950U, 7942U, 913U}, 
        {7951U, 7943U, 913U}, 
        {7960U, 7952U, 917U}, 
        {7961U, 7953U, 917U}, 
        {7962U, 7954U, 917U}, 
        {7963U, 7955U, 917U}, 
        {7964U, 7956U, 917U}, 
        {7965U, 7957U, 917U}, 
        {7958U, 7958U, 7958U}, 
        {7959U, 7959U, 7959U}, 
        {7960U, 7952U, 917U}, 
        {7961U, 7953U, 917U}, 
        {7962U, 7954U, 917U}, 
        {7963U, 7955U, 917U}, 
        {7964U, 7956U, 917U}, 
        {7965U, 7957U, 917U}, 
        {7966U, 7966U, 7966U}, 
        {7967U, 7967U, 7967U}, 
        {7976U, 7968U, 919U}, 
        {7977U, 7969U, 919U}, 
        {7978U, 7970U, 919U}, 
        {7979U, 7971U, 919U}, 
        {7980U, 7972U, 919U}, 
        {7981U, 7973U, 919U}, 
        {7982U, 7974U, 919U}, 
        {7983U, 7975U, 919U}, 
        {7976U, 7968U, 919U}, 
        {7977U, 7969U, 919U}, 
        {7978U, 7970U, 919U}, 
        {7979U, 7971U, 919U}, 
        {7980U, 7972U, 919U}, 
        {7981U, 7973U, 919U}, 
        {7982U, 7974U, 919U}, 
        {7983U, 7975U, 919U}, 
        {7992U, 7984U, 921U}, 
        {7993U, 7985U, 921U}, 
        {7994U, 7986U, 921U}, 
        {7995U, 7987U, 921U}, 
        {7996U, 7988U, 921U}, 
        {7997U, 7989U, 921U}, 
        {7998U, 7990U, 921U}, 
        {7999U, 7991U, 921U}, 
        {7992U, 7984U, 921U}, 
        {7993U, 7985U, 921U}, 
        {7994U, 7986U, 921U}, 
        {7995U, 7987U, 921U}, 
        {7996U, 7988U, 921U}, 
        {7997U, 7989U, 921U}, 
        {7998U, 7990U, 921U}, 
        {7999U, 7991U, 921U}, 
        {8008U, 8000U, 927U}, 
        {8009U, 8001U, 927U}, 
        {8010U, 8002U, 927U}, 
        {8011U, 8003U, 927U}, 
        {8012U, 8004U, 927U}, 
        {8013U, 8005U, 927U}, 
        {8006U, 8006U, 8006U}, 
        {8007U, 8007U, 8007U}, 
        {8008U, 8000U, 927U}, 
        {8009U, 8001U, 927U}, 
        {8010U, 8002U, 927U}, 
        {8011U, 8003U, 927U}, 
        {8012U, 8004U, 927U}, 
        {8013U, 8005U, 927U}, 
        {8014U, 8014U, 8014U}, 
        {8015U, 8015U, 8015U}, 
        {8016U, 8016U, 933U}, 
        {8025U, 8017U, 933U}, 
        {8018U, 8018U, 933U}, 
        {8027U, 8019U, 933U}, 
        {8020U, 8020U, 933U}, 
        {8029U, 8021U, 933U}, 
        {8022U, 8022U, 933U}, 
        {8031U, 8023U, 933U}, 
        {8024U, 8024U, 8024U}, 
        {8025U, 8017U, 933U}, 
        {8026U, 8026U, 8026U}, 
        {8027U, 8019U, 933U}, 
        {8028U, 8028U, 8028U}, 
        {8029U, 8021U, 933U}, 
        {8030U, 8030U, 8030U}, 
        {8031U, 8023U, 933U}, 
        {8040U, 8032U, 937U}, 
        {8041U, 8033U, 937U}, 
        {8042U, 8034U, 937U}, 
        {8043U, 8035U, 937U}, 
        {8044U, 8036U, 937U}, 
        {8045U, 8037U, 937U}, 
        {8046U, 8038U, 937U}, 
        {8047U, 8039U, 937U}, 
        {8040U, 8032U, 937U}, 
        {8041U, 8033U, 937U}, 
        {8042U, 8034U, 937U}, 
        {8043U, 8035U, 937U}, 
        {8044U, 8036U, 937U}, 
        {8045U, 8037U, 937U}, 
        {8046U, 8038U, 937U}, 
        {8047U, 8039U, 937U}, 
        {8122U, 8048U, 913U}, 
        {8123U, 8049U, 8123U}, 
        {8136U, 8050U, 917U}, 
        {8137U, 8051U, 8137U}, 
        {8138U, 8052U, 919U}, 
        {8139U, 8053U, 8139U}, 
        {8154U, 8054U, 921U}, 
        {8155U, 8055U, 8155U}, 
        {8184U, 8056U, 927U}, 
        {8185U, 8057U, 8185U}, 
        {8170U, 8058U, 933U}, 
        {8171U, 8059U, 8171U}, 
        {8186U, 8060U, 937U}, 
        {8187U, 8061U, 8187U}, 
        {8062U, 8062U, 8062U}, 
        {8063U, 8063U, 8063U}, 
        {8072U, 8064U, 913U}, 
        {8073U, 8065U, 913U}, 
        {8074U, 8066U, 913U}, 
        {8075U, 8067U, 913U}, 
        {8076U, 8068U, 913U}, 
        {8077U, 8069U, 913U}, 
        {8078U, 8070U, 913U}, 
        {8079U, 8071U, 913U}, 
        {8072U, 8064U, 913U}, 
        {8073U, 8065U, 913U}, 
        {8074U, 8066U, 913U}, 
        {8075U, 8067U, 913U}, 
        {8076U, 8068U, 913U}, 
        {8077U, 8069U, 913U}, 
        {8078U, 8070U, 913U}, 
        {8079U, 8071U, 913U}, 
        {8088U, 8080U, 919U}, 
        {8089U, 8081U, 919U}, 
        {8090U, 8082U, 919U}, 
        {8091U, 8083U, 919U}, 
        {8092U, 8084U, 919U}, 
        {8093U, 8085U, 919U}, 
        {8094U, 8086U, 919U}, 
        {8095U, 8087U, 919U}, 
        {8088U, 8080U, 919U}, 
        {8089U, 8081U, 919U}, 
        {8090U, 8082U, 919U}, 
        {8091U, 8083U, 919U}, 
        {8092U, 8084U, 919U}, 
        {8093U, 8085U, 919U}, 
        {8094U, 8086U, 919U}, 
        {8095U, 8087U, 919U}, 
        {8104U, 8096U, 937U}, 
        {8105U, 8097U, 937U}, 
        {8106U, 8098U, 937U}, 
        {8107U, 8099U, 937U}, 
        {8108U, 8100U, 937U}, 
        {8109U, 8101U, 937U}, 
        {8110U, 8102U, 937U}, 
        {8111U, 8103U, 937U}, 
        {8104U, 8096U, 937U}, 
        {8105U, 8097U, 937U}, 
        {8106U, 8098U, 937U}, 
        {8107U, 8099U, 937U}, 
        {8108U, 8100U, 937U}, 
        {8109U, 8101U, 937U}, 
        {8110U, 8102U, 937U}, 
        {8111U, 8103U, 937U}, 
        {8120U, 8112U, 913U}, 
        {8121U, 8113U, 913U}, 
        {8114U, 8114U, 913U}, 
        {8124U, 8115U, 913U}, 
        {8116U, 8116U, 913U}, 
        {8117U, 8117U, 8117U}, 
        {8118U, 8118U, 913U}, 
        {8119U, 8119U, 913U}, 
        {8120U, 8112U, 913U}, 
        {8121U, 8113U, 913U}, 
        {8122U, 8048U, 913U}, 
        {8123U, 8049U, 8123U}, 
        {8124U, 8115U, 913U}, 
        {8125U, 8125U, 8125U}, 
        {921U, 8126U, 921U}, 
        {8127U, 8127U, 8127U}, 
        {8128U, 8128U, 8128U}, 
        {8129U, 8129U, 8129U}, 
        {8130U, 8130U, 919U}, 
        {8140U, 8131U, 919U}, 
        {8132U, 8132U, 919U}, 
        {8133U, 8133U, 8133U}, 
        {8134U, 8134U, 919U}, 
        {8135U, 8135U, 919U}, 
        {8136U, 8050U, 917U}, 
        {8137U, 8051U, 8137U}, 
        {8138U, 8052U, 919U}, 
        {8139U, 8053U, 8139U}, 
        {8140U, 8131U, 919U}, 
        {8141U, 8141U, 8141U}, 
        {8142U, 8142U, 8142U}, 
        {8143U, 8143U, 8143U}, 
        {8152U, 8144U, 921U}, 
        {8153U, 8145U, 921U}, 
        {8146U, 8146U, 921U}, 
        {8147U, 8147U, 8147U}, 
        {8148U, 8148U, 8148U}, 
        {8149U, 8149U, 8149U}, 
        {8150U, 8150U, 921U}, 
        {8151U, 8151U, 921U}, 
        {8152U, 8144U, 921U}, 
        {8153U, 8145U, 921U}, 
        {8154U, 8054U, 921U}, 
        {8155U, 8055U, 8155U}, 
        {8156U, 8156U, 8156U}, 
        {8157U, 8157U, 8157U}, 
        {8158U, 8158U, 8158U}, 
        {8159U, 8159U, 8159U}, 
        {8168U, 8160U, 933U}, 
        {8169U, 8161U, 933U}, 
        {8162U, 8162U, 933U}, 
        {8163U, 8163U, 8163U}, 
        {8164U, 8164U, 929U}, 
        {8172U, 8165U, 929U}, 
        {8166U, 8166U, 933U}, 
        {8167U, 8167U, 933U}, 
        {8168U, 8160U, 933U}, 
        {8169U, 8161U, 933U}, 
        {8170U, 8058U, 933U}, 
        {8171U, 8059U, 8171U}, 
        {8172U, 8165U, 929U}, 
        {8173U, 8173U, 8173U}, 
        {8174U, 8174U, 8174U}, 
        {8175U, 8175U, 8175U}, 
        {8176U, 8176U, 8176U}, 
        {8177U, 8177U, 8177U}, 
        {8178U, 8178U, 937U}, 
        {8188U, 8179U, 937U}, 
        {8180U, 8180U, 937U}, 
        {8181U, 8181U, 8181U}, 
        {8182U, 8182U, 937U}, 
        {8183U, 8183U, 937U}, 
        {8184U, 8056U, 927U}, 
        {8185U, 8057U, 8185U}, 
        {8186U, 8060U, 937U}, 
        {8187U, 8061U, 8187U}, 
        {8188U, 8179U, 937U}, 
        {8189U, 8189U, 8189U}, 
        {8190U, 8190U, 8190U}, 
        {8191U, 8191U, 8191U}};
#line 1083 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane21[256]  = 
#line 1083
  {      {8448U, 8448U, 8448U}, 
        {8449U, 8449U, 8449U}, 
        {8450U, 8450U, 8450U}, 
        {8451U, 8451U, 8451U}, 
        {8452U, 8452U, 8452U}, 
        {8453U, 8453U, 8453U}, 
        {8454U, 8454U, 8454U}, 
        {8455U, 8455U, 8455U}, 
        {8456U, 8456U, 8456U}, 
        {8457U, 8457U, 8457U}, 
        {8458U, 8458U, 8458U}, 
        {8459U, 8459U, 8459U}, 
        {8460U, 8460U, 8460U}, 
        {8461U, 8461U, 8461U}, 
        {8462U, 8462U, 8462U}, 
        {8463U, 8463U, 8463U}, 
        {8464U, 8464U, 8464U}, 
        {8465U, 8465U, 8465U}, 
        {8466U, 8466U, 8466U}, 
        {8467U, 8467U, 8467U}, 
        {8468U, 8468U, 8468U}, 
        {8469U, 8469U, 8469U}, 
        {8470U, 8470U, 8470U}, 
        {8471U, 8471U, 8471U}, 
        {8472U, 8472U, 8472U}, 
        {8473U, 8473U, 8473U}, 
        {8474U, 8474U, 8474U}, 
        {8475U, 8475U, 8475U}, 
        {8476U, 8476U, 8476U}, 
        {8477U, 8477U, 8477U}, 
        {8478U, 8478U, 8478U}, 
        {8479U, 8479U, 8479U}, 
        {8480U, 8480U, 8480U}, 
        {8481U, 8481U, 8481U}, 
        {8482U, 8482U, 8482U}, 
        {8483U, 8483U, 8483U}, 
        {8484U, 8484U, 8484U}, 
        {8485U, 8485U, 8485U}, 
        {8486U, 969U, 8486U}, 
        {8487U, 8487U, 8487U}, 
        {8488U, 8488U, 8488U}, 
        {8489U, 8489U, 8489U}, 
        {8490U, 107U, 8490U}, 
        {8491U, 229U, 8491U}, 
        {8492U, 8492U, 8492U}, 
        {8493U, 8493U, 8493U}, 
        {8494U, 8494U, 8494U}, 
        {8495U, 8495U, 8495U}, 
        {8496U, 8496U, 8496U}, 
        {8497U, 8497U, 8497U}, 
        {8498U, 8498U, 8498U}, 
        {8499U, 8499U, 8499U}, 
        {8500U, 8500U, 8500U}, 
        {8501U, 8501U, 8501U}, 
        {8502U, 8502U, 8502U}, 
        {8503U, 8503U, 8503U}, 
        {8504U, 8504U, 8504U}, 
        {8505U, 8505U, 8505U}, 
        {8506U, 8506U, 8506U}, 
        {8507U, 8507U, 8507U}, 
        {8508U, 8508U, 8508U}, 
        {8509U, 8509U, 8509U}, 
        {8510U, 8510U, 8510U}, 
        {8511U, 8511U, 8511U}, 
        {8512U, 8512U, 8512U}, 
        {8513U, 8513U, 8513U}, 
        {8514U, 8514U, 8514U}, 
        {8515U, 8515U, 8515U}, 
        {8516U, 8516U, 8516U}, 
        {8517U, 8517U, 8517U}, 
        {8518U, 8518U, 8518U}, 
        {8519U, 8519U, 8519U}, 
        {8520U, 8520U, 8520U}, 
        {8521U, 8521U, 8521U}, 
        {8522U, 8522U, 8522U}, 
        {8523U, 8523U, 8523U}, 
        {8524U, 8524U, 8524U}, 
        {8525U, 8525U, 8525U}, 
        {8526U, 8526U, 8526U}, 
        {8527U, 8527U, 8527U}, 
        {8528U, 8528U, 8528U}, 
        {8529U, 8529U, 8529U}, 
        {8530U, 8530U, 8530U}, 
        {8531U, 8531U, 8531U}, 
        {8532U, 8532U, 8532U}, 
        {8533U, 8533U, 8533U}, 
        {8534U, 8534U, 8534U}, 
        {8535U, 8535U, 8535U}, 
        {8536U, 8536U, 8536U}, 
        {8537U, 8537U, 8537U}, 
        {8538U, 8538U, 8538U}, 
        {8539U, 8539U, 8539U}, 
        {8540U, 8540U, 8540U}, 
        {8541U, 8541U, 8541U}, 
        {8542U, 8542U, 8542U}, 
        {8543U, 8543U, 8543U}, 
        {8544U, 8560U, 8544U}, 
        {8545U, 8561U, 8545U}, 
        {8546U, 8562U, 8546U}, 
        {8547U, 8563U, 8547U}, 
        {8548U, 8564U, 8548U}, 
        {8549U, 8565U, 8549U}, 
        {8550U, 8566U, 8550U}, 
        {8551U, 8567U, 8551U}, 
        {8552U, 8568U, 8552U}, 
        {8553U, 8569U, 8553U}, 
        {8554U, 8570U, 8554U}, 
        {8555U, 8571U, 8555U}, 
        {8556U, 8572U, 8556U}, 
        {8557U, 8573U, 8557U}, 
        {8558U, 8574U, 8558U}, 
        {8559U, 8575U, 8559U}, 
        {8544U, 8560U, 8544U}, 
        {8545U, 8561U, 8545U}, 
        {8546U, 8562U, 8546U}, 
        {8547U, 8563U, 8547U}, 
        {8548U, 8564U, 8548U}, 
        {8549U, 8565U, 8549U}, 
        {8550U, 8566U, 8550U}, 
        {8551U, 8567U, 8551U}, 
        {8552U, 8568U, 8552U}, 
        {8553U, 8569U, 8553U}, 
        {8554U, 8570U, 8554U}, 
        {8555U, 8571U, 8555U}, 
        {8556U, 8572U, 8556U}, 
        {8557U, 8573U, 8557U}, 
        {8558U, 8574U, 8558U}, 
        {8559U, 8575U, 8559U}, 
        {8576U, 8576U, 8576U}, 
        {8577U, 8577U, 8577U}, 
        {8578U, 8578U, 8578U}, 
        {8579U, 8579U, 8579U}, 
        {8580U, 8580U, 8580U}, 
        {8581U, 8581U, 8581U}, 
        {8582U, 8582U, 8582U}, 
        {8583U, 8583U, 8583U}, 
        {8584U, 8584U, 8584U}, 
        {8585U, 8585U, 8585U}, 
        {8586U, 8586U, 8586U}, 
        {8587U, 8587U, 8587U}, 
        {8588U, 8588U, 8588U}, 
        {8589U, 8589U, 8589U}, 
        {8590U, 8590U, 8590U}, 
        {8591U, 8591U, 8591U}, 
        {8592U, 8592U, 8592U}, 
        {8593U, 8593U, 8593U}, 
        {8594U, 8594U, 8594U}, 
        {8595U, 8595U, 8595U}, 
        {8596U, 8596U, 8596U}, 
        {8597U, 8597U, 8597U}, 
        {8598U, 8598U, 8598U}, 
        {8599U, 8599U, 8599U}, 
        {8600U, 8600U, 8600U}, 
        {8601U, 8601U, 8601U}, 
        {8602U, 8602U, 8602U}, 
        {8603U, 8603U, 8603U}, 
        {8604U, 8604U, 8604U}, 
        {8605U, 8605U, 8605U}, 
        {8606U, 8606U, 8606U}, 
        {8607U, 8607U, 8607U}, 
        {8608U, 8608U, 8608U}, 
        {8609U, 8609U, 8609U}, 
        {8610U, 8610U, 8610U}, 
        {8611U, 8611U, 8611U}, 
        {8612U, 8612U, 8612U}, 
        {8613U, 8613U, 8613U}, 
        {8614U, 8614U, 8614U}, 
        {8615U, 8615U, 8615U}, 
        {8616U, 8616U, 8616U}, 
        {8617U, 8617U, 8617U}, 
        {8618U, 8618U, 8618U}, 
        {8619U, 8619U, 8619U}, 
        {8620U, 8620U, 8620U}, 
        {8621U, 8621U, 8621U}, 
        {8622U, 8622U, 8622U}, 
        {8623U, 8623U, 8623U}, 
        {8624U, 8624U, 8624U}, 
        {8625U, 8625U, 8625U}, 
        {8626U, 8626U, 8626U}, 
        {8627U, 8627U, 8627U}, 
        {8628U, 8628U, 8628U}, 
        {8629U, 8629U, 8629U}, 
        {8630U, 8630U, 8630U}, 
        {8631U, 8631U, 8631U}, 
        {8632U, 8632U, 8632U}, 
        {8633U, 8633U, 8633U}, 
        {8634U, 8634U, 8634U}, 
        {8635U, 8635U, 8635U}, 
        {8636U, 8636U, 8636U}, 
        {8637U, 8637U, 8637U}, 
        {8638U, 8638U, 8638U}, 
        {8639U, 8639U, 8639U}, 
        {8640U, 8640U, 8640U}, 
        {8641U, 8641U, 8641U}, 
        {8642U, 8642U, 8642U}, 
        {8643U, 8643U, 8643U}, 
        {8644U, 8644U, 8644U}, 
        {8645U, 8645U, 8645U}, 
        {8646U, 8646U, 8646U}, 
        {8647U, 8647U, 8647U}, 
        {8648U, 8648U, 8648U}, 
        {8649U, 8649U, 8649U}, 
        {8650U, 8650U, 8650U}, 
        {8651U, 8651U, 8651U}, 
        {8652U, 8652U, 8652U}, 
        {8653U, 8653U, 8653U}, 
        {8654U, 8654U, 8654U}, 
        {8655U, 8655U, 8655U}, 
        {8656U, 8656U, 8656U}, 
        {8657U, 8657U, 8657U}, 
        {8658U, 8658U, 8658U}, 
        {8659U, 8659U, 8659U}, 
        {8660U, 8660U, 8660U}, 
        {8661U, 8661U, 8661U}, 
        {8662U, 8662U, 8662U}, 
        {8663U, 8663U, 8663U}, 
        {8664U, 8664U, 8664U}, 
        {8665U, 8665U, 8665U}, 
        {8666U, 8666U, 8666U}, 
        {8667U, 8667U, 8667U}, 
        {8668U, 8668U, 8668U}, 
        {8669U, 8669U, 8669U}, 
        {8670U, 8670U, 8670U}, 
        {8671U, 8671U, 8671U}, 
        {8672U, 8672U, 8672U}, 
        {8673U, 8673U, 8673U}, 
        {8674U, 8674U, 8674U}, 
        {8675U, 8675U, 8675U}, 
        {8676U, 8676U, 8676U}, 
        {8677U, 8677U, 8677U}, 
        {8678U, 8678U, 8678U}, 
        {8679U, 8679U, 8679U}, 
        {8680U, 8680U, 8680U}, 
        {8681U, 8681U, 8681U}, 
        {8682U, 8682U, 8682U}, 
        {8683U, 8683U, 8683U}, 
        {8684U, 8684U, 8684U}, 
        {8685U, 8685U, 8685U}, 
        {8686U, 8686U, 8686U}, 
        {8687U, 8687U, 8687U}, 
        {8688U, 8688U, 8688U}, 
        {8689U, 8689U, 8689U}, 
        {8690U, 8690U, 8690U}, 
        {8691U, 8691U, 8691U}, 
        {8692U, 8692U, 8692U}, 
        {8693U, 8693U, 8693U}, 
        {8694U, 8694U, 8694U}, 
        {8695U, 8695U, 8695U}, 
        {8696U, 8696U, 8696U}, 
        {8697U, 8697U, 8697U}, 
        {8698U, 8698U, 8698U}, 
        {8699U, 8699U, 8699U}, 
        {8700U, 8700U, 8700U}, 
        {8701U, 8701U, 8701U}, 
        {8702U, 8702U, 8702U}, 
        {8703U, 8703U, 8703U}};
#line 1214 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO plane24[256]  = 
#line 1214
  {      {9216U, 9216U, 9216U}, 
        {9217U, 9217U, 9217U}, 
        {9218U, 9218U, 9218U}, 
        {9219U, 9219U, 9219U}, 
        {9220U, 9220U, 9220U}, 
        {9221U, 9221U, 9221U}, 
        {9222U, 9222U, 9222U}, 
        {9223U, 9223U, 9223U}, 
        {9224U, 9224U, 9224U}, 
        {9225U, 9225U, 9225U}, 
        {9226U, 9226U, 9226U}, 
        {9227U, 9227U, 9227U}, 
        {9228U, 9228U, 9228U}, 
        {9229U, 9229U, 9229U}, 
        {9230U, 9230U, 9230U}, 
        {9231U, 9231U, 9231U}, 
        {9232U, 9232U, 9232U}, 
        {9233U, 9233U, 9233U}, 
        {9234U, 9234U, 9234U}, 
        {9235U, 9235U, 9235U}, 
        {9236U, 9236U, 9236U}, 
        {9237U, 9237U, 9237U}, 
        {9238U, 9238U, 9238U}, 
        {9239U, 9239U, 9239U}, 
        {9240U, 9240U, 9240U}, 
        {9241U, 9241U, 9241U}, 
        {9242U, 9242U, 9242U}, 
        {9243U, 9243U, 9243U}, 
        {9244U, 9244U, 9244U}, 
        {9245U, 9245U, 9245U}, 
        {9246U, 9246U, 9246U}, 
        {9247U, 9247U, 9247U}, 
        {9248U, 9248U, 9248U}, 
        {9249U, 9249U, 9249U}, 
        {9250U, 9250U, 9250U}, 
        {9251U, 9251U, 9251U}, 
        {9252U, 9252U, 9252U}, 
        {9253U, 9253U, 9253U}, 
        {9254U, 9254U, 9254U}, 
        {9255U, 9255U, 9255U}, 
        {9256U, 9256U, 9256U}, 
        {9257U, 9257U, 9257U}, 
        {9258U, 9258U, 9258U}, 
        {9259U, 9259U, 9259U}, 
        {9260U, 9260U, 9260U}, 
        {9261U, 9261U, 9261U}, 
        {9262U, 9262U, 9262U}, 
        {9263U, 9263U, 9263U}, 
        {9264U, 9264U, 9264U}, 
        {9265U, 9265U, 9265U}, 
        {9266U, 9266U, 9266U}, 
        {9267U, 9267U, 9267U}, 
        {9268U, 9268U, 9268U}, 
        {9269U, 9269U, 9269U}, 
        {9270U, 9270U, 9270U}, 
        {9271U, 9271U, 9271U}, 
        {9272U, 9272U, 9272U}, 
        {9273U, 9273U, 9273U}, 
        {9274U, 9274U, 9274U}, 
        {9275U, 9275U, 9275U}, 
        {9276U, 9276U, 9276U}, 
        {9277U, 9277U, 9277U}, 
        {9278U, 9278U, 9278U}, 
        {9279U, 9279U, 9279U}, 
        {9280U, 9280U, 9280U}, 
        {9281U, 9281U, 9281U}, 
        {9282U, 9282U, 9282U}, 
        {9283U, 9283U, 9283U}, 
        {9284U, 9284U, 9284U}, 
        {9285U, 9285U, 9285U}, 
        {9286U, 9286U, 9286U}, 
        {9287U, 9287U, 9287U}, 
        {9288U, 9288U, 9288U}, 
        {9289U, 9289U, 9289U}, 
        {9290U, 9290U, 9290U}, 
        {9291U, 9291U, 9291U}, 
        {9292U, 9292U, 9292U}, 
        {9293U, 9293U, 9293U}, 
        {9294U, 9294U, 9294U}, 
        {9295U, 9295U, 9295U}, 
        {9296U, 9296U, 9296U}, 
        {9297U, 9297U, 9297U}, 
        {9298U, 9298U, 9298U}, 
        {9299U, 9299U, 9299U}, 
        {9300U, 9300U, 9300U}, 
        {9301U, 9301U, 9301U}, 
        {9302U, 9302U, 9302U}, 
        {9303U, 9303U, 9303U}, 
        {9304U, 9304U, 9304U}, 
        {9305U, 9305U, 9305U}, 
        {9306U, 9306U, 9306U}, 
        {9307U, 9307U, 9307U}, 
        {9308U, 9308U, 9308U}, 
        {9309U, 9309U, 9309U}, 
        {9310U, 9310U, 9310U}, 
        {9311U, 9311U, 9311U}, 
        {9312U, 9312U, 9312U}, 
        {9313U, 9313U, 9313U}, 
        {9314U, 9314U, 9314U}, 
        {9315U, 9315U, 9315U}, 
        {9316U, 9316U, 9316U}, 
        {9317U, 9317U, 9317U}, 
        {9318U, 9318U, 9318U}, 
        {9319U, 9319U, 9319U}, 
        {9320U, 9320U, 9320U}, 
        {9321U, 9321U, 9321U}, 
        {9322U, 9322U, 9322U}, 
        {9323U, 9323U, 9323U}, 
        {9324U, 9324U, 9324U}, 
        {9325U, 9325U, 9325U}, 
        {9326U, 9326U, 9326U}, 
        {9327U, 9327U, 9327U}, 
        {9328U, 9328U, 9328U}, 
        {9329U, 9329U, 9329U}, 
        {9330U, 9330U, 9330U}, 
        {9331U, 9331U, 9331U}, 
        {9332U, 9332U, 9332U}, 
        {9333U, 9333U, 9333U}, 
        {9334U, 9334U, 9334U}, 
        {9335U, 9335U, 9335U}, 
        {9336U, 9336U, 9336U}, 
        {9337U, 9337U, 9337U}, 
        {9338U, 9338U, 9338U}, 
        {9339U, 9339U, 9339U}, 
        {9340U, 9340U, 9340U}, 
        {9341U, 9341U, 9341U}, 
        {9342U, 9342U, 9342U}, 
        {9343U, 9343U, 9343U}, 
        {9344U, 9344U, 9344U}, 
        {9345U, 9345U, 9345U}, 
        {9346U, 9346U, 9346U}, 
        {9347U, 9347U, 9347U}, 
        {9348U, 9348U, 9348U}, 
        {9349U, 9349U, 9349U}, 
        {9350U, 9350U, 9350U}, 
        {9351U, 9351U, 9351U}, 
        {9352U, 9352U, 9352U}, 
        {9353U, 9353U, 9353U}, 
        {9354U, 9354U, 9354U}, 
        {9355U, 9355U, 9355U}, 
        {9356U, 9356U, 9356U}, 
        {9357U, 9357U, 9357U}, 
        {9358U, 9358U, 9358U}, 
        {9359U, 9359U, 9359U}, 
        {9360U, 9360U, 9360U}, 
        {9361U, 9361U, 9361U}, 
        {9362U, 9362U, 9362U}, 
        {9363U, 9363U, 9363U}, 
        {9364U, 9364U, 9364U}, 
        {9365U, 9365U, 9365U}, 
        {9366U, 9366U, 9366U}, 
        {9367U, 9367U, 9367U}, 
        {9368U, 9368U, 9368U}, 
        {9369U, 9369U, 9369U}, 
        {9370U, 9370U, 9370U}, 
        {9371U, 9371U, 9371U}, 
        {9372U, 9372U, 9372U}, 
        {9373U, 9373U, 9373U}, 
        {9374U, 9374U, 9374U}, 
        {9375U, 9375U, 9375U}, 
        {9376U, 9376U, 9376U}, 
        {9377U, 9377U, 9377U}, 
        {9378U, 9378U, 9378U}, 
        {9379U, 9379U, 9379U}, 
        {9380U, 9380U, 9380U}, 
        {9381U, 9381U, 9381U}, 
        {9382U, 9382U, 9382U}, 
        {9383U, 9383U, 9383U}, 
        {9384U, 9384U, 9384U}, 
        {9385U, 9385U, 9385U}, 
        {9386U, 9386U, 9386U}, 
        {9387U, 9387U, 9387U}, 
        {9388U, 9388U, 9388U}, 
        {9389U, 9389U, 9389U}, 
        {9390U, 9390U, 9390U}, 
        {9391U, 9391U, 9391U}, 
        {9392U, 9392U, 9392U}, 
        {9393U, 9393U, 9393U}, 
        {9394U, 9394U, 9394U}, 
        {9395U, 9395U, 9395U}, 
        {9396U, 9396U, 9396U}, 
        {9397U, 9397U, 9397U}, 
        {9398U, 9424U, 9398U}, 
        {9399U, 9425U, 9399U}, 
        {9400U, 9426U, 9400U}, 
        {9401U, 9427U, 9401U}, 
        {9402U, 9428U, 9402U}, 
        {9403U, 9429U, 9403U}, 
        {9404U, 9430U, 9404U}, 
        {9405U, 9431U, 9405U}, 
        {9406U, 9432U, 9406U}, 
        {9407U, 9433U, 9407U}, 
        {9408U, 9434U, 9408U}, 
        {9409U, 9435U, 9409U}, 
        {9410U, 9436U, 9410U}, 
        {9411U, 9437U, 9411U}, 
        {9412U, 9438U, 9412U}, 
        {9413U, 9439U, 9413U}, 
        {9414U, 9440U, 9414U}, 
        {9415U, 9441U, 9415U}, 
        {9416U, 9442U, 9416U}, 
        {9417U, 9443U, 9417U}, 
        {9418U, 9444U, 9418U}, 
        {9419U, 9445U, 9419U}, 
        {9420U, 9446U, 9420U}, 
        {9421U, 9447U, 9421U}, 
        {9422U, 9448U, 9422U}, 
        {9423U, 9449U, 9423U}, 
        {9398U, 9424U, 9398U}, 
        {9399U, 9425U, 9399U}, 
        {9400U, 9426U, 9400U}, 
        {9401U, 9427U, 9401U}, 
        {9402U, 9428U, 9402U}, 
        {9403U, 9429U, 9403U}, 
        {9404U, 9430U, 9404U}, 
        {9405U, 9431U, 9405U}, 
        {9406U, 9432U, 9406U}, 
        {9407U, 9433U, 9407U}, 
        {9408U, 9434U, 9408U}, 
        {9409U, 9435U, 9409U}, 
        {9410U, 9436U, 9410U}, 
        {9411U, 9437U, 9411U}, 
        {9412U, 9438U, 9412U}, 
        {9413U, 9439U, 9413U}, 
        {9414U, 9440U, 9414U}, 
        {9415U, 9441U, 9415U}, 
        {9416U, 9442U, 9416U}, 
        {9417U, 9443U, 9417U}, 
        {9418U, 9444U, 9418U}, 
        {9419U, 9445U, 9419U}, 
        {9420U, 9446U, 9420U}, 
        {9421U, 9447U, 9421U}, 
        {9422U, 9448U, 9422U}, 
        {9423U, 9449U, 9423U}, 
        {9450U, 9450U, 9450U}, 
        {9451U, 9451U, 9451U}, 
        {9452U, 9452U, 9452U}, 
        {9453U, 9453U, 9453U}, 
        {9454U, 9454U, 9454U}, 
        {9455U, 9455U, 9455U}, 
        {9456U, 9456U, 9456U}, 
        {9457U, 9457U, 9457U}, 
        {9458U, 9458U, 9458U}, 
        {9459U, 9459U, 9459U}, 
        {9460U, 9460U, 9460U}, 
        {9461U, 9461U, 9461U}, 
        {9462U, 9462U, 9462U}, 
        {9463U, 9463U, 9463U}, 
        {9464U, 9464U, 9464U}, 
        {9465U, 9465U, 9465U}, 
        {9466U, 9466U, 9466U}, 
        {9467U, 9467U, 9467U}, 
        {9468U, 9468U, 9468U}, 
        {9469U, 9469U, 9469U}, 
        {9470U, 9470U, 9470U}, 
        {9471U, 9471U, 9471U}};
#line 1345 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static MY_UNICASE_INFO planeFF[256]  = 
#line 1345
  {      {65280U, 65280U, 65280U}, 
        {65281U, 65281U, 65281U}, 
        {65282U, 65282U, 65282U}, 
        {65283U, 65283U, 65283U}, 
        {65284U, 65284U, 65284U}, 
        {65285U, 65285U, 65285U}, 
        {65286U, 65286U, 65286U}, 
        {65287U, 65287U, 65287U}, 
        {65288U, 65288U, 65288U}, 
        {65289U, 65289U, 65289U}, 
        {65290U, 65290U, 65290U}, 
        {65291U, 65291U, 65291U}, 
        {65292U, 65292U, 65292U}, 
        {65293U, 65293U, 65293U}, 
        {65294U, 65294U, 65294U}, 
        {65295U, 65295U, 65295U}, 
        {65296U, 65296U, 65296U}, 
        {65297U, 65297U, 65297U}, 
        {65298U, 65298U, 65298U}, 
        {65299U, 65299U, 65299U}, 
        {65300U, 65300U, 65300U}, 
        {65301U, 65301U, 65301U}, 
        {65302U, 65302U, 65302U}, 
        {65303U, 65303U, 65303U}, 
        {65304U, 65304U, 65304U}, 
        {65305U, 65305U, 65305U}, 
        {65306U, 65306U, 65306U}, 
        {65307U, 65307U, 65307U}, 
        {65308U, 65308U, 65308U}, 
        {65309U, 65309U, 65309U}, 
        {65310U, 65310U, 65310U}, 
        {65311U, 65311U, 65311U}, 
        {65312U, 65312U, 65312U}, 
        {65313U, 65345U, 65313U}, 
        {65314U, 65346U, 65314U}, 
        {65315U, 65347U, 65315U}, 
        {65316U, 65348U, 65316U}, 
        {65317U, 65349U, 65317U}, 
        {65318U, 65350U, 65318U}, 
        {65319U, 65351U, 65319U}, 
        {65320U, 65352U, 65320U}, 
        {65321U, 65353U, 65321U}, 
        {65322U, 65354U, 65322U}, 
        {65323U, 65355U, 65323U}, 
        {65324U, 65356U, 65324U}, 
        {65325U, 65357U, 65325U}, 
        {65326U, 65358U, 65326U}, 
        {65327U, 65359U, 65327U}, 
        {65328U, 65360U, 65328U}, 
        {65329U, 65361U, 65329U}, 
        {65330U, 65362U, 65330U}, 
        {65331U, 65363U, 65331U}, 
        {65332U, 65364U, 65332U}, 
        {65333U, 65365U, 65333U}, 
        {65334U, 65366U, 65334U}, 
        {65335U, 65367U, 65335U}, 
        {65336U, 65368U, 65336U}, 
        {65337U, 65369U, 65337U}, 
        {65338U, 65370U, 65338U}, 
        {65339U, 65339U, 65339U}, 
        {65340U, 65340U, 65340U}, 
        {65341U, 65341U, 65341U}, 
        {65342U, 65342U, 65342U}, 
        {65343U, 65343U, 65343U}, 
        {65344U, 65344U, 65344U}, 
        {65313U, 65345U, 65313U}, 
        {65314U, 65346U, 65314U}, 
        {65315U, 65347U, 65315U}, 
        {65316U, 65348U, 65316U}, 
        {65317U, 65349U, 65317U}, 
        {65318U, 65350U, 65318U}, 
        {65319U, 65351U, 65319U}, 
        {65320U, 65352U, 65320U}, 
        {65321U, 65353U, 65321U}, 
        {65322U, 65354U, 65322U}, 
        {65323U, 65355U, 65323U}, 
        {65324U, 65356U, 65324U}, 
        {65325U, 65357U, 65325U}, 
        {65326U, 65358U, 65326U}, 
        {65327U, 65359U, 65327U}, 
        {65328U, 65360U, 65328U}, 
        {65329U, 65361U, 65329U}, 
        {65330U, 65362U, 65330U}, 
        {65331U, 65363U, 65331U}, 
        {65332U, 65364U, 65332U}, 
        {65333U, 65365U, 65333U}, 
        {65334U, 65366U, 65334U}, 
        {65335U, 65367U, 65335U}, 
        {65336U, 65368U, 65336U}, 
        {65337U, 65369U, 65337U}, 
        {65338U, 65370U, 65338U}, 
        {65371U, 65371U, 65371U}, 
        {65372U, 65372U, 65372U}, 
        {65373U, 65373U, 65373U}, 
        {65374U, 65374U, 65374U}, 
        {65375U, 65375U, 65375U}, 
        {65376U, 65376U, 65376U}, 
        {65377U, 65377U, 65377U}, 
        {65378U, 65378U, 65378U}, 
        {65379U, 65379U, 65379U}, 
        {65380U, 65380U, 65380U}, 
        {65381U, 65381U, 65381U}, 
        {65382U, 65382U, 65382U}, 
        {65383U, 65383U, 65383U}, 
        {65384U, 65384U, 65384U}, 
        {65385U, 65385U, 65385U}, 
        {65386U, 65386U, 65386U}, 
        {65387U, 65387U, 65387U}, 
        {65388U, 65388U, 65388U}, 
        {65389U, 65389U, 65389U}, 
        {65390U, 65390U, 65390U}, 
        {65391U, 65391U, 65391U}, 
        {65392U, 65392U, 65392U}, 
        {65393U, 65393U, 65393U}, 
        {65394U, 65394U, 65394U}, 
        {65395U, 65395U, 65395U}, 
        {65396U, 65396U, 65396U}, 
        {65397U, 65397U, 65397U}, 
        {65398U, 65398U, 65398U}, 
        {65399U, 65399U, 65399U}, 
        {65400U, 65400U, 65400U}, 
        {65401U, 65401U, 65401U}, 
        {65402U, 65402U, 65402U}, 
        {65403U, 65403U, 65403U}, 
        {65404U, 65404U, 65404U}, 
        {65405U, 65405U, 65405U}, 
        {65406U, 65406U, 65406U}, 
        {65407U, 65407U, 65407U}, 
        {65408U, 65408U, 65408U}, 
        {65409U, 65409U, 65409U}, 
        {65410U, 65410U, 65410U}, 
        {65411U, 65411U, 65411U}, 
        {65412U, 65412U, 65412U}, 
        {65413U, 65413U, 65413U}, 
        {65414U, 65414U, 65414U}, 
        {65415U, 65415U, 65415U}, 
        {65416U, 65416U, 65416U}, 
        {65417U, 65417U, 65417U}, 
        {65418U, 65418U, 65418U}, 
        {65419U, 65419U, 65419U}, 
        {65420U, 65420U, 65420U}, 
        {65421U, 65421U, 65421U}, 
        {65422U, 65422U, 65422U}, 
        {65423U, 65423U, 65423U}, 
        {65424U, 65424U, 65424U}, 
        {65425U, 65425U, 65425U}, 
        {65426U, 65426U, 65426U}, 
        {65427U, 65427U, 65427U}, 
        {65428U, 65428U, 65428U}, 
        {65429U, 65429U, 65429U}, 
        {65430U, 65430U, 65430U}, 
        {65431U, 65431U, 65431U}, 
        {65432U, 65432U, 65432U}, 
        {65433U, 65433U, 65433U}, 
        {65434U, 65434U, 65434U}, 
        {65435U, 65435U, 65435U}, 
        {65436U, 65436U, 65436U}, 
        {65437U, 65437U, 65437U}, 
        {65438U, 65438U, 65438U}, 
        {65439U, 65439U, 65439U}, 
        {65440U, 65440U, 65440U}, 
        {65441U, 65441U, 65441U}, 
        {65442U, 65442U, 65442U}, 
        {65443U, 65443U, 65443U}, 
        {65444U, 65444U, 65444U}, 
        {65445U, 65445U, 65445U}, 
        {65446U, 65446U, 65446U}, 
        {65447U, 65447U, 65447U}, 
        {65448U, 65448U, 65448U}, 
        {65449U, 65449U, 65449U}, 
        {65450U, 65450U, 65450U}, 
        {65451U, 65451U, 65451U}, 
        {65452U, 65452U, 65452U}, 
        {65453U, 65453U, 65453U}, 
        {65454U, 65454U, 65454U}, 
        {65455U, 65455U, 65455U}, 
        {65456U, 65456U, 65456U}, 
        {65457U, 65457U, 65457U}, 
        {65458U, 65458U, 65458U}, 
        {65459U, 65459U, 65459U}, 
        {65460U, 65460U, 65460U}, 
        {65461U, 65461U, 65461U}, 
        {65462U, 65462U, 65462U}, 
        {65463U, 65463U, 65463U}, 
        {65464U, 65464U, 65464U}, 
        {65465U, 65465U, 65465U}, 
        {65466U, 65466U, 65466U}, 
        {65467U, 65467U, 65467U}, 
        {65468U, 65468U, 65468U}, 
        {65469U, 65469U, 65469U}, 
        {65470U, 65470U, 65470U}, 
        {65471U, 65471U, 65471U}, 
        {65472U, 65472U, 65472U}, 
        {65473U, 65473U, 65473U}, 
        {65474U, 65474U, 65474U}, 
        {65475U, 65475U, 65475U}, 
        {65476U, 65476U, 65476U}, 
        {65477U, 65477U, 65477U}, 
        {65478U, 65478U, 65478U}, 
        {65479U, 65479U, 65479U}, 
        {65480U, 65480U, 65480U}, 
        {65481U, 65481U, 65481U}, 
        {65482U, 65482U, 65482U}, 
        {65483U, 65483U, 65483U}, 
        {65484U, 65484U, 65484U}, 
        {65485U, 65485U, 65485U}, 
        {65486U, 65486U, 65486U}, 
        {65487U, 65487U, 65487U}, 
        {65488U, 65488U, 65488U}, 
        {65489U, 65489U, 65489U}, 
        {65490U, 65490U, 65490U}, 
        {65491U, 65491U, 65491U}, 
        {65492U, 65492U, 65492U}, 
        {65493U, 65493U, 65493U}, 
        {65494U, 65494U, 65494U}, 
        {65495U, 65495U, 65495U}, 
        {65496U, 65496U, 65496U}, 
        {65497U, 65497U, 65497U}, 
        {65498U, 65498U, 65498U}, 
        {65499U, 65499U, 65499U}, 
        {65500U, 65500U, 65500U}, 
        {65501U, 65501U, 65501U}, 
        {65502U, 65502U, 65502U}, 
        {65503U, 65503U, 65503U}, 
        {65504U, 65504U, 65504U}, 
        {65505U, 65505U, 65505U}, 
        {65506U, 65506U, 65506U}, 
        {65507U, 65507U, 65507U}, 
        {65508U, 65508U, 65508U}, 
        {65509U, 65509U, 65509U}, 
        {65510U, 65510U, 65510U}, 
        {65511U, 65511U, 65511U}, 
        {65512U, 65512U, 65512U}, 
        {65513U, 65513U, 65513U}, 
        {65514U, 65514U, 65514U}, 
        {65515U, 65515U, 65515U}, 
        {65516U, 65516U, 65516U}, 
        {65517U, 65517U, 65517U}, 
        {65518U, 65518U, 65518U}, 
        {65519U, 65519U, 65519U}, 
        {65520U, 65520U, 65520U}, 
        {65521U, 65521U, 65521U}, 
        {65522U, 65522U, 65522U}, 
        {65523U, 65523U, 65523U}, 
        {65524U, 65524U, 65524U}, 
        {65525U, 65525U, 65525U}, 
        {65526U, 65526U, 65526U}, 
        {65527U, 65527U, 65527U}, 
        {65528U, 65528U, 65528U}, 
        {65529U, 65529U, 65529U}, 
        {65530U, 65530U, 65530U}, 
        {65531U, 65531U, 65531U}, 
        {65532U, 65532U, 65532U}, 
        {65533U, 65533U, 65533U}, 
        {65534U, 65534U, 65534U}, 
        {65535U, 65535U, 65535U}};
#line 1476 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
MY_UNICASE_INFO *uni_plane[256]  = 
#line 1476
  {      plane00,      plane01,      plane02,      plane03, 
        plane04,      plane05,      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      plane1E,      plane1F, 
        (MY_UNICASE_INFO *)((void *)0),      plane21,      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        plane24,      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0), 
        (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      (MY_UNICASE_INFO *)((void *)0),      planeFF};
#line 1512 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
size_t utf8_char_width(unsigned char const   *p ) 
{ 


  {
#line 1515
  if ((int const   )*p <= 127) {
#line 1516
    return ((size_t )1);
  }
#line 1517
  if (194 <= (int )*p) {
#line 1517
    if ((int const   )*p <= 223) {
#line 1518
      return ((size_t )2);
    }
  }
#line 1519
  if (224 <= (int )*p) {
#line 1519
    if ((int const   )*p <= 239) {
#line 1520
      return ((size_t )3);
    }
  }
#line 1521
  if (240 <= (int )*p) {
#line 1521
    if ((int const   )*p <= 244) {
#line 1522
      return ((size_t )4);
    }
  }
#line 1523
  return ((size_t )0);
}
}
#line 1526 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
size_t utf8_strlen(char const   *s ) 
{ 
  size_t len ;
  size_t n ;

  {
#line 1529
  len = (size_t )0;
  {
#line 1532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1532
    if (*s) {
      {
#line 1532
      n = utf8_char_width((unsigned char const   *)s);
      }
#line 1532
      if (! (n != 0U)) {
#line 1532
        goto while_break;
      }
    } else {
#line 1532
      goto while_break;
    }
#line 1534
    len ++;
#line 1535
    s += n;
  }
  while_break: /* CIL Label */ ;
  }
#line 1537
  return (len);
}
}
#line 1541 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static int utf8_iter0(struct utf8_iterator *itr ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 1544
  tmp = utf8_char_width((unsigned char const   *)itr->curptr);
#line 1544
  n = tmp;
  }
#line 1545
  if (n == 0U) {
#line 1546
    return (1);
  }
#line 1547
  itr->curwidth = n;
#line 1548
  return (0);
}
}
#line 1551 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_iter_end_p(struct utf8_iterator *itr ) 
{ 


  {
#line 1554
  return ((int )*(itr->curptr) == 0);
}
}
#line 1557 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_iter_first(struct utf8_iterator *itr , unsigned char *ptr ) 
{ 
  int tmp ;

  {
  {
#line 1560
  itr->string = (char *)ptr;
#line 1561
  itr->curptr = (char *)ptr;
#line 1562
  tmp = utf8_iter0(itr);
  }
#line 1562
  return (tmp);
}
}
#line 1565 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_iter_next(struct utf8_iterator *itr ) 
{ 
  int tmp ;

  {
#line 1568
  if ((int )*(itr->curptr) == 0) {
#line 1569
    return (-1);
  }
  {
#line 1570
  itr->curptr += itr->curwidth;
#line 1571
  tmp = utf8_iter0(itr);
  }
#line 1571
  return (tmp);
}
}
#line 1577 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_wctomb(unsigned char *r , unsigned int wc ) 
{ 
  int count ;

  {
#line 1582
  if (wc < 128U) {
#line 1583
    count = 1;
  } else
#line 1584
  if (wc < 2048U) {
#line 1585
    count = 2;
  } else
#line 1586
  if (wc < 65536U) {
#line 1587
    count = 3;
  } else
#line 1588
  if (wc < 2097152U) {
#line 1589
    count = 4;
  } else
#line 1590
  if (wc < 67108864U) {
#line 1591
    count = 5;
  } else
#line 1592
  if (wc <= 2147483647U) {
#line 1593
    count = 6;
  } else {
#line 1595
    return (-1);
  }
  {
#line 1600
  if (count == 6) {
#line 1600
    goto case_6;
  }
#line 1601
  if (count == 5) {
#line 1601
    goto case_5;
  }
#line 1602
  if (count == 4) {
#line 1602
    goto case_4;
  }
#line 1603
  if (count == 3) {
#line 1603
    goto case_3;
  }
#line 1604
  if (count == 2) {
#line 1604
    goto case_2;
  }
#line 1605
  if (count == 1) {
#line 1605
    goto case_1;
  }
#line 1597
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1600
  *(r + 5) = (unsigned char )(128U | (wc & 63U));
#line 1600
  wc >>= 6;
#line 1600
  wc |= 67108864U;
  case_5: /* CIL Label */ 
#line 1601
  *(r + 4) = (unsigned char )(128U | (wc & 63U));
#line 1601
  wc >>= 6;
#line 1601
  wc |= 2097152U;
  case_4: /* CIL Label */ 
#line 1602
  *(r + 3) = (unsigned char )(128U | (wc & 63U));
#line 1602
  wc >>= 6;
#line 1602
  wc |= 65536U;
  case_3: /* CIL Label */ 
#line 1603
  *(r + 2) = (unsigned char )(128U | (wc & 63U));
#line 1603
  wc >>= 6;
#line 1603
  wc |= 2048U;
  case_2: /* CIL Label */ 
#line 1604
  *(r + 1) = (unsigned char )(128U | (wc & 63U));
#line 1604
  wc >>= 6;
#line 1604
  wc |= 192U;
  case_1: /* CIL Label */ 
#line 1605
  *(r + 0) = (unsigned char )wc;
  switch_break: /* CIL Label */ ;
  }
#line 1608
  return (count);
}
}
#line 1616 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_mbtowc_internal(void *data , int (*read___0)(void * ) , unsigned int *pwc ) 
{ 
  int s[4] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  void *__cil_tmp17 ;

  {
  {
#line 1622
  s[0] = (*read___0)(data);
  }
#line 1622
  if (s[0] <= 0) {
    {
#line 1622
    tmp = __errno_location();
#line 1622
    *tmp = 61;
    }
#line 1622
    return (-1);
  }
#line 1623
  if (s[0] < 128) {
#line 1625
    *pwc = (unsigned int )s[0];
#line 1626
    return (1);
  }
#line 1629
  if (s[0] < 194) {
    {
#line 1631
    tmp___0 = __errno_location();
#line 1631
    *tmp___0 = 84;
    }
#line 1632
    return (-1);
  } else
#line 1634
  if (s[0] < 224) {
    {
#line 1636
    s[1] = (*read___0)(data);
    }
#line 1636
    if (s[1] <= 0) {
      {
#line 1636
      tmp___1 = __errno_location();
#line 1636
      *tmp___1 = 61;
      }
#line 1636
      return (-1);
    }
#line 1637
    if (! ((s[1] ^ 128) < 64)) {
      {
#line 1639
      tmp___2 = __errno_location();
#line 1639
      *tmp___2 = 84;
      }
#line 1640
      return (-1);
    }
#line 1642
    *pwc = ((unsigned int )(s[0] & 31) << 6) | (unsigned int )(s[1] ^ 128);
#line 1644
    return (2);
  }
#line 1647
  if (s[0] < 240) {
    {
#line 1649
    s[1] = (*read___0)(data);
    }
#line 1649
    if (s[1] <= 0) {
      {
#line 1649
      tmp___3 = __errno_location();
#line 1649
      *tmp___3 = 61;
      }
#line 1649
      return (-1);
    }
    {
#line 1650
    s[2] = (*read___0)(data);
    }
#line 1650
    if (s[2] <= 0) {
      {
#line 1650
      tmp___4 = __errno_location();
#line 1650
      *tmp___4 = 61;
      }
#line 1650
      return (-1);
    }
#line 1652
    if ((s[1] ^ 128) < 64) {
#line 1652
      if ((s[2] ^ 128) < 64) {
#line 1652
        if (! (s[0] >= 225)) {
#line 1652
          if (! (s[1] >= 160)) {
            {
#line 1656
            tmp___5 = __errno_location();
#line 1656
            *tmp___5 = 84;
            }
#line 1657
            return (-1);
          }
        }
      } else {
        {
#line 1656
        tmp___5 = __errno_location();
#line 1656
        *tmp___5 = 84;
        }
#line 1657
        return (-1);
      }
    } else {
      {
#line 1656
      tmp___5 = __errno_location();
#line 1656
      *tmp___5 = 84;
      }
#line 1657
      return (-1);
    }
#line 1660
    *pwc = (unsigned int )((((unsigned long )(s[0] & 15) << 12) | ((unsigned long )(s[1] ^ 128) << 6)) | (unsigned long )(s[2] ^ 128));
#line 1664
    return (3);
  }
#line 1667
  if (s[0] < 248) {
    {
#line 1669
    s[1] = (*read___0)(data);
    }
#line 1669
    if (s[1] <= 0) {
      {
#line 1669
      tmp___6 = __errno_location();
#line 1669
      *tmp___6 = 61;
      }
#line 1669
      return (-1);
    }
    {
#line 1670
    s[2] = (*read___0)(data);
    }
#line 1670
    if (s[2] <= 0) {
      {
#line 1670
      tmp___7 = __errno_location();
#line 1670
      *tmp___7 = 61;
      }
#line 1670
      return (-1);
    }
    {
#line 1671
    s[3] = (*read___0)(data);
    }
#line 1671
    if (s[3] <= 0) {
      {
#line 1671
      tmp___8 = __errno_location();
#line 1671
      *tmp___8 = 61;
      }
#line 1671
      return (-1);
    }
#line 1673
    if ((s[1] ^ 128) < 64) {
#line 1673
      if ((s[2] ^ 128) < 64) {
#line 1673
        if ((s[3] ^ 128) < 64) {
#line 1673
          if (! (s[0] >= 241)) {
#line 1673
            if (! (s[1] >= 144)) {
              {
#line 1678
              tmp___9 = __errno_location();
#line 1678
              *tmp___9 = 84;
              }
#line 1679
              return (-1);
            }
          }
        } else {
          {
#line 1678
          tmp___9 = __errno_location();
#line 1678
          *tmp___9 = 84;
          }
#line 1679
          return (-1);
        }
      } else {
        {
#line 1678
        tmp___9 = __errno_location();
#line 1678
        *tmp___9 = 84;
        }
#line 1679
        return (-1);
      }
    } else {
      {
#line 1678
      tmp___9 = __errno_location();
#line 1678
      *tmp___9 = 84;
      }
#line 1679
      return (-1);
    }
#line 1682
    *pwc = (unsigned int )(((((unsigned long )(s[0] & 7) << 18) | ((unsigned long )(s[1] ^ 128) << 12)) | ((unsigned long )(s[2] ^ 128) << 6)) | (unsigned long )(s[3] ^ 128));
#line 1687
    return (4);
  }
  {
#line 1689
  tmp___10 = __errno_location();
#line 1689
  *tmp___10 = 84;
  }
#line 1690
  return (-1);
}
}
#line 1700 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
static int _next_char_from_string(void *data ) 
{ 
  struct tstring *p ;
  unsigned char *tmp ;

  {
#line 1703
  p = (struct tstring *)data;
#line 1704
  if (p->len == 0U) {
#line 1705
    return (0);
  }
#line 1706
  (p->len) --;
#line 1707
  tmp = p->ptr;
#line 1707
  (p->ptr) ++;
#line 1707
  return ((int )*tmp);
}
}
#line 1710 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_mbtowc(unsigned int *pwc , unsigned char *r , size_t len ) 
{ 
  struct tstring ts ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 1714
  ts.ptr = r;
#line 1715
  if (len) {
#line 1715
    ts.len = len;
  } else {
    {
#line 1715
    tmp = utf8_char_width((unsigned char const   *)r);
#line 1715
    ts.len = tmp;
    }
  }
  {
#line 1716
  tmp___0 = utf8_mbtowc_internal((void *)(& ts), & _next_char_from_string, pwc);
  }
#line 1716
  return (tmp___0);
}
}
#line 1720 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_symcmp(unsigned char *a , unsigned char *b ) 
{ 
  unsigned int wa ;
  unsigned int wb ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 1725
  tmp = utf8_char_width((unsigned char const   *)a);
#line 1725
  utf8_mbtowc(& wa, a, tmp);
#line 1726
  tmp___0 = utf8_char_width((unsigned char const   *)b);
#line 1726
  utf8_mbtowc(& wb, b, tmp___0);
  }
#line 1727
  if (wa < wb) {
#line 1728
    return (-1);
  }
#line 1729
  if (wa > wb) {
#line 1730
    return (1);
  }
#line 1731
  return (0);
}
}
#line 1734 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int urf8_symcasecmp(unsigned char *a , unsigned char *b ) 
{ 
  unsigned int wa ;
  unsigned int wb ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 1739
  tmp = utf8_char_width((unsigned char const   *)a);
#line 1739
  utf8_mbtowc(& wa, a, tmp);
#line 1740
  tmp___0 = utf8_char_width((unsigned char const   *)b);
#line 1740
  utf8_mbtowc(& wb, b, tmp___0);
#line 1741
  wa = utf8_wc_toupper(wa);
#line 1742
  wb = utf8_wc_toupper(wb);
  }
#line 1743
  if (wa < wb) {
#line 1744
    return (-1);
  }
#line 1745
  if (wa > wb) {
#line 1746
    return (1);
  }
#line 1747
  return (0);
}
}
#line 1750 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_strcasecmp(unsigned char *a , unsigned char *b ) 
{ 
  int alen ;
  int blen ;
  unsigned int wa ;
  unsigned int wb ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 1755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1755
    if (! *a) {
#line 1755
      goto while_break;
    }
#line 1759
    if ((int )*b == 0) {
#line 1760
      return (1);
    }
    {
#line 1762
    tmp = utf8_char_width((unsigned char const   *)a);
#line 1762
    alen = (int )tmp;
#line 1763
    utf8_mbtowc(& wa, a, (size_t )alen);
#line 1764
    tmp___0 = utf8_char_width((unsigned char const   *)b);
#line 1764
    blen = (int )tmp___0;
#line 1765
    utf8_mbtowc(& wb, b, (size_t )blen);
#line 1766
    wa = utf8_wc_toupper(wa);
#line 1767
    wb = utf8_wc_toupper(wb);
    }
#line 1768
    if (wa < wb) {
#line 1769
      return (-1);
    }
#line 1770
    if (wa > wb) {
#line 1771
      return (1);
    }
#line 1755
    a += alen;
#line 1755
    b += blen;
  }
  while_break: /* CIL Label */ ;
  }
#line 1774
  if (*b) {
#line 1775
    return (-1);
  }
#line 1776
  return (0);
}
}
#line 1779 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_strncasecmp(unsigned char *a , unsigned char *b , size_t maxlen ) 
{ 
  int alen ;
  int blen ;
  unsigned char *aend ;
  unsigned char *bend ;
  unsigned int wa ;
  unsigned int wb ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 1783
  aend = a + maxlen;
#line 1783
  bend = b + maxlen;
  {
#line 1785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1785
    if (! ((unsigned long )a < (unsigned long )aend)) {
#line 1785
      goto while_break;
    }
#line 1789
    if ((int )*a == 0) {
#line 1790
      if ((int )*b == 0) {
#line 1790
        tmp = 0;
      } else {
#line 1790
        tmp = -1;
      }
#line 1790
      return (tmp);
    }
#line 1792
    if ((int )*b == 0) {
#line 1793
      return (1);
    } else
#line 1792
    if ((unsigned long )b >= (unsigned long )bend) {
#line 1793
      return (1);
    }
    {
#line 1795
    tmp___0 = utf8_char_width((unsigned char const   *)a);
#line 1795
    alen = (int )tmp___0;
#line 1796
    utf8_mbtowc(& wa, a, (size_t )alen);
#line 1797
    tmp___1 = utf8_char_width((unsigned char const   *)b);
#line 1797
    blen = (int )tmp___1;
#line 1798
    utf8_mbtowc(& wb, b, (size_t )blen);
#line 1799
    wa = utf8_wc_toupper(wa);
#line 1800
    wb = utf8_wc_toupper(wb);
    }
#line 1801
    if (wa < wb) {
#line 1802
      return (-1);
    }
#line 1803
    if (wa > wb) {
#line 1804
      return (1);
    }
#line 1785
    a += alen;
#line 1785
    b += blen;
  }
  while_break: /* CIL Label */ ;
  }
#line 1807
  return (0);
}
}
#line 1812 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
unsigned int utf8_wc_toupper(unsigned int wc ) 
{ 
  int plane ;
  unsigned int tmp ;

  {
#line 1815
  plane = (int )((wc >> 8) & 255U);
#line 1816
  if (uni_plane[plane]) {
#line 1816
    tmp = (uni_plane[plane] + (wc & 255U))->toupper;
  } else {
#line 1816
    tmp = wc;
  }
#line 1816
  return (tmp);
}
}
#line 1819 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_toupper(char *s , size_t len ) 
{ 
  unsigned int wc ;
  int rc ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1822
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1822
    if (! (len > 0U)) {
#line 1822
      goto while_break;
    }
    {
#line 1825
    tmp = utf8_mbtowc(& wc, (unsigned char *)s, len);
#line 1825
    rc = tmp;
    }
#line 1826
    if (rc <= 0) {
#line 1827
      return (1);
    }
    {
#line 1828
    tmp___0 = utf8_wc_toupper(wc);
#line 1828
    tmp___1 = utf8_wctomb((unsigned char *)s, tmp___0);
    }
#line 1828
    if (rc != tmp___1) {
#line 1829
      return (1);
    }
#line 1830
    s += rc;
#line 1831
    len -= (size_t )rc;
  }
  while_break: /* CIL Label */ ;
  }
#line 1833
  return (0);
}
}
#line 1836 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
unsigned int utf8_wc_tolower(unsigned int wc ) 
{ 
  int plane ;
  unsigned int tmp ;

  {
#line 1839
  plane = (int )((wc >> 8) & 255U);
#line 1840
  if (uni_plane[plane]) {
#line 1840
    tmp = (uni_plane[plane] + (wc & 255U))->tolower;
  } else {
#line 1840
    tmp = wc;
  }
#line 1840
  return (tmp);
}
}
#line 1843 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_tolower(char *s , size_t len ) 
{ 
  unsigned int wc ;
  int rc ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1846
    if (! (len > 0U)) {
#line 1846
      goto while_break;
    }
    {
#line 1849
    tmp = utf8_mbtowc(& wc, (unsigned char *)s, len);
#line 1849
    rc = tmp;
    }
#line 1850
    if (rc <= 0) {
#line 1851
      return (1);
    }
    {
#line 1852
    tmp___0 = utf8_wc_tolower(wc);
#line 1852
    tmp___1 = utf8_wctomb((unsigned char *)s, tmp___0);
    }
#line 1852
    if (rc != tmp___1) {
#line 1853
      return (1);
    }
#line 1854
    s += rc;
#line 1855
    len -= (size_t )rc;
  }
  while_break: /* CIL Label */ ;
  }
#line 1857
  return (0);
}
}
#line 1861 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
size_t utf8_wc_strlen(unsigned int const   *s ) 
{ 
  size_t len ;
  unsigned int const   *tmp ;

  {
#line 1864
  len = (size_t )0;
  {
#line 1865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1865
    tmp = s;
#line 1865
    s ++;
#line 1865
    if (! *tmp) {
#line 1865
      goto while_break;
    }
#line 1866
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1867
  return (len);
}
}
#line 1870 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
unsigned int *utf8_wc_strdup(unsigned int const   *s ) 
{ 
  size_t len ;
  size_t tmp ;
  unsigned int *clone ;
  void *tmp___0 ;

  {
  {
#line 1873
  tmp = utf8_wc_strlen(s);
#line 1873
  len = tmp + 1U;
#line 1874
  tmp___0 = calloc(len, (size_t )sizeof(*(s + 0)));
#line 1874
  clone = (unsigned int *)tmp___0;
  }
#line 1875
  if (clone) {
    {
#line 1876
    memcpy((void */* __restrict  */)clone, (void const   */* __restrict  */)s, len);
    }
  }
#line 1877
  return (clone);
}
}
#line 1880 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
size_t utf8_wc_hash_string(unsigned int const   *ws , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned int wc ;
  unsigned int const   *tmp ;

  {
#line 1883
  value = (size_t )0;
  {
#line 1890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1890
    tmp = ws;
#line 1890
    ws ++;
#line 1890
    wc = (unsigned int )*tmp;
#line 1890
    if (! wc) {
#line 1890
      goto while_break;
    }
#line 1891
    value = wc + ((value << 16) | (value >> (sizeof(size_t ) * 8UL - 16UL)));
  }
  while_break: /* CIL Label */ ;
  }
#line 1892
  return (value % n_buckets);
}
}
#line 1895 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_wc_strcmp(unsigned int const   *a , unsigned int const   *b ) 
{ 


  {
  {
#line 1898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1898
    if (! (*a == *b)) {
#line 1898
      goto while_break;
    }
#line 1900
    if (*a == 0U) {
#line 1901
      return (0);
    }
#line 1902
    a ++;
#line 1903
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1905
  if (*a < *b) {
#line 1906
    return (-1);
  }
#line 1907
  if (*a > *b) {
#line 1908
    return (1);
  }
#line 1909
  return (0);
}
}
#line 1912 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_wc_strcasecmp(unsigned int const   *a , unsigned int const   *b ) 
{ 
  unsigned int wa ;
  unsigned int wb ;

  {
  {
#line 1917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1917
    if (! (*a == *b)) {
#line 1917
      goto while_break;
    }
#line 1919
    if (*a == 0U) {
#line 1920
      return (0);
    }
#line 1921
    a ++;
#line 1922
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1924
  wa = utf8_wc_toupper((unsigned int )*a);
#line 1925
  wb = utf8_wc_toupper((unsigned int )*b);
  }
#line 1927
  if (wa < wb) {
#line 1928
    return (-1);
  }
#line 1929
  if (wa > wb) {
#line 1930
    return (1);
  }
#line 1931
  return (0);
}
}
#line 1934 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
unsigned int *utf8_wc_quote(unsigned int const   *s ) 
{ 
  size_t len ;
  size_t tmp ;
  unsigned int *clone ;
  void *tmp___0 ;
  size_t i ;
  size_t j ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1937
  tmp = utf8_wc_strlen(s);
#line 1937
  len = tmp;
#line 1938
  tmp___0 = calloc(2U * len + 1U, (size_t )sizeof(*(s + 0)));
#line 1938
  clone = (unsigned int *)tmp___0;
  }
#line 1939
  if (clone) {
#line 1942
    j = (size_t )0;
#line 1942
    i = j;
    {
#line 1942
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1942
      if (! (i < len)) {
#line 1942
        goto while_break;
      }
      {
#line 1947
      if (*(s + i) == 34U) {
#line 1947
        goto case_34;
      }
#line 1947
      if (*(s + i) == 92U) {
#line 1947
        goto case_34;
      }
#line 1950
      goto switch_default;
      case_34: /* CIL Label */ 
      case_92: /* CIL Label */ 
#line 1948
      tmp___1 = j;
#line 1948
      j ++;
#line 1948
      *(clone + tmp___1) = (unsigned int )'\\';
      switch_default: /* CIL Label */ 
#line 1951
      tmp___2 = j;
#line 1951
      j ++;
#line 1951
      *(clone + tmp___2) = (unsigned int )*(s + i);
      switch_break: /* CIL Label */ ;
      }
#line 1942
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1954
    *(clone + j) = 0U;
#line 1955
    tmp___3 = realloc((void *)clone, (size_t )((unsigned long )(j + 1U) * sizeof(*(clone + 0))));
#line 1955
    clone = (unsigned int *)tmp___3;
    }
  }
#line 1957
  return (clone);
}
}
#line 1960 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_wc_to_mbstr(unsigned int const   *wordbuf , size_t wordlen , char **sptr ) 
{ 
  size_t i ;
  size_t wbc ;
  char *s ;
  char r[4] ;
  int rc ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char r___0[4] ;
  int rc___0 ;
  int tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
#line 1967
  wbc = (size_t )0;
#line 1968
  i = (size_t )0;
  {
#line 1968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1968
    if (! (i < wordlen)) {
#line 1968
      goto while_break;
    }
    {
#line 1971
    tmp = utf8_wctomb((unsigned char *)(r), (unsigned int )*(wordbuf + i));
#line 1971
    rc = tmp;
    }
#line 1972
    if (rc <= 0) {
#line 1973
      return (rc);
    }
#line 1974
    wbc += (size_t )rc;
#line 1968
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1977
  tmp___0 = malloc(wbc + 1U);
#line 1977
  s = (char *)tmp___0;
  }
#line 1978
  if (! s) {
    {
#line 1980
    tmp___1 = __errno_location();
#line 1980
    *tmp___1 = 12;
    }
#line 1981
    return (-1);
  }
#line 1984
  wbc = (size_t )0;
#line 1985
  i = (size_t )0;
  {
#line 1985
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1985
    if (! (i < wordlen)) {
#line 1985
      goto while_break___0;
    }
    {
#line 1988
    tmp___2 = utf8_wctomb((unsigned char *)(r___0), (unsigned int )*(wordbuf + i));
#line 1988
    rc___0 = tmp___2;
    }
#line 1989
    if (rc___0 <= 0) {
#line 1990
      return (rc___0);
    }
    {
#line 1991
    memcpy((void */* __restrict  */)(s + wbc), (void const   */* __restrict  */)(r___0),
           (size_t )rc___0);
#line 1992
    wbc += (size_t )rc___0;
#line 1985
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1994
  *(s + wbc) = (char)0;
#line 1995
  *sptr = s;
#line 1996
  return (0);
}
}
#line 1999 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_mbstr_to_wc(char const   *str , unsigned int **wptr ) 
{ 
  size_t sc ;
  size_t tmp ;
  size_t len ;
  size_t i ;
  unsigned int *w ;
  void *tmp___0 ;
  int rc ;
  int tmp___1 ;

  {
  {
#line 2002
  tmp = strlen(str);
#line 2002
  sc = tmp;
#line 2004
  tmp___0 = calloc((size_t )sizeof(*(w + 0)), sc + 1U);
#line 2004
  w = (unsigned int *)tmp___0;
  }
#line 2006
  if (! w) {
#line 2007
    return (-1);
  }
  {
#line 2008
  i = (size_t )0;
#line 2008
  len = strlen(str);
  }
  {
#line 2008
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2008
    if (! len) {
#line 2008
      goto while_break;
    }
    {
#line 2010
    tmp___1 = utf8_mbtowc(w + i, (unsigned char *)str, len);
#line 2010
    rc = tmp___1;
    }
#line 2011
    if (rc <= 0) {
      {
#line 2013
      free((void *)w);
      }
#line 2014
      return (-1);
    }
#line 2016
    str += rc;
#line 2017
    len -= (size_t )rc;
#line 2008
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2019
  *wptr = w;
#line 2020
  return ((int )sc);
}
}
#line 2025 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_mbstr_to_norm_wc(char const   *str , unsigned int **nptr ) 
{ 
  int inws ;
  size_t len ;
  size_t tmp ;
  unsigned int *base ;
  void *tmp___0 ;
  size_t i ;
  unsigned int wc ;
  int rc ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 2028
  inws = 0;
#line 2029
  tmp = strlen(str);
#line 2029
  len = tmp;
#line 2030
  tmp___0 = calloc(len + 1U, (size_t )sizeof(*(base + 0)));
#line 2030
  base = (unsigned int *)tmp___0;
#line 2031
  i = (size_t )0;
  }
#line 2033
  if (! base) {
#line 2034
    return (-1);
  }
  {
#line 2036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2036
    if (! (len > 0U)) {
#line 2036
      goto while_break;
    }
    {
#line 2038
    tmp___1 = utf8_mbtowc(& wc, (unsigned char *)str, len);
#line 2038
    rc = tmp___1;
    }
#line 2039
    if (rc <= 0) {
#line 2040
      return (1);
    }
#line 2041
    str += rc;
#line 2042
    len -= (size_t )rc;
#line 2043
    if (rc == 1) {
#line 2043
      if (wc == 32U) {
#line 2043
        goto _L;
      } else
#line 2043
      if (wc == 9U) {
#line 2043
        goto _L;
      } else
#line 2043
      if (wc == 10U) {
        _L: /* CIL Label */ 
#line 2044
        if (! inws) {
#line 2045
          wc = (unsigned int )' ';
#line 2046
          inws = 1;
        } else {
#line 2048
          goto while_continue;
        }
      } else {
#line 2050
        inws = 0;
      }
    } else {
#line 2050
      inws = 0;
    }
#line 2051
    tmp___2 = i;
#line 2051
    i ++;
#line 2051
    *(base + tmp___2) = wc;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2053
  tmp___3 = i;
#line 2053
  i ++;
#line 2053
  *(base + tmp___3) = 0U;
#line 2054
  tmp___4 = realloc((void *)base, (size_t )((unsigned long )i * sizeof(*(base + 0))));
#line 2054
  *nptr = (unsigned int *)tmp___4;
  }
#line 2055
  return (0);
}
}
#line 2058 "/home/wslee/benchmarks/textformat/dico-2.0/lib/utf8.c"
int utf8_quote(char const   *str , char **sptr ) 
{ 
  int rc ;
  unsigned int *ws ;
  unsigned int *ret ;
  size_t tmp ;
  int *tmp___0 ;

  {
  {
#line 2064
  rc = utf8_mbstr_to_wc(str, & ws);
  }
#line 2065
  if (rc < 0) {
#line 2066
    return (rc);
  }
  {
#line 2067
  ret = utf8_wc_quote((unsigned int const   *)ws);
  }
#line 2068
  if (ret) {
    {
#line 2070
    tmp = utf8_wc_strlen((unsigned int const   *)ret);
#line 2070
    rc = utf8_wc_to_mbstr((unsigned int const   *)ret, tmp, sptr);
#line 2071
    free((void *)ret);
    }
  } else {
    {
#line 2075
    tmp___0 = __errno_location();
#line 2075
    *tmp___0 = 12;
#line 2076
    rc = -1;
    }
  }
#line 2078
  return (rc);
}
}
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 32 "../include/dico/assoc.h"
dico_assoc_list_t dico_assoc_create(int flags ) ;
#line 34
void dico_assoc_destroy(dico_assoc_list_t *passoc ) ;
#line 39
int dico_assoc_append(dico_assoc_list_t assoc , char const   *key , char const   *value ) ;
#line 43
char const   *dico_assoc_find(dico_assoc_list_t assoc , char const   *key ) ;
#line 46 "../include/dico/url.h"
int dico_url_parse(dico_url_t *purl , char const   *str ) ;
#line 47
void dico_url_destroy(dico_url_t *purl ) ;
#line 48
char const   *dico_url_get_arg(dico_url_t url , char const   *argname ) ;
#line 49
char *dico_url_full_path(dico_url_t url ) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 282
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int alloc_string_len(char **sptr , char const   *start , size_t len ) 
{ 
  void *tmp ;

  {
  {
#line 32
  tmp = malloc(len + 1U);
#line 32
  *sptr = (char *)tmp;
  }
#line 33
  if (! *sptr) {
#line 34
    return (1);
  }
  {
#line 35
  memcpy((void */* __restrict  */)*sptr, (void const   */* __restrict  */)start, len);
#line 36
  *(*sptr + len) = (char)0;
  }
#line 37
  return (0);
}
}
#line 40 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int alloc_string(char **sptr , char const   *start , char const   *end ) 
{ 
  size_t len ;
  size_t tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 43
  if (end) {
#line 43
    tmp___0 = end - start;
  } else {
    {
#line 43
    tmp = strlen(start);
#line 43
    tmp___0 = (long )tmp;
    }
  }
  {
#line 43
  len = (size_t )tmp___0;
#line 44
  tmp___1 = alloc_string_len(sptr, start, len);
  }
#line 44
  return (tmp___1);
}
}
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int alloc_string_def(char **sptr , char const   *start , char const   *end ,
                            char const   *def ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 51
  if ((unsigned long )end == (unsigned long )start) {
    {
#line 52
    tmp = alloc_string(sptr, def, (char const   *)((void *)0));
    }
#line 52
    return (tmp);
  } else {
    {
#line 54
    tmp___0 = alloc_string(sptr, start, end);
    }
#line 54
    return (tmp___0);
  }
}
}
#line 57 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_parse_arg(dico_url_t url , char *p , char *q ) 
{ 
  char *s ;
  char *key ;
  char *value ;
  int tmp ;
  int tmp___0 ;

  {
#line 61
  value = (char *)((void *)0);
#line 63
  s = p;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if ((unsigned long )s < (unsigned long )q) {
#line 63
      if (! ((int )*s != 61)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 63
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  tmp = alloc_string(& key, (char const   *)p, (char const   *)s);
  }
#line 66
  if (tmp) {
#line 67
    return (1);
  }
#line 68
  if ((unsigned long )s != (unsigned long )q) {
    {
#line 69
    tmp___0 = alloc_string(& value, (char const   *)(s + 1), (char const   *)q);
    }
#line 69
    if (tmp___0) {
#line 70
      return (1);
    }
  }
  {
#line 72
  dico_assoc_append(url->args, (char const   *)key, (char const   *)value);
#line 73
  free((void *)key);
#line 74
  free((void *)value);
  }
#line 75
  return (0);
}
}
#line 78 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_get_args(dico_url_t url , char **str ) 
{ 
  int rc ;
  char *p ;
  char *q ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 84
  if (! *(*str)) {
#line 85
    return (0);
  }
  {
#line 87
  url->args = dico_assoc_create(2);
  }
#line 88
  if (! url->args) {
#line 89
    return (1);
  }
#line 90
  p = *str;
#line 90
  rc = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (! rc)) {
#line 90
      goto while_break;
    }
    {
#line 91
    tmp = strchr((char const   *)p, ';');
#line 91
    q = tmp;
    }
#line 92
    if (q) {
      {
#line 93
      rc = url_parse_arg(url, p, q);
#line 94
      p = q + 1;
      }
    } else {
      {
#line 96
      tmp___0 = strlen((char const   *)p);
#line 96
      rc = url_parse_arg(url, p, p + tmp___0);
      }
#line 97
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (rc);
}
}
#line 103 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_get_path(dico_url_t url , char **str ) 
{ 
  char *p ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 108
  p = strchr((char const   *)*str, ';');
  }
#line 109
  if (! p) {
    {
#line 110
    tmp = strlen((char const   *)*str);
#line 110
    p = *str + tmp;
    }
  }
  {
#line 111
  tmp___0 = alloc_string(& url->path, (char const   *)*str, (char const   *)p);
  }
#line 111
  if (tmp___0) {
#line 112
    return (1);
  }
#line 113
  *str = p;
#line 114
  if (*p) {
#line 115
    (*str) ++;
  }
  {
#line 116
  tmp___1 = url_get_args(url, str);
  }
#line 116
  return (tmp___1);
}
}
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_get_host(dico_url_t url , char **str ) 
{ 
  char *s ;
  size_t len ;
  size_t tmp ;
  char *q ;
  unsigned long n ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 124
  s = *str;
#line 125
  tmp = strcspn((char const   *)s, "/:");
#line 125
  len = tmp;
  }
#line 127
  if ((int )*(s + len) == 58) {
    {
#line 129
    tmp___0 = strtoul((char const   */* __restrict  */)((s + len) + 1), (char **/* __restrict  */)(& q),
                      10);
#line 129
    n = tmp___0;
    }
#line 130
    if (*q) {
      {
#line 130
      tmp___1 = strchr("/;:", (int )*q);
      }
#line 130
      if (tmp___1) {
#line 130
        goto _L;
      } else {
#line 131
        return (1);
      }
    } else
    _L: /* CIL Label */ 
#line 130
    if (n > 65535UL) {
#line 131
      return (1);
    }
    {
#line 132
    url->port = (int )n;
#line 133
    tmp___2 = strcspn((char const   *)q, "/");
#line 133
    *str = q + tmp___2;
    }
  } else {
#line 135
    *str = s + len;
  }
  {
#line 136
  tmp___3 = alloc_string_len(& url->host, (char const   *)s, len);
  }
#line 136
  if (tmp___3) {
#line 137
    return (1);
  }
#line 138
  if (*(*str)) {
    {
#line 139
    (*str) ++;
#line 140
    tmp___4 = url_get_path(url, str);
    }
#line 140
    return (tmp___4);
  }
#line 142
  return (0);
}
}
#line 146 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_get_user(dico_url_t url , char **str ) 
{ 
  size_t len ;
  size_t tmp ;
  char *p ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 149
  tmp = strcspn((char const   *)*str, ":;@/");
#line 149
  len = tmp;
#line 150
  p = *str + len;
  }
  {
#line 153
  if ((int )*p == 59) {
#line 153
    goto case_59;
  }
#line 157
  if ((int )*p == 58) {
#line 157
    goto case_58;
  }
#line 168
  if ((int )*p == 64) {
#line 168
    goto case_64;
  }
#line 152
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 154
  tmp___0 = strcmp((char const   *)url->proto, "dict");
  }
#line 154
  if (tmp___0) {
#line 155
    goto switch_break;
  }
  case_58: /* CIL Label */ 
  {
#line 158
  len = strcspn((char const   *)(p + 1), "@/:");
  }
#line 159
  if ((int )*(p + (len + 1U)) == 64) {
    {
#line 160
    tmp___1 = alloc_string_len(& url->passwd, (char const   *)(p + 1), len);
    }
#line 160
    if (tmp___1) {
#line 161
      return (1);
    }
    {
#line 162
    tmp___2 = alloc_string(& url->user, (char const   *)*str, (char const   *)p);
    }
#line 162
    if (tmp___2) {
#line 163
      return (1);
    }
#line 164
    *str = (p + len) + 2;
  }
#line 166
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 169
  tmp___3 = alloc_string(& url->user, (char const   *)*str, (char const   *)p);
  }
#line 169
  if (tmp___3) {
#line 170
    return (1);
  }
#line 171
  url->passwd = (char *)((void *)0);
#line 172
  *str = p + 1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 174
  tmp___4 = url_get_host(url, str);
  }
#line 174
  return (tmp___4);
}
}
#line 177 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_get_proto(dico_url_t url , char const   *str ) 
{ 
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 182
  if (! str) {
    {
#line 183
    tmp = __errno_location();
#line 183
    *tmp = 22;
    }
#line 184
    return (1);
  }
  {
#line 187
  p = strchr(str, ':');
  }
#line 188
  if (! p) {
    {
#line 189
    tmp___0 = __errno_location();
#line 189
    *tmp___0 = 22;
    }
#line 190
    return (1);
  }
  {
#line 193
  alloc_string(& url->proto, str, (char const   *)p);
#line 196
  p ++;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! ((int )*p == 47)) {
#line 196
      goto while_break;
    }
#line 196
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  tmp___1 = url_get_user(url, & p);
  }
#line 198
  return (tmp___1);
}
}
#line 201 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
static int url_parse_dico_request(dico_url_t url ) 
{ 
  char *p ;
  char *q ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 206
  if (! url->path) {
#line 207
    return (0);
  }
#line 208
  p = url->path;
#line 209
  if ((int )*(p + 1) != 58) {
#line 210
    return (1);
  }
  {
#line 212
  if ((int )*p == 109) {
#line 212
    goto case_109;
  }
#line 216
  if ((int )*p == 100) {
#line 216
    goto case_100;
  }
#line 220
  goto switch_default;
  case_109: /* CIL Label */ 
#line 213
  url->req.type = 1;
#line 214
  goto switch_break;
  case_100: /* CIL Label */ 
#line 217
  url->req.type = 0;
#line 218
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 221
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 224
  p += 2;
#line 225
  q = strchr((char const   *)p, ':');
#line 226
  tmp = alloc_string(& url->req.word, (char const   *)p, (char const   *)q);
  }
#line 226
  if (tmp) {
#line 227
    return (1);
  }
#line 228
  if (! q) {
    {
#line 229
    tmp___0 = alloc_string_len(& url->req.database, "!", (size_t )1);
    }
#line 229
    if (tmp___0) {
#line 229
      tmp___2 = 1;
    } else {
      {
#line 229
      tmp___1 = alloc_string_len(& url->req.strategy, ".", (size_t )1);
      }
#line 229
      if (tmp___1) {
#line 229
        tmp___2 = 1;
      } else {
#line 229
        tmp___2 = 0;
      }
    }
#line 229
    return (tmp___2);
  }
  {
#line 232
  p = q + 1;
#line 233
  q = strchr((char const   *)p, ':');
#line 234
  tmp___3 = alloc_string_def(& url->req.database, (char const   *)p, (char const   *)q,
                             "*");
  }
#line 234
  if (tmp___3) {
#line 235
    return (1);
  }
#line 237
  if (url->req.type == 1) {
#line 238
    if (! q) {
      {
#line 239
      tmp___4 = alloc_string_len(& url->req.strategy, ".", (size_t )1);
      }
#line 239
      return (tmp___4);
    }
    {
#line 241
    p = q + 1;
#line 242
    q = strchr((char const   *)p, ':');
#line 243
    tmp___5 = alloc_string_def(& url->req.strategy, (char const   *)p, (char const   *)q,
                               ".");
    }
#line 243
    if (tmp___5) {
#line 244
      return (1);
    }
  }
#line 247
  if (q) {
    {
#line 248
    p = q + 1;
#line 249
    url->req.n = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& q),
                         10);
    }
#line 250
    if (*q) {
#line 251
      return (1);
    }
  }
#line 254
  return (0);
}
}
#line 257 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
void dico_url_destroy(dico_url_t *purl ) 
{ 
  dico_url_t url ;

  {
  {
#line 260
  url = *purl;
#line 262
  free((void *)url->string);
#line 263
  free((void *)url->proto);
#line 264
  free((void *)url->host);
#line 265
  free((void *)url->path);
#line 266
  free((void *)url->user);
#line 267
  free((void *)url->passwd);
#line 268
  dico_assoc_destroy(& url->args);
#line 269
  free((void *)url->req.word);
#line 270
  free((void *)url->req.database);
#line 271
  free((void *)url->req.strategy);
#line 272
  free((void *)url);
#line 273
  *purl = (dico_url_t )((void *)0);
  }
#line 274
  return;
}
}
#line 276 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
int dico_url_parse(dico_url_t *purl , char const   *str ) 
{ 
  int rc ;
  dico_url_t url ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 282
  tmp = malloc((size_t )sizeof(*url));
#line 282
  url = (dico_url_t )tmp;
  }
#line 283
  if (! url) {
#line 284
    return (1);
  }
  {
#line 285
  memset((void *)url, 0, (size_t )sizeof(*url));
#line 286
  rc = url_get_proto(url, str);
  }
#line 287
  if (rc) {
    {
#line 288
    dico_url_destroy(& url);
    }
  } else {
    {
#line 290
    url->string = strdup(str);
#line 292
    tmp___0 = memcmp((void const   *)url->proto, (void const   *)"dict", (size_t )4);
    }
#line 292
    if (tmp___0 == 0) {
      {
#line 292
      tmp___1 = url_parse_dico_request(url);
      }
#line 292
      if (tmp___1) {
        {
#line 294
        dico_url_destroy(& url);
        }
#line 295
        return (1);
      }
    }
#line 298
    *purl = url;
  }
#line 300
  return (rc);
}
}
#line 303 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
char *dico_url_full_path(dico_url_t url ) 
{ 
  char *path ;
  size_t size ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 307
  size = (size_t )1;
#line 309
  if (url->host) {
    {
#line 310
    tmp = strlen((char const   *)url->host);
#line 310
    size += tmp;
    }
  }
#line 311
  if (url->path) {
    {
#line 312
    tmp___0 = strlen((char const   *)url->path);
#line 312
    size += tmp___0 + 1U;
    }
  }
  {
#line 313
  tmp___1 = malloc(size + 1U);
#line 313
  path = (char *)tmp___1;
  }
#line 314
  if (path) {
#line 315
    if (url->host) {
      {
#line 316
      strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)"/");
#line 317
      strcat((char */* __restrict  */)path, (char const   */* __restrict  */)url->host);
      }
    }
#line 319
    if (url->path) {
#line 320
      if (*(path + 0)) {
        {
#line 321
        strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/");
        }
      }
      {
#line 322
      strcat((char */* __restrict  */)path, (char const   */* __restrict  */)url->path);
      }
    }
  }
#line 325
  return (path);
}
}
#line 328 "/home/wslee/benchmarks/textformat/dico-2.0/lib/url.c"
char const   *dico_url_get_arg(dico_url_t url , char const   *argname ) 
{ 
  char const   *tmp ;

  {
  {
#line 331
  tmp = dico_assoc_find(url->args, argname);
  }
#line 331
  return (tmp);
}
}
#line 28 "../include/dico/xlat.h"
int xlat_string(struct xlat_tab *tab___0 , char const   *string , size_t len , int flags ,
                int *result ) ;
#line 30
int xlat_c_string(struct xlat_tab *tab___0 , char const   *string , int flags , int *result ) ;
#line 113 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xlat.c"
int xlat_string(struct xlat_tab *tab___0 , char const   *string , size_t len , int flags ,
                int *result ) 
{ 
  int (*cmp)(char const   * , char const   * , size_t  ) ;
  int ( __attribute__((__nonnull__(1,2))) (*tmp))(char const   *__s1 , char const   *__s2 ,
                                                  size_t __n ) ;
  int tmp___0 ;

  {
#line 29
  if (flags & 1) {
#line 29
    tmp = & strncasecmp;
  } else {
#line 29
    tmp = & strncmp;
  }
#line 29
  cmp = (int (*)(char const   * , char const   * , size_t  ))tmp;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! tab___0->string) {
#line 31
      goto while_break;
    }
    {
#line 32
    tmp___0 = (*cmp)((char const   *)tab___0->string, string, len);
    }
#line 32
    if (tmp___0 == 0) {
#line 33
      *result = tab___0->num;
#line 34
      return (0);
    }
#line 31
    tab___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return (1);
}
}
#line 40 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xlat.c"
int xlat_c_string(struct xlat_tab *tab___0 , char const   *string , int flags , int *result ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 44
  tmp = strlen(string);
#line 44
  tmp___0 = xlat_string(tab___0, string, tmp, flags, result);
  }
#line 44
  return (tmp___0);
}
}
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 37 "../include/dico/stream.h"
int dico_stream_create(dico_stream_t *pstream , int flags , void *data ) ;
#line 38
int dico_stream_open(dico_stream_t stream ) ;
#line 39
void dico_stream_set_open(dico_stream_t stream , int (*openfn)(void * , int  ) ) ;
#line 40
void dico_stream_set_seek(dico_stream_t stream , int (*fun_seek)(void * , off_t  ,
                                                                 int  , off_t * ) ) ;
#line 42
void dico_stream_set_size(dico_stream_t stream , int (*sizefn)(void * , off_t * ) ) ;
#line 44
void dico_stream_set_read(dico_stream_t stream , int (*readfn)(void * , char * , size_t  ,
                                                               size_t * ) ) ;
#line 46
void dico_stream_set_write(dico_stream_t stream , int (*writefn)(void * , char const   * ,
                                                                 size_t  , size_t * ) ) ;
#line 49
void dico_stream_set_flush(dico_stream_t stream , int (*flushfn)(void * ) ) ;
#line 50
void dico_stream_set_close(dico_stream_t stream , int (*closefn)(void * ) ) ;
#line 51
void dico_stream_set_destroy(dico_stream_t stream , int (*destroyfn)(void * ) ) ;
#line 53
void dico_stream_set_error_string(dico_stream_t stream , char const   *(*error_string)(void * ,
                                                                                       int  ) ) ;
#line 56
int dico_stream_set_buffer(dico_stream_t stream , enum dico_buffer_type type , size_t size ) ;
#line 60
off_t dico_stream_seek(dico_stream_t stream , off_t offset , int whence ) ;
#line 61
int dico_stream_size(dico_stream_t stream , off_t *psize ) ;
#line 64
int dico_stream_read_unbuffered(dico_stream_t stream , void *buf___1 , size_t size ,
                                size_t *pread ) ;
#line 66
int dico_stream_write_unbuffered(dico_stream_t stream , void const   *buf___1 , size_t size ,
                                 size_t *pwrite ) ;
#line 70
int dico_stream_read(dico_stream_t stream , void *buf___1 , size_t size , size_t *pread ) ;
#line 72
int dico_stream_readln(dico_stream_t stream , char *buf___1 , size_t size , size_t *pread ) ;
#line 74
int dico_stream_getdelim(dico_stream_t stream , char **pbuf , size_t *psize , int delim ,
                         size_t *pread ) ;
#line 76
int dico_stream_getline(dico_stream_t stream , char **pbuf , size_t *psize , size_t *pread ) ;
#line 78
int dico_stream_write(dico_stream_t stream , void const   *buf___1 , size_t size ) ;
#line 79
int dico_stream_writeln(dico_stream_t stream , char const   *buf___1 , size_t size ) ;
#line 81
char const   *dico_stream_strerror(dico_stream_t stream , int rc ) ;
#line 82
int dico_stream_last_error(dico_stream_t stream ) ;
#line 83
void dico_stream_clearerr(dico_stream_t stream ) ;
#line 84
int dico_stream_eof(dico_stream_t stream ) ;
#line 86
int dico_stream_flush(dico_stream_t stream ) ;
#line 87
int dico_stream_close(dico_stream_t stream ) ;
#line 88
void dico_stream_destroy(dico_stream_t *stream ) ;
#line 90
off_t dico_stream_bytes_in(dico_stream_t stream ) ;
#line 91
off_t dico_stream_bytes_out(dico_stream_t stream ) ;
#line 93
void dico_stream_set_ioctl(dico_stream_t stream , int (*ctl)(void * , int  , void * ) ) ;
#line 95
int dico_stream_ioctl(dico_stream_t stream , int code___0 , void *ptr ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 94
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
static int _stream_seterror(dico_stream_t stream , int code___0 , int perm ) 
{ 


  {
#line 57
  stream->last_err = code___0;
#line 58
  if (perm) {
#line 59
    stream->flags |= 8192;
  }
#line 60
  return (code___0);
}
}
#line 63 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_create(dico_stream_t *pstream , int flags , void *data ) 
{ 
  dico_stream_t stream ;
  void *tmp ;

  {
  {
#line 66
  tmp = malloc((size_t )sizeof(*stream));
#line 66
  stream = (dico_stream_t )tmp;
  }
#line 67
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 68
    return (12);
  }
  {
#line 69
  memset((void *)stream, 0, (size_t )sizeof(*stream));
#line 70
  stream->flags = flags;
#line 71
  stream->data = data;
#line 72
  *pstream = stream;
  }
#line 73
  return (0);
}
}
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_open(dico_stream_t stream ) 
{ 
  int rc ;
  int tmp ;
  off_t tmp___0 ;

  {
#line 80
  if (stream->open) {
    {
#line 80
    rc = (*(stream->open))(stream->data, stream->flags);
    }
#line 80
    if (rc) {
      {
#line 81
      tmp = _stream_seterror(stream, rc, 1);
      }
#line 81
      return (tmp);
    }
  }
#line 82
  tmp___0 = (off_t )0;
#line 82
  stream->bytes_out = tmp___0;
#line 82
  stream->bytes_in = tmp___0;
#line 83
  return (0);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_error_string(dico_stream_t stream , char const   *(*error_string)(void * ,
                                                                                       int  ) ) 
{ 


  {
#line 90
  stream->error_string = error_string;
#line 91
  return;
}
}
#line 93 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_open(dico_stream_t stream , int (*openfn)(void * , int  ) ) 
{ 


  {
#line 96
  stream->open = openfn;
#line 97
  return;
}
}
#line 99 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_seek(dico_stream_t stream , int (*fun_seek)(void * , off_t  ,
                                                                 int  , off_t * ) ) 
{ 


  {
#line 103
  stream->seek = fun_seek;
#line 104
  return;
}
}
#line 106 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_read(dico_stream_t stream , int (*readfn)(void * , char * , size_t  ,
                                                               size_t * ) ) 
{ 


  {
#line 110
  stream->read = readfn;
#line 111
  return;
}
}
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_write(dico_stream_t stream , int (*writefn)(void * , char const   * ,
                                                                 size_t  , size_t * ) ) 
{ 


  {
#line 117
  stream->write = writefn;
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_flush(dico_stream_t stream , int (*flushfn)(void * ) ) 
{ 


  {
#line 123
  stream->flush = flushfn;
#line 124
  return;
}
}
#line 126 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_close(dico_stream_t stream , int (*closefn)(void * ) ) 
{ 


  {
#line 129
  stream->close = closefn;
#line 130
  return;
}
}
#line 132 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_destroy(dico_stream_t stream , int (*destroyfn)(void * ) ) 
{ 


  {
#line 135
  stream->destroy = destroyfn;
#line 136
  return;
}
}
#line 138 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_size(dico_stream_t stream , int (*sizefn)(void * , off_t * ) ) 
{ 


  {
#line 141
  stream->size = sizefn;
#line 142
  return;
}
}
#line 144 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_set_ioctl(dico_stream_t stream , int (*ctl)(void * , int  , void * ) ) 
{ 


  {
#line 147
  stream->ctl = ctl;
#line 148
  return;
}
}
#line 151 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
char const   *dico_stream_strerror(dico_stream_t stream , int rc ) 
{ 
  char const   *str ;
  char *tmp ;

  {
#line 155
  if (stream->error_string) {
    {
#line 156
    str = (*(stream->error_string))(stream->data, rc);
    }
  } else {
    {
#line 158
    tmp = strerror(rc);
#line 158
    str = (char const   *)tmp;
    }
  }
#line 159
  return (str);
}
}
#line 162 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_last_error(dico_stream_t stream ) 
{ 


  {
#line 165
  return (stream->last_err);
}
}
#line 168 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_clearerr(dico_stream_t stream ) 
{ 


  {
#line 171
  stream->last_err = 0;
#line 172
  return;
}
}
#line 174 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_eof(dico_stream_t stream ) 
{ 


  {
#line 177
  return (stream->flags & 16384);
}
}
#line 185 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
off_t dico_stream_seek(dico_stream_t stream , off_t offset , int whence ) 
{ 
  int rc ;
  off_t res ;
  size_t bpos ;
  int tmp ;

  {
#line 192
  if (! stream->seek) {
    {
#line 193
    _stream_seterror(stream, 38, 0);
    }
#line 194
    return ((off_t )-1);
  }
#line 196
  if (! (stream->flags & 4)) {
    {
#line 197
    _stream_seterror(stream, 13, 1);
    }
#line 198
    return ((off_t )-1);
  }
  {
#line 202
  if (whence == 0) {
#line 202
    goto case_0;
  }
#line 205
  if (whence == 1) {
#line 205
    goto case_1;
  }
#line 208
  if (whence == 2) {
#line 208
    goto case_2;
  }
#line 222
  goto switch_default;
  case_0: /* CIL Label */ 
#line 203
  goto switch_break;
  case_1: /* CIL Label */ 
#line 206
  goto switch_break;
  case_2: /* CIL Label */ 
#line 209
  bpos = (size_t )(stream->cur - stream->buffer);
#line 210
  if ((off_t )bpos + offset >= 0L) {
#line 210
    if ((off_t )bpos + offset < (long )stream->level + (stream->cur - stream->buffer)) {
      {
#line 211
      rc = (*(stream->seek))(stream->data, offset, whence, & res);
      }
#line 211
      if (rc) {
        {
#line 212
        _stream_seterror(stream, rc, 1);
        }
#line 213
        return ((off_t )-1);
      }
#line 215
      offset -= (off_t )bpos;
#line 216
      stream->cur += offset;
#line 216
      stream->level = (size_t )((off_t )stream->level - offset);
#line 217
      stream->flags &= -16385;
#line 218
      return (res - (off_t )stream->level);
    }
  }
#line 220
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 223
  _stream_seterror(stream, 22, 1);
  }
#line 224
  return ((off_t )-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 227
  tmp = dico_stream_flush(stream);
  }
#line 227
  if (tmp) {
#line 228
    return ((off_t )-1);
  }
  {
#line 229
  rc = (*(stream->seek))(stream->data, offset, whence, & res);
  }
#line 230
  if (rc) {
    {
#line 231
    _stream_seterror(stream, rc, 1);
    }
#line 232
    return ((off_t )-1);
  }
#line 234
  stream->flags &= -16385;
#line 235
  return (res);
}
}
#line 238 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_set_buffer(dico_stream_t stream , enum dico_buffer_type type , size_t size ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 242
  if (size == 0U) {
#line 243
    type = (enum dico_buffer_type )0;
  }
#line 245
  if (stream->buffer) {
    {
#line 246
    dico_stream_flush(stream);
#line 247
    free((void *)stream->buffer);
    }
  }
#line 250
  stream->buftype = type;
#line 251
  if ((unsigned int )type == 0U) {
#line 252
    stream->buffer = (char *)((void *)0);
#line 253
    return (0);
  }
  {
#line 256
  tmp = malloc(size);
#line 256
  stream->buffer = (char *)tmp;
  }
#line 257
  if ((unsigned long )stream->buffer == (unsigned long )((void *)0)) {
    {
#line 258
    stream->buftype = (enum dico_buffer_type )0;
#line 259
    tmp___0 = _stream_seterror(stream, 12, 1);
    }
#line 259
    return (tmp___0);
  }
#line 261
  stream->bufsize = size;
#line 262
  stream->cur = stream->buffer;
#line 263
  stream->level = (size_t )0;
#line 265
  return (0);
}
}
#line 268 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_read_unbuffered(dico_stream_t stream , void *buf___1 , size_t size ,
                                size_t *pread ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  size_t rdbytes ;

  {
#line 274
  if (! stream->read) {
    {
#line 275
    tmp = _stream_seterror(stream, 38, 0);
    }
#line 275
    return (tmp);
  }
#line 277
  if (! (stream->flags & 1)) {
    {
#line 278
    tmp___0 = _stream_seterror(stream, 13, 1);
    }
#line 278
    return (tmp___0);
  }
#line 280
  if (stream->flags & 8192) {
#line 281
    return (stream->last_err);
  }
#line 283
  if (stream->flags & 16384) {
#line 283
    goto _L;
  } else
#line 283
  if (size == 0U) {
    _L: /* CIL Label */ 
#line 284
    if (pread) {
#line 285
      *pread = (size_t )0;
#line 286
      return (0);
    } else {
      {
#line 288
      _stream_seterror(stream, 5, 0);
      }
#line 289
      return (5);
    }
  }
#line 293
  if ((unsigned long )pread == (unsigned long )((void *)0)) {
    {
#line 296
    while (1) {
      while_continue: /* CIL Label */ ;
#line 296
      if (size > 0U) {
        {
#line 296
        rc = (*(stream->read))(stream->data, (char *)buf___1, size, & rdbytes);
        }
#line 296
        if (! (rc == 0)) {
#line 296
          goto while_break;
        }
      } else {
#line 296
        goto while_break;
      }
#line 298
      if (rdbytes == 0U) {
#line 299
        stream->flags |= 16384;
#line 300
        goto while_break;
      }
#line 302
      buf___1 += rdbytes;
#line 303
      size -= rdbytes;
#line 304
      stream->bytes_in += (off_t )rdbytes;
    }
    while_break: /* CIL Label */ ;
    }
#line 306
    if (size) {
      {
#line 307
      _stream_seterror(stream, 5, 0);
      }
#line 308
      return (5);
    }
  } else {
    {
#line 311
    rc = (*(stream->read))(stream->data, (char *)buf___1, size, pread);
    }
#line 312
    if (rc == 0) {
#line 313
      if (*pread == 0U) {
#line 314
        stream->flags |= 16384;
      }
#line 315
      stream->bytes_in += (off_t )*pread;
    }
  }
  {
#line 318
  _stream_seterror(stream, rc, rc != 0);
  }
#line 319
  return (rc);
}
}
#line 322 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_write_unbuffered(dico_stream_t stream , void const   *buf___1 , size_t size ,
                                 size_t *pwrite ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  size_t wrbytes ;
  char const   *bufp ;

  {
#line 329
  if (! stream->write) {
    {
#line 330
    tmp = _stream_seterror(stream, 38, 0);
    }
#line 330
    return (tmp);
  }
#line 332
  if (! (stream->flags & 2)) {
    {
#line 333
    tmp___0 = _stream_seterror(stream, 13, 1);
    }
#line 333
    return (tmp___0);
  }
#line 335
  if (stream->flags & 8192) {
#line 336
    return (stream->last_err);
  }
#line 338
  if (size == 0U) {
#line 339
    if (pwrite) {
#line 340
      *pwrite = (size_t )0;
    }
#line 341
    return (0);
  }
#line 344
  if ((unsigned long )pwrite == (unsigned long )((void *)0)) {
#line 346
    bufp = (char const   *)buf___1;
    {
#line 348
    while (1) {
      while_continue: /* CIL Label */ ;
#line 348
      if (size > 0U) {
        {
#line 348
        rc = (*(stream->write))(stream->data, bufp, size, & wrbytes);
        }
#line 348
        if (! (rc == 0)) {
#line 348
          goto while_break;
        }
      } else {
#line 348
        goto while_break;
      }
#line 351
      if (wrbytes == 0U) {
#line 352
        rc = 5;
#line 353
        goto while_break;
      }
#line 355
      bufp += wrbytes;
#line 356
      size -= wrbytes;
#line 357
      stream->bytes_out += (off_t )wrbytes;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 360
    rc = (*(stream->write))(stream->data, (char const   *)buf___1, size, pwrite);
    }
#line 361
    if (rc == 0) {
#line 362
      stream->bytes_out += (off_t )*pwrite;
    }
  }
  {
#line 364
  _stream_seterror(stream, rc, rc != 0);
  }
#line 365
  return (rc);
}
}
#line 368 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
static int _stream_fill_buffer(dico_stream_t stream ) 
{ 
  size_t n ;
  int rc ;
  char c ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 372
  rc = 0;
  {
#line 376
  if ((unsigned int )stream->buftype == 0U) {
#line 376
    goto case_0;
  }
#line 379
  if ((unsigned int )stream->buftype == 2U) {
#line 379
    goto case_2;
  }
#line 386
  if ((unsigned int )stream->buftype == 1U) {
#line 386
    goto case_1;
  }
#line 375
  goto switch_break;
  case_0: /* CIL Label */ 
#line 377
  return (0);
  case_2: /* CIL Label */ 
  {
#line 380
  tmp = dico_stream_read_unbuffered(stream, (void *)stream->buffer, stream->bufsize,
                                    & stream->level);
  }
#line 380
  if (tmp) {
#line 383
    return (1);
  }
#line 384
  goto switch_break;
  case_1: /* CIL Label */ 
#line 387
  n = (size_t )0;
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (n < stream->bufsize) {
      {
#line 387
      rc = dico_stream_read_unbuffered(stream, (void *)(& c), (size_t )1, (size_t *)((void *)0));
      }
#line 387
      if (! (rc == 0)) {
#line 387
        goto while_break;
      }
    } else {
#line 387
      goto while_break;
    }
#line 391
    tmp___0 = n;
#line 391
    n ++;
#line 391
    *(stream->buffer + tmp___0) = c;
#line 392
    if ((int )c == 10) {
#line 393
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  stream->level = n;
#line 396
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 398
  stream->cur = stream->buffer;
#line 399
  return (rc);
}
}
#line 405 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
static int _stream_buffer_full_p(dico_stream_t stream ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 409
  if ((unsigned int )stream->buftype == 0U) {
#line 409
    goto case_0;
  }
#line 412
  if ((unsigned int )stream->buftype == 1U) {
#line 412
    goto case_1;
  }
#line 416
  if ((unsigned int )stream->buftype == 2U) {
#line 416
    goto case_2;
  }
#line 408
  goto switch_break;
  case_0: /* CIL Label */ 
#line 410
  goto switch_break;
  case_1: /* CIL Label */ 
#line 413
  if ((unsigned long )(stream->cur + stream->level) == (unsigned long )(stream->buffer + stream->bufsize)) {
#line 413
    tmp___0 = 1;
  } else {
    {
#line 413
    tmp = memchr((void const   *)stream->cur, '\n', stream->level);
    }
#line 413
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 413
      tmp___0 = 1;
    } else {
#line 413
      tmp___0 = 0;
    }
  }
#line 413
  return (tmp___0);
  case_2: /* CIL Label */ 
#line 417
  return ((unsigned long )(stream->cur + stream->level) == (unsigned long )(stream->buffer + stream->bufsize));
  switch_break: /* CIL Label */ ;
  }
#line 419
  return (0);
}
}
#line 422 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
static int _stream_flush_buffer(dico_stream_t stream , int all ) 
{ 
  char *end ;
  off_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  int rc ;
  int tmp___3 ;
  int rc___0 ;
  int tmp___4 ;

  {
#line 427
  if (stream->flags & 4096) {
#line 428
    if (stream->flags & 4) {
      {
#line 428
      tmp = dico_stream_seek(stream, - ((long )stream->level + (stream->cur - stream->buffer)),
                             1);
      }
#line 428
      if (tmp < 0L) {
#line 432
        return (1);
      }
    }
    {
#line 435
    if ((unsigned int )stream->buftype == 0U) {
#line 435
      goto case_0;
    }
#line 438
    if ((unsigned int )stream->buftype == 2U) {
#line 438
      goto case_2;
    }
#line 444
    if ((unsigned int )stream->buftype == 1U) {
#line 444
      goto case_1;
    }
#line 434
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 436
    abort();
    }
    case_2: /* CIL Label */ 
    {
#line 439
    tmp___0 = dico_stream_write_unbuffered(stream, (void const   *)stream->cur, stream->level,
                                           (size_t *)((void *)0));
    }
#line 439
    if (tmp___0) {
#line 441
      return (1);
    }
#line 442
    goto switch_break;
    case_1: /* CIL Label */ 
#line 445
    if (stream->level == 0U) {
#line 446
      goto switch_break;
    }
    {
#line 447
    tmp___1 = memchr((void const   *)stream->cur, '\n', stream->level);
#line 447
    end = (char *)tmp___1;
    }
    {
#line 447
    while (1) {
      while_continue: /* CIL Label */ ;
#line 447
      if (! end) {
#line 447
        goto while_break;
      }
      {
#line 450
      size = (size_t )((end - stream->cur) + 1L);
#line 451
      tmp___3 = dico_stream_write_unbuffered(stream, (void const   *)stream->cur,
                                             size, (size_t *)((void *)0));
#line 451
      rc = tmp___3;
      }
#line 453
      if (rc) {
#line 454
        return (rc);
      }
      {
#line 455
      stream->cur += size;
#line 455
      stream->level -= size;
#line 447
      tmp___2 = memchr((void const   *)stream->cur, '\n', stream->level);
#line 447
      end = (char *)tmp___2;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 457
    if (all) {
#line 457
      if (stream->level) {
#line 457
        goto _L;
      } else {
#line 457
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 457
    if ((unsigned long )(stream->cur + stream->level) == (unsigned long )(stream->buffer + stream->bufsize)) {
      _L: /* CIL Label */ 
      {
#line 458
      tmp___4 = dico_stream_write_unbuffered(stream, (void const   *)stream->cur,
                                             stream->level, (size_t *)((void *)0));
#line 458
      rc___0 = tmp___4;
      }
#line 460
      if (rc___0) {
#line 461
        return (rc___0);
      }
#line 462
      stream->cur += stream->level;
#line 462
      stream->level -= stream->level;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 466
  if (stream->level) {
#line 467
    if ((unsigned long )stream->cur > (unsigned long )stream->buffer) {
      {
#line 468
      memmove((void *)stream->buffer, (void const   *)stream->cur, stream->level);
      }
    }
  } else {
#line 470
    stream->flags &= -4097;
#line 471
    stream->level = (size_t )0;
  }
#line 473
  stream->cur = stream->buffer;
#line 474
  return (0);
}
}
#line 477 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_read(dico_stream_t stream , void *buf___1 , size_t size , size_t *pread ) 
{ 
  int tmp ;
  char *bufp ;
  size_t nbytes ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 480
  if ((unsigned int )stream->buftype == 0U) {
    {
#line 481
    tmp = dico_stream_read_unbuffered(stream, buf___1, size, pread);
    }
#line 481
    return (tmp);
  } else {
#line 483
    bufp = (char *)buf___1;
#line 484
    nbytes = (size_t )0;
    {
#line 485
    while (1) {
      while_continue: /* CIL Label */ ;
#line 485
      if (! size) {
#line 485
        goto while_break;
      }
#line 488
      if (stream->level == 0U) {
        {
#line 488
        tmp___0 = _stream_fill_buffer(stream);
        }
#line 488
        if (tmp___0) {
#line 489
          if (nbytes) {
#line 490
            goto while_break;
          }
#line 491
          return (1);
        }
      }
#line 494
      n = size;
#line 495
      if (n > stream->level) {
#line 496
        n = stream->level;
      }
      {
#line 497
      memcpy((void */* __restrict  */)bufp, (void const   */* __restrict  */)stream->cur,
             n);
#line 498
      stream->cur += n;
#line 498
      stream->level -= n;
#line 499
      nbytes += n;
#line 500
      bufp += n;
#line 501
      size -= n;
      }
#line 502
      if ((unsigned int )stream->buftype == 1U) {
#line 502
        if ((int )*(bufp + -1) == 10) {
#line 503
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 506
    if (pread) {
#line 507
      *pread = nbytes;
    } else
#line 508
    if (size) {
      {
#line 509
      tmp___1 = _stream_seterror(stream, 5, 1);
      }
#line 509
      return (tmp___1);
    }
  }
#line 511
  return (0);
}
}
#line 514 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_readln(dico_stream_t stream , char *buf___1 , size_t size , size_t *pread ) 
{ 
  int rc ;
  char c ;
  size_t n ;
  char *tmp ;

  {
#line 519
  n = (size_t )0;
#line 521
  if (size == 0U) {
#line 522
    return (5);
  }
#line 524
  size --;
#line 525
  n = (size_t )0;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (n < size) {
      {
#line 525
      rc = dico_stream_read(stream, (void *)(& c), (size_t )1, (size_t *)((void *)0));
      }
#line 525
      if (! (rc == 0)) {
#line 525
        goto while_break;
      }
    } else {
#line 525
      goto while_break;
    }
#line 527
    tmp = buf___1;
#line 527
    buf___1 ++;
#line 527
    *tmp = c;
#line 528
    if ((int )c == 10) {
#line 529
      goto while_break;
    }
#line 525
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  *buf___1 = (char)0;
#line 532
  if (pread) {
#line 533
    *pread = n;
  }
#line 534
  return (rc);
}
}
#line 537 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_getdelim(dico_stream_t stream , char **pbuf , size_t *psize , int delim ,
                         size_t *pread ) 
{ 
  int rc ;
  char *lineptr ;
  size_t n ;
  size_t cur_len ;
  char *new_lineptr ;
  void *tmp ;
  char c ;
  size_t needed_max ;
  size_t needed ;
  char *new_lineptr___0 ;
  void *tmp___0 ;

  {
#line 542
  lineptr = *pbuf;
#line 543
  n = *psize;
#line 544
  cur_len = (size_t )0;
#line 546
  if ((unsigned long )lineptr == (unsigned long )((void *)0)) {
#line 546
    goto _L;
  } else
#line 546
  if (n == 0U) {
    _L: /* CIL Label */ 
    {
#line 548
    n = (size_t )120;
#line 549
    tmp = realloc((void *)lineptr, n);
#line 549
    new_lineptr = (char *)tmp;
    }
#line 550
    if ((unsigned long )new_lineptr == (unsigned long )((void *)0)) {
#line 551
      return (12);
    }
#line 552
    lineptr = new_lineptr;
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 558
    rc = dico_stream_read(stream, (void *)(& c), (size_t )1, (size_t *)((void *)0));
    }
#line 559
    if (rc) {
#line 560
      goto while_break;
    }
#line 563
    if (cur_len + 1U >= n) {
#line 564
      needed_max = 2147483648U;
#line 566
      needed = 2U * n + 1U;
#line 569
      if (needed_max < needed) {
#line 570
        needed = needed_max;
      }
#line 571
      if (cur_len + 1U >= needed) {
#line 572
        rc = 75;
#line 573
        goto while_break;
      }
      {
#line 576
      tmp___0 = realloc((void *)lineptr, needed);
#line 576
      new_lineptr___0 = (char *)tmp___0;
      }
#line 577
      if ((unsigned long )new_lineptr___0 == (unsigned long )((void *)0)) {
#line 578
        rc = 12;
#line 579
        goto while_break;
      }
#line 582
      lineptr = new_lineptr___0;
#line 583
      n = needed;
    }
#line 586
    *(lineptr + cur_len) = c;
#line 587
    cur_len ++;
#line 589
    if ((int )c == delim) {
#line 590
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  *(lineptr + cur_len) = (char )'\000';
#line 594
  *pbuf = lineptr;
#line 595
  *psize = n;
#line 597
  if (pread) {
#line 598
    *pread = cur_len;
  }
#line 599
  return (rc);
}
}
#line 602 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_getline(dico_stream_t stream , char **pbuf , size_t *psize , size_t *pread ) 
{ 
  int tmp ;

  {
  {
#line 606
  tmp = dico_stream_getdelim(stream, pbuf, psize, '\n', pread);
  }
#line 606
  return (tmp);
}
}
#line 609 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_write(dico_stream_t stream , void const   *buf___1 , size_t size ) 
{ 
  int tmp ;
  size_t nbytes ;
  char const   *bufp ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 612
  if ((unsigned int )stream->buftype == 0U) {
    {
#line 613
    tmp = dico_stream_write_unbuffered(stream, buf___1, size, (size_t *)((void *)0));
    }
#line 613
    return (tmp);
  } else {
#line 615
    nbytes = (size_t )0;
#line 616
    bufp = (char const   *)buf___1;
    {
#line 618
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 621
      tmp___0 = _stream_buffer_full_p(stream);
      }
#line 621
      if (tmp___0) {
        {
#line 621
        tmp___1 = _stream_flush_buffer(stream, 0);
        }
#line 621
        if (tmp___1) {
#line 623
          return (1);
        }
      }
#line 625
      if (size == 0U) {
#line 626
        goto while_break;
      }
#line 628
      n = stream->bufsize - stream->level;
#line 629
      if (n > size) {
#line 630
        n = size;
      }
      {
#line 631
      memcpy((void */* __restrict  */)(stream->cur + stream->level), (void const   */* __restrict  */)bufp,
             n);
#line 632
      stream->level += n;
#line 633
      nbytes += n;
#line 634
      bufp += n;
#line 635
      size -= n;
#line 636
      stream->flags |= 4096;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 639
  return (0);
}
}
#line 642 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_writeln(dico_stream_t stream , char const   *buf___1 , size_t size ) 
{ 
  int rc ;
  char *__cil_tmp5 ;

  {
  {
#line 646
  rc = dico_stream_write(stream, (void const   *)buf___1, size);
  }
#line 646
  if (rc == 0) {
    {
#line 647
    rc = dico_stream_write(stream, (void const   *)"\r\n", (size_t )2);
    }
  }
#line 648
  return (rc);
}
}
#line 651 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_flush(dico_stream_t stream ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 654
  if (! stream) {
    {
#line 655
    tmp = __errno_location();
#line 655
    *tmp = 22;
    }
#line 656
    return (1);
  }
  {
#line 658
  tmp___0 = _stream_flush_buffer(stream, 1);
  }
#line 658
  if (tmp___0) {
#line 659
    return (1);
  }
#line 660
  if (stream->flush) {
    {
#line 661
    tmp___1 = (*(stream->flush))(stream->data);
    }
#line 661
    return (tmp___1);
  }
#line 662
  return (0);
}
}
#line 665 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_close(dico_stream_t stream ) 
{ 
  int rc ;

  {
#line 668
  rc = 0;
#line 669
  if (! stream) {
#line 670
    return (22);
  }
  {
#line 671
  dico_stream_flush(stream);
  }
#line 672
  if (stream->close) {
    {
#line 673
    rc = (*(stream->close))(stream->data);
    }
  }
#line 674
  return (rc);
}
}
#line 677 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_size(dico_stream_t stream , off_t *psize ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
#line 681
  if (! stream->size) {
    {
#line 682
    tmp = _stream_seterror(stream, 38, 0);
    }
#line 682
    return (tmp);
  }
  {
#line 683
  rc = (*(stream->size))(stream->data, psize);
#line 684
  tmp___0 = _stream_seterror(stream, rc, rc != 0);
  }
#line 684
  return (tmp___0);
}
}
#line 687 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
void dico_stream_destroy(dico_stream_t *stream ) 
{ 


  {
#line 690
  if (! stream) {
#line 691
    return;
  } else
#line 690
  if (! *stream) {
#line 691
    return;
  }
#line 692
  if ((*stream)->destroy) {
    {
#line 693
    (*((*stream)->destroy))((*stream)->data);
    }
  }
  {
#line 694
  free((void *)*stream);
#line 695
  *stream = (dico_stream_t )((void *)0);
  }
#line 696
  return;
}
}
#line 698 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
off_t dico_stream_bytes_in(dico_stream_t stream ) 
{ 


  {
#line 701
  return (stream->bytes_in);
}
}
#line 704 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
off_t dico_stream_bytes_out(dico_stream_t stream ) 
{ 


  {
#line 707
  return (stream->bytes_out);
}
}
#line 710 "/home/wslee/benchmarks/textformat/dico-2.0/lib/stream.c"
int dico_stream_ioctl(dico_stream_t stream , int code___0 , void *ptr ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 713
  if ((unsigned long )stream->ctl == (unsigned long )((void *)0)) {
    {
#line 714
    tmp = __errno_location();
#line 714
    *tmp = 38;
    }
#line 715
    return (-1);
  }
  {
#line 717
  tmp___0 = (*(stream->ctl))(stream->data, code___0, ptr);
  }
#line 717
  return (tmp___0);
}
}
#line 28 "../include/dico/list.h"
struct dico_list *dico_list_create(void) ;
#line 29
void dico_list_destroy(struct dico_list **plist ) ;
#line 31
int dico_list_set_free_item(struct dico_list *list , int (*free_item)(void *item ,
                                                                      void *data ) ,
                            void *data ) ;
#line 33
dico_list_comp_t dico_list_set_comparator(struct dico_list *list , int (*comp)(void const   * ,
                                                                               void * ) ) ;
#line 37
void dico_list_iterate(struct dico_list *list , int (*func)(void *item , void *data ) ,
                       void *data ) ;
#line 39
size_t dico_list_count(struct dico_list *list ) ;
#line 40
int dico_list_append(struct dico_list *list , void *data ) ;
#line 53
void *dico_list_locate(struct dico_list *list , void *data ) ;
#line 57
dico_iterator_t dico_list_iterator(dico_list_t list ) ;
#line 32 "../include/dico/strat.h"
int dico_strat_name_cmp(void const   *item , void *data ) ;
#line 33
int dico_strat_free(void *item , void *data ) ;
#line 35
dico_strategy_t dico_strategy_create(char const   *name , char const   *descr ) ;
#line 36
dico_strategy_t dico_strategy_dup(dico_strategy_t const   strat ) ;
#line 37
dico_strategy_t dico_strategy_find(char const   *name ) ;
#line 38
int dico_strategy_add(dico_strategy_t const   strat ) ;
#line 39
dico_iterator_t dico_strategy_iterator(void) ;
#line 40
void dico_strategy_iterate(int (*itr)(void *item , void *data ) , void *data ) ;
#line 41
size_t dico_strategy_count(void) ;
#line 43
int dico_set_default_strategy(char const   *name ) ;
#line 44
dico_strategy_t const   dico_get_default_strategy(void) ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
static dico_list_t strategy_list  ;
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
static dico_strategy_t default_strategy  ;
#line 31 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
int dico_strat_name_cmp(void const   *item , void *data ) 
{ 
  dico_strategy_t strat ;
  char const   *name ;
  int tmp ;

  {
  {
#line 34
  strat = (dico_strategy_t )item;
#line 35
  name = (char const   *)data;
#line 36
  tmp = strcmp((char const   *)strat->name, name);
  }
#line 36
  return (tmp);
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
dico_strategy_t dico_strategy_create(char const   *name , char const   *descr ) 
{ 
  dico_strategy_t np ;
  size_t size ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 43
  tmp = strlen(name);
#line 43
  tmp___0 = strlen(descr);
#line 43
  size = (size_t )(((sizeof(*np) + (unsigned long )tmp) + (unsigned long )tmp___0) + 2UL);
#line 44
  tmp___1 = malloc(size);
#line 44
  np = (dico_strategy_t )tmp___1;
  }
#line 45
  if (np) {
    {
#line 46
    memset((void *)np, 0, size);
#line 47
    np->name = (char *)(np + 1);
#line 48
    strcpy((char */* __restrict  */)np->name, (char const   */* __restrict  */)name);
#line 49
    tmp___2 = strlen((char const   *)np->name);
#line 49
    np->descr = (np->name + tmp___2) + 1;
#line 50
    strcpy((char */* __restrict  */)np->descr, (char const   */* __restrict  */)descr);
    }
  }
#line 52
  return (np);
}
}
#line 55 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
int dico_strat_free(void *item , void *data ) 
{ 
  dico_strategy_t strat ;

  {
  {
#line 58
  strat = (dico_strategy_t )item;
#line 59
  dico_list_destroy(& strat->stratcl);
#line 60
  free((void *)strat);
  }
#line 61
  return (0);
}
}
#line 64 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
dico_strategy_t dico_strategy_dup(dico_strategy_t const   strat ) 
{ 
  dico_strategy_t np ;
  dico_strategy_t tmp ;

  {
  {
#line 67
  tmp = dico_strategy_create((char const   *)strat->name, (char const   *)strat->descr);
#line 67
  np = tmp;
  }
#line 68
  if (np) {
#line 69
    np->sel = strat->sel;
#line 70
    np->closure = strat->closure;
  }
#line 72
  return (np);
}
}
#line 75 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
dico_strategy_t dico_strategy_find(char const   *name ) 
{ 
  void *tmp ;

  {
#line 78
  if ((int const   )*(name + 0) == 46) {
#line 78
    if ((int const   )*(name + 1) == 0) {
#line 79
      return (default_strategy);
    }
  }
  {
#line 80
  tmp = dico_list_locate(strategy_list, (void *)name);
  }
#line 80
  return ((dico_strategy_t )tmp);
}
}
#line 83 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
int dico_strategy_add(dico_strategy_t const   strat ) 
{ 
  dico_strategy_t new_strat ;
  dico_strategy_t tmp ;
  dico_strategy_t tmp___0 ;

  {
#line 86
  if (! strategy_list) {
    {
#line 87
    strategy_list = dico_list_create();
    }
#line 88
    if (! strategy_list) {
#line 89
      return (1);
    }
    {
#line 90
    dico_list_set_comparator(strategy_list, & dico_strat_name_cmp);
#line 91
    dico_list_set_free_item(strategy_list, & dico_strat_free, (void *)0);
    }
  }
  {
#line 93
  tmp___0 = dico_strategy_find((char const   *)strat->name);
  }
#line 93
  if (! tmp___0) {
    {
#line 94
    tmp = dico_strategy_dup(strat);
#line 94
    new_strat = tmp;
    }
#line 95
    if (! new_strat) {
#line 96
      return (1);
    }
    {
#line 97
    dico_list_append(strategy_list, (void *)new_strat);
    }
  }
#line 99
  return (0);
}
}
#line 102 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
dico_iterator_t dico_strategy_iterator(void) 
{ 
  dico_iterator_t tmp ;

  {
  {
#line 105
  tmp = dico_list_iterator(strategy_list);
  }
#line 105
  return (tmp);
}
}
#line 108 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
size_t dico_strategy_count(void) 
{ 
  size_t tmp ;

  {
  {
#line 111
  tmp = dico_list_count(strategy_list);
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
void dico_strategy_iterate(int (*itr)(void *item , void *data ) , void *data ) 
{ 


  {
  {
#line 117
  dico_list_iterate(strategy_list, itr, data);
  }
#line 117
  return;
}
}
#line 120 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
int dico_set_default_strategy(char const   *name ) 
{ 
  dico_strategy_t sp ;
  int *tmp ;

  {
#line 125
  if ((int const   )*(name + 0) == 46) {
#line 125
    if ((int const   )*(name + 1) == 0) {
      {
#line 126
      tmp = __errno_location();
#line 126
      *tmp = 22;
      }
#line 127
      return (1);
    } else {
#line 125
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 125
    sp = dico_strategy_find(name);
    }
#line 125
    if ((unsigned long )sp == (unsigned long )((void *)0)) {
      {
#line 126
      tmp = __errno_location();
#line 126
      *tmp = 22;
      }
#line 127
      return (1);
    }
  }
#line 129
  if (default_strategy) {
#line 130
    default_strategy->is_default = 0;
  }
#line 131
  sp->is_default = 1;
#line 132
  default_strategy = sp;
#line 133
  return (0);
}
}
#line 136 "/home/wslee/benchmarks/textformat/dico-2.0/lib/strat.c"
dico_strategy_t const   dico_get_default_strategy(void) 
{ 


  {
#line 139
  return ((dico_strategy_t const   )default_strategy);
}
}
#line 119 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 68 "../include/dico/utf8.h"
int dico_soundex(char const   *s , char *codestr ) ;
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/soundex.c"
static unsigned char soundextbl[26]  = 
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/soundex.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)2,      (unsigned char)2,      (unsigned char)4, 
        (unsigned char)5,      (unsigned char)5,      (unsigned char)0,      (unsigned char)1, 
        (unsigned char)2,      (unsigned char)6,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)0,      (unsigned char)1,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)0,      (unsigned char)2};
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/lib/soundex.c"
int dico_soundex(char const   *s , char *codestr ) 
{ 
  int i ;
  int prev ;
  int tmp ;
  int n ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 57
  prev = 0;
#line 59
  tmp = toupper((int )*s);
#line 59
  *(codestr + 0) = (char )tmp;
#line 60
  i = 1;
#line 60
  s ++;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (i < 4) {
#line 60
      if (! *s) {
#line 60
        goto while_break;
      }
    } else {
#line 60
      goto while_break;
    }
    {
#line 61
    tmp___0 = toupper((int )*s);
#line 61
    n = (int )soundextbl[tmp___0 - 65];
    }
#line 62
    if (n) {
#line 63
      if (n == prev) {
#line 64
        goto __Cont;
      }
#line 65
      tmp___1 = i;
#line 65
      i ++;
#line 65
      *(codestr + tmp___1) = (char )(n + 48);
#line 66
      prev = n;
    }
    __Cont: /* CIL Label */ 
#line 60
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i < 4)) {
#line 69
      goto while_break___0;
    }
#line 70
    *(codestr + i) = (char )'0';
#line 69
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  *(codestr + i) = (char)0;
#line 72
  return (0);
}
}
#line 27 "../include/dico/filter.h"
dico_stream_t filter_stream_create(dico_stream_t str , size_t min_level , size_t max_line_length ,
                                   int (*xcode)(char const   * , size_t  , char * ,
                                                size_t  , size_t * ) , int mode___0 ) ;
#line 36
dico_stream_t dico_qp_stream_create(dico_stream_t str , int mode___0 ) ;
#line 46
int dico_qp_decode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                   size_t *pnbytes ) ;
#line 49
int dico_qp_encode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                   size_t *pnbytes ) ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/qp.c"
int dico_qp_decode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                   size_t *pnbytes ) 
{ 
  char c ;
  int last_char ;
  size_t consumed ;
  size_t wscount ;
  size_t nbytes ;
  char const   *tmp ;
  size_t sz ;
  char chr[3] ;
  int new_c ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp21 ;

  {
#line 31
  last_char = 0;
#line 32
  consumed = (size_t )0;
#line 33
  wscount = (size_t )0;
#line 34
  nbytes = (size_t )0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (consumed < isize) {
#line 36
      if (! (nbytes < osize)) {
#line 36
        goto while_break;
      }
    } else {
#line 36
      goto while_break;
    }
#line 37
    tmp = iptr;
#line 37
    iptr ++;
#line 37
    c = (char )*tmp;
#line 39
    if ((int )c == 32) {
#line 40
      wscount ++;
#line 41
      consumed ++;
    } else
#line 39
    if ((int )c == 9) {
#line 40
      wscount ++;
#line 41
      consumed ++;
    } else {
#line 51
      if (wscount) {
#line 52
        if ((int )c != 13) {
#line 52
          if ((int )c != 10) {
#line 55
            if (consumed >= isize) {
#line 56
              goto while_break;
            }
#line 58
            if (nbytes + wscount > osize) {
#line 59
              sz = osize - nbytes;
            } else {
#line 61
              sz = wscount;
            }
            {
#line 62
            memcpy((void */* __restrict  */)optr, (void const   */* __restrict  */)((iptr - wscount) - 1),
                   sz);
#line 63
            optr += sz;
#line 64
            nbytes += sz;
            }
#line 65
            if (wscount > sz) {
#line 66
              wscount -= sz;
#line 67
              goto while_break;
            }
          }
        }
#line 70
        wscount = (size_t )0;
#line 71
        if (nbytes == osize) {
#line 72
          goto while_break;
        }
      }
#line 75
      if ((int )c == 61) {
#line 77
        if (consumed + 2U >= isize) {
#line 78
          goto while_break;
        } else {
#line 84
          chr[2] = (char)0;
#line 85
          tmp___0 = iptr;
#line 85
          iptr ++;
#line 85
          chr[0] = (char )*tmp___0;
#line 87
          if ((int )chr[0] != 10) {
            {
#line 88
            tmp___1 = iptr;
#line 88
            iptr ++;
#line 88
            chr[1] = (char )*tmp___1;
#line 89
            tmp___2 = strtoul((char const   */* __restrict  */)(chr), (char **/* __restrict  */)((void *)0),
                              16);
#line 89
            new_c = (int )tmp___2;
#line 90
            tmp___3 = optr;
#line 90
            optr ++;
#line 90
            *tmp___3 = (char )new_c;
#line 91
            nbytes ++;
#line 92
            consumed += 3U;
            }
          } else {
#line 94
            consumed += 2U;
          }
        }
      } else
#line 98
      if ((int )c == 13) {
#line 101
        if (consumed + 1U >= isize) {
#line 102
          goto while_break;
        } else {
#line 104
          iptr ++;
#line 105
          tmp___4 = optr;
#line 105
          optr ++;
#line 105
          *tmp___4 = (char )'\n';
#line 106
          nbytes ++;
#line 107
          consumed += 2U;
        }
      } else {
#line 110
        tmp___5 = optr;
#line 110
        optr ++;
#line 110
        *tmp___5 = c;
#line 111
        nbytes ++;
#line 112
        consumed ++;
      }
    }
#line 115
    last_char = (int )c;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  *pnbytes = nbytes;
#line 118
  return ((int )(consumed - wscount));
}
}
#line 128 "/home/wslee/benchmarks/textformat/dico-2.0/lib/qp.c"
static char const   _hexdigits[17]  = 
#line 128
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'\000'};
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/lib/qp.c"
int dico_qp_encode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                   size_t *pnbytes ) 
{ 
  unsigned int c ;
  size_t consumed ;
  size_t nbytes ;
  int simple_char ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 126
  consumed = (size_t )0;
#line 127
  nbytes = (size_t )0;
#line 130
  nbytes = (size_t )0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (consumed < isize)) {
#line 137
      goto while_break;
    }
#line 141
    c = (unsigned int )*((unsigned char *)iptr);
#line 142
    if (c >= 32U) {
#line 142
      if (c <= 60U) {
#line 142
        tmp = 1;
      } else {
#line 142
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 142
    if (c >= 62U) {
#line 142
      if (c <= 126U) {
#line 142
        tmp = 1;
      } else {
#line 142
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 142
    if (c == 9U) {
#line 142
      tmp = 1;
    } else
#line 142
    if (c == 10U) {
#line 142
      tmp = 1;
    } else {
#line 142
      tmp = 0;
    }
#line 142
    simple_char = tmp;
#line 147
    if (simple_char) {
#line 149
      if (nbytes + 1U > osize) {
#line 150
        goto while_break;
      }
#line 152
      tmp___0 = optr;
#line 152
      optr ++;
#line 152
      *tmp___0 = (char )c;
#line 153
      nbytes ++;
#line 155
      iptr ++;
#line 156
      consumed ++;
    } else {
#line 160
      if (nbytes + 3U > osize) {
#line 161
        goto while_break;
      }
#line 163
      tmp___1 = optr;
#line 163
      optr ++;
#line 163
      *tmp___1 = (char )'=';
#line 164
      tmp___2 = optr;
#line 164
      optr ++;
#line 164
      *tmp___2 = (char )_hexdigits[(c >> 4) & 15U];
#line 165
      tmp___3 = optr;
#line 165
      optr ++;
#line 165
      *tmp___3 = (char )_hexdigits[c & 15U];
#line 167
      nbytes += 3U;
#line 170
      iptr ++;
#line 171
      consumed ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  *pnbytes = nbytes;
#line 175
  return ((int )consumed);
}
}
#line 179 "/home/wslee/benchmarks/textformat/dico-2.0/lib/qp.c"
dico_stream_t dico_qp_stream_create(dico_stream_t str , int mode___0 ) 
{ 
  int (*tmp)(char const   *iptr , size_t isize , char *optr , size_t osize , size_t *pnbytes ) ;
  dico_stream_t tmp___0 ;

  {
#line 182
  if (mode___0 == 0) {
#line 182
    tmp = & dico_qp_encode;
  } else {
#line 182
    tmp = & dico_qp_decode;
  }
  {
#line 182
  tmp___0 = filter_stream_create(str, (size_t )4, (size_t )0, tmp, mode___0);
  }
#line 182
  return (tmp___0);
}
}
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 48 "../include/dico/diag.h"
void ( /* format attribute */  dico_log)(int lvl , int errcode , char const   *fmt 
                                         , ...) ;
#line 51 "../include/dico/parseopt.h"
int dico_parseopt(struct dico_option *opt , int argc , char **argv , int flags , int *pindex ) ;
#line 45 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dgettext(char const   *__domainname , char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 21 "../include/libi18n.h"
void _dico_libi18n_init(void) ;
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/parseopt.c"
static struct dico_option *find_opt(struct dico_option *opt , char const   *str ,
                                    char const   **value ) 
{ 
  size_t len ;
  size_t tmp ;
  int isbool ;
  int tmp___0 ;
  int eq ;
  int tmp___1 ;
  char *__cil_tmp10 ;

  {
  {
#line 27
  tmp = strlen(str);
#line 27
  len = tmp;
  }
#line 30
  if (len > 2U) {
    {
#line 30
    tmp___0 = memcmp((void const   *)str, (void const   *)"no", (size_t )2);
    }
#line 30
    if (tmp___0 == 0) {
#line 31
      *value = (char const   *)((void *)0);
#line 32
      str += 2;
#line 33
      isbool = 1;
    } else {
#line 35
      isbool = 0;
#line 36
      *value = str;
    }
  } else {
#line 35
    isbool = 0;
#line 36
    *value = str;
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! opt->name) {
#line 39
      goto while_break;
    }
#line 40
    if (len >= opt->len) {
      {
#line 40
      tmp___1 = memcmp((void const   *)opt->name, (void const   *)str, opt->len);
      }
#line 40
      if (tmp___1 == 0) {
#line 40
        if (! isbool) {
#line 40
          goto _L;
        } else
#line 40
        if ((unsigned int )opt->type == 1U) {
          _L: /* CIL Label */ 
#line 43
          eq = (int const   )*(str + opt->len) == 61;
          {
#line 49
          if ((unsigned int )opt->type == 6U) {
#line 49
            goto case_6;
          }
#line 49
          if ((unsigned int )opt->type == 8U) {
#line 49
            goto case_6;
          }
#line 49
          if ((unsigned int )opt->type == 5U) {
#line 49
            goto case_6;
          }
#line 49
          if ((unsigned int )opt->type == 4U) {
#line 49
            goto case_6;
          }
#line 55
          if ((unsigned int )opt->type == 0U) {
#line 55
            goto case_0;
          }
#line 62
          goto switch_default;
          case_6: /* CIL Label */ 
          case_8: /* CIL Label */ 
          case_5: /* CIL Label */ 
          case_4: /* CIL Label */ 
#line 50
          if (! eq) {
#line 51
            goto __Cont;
          }
#line 52
          *value = (str + opt->len) + 1;
#line 53
          goto switch_break;
          case_0: /* CIL Label */ 
#line 56
          if (eq) {
#line 57
            *value = (str + opt->len) + 1;
          } else {
#line 59
            *value = (char const   *)((void *)0);
          }
#line 60
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 63
          if (eq) {
#line 64
            goto __Cont;
          }
#line 65
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 67
          return (opt);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 39
    opt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return ((struct dico_option *)((void *)0));
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/lib/parseopt.c"
int find_value(char const   **enumstr , char const   *value ) 
{ 
  int i ;
  int tmp ;

  {
#line 77
  i = 0;
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! *enumstr) {
#line 77
      goto while_break;
    }
    {
#line 78
    tmp = strcmp(*enumstr, value);
    }
#line 78
    if (tmp == 0) {
#line 79
      return (i);
    }
#line 77
    enumstr ++;
#line 77
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (-1);
}
}
#line 83 "/home/wslee/benchmarks/textformat/dico-2.0/lib/parseopt.c"
int dico_parseopt(struct dico_option *opt , int argc , char **argv , int flags , int *pindex ) 
{ 
  int i ;
  long n ;
  char *s ;
  int rc ;
  char const   *modname ;
  char const   *value ;
  struct dico_option *p ;
  struct dico_option *tmp ;
  int j ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 90
  rc = 0;
#line 91
  modname = (char const   *)*(argv + 0);
#line 93
  _dico_libi18n_init();
  }
#line 95
  if (flags & 1) {
#line 95
    i = 0;
  } else {
#line 95
    i = 1;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < argc)) {
#line 95
      goto while_break;
    }
    {
#line 98
    tmp = find_opt(opt, (char const   *)*(argv + i), & value);
#line 98
    p = tmp;
    }
#line 100
    if (! p) {
#line 101
      if (pindex) {
#line 102
        if (flags & 2) {
#line 105
          j = i + 1;
          {
#line 105
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 105
            if (! (j < argc)) {
#line 105
              goto while_break___0;
            }
            {
#line 106
            p = find_opt(opt, (char const   *)*(argv + j), & value);
            }
#line 106
            if (p) {
#line 107
              goto while_break___0;
            }
#line 105
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 109
          if (p) {
#line 110
            tmp___0 = *(argv + j);
#line 111
            *(argv + j) = *(argv + i);
#line 112
            *(argv + i) = tmp___0;
          } else {
#line 114
            goto while_break;
          }
        } else {
#line 116
          goto while_break;
        }
      } else {
        {
#line 118
        tmp___1 = dgettext("dico", "%s: %s: unknown option");
#line 118
        dico_log(4, 0, (char const   *)tmp___1, modname, *(argv + i));
#line 120
        rc = 1;
        }
#line 121
        goto __Cont;
      }
    }
    {
#line 126
    if ((unsigned int )p->type == 4U) {
#line 126
      goto case_4;
    }
#line 137
    if ((unsigned int )p->type == 7U) {
#line 137
      goto case_7;
    }
#line 141
    if ((unsigned int )p->type == 8U) {
#line 141
      goto case_8;
    }
#line 145
    if ((unsigned int )p->type == 5U) {
#line 145
      goto case_5;
    }
#line 149
    if ((unsigned int )p->type == 1U) {
#line 149
      goto case_1;
    }
#line 159
    if ((unsigned int )p->type == 2U) {
#line 159
      goto case_2;
    }
#line 163
    if ((unsigned int )p->type == 3U) {
#line 163
      goto case_3;
    }
#line 167
    if ((unsigned int )p->type == 6U) {
#line 167
      goto case_6;
    }
#line 178
    if ((unsigned int )p->type == 0U) {
#line 178
      goto case_0;
    }
#line 125
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 127
    n = strtol((char const   */* __restrict  */)value, (char **/* __restrict  */)(& s),
               0);
    }
#line 128
    if (*s) {
      {
#line 129
      tmp___2 = dgettext("dico", "%s: %s: %s is not a valid number");
#line 129
      dico_log(4, 0, (char const   *)tmp___2, modname, p->name, value);
#line 131
      rc = 1;
      }
#line 132
      goto __Cont;
    }
#line 134
    *((long *)p->data) = n;
#line 135
    goto switch_break;
    case_7: /* CIL Label */ 
#line 138
    *((long *)p->data) = p->v.value;
#line 139
    goto switch_break;
    case_8: /* CIL Label */ 
#line 142
    *((char const   **)p->data) = value;
#line 143
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 146
    tmp___3 = strdup(value);
#line 146
    *((char const   **)p->data) = (char const   *)tmp___3;
    }
#line 147
    goto switch_break;
    case_1: /* CIL Label */ 
#line 150
    if (p->v.value) {
#line 151
      if (value) {
#line 152
        *((int *)p->data) = (int )((long )*((int *)p->data) | p->v.value);
      } else {
#line 154
        *((int *)p->data) = (int )((long )*((int *)p->data) & ~ p->v.value);
      }
    } else {
#line 156
      *((int *)p->data) = (unsigned long )value != (unsigned long )((void *)0);
    }
#line 157
    goto switch_break;
    case_2: /* CIL Label */ 
#line 160
    *((int *)p->data) = (int )((long )*((int *)p->data) | p->v.value);
#line 161
    goto switch_break;
    case_3: /* CIL Label */ 
#line 164
    *((int *)p->data) = (int )((long )*((int *)p->data) & ~ p->v.value);
#line 165
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 168
    tmp___4 = find_value(p->v.enumstr, value);
#line 168
    n = (long )tmp___4;
    }
#line 169
    if (n == -1L) {
      {
#line 170
      tmp___5 = dgettext("dico", "%s: %s: invalid value %s");
#line 170
      dico_log(4, 0, (char const   *)tmp___5, modname, p->name, value);
#line 172
      rc = 1;
      }
#line 173
      goto __Cont;
    }
#line 175
    *((int *)p->data) = (int )n;
#line 176
    goto switch_break;
    case_0: /* CIL Label */ 
#line 179
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 182
    if (p->func) {
      {
#line 182
      tmp___6 = (*(p->func))(p, value);
      }
#line 182
      if (tmp___6) {
#line 183
        rc = 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if (pindex) {
#line 186
    *pindex = i;
  }
#line 187
  return (rc);
}
}
#line 24 "../include/dico/markup.h"
char const   *dico_markup_lookup(char const   *name ) ;
#line 25
int dico_markup_register(char const   *name ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/markup.c"
char const   *dico_markup_type  =    "none";
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/lib/markup.c"
static int cmp_markup_name(void const   *item , void *data ) 
{ 
  int tmp ;

  {
  {
#line 30
  tmp = strcasecmp((char const   *)((char *)item), (char const   *)((char *)data));
  }
#line 30
  return (tmp);
}
}
#line 33 "/home/wslee/benchmarks/textformat/dico-2.0/lib/markup.c"
char const   *dico_markup_lookup(char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 36
  tmp = dico_list_locate(dico_markup_list, (void *)name);
  }
#line 36
  return ((char const   *)tmp);
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/lib/markup.c"
int dico_markup_valid_name_p(char const   *name ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! *name) {
#line 42
      goto while_break;
    }
#line 43
    if (((int const   )*name & -128) == 0) {
      {
#line 43
      tmp = __ctype_b_loc();
      }
#line 43
      if (! ((int const   )*(*tmp + (int )*name) & 8)) {
#line 43
        if (! ((int const   )*name == 95)) {
#line 44
          return (0);
        }
      }
    } else {
#line 44
      return (0);
    }
#line 42
    name ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (1);
}
}
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/lib/markup.c"
int dico_markup_register(char const   *name ) 
{ 
  int tmp ;
  char *s ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 51
  tmp = dico_markup_valid_name_p(name);
  }
#line 51
  if (! tmp) {
#line 52
    return (22);
  }
#line 54
  if (! dico_markup_list) {
    {
#line 55
    dico_markup_list = dico_list_create();
    }
#line 56
    if (! dico_markup_list) {
#line 57
      return (12);
    }
    {
#line 58
    dico_list_set_comparator(dico_markup_list, & cmp_markup_name);
    }
  }
  {
#line 61
  tmp___2 = dico_markup_lookup(name);
  }
#line 61
  if (! tmp___2) {
    {
#line 62
    tmp___0 = strdup(name);
#line 62
    s = tmp___0;
    }
#line 63
    if (! s) {
#line 64
      return (12);
    }
    {
#line 65
    tmp___1 = dico_list_append(dico_markup_list, (void *)s);
    }
#line 65
    return (tmp___1);
  }
#line 67
  return (0);
}
}
#line 111 "../include/dico/stream.h"
dico_stream_t dico_mapfile_stream_create(char const   *filename , int flags ) ;
#line 214 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 58 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
#line 77
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
static int _mapfile_close(void *data ) 
{ 
  struct _mapfile_stream *mfs ;

  {
#line 50
  mfs = (struct _mapfile_stream *)data;
#line 51
  if (mfs->start) {
    {
#line 52
    munmap((void *)mfs->start, mfs->size);
#line 53
    mfs->start = (char *)((void *)0);
#line 54
    mfs->size = (size_t )0;
    }
  }
  {
#line 56
  close(mfs->fd);
#line 57
  mfs->fd = -1;
  }
#line 58
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
int _mapfile_destroy(void *data ) 
{ 
  struct _mapfile_stream *str ;

  {
  {
#line 64
  str = (struct _mapfile_stream *)data;
#line 65
  free((void *)str->filename);
#line 66
  free((void *)str);
  }
#line 67
  return (0);
}
}
#line 70 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
int _mapfile_open(void *data , int flags ) 
{ 
  struct _mapfile_stream *mfs ;
  struct stat st ;
  int mflags ;
  int oflags ;
  int *tmp ;
  int err ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int err___0 ;
  int *tmp___3 ;

  {
  {
#line 73
  mfs = (struct _mapfile_stream *)data;
#line 75
  mflags = 0;
#line 75
  oflags = 0;
#line 78
  _mapfile_close(data);
  }
#line 81
  if (flags & 1) {
#line 82
    mflags |= 1;
  }
#line 83
  if (flags & 2) {
#line 84
    mflags |= 2;
  }
#line 86
  if ((flags & 3) == 3) {
#line 88
    oflags = 2;
  } else
#line 89
  if (flags & 1) {
#line 90
    oflags = 0;
  } else {
#line 92
    oflags = 1;
  }
  {
#line 94
  mfs->fd = open((char const   *)mfs->filename, oflags);
  }
#line 95
  if (mfs->fd < 0) {
    {
#line 96
    tmp = __errno_location();
    }
#line 96
    return (*tmp);
  }
  {
#line 97
  tmp___1 = fstat(mfs->fd, & st);
  }
#line 97
  if (tmp___1) {
    {
#line 98
    tmp___0 = __errno_location();
#line 98
    err = *tmp___0;
#line 99
    close(mfs->fd);
    }
#line 100
    return (err);
  }
#line 102
  mfs->size = (size_t )st.st_size;
#line 103
  if (mfs->size) {
    {
#line 104
    tmp___2 = mmap((void *)0, mfs->size, mflags, 1, mfs->fd, (__off_t )0);
#line 104
    mfs->start = (char *)tmp___2;
    }
#line 105
    if ((unsigned long )mfs->start == (unsigned long )((void *)-1)) {
      {
#line 106
      tmp___3 = __errno_location();
#line 106
      err___0 = *tmp___3;
#line 107
      close(mfs->fd);
#line 108
      mfs->start = (char *)((void *)0);
      }
#line 109
      return (err___0);
    }
  } else {
#line 112
    mfs->start = (char *)((void *)0);
  }
#line 113
  mfs->flags = mflags;
#line 114
  return (0);
}
}
#line 117 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
static int _mapfile_seek(void *data , off_t needle , int whence , off_t *presult ) 
{ 
  struct _mapfile_stream *str ;
  off_t offset ;

  {
#line 120
  str = (struct _mapfile_stream *)data;
  {
#line 124
  if (whence == 0) {
#line 124
    goto case_0;
  }
#line 128
  if (whence == 1) {
#line 128
    goto case_1;
  }
#line 132
  if (whence == 2) {
#line 132
    goto case_2;
  }
#line 136
  goto switch_default;
  case_0: /* CIL Label */ 
#line 125
  offset = needle;
#line 126
  goto switch_break;
  case_1: /* CIL Label */ 
#line 129
  offset = str->offset + needle;
#line 130
  goto switch_break;
  case_2: /* CIL Label */ 
#line 133
  offset = (off_t )str->size + needle;
#line 134
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 137
  return (22);
  switch_break: /* CIL Label */ ;
  }
#line 140
  if (offset < 0L) {
#line 141
    return (22);
  } else
#line 140
  if (offset > (off_t )str->size) {
#line 141
    return (22);
  }
#line 142
  str->offset = offset;
#line 143
  *presult = offset;
#line 144
  return (0);
}
}
#line 147 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
static int _mapfile_size(void *data , off_t *presult ) 
{ 
  struct _mapfile_stream *mfs ;

  {
#line 150
  mfs = (struct _mapfile_stream *)data;
#line 152
  if ((unsigned long )mfs->start == (unsigned long )((void *)0)) {
#line 153
    return (22);
  }
#line 154
  *presult = (off_t )mfs->size;
#line 155
  return (0);
}
}
#line 158 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
static int _mapfile_read(void *data , char *buf___1 , size_t size , size_t *pret ) 
{ 
  struct _mapfile_stream *mfs ;
  size_t n ;

  {
#line 161
  mfs = (struct _mapfile_stream *)data;
#line 164
  if ((unsigned long )mfs->start == (unsigned long )((void *)0)) {
#line 165
    return (22);
  }
#line 167
  if (mfs->offset + (off_t )size > (off_t )mfs->size) {
#line 167
    n = (size_t )((off_t )mfs->size - mfs->offset);
  } else {
#line 167
    n = size;
  }
  {
#line 168
  memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)(mfs->start + mfs->offset),
         n);
#line 169
  mfs->offset += (off_t )n;
#line 171
  *pret = n;
  }
#line 172
  return (0);
}
}
#line 175 "/home/wslee/benchmarks/textformat/dico-2.0/lib/mapstream.c"
dico_stream_t dico_mapfile_stream_create(char const   *filename , int flags ) 
{ 
  int rc ;
  dico_stream_t str ;
  struct _mapfile_stream *s ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 180
  tmp = malloc((size_t )sizeof(*s));
#line 180
  s = (struct _mapfile_stream *)tmp;
  }
#line 183
  if (flags & 2) {
    {
#line 184
    tmp___0 = __errno_location();
#line 184
    *tmp___0 = 22;
    }
#line 185
    return ((dico_stream_t )((void *)0));
  }
#line 188
  if (! s) {
#line 189
    return ((dico_stream_t )((void *)0));
  }
  {
#line 190
  memset((void *)s, 0, (size_t )sizeof(*s));
#line 191
  s->fd = -1;
#line 192
  s->filename = strdup(filename);
  }
#line 193
  if (! s->filename) {
    {
#line 194
    free((void *)s);
    }
#line 195
    return ((dico_stream_t )((void *)0));
  }
  {
#line 198
  rc = dico_stream_create(& str, flags, (void *)s);
  }
#line 199
  if (rc) {
    {
#line 200
    free((void *)s->filename);
#line 201
    free((void *)s);
    }
#line 202
    return ((dico_stream_t )((void *)0));
  }
  {
#line 204
  dico_stream_set_open(str, & _mapfile_open);
#line 205
  dico_stream_set_seek(str, & _mapfile_seek);
#line 206
  dico_stream_set_size(str, & _mapfile_size);
#line 207
  dico_stream_set_read(str, & _mapfile_read);
#line 208
  dico_stream_set_close(str, & _mapfile_close);
#line 209
  dico_stream_set_destroy(str, & _mapfile_destroy);
  }
#line 210
  return (str);
}
}
#line 54 "../include/dico/diag.h"
dico_stream_t dico_log_stream_create(int level ) ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/logstream.c"
static int log_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct log_stream *p ;
  char *__cil_tmp6 ;

  {
#line 29
  p = (struct log_stream *)data;
#line 30
  if (pret) {
#line 31
    *pret = size;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (size > 0U) {
#line 32
      if (! ((int const   )*(buf___1 + (size - 1U)) == 10)) {
#line 32
        if (! ((int const   )*(buf___1 + (size - 1U)) == 13)) {
#line 32
          goto while_break;
        }
      }
    } else {
#line 32
      goto while_break;
    }
#line 33
    size --;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  if (size) {
    {
#line 35
    dico_log(p->level, 0, "%.*s", size, buf___1);
    }
  }
#line 36
  return (0);
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/lib/logstream.c"
static int log_destroy(void *data ) 
{ 


  {
  {
#line 42
  free(data);
  }
#line 43
  return (0);
}
}
#line 46 "/home/wslee/benchmarks/textformat/dico-2.0/lib/logstream.c"
dico_stream_t dico_log_stream_create(int level ) 
{ 
  struct log_stream *p ;
  void *tmp ;
  dico_stream_t stream ;
  int tmp___0 ;

  {
  {
#line 49
  tmp = malloc((size_t )sizeof(*p));
#line 49
  p = (struct log_stream *)tmp;
  }
#line 52
  if (! p) {
#line 53
    return ((dico_stream_t )((void *)0));
  } else {
    {
#line 52
    tmp___0 = dico_stream_create(& stream, 2, (void *)p);
    }
#line 52
    if (tmp___0) {
#line 53
      return ((dico_stream_t )((void *)0));
    }
  }
  {
#line 54
  dico_stream_set_write(stream, & log_write);
#line 55
  dico_stream_set_destroy(stream, & log_destroy);
#line 56
  dico_stream_set_buffer(stream, (enum dico_buffer_type )1, (size_t )1024);
#line 57
  p->level = level;
  }
#line 58
  return (stream);
}
}
#line 30 "../include/dico/list.h"
int dico_list_clear(struct dico_list *list ) ;
#line 35
dico_list_comp_t dico_list_get_comparator(struct dico_list *list ) ;
#line 38
void *dico_list_item(struct dico_list *list , size_t n ) ;
#line 41
int dico_list_prepend(struct dico_list *list , void *data ) ;
#line 42
int dico_list_insert_sorted(struct dico_list *list , void *data ) ;
#line 43
dico_list_t dico_list_intersect(dico_list_t a , dico_list_t b , int (*cmp)(void const   * ,
                                                                           void * ) ) ;
#line 45
int dico_list_intersect_p(dico_list_t a , dico_list_t b , int (*cmp)(void const   * ,
                                                                     void * ) ) ;
#line 48
void *dico_list_pop(struct dico_list *list ) ;
#line 50
void *_dico_list_locate(struct dico_list *list , void *data , int (*cmp)(void const   * ,
                                                                         void * ) ) ;
#line 51
int _dico_list_remove(struct dico_list *list , void *data , int (*cmp)(void const   * ,
                                                                       void * ) ,
                      void **pptr ) ;
#line 54
int dico_list_remove(struct dico_list *list , void *data , void **pret ) ;
#line 56
void *dico_iterator_current(dico_iterator_t ip ) ;
#line 58
void dico_iterator_destroy(dico_iterator_t *ip ) ;
#line 59
void *dico_iterator_first(dico_iterator_t ip ) ;
#line 60
void *dico_iterator_next(dico_iterator_t ip ) ;
#line 62
int dico_iterator_remove_current(dico_iterator_t ip , void **pptr ) ;
#line 63
void dico_iterator_set_data(dico_iterator_t ip , void *data ) ;
#line 46 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
static int cmp_ptr(void const   *a , void *b ) 
{ 


  {
#line 49
  return ((unsigned long )a != (unsigned long )b);
}
}
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
struct dico_list *dico_list_create(void) 
{ 
  struct dico_list *p ;
  void *tmp ;
  struct list_entry *tmp___0 ;

  {
  {
#line 55
  tmp = malloc((size_t )sizeof(*p));
#line 55
  p = (struct dico_list *)tmp;
  }
#line 56
  if (p) {
#line 57
    p->count = (size_t )0;
#line 58
    tmp___0 = (struct list_entry *)((void *)0);
#line 58
    p->tail = tmp___0;
#line 58
    p->head = tmp___0;
#line 59
    p->itr = (struct iterator *)((void *)0);
#line 60
    p->comp = & cmp_ptr;
#line 61
    p->free_item = (int (*)(void *item , void *data ))((void *)0);
#line 62
    p->free_data = (void *)0;
  }
#line 64
  return (p);
}
}
#line 67 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_clear(struct dico_list *list ) 
{ 
  struct list_entry *p ;
  int *tmp ;
  struct list_entry *tmp___0 ;
  struct list_entry *next ;

  {
#line 72
  if (! list) {
    {
#line 73
    tmp = __errno_location();
#line 73
    *tmp = 22;
    }
#line 74
    return (1);
  }
#line 77
  p = list->head;
#line 78
  tmp___0 = (struct list_entry *)((void *)0);
#line 78
  list->tail = tmp___0;
#line 78
  list->head = tmp___0;
#line 79
  list->count = (size_t )0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! p) {
#line 81
      goto while_break;
    }
#line 82
    next = p->next;
#line 83
    if (list->free_item) {
      {
#line 84
      (*(list->free_item))(p->data, list->free_data);
      }
    }
    {
#line 85
    free((void *)p);
#line 86
    p = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (0);
}
}
#line 91 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void dico_list_destroy(struct dico_list **plist ) 
{ 
  struct dico_list *list ;

  {
#line 96
  if (! plist) {
#line 97
    return;
  } else
#line 96
  if (! *plist) {
#line 97
    return;
  }
  {
#line 99
  list = *plist;
#line 100
  *plist = (struct dico_list *)((void *)0);
#line 102
  dico_list_clear(list);
#line 103
  free((void *)list);
  }
#line 104
  return;
}
}
#line 106 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void dico_list_free_item(struct dico_list *list , void *item ) 
{ 


  {
#line 109
  if (list->free_item) {
    {
#line 110
    (*(list->free_item))(item, list->free_data);
    }
  }
#line 111
  return;
}
}
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_iterator_current(dico_iterator_t ip ) 
{ 
  void *tmp ;

  {
#line 116
  if (! ip) {
#line 117
    return ((void *)0);
  }
#line 118
  if (ip->cur) {
#line 118
    tmp = (ip->cur)->data;
  } else {
#line 118
    tmp = (void *)0;
  }
#line 118
  return (tmp);
}
}
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
static void dico_iterator_attach(dico_iterator_t itr , dico_list_t list ) 
{ 


  {
#line 124
  itr->list = list;
#line 125
  itr->cur = (struct list_entry *)((void *)0);
#line 126
  itr->next = list->itr;
#line 127
  itr->advanced = 0;
#line 128
  list->itr = itr;
#line 129
  return;
}
}
#line 131 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
static dico_iterator_t dico_iterator_detach(dico_iterator_t iter ) 
{ 
  dico_iterator_t cur ;
  dico_iterator_t prev ;

  {
#line 136
  cur = (iter->list)->itr;
#line 136
  prev = (dico_iterator_t )((void *)0);
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! cur) {
#line 136
      goto while_break;
    }
#line 139
    if ((unsigned long )cur == (unsigned long )iter) {
#line 140
      goto while_break;
    }
#line 136
    prev = cur;
#line 136
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (cur) {
#line 143
    if (prev) {
#line 144
      prev->next = cur->next;
    } else {
#line 146
      (cur->list)->itr = cur->next;
    }
  }
#line 148
  return (cur);
}
}
#line 151 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
dico_iterator_t dico_list_iterator(dico_list_t list ) 
{ 
  dico_iterator_t itr ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 156
  if (! list) {
    {
#line 157
    tmp = __errno_location();
#line 157
    *tmp = 22;
    }
#line 158
    return ((dico_iterator_t )((void *)0));
  }
  {
#line 160
  tmp___0 = malloc((size_t )sizeof(*itr));
#line 160
  itr = (dico_iterator_t )tmp___0;
  }
#line 161
  if (itr) {
    {
#line 162
    dico_iterator_attach(itr, list);
    }
  }
#line 163
  return (itr);
}
}
#line 166 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void dico_iterator_destroy(dico_iterator_t *ip ) 
{ 
  dico_iterator_t itr ;

  {
#line 171
  if (! ip) {
#line 172
    return;
  } else
#line 171
  if (! *ip) {
#line 172
    return;
  }
  {
#line 173
  itr = dico_iterator_detach(*ip);
  }
#line 174
  if (itr) {
    {
#line 175
    free((void *)itr);
    }
  }
#line 176
  *ip = (dico_iterator_t )((void *)0);
#line 177
  return;
}
}
#line 179 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_iterator_first(dico_iterator_t ip ) 
{ 
  void *tmp ;

  {
#line 182
  if (! ip) {
#line 183
    return ((void *)0);
  }
  {
#line 184
  ip->cur = (ip->list)->head;
#line 185
  ip->advanced = 0;
#line 186
  tmp = dico_iterator_current(ip);
  }
#line 186
  return (tmp);
}
}
#line 189 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_iterator_next(dico_iterator_t ip ) 
{ 
  void *tmp ;

  {
#line 192
  if (! ip) {
#line 193
    return ((void *)0);
  } else
#line 192
  if (! ip->cur) {
#line 193
    return ((void *)0);
  }
#line 194
  if (! ip->advanced) {
#line 195
    ip->cur = (ip->cur)->next;
  }
  {
#line 196
  ip->advanced = 0;
#line 197
  tmp = dico_iterator_current(ip);
  }
#line 197
  return (tmp);
}
}
#line 200 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_iterator_remove_current(dico_iterator_t ip , void **pptr ) 
{ 
  int tmp ;

  {
  {
#line 203
  tmp = _dico_list_remove(ip->list, (ip->cur)->data, (int (*)(void const   * , void * ))((void *)0),
                          pptr);
  }
#line 203
  return (tmp);
}
}
#line 206 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void dico_iterator_set_data(dico_iterator_t ip , void *data ) 
{ 


  {
#line 209
  (ip->cur)->data = data;
#line 210
  return;
}
}
#line 212 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
static void _iterator_advance(dico_iterator_t ip , struct list_entry *e ) 
{ 


  {
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ip) {
#line 215
      goto while_break;
    }
#line 216
    if ((unsigned long )ip->cur == (unsigned long )e) {
#line 217
      ip->cur = e->next;
#line 218
      (ip->advanced) ++;
    }
#line 215
    ip = ip->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 223 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_list_item(struct dico_list *list , size_t n ) 
{ 
  struct list_entry *p ;

  {
#line 227
  if (! list) {
#line 228
    return ((void *)0);
  } else
#line 227
  if (n >= list->count) {
#line 228
    return ((void *)0);
  }
#line 229
  p = list->head;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (n > 0U) {
#line 229
      if (! p) {
#line 229
        goto while_break;
      }
    } else {
#line 229
      goto while_break;
    }
#line 229
    p = p->next;
#line 229
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return (p->data);
}
}
#line 234 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
size_t dico_list_count(struct dico_list *list ) 
{ 


  {
#line 237
  if (! list) {
#line 238
    return ((size_t )0);
  }
#line 239
  return (list->count);
}
}
#line 242 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_set_free_item(struct dico_list *list , int (*free_item)(void *item ,
                                                                      void *data ) ,
                            void *data ) 
{ 
  int *tmp ;

  {
#line 246
  if (! list) {
    {
#line 247
    tmp = __errno_location();
#line 247
    *tmp = 22;
    }
#line 248
    return (1);
  }
#line 250
  list->free_item = free_item;
#line 251
  list->free_data = data;
#line 252
  return (0);
}
}
#line 255 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
dico_list_comp_t dico_list_set_comparator(struct dico_list *list , int (*comp)(void const   * ,
                                                                               void * ) ) 
{ 
  int (*prev)(void const   * , void * ) ;
  int *tmp ;

  {
#line 260
  if (! list) {
    {
#line 261
    tmp = __errno_location();
#line 261
    *tmp = 22;
    }
#line 262
    return ((dico_list_comp_t )((void *)0));
  }
#line 264
  prev = list->comp;
#line 265
  list->comp = comp;
#line 266
  return (prev);
}
}
#line 269 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
dico_list_comp_t dico_list_get_comparator(struct dico_list *list ) 
{ 
  int *tmp ;

  {
#line 272
  if (! list) {
    {
#line 273
    tmp = __errno_location();
#line 273
    *tmp = 22;
    }
#line 274
    return ((dico_list_comp_t )((void *)0));
  }
#line 276
  return (list->comp);
}
}
#line 279 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_append(struct dico_list *list , void *data ) 
{ 
  struct list_entry *ep ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 284
  if (! list) {
    {
#line 285
    tmp = __errno_location();
#line 285
    *tmp = 22;
    }
#line 286
    return (1);
  }
  {
#line 288
  tmp___0 = malloc((size_t )sizeof(*ep));
#line 288
  ep = (struct list_entry *)tmp___0;
  }
#line 289
  if (! ep) {
#line 290
    return (1);
  }
#line 291
  ep->next = (struct list_entry *)((void *)0);
#line 292
  ep->data = data;
#line 293
  if (list->tail) {
#line 294
    (list->tail)->next = ep;
  } else {
#line 296
    list->head = ep;
  }
#line 297
  list->tail = ep;
#line 298
  (list->count) ++;
#line 299
  return (0);
}
}
#line 302 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_prepend(struct dico_list *list , void *data ) 
{ 
  struct list_entry *ep ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 307
  if (! list) {
    {
#line 308
    tmp = __errno_location();
#line 308
    *tmp = 22;
    }
#line 309
    return (1);
  }
  {
#line 311
  tmp___0 = malloc((size_t )sizeof(*ep));
#line 311
  ep = (struct list_entry *)tmp___0;
  }
#line 312
  if (! ep) {
#line 313
    return (1);
  }
#line 314
  ep->data = data;
#line 315
  ep->next = list->head;
#line 316
  list->head = ep;
#line 317
  if (! list->tail) {
#line 318
    list->tail = list->head;
  }
#line 319
  (list->count) ++;
#line 320
  return (0);
}
}
#line 323 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int _dico_list_remove(struct dico_list *list , void *data , int (*cmp)(void const   * ,
                                                                       void * ) ,
                      void **pptr ) 
{ 
  struct list_entry *p ;
  struct list_entry *prev ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 329
  if (! list) {
    {
#line 330
    tmp = __errno_location();
#line 330
    *tmp = 2;
    }
#line 331
    return (1);
  } else
#line 329
  if (! list->head) {
    {
#line 330
    tmp = __errno_location();
#line 330
    *tmp = 2;
    }
#line 331
    return (1);
  }
#line 334
  if (! cmp) {
#line 335
    cmp = & cmp_ptr;
  }
#line 336
  p = list->head;
#line 336
  prev = (struct list_entry *)((void *)0);
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! p) {
#line 336
      goto while_break;
    }
    {
#line 337
    tmp___0 = (*cmp)((void const   *)p->data, data);
    }
#line 337
    if (tmp___0 == 0) {
#line 338
      goto while_break;
    }
#line 336
    prev = p;
#line 336
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if (! p) {
    {
#line 341
    tmp___1 = __errno_location();
#line 341
    *tmp___1 = 2;
    }
#line 342
    return (1);
  }
  {
#line 345
  _iterator_advance(list->itr, p);
  }
#line 346
  if ((unsigned long )p == (unsigned long )list->head) {
#line 347
    list->head = (list->head)->next;
#line 348
    if (! list->head) {
#line 349
      list->tail = (struct list_entry *)((void *)0);
    }
  } else {
#line 351
    prev->next = p->next;
  }
#line 353
  if ((unsigned long )p == (unsigned long )list->tail) {
#line 354
    list->tail = prev;
  }
  {
#line 356
  free((void *)p);
#line 357
  (list->count) --;
  }
#line 359
  if (pptr) {
#line 360
    *pptr = data;
  } else
#line 361
  if (list->free_item) {
    {
#line 362
    (*(list->free_item))(data, list->free_data);
    }
  }
#line 363
  return (0);
}
}
#line 366 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_remove(struct dico_list *list , void *data , void **pret ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 369
  if (! list) {
    {
#line 370
    tmp = __errno_location();
#line 370
    *tmp = 22;
    }
#line 371
    return (1);
  }
  {
#line 373
  tmp___0 = _dico_list_remove(list, data, list->comp, pret);
  }
#line 373
  return (tmp___0);
}
}
#line 376 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_list_pop(struct dico_list *list ) 
{ 
  void *p ;

  {
  {
#line 380
  dico_list_remove(list, (list->head)->data, & p);
  }
#line 381
  return (p);
}
}
#line 386 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void dico_list_iterate(struct dico_list *list , int (*func)(void *item , void *data ) ,
                       void *data ) 
{ 
  struct iterator itr ;
  void *p ;
  int tmp ;

  {
#line 393
  if (! list) {
#line 394
    return;
  }
  {
#line 395
  dico_iterator_attach(& itr, list);
#line 396
  p = dico_iterator_first(& itr);
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! p) {
#line 396
      goto while_break;
    }
    {
#line 397
    tmp = (*func)(p, data);
    }
#line 397
    if (tmp) {
#line 398
      goto while_break;
    }
    {
#line 396
    p = dico_iterator_next(& itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  dico_iterator_detach(& itr);
  }
#line 401
  return;
}
}
#line 403 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *_dico_list_locate(struct dico_list *list , void *data , int (*cmp)(void const   * ,
                                                                         void * ) ) 
{ 
  struct list_entry *cur ;
  int tmp ;
  void *tmp___0 ;

  {
#line 407
  if (! list) {
#line 408
    return ((void *)0);
  }
#line 409
  if (! cmp) {
#line 410
    cmp = & cmp_ptr;
  }
#line 411
  cur = list->head;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! cur) {
#line 411
      goto while_break;
    }
    {
#line 412
    tmp = (*cmp)((void const   *)cur->data, data);
    }
#line 412
    if (tmp == 0) {
#line 413
      goto while_break;
    }
#line 411
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 414
  if (cur) {
#line 414
    tmp___0 = cur->data;
  } else {
#line 414
    tmp___0 = (void *)0;
  }
#line 414
  return (tmp___0);
}
}
#line 417 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
void *dico_list_locate(struct dico_list *list , void *data ) 
{ 
  void *tmp ;

  {
#line 420
  if (! list) {
#line 421
    return ((void *)0);
  }
  {
#line 422
  tmp = _dico_list_locate(list, data, list->comp);
  }
#line 422
  return (tmp);
}
}
#line 425 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int _dico_list_insert_sorted(struct dico_list *list , void *data , int (*cmp)(void const   * ,
                                                                              void * ) ) 
{ 
  int rc ;
  struct list_entry *cur ;
  struct list_entry *prev ;
  int *tmp ;
  int tmp___0 ;
  struct list_entry *ep ;
  void *tmp___1 ;

  {
#line 432
  if (! list) {
    {
#line 433
    tmp = __errno_location();
#line 433
    *tmp = 22;
    }
#line 434
    return (1);
  }
#line 437
  if (! cmp) {
#line 438
    cmp = & cmp_ptr;
  }
#line 440
  cur = list->head;
#line 440
  prev = (struct list_entry *)((void *)0);
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! cur) {
#line 440
      goto while_break;
    }
    {
#line 441
    tmp___0 = (*cmp)((void const   *)cur->data, data);
    }
#line 441
    if (tmp___0 > 0) {
#line 442
      goto while_break;
    }
#line 440
    prev = cur;
#line 440
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  if (! prev) {
    {
#line 445
    rc = dico_list_prepend(list, data);
    }
  } else
#line 446
  if (! cur) {
    {
#line 447
    rc = dico_list_append(list, data);
    }
  } else {
    {
#line 449
    tmp___1 = malloc((size_t )sizeof(*ep));
#line 449
    ep = (struct list_entry *)tmp___1;
    }
#line 450
    if (ep) {
#line 451
      rc = 0;
#line 452
      ep->data = data;
#line 453
      ep->next = cur;
#line 454
      prev->next = ep;
#line 455
      (list->count) ++;
    } else {
#line 457
      rc = 1;
    }
  }
#line 459
  return (rc);
}
}
#line 462 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_insert_sorted(struct dico_list *list , void *data ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 465
  if (! list) {
    {
#line 466
    tmp = __errno_location();
#line 466
    *tmp = 22;
    }
#line 467
    return (1);
  }
  {
#line 469
  tmp___0 = _dico_list_insert_sorted(list, data, list->comp);
  }
#line 469
  return (tmp___0);
}
}
#line 476 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
dico_list_t dico_list_intersect(dico_list_t a , dico_list_t b , int (*cmp)(void const   * ,
                                                                           void * ) ) 
{ 
  dico_list_t res ;
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  void *p ;
  void *tmp___0 ;

  {
  {
#line 480
  tmp = dico_list_iterator(a);
#line 480
  itr = tmp;
  }
#line 483
  if (! itr) {
#line 484
    return ((dico_list_t )((void *)0));
  }
  {
#line 485
  res = dico_list_create();
  }
#line 486
  if (! res) {
#line 487
    return ((dico_list_t )((void *)0));
  }
  {
#line 488
  p = dico_iterator_first(itr);
  }
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    if (! p) {
#line 488
      goto while_break;
    }
    {
#line 489
    tmp___0 = _dico_list_locate(b, p, cmp);
    }
#line 489
    if (tmp___0) {
      {
#line 490
      dico_list_append(res, p);
      }
    }
    {
#line 488
    p = dico_iterator_next(itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 492
  dico_iterator_destroy(& itr);
  }
#line 493
  return (res);
}
}
#line 497 "/home/wslee/benchmarks/textformat/dico-2.0/lib/list.c"
int dico_list_intersect_p(dico_list_t a , dico_list_t b , int (*cmp)(void const   * ,
                                                                     void * ) ) 
{ 
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  void *p ;
  int rc ;
  void *tmp___0 ;

  {
  {
#line 500
  tmp = dico_list_iterator(a);
#line 500
  itr = tmp;
#line 502
  rc = 0;
#line 504
  p = dico_iterator_first(itr);
  }
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 504
    if (! p) {
#line 504
      goto while_break;
    }
    {
#line 505
    tmp___0 = _dico_list_locate(b, p, cmp);
    }
#line 505
    if (tmp___0) {
#line 506
      rc = 1;
#line 507
      goto while_break;
    }
    {
#line 504
    p = dico_iterator_next(itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 510
  dico_iterator_destroy(& itr);
  }
#line 511
  return (rc);
}
}
#line 87 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/libi18n.c"
static int libdico_initialized  ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/libi18n.c"
void _dico_libi18n_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
#line 29
  if (! libdico_initialized) {
    {
#line 30
    bindtextdomain("dico", "/usr/local/share/locale");
#line 31
    libdico_initialized = 1;
    }
  }
#line 33
  return;
}
}
#line 66 "../include/dico/utf8.h"
int dico_levenshtein_distance(char const   *astr , char const   *bstr , int flags ) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/lib/levenshtein.c"
int dico_levenshtein_distance(char const   *astr , char const   *bstr , int flags ) 
{ 
  unsigned int *a ;
  unsigned int *b ;
  int alen ;
  int blen ;
  unsigned int *rowptr ;
  unsigned int *row[3] ;
  int i ;
  int j ;
  int idx ;
  int nrows ;
  int dist ;
  int (*conv)(char const   * , unsigned int ** ) ;
  int (*tmp)(char const   *str , unsigned int **nptr ) ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  unsigned int n ;
  unsigned int cost ;
  int prev ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  void *__cil_tmp32 ;

  {
#line 45
  if (flags & 1) {
#line 45
    tmp = & utf8_mbstr_to_norm_wc;
  } else {
#line 45
    tmp = & utf8_mbstr_to_wc;
  }
  {
#line 45
  conv = tmp;
#line 48
  tmp___0 = (*conv)(astr, & a);
  }
#line 48
  if (tmp___0 < 0) {
#line 49
    return (-1);
  }
  {
#line 50
  tmp___1 = (*conv)(bstr, & b);
  }
#line 50
  if (tmp___1 < 0) {
    {
#line 51
    free((void *)a);
    }
#line 52
    return (-1);
  }
  {
#line 54
  tmp___2 = utf8_wc_strlen((unsigned int const   *)a);
#line 54
  alen = (int )tmp___2;
#line 55
  tmp___3 = utf8_wc_strlen((unsigned int const   *)b);
#line 55
  blen = (int )tmp___3;
#line 57
  tmp___4 = calloc((size_t )sizeof(*(rowptr + 0)), (size_t )((2 + ! (! (flags & 2))) * (blen + 1)));
#line 57
  rowptr = (unsigned int *)tmp___4;
#line 59
  row[0] = rowptr;
#line 60
  row[1] = (rowptr + blen) + 1;
  }
#line 61
  if (flags & 2) {
#line 62
    nrows = 3;
#line 63
    row[2] = (row[1] + blen) + 1;
  } else {
#line 65
    nrows = 2;
  }
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < blen + 1)) {
#line 67
      goto while_break;
    }
#line 68
    *(row[0] + i) = (unsigned int )i;
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  idx = 1;
#line 74
  i = 0;
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (! (i < alen)) {
#line 74
      goto while_break___0;
    }
#line 75
    *(row[idx] + 0) = (unsigned int )(i + 1);
#line 77
    j = 0;
    {
#line 77
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 77
      if (! (j < blen)) {
#line 77
        goto while_break___1;
      }
      {
#line 79
      prev = ((idx + nrows) - 1) % nrows;
#line 81
      tmp___5 = utf8_wc_toupper(*(a + i));
#line 81
      tmp___6 = utf8_wc_toupper(*(b + j));
      }
#line 81
      if (tmp___5 == tmp___6) {
#line 81
        tmp___7 = 0;
      } else {
#line 81
        tmp___7 = 1;
      }
#line 81
      cost = (unsigned int )tmp___7;
#line 82
      if (*(row[prev] + (j + 1)) + 1U < *(row[idx] + j) + 1U) {
#line 82
        n = *(row[prev] + (j + 1)) + 1U;
      } else {
#line 82
        n = *(row[idx] + j) + 1U;
      }
#line 84
      if (n < *(row[prev] + j) + cost) {
#line 84
        n = n;
      } else {
#line 84
        n = *(row[prev] + j) + cost;
      }
#line 85
      if (flags & 2) {
#line 86
        if (i > 0) {
#line 86
          if (j > 0) {
            {
#line 86
            tmp___8 = utf8_wc_toupper(*(a + i));
#line 86
            tmp___9 = utf8_wc_toupper(*(b + (j - 1)));
            }
#line 86
            if (tmp___8 == tmp___9) {
              {
#line 86
              tmp___10 = utf8_wc_toupper(*(a + (i - 1)));
#line 86
              tmp___11 = utf8_wc_toupper(*(b + j));
              }
#line 86
              if (tmp___10 == tmp___11) {
#line 90
                if (n < *(row[(idx + 1) % nrows] + (j - 1)) + cost) {
#line 90
                  n = n;
                } else {
#line 90
                  n = *(row[(idx + 1) % nrows] + (j - 1)) + cost;
                }
              }
            }
          }
        }
      }
#line 92
      *(row[idx] + (j + 1)) = n;
#line 77
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 95
    dist = (int )*(row[idx] + blen);
#line 74
    i ++;
#line 74
    idx = (idx + 1) % nrows;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 99
  free((void *)rowptr);
#line 100
  free((void *)a);
#line 101
  free((void *)b);
  }
#line 102
  return (dist);
}
}
#line 110 "../include/dico/stream.h"
dico_stream_t dico_io_stream(dico_stream_t in , dico_stream_t out ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static int io_read(void *data , char *buf___1 , size_t size , size_t *pret ) 
{ 
  struct _iostr *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 33
  p = (struct _iostr *)data;
#line 34
  tmp___0 = dico_stream_read(p->in, (void *)buf___1, size, pret);
  }
#line 34
  if (tmp___0) {
    {
#line 35
    p->last_err = p->in;
#line 36
    tmp = dico_stream_last_error(p->in);
    }
#line 36
    return (tmp);
  }
#line 38
  return (0);
}
}
#line 41 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static int io_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct _iostr *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 44
  p = (struct _iostr *)data;
#line 45
  tmp___0 = dico_stream_write(p->out, (void const   *)buf___1, size);
  }
#line 45
  if (tmp___0) {
    {
#line 46
    p->last_err = p->out;
#line 47
    tmp = dico_stream_last_error(p->out);
    }
#line 47
    return (tmp);
  }
#line 49
  *pret = size;
#line 50
  return (0);
}
}
#line 53 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static int io_flush(void *data ) 
{ 
  struct _iostr *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 56
  p = (struct _iostr *)data;
#line 57
  tmp___0 = dico_stream_flush(p->in);
  }
#line 57
  if (tmp___0) {
    {
#line 58
    p->last_err = p->in;
#line 59
    tmp = dico_stream_last_error(p->in);
    }
#line 59
    return (tmp);
  }
  {
#line 61
  tmp___2 = dico_stream_flush(p->out);
  }
#line 61
  if (tmp___2) {
    {
#line 62
    p->last_err = p->out;
#line 63
    tmp___1 = dico_stream_last_error(p->out);
    }
#line 63
    return (tmp___1);
  }
#line 65
  return (0);
}
}
#line 68 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static int io_close(void *data ) 
{ 
  struct _iostr *p ;

  {
  {
#line 71
  p = (struct _iostr *)data;
#line 73
  dico_stream_close(p->in);
#line 74
  dico_stream_close(p->out);
  }
#line 75
  return (0);
}
}
#line 78 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static int io_destroy(void *data ) 
{ 
  struct _iostr *p ;

  {
  {
#line 81
  p = (struct _iostr *)data;
#line 82
  dico_stream_destroy(& p->in);
#line 83
  dico_stream_destroy(& p->out);
#line 84
  free((void *)p);
  }
#line 85
  return (0);
}
}
#line 88 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
static char const   *io_error_string(void *data , int code___0 ) 
{ 
  struct _iostr *p ;
  char *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 91
  p = (struct _iostr *)data;
#line 92
  if (! p->last_err) {
    {
#line 93
    tmp = dgettext("dico", "No error");
    }
#line 93
    return ((char const   *)tmp);
  }
  {
#line 94
  tmp___0 = dico_stream_strerror(p->last_err, code___0);
  }
#line 94
  return (tmp___0);
}
}
#line 97 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iostr.c"
dico_stream_t dico_io_stream(dico_stream_t in , dico_stream_t out ) 
{ 
  int rc ;
  dico_stream_t str ;
  struct _iostr *s ;
  void *tmp ;

  {
  {
#line 104
  _dico_libi18n_init();
#line 105
  tmp = malloc((size_t )sizeof(*s));
#line 105
  s = (struct _iostr *)tmp;
  }
#line 106
  if (! s) {
#line 107
    return ((dico_stream_t )((void *)0));
  }
  {
#line 108
  rc = dico_stream_create(& str, 3, (void *)s);
  }
#line 109
  if (rc) {
    {
#line 110
    free((void *)s);
    }
#line 111
    return ((dico_stream_t )((void *)0));
  }
  {
#line 113
  s->in = in;
#line 114
  s->out = out;
#line 115
  s->last_err = (dico_stream_t )((void *)0);
#line 116
  dico_stream_set_write(str, & io_write);
#line 117
  dico_stream_set_read(str, & io_read);
#line 118
  dico_stream_set_flush(str, & io_flush);
#line 119
  dico_stream_set_close(str, & io_close);
#line 120
  dico_stream_set_destroy(str, & io_destroy);
#line 121
  dico_stream_set_error_string(str, & io_error_string);
  }
#line 122
  return (str);
}
}
#line 49 "../include/dico/assoc.h"
int dico_header_parse(dico_assoc_list_t *pasc , char const   *text ) ;
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/lib/header.c"
static int hdr_buf_append(struct hdr_buf *buf___1 , char const   *str , size_t len ) 
{ 
  size_t size ;
  void *tmp ;
  char *p ;
  size_t diff ;
  size_t size___0 ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 40
  if (len == 0U) {
#line 41
    return (0);
  }
#line 43
  if (buf___1->size == 0U) {
    {
#line 44
    size = 128U * (((len + 128U) - 1U) / 128U);
#line 45
    tmp = malloc(size);
#line 45
    buf___1->base = (char *)tmp;
    }
#line 46
    if (! buf___1->base) {
#line 47
      return (1);
    }
#line 48
    buf___1->size = size;
  } else
#line 49
  if (buf___1->level + len > buf___1->size) {
#line 51
    diff = (buf___1->level + len) - buf___1->size;
#line 52
    size___0 = buf___1->size * (((diff + buf___1->size) - 1U) / buf___1->size + 1U);
#line 53
    if (size___0 < buf___1->size) {
      {
#line 54
      tmp___0 = __errno_location();
#line 54
      *tmp___0 = 12;
      }
#line 55
      return (1);
    }
    {
#line 57
    tmp___1 = realloc((void *)buf___1->base, size___0);
#line 57
    p = (char *)tmp___1;
    }
#line 58
    if (! p) {
#line 59
      return (1);
    }
#line 60
    buf___1->base = p;
#line 61
    buf___1->size = size___0;
  }
  {
#line 63
  memcpy((void */* __restrict  */)(buf___1->base + buf___1->level), (void const   */* __restrict  */)str,
         len);
#line 64
  buf___1->level += len;
  }
#line 65
  return (0);
}
}
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/lib/header.c"
static int collect_line(char const   **ptext , dico_assoc_list_t asc , struct hdr_buf *hbuf ) 
{ 
  char const   *text ;
  char c ;
  char *p ;
  size_t n ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp14 ;

  {
#line 74
  text = *ptext;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    hbuf->level = (size_t )0;
#line 78
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if ((int const   )*text == 32) {
#line 80
      goto _L;
    } else
#line 80
    if ((int const   )*text == 9) {
      _L: /* CIL Label */ 
      {
#line 81
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 81
        if (*text) {
#line 81
          if (! ((int const   )*text == 32)) {
#line 81
            if (! ((int const   )*text == 9)) {
#line 81
              goto while_break___1;
            }
          }
        } else {
#line 81
          goto while_break___1;
        }
#line 82
        text ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 83
      text --;
    }
    {
#line 85
    n = strcspn(text, "\n");
    }
#line 87
    if (n == 0U) {
      {
#line 88
      tmp = strlen(text);
#line 88
      text += tmp;
      }
#line 89
      goto while_break___0;
    }
    {
#line 92
    tmp___0 = hdr_buf_append(hbuf, text, n);
    }
#line 92
    if (tmp___0) {
#line 93
      return (1);
    }
#line 95
    text += n;
#line 96
    if (! *text) {
#line 97
      goto while_break___0;
    }
#line 98
    text ++;
#line 79
    if (! ((int const   )*text == 32)) {
#line 79
      if (! ((int const   )*text == 9)) {
#line 79
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 101
  c = (char)0;
#line 102
  tmp___1 = hdr_buf_append(hbuf, (char const   *)(& c), (size_t )1);
  }
#line 102
  if (tmp___1) {
#line 103
    return (1);
  }
  {
#line 104
  p = strchr((char const   *)hbuf->base, ':');
  }
#line 105
  if (! p) {
    {
#line 106
    tmp___2 = __errno_location();
#line 106
    *tmp___2 = 22;
    }
#line 107
    return (1);
  }
#line 109
  tmp___3 = p;
#line 109
  p ++;
#line 109
  *tmp___3 = (char)0;
  {
#line 110
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 110
    if (*p) {
#line 110
      if (! ((int )*p == 32)) {
#line 110
        if (! ((int )*p == 9)) {
#line 110
          goto while_break___2;
        }
      }
    } else {
#line 110
      goto while_break___2;
    }
#line 111
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 112
  tmp___4 = dico_assoc_append(asc, (char const   *)hbuf->base, (char const   *)p);
  }
#line 112
  if (tmp___4) {
#line 113
    return (1);
  }
#line 114
  *ptext = text;
#line 115
  return (0);
}
}
#line 118 "/home/wslee/benchmarks/textformat/dico-2.0/lib/header.c"
int dico_header_parse(dico_assoc_list_t *pasc , char const   *text ) 
{ 
  int rc ;
  struct hdr_buf hbuf ;
  dico_assoc_list_t asc ;
  dico_assoc_list_t tmp ;
  int ec ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 121
  rc = 0;
#line 122
  hbuf.base = (char *)((void *)0);
#line 122
  hbuf.size = (size_t )0;
#line 122
  hbuf.level = (size_t )0;
#line 123
  tmp = dico_assoc_create(3);
#line 123
  asc = tmp;
  }
#line 125
  if (! asc) {
#line 126
    return (1);
  }
#line 128
  if (text) {
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
#line 129
      if (*text) {
#line 129
        if ((int const   )*text != 10) {
          {
#line 129
          rc = collect_line(& text, asc, & hbuf);
          }
#line 129
          if (! (rc == 0)) {
#line 129
            goto while_break;
          }
        } else {
#line 129
          goto while_break;
        }
      } else {
#line 129
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 132
      free((void *)hbuf.base);
      }
#line 132
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 135
  if (rc) {
    {
#line 136
    tmp___0 = __errno_location();
#line 136
    ec = *tmp___0;
#line 137
    dico_assoc_destroy(& asc);
#line 138
    tmp___1 = __errno_location();
#line 138
    *tmp___1 = ec;
    }
  } else {
#line 140
    *pasc = asc;
  }
#line 141
  return (rc);
}
}
#line 32 "../include/dico/filter.h"
dico_stream_t dico_codec_stream_create(char const   *encoding , int mode___0 , dico_stream_t transport ) ;
#line 35
dico_stream_t dico_base64_stream_create(dico_stream_t str , int mode___0 ) ;
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_read(void *data , char *buf___1 , size_t size , size_t *pret ) 
{ 
  struct filter_stream *fs ;
  size_t rdsize ;
  int rc ;

  {
#line 40
  fs = (struct filter_stream *)data;
#line 44
  if (fs->level < fs->min_level) {
    {
#line 45
    rc = dico_stream_read(fs->transport, (void *)(fs->buf + fs->level), (size_t )(sizeof(fs->buf) - (unsigned long )fs->level),
                          & rdsize);
    }
#line 48
    if (rc) {
#line 49
      return (rc);
    }
#line 50
    fs->level = rdsize;
  }
#line 53
  if (fs->level) {
    {
#line 54
    rc = (*(fs->xcode))((char const   *)(fs->buf), fs->level, buf___1, size, & rdsize);
#line 56
    memmove((void *)(fs->buf), (void const   *)(fs->buf + rc), fs->level - (size_t )rc);
#line 57
    fs->level = (size_t )rc;
#line 58
    *pret = rdsize;
#line 59
    rc = 0;
    }
  } else {
#line 61
    *pret = (size_t )0;
#line 62
    rc = 0;
  }
#line 64
  return (rc);
}
}
#line 67 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_flush(struct filter_stream *fs ) 
{ 
  int tmp ;
  char *buf___1 ;
  size_t level ;
  int rc ;
  size_t rest ;
  size_t len ;
  int skip ;
  char *p ;
  void *tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 70
  if (fs->level == 0U) {
#line 71
    return (0);
  } else
#line 72
  if (fs->max_line_length == 0U) {
    {
#line 73
    tmp = dico_stream_write(fs->transport, (void const   *)(fs->buf), fs->level);
    }
#line 73
    return (tmp);
  } else {
#line 75
    buf___1 = fs->buf;
#line 76
    level = fs->level;
    {
#line 77
    while (1) {
      while_continue: /* CIL Label */ ;
#line 77
      if (! level) {
#line 77
        goto while_break;
      }
      {
#line 79
      rest = fs->max_line_length - fs->line_length;
#line 81
      skip = 0;
#line 82
      tmp___0 = memchr((void const   *)buf___1, '\n', level);
#line 82
      p = (char *)tmp___0;
      }
#line 84
      if (rest > level) {
#line 85
        rest = level;
      }
#line 87
      if (p) {
#line 88
        len = (size_t )(p - buf___1);
#line 89
        if (len > rest) {
#line 90
          len = rest;
        } else {
#line 92
          skip = 1;
        }
      } else {
#line 94
        len = rest;
      }
      {
#line 96
      rc = dico_stream_write(fs->transport, (void const   *)buf___1, len);
      }
#line 97
      if (rc) {
#line 98
        return (1);
      }
#line 99
      fs->line_length += len;
#line 100
      if (fs->line_length == fs->max_line_length) {
        {
#line 101
        fs->line_length = (size_t )0;
#line 102
        rc = dico_stream_write(fs->transport, (void const   *)"\r\n", (size_t )2);
        }
#line 103
        if (rc) {
#line 104
          return (1);
        }
      }
#line 107
      if (skip) {
#line 108
        len ++;
      }
#line 109
      buf___1 += len;
#line 110
      level -= len;
    }
    while_break: /* CIL Label */ ;
    }
#line 112
    fs->level = (size_t )0;
  }
#line 114
  return (0);
}
}
#line 117 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_write0(struct filter_stream *fs , char const   *buf___1 , size_t size ,
                         size_t *pret ) 
{ 
  size_t wrsize ;
  int rc ;

  {
#line 124
  if ((unsigned long )fs->level >= sizeof(fs->buf) - (unsigned long )fs->min_level) {
    {
#line 125
    rc = filter_flush(fs);
    }
#line 126
    if (rc) {
#line 127
      return (rc);
    }
#line 128
    fs->level = (size_t )0;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 132
    rc = (*(fs->xcode))(buf___1, size, fs->buf + fs->level, (size_t )(sizeof(fs->buf) - (unsigned long )fs->level),
                        & wrsize);
    }
#line 134
    if (rc == 0) {
      {
#line 135
      rc = filter_flush(fs);
      }
#line 136
      if (rc) {
#line 137
        return (rc);
      }
#line 138
      fs->level = (size_t )0;
    } else {
#line 140
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  fs->level += wrsize;
#line 143
  *pret = (size_t )rc;
#line 144
  return (0);
}
}
#line 147 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct filter_stream *fs ;
  size_t ret ;
  size_t wrs ;
  int rc ;
  size_t rest ;

  {
#line 150
  fs = (struct filter_stream *)data;
#line 151
  ret = (size_t )0;
#line 155
  if (size < fs->min_level) {
#line 155
    goto _L;
  } else
#line 155
  if (fs->inlevel) {
#line 155
    if (fs->inlevel < fs->min_level) {
      _L: /* CIL Label */ 
#line 157
      rest = fs->min_level - fs->inlevel;
#line 158
      if (rest > size) {
#line 159
        rest = size;
      }
      {
#line 160
      memcpy((void */* __restrict  */)(fs->inbuf + fs->inlevel), (void const   */* __restrict  */)buf___1,
             rest);
#line 161
      fs->inlevel += rest;
      }
#line 162
      if (fs->inlevel < fs->min_level) {
#line 163
        *pret = rest;
#line 164
        return (0);
      }
      {
#line 166
      buf___1 += rest;
#line 167
      size -= rest;
#line 169
      rc = filter_write0(fs, (char const   *)fs->inbuf, fs->inlevel, & wrs);
      }
#line 170
      if (rc) {
#line 171
        return (rc);
      }
#line 172
      if (wrs != fs->inlevel) {
#line 174
        return (1);
      }
#line 176
      fs->inlevel = (size_t )0;
#line 177
      ret = rest;
    }
  }
#line 179
  if (size) {
    {
#line 180
    rc = filter_write0(fs, buf___1, size, & wrs);
    }
  } else {
#line 182
    rc = 0;
#line 183
    wrs = (size_t )0;
  }
#line 185
  if (rc == 0) {
#line 186
    ret += wrs;
#line 187
    *pret = ret;
  }
#line 189
  return (0);
}
}
#line 193 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_wr_flush(void *data ) 
{ 
  struct filter_stream *fs ;
  int rc ;
  int nl ;
  size_t wrs ;
  char *__cil_tmp6 ;

  {
#line 196
  fs = (struct filter_stream *)data;
#line 197
  rc = 0;
#line 199
  if (fs->level) {
    {
#line 200
    nl = (int )fs->buf[fs->level - 1U] == 10;
#line 202
    rc = filter_flush(fs);
    }
#line 203
    if (rc == 0) {
#line 204
      if (fs->inlevel) {
        {
#line 206
        filter_write0(fs, (char const   *)fs->inbuf, fs->inlevel, & wrs);
#line 207
        nl = (int )fs->buf[fs->level - 1U] == 10;
#line 208
        rc = filter_flush(fs);
        }
      }
#line 210
      if (! nl) {
        {
#line 211
        rc = dico_stream_write(fs->transport, (void const   *)"\r\n", (size_t )2);
        }
      }
    }
  }
#line 214
  return (rc);
}
}
#line 217 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
static int filter_stream_destroy(void *data ) 
{ 
  struct filter_stream *fs ;

  {
  {
#line 220
  fs = (struct filter_stream *)data;
#line 221
  free((void *)fs->inbuf);
  }
#line 222
  return (0);
}
}
#line 225 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
dico_stream_t filter_stream_create(dico_stream_t str , size_t min_level , size_t max_line_length ,
                                   int (*xcode)(char const   * , size_t  , char * ,
                                                size_t  , size_t * ) , int mode___0 ) 
{ 
  struct filter_stream *fs ;
  void *tmp ;
  dico_stream_t stream ;
  int rc ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 232
  tmp = malloc((size_t )sizeof(*fs));
#line 232
  fs = (struct filter_stream *)tmp;
  }
#line 236
  if (! fs) {
#line 237
    return ((dico_stream_t )((void *)0));
  }
#line 239
  if (mode___0 == 0) {
#line 239
    tmp___0 = 2;
  } else {
#line 239
    tmp___0 = 1;
  }
  {
#line 239
  rc = dico_stream_create(& stream, tmp___0, (void *)fs);
  }
#line 243
  if (rc) {
    {
#line 244
    free((void *)fs);
    }
#line 245
    return ((dico_stream_t )((void *)0));
  }
#line 248
  if (mode___0 == 0) {
    {
#line 249
    tmp___1 = malloc(min_level);
#line 249
    fs->inbuf = (char *)tmp___1;
    }
#line 250
    if (! fs->inbuf) {
      {
#line 251
      dico_stream_destroy(& stream);
      }
#line 252
      return ((dico_stream_t )((void *)0));
    }
    {
#line 254
    fs->inlevel = (size_t )0;
#line 255
    dico_stream_set_write(stream, & filter_write);
#line 256
    dico_stream_set_flush(stream, & filter_wr_flush);
#line 257
    dico_stream_set_destroy(stream, & filter_stream_destroy);
    }
  } else {
    {
#line 259
    dico_stream_set_read(stream, & filter_read);
    }
  }
#line 262
  fs->transport = str;
#line 263
  fs->level = (size_t )0;
#line 264
  fs->min_level = min_level;
#line 265
  fs->line_length = (size_t )0;
#line 266
  fs->max_line_length = max_line_length;
#line 267
  fs->xcode = xcode;
#line 269
  return (stream);
}
}
#line 272 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fltstream.c"
dico_stream_t dico_codec_stream_create(char const   *encoding , int mode___0 , dico_stream_t transport ) 
{ 
  dico_stream_t str ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 276
  str = (dico_stream_t )((void *)0);
#line 277
  tmp___0 = strcmp(encoding, "base64");
  }
#line 277
  if (tmp___0 == 0) {
    {
#line 278
    str = dico_base64_stream_create(transport, mode___0);
    }
  } else {
    {
#line 279
    tmp = strcmp(encoding, "quoted-printable");
    }
#line 279
    if (tmp == 0) {
      {
#line 280
      str = dico_qp_stream_create(transport, mode___0);
      }
    }
  }
#line 281
  return (str);
}
}
#line 107 "../include/dico/stream.h"
dico_stream_t dico_fd_stream_create(int fd , int flags , int noclose ) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 363
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
static int fd_read(void *data , char *buf___1 , size_t size , size_t *pret ) 
{ 
  struct _stream *p ;
  int n ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 33
  p = (struct _stream *)data;
#line 34
  tmp = read(p->fd, (void *)buf___1, size);
#line 34
  n = tmp;
  }
#line 35
  if (n == -1) {
    {
#line 36
    tmp___0 = __errno_location();
    }
#line 36
    return (*tmp___0);
  }
#line 37
  *pret = (size_t )n;
#line 38
  return (0);
}
}
#line 41 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
static int fd_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct _stream *p ;
  int n ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 44
  p = (struct _stream *)data;
#line 45
  tmp = write(p->fd, (void const   *)((char *)buf___1), size);
#line 45
  n = tmp;
  }
#line 46
  if (n == -1) {
    {
#line 47
    tmp___0 = __errno_location();
    }
#line 47
    return (*tmp___0);
  }
#line 48
  *pret = (size_t )n;
#line 49
  return (0);
}
}
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
static int fd_close(void *data ) 
{ 
  struct _stream *p ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 55
  p = (struct _stream *)data;
#line 56
  tmp___0 = close(p->fd);
  }
#line 56
  if (tmp___0) {
    {
#line 57
    tmp = __errno_location();
    }
#line 57
    return (*tmp);
  }
#line 58
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
int fd_seek(void *data , off_t off , int whence , off_t *presult ) 
{ 
  struct _stream *p ;
  int *tmp ;

  {
  {
#line 64
  p = (struct _stream *)data;
#line 65
  off = lseek(p->fd, off, whence);
  }
#line 66
  if (off <= 0L) {
    {
#line 67
    tmp = __errno_location();
    }
#line 67
    return (*tmp);
  }
#line 68
  *presult = off;
#line 69
  return (0);
}
}
#line 72 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
int fd_size(void *data , off_t *psize ) 
{ 
  struct _stream *p ;
  off_t size ;
  __off_t tmp ;
  int *tmp___0 ;

  {
  {
#line 75
  p = (struct _stream *)data;
#line 76
  tmp = lseek(p->fd, (__off_t )0, 2);
#line 76
  size = tmp;
  }
#line 77
  if (size < 0L) {
    {
#line 78
    tmp___0 = __errno_location();
    }
#line 78
    return (*tmp___0);
  }
#line 79
  *psize = size;
#line 80
  return (0);
}
}
#line 83 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
int fd_destroy(void *data ) 
{ 


  {
  {
#line 86
  free(data);
  }
#line 87
  return (0);
}
}
#line 90 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdstream.c"
dico_stream_t dico_fd_stream_create(int fd , int flags , int noclose ) 
{ 
  int rc ;
  dico_stream_t str ;
  struct _stream *s ;
  void *tmp ;

  {
  {
#line 95
  tmp = malloc((size_t )sizeof(*s));
#line 95
  s = (struct _stream *)tmp;
  }
#line 97
  if (! s) {
#line 98
    return ((dico_stream_t )((void *)0));
  }
  {
#line 99
  rc = dico_stream_create(& str, flags, (void *)s);
  }
#line 100
  if (rc) {
    {
#line 101
    free((void *)s);
    }
#line 102
    return ((dico_stream_t )((void *)0));
  }
  {
#line 104
  s->fd = fd;
#line 105
  dico_stream_set_seek(str, & fd_seek);
#line 106
  dico_stream_set_size(str, & fd_size);
#line 107
  dico_stream_set_write(str, & fd_write);
#line 108
  dico_stream_set_read(str, & fd_read);
  }
#line 109
  if (! noclose) {
    {
#line 110
    dico_stream_set_close(str, & fd_close);
    }
  }
  {
#line 111
  dico_stream_set_destroy(str, & fd_destroy);
  }
#line 112
  return (str);
}
}
#line 108 "../include/dico/stream.h"
dico_stream_t dico_fd_io_stream_create(int ifd , int ofd ) ;
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/fdiostr.c"
dico_stream_t dico_fd_io_stream_create(int ifd , int ofd ) 
{ 
  dico_stream_t in ;
  dico_stream_t out ;
  dico_stream_t str ;

  {
  {
#line 29
  in = dico_fd_stream_create(ifd, 1, 0);
  }
#line 30
  if (! in) {
#line 31
    return ((dico_stream_t )((void *)0));
  }
  {
#line 32
  out = dico_fd_stream_create(ofd, 2, 0);
  }
#line 33
  if (! out) {
    {
#line 34
    dico_stream_destroy(& in);
    }
#line 35
    return ((dico_stream_t )((void *)0));
  }
  {
#line 38
  str = dico_io_stream(in, out);
  }
#line 39
  if (! str) {
    {
#line 40
    dico_stream_destroy(& in);
#line 41
    dico_stream_destroy(& out);
    }
  }
#line 43
  return (str);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 348 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 35 "../include/dico/diag.h"
char const   *dico_program_name  ;
#line 36 "../include/dico/diag.h"
char const   *dico_invocation_name  ;
#line 37
void dico_set_program_name(char *name ) ;
#line 44
void _dico_stderr_log_printer(int lvl , int exitcode , int errcode , char const   *fmt ,
                              va_list ap ) ;
#line 46
void dico_set_log_printer(void (*prt)(int  , int  , int  , char const   * , va_list  ) ) ;
#line 47
void dico_vlog(int lvl , int errcode , char const   *fmt , va_list ap ) ;
#line 50
void ( /* format attribute */  dico_die)(int exitcode , int lvl , int errcode , char const   *fmt 
                                         , ...) ;
#line 52
int dico_str_to_diag_level(char const   *str ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void dico_set_program_name(char *name ) 
{ 
  char const   *progname ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 35
  dico_invocation_name = (char const   *)name;
#line 36
  if (! name) {
#line 37
    progname = (char const   *)name;
  } else {
    {
#line 39
    tmp = strrchr((char const   *)name, '/');
#line 39
    progname = (char const   *)tmp;
    }
#line 40
    if (progname) {
#line 41
      progname ++;
    } else {
#line 43
      progname = (char const   *)name;
    }
    {
#line 45
    tmp___0 = strlen(progname);
    }
#line 45
    if (tmp___0 > 3U) {
      {
#line 45
      tmp___1 = memcmp((void const   *)progname, (void const   *)"lt-", (size_t )3);
      }
#line 45
      if (tmp___1 == 0) {
#line 46
        progname += 3;
      }
    }
  }
#line 49
  dico_program_name = progname;
#line 50
  return;
}
}
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
static char *prefix[8]  = 
#line 52
  {      (char *)"Debug",      (char *)"Info",      (char *)"Notice",      (char *)"Warning", 
        (char *)"Error",      (char *)"CRIT",      (char *)"ALERT",      (char *)"EMERG"};
#line 63 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
int dico_str_to_diag_level(char const   *str ) 
{ 
  int i ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 67
  if ((int const   )*(str + 1) == 0) {
    {
#line 67
    tmp = __ctype_b_loc();
    }
#line 67
    if ((int const   )*(*tmp + (int )*str) & 2048) {
#line 68
      return ((int )((int const   )*str - 48));
    }
  }
#line 69
  i = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((unsigned long )i < sizeof(prefix) / sizeof(prefix[0]))) {
#line 69
      goto while_break;
    }
    {
#line 70
    tmp___0 = strcasecmp((char const   *)prefix[i], str);
    }
#line 70
    if (tmp___0 == 0) {
#line 71
      return (i);
    }
#line 69
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return (-1);
}
}
#line 75 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void _dico_stderr_log_printer(int lvl , int exitcode , int errcode , char const   *fmt ,
                              va_list ap ) 
{ 
  char *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: ",
          dico_program_name, prefix[lvl & 255]);
#line 80
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
  }
#line 81
  if (errcode) {
    {
#line 82
    tmp = strerror(errcode);
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp);
    }
  }
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 84
  return;
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
static void (*_log_printer)(int  , int  , int  , char const   * , va_list  )  =    & _dico_stderr_log_printer;
#line 88 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void dico_set_log_printer(void (*prt)(int  , int  , int  , char const   * , va_list  ) ) 
{ 


  {
#line 91
  _log_printer = prt;
#line 92
  return;
}
}
#line 94 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void dico_vlog(int lvl , int errcode , char const   *fmt , va_list ap ) 
{ 


  {
  {
#line 97
  (*_log_printer)(lvl, 0, errcode, fmt, ap);
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void ( /* format attribute */  dico_log)(int lvl , int errcode , char const   *fmt 
                                         , ...) 
{ 
  va_list ap ;

  {
  {
#line 105
  __builtin_va_start(ap, fmt);
#line 106
  (*_log_printer)(lvl, 0, errcode, fmt, ap);
#line 107
  __builtin_va_end(ap);
  }
#line 108
  return;
}
}
#line 110 "/home/wslee/benchmarks/textformat/dico-2.0/lib/diag.c"
void ( /* format attribute */  dico_die)(int exitcode , int lvl , int errcode , char const   *fmt 
                                         , ...) 
{ 
  va_list ap ;

  {
  {
#line 115
  __builtin_va_start(ap, fmt);
#line 116
  (*_log_printer)(lvl, exitcode, errcode, fmt, ap);
#line 117
  __builtin_va_end(ap);
#line 118
  exit(exitcode);
  }
}
}
#line 55 "../include/dico/diag.h"
dico_stream_t dico_dbg_stream_create(void) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
static char *fmtline(unsigned int num , char *buf___1 , size_t bufsize___1 ) 
{ 
  char *p ;
  unsigned int x ;

  {
#line 39
  p = buf___1 + bufsize___1;
#line 40
  p --;
#line 40
  *p = (char)0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((unsigned long )p > (unsigned long )buf___1)) {
#line 41
      goto while_break;
    }
#line 42
    x = num % 10U;
#line 43
    p --;
#line 43
    *p = (char )(x + 48U);
#line 44
    num /= 10U;
#line 45
    if (num == 0U) {
#line 46
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return (p);
}
}
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
static int dbg_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct dbg_stream *p ;
  char nbuf[128] ;
  char *s ;
  struct timeval tv ;
  size_t tmp ;
  size_t tmp___0 ;
  char *s___0 ;
  char nbuf___0[128] ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 54
  p = (struct dbg_stream *)data;
#line 56
  if (p->ts) {
    {
#line 59
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 60
    dico_stream_write(p->transport, (void const   *)"[", (size_t )1);
#line 61
    s = fmtline((unsigned int )tv.tv_sec, nbuf, (size_t )sizeof(nbuf));
#line 62
    tmp = strlen((char const   *)s);
#line 62
    dico_stream_write(p->transport, (void const   *)s, tmp);
#line 63
    dico_stream_write(p->transport, (void const   *)".", (size_t )1);
#line 64
    s = fmtline((unsigned int )tv.tv_usec, nbuf, (size_t )sizeof(nbuf));
#line 65
    tmp___0 = strlen((char const   *)s);
#line 65
    dico_stream_write(p->transport, (void const   *)s, tmp___0);
#line 66
    dico_stream_write(p->transport, (void const   *)"] ", (size_t )2);
    }
  }
#line 69
  if (p->file) {
    {
#line 73
    tmp___1 = strlen(p->file);
#line 73
    dico_stream_write(p->transport, (void const   *)p->file, tmp___1);
#line 74
    dico_stream_write(p->transport, (void const   *)":", (size_t )1);
#line 75
    s___0 = fmtline(p->line, nbuf___0, (size_t )sizeof(nbuf___0));
#line 76
    tmp___2 = strlen((char const   *)s___0);
#line 76
    dico_stream_write(p->transport, (void const   *)s___0, tmp___2);
#line 77
    dico_stream_write(p->transport, (void const   *)": ", (size_t )2);
    }
  }
  {
#line 79
  dico_stream_write(p->transport, (void const   *)buf___1, size);
  }
#line 81
  if (pret) {
#line 82
    *pret = size;
  }
#line 83
  return (0);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
static int dbg_destroy(void *data ) 
{ 
  struct dbg_stream *p ;

  {
  {
#line 89
  p = (struct dbg_stream *)data;
#line 90
  dico_stream_destroy(& p->transport);
#line 91
  free(data);
  }
#line 92
  return (0);
}
}
#line 95 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
static int dbg_ioctl(void *data , int code___0 , void *call_data ) 
{ 
  struct dbg_stream *p ;
  int *tmp ;

  {
#line 98
  p = (struct dbg_stream *)data;
  {
#line 100
  if (code___0 == 2) {
#line 100
    goto case_2;
  }
#line 104
  if (code___0 == 3) {
#line 104
    goto case_3;
  }
#line 108
  if (code___0 == 4) {
#line 108
    goto case_4;
  }
#line 112
  goto switch_default;
  case_2: /* CIL Label */ 
#line 101
  p->file = (char const   *)call_data;
#line 102
  goto switch_break;
  case_3: /* CIL Label */ 
#line 105
  p->line = *((unsigned int *)call_data);
#line 106
  goto switch_break;
  case_4: /* CIL Label */ 
#line 109
  p->ts = *((int *)call_data);
#line 110
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 113
  tmp = __errno_location();
#line 113
  *tmp = 22;
  }
#line 114
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 116
  return (0);
}
}
#line 119 "/home/wslee/benchmarks/textformat/dico-2.0/lib/dbgstream.c"
dico_stream_t dico_dbg_stream_create(void) 
{ 
  struct dbg_stream *p ;
  void *tmp ;
  dico_stream_t stream ;
  int tmp___0 ;

  {
  {
#line 122
  tmp = malloc((size_t )sizeof(*p));
#line 122
  p = (struct dbg_stream *)tmp;
  }
#line 125
  if (! p) {
#line 126
    return ((dico_stream_t )((void *)0));
  } else {
    {
#line 125
    tmp___0 = dico_stream_create(& stream, 2, (void *)p);
    }
#line 125
    if (tmp___0) {
#line 126
      return ((dico_stream_t )((void *)0));
    }
  }
  {
#line 127
  dico_stream_set_write(stream, & dbg_write);
#line 128
  dico_stream_set_destroy(stream, & dbg_destroy);
#line 129
  dico_stream_set_ioctl(stream, & dbg_ioctl);
#line 130
  dico_stream_set_buffer(stream, (enum dico_buffer_type )1, (size_t )1024);
#line 131
  p->transport = dico_log_stream_create(0);
#line 132
  p->file = (char const   *)((void *)0);
#line 133
  p->line = 0U;
  }
#line 134
  return (stream);
}
}
#line 38 "../include/dico/filter.h"
int dico_base64_input(char c ) ;
#line 40
int dico_base64_decode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                       size_t *pnbytes ) ;
#line 43
int dico_base64_encode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                       size_t *pnbytes ) ;
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
char const   b64_table[64]  = 
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
int dico_base64_input(char c ) 
{ 
  int i ;

  {
#line 31
  i = 0;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    if (! (i < 64)) {
#line 31
      goto while_break;
    }
#line 32
    if ((int const   )b64_table[i] == (int const   )c) {
#line 33
      return (i);
    }
#line 31
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  return (-1);
}
}
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
int dico_base64_decode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                       size_t *pnbytes ) 
{ 
  int i ;
  int tmp ;
  int pad ;
  size_t consumed ;
  unsigned char data[4] ;
  size_t nbytes ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp18 ;

  {
#line 42
  i = 0;
#line 42
  tmp = 0;
#line 42
  pad = 0;
#line 43
  consumed = (size_t )0;
#line 45
  nbytes = (size_t )0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (consumed < isize) {
#line 47
      if (! (nbytes + 3U < osize)) {
#line 47
        goto while_break;
      }
    } else {
#line 47
      goto while_break;
    }
    {
#line 48
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 48
      if (i < 4) {
#line 48
        if (! (consumed < isize)) {
#line 48
          goto while_break___0;
        }
      } else {
#line 48
        goto while_break___0;
      }
      {
#line 49
      tmp___0 = iptr;
#line 49
      iptr ++;
#line 49
      tmp = dico_base64_input((char )*tmp___0);
#line 50
      consumed ++;
      }
#line 51
      if (tmp != -1) {
#line 52
        tmp___1 = i;
#line 52
        i ++;
#line 52
        data[tmp___1] = (unsigned char )tmp;
      } else
#line 53
      if ((int const   )*(iptr - 1) == 61) {
#line 54
        tmp___2 = i;
#line 54
        i ++;
#line 54
        data[tmp___2] = (unsigned char)0;
#line 55
        pad ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 60
    if (i == 4) {
#line 61
      tmp___3 = optr;
#line 61
      optr ++;
#line 61
      *tmp___3 = (char )(((int )data[0] << 2) | (((int )data[1] & 48) >> 4));
#line 62
      tmp___4 = optr;
#line 62
      optr ++;
#line 62
      *tmp___4 = (char )((((int )data[1] & 15) << 4) | (((int )data[2] & 60) >> 2));
#line 63
      tmp___5 = optr;
#line 63
      optr ++;
#line 63
      *tmp___5 = (char )((((int )data[2] & 3) << 6) | (int )data[3]);
#line 64
      nbytes += (size_t )(3 - pad);
    } else {
#line 67
      consumed -= (size_t )i;
#line 68
      goto while_break;
    }
#line 70
    i = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  *pnbytes = nbytes;
#line 73
  return ((int )consumed);
}
}
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
int dico_base64_encode(char const   *iptr , size_t isize , char *optr , size_t osize ,
                       size_t *pnbytes ) 
{ 
  size_t consumed ;
  int pad ;
  unsigned char const   *ptr ;
  size_t nbytes ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char x ;
  unsigned char y ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 81
  consumed = (size_t )0;
#line 82
  pad = 0;
#line 83
  ptr = (unsigned char const   *)iptr;
#line 84
  nbytes = (size_t )0;
#line 86
  if (isize <= 3U) {
#line 87
    pad = 1;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (consumed + 3U <= isize) {
#line 88
      if (! (nbytes + 4U <= osize)) {
#line 88
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 88
    if (! pad) {
#line 88
      goto while_break;
    }
#line 89
    c1 = (unsigned char)0;
#line 89
    c2 = (unsigned char)0;
#line 89
    x = (unsigned char )'=';
#line 89
    y = (unsigned char )'=';
#line 91
    tmp = optr;
#line 91
    optr ++;
#line 91
    *tmp = (char )b64_table[(int const   )*(ptr + 0) >> 2];
#line 92
    consumed ++;
    {
#line 98
    if (isize - consumed == 1U) {
#line 98
      goto case_1;
    }
#line 102
    if (isize - consumed == 0U) {
#line 102
      goto case_0;
    }
#line 94
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 95
    consumed ++;
#line 96
    y = (unsigned char )b64_table[(int const   )*(ptr + 2) & 63];
#line 97
    c2 = (unsigned char )((int const   )*(ptr + 2) >> 6);
    case_1: /* CIL Label */ 
#line 99
    consumed ++;
#line 100
    x = (unsigned char )b64_table[(((int const   )*(ptr + 1) << 2) + (int const   )c2) & 63];
#line 101
    c1 = (unsigned char )((int const   )*(ptr + 1) >> 4);
    case_0: /* CIL Label */ 
#line 103
    tmp___0 = optr;
#line 103
    optr ++;
#line 103
    *tmp___0 = (char )b64_table[(((int const   )*(ptr + 0) << 4) + (int const   )c1) & 63];
#line 104
    tmp___1 = optr;
#line 104
    optr ++;
#line 104
    *tmp___1 = (char )x;
#line 105
    tmp___2 = optr;
#line 105
    optr ++;
#line 105
    *tmp___2 = (char )y;
    switch_break: /* CIL Label */ ;
    }
#line 108
    ptr += 3;
#line 109
    nbytes += 4U;
#line 110
    pad = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  *pnbytes = nbytes;
#line 114
  return ((int )consumed);
}
}
#line 117 "/home/wslee/benchmarks/textformat/dico-2.0/lib/base64.c"
dico_stream_t dico_base64_stream_create(dico_stream_t str , int mode___0 ) 
{ 
  int (*tmp)(char const   *iptr , size_t isize , char *optr , size_t osize , size_t *pnbytes ) ;
  dico_stream_t tmp___0 ;

  {
#line 120
  if (mode___0 == 0) {
#line 120
    tmp = & dico_base64_encode;
  } else {
#line 120
    tmp = & dico_base64_decode;
  }
  {
#line 120
  tmp___0 = filter_stream_create(str, (size_t )3, (size_t )76, tmp, mode___0);
  }
#line 120
  return (tmp___0);
}
}
#line 33 "../include/dico/assoc.h"
dico_assoc_list_t dico_assoc_dup(dico_assoc_list_t src ) ;
#line 35
int dico_assoc_clear(dico_assoc_list_t assoc ) ;
#line 36
int dico_assoc_add(dico_assoc_list_t assoc , char const   *key , char const   *value ,
                   size_t count , int replace ) ;
#line 41
char const   *dico_assoc_find_n(dico_assoc_list_t assoc , char const   *key , size_t n ) ;
#line 44
void dico_assoc_remove_n(dico_assoc_list_t assoc , char const   *key , size_t n ) ;
#line 45
void dico_assoc_remove(dico_assoc_list_t assoc , char const   *key ) ;
#line 47
dico_iterator_t dico_assoc_iterator(dico_assoc_list_t assoc ) ;
#line 34 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
static int assoc_key_cmp(void const   *item , void *data ) 
{ 
  struct dico_assoc  const  *aptr ;
  struct find_closure *clos ;
  int tmp ;

  {
  {
#line 37
  aptr = (struct dico_assoc  const  *)item;
#line 38
  clos = (struct find_closure *)data;
#line 39
  tmp = strcmp((char const   *)aptr->key, clos->str);
  }
#line 39
  if (tmp == 0) {
#line 39
    (clos->count) --;
#line 39
    if (clos->count == 0U) {
#line 40
      return (0);
    }
  }
#line 41
  return (1);
}
}
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
static int assoc_key_cmp_ci(void const   *item , void *data ) 
{ 
  struct dico_assoc  const  *aptr ;
  struct find_closure *clos ;
  int tmp ;

  {
  {
#line 47
  aptr = (struct dico_assoc  const  *)item;
#line 48
  clos = (struct find_closure *)data;
#line 49
  tmp = strcasecmp((char const   *)aptr->key, clos->str);
  }
#line 49
  if (tmp == 0) {
#line 49
    (clos->count) --;
#line 49
    if (clos->count == 0U) {
#line 50
      return (0);
    }
  }
#line 51
  return (1);
}
}
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
static int assoc_free(void *item , void *data ) 
{ 
  struct dico_assoc *a ;

  {
  {
#line 57
  a = (struct dico_assoc *)item;
#line 58
  free((void *)a->value);
#line 59
  free((void *)a);
  }
#line 60
  return (0);
}
}
#line 63 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
dico_assoc_list_t dico_assoc_create(int flags ) 
{ 
  struct dico_assoc_list *assoc ;
  void *tmp ;
  int ec ;
  int *tmp___0 ;
  int *tmp___1 ;
  int (*tmp___2)(void const   *item , void *data ) ;

  {
  {
#line 66
  tmp = malloc((size_t )sizeof(*assoc));
#line 66
  assoc = (struct dico_assoc_list *)tmp;
  }
#line 67
  if (assoc) {
    {
#line 68
    assoc->flags = flags;
#line 69
    assoc->list = dico_list_create();
    }
#line 70
    if (! assoc->list) {
      {
#line 71
      tmp___0 = __errno_location();
#line 71
      ec = *tmp___0;
#line 72
      free((void *)assoc);
#line 73
      assoc = (struct dico_assoc_list *)((void *)0);
#line 74
      tmp___1 = __errno_location();
#line 74
      *tmp___1 = ec;
      }
    } else {
#line 76
      if (flags & 1) {
#line 76
        tmp___2 = & assoc_key_cmp_ci;
      } else {
#line 76
        tmp___2 = & assoc_key_cmp;
      }
      {
#line 76
      dico_list_set_comparator(assoc->list, tmp___2);
#line 79
      dico_list_set_free_item(assoc->list, & assoc_free, (void *)0);
      }
    }
  }
#line 82
  return (assoc);
}
}
#line 85 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
dico_assoc_list_t dico_assoc_dup(dico_assoc_list_t src ) 
{ 
  dico_iterator_t itr ;
  struct dico_assoc *p ;
  dico_assoc_list_t dst ;
  int ec ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int ec___0 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 93
  dst = dico_assoc_create(src->flags);
  }
#line 94
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 95
    return ((dico_assoc_list_t )((void *)0));
  }
  {
#line 97
  itr = dico_assoc_iterator(src);
  }
#line 98
  if (! itr) {
    {
#line 99
    tmp = __errno_location();
#line 99
    ec = *tmp;
#line 100
    dico_assoc_destroy(& dst);
#line 101
    tmp___0 = __errno_location();
#line 101
    *tmp___0 = ec;
    }
#line 102
    return ((dico_assoc_list_t )((void *)0));
  }
  {
#line 105
  tmp___1 = dico_iterator_first(itr);
#line 105
  p = (struct dico_assoc *)tmp___1;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! p) {
#line 105
      goto while_break;
    }
    {
#line 106
    tmp___5 = dico_assoc_append(dst, p->key, (char const   *)p->value);
    }
#line 106
    if (tmp___5) {
      {
#line 107
      tmp___3 = __errno_location();
#line 107
      ec___0 = *tmp___3;
#line 108
      dico_assoc_destroy(& dst);
#line 109
      tmp___4 = __errno_location();
#line 109
      *tmp___4 = ec___0;
      }
#line 110
      goto while_break;
    }
    {
#line 105
    tmp___2 = dico_iterator_next(itr);
#line 105
    p = (struct dico_assoc *)tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  dico_iterator_destroy(& itr);
  }
#line 114
  return (dst);
}
}
#line 118 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
struct dico_assoc *_dico_assoc_find_n(dico_assoc_list_t assoc , char const   *key ,
                                      size_t n ) 
{ 
  struct find_closure clos ;
  void *tmp ;

  {
#line 122
  if (! assoc) {
#line 123
    return ((struct dico_assoc *)((void *)0));
  } else
#line 122
  if (n == 0U) {
#line 123
    return ((struct dico_assoc *)((void *)0));
  }
  {
#line 124
  clos.count = n;
#line 125
  clos.str = key;
#line 126
  tmp = dico_list_locate(assoc->list, (void *)(& clos));
  }
#line 126
  return ((struct dico_assoc *)tmp);
}
}
#line 129 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
char const   *dico_assoc_find_n(dico_assoc_list_t assoc , char const   *key , size_t n ) 
{ 
  struct dico_assoc *kvp ;
  struct dico_assoc *tmp ;
  char *tmp___0 ;

  {
  {
#line 132
  tmp = _dico_assoc_find_n(assoc, key, n);
#line 132
  kvp = tmp;
  }
#line 133
  if (kvp) {
#line 133
    tmp___0 = kvp->value;
  } else {
#line 133
    tmp___0 = (char *)((void *)0);
  }
#line 133
  return ((char const   *)tmp___0);
}
}
#line 136 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
char const   *dico_assoc_find(dico_assoc_list_t assoc , char const   *key ) 
{ 
  char const   *tmp ;

  {
  {
#line 139
  tmp = dico_assoc_find_n(assoc, key, (size_t )1);
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
void dico_assoc_remove_n(dico_assoc_list_t assoc , char const   *key , size_t n ) 
{ 
  struct find_closure clos ;

  {
#line 146
  if (n == 0U) {
#line 147
    return;
  }
  {
#line 148
  clos.count = n;
#line 149
  clos.str = key;
#line 150
  dico_list_remove(assoc->list, (void *)(& clos), (void **)((void *)0));
  }
#line 151
  return;
}
}
#line 153 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
void dico_assoc_remove(dico_assoc_list_t assoc , char const   *key ) 
{ 


  {
  {
#line 156
  dico_assoc_remove_n(assoc, key, (size_t )1);
  }
#line 156
  return;
}
}
#line 159 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
int dico_assoc_add(dico_assoc_list_t assoc , char const   *key , char const   *value ,
                   size_t count , int replace ) 
{ 
  struct dico_assoc *a ;
  size_t size ;
  char *s ;
  char *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int ec ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 166
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 167
    dico_assoc_remove_n(assoc, key, count);
    }
#line 168
    return (0);
  }
#line 171
  if (! (assoc->flags & 2)) {
    {
#line 172
    a = _dico_assoc_find_n(assoc, key, count);
    }
#line 173
    if (a) {
#line 174
      if (replace) {
        {
#line 175
        tmp = strdup(value);
#line 175
        s = tmp;
        }
#line 176
        if (! s) {
#line 177
          return (1);
        }
        {
#line 178
        free((void *)a->value);
#line 179
        a->value = s;
        }
#line 180
        return (0);
      }
      {
#line 182
      tmp___0 = __errno_location();
#line 182
      *tmp___0 = 17;
      }
#line 183
      return (1);
    }
  }
  {
#line 187
  tmp___1 = strlen(key);
#line 187
  size = (size_t )((sizeof(*a) + (unsigned long )tmp___1) + 1UL);
#line 188
  tmp___2 = malloc(size);
#line 188
  a = (struct dico_assoc *)tmp___2;
  }
#line 189
  if (! a) {
#line 190
    return (1);
  }
  {
#line 191
  a->key = (char const   *)((char *)(a + 1));
#line 192
  strcpy((char */* __restrict  */)((char *)a->key), (char const   */* __restrict  */)key);
#line 193
  a->value = strdup(value);
  }
#line 194
  if (! a->value) {
    {
#line 195
    tmp___3 = __errno_location();
#line 195
    ec = *tmp___3;
#line 196
    free((void *)a);
#line 197
    tmp___4 = __errno_location();
#line 197
    *tmp___4 = ec;
    }
#line 198
    return (1);
  }
  {
#line 200
  tmp___5 = dico_list_append(assoc->list, (void *)a);
  }
#line 200
  return (tmp___5);
}
}
#line 203 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
int dico_assoc_append(dico_assoc_list_t assoc , char const   *key , char const   *value ) 
{ 
  int tmp ;

  {
  {
#line 206
  tmp = dico_assoc_add(assoc, key, value, (size_t )1, 0);
  }
#line 206
  return (tmp);
}
}
#line 209 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
int dico_assoc_clear(dico_assoc_list_t assoc ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 212
  if (! assoc) {
    {
#line 213
    tmp = __errno_location();
#line 213
    *tmp = 22;
    }
#line 214
    return (1);
  }
  {
#line 216
  tmp___0 = dico_list_clear(assoc->list);
  }
#line 216
  return (tmp___0);
}
}
#line 219 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
void dico_assoc_destroy(dico_assoc_list_t *passoc ) 
{ 
  dico_assoc_list_t assoc ;

  {
#line 222
  if (passoc) {
#line 222
    if (*passoc) {
      {
#line 223
      assoc = *passoc;
#line 224
      dico_list_destroy(& assoc->list);
#line 225
      free((void *)assoc);
      }
    }
  }
#line 227
  return;
}
}
#line 229 "/home/wslee/benchmarks/textformat/dico-2.0/lib/assoc.c"
dico_iterator_t dico_assoc_iterator(dico_assoc_list_t assoc ) 
{ 
  dico_iterator_t tmp ;

  {
#line 232
  if (! assoc) {
#line 233
    return ((dico_iterator_t )((void *)0));
  }
  {
#line 234
  tmp = dico_list_iterator(assoc->list);
  }
#line 234
  return (tmp);
}
}
#line 363 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 37 "../include/dico/argcv.h"
enum dico_argcv_quoting_style dico_argcv_quoting_style  ;
#line 39
int dico_argcv_get(char const   *command , char const   *delim , char const   *cmnt ,
                   int *argc , char ***argv ) ;
#line 42
int dico_argcv_get_n(char const   *command , int len , char const   *delim , char const   *cmnt ,
                     int *pargc , char ***pargv ) ;
#line 45
int dico_argcv_get_np(char const   *command , int len , char const   *delim , char const   *cmnt ,
                      int flags , int *pargc , char ***pargv , char **endp ) ;
#line 50
int dico_argcv_string(int argc , char const   **argv , char **pstring ) ;
#line 51
void dico_argcv_free(int argc , char **argv ) ;
#line 52
void dico_argv_free(char **argv ) ;
#line 54
int dico_argcv_unquote_char(int c ) ;
#line 55
int dico_argcv_quote_char(int c ) ;
#line 56
size_t dico_argcv_quoted_length(char const   *str , int *quote___0 ) ;
#line 57
void dico_argcv_unquote_copy(char *dst , char const   *src , size_t n ) ;
#line 58
void dico_argcv_quote_copy(char *dst , char const   *src ) ;
#line 59
void dico_argcv_remove(int *pargc , char ***pargv , int (*sel)(char const   * , void * ) ,
                       void *data ) ;
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
static void init_argcv_info(struct argcv_info *ap , int flags , int len , char const   *command ,
                            char const   *delim , char const   *comment ) 
{ 


  {
  {
#line 78
  memset((void *)ap, 0, (size_t )sizeof(*ap));
#line 79
  ap->len = len;
#line 80
  ap->command = command;
#line 81
  ap->delim = delim;
#line 82
  ap->comment = comment;
#line 83
  ap->flags = flags;
  }
#line 84
  return;
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
static int argcv_scan(struct argcv_info *ap ) 
{ 
  int i ;
  int len ;
  char const   *command ;
  char const   *delim ;
  char const   *comment ;
  int j ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 89
  i = 0;
#line 90
  len = ap->len;
#line 91
  command = ap->command;
#line 92
  delim = ap->delim;
#line 93
  comment = ap->comment;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    i = ap->save;
#line 99
    if (i >= len) {
#line 100
      return (i + 1);
    }
    {
#line 103
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 103
      if (i < len) {
#line 103
        if (! ((int const   )*(command + i) == 32)) {
#line 103
          if (! ((int const   )*(command + i) == 9)) {
#line 103
            if (! ((int const   )*(command + i) == 10)) {
#line 103
              goto while_break___0;
            }
          }
        }
      } else {
#line 103
        goto while_break___0;
      }
#line 104
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 105
    ap->start = i;
#line 107
    tmp___1 = strchr(delim, (int )*(command + i));
    }
#line 107
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 137
      if (! (ap->flags & 1)) {
        {
#line 139
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 139
          if (i < len) {
            {
#line 139
            tmp___0 = strchr(delim, (int )*(command + i));
            }
#line 139
            if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 139
              goto while_break___1;
            }
          } else {
#line 139
            goto while_break___1;
          }
#line 140
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 141
        ap->save = i;
#line 142
        goto __Cont;
      }
    } else {
      {
#line 109
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 109
        if (! (i < len)) {
#line 109
          goto while_break___2;
        }
#line 111
        if ((int const   )*(command + i) == 92) {
#line 113
          i ++;
#line 113
          if (i == len) {
#line 114
            goto while_break___2;
          }
#line 115
          i ++;
#line 116
          goto while_continue___2;
        }
#line 119
        if ((int const   )*(command + i) == 39) {
#line 119
          goto _L;
        } else
#line 119
        if ((int const   )*(command + i) == 34) {
          _L: /* CIL Label */ 
#line 122
          j = i + 1;
          {
#line 122
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 122
            if (j < len) {
#line 122
              if (! ((int const   )*(command + j) != (int const   )*(command + i))) {
#line 122
                goto while_break___3;
              }
            } else {
#line 122
              goto while_break___3;
            }
#line 123
            if ((int const   )*(command + j) == 92) {
#line 124
              j ++;
            }
#line 122
            j ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 125
          if (j < len) {
#line 126
            i = j + 1;
          } else {
#line 128
            i ++;
          }
        } else
#line 130
        if ((int const   )*(command + i) == 32) {
#line 131
          goto while_break___2;
        } else
#line 130
        if ((int const   )*(command + i) == 9) {
#line 131
          goto while_break___2;
        } else
#line 130
        if ((int const   )*(command + i) == 10) {
#line 131
          goto while_break___2;
        } else {
          {
#line 130
          tmp = strchr(delim, (int )*(command + i));
          }
#line 130
          if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 131
            goto while_break___2;
          } else {
#line 133
            i ++;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 135
      i --;
    }
#line 146
    ap->end = i;
#line 147
    tmp___2 = i + 1;
#line 147
    ap->finish_pos = tmp___2;
#line 147
    ap->save = tmp___2;
#line 151
    if (ap->save <= len) {
      {
#line 153
      tmp___3 = strchr(comment, (int )*(command + ap->start));
      }
#line 153
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 155
        ap->finish_pos = ap->start;
#line 156
        i = ap->save;
        {
#line 157
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 157
          if (i < len) {
#line 157
            if (! ((int const   )*(command + i) != 10)) {
#line 157
              goto while_break___4;
            }
          } else {
#line 157
            goto while_break___4;
          }
#line 158
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 160
        ap->save = i;
#line 161
        goto __Cont;
      }
    }
#line 164
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return (ap->save);
}
}
#line 169 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
static char quote_transtab[15]  = 
#line 169
  {      (char )'\\',      (char )'\\',      (char )'a',      (char )'\a', 
        (char )'b',      (char )'\b',      (char )'f',      (char )'\f', 
        (char )'n',      (char )'\n',      (char )'r',      (char )'\r', 
        (char )'t',      (char )'\t',      (char )'\000'};
#line 171 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_unquote_char(int c ) 
{ 
  char *p ;

  {
#line 176
  p = quote_transtab;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! *p) {
#line 176
      goto while_break;
    }
#line 178
    if ((int )*p == c) {
#line 179
      return ((int )*(p + 1));
    }
#line 176
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return (c);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_quote_char(int c ) 
{ 
  char *p ;

  {
#line 189
  p = (quote_transtab + sizeof(quote_transtab)) - 2;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! ((unsigned long )p > (unsigned long )(quote_transtab))) {
#line 189
      goto while_break;
    }
#line 192
    if ((int )*p == c) {
#line 193
      return ((int )*(p + -1));
    }
#line 189
    p -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return (-1);
}
}
#line 201 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
static int xtonum(int *pval , char const   *src , int base , int cnt ) 
{ 
  int i ;
  int val ;
  int n ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 206
  i = 0;
#line 206
  val = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < cnt)) {
#line 206
      goto while_break;
    }
#line 208
    n = (int )*((unsigned char *)src);
#line 209
    if (n > 127) {
#line 210
      goto while_break;
    } else {
      {
#line 209
      tmp___4 = __ctype_b_loc();
      }
#line 209
      if ((int const   )*(*tmp___4 + n) & 2048) {
#line 209
        n -= 48;
      } else {
        {
#line 209
        tmp___3 = __ctype_b_loc();
        }
#line 209
        if ((int const   )*(*tmp___3 + n) & 4096) {
          {
#line 209
          tmp___1 = toupper(n);
#line 209
          tmp___2 = (tmp___1 - 65) + 10;
          }
        } else {
#line 209
          tmp___2 = 255;
        }
#line 209
        n = tmp___2;
      }
#line 209
      if (n >= base) {
#line 210
        goto while_break;
      }
    }
#line 211
    val = val * base + n;
#line 206
    i ++;
#line 206
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  *pval = val;
#line 214
  return (i);
}
}
#line 217 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
size_t dico_argcv_quoted_length(char const   *str , int *quote___0 ) 
{ 
  size_t len ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 220
  len = (size_t )0;
#line 222
  if ((int const   )*str == 0) {
#line 223
    *quote___0 = 1;
#line 224
    return ((size_t )0);
  }
#line 226
  *quote___0 = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! *str) {
#line 227
      goto while_break;
    }
#line 229
    if ((int const   )*str == 32) {
#line 231
      len ++;
#line 232
      *quote___0 = 1;
    } else
#line 234
    if ((int const   )*str == 34) {
#line 236
      len += 2U;
#line 237
      *quote___0 = 1;
    } else
#line 239
    if ((int const   )*str != 9) {
#line 239
      if ((int const   )*str != 92) {
        {
#line 239
        tmp___0 = __ctype_b_loc();
        }
#line 239
        if ((int const   )*(*tmp___0 + (int )*str) & 16384) {
#line 240
          len ++;
        } else {
#line 239
          goto _L___0;
        }
      } else {
#line 239
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 245
      if ((unsigned int )dico_argcv_quoting_style == 0U) {
#line 245
        goto case_0;
      }
#line 252
      if ((unsigned int )dico_argcv_quoting_style == 1U) {
#line 252
        goto case_1;
      }
#line 243
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 246
      tmp = dico_argcv_quote_char((int )*str);
      }
#line 246
      if (tmp != -1) {
#line 247
        len += 2U;
      } else {
#line 249
        len += 4U;
      }
#line 250
      goto switch_break;
      case_1: /* CIL Label */ 
#line 253
      len += 3U;
#line 254
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 227
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return (len);
}
}
#line 261 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
void dico_argcv_unquote_copy(char *dst , char const   *src , size_t n ) 
{ 
  int i ;
  int c ;
  int expect_delim ;
  char const   *p ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int off ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int off___0 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned short const   **tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;

  {
#line 264
  i = 0;
#line 266
  expect_delim = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! ((size_t )i < n)) {
#line 268
      goto while_break;
    }
    {
#line 273
    if ((int const   )*(src + i) == 34) {
#line 273
      goto case_34;
    }
#line 273
    if ((int const   )*(src + i) == 39) {
#line 273
      goto case_34;
    }
#line 292
    if ((int const   )*(src + i) == 92) {
#line 292
      goto case_92;
    }
#line 342
    goto switch_default;
    case_34: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 274
    if (! expect_delim) {
#line 278
      p = (src + i) + 1;
      {
#line 278
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 278
        if (*p) {
#line 278
          if (! ((int const   )*p != (int const   )*(src + i))) {
#line 278
            goto while_break___0;
          }
        } else {
#line 278
          goto while_break___0;
        }
#line 279
        if ((int const   )*p == 92) {
#line 280
          p ++;
        }
#line 278
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 281
      if (*p) {
#line 282
        tmp = i;
#line 282
        i ++;
#line 282
        expect_delim = (int )*(src + tmp);
      } else {
#line 284
        tmp___0 = dst;
#line 284
        dst ++;
#line 284
        tmp___1 = i;
#line 284
        i ++;
#line 284
        *tmp___0 = (char )*(src + tmp___1);
      }
    } else
#line 286
    if (expect_delim == (int )*(src + i)) {
#line 287
      i ++;
    } else {
#line 289
      tmp___2 = dst;
#line 289
      dst ++;
#line 289
      tmp___3 = i;
#line 289
      i ++;
#line 289
      *tmp___2 = (char )*(src + tmp___3);
    }
#line 290
    goto switch_break;
    case_92: /* CIL Label */ 
#line 293
    i ++;
#line 294
    if ((int const   )*(src + i) == 120) {
#line 294
      goto _L___0;
    } else
#line 294
    if ((int const   )*(src + i) == 88) {
      _L___0: /* CIL Label */ 
#line 296
      if (n - (size_t )i < 2U) {
#line 298
        tmp___4 = dst;
#line 298
        dst ++;
#line 298
        *tmp___4 = (char )'\\';
#line 299
        tmp___5 = dst;
#line 299
        dst ++;
#line 299
        tmp___6 = i;
#line 299
        i ++;
#line 299
        *tmp___5 = (char )*(src + tmp___6);
      } else {
        {
#line 303
        tmp___7 = xtonum(& c, (src + i) + 1, 16, 2);
#line 303
        off = tmp___7;
        }
#line 304
        if (off == 0) {
#line 306
          tmp___8 = dst;
#line 306
          dst ++;
#line 306
          *tmp___8 = (char )'\\';
#line 307
          tmp___9 = dst;
#line 307
          dst ++;
#line 307
          tmp___10 = i;
#line 307
          i ++;
#line 307
          *tmp___9 = (char )*(src + tmp___10);
        } else {
#line 311
          tmp___11 = dst;
#line 311
          dst ++;
#line 311
          *tmp___11 = (char )c;
#line 312
          i += off + 1;
        }
      }
    } else
#line 316
    if ((int )((unsigned char )*(src + i)) < 128) {
      {
#line 316
      tmp___23 = __ctype_b_loc();
      }
#line 316
      if ((int const   )*(*tmp___23 + (int )*(src + i)) & 2048) {
#line 318
        if (n - (size_t )i < 1U) {
#line 320
          tmp___12 = dst;
#line 320
          dst ++;
#line 320
          *tmp___12 = (char )'\\';
#line 321
          tmp___13 = dst;
#line 321
          dst ++;
#line 321
          tmp___14 = i;
#line 321
          i ++;
#line 321
          *tmp___13 = (char )*(src + tmp___14);
        } else {
          {
#line 325
          tmp___15 = xtonum(& c, src + i, 8, 3);
#line 325
          off___0 = tmp___15;
          }
#line 326
          if (off___0 == 0) {
#line 328
            tmp___16 = dst;
#line 328
            dst ++;
#line 328
            *tmp___16 = (char )'\\';
#line 329
            tmp___17 = dst;
#line 329
            dst ++;
#line 329
            tmp___18 = i;
#line 329
            i ++;
#line 329
            *tmp___17 = (char )*(src + tmp___18);
          } else {
#line 333
            tmp___19 = dst;
#line 333
            dst ++;
#line 333
            *tmp___19 = (char )c;
#line 334
            i += off___0;
          }
        }
      } else {
#line 316
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 339
      tmp___20 = dst;
#line 339
      dst ++;
#line 339
      tmp___21 = i;
#line 339
      i ++;
#line 339
      tmp___22 = dico_argcv_unquote_char((int )*(src + tmp___21));
#line 339
      *tmp___20 = (char )tmp___22;
      }
    }
#line 340
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 343
    tmp___24 = dst;
#line 343
    dst ++;
#line 343
    tmp___25 = i;
#line 343
    i ++;
#line 343
    *tmp___24 = (char )*(src + tmp___25);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *dst = (char)0;
#line 347
  return;
}
}
#line 349 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
void dico_argcv_quote_copy(char *dst , char const   *src ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char tmp___2[4] ;
  int c ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! *src) {
#line 352
      goto while_break;
    }
#line 354
    if ((int const   )*src == 34) {
#line 356
      tmp = dst;
#line 356
      dst ++;
#line 356
      *tmp = (char )'\\';
#line 357
      tmp___0 = dst;
#line 357
      dst ++;
#line 357
      *tmp___0 = (char )*src;
    } else
#line 359
    if ((int const   )*src != 9) {
#line 359
      if ((int const   )*src != 92) {
        {
#line 359
        tmp___6 = __ctype_b_loc();
        }
#line 359
        if ((int const   )*(*tmp___6 + (int )*src) & 16384) {
#line 360
          tmp___1 = dst;
#line 360
          dst ++;
#line 360
          *tmp___1 = (char )*src;
        } else {
#line 359
          goto _L___0;
        }
      } else {
#line 359
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 367
      if ((unsigned int )dico_argcv_quoting_style == 0U) {
#line 367
        goto case_0;
      }
#line 382
      if ((unsigned int )dico_argcv_quoting_style == 1U) {
#line 382
        goto case_1;
      }
#line 365
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 369
      tmp___3 = dico_argcv_quote_char((int )*src);
#line 369
      c = tmp___3;
#line 370
      tmp___4 = dst;
#line 370
      dst ++;
#line 370
      *tmp___4 = (char )'\\';
      }
#line 371
      if (c != -1) {
#line 372
        tmp___5 = dst;
#line 372
        dst ++;
#line 372
        *tmp___5 = (char )c;
      } else {
        {
#line 375
        snprintf((char */* __restrict  */)(tmp___2), (size_t )sizeof(tmp___2), (char const   */* __restrict  */)"%03o",
                 (int )*((unsigned char *)src));
#line 376
        memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(tmp___2),
               (size_t )3);
#line 377
        dst += 3;
        }
      }
#line 379
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 383
      snprintf((char */* __restrict  */)(tmp___2), (size_t )sizeof(tmp___2), (char const   */* __restrict  */)"%%%02X",
               (int )*((unsigned char *)src));
#line 384
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(tmp___2),
             (size_t )3);
#line 385
      dst += 3;
      }
#line 386
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 352
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return;
}
}
#line 392 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_get_np(char const   *command , int len , char const   *delim , char const   *cmnt ,
                      int flags , int *pargc , char ***pargv , char **endp ) 
{ 
  int i ;
  struct argcv_info info ;
  int argc ;
  char **argv ;
  int tmp ;
  void *tmp___0 ;
  int n ;
  int unquote ;
  void *tmp___1 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 398
  i = 0;
#line 403
  if (! delim) {
#line 404
    delim = "";
  }
#line 405
  if (! cmnt) {
#line 406
    cmnt = "";
  }
  {
#line 408
  init_argcv_info(& info, flags, len, command, delim, cmnt);
#line 411
  argc = 0;
  }
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 412
    tmp = argcv_scan(& info);
    }
#line 412
    if (! (tmp <= len)) {
#line 412
      goto while_break;
    }
#line 413
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  tmp___0 = calloc((size_t )(argc + 1), (size_t )sizeof(char *));
#line 415
  argv = (char **)tmp___0;
  }
#line 416
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 417
    return (12);
  }
#line 419
  i = 0;
#line 420
  info.save = 0;
#line 421
  i = 0;
  {
#line 421
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 421
    if (! (i < argc)) {
#line 421
      goto while_break___0;
    }
    {
#line 426
    argcv_scan(& info);
    }
#line 428
    if ((int const   )*(command + info.start) == 34) {
#line 428
      goto _L;
    } else
#line 428
    if ((int const   )*(command + info.end) == 39) {
      _L: /* CIL Label */ 
#line 428
      if ((int const   )*(command + info.end) == (int const   )*(command + info.start)) {
#line 431
        if (info.start < info.end) {
#line 433
          (info.start) ++;
#line 434
          (info.end) --;
        }
#line 436
        unquote = 0;
      } else {
#line 439
        unquote = 1;
      }
    } else {
#line 439
      unquote = 1;
    }
    {
#line 441
    n = (info.end - info.start) + 1;
#line 442
    tmp___1 = calloc((size_t )(n + 1), (size_t )sizeof(char ));
#line 442
    *(argv + i) = (char *)tmp___1;
    }
#line 443
    if ((unsigned long )*(argv + i) == (unsigned long )((void *)0)) {
      {
#line 445
      dico_argcv_free(i, argv);
      }
#line 446
      return (12);
    }
#line 448
    if (unquote) {
      {
#line 449
      dico_argcv_unquote_copy(*(argv + i), command + info.start, (size_t )n);
      }
    } else {
      {
#line 451
      memcpy((void */* __restrict  */)*(argv + i), (void const   */* __restrict  */)(command + info.start),
             (size_t )n);
      }
    }
#line 452
    *(*(argv + i) + n) = (char)0;
#line 421
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 454
  *(argv + i) = (char *)((void *)0);
#line 456
  *pargc = argc;
#line 457
  *pargv = argv;
#line 458
  if (endp) {
#line 459
    *endp = (char *)(command + info.finish_pos);
  }
#line 460
  return (0);
}
}
#line 463 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_get_n(char const   *command , int len , char const   *delim , char const   *cmnt ,
                     int *pargc , char ***pargv ) 
{ 
  int tmp ;

  {
  {
#line 467
  tmp = dico_argcv_get_np(command, len, delim, cmnt, 1, pargc, pargv, (char **)((void *)0));
  }
#line 467
  return (tmp);
}
}
#line 471 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_get(char const   *command , char const   *delim , char const   *cmnt ,
                   int *argc , char ***argv ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 475
  tmp = strlen(command);
#line 475
  tmp___0 = dico_argcv_get_n(command, (int )tmp, delim, cmnt, argc, argv);
  }
#line 475
  return (tmp___0);
}
}
#line 484 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
void dico_argcv_free(int argc , char **argv ) 
{ 


  {
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    argc --;
#line 487
    if (! (argc >= 0)) {
#line 487
      goto while_break;
    }
#line 488
    if (*(argv + argc)) {
      {
#line 489
      free((void *)*(argv + argc));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 490
  free((void *)argv);
  }
#line 491
  return;
}
}
#line 493 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
void dico_argv_free(char **argv ) 
{ 
  int i ;

  {
#line 498
  i = 0;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! *(argv + i)) {
#line 498
      goto while_break;
    }
    {
#line 499
    free((void *)*(argv + i));
#line 498
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 500
  free((void *)argv);
  }
#line 501
  return;
}
}
#line 505 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
int dico_argcv_string(int argc , char const   **argv , char **pstring ) 
{ 
  size_t i ;
  size_t j ;
  size_t len ;
  char *buffer ;
  void *tmp ;
  int quote___0 ;
  int toklen ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 512
  if ((unsigned long )pstring == (unsigned long )((void *)0)) {
#line 513
    return (22);
  }
  {
#line 515
  tmp = malloc((size_t )1);
#line 515
  buffer = (char *)tmp;
  }
#line 516
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 517
    return (12);
  }
#line 518
  *buffer = (char )'\000';
#line 520
  j = (size_t )0;
#line 520
  i = j;
#line 520
  len = i;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! (i < (size_t )argc)) {
#line 520
      goto while_break;
    }
    {
#line 525
    tmp___0 = dico_argcv_quoted_length(*(argv + i), & quote___0);
#line 525
    toklen = (int )tmp___0;
#line 527
    len += (size_t )(toklen + 2);
    }
#line 528
    if (quote___0) {
#line 529
      len += 2U;
    }
    {
#line 531
    tmp___1 = realloc((void *)buffer, len);
#line 531
    buffer = (char *)tmp___1;
    }
#line 532
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 533
      return (12);
    }
#line 535
    if (i != 0U) {
#line 536
      tmp___2 = j;
#line 536
      j ++;
#line 536
      *(buffer + tmp___2) = (char )' ';
    }
#line 537
    if (quote___0) {
#line 538
      tmp___3 = j;
#line 538
      j ++;
#line 538
      *(buffer + tmp___3) = (char )'\"';
    }
    {
#line 539
    dico_argcv_quote_copy(buffer + j, *(argv + i));
#line 540
    j += (size_t )toklen;
    }
#line 541
    if (quote___0) {
#line 542
      tmp___4 = j;
#line 542
      j ++;
#line 542
      *(buffer + tmp___4) = (char )'\"';
    }
#line 520
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 545
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 545
    if (j > 0U) {
      {
#line 545
      tmp___5 = __ctype_b_loc();
      }
#line 545
      if (! ((int const   )*(*tmp___5 + (int )*(buffer + (j - 1U))) & 8192)) {
#line 545
        goto while_break___0;
      }
    } else {
#line 545
      goto while_break___0;
    }
#line 545
    j --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 547
  *(buffer + j) = (char)0;
#line 548
  if (pstring) {
#line 549
    *pstring = buffer;
  }
#line 550
  return (0);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dico-2.0/lib/argcv.c"
void dico_argcv_remove(int *pargc , char ***pargv , int (*sel)(char const   * , void * ) ,
                       void *data ) 
{ 
  int i ;
  int j ;
  int argc ;
  char **argv ;
  int cnt ;
  int tmp ;

  {
#line 558
  argc = *pargc;
#line 559
  argv = *pargv;
#line 560
  cnt = 0;
#line 562
  j = 0;
#line 562
  i = j;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! (i < argc)) {
#line 562
      goto while_break;
    }
    {
#line 564
    tmp = (*sel)((char const   *)*(argv + i), data);
    }
#line 564
    if (tmp) {
      {
#line 566
      free((void *)*(argv + i));
#line 567
      cnt ++;
      }
    } else {
#line 571
      if (i != j) {
#line 572
        *(argv + j) = *(argv + i);
      }
#line 573
      j ++;
    }
#line 562
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  if (i != j) {
#line 577
    *(argv + j) = (char *)((void *)0);
  }
#line 578
  argc -= cnt;
#line 580
  *pargc = argc;
#line 581
  *pargv = argv;
#line 582
  return;
}
}
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 25
  dico_die(1, 5, 0, "Not enough memory");
  }
#line 26
  return;
}
}
#line 57 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xalloc.h"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 58
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 59
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 60
void *xrealloc(void *p , size_t n ) ;
#line 61
void *x2realloc(void *p , size_t *pn ) ;
#line 62
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 63
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 196 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 199
  n = *pn;
#line 201
  if (! p) {
#line 203
    if (! n) {
#line 211
      n = 64U / s;
#line 212
      n += (size_t )(! n);
    }
  } else {
#line 221
    if (2863311530U / s <= n) {
      {
#line 222
      xalloc_die();
      }
    }
#line 223
    n += (n + 1U) / 2U;
  }
  {
#line 226
  *pn = n;
#line 227
  tmp = xrealloc(p, n * s);
  }
#line 227
  return (tmp);
}
}
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 47
  tmp = malloc(n);
#line 47
  p = tmp;
  }
#line 48
  if (! p) {
#line 48
    if (n != 0U) {
      {
#line 49
      xalloc_die();
      }
    }
  }
#line 50
  return (p);
}
}
#line 56 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
  {
#line 59
  p = realloc(p, n);
  }
#line 60
  if (! p) {
#line 60
    if (n != 0U) {
      {
#line 61
      xalloc_die();
      }
    }
  }
#line 62
  return (p);
}
}
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 74
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 74
  return (tmp);
}
}
#line 81
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 81 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 84
  tmp = xmalloc(s);
#line 84
  tmp___0 = memset(tmp, 0, s);
  }
#line 84
  return (tmp___0);
}
}
#line 90
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 90 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 98
  p = calloc(n, s);
  }
#line 98
  if (! p) {
    {
#line 100
    xalloc_die();
    }
  }
#line 101
  return (p);
}
}
#line 108
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 108 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 111
  tmp = xmalloc(s);
#line 111
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 111
  return (tmp___0);
}
}
#line 116
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 116 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 119
  tmp = strlen(string);
#line 119
  tmp___0 = xmemdup((void const   *)string, tmp + 1U);
  }
#line 119
  return ((char *)tmp___0);
}
}
#line 3 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xgethostname.h"
char *xgethostname(void) ;
#line 895 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xgethostname.c"
char *xgethostname(void) 
{ 
  char *hostname___0 ;
  size_t size ;
  size_t size_1 ;
  void *tmp ;
  int *tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 48
  hostname___0 = (char *)((void *)0);
#line 49
  size = (size_t )34;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 58
    tmp = x2realloc((void *)hostname___0, & size);
#line 58
    hostname___0 = (char *)tmp;
#line 59
    size_1 = size - 1U;
#line 60
    *(hostname___0 + (size_1 - 1U)) = (char )'\000';
#line 61
    tmp___0 = __errno_location();
#line 61
    *tmp___0 = 0;
#line 63
    tmp___7 = gethostname(hostname___0, size_1);
    }
#line 63
    if (tmp___7 == 0) {
#line 65
      if (! *(hostname___0 + (size_1 - 1U))) {
#line 66
        goto while_break;
      }
    } else {
      {
#line 68
      tmp___3 = __errno_location();
      }
#line 68
      if (*tmp___3 != 0) {
        {
#line 68
        tmp___4 = __errno_location();
        }
#line 68
        if (*tmp___4 != 36) {
          {
#line 68
          tmp___5 = __errno_location();
          }
#line 68
          if (*tmp___5 != 22) {
            {
#line 68
            tmp___6 = __errno_location();
            }
#line 68
            if (*tmp___6 != 12) {
              {
#line 72
              tmp___1 = __errno_location();
#line 72
              saved_errno = *tmp___1;
#line 73
              free((void *)hostname___0);
#line 74
              tmp___2 = __errno_location();
#line 74
              *tmp___2 = saved_errno;
              }
#line 75
              return ((char *)((void *)0));
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (hostname___0);
}
}
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xgetdomainname.h"
char *xgetdomainname(void) ;
#line 913 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) getdomainname)(char *__name ,
                                                                                          size_t __len ) ;
#line 49 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xgetdomainname.c"
char *xgetdomainname(void) 
{ 
  char *domainname ;
  size_t size ;
  void *tmp ;
  int k ;
  int err ;
  int *tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 55
  size = (size_t )34;
#line 56
  tmp = xmalloc(size);
#line 56
  domainname = (char *)tmp;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    k = (int )(size - 1U);
#line 62
    tmp___0 = __errno_location();
#line 62
    *tmp___0 = 0;
#line 63
    *(domainname + k) = (char )'\000';
#line 64
    err = getdomainname(domainname, size);
    }
#line 65
    if (err >= 0) {
#line 65
      if ((int )*(domainname + k) == 0) {
#line 66
        goto while_break;
      } else {
#line 65
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 67
    if (err < 0) {
      {
#line 67
      tmp___3 = __errno_location();
      }
#line 67
      if (*tmp___3 != 22) {
        {
#line 69
        tmp___1 = __errno_location();
#line 69
        saved_errno = *tmp___1;
#line 70
        free((void *)domainname);
#line 71
        tmp___2 = __errno_location();
#line 71
        *tmp___2 = saved_errno;
        }
#line 72
        return ((char *)((void *)0));
      }
    }
    {
#line 74
    size *= 2U;
#line 75
    tmp___4 = xrealloc((void *)domainname, size);
#line 75
    domainname = (char *)tmp___4;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (domainname);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/vasnprintf.h"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) ;
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 176 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 60
  sum = size1 + size2;
#line 61
  if (sum >= size1) {
#line 61
    tmp = sum;
  } else {
#line 61
    tmp = 4294967295U;
  }
#line 61
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 75 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 81
  tmp = xsum(size1, size2);
#line 81
  tmp___0 = xsum((size_t )tmp, size3);
#line 81
  tmp___1 = xsum((size_t )tmp___0, size4);
  }
#line 81
  return (tmp___1);
}
}
#line 85 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xsize.h"
__inline static size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 93
  if (size1 >= size2) {
#line 93
    tmp = size1;
  } else {
#line 93
    tmp = size2;
  }
#line 93
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 1479 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/vasnprintf.c"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf___1 ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  unsigned long tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  arg_type type ;
  int flags ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  size_t n___0 ;
  char const   *mp ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  size_t n___1 ;
  char const   *mp___0 ;
  char *tmp___25 ;
  char const   *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___32 ;
  size_t __attribute__((__pure__))  tmp___33 ;
  size_t __attribute__((__pure__))  tmp___34 ;
  void *tmp___35 ;
  void *tmp___36 ;
  size_t __attribute__((__pure__))  tmp___37 ;
  int count ;
  int retcount ;
  size_t maxlen ;
  int arg ;
  unsigned int arg___0 ;
  int arg___1 ;
  unsigned int arg___2 ;
  int arg___3 ;
  unsigned int arg___4 ;
  long arg___5 ;
  unsigned long arg___6 ;
  long long arg___7 ;
  unsigned long long arg___8 ;
  double arg___9 ;
  long double arg___10 ;
  int arg___11 ;
  wint_t arg___12 ;
  char const   *arg___13 ;
  wchar_t const   *arg___14 ;
  void *arg___15 ;
  size_t bigger_need ;
  size_t tmp___38 ;
  size_t __attribute__((__pure__))  tmp___39 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  int *tmp___43 ;
  size_t n___2 ;
  size_t tmp___44 ;
  size_t __attribute__((__pure__))  tmp___45 ;
  size_t __attribute__((__pure__))  tmp___46 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  void *tmp___49 ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t tmp___50 ;
  size_t __attribute__((__pure__))  tmp___51 ;
  size_t __attribute__((__pure__))  tmp___52 ;
  void *tmp___53 ;
  void *tmp___54 ;
  size_t __attribute__((__pure__))  tmp___55 ;
  char *memory___5 ;
  void *tmp___56 ;
  int *tmp___57 ;
  int *tmp___58 ;
  void *__cil_tmp124 ;

  {
  {
#line 1486
  tmp = printf_parse(format, & d, & a);
  }
#line 1486
  if (tmp < 0) {
#line 1488
    return ((char *)((void *)0));
  }
  {
#line 1495
  tmp___1 = printf_fetchargs(args, & a);
  }
#line 1495
  if (tmp___1 < 0) {
    {
#line 1497
    free((void *)d.dir);
    }
#line 1497
    if (a.arg) {
      {
#line 1497
      free((void *)a.arg);
      }
    }
    {
#line 1498
    tmp___0 = __errno_location();
#line 1498
    *tmp___0 = 22;
    }
#line 1499
    return ((char *)((void *)0));
  }
  {
#line 1516
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1516
  buf_neededlength = (size_t )tmp___2;
  }
#line 1519
  if ((unsigned long )buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1521
    tmp___3 = __builtin_alloca((unsigned long )buf_neededlength * sizeof(char ));
#line 1521
    buf___1 = (char *)tmp___3;
#line 1522
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1527
    if ((unsigned long )buf_neededlength <= 4294967295UL / sizeof(char )) {
#line 1527
      tmp___4 = (unsigned long )buf_neededlength * sizeof(char );
    } else {
#line 1527
      tmp___4 = 4294967295UL;
    }
#line 1527
    buf_memsize = (size_t )tmp___4;
#line 1528
    if (buf_memsize == 4294967295U) {
#line 1529
      goto out_of_memory_1;
    }
    {
#line 1530
    tmp___5 = malloc(buf_memsize);
#line 1530
    buf___1 = (char *)tmp___5;
    }
#line 1531
    if ((unsigned long )buf___1 == (unsigned long )((void *)0)) {
#line 1532
      goto out_of_memory_1;
    }
#line 1533
    buf_malloced = buf___1;
  }
#line 1536
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1538
    result = resultbuf;
#line 1539
    allocated = *lengthp;
  } else {
#line 1543
    result = (char *)((void *)0);
#line 1544
    allocated = (size_t )0;
  }
#line 1546
  length = (size_t )0;
#line 1576
  cp = format;
#line 1576
  i = (size_t )0;
#line 1576
  dp = d.dir + 0;
  {
#line 1576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1578
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      {
#line 1580
      n = (size_t )(dp->dir_start - cp);
#line 1581
      tmp___6 = xsum(length, n);
#line 1581
      augmented_length = (size_t )tmp___6;
      }
#line 1583
      if (augmented_length > allocated) {
#line 1583
        if (allocated > 0U) {
#line 1583
          if (allocated <= 2147483647U) {
#line 1583
            tmp___7 = allocated * 2U;
          } else {
#line 1583
            tmp___7 = 4294967295U;
          }
#line 1583
          allocated = tmp___7;
        } else {
#line 1583
          allocated = (size_t )12;
        }
#line 1583
        if (augmented_length > allocated) {
#line 1583
          allocated = augmented_length;
        }
#line 1583
        if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 1583
          memory_size = (size_t )((unsigned long )allocated * sizeof(char ));
        } else {
#line 1583
          memory_size = 4294967295U;
        }
#line 1583
        if (memory_size == 4294967295U) {
#line 1583
          goto out_of_memory;
        }
#line 1583
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1583
          tmp___8 = malloc(memory_size);
#line 1583
          memory = (char *)tmp___8;
          }
        } else
#line 1583
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1583
          tmp___8 = malloc(memory_size);
#line 1583
          memory = (char *)tmp___8;
          }
        } else {
          {
#line 1583
          tmp___9 = realloc((void *)result, memory_size);
#line 1583
          memory = (char *)tmp___9;
          }
        }
#line 1583
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1583
          goto out_of_memory;
        }
#line 1583
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1583
          if (length > 0U) {
            {
#line 1583
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1583
        result = memory;
      }
#line 1587
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1589
        memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)cp,
               n);
#line 1590
        length = augmented_length;
        }
      } else {
        {
#line 1594
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1595
          tmp___10 = length;
#line 1595
          length ++;
#line 1595
          tmp___11 = cp;
#line 1595
          cp ++;
#line 1595
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
#line 1594
          n --;
#line 1594
          if (! (n > 0U)) {
#line 1594
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1599
    if (i == d.count) {
#line 1600
      goto while_break;
    }
#line 1603
    if ((int )dp->conversion == 37) {
#line 1607
      if (! (dp->arg_index == 4294967295U)) {
        {
#line 1608
        abort();
        }
      }
      {
#line 1609
      tmp___12 = xsum(length, (size_t )1);
#line 1609
      augmented_length___0 = (size_t )tmp___12;
      }
#line 1610
      if (augmented_length___0 > allocated) {
#line 1610
        if (allocated > 0U) {
#line 1610
          if (allocated <= 2147483647U) {
#line 1610
            tmp___13 = allocated * 2U;
          } else {
#line 1610
            tmp___13 = 4294967295U;
          }
#line 1610
          allocated = tmp___13;
        } else {
#line 1610
          allocated = (size_t )12;
        }
#line 1610
        if (augmented_length___0 > allocated) {
#line 1610
          allocated = augmented_length___0;
        }
#line 1610
        if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 1610
          memory_size___0 = (size_t )((unsigned long )allocated * sizeof(char ));
        } else {
#line 1610
          memory_size___0 = 4294967295U;
        }
#line 1610
        if (memory_size___0 == 4294967295U) {
#line 1610
          goto out_of_memory;
        }
#line 1610
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1610
          tmp___14 = malloc(memory_size___0);
#line 1610
          memory___0 = (char *)tmp___14;
          }
        } else
#line 1610
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1610
          tmp___14 = malloc(memory_size___0);
#line 1610
          memory___0 = (char *)tmp___14;
          }
        } else {
          {
#line 1610
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1610
          memory___0 = (char *)tmp___15;
          }
        }
#line 1610
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1610
          goto out_of_memory;
        }
#line 1610
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1610
          if (length > 0U) {
            {
#line 1610
            memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1610
        result = memory___0;
      }
#line 1611
      *(result + length) = (char )'%';
#line 1612
      length = augmented_length___0;
    } else {
#line 1616
      if (! (dp->arg_index != 4294967295U)) {
        {
#line 1617
        abort();
        }
      }
#line 1619
      if ((int )dp->conversion == 110) {
        {
#line 1623
        if ((unsigned int )(a.arg + dp->arg_index)->type == 18U) {
#line 1623
          goto case_18;
        }
#line 1626
        if ((unsigned int )(a.arg + dp->arg_index)->type == 19U) {
#line 1626
          goto case_19;
        }
#line 1629
        if ((unsigned int )(a.arg + dp->arg_index)->type == 20U) {
#line 1629
          goto case_20;
        }
#line 1632
        if ((unsigned int )(a.arg + dp->arg_index)->type == 21U) {
#line 1632
          goto case_21;
        }
#line 1636
        if ((unsigned int )(a.arg + dp->arg_index)->type == 22U) {
#line 1636
          goto case_22;
        }
#line 1640
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1624
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1625
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1627
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1628
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1630
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1631
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1633
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1634
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1637
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1638
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1641
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 4305
        type = (a.arg + dp->arg_index)->type;
#line 4306
        flags = dp->flags;
#line 4702
        fbp = buf___1;
#line 4703
        tmp___16 = fbp;
#line 4703
        fbp ++;
#line 4703
        *tmp___16 = (char )'%';
#line 4709
        if (flags & 1) {
#line 4710
          tmp___17 = fbp;
#line 4710
          fbp ++;
#line 4710
          *tmp___17 = (char )'\'';
        }
#line 4712
        if (flags & 2) {
#line 4713
          tmp___18 = fbp;
#line 4713
          fbp ++;
#line 4713
          *tmp___18 = (char )'-';
        }
#line 4714
        if (flags & 4) {
#line 4715
          tmp___19 = fbp;
#line 4715
          fbp ++;
#line 4715
          *tmp___19 = (char )'+';
        }
#line 4716
        if (flags & 8) {
#line 4717
          tmp___20 = fbp;
#line 4717
          fbp ++;
#line 4717
          *tmp___20 = (char )' ';
        }
#line 4718
        if (flags & 16) {
#line 4719
          tmp___21 = fbp;
#line 4719
          fbp ++;
#line 4719
          *tmp___21 = (char )'#';
        }
#line 4722
        if (flags & 32) {
#line 4723
          tmp___22 = fbp;
#line 4723
          fbp ++;
#line 4723
          *tmp___22 = (char )'0';
        }
#line 4724
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4726
          n___0 = (size_t )(dp->width_end - dp->width_start);
#line 4729
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4731
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->width_start,
                   (size_t )((unsigned long )n___0 * sizeof(char )));
#line 4732
            fbp += n___0;
            }
          } else {
#line 4736
            mp = dp->width_start;
            {
#line 4737
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4738
              tmp___23 = fbp;
#line 4738
              fbp ++;
#line 4738
              tmp___24 = mp;
#line 4738
              mp ++;
#line 4738
              *tmp___23 = (char )((unsigned char )*tmp___24);
#line 4737
              n___0 --;
#line 4737
              if (! (n___0 > 0U)) {
#line 4737
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 4745
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4747
          n___1 = (size_t )(dp->precision_end - dp->precision_start);
#line 4750
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4752
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->precision_start,
                   (size_t )((unsigned long )n___1 * sizeof(char )));
#line 4753
            fbp += n___1;
            }
          } else {
#line 4757
            mp___0 = dp->precision_start;
            {
#line 4758
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 4759
              tmp___25 = fbp;
#line 4759
              fbp ++;
#line 4759
              tmp___26 = mp___0;
#line 4759
              mp___0 ++;
#line 4759
              *tmp___25 = (char )((unsigned char )*tmp___26);
#line 4758
              n___1 --;
#line 4758
              if (! (n___1 > 0U)) {
#line 4758
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
        {
#line 4769
        if ((unsigned int )type == 10U) {
#line 4769
          goto case_10;
        }
#line 4769
        if ((unsigned int )type == 9U) {
#line 4769
          goto case_10;
        }
#line 4786
        if ((unsigned int )type == 16U) {
#line 4786
          goto case_16;
        }
#line 4786
        if ((unsigned int )type == 14U) {
#line 4786
          goto case_16;
        }
#line 4786
        if ((unsigned int )type == 8U) {
#line 4786
          goto case_16;
        }
#line 4786
        if ((unsigned int )type == 7U) {
#line 4786
          goto case_16;
        }
#line 4790
        if ((unsigned int )type == 12U) {
#line 4790
          goto case_12;
        }
#line 4793
        goto switch_default___0;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 4776
        tmp___27 = fbp;
#line 4776
        fbp ++;
#line 4776
        *tmp___27 = (char )'l';
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
#line 4788
        tmp___28 = fbp;
#line 4788
        fbp ++;
#line 4788
        *tmp___28 = (char )'l';
#line 4789
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4791
        tmp___29 = fbp;
#line 4791
        fbp ++;
#line 4791
        *tmp___29 = (char )'L';
#line 4792
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4794
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4801
        *fbp = dp->conversion;
#line 4831
        *(fbp + 1) = (char )'\000';
#line 4838
        prefix_count = 0U;
#line 4839
        if (dp->width_arg_index != 4294967295U) {
#line 4841
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4842
            abort();
            }
          }
#line 4843
          tmp___30 = prefix_count;
#line 4843
          prefix_count ++;
#line 4843
          prefixes[tmp___30] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4845
        if (dp->precision_arg_index != 4294967295U) {
#line 4847
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4848
            abort();
            }
          }
#line 4849
          tmp___31 = prefix_count;
#line 4849
          prefix_count ++;
#line 4849
          prefixes[tmp___31] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4861
        tmp___37 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
        }
#line 4861
        if (tmp___37 > (size_t __attribute__((__pure__))  )allocated) {
#line 4861
          if (allocated > 0U) {
#line 4861
            if (allocated <= 2147483647U) {
#line 4861
              tmp___32 = allocated * 2U;
            } else {
#line 4861
              tmp___32 = 4294967295U;
            }
#line 4861
            allocated = tmp___32;
          } else {
#line 4861
            allocated = (size_t )12;
          }
          {
#line 4861
          tmp___34 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
          }
#line 4861
          if (tmp___34 > (size_t __attribute__((__pure__))  )allocated) {
            {
#line 4861
            tmp___33 = xsum(length, (size_t )(((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
#line 4861
            allocated = (size_t )tmp___33;
            }
          }
#line 4861
          if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 4861
            memory_size___1 = (size_t )((unsigned long )allocated * sizeof(char ));
          } else {
#line 4861
            memory_size___1 = 4294967295U;
          }
#line 4861
          if (memory_size___1 == 4294967295U) {
#line 4861
            goto out_of_memory;
          }
#line 4861
          if ((unsigned long )result == (unsigned long )resultbuf) {
            {
#line 4861
            tmp___35 = malloc(memory_size___1);
#line 4861
            memory___1 = (char *)tmp___35;
            }
          } else
#line 4861
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
#line 4861
            tmp___35 = malloc(memory_size___1);
#line 4861
            memory___1 = (char *)tmp___35;
            }
          } else {
            {
#line 4861
            tmp___36 = realloc((void *)result, memory_size___1);
#line 4861
            memory___1 = (char *)tmp___36;
            }
          }
#line 4861
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 4861
            goto out_of_memory;
          }
#line 4861
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4861
            if (length > 0U) {
              {
#line 4861
              memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)result,
                     length);
              }
            }
          }
#line 4861
          result = memory___1;
        }
#line 4866
        *(result + length) = (char )'\000';
        {
#line 4869
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4871
          count = -1;
#line 4874
          retcount = 0;
#line 4875
          maxlen = allocated - length;
#line 4878
          if ((unsigned long )maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4879
            maxlen = (size_t )(2147483647UL / (sizeof(char ) / sizeof(char )));
          }
#line 4880
          maxlen = (size_t )((unsigned long )maxlen * (sizeof(char ) / sizeof(char )));
          {
#line 4924
          if ((unsigned int )type == 1U) {
#line 4924
            goto case_1;
          }
#line 4930
          if ((unsigned int )type == 2U) {
#line 4930
            goto case_2___0;
          }
#line 4936
          if ((unsigned int )type == 3U) {
#line 4936
            goto case_3;
          }
#line 4942
          if ((unsigned int )type == 4U) {
#line 4942
            goto case_4;
          }
#line 4948
          if ((unsigned int )type == 5U) {
#line 4948
            goto case_5;
          }
#line 4954
          if ((unsigned int )type == 6U) {
#line 4954
            goto case_6;
          }
#line 4960
          if ((unsigned int )type == 7U) {
#line 4960
            goto case_7___0;
          }
#line 4966
          if ((unsigned int )type == 8U) {
#line 4966
            goto case_8___0;
          }
#line 4973
          if ((unsigned int )type == 9U) {
#line 4973
            goto case_9___0;
          }
#line 4979
          if ((unsigned int )type == 10U) {
#line 4979
            goto case_10___0;
          }
#line 4986
          if ((unsigned int )type == 11U) {
#line 4986
            goto case_11;
          }
#line 4992
          if ((unsigned int )type == 12U) {
#line 4992
            goto case_12___0;
          }
#line 4998
          if ((unsigned int )type == 13U) {
#line 4998
            goto case_13;
          }
#line 5005
          if ((unsigned int )type == 14U) {
#line 5005
            goto case_14___0;
          }
#line 5012
          if ((unsigned int )type == 15U) {
#line 5012
            goto case_15;
          }
#line 5019
          if ((unsigned int )type == 16U) {
#line 5019
            goto case_16___0;
          }
#line 5026
          if ((unsigned int )type == 17U) {
#line 5026
            goto case_17;
          }
#line 5032
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 4926
          arg = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 4927
          if (prefix_count == 0U) {
#line 4927
            goto case_0;
          }
#line 4927
          if (prefix_count == 1U) {
#line 4927
            goto case_1___0;
          }
#line 4927
          if (prefix_count == 2U) {
#line 4927
            goto case_2;
          }
#line 4927
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 4927
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg, & count);
          }
#line 4927
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 4927
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg, & count);
          }
#line 4927
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 4927
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg, & count);
          }
#line 4927
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 4927
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }
#line 4929
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 4932
          arg___0 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 4933
          if (prefix_count == 0U) {
#line 4933
            goto case_0___0;
          }
#line 4933
          if (prefix_count == 1U) {
#line 4933
            goto case_1___1;
          }
#line 4933
          if (prefix_count == 2U) {
#line 4933
            goto case_2___1;
          }
#line 4933
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 4933
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___0, & count);
          }
#line 4933
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 4933
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___0, & count);
          }
#line 4933
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 4933
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___0, & count);
          }
#line 4933
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 4933
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }
#line 4935
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 4938
          arg___1 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 4939
          if (prefix_count == 0U) {
#line 4939
            goto case_0___1;
          }
#line 4939
          if (prefix_count == 1U) {
#line 4939
            goto case_1___2;
          }
#line 4939
          if (prefix_count == 2U) {
#line 4939
            goto case_2___2;
          }
#line 4939
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 4939
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___1, & count);
          }
#line 4939
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 4939
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___1, & count);
          }
#line 4939
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 4939
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___1, & count);
          }
#line 4939
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 4939
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }
#line 4941
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 4944
          arg___2 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 4945
          if (prefix_count == 0U) {
#line 4945
            goto case_0___2;
          }
#line 4945
          if (prefix_count == 1U) {
#line 4945
            goto case_1___3;
          }
#line 4945
          if (prefix_count == 2U) {
#line 4945
            goto case_2___3;
          }
#line 4945
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 4945
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___2, & count);
          }
#line 4945
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 4945
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___2, & count);
          }
#line 4945
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 4945
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___2, & count);
          }
#line 4945
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 4945
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }
#line 4947
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 4950
          arg___3 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 4951
          if (prefix_count == 0U) {
#line 4951
            goto case_0___3;
          }
#line 4951
          if (prefix_count == 1U) {
#line 4951
            goto case_1___4;
          }
#line 4951
          if (prefix_count == 2U) {
#line 4951
            goto case_2___4;
          }
#line 4951
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 4951
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___3, & count);
          }
#line 4951
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 4951
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___3, & count);
          }
#line 4951
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 4951
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___3, & count);
          }
#line 4951
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 4951
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }
#line 4953
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 4956
          arg___4 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 4957
          if (prefix_count == 0U) {
#line 4957
            goto case_0___4;
          }
#line 4957
          if (prefix_count == 1U) {
#line 4957
            goto case_1___5;
          }
#line 4957
          if (prefix_count == 2U) {
#line 4957
            goto case_2___5;
          }
#line 4957
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 4957
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___4, & count);
          }
#line 4957
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 4957
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___4, & count);
          }
#line 4957
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 4957
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___4, & count);
          }
#line 4957
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 4957
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }
#line 4959
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 4962
          arg___5 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 4963
          if (prefix_count == 0U) {
#line 4963
            goto case_0___5;
          }
#line 4963
          if (prefix_count == 1U) {
#line 4963
            goto case_1___6;
          }
#line 4963
          if (prefix_count == 2U) {
#line 4963
            goto case_2___6;
          }
#line 4963
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 4963
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___5, & count);
          }
#line 4963
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 4963
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___5, & count);
          }
#line 4963
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 4963
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___5, & count);
          }
#line 4963
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 4963
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }
#line 4965
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 4968
          arg___6 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 4969
          if (prefix_count == 0U) {
#line 4969
            goto case_0___6;
          }
#line 4969
          if (prefix_count == 1U) {
#line 4969
            goto case_1___7;
          }
#line 4969
          if (prefix_count == 2U) {
#line 4969
            goto case_2___7;
          }
#line 4969
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 4969
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___6, & count);
          }
#line 4969
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 4969
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___6, & count);
          }
#line 4969
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 4969
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___6, & count);
          }
#line 4969
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 4969
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }
#line 4971
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 4975
          arg___7 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 4976
          if (prefix_count == 0U) {
#line 4976
            goto case_0___7;
          }
#line 4976
          if (prefix_count == 1U) {
#line 4976
            goto case_1___8;
          }
#line 4976
          if (prefix_count == 2U) {
#line 4976
            goto case_2___8;
          }
#line 4976
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 4976
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___7, & count);
          }
#line 4976
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 4976
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___7, & count);
          }
#line 4976
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 4976
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___7, & count);
          }
#line 4976
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 4976
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }
#line 4978
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 4981
          arg___8 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 4982
          if (prefix_count == 0U) {
#line 4982
            goto case_0___8;
          }
#line 4982
          if (prefix_count == 1U) {
#line 4982
            goto case_1___9;
          }
#line 4982
          if (prefix_count == 2U) {
#line 4982
            goto case_2___9;
          }
#line 4982
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 4982
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___8, & count);
          }
#line 4982
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 4982
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___8, & count);
          }
#line 4982
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 4982
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___8, & count);
          }
#line 4982
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 4982
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }
#line 4984
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 4988
          arg___9 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 4989
          if (prefix_count == 0U) {
#line 4989
            goto case_0___9;
          }
#line 4989
          if (prefix_count == 1U) {
#line 4989
            goto case_1___10;
          }
#line 4989
          if (prefix_count == 2U) {
#line 4989
            goto case_2___10;
          }
#line 4989
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 4989
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___9, & count);
          }
#line 4989
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 4989
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___9, & count);
          }
#line 4989
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 4989
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___9, & count);
          }
#line 4989
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 4989
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }
#line 4991
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 4994
          arg___10 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 4995
          if (prefix_count == 0U) {
#line 4995
            goto case_0___10;
          }
#line 4995
          if (prefix_count == 1U) {
#line 4995
            goto case_1___11;
          }
#line 4995
          if (prefix_count == 2U) {
#line 4995
            goto case_2___11;
          }
#line 4995
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 4995
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___10,
                              & count);
          }
#line 4995
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 4995
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___10, & count);
          }
#line 4995
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 4995
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___10, & count);
          }
#line 4995
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 4995
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }
#line 4997
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 5000
          arg___11 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 5001
          if (prefix_count == 0U) {
#line 5001
            goto case_0___11;
          }
#line 5001
          if (prefix_count == 1U) {
#line 5001
            goto case_1___12;
          }
#line 5001
          if (prefix_count == 2U) {
#line 5001
            goto case_2___12;
          }
#line 5001
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___11,
                              & count);
          }
#line 5001
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___11, & count);
          }
#line 5001
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___11, & count);
          }
#line 5001
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 5001
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }
#line 5003
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 5007
          arg___12 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 5008
          if (prefix_count == 0U) {
#line 5008
            goto case_0___12;
          }
#line 5008
          if (prefix_count == 1U) {
#line 5008
            goto case_1___13;
          }
#line 5008
          if (prefix_count == 2U) {
#line 5008
            goto case_2___13;
          }
#line 5008
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 5008
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___12,
                              & count);
          }
#line 5008
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 5008
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___12, & count);
          }
#line 5008
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 5008
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___12, & count);
          }
#line 5008
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 5008
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }
#line 5010
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 5014
          arg___13 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 5015
          if (prefix_count == 0U) {
#line 5015
            goto case_0___13;
          }
#line 5015
          if (prefix_count == 1U) {
#line 5015
            goto case_1___14;
          }
#line 5015
          if (prefix_count == 2U) {
#line 5015
            goto case_2___14;
          }
#line 5015
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 5015
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___13,
                              & count);
          }
#line 5015
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 5015
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___13, & count);
          }
#line 5015
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 5015
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___13, & count);
          }
#line 5015
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 5015
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }
#line 5017
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 5021
          arg___14 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 5022
          if (prefix_count == 0U) {
#line 5022
            goto case_0___14;
          }
#line 5022
          if (prefix_count == 1U) {
#line 5022
            goto case_1___15;
          }
#line 5022
          if (prefix_count == 2U) {
#line 5022
            goto case_2___15;
          }
#line 5022
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 5022
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___14,
                              & count);
          }
#line 5022
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 5022
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___14, & count);
          }
#line 5022
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 5022
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___14, & count);
          }
#line 5022
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 5022
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }
#line 5024
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 5028
          arg___15 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 5029
          if (prefix_count == 0U) {
#line 5029
            goto case_0___15;
          }
#line 5029
          if (prefix_count == 1U) {
#line 5029
            goto case_1___16;
          }
#line 5029
          if (prefix_count == 2U) {
#line 5029
            goto case_2___16;
          }
#line 5029
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 5029
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, arg___15,
                              & count);
          }
#line 5029
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 5029
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              arg___15, & count);
          }
#line 5029
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 5029
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf___1, prefixes[0],
                              prefixes[1], arg___15, & count);
          }
#line 5029
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 5029
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }
#line 5031
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 5033
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 5041
          if (count >= 0) {
#line 5045
            if ((size_t )count < maxlen) {
#line 5045
              if ((int )*((result + length) + count) != 0) {
                {
#line 5047
                abort();
                }
              }
            }
#line 5049
            if (retcount > count) {
#line 5050
              count = retcount;
            }
          } else
#line 5056
          if ((int )*(fbp + 1) != 0) {
#line 5060
            *(fbp + 1) = (char )'\000';
#line 5061
            goto __Cont;
          } else
#line 5066
          if (retcount < 0) {
#line 5073
            if (allocated <= 2147483647U) {
#line 5073
              tmp___38 = allocated * 2U;
            } else {
#line 5073
              tmp___38 = 4294967295U;
            }
            {
#line 5073
            tmp___39 = xsum(tmp___38, (size_t )12);
#line 5073
            bigger_need = (size_t )tmp___39;
            }
#line 5075
            if (bigger_need > allocated) {
#line 5075
              if (allocated > 0U) {
#line 5075
                if (allocated <= 2147483647U) {
#line 5075
                  tmp___40 = allocated * 2U;
                } else {
#line 5075
                  tmp___40 = 4294967295U;
                }
#line 5075
                allocated = tmp___40;
              } else {
#line 5075
                allocated = (size_t )12;
              }
#line 5075
              if (bigger_need > allocated) {
#line 5075
                allocated = bigger_need;
              }
#line 5075
              if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5075
                memory_size___2 = (size_t )((unsigned long )allocated * sizeof(char ));
              } else {
#line 5075
                memory_size___2 = 4294967295U;
              }
#line 5075
              if (memory_size___2 == 4294967295U) {
#line 5075
                goto out_of_memory;
              }
#line 5075
              if ((unsigned long )result == (unsigned long )resultbuf) {
                {
#line 5075
                tmp___41 = malloc(memory_size___2);
#line 5075
                memory___2 = (char *)tmp___41;
                }
              } else
#line 5075
              if ((unsigned long )result == (unsigned long )((void *)0)) {
                {
#line 5075
                tmp___41 = malloc(memory_size___2);
#line 5075
                memory___2 = (char *)tmp___41;
                }
              } else {
                {
#line 5075
                tmp___42 = realloc((void *)result, memory_size___2);
#line 5075
                memory___2 = (char *)tmp___42;
                }
              }
#line 5075
              if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 5075
                goto out_of_memory;
              }
#line 5075
              if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5075
                if (length > 0U) {
                  {
#line 5075
                  memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)result,
                         length);
                  }
                }
              }
#line 5075
              result = memory___2;
            }
#line 5076
            goto __Cont;
          } else {
#line 5079
            count = retcount;
          }
#line 5085
          if (count < 0) {
#line 5087
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5087
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                {
#line 5088
                free((void *)result);
                }
              }
            }
#line 5089
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
              {
#line 5090
              free((void *)buf_malloced);
              }
            }
            {
#line 5091
            free((void *)d.dir);
            }
#line 5091
            if (a.arg) {
              {
#line 5091
              free((void *)a.arg);
              }
            }
            {
#line 5092
            tmp___43 = __errno_location();
#line 5092
            *tmp___43 = 22;
            }
#line 5093
            return ((char *)((void *)0));
          }
#line 5102
          if ((unsigned int )count + 1U >= maxlen) {
#line 5107
            if ((unsigned long )maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5108
              goto overflow;
            } else {
#line 5120
              if (allocated <= 2147483647U) {
#line 5120
                tmp___44 = allocated * 2U;
              } else {
#line 5120
                tmp___44 = 4294967295U;
              }
              {
#line 5120
              tmp___45 = xsum(length, (size_t )((((unsigned long )((unsigned int )count + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char ))));
#line 5120
              tmp___46 = xmax((size_t )tmp___45, tmp___44);
#line 5120
              n___2 = (size_t )tmp___46;
              }
#line 5127
              if (n___2 > allocated) {
#line 5127
                if (allocated > 0U) {
#line 5127
                  if (allocated <= 2147483647U) {
#line 5127
                    tmp___47 = allocated * 2U;
                  } else {
#line 5127
                    tmp___47 = 4294967295U;
                  }
#line 5127
                  allocated = tmp___47;
                } else {
#line 5127
                  allocated = (size_t )12;
                }
#line 5127
                if (n___2 > allocated) {
#line 5127
                  allocated = n___2;
                }
#line 5127
                if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5127
                  memory_size___3 = (size_t )((unsigned long )allocated * sizeof(char ));
                } else {
#line 5127
                  memory_size___3 = 4294967295U;
                }
#line 5127
                if (memory_size___3 == 4294967295U) {
#line 5127
                  goto out_of_memory;
                }
#line 5127
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 5127
                  tmp___48 = malloc(memory_size___3);
#line 5127
                  memory___3 = (char *)tmp___48;
                  }
                } else
#line 5127
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 5127
                  tmp___48 = malloc(memory_size___3);
#line 5127
                  memory___3 = (char *)tmp___48;
                  }
                } else {
                  {
#line 5127
                  tmp___49 = realloc((void *)result, memory_size___3);
#line 5127
                  memory___3 = (char *)tmp___49;
                  }
                }
#line 5127
                if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 5127
                  goto out_of_memory;
                }
#line 5127
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5127
                  if (length > 0U) {
                    {
#line 5127
                    memcpy((void */* __restrict  */)memory___3, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 5127
                result = memory___3;
              }
#line 5128
              goto __Cont;
            }
          }
#line 5426
          length += (size_t )count;
#line 5427
          goto while_break___3;
          __Cont: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 1576
    cp = dp->dir_end;
#line 1576
    i ++;
#line 1576
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5434
  tmp___55 = xsum(length, (size_t )1);
  }
#line 5434
  if (tmp___55 > (size_t __attribute__((__pure__))  )allocated) {
#line 5434
    if (allocated > 0U) {
#line 5434
      if (allocated <= 2147483647U) {
#line 5434
        tmp___50 = allocated * 2U;
      } else {
#line 5434
        tmp___50 = 4294967295U;
      }
#line 5434
      allocated = tmp___50;
    } else {
#line 5434
      allocated = (size_t )12;
    }
    {
#line 5434
    tmp___52 = xsum(length, (size_t )1);
    }
#line 5434
    if (tmp___52 > (size_t __attribute__((__pure__))  )allocated) {
      {
#line 5434
      tmp___51 = xsum(length, (size_t )1);
#line 5434
      allocated = (size_t )tmp___51;
      }
    }
#line 5434
    if ((unsigned long )allocated <= 4294967295UL / sizeof(char )) {
#line 5434
      memory_size___4 = (size_t )((unsigned long )allocated * sizeof(char ));
    } else {
#line 5434
      memory_size___4 = 4294967295U;
    }
#line 5434
    if (memory_size___4 == 4294967295U) {
#line 5434
      goto out_of_memory;
    }
#line 5434
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
#line 5434
      tmp___53 = malloc(memory_size___4);
#line 5434
      memory___4 = (char *)tmp___53;
      }
    } else
#line 5434
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 5434
      tmp___53 = malloc(memory_size___4);
#line 5434
      memory___4 = (char *)tmp___53;
      }
    } else {
      {
#line 5434
      tmp___54 = realloc((void *)result, memory_size___4);
#line 5434
      memory___4 = (char *)tmp___54;
      }
    }
#line 5434
    if ((unsigned long )memory___4 == (unsigned long )((void *)0)) {
#line 5434
      goto out_of_memory;
    }
#line 5434
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5434
      if (length > 0U) {
        {
#line 5434
        memcpy((void */* __restrict  */)memory___4, (void const   */* __restrict  */)result,
               length);
        }
      }
    }
#line 5434
    result = memory___4;
  }
#line 5435
  *(result + length) = (char )'\000';
#line 5437
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 5437
    if (length + 1U < allocated) {
      {
#line 5442
      tmp___56 = realloc((void *)result, (size_t )((unsigned long )(length + 1U) * sizeof(char )));
#line 5442
      memory___5 = (char *)tmp___56;
      }
#line 5443
      if ((unsigned long )memory___5 != (unsigned long )((void *)0)) {
#line 5444
        result = memory___5;
      }
    }
  }
#line 5447
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5448
    free((void *)buf_malloced);
    }
  }
  {
#line 5449
  free((void *)d.dir);
  }
#line 5449
  if (a.arg) {
    {
#line 5449
    free((void *)a.arg);
    }
  }
#line 5450
  *lengthp = length;
#line 5455
  return (result);
  overflow: 
#line 5459
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5459
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5460
      free((void *)result);
      }
    }
  }
#line 5461
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5462
    free((void *)buf_malloced);
    }
  }
  {
#line 5463
  free((void *)d.dir);
  }
#line 5463
  if (a.arg) {
    {
#line 5463
    free((void *)a.arg);
    }
  }
  {
#line 5464
  tmp___57 = __errno_location();
#line 5464
  *tmp___57 = 75;
  }
#line 5465
  return ((char *)((void *)0));
  out_of_memory: 
#line 5469
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5469
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5470
      free((void *)result);
      }
    }
  }
#line 5471
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5472
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
  {
#line 5474
  free((void *)d.dir);
  }
#line 5474
  if (a.arg) {
    {
#line 5474
    free((void *)a.arg);
    }
  }
  {
#line 5475
  tmp___58 = __errno_location();
#line 5475
  *tmp___58 = 12;
  }
#line 5476
  return ((char *)((void *)0));
}
}
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___1 ) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___1 ) 
{ 
  char *p ;

  {
#line 38
  p = buf___1 + (((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i < 0ULL) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48ULL - i % 10ULL);
#line 43
      i /= 10ULL;
#line 43
      if (! (i != 0ULL)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48ULL + i % 10ULL);
#line 51
      i /= 10ULL;
#line 51
      if (! (i != 0ULL)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 24
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___1 ) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___1 ) 
{ 
  char *p ;

  {
#line 38
  p = buf___1 + (((sizeof(unsigned int ) * 8UL) * 146UL) / 485UL + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i < 0U) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48U - i % 10U);
#line 43
      i /= 10U;
#line 43
      if (! (i != 0U)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48U + i % 10U);
#line 51
      i /= 10U;
#line 51
      if (! (i != 0U)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 193 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 199
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.h"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 304 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    tmp___0 = len;
#line 308
    len --;
#line 308
    if (! (tmp___0 > 0U)) {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp = tolower((int )((unsigned char )*(src + len)));
#line 309
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return (dest);
}
}
#line 313 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    tmp___0 = len;
#line 317
    len --;
#line 317
    if (! (tmp___0 > 0U)) {
#line 317
      goto while_break;
    }
    {
#line 318
    tmp = toupper((int )((unsigned char )*(src + len)));
#line 318
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return (dest);
}
}
#line 360 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
__inline static int iso_week_days(int yday , int wday ) 
{ 
  int big_enough_multiple_of_7 ;

  {
#line 366
  big_enough_multiple_of_7 = 378;
#line 367
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
#line 408 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static size_t strftime_case_(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                             struct tm  const  *tp , int ut , int ns ) 
{ 
  int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  struct tm copy ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t len ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  int century ;
  int tmp___9 ;
  int tmp___10 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___11 ;
  int padding ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___12 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___13 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___14 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___15 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___16 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___17 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___18 ;
  int year ;
  int tmp___19 ;
  int year_adjust ;
  int days ;
  int tmp___20 ;
  int tmp___21 ;
  int d___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int yy ;
  int tmp___24 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___25 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___26 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___27 ;
  void *__cil_tmp122 ;
  void *__cil_tmp123 ;
  void *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;

  {
#line 421
  hour12 = (int )tp->tm_hour;
#line 446
  i = (size_t )0;
#line 447
  p = s;
#line 458
  copy = *tp;
#line 459
  tp = (struct tm  const  *)(& copy);
#line 462
  zone = (char const   *)((void *)0);
#line 470
  zone = (char const   *)tp->tm_zone;
#line 488
  if (hour12 > 12) {
#line 489
    hour12 -= 12;
  } else
#line 491
  if (hour12 == 0) {
#line 492
    hour12 = 12;
  }
#line 494
  f = format;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! ((int const   )*f != 0)) {
#line 494
      goto while_break;
    }
#line 496
    pad = 0;
#line 498
    digits = 0;
#line 512
    width = -1;
#line 513
    to_lowcase = (_Bool)0;
#line 514
    to_uppcase = upcase;
#line 516
    change_case = (_Bool)0;
#line 599
    if ((int const   )*f != 37) {
      {
#line 601
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 601
        _n = 1;
#line 601
        _delta = width - _n;
#line 601
        if (_delta > 0) {
#line 601
          tmp = _delta;
        } else {
#line 601
          tmp = 0;
        }
#line 601
        _incr = _n + tmp;
#line 601
        if ((size_t )_incr >= maxsize - i) {
#line 601
          return ((size_t )0);
        }
#line 601
        if (p) {
#line 601
          if (digits == 0) {
#line 601
            if (_delta > 0) {
#line 601
              if (pad == 48) {
                {
#line 601
                memset((void *)p, '0', (size_t )_delta);
#line 601
                p += _delta;
                }
              } else {
                {
#line 601
                memset((void *)p, ' ', (size_t )_delta);
#line 601
                p += _delta;
                }
              }
            }
          }
#line 601
          *p = (char )*f;
#line 601
          p += _n;
        }
#line 601
        i += (size_t )_incr;
#line 601
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 602
      goto __Cont;
    }
    {
#line 608
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 610
      f ++;
      {
#line 615
      if ((int const   )*f == 48) {
#line 615
        goto case_48;
      }
#line 615
      if ((int const   )*f == 45) {
#line 615
        goto case_48;
      }
#line 615
      if ((int const   )*f == 95) {
#line 615
        goto case_48;
      }
#line 620
      if ((int const   )*f == 94) {
#line 620
        goto case_94;
      }
#line 623
      if ((int const   )*f == 35) {
#line 623
        goto case_35;
      }
#line 627
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 616
      pad = (int )*f;
#line 617
      goto while_continue___1;
      case_94: /* CIL Label */ 
#line 621
      to_uppcase = (_Bool)1;
#line 622
      goto while_continue___1;
      case_35: /* CIL Label */ 
#line 624
      change_case = (_Bool)1;
#line 625
      goto while_continue___1;
      switch_default: /* CIL Label */ 
#line 628
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 630
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 634
    if ((unsigned int )*f - 48U <= 9U) {
#line 636
      width = 0;
      {
#line 637
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 639
        if (width > 214748364) {
#line 642
          width = 2147483647;
        } else
#line 639
        if (width == 214748364) {
#line 639
          if ((int const   )*f - 48 > 7) {
#line 642
            width = 2147483647;
          } else {
#line 645
            width *= 10;
#line 646
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 645
          width *= 10;
#line 646
          width += (int )((int const   )*f - 48);
        }
#line 648
        f ++;
#line 637
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 637
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 657
    if ((int const   )*f == 79) {
#line 657
      goto case_79;
    }
#line 657
    if ((int const   )*f == 69) {
#line 657
      goto case_79;
    }
#line 661
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 658
    tmp___0 = f;
#line 658
    f ++;
#line 658
    modifier = (int )*tmp___0;
#line 659
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 662
    modifier = 0;
#line 663
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 667
    format_char = (int )*f;
    {
#line 690
    if (format_char == 37) {
#line 690
      goto case_37;
    }
#line 696
    if (format_char == 97) {
#line 696
      goto case_97;
    }
#line 711
    if (format_char == 65) {
#line 711
      goto case_65;
    }
#line 727
    if (format_char == 104) {
#line 727
      goto case_104;
    }
#line 727
    if (format_char == 98) {
#line 727
      goto case_104;
    }
#line 742
    if (format_char == 66) {
#line 742
      goto case_66;
    }
#line 757
    if (format_char == 99) {
#line 757
      goto case_99;
    }
#line 816
    if (format_char == 67) {
#line 816
      goto case_67;
    }
#line 845
    if (format_char == 120) {
#line 845
      goto case_120;
    }
#line 858
    if (format_char == 68) {
#line 858
      goto case_68;
    }
#line 864
    if (format_char == 100) {
#line 864
      goto case_100;
    }
#line 870
    if (format_char == 101) {
#line 870
      goto case_101;
    }
#line 996
    if (format_char == 70) {
#line 996
      goto case_70;
    }
#line 1002
    if (format_char == 72) {
#line 1002
      goto case_72;
    }
#line 1008
    if (format_char == 73) {
#line 1008
      goto case_73;
    }
#line 1014
    if (format_char == 107) {
#line 1014
      goto case_107;
    }
#line 1020
    if (format_char == 108) {
#line 1020
      goto case_108;
    }
#line 1026
    if (format_char == 106) {
#line 1026
      goto case_106;
    }
#line 1032
    if (format_char == 77) {
#line 1032
      goto case_77;
    }
#line 1038
    if (format_char == 109) {
#line 1038
      goto case_109;
    }
#line 1045
    if (format_char == 78) {
#line 1045
      goto case_78;
    }
#line 1063
    if (format_char == 110) {
#line 1063
      goto case_110;
    }
#line 1067
    if (format_char == 80) {
#line 1067
      goto case_80;
    }
#line 1074
    if (format_char == 112) {
#line 1074
      goto case_112;
    }
#line 1087
    if (format_char == 82) {
#line 1087
      goto case_82;
    }
#line 1091
    if (format_char == 114) {
#line 1091
      goto case_114;
    }
#line 1102
    if (format_char == 83) {
#line 1102
      goto case_83;
    }
#line 1108
    if (format_char == 115) {
#line 1108
      goto case_115;
    }
#line 1135
    if (format_char == 88) {
#line 1135
      goto case_88;
    }
#line 1148
    if (format_char == 84) {
#line 1148
      goto case_84;
    }
#line 1152
    if (format_char == 116) {
#line 1152
      goto case_116;
    }
#line 1156
    if (format_char == 117) {
#line 1156
      goto case_117;
    }
#line 1159
    if (format_char == 85) {
#line 1159
      goto case_85;
    }
#line 1167
    if (format_char == 71) {
#line 1167
      goto case_71;
    }
#line 1167
    if (format_char == 103) {
#line 1167
      goto case_71;
    }
#line 1167
    if (format_char == 86) {
#line 1167
      goto case_71;
    }
#line 1223
    if (format_char == 87) {
#line 1223
      goto case_87;
    }
#line 1229
    if (format_char == 119) {
#line 1229
      goto case_119;
    }
#line 1235
    if (format_char == 89) {
#line 1235
      goto case_89;
    }
#line 1259
    if (format_char == 121) {
#line 1259
      goto case_121;
    }
#line 1282
    if (format_char == 90) {
#line 1282
      goto case_90;
    }
#line 1311
    if (format_char == 58) {
#line 1311
      goto case_58;
    }
#line 1321
    if (format_char == 122) {
#line 1321
      goto case_122;
    }
#line 1399
    if (format_char == 0) {
#line 1399
      goto case_0___0;
    }
#line 1402
    goto bad_format;
    case_37: /* CIL Label */ 
#line 691
    if (modifier != 0) {
#line 692
      goto bad_format;
    }
    {
#line 693
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 693
      _n___0 = 1;
#line 693
      _delta___0 = width - _n___0;
#line 693
      if (_delta___0 > 0) {
#line 693
        tmp___1 = _delta___0;
      } else {
#line 693
        tmp___1 = 0;
      }
#line 693
      _incr___0 = _n___0 + tmp___1;
#line 693
      if ((size_t )_incr___0 >= maxsize - i) {
#line 693
        return ((size_t )0);
      }
#line 693
      if (p) {
#line 693
        if (digits == 0) {
#line 693
          if (_delta___0 > 0) {
#line 693
            if (pad == 48) {
              {
#line 693
              memset((void *)p, '0', (size_t )_delta___0);
#line 693
              p += _delta___0;
              }
            } else {
              {
#line 693
              memset((void *)p, ' ', (size_t )_delta___0);
#line 693
              p += _delta___0;
              }
            }
          }
        }
#line 693
        *p = (char )*f;
#line 693
        p += _n___0;
      }
#line 693
      i += (size_t )_incr___0;
#line 693
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 694
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 697
    if (modifier != 0) {
#line 698
      goto bad_format;
    }
#line 699
    if (change_case) {
#line 701
      to_uppcase = (_Bool)1;
#line 702
      to_lowcase = (_Bool)0;
    }
#line 708
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 712
    if (modifier != 0) {
#line 713
      goto bad_format;
    }
#line 714
    if (change_case) {
#line 716
      to_uppcase = (_Bool)1;
#line 717
      to_lowcase = (_Bool)0;
    }
#line 723
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 728
    if (change_case) {
#line 730
      to_uppcase = (_Bool)1;
#line 731
      to_lowcase = (_Bool)0;
    }
#line 733
    if (modifier != 0) {
#line 734
      goto bad_format;
    }
#line 739
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 743
    if (modifier != 0) {
#line 744
      goto bad_format;
    }
#line 745
    if (change_case) {
#line 747
      to_uppcase = (_Bool)1;
#line 748
      to_lowcase = (_Bool)0;
    }
#line 754
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 758
    if (modifier == 79) {
#line 759
      goto bad_format;
    }
#line 768
    goto underlying_strftime;
    subformat: 
    {
#line 773
    tmp___2 = strftime_case_(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                             tp, ut, ns);
#line 773
    len = tmp___2;
    }
    {
#line 777
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 777
      _n___1 = (int )len;
#line 777
      _delta___1 = width - _n___1;
#line 777
      if (_delta___1 > 0) {
#line 777
        tmp___3 = _delta___1;
      } else {
#line 777
        tmp___3 = 0;
      }
#line 777
      _incr___1 = _n___1 + tmp___3;
#line 777
      if ((size_t )_incr___1 >= maxsize - i) {
#line 777
        return ((size_t )0);
      }
#line 777
      if (p) {
#line 777
        if (digits == 0) {
#line 777
          if (_delta___1 > 0) {
#line 777
            if (pad == 48) {
              {
#line 777
              memset((void *)p, '0', (size_t )_delta___1);
#line 777
              p += _delta___1;
              }
            } else {
              {
#line 777
              memset((void *)p, ' ', (size_t )_delta___1);
#line 777
              p += _delta___1;
              }
            }
          }
        }
        {
#line 777
        strftime_case_(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
#line 777
        p += _n___1;
        }
      }
#line 777
      i += (size_t )_incr___1;
#line 777
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 782
    goto switch_break___1;
    underlying_strftime: 
#line 790
    u = ufmt;
#line 803
    tmp___4 = u;
#line 803
    u ++;
#line 803
    *tmp___4 = (char )' ';
#line 804
    tmp___5 = u;
#line 804
    u ++;
#line 804
    *tmp___5 = (char )'%';
#line 805
    if (modifier != 0) {
#line 806
      tmp___6 = u;
#line 806
      u ++;
#line 806
      *tmp___6 = (char )modifier;
    }
    {
#line 807
    tmp___7 = u;
#line 807
    u ++;
#line 807
    *tmp___7 = (char )format_char;
#line 808
    *u = (char )'\000';
#line 809
    len___0 = strftime((char */* __restrict  */)(ubuf), (size_t )sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 810
    if (len___0 != 0U) {
      {
#line 811
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 811
        _n___2 = (int )(len___0 - 1U);
#line 811
        _delta___2 = width - _n___2;
#line 811
        if (_delta___2 > 0) {
#line 811
          tmp___8 = _delta___2;
        } else {
#line 811
          tmp___8 = 0;
        }
#line 811
        _incr___2 = _n___2 + tmp___8;
#line 811
        if ((size_t )_incr___2 >= maxsize - i) {
#line 811
          return ((size_t )0);
        }
#line 811
        if (p) {
#line 811
          if (digits == 0) {
#line 811
            if (_delta___2 > 0) {
#line 811
              if (pad == 48) {
                {
#line 811
                memset((void *)p, '0', (size_t )_delta___2);
#line 811
                p += _delta___2;
                }
              } else {
                {
#line 811
                memset((void *)p, ' ', (size_t )_delta___2);
#line 811
                p += _delta___2;
                }
              }
            }
          }
#line 811
          if (to_lowcase) {
            {
#line 811
            memcpy_lowcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else
#line 811
          if (to_uppcase) {
            {
#line 811
            memcpy_uppcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else {
            {
#line 811
            memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(ubuf + 1)),
                   (size_t )_n___2);
            }
          }
#line 811
          p += _n___2;
        }
#line 811
        i += (size_t )_incr___2;
#line 811
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 813
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 817
    if (modifier == 79) {
#line 818
      goto bad_format;
    }
#line 819
    if (modifier == 69) {
#line 835
      goto underlying_strftime;
    }
#line 840
    century = (int )(tp->tm_year / 100 + 19);
#line 841
    if (tp->tm_year % 100 < 0) {
#line 841
      if (0 < century) {
#line 841
        tmp___9 = 1;
      } else {
#line 841
        tmp___9 = 0;
      }
    } else {
#line 841
      tmp___9 = 0;
    }
#line 841
    century -= tmp___9;
#line 842
    digits = 2;
#line 842
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 842
    u_number_value = (unsigned int )century;
#line 842
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 846
    if (modifier == 79) {
#line 847
      goto bad_format;
    }
#line 856
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 859
    if (modifier != 0) {
#line 860
      goto bad_format;
    }
#line 861
    subfmt = "%m/%d/%y";
#line 862
    goto subformat;
    case_100: /* CIL Label */ 
#line 865
    if (modifier == 69) {
#line 866
      goto bad_format;
    }
#line 868
    digits = 2;
#line 868
    number_value = (int )tp->tm_mday;
#line 868
    goto do_number;
    case_101: /* CIL Label */ 
#line 871
    if (modifier == 69) {
#line 872
      goto bad_format;
    }
#line 874
    digits = 2;
#line 874
    number_value = (int )tp->tm_mday;
#line 874
    goto do_number_spacepad;
    do_tz_offset: 
#line 880
    always_output_a_sign = (_Bool)1;
#line 881
    goto do_number_body;
    do_number_spacepad: 
#line 885
    if (pad != 48) {
#line 885
      if (pad != 45) {
#line 886
        pad = '_';
      }
    }
    do_number: 
#line 890
    negative_number = (_Bool )(number_value < 0);
#line 891
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 894
    always_output_a_sign = (_Bool)0;
#line 895
    tz_colon_mask = 0;
    do_number_body: 
#line 903
    if (modifier == 79) {
#line 903
      if (! negative_number) {
#line 921
        goto underlying_strftime;
      }
    }
#line 925
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 927
    if (negative_number) {
#line 928
      u_number_value = - u_number_value;
    }
    {
#line 930
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 932
      if (tz_colon_mask & 1) {
#line 933
        bufp --;
#line 933
        *bufp = (char )':';
      }
#line 934
      tz_colon_mask >>= 1;
#line 935
      bufp --;
#line 935
      *bufp = (char )(u_number_value % 10U + 48U);
#line 936
      u_number_value /= 10U;
#line 930
      if (! (u_number_value != 0U)) {
#line 930
        if (! (tz_colon_mask != 0)) {
#line 930
          goto while_break___6;
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 941
    if (digits < width) {
#line 942
      digits = width;
    }
#line 944
    if (negative_number) {
#line 944
      sign_char = (char )'-';
    } else {
#line 944
      if (always_output_a_sign) {
#line 944
        tmp___10 = '+';
      } else {
#line 944
        tmp___10 = 0;
      }
#line 944
      sign_char = (char )tmp___10;
    }
#line 948
    if (pad == 45) {
#line 950
      if (sign_char) {
        {
#line 951
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 951
          _n___3 = 1;
#line 951
          _delta___3 = width - _n___3;
#line 951
          if (_delta___3 > 0) {
#line 951
            tmp___11 = _delta___3;
          } else {
#line 951
            tmp___11 = 0;
          }
#line 951
          _incr___3 = _n___3 + tmp___11;
#line 951
          if ((size_t )_incr___3 >= maxsize - i) {
#line 951
            return ((size_t )0);
          }
#line 951
          if (p) {
#line 951
            if (digits == 0) {
#line 951
              if (_delta___3 > 0) {
#line 951
                if (pad == 48) {
                  {
#line 951
                  memset((void *)p, '0', (size_t )_delta___3);
#line 951
                  p += _delta___3;
                  }
                } else {
                  {
#line 951
                  memset((void *)p, ' ', (size_t )_delta___3);
#line 951
                  p += _delta___3;
                  }
                }
              }
            }
#line 951
            *p = sign_char;
#line 951
            p += _n___3;
          }
#line 951
          i += (size_t )_incr___3;
#line 951
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    } else {
#line 955
      padding = (int )(((long )digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - (long )(! (! sign_char)));
#line 958
      if (padding > 0) {
#line 960
        if (pad == 95) {
#line 962
          if ((size_t )padding >= maxsize - i) {
#line 963
            return ((size_t )0);
          }
#line 965
          if (p) {
            {
#line 966
            memset((void *)p, ' ', (size_t )padding);
#line 966
            p += padding;
            }
          }
#line 967
          i += (size_t )padding;
#line 968
          if (width > padding) {
#line 968
            width -= padding;
          } else {
#line 968
            width = 0;
          }
#line 969
          if (sign_char) {
            {
#line 970
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 970
              _n___4 = 1;
#line 970
              _delta___4 = width - _n___4;
#line 970
              if (_delta___4 > 0) {
#line 970
                tmp___12 = _delta___4;
              } else {
#line 970
                tmp___12 = 0;
              }
#line 970
              _incr___4 = _n___4 + tmp___12;
#line 970
              if ((size_t )_incr___4 >= maxsize - i) {
#line 970
                return ((size_t )0);
              }
#line 970
              if (p) {
#line 970
                if (digits == 0) {
#line 970
                  if (_delta___4 > 0) {
#line 970
                    if (pad == 48) {
                      {
#line 970
                      memset((void *)p, '0', (size_t )_delta___4);
#line 970
                      p += _delta___4;
                      }
                    } else {
                      {
#line 970
                      memset((void *)p, ' ', (size_t )_delta___4);
#line 970
                      p += _delta___4;
                      }
                    }
                  }
                }
#line 970
                *p = sign_char;
#line 970
                p += _n___4;
              }
#line 970
              i += (size_t )_incr___4;
#line 970
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        } else {
#line 974
          if ((size_t )digits >= maxsize - i) {
#line 975
            return ((size_t )0);
          }
#line 977
          if (sign_char) {
            {
#line 978
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 978
              _n___5 = 1;
#line 978
              _delta___5 = width - _n___5;
#line 978
              if (_delta___5 > 0) {
#line 978
                tmp___13 = _delta___5;
              } else {
#line 978
                tmp___13 = 0;
              }
#line 978
              _incr___5 = _n___5 + tmp___13;
#line 978
              if ((size_t )_incr___5 >= maxsize - i) {
#line 978
                return ((size_t )0);
              }
#line 978
              if (p) {
#line 978
                if (digits == 0) {
#line 978
                  if (_delta___5 > 0) {
#line 978
                    if (pad == 48) {
                      {
#line 978
                      memset((void *)p, '0', (size_t )_delta___5);
#line 978
                      p += _delta___5;
                      }
                    } else {
                      {
#line 978
                      memset((void *)p, ' ', (size_t )_delta___5);
#line 978
                      p += _delta___5;
                      }
                    }
                  }
                }
#line 978
                *p = sign_char;
#line 978
                p += _n___5;
              }
#line 978
              i += (size_t )_incr___5;
#line 978
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
          }
#line 980
          if (p) {
            {
#line 981
            memset((void *)p, '0', (size_t )padding);
#line 981
            p += padding;
            }
          }
#line 982
          i += (size_t )padding;
#line 983
          width = 0;
        }
      } else
#line 988
      if (sign_char) {
        {
#line 989
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 989
          _n___6 = 1;
#line 989
          _delta___6 = width - _n___6;
#line 989
          if (_delta___6 > 0) {
#line 989
            tmp___14 = _delta___6;
          } else {
#line 989
            tmp___14 = 0;
          }
#line 989
          _incr___6 = _n___6 + tmp___14;
#line 989
          if ((size_t )_incr___6 >= maxsize - i) {
#line 989
            return ((size_t )0);
          }
#line 989
          if (p) {
#line 989
            if (digits == 0) {
#line 989
              if (_delta___6 > 0) {
#line 989
                if (pad == 48) {
                  {
#line 989
                  memset((void *)p, '0', (size_t )_delta___6);
#line 989
                  p += _delta___6;
                  }
                } else {
                  {
#line 989
                  memset((void *)p, ' ', (size_t )_delta___6);
#line 989
                  p += _delta___6;
                  }
                }
              }
            }
#line 989
            *p = sign_char;
#line 989
            p += _n___6;
          }
#line 989
          i += (size_t )_incr___6;
#line 989
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    }
    {
#line 993
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 993
      _n___7 = (int )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
#line 993
      _delta___7 = width - _n___7;
#line 993
      if (_delta___7 > 0) {
#line 993
        tmp___15 = _delta___7;
      } else {
#line 993
        tmp___15 = 0;
      }
#line 993
      _incr___7 = _n___7 + tmp___15;
#line 993
      if ((size_t )_incr___7 >= maxsize - i) {
#line 993
        return ((size_t )0);
      }
#line 993
      if (p) {
#line 993
        if (digits == 0) {
#line 993
          if (_delta___7 > 0) {
#line 993
            if (pad == 48) {
              {
#line 993
              memset((void *)p, '0', (size_t )_delta___7);
#line 993
              p += _delta___7;
              }
            } else {
              {
#line 993
              memset((void *)p, ' ', (size_t )_delta___7);
#line 993
              p += _delta___7;
              }
            }
          }
        }
#line 993
        if (to_lowcase) {
          {
#line 993
          memcpy_lowcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else
#line 993
        if (to_uppcase) {
          {
#line 993
          memcpy_uppcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else {
          {
#line 993
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)bufp),
                 (size_t )_n___7);
          }
        }
#line 993
        p += _n___7;
      }
#line 993
      i += (size_t )_incr___7;
#line 993
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 994
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 997
    if (modifier != 0) {
#line 998
      goto bad_format;
    }
#line 999
    subfmt = "%Y-%m-%d";
#line 1000
    goto subformat;
    case_72: /* CIL Label */ 
#line 1003
    if (modifier == 69) {
#line 1004
      goto bad_format;
    }
#line 1006
    digits = 2;
#line 1006
    number_value = (int )tp->tm_hour;
#line 1006
    goto do_number;
    case_73: /* CIL Label */ 
#line 1009
    if (modifier == 69) {
#line 1010
      goto bad_format;
    }
#line 1012
    digits = 2;
#line 1012
    number_value = hour12;
#line 1012
    goto do_number;
    case_107: /* CIL Label */ 
#line 1015
    if (modifier == 69) {
#line 1016
      goto bad_format;
    }
#line 1018
    digits = 2;
#line 1018
    number_value = (int )tp->tm_hour;
#line 1018
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1021
    if (modifier == 69) {
#line 1022
      goto bad_format;
    }
#line 1024
    digits = 2;
#line 1024
    number_value = hour12;
#line 1024
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1027
    if (modifier == 69) {
#line 1028
      goto bad_format;
    }
#line 1030
    digits = 3;
#line 1030
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1030
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1030
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1033
    if (modifier == 69) {
#line 1034
      goto bad_format;
    }
#line 1036
    digits = 2;
#line 1036
    number_value = (int )tp->tm_min;
#line 1036
    goto do_number;
    case_109: /* CIL Label */ 
#line 1039
    if (modifier == 69) {
#line 1040
      goto bad_format;
    }
#line 1042
    digits = 2;
#line 1042
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1042
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1042
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1046
    if (modifier == 69) {
#line 1047
      goto bad_format;
    }
#line 1049
    number_value = ns;
#line 1050
    if (width == -1) {
#line 1051
      width = 9;
    } else {
#line 1056
      j = width;
      {
#line 1056
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1056
        if (! (j < 9)) {
#line 1056
          goto while_break___12;
        }
#line 1057
        number_value /= 10;
#line 1056
        j ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1060
    digits = width;
#line 1060
    number_value = number_value;
#line 1060
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1064
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1064
      _n___8 = 1;
#line 1064
      _delta___8 = width - _n___8;
#line 1064
      if (_delta___8 > 0) {
#line 1064
        tmp___16 = _delta___8;
      } else {
#line 1064
        tmp___16 = 0;
      }
#line 1064
      _incr___8 = _n___8 + tmp___16;
#line 1064
      if ((size_t )_incr___8 >= maxsize - i) {
#line 1064
        return ((size_t )0);
      }
#line 1064
      if (p) {
#line 1064
        if (digits == 0) {
#line 1064
          if (_delta___8 > 0) {
#line 1064
            if (pad == 48) {
              {
#line 1064
              memset((void *)p, '0', (size_t )_delta___8);
#line 1064
              p += _delta___8;
              }
            } else {
              {
#line 1064
              memset((void *)p, ' ', (size_t )_delta___8);
#line 1064
              p += _delta___8;
              }
            }
          }
        }
#line 1064
        *p = (char )'\n';
#line 1064
        p += _n___8;
      }
#line 1064
      i += (size_t )_incr___8;
#line 1064
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1065
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1068
    to_lowcase = (_Bool)1;
#line 1070
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1075
    if (change_case) {
#line 1077
      to_uppcase = (_Bool)0;
#line 1078
      to_lowcase = (_Bool)1;
    }
#line 1084
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1088
    subfmt = "%H:%M";
#line 1089
    goto subformat;
    case_114: /* CIL Label */ 
#line 1099
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1103
    if (modifier == 69) {
#line 1104
      goto bad_format;
    }
#line 1106
    digits = 2;
#line 1106
    number_value = (int )tp->tm_sec;
#line 1106
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1113
    ltm = (struct tm )*tp;
#line 1114
    t = mktime(& ltm);
#line 1119
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 1120
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1122
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1124
      d = (int )(t % 10L);
#line 1125
      t /= 10L;
#line 1126
      bufp --;
#line 1126
      if (negative_number) {
#line 1126
        tmp___17 = - d;
      } else {
#line 1126
        tmp___17 = d;
      }
#line 1126
      *bufp = (char )(tmp___17 + 48);
#line 1122
      if (! (t != 0L)) {
#line 1122
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1130
    digits = 1;
#line 1131
    always_output_a_sign = (_Bool)0;
#line 1132
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1136
    if (modifier == 79) {
#line 1137
      goto bad_format;
    }
#line 1146
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1149
    subfmt = "%H:%M:%S";
#line 1150
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1153
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1153
      _n___9 = 1;
#line 1153
      _delta___9 = width - _n___9;
#line 1153
      if (_delta___9 > 0) {
#line 1153
        tmp___18 = _delta___9;
      } else {
#line 1153
        tmp___18 = 0;
      }
#line 1153
      _incr___9 = _n___9 + tmp___18;
#line 1153
      if ((size_t )_incr___9 >= maxsize - i) {
#line 1153
        return ((size_t )0);
      }
#line 1153
      if (p) {
#line 1153
        if (digits == 0) {
#line 1153
          if (_delta___9 > 0) {
#line 1153
            if (pad == 48) {
              {
#line 1153
              memset((void *)p, '0', (size_t )_delta___9);
#line 1153
              p += _delta___9;
              }
            } else {
              {
#line 1153
              memset((void *)p, ' ', (size_t )_delta___9);
#line 1153
              p += _delta___9;
              }
            }
          }
        }
#line 1153
        *p = (char )'\t';
#line 1153
        p += _n___9;
      }
#line 1153
      i += (size_t )_incr___9;
#line 1153
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 1154
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1157
    digits = 1;
#line 1157
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1157
    goto do_number;
    case_85: /* CIL Label */ 
#line 1160
    if (modifier == 69) {
#line 1161
      goto bad_format;
    }
#line 1163
    digits = 2;
#line 1163
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1163
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1168
    if (modifier == 69) {
#line 1169
      goto bad_format;
    }
#line 1175
    if (tp->tm_year < 0) {
#line 1175
      tmp___19 = 300;
    } else {
#line 1175
      tmp___19 = -100;
    }
    {
#line 1175
    year = (int )(tp->tm_year + (int const   )tmp___19);
#line 1179
    year_adjust = 0;
#line 1180
    tmp___20 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1180
    days = tmp___20;
    }
#line 1182
    if (days < 0) {
#line 1185
      year_adjust = -1;
#line 1186
      if ((year - 1) % 4 == 0) {
#line 1186
        if ((year - 1) % 100 != 0) {
#line 1186
          tmp___21 = 1;
        } else
#line 1186
        if ((year - 1) % 400 == 0) {
#line 1186
          tmp___21 = 1;
        } else {
#line 1186
          tmp___21 = 0;
        }
      } else {
#line 1186
        tmp___21 = 0;
      }
      {
#line 1186
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___21)), (int )tp->tm_wday);
      }
    } else {
#line 1191
      if (year % 4 == 0) {
#line 1191
        if (year % 100 != 0) {
#line 1191
          tmp___22 = 1;
        } else
#line 1191
        if (year % 400 == 0) {
#line 1191
          tmp___22 = 1;
        } else {
#line 1191
          tmp___22 = 0;
        }
      } else {
#line 1191
        tmp___22 = 0;
      }
      {
#line 1191
      tmp___23 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___22)),
                               (int )tp->tm_wday);
#line 1191
      d___0 = tmp___23;
      }
#line 1193
      if (0 <= d___0) {
#line 1196
        year_adjust = 1;
#line 1197
        days = d___0;
      }
    }
    {
#line 1203
    if ((int const   )*f == 103) {
#line 1203
      goto case_103___0;
    }
#line 1213
    if ((int const   )*f == 71) {
#line 1213
      goto case_71___0;
    }
#line 1218
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1205
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1206
    digits = 2;
#line 1206
    if (0 <= yy) {
#line 1206
      number_value = yy;
    } else {
#line 1206
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1206
        tmp___24 = - yy;
      } else {
#line 1206
        tmp___24 = yy + 100;
      }
#line 1206
      number_value = tmp___24;
    }
#line 1206
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1214
    digits = 4;
#line 1214
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1214
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1214
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1219
    digits = 2;
#line 1219
    number_value = days / 7 + 1;
#line 1219
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1224
    if (modifier == 69) {
#line 1225
      goto bad_format;
    }
#line 1227
    digits = 2;
#line 1227
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1227
    goto do_number;
    case_119: /* CIL Label */ 
#line 1230
    if (modifier == 69) {
#line 1231
      goto bad_format;
    }
#line 1233
    digits = 1;
#line 1233
    number_value = (int )tp->tm_wday;
#line 1233
    goto do_number;
    case_89: /* CIL Label */ 
#line 1236
    if (modifier == 69) {
#line 1250
      goto underlying_strftime;
    }
#line 1253
    if (modifier == 79) {
#line 1254
      goto bad_format;
    } else {
#line 1256
      digits = 4;
    }
#line 1256
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1256
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1256
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1260
    if (modifier == 69) {
#line 1271
      goto underlying_strftime;
    }
#line 1276
    yy___0 = (int )(tp->tm_year % 100);
#line 1277
    if (yy___0 < 0) {
#line 1278
      if (tp->tm_year < -1900) {
#line 1278
        yy___0 = - yy___0;
      } else {
#line 1278
        yy___0 += 100;
      }
    }
#line 1279
    digits = 2;
#line 1279
    number_value = yy___0;
#line 1279
    goto do_number;
    case_90: /* CIL Label */ 
#line 1283
    if (change_case) {
#line 1285
      to_uppcase = (_Bool)0;
#line 1286
      to_lowcase = (_Bool)1;
    }
#line 1294
    if (! zone) {
#line 1295
      zone = "";
    }
    {
#line 1307
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 1307
      tmp___25 = strlen(zone);
#line 1307
      _n___10 = (int )tmp___25;
#line 1307
      _delta___10 = width - _n___10;
      }
#line 1307
      if (_delta___10 > 0) {
#line 1307
        tmp___26 = _delta___10;
      } else {
#line 1307
        tmp___26 = 0;
      }
#line 1307
      _incr___10 = _n___10 + tmp___26;
#line 1307
      if ((size_t )_incr___10 >= maxsize - i) {
#line 1307
        return ((size_t )0);
      }
#line 1307
      if (p) {
#line 1307
        if (digits == 0) {
#line 1307
          if (_delta___10 > 0) {
#line 1307
            if (pad == 48) {
              {
#line 1307
              memset((void *)p, '0', (size_t )_delta___10);
#line 1307
              p += _delta___10;
              }
            } else {
              {
#line 1307
              memset((void *)p, ' ', (size_t )_delta___10);
#line 1307
              p += _delta___10;
              }
            }
          }
        }
#line 1307
        if (to_lowcase) {
          {
#line 1307
          memcpy_lowcase(p, zone, (size_t )_n___10);
          }
        } else
#line 1307
        if (to_uppcase) {
          {
#line 1307
          memcpy_uppcase(p, zone, (size_t )_n___10);
          }
        } else {
          {
#line 1307
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)zone),
                 (size_t )_n___10);
          }
        }
#line 1307
        p += _n___10;
      }
#line 1307
      i += (size_t )_incr___10;
#line 1307
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1309
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1314
    colons = (size_t )1;
    {
#line 1314
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1314
      if (! ((int const   )*(f + colons) == 58)) {
#line 1314
        goto while_break___17;
      }
#line 1315
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1314
      colons ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1316
    if ((int const   )*(f + colons) != 122) {
#line 1317
      goto bad_format;
    }
#line 1318
    f += colons;
#line 1319
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1322
    colons = (size_t )0;
    do_z_conversion: 
#line 1325
    if (tp->tm_isdst < 0) {
#line 1326
      goto switch_break___1;
    }
#line 1334
    diff = (int )tp->tm_gmtoff;
#line 1371
    hour_diff = (diff / 60) / 60;
#line 1372
    min_diff = (diff / 60) % 60;
#line 1373
    sec_diff = diff % 60;
    {
#line 1377
    if (colons == 0U) {
#line 1377
      goto case_0;
    }
#line 1380
    if (colons == 1U) {
#line 1380
      goto tz_hh_mm;
    }
#line 1383
    if (colons == 2U) {
#line 1383
      goto tz_hh_mm_ss;
    }
#line 1387
    if (colons == 3U) {
#line 1387
      goto case_3;
    }
#line 1394
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1378
    digits = 5;
#line 1378
    negative_number = (_Bool )(diff < 0);
#line 1378
    tz_colon_mask = 0;
#line 1378
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1378
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1381
    digits = 6;
#line 1381
    negative_number = (_Bool )(diff < 0);
#line 1381
    tz_colon_mask = 4;
#line 1381
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1381
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1384
    digits = 9;
#line 1384
    negative_number = (_Bool )(diff < 0);
#line 1384
    tz_colon_mask = 20;
#line 1384
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1384
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1388
    if (sec_diff != 0) {
#line 1389
      goto tz_hh_mm_ss;
    }
#line 1390
    if (min_diff != 0) {
#line 1391
      goto tz_hh_mm;
    }
#line 1392
    digits = 3;
#line 1392
    negative_number = (_Bool )(diff < 0);
#line 1392
    tz_colon_mask = 0;
#line 1392
    u_number_value = (unsigned int )hour_diff;
#line 1392
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1395
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1400
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1409
    flen = 1;
    {
#line 1409
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1409
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1409
        goto while_break___18;
      }
#line 1410
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1409
      flen ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 1411
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1411
      _n___11 = flen;
#line 1411
      _delta___11 = width - _n___11;
#line 1411
      if (_delta___11 > 0) {
#line 1411
        tmp___27 = _delta___11;
      } else {
#line 1411
        tmp___27 = 0;
      }
#line 1411
      _incr___11 = _n___11 + tmp___27;
#line 1411
      if ((size_t )_incr___11 >= maxsize - i) {
#line 1411
        return ((size_t )0);
      }
#line 1411
      if (p) {
#line 1411
        if (digits == 0) {
#line 1411
          if (_delta___11 > 0) {
#line 1411
            if (pad == 48) {
              {
#line 1411
              memset((void *)p, '0', (size_t )_delta___11);
#line 1411
              p += _delta___11;
              }
            } else {
              {
#line 1411
              memset((void *)p, ' ', (size_t )_delta___11);
#line 1411
              p += _delta___11;
              }
            }
          }
        }
#line 1411
        if (to_lowcase) {
          {
#line 1411
          memcpy_lowcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else
#line 1411
        if (to_uppcase) {
          {
#line 1411
          memcpy_uppcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else {
          {
#line 1411
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(f + (1 - flen))),
                 (size_t )_n___11);
          }
        }
#line 1411
        p += _n___11;
      }
#line 1411
      i += (size_t )_incr___11;
#line 1411
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1413
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 494
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1418
  if (p) {
#line 1418
    if (maxsize != 0U) {
#line 1419
      *p = (char )'\000';
    }
  }
#line 1422
  return (i);
}
}
#line 1431 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1436
  tmp = strftime_case_((_Bool)0, s, maxsize, format, tp, ut, ns);
  }
#line 1436
  return (tmp);
}
}
#line 191 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 192
enum quoting_style  const  quoting_style_vals[8] ;
#line 202
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 205
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 209
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 216
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 222
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 235
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 242
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 251
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 261
char *quotearg_n(int n , char const   *arg ) ;
#line 264
char *quotearg(char const   *arg ) ;
#line 269
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 272
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 277
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 282
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 286
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 289
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 293
char *quotearg_char(char const   *arg , char ch ) ;
#line 296
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 299
char *quotearg_colon(char const   *arg ) ;
#line 302
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 305
void quotearg_free(void) ;
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 122
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 122 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 125
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 125
    tmp = -1;
  } else {
#line 125
    tmp = -2;
  }
#line 125
  if ((size_t )tmp / s < n) {
    {
#line 126
    xalloc_die();
    }
  }
  {
#line 127
  tmp___0 = xmalloc(n * s);
  }
#line 127
  return (tmp___0);
}
}
#line 233
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 234
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 234 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 237
  if (sizeof(char ) == 1UL) {
    {
#line 237
    tmp = xmalloc(n);
#line 237
    tmp___1 = tmp;
    }
  } else {
    {
#line 237
    tmp___0 = xnmalloc(n, (size_t )sizeof(char ));
#line 237
    tmp___1 = tmp___0;
    }
  }
#line 237
  return ((char *)tmp___1);
}
}
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 359 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 363
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 137 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 76
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 89 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 94 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 97
  tmp = __errno_location();
#line 97
  e = *tmp;
  }
#line 98
  if (o) {
#line 98
    tmp___0 = o;
  } else {
#line 98
    tmp___0 = & default_quoting_options;
  }
  {
#line 98
  tmp___1 = xmemdup((void const   *)tmp___0, (size_t )sizeof(*o));
#line 98
  p = (struct quoting_options *)tmp___1;
#line 100
  tmp___2 = __errno_location();
#line 100
  *tmp___2 = e;
  }
#line 101
  return (p);
}
}
#line 105 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 108
  if (o) {
#line 108
    tmp = o;
  } else {
#line 108
    tmp = & default_quoting_options;
  }
#line 108
  return (tmp->style);
}
}
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 116
  if (o) {
#line 116
    tmp = o;
  } else {
#line 116
    tmp = & default_quoting_options;
  }
#line 116
  tmp->style = s;
#line 117
  return;
}
}
#line 124 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 127
  uc = (unsigned char )c;
#line 128
  if (o) {
#line 128
    tmp = o;
  } else {
#line 128
    tmp = & default_quoting_options;
  }
#line 128
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 130
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 131
  r = (int )((*p >> shift) & 1U);
#line 132
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 133
  return (r);
}
}
#line 140 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 144
  if (! o) {
#line 145
    o = & default_quoting_options;
  }
#line 146
  r = o->flags;
#line 147
  o->flags = i;
#line 148
  return (r);
}
}
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;

  {
  {
#line 156
  o.style = style;
#line 157
  o.flags = 0;
#line 158
  memset((void *)(o.quote_these_too), 0, (size_t )sizeof(o.quote_these_too));
  }
#line 159
  return (o);
}
}
#line 164 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 167
  tmp = gettext(msgid);
#line 167
  translation = (char const   *)tmp;
  }
#line 168
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 168
    if ((unsigned int )s == 7U) {
#line 169
      translation = "\"";
    }
  }
#line 170
  return (translation);
}
}
#line 186 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  char const   *left ;
  char const   *tmp___0 ;
  char const   *right ;
  char const   *tmp___1 ;
  unsigned char c ;
  unsigned char esc ;
  int tmp___2 ;
  int tmp___3 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___4 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___5 ;
  size_t j ;
  int tmp___6 ;
  int tmp___7 ;
  size_t ilim ;
  int tmp___8 ;
  size_t tmp___9 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 193
  len = (size_t )0;
#line 194
  quote_string = (char const   *)0;
#line 195
  quote_string_len = (size_t )0;
#line 196
  backslash_escapes = (_Bool)0;
#line 197
  tmp = __ctype_get_mb_cur_max();
#line 197
  unibyte_locale = (_Bool )(tmp == 1U);
#line 198
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 211
  if ((unsigned int )quoting_style == 4U) {
#line 211
    goto case_4;
  }
#line 215
  if ((unsigned int )quoting_style == 3U) {
#line 215
    goto case_3;
  }
#line 223
  if ((unsigned int )quoting_style == 5U) {
#line 223
    goto case_5;
  }
#line 229
  if ((unsigned int )quoting_style == 7U) {
#line 229
    goto case_7;
  }
#line 229
  if ((unsigned int )quoting_style == 6U) {
#line 229
    goto case_7;
  }
#line 262
  if ((unsigned int )quoting_style == 1U) {
#line 262
    goto case_1;
  }
#line 266
  if ((unsigned int )quoting_style == 2U) {
#line 266
    goto case_2;
  }
#line 273
  if ((unsigned int )quoting_style == 0U) {
#line 273
    goto case_0;
  }
#line 277
  goto switch_default;
  case_4: /* CIL Label */ 
#line 212
  quoting_style = (enum quoting_style )3;
#line 213
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 216
  if (! elide_outer_quotes) {
    {
#line 217
    while (1) {
      while_continue: /* CIL Label */ ;
#line 217
      if (len < buffersize) {
#line 217
        *(buffer + len) = (char )'\"';
      }
#line 217
      len ++;
#line 217
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 218
  backslash_escapes = (_Bool)1;
#line 219
  quote_string = "\"";
#line 220
  quote_string_len = (size_t )1;
#line 221
  goto switch_break;
  case_5: /* CIL Label */ 
#line 224
  backslash_escapes = (_Bool)1;
#line 225
  elide_outer_quotes = (_Bool)0;
#line 226
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 251
  tmp___0 = gettext_quote("`", quoting_style);
#line 251
  left = tmp___0;
#line 252
  tmp___1 = gettext_quote("\'", quoting_style);
#line 252
  right = tmp___1;
  }
#line 253
  if (! elide_outer_quotes) {
#line 254
    quote_string = left;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! *quote_string) {
#line 254
        goto while_break___0;
      }
      {
#line 255
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 255
        if (len < buffersize) {
#line 255
          *(buffer + len) = (char )*quote_string;
        }
#line 255
        len ++;
#line 255
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 254
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 256
  backslash_escapes = (_Bool)1;
#line 257
  quote_string = right;
#line 258
  quote_string_len = strlen(quote_string);
  }
#line 260
  goto switch_break;
  case_1: /* CIL Label */ 
#line 263
  quoting_style = (enum quoting_style )2;
#line 264
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 267
  if (! elide_outer_quotes) {
    {
#line 268
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 268
      if (len < buffersize) {
#line 268
        *(buffer + len) = (char )'\'';
      }
#line 268
      len ++;
#line 268
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 269
  quote_string = "\'";
#line 270
  quote_string_len = (size_t )1;
#line 271
  goto switch_break;
  case_0: /* CIL Label */ 
#line 274
  elide_outer_quotes = (_Bool)0;
#line 275
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 278
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 281
  i = (size_t )0;
  {
#line 281
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 281
    if (argsize == 4294967295U) {
#line 281
      tmp___8 = (int const   )*(arg + i) == 0;
    } else {
#line 281
      tmp___8 = i == argsize;
    }
#line 281
    if (tmp___8) {
#line 281
      goto while_break___3;
    }
#line 286
    if (backslash_escapes) {
#line 286
      if (quote_string_len) {
#line 286
        if (i + quote_string_len <= argsize) {
          {
#line 286
          tmp___2 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 286
          if (tmp___2 == 0) {
#line 291
            if (elide_outer_quotes) {
#line 292
              goto force_outer_quoting_style;
            }
            {
#line 293
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 293
              if (len < buffersize) {
#line 293
                *(buffer + len) = (char )'\\';
              }
#line 293
              len ++;
#line 293
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 296
    c = (unsigned char )*(arg + i);
    {
#line 299
    if ((int )c == 0) {
#line 299
      goto case_0___0;
    }
#line 316
    if ((int )c == 63) {
#line 316
      goto case_63;
    }
#line 354
    if ((int )c == 7) {
#line 354
      goto case_7___0;
    }
#line 355
    if ((int )c == 8) {
#line 355
      goto case_8;
    }
#line 356
    if ((int )c == 12) {
#line 356
      goto case_12;
    }
#line 357
    if ((int )c == 10) {
#line 357
      goto case_10;
    }
#line 358
    if ((int )c == 13) {
#line 358
      goto case_13;
    }
#line 359
    if ((int )c == 9) {
#line 359
      goto case_9;
    }
#line 360
    if ((int )c == 11) {
#line 360
      goto case_11;
    }
#line 361
    if ((int )c == 92) {
#line 361
      goto case_92;
    }
#line 380
    if ((int )c == 125) {
#line 380
      goto case_125;
    }
#line 380
    if ((int )c == 123) {
#line 380
      goto case_125;
    }
#line 384
    if ((int )c == 126) {
#line 384
      goto case_126;
    }
#line 384
    if ((int )c == 35) {
#line 384
      goto case_126;
    }
#line 396
    if ((int )c == 124) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 96) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 94) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 91) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 62) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 61) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 60) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 59) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 42) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 41) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 40) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 38) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 36) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 34) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 33) {
#line 396
      goto case_124;
    }
#line 396
    if ((int )c == 32) {
#line 396
      goto case_124;
    }
#line 406
    if ((int )c == 39) {
#line 406
      goto case_39___0;
    }
#line 428
    if ((int )c == 122) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 121) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 120) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 119) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 118) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 117) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 116) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 115) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 114) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 113) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 112) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 111) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 110) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 109) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 108) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 107) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 106) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 105) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 104) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 103) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 102) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 101) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 100) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 99) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 98) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 97) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 95) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 93) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 90) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 89) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 88) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 87) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 86) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 85) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 84) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 83) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 82) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 81) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 80) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 79) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 78) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 77) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 76) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 75) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 74) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 73) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 72) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 71) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 70) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 69) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 68) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 67) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 66) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 65) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 58) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 57) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 56) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 55) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 54) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 53) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 52) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 51) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 50) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 49) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 48) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 47) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 46) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 45) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 44) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 43) {
#line 428
      goto case_122;
    }
#line 428
    if ((int )c == 37) {
#line 428
      goto case_122;
    }
#line 433
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 300
    if (backslash_escapes) {
#line 302
      if (elide_outer_quotes) {
#line 303
        goto force_outer_quoting_style;
      }
      {
#line 304
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 304
        if (len < buffersize) {
#line 304
          *(buffer + len) = (char )'\\';
        }
#line 304
        len ++;
#line 304
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 305
      if (i + 1U < argsize) {
#line 305
        if (48 <= (int )*(arg + (i + 1U))) {
#line 305
          if ((int const   )*(arg + (i + 1U)) <= 57) {
            {
#line 307
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 307
              if (len < buffersize) {
#line 307
                *(buffer + len) = (char )'0';
              }
#line 307
              len ++;
#line 307
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 308
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 308
              if (len < buffersize) {
#line 308
                *(buffer + len) = (char )'0';
              }
#line 308
              len ++;
#line 308
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
      }
#line 310
      c = (unsigned char )'0';
    } else
#line 312
    if (flags & 1) {
#line 313
      goto __Cont;
    }
#line 314
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 319
    if ((unsigned int )quoting_style == 2U) {
#line 319
      goto case_2___0;
    }
#line 324
    if ((unsigned int )quoting_style == 3U) {
#line 324
      goto case_3___0;
    }
#line 349
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 320
    if (elide_outer_quotes) {
#line 321
      goto force_outer_quoting_style;
    }
#line 322
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 325
    if (flags & 4) {
#line 325
      if (i + 2U < argsize) {
#line 325
        if ((int const   )*(arg + (i + 1U)) == 63) {
          {
#line 331
          if ((int const   )*(arg + (i + 2U)) == 62) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i + 2U)) == 61) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i + 2U)) == 60) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i + 2U)) == 47) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i + 2U)) == 45) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i + 2U)) == 41) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i + 2U)) == 40) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i + 2U)) == 39) {
#line 331
            goto case_62;
          }
#line 331
          if ((int const   )*(arg + (i + 2U)) == 33) {
#line 331
            goto case_62;
          }
#line 344
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 334
          if (elide_outer_quotes) {
#line 335
            goto force_outer_quoting_style;
          }
#line 336
          c = (unsigned char )*(arg + (i + 2U));
#line 337
          i += 2U;
          {
#line 338
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 338
            if (len < buffersize) {
#line 338
              *(buffer + len) = (char )'?';
            }
#line 338
            len ++;
#line 338
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 339
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 339
            if (len < buffersize) {
#line 339
              *(buffer + len) = (char )'\"';
            }
#line 339
            len ++;
#line 339
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 340
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 340
            if (len < buffersize) {
#line 340
              *(buffer + len) = (char )'\"';
            }
#line 340
            len ++;
#line 340
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 341
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 341
            if (len < buffersize) {
#line 341
              *(buffer + len) = (char )'?';
            }
#line 341
            len ++;
#line 341
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 342
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 345
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 347
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 350
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 352
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 354
    esc = (unsigned char )'a';
#line 354
    goto c_escape;
    case_8: /* CIL Label */ 
#line 355
    esc = (unsigned char )'b';
#line 355
    goto c_escape;
    case_12: /* CIL Label */ 
#line 356
    esc = (unsigned char )'f';
#line 356
    goto c_escape;
    case_10: /* CIL Label */ 
#line 357
    esc = (unsigned char )'n';
#line 357
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 358
    esc = (unsigned char )'r';
#line 358
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 359
    esc = (unsigned char )'t';
#line 359
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 360
    esc = (unsigned char )'v';
#line 360
    goto c_escape;
    case_92: /* CIL Label */ 
#line 361
    esc = c;
#line 364
    if (backslash_escapes) {
#line 364
      if (elide_outer_quotes) {
#line 364
        if (quote_string_len) {
#line 365
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 368
    if ((unsigned int )quoting_style == 2U) {
#line 368
      if (elide_outer_quotes) {
#line 370
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 373
    if (backslash_escapes) {
#line 375
      c = esc;
#line 376
      goto store_escape;
    }
#line 378
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 381
    if (argsize == 4294967295U) {
#line 381
      tmp___3 = (int const   )*(arg + 1) == 0;
    } else {
#line 381
      tmp___3 = argsize == 1U;
    }
#line 381
    if (! tmp___3) {
#line 382
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 385
    if (i != 0U) {
#line 386
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 401
    if ((unsigned int )quoting_style == 2U) {
#line 401
      if (elide_outer_quotes) {
#line 403
        goto force_outer_quoting_style;
      }
    }
#line 404
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 407
    if ((unsigned int )quoting_style == 2U) {
#line 409
      if (elide_outer_quotes) {
#line 410
        goto force_outer_quoting_style;
      }
      {
#line 411
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 411
        if (len < buffersize) {
#line 411
          *(buffer + len) = (char )'\'';
        }
#line 411
        len ++;
#line 411
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 412
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 412
        if (len < buffersize) {
#line 412
          *(buffer + len) = (char )'\\';
        }
#line 412
        len ++;
#line 412
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 413
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 413
        if (len < buffersize) {
#line 413
          *(buffer + len) = (char )'\'';
        }
#line 413
        len ++;
#line 413
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 415
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 431
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 445
    if (unibyte_locale) {
      {
#line 447
      m = (size_t )1;
#line 448
      tmp___4 = __ctype_b_loc();
#line 448
      printable = (_Bool )(((int const   )*(*tmp___4 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 453
      memset((void *)(& mbstate), 0, (size_t )sizeof(mbstate));
#line 455
      m = (size_t )0;
#line 456
      printable = (_Bool)1;
      }
#line 457
      if (argsize == 4294967295U) {
        {
#line 458
        argsize = strlen(arg);
        }
      }
      {
#line 460
      while (1) {
        while_continue___15: /* CIL Label */ ;
        {
#line 463
        tmp___5 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), & mbstate);
#line 463
        bytes = tmp___5;
        }
#line 465
        if (bytes == 0U) {
#line 466
          goto while_break___15;
        } else
#line 467
        if (bytes == 4294967295U) {
#line 469
          printable = (_Bool)0;
#line 470
          goto while_break___15;
        } else
#line 472
        if (bytes == 4294967294U) {
#line 474
          printable = (_Bool)0;
          {
#line 475
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 475
            if (i + m < argsize) {
#line 475
              if (! *(arg + (i + m))) {
#line 475
                goto while_break___16;
              }
            } else {
#line 475
              goto while_break___16;
            }
#line 476
            m ++;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 477
          goto while_break___15;
        } else {
#line 485
          if (elide_outer_quotes) {
#line 485
            if ((unsigned int )quoting_style == 2U) {
#line 489
              j = (size_t )1;
              {
#line 489
              while (1) {
                while_continue___17: /* CIL Label */ ;
#line 489
                if (! (j < bytes)) {
#line 489
                  goto while_break___17;
                }
                {
#line 493
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 493
                  goto case_124___0;
                }
#line 493
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 493
                  goto case_124___0;
                }
#line 493
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 493
                  goto case_124___0;
                }
#line 493
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 493
                  goto case_124___0;
                }
#line 493
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 493
                  goto case_124___0;
                }
#line 496
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 494
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 497
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 489
                j ++;
              }
              while_break___17: /* CIL Label */ ;
              }
            }
          }
          {
#line 501
          tmp___6 = iswprint((wint_t )w);
          }
#line 501
          if (! tmp___6) {
#line 502
            printable = (_Bool)0;
          }
#line 503
          m += bytes;
        }
        {
#line 460
        tmp___7 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 460
        if (tmp___7) {
#line 460
          goto while_break___15;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 509
    if (1U < m) {
#line 509
      goto _L;
    } else
#line 509
    if (backslash_escapes) {
#line 509
      if (! printable) {
        _L: /* CIL Label */ 
#line 513
        ilim = i + m;
        {
#line 515
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 517
          if (backslash_escapes) {
#line 517
            if (! printable) {
#line 519
              if (elide_outer_quotes) {
#line 520
                goto force_outer_quoting_style;
              }
              {
#line 521
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 521
                if (len < buffersize) {
#line 521
                  *(buffer + len) = (char )'\\';
                }
#line 521
                len ++;
#line 521
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 522
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 522
                if (len < buffersize) {
#line 522
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 522
                len ++;
#line 522
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
              {
#line 523
              while (1) {
                while_continue___21: /* CIL Label */ ;
#line 523
                if (len < buffersize) {
#line 523
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 523
                len ++;
#line 523
                goto while_break___21;
              }
              while_break___21: /* CIL Label */ ;
              }
#line 524
              c = (unsigned char )(48 + ((int )c & 7));
            }
          }
#line 526
          if (ilim <= i + 1U) {
#line 527
            goto while_break___18;
          }
          {
#line 528
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 528
            if (len < buffersize) {
#line 528
              *(buffer + len) = (char )c;
            }
#line 528
            len ++;
#line 528
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 529
          i ++;
#line 529
          c = (unsigned char )*(arg + i);
        }
        while_break___18: /* CIL Label */ ;
        }
#line 532
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 537
    if (backslash_escapes) {
#line 537
      goto _L___0;
    } else
#line 537
    if (elide_outer_quotes) {
      _L___0: /* CIL Label */ 
#line 537
      if (quote_these_too) {
#line 537
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 540
          goto store_c;
        }
      } else {
#line 540
        goto store_c;
      }
    } else {
#line 540
      goto store_c;
    }
    store_escape: 
#line 543
    if (elide_outer_quotes) {
#line 544
      goto force_outer_quoting_style;
    }
    {
#line 545
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 545
      if (len < buffersize) {
#line 545
        *(buffer + len) = (char )'\\';
      }
#line 545
      len ++;
#line 545
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 548
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 548
      if (len < buffersize) {
#line 548
        *(buffer + len) = (char )c;
      }
#line 548
      len ++;
#line 548
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 281
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 551
  if (len == 0U) {
#line 551
    if ((unsigned int )quoting_style == 2U) {
#line 551
      if (elide_outer_quotes) {
#line 553
        goto force_outer_quoting_style;
      }
    }
  }
#line 555
  if (quote_string) {
#line 555
    if (! elide_outer_quotes) {
      {
#line 556
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 556
        if (! *quote_string) {
#line 556
          goto while_break___25;
        }
        {
#line 557
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 557
          if (len < buffersize) {
#line 557
            *(buffer + len) = (char )*quote_string;
          }
#line 557
          len ++;
#line 557
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 556
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 559
  if (len < buffersize) {
#line 560
    *(buffer + len) = (char )'\000';
  }
#line 561
  return (len);
  force_outer_quoting_style: 
  {
#line 566
  tmp___9 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0));
  }
#line 566
  return (tmp___9);
}
}
#line 580 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 585
  if (o) {
#line 585
    tmp = o;
  } else {
#line 585
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 585
  p = tmp;
#line 586
  tmp___0 = __errno_location();
#line 586
  e = *tmp___0;
#line 587
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too));
#line 587
  r = tmp___1;
#line 589
  tmp___2 = __errno_location();
#line 589
  *tmp___2 = e;
  }
#line 590
  return (r);
}
}
#line 594 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 598
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 598
  return (tmp);
}
}
#line 607 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize___1 ;
  size_t tmp___2 ;
  char *buf___1 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 611
  if (o) {
#line 611
    tmp = o;
  } else {
#line 611
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 611
  p = tmp;
#line 612
  tmp___0 = __errno_location();
#line 612
  e = *tmp___0;
  }
#line 614
  if (size) {
#line 614
    tmp___1 = 0;
  } else {
#line 614
    tmp___1 = 1;
  }
  {
#line 614
  flags = (int )(p->flags | (int const   )tmp___1);
#line 615
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too));
#line 615
  bufsize___1 = tmp___2 + 1U;
#line 617
  tmp___3 = xcharalloc(bufsize___1);
#line 617
  buf___1 = tmp___3;
#line 618
  quotearg_buffer_restyled(buf___1, bufsize___1, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too));
#line 620
  tmp___4 = __errno_location();
#line 620
  *tmp___4 = e;
  }
#line 621
  if (size) {
#line 622
    *size = bufsize___1 - 1U;
  }
#line 623
  return (buf___1);
}
}
#line 635 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static char slot0[256]  ;
#line 636 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static unsigned int nslots  =    1U;
#line 637 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static struct slotvec slotvec0  =    {(size_t )sizeof(slot0), slot0};
#line 638 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 640 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 643
  sv = slotvec;
#line 645
  i = 1U;
  {
#line 645
  while (1) {
    while_continue: /* CIL Label */ ;
#line 645
    if (! (i < nslots)) {
#line 645
      goto while_break;
    }
    {
#line 646
    free((void *)(sv + i)->val);
#line 645
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 649
    free((void *)(sv + 0)->val);
#line 650
    slotvec0.size = (size_t )sizeof(slot0);
#line 651
    slotvec0.val = slot0;
    }
  }
#line 653
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 655
    free((void *)sv);
#line 656
    slotvec = & slotvec0;
    }
  }
#line 658
  nslots = 1U;
#line 659
  return;
}
}
#line 669 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 673
  tmp = __errno_location();
#line 673
  e = *tmp;
#line 675
  n0 = (unsigned int )n;
#line 676
  sv = slotvec;
  }
#line 678
  if (n < 0) {
    {
#line 679
    abort();
    }
  }
#line 681
  if (nslots <= n0) {
#line 688
    n1 = n0 + 1U;
#line 689
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 691
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 691
      tmp___0 = -1;
    } else {
#line 691
      tmp___0 = -2;
    }
#line 691
    if ((unsigned long )((size_t )tmp___0) / sizeof(*sv) < (unsigned long )n1) {
      {
#line 692
      xalloc_die();
      }
    }
#line 694
    if (preallocated) {
#line 694
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 694
      tmp___1 = sv;
    }
    {
#line 694
    tmp___2 = xrealloc((void *)tmp___1, (size_t )((unsigned long )n1 * sizeof(*sv)));
#line 694
    sv = (struct slotvec *)tmp___2;
#line 694
    slotvec = sv;
    }
#line 695
    if (preallocated) {
#line 696
      *sv = slotvec0;
    }
    {
#line 697
    memset((void *)(sv + nslots), 0, (size_t )((unsigned long )(n1 - nslots) * sizeof(*sv)));
#line 698
    nslots = n1;
    }
  }
  {
#line 702
  size = (sv + n)->size;
#line 703
  val = (sv + n)->val;
#line 705
  flags = (int )(options->flags | 1);
#line 706
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too));
#line 706
  qsize = tmp___3;
  }
#line 710
  if (size <= qsize) {
#line 712
    size = qsize + 1U;
#line 712
    (sv + n)->size = size;
#line 713
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 714
      free((void *)val);
      }
    }
    {
#line 715
    val = xcharalloc(size);
#line 715
    (sv + n)->val = val;
#line 716
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too));
    }
  }
  {
#line 720
  tmp___4 = __errno_location();
#line 720
  *tmp___4 = e;
  }
#line 721
  return (val);
}
}
#line 725 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 728
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 728
  return (tmp);
}
}
#line 731 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 734
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 734
  return (tmp);
}
}
#line 737 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 740
  tmp = quotearg_n(0, arg);
  }
#line 740
  return (tmp);
}
}
#line 743 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 746
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 746
  return (tmp);
}
}
#line 749 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 752
  tmp = quoting_options_from_style(s);
#line 752
  o = tmp;
#line 753
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
  }
#line 753
  return (tmp___0);
}
}
#line 756 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 760
  tmp = quoting_options_from_style(s);
#line 760
  o = tmp;
#line 761
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 761
  return (tmp___0);
}
}
#line 764 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 767
  tmp = quotearg_n_style(0, s, arg);
  }
#line 767
  return (tmp);
}
}
#line 770 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 773
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 773
  return (tmp);
}
}
#line 776 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 780
  options = default_quoting_options;
#line 781
  set_char_quoting(& options, ch, 1);
#line 782
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 782
  return (tmp);
}
}
#line 785 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 788
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
  }
#line 788
  return (tmp);
}
}
#line 791 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 794
  tmp = quotearg_char(arg, (char )':');
  }
#line 794
  return (tmp);
}
}
#line 797 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 800
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 800
  return (tmp);
}
}
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quote.h"
char const   *quote_n(int n , char const   *name ) ;
#line 23
char const   *quote(char const   *name ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quote.c"
char const   *quote_n(int n , char const   *name ) 
{ 
  char *tmp ;

  {
  {
#line 33
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
  }
#line 33
  return ((char const   *)tmp);
}
}
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/quote.c"
char const   *quote(char const   *name ) 
{ 
  char const   *tmp ;

  {
  {
#line 41
  tmp = quote_n(0, name);
  }
#line 41
  return (tmp);
}
}
#line 82 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  void *tmp ;
  char c ;
  char const   *tmp___0 ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___3 ;
  size_t __attribute__((__pure__))  tmp___4 ;
  size_t tmp___5 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___11 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t tmp___13 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;

  {
  {
#line 85
  cp = format;
#line 86
  arg_posn = (size_t )0;
#line 89
  max_width_length = (size_t )0;
#line 90
  max_precision_length = (size_t )0;
#line 92
  d->count = (size_t )0;
#line 93
  d_allocated = (size_t )1;
#line 94
  tmp = malloc((size_t )((unsigned long )d_allocated * sizeof(char_directive )));
#line 94
  d->dir = (char_directive *)tmp;
  }
#line 95
  if ((unsigned long )d->dir == (unsigned long )((void *)0)) {
#line 97
    goto out_of_memory_1;
  }
#line 99
  a->count = (size_t )0;
#line 100
  a_allocated = (size_t )0;
#line 101
  a->arg = (argument *)((void *)0);
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int const   )*cp != 0)) {
#line 135
      goto while_break;
    }
#line 137
    tmp___0 = cp;
#line 137
    cp ++;
#line 137
    c = (char )*tmp___0;
#line 138
    if ((int )c == 37) {
#line 140
      arg_index = ~ ((size_t )0);
#line 141
      dp = d->dir + d->count;
#line 144
      dp->dir_start = cp - 1;
#line 145
      dp->flags = 0;
#line 146
      dp->width_start = (char const   *)((void *)0);
#line 147
      dp->width_end = (char const   *)((void *)0);
#line 148
      dp->width_arg_index = ~ ((size_t )0);
#line 149
      dp->precision_start = (char const   *)((void *)0);
#line 150
      dp->precision_end = (char const   *)((void *)0);
#line 151
      dp->precision_arg_index = ~ ((size_t )0);
#line 152
      dp->arg_index = ~ ((size_t )0);
#line 155
      if ((int const   )*cp >= 48) {
#line 155
        if ((int const   )*cp <= 57) {
#line 159
          np = cp;
          {
#line 159
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 159
            if ((int const   )*np >= 48) {
#line 159
              if (! ((int const   )*np <= 57)) {
#line 159
                goto while_break___0;
              }
            } else {
#line 159
              goto while_break___0;
            }
#line 159
            np ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 161
          if ((int const   )*np == 36) {
#line 163
            n = (size_t )0;
#line 165
            np = cp;
            {
#line 165
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 165
              if ((int const   )*np >= 48) {
#line 165
                if (! ((int const   )*np <= 57)) {
#line 165
                  goto while_break___1;
                }
              } else {
#line 165
                goto while_break___1;
              }
#line 166
              if (n <= 429496729U) {
#line 166
                tmp___1 = n * 10U;
              } else {
#line 166
                tmp___1 = 4294967295U;
              }
              {
#line 166
              tmp___2 = xsum(tmp___1, (size_t )((int const   )*np - 48));
#line 166
              n = (size_t )tmp___2;
#line 165
              np ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 167
            if (n == 0U) {
#line 169
              goto error;
            }
#line 170
            if (n == 4294967295U) {
#line 172
              goto error;
            }
#line 173
            arg_index = n - 1U;
#line 174
            cp = np + 1;
          }
        }
      }
      {
#line 179
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 181
        if ((int const   )*cp == 39) {
#line 183
          dp->flags |= 1;
#line 184
          cp ++;
        } else
#line 186
        if ((int const   )*cp == 45) {
#line 188
          dp->flags |= 2;
#line 189
          cp ++;
        } else
#line 191
        if ((int const   )*cp == 43) {
#line 193
          dp->flags |= 4;
#line 194
          cp ++;
        } else
#line 196
        if ((int const   )*cp == 32) {
#line 198
          dp->flags |= 8;
#line 199
          cp ++;
        } else
#line 201
        if ((int const   )*cp == 35) {
#line 203
          dp->flags |= 16;
#line 204
          cp ++;
        } else
#line 206
        if ((int const   )*cp == 48) {
#line 208
          dp->flags |= 32;
#line 209
          cp ++;
        } else {
#line 212
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 216
      if ((int const   )*cp == 42) {
#line 218
        dp->width_start = cp;
#line 219
        cp ++;
#line 220
        dp->width_end = cp;
#line 221
        if (max_width_length < 1U) {
#line 222
          max_width_length = (size_t )1;
        }
#line 225
        if ((int const   )*cp >= 48) {
#line 225
          if ((int const   )*cp <= 57) {
#line 229
            np___0 = cp;
            {
#line 229
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 229
              if ((int const   )*np___0 >= 48) {
#line 229
                if (! ((int const   )*np___0 <= 57)) {
#line 229
                  goto while_break___3;
                }
              } else {
#line 229
                goto while_break___3;
              }
#line 229
              np___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 231
            if ((int const   )*np___0 == 36) {
#line 233
              n___0 = (size_t )0;
#line 235
              np___0 = cp;
              {
#line 235
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 235
                if ((int const   )*np___0 >= 48) {
#line 235
                  if (! ((int const   )*np___0 <= 57)) {
#line 235
                    goto while_break___4;
                  }
                } else {
#line 235
                  goto while_break___4;
                }
#line 236
                if (n___0 <= 429496729U) {
#line 236
                  tmp___3 = n___0 * 10U;
                } else {
#line 236
                  tmp___3 = 4294967295U;
                }
                {
#line 236
                tmp___4 = xsum(tmp___3, (size_t )((int const   )*np___0 - 48));
#line 236
                n___0 = (size_t )tmp___4;
#line 235
                np___0 ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 237
              if (n___0 == 0U) {
#line 239
                goto error;
              }
#line 240
              if (n___0 == 4294967295U) {
#line 242
                goto error;
              }
#line 243
              dp->width_arg_index = n___0 - 1U;
#line 244
              cp = np___0 + 1;
            }
          }
        }
#line 247
        if (dp->width_arg_index == 4294967295U) {
#line 249
          tmp___5 = arg_posn;
#line 249
          arg_posn ++;
#line 249
          dp->width_arg_index = tmp___5;
#line 250
          if (dp->width_arg_index == 4294967295U) {
#line 252
            goto error;
          }
        }
#line 254
        n___1 = dp->width_arg_index;
#line 254
        if (n___1 >= a_allocated) {
#line 254
          if (a_allocated <= 2147483647U) {
#line 254
            a_allocated *= 2U;
          } else {
#line 254
            a_allocated = 4294967295U;
          }
#line 254
          if (a_allocated <= n___1) {
            {
#line 254
            tmp___6 = xsum(n___1, (size_t )1);
#line 254
            a_allocated = (size_t )tmp___6;
            }
          }
#line 254
          if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 254
            memory_size = (size_t )((unsigned long )a_allocated * sizeof(argument ));
          } else {
#line 254
            memory_size = 4294967295U;
          }
#line 254
          if (memory_size == 4294967295U) {
#line 254
            goto out_of_memory;
          }
#line 254
          if (a->arg) {
            {
#line 254
            tmp___7 = realloc((void *)a->arg, memory_size);
#line 254
            tmp___9 = tmp___7;
            }
          } else {
            {
#line 254
            tmp___8 = malloc(memory_size);
#line 254
            tmp___9 = tmp___8;
            }
          }
#line 254
          memory = (argument *)tmp___9;
#line 254
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 254
            goto out_of_memory;
          }
#line 254
          a->arg = memory;
        }
        {
#line 254
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 254
          if (! (a->count <= n___1)) {
#line 254
            goto while_break___5;
          }
#line 254
          tmp___10 = a->count;
#line 254
          (a->count) ++;
#line 254
          (a->arg + tmp___10)->type = (arg_type )0;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 254
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 254
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 254
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 254
          goto error;
        }
      } else
#line 256
      if ((int const   )*cp >= 48) {
#line 256
        if ((int const   )*cp <= 57) {
#line 260
          dp->width_start = cp;
          {
#line 261
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 261
            if ((int const   )*cp >= 48) {
#line 261
              if (! ((int const   )*cp <= 57)) {
#line 261
                goto while_break___6;
              }
            } else {
#line 261
              goto while_break___6;
            }
#line 261
            cp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 263
          dp->width_end = cp;
#line 264
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 265
          if (max_width_length < width_length) {
#line 266
            max_width_length = width_length;
          }
        }
      }
#line 270
      if ((int const   )*cp == 46) {
#line 272
        cp ++;
#line 273
        if ((int const   )*cp == 42) {
#line 275
          dp->precision_start = cp - 1;
#line 276
          cp ++;
#line 277
          dp->precision_end = cp;
#line 278
          if (max_precision_length < 2U) {
#line 279
            max_precision_length = (size_t )2;
          }
#line 282
          if ((int const   )*cp >= 48) {
#line 282
            if ((int const   )*cp <= 57) {
#line 286
              np___1 = cp;
              {
#line 286
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 286
                if ((int const   )*np___1 >= 48) {
#line 286
                  if (! ((int const   )*np___1 <= 57)) {
#line 286
                    goto while_break___7;
                  }
                } else {
#line 286
                  goto while_break___7;
                }
#line 286
                np___1 ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 288
              if ((int const   )*np___1 == 36) {
#line 290
                n___2 = (size_t )0;
#line 292
                np___1 = cp;
                {
#line 292
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 292
                  if ((int const   )*np___1 >= 48) {
#line 292
                    if (! ((int const   )*np___1 <= 57)) {
#line 292
                      goto while_break___8;
                    }
                  } else {
#line 292
                    goto while_break___8;
                  }
#line 293
                  if (n___2 <= 429496729U) {
#line 293
                    tmp___11 = n___2 * 10U;
                  } else {
#line 293
                    tmp___11 = 4294967295U;
                  }
                  {
#line 293
                  tmp___12 = xsum(tmp___11, (size_t )((int const   )*np___1 - 48));
#line 293
                  n___2 = (size_t )tmp___12;
#line 292
                  np___1 ++;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 294
                if (n___2 == 0U) {
#line 296
                  goto error;
                }
#line 297
                if (n___2 == 4294967295U) {
#line 300
                  goto error;
                }
#line 301
                dp->precision_arg_index = n___2 - 1U;
#line 302
                cp = np___1 + 1;
              }
            }
          }
#line 305
          if (dp->precision_arg_index == 4294967295U) {
#line 307
            tmp___13 = arg_posn;
#line 307
            arg_posn ++;
#line 307
            dp->precision_arg_index = tmp___13;
#line 308
            if (dp->precision_arg_index == 4294967295U) {
#line 310
              goto error;
            }
          }
#line 312
          n___3 = dp->precision_arg_index;
#line 312
          if (n___3 >= a_allocated) {
#line 312
            if (a_allocated <= 2147483647U) {
#line 312
              a_allocated *= 2U;
            } else {
#line 312
              a_allocated = 4294967295U;
            }
#line 312
            if (a_allocated <= n___3) {
              {
#line 312
              tmp___14 = xsum(n___3, (size_t )1);
#line 312
              a_allocated = (size_t )tmp___14;
              }
            }
#line 312
            if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 312
              memory_size___0 = (size_t )((unsigned long )a_allocated * sizeof(argument ));
            } else {
#line 312
              memory_size___0 = 4294967295U;
            }
#line 312
            if (memory_size___0 == 4294967295U) {
#line 312
              goto out_of_memory;
            }
#line 312
            if (a->arg) {
              {
#line 312
              tmp___15 = realloc((void *)a->arg, memory_size___0);
#line 312
              tmp___17 = tmp___15;
              }
            } else {
              {
#line 312
              tmp___16 = malloc(memory_size___0);
#line 312
              tmp___17 = tmp___16;
              }
            }
#line 312
            memory___0 = (argument *)tmp___17;
#line 312
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 312
              goto out_of_memory;
            }
#line 312
            a->arg = memory___0;
          }
          {
#line 312
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 312
            if (! (a->count <= n___3)) {
#line 312
              goto while_break___9;
            }
#line 312
            tmp___18 = a->count;
#line 312
            (a->count) ++;
#line 312
            (a->arg + tmp___18)->type = (arg_type )0;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 312
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 312
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 312
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 312
            goto error;
          }
        } else {
#line 318
          dp->precision_start = cp - 1;
          {
#line 319
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 319
            if ((int const   )*cp >= 48) {
#line 319
              if (! ((int const   )*cp <= 57)) {
#line 319
                goto while_break___10;
              }
            } else {
#line 319
              goto while_break___10;
            }
#line 319
            cp ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 321
          dp->precision_end = cp;
#line 322
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 323
          if (max_precision_length < precision_length) {
#line 324
            max_precision_length = precision_length;
          }
        }
      }
#line 333
      flags = 0;
      {
#line 335
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 337
        if ((int const   )*cp == 104) {
#line 339
          flags |= 1 << (flags & 1);
#line 340
          cp ++;
        } else
#line 342
        if ((int const   )*cp == 76) {
#line 344
          flags |= 4;
#line 345
          cp ++;
        } else
#line 347
        if ((int const   )*cp == 108) {
#line 349
          flags += 8;
#line 350
          cp ++;
        } else
#line 352
        if ((int const   )*cp == 106) {
#line 354
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 357
            flags += 16;
          } else
#line 359
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 362
            flags += 8;
          }
#line 364
          cp ++;
        } else
#line 366
        if ((int const   )*cp == 122) {
#line 366
          goto _L;
        } else
#line 366
        if ((int const   )*cp == 90) {
          _L: /* CIL Label */ 
#line 371
          if (sizeof(size_t ) > sizeof(long )) {
#line 374
            flags += 16;
          } else
#line 376
          if (sizeof(size_t ) > sizeof(int )) {
#line 379
            flags += 8;
          }
#line 381
          cp ++;
        } else
#line 383
        if ((int const   )*cp == 116) {
#line 385
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 388
            flags += 16;
          } else
#line 390
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 393
            flags += 8;
          }
#line 395
          cp ++;
        } else {
#line 436
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 440
      tmp___19 = cp;
#line 440
      cp ++;
#line 440
      c = (char )*tmp___19;
      {
#line 443
      if ((int )c == 105) {
#line 443
        goto case_105;
      }
#line 443
      if ((int )c == 100) {
#line 443
        goto case_105;
      }
#line 461
      if ((int )c == 88) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 120) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 117) {
#line 461
        goto case_88;
      }
#line 461
      if ((int )c == 111) {
#line 461
        goto case_88;
      }
#line 480
      if ((int )c == 65) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 97) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 71) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 103) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 69) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 101) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 70) {
#line 480
        goto case_65;
      }
#line 480
      if ((int )c == 102) {
#line 480
        goto case_65;
      }
#line 486
      if ((int )c == 99) {
#line 486
        goto case_99;
      }
#line 497
      if ((int )c == 67) {
#line 497
        goto case_67;
      }
#line 502
      if ((int )c == 115) {
#line 502
        goto case_115;
      }
#line 513
      if ((int )c == 83) {
#line 513
        goto case_83;
      }
#line 518
      if ((int )c == 112) {
#line 518
        goto case_112;
      }
#line 521
      if ((int )c == 110) {
#line 521
        goto case_110;
      }
#line 550
      if ((int )c == 37) {
#line 550
        goto case_37;
      }
#line 553
      goto switch_default;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 446
      if (flags >= 16) {
#line 447
        type = (arg_type )9;
      } else
#line 446
      if (flags & 4) {
#line 447
        type = (arg_type )9;
      } else
#line 452
      if (flags >= 8) {
#line 453
        type = (arg_type )7;
      } else
#line 454
      if (flags & 2) {
#line 455
        type = (arg_type )1;
      } else
#line 456
      if (flags & 1) {
#line 457
        type = (arg_type )3;
      } else {
#line 459
        type = (arg_type )5;
      }
#line 460
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 464
      if (flags >= 16) {
#line 465
        type = (arg_type )10;
      } else
#line 464
      if (flags & 4) {
#line 465
        type = (arg_type )10;
      } else
#line 470
      if (flags >= 8) {
#line 471
        type = (arg_type )8;
      } else
#line 472
      if (flags & 2) {
#line 473
        type = (arg_type )2;
      } else
#line 474
      if (flags & 1) {
#line 475
        type = (arg_type )4;
      } else {
#line 477
        type = (arg_type )6;
      }
#line 478
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 481
      if (flags >= 16) {
#line 482
        type = (arg_type )12;
      } else
#line 481
      if (flags & 4) {
#line 482
        type = (arg_type )12;
      } else {
#line 484
        type = (arg_type )11;
      }
#line 485
      goto switch_break;
      case_99: /* CIL Label */ 
#line 487
      if (flags >= 8) {
#line 489
        type = (arg_type )14;
      } else {
#line 494
        type = (arg_type )13;
      }
#line 495
      goto switch_break;
      case_67: /* CIL Label */ 
#line 498
      type = (arg_type )14;
#line 499
      c = (char )'c';
#line 500
      goto switch_break;
      case_115: /* CIL Label */ 
#line 503
      if (flags >= 8) {
#line 505
        type = (arg_type )16;
      } else {
#line 510
        type = (arg_type )15;
      }
#line 511
      goto switch_break;
      case_83: /* CIL Label */ 
#line 514
      type = (arg_type )16;
#line 515
      c = (char )'s';
#line 516
      goto switch_break;
      case_112: /* CIL Label */ 
#line 519
      type = (arg_type )17;
#line 520
      goto switch_break;
      case_110: /* CIL Label */ 
#line 524
      if (flags >= 16) {
#line 525
        type = (arg_type )22;
      } else
#line 524
      if (flags & 4) {
#line 525
        type = (arg_type )22;
      } else
#line 530
      if (flags >= 8) {
#line 531
        type = (arg_type )21;
      } else
#line 532
      if (flags & 2) {
#line 533
        type = (arg_type )18;
      } else
#line 534
      if (flags & 1) {
#line 535
        type = (arg_type )19;
      } else {
#line 537
        type = (arg_type )20;
      }
#line 538
      goto switch_break;
      case_37: /* CIL Label */ 
#line 551
      type = (arg_type )0;
#line 552
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 555
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 559
      if ((unsigned int )type != 0U) {
#line 561
        dp->arg_index = arg_index;
#line 562
        if (dp->arg_index == 4294967295U) {
#line 564
          tmp___20 = arg_posn;
#line 564
          arg_posn ++;
#line 564
          dp->arg_index = tmp___20;
#line 565
          if (dp->arg_index == 4294967295U) {
#line 567
            goto error;
          }
        }
#line 569
        n___4 = dp->arg_index;
#line 569
        if (n___4 >= a_allocated) {
#line 569
          if (a_allocated <= 2147483647U) {
#line 569
            a_allocated *= 2U;
          } else {
#line 569
            a_allocated = 4294967295U;
          }
#line 569
          if (a_allocated <= n___4) {
            {
#line 569
            tmp___21 = xsum(n___4, (size_t )1);
#line 569
            a_allocated = (size_t )tmp___21;
            }
          }
#line 569
          if ((unsigned long )a_allocated <= 4294967295UL / sizeof(argument )) {
#line 569
            memory_size___1 = (size_t )((unsigned long )a_allocated * sizeof(argument ));
          } else {
#line 569
            memory_size___1 = 4294967295U;
          }
#line 569
          if (memory_size___1 == 4294967295U) {
#line 569
            goto out_of_memory;
          }
#line 569
          if (a->arg) {
            {
#line 569
            tmp___22 = realloc((void *)a->arg, memory_size___1);
#line 569
            tmp___24 = tmp___22;
            }
          } else {
            {
#line 569
            tmp___23 = malloc(memory_size___1);
#line 569
            tmp___24 = tmp___23;
            }
          }
#line 569
          memory___1 = (argument *)tmp___24;
#line 569
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 569
            goto out_of_memory;
          }
#line 569
          a->arg = memory___1;
        }
        {
#line 569
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 569
          if (! (a->count <= n___4)) {
#line 569
            goto while_break___12;
          }
#line 569
          tmp___25 = a->count;
#line 569
          (a->count) ++;
#line 569
          (a->arg + tmp___25)->type = (arg_type )0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 569
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 569
          (a->arg + n___4)->type = type;
        } else
#line 569
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 569
          goto error;
        }
      }
#line 571
      dp->conversion = c;
#line 572
      dp->dir_end = cp;
#line 575
      (d->count) ++;
#line 576
      if (d->count >= d_allocated) {
#line 581
        if (d_allocated <= 2147483647U) {
#line 581
          d_allocated *= 2U;
        } else {
#line 581
          d_allocated = 4294967295U;
        }
#line 582
        if ((unsigned long )d_allocated <= 4294967295UL / sizeof(char_directive )) {
#line 582
          memory_size___2 = (size_t )((unsigned long )d_allocated * sizeof(char_directive ));
        } else {
#line 582
          memory_size___2 = 4294967295U;
        }
#line 583
        if (memory_size___2 == 4294967295U) {
#line 585
          goto out_of_memory;
        }
        {
#line 586
        tmp___26 = realloc((void *)d->dir, memory_size___2);
#line 586
        memory___2 = (char_directive *)tmp___26;
        }
#line 587
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 589
          goto out_of_memory;
        }
#line 590
        d->dir = memory___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  (d->dir + d->count)->dir_start = cp;
#line 603
  d->max_width_length = max_width_length;
#line 604
  d->max_precision_length = max_precision_length;
#line 605
  return (0);
  error: 
#line 608
  if (a->arg) {
    {
#line 609
    free((void *)a->arg);
    }
  }
#line 610
  if (d->dir) {
    {
#line 611
    free((void *)d->dir);
    }
  }
  {
#line 612
  tmp___27 = __errno_location();
#line 612
  *tmp___27 = 22;
  }
#line 613
  return (-1);
  out_of_memory: 
#line 616
  if (a->arg) {
    {
#line 617
    free((void *)a->arg);
    }
  }
#line 618
  if (d->dir) {
    {
#line 619
    free((void *)d->dir);
    }
  }
  out_of_memory_1: 
  {
#line 621
  tmp___28 = __errno_location();
#line 621
  *tmp___28 = 12;
  }
#line 622
  return (-1);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 114 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  signed char tmp ;
  unsigned char tmp___0 ;
  short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned long tmp___6 ;
  long long tmp___7 ;
  unsigned long long tmp___8 ;
  double tmp___9 ;
  long double tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  wint_t tmp___15 ;
  char const   *tmp___16 ;
  wchar_t const   *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;
  char *__cil_tmp30 ;

  {
#line 43
  i = (size_t )0;
#line 43
  ap = a->arg + 0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! (i < a->count)) {
#line 43
      goto while_break;
    }
    {
#line 46
    if ((unsigned int )ap->type == 1U) {
#line 46
      goto case_1;
    }
#line 49
    if ((unsigned int )ap->type == 2U) {
#line 49
      goto case_2;
    }
#line 52
    if ((unsigned int )ap->type == 3U) {
#line 52
      goto case_3;
    }
#line 55
    if ((unsigned int )ap->type == 4U) {
#line 55
      goto case_4;
    }
#line 58
    if ((unsigned int )ap->type == 5U) {
#line 58
      goto case_5;
    }
#line 61
    if ((unsigned int )ap->type == 6U) {
#line 61
      goto case_6;
    }
#line 64
    if ((unsigned int )ap->type == 7U) {
#line 64
      goto case_7;
    }
#line 67
    if ((unsigned int )ap->type == 8U) {
#line 67
      goto case_8;
    }
#line 71
    if ((unsigned int )ap->type == 9U) {
#line 71
      goto case_9;
    }
#line 74
    if ((unsigned int )ap->type == 10U) {
#line 74
      goto case_10;
    }
#line 78
    if ((unsigned int )ap->type == 11U) {
#line 78
      goto case_11;
    }
#line 81
    if ((unsigned int )ap->type == 12U) {
#line 81
      goto case_12;
    }
#line 84
    if ((unsigned int )ap->type == 13U) {
#line 84
      goto case_13;
    }
#line 88
    if ((unsigned int )ap->type == 14U) {
#line 88
      goto case_14;
    }
#line 98
    if ((unsigned int )ap->type == 15U) {
#line 98
      goto case_15;
    }
#line 107
    if ((unsigned int )ap->type == 16U) {
#line 107
      goto case_16;
    }
#line 125
    if ((unsigned int )ap->type == 17U) {
#line 125
      goto case_17;
    }
#line 128
    if ((unsigned int )ap->type == 18U) {
#line 128
      goto case_18;
    }
#line 131
    if ((unsigned int )ap->type == 19U) {
#line 131
      goto case_19;
    }
#line 134
    if ((unsigned int )ap->type == 20U) {
#line 134
      goto case_20;
    }
#line 137
    if ((unsigned int )ap->type == 21U) {
#line 137
      goto case_21;
    }
#line 141
    if ((unsigned int )ap->type == 22U) {
#line 141
      goto case_22;
    }
#line 184
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 47
    tmp = __builtin_va_arg(args, int );
#line 47
    ap->a.a_schar = tmp;
    }
#line 48
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 50
    tmp___0 = __builtin_va_arg(args, int );
#line 50
    ap->a.a_uchar = tmp___0;
    }
#line 51
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 53
    tmp___1 = __builtin_va_arg(args, int );
#line 53
    ap->a.a_short = tmp___1;
    }
#line 54
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 56
    tmp___2 = __builtin_va_arg(args, int );
#line 56
    ap->a.a_ushort = tmp___2;
    }
#line 57
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 59
    tmp___3 = __builtin_va_arg(args, int );
#line 59
    ap->a.a_int = tmp___3;
    }
#line 60
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 62
    tmp___4 = __builtin_va_arg(args, unsigned int );
#line 62
    ap->a.a_uint = tmp___4;
    }
#line 63
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 65
    tmp___5 = __builtin_va_arg(args, long );
#line 65
    ap->a.a_longint = tmp___5;
    }
#line 66
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 68
    tmp___6 = __builtin_va_arg(args, unsigned long );
#line 68
    ap->a.a_ulongint = tmp___6;
    }
#line 69
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 72
    tmp___7 = __builtin_va_arg(args, long long );
#line 72
    ap->a.a_longlongint = tmp___7;
    }
#line 73
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 75
    tmp___8 = __builtin_va_arg(args, unsigned long long );
#line 75
    ap->a.a_ulonglongint = tmp___8;
    }
#line 76
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 79
    tmp___9 = __builtin_va_arg(args, double );
#line 79
    ap->a.a_double = tmp___9;
    }
#line 80
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 82
    tmp___10 = __builtin_va_arg(args, long double );
#line 82
    ap->a.a_longdouble = tmp___10;
    }
#line 83
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 85
    tmp___11 = __builtin_va_arg(args, int );
#line 85
    ap->a.a_char = tmp___11;
    }
#line 86
    goto switch_break;
    case_14: /* CIL Label */ 
#line 92
    if (sizeof(wint_t ) < sizeof(int )) {
      {
#line 92
      tmp___13 = __builtin_va_arg(args, int );
#line 92
      ap->a.a_wide_char = (wint_t )tmp___13;
      }
    } else {
      {
#line 92
      tmp___15 = __builtin_va_arg(args, wint_t );
#line 92
      ap->a.a_wide_char = tmp___15;
      }
    }
#line 96
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 99
    tmp___16 = __builtin_va_arg(args, char const   *);
#line 99
    ap->a.a_string = tmp___16;
    }
#line 103
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 104
      ap->a.a_string = "(NULL)";
    }
#line 105
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 108
    tmp___17 = __builtin_va_arg(args, wchar_t const   *);
#line 108
    ap->a.a_wide_string = tmp___17;
    }
#line 112
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 121
      ap->a.a_wide_string = wide_null_string;
    }
#line 123
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 126
    tmp___18 = __builtin_va_arg(args, void *);
#line 126
    ap->a.a_pointer = tmp___18;
    }
#line 127
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 129
    tmp___19 = __builtin_va_arg(args, signed char *);
#line 129
    ap->a.a_count_schar_pointer = tmp___19;
    }
#line 130
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 132
    tmp___20 = __builtin_va_arg(args, short *);
#line 132
    ap->a.a_count_short_pointer = tmp___20;
    }
#line 133
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 135
    tmp___21 = __builtin_va_arg(args, int *);
#line 135
    ap->a.a_count_int_pointer = tmp___21;
    }
#line 136
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 138
    tmp___22 = __builtin_va_arg(args, long *);
#line 138
    ap->a.a_count_longint_pointer = tmp___22;
    }
#line 139
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 142
    tmp___23 = __builtin_va_arg(args, long long *);
#line 142
    ap->a.a_count_longlongint_pointer = tmp___23;
    }
#line 143
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 186
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 43
    i ++;
#line 43
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (0);
}
}
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___1 ) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___1 ) 
{ 
  char *p ;

  {
#line 38
  p = buf___1 + ((((sizeof(off_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i < 0L) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48L - i % 10L);
#line 43
      i /= 10L;
#line 43
      if (! (i != 0L)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48L + i % 10L);
#line 51
      i /= 10L;
#line 51
      if (! (i != 0L)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 79 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.h"
 __attribute__((__nothrow__)) void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 85
 __attribute__((__nothrow__)) void md5_process_block(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
#line 92
 __attribute__((__nothrow__)) void md5_process_bytes(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
#line 99
 __attribute__((__nothrow__)) void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 105
 __attribute__((__nothrow__)) void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 111
 __attribute__((__nothrow__)) int md5_stream(FILE *stream , void *resblock ) ;
#line 117
 __attribute__((__nothrow__)) void *md5_buffer(char const   *buffer , size_t len ,
                                               void *resblock ) ;
#line 68 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 73
 __attribute__((__nothrow__)) void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void md5_init_ctx(struct md5_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 76
  ctx->A = (uint32_t )1732584193;
#line 77
  ctx->B = 4023233417U;
#line 78
  ctx->C = 2562383102U;
#line 79
  ctx->D = (uint32_t )271733878;
#line 81
  tmp = (uint32_t )0;
#line 81
  ctx->total[1] = tmp;
#line 81
  ctx->total[0] = tmp;
#line 82
  ctx->buflen = (uint32_t )0;
#line 83
  return;
}
}
#line 88 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
__inline static void set_uint32(char *cp , uint32_t v ) 
{ 


  {
  {
#line 91
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)(& v), (size_t )sizeof(v));
  }
#line 92
  return;
}
}
#line 96
 __attribute__((__nothrow__)) void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 96 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 
  char *r ;

  {
  {
#line 99
  r = (char *)resbuf;
#line 100
  set_uint32(r + 0UL, (uint32_t )ctx->A);
#line 101
  set_uint32(r + sizeof(ctx->B), (uint32_t )ctx->B);
#line 102
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )ctx->C);
#line 103
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )ctx->D);
  }
#line 105
  return (resbuf);
}
}
#line 110
 __attribute__((__nothrow__)) void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 110 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ 
  uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
#line 114
  bytes = ctx->buflen;
#line 115
  if (bytes < 56U) {
#line 115
    tmp = 16;
  } else {
#line 115
    tmp = 32;
  }
#line 115
  size = (size_t )tmp;
#line 118
  ctx->total[0] += bytes;
#line 119
  if (ctx->total[0] < bytes) {
#line 120
    (ctx->total[1]) ++;
  }
  {
#line 123
  ctx->buffer[size - 2U] = ctx->total[0] << 3;
#line 124
  ctx->buffer[size - 1U] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 126
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf),
         (size - 2U) * 4U - bytes);
#line 129
  md5_process_block((void const   *)(ctx->buffer), size * 4U, ctx);
#line 131
  tmp___0 = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  }
#line 131
  return (tmp___0);
}
}
#line 137
 __attribute__((__nothrow__)) int md5_stream(FILE *stream , void *resblock ) ;
#line 137 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
int md5_stream(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  char buffer[4168] ;
  size_t sum ;
  size_t n ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;

  {
  {
#line 145
  md5_init_ctx(& ctx);
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    sum = (size_t )0;
    {
#line 157
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 159
      n = fread((void */* __restrict  */)(buffer + sum), (size_t )1, 4096U - sum,
                (FILE */* __restrict  */)stream);
#line 161
      sum += n;
      }
#line 163
      if (sum == 4096U) {
#line 164
        goto while_break___0;
      }
#line 166
      if (n == 0U) {
        {
#line 171
        tmp = ferror(stream);
        }
#line 171
        if (tmp) {
#line 172
          return (1);
        }
#line 173
        goto process_partial_block;
      }
      {
#line 179
      tmp___0 = feof(stream);
      }
#line 179
      if (tmp___0) {
#line 180
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 186
    md5_process_block((void const   *)(buffer), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: 
#line 192
  if (sum > 0U) {
    {
#line 193
    md5_process_bytes((void const   *)(buffer), sum, & ctx);
    }
  }
  {
#line 196
  md5_finish_ctx(& ctx, resblock);
  }
#line 197
  return (0);
}
}
#line 204
 __attribute__((__nothrow__)) void *md5_buffer(char const   *buffer , size_t len ,
                                               void *resblock ) ;
#line 204 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void *md5_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp ;

  {
  {
#line 210
  md5_init_ctx(& ctx);
#line 213
  md5_process_bytes((void const   *)buffer, len, & ctx);
#line 216
  tmp = md5_finish_ctx(& ctx, resblock);
  }
#line 216
  return (tmp);
}
}
#line 220
 __attribute__((__nothrow__)) void md5_process_bytes(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
#line 220 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void md5_process_bytes(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 225
  if (ctx->buflen != 0U) {
#line 227
    left_over = ctx->buflen;
#line 228
    if (128U - left_over > len) {
#line 228
      tmp = len;
    } else {
#line 228
      tmp = 128U - left_over;
    }
    {
#line 228
    add = tmp;
#line 230
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over), (void const   */* __restrict  */)buffer,
           add);
#line 231
    ctx->buflen += add;
    }
#line 233
    if (ctx->buflen > 64U) {
      {
#line 235
      md5_process_block((void const   *)(ctx->buffer), ctx->buflen & 4294967232U,
                        ctx);
#line 237
      ctx->buflen &= 63U;
#line 239
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)((char *)(ctx->buffer) + ((left_over + add) & 4294967232U)),
             ctx->buflen);
      }
    }
#line 244
    buffer = (void const   *)((char const   *)buffer + add);
#line 245
    len -= add;
  }
#line 249
  if (len >= 64U) {
#line 254
    if ((unsigned long )((size_t )buffer) % (unsigned long )(& ((struct __anonstruct_28 *)0)->x) != 0UL) {
      {
#line 255
      while (1) {
        while_continue: /* CIL Label */ ;
#line 255
        if (! (len > 64U)) {
#line 255
          goto while_break;
        }
        {
#line 257
        tmp___0 = memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer,
                         (size_t )64);
#line 257
        md5_process_block((void const   *)tmp___0, (size_t )64, ctx);
#line 258
        buffer = (void const   *)((char const   *)buffer + 64);
#line 259
        len -= 64U;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 264
      md5_process_block(buffer, len & 4294967232U, ctx);
#line 265
      buffer = (void const   *)((char const   *)buffer + (len & 4294967232U));
#line 266
      len &= 63U;
      }
    }
  }
#line 271
  if (len > 0U) {
    {
#line 273
    left_over___0 = ctx->buflen;
#line 275
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over___0), (void const   */* __restrict  */)buffer,
           len);
#line 276
    left_over___0 += len;
    }
#line 277
    if (left_over___0 >= 64U) {
      {
#line 279
      md5_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 280
      left_over___0 -= 64U;
#line 281
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[16]),
             left_over___0);
      }
    }
#line 283
    ctx->buflen = left_over___0;
  }
#line 285
  return;
}
}
#line 300
 __attribute__((__nothrow__)) void md5_process_block(void const   *buffer , size_t len ,
                                                     struct md5_ctx *ctx ) ;
#line 300 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/md5.c"
void md5_process_block(void const   *buffer , size_t len , struct md5_ctx *ctx ) 
{ 
  uint32_t correct_words[16] ;
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;
  uint32_t *cwp ;
  uint32_t A_save ;
  uint32_t B_save ;
  uint32_t C_save ;
  uint32_t D_save ;
  uint32_t *tmp ;
  uint32_t tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t tmp___30 ;
  void *__cil_tmp49 ;

  {
#line 304
  words = (uint32_t const   *)buffer;
#line 305
  nwords = (size_t )((unsigned long )len / sizeof(uint32_t ));
#line 306
  endp = words + nwords;
#line 307
  A = ctx->A;
#line 308
  B = ctx->B;
#line 309
  C = ctx->C;
#line 310
  D = ctx->D;
#line 315
  ctx->total[0] += len;
#line 316
  if (ctx->total[0] < len) {
#line 317
    (ctx->total[1]) ++;
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 321
      goto while_break;
    }
#line 323
    cwp = correct_words;
#line 324
    A_save = A;
#line 325
    B_save = B;
#line 326
    C_save = C;
#line 327
    D_save = D;
    {
#line 361
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 361
      tmp = cwp;
#line 361
      cwp ++;
#line 361
      tmp___0 = (uint32_t )*words;
#line 361
      *tmp = tmp___0;
#line 361
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
#line 361
      words ++;
#line 361
      A = (A << 7) | (A >> 25);
#line 361
      A += B;
#line 361
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 362
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 362
      tmp___1 = cwp;
#line 362
      cwp ++;
#line 362
      tmp___2 = (uint32_t )*words;
#line 362
      *tmp___1 = tmp___2;
#line 362
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
#line 362
      words ++;
#line 362
      D = (D << 12) | (D >> 20);
#line 362
      D += A;
#line 362
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 363
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 363
      tmp___3 = cwp;
#line 363
      cwp ++;
#line 363
      tmp___4 = (uint32_t )*words;
#line 363
      *tmp___3 = tmp___4;
#line 363
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
#line 363
      words ++;
#line 363
      C = (C << 17) | (C >> 15);
#line 363
      C += D;
#line 363
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 364
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 364
      tmp___5 = cwp;
#line 364
      cwp ++;
#line 364
      tmp___6 = (uint32_t )*words;
#line 364
      *tmp___5 = tmp___6;
#line 364
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
#line 364
      words ++;
#line 364
      B = (B << 22) | (B >> 10);
#line 364
      B += C;
#line 364
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 365
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 365
      tmp___7 = cwp;
#line 365
      cwp ++;
#line 365
      tmp___8 = (uint32_t )*words;
#line 365
      *tmp___7 = tmp___8;
#line 365
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
#line 365
      words ++;
#line 365
      A = (A << 7) | (A >> 25);
#line 365
      A += B;
#line 365
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 366
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 366
      tmp___9 = cwp;
#line 366
      cwp ++;
#line 366
      tmp___10 = (uint32_t )*words;
#line 366
      *tmp___9 = tmp___10;
#line 366
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
#line 366
      words ++;
#line 366
      D = (D << 12) | (D >> 20);
#line 366
      D += A;
#line 366
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 367
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 367
      tmp___11 = cwp;
#line 367
      cwp ++;
#line 367
      tmp___12 = (uint32_t )*words;
#line 367
      *tmp___11 = tmp___12;
#line 367
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
#line 367
      words ++;
#line 367
      C = (C << 17) | (C >> 15);
#line 367
      C += D;
#line 367
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 368
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 368
      tmp___13 = cwp;
#line 368
      cwp ++;
#line 368
      tmp___14 = (uint32_t )*words;
#line 368
      *tmp___13 = tmp___14;
#line 368
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
#line 368
      words ++;
#line 368
      B = (B << 22) | (B >> 10);
#line 368
      B += C;
#line 368
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 369
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 369
      tmp___15 = cwp;
#line 369
      cwp ++;
#line 369
      tmp___16 = (uint32_t )*words;
#line 369
      *tmp___15 = tmp___16;
#line 369
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
#line 369
      words ++;
#line 369
      A = (A << 7) | (A >> 25);
#line 369
      A += B;
#line 369
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 370
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 370
      tmp___17 = cwp;
#line 370
      cwp ++;
#line 370
      tmp___18 = (uint32_t )*words;
#line 370
      *tmp___17 = tmp___18;
#line 370
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
#line 370
      words ++;
#line 370
      D = (D << 12) | (D >> 20);
#line 370
      D += A;
#line 370
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 371
      tmp___19 = cwp;
#line 371
      cwp ++;
#line 371
      tmp___20 = (uint32_t )*words;
#line 371
      *tmp___19 = tmp___20;
#line 371
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
#line 371
      words ++;
#line 371
      C = (C << 17) | (C >> 15);
#line 371
      C += D;
#line 371
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 372
      tmp___21 = cwp;
#line 372
      cwp ++;
#line 372
      tmp___22 = (uint32_t )*words;
#line 372
      *tmp___21 = tmp___22;
#line 372
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
#line 372
      words ++;
#line 372
      B = (B << 22) | (B >> 10);
#line 372
      B += C;
#line 372
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 373
      tmp___23 = cwp;
#line 373
      cwp ++;
#line 373
      tmp___24 = (uint32_t )*words;
#line 373
      *tmp___23 = tmp___24;
#line 373
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
#line 373
      words ++;
#line 373
      A = (A << 7) | (A >> 25);
#line 373
      A += B;
#line 373
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 374
      tmp___25 = cwp;
#line 374
      cwp ++;
#line 374
      tmp___26 = (uint32_t )*words;
#line 374
      *tmp___25 = tmp___26;
#line 374
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
#line 374
      words ++;
#line 374
      D = (D << 12) | (D >> 20);
#line 374
      D += A;
#line 374
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 375
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 375
      tmp___27 = cwp;
#line 375
      cwp ++;
#line 375
      tmp___28 = (uint32_t )*words;
#line 375
      *tmp___27 = tmp___28;
#line 375
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
#line 375
      words ++;
#line 375
      C = (C << 17) | (C >> 15);
#line 375
      C += D;
#line 375
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 376
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 376
      tmp___29 = cwp;
#line 376
      cwp ++;
#line 376
      tmp___30 = (uint32_t )*words;
#line 376
      *tmp___29 = tmp___30;
#line 376
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
#line 376
      words ++;
#line 376
      B = (B << 22) | (B >> 10);
#line 376
      B += C;
#line 376
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 392
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 392
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 392
      A = (A << 5) | (A >> 27);
#line 392
      A += B;
#line 392
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 393
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 393
      D = (D << 9) | (D >> 23);
#line 393
      D += A;
#line 393
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 394
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 394
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 394
      C = (C << 14) | (C >> 18);
#line 394
      C += D;
#line 394
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 395
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 395
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 395
      B = (B << 20) | (B >> 12);
#line 395
      B += C;
#line 395
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 396
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 396
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 396
      A = (A << 5) | (A >> 27);
#line 396
      A += B;
#line 396
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 397
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 397
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 397
      D = (D << 9) | (D >> 23);
#line 397
      D += A;
#line 397
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 398
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 398
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 398
      C = (C << 14) | (C >> 18);
#line 398
      C += D;
#line 398
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 399
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 399
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 399
      B = (B << 20) | (B >> 12);
#line 399
      B += C;
#line 399
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 400
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 400
      A = (A << 5) | (A >> 27);
#line 400
      A += B;
#line 400
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 401
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 401
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 401
      D = (D << 9) | (D >> 23);
#line 401
      D += A;
#line 401
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 402
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 402
      C = (C << 14) | (C >> 18);
#line 402
      C += D;
#line 402
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 403
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 403
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 403
      B = (B << 20) | (B >> 12);
#line 403
      B += C;
#line 403
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 404
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 404
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 404
      A = (A << 5) | (A >> 27);
#line 404
      A += B;
#line 404
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 405
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 405
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 405
      D = (D << 9) | (D >> 23);
#line 405
      D += A;
#line 405
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 406
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 406
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 406
      C = (C << 14) | (C >> 18);
#line 406
      C += D;
#line 406
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 407
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 407
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 407
      B = (B << 20) | (B >> 12);
#line 407
      B += C;
#line 407
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 410
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 410
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 410
      A = (A << 4) | (A >> 28);
#line 410
      A += B;
#line 410
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 411
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 411
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 411
      D = (D << 11) | (D >> 21);
#line 411
      D += A;
#line 411
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 412
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 412
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 412
      C = (C << 16) | (C >> 16);
#line 412
      C += D;
#line 412
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 413
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 413
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 413
      B = (B << 23) | (B >> 9);
#line 413
      B += C;
#line 413
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 414
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 414
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 414
      A = (A << 4) | (A >> 28);
#line 414
      A += B;
#line 414
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 415
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 415
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 415
      D = (D << 11) | (D >> 21);
#line 415
      D += A;
#line 415
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 416
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 416
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 416
      C = (C << 16) | (C >> 16);
#line 416
      C += D;
#line 416
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 417
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 417
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 417
      B = (B << 23) | (B >> 9);
#line 417
      B += C;
#line 417
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 418
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 418
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 418
      A = (A << 4) | (A >> 28);
#line 418
      A += B;
#line 418
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 419
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 419
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 419
      D = (D << 11) | (D >> 21);
#line 419
      D += A;
#line 419
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 420
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 420
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 420
      C = (C << 16) | (C >> 16);
#line 420
      C += D;
#line 420
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 421
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 421
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 421
      B = (B << 23) | (B >> 9);
#line 421
      B += C;
#line 421
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 422
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 422
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 422
      A = (A << 4) | (A >> 28);
#line 422
      A += B;
#line 422
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 423
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 423
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 423
      D = (D << 11) | (D >> 21);
#line 423
      D += A;
#line 423
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 424
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 424
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 424
      C = (C << 16) | (C >> 16);
#line 424
      C += D;
#line 424
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 425
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 425
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 425
      B = (B << 23) | (B >> 9);
#line 425
      B += C;
#line 425
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 428
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 428
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 428
      A = (A << 6) | (A >> 26);
#line 428
      A += B;
#line 428
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 429
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 429
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 429
      D = (D << 10) | (D >> 22);
#line 429
      D += A;
#line 429
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 430
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 430
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 430
      C = (C << 15) | (C >> 17);
#line 430
      C += D;
#line 430
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 431
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 431
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 431
      B = (B << 21) | (B >> 11);
#line 431
      B += C;
#line 431
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 432
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 432
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 432
      A = (A << 6) | (A >> 26);
#line 432
      A += B;
#line 432
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 433
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 433
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 433
      D = (D << 10) | (D >> 22);
#line 433
      D += A;
#line 433
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 434
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 434
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 434
      C = (C << 15) | (C >> 17);
#line 434
      C += D;
#line 434
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 435
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 435
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 435
      B = (B << 21) | (B >> 11);
#line 435
      B += C;
#line 435
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 436
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 436
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 436
      A = (A << 6) | (A >> 26);
#line 436
      A += B;
#line 436
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 437
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 437
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 437
      D = (D << 10) | (D >> 22);
#line 437
      D += A;
#line 437
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 438
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 438
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 438
      C = (C << 15) | (C >> 17);
#line 438
      C += D;
#line 438
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 439
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 439
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 439
      B = (B << 21) | (B >> 11);
#line 439
      B += C;
#line 439
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 440
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 440
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 440
      A = (A << 6) | (A >> 26);
#line 440
      A += B;
#line 440
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 441
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 441
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 441
      D = (D << 10) | (D >> 22);
#line 441
      D += A;
#line 441
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 442
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 442
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 442
      C = (C << 15) | (C >> 17);
#line 442
      C += D;
#line 442
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 443
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 443
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 443
      B = (B << 21) | (B >> 11);
#line 443
      B += C;
#line 443
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 446
    A += A_save;
#line 447
    B += B_save;
#line 448
    C += C_save;
#line 449
    D += D_save;
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  ctx->A = A;
#line 454
  ctx->B = B;
#line 455
  ctx->C = C;
#line 456
  ctx->D = D;
#line 457
  return;
}
}
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/localcharset.h"
char const   *locale_charset(void) ;
#line 407 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 532
extern int getc_unlocked(FILE *__stream ) ;
#line 675
extern int ungetc(int __c , FILE *__stream ) ;
#line 584 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 110 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  FILE *fp ;
  char const   *dir ;
  char const   *base ;
  char *file_name ;
  char *tmp ;
  size_t dir_len ;
  size_t tmp___0 ;
  size_t base_len ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 118
  cp = (char const   *)charset_aliases;
#line 119
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 124
    base = "charset.alias";
#line 129
    tmp = getenv("CHARSETALIASDIR");
#line 129
    dir = (char const   *)tmp;
    }
#line 130
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 131
      dir = "/usr/local/lib";
    } else
#line 130
    if ((int const   )*(dir + 0) == 0) {
#line 131
      dir = "/usr/local/lib";
    }
    {
#line 135
    tmp___0 = strlen(dir);
#line 135
    dir_len = tmp___0;
#line 136
    tmp___1 = strlen(base);
#line 136
    base_len = tmp___1;
    }
#line 137
    if (dir_len > 0U) {
#line 137
      if (! ((int const   )*(dir + (dir_len - 1U)) == 47)) {
#line 137
        tmp___2 = 1;
      } else {
#line 137
        tmp___2 = 0;
      }
    } else {
#line 137
      tmp___2 = 0;
    }
    {
#line 137
    add_slash = tmp___2;
#line 138
    tmp___3 = malloc(((dir_len + (size_t )add_slash) + base_len) + 1U);
#line 138
    file_name = (char *)tmp___3;
    }
#line 139
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 141
      memcpy((void */* __restrict  */)file_name, (void const   */* __restrict  */)dir,
             dir_len);
      }
#line 142
      if (add_slash) {
#line 143
        *(file_name + dir_len) = (char )'/';
      }
      {
#line 144
      memcpy((void */* __restrict  */)((file_name + dir_len) + add_slash), (void const   */* __restrict  */)base,
             base_len + 1U);
      }
    }
#line 148
    if ((unsigned long )file_name == (unsigned long )((void *)0)) {
#line 150
      cp = "";
    } else {
      {
#line 148
      fp = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"r");
      }
#line 148
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 150
        cp = "";
      } else {
#line 154
        res_ptr = (char *)((void *)0);
#line 155
        res_size = (size_t )0;
        {
#line 157
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 165
          c = getc_unlocked(fp);
          }
#line 166
          if (c == -1) {
#line 167
            goto while_break;
          }
#line 168
          if (c == 10) {
#line 169
            goto __Cont;
          } else
#line 168
          if (c == 32) {
#line 169
            goto __Cont;
          } else
#line 168
          if (c == 9) {
#line 169
            goto __Cont;
          }
#line 170
          if (c == 35) {
            {
#line 173
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 174
              c = getc_unlocked(fp);
              }
#line 173
              if (c == -1) {
#line 173
                goto while_break___0;
              } else
#line 173
              if (c == 10) {
#line 173
                goto while_break___0;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 176
            if (c == -1) {
#line 177
              goto while_break;
            }
#line 178
            goto __Cont;
          }
          {
#line 180
          ungetc(c, fp);
#line 181
          tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                           buf1, buf2);
          }
#line 181
          if (tmp___4 < 2) {
#line 182
            goto while_break;
          }
          {
#line 183
          l1 = strlen((char const   *)(buf1));
#line 184
          l2 = strlen((char const   *)(buf2));
#line 185
          old_res_ptr = res_ptr;
          }
#line 186
          if (res_size == 0U) {
            {
#line 188
            res_size = ((l1 + 1U) + l2) + 1U;
#line 189
            tmp___5 = malloc(res_size + 1U);
#line 189
            res_ptr = (char *)tmp___5;
            }
          } else {
            {
#line 193
            res_size += ((l1 + 1U) + l2) + 1U;
#line 194
            tmp___6 = realloc((void *)res_ptr, res_size + 1U);
#line 194
            res_ptr = (char *)tmp___6;
            }
          }
#line 196
          if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
#line 199
            res_size = (size_t )0;
#line 200
            if ((unsigned long )old_res_ptr != (unsigned long )((void *)0)) {
              {
#line 201
              free((void *)old_res_ptr);
              }
            }
#line 202
            goto while_break;
          }
          {
#line 204
          strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1U)) - (l1 + 1U)),
                 (char const   */* __restrict  */)(buf1));
#line 205
          strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1U)), (char const   */* __restrict  */)(buf2));
          }
          __Cont: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 207
        fclose(fp);
        }
#line 208
        if (res_size == 0U) {
#line 209
          cp = "";
        } else {
#line 212
          *(res_ptr + res_size) = (char )'\000';
#line 213
          cp = (char const   *)res_ptr;
        }
      }
    }
#line 217
    if ((unsigned long )file_name != (unsigned long )((void *)0)) {
      {
#line 218
      free((void *)file_name);
      }
    }
#line 311
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 314
  return (cp);
}
}
#line 326 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 337
  tmp = nl_langinfo(14);
#line 337
  codeset = (char const   *)tmp;
  }
#line 479
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 481
    codeset = "";
  }
  {
#line 484
  aliases = get_charset_aliases();
  }
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! ((int const   )*aliases != 0)) {
#line 484
      goto while_break;
    }
    {
#line 487
    tmp___3 = strcmp(codeset, aliases);
    }
#line 487
    if (tmp___3 == 0) {
      {
#line 490
      tmp___2 = strlen(aliases);
#line 490
      codeset = (aliases + tmp___2) + 1;
      }
#line 491
      goto while_break;
    } else
#line 487
    if ((int const   )*(aliases + 0) == 42) {
#line 487
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 490
        tmp___2 = strlen(aliases);
#line 490
        codeset = (aliases + tmp___2) + 1;
        }
#line 491
        goto while_break;
      }
    }
    {
#line 484
    tmp___0 = strlen(aliases);
#line 484
    aliases += tmp___0 + 1U;
#line 484
    tmp___1 = strlen(aliases);
#line 484
    aliases += tmp___1 + 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 497
  if ((int const   )*(codeset + 0) == 0) {
#line 498
    codeset = "ASCII";
  }
#line 500
  return (codeset);
}
}
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 46 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___1 ) ;
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/inttostr.c"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___1 ) 
{ 
  char *p ;

  {
#line 38
  p = buf___1 + ((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i < 0LL) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48LL - i % 10LL);
#line 43
      i /= 10LL;
#line 43
      if (! (i != 0LL)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48LL + i % 10LL);
#line 51
      i /= 10LL;
#line 51
      if (! (i != 0LL)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table ) ;
#line 62
size_t hash_get_n_buckets_used(Hash_table const   *table ) ;
#line 63
size_t hash_get_n_entries(Hash_table const   *table ) ;
#line 64
size_t hash_get_max_bucket_length(Hash_table const   *table ) ;
#line 65
_Bool hash_table_ok(Hash_table const   *table ) ;
#line 66
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 67
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 70
void *hash_get_first(Hash_table const   *table ) ;
#line 71
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 72
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) ;
#line 73
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 76
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 77
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 78
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) ;
#line 81
void hash_clear(Hash_table *table ) ;
#line 82
void hash_free(Hash_table *table ) ;
#line 85
_Bool hash_rehash(Hash_table *table , size_t candidate ) ;
#line 86
void *hash_insert(Hash_table *table , void const   *entry ) ;
#line 87
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 129 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 148 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 151
  return ((size_t )table->n_buckets);
}
}
#line 156 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 159
  return ((size_t )table->n_buckets_used);
}
}
#line 164 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 167
  return ((size_t )table->n_entries);
}
}
#line 172 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 176
  max_bucket_length = (size_t )0;
#line 178
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 178
      goto while_break;
    }
#line 180
    if (bucket->data) {
#line 182
      cursor = bucket;
#line 183
      bucket_length = (size_t )1;
      {
#line 185
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 185
        cursor = (struct hash_entry  const  *)cursor->next;
#line 185
        if (! cursor) {
#line 185
          goto while_break___0;
        }
#line 186
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 188
      if (bucket_length > max_bucket_length) {
#line 189
        max_bucket_length = bucket_length;
      }
    }
#line 178
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  return (max_bucket_length);
}
}
#line 199 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 203
  n_buckets_used = (size_t )0;
#line 204
  n_entries = (size_t )0;
#line 206
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 206
      goto while_break;
    }
#line 208
    if (bucket->data) {
#line 210
      cursor = bucket;
#line 213
      n_buckets_used ++;
#line 214
      n_entries ++;
      {
#line 217
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 217
        cursor = (struct hash_entry  const  *)cursor->next;
#line 217
        if (! cursor) {
#line 217
          goto while_break___0;
        }
#line 218
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 206
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 222
    if (n_entries == (size_t )table->n_entries) {
#line 223
      return ((_Bool)1);
    }
  }
#line 225
  return ((_Bool)0);
}
}
#line 228 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 231
  tmp = hash_get_n_entries(table);
#line 231
  n_entries = tmp;
#line 232
  tmp___0 = hash_get_n_buckets(table);
#line 232
  n_buckets = tmp___0;
#line 233
  tmp___1 = hash_get_n_buckets_used(table);
#line 233
  n_buckets_used = tmp___1;
#line 234
  tmp___2 = hash_get_max_bucket_length(table);
#line 234
  max_bucket_length = tmp___2;
#line 236
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          (unsigned long )n_entries);
#line 237
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          (unsigned long )n_buckets);
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          (unsigned long )n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 241
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          (unsigned long )max_bucket_length);
  }
#line 243
  return;
}
}
#line 248 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 251
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 251
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
  }
#line 255
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 256
    abort();
    }
  }
#line 258
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 259
    return ((void *)0);
  }
#line 261
  cursor = bucket;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! cursor) {
#line 261
      goto while_break;
    }
    {
#line 262
    tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
    }
#line 262
    if (tmp___0) {
#line 263
      return ((void *)cursor->data);
    }
#line 261
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  return ((void *)0);
}
}
#line 277 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 282
  if (table->n_entries == 0U) {
#line 283
    return ((void *)0);
  }
#line 285
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 287
      abort();
      }
    } else
#line 288
    if (bucket->data) {
#line 289
      return ((void *)bucket->data);
    }
#line 285
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 296 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 299
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 299
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
  }
#line 303
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 304
    abort();
    }
  }
#line 307
  cursor = bucket;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! cursor) {
#line 307
      goto while_break;
    }
#line 308
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 308
      if (cursor->next) {
#line 309
        return ((cursor->next)->data);
      }
    }
#line 307
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 312
    bucket ++;
#line 312
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 312
      goto while_break___0;
    }
#line 313
    if (bucket->data) {
#line 314
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 317
  return ((void *)0);
}
}
#line 324 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 328
  counter = (size_t )0;
#line 332
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 332
      goto while_break;
    }
#line 334
    if (bucket->data) {
#line 336
      cursor = bucket;
      {
#line 336
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 336
        if (! cursor) {
#line 336
          goto while_break___0;
        }
#line 338
        if (counter >= buffer_size) {
#line 339
          return (counter);
        }
#line 340
        tmp = counter;
#line 340
        counter ++;
#line 340
        *(buffer + tmp) = (void *)cursor->data;
#line 336
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 332
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return (counter);
}
}
#line 356 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 360
  counter = (size_t )0;
#line 364
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 364
      goto while_break;
    }
#line 366
    if (bucket->data) {
#line 368
      cursor = bucket;
      {
#line 368
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 368
        if (! cursor) {
#line 368
          goto while_break___0;
        }
        {
#line 370
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 370
        if (! tmp) {
#line 371
          return (counter);
        }
#line 372
        counter ++;
#line 368
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 364
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  return (counter);
}
}
#line 419 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 422
  value = (size_t )0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    ch = (unsigned char )*string;
#line 425
    if (! ch) {
#line 425
      goto while_break;
    }
#line 426
    value = (value * 31U + (size_t )ch) % n_buckets;
#line 425
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 427
  return (value);
}
}
#line 435 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 438
  divisor = (size_t )3;
#line 439
  square = divisor * divisor;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (square < candidate) {
#line 441
      if (! (candidate % divisor)) {
#line 441
        goto while_break;
      }
    } else {
#line 441
      goto while_break;
    }
#line 443
    divisor ++;
#line 444
    square += 4U * divisor;
#line 445
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  if (candidate % divisor) {
#line 448
    tmp = 1;
  } else {
#line 448
    tmp = 0;
  }
#line 448
  return ((_Bool )tmp);
}
}
#line 454 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 458
  if (candidate < 10U) {
#line 459
    candidate = (size_t )10;
  }
#line 462
  candidate |= 1U;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 464
    tmp = is_prime(candidate);
    }
#line 464
    if (tmp) {
#line 464
      goto while_break;
    }
#line 465
    candidate += 2U;
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  return (candidate);
}
}
#line 470 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 473
  *tuning = (Hash_tuning )default_tuning;
#line 474
  return;
}
}
#line 482 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 485
  tuning = table->tuning;
#line 492
  epsilon = 0.1f;
#line 494
  if (epsilon < (float )tuning->growth_threshold) {
#line 494
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 494
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 494
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 494
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 494
            if (tuning->shrink_factor <= (float const   )1) {
#line 494
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 501
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 503
  table->tuning = & default_tuning;
#line 504
  return ((_Bool)0);
}
}
#line 538 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
Hash_table *hash_initialize(size_t candidate , Hash_tuning const   *tuning , size_t (*hasher)(void const   * ,
                                                                                              size_t  ) ,
                            _Bool (*comparator)(void const   * , void const   * ) ,
                            void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  float new_candidate ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 545
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 546
    return ((Hash_table *)((void *)0));
  } else
#line 545
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 546
    return ((Hash_table *)((void *)0));
  }
  {
#line 548
  tmp = malloc((size_t )sizeof(*table));
#line 548
  table = (Hash_table *)tmp;
  }
#line 549
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 550
    return ((Hash_table *)((void *)0));
  }
#line 552
  if (! tuning) {
#line 553
    tuning = & default_tuning;
  }
  {
#line 554
  table->tuning = tuning;
#line 555
  tmp___0 = check_tuning(table);
  }
#line 555
  if (! tmp___0) {
#line 562
    goto fail;
  }
#line 565
  if (! tuning->is_n_buckets) {
#line 567
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 568
    if ((float )4294967295U <= new_candidate) {
#line 569
      goto fail;
    }
#line 570
    candidate = (size_t )new_candidate;
  }
#line 573
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 573
    tmp___1 = -1;
  } else {
#line 573
    tmp___1 = -2;
  }
#line 573
  if ((unsigned long )((size_t )tmp___1) / sizeof(*(table->bucket)) < (unsigned long )candidate) {
#line 574
    goto fail;
  }
  {
#line 575
  table->n_buckets = next_prime(candidate);
  }
#line 576
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 576
    tmp___2 = -1;
  } else {
#line 576
    tmp___2 = -2;
  }
#line 576
  if ((unsigned long )((size_t )tmp___2) / sizeof(*(table->bucket)) < (unsigned long )table->n_buckets) {
#line 577
    goto fail;
  }
  {
#line 579
  tmp___3 = calloc(table->n_buckets, (size_t )sizeof(*(table->bucket)));
#line 579
  table->bucket = (struct hash_entry *)tmp___3;
  }
#line 580
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 581
    goto fail;
  }
#line 582
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 583
  table->n_buckets_used = (size_t )0;
#line 584
  table->n_entries = (size_t )0;
#line 586
  table->hasher = hasher;
#line 587
  table->comparator = comparator;
#line 588
  table->data_freer = data_freer;
#line 590
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 594
  return (table);
  fail: 
  {
#line 597
  free((void *)table);
  }
#line 598
  return ((Hash_table *)((void *)0));
}
}
#line 605 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 610
  bucket = table->bucket;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 610
      goto while_break;
    }
#line 612
    if (bucket->data) {
#line 618
      cursor = bucket->next;
      {
#line 618
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 618
        if (! cursor) {
#line 618
          goto while_break___0;
        }
#line 620
        if (table->data_freer) {
          {
#line 621
          (*(table->data_freer))(cursor->data);
          }
        }
#line 622
        cursor->data = (void *)0;
#line 624
        next = cursor->next;
#line 627
        cursor->next = table->free_entry_list;
#line 628
        table->free_entry_list = cursor;
#line 618
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 632
      if (table->data_freer) {
        {
#line 633
        (*(table->data_freer))(bucket->data);
        }
      }
#line 634
      bucket->data = (void *)0;
#line 635
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 610
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  table->n_buckets_used = (size_t )0;
#line 640
  table->n_entries = (size_t )0;
#line 641
  return;
}
}
#line 648 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 656
  if (table->data_freer) {
#line 656
    if (table->n_entries) {
#line 658
      bucket = table->bucket;
      {
#line 658
      while (1) {
        while_continue: /* CIL Label */ ;
#line 658
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 658
          goto while_break;
        }
#line 660
        if (bucket->data) {
#line 662
          cursor = bucket;
          {
#line 662
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 662
            if (! cursor) {
#line 662
              goto while_break___0;
            }
            {
#line 664
            (*(table->data_freer))(cursor->data);
#line 662
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 658
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 677
  bucket = table->bucket;
  {
#line 677
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 677
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 677
      goto while_break___1;
    }
#line 679
    cursor = bucket->next;
    {
#line 679
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 679
      if (! cursor) {
#line 679
        goto while_break___2;
      }
      {
#line 681
      next = cursor->next;
#line 682
      free((void *)cursor);
#line 679
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 677
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 687
  cursor = table->free_entry_list;
  {
#line 687
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 687
    if (! cursor) {
#line 687
      goto while_break___3;
    }
    {
#line 689
    next = cursor->next;
#line 690
    free((void *)cursor);
#line 687
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 696
  free((void *)table->bucket);
#line 697
  free((void *)table);
  }
#line 698
  return;
}
}
#line 705 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 710
  if (table->free_entry_list) {
#line 712
    new = table->free_entry_list;
#line 713
    table->free_entry_list = new->next;
  } else {
    {
#line 720
    tmp = malloc((size_t )sizeof(*new));
#line 720
    new = (struct hash_entry *)tmp;
    }
  }
#line 724
  return (new);
}
}
#line 730 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 733
  entry->data = (void *)0;
#line 734
  entry->next = table->free_entry_list;
#line 735
  table->free_entry_list = entry;
#line 736
  return;
}
}
#line 744 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  size_t tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 748
  tmp = (*(table->hasher))(entry, table->n_buckets);
#line 748
  bucket = table->bucket + tmp;
  }
#line 752
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
    {
#line 753
    abort();
    }
  }
#line 755
  *bucket_head = bucket;
#line 758
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 759
    return ((void *)0);
  }
  {
#line 762
  tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
  }
#line 762
  if (tmp___0) {
#line 764
    data = bucket->data;
#line 766
    if (delete) {
#line 768
      if (bucket->next) {
        {
#line 770
        next = bucket->next;
#line 774
        *bucket = *next;
#line 775
        free_entry(table, next);
        }
      } else {
#line 779
        bucket->data = (void *)0;
      }
    }
#line 783
    return (data);
  }
#line 787
  cursor = bucket;
  {
#line 787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 787
    if (! cursor->next) {
#line 787
      goto while_break;
    }
    {
#line 789
    tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
    }
#line 789
    if (tmp___1) {
#line 791
      data___0 = (cursor->next)->data;
#line 793
      if (delete) {
        {
#line 795
        next___0 = cursor->next;
#line 799
        cursor->next = next___0->next;
#line 800
        free_entry(table, next___0);
        }
      }
#line 803
      return (data___0);
    }
#line 787
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  return ((void *)0);
}
}
#line 819 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
_Bool hash_rehash(Hash_table *table , size_t candidate ) 
{ 
  Hash_table *new_table ;
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  size_t tmp ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___0 ;

  {
  {
#line 827
  new_table = hash_initialize(candidate, table->tuning, table->hasher, table->comparator,
                              table->data_freer);
  }
#line 829
  if ((unsigned long )new_table == (unsigned long )((void *)0)) {
#line 830
    return ((_Bool)0);
  }
#line 837
  new_table->free_entry_list = table->free_entry_list;
#line 839
  bucket = table->bucket;
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 839
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 839
      goto while_break;
    }
#line 840
    if (bucket->data) {
#line 841
      cursor = bucket;
      {
#line 841
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 841
        if (! cursor) {
#line 841
          goto while_break___0;
        }
        {
#line 843
        data = cursor->data;
#line 844
        tmp = (*(new_table->hasher))((void const   *)data, new_table->n_buckets);
#line 844
        new_bucket = new_table->bucket + tmp;
        }
#line 848
        if (! ((unsigned long )new_bucket < (unsigned long )new_table->bucket_limit)) {
          {
#line 849
          abort();
          }
        }
#line 851
        next = cursor->next;
#line 853
        if (new_bucket->data) {
#line 855
          if ((unsigned long )cursor == (unsigned long )bucket) {
            {
#line 859
            tmp___0 = allocate_entry(new_table);
#line 859
            new_entry = tmp___0;
            }
#line 861
            if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 862
              return ((_Bool)0);
            }
#line 864
            new_entry->data = data;
#line 865
            new_entry->next = new_bucket->next;
#line 866
            new_bucket->next = new_entry;
          } else {
#line 872
            cursor->next = new_bucket->next;
#line 873
            new_bucket->next = cursor;
          }
        } else {
#line 882
          new_bucket->data = data;
#line 883
          (new_table->n_buckets_used) ++;
#line 884
          if ((unsigned long )cursor != (unsigned long )bucket) {
            {
#line 885
            free_entry(new_table, cursor);
            }
          }
        }
#line 841
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 839
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 889
  free((void *)table->bucket);
#line 890
  table->bucket = new_table->bucket;
#line 891
  table->bucket_limit = new_table->bucket_limit;
#line 892
  table->n_buckets = new_table->n_buckets;
#line 893
  table->n_buckets_used = new_table->n_buckets_used;
#line 894
  table->free_entry_list = new_table->free_entry_list;
#line 899
  free((void *)new_table);
  }
#line 901
  return ((_Bool)1);
}
}
#line 908 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void *hash_insert(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp___0 ;
  _Bool tmp___1 ;

  {
#line 915
  if (! entry) {
    {
#line 916
    abort();
    }
  }
  {
#line 919
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
  }
#line 919
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 920
    return (data);
  }
#line 924
  if (bucket->data) {
    {
#line 926
    tmp = allocate_entry(table);
#line 926
    new_entry = tmp;
    }
#line 928
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 929
      return ((void *)0);
    }
#line 933
    new_entry->data = (void *)entry;
#line 934
    new_entry->next = bucket->next;
#line 935
    bucket->next = new_entry;
#line 936
    (table->n_entries) ++;
#line 937
    return ((void *)entry);
  }
#line 942
  bucket->data = (void *)entry;
#line 943
  (table->n_entries) ++;
#line 944
  (table->n_buckets_used) ++;
#line 951
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 956
    check_tuning(table);
    }
#line 957
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 960
      tuning = table->tuning;
#line 961
      if (tuning->is_n_buckets) {
#line 961
        tmp___0 = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 961
        tmp___0 = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 961
      candidate = (float )tmp___0;
#line 967
      if ((float )4294967295U <= candidate) {
#line 968
        return ((void *)0);
      }
      {
#line 971
      tmp___1 = hash_rehash(table, (size_t )candidate);
      }
#line 971
      if (! tmp___1) {
#line 972
        entry = (void const   *)((void *)0);
      }
    }
  }
#line 976
  return ((void *)entry);
}
}
#line 983 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;

  {
  {
#line 989
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
  }
#line 990
  if (! data) {
#line 991
    return ((void *)0);
  }
#line 993
  (table->n_entries) --;
#line 994
  if (! bucket->data) {
#line 996
    (table->n_buckets_used) --;
#line 1001
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1006
      check_tuning(table);
      }
#line 1007
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1010
        tuning = table->tuning;
#line 1011
        if (tuning->is_n_buckets) {
#line 1011
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1011
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1011
        candidate = (size_t )tmp;
#line 1017
        hash_rehash(table, candidate);
        }
      }
    }
  }
#line 1022
  return (data);
}
}
#line 964 "/usr/include/unistd.h"
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const   *prompt ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 229
extern int fflush_unlocked(FILE *__stream ) ;
#line 584
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 651
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 699
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 746
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 886
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 893
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 83 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int __fsetlocking(FILE *__fp , int __type ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 80 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/getpass.c"
static void call_fclose(void *arg ) 
{ 


  {
#line 83
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
    {
#line 84
    fclose((FILE *)arg);
    }
  }
#line 85
  return;
}
}
#line 94 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/getpass.c"
static char *buf  ;
#line 95 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/getpass.c"
static size_t bufsize  ;
#line 87 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/getpass.c"
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const   *prompt ) 
{ 
  FILE *tty ;
  FILE *in ;
  FILE *out ;
  struct termios s ;
  struct termios t ;
  _Bool tty_changed ;
  ssize_t nread ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 93
  tty_changed = (_Bool)0;
#line 101
  tty = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"w+");
  }
#line 102
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
#line 104
    in = stdin;
#line 105
    out = stderr;
  } else {
    {
#line 110
    __fsetlocking(tty, 2);
#line 112
    in = tty;
#line 112
    out = in;
    }
  }
  {
#line 115
  flockfile(out);
#line 119
  tmp___1 = fileno(in);
#line 119
  tmp___2 = tcgetattr(tmp___1, & t);
  }
#line 119
  if (tmp___2 == 0) {
    {
#line 122
    s = t;
#line 124
    t.c_lflag &= 4294967286U;
#line 125
    tmp = fileno(in);
#line 125
    tmp___0 = tcsetattr(tmp, 2, (struct termios  const  *)(& t));
#line 125
    tty_changed = (_Bool )(tmp___0 == 0);
    }
  }
  {
#line 130
  fputs_unlocked((char const   */* __restrict  */)prompt, (FILE */* __restrict  */)out);
#line 131
  fflush_unlocked(out);
#line 134
  nread = getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& bufsize),
                  (FILE */* __restrict  */)in);
#line 145
  fseeko(out, (__off_t )0, 1);
  }
#line 147
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 149
    if (nread < 0) {
#line 150
      *(buf + 0) = (char )'\000';
    } else
#line 151
    if ((int )*(buf + (nread - 1)) == 10) {
#line 154
      *(buf + (nread - 1)) = (char )'\000';
#line 155
      if (tty_changed) {
        {
#line 158
        putc_unlocked('\n', out);
        }
      }
    }
  }
#line 165
  if (tty_changed) {
    {
#line 166
    tmp___3 = fileno(in);
#line 166
    tcsetattr(tmp___3, 2, (struct termios  const  *)(& s));
    }
  }
  {
#line 169
  funlockfile(out);
#line 171
  call_fclose((void *)tty);
  }
#line 173
  return (buf);
}
}
#line 555 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/fprintftime.h"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) ;
#line 284 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static void fwrite_lowcase(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    tmp___0 = len;
#line 287
    len --;
#line 287
    if (! (tmp___0 > 0U)) {
#line 287
      goto while_break;
    }
    {
#line 289
    tmp = tolower((int )((unsigned char )*src));
#line 289
    fputc(tmp, fp);
#line 290
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 294 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static void fwrite_uppcase(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    tmp___0 = len;
#line 297
    len --;
#line 297
    if (! (tmp___0 > 0U)) {
#line 297
      goto while_break;
    }
    {
#line 299
    tmp = toupper((int )((unsigned char )*src));
#line 299
    fputc(tmp, fp);
#line 300
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return;
}
}
#line 408 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
static size_t strftime_case____0(_Bool upcase , FILE *s , char const   *format , struct tm  const  *tp ,
                                 int ut , int ns ) 
{ 
  size_t maxsize ;
  int hour12 ;
  char const   *zone ;
  size_t i ;
  FILE *p ;
  char const   *f ;
  struct tm copy ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___1[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  size_t _i ;
  size_t _i___0 ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t _i___1 ;
  size_t _i___2 ;
  size_t len ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  size_t _i___3 ;
  size_t _i___4 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  size_t _i___5 ;
  size_t _i___6 ;
  int century ;
  int tmp___9 ;
  int tmp___10 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___11 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int padding ;
  size_t _i___9 ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___12 ;
  size_t _i___10 ;
  size_t _i___11 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___13 ;
  size_t _i___12 ;
  size_t _i___13 ;
  size_t _i___14 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___14 ;
  size_t _i___15 ;
  size_t _i___16 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___15 ;
  size_t _i___17 ;
  size_t _i___18 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___16 ;
  size_t _i___19 ;
  size_t _i___20 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___17 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___18 ;
  size_t _i___21 ;
  size_t _i___22 ;
  int year ;
  int tmp___19 ;
  int year_adjust ;
  int days ;
  int tmp___20 ;
  int tmp___21 ;
  int d___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int yy ;
  int tmp___24 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___25 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___26 ;
  size_t _i___23 ;
  size_t _i___24 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___27 ;
  size_t _i___25 ;
  size_t _i___26 ;
  void *__cil_tmp150 ;
  void *__cil_tmp151 ;
  void *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;

  {
#line 418
  maxsize = (size_t )-1;
#line 421
  hour12 = (int )tp->tm_hour;
#line 446
  i = (size_t )0;
#line 447
  p = s;
#line 458
  copy = *tp;
#line 459
  tp = (struct tm  const  *)(& copy);
#line 462
  zone = (char const   *)((void *)0);
#line 470
  zone = (char const   *)tp->tm_zone;
#line 488
  if (hour12 > 12) {
#line 489
    hour12 -= 12;
  } else
#line 491
  if (hour12 == 0) {
#line 492
    hour12 = 12;
  }
#line 494
  f = format;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! ((int const   )*f != 0)) {
#line 494
      goto while_break;
    }
#line 496
    pad = 0;
#line 498
    digits = 0;
#line 512
    width = -1;
#line 513
    to_lowcase = (_Bool)0;
#line 514
    to_uppcase = upcase;
#line 516
    change_case = (_Bool)0;
#line 599
    if ((int const   )*f != 37) {
      {
#line 601
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 601
        _n = 1;
#line 601
        _delta = width - _n;
#line 601
        if (_delta > 0) {
#line 601
          tmp = _delta;
        } else {
#line 601
          tmp = 0;
        }
#line 601
        _incr = _n + tmp;
#line 601
        if ((size_t )_incr >= maxsize - i) {
#line 601
          return ((size_t )0);
        }
#line 601
        if (p) {
#line 601
          if (digits == 0) {
#line 601
            if (_delta > 0) {
#line 601
              if (pad == 48) {
                {
#line 601
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 601
                  _i = (size_t )0;
                  {
#line 601
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 601
                    if (! (_i < (size_t )_delta)) {
#line 601
                      goto while_break___2;
                    }
                    {
#line 601
                    fputc('0', p);
#line 601
                    _i ++;
                    }
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 601
                  goto while_break___1;
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
                {
#line 601
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 601
                  _i___0 = (size_t )0;
                  {
#line 601
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 601
                    if (! (_i___0 < (size_t )_delta)) {
#line 601
                      goto while_break___4;
                    }
                    {
#line 601
                    fputc(' ', p);
#line 601
                    _i___0 ++;
                    }
                  }
                  while_break___4: /* CIL Label */ ;
                  }
#line 601
                  goto while_break___3;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
            }
          }
          {
#line 601
          fputc((int )*f, p);
          }
        }
#line 601
        i += (size_t )_incr;
#line 601
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 602
      goto __Cont;
    }
    {
#line 608
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 610
      f ++;
      {
#line 615
      if ((int const   )*f == 48) {
#line 615
        goto case_48;
      }
#line 615
      if ((int const   )*f == 45) {
#line 615
        goto case_48;
      }
#line 615
      if ((int const   )*f == 95) {
#line 615
        goto case_48;
      }
#line 620
      if ((int const   )*f == 94) {
#line 620
        goto case_94;
      }
#line 623
      if ((int const   )*f == 35) {
#line 623
        goto case_35;
      }
#line 627
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 616
      pad = (int )*f;
#line 617
      goto while_continue___5;
      case_94: /* CIL Label */ 
#line 621
      to_uppcase = (_Bool)1;
#line 622
      goto while_continue___5;
      case_35: /* CIL Label */ 
#line 624
      change_case = (_Bool)1;
#line 625
      goto while_continue___5;
      switch_default: /* CIL Label */ 
#line 628
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 630
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 634
    if ((unsigned int )*f - 48U <= 9U) {
#line 636
      width = 0;
      {
#line 637
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 639
        if (width > 214748364) {
#line 642
          width = 2147483647;
        } else
#line 639
        if (width == 214748364) {
#line 639
          if ((int const   )*f - 48 > 7) {
#line 642
            width = 2147483647;
          } else {
#line 645
            width *= 10;
#line 646
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 645
          width *= 10;
#line 646
          width += (int )((int const   )*f - 48);
        }
#line 648
        f ++;
#line 637
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 637
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 657
    if ((int const   )*f == 79) {
#line 657
      goto case_79;
    }
#line 657
    if ((int const   )*f == 69) {
#line 657
      goto case_79;
    }
#line 661
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 658
    tmp___0 = f;
#line 658
    f ++;
#line 658
    modifier = (int )*tmp___0;
#line 659
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 662
    modifier = 0;
#line 663
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 667
    format_char = (int )*f;
    {
#line 690
    if (format_char == 37) {
#line 690
      goto case_37;
    }
#line 696
    if (format_char == 97) {
#line 696
      goto case_97;
    }
#line 711
    if (format_char == 65) {
#line 711
      goto case_65;
    }
#line 727
    if (format_char == 104) {
#line 727
      goto case_104;
    }
#line 727
    if (format_char == 98) {
#line 727
      goto case_104;
    }
#line 742
    if (format_char == 66) {
#line 742
      goto case_66;
    }
#line 757
    if (format_char == 99) {
#line 757
      goto case_99;
    }
#line 816
    if (format_char == 67) {
#line 816
      goto case_67;
    }
#line 845
    if (format_char == 120) {
#line 845
      goto case_120;
    }
#line 858
    if (format_char == 68) {
#line 858
      goto case_68;
    }
#line 864
    if (format_char == 100) {
#line 864
      goto case_100;
    }
#line 870
    if (format_char == 101) {
#line 870
      goto case_101;
    }
#line 996
    if (format_char == 70) {
#line 996
      goto case_70;
    }
#line 1002
    if (format_char == 72) {
#line 1002
      goto case_72;
    }
#line 1008
    if (format_char == 73) {
#line 1008
      goto case_73;
    }
#line 1014
    if (format_char == 107) {
#line 1014
      goto case_107;
    }
#line 1020
    if (format_char == 108) {
#line 1020
      goto case_108;
    }
#line 1026
    if (format_char == 106) {
#line 1026
      goto case_106;
    }
#line 1032
    if (format_char == 77) {
#line 1032
      goto case_77;
    }
#line 1038
    if (format_char == 109) {
#line 1038
      goto case_109;
    }
#line 1045
    if (format_char == 78) {
#line 1045
      goto case_78;
    }
#line 1063
    if (format_char == 110) {
#line 1063
      goto case_110;
    }
#line 1067
    if (format_char == 80) {
#line 1067
      goto case_80;
    }
#line 1074
    if (format_char == 112) {
#line 1074
      goto case_112;
    }
#line 1087
    if (format_char == 82) {
#line 1087
      goto case_82;
    }
#line 1091
    if (format_char == 114) {
#line 1091
      goto case_114;
    }
#line 1102
    if (format_char == 83) {
#line 1102
      goto case_83;
    }
#line 1108
    if (format_char == 115) {
#line 1108
      goto case_115;
    }
#line 1135
    if (format_char == 88) {
#line 1135
      goto case_88;
    }
#line 1148
    if (format_char == 84) {
#line 1148
      goto case_84;
    }
#line 1152
    if (format_char == 116) {
#line 1152
      goto case_116;
    }
#line 1156
    if (format_char == 117) {
#line 1156
      goto case_117;
    }
#line 1159
    if (format_char == 85) {
#line 1159
      goto case_85;
    }
#line 1167
    if (format_char == 71) {
#line 1167
      goto case_71;
    }
#line 1167
    if (format_char == 103) {
#line 1167
      goto case_71;
    }
#line 1167
    if (format_char == 86) {
#line 1167
      goto case_71;
    }
#line 1223
    if (format_char == 87) {
#line 1223
      goto case_87;
    }
#line 1229
    if (format_char == 119) {
#line 1229
      goto case_119;
    }
#line 1235
    if (format_char == 89) {
#line 1235
      goto case_89;
    }
#line 1259
    if (format_char == 121) {
#line 1259
      goto case_121;
    }
#line 1282
    if (format_char == 90) {
#line 1282
      goto case_90;
    }
#line 1311
    if (format_char == 58) {
#line 1311
      goto case_58;
    }
#line 1321
    if (format_char == 122) {
#line 1321
      goto case_122;
    }
#line 1399
    if (format_char == 0) {
#line 1399
      goto case_0___0;
    }
#line 1402
    goto bad_format;
    case_37: /* CIL Label */ 
#line 691
    if (modifier != 0) {
#line 692
      goto bad_format;
    }
    {
#line 693
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 693
      _n___0 = 1;
#line 693
      _delta___0 = width - _n___0;
#line 693
      if (_delta___0 > 0) {
#line 693
        tmp___1 = _delta___0;
      } else {
#line 693
        tmp___1 = 0;
      }
#line 693
      _incr___0 = _n___0 + tmp___1;
#line 693
      if ((size_t )_incr___0 >= maxsize - i) {
#line 693
        return ((size_t )0);
      }
#line 693
      if (p) {
#line 693
        if (digits == 0) {
#line 693
          if (_delta___0 > 0) {
#line 693
            if (pad == 48) {
              {
#line 693
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 693
                _i___1 = (size_t )0;
                {
#line 693
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 693
                  if (! (_i___1 < (size_t )_delta___0)) {
#line 693
                    goto while_break___9;
                  }
                  {
#line 693
                  fputc('0', p);
#line 693
                  _i___1 ++;
                  }
                }
                while_break___9: /* CIL Label */ ;
                }
#line 693
                goto while_break___8;
              }
              while_break___8: /* CIL Label */ ;
              }
            } else {
              {
#line 693
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 693
                _i___2 = (size_t )0;
                {
#line 693
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 693
                  if (! (_i___2 < (size_t )_delta___0)) {
#line 693
                    goto while_break___11;
                  }
                  {
#line 693
                  fputc(' ', p);
#line 693
                  _i___2 ++;
                  }
                }
                while_break___11: /* CIL Label */ ;
                }
#line 693
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 693
        fputc((int )*f, p);
        }
      }
#line 693
      i += (size_t )_incr___0;
#line 693
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 694
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 697
    if (modifier != 0) {
#line 698
      goto bad_format;
    }
#line 699
    if (change_case) {
#line 701
      to_uppcase = (_Bool)1;
#line 702
      to_lowcase = (_Bool)0;
    }
#line 708
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 712
    if (modifier != 0) {
#line 713
      goto bad_format;
    }
#line 714
    if (change_case) {
#line 716
      to_uppcase = (_Bool)1;
#line 717
      to_lowcase = (_Bool)0;
    }
#line 723
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 728
    if (change_case) {
#line 730
      to_uppcase = (_Bool)1;
#line 731
      to_lowcase = (_Bool)0;
    }
#line 733
    if (modifier != 0) {
#line 734
      goto bad_format;
    }
#line 739
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 743
    if (modifier != 0) {
#line 744
      goto bad_format;
    }
#line 745
    if (change_case) {
#line 747
      to_uppcase = (_Bool)1;
#line 748
      to_lowcase = (_Bool)0;
    }
#line 754
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 758
    if (modifier == 79) {
#line 759
      goto bad_format;
    }
#line 768
    goto underlying_strftime;
    subformat: 
    {
#line 773
    tmp___2 = strftime_case____0(to_uppcase, (FILE *)((void *)0), subfmt, tp, ut,
                                 ns);
#line 773
    len = tmp___2;
    }
    {
#line 777
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 777
      _n___1 = (int )len;
#line 777
      _delta___1 = width - _n___1;
#line 777
      if (_delta___1 > 0) {
#line 777
        tmp___3 = _delta___1;
      } else {
#line 777
        tmp___3 = 0;
      }
#line 777
      _incr___1 = _n___1 + tmp___3;
#line 777
      if ((size_t )_incr___1 >= maxsize - i) {
#line 777
        return ((size_t )0);
      }
#line 777
      if (p) {
#line 777
        if (digits == 0) {
#line 777
          if (_delta___1 > 0) {
#line 777
            if (pad == 48) {
              {
#line 777
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 777
                _i___3 = (size_t )0;
                {
#line 777
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 777
                  if (! (_i___3 < (size_t )_delta___1)) {
#line 777
                    goto while_break___14;
                  }
                  {
#line 777
                  fputc('0', p);
#line 777
                  _i___3 ++;
                  }
                }
                while_break___14: /* CIL Label */ ;
                }
#line 777
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            } else {
              {
#line 777
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 777
                _i___4 = (size_t )0;
                {
#line 777
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 777
                  if (! (_i___4 < (size_t )_delta___1)) {
#line 777
                    goto while_break___16;
                  }
                  {
#line 777
                  fputc(' ', p);
#line 777
                  _i___4 ++;
                  }
                }
                while_break___16: /* CIL Label */ ;
                }
#line 777
                goto while_break___15;
              }
              while_break___15: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 777
        strftime_case____0(to_uppcase, p, subfmt, tp, ut, ns);
        }
      }
#line 777
      i += (size_t )_incr___1;
#line 777
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 782
    goto switch_break___1;
    underlying_strftime: 
#line 790
    u = ufmt;
#line 803
    tmp___4 = u;
#line 803
    u ++;
#line 803
    *tmp___4 = (char )' ';
#line 804
    tmp___5 = u;
#line 804
    u ++;
#line 804
    *tmp___5 = (char )'%';
#line 805
    if (modifier != 0) {
#line 806
      tmp___6 = u;
#line 806
      u ++;
#line 806
      *tmp___6 = (char )modifier;
    }
    {
#line 807
    tmp___7 = u;
#line 807
    u ++;
#line 807
    *tmp___7 = (char )format_char;
#line 808
    *u = (char )'\000';
#line 809
    len___0 = strftime((char */* __restrict  */)(ubuf), (size_t )sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 810
    if (len___0 != 0U) {
      {
#line 811
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 811
        _n___2 = (int )(len___0 - 1U);
#line 811
        _delta___2 = width - _n___2;
#line 811
        if (_delta___2 > 0) {
#line 811
          tmp___8 = _delta___2;
        } else {
#line 811
          tmp___8 = 0;
        }
#line 811
        _incr___2 = _n___2 + tmp___8;
#line 811
        if ((size_t )_incr___2 >= maxsize - i) {
#line 811
          return ((size_t )0);
        }
#line 811
        if (p) {
#line 811
          if (digits == 0) {
#line 811
            if (_delta___2 > 0) {
#line 811
              if (pad == 48) {
                {
#line 811
                while (1) {
                  while_continue___18: /* CIL Label */ ;
#line 811
                  _i___5 = (size_t )0;
                  {
#line 811
                  while (1) {
                    while_continue___19: /* CIL Label */ ;
#line 811
                    if (! (_i___5 < (size_t )_delta___2)) {
#line 811
                      goto while_break___19;
                    }
                    {
#line 811
                    fputc('0', p);
#line 811
                    _i___5 ++;
                    }
                  }
                  while_break___19: /* CIL Label */ ;
                  }
#line 811
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
              } else {
                {
#line 811
                while (1) {
                  while_continue___20: /* CIL Label */ ;
#line 811
                  _i___6 = (size_t )0;
                  {
#line 811
                  while (1) {
                    while_continue___21: /* CIL Label */ ;
#line 811
                    if (! (_i___6 < (size_t )_delta___2)) {
#line 811
                      goto while_break___21;
                    }
                    {
#line 811
                    fputc(' ', p);
#line 811
                    _i___6 ++;
                    }
                  }
                  while_break___21: /* CIL Label */ ;
                  }
#line 811
                  goto while_break___20;
                }
                while_break___20: /* CIL Label */ ;
                }
              }
            }
          }
#line 811
          if (to_lowcase) {
            {
#line 811
            fwrite_lowcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else
#line 811
          if (to_uppcase) {
            {
#line 811
            fwrite_uppcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            }
          } else {
            {
#line 811
            fwrite((void const   */* __restrict  */)(ubuf + 1), (size_t )_n___2, (size_t )1,
                   (FILE */* __restrict  */)p);
            }
          }
        }
#line 811
        i += (size_t )_incr___2;
#line 811
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 813
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 817
    if (modifier == 79) {
#line 818
      goto bad_format;
    }
#line 819
    if (modifier == 69) {
#line 835
      goto underlying_strftime;
    }
#line 840
    century = (int )(tp->tm_year / 100 + 19);
#line 841
    if (tp->tm_year % 100 < 0) {
#line 841
      if (0 < century) {
#line 841
        tmp___9 = 1;
      } else {
#line 841
        tmp___9 = 0;
      }
    } else {
#line 841
      tmp___9 = 0;
    }
#line 841
    century -= tmp___9;
#line 842
    digits = 2;
#line 842
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 842
    u_number_value = (unsigned int )century;
#line 842
    goto do_signed_number;
    case_120: /* CIL Label */ 
#line 846
    if (modifier == 79) {
#line 847
      goto bad_format;
    }
#line 856
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 859
    if (modifier != 0) {
#line 860
      goto bad_format;
    }
#line 861
    subfmt = "%m/%d/%y";
#line 862
    goto subformat;
    case_100: /* CIL Label */ 
#line 865
    if (modifier == 69) {
#line 866
      goto bad_format;
    }
#line 868
    digits = 2;
#line 868
    number_value = (int )tp->tm_mday;
#line 868
    goto do_number;
    case_101: /* CIL Label */ 
#line 871
    if (modifier == 69) {
#line 872
      goto bad_format;
    }
#line 874
    digits = 2;
#line 874
    number_value = (int )tp->tm_mday;
#line 874
    goto do_number_spacepad;
    do_tz_offset: 
#line 880
    always_output_a_sign = (_Bool)1;
#line 881
    goto do_number_body;
    do_number_spacepad: 
#line 885
    if (pad != 48) {
#line 885
      if (pad != 45) {
#line 886
        pad = '_';
      }
    }
    do_number: 
#line 890
    negative_number = (_Bool )(number_value < 0);
#line 891
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 894
    always_output_a_sign = (_Bool)0;
#line 895
    tz_colon_mask = 0;
    do_number_body: 
#line 903
    if (modifier == 79) {
#line 903
      if (! negative_number) {
#line 921
        goto underlying_strftime;
      }
    }
#line 925
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 927
    if (negative_number) {
#line 928
      u_number_value = - u_number_value;
    }
    {
#line 930
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 932
      if (tz_colon_mask & 1) {
#line 933
        bufp --;
#line 933
        *bufp = (char )':';
      }
#line 934
      tz_colon_mask >>= 1;
#line 935
      bufp --;
#line 935
      *bufp = (char )(u_number_value % 10U + 48U);
#line 936
      u_number_value /= 10U;
#line 930
      if (! (u_number_value != 0U)) {
#line 930
        if (! (tz_colon_mask != 0)) {
#line 930
          goto while_break___22;
        }
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 941
    if (digits < width) {
#line 942
      digits = width;
    }
#line 944
    if (negative_number) {
#line 944
      sign_char = (char )'-';
    } else {
#line 944
      if (always_output_a_sign) {
#line 944
        tmp___10 = '+';
      } else {
#line 944
        tmp___10 = 0;
      }
#line 944
      sign_char = (char )tmp___10;
    }
#line 948
    if (pad == 45) {
#line 950
      if (sign_char) {
        {
#line 951
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 951
          _n___3 = 1;
#line 951
          _delta___3 = width - _n___3;
#line 951
          if (_delta___3 > 0) {
#line 951
            tmp___11 = _delta___3;
          } else {
#line 951
            tmp___11 = 0;
          }
#line 951
          _incr___3 = _n___3 + tmp___11;
#line 951
          if ((size_t )_incr___3 >= maxsize - i) {
#line 951
            return ((size_t )0);
          }
#line 951
          if (p) {
#line 951
            if (digits == 0) {
#line 951
              if (_delta___3 > 0) {
#line 951
                if (pad == 48) {
                  {
#line 951
                  while (1) {
                    while_continue___24: /* CIL Label */ ;
#line 951
                    _i___7 = (size_t )0;
                    {
#line 951
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 951
                      if (! (_i___7 < (size_t )_delta___3)) {
#line 951
                        goto while_break___25;
                      }
                      {
#line 951
                      fputc('0', p);
#line 951
                      _i___7 ++;
                      }
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 951
                    goto while_break___24;
                  }
                  while_break___24: /* CIL Label */ ;
                  }
                } else {
                  {
#line 951
                  while (1) {
                    while_continue___26: /* CIL Label */ ;
#line 951
                    _i___8 = (size_t )0;
                    {
#line 951
                    while (1) {
                      while_continue___27: /* CIL Label */ ;
#line 951
                      if (! (_i___8 < (size_t )_delta___3)) {
#line 951
                        goto while_break___27;
                      }
                      {
#line 951
                      fputc(' ', p);
#line 951
                      _i___8 ++;
                      }
                    }
                    while_break___27: /* CIL Label */ ;
                    }
#line 951
                    goto while_break___26;
                  }
                  while_break___26: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 951
            fputc((int )sign_char, p);
            }
          }
#line 951
          i += (size_t )_incr___3;
#line 951
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
    } else {
#line 955
      padding = (int )(((long )digits - ((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp)) - (long )(! (! sign_char)));
#line 958
      if (padding > 0) {
#line 960
        if (pad == 95) {
#line 962
          if ((size_t )padding >= maxsize - i) {
#line 963
            return ((size_t )0);
          }
#line 965
          if (p) {
            {
#line 966
            while (1) {
              while_continue___28: /* CIL Label */ ;
#line 966
              _i___9 = (size_t )0;
              {
#line 966
              while (1) {
                while_continue___29: /* CIL Label */ ;
#line 966
                if (! (_i___9 < (size_t )padding)) {
#line 966
                  goto while_break___29;
                }
                {
#line 966
                fputc(' ', p);
#line 966
                _i___9 ++;
                }
              }
              while_break___29: /* CIL Label */ ;
              }
#line 966
              goto while_break___28;
            }
            while_break___28: /* CIL Label */ ;
            }
          }
#line 967
          i += (size_t )padding;
#line 968
          if (width > padding) {
#line 968
            width -= padding;
          } else {
#line 968
            width = 0;
          }
#line 969
          if (sign_char) {
            {
#line 970
            while (1) {
              while_continue___30: /* CIL Label */ ;
#line 970
              _n___4 = 1;
#line 970
              _delta___4 = width - _n___4;
#line 970
              if (_delta___4 > 0) {
#line 970
                tmp___12 = _delta___4;
              } else {
#line 970
                tmp___12 = 0;
              }
#line 970
              _incr___4 = _n___4 + tmp___12;
#line 970
              if ((size_t )_incr___4 >= maxsize - i) {
#line 970
                return ((size_t )0);
              }
#line 970
              if (p) {
#line 970
                if (digits == 0) {
#line 970
                  if (_delta___4 > 0) {
#line 970
                    if (pad == 48) {
                      {
#line 970
                      while (1) {
                        while_continue___31: /* CIL Label */ ;
#line 970
                        _i___10 = (size_t )0;
                        {
#line 970
                        while (1) {
                          while_continue___32: /* CIL Label */ ;
#line 970
                          if (! (_i___10 < (size_t )_delta___4)) {
#line 970
                            goto while_break___32;
                          }
                          {
#line 970
                          fputc('0', p);
#line 970
                          _i___10 ++;
                          }
                        }
                        while_break___32: /* CIL Label */ ;
                        }
#line 970
                        goto while_break___31;
                      }
                      while_break___31: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 970
                      while (1) {
                        while_continue___33: /* CIL Label */ ;
#line 970
                        _i___11 = (size_t )0;
                        {
#line 970
                        while (1) {
                          while_continue___34: /* CIL Label */ ;
#line 970
                          if (! (_i___11 < (size_t )_delta___4)) {
#line 970
                            goto while_break___34;
                          }
                          {
#line 970
                          fputc(' ', p);
#line 970
                          _i___11 ++;
                          }
                        }
                        while_break___34: /* CIL Label */ ;
                        }
#line 970
                        goto while_break___33;
                      }
                      while_break___33: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 970
                fputc((int )sign_char, p);
                }
              }
#line 970
              i += (size_t )_incr___4;
#line 970
              goto while_break___30;
            }
            while_break___30: /* CIL Label */ ;
            }
          }
        } else {
#line 974
          if ((size_t )digits >= maxsize - i) {
#line 975
            return ((size_t )0);
          }
#line 977
          if (sign_char) {
            {
#line 978
            while (1) {
              while_continue___35: /* CIL Label */ ;
#line 978
              _n___5 = 1;
#line 978
              _delta___5 = width - _n___5;
#line 978
              if (_delta___5 > 0) {
#line 978
                tmp___13 = _delta___5;
              } else {
#line 978
                tmp___13 = 0;
              }
#line 978
              _incr___5 = _n___5 + tmp___13;
#line 978
              if ((size_t )_incr___5 >= maxsize - i) {
#line 978
                return ((size_t )0);
              }
#line 978
              if (p) {
#line 978
                if (digits == 0) {
#line 978
                  if (_delta___5 > 0) {
#line 978
                    if (pad == 48) {
                      {
#line 978
                      while (1) {
                        while_continue___36: /* CIL Label */ ;
#line 978
                        _i___12 = (size_t )0;
                        {
#line 978
                        while (1) {
                          while_continue___37: /* CIL Label */ ;
#line 978
                          if (! (_i___12 < (size_t )_delta___5)) {
#line 978
                            goto while_break___37;
                          }
                          {
#line 978
                          fputc('0', p);
#line 978
                          _i___12 ++;
                          }
                        }
                        while_break___37: /* CIL Label */ ;
                        }
#line 978
                        goto while_break___36;
                      }
                      while_break___36: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 978
                      while (1) {
                        while_continue___38: /* CIL Label */ ;
#line 978
                        _i___13 = (size_t )0;
                        {
#line 978
                        while (1) {
                          while_continue___39: /* CIL Label */ ;
#line 978
                          if (! (_i___13 < (size_t )_delta___5)) {
#line 978
                            goto while_break___39;
                          }
                          {
#line 978
                          fputc(' ', p);
#line 978
                          _i___13 ++;
                          }
                        }
                        while_break___39: /* CIL Label */ ;
                        }
#line 978
                        goto while_break___38;
                      }
                      while_break___38: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 978
                fputc((int )sign_char, p);
                }
              }
#line 978
              i += (size_t )_incr___5;
#line 978
              goto while_break___35;
            }
            while_break___35: /* CIL Label */ ;
            }
          }
#line 980
          if (p) {
            {
#line 981
            while (1) {
              while_continue___40: /* CIL Label */ ;
#line 981
              _i___14 = (size_t )0;
              {
#line 981
              while (1) {
                while_continue___41: /* CIL Label */ ;
#line 981
                if (! (_i___14 < (size_t )padding)) {
#line 981
                  goto while_break___41;
                }
                {
#line 981
                fputc('0', p);
#line 981
                _i___14 ++;
                }
              }
              while_break___41: /* CIL Label */ ;
              }
#line 981
              goto while_break___40;
            }
            while_break___40: /* CIL Label */ ;
            }
          }
#line 982
          i += (size_t )padding;
#line 983
          width = 0;
        }
      } else
#line 988
      if (sign_char) {
        {
#line 989
        while (1) {
          while_continue___42: /* CIL Label */ ;
#line 989
          _n___6 = 1;
#line 989
          _delta___6 = width - _n___6;
#line 989
          if (_delta___6 > 0) {
#line 989
            tmp___14 = _delta___6;
          } else {
#line 989
            tmp___14 = 0;
          }
#line 989
          _incr___6 = _n___6 + tmp___14;
#line 989
          if ((size_t )_incr___6 >= maxsize - i) {
#line 989
            return ((size_t )0);
          }
#line 989
          if (p) {
#line 989
            if (digits == 0) {
#line 989
              if (_delta___6 > 0) {
#line 989
                if (pad == 48) {
                  {
#line 989
                  while (1) {
                    while_continue___43: /* CIL Label */ ;
#line 989
                    _i___15 = (size_t )0;
                    {
#line 989
                    while (1) {
                      while_continue___44: /* CIL Label */ ;
#line 989
                      if (! (_i___15 < (size_t )_delta___6)) {
#line 989
                        goto while_break___44;
                      }
                      {
#line 989
                      fputc('0', p);
#line 989
                      _i___15 ++;
                      }
                    }
                    while_break___44: /* CIL Label */ ;
                    }
#line 989
                    goto while_break___43;
                  }
                  while_break___43: /* CIL Label */ ;
                  }
                } else {
                  {
#line 989
                  while (1) {
                    while_continue___45: /* CIL Label */ ;
#line 989
                    _i___16 = (size_t )0;
                    {
#line 989
                    while (1) {
                      while_continue___46: /* CIL Label */ ;
#line 989
                      if (! (_i___16 < (size_t )_delta___6)) {
#line 989
                        goto while_break___46;
                      }
                      {
#line 989
                      fputc(' ', p);
#line 989
                      _i___16 ++;
                      }
                    }
                    while_break___46: /* CIL Label */ ;
                    }
#line 989
                    goto while_break___45;
                  }
                  while_break___45: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 989
            fputc((int )sign_char, p);
            }
          }
#line 989
          i += (size_t )_incr___6;
#line 989
          goto while_break___42;
        }
        while_break___42: /* CIL Label */ ;
        }
      }
    }
    {
#line 993
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 993
      _n___7 = (int )((buf___1 + sizeof(buf___1) / sizeof(buf___1[0])) - bufp);
#line 993
      _delta___7 = width - _n___7;
#line 993
      if (_delta___7 > 0) {
#line 993
        tmp___15 = _delta___7;
      } else {
#line 993
        tmp___15 = 0;
      }
#line 993
      _incr___7 = _n___7 + tmp___15;
#line 993
      if ((size_t )_incr___7 >= maxsize - i) {
#line 993
        return ((size_t )0);
      }
#line 993
      if (p) {
#line 993
        if (digits == 0) {
#line 993
          if (_delta___7 > 0) {
#line 993
            if (pad == 48) {
              {
#line 993
              while (1) {
                while_continue___48: /* CIL Label */ ;
#line 993
                _i___17 = (size_t )0;
                {
#line 993
                while (1) {
                  while_continue___49: /* CIL Label */ ;
#line 993
                  if (! (_i___17 < (size_t )_delta___7)) {
#line 993
                    goto while_break___49;
                  }
                  {
#line 993
                  fputc('0', p);
#line 993
                  _i___17 ++;
                  }
                }
                while_break___49: /* CIL Label */ ;
                }
#line 993
                goto while_break___48;
              }
              while_break___48: /* CIL Label */ ;
              }
            } else {
              {
#line 993
              while (1) {
                while_continue___50: /* CIL Label */ ;
#line 993
                _i___18 = (size_t )0;
                {
#line 993
                while (1) {
                  while_continue___51: /* CIL Label */ ;
#line 993
                  if (! (_i___18 < (size_t )_delta___7)) {
#line 993
                    goto while_break___51;
                  }
                  {
#line 993
                  fputc(' ', p);
#line 993
                  _i___18 ++;
                  }
                }
                while_break___51: /* CIL Label */ ;
                }
#line 993
                goto while_break___50;
              }
              while_break___50: /* CIL Label */ ;
              }
            }
          }
        }
#line 993
        if (to_lowcase) {
          {
#line 993
          fwrite_lowcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else
#line 993
        if (to_uppcase) {
          {
#line 993
          fwrite_uppcase(p, (char const   *)bufp, (size_t )_n___7);
          }
        } else {
          {
#line 993
          fwrite((void const   */* __restrict  */)bufp, (size_t )_n___7, (size_t )1,
                 (FILE */* __restrict  */)p);
          }
        }
      }
#line 993
      i += (size_t )_incr___7;
#line 993
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
#line 994
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 997
    if (modifier != 0) {
#line 998
      goto bad_format;
    }
#line 999
    subfmt = "%Y-%m-%d";
#line 1000
    goto subformat;
    case_72: /* CIL Label */ 
#line 1003
    if (modifier == 69) {
#line 1004
      goto bad_format;
    }
#line 1006
    digits = 2;
#line 1006
    number_value = (int )tp->tm_hour;
#line 1006
    goto do_number;
    case_73: /* CIL Label */ 
#line 1009
    if (modifier == 69) {
#line 1010
      goto bad_format;
    }
#line 1012
    digits = 2;
#line 1012
    number_value = hour12;
#line 1012
    goto do_number;
    case_107: /* CIL Label */ 
#line 1015
    if (modifier == 69) {
#line 1016
      goto bad_format;
    }
#line 1018
    digits = 2;
#line 1018
    number_value = (int )tp->tm_hour;
#line 1018
    goto do_number_spacepad;
    case_108: /* CIL Label */ 
#line 1021
    if (modifier == 69) {
#line 1022
      goto bad_format;
    }
#line 1024
    digits = 2;
#line 1024
    number_value = hour12;
#line 1024
    goto do_number_spacepad;
    case_106: /* CIL Label */ 
#line 1027
    if (modifier == 69) {
#line 1028
      goto bad_format;
    }
#line 1030
    digits = 3;
#line 1030
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1030
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1030
    goto do_signed_number;
    case_77: /* CIL Label */ 
#line 1033
    if (modifier == 69) {
#line 1034
      goto bad_format;
    }
#line 1036
    digits = 2;
#line 1036
    number_value = (int )tp->tm_min;
#line 1036
    goto do_number;
    case_109: /* CIL Label */ 
#line 1039
    if (modifier == 69) {
#line 1040
      goto bad_format;
    }
#line 1042
    digits = 2;
#line 1042
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1042
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1042
    goto do_signed_number;
    case_78: /* CIL Label */ 
#line 1046
    if (modifier == 69) {
#line 1047
      goto bad_format;
    }
#line 1049
    number_value = ns;
#line 1050
    if (width == -1) {
#line 1051
      width = 9;
    } else {
#line 1056
      j = width;
      {
#line 1056
      while (1) {
        while_continue___52: /* CIL Label */ ;
#line 1056
        if (! (j < 9)) {
#line 1056
          goto while_break___52;
        }
#line 1057
        number_value /= 10;
#line 1056
        j ++;
      }
      while_break___52: /* CIL Label */ ;
      }
    }
#line 1060
    digits = width;
#line 1060
    number_value = number_value;
#line 1060
    goto do_number;
    case_110: /* CIL Label */ 
    {
#line 1064
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 1064
      _n___8 = 1;
#line 1064
      _delta___8 = width - _n___8;
#line 1064
      if (_delta___8 > 0) {
#line 1064
        tmp___16 = _delta___8;
      } else {
#line 1064
        tmp___16 = 0;
      }
#line 1064
      _incr___8 = _n___8 + tmp___16;
#line 1064
      if ((size_t )_incr___8 >= maxsize - i) {
#line 1064
        return ((size_t )0);
      }
#line 1064
      if (p) {
#line 1064
        if (digits == 0) {
#line 1064
          if (_delta___8 > 0) {
#line 1064
            if (pad == 48) {
              {
#line 1064
              while (1) {
                while_continue___54: /* CIL Label */ ;
#line 1064
                _i___19 = (size_t )0;
                {
#line 1064
                while (1) {
                  while_continue___55: /* CIL Label */ ;
#line 1064
                  if (! (_i___19 < (size_t )_delta___8)) {
#line 1064
                    goto while_break___55;
                  }
                  {
#line 1064
                  fputc('0', p);
#line 1064
                  _i___19 ++;
                  }
                }
                while_break___55: /* CIL Label */ ;
                }
#line 1064
                goto while_break___54;
              }
              while_break___54: /* CIL Label */ ;
              }
            } else {
              {
#line 1064
              while (1) {
                while_continue___56: /* CIL Label */ ;
#line 1064
                _i___20 = (size_t )0;
                {
#line 1064
                while (1) {
                  while_continue___57: /* CIL Label */ ;
#line 1064
                  if (! (_i___20 < (size_t )_delta___8)) {
#line 1064
                    goto while_break___57;
                  }
                  {
#line 1064
                  fputc(' ', p);
#line 1064
                  _i___20 ++;
                  }
                }
                while_break___57: /* CIL Label */ ;
                }
#line 1064
                goto while_break___56;
              }
              while_break___56: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1064
        fputc('\n', p);
        }
      }
#line 1064
      i += (size_t )_incr___8;
#line 1064
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
#line 1065
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1068
    to_lowcase = (_Bool)1;
#line 1070
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1075
    if (change_case) {
#line 1077
      to_uppcase = (_Bool)0;
#line 1078
      to_lowcase = (_Bool)1;
    }
#line 1084
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1088
    subfmt = "%H:%M";
#line 1089
    goto subformat;
    case_114: /* CIL Label */ 
#line 1099
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1103
    if (modifier == 69) {
#line 1104
      goto bad_format;
    }
#line 1106
    digits = 2;
#line 1106
    number_value = (int )tp->tm_sec;
#line 1106
    goto do_number;
    case_115: /* CIL Label */ 
    {
#line 1113
    ltm = (struct tm )*tp;
#line 1114
    t = mktime(& ltm);
#line 1119
    bufp = buf___1 + sizeof(buf___1) / sizeof(buf___1[0]);
#line 1120
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1122
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 1124
      d = (int )(t % 10L);
#line 1125
      t /= 10L;
#line 1126
      bufp --;
#line 1126
      if (negative_number) {
#line 1126
        tmp___17 = - d;
      } else {
#line 1126
        tmp___17 = d;
      }
#line 1126
      *bufp = (char )(tmp___17 + 48);
#line 1122
      if (! (t != 0L)) {
#line 1122
        goto while_break___58;
      }
    }
    while_break___58: /* CIL Label */ ;
    }
#line 1130
    digits = 1;
#line 1131
    always_output_a_sign = (_Bool)0;
#line 1132
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1136
    if (modifier == 79) {
#line 1137
      goto bad_format;
    }
#line 1146
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1149
    subfmt = "%H:%M:%S";
#line 1150
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1153
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 1153
      _n___9 = 1;
#line 1153
      _delta___9 = width - _n___9;
#line 1153
      if (_delta___9 > 0) {
#line 1153
        tmp___18 = _delta___9;
      } else {
#line 1153
        tmp___18 = 0;
      }
#line 1153
      _incr___9 = _n___9 + tmp___18;
#line 1153
      if ((size_t )_incr___9 >= maxsize - i) {
#line 1153
        return ((size_t )0);
      }
#line 1153
      if (p) {
#line 1153
        if (digits == 0) {
#line 1153
          if (_delta___9 > 0) {
#line 1153
            if (pad == 48) {
              {
#line 1153
              while (1) {
                while_continue___60: /* CIL Label */ ;
#line 1153
                _i___21 = (size_t )0;
                {
#line 1153
                while (1) {
                  while_continue___61: /* CIL Label */ ;
#line 1153
                  if (! (_i___21 < (size_t )_delta___9)) {
#line 1153
                    goto while_break___61;
                  }
                  {
#line 1153
                  fputc('0', p);
#line 1153
                  _i___21 ++;
                  }
                }
                while_break___61: /* CIL Label */ ;
                }
#line 1153
                goto while_break___60;
              }
              while_break___60: /* CIL Label */ ;
              }
            } else {
              {
#line 1153
              while (1) {
                while_continue___62: /* CIL Label */ ;
#line 1153
                _i___22 = (size_t )0;
                {
#line 1153
                while (1) {
                  while_continue___63: /* CIL Label */ ;
#line 1153
                  if (! (_i___22 < (size_t )_delta___9)) {
#line 1153
                    goto while_break___63;
                  }
                  {
#line 1153
                  fputc(' ', p);
#line 1153
                  _i___22 ++;
                  }
                }
                while_break___63: /* CIL Label */ ;
                }
#line 1153
                goto while_break___62;
              }
              while_break___62: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1153
        fputc('\t', p);
        }
      }
#line 1153
      i += (size_t )_incr___9;
#line 1153
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
#line 1154
    goto switch_break___1;
    case_117: /* CIL Label */ 
#line 1157
    digits = 1;
#line 1157
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1157
    goto do_number;
    case_85: /* CIL Label */ 
#line 1160
    if (modifier == 69) {
#line 1161
      goto bad_format;
    }
#line 1163
    digits = 2;
#line 1163
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1163
    goto do_number;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1168
    if (modifier == 69) {
#line 1169
      goto bad_format;
    }
#line 1175
    if (tp->tm_year < 0) {
#line 1175
      tmp___19 = 300;
    } else {
#line 1175
      tmp___19 = -100;
    }
    {
#line 1175
    year = (int )(tp->tm_year + (int const   )tmp___19);
#line 1179
    year_adjust = 0;
#line 1180
    tmp___20 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1180
    days = tmp___20;
    }
#line 1182
    if (days < 0) {
#line 1185
      year_adjust = -1;
#line 1186
      if ((year - 1) % 4 == 0) {
#line 1186
        if ((year - 1) % 100 != 0) {
#line 1186
          tmp___21 = 1;
        } else
#line 1186
        if ((year - 1) % 400 == 0) {
#line 1186
          tmp___21 = 1;
        } else {
#line 1186
          tmp___21 = 0;
        }
      } else {
#line 1186
        tmp___21 = 0;
      }
      {
#line 1186
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___21)), (int )tp->tm_wday);
      }
    } else {
#line 1191
      if (year % 4 == 0) {
#line 1191
        if (year % 100 != 0) {
#line 1191
          tmp___22 = 1;
        } else
#line 1191
        if (year % 400 == 0) {
#line 1191
          tmp___22 = 1;
        } else {
#line 1191
          tmp___22 = 0;
        }
      } else {
#line 1191
        tmp___22 = 0;
      }
      {
#line 1191
      tmp___23 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___22)),
                               (int )tp->tm_wday);
#line 1191
      d___0 = tmp___23;
      }
#line 1193
      if (0 <= d___0) {
#line 1196
        year_adjust = 1;
#line 1197
        days = d___0;
      }
    }
    {
#line 1203
    if ((int const   )*f == 103) {
#line 1203
      goto case_103___0;
    }
#line 1213
    if ((int const   )*f == 71) {
#line 1213
      goto case_71___0;
    }
#line 1218
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1205
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1206
    digits = 2;
#line 1206
    if (0 <= yy) {
#line 1206
      number_value = yy;
    } else {
#line 1206
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1206
        tmp___24 = - yy;
      } else {
#line 1206
        tmp___24 = yy + 100;
      }
#line 1206
      number_value = tmp___24;
    }
#line 1206
    goto do_number;
    case_71___0: /* CIL Label */ 
#line 1214
    digits = 4;
#line 1214
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1214
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1214
    goto do_signed_number;
    switch_default___1: /* CIL Label */ 
#line 1219
    digits = 2;
#line 1219
    number_value = days / 7 + 1;
#line 1219
    goto do_number;
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1224
    if (modifier == 69) {
#line 1225
      goto bad_format;
    }
#line 1227
    digits = 2;
#line 1227
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1227
    goto do_number;
    case_119: /* CIL Label */ 
#line 1230
    if (modifier == 69) {
#line 1231
      goto bad_format;
    }
#line 1233
    digits = 1;
#line 1233
    number_value = (int )tp->tm_wday;
#line 1233
    goto do_number;
    case_89: /* CIL Label */ 
#line 1236
    if (modifier == 69) {
#line 1250
      goto underlying_strftime;
    }
#line 1253
    if (modifier == 79) {
#line 1254
      goto bad_format;
    } else {
#line 1256
      digits = 4;
    }
#line 1256
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1256
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1256
    goto do_signed_number;
    case_121: /* CIL Label */ 
#line 1260
    if (modifier == 69) {
#line 1271
      goto underlying_strftime;
    }
#line 1276
    yy___0 = (int )(tp->tm_year % 100);
#line 1277
    if (yy___0 < 0) {
#line 1278
      if (tp->tm_year < -1900) {
#line 1278
        yy___0 = - yy___0;
      } else {
#line 1278
        yy___0 += 100;
      }
    }
#line 1279
    digits = 2;
#line 1279
    number_value = yy___0;
#line 1279
    goto do_number;
    case_90: /* CIL Label */ 
#line 1283
    if (change_case) {
#line 1285
      to_uppcase = (_Bool)0;
#line 1286
      to_lowcase = (_Bool)1;
    }
#line 1294
    if (! zone) {
#line 1295
      zone = "";
    }
    {
#line 1307
    while (1) {
      while_continue___64: /* CIL Label */ ;
      {
#line 1307
      tmp___25 = strlen(zone);
#line 1307
      _n___10 = (int )tmp___25;
#line 1307
      _delta___10 = width - _n___10;
      }
#line 1307
      if (_delta___10 > 0) {
#line 1307
        tmp___26 = _delta___10;
      } else {
#line 1307
        tmp___26 = 0;
      }
#line 1307
      _incr___10 = _n___10 + tmp___26;
#line 1307
      if ((size_t )_incr___10 >= maxsize - i) {
#line 1307
        return ((size_t )0);
      }
#line 1307
      if (p) {
#line 1307
        if (digits == 0) {
#line 1307
          if (_delta___10 > 0) {
#line 1307
            if (pad == 48) {
              {
#line 1307
              while (1) {
                while_continue___65: /* CIL Label */ ;
#line 1307
                _i___23 = (size_t )0;
                {
#line 1307
                while (1) {
                  while_continue___66: /* CIL Label */ ;
#line 1307
                  if (! (_i___23 < (size_t )_delta___10)) {
#line 1307
                    goto while_break___66;
                  }
                  {
#line 1307
                  fputc('0', p);
#line 1307
                  _i___23 ++;
                  }
                }
                while_break___66: /* CIL Label */ ;
                }
#line 1307
                goto while_break___65;
              }
              while_break___65: /* CIL Label */ ;
              }
            } else {
              {
#line 1307
              while (1) {
                while_continue___67: /* CIL Label */ ;
#line 1307
                _i___24 = (size_t )0;
                {
#line 1307
                while (1) {
                  while_continue___68: /* CIL Label */ ;
#line 1307
                  if (! (_i___24 < (size_t )_delta___10)) {
#line 1307
                    goto while_break___68;
                  }
                  {
#line 1307
                  fputc(' ', p);
#line 1307
                  _i___24 ++;
                  }
                }
                while_break___68: /* CIL Label */ ;
                }
#line 1307
                goto while_break___67;
              }
              while_break___67: /* CIL Label */ ;
              }
            }
          }
        }
#line 1307
        if (to_lowcase) {
          {
#line 1307
          fwrite_lowcase(p, zone, (size_t )_n___10);
          }
        } else
#line 1307
        if (to_uppcase) {
          {
#line 1307
          fwrite_uppcase(p, zone, (size_t )_n___10);
          }
        } else {
          {
#line 1307
          fwrite((void const   */* __restrict  */)zone, (size_t )_n___10, (size_t )1,
                 (FILE */* __restrict  */)p);
          }
        }
      }
#line 1307
      i += (size_t )_incr___10;
#line 1307
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
#line 1309
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1314
    colons = (size_t )1;
    {
#line 1314
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 1314
      if (! ((int const   )*(f + colons) == 58)) {
#line 1314
        goto while_break___69;
      }
#line 1315
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1314
      colons ++;
    }
    while_break___69: /* CIL Label */ ;
    }
#line 1316
    if ((int const   )*(f + colons) != 122) {
#line 1317
      goto bad_format;
    }
#line 1318
    f += colons;
#line 1319
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1322
    colons = (size_t )0;
    do_z_conversion: 
#line 1325
    if (tp->tm_isdst < 0) {
#line 1326
      goto switch_break___1;
    }
#line 1334
    diff = (int )tp->tm_gmtoff;
#line 1371
    hour_diff = (diff / 60) / 60;
#line 1372
    min_diff = (diff / 60) % 60;
#line 1373
    sec_diff = diff % 60;
    {
#line 1377
    if (colons == 0U) {
#line 1377
      goto case_0;
    }
#line 1380
    if (colons == 1U) {
#line 1380
      goto tz_hh_mm;
    }
#line 1383
    if (colons == 2U) {
#line 1383
      goto tz_hh_mm_ss;
    }
#line 1387
    if (colons == 3U) {
#line 1387
      goto case_3;
    }
#line 1394
    goto switch_default___2;
    case_0: /* CIL Label */ 
#line 1378
    digits = 5;
#line 1378
    negative_number = (_Bool )(diff < 0);
#line 1378
    tz_colon_mask = 0;
#line 1378
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1378
    goto do_tz_offset;
    tz_hh_mm: 
    case_1: /* CIL Label */ 
#line 1381
    digits = 6;
#line 1381
    negative_number = (_Bool )(diff < 0);
#line 1381
    tz_colon_mask = 4;
#line 1381
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1381
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
#line 1384
    digits = 9;
#line 1384
    negative_number = (_Bool )(diff < 0);
#line 1384
    tz_colon_mask = 20;
#line 1384
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1384
    goto do_tz_offset;
    case_3: /* CIL Label */ 
#line 1388
    if (sec_diff != 0) {
#line 1389
      goto tz_hh_mm_ss;
    }
#line 1390
    if (min_diff != 0) {
#line 1391
      goto tz_hh_mm;
    }
#line 1392
    digits = 3;
#line 1392
    negative_number = (_Bool )(diff < 0);
#line 1392
    tz_colon_mask = 0;
#line 1392
    u_number_value = (unsigned int )hour_diff;
#line 1392
    goto do_tz_offset;
    switch_default___2: /* CIL Label */ 
#line 1395
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1400
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1409
    flen = 1;
    {
#line 1409
    while (1) {
      while_continue___70: /* CIL Label */ ;
#line 1409
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1409
        goto while_break___70;
      }
#line 1410
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1409
      flen ++;
    }
    while_break___70: /* CIL Label */ ;
    }
    {
#line 1411
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 1411
      _n___11 = flen;
#line 1411
      _delta___11 = width - _n___11;
#line 1411
      if (_delta___11 > 0) {
#line 1411
        tmp___27 = _delta___11;
      } else {
#line 1411
        tmp___27 = 0;
      }
#line 1411
      _incr___11 = _n___11 + tmp___27;
#line 1411
      if ((size_t )_incr___11 >= maxsize - i) {
#line 1411
        return ((size_t )0);
      }
#line 1411
      if (p) {
#line 1411
        if (digits == 0) {
#line 1411
          if (_delta___11 > 0) {
#line 1411
            if (pad == 48) {
              {
#line 1411
              while (1) {
                while_continue___72: /* CIL Label */ ;
#line 1411
                _i___25 = (size_t )0;
                {
#line 1411
                while (1) {
                  while_continue___73: /* CIL Label */ ;
#line 1411
                  if (! (_i___25 < (size_t )_delta___11)) {
#line 1411
                    goto while_break___73;
                  }
                  {
#line 1411
                  fputc('0', p);
#line 1411
                  _i___25 ++;
                  }
                }
                while_break___73: /* CIL Label */ ;
                }
#line 1411
                goto while_break___72;
              }
              while_break___72: /* CIL Label */ ;
              }
            } else {
              {
#line 1411
              while (1) {
                while_continue___74: /* CIL Label */ ;
#line 1411
                _i___26 = (size_t )0;
                {
#line 1411
                while (1) {
                  while_continue___75: /* CIL Label */ ;
#line 1411
                  if (! (_i___26 < (size_t )_delta___11)) {
#line 1411
                    goto while_break___75;
                  }
                  {
#line 1411
                  fputc(' ', p);
#line 1411
                  _i___26 ++;
                  }
                }
                while_break___75: /* CIL Label */ ;
                }
#line 1411
                goto while_break___74;
              }
              while_break___74: /* CIL Label */ ;
              }
            }
          }
        }
#line 1411
        if (to_lowcase) {
          {
#line 1411
          fwrite_lowcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else
#line 1411
        if (to_uppcase) {
          {
#line 1411
          fwrite_uppcase(p, f + (1 - flen), (size_t )_n___11);
          }
        } else {
          {
#line 1411
          fwrite((void const   */* __restrict  */)(f + (1 - flen)), (size_t )_n___11,
                 (size_t )1, (FILE */* __restrict  */)p);
          }
        }
      }
#line 1411
      i += (size_t )_incr___11;
#line 1411
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
#line 1413
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 494
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  return (i);
}
}
#line 1431 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/strftime.c"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1436
  tmp = strftime_case____0((_Bool)0, s, format, tp, ut, ns);
  }
#line 1436
  return (tmp);
}
}
#line 20 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/exitfail.h"
int volatile   exit_failure ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.h"
_Bool gl_des_is_weak_key(char const   *key ) ;
#line 63
void gl_des_setkey(gl_des_ctx *ctx , char const   *key ) ;
#line 69
_Bool gl_des_makekey(gl_des_ctx *ctx , char const   *key , size_t keylen ) ;
#line 74
void gl_des_ecb_crypt(gl_des_ctx *ctx , char const   *_from , char *_to , int mode___0 ) ;
#line 87
void gl_3des_set2keys(gl_3des_ctx *ctx , char const   *key1 , char const   *key2 ) ;
#line 97
void gl_3des_set3keys(gl_3des_ctx *ctx , char const   *key1 , char const   *key2 ,
                      char const   *key3 ) ;
#line 106
_Bool gl_3des_makekey(gl_3des_ctx *ctx , char const   *key , size_t keylen ) ;
#line 114
void gl_3des_ecb_crypt(gl_3des_ctx *ctx , char const   *_from , char *_to , int mode___0 ) ;
#line 110 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox1[64]  = 
#line 110 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
  {      (uint32_t const   )16843776,      (uint32_t const   )0,      (uint32_t const   )65536,      (uint32_t const   )16843780, 
        (uint32_t const   )16842756,      (uint32_t const   )66564,      (uint32_t const   )4,      (uint32_t const   )65536, 
        (uint32_t const   )1024,      (uint32_t const   )16843776,      (uint32_t const   )16843780,      (uint32_t const   )1024, 
        (uint32_t const   )16778244,      (uint32_t const   )16842756,      (uint32_t const   )16777216,      (uint32_t const   )4, 
        (uint32_t const   )1028,      (uint32_t const   )16778240,      (uint32_t const   )16778240,      (uint32_t const   )66560, 
        (uint32_t const   )66560,      (uint32_t const   )16842752,      (uint32_t const   )16842752,      (uint32_t const   )16778244, 
        (uint32_t const   )65540,      (uint32_t const   )16777220,      (uint32_t const   )16777220,      (uint32_t const   )65540, 
        (uint32_t const   )0,      (uint32_t const   )1028,      (uint32_t const   )66564,      (uint32_t const   )16777216, 
        (uint32_t const   )65536,      (uint32_t const   )16843780,      (uint32_t const   )4,      (uint32_t const   )16842752, 
        (uint32_t const   )16843776,      (uint32_t const   )16777216,      (uint32_t const   )16777216,      (uint32_t const   )1024, 
        (uint32_t const   )16842756,      (uint32_t const   )65536,      (uint32_t const   )66560,      (uint32_t const   )16777220, 
        (uint32_t const   )1024,      (uint32_t const   )4,      (uint32_t const   )16778244,      (uint32_t const   )66564, 
        (uint32_t const   )16843780,      (uint32_t const   )65540,      (uint32_t const   )16842752,      (uint32_t const   )16778244, 
        (uint32_t const   )16777220,      (uint32_t const   )1028,      (uint32_t const   )66564,      (uint32_t const   )16843776, 
        (uint32_t const   )1028,      (uint32_t const   )16778240,      (uint32_t const   )16778240,      (uint32_t const   )0, 
        (uint32_t const   )65540,      (uint32_t const   )66560,      (uint32_t const   )0,      (uint32_t const   )16842756};
#line 124 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox2[64]  = 
#line 124
  {      (uint32_t const   )2148565024U,      (uint32_t const   )2147516416U,      (uint32_t const   )32768,      (uint32_t const   )1081376, 
        (uint32_t const   )1048576,      (uint32_t const   )32,      (uint32_t const   )2148532256U,      (uint32_t const   )2147516448U, 
        (uint32_t const   )2147483680U,      (uint32_t const   )2148565024U,      (uint32_t const   )2148564992U,      (uint32_t const   )2147483648U, 
        (uint32_t const   )2147516416U,      (uint32_t const   )1048576,      (uint32_t const   )32,      (uint32_t const   )2148532256U, 
        (uint32_t const   )1081344,      (uint32_t const   )1048608,      (uint32_t const   )2147516448U,      (uint32_t const   )0, 
        (uint32_t const   )2147483648U,      (uint32_t const   )32768,      (uint32_t const   )1081376,      (uint32_t const   )2148532224U, 
        (uint32_t const   )1048608,      (uint32_t const   )2147483680U,      (uint32_t const   )0,      (uint32_t const   )1081344, 
        (uint32_t const   )32800,      (uint32_t const   )2148564992U,      (uint32_t const   )2148532224U,      (uint32_t const   )32800, 
        (uint32_t const   )0,      (uint32_t const   )1081376,      (uint32_t const   )2148532256U,      (uint32_t const   )1048576, 
        (uint32_t const   )2147516448U,      (uint32_t const   )2148532224U,      (uint32_t const   )2148564992U,      (uint32_t const   )32768, 
        (uint32_t const   )2148532224U,      (uint32_t const   )2147516416U,      (uint32_t const   )32,      (uint32_t const   )2148565024U, 
        (uint32_t const   )1081376,      (uint32_t const   )32,      (uint32_t const   )32768,      (uint32_t const   )2147483648U, 
        (uint32_t const   )32800,      (uint32_t const   )2148564992U,      (uint32_t const   )1048576,      (uint32_t const   )2147483680U, 
        (uint32_t const   )1048608,      (uint32_t const   )2147516448U,      (uint32_t const   )2147483680U,      (uint32_t const   )1048608, 
        (uint32_t const   )1081344,      (uint32_t const   )0,      (uint32_t const   )2147516416U,      (uint32_t const   )32800, 
        (uint32_t const   )2147483648U,      (uint32_t const   )2148532256U,      (uint32_t const   )2148565024U,      (uint32_t const   )1081344};
#line 138 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox3[64]  = 
#line 138
  {      (uint32_t const   )520,      (uint32_t const   )134349312,      (uint32_t const   )0,      (uint32_t const   )134348808, 
        (uint32_t const   )134218240,      (uint32_t const   )0,      (uint32_t const   )131592,      (uint32_t const   )134218240, 
        (uint32_t const   )131080,      (uint32_t const   )134217736,      (uint32_t const   )134217736,      (uint32_t const   )131072, 
        (uint32_t const   )134349320,      (uint32_t const   )131080,      (uint32_t const   )134348800,      (uint32_t const   )520, 
        (uint32_t const   )134217728,      (uint32_t const   )8,      (uint32_t const   )134349312,      (uint32_t const   )512, 
        (uint32_t const   )131584,      (uint32_t const   )134348800,      (uint32_t const   )134348808,      (uint32_t const   )131592, 
        (uint32_t const   )134218248,      (uint32_t const   )131584,      (uint32_t const   )131072,      (uint32_t const   )134218248, 
        (uint32_t const   )8,      (uint32_t const   )134349320,      (uint32_t const   )512,      (uint32_t const   )134217728, 
        (uint32_t const   )134349312,      (uint32_t const   )134217728,      (uint32_t const   )131080,      (uint32_t const   )520, 
        (uint32_t const   )131072,      (uint32_t const   )134349312,      (uint32_t const   )134218240,      (uint32_t const   )0, 
        (uint32_t const   )512,      (uint32_t const   )131080,      (uint32_t const   )134349320,      (uint32_t const   )134218240, 
        (uint32_t const   )134217736,      (uint32_t const   )512,      (uint32_t const   )0,      (uint32_t const   )134348808, 
        (uint32_t const   )134218248,      (uint32_t const   )131072,      (uint32_t const   )134217728,      (uint32_t const   )134349320, 
        (uint32_t const   )8,      (uint32_t const   )131592,      (uint32_t const   )131584,      (uint32_t const   )134217736, 
        (uint32_t const   )134348800,      (uint32_t const   )134218248,      (uint32_t const   )520,      (uint32_t const   )134348800, 
        (uint32_t const   )131592,      (uint32_t const   )8,      (uint32_t const   )134348808,      (uint32_t const   )131584};
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox4[64]  = 
#line 152
  {      (uint32_t const   )8396801,      (uint32_t const   )8321,      (uint32_t const   )8321,      (uint32_t const   )128, 
        (uint32_t const   )8396928,      (uint32_t const   )8388737,      (uint32_t const   )8388609,      (uint32_t const   )8193, 
        (uint32_t const   )0,      (uint32_t const   )8396800,      (uint32_t const   )8396800,      (uint32_t const   )8396929, 
        (uint32_t const   )129,      (uint32_t const   )0,      (uint32_t const   )8388736,      (uint32_t const   )8388609, 
        (uint32_t const   )1,      (uint32_t const   )8192,      (uint32_t const   )8388608,      (uint32_t const   )8396801, 
        (uint32_t const   )128,      (uint32_t const   )8388608,      (uint32_t const   )8193,      (uint32_t const   )8320, 
        (uint32_t const   )8388737,      (uint32_t const   )1,      (uint32_t const   )8320,      (uint32_t const   )8388736, 
        (uint32_t const   )8192,      (uint32_t const   )8396928,      (uint32_t const   )8396929,      (uint32_t const   )129, 
        (uint32_t const   )8388736,      (uint32_t const   )8388609,      (uint32_t const   )8396800,      (uint32_t const   )8396929, 
        (uint32_t const   )129,      (uint32_t const   )0,      (uint32_t const   )0,      (uint32_t const   )8396800, 
        (uint32_t const   )8320,      (uint32_t const   )8388736,      (uint32_t const   )8388737,      (uint32_t const   )1, 
        (uint32_t const   )8396801,      (uint32_t const   )8321,      (uint32_t const   )8321,      (uint32_t const   )128, 
        (uint32_t const   )8396929,      (uint32_t const   )129,      (uint32_t const   )1,      (uint32_t const   )8192, 
        (uint32_t const   )8388609,      (uint32_t const   )8193,      (uint32_t const   )8396928,      (uint32_t const   )8388737, 
        (uint32_t const   )8193,      (uint32_t const   )8320,      (uint32_t const   )8388608,      (uint32_t const   )8396801, 
        (uint32_t const   )128,      (uint32_t const   )8388608,      (uint32_t const   )8192,      (uint32_t const   )8396928};
#line 166 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox5[64]  = 
#line 166
  {      (uint32_t const   )256,      (uint32_t const   )34078976,      (uint32_t const   )34078720,      (uint32_t const   )1107296512, 
        (uint32_t const   )524288,      (uint32_t const   )256,      (uint32_t const   )1073741824,      (uint32_t const   )34078720, 
        (uint32_t const   )1074266368,      (uint32_t const   )524288,      (uint32_t const   )33554688,      (uint32_t const   )1074266368, 
        (uint32_t const   )1107296512,      (uint32_t const   )1107820544,      (uint32_t const   )524544,      (uint32_t const   )1073741824, 
        (uint32_t const   )33554432,      (uint32_t const   )1074266112,      (uint32_t const   )1074266112,      (uint32_t const   )0, 
        (uint32_t const   )1073742080,      (uint32_t const   )1107820800,      (uint32_t const   )1107820800,      (uint32_t const   )33554688, 
        (uint32_t const   )1107820544,      (uint32_t const   )1073742080,      (uint32_t const   )0,      (uint32_t const   )1107296256, 
        (uint32_t const   )34078976,      (uint32_t const   )33554432,      (uint32_t const   )1107296256,      (uint32_t const   )524544, 
        (uint32_t const   )524288,      (uint32_t const   )1107296512,      (uint32_t const   )256,      (uint32_t const   )33554432, 
        (uint32_t const   )1073741824,      (uint32_t const   )34078720,      (uint32_t const   )1107296512,      (uint32_t const   )1074266368, 
        (uint32_t const   )33554688,      (uint32_t const   )1073741824,      (uint32_t const   )1107820544,      (uint32_t const   )34078976, 
        (uint32_t const   )1074266368,      (uint32_t const   )256,      (uint32_t const   )33554432,      (uint32_t const   )1107820544, 
        (uint32_t const   )1107820800,      (uint32_t const   )524544,      (uint32_t const   )1107296256,      (uint32_t const   )1107820800, 
        (uint32_t const   )34078720,      (uint32_t const   )0,      (uint32_t const   )1074266112,      (uint32_t const   )1107296256, 
        (uint32_t const   )524544,      (uint32_t const   )33554688,      (uint32_t const   )1073742080,      (uint32_t const   )524288, 
        (uint32_t const   )0,      (uint32_t const   )1074266112,      (uint32_t const   )34078976,      (uint32_t const   )1073742080};
#line 180 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox6[64]  = 
#line 180
  {      (uint32_t const   )536870928,      (uint32_t const   )541065216,      (uint32_t const   )16384,      (uint32_t const   )541081616, 
        (uint32_t const   )541065216,      (uint32_t const   )16,      (uint32_t const   )541081616,      (uint32_t const   )4194304, 
        (uint32_t const   )536887296,      (uint32_t const   )4210704,      (uint32_t const   )4194304,      (uint32_t const   )536870928, 
        (uint32_t const   )4194320,      (uint32_t const   )536887296,      (uint32_t const   )536870912,      (uint32_t const   )16400, 
        (uint32_t const   )0,      (uint32_t const   )4194320,      (uint32_t const   )536887312,      (uint32_t const   )16384, 
        (uint32_t const   )4210688,      (uint32_t const   )536887312,      (uint32_t const   )16,      (uint32_t const   )541065232, 
        (uint32_t const   )541065232,      (uint32_t const   )0,      (uint32_t const   )4210704,      (uint32_t const   )541081600, 
        (uint32_t const   )16400,      (uint32_t const   )4210688,      (uint32_t const   )541081600,      (uint32_t const   )536870912, 
        (uint32_t const   )536887296,      (uint32_t const   )16,      (uint32_t const   )541065232,      (uint32_t const   )4210688, 
        (uint32_t const   )541081616,      (uint32_t const   )4194304,      (uint32_t const   )16400,      (uint32_t const   )536870928, 
        (uint32_t const   )4194304,      (uint32_t const   )536887296,      (uint32_t const   )536870912,      (uint32_t const   )16400, 
        (uint32_t const   )536870928,      (uint32_t const   )541081616,      (uint32_t const   )4210688,      (uint32_t const   )541065216, 
        (uint32_t const   )4210704,      (uint32_t const   )541081600,      (uint32_t const   )0,      (uint32_t const   )541065232, 
        (uint32_t const   )16,      (uint32_t const   )16384,      (uint32_t const   )541065216,      (uint32_t const   )4210704, 
        (uint32_t const   )16384,      (uint32_t const   )4194320,      (uint32_t const   )536887312,      (uint32_t const   )0, 
        (uint32_t const   )541081600,      (uint32_t const   )536870912,      (uint32_t const   )4194320,      (uint32_t const   )536887312};
#line 194 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox7[64]  = 
#line 194
  {      (uint32_t const   )2097152,      (uint32_t const   )69206018,      (uint32_t const   )67110914,      (uint32_t const   )0, 
        (uint32_t const   )2048,      (uint32_t const   )67110914,      (uint32_t const   )2099202,      (uint32_t const   )69208064, 
        (uint32_t const   )69208066,      (uint32_t const   )2097152,      (uint32_t const   )0,      (uint32_t const   )67108866, 
        (uint32_t const   )2,      (uint32_t const   )67108864,      (uint32_t const   )69206018,      (uint32_t const   )2050, 
        (uint32_t const   )67110912,      (uint32_t const   )2099202,      (uint32_t const   )2097154,      (uint32_t const   )67110912, 
        (uint32_t const   )67108866,      (uint32_t const   )69206016,      (uint32_t const   )69208064,      (uint32_t const   )2097154, 
        (uint32_t const   )69206016,      (uint32_t const   )2048,      (uint32_t const   )2050,      (uint32_t const   )69208066, 
        (uint32_t const   )2099200,      (uint32_t const   )2,      (uint32_t const   )67108864,      (uint32_t const   )2099200, 
        (uint32_t const   )67108864,      (uint32_t const   )2099200,      (uint32_t const   )2097152,      (uint32_t const   )67110914, 
        (uint32_t const   )67110914,      (uint32_t const   )69206018,      (uint32_t const   )69206018,      (uint32_t const   )2, 
        (uint32_t const   )2097154,      (uint32_t const   )67108864,      (uint32_t const   )67110912,      (uint32_t const   )2097152, 
        (uint32_t const   )69208064,      (uint32_t const   )2050,      (uint32_t const   )2099202,      (uint32_t const   )69208064, 
        (uint32_t const   )2050,      (uint32_t const   )67108866,      (uint32_t const   )69208066,      (uint32_t const   )69206016, 
        (uint32_t const   )2099200,      (uint32_t const   )0,      (uint32_t const   )2,      (uint32_t const   )69208066, 
        (uint32_t const   )0,      (uint32_t const   )2099202,      (uint32_t const   )69206016,      (uint32_t const   )2048, 
        (uint32_t const   )67108866,      (uint32_t const   )67110912,      (uint32_t const   )2048,      (uint32_t const   )2097154};
#line 208 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   sbox8[64]  = 
#line 208
  {      (uint32_t const   )268439616,      (uint32_t const   )4096,      (uint32_t const   )262144,      (uint32_t const   )268701760, 
        (uint32_t const   )268435456,      (uint32_t const   )268439616,      (uint32_t const   )64,      (uint32_t const   )268435456, 
        (uint32_t const   )262208,      (uint32_t const   )268697600,      (uint32_t const   )268701760,      (uint32_t const   )266240, 
        (uint32_t const   )268701696,      (uint32_t const   )266304,      (uint32_t const   )4096,      (uint32_t const   )64, 
        (uint32_t const   )268697600,      (uint32_t const   )268435520,      (uint32_t const   )268439552,      (uint32_t const   )4160, 
        (uint32_t const   )266240,      (uint32_t const   )262208,      (uint32_t const   )268697664,      (uint32_t const   )268701696, 
        (uint32_t const   )4160,      (uint32_t const   )0,      (uint32_t const   )0,      (uint32_t const   )268697664, 
        (uint32_t const   )268435520,      (uint32_t const   )268439552,      (uint32_t const   )266304,      (uint32_t const   )262144, 
        (uint32_t const   )266304,      (uint32_t const   )262144,      (uint32_t const   )268701696,      (uint32_t const   )4096, 
        (uint32_t const   )64,      (uint32_t const   )268697664,      (uint32_t const   )4096,      (uint32_t const   )266304, 
        (uint32_t const   )268439552,      (uint32_t const   )64,      (uint32_t const   )268435520,      (uint32_t const   )268697600, 
        (uint32_t const   )268697664,      (uint32_t const   )268435456,      (uint32_t const   )262144,      (uint32_t const   )268439616, 
        (uint32_t const   )0,      (uint32_t const   )268701760,      (uint32_t const   )262208,      (uint32_t const   )268435520, 
        (uint32_t const   )268697600,      (uint32_t const   )268439552,      (uint32_t const   )268439616,      (uint32_t const   )0, 
        (uint32_t const   )268701760,      (uint32_t const   )266240,      (uint32_t const   )266240,      (uint32_t const   )4160, 
        (uint32_t const   )4160,      (uint32_t const   )262208,      (uint32_t const   )268435456,      (uint32_t const   )268701696};
#line 226 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   leftkey_swap[16]  = 
#line 226
  {      (uint32_t const   )0,      (uint32_t const   )1,      (uint32_t const   )256,      (uint32_t const   )257, 
        (uint32_t const   )65536,      (uint32_t const   )65537,      (uint32_t const   )65792,      (uint32_t const   )65793, 
        (uint32_t const   )16777216,      (uint32_t const   )16777217,      (uint32_t const   )16777472,      (uint32_t const   )16777473, 
        (uint32_t const   )16842752,      (uint32_t const   )16842753,      (uint32_t const   )16843008,      (uint32_t const   )16843009};
#line 233 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static uint32_t const   rightkey_swap[16]  = 
#line 233
  {      (uint32_t const   )0,      (uint32_t const   )16777216,      (uint32_t const   )65536,      (uint32_t const   )16842752, 
        (uint32_t const   )256,      (uint32_t const   )16777472,      (uint32_t const   )65792,      (uint32_t const   )16843008, 
        (uint32_t const   )1,      (uint32_t const   )16777217,      (uint32_t const   )65537,      (uint32_t const   )16842753, 
        (uint32_t const   )257,      (uint32_t const   )16777473,      (uint32_t const   )65793,      (uint32_t const   )16843009};
#line 246 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static unsigned char const   encrypt_rotate_tab[16]  = 
#line 246
  {      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )1};
#line 257 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static unsigned char const   weak_keys[64][8]  = 
#line 257
  { {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0,        (unsigned char const   )254}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )30,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )14,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )224,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )240,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )254,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )0,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )0,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )30,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )14,        (unsigned char const   )254}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )224,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )240,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )254,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )254,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )0,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )0,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )30,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )14,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )224,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )240,        (unsigned char const   )254}, 
   {        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )254,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )254,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )0,        (unsigned char const   )0}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )30,        (unsigned char const   )30, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )14,        (unsigned char const   )14}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )224,        (unsigned char const   )224, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )240,        (unsigned char const   )240}, 
   {        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254, 
            (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254,        (unsigned char const   )254}};
#line 324 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
_Bool gl_des_is_weak_key(char const   *key ) 
{ 
  char work[8] ;
  int i ;
  int left ;
  int right ;
  int middle ;
  int cmp_result ;
  void *__cil_tmp8 ;

  {
#line 331
  i = 0;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (i < 8)) {
#line 331
      goto while_break;
    }
#line 332
    work[i] = (char )((int )((unsigned char )*(key + i)) & 254);
#line 331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  left = 0;
#line 336
  right = 63;
  {
#line 337
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 337
    if (! (left <= right)) {
#line 337
      goto while_break___0;
    }
    {
#line 339
    middle = (left + right) / 2;
#line 341
    cmp_result = memcmp((void const   *)(work), (void const   *)(weak_keys[middle]),
                        (size_t )8);
    }
#line 341
    if (! cmp_result) {
#line 342
      return ((_Bool)1);
    }
#line 344
    if (cmp_result > 0) {
#line 345
      left = middle + 1;
    } else {
#line 347
      right = middle - 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 350
  return ((_Bool)0);
}
}
#line 435 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
static void des_key_schedule(char const   *_rawkey , uint32_t *subkey ) 
{ 
  unsigned char const   *rawkey ;
  uint32_t left ;
  uint32_t right ;
  uint32_t work ;
  int round ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;

  {
#line 438
  rawkey = (unsigned char const   *)_rawkey;
#line 442
  left = (uint32_t )(((((int const   )*(rawkey + 0) << 24) | ((int const   )*(rawkey + 1) << 16)) | ((int const   )*(rawkey + 2) << 8)) | (int const   )*(rawkey + 3));
#line 442
  right = (uint32_t )(((((int const   )*(rawkey + 4) << 24) | ((int const   )*(rawkey + 5) << 16)) | ((int const   )*(rawkey + 6) << 8)) | (int const   )*(rawkey + 7));
#line 443
  work = ((right >> 4) ^ left) & 252645135U;
#line 443
  left ^= work;
#line 443
  right ^= work << 4;
#line 444
  work = (right ^ left) & 269488144U;
#line 444
  left ^= work;
#line 444
  right ^= work;
#line 445
  left = (uint32_t )((((((((leftkey_swap[left & 15U] << 3) | (leftkey_swap[(left >> 8) & 15U] << 2)) | (leftkey_swap[(left >> 16) & 15U] << 1)) | leftkey_swap[(left >> 24) & 15U]) | (leftkey_swap[(left >> 5) & 15U] << 7)) | (leftkey_swap[(left >> 13) & 15U] << 6)) | (leftkey_swap[(left >> 21) & 15U] << 5)) | (leftkey_swap[(left >> 29) & 15U] << 4));
#line 454
  left &= 268435455U;
#line 456
  right = (uint32_t )((((((((rightkey_swap[(right >> 1) & 15U] << 3) | (rightkey_swap[(right >> 9) & 15U] << 2)) | (rightkey_swap[(right >> 17) & 15U] << 1)) | rightkey_swap[(right >> 25) & 15U]) | (rightkey_swap[(right >> 4) & 15U] << 7)) | (rightkey_swap[(right >> 12) & 15U] << 6)) | (rightkey_swap[(right >> 20) & 15U] << 5)) | (rightkey_swap[(right >> 28) & 15U] << 4));
#line 465
  right &= 268435455U;
#line 467
  round = 0;
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (! (round < 16)) {
#line 467
      goto while_break;
    }
#line 469
    left = ((left << (int const   )encrypt_rotate_tab[round]) | (left >> (28 - (int )encrypt_rotate_tab[round]))) & 268435455U;
#line 471
    right = ((right << (int const   )encrypt_rotate_tab[round]) | (right >> (28 - (int )encrypt_rotate_tab[round]))) & 268435455U;
#line 474
    tmp = subkey;
#line 474
    subkey ++;
#line 474
    *tmp = ((((((((((((((((((((((left << 4) & 603979776U) | ((left << 28) & 268435456U)) | ((left << 14) & 134217728U)) | ((left << 18) & 34078720U)) | ((left << 6) & 16777216U)) | ((left << 9) & 2097152U)) | ((left >> 1) & 1048576U)) | ((left << 10) & 262144U)) | ((left << 2) & 131072U)) | ((left >> 10) & 65536U)) | ((right >> 13) & 8192U)) | ((right >> 4) & 4096U)) | ((right << 6) & 2048U)) | ((right >> 1) & 1024U)) | ((right >> 14) & 512U)) | (right & 256U)) | ((right >> 5) & 32U)) | ((right >> 10) & 16U)) | ((right >> 3) & 8U)) | ((right >> 18) & 4U)) | ((right >> 26) & 2U)) | ((right >> 24) & 1U);
#line 497
    tmp___0 = subkey;
#line 497
    subkey ++;
#line 497
    *tmp___0 = ((((((((((((((((((((((left << 15) & 536870912U) | ((left << 17) & 268435456U)) | ((left << 10) & 134217728U)) | ((left << 22) & 67108864U)) | ((left >> 2) & 33554432U)) | ((left << 1) & 16777216U)) | ((left << 16) & 2097152U)) | ((left << 11) & 1048576U)) | ((left << 3) & 524288U)) | ((left >> 6) & 262144U)) | ((left << 15) & 131072U)) | ((left >> 4) & 65536U)) | ((right >> 2) & 8192U)) | ((right << 8) & 4096U)) | ((right >> 14) & 2056U)) | ((right >> 9) & 1024U)) | (right & 512U)) | ((right << 7) & 256U)) | ((right >> 7) & 32U)) | ((right >> 3) & 17U)) | ((right << 2) & 4U)) | ((right >> 21) & 2U);
#line 467
    round ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return;
}
}
#line 522 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
void gl_des_setkey(gl_des_ctx *ctx , char const   *key ) 
{ 
  int i ;

  {
  {
#line 527
  des_key_schedule(key, ctx->encrypt_subkeys);
#line 529
  i = 0;
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! (i < 32)) {
#line 529
      goto while_break;
    }
#line 531
    ctx->decrypt_subkeys[i] = ctx->encrypt_subkeys[30 - i];
#line 532
    ctx->decrypt_subkeys[i + 1] = ctx->encrypt_subkeys[31 - i];
#line 529
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  return;
}
}
#line 536 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
_Bool gl_des_makekey(gl_des_ctx *ctx , char const   *key , size_t keylen ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 539
  if (keylen != 8U) {
#line 540
    return ((_Bool)0);
  }
  {
#line 542
  gl_des_setkey(ctx, key);
#line 544
  tmp = gl_des_is_weak_key(key);
  }
#line 544
  if (tmp) {
#line 544
    tmp___0 = 0;
  } else {
#line 544
    tmp___0 = 1;
  }
#line 544
  return ((_Bool )tmp___0);
}
}
#line 547 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
void gl_des_ecb_crypt(gl_des_ctx *ctx , char const   *_from , char *_to , int mode___0 ) 
{ 
  unsigned char const   *from ;
  unsigned char *to ;
  uint32_t left ;
  uint32_t right ;
  uint32_t work ;
  uint32_t *keys ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t *tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t *tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t *tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t *tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t *tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t *tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t *tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t *tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t *tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t *tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t *tmp___30 ;

  {
#line 550
  from = (unsigned char const   *)_from;
#line 551
  to = (unsigned char *)_to;
#line 555
  if (mode___0) {
#line 555
    keys = ctx->decrypt_subkeys;
  } else {
#line 555
    keys = ctx->encrypt_subkeys;
  }
#line 557
  left = (uint32_t )(((((int const   )*(from + 0) << 24) | ((int const   )*(from + 1) << 16)) | ((int const   )*(from + 2) << 8)) | (int const   )*(from + 3));
#line 557
  right = (uint32_t )(((((int const   )*(from + 4) << 24) | ((int const   )*(from + 5) << 16)) | ((int const   )*(from + 6) << 8)) | (int const   )*(from + 7));
#line 558
  work = ((left >> 4) ^ right) & 252645135U;
#line 558
  right ^= work;
#line 558
  left ^= work << 4;
#line 558
  work = ((left >> 16) ^ right) & 65535U;
#line 558
  right ^= work;
#line 558
  left ^= work << 16;
#line 558
  work = ((right >> 2) ^ left) & 858993459U;
#line 558
  left ^= work;
#line 558
  right ^= work << 2;
#line 558
  work = ((right >> 8) ^ left) & 16711935U;
#line 558
  left ^= work;
#line 558
  right ^= work << 8;
#line 558
  right = (right << 1) | (right >> 31);
#line 558
  work = (left ^ right) & 2863311530U;
#line 558
  right ^= work;
#line 558
  left ^= work;
#line 558
  left = (left << 1) | (left >> 31);
#line 559
  tmp = keys;
#line 559
  keys ++;
#line 559
  work = right ^ *tmp;
#line 559
  left ^= (unsigned int )sbox8[work & 63U];
#line 559
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 559
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 559
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 559
  tmp___0 = keys;
#line 559
  keys ++;
#line 559
  work = ((right << 28) | (right >> 4)) ^ *tmp___0;
#line 559
  left ^= (unsigned int )sbox7[work & 63U];
#line 559
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 559
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 559
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 559
  tmp___1 = keys;
#line 559
  keys ++;
#line 559
  work = left ^ *tmp___1;
#line 559
  right ^= (unsigned int )sbox8[work & 63U];
#line 559
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 559
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 559
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 559
  tmp___2 = keys;
#line 559
  keys ++;
#line 559
  work = ((left << 28) | (left >> 4)) ^ *tmp___2;
#line 559
  right ^= (unsigned int )sbox7[work & 63U];
#line 559
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 559
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 559
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 560
  tmp___3 = keys;
#line 560
  keys ++;
#line 560
  work = right ^ *tmp___3;
#line 560
  left ^= (unsigned int )sbox8[work & 63U];
#line 560
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 560
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 560
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 560
  tmp___4 = keys;
#line 560
  keys ++;
#line 560
  work = ((right << 28) | (right >> 4)) ^ *tmp___4;
#line 560
  left ^= (unsigned int )sbox7[work & 63U];
#line 560
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 560
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 560
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 560
  tmp___5 = keys;
#line 560
  keys ++;
#line 560
  work = left ^ *tmp___5;
#line 560
  right ^= (unsigned int )sbox8[work & 63U];
#line 560
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 560
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 560
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 560
  tmp___6 = keys;
#line 560
  keys ++;
#line 560
  work = ((left << 28) | (left >> 4)) ^ *tmp___6;
#line 560
  right ^= (unsigned int )sbox7[work & 63U];
#line 560
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 560
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 560
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 561
  tmp___7 = keys;
#line 561
  keys ++;
#line 561
  work = right ^ *tmp___7;
#line 561
  left ^= (unsigned int )sbox8[work & 63U];
#line 561
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 561
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 561
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 561
  tmp___8 = keys;
#line 561
  keys ++;
#line 561
  work = ((right << 28) | (right >> 4)) ^ *tmp___8;
#line 561
  left ^= (unsigned int )sbox7[work & 63U];
#line 561
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 561
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 561
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 561
  tmp___9 = keys;
#line 561
  keys ++;
#line 561
  work = left ^ *tmp___9;
#line 561
  right ^= (unsigned int )sbox8[work & 63U];
#line 561
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 561
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 561
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 561
  tmp___10 = keys;
#line 561
  keys ++;
#line 561
  work = ((left << 28) | (left >> 4)) ^ *tmp___10;
#line 561
  right ^= (unsigned int )sbox7[work & 63U];
#line 561
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 561
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 561
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 562
  tmp___11 = keys;
#line 562
  keys ++;
#line 562
  work = right ^ *tmp___11;
#line 562
  left ^= (unsigned int )sbox8[work & 63U];
#line 562
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 562
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 562
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 562
  tmp___12 = keys;
#line 562
  keys ++;
#line 562
  work = ((right << 28) | (right >> 4)) ^ *tmp___12;
#line 562
  left ^= (unsigned int )sbox7[work & 63U];
#line 562
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 562
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 562
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 562
  tmp___13 = keys;
#line 562
  keys ++;
#line 562
  work = left ^ *tmp___13;
#line 562
  right ^= (unsigned int )sbox8[work & 63U];
#line 562
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 562
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 562
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 562
  tmp___14 = keys;
#line 562
  keys ++;
#line 562
  work = ((left << 28) | (left >> 4)) ^ *tmp___14;
#line 562
  right ^= (unsigned int )sbox7[work & 63U];
#line 562
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 562
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 562
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 563
  tmp___15 = keys;
#line 563
  keys ++;
#line 563
  work = right ^ *tmp___15;
#line 563
  left ^= (unsigned int )sbox8[work & 63U];
#line 563
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 563
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 563
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 563
  tmp___16 = keys;
#line 563
  keys ++;
#line 563
  work = ((right << 28) | (right >> 4)) ^ *tmp___16;
#line 563
  left ^= (unsigned int )sbox7[work & 63U];
#line 563
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 563
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 563
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 563
  tmp___17 = keys;
#line 563
  keys ++;
#line 563
  work = left ^ *tmp___17;
#line 563
  right ^= (unsigned int )sbox8[work & 63U];
#line 563
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 563
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 563
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 563
  tmp___18 = keys;
#line 563
  keys ++;
#line 563
  work = ((left << 28) | (left >> 4)) ^ *tmp___18;
#line 563
  right ^= (unsigned int )sbox7[work & 63U];
#line 563
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 563
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 563
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 564
  tmp___19 = keys;
#line 564
  keys ++;
#line 564
  work = right ^ *tmp___19;
#line 564
  left ^= (unsigned int )sbox8[work & 63U];
#line 564
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 564
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 564
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 564
  tmp___20 = keys;
#line 564
  keys ++;
#line 564
  work = ((right << 28) | (right >> 4)) ^ *tmp___20;
#line 564
  left ^= (unsigned int )sbox7[work & 63U];
#line 564
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 564
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 564
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 564
  tmp___21 = keys;
#line 564
  keys ++;
#line 564
  work = left ^ *tmp___21;
#line 564
  right ^= (unsigned int )sbox8[work & 63U];
#line 564
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 564
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 564
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 564
  tmp___22 = keys;
#line 564
  keys ++;
#line 564
  work = ((left << 28) | (left >> 4)) ^ *tmp___22;
#line 564
  right ^= (unsigned int )sbox7[work & 63U];
#line 564
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 564
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 564
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 565
  tmp___23 = keys;
#line 565
  keys ++;
#line 565
  work = right ^ *tmp___23;
#line 565
  left ^= (unsigned int )sbox8[work & 63U];
#line 565
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 565
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 565
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 565
  tmp___24 = keys;
#line 565
  keys ++;
#line 565
  work = ((right << 28) | (right >> 4)) ^ *tmp___24;
#line 565
  left ^= (unsigned int )sbox7[work & 63U];
#line 565
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 565
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 565
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 565
  tmp___25 = keys;
#line 565
  keys ++;
#line 565
  work = left ^ *tmp___25;
#line 565
  right ^= (unsigned int )sbox8[work & 63U];
#line 565
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 565
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 565
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 565
  tmp___26 = keys;
#line 565
  keys ++;
#line 565
  work = ((left << 28) | (left >> 4)) ^ *tmp___26;
#line 565
  right ^= (unsigned int )sbox7[work & 63U];
#line 565
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 565
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 565
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 566
  tmp___27 = keys;
#line 566
  keys ++;
#line 566
  work = right ^ *tmp___27;
#line 566
  left ^= (unsigned int )sbox8[work & 63U];
#line 566
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 566
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 566
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 566
  tmp___28 = keys;
#line 566
  keys ++;
#line 566
  work = ((right << 28) | (right >> 4)) ^ *tmp___28;
#line 566
  left ^= (unsigned int )sbox7[work & 63U];
#line 566
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 566
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 566
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 566
  tmp___29 = keys;
#line 566
  keys ++;
#line 566
  work = left ^ *tmp___29;
#line 566
  right ^= (unsigned int )sbox8[work & 63U];
#line 566
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 566
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 566
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 566
  tmp___30 = keys;
#line 566
  keys ++;
#line 566
  work = ((left << 28) | (left >> 4)) ^ *tmp___30;
#line 566
  right ^= (unsigned int )sbox7[work & 63U];
#line 566
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 566
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 566
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 567
  right = (right << 31) | (right >> 1);
#line 567
  work = (right ^ left) & 2863311530U;
#line 567
  right ^= work;
#line 567
  left ^= work;
#line 567
  left = (left << 31) | (left >> 1);
#line 567
  work = ((left >> 8) ^ right) & 16711935U;
#line 567
  right ^= work;
#line 567
  left ^= work << 8;
#line 567
  work = ((left >> 2) ^ right) & 858993459U;
#line 567
  right ^= work;
#line 567
  left ^= work << 2;
#line 567
  work = ((right >> 16) ^ left) & 65535U;
#line 567
  left ^= work;
#line 567
  right ^= work << 16;
#line 567
  work = ((right >> 4) ^ left) & 252645135U;
#line 567
  left ^= work;
#line 567
  right ^= work << 4;
#line 568
  *(to + 0) = (unsigned char )((right >> 24) & 255U);
#line 568
  *(to + 1) = (unsigned char )((right >> 16) & 255U);
#line 568
  *(to + 2) = (unsigned char )((right >> 8) & 255U);
#line 568
  *(to + 3) = (unsigned char )(right & 255U);
#line 568
  *(to + 4) = (unsigned char )((left >> 24) & 255U);
#line 568
  *(to + 5) = (unsigned char )((left >> 16) & 255U);
#line 568
  *(to + 6) = (unsigned char )((left >> 8) & 255U);
#line 568
  *(to + 7) = (unsigned char )(left & 255U);
#line 569
  return;
}
}
#line 571 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
void gl_3des_set2keys(gl_3des_ctx *ctx , char const   *key1 , char const   *key2 ) 
{ 
  int i ;

  {
  {
#line 576
  des_key_schedule(key1, ctx->encrypt_subkeys);
#line 577
  des_key_schedule(key2, & ctx->decrypt_subkeys[32]);
#line 579
  i = 0;
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 579
    if (! (i < 32)) {
#line 579
      goto while_break;
    }
#line 581
    ctx->decrypt_subkeys[i] = ctx->encrypt_subkeys[30 - i];
#line 582
    ctx->decrypt_subkeys[i + 1] = ctx->encrypt_subkeys[31 - i];
#line 584
    ctx->encrypt_subkeys[i + 32] = ctx->decrypt_subkeys[62 - i];
#line 585
    ctx->encrypt_subkeys[i + 33] = ctx->decrypt_subkeys[63 - i];
#line 587
    ctx->encrypt_subkeys[i + 64] = ctx->encrypt_subkeys[i];
#line 588
    ctx->encrypt_subkeys[i + 65] = ctx->encrypt_subkeys[i + 1];
#line 590
    ctx->decrypt_subkeys[i + 64] = ctx->decrypt_subkeys[i];
#line 591
    ctx->decrypt_subkeys[i + 65] = ctx->decrypt_subkeys[i + 1];
#line 579
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 593
  return;
}
}
#line 595 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
void gl_3des_set3keys(gl_3des_ctx *ctx , char const   *key1 , char const   *key2 ,
                      char const   *key3 ) 
{ 
  int i ;

  {
  {
#line 601
  des_key_schedule(key1, ctx->encrypt_subkeys);
#line 602
  des_key_schedule(key2, & ctx->decrypt_subkeys[32]);
#line 603
  des_key_schedule(key3, & ctx->encrypt_subkeys[64]);
#line 605
  i = 0;
  }
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i < 32)) {
#line 605
      goto while_break;
    }
#line 607
    ctx->decrypt_subkeys[i] = ctx->encrypt_subkeys[94 - i];
#line 608
    ctx->decrypt_subkeys[i + 1] = ctx->encrypt_subkeys[95 - i];
#line 610
    ctx->encrypt_subkeys[i + 32] = ctx->decrypt_subkeys[62 - i];
#line 611
    ctx->encrypt_subkeys[i + 33] = ctx->decrypt_subkeys[63 - i];
#line 613
    ctx->decrypt_subkeys[i + 64] = ctx->encrypt_subkeys[30 - i];
#line 614
    ctx->decrypt_subkeys[i + 65] = ctx->encrypt_subkeys[31 - i];
#line 605
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  return;
}
}
#line 618 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
void gl_3des_ecb_crypt(gl_3des_ctx *ctx , char const   *_from , char *_to , int mode___0 ) 
{ 
  unsigned char const   *from ;
  unsigned char *to ;
  uint32_t left ;
  uint32_t right ;
  uint32_t work ;
  uint32_t *keys ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t *tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t *tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t *tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t *tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t *tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t *tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t *tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t *tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t *tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t *tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t *tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t *tmp___30 ;
  uint32_t *tmp___31 ;
  uint32_t *tmp___32 ;
  uint32_t *tmp___33 ;
  uint32_t *tmp___34 ;
  uint32_t *tmp___35 ;
  uint32_t *tmp___36 ;
  uint32_t *tmp___37 ;
  uint32_t *tmp___38 ;
  uint32_t *tmp___39 ;
  uint32_t *tmp___40 ;
  uint32_t *tmp___41 ;
  uint32_t *tmp___42 ;
  uint32_t *tmp___43 ;
  uint32_t *tmp___44 ;
  uint32_t *tmp___45 ;
  uint32_t *tmp___46 ;
  uint32_t *tmp___47 ;
  uint32_t *tmp___48 ;
  uint32_t *tmp___49 ;
  uint32_t *tmp___50 ;
  uint32_t *tmp___51 ;
  uint32_t *tmp___52 ;
  uint32_t *tmp___53 ;
  uint32_t *tmp___54 ;
  uint32_t *tmp___55 ;
  uint32_t *tmp___56 ;
  uint32_t *tmp___57 ;
  uint32_t *tmp___58 ;
  uint32_t *tmp___59 ;
  uint32_t *tmp___60 ;
  uint32_t *tmp___61 ;
  uint32_t *tmp___62 ;
  uint32_t *tmp___63 ;
  uint32_t *tmp___64 ;
  uint32_t *tmp___65 ;
  uint32_t *tmp___66 ;
  uint32_t *tmp___67 ;
  uint32_t *tmp___68 ;
  uint32_t *tmp___69 ;
  uint32_t *tmp___70 ;
  uint32_t *tmp___71 ;
  uint32_t *tmp___72 ;
  uint32_t *tmp___73 ;
  uint32_t *tmp___74 ;
  uint32_t *tmp___75 ;
  uint32_t *tmp___76 ;
  uint32_t *tmp___77 ;
  uint32_t *tmp___78 ;
  uint32_t *tmp___79 ;
  uint32_t *tmp___80 ;
  uint32_t *tmp___81 ;
  uint32_t *tmp___82 ;
  uint32_t *tmp___83 ;
  uint32_t *tmp___84 ;
  uint32_t *tmp___85 ;
  uint32_t *tmp___86 ;
  uint32_t *tmp___87 ;
  uint32_t *tmp___88 ;
  uint32_t *tmp___89 ;
  uint32_t *tmp___90 ;
  uint32_t *tmp___91 ;
  uint32_t *tmp___92 ;
  uint32_t *tmp___93 ;
  uint32_t *tmp___94 ;

  {
#line 623
  from = (unsigned char const   *)_from;
#line 624
  to = (unsigned char *)_to;
#line 628
  if (mode___0) {
#line 628
    keys = ctx->decrypt_subkeys;
  } else {
#line 628
    keys = ctx->encrypt_subkeys;
  }
#line 630
  left = (uint32_t )(((((int const   )*(from + 0) << 24) | ((int const   )*(from + 1) << 16)) | ((int const   )*(from + 2) << 8)) | (int const   )*(from + 3));
#line 630
  right = (uint32_t )(((((int const   )*(from + 4) << 24) | ((int const   )*(from + 5) << 16)) | ((int const   )*(from + 6) << 8)) | (int const   )*(from + 7));
#line 631
  work = ((left >> 4) ^ right) & 252645135U;
#line 631
  right ^= work;
#line 631
  left ^= work << 4;
#line 631
  work = ((left >> 16) ^ right) & 65535U;
#line 631
  right ^= work;
#line 631
  left ^= work << 16;
#line 631
  work = ((right >> 2) ^ left) & 858993459U;
#line 631
  left ^= work;
#line 631
  right ^= work << 2;
#line 631
  work = ((right >> 8) ^ left) & 16711935U;
#line 631
  left ^= work;
#line 631
  right ^= work << 8;
#line 631
  right = (right << 1) | (right >> 31);
#line 631
  work = (left ^ right) & 2863311530U;
#line 631
  right ^= work;
#line 631
  left ^= work;
#line 631
  left = (left << 1) | (left >> 31);
#line 632
  tmp = keys;
#line 632
  keys ++;
#line 632
  work = right ^ *tmp;
#line 632
  left ^= (unsigned int )sbox8[work & 63U];
#line 632
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 632
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 632
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 632
  tmp___0 = keys;
#line 632
  keys ++;
#line 632
  work = ((right << 28) | (right >> 4)) ^ *tmp___0;
#line 632
  left ^= (unsigned int )sbox7[work & 63U];
#line 632
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 632
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 632
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 632
  tmp___1 = keys;
#line 632
  keys ++;
#line 632
  work = left ^ *tmp___1;
#line 632
  right ^= (unsigned int )sbox8[work & 63U];
#line 632
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 632
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 632
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 632
  tmp___2 = keys;
#line 632
  keys ++;
#line 632
  work = ((left << 28) | (left >> 4)) ^ *tmp___2;
#line 632
  right ^= (unsigned int )sbox7[work & 63U];
#line 632
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 632
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 632
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 633
  tmp___3 = keys;
#line 633
  keys ++;
#line 633
  work = right ^ *tmp___3;
#line 633
  left ^= (unsigned int )sbox8[work & 63U];
#line 633
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 633
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 633
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 633
  tmp___4 = keys;
#line 633
  keys ++;
#line 633
  work = ((right << 28) | (right >> 4)) ^ *tmp___4;
#line 633
  left ^= (unsigned int )sbox7[work & 63U];
#line 633
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 633
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 633
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 633
  tmp___5 = keys;
#line 633
  keys ++;
#line 633
  work = left ^ *tmp___5;
#line 633
  right ^= (unsigned int )sbox8[work & 63U];
#line 633
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 633
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 633
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 633
  tmp___6 = keys;
#line 633
  keys ++;
#line 633
  work = ((left << 28) | (left >> 4)) ^ *tmp___6;
#line 633
  right ^= (unsigned int )sbox7[work & 63U];
#line 633
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 633
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 633
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 634
  tmp___7 = keys;
#line 634
  keys ++;
#line 634
  work = right ^ *tmp___7;
#line 634
  left ^= (unsigned int )sbox8[work & 63U];
#line 634
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 634
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 634
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 634
  tmp___8 = keys;
#line 634
  keys ++;
#line 634
  work = ((right << 28) | (right >> 4)) ^ *tmp___8;
#line 634
  left ^= (unsigned int )sbox7[work & 63U];
#line 634
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 634
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 634
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 634
  tmp___9 = keys;
#line 634
  keys ++;
#line 634
  work = left ^ *tmp___9;
#line 634
  right ^= (unsigned int )sbox8[work & 63U];
#line 634
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 634
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 634
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 634
  tmp___10 = keys;
#line 634
  keys ++;
#line 634
  work = ((left << 28) | (left >> 4)) ^ *tmp___10;
#line 634
  right ^= (unsigned int )sbox7[work & 63U];
#line 634
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 634
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 634
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 635
  tmp___11 = keys;
#line 635
  keys ++;
#line 635
  work = right ^ *tmp___11;
#line 635
  left ^= (unsigned int )sbox8[work & 63U];
#line 635
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 635
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 635
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 635
  tmp___12 = keys;
#line 635
  keys ++;
#line 635
  work = ((right << 28) | (right >> 4)) ^ *tmp___12;
#line 635
  left ^= (unsigned int )sbox7[work & 63U];
#line 635
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 635
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 635
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 635
  tmp___13 = keys;
#line 635
  keys ++;
#line 635
  work = left ^ *tmp___13;
#line 635
  right ^= (unsigned int )sbox8[work & 63U];
#line 635
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 635
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 635
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 635
  tmp___14 = keys;
#line 635
  keys ++;
#line 635
  work = ((left << 28) | (left >> 4)) ^ *tmp___14;
#line 635
  right ^= (unsigned int )sbox7[work & 63U];
#line 635
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 635
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 635
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 636
  tmp___15 = keys;
#line 636
  keys ++;
#line 636
  work = right ^ *tmp___15;
#line 636
  left ^= (unsigned int )sbox8[work & 63U];
#line 636
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 636
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 636
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 636
  tmp___16 = keys;
#line 636
  keys ++;
#line 636
  work = ((right << 28) | (right >> 4)) ^ *tmp___16;
#line 636
  left ^= (unsigned int )sbox7[work & 63U];
#line 636
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 636
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 636
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 636
  tmp___17 = keys;
#line 636
  keys ++;
#line 636
  work = left ^ *tmp___17;
#line 636
  right ^= (unsigned int )sbox8[work & 63U];
#line 636
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 636
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 636
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 636
  tmp___18 = keys;
#line 636
  keys ++;
#line 636
  work = ((left << 28) | (left >> 4)) ^ *tmp___18;
#line 636
  right ^= (unsigned int )sbox7[work & 63U];
#line 636
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 636
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 636
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 637
  tmp___19 = keys;
#line 637
  keys ++;
#line 637
  work = right ^ *tmp___19;
#line 637
  left ^= (unsigned int )sbox8[work & 63U];
#line 637
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 637
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 637
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 637
  tmp___20 = keys;
#line 637
  keys ++;
#line 637
  work = ((right << 28) | (right >> 4)) ^ *tmp___20;
#line 637
  left ^= (unsigned int )sbox7[work & 63U];
#line 637
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 637
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 637
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 637
  tmp___21 = keys;
#line 637
  keys ++;
#line 637
  work = left ^ *tmp___21;
#line 637
  right ^= (unsigned int )sbox8[work & 63U];
#line 637
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 637
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 637
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 637
  tmp___22 = keys;
#line 637
  keys ++;
#line 637
  work = ((left << 28) | (left >> 4)) ^ *tmp___22;
#line 637
  right ^= (unsigned int )sbox7[work & 63U];
#line 637
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 637
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 637
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 638
  tmp___23 = keys;
#line 638
  keys ++;
#line 638
  work = right ^ *tmp___23;
#line 638
  left ^= (unsigned int )sbox8[work & 63U];
#line 638
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 638
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 638
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 638
  tmp___24 = keys;
#line 638
  keys ++;
#line 638
  work = ((right << 28) | (right >> 4)) ^ *tmp___24;
#line 638
  left ^= (unsigned int )sbox7[work & 63U];
#line 638
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 638
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 638
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 638
  tmp___25 = keys;
#line 638
  keys ++;
#line 638
  work = left ^ *tmp___25;
#line 638
  right ^= (unsigned int )sbox8[work & 63U];
#line 638
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 638
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 638
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 638
  tmp___26 = keys;
#line 638
  keys ++;
#line 638
  work = ((left << 28) | (left >> 4)) ^ *tmp___26;
#line 638
  right ^= (unsigned int )sbox7[work & 63U];
#line 638
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 638
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 638
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 639
  tmp___27 = keys;
#line 639
  keys ++;
#line 639
  work = right ^ *tmp___27;
#line 639
  left ^= (unsigned int )sbox8[work & 63U];
#line 639
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 639
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 639
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 639
  tmp___28 = keys;
#line 639
  keys ++;
#line 639
  work = ((right << 28) | (right >> 4)) ^ *tmp___28;
#line 639
  left ^= (unsigned int )sbox7[work & 63U];
#line 639
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 639
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 639
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 639
  tmp___29 = keys;
#line 639
  keys ++;
#line 639
  work = left ^ *tmp___29;
#line 639
  right ^= (unsigned int )sbox8[work & 63U];
#line 639
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 639
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 639
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 639
  tmp___30 = keys;
#line 639
  keys ++;
#line 639
  work = ((left << 28) | (left >> 4)) ^ *tmp___30;
#line 639
  right ^= (unsigned int )sbox7[work & 63U];
#line 639
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 639
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 639
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 640
  tmp___31 = keys;
#line 640
  keys ++;
#line 640
  work = left ^ *tmp___31;
#line 640
  right ^= (unsigned int )sbox8[work & 63U];
#line 640
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 640
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 640
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 640
  tmp___32 = keys;
#line 640
  keys ++;
#line 640
  work = ((left << 28) | (left >> 4)) ^ *tmp___32;
#line 640
  right ^= (unsigned int )sbox7[work & 63U];
#line 640
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 640
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 640
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 640
  tmp___33 = keys;
#line 640
  keys ++;
#line 640
  work = right ^ *tmp___33;
#line 640
  left ^= (unsigned int )sbox8[work & 63U];
#line 640
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 640
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 640
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 640
  tmp___34 = keys;
#line 640
  keys ++;
#line 640
  work = ((right << 28) | (right >> 4)) ^ *tmp___34;
#line 640
  left ^= (unsigned int )sbox7[work & 63U];
#line 640
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 640
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 640
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 641
  tmp___35 = keys;
#line 641
  keys ++;
#line 641
  work = left ^ *tmp___35;
#line 641
  right ^= (unsigned int )sbox8[work & 63U];
#line 641
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 641
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 641
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 641
  tmp___36 = keys;
#line 641
  keys ++;
#line 641
  work = ((left << 28) | (left >> 4)) ^ *tmp___36;
#line 641
  right ^= (unsigned int )sbox7[work & 63U];
#line 641
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 641
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 641
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 641
  tmp___37 = keys;
#line 641
  keys ++;
#line 641
  work = right ^ *tmp___37;
#line 641
  left ^= (unsigned int )sbox8[work & 63U];
#line 641
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 641
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 641
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 641
  tmp___38 = keys;
#line 641
  keys ++;
#line 641
  work = ((right << 28) | (right >> 4)) ^ *tmp___38;
#line 641
  left ^= (unsigned int )sbox7[work & 63U];
#line 641
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 641
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 641
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 642
  tmp___39 = keys;
#line 642
  keys ++;
#line 642
  work = left ^ *tmp___39;
#line 642
  right ^= (unsigned int )sbox8[work & 63U];
#line 642
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 642
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 642
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 642
  tmp___40 = keys;
#line 642
  keys ++;
#line 642
  work = ((left << 28) | (left >> 4)) ^ *tmp___40;
#line 642
  right ^= (unsigned int )sbox7[work & 63U];
#line 642
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 642
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 642
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 642
  tmp___41 = keys;
#line 642
  keys ++;
#line 642
  work = right ^ *tmp___41;
#line 642
  left ^= (unsigned int )sbox8[work & 63U];
#line 642
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 642
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 642
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 642
  tmp___42 = keys;
#line 642
  keys ++;
#line 642
  work = ((right << 28) | (right >> 4)) ^ *tmp___42;
#line 642
  left ^= (unsigned int )sbox7[work & 63U];
#line 642
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 642
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 642
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 643
  tmp___43 = keys;
#line 643
  keys ++;
#line 643
  work = left ^ *tmp___43;
#line 643
  right ^= (unsigned int )sbox8[work & 63U];
#line 643
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 643
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 643
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 643
  tmp___44 = keys;
#line 643
  keys ++;
#line 643
  work = ((left << 28) | (left >> 4)) ^ *tmp___44;
#line 643
  right ^= (unsigned int )sbox7[work & 63U];
#line 643
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 643
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 643
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 643
  tmp___45 = keys;
#line 643
  keys ++;
#line 643
  work = right ^ *tmp___45;
#line 643
  left ^= (unsigned int )sbox8[work & 63U];
#line 643
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 643
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 643
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 643
  tmp___46 = keys;
#line 643
  keys ++;
#line 643
  work = ((right << 28) | (right >> 4)) ^ *tmp___46;
#line 643
  left ^= (unsigned int )sbox7[work & 63U];
#line 643
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 643
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 643
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 644
  tmp___47 = keys;
#line 644
  keys ++;
#line 644
  work = left ^ *tmp___47;
#line 644
  right ^= (unsigned int )sbox8[work & 63U];
#line 644
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 644
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 644
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 644
  tmp___48 = keys;
#line 644
  keys ++;
#line 644
  work = ((left << 28) | (left >> 4)) ^ *tmp___48;
#line 644
  right ^= (unsigned int )sbox7[work & 63U];
#line 644
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 644
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 644
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 644
  tmp___49 = keys;
#line 644
  keys ++;
#line 644
  work = right ^ *tmp___49;
#line 644
  left ^= (unsigned int )sbox8[work & 63U];
#line 644
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 644
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 644
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 644
  tmp___50 = keys;
#line 644
  keys ++;
#line 644
  work = ((right << 28) | (right >> 4)) ^ *tmp___50;
#line 644
  left ^= (unsigned int )sbox7[work & 63U];
#line 644
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 644
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 644
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 645
  tmp___51 = keys;
#line 645
  keys ++;
#line 645
  work = left ^ *tmp___51;
#line 645
  right ^= (unsigned int )sbox8[work & 63U];
#line 645
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 645
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 645
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 645
  tmp___52 = keys;
#line 645
  keys ++;
#line 645
  work = ((left << 28) | (left >> 4)) ^ *tmp___52;
#line 645
  right ^= (unsigned int )sbox7[work & 63U];
#line 645
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 645
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 645
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 645
  tmp___53 = keys;
#line 645
  keys ++;
#line 645
  work = right ^ *tmp___53;
#line 645
  left ^= (unsigned int )sbox8[work & 63U];
#line 645
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 645
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 645
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 645
  tmp___54 = keys;
#line 645
  keys ++;
#line 645
  work = ((right << 28) | (right >> 4)) ^ *tmp___54;
#line 645
  left ^= (unsigned int )sbox7[work & 63U];
#line 645
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 645
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 645
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 646
  tmp___55 = keys;
#line 646
  keys ++;
#line 646
  work = left ^ *tmp___55;
#line 646
  right ^= (unsigned int )sbox8[work & 63U];
#line 646
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 646
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 646
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 646
  tmp___56 = keys;
#line 646
  keys ++;
#line 646
  work = ((left << 28) | (left >> 4)) ^ *tmp___56;
#line 646
  right ^= (unsigned int )sbox7[work & 63U];
#line 646
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 646
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 646
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 646
  tmp___57 = keys;
#line 646
  keys ++;
#line 646
  work = right ^ *tmp___57;
#line 646
  left ^= (unsigned int )sbox8[work & 63U];
#line 646
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 646
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 646
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 646
  tmp___58 = keys;
#line 646
  keys ++;
#line 646
  work = ((right << 28) | (right >> 4)) ^ *tmp___58;
#line 646
  left ^= (unsigned int )sbox7[work & 63U];
#line 646
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 646
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 646
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 647
  tmp___59 = keys;
#line 647
  keys ++;
#line 647
  work = left ^ *tmp___59;
#line 647
  right ^= (unsigned int )sbox8[work & 63U];
#line 647
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 647
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 647
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 647
  tmp___60 = keys;
#line 647
  keys ++;
#line 647
  work = ((left << 28) | (left >> 4)) ^ *tmp___60;
#line 647
  right ^= (unsigned int )sbox7[work & 63U];
#line 647
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 647
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 647
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 647
  tmp___61 = keys;
#line 647
  keys ++;
#line 647
  work = right ^ *tmp___61;
#line 647
  left ^= (unsigned int )sbox8[work & 63U];
#line 647
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 647
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 647
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 647
  tmp___62 = keys;
#line 647
  keys ++;
#line 647
  work = ((right << 28) | (right >> 4)) ^ *tmp___62;
#line 647
  left ^= (unsigned int )sbox7[work & 63U];
#line 647
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 647
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 647
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 648
  tmp___63 = keys;
#line 648
  keys ++;
#line 648
  work = right ^ *tmp___63;
#line 648
  left ^= (unsigned int )sbox8[work & 63U];
#line 648
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 648
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 648
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 648
  tmp___64 = keys;
#line 648
  keys ++;
#line 648
  work = ((right << 28) | (right >> 4)) ^ *tmp___64;
#line 648
  left ^= (unsigned int )sbox7[work & 63U];
#line 648
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 648
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 648
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 648
  tmp___65 = keys;
#line 648
  keys ++;
#line 648
  work = left ^ *tmp___65;
#line 648
  right ^= (unsigned int )sbox8[work & 63U];
#line 648
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 648
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 648
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 648
  tmp___66 = keys;
#line 648
  keys ++;
#line 648
  work = ((left << 28) | (left >> 4)) ^ *tmp___66;
#line 648
  right ^= (unsigned int )sbox7[work & 63U];
#line 648
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 648
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 648
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 649
  tmp___67 = keys;
#line 649
  keys ++;
#line 649
  work = right ^ *tmp___67;
#line 649
  left ^= (unsigned int )sbox8[work & 63U];
#line 649
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 649
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 649
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 649
  tmp___68 = keys;
#line 649
  keys ++;
#line 649
  work = ((right << 28) | (right >> 4)) ^ *tmp___68;
#line 649
  left ^= (unsigned int )sbox7[work & 63U];
#line 649
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 649
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 649
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 649
  tmp___69 = keys;
#line 649
  keys ++;
#line 649
  work = left ^ *tmp___69;
#line 649
  right ^= (unsigned int )sbox8[work & 63U];
#line 649
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 649
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 649
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 649
  tmp___70 = keys;
#line 649
  keys ++;
#line 649
  work = ((left << 28) | (left >> 4)) ^ *tmp___70;
#line 649
  right ^= (unsigned int )sbox7[work & 63U];
#line 649
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 649
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 649
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 650
  tmp___71 = keys;
#line 650
  keys ++;
#line 650
  work = right ^ *tmp___71;
#line 650
  left ^= (unsigned int )sbox8[work & 63U];
#line 650
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 650
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 650
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 650
  tmp___72 = keys;
#line 650
  keys ++;
#line 650
  work = ((right << 28) | (right >> 4)) ^ *tmp___72;
#line 650
  left ^= (unsigned int )sbox7[work & 63U];
#line 650
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 650
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 650
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 650
  tmp___73 = keys;
#line 650
  keys ++;
#line 650
  work = left ^ *tmp___73;
#line 650
  right ^= (unsigned int )sbox8[work & 63U];
#line 650
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 650
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 650
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 650
  tmp___74 = keys;
#line 650
  keys ++;
#line 650
  work = ((left << 28) | (left >> 4)) ^ *tmp___74;
#line 650
  right ^= (unsigned int )sbox7[work & 63U];
#line 650
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 650
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 650
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 651
  tmp___75 = keys;
#line 651
  keys ++;
#line 651
  work = right ^ *tmp___75;
#line 651
  left ^= (unsigned int )sbox8[work & 63U];
#line 651
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 651
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 651
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 651
  tmp___76 = keys;
#line 651
  keys ++;
#line 651
  work = ((right << 28) | (right >> 4)) ^ *tmp___76;
#line 651
  left ^= (unsigned int )sbox7[work & 63U];
#line 651
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 651
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 651
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 651
  tmp___77 = keys;
#line 651
  keys ++;
#line 651
  work = left ^ *tmp___77;
#line 651
  right ^= (unsigned int )sbox8[work & 63U];
#line 651
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 651
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 651
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 651
  tmp___78 = keys;
#line 651
  keys ++;
#line 651
  work = ((left << 28) | (left >> 4)) ^ *tmp___78;
#line 651
  right ^= (unsigned int )sbox7[work & 63U];
#line 651
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 651
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 651
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 652
  tmp___79 = keys;
#line 652
  keys ++;
#line 652
  work = right ^ *tmp___79;
#line 652
  left ^= (unsigned int )sbox8[work & 63U];
#line 652
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 652
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 652
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 652
  tmp___80 = keys;
#line 652
  keys ++;
#line 652
  work = ((right << 28) | (right >> 4)) ^ *tmp___80;
#line 652
  left ^= (unsigned int )sbox7[work & 63U];
#line 652
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 652
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 652
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 652
  tmp___81 = keys;
#line 652
  keys ++;
#line 652
  work = left ^ *tmp___81;
#line 652
  right ^= (unsigned int )sbox8[work & 63U];
#line 652
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 652
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 652
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 652
  tmp___82 = keys;
#line 652
  keys ++;
#line 652
  work = ((left << 28) | (left >> 4)) ^ *tmp___82;
#line 652
  right ^= (unsigned int )sbox7[work & 63U];
#line 652
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 652
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 652
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 653
  tmp___83 = keys;
#line 653
  keys ++;
#line 653
  work = right ^ *tmp___83;
#line 653
  left ^= (unsigned int )sbox8[work & 63U];
#line 653
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 653
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 653
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 653
  tmp___84 = keys;
#line 653
  keys ++;
#line 653
  work = ((right << 28) | (right >> 4)) ^ *tmp___84;
#line 653
  left ^= (unsigned int )sbox7[work & 63U];
#line 653
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 653
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 653
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 653
  tmp___85 = keys;
#line 653
  keys ++;
#line 653
  work = left ^ *tmp___85;
#line 653
  right ^= (unsigned int )sbox8[work & 63U];
#line 653
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 653
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 653
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 653
  tmp___86 = keys;
#line 653
  keys ++;
#line 653
  work = ((left << 28) | (left >> 4)) ^ *tmp___86;
#line 653
  right ^= (unsigned int )sbox7[work & 63U];
#line 653
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 653
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 653
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 654
  tmp___87 = keys;
#line 654
  keys ++;
#line 654
  work = right ^ *tmp___87;
#line 654
  left ^= (unsigned int )sbox8[work & 63U];
#line 654
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 654
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 654
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 654
  tmp___88 = keys;
#line 654
  keys ++;
#line 654
  work = ((right << 28) | (right >> 4)) ^ *tmp___88;
#line 654
  left ^= (unsigned int )sbox7[work & 63U];
#line 654
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 654
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 654
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 654
  tmp___89 = keys;
#line 654
  keys ++;
#line 654
  work = left ^ *tmp___89;
#line 654
  right ^= (unsigned int )sbox8[work & 63U];
#line 654
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 654
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 654
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 654
  tmp___90 = keys;
#line 654
  keys ++;
#line 654
  work = ((left << 28) | (left >> 4)) ^ *tmp___90;
#line 654
  right ^= (unsigned int )sbox7[work & 63U];
#line 654
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 654
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 654
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 655
  tmp___91 = keys;
#line 655
  keys ++;
#line 655
  work = right ^ *tmp___91;
#line 655
  left ^= (unsigned int )sbox8[work & 63U];
#line 655
  left ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 655
  left ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 655
  left ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 655
  tmp___92 = keys;
#line 655
  keys ++;
#line 655
  work = ((right << 28) | (right >> 4)) ^ *tmp___92;
#line 655
  left ^= (unsigned int )sbox7[work & 63U];
#line 655
  left ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 655
  left ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 655
  left ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 655
  tmp___93 = keys;
#line 655
  keys ++;
#line 655
  work = left ^ *tmp___93;
#line 655
  right ^= (unsigned int )sbox8[work & 63U];
#line 655
  right ^= (unsigned int )sbox6[(work >> 8) & 63U];
#line 655
  right ^= (unsigned int )sbox4[(work >> 16) & 63U];
#line 655
  right ^= (unsigned int )sbox2[(work >> 24) & 63U];
#line 655
  tmp___94 = keys;
#line 655
  keys ++;
#line 655
  work = ((left << 28) | (left >> 4)) ^ *tmp___94;
#line 655
  right ^= (unsigned int )sbox7[work & 63U];
#line 655
  right ^= (unsigned int )sbox5[(work >> 8) & 63U];
#line 655
  right ^= (unsigned int )sbox3[(work >> 16) & 63U];
#line 655
  right ^= (unsigned int )sbox1[(work >> 24) & 63U];
#line 656
  right = (right << 31) | (right >> 1);
#line 656
  work = (right ^ left) & 2863311530U;
#line 656
  right ^= work;
#line 656
  left ^= work;
#line 656
  left = (left << 31) | (left >> 1);
#line 656
  work = ((left >> 8) ^ right) & 16711935U;
#line 656
  right ^= work;
#line 656
  left ^= work << 8;
#line 656
  work = ((left >> 2) ^ right) & 858993459U;
#line 656
  right ^= work;
#line 656
  left ^= work << 2;
#line 656
  work = ((right >> 16) ^ left) & 65535U;
#line 656
  left ^= work;
#line 656
  right ^= work << 16;
#line 656
  work = ((right >> 4) ^ left) & 252645135U;
#line 656
  left ^= work;
#line 656
  right ^= work << 4;
#line 657
  *(to + 0) = (unsigned char )((right >> 24) & 255U);
#line 657
  *(to + 1) = (unsigned char )((right >> 16) & 255U);
#line 657
  *(to + 2) = (unsigned char )((right >> 8) & 255U);
#line 657
  *(to + 3) = (unsigned char )(right & 255U);
#line 657
  *(to + 4) = (unsigned char )((left >> 24) & 255U);
#line 657
  *(to + 5) = (unsigned char )((left >> 16) & 255U);
#line 657
  *(to + 6) = (unsigned char )((left >> 8) & 255U);
#line 657
  *(to + 7) = (unsigned char )(left & 255U);
#line 658
  return;
}
}
#line 660 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/des.c"
_Bool gl_3des_makekey(gl_3des_ctx *ctx , char const   *key , size_t keylen ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
#line 663
  if (keylen != 24U) {
#line 664
    return ((_Bool)0);
  }
  {
#line 666
  gl_3des_set3keys(ctx, key, key + 8, key + 16);
#line 668
  tmp = gl_des_is_weak_key(key);
  }
#line 668
  if (tmp) {
#line 668
    tmp___2 = 0;
  } else {
    {
#line 668
    tmp___0 = gl_des_is_weak_key(key + 8);
    }
#line 668
    if (tmp___0) {
#line 668
      tmp___2 = 0;
    } else {
      {
#line 668
      tmp___1 = gl_des_is_weak_key(key + 16);
      }
#line 668
      if (tmp___1) {
#line 668
        tmp___2 = 0;
      } else {
#line 668
        tmp___2 = 1;
      }
    }
  }
#line 668
  return ((_Bool )tmp___2);
}
}
#line 49 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 138 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.h"
int c_tolower(int c ) ;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  } else
#line 36
  if (n == 0U) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
#line 44
    n --;
    }
#line 44
    if (n == 0U) {
#line 45
      goto while_break;
    } else
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 32
  p1 = (unsigned char const   *)s1;
#line 33
  p2 = (unsigned char const   *)s2;
#line 36
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 37
    return (0);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 41
    tmp = c_tolower((int )*p1);
#line 41
    c1 = (unsigned char )tmp;
#line 42
    tmp___0 = c_tolower((int )*p2);
#line 42
    c2 = (unsigned char )tmp___0;
    }
#line 44
    if ((int )c1 == 0) {
#line 45
      goto while_break;
    }
#line 47
    p1 ++;
#line 48
    p2 ++;
#line 39
    if (! ((int )c1 == (int )c2)) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return ((int )c1 - (int )c2);
}
}
#line 123 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.h"
_Bool c_isascii(int c ) ;
#line 125
_Bool c_isalnum(int c ) ;
#line 126
_Bool c_isalpha(int c ) ;
#line 127
_Bool c_isblank(int c ) ;
#line 128
_Bool c_iscntrl(int c ) ;
#line 129
_Bool c_isdigit(int c ) ;
#line 130
_Bool c_islower(int c ) ;
#line 131
_Bool c_isgraph(int c ) ;
#line 132
_Bool c_isprint(int c ) ;
#line 133
_Bool c_ispunct(int c ) ;
#line 134
_Bool c_isspace(int c ) ;
#line 135
_Bool c_isupper(int c ) ;
#line 136
_Bool c_isxdigit(int c ) ;
#line 139
int c_toupper(int c ) ;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 32
  if (c >= 0) {
#line 32
    if (c <= 127) {
#line 32
      tmp = 1;
    } else {
#line 32
      tmp = 0;
    }
  } else {
#line 32
    tmp = 0;
  }
#line 32
  return ((_Bool )tmp);
}
}
#line 35 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 41
  if (c >= 48) {
#line 41
    if (c <= 57) {
#line 41
      tmp = 1;
    } else {
#line 41
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 41
  if ((c & -33) >= 65) {
#line 41
    if ((c & -33) <= 90) {
#line 41
      tmp = 1;
    } else {
#line 41
      tmp = 0;
    }
  } else {
#line 41
    tmp = 0;
  }
#line 41
  return ((_Bool )tmp);
}
}
#line 70 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 75
  if ((c & -33) >= 65) {
#line 75
    if ((c & -33) <= 90) {
#line 75
      tmp = 1;
    } else {
#line 75
      tmp = 0;
    }
  } else {
#line 75
    tmp = 0;
  }
#line 75
  return ((_Bool )tmp);
}
}
#line 99 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 102
  if (c == 32) {
#line 102
    tmp = 1;
  } else
#line 102
  if (c == 9) {
#line 102
    tmp = 1;
  } else {
#line 102
    tmp = 0;
  }
#line 102
  return ((_Bool )tmp);
}
}
#line 105 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 109
  if ((c & -32) == 0) {
#line 109
    tmp = 1;
  } else
#line 109
  if (c == 127) {
#line 109
    tmp = 1;
  } else {
#line 109
    tmp = 0;
  }
#line 109
  return ((_Bool )tmp);
}
}
#line 139 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 143
  if (c >= 48) {
#line 143
    if (c <= 57) {
#line 143
      tmp = 1;
    } else {
#line 143
      tmp = 0;
    }
  } else {
#line 143
    tmp = 0;
  }
#line 143
  return ((_Bool )tmp);
}
}
#line 156 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 160
  if (c >= 97) {
#line 160
    if (c <= 122) {
#line 160
      tmp = 1;
    } else {
#line 160
      tmp = 0;
    }
  } else {
#line 160
    tmp = 0;
  }
#line 160
  return ((_Bool )tmp);
}
}
#line 176 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 180
  if (c >= 33) {
#line 180
    if (c <= 126) {
#line 180
      tmp = 1;
    } else {
#line 180
      tmp = 0;
    }
  } else {
#line 180
    tmp = 0;
  }
#line 180
  return ((_Bool )tmp);
}
}
#line 210 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 214
  if (c >= 32) {
#line 214
    if (c <= 126) {
#line 214
      tmp = 1;
    } else {
#line 214
      tmp = 0;
    }
  } else {
#line 214
    tmp = 0;
  }
#line 214
  return ((_Bool )tmp);
}
}
#line 244 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 248
  if (c >= 33) {
#line 248
    if (c <= 126) {
#line 248
      if (c >= 48) {
#line 248
        if (c <= 57) {
#line 248
          tmp = 0;
        } else {
#line 248
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 248
      if ((c & -33) >= 65) {
#line 248
        if ((c & -33) <= 90) {
#line 248
          tmp = 0;
        } else {
#line 248
          tmp = 1;
        }
      } else {
#line 248
        tmp = 1;
      }
    } else {
#line 248
      tmp = 0;
    }
  } else {
#line 248
    tmp = 0;
  }
#line 248
  return ((_Bool )tmp);
}
}
#line 268 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 271
  if (c == 32) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 9) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 10) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 11) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 12) {
#line 271
    tmp = 1;
  } else
#line 271
  if (c == 13) {
#line 271
    tmp = 1;
  } else {
#line 271
    tmp = 0;
  }
#line 271
  return ((_Bool )tmp);
}
}
#line 275 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 279
  if (c >= 65) {
#line 279
    if (c <= 90) {
#line 279
      tmp = 1;
    } else {
#line 279
      tmp = 0;
    }
  } else {
#line 279
    tmp = 0;
  }
#line 279
  return ((_Bool )tmp);
}
}
#line 295 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 301
  if (c >= 48) {
#line 301
    if (c <= 57) {
#line 301
      tmp = 1;
    } else {
#line 301
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 301
  if ((c & -33) >= 65) {
#line 301
    if ((c & -33) <= 70) {
#line 301
      tmp = 1;
    } else {
#line 301
      tmp = 0;
    }
  } else {
#line 301
    tmp = 0;
  }
#line 301
  return ((_Bool )tmp);
}
}
#line 322 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 326
  if (c >= 65) {
#line 326
    if (c <= 90) {
#line 326
      tmp = (c - 65) + 97;
    } else {
#line 326
      tmp = c;
    }
  } else {
#line 326
    tmp = c;
  }
#line 326
  return (tmp);
}
}
#line 361 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 365
  if (c >= 97) {
#line 365
    if (c <= 122) {
#line 365
      tmp = (c - 97) + 65;
    } else {
#line 365
      tmp = c;
    }
  } else {
#line 365
    tmp = c;
  }
#line 365
  return (tmp);
}
}
#line 74 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/vasnprintf.h"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) ;
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/gnu/asnprintf.c"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 33
  __builtin_va_start(args, format);
#line 34
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 35
  __builtin_va_end(args);
  }
#line 36
  return (result);
}
}
#line 45 "../include/xdico.h"
char *make_full_file_name(char const   *dir , char const   *file ) ;
#line 46
void trimnl(char *buf___1 , size_t len ) ;
#line 48
dico_list_t xdico_list_create(void) ;
#line 49
dico_iterator_t xdico_list_iterator(dico_list_t list ) ;
#line 50
void xdico_list_append(struct dico_list *list , void *data ) ;
#line 51
void xdico_list_prepend(struct dico_list *list , void *data ) ;
#line 52
dico_assoc_list_t xdico_assoc_create(int flags ) ;
#line 53
void xdico_assoc_append(dico_assoc_list_t assoc , char const   *key , char const   *value ) ;
#line 55
int xdico_assoc_add(dico_assoc_list_t assoc , char const   *key , char const   *value ,
                    size_t count , int replace ) ;
#line 57
char *xdico_assign_string(char **dest , char *str ) ;
#line 59
char *xdico_sasl_mech_to_capa(char *mech ) ;
#line 60
int xdico_sasl_capa_match_p(char const   *mech , char const   *capa ) ;
#line 62
int dicod_free_item(void *item , void *data  __attribute__((__unused__)) ) ;
#line 26 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
void trimnl(char *buf___1 , size_t len ) 
{ 


  {
#line 29
  if (len > 1U) {
#line 29
    len --;
#line 29
    if ((int )*(buf___1 + len) == 10) {
#line 30
      *(buf___1 + len) = (char)0;
#line 31
      if (len > 1U) {
#line 31
        len --;
#line 31
        if ((int )*(buf___1 + len) == 13) {
#line 32
          *(buf___1 + len) = (char)0;
        }
      }
    }
  }
#line 34
  return;
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
char *make_full_file_name(char const   *dir , char const   *file ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 42
  tmp = dico_full_file_name(dir, file);
#line 42
  s = tmp;
  }
#line 43
  if (! s) {
    {
#line 44
    xalloc_die();
    }
  }
#line 45
  return (s);
}
}
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
dico_list_t xdico_list_create(void) 
{ 
  dico_list_t p ;
  dico_list_t tmp ;

  {
  {
#line 51
  tmp = dico_list_create();
#line 51
  p = tmp;
  }
#line 52
  if (! p) {
    {
#line 53
    xalloc_die();
    }
  }
#line 54
  return (p);
}
}
#line 57 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
dico_iterator_t xdico_list_iterator(dico_list_t list ) 
{ 
  dico_iterator_t p ;
  dico_iterator_t tmp ;
  int *tmp___0 ;

  {
  {
#line 60
  tmp = dico_list_iterator(list);
#line 60
  p = tmp;
  }
#line 61
  if (! p) {
    {
#line 61
    tmp___0 = __errno_location();
    }
#line 61
    if (*tmp___0 == 12) {
      {
#line 62
      xalloc_die();
      }
    }
  }
#line 63
  return (p);
}
}
#line 66 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
void xdico_list_append(struct dico_list *list , void *data ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 69
  tmp = dico_list_append(list, data);
  }
#line 69
  if (tmp) {
    {
#line 69
    tmp___0 = __errno_location();
    }
#line 69
    if (*tmp___0 == 12) {
      {
#line 70
      xalloc_die();
      }
    }
  }
#line 71
  return;
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
void xdico_list_prepend(struct dico_list *list , void *data ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 76
  tmp = dico_list_prepend(list, data);
  }
#line 76
  if (tmp) {
    {
#line 76
    tmp___0 = __errno_location();
    }
#line 76
    if (*tmp___0 == 12) {
      {
#line 77
      xalloc_die();
      }
    }
  }
#line 78
  return;
}
}
#line 80 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
dico_assoc_list_t xdico_assoc_create(int flags ) 
{ 
  dico_assoc_list_t p ;
  dico_assoc_list_t tmp ;

  {
  {
#line 83
  tmp = dico_assoc_create(flags);
#line 83
  p = tmp;
  }
#line 84
  if (! p) {
    {
#line 85
    xalloc_die();
    }
  }
#line 86
  return (p);
}
}
#line 89 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
void xdico_assoc_append(dico_assoc_list_t assoc , char const   *key , char const   *value ) 
{ 
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 92
  tmp = dico_assoc_append(assoc, key, value);
  }
#line 92
  if (tmp) {
    {
#line 92
    tmp___0 = __errno_location();
    }
#line 92
    if (*tmp___0 == 12) {
      {
#line 93
      xalloc_die();
      }
    }
  }
#line 94
  return;
}
}
#line 96 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
int xdico_assoc_add(dico_assoc_list_t assoc , char const   *key , char const   *value ,
                    size_t count , int replace ) 
{ 
  int rc ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 100
  tmp = dico_assoc_add(assoc, key, value, count, replace);
#line 100
  rc = tmp;
  }
#line 101
  if (rc) {
    {
#line 101
    tmp___0 = __errno_location();
    }
#line 101
    if (*tmp___0 == 12) {
      {
#line 102
      xalloc_die();
      }
    }
  }
#line 103
  return (rc);
}
}
#line 106 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
char *xdico_assign_string(char **dest , char *str ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 109
  if (*dest) {
    {
#line 110
    free((void *)*dest);
    }
  }
#line 111
  if (str) {
    {
#line 111
    tmp___0 = xstrdup((char const   *)str);
#line 111
    tmp = tmp___0;
    }
  } else {
#line 111
    tmp = (char *)((void *)0);
  }
#line 111
  *dest = tmp;
#line 111
  return (tmp);
}
}
#line 114 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
static char *mech_to_capa_table[4][2]  = { {        (char *)"EXTERNAL",        (char *)"external"}, 
   {        (char *)"SKEY",        (char *)"skey"}, 
   {        (char *)"GSSAPI",        (char *)"gssapi"}, 
   {        (char *)"KERBEROS_V4",        (char *)"kerberos_v4"}};
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
char *xdico_sasl_mech_to_capa(char *mech ) 
{ 
  int i ;
  size_t len ;
  char *rets ;
  char *p ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 128
  i = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! ((unsigned long )i < sizeof(mech_to_capa_table) / sizeof(mech_to_capa_table[0]))) {
#line 128
      goto while_break;
    }
    {
#line 129
    tmp___0 = strcmp((char const   *)mech_to_capa_table[i][0], (char const   *)mech);
    }
#line 129
    if (tmp___0 == 0) {
      {
#line 130
      tmp = xstrdup((char const   *)mech_to_capa_table[i][1]);
      }
#line 130
      return (tmp);
    }
#line 128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 132
  tmp___1 = strlen((char const   *)mech);
#line 132
  len = tmp___1 + 1U;
#line 133
  tmp___2 = xmalloc(len + 1U);
#line 133
  p = (char *)tmp___2;
#line 133
  rets = p;
#line 134
  tmp___3 = p;
#line 134
  p ++;
#line 134
  *tmp___3 = (char )'x';
  }
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! *mech) {
#line 135
      goto while_break___0;
    }
    {
#line 136
    tmp___4 = p;
#line 136
    p ++;
#line 136
    tmp___5 = tolower((int )*mech);
#line 136
    *tmp___4 = (char )tmp___5;
#line 135
    mech ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 137
  *p = (char)0;
#line 138
  return (rets);
}
}
#line 141 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
int xdico_sasl_capa_match_p(char const   *mech , char const   *capa ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! ((unsigned long )i < sizeof(mech_to_capa_table) / sizeof(mech_to_capa_table[0]))) {
#line 146
      goto while_break;
    }
    {
#line 147
    tmp___0 = c_strcasecmp((char const   *)mech_to_capa_table[i][0], mech);
    }
#line 147
    if (tmp___0 == 0) {
      {
#line 148
      tmp = c_strcasecmp((char const   *)mech_to_capa_table[i][1], capa);
      }
#line 148
      return (tmp == 0);
    }
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  if ((int const   )*capa == 120) {
    {
#line 151
    tmp___1 = c_strcasecmp(mech, capa + 1);
    }
#line 151
    return (tmp___1 == 0);
  }
#line 152
  return (0);
}
}
#line 156 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xutil.c"
int dicod_free_item(void *item , void *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 159
  free(item);
  }
#line 160
  return (0);
}
}
#line 376 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 83 "../include/xdico.h"
int stream_writez(dico_stream_t str , char *buf___1 ) ;
#line 84
int stream_printf(dico_stream_t str , char const   *fmt  , ...) ;
#line 85
void stream_write_multiline(dico_stream_t str , char const   *text ) ;
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xstream.c"
int stream_writez(dico_stream_t str , char *buf___1 ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 28
  tmp = strlen((char const   *)buf___1);
#line 28
  tmp___0 = dico_stream_write(str, (void const   *)buf___1, tmp);
  }
#line 28
  return (tmp___0);
}
}
#line 31 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xstream.c"
int stream_printf(dico_stream_t str , char const   *fmt  , ...) 
{ 
  int len ;
  char *buf___1 ;
  va_list ap ;
  char *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 38
  __builtin_va_start(ap, fmt);
#line 39
  len = vasprintf((char **/* __restrict  */)(& buf___1), (char const   */* __restrict  */)fmt,
                  ap);
#line 40
  __builtin_va_end(ap);
  }
#line 41
  if (len < 0) {
    {
#line 42
    tmp = dgettext("dico", "not enough memory while formatting reply message");
#line 42
    dico_log(5, 0, (char const   *)tmp);
#line 44
    exit(1);
    }
  }
  {
#line 46
  len = dico_stream_write(str, (void const   *)buf___1, (size_t )len);
#line 47
  free((void *)buf___1);
  }
#line 48
  return (len);
}
}
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xstream.c"
void stream_write_multiline(dico_stream_t str , char const   *text ) 
{ 
  struct utf8_iterator itr ;
  size_t len ;
  int tmp ;

  {
  {
#line 55
  len = (size_t )0;
#line 57
  utf8_iter_first(& itr, (unsigned char *)text);
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 57
    tmp = utf8_iter_end_p(& itr);
    }
#line 57
    if (tmp) {
#line 57
      goto while_break;
    }
#line 60
    if (itr.curwidth == 1U) {
#line 60
      if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 60
        if ((int )*(itr.curptr) == 10) {
          {
#line 61
          dico_stream_writeln(str, (char const   *)(itr.curptr - len), len);
#line 62
          len = (size_t )0;
          }
        } else {
#line 64
          len += itr.curwidth;
        }
      } else {
#line 64
        len += itr.curwidth;
      }
    } else {
#line 64
      len += itr.curwidth;
    }
    {
#line 57
    utf8_iter_next(& itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (len) {
    {
#line 67
    dico_stream_writeln(str, (char const   *)(itr.curptr - len), len);
    }
  }
#line 68
  return;
}
}
#line 78 "../include/xdico.h"
dico_stream_t xdico_transcript_stream_create(dico_stream_t transport , dico_stream_t logstr ,
                                             char const   **prefix___0 ) ;
#line 43 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static void print_transcript(struct transcript_stream *str , int flag , char const   *buf___1 ,
                             size_t size ) 
{ 
  char const   *p ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;

  {
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! size) {
#line 47
      goto while_break;
    }
#line 51
    if (str->flags & flag) {
      {
#line 52
      tmp = strlen((char const   *)str->prefix[flag - 1]);
#line 52
      dico_stream_write(str->logstr, (void const   *)str->prefix[flag - 1], tmp);
#line 55
      str->flags &= ~ flag;
      }
    }
    {
#line 57
    tmp___0 = memchr((void const   *)buf___1, '\n', size);
#line 57
    p = (char const   *)tmp___0;
    }
#line 58
    if (p) {
#line 59
      len = (size_t )(p - buf___1);
#line 60
      if ((unsigned long )p > (unsigned long )buf___1) {
#line 60
        if ((int const   )*(p + -1) == 13) {
#line 61
          len --;
        }
      }
      {
#line 62
      dico_stream_write(str->logstr, (void const   *)buf___1, len);
#line 63
      dico_stream_write(str->logstr, (void const   *)"\n", (size_t )1);
#line 64
      str->flags |= flag;
#line 66
      len = (size_t )((p - buf___1) + 1L);
#line 67
      buf___1 = p + 1;
#line 68
      size -= len;
      }
    } else {
      {
#line 70
      dico_stream_write(str->logstr, (void const   *)buf___1, size);
      }
#line 71
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_read(void *data , char *buf___1 , size_t size , size_t *pret ) 
{ 
  struct transcript_stream *p ;
  size_t nbytes ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 79
  p = (struct transcript_stream *)data;
#line 82
  tmp___0 = dico_stream_read(p->transport, (void *)buf___1, size, & nbytes);
  }
#line 82
  if (tmp___0 == 0) {
    {
#line 83
    print_transcript(p, 1, (char const   *)buf___1, nbytes);
    }
#line 84
    if (pret) {
#line 85
      *pret = nbytes;
    }
  } else {
    {
#line 87
    tmp = dico_stream_last_error(p->transport);
    }
#line 87
    return (tmp);
  }
#line 88
  return (0);
}
}
#line 91 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct transcript_stream *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 94
  p = (struct transcript_stream *)data;
#line 95
  tmp___0 = dico_stream_write(p->transport, (void const   *)buf___1, size);
  }
#line 95
  if (tmp___0 == 0) {
    {
#line 96
    print_transcript(p, 2, buf___1, size);
    }
#line 97
    if (pret) {
#line 98
      *pret = size;
    }
  } else {
    {
#line 100
    tmp = dico_stream_last_error(p->transport);
    }
#line 100
    return (tmp);
  }
#line 101
  return (0);
}
}
#line 104 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_flush(void *data ) 
{ 
  struct transcript_stream *p ;
  int tmp ;

  {
#line 107
  p = (struct transcript_stream *)data;
#line 108
  if (! p->transport) {
#line 109
    return (0);
  }
  {
#line 110
  tmp = dico_stream_flush(p->transport);
  }
#line 110
  return (tmp);
}
}
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_close(void *data ) 
{ 
  struct transcript_stream *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 116
  p = (struct transcript_stream *)data;
#line 117
  tmp = dico_stream_close(p->logstr);
  }
#line 117
  return (tmp);
  {
#line 118
  tmp___0 = dico_stream_close(p->transport);
  }
#line 118
  return (tmp___0);
}
}
#line 122 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_destroy(void *data ) 
{ 
  struct transcript_stream *p ;

  {
  {
#line 125
  p = (struct transcript_stream *)data;
#line 126
  free((void *)p->prefix[0]);
#line 127
  free((void *)p->prefix[1]);
#line 128
  dico_stream_destroy(& p->transport);
#line 129
  dico_stream_destroy(& p->logstr);
#line 130
  free((void *)p);
  }
#line 131
  return (0);
}
}
#line 134 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static char const   *transcript_strerror(void *data , int rc ) 
{ 
  struct transcript_stream *p ;
  char const   *tmp ;

  {
  {
#line 137
  p = (struct transcript_stream *)data;
#line 138
  tmp = dico_stream_strerror(p->transport, rc);
  }
#line 138
  return (tmp);
}
}
#line 141 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
static int transcript_ioctl(void *data , int code___0 , void *call_data ) 
{ 
  struct transcript_stream *p ;
  int *tmp ;

  {
#line 144
  p = (struct transcript_stream *)data;
  {
#line 146
  if (code___0 == 0) {
#line 146
    goto case_0;
  }
#line 150
  if (code___0 == 1) {
#line 150
    goto case_1;
  }
#line 154
  goto switch_default;
  case_0: /* CIL Label */ 
#line 147
  *((dico_stream_t *)call_data) = p->transport;
#line 148
  goto switch_break;
  case_1: /* CIL Label */ 
#line 151
  p->transport = (dico_stream_t )call_data;
#line 152
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 155
  tmp = __errno_location();
#line 155
  *tmp = 22;
  }
#line 156
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 158
  return (0);
}
}
#line 161 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
char const   *default_prefix[2]  = {      "C: ",      "S: "};
#line 165 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xscript.c"
dico_stream_t xdico_transcript_stream_create(dico_stream_t transport , dico_stream_t logstr ,
                                             char const   **prefix___0 ) 
{ 
  struct transcript_stream *p ;
  void *tmp ;
  dico_stream_t stream ;
  int rc ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 169
  tmp = xmalloc((size_t )sizeof(*p));
#line 169
  p = (struct transcript_stream *)tmp;
#line 171
  tmp___0 = dico_stream_create(& stream, 3, (void *)p);
#line 171
  rc = tmp___0;
  }
#line 173
  if (rc) {
    {
#line 174
    xalloc_die();
    }
  }
#line 175
  p->flags = 3;
#line 176
  if (prefix___0) {
#line 177
    if (*(prefix___0 + 0)) {
#line 177
      tmp___1 = *(prefix___0 + 0);
    } else {
#line 177
      tmp___1 = default_prefix[0];
    }
    {
#line 177
    p->prefix[0] = xstrdup(tmp___1);
    }
#line 178
    if (*(prefix___0 + 1)) {
#line 178
      tmp___2 = *(prefix___0 + 1);
    } else {
#line 178
      tmp___2 = default_prefix[1];
    }
    {
#line 178
    p->prefix[1] = xstrdup(tmp___2);
    }
  } else {
    {
#line 180
    p->prefix[0] = xstrdup(default_prefix[0]);
#line 181
    p->prefix[1] = xstrdup(default_prefix[1]);
    }
  }
  {
#line 183
  p->transport = transport;
#line 184
  p->logstr = logstr;
#line 186
  dico_stream_set_read(stream, & transcript_read);
#line 187
  dico_stream_set_write(stream, & transcript_write);
#line 188
  dico_stream_set_flush(stream, & transcript_flush);
#line 189
  dico_stream_set_close(stream, & transcript_close);
#line 190
  dico_stream_set_destroy(stream, & transcript_destroy);
#line 191
  dico_stream_set_ioctl(stream, & transcript_ioctl);
#line 192
  dico_stream_set_error_string(stream, & transcript_strerror);
#line 193
  dico_stream_set_buffer(stream, (enum dico_buffer_type )1, (size_t )1024);
  }
#line 195
  return (stream);
}
}
#line 143 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 101 "../include/xdico.h"
char *xdico_local_hostname(void) ;
#line 28 "/home/wslee/benchmarks/textformat/dico-2.0/lib/xhostname.c"
char *xdico_local_hostname(void) 
{ 
  struct hostent *hp ;
  char *hostpart ;
  char *tmp ;
  char *ret ;
  char *domainpart ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 32
  tmp = xgethostname();
#line 32
  hostpart = tmp;
#line 35
  hp = gethostbyname((char const   *)hostpart);
  }
#line 36
  if (hp) {
    {
#line 37
    ret = xstrdup((char const   *)hp->h_name);
    }
  } else {
    {
#line 39
    tmp___0 = xgetdomainname();
#line 39
    domainpart = tmp___0;
    }
#line 41
    if (domainpart) {
#line 41
      if (*(domainpart + 0)) {
        {
#line 41
        tmp___4 = strcmp((char const   *)domainpart, "(none)");
        }
#line 41
        if (tmp___4) {
          {
#line 42
          tmp___1 = strlen((char const   *)hostpart);
#line 42
          tmp___2 = strlen((char const   *)domainpart);
#line 42
          tmp___3 = xmalloc(((tmp___1 + 1U) + tmp___2) + 1U);
#line 42
          ret = (char *)tmp___3;
#line 44
          strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)hostpart);
#line 45
          strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)".");
#line 46
          strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)domainpart);
#line 47
          free((void *)hostpart);
          }
        } else {
#line 49
          ret = hostpart;
        }
      } else {
#line 49
        ret = hostpart;
      }
    } else {
#line 49
      ret = hostpart;
    }
    {
#line 50
    free((void *)domainpart);
    }
  }
#line 52
  return (ret);
}
}
#line 692 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 695
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 701
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 717
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 722
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 734
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 744
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 41 "../include/xdico.h"
int switch_to_privs(uid_t uid , gid_t gid , dico_list_t retain_groups ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/lib/userprivs.c"
int switch_to_privs(uid_t uid , gid_t gid , dico_list_t retain_groups ) 
{ 
  int rc ;
  gid_t *emptygidset ;
  size_t size ;
  size_t j ;
  dico_iterator_t itr ;
  void *gp ;
  char *tmp ;
  void *tmp___0 ;
  __gid_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  __uid_t tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  __gid_t tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  __gid_t tmp___14 ;
  uid_t euid ;
  char *tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int *tmp___22 ;
  __uid_t tmp___23 ;
  int tmp___24 ;
  __uid_t tmp___25 ;
  __uid_t tmp___26 ;
  __uid_t tmp___27 ;
  __uid_t tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
  {
#line 33
  rc = 0;
#line 35
  size = (size_t )1;
#line 35
  j = (size_t )1;
#line 39
  _dico_libi18n_init();
  }
#line 41
  if (uid == 0U) {
    {
#line 42
    tmp = dgettext("dico", "Refusing to run as root");
#line 42
    dico_log(4, 0, (char const   *)tmp);
    }
#line 43
    return (1);
  }
  {
#line 47
  size = dico_list_count(retain_groups);
#line 48
  size ++;
#line 49
  tmp___0 = xcalloc(size, (size_t )sizeof(*(emptygidset + 0)));
#line 49
  emptygidset = (gid_t *)tmp___0;
  }
#line 50
  if (gid) {
#line 50
    *(emptygidset + 0) = gid;
  } else {
    {
#line 50
    tmp___1 = getegid();
#line 50
    *(emptygidset + 0) = tmp___1;
    }
  }
  {
#line 52
  itr = dico_list_iterator(retain_groups);
#line 53
  gp = dico_iterator_first(itr);
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! gp) {
#line 53
      goto while_break;
    }
    {
#line 55
    tmp___2 = j;
#line 55
    j ++;
#line 55
    *(emptygidset + tmp___2) = (gid_t )gp;
#line 53
    gp = dico_iterator_next(itr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  dico_iterator_destroy(& itr);
#line 59
  tmp___5 = geteuid();
  }
#line 59
  if (tmp___5 == 0U) {
    {
#line 59
    tmp___6 = setgroups(j, (__gid_t const   *)emptygidset);
    }
#line 59
    if (tmp___6) {
      {
#line 60
      tmp___3 = dgettext("dico", "setgroups(1, %lu) failed");
#line 60
      tmp___4 = __errno_location();
#line 60
      dico_log(4, *tmp___4, (char const   *)tmp___3, (unsigned long )*(emptygidset + 0));
#line 62
      rc = 1;
      }
    }
  }
  {
#line 64
  free((void *)emptygidset);
#line 70
  rc = setegid(gid);
  }
#line 70
  if (rc < 0) {
    {
#line 71
    tmp___7 = dgettext("dico", "setegid(%lu) failed");
#line 71
    tmp___8 = __errno_location();
#line 71
    dico_log(4, *tmp___8, (char const   *)tmp___7, (unsigned long )gid);
    }
  }
#line 85
  if (rc == 0) {
#line 85
    if (gid != 0U) {
      {
#line 86
      rc = setgid(gid);
      }
#line 86
      if (rc < 0) {
        {
#line 86
        tmp___11 = getegid();
        }
#line 86
        if (tmp___11 != gid) {
          {
#line 87
          tmp___9 = dgettext("dico", "setgid(%lu) failed");
#line 87
          tmp___10 = __errno_location();
#line 87
          dico_log(4, *tmp___10, (char const   *)tmp___9, (unsigned long )gid);
          }
        }
      }
#line 89
      if (rc == 0) {
        {
#line 89
        tmp___14 = getegid();
        }
#line 89
        if (tmp___14 != gid) {
          {
#line 90
          tmp___12 = dgettext("dico", "Cannot set effective gid to %lu");
#line 90
          tmp___13 = __errno_location();
#line 90
          dico_log(4, *tmp___13, (char const   *)tmp___12, (unsigned long )gid);
#line 92
          rc = 1;
          }
        }
      }
    }
  }
#line 97
  if (rc == 0) {
#line 97
    if (uid != 0U) {
      {
#line 100
      tmp___24 = setuid(uid);
      }
#line 100
      if (tmp___24) {
#line 100
        goto _L___0;
      } else {
        {
#line 100
        tmp___25 = geteuid();
        }
#line 100
        if (tmp___25 != uid) {
#line 100
          goto _L___0;
        } else {
          {
#line 100
          tmp___26 = getuid();
          }
#line 100
          if (tmp___26 != uid) {
            {
#line 100
            tmp___27 = geteuid();
            }
#line 100
            if (tmp___27 == 0U) {
#line 100
              goto _L___0;
            } else {
              {
#line 100
              tmp___28 = getuid();
              }
#line 100
              if (tmp___28 == 0U) {
                _L___0: /* CIL Label */ 
                {
#line 106
                tmp___23 = geteuid();
                }
#line 106
                if (tmp___23 != uid) {
                  {
#line 107
                  tmp___17 = setreuid(uid, (__uid_t )-1);
                  }
#line 107
                  if (tmp___17 < 0) {
                    {
#line 108
                    tmp___15 = dgettext("dico", "setreuid(%lu,-1) failed");
#line 108
                    tmp___16 = __errno_location();
#line 108
                    dico_log(4, *tmp___16, (char const   *)tmp___15, (unsigned long )uid);
#line 110
                    rc = 1;
                    }
                  }
                  {
#line 112
                  tmp___20 = setuid(uid);
                  }
#line 112
                  if (tmp___20 < 0) {
                    {
#line 113
                    tmp___18 = dgettext("dico", "second setuid(%lu) failed");
#line 113
                    tmp___19 = __errno_location();
#line 113
                    dico_log(4, *tmp___19, (char const   *)tmp___18, (unsigned long )uid);
#line 115
                    rc = 1;
                    }
                  }
                } else {
                  {
#line 120
                  tmp___21 = dgettext("dico", "setuid(%lu) failed");
#line 120
                  tmp___22 = __errno_location();
#line 120
                  dico_log(4, *tmp___22, (char const   *)tmp___21, (unsigned long )uid);
#line 122
                  rc = 1;
                  }
                }
              }
            }
          }
        }
      }
      {
#line 126
      euid = geteuid();
      }
#line 127
      if (uid != 0U) {
        {
#line 127
        tmp___32 = setuid((__uid_t )0);
        }
#line 127
        if (tmp___32 == 0) {
          {
#line 128
          tmp___29 = dgettext("dico", "seteuid(0) succeeded when it should not");
#line 128
          dico_log(4, 0, (char const   *)tmp___29);
#line 129
          rc = 1;
          }
        } else {
#line 127
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 130
      if (uid != euid) {
        {
#line 130
        tmp___31 = setuid(euid);
        }
#line 130
        if (tmp___31 == 0) {
          {
#line 131
          tmp___30 = dgettext("dico", "Cannot drop non-root setuid privileges");
#line 131
          dico_log(4, 0, (char const   *)tmp___30);
#line 132
          rc = 1;
          }
        }
      }
    }
  }
#line 137
  return (rc);
}
}
#line 90 "../include/xdico.h"
int xdico_unquote_char(int c ) ;
#line 91
int xdico_quote_char(int c ) ;
#line 92
xdico_input_t xdico_tokenize_begin(void) ;
#line 93
void xdico_tokenize_end(xdico_input_t *pin ) ;
#line 94
int xdico_tokenize_input(xdico_input_t in , char *str , int *pargc , char ***pargv ) ;
#line 182 "../gnu/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 183
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 195
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
static char quote_transtab___0[17]  = 
#line 36 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
  {      (char )'\\',      (char )'\\',      (char )'\"',      (char )'\"', 
        (char )'a',      (char )'\a',      (char )'b',      (char )'\b', 
        (char )'f',      (char )'\f',      (char )'n',      (char )'\n', 
        (char )'r',      (char )'\r',      (char )'t',      (char )'\t', 
        (char )'\000'};
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
int xdico_unquote_char(int c ) 
{ 
  char *p ;

  {
#line 43
  p = quote_transtab___0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! *p) {
#line 43
      goto while_break;
    }
#line 44
    if ((int )*p == c) {
#line 45
      return ((int )*(p + 1));
    }
#line 43
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (0);
}
}
#line 50 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
int xdico_quote_char(int c ) 
{ 
  char *p ;

  {
#line 55
  p = quote_transtab___0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! *p) {
#line 55
      goto while_break;
    }
#line 56
    if ((int )*(p + 1) == c) {
#line 57
      return ((int )*(p + 0));
    }
#line 55
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return (0);
}
}
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
xdico_input_t xdico_tokenize_begin(void) 
{ 
  void *tmp ;

  {
  {
#line 65
  tmp = xzalloc((size_t )sizeof(struct xdico_input ));
  }
#line 65
  return ((xdico_input_t )tmp);
}
}
#line 68 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
void xdico_tokenize_end(xdico_input_t *pin ) 
{ 
  xdico_input_t in ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 71
  in = *pin;
#line 72
  __o = & in->stk;
#line 72
  __obj = (void *)0;
#line 72
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 72
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 72
      tmp = (char *)__obj;
#line 72
      __o->object_base = tmp;
#line 72
      __o->next_free = tmp;
    } else {
      {
#line 72
      obstack_free(__o, __obj);
      }
    }
  } else {
    {
#line 72
    obstack_free(__o, __obj);
    }
  }
  {
#line 73
  free((void *)in);
#line 74
  *pin = (xdico_input_t )((void *)0);
  }
#line 75
  return;
}
}
#line 77 "/home/wslee/benchmarks/textformat/dico-2.0/lib/tokenize.c"
int xdico_tokenize_input(xdico_input_t in , char *str , int *pargc , char ***pargv ) 
{ 
  struct utf8_iterator itr ;
  int i ;
  int argc ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  int quote___0 ;
  int tmp___0 ;
  int tmp___1 ;
  struct obstack *__o___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct obstack *__o___1 ;
  char *tmp___4 ;
  struct obstack *__o___2 ;
  int __len ;
  struct obstack *__o___3 ;
  int __len___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct obstack *__o___4 ;
  char *tmp___8 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct obstack *__h ;
  struct obstack *__o___5 ;
  int __len___1 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;

  {
#line 81
  argc = 0;
#line 83
  if (! in->rootptr) {
    {
#line 84
    _obstack_begin(& in->stk, 0, 0, (void *(*)(long  ))(& malloc), & free);
    }
  } else {
#line 86
    __o = & in->stk;
#line 86
    __obj = (void *)in->rootptr;
#line 86
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 86
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 86
        tmp = (char *)__obj;
#line 86
        __o->object_base = tmp;
#line 86
        __o->next_free = tmp;
      } else {
        {
#line 86
        obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 86
      obstack_free(__o, __obj);
      }
    }
  }
  {
#line 88
  utf8_iter_first(& itr, (unsigned char *)str);
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 93
      tmp___0 = utf8_iter_end_p(& itr);
      }
#line 93
      if (tmp___0) {
#line 93
        goto while_break___0;
      } else
#line 93
      if (itr.curwidth == 1U) {
#line 93
        if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 93
          if (! ((int )*(itr.curptr) == 32)) {
#line 93
            if (! ((int )*(itr.curptr) == 9)) {
#line 93
              goto while_break___0;
            }
          }
        } else {
#line 93
          goto while_break___0;
        }
      } else {
#line 93
        goto while_break___0;
      }
      {
#line 93
      utf8_iter_next(& itr);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 98
    tmp___1 = utf8_iter_end_p(& itr);
    }
#line 98
    if (tmp___1) {
#line 99
      goto while_break;
    }
#line 101
    if (itr.curwidth == 1U) {
#line 101
      if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 101
        if ((int )*(itr.curptr) == 34) {
          {
#line 102
          quote___0 = (int )*(itr.curptr);
#line 103
          utf8_iter_next(& itr);
          }
        } else
#line 101
        if ((int )*(itr.curptr) == 39) {
          {
#line 102
          quote___0 = (int )*(itr.curptr);
#line 103
          utf8_iter_next(& itr);
          }
        } else {
#line 105
          quote___0 = 0;
        }
      } else {
#line 105
        quote___0 = 0;
      }
    } else {
#line 105
      quote___0 = 0;
    }
    {
#line 107
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 107
      tmp___5 = utf8_iter_end_p(& itr);
      }
#line 107
      if (tmp___5) {
#line 107
        goto while_break___1;
      } else
#line 107
      if (itr.curwidth == 1U) {
#line 107
        if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 107
          if (quote___0) {
#line 107
            tmp___7 = 0;
          } else {
#line 107
            if ((int )*(itr.curptr) == 32) {
#line 107
              tmp___6 = 1;
            } else
#line 107
            if ((int )*(itr.curptr) == 9) {
#line 107
              tmp___6 = 1;
            } else {
#line 107
              tmp___6 = 0;
            }
#line 107
            tmp___7 = tmp___6;
          }
#line 107
          if (tmp___7) {
#line 107
            goto while_break___1;
          }
        }
      }
#line 110
      if (itr.curwidth == 1U) {
#line 110
        if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 111
          if ((int )*(itr.curptr) == quote___0) {
            {
#line 112
            utf8_iter_next(& itr);
            }
#line 113
            goto while_break___1;
          } else
#line 114
          if ((int )*(itr.curptr) == 92) {
            {
#line 115
            utf8_iter_next(& itr);
            }
#line 116
            if (itr.curwidth == 1U) {
#line 116
              if (((int )*(itr.curptr + 0) & -128) == 0) {
#line 117
                __o___0 = & in->stk;
#line 117
                if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
                  {
#line 117
                  _obstack_newchunk(__o___0, 1);
                  }
                }
                {
#line 117
                tmp___2 = __o___0->next_free;
#line 117
                (__o___0->next_free) ++;
#line 117
                tmp___3 = xdico_quote_char((int )*(itr.curptr));
#line 117
                *tmp___2 = (char )tmp___3;
                }
              } else {
#line 116
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 119
              __o___1 = & in->stk;
#line 119
              if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
                {
#line 119
                _obstack_newchunk(__o___1, 1);
                }
              }
#line 119
              tmp___4 = __o___1->next_free;
#line 119
              (__o___1->next_free) ++;
#line 119
              *tmp___4 = (char )'\\';
#line 120
              __o___2 = & in->stk;
#line 120
              __len = (int )itr.curwidth;
#line 120
              if ((unsigned long )(__o___2->next_free + __len) > (unsigned long )__o___2->chunk_limit) {
                {
#line 120
                _obstack_newchunk(__o___2, __len);
                }
              }
              {
#line 120
              memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)itr.curptr,
                     (size_t )__len);
#line 120
              __o___2->next_free += __len;
              }
            }
#line 122
            goto __Cont;
          }
        }
      }
#line 125
      __o___3 = & in->stk;
#line 125
      __len___0 = (int )itr.curwidth;
#line 125
      if ((unsigned long )(__o___3->next_free + __len___0) > (unsigned long )__o___3->chunk_limit) {
        {
#line 125
        _obstack_newchunk(__o___3, __len___0);
        }
      }
      {
#line 125
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)itr.curptr,
             (size_t )__len___0);
#line 125
      __o___3->next_free += __len___0;
      }
      __Cont: /* CIL Label */ 
      {
#line 107
      utf8_iter_next(& itr);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 127
    __o___4 = & in->stk;
#line 127
    if ((unsigned long )(__o___4->next_free + 1) > (unsigned long )__o___4->chunk_limit) {
      {
#line 127
      _obstack_newchunk(__o___4, 1);
      }
    }
#line 127
    tmp___8 = __o___4->next_free;
#line 127
    (__o___4->next_free) ++;
#line 127
    *tmp___8 = (char)0;
#line 128
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  __o1 = & in->stk;
#line 131
  __value = (void *)__o1->object_base;
#line 131
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 131
    __o1->maybe_empty_object = 1U;
  }
#line 131
  if (sizeof(int ) < sizeof(void *)) {
#line 131
    tmp___9 = __o1->object_base;
  } else {
#line 131
    tmp___9 = (char *)0;
  }
#line 131
  if (sizeof(int ) < sizeof(void *)) {
#line 131
    tmp___10 = __o1->object_base;
  } else {
#line 131
    tmp___10 = (char *)0;
  }
#line 131
  __o1->next_free = tmp___9 + (((__o1->next_free - tmp___10) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 131
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 131
    __o1->next_free = __o1->chunk_limit;
  }
#line 131
  __o1->object_base = __o1->next_free;
#line 131
  in->rootptr = (char *)__value;
#line 133
  in->argc = argc;
#line 134
  __h = & in->stk;
#line 134
  __o___5 = __h;
#line 134
  __len___1 = (int )((unsigned long )(argc + 1) * sizeof(*(in->argv + 0)));
#line 134
  if (__o___5->chunk_limit - __o___5->next_free < (long )__len___1) {
    {
#line 134
    _obstack_newchunk(__o___5, __len___1);
    }
  }
#line 134
  __o___5->next_free += __len___1;
#line 134
  __o1___0 = __h;
#line 134
  __value___0 = (void *)__o1___0->object_base;
#line 134
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 134
    __o1___0->maybe_empty_object = 1U;
  }
#line 134
  if (sizeof(int ) < sizeof(void *)) {
#line 134
    tmp___11 = __o1___0->object_base;
  } else {
#line 134
    tmp___11 = (char *)0;
  }
#line 134
  if (sizeof(int ) < sizeof(void *)) {
#line 134
    tmp___12 = __o1___0->object_base;
  } else {
#line 134
    tmp___12 = (char *)0;
  }
#line 134
  __o1___0->next_free = tmp___11 + (((__o1___0->next_free - tmp___12) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 134
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 134
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 134
  __o1___0->object_base = __o1___0->next_free;
#line 134
  in->argv = (char **)__value___0;
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 136
    if (! (i < argc)) {
#line 136
      goto while_break___2;
    }
    {
#line 137
    *(in->argv + i) = in->rootptr;
#line 138
    tmp___13 = strlen((char const   *)in->rootptr);
#line 138
    in->rootptr += tmp___13 + 1U;
#line 136
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 140
  *(in->argv + i) = (char *)((void *)0);
#line 141
  *pargc = in->argc;
#line 142
  *pargv = in->argv;
#line 143
  return (argc);
}
}
#line 68 "../include/xdico.h"
xdico_timer_t timer_get(char const   *name ) ;
#line 69
xdico_timer_t timer_start(char const   *name ) ;
#line 70
xdico_timer_t timer_stop(char const   *name ) ;
#line 71
xdico_timer_t timer_reset(char const   *name ) ;
#line 72
double timer_get_real(xdico_timer_t t ) ;
#line 73
double timer_get_user(xdico_timer_t t ) ;
#line 74
double timer_get_system(xdico_timer_t t ) ;
#line 75
void timer_format_time(dico_stream_t stream , double t ) ;
#line 88 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static Hash_table *timer_table  ;
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static size_t hash_string_ci(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;
  int tmp ;

  {
#line 47
  value = (size_t )0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    ch = (unsigned char )*string;
#line 50
    if (! ch) {
#line 50
      goto while_break;
    }
    {
#line 51
    tmp = tolower((int )ch);
#line 51
    value = (value * 31U + (size_t )tmp) % n_buckets;
#line 50
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (value);
}
}
#line 56 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static size_t timer_hasher(void const   *data , unsigned int n_buckets ) 
{ 
  struct timer_slot  const  *t ;
  size_t tmp ;

  {
  {
#line 59
  t = (struct timer_slot  const  *)data;
#line 60
  tmp = hash_string_ci((char const   *)t->name, n_buckets);
  }
#line 60
  return (tmp);
}
}
#line 64 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static _Bool timer_compare(void const   *data1 , void const   *data2 ) 
{ 
  struct timer_slot  const  *t1 ;
  struct timer_slot  const  *t2 ;
  int tmp ;

  {
  {
#line 67
  t1 = (struct timer_slot  const  *)data1;
#line 68
  t2 = (struct timer_slot  const  *)data2;
#line 69
  tmp = strcasecmp((char const   *)t1->name, (char const   *)t2->name);
  }
#line 69
  return ((_Bool )(tmp == 0));
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static xdico_timer_t timer_alloc(char const   *name ) 
{ 
  xdico_timer_t t ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 76
  tmp = strlen(name);
#line 76
  tmp___0 = xmalloc((size_t )((sizeof(*t) + (unsigned long )tmp) + 1UL));
#line 76
  t = (xdico_timer_t )tmp___0;
#line 77
  memset((void *)t, 0, (size_t )sizeof(*t));
#line 78
  t->name = (char *)(t + 1);
#line 79
  strcpy((char */* __restrict  */)t->name, (char const   */* __restrict  */)name);
  }
#line 80
  return (t);
}
}
#line 84 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
xdico_timer_t timer_get(char const   *name ) 
{ 
  xdico_timer_t tp ;
  xdico_timer_t ret ;
  void *tmp ;

  {
  {
#line 89
  tp = timer_alloc(name);
  }
#line 91
  if (timer_table) {
#line 91
    goto _L;
  } else {
    {
#line 91
    timer_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & timer_hasher,
                                  & timer_compare, (void (*)(void * ))0);
    }
#line 91
    if (timer_table) {
      _L: /* CIL Label */ 
      {
#line 91
      tmp = hash_insert(timer_table, (void const   *)tp);
#line 91
      ret = (xdico_timer_t )tmp;
      }
#line 91
      if (! ret) {
        {
#line 96
        xalloc_die();
        }
      }
    } else {
      {
#line 96
      xalloc_die();
      }
    }
  }
#line 98
  if ((unsigned long )ret != (unsigned long )tp) {
    {
#line 99
    free((void *)tp);
    }
  }
#line 100
  return (ret);
}
}
#line 103 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
xdico_timer_t timer_start(char const   *name ) 
{ 
  xdico_timer_t t ;
  xdico_timer_t tmp ;

  {
  {
#line 106
  tmp = timer_get(name);
#line 106
  t = tmp;
#line 108
  gettimeofday((struct timeval */* __restrict  */)(& t->real_mark), (__timezone_ptr_t )((void *)0));
#line 109
  getrusage((__rusage_who_t )0, & t->self_mark);
#line 110
  getrusage((__rusage_who_t )-1, & t->children_mark);
  }
#line 111
  return (t);
}
}
#line 118 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static void _timer_compute(xdico_timer_t t ) 
{ 
  struct timeval real ;
  struct rusage rusage ;

  {
  {
#line 124
  gettimeofday((struct timeval */* __restrict  */)(& real), (__timezone_ptr_t )((void *)0));
#line 125
  t->real = (double )(real.tv_sec - t->real_mark.tv_sec) + (double )(real.tv_usec - t->real_mark.tv_usec) / (double )1000000;
#line 126
  getrusage((__rusage_who_t )0, & rusage);
#line 127
  t->self_user = (double )(rusage.ru_utime.tv_sec - t->self_mark.ru_utime.tv_sec) + (double )(rusage.ru_utime.tv_usec - t->self_mark.ru_utime.tv_usec) / (double )1000000;
#line 128
  t->self_system = (double )(rusage.ru_stime.tv_sec - t->self_mark.ru_stime.tv_sec) + (double )(rusage.ru_stime.tv_usec - t->self_mark.ru_stime.tv_usec) / (double )1000000;
#line 130
  getrusage((__rusage_who_t )-1, & rusage);
#line 131
  t->children_user = (double )(rusage.ru_utime.tv_sec - t->children_mark.ru_utime.tv_sec) + (double )(rusage.ru_utime.tv_usec - t->children_mark.ru_utime.tv_usec) / (double )1000000;
#line 132
  t->children_system = (double )(rusage.ru_stime.tv_sec - t->children_mark.ru_stime.tv_sec) + (double )(rusage.ru_stime.tv_usec - t->children_mark.ru_stime.tv_usec) / (double )1000000;
  }
#line 133
  return;
}
}
#line 135 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
xdico_timer_t timer_stop(char const   *name ) 
{ 
  xdico_timer_t t ;
  xdico_timer_t tmp ;

  {
  {
#line 138
  tmp = timer_get(name);
#line 138
  t = tmp;
#line 139
  _timer_compute(t);
  }
#line 140
  return (t);
}
}
#line 143 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
xdico_timer_t timer_reset(char const   *name ) 
{ 
  xdico_timer_t t ;
  xdico_timer_t tmp ;

  {
  {
#line 146
  tmp = timer_get(name);
#line 146
  t = tmp;
#line 147
  t->real = 0.0;
#line 148
  t->self_user = 0.0;
#line 149
  t->self_system = 0.0;
#line 150
  t->children_user = 0.0;
#line 151
  t->children_system = 0.0;
  }
#line 152
  return (t);
}
}
#line 155 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
double timer_get_real(xdico_timer_t t ) 
{ 


  {
#line 158
  return (t->real);
}
}
#line 161 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
double timer_get_user(xdico_timer_t t ) 
{ 


  {
#line 164
  return (t->self_user + t->children_user);
}
}
#line 167 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
double timer_get_system(xdico_timer_t t ) 
{ 


  {
#line 170
  return (t->self_system + t->children_system);
}
}
#line 176 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
static char buf___0[128]  ;
#line 173 "/home/wslee/benchmarks/textformat/dico-2.0/lib/timer.c"
void timer_format_time(dico_stream_t stream , double t ) 
{ 
  long s ;
  long m ;
  long h ;
  long d ;
  size_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 178
  if (t < (double )600) {
    {
#line 179
    snprintf((char */* __restrict  */)(buf___0), (size_t )sizeof(buf___0), (char const   */* __restrict  */)"%0.3f",
             t);
    }
  } else {
#line 183
    s = (long )t;
#line 184
    d = s / 86400L;
#line 185
    s -= (d * 3600L) * 24L;
#line 186
    h = s / 3600L;
#line 187
    s -= h * 3600L;
#line 188
    m = s / 60L;
#line 189
    s -= m * 60L;
#line 191
    if (d) {
      {
#line 192
      snprintf((char */* __restrict  */)(buf___0), (size_t )sizeof(buf___0), (char const   */* __restrict  */)"%ld+%02ld:%02ld:%02ld",
               d, h, m, s);
      }
    } else
#line 193
    if (h) {
      {
#line 194
      snprintf((char */* __restrict  */)(buf___0), (size_t )sizeof(buf___0), (char const   */* __restrict  */)"%02ld:%02ld:%02ld",
               h, m, s);
      }
    } else {
      {
#line 196
      snprintf((char */* __restrict  */)(buf___0), (size_t )sizeof(buf___0), (char const   */* __restrict  */)"%02ld:%02ld",
               m, s);
      }
    }
  }
  {
#line 198
  tmp = strlen((char const   *)(buf___0));
#line 198
  dico_stream_write(stream, (void const   *)(buf___0), tmp);
  }
#line 199
  return;
}
}
#line 33 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
static struct cvt_tab *tab_lookup(struct cvt_tab *tab___0 , int c ) ;
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
struct cvt_tab shin_to_shift_tab[63]  = 
#line 38
  {      {(uchar )33, {(uchar )33, (uchar )96}, (uchar )129, (uchar )64}, 
        {(uchar )33, {(uchar )96, (uchar )127}, (uchar )129, (uchar )128}, 
        {(uchar )34, {(uchar )33, (uchar )46}, (uchar )129, (uchar )159}, 
        {(uchar )35, {(uchar )48, (uchar )57}, (uchar )130, (uchar )79}, 
        {(uchar )35, {(uchar )65, (uchar )90}, (uchar )130, (uchar )96}, 
        {(uchar )35, {(uchar )97, (uchar )122}, (uchar )130, (uchar )129}, 
        {(uchar )36, {(uchar )33, (uchar )115}, (uchar )130, (uchar )159}, 
        {(uchar )37, {(uchar )33, (uchar )96}, (uchar )131, (uchar )64}, 
        {(uchar )37, {(uchar )96, (uchar )119}, (uchar )131, (uchar )128}, 
        {(uchar )38, {(uchar )33, (uchar )56}, (uchar )131, (uchar )159}, 
        {(uchar )38, {(uchar )65, (uchar )88}, (uchar )129, (uchar )191}, 
        {(uchar )39, {(uchar )33, (uchar )96}, (uchar )132, (uchar )64}, 
        {(uchar )39, {(uchar )96, (uchar )114}, (uchar )132, (uchar )128}, 
        {(uchar )40, {(uchar )33, (uchar )64}, (uchar )132, (uchar )159}, 
        {(uchar )48, {(uchar )33, (uchar )126}, (uchar )136, (uchar )159}, 
        {(uchar )49, {(uchar )33, (uchar )96}, (uchar )137, (uchar )64}, 
        {(uchar )49, {(uchar )96, (uchar )126}, (uchar )137, (uchar )128}, 
        {(uchar )50, {(uchar )33, (uchar )126}, (uchar )137, (uchar )159}, 
        {(uchar )51, {(uchar )33, (uchar )96}, (uchar )138, (uchar )64}, 
        {(uchar )51, {(uchar )96, (uchar )126}, (uchar )138, (uchar )128}, 
        {(uchar )52, {(uchar )33, (uchar )126}, (uchar )138, (uchar )159}, 
        {(uchar )53, {(uchar )33, (uchar )96}, (uchar )139, (uchar )64}, 
        {(uchar )53, {(uchar )96, (uchar )126}, (uchar )139, (uchar )128}, 
        {(uchar )54, {(uchar )33, (uchar )126}, (uchar )139, (uchar )159}, 
        {(uchar )55, {(uchar )33, (uchar )96}, (uchar )140, (uchar )64}, 
        {(uchar )55, {(uchar )96, (uchar )126}, (uchar )140, (uchar )128}, 
        {(uchar )56, {(uchar )33, (uchar )126}, (uchar )140, (uchar )159}, 
        {(uchar )57, {(uchar )33, (uchar )96}, (uchar )141, (uchar )64}, 
        {(uchar )57, {(uchar )96, (uchar )126}, (uchar )141, (uchar )128}, 
        {(uchar )58, {(uchar )33, (uchar )126}, (uchar )141, (uchar )159}, 
        {(uchar )59, {(uchar )33, (uchar )96}, (uchar )142, (uchar )64}, 
        {(uchar )59, {(uchar )96, (uchar )126}, (uchar )142, (uchar )128}, 
        {(uchar )60, {(uchar )33, (uchar )126}, (uchar )142, (uchar )159}, 
        {(uchar )61, {(uchar )33, (uchar )96}, (uchar )143, (uchar )64}, 
        {(uchar )61, {(uchar )96, (uchar )126}, (uchar )143, (uchar )128}, 
        {(uchar )62, {(uchar )33, (uchar )126}, (uchar )143, (uchar )159}, 
        {(uchar )63, {(uchar )33, (uchar )96}, (uchar )144, (uchar )64}, 
        {(uchar )63, {(uchar )96, (uchar )126}, (uchar )144, (uchar )128}, 
        {(uchar )64, {(uchar )33, (uchar )126}, (uchar )144, (uchar )159}, 
        {(uchar )65, {(uchar )33, (uchar )96}, (uchar )145, (uchar )64}, 
        {(uchar )65, {(uchar )96, (uchar )126}, (uchar )145, (uchar )128}, 
        {(uchar )66, {(uchar )33, (uchar )126}, (uchar )145, (uchar )159}, 
        {(uchar )67, {(uchar )33, (uchar )96}, (uchar )146, (uchar )64}, 
        {(uchar )67, {(uchar )96, (uchar )126}, (uchar )146, (uchar )128}, 
        {(uchar )68, {(uchar )33, (uchar )126}, (uchar )146, (uchar )159}, 
        {(uchar )69, {(uchar )33, (uchar )96}, (uchar )147, (uchar )64}, 
        {(uchar )69, {(uchar )96, (uchar )126}, (uchar )147, (uchar )128}, 
        {(uchar )70, {(uchar )33, (uchar )126}, (uchar )147, (uchar )159}, 
        {(uchar )71, {(uchar )33, (uchar )96}, (uchar )148, (uchar )64}, 
        {(uchar )71, {(uchar )96, (uchar )126}, (uchar )148, (uchar )128}, 
        {(uchar )72, {(uchar )33, (uchar )126}, (uchar )148, (uchar )159}, 
        {(uchar )73, {(uchar )33, (uchar )96}, (uchar )149, (uchar )64}, 
        {(uchar )73, {(uchar )96, (uchar )126}, (uchar )149, (uchar )128}, 
        {(uchar )74, {(uchar )33, (uchar )126}, (uchar )149, (uchar )159}, 
        {(uchar )75, {(uchar )33, (uchar )96}, (uchar )150, (uchar )64}, 
        {(uchar )75, {(uchar )96, (uchar )126}, (uchar )150, (uchar )128}, 
        {(uchar )76, {(uchar )33, (uchar )126}, (uchar )150, (uchar )159}, 
        {(uchar )77, {(uchar )33, (uchar )96}, (uchar )151, (uchar )64}, 
        {(uchar )77, {(uchar )96, (uchar )126}, (uchar )151, (uchar )128}, 
        {(uchar )78, {(uchar )33, (uchar )126}, (uchar )151, (uchar )159}, 
        {(uchar )79, {(uchar )33, (uchar )96}, (uchar )152, (uchar )64}, 
        {(uchar )79, {(uchar )96, (uchar )126}, (uchar )152, (uchar )128}, 
        {(uchar )0, {(unsigned char)0, (unsigned char)0}, (unsigned char)0, (unsigned char)0}};
#line 106 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
struct cvt_tab shift_to_shin_tab[63]  = 
#line 106
  {      {(uchar )129, {(uchar )64, (uchar )127}, (uchar )33, (uchar )33}, 
        {(uchar )129, {(uchar )128, (uchar )158}, (uchar )33, (uchar )96}, 
        {(uchar )129, {(uchar )159, (uchar )172}, (uchar )34, (uchar )33}, 
        {(uchar )130, {(uchar )79, (uchar )88}, (uchar )35, (uchar )48}, 
        {(uchar )130, {(uchar )96, (uchar )121}, (uchar )35, (uchar )65}, 
        {(uchar )130, {(uchar )129, (uchar )154}, (uchar )35, (uchar )97}, 
        {(uchar )130, {(uchar )159, (uchar )241}, (uchar )36, (uchar )33}, 
        {(uchar )131, {(uchar )64, (uchar )127}, (uchar )37, (uchar )33}, 
        {(uchar )131, {(uchar )128, (uchar )150}, (uchar )37, (uchar )96}, 
        {(uchar )131, {(uchar )159, (uchar )182}, (uchar )38, (uchar )33}, 
        {(uchar )129, {(uchar )191, (uchar )214}, (uchar )38, (uchar )65}, 
        {(uchar )132, {(uchar )64, (uchar )127}, (uchar )39, (uchar )33}, 
        {(uchar )132, {(uchar )128, (uchar )145}, (uchar )39, (uchar )96}, 
        {(uchar )132, {(uchar )159, (uchar )190}, (uchar )40, (uchar )33}, 
        {(uchar )136, {(uchar )159, (uchar )252}, (uchar )48, (uchar )33}, 
        {(uchar )137, {(uchar )64, (uchar )127}, (uchar )49, (uchar )33}, 
        {(uchar )137, {(uchar )128, (uchar )158}, (uchar )49, (uchar )96}, 
        {(uchar )137, {(uchar )159, (uchar )252}, (uchar )50, (uchar )33}, 
        {(uchar )138, {(uchar )64, (uchar )127}, (uchar )51, (uchar )33}, 
        {(uchar )138, {(uchar )128, (uchar )158}, (uchar )51, (uchar )96}, 
        {(uchar )138, {(uchar )159, (uchar )252}, (uchar )52, (uchar )33}, 
        {(uchar )139, {(uchar )64, (uchar )127}, (uchar )53, (uchar )33}, 
        {(uchar )139, {(uchar )128, (uchar )158}, (uchar )53, (uchar )96}, 
        {(uchar )139, {(uchar )159, (uchar )252}, (uchar )54, (uchar )33}, 
        {(uchar )140, {(uchar )64, (uchar )127}, (uchar )55, (uchar )33}, 
        {(uchar )140, {(uchar )128, (uchar )158}, (uchar )55, (uchar )96}, 
        {(uchar )140, {(uchar )159, (uchar )252}, (uchar )56, (uchar )33}, 
        {(uchar )141, {(uchar )64, (uchar )127}, (uchar )57, (uchar )33}, 
        {(uchar )141, {(uchar )128, (uchar )158}, (uchar )57, (uchar )96}, 
        {(uchar )141, {(uchar )159, (uchar )252}, (uchar )58, (uchar )33}, 
        {(uchar )142, {(uchar )64, (uchar )127}, (uchar )59, (uchar )33}, 
        {(uchar )142, {(uchar )128, (uchar )158}, (uchar )59, (uchar )96}, 
        {(uchar )142, {(uchar )159, (uchar )252}, (uchar )60, (uchar )33}, 
        {(uchar )143, {(uchar )64, (uchar )127}, (uchar )61, (uchar )33}, 
        {(uchar )143, {(uchar )128, (uchar )158}, (uchar )61, (uchar )96}, 
        {(uchar )143, {(uchar )159, (uchar )252}, (uchar )62, (uchar )33}, 
        {(uchar )144, {(uchar )64, (uchar )127}, (uchar )63, (uchar )33}, 
        {(uchar )144, {(uchar )128, (uchar )158}, (uchar )63, (uchar )96}, 
        {(uchar )144, {(uchar )159, (uchar )252}, (uchar )64, (uchar )33}, 
        {(uchar )145, {(uchar )64, (uchar )127}, (uchar )65, (uchar )33}, 
        {(uchar )145, {(uchar )128, (uchar )158}, (uchar )65, (uchar )96}, 
        {(uchar )145, {(uchar )159, (uchar )252}, (uchar )66, (uchar )33}, 
        {(uchar )146, {(uchar )64, (uchar )127}, (uchar )67, (uchar )33}, 
        {(uchar )146, {(uchar )128, (uchar )158}, (uchar )67, (uchar )96}, 
        {(uchar )146, {(uchar )159, (uchar )252}, (uchar )68, (uchar )33}, 
        {(uchar )147, {(uchar )64, (uchar )127}, (uchar )69, (uchar )33}, 
        {(uchar )147, {(uchar )128, (uchar )158}, (uchar )69, (uchar )96}, 
        {(uchar )147, {(uchar )159, (uchar )252}, (uchar )70, (uchar )33}, 
        {(uchar )148, {(uchar )64, (uchar )127}, (uchar )71, (uchar )33}, 
        {(uchar )148, {(uchar )128, (uchar )158}, (uchar )71, (uchar )96}, 
        {(uchar )148, {(uchar )159, (uchar )252}, (uchar )72, (uchar )33}, 
        {(uchar )149, {(uchar )64, (uchar )127}, (uchar )73, (uchar )33}, 
        {(uchar )149, {(uchar )128, (uchar )158}, (uchar )73, (uchar )96}, 
        {(uchar )149, {(uchar )159, (uchar )252}, (uchar )74, (uchar )33}, 
        {(uchar )150, {(uchar )64, (uchar )127}, (uchar )75, (uchar )33}, 
        {(uchar )150, {(uchar )128, (uchar )158}, (uchar )75, (uchar )96}, 
        {(uchar )150, {(uchar )159, (uchar )252}, (uchar )76, (uchar )33}, 
        {(uchar )151, {(uchar )64, (uchar )127}, (uchar )77, (uchar )33}, 
        {(uchar )151, {(uchar )128, (uchar )158}, (uchar )77, (uchar )96}, 
        {(uchar )151, {(uchar )159, (uchar )252}, (uchar )78, (uchar )33}, 
        {(uchar )152, {(uchar )64, (uchar )127}, (uchar )79, (uchar )33}, 
        {(uchar )152, {(uchar )128, (uchar )158}, (uchar )79, (uchar )96}, 
        {(uchar )0, {(unsigned char)0, (unsigned char)0}, (unsigned char)0, (unsigned char)0}};
#line 175 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
static struct cvt_tab *tab_lookup(struct cvt_tab *tab___0 , int c ) 
{ 


  {
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((int )tab___0->in1 > 0)) {
#line 178
      goto while_break;
    }
#line 179
    if ((int )tab___0->in1 == c) {
#line 180
      return (tab___0);
    }
#line 178
    tab___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return ((struct cvt_tab *)((void *)0));
}
}
#line 184 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
int convert(uchar *text , int len , struct cvt_tab *tab___0 ) 
{ 
  int i ;
  int c ;
  int c2 ;
  struct cvt_tab *t ;

  {
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < len)) {
#line 190
      goto while_break;
    }
    {
#line 191
    c = (int )*(text + 0);
#line 192
    t = tab_lookup(tab___0, c);
    }
#line 192
    if (t) {
#line 193
      c2 = (int )*(text + 1);
      {
#line 194
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 194
        if (! ((int )t->in1 == c)) {
#line 194
          goto while_break___0;
        }
#line 195
        if ((int )t->in2_range[0] <= c2) {
#line 195
          if (c2 <= (int )t->in2_range[1]) {
#line 196
            goto while_break___0;
          }
        }
#line 194
        t ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 199
      if ((int )t->in1 == c) {
#line 200
        c2 -= (int )t->in2_range[0] - (int )t->out2;
#line 201
        *(text + 0) = t->out1;
#line 202
        *(text + 1) = (uchar )c2;
      } else {
#line 204
        goto while_break;
      }
    } else {
#line 207
      goto while_break;
    }
#line 190
    i += 2;
#line 190
    text += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (i);
}
}
#line 214 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
int shift_to_shin(char *text , int len ) 
{ 
  int tmp ;

  {
  {
#line 217
  tmp = convert((uchar *)text, len, shift_to_shin_tab);
  }
#line 217
  return (tmp);
}
}
#line 220 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
int euc_to_shin(uchar *text , int len ) 
{ 
  int i ;
  uchar *tmp ;

  {
#line 225
  i = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < len)) {
#line 225
      goto while_break;
    }
#line 226
    tmp = text;
#line 226
    text ++;
#line 226
    *tmp = (uchar )((int )*tmp - 128);
#line 225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (len);
}
}
#line 231 "/home/wslee/benchmarks/textformat/dico-2.0/lib/jiscvt.c"
int shin_to_euc(uchar *text , int len ) 
{ 
  int i ;
  uchar *tmp ;

  {
#line 236
  i = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i < len)) {
#line 236
      goto while_break;
    }
#line 237
    tmp = text;
#line 237
    text ++;
#line 237
    *tmp = (uchar )((int )*tmp + 128);
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return (len);
}
}
#line 365 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
#line 366
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 368
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 74
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
#line 136 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 289
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 29 "../include/xdico.h"
char *ip_hostname(IPADDR ipaddr ) ;
#line 30
IPADDR get_ipaddr(char *host ) ;
#line 31
int str2port(char *str ) ;
#line 35
void sockaddr_to_str(struct sockaddr  const  *sa , int salen , char *bufptr , size_t buflen ,
                     size_t *plen ) ;
#line 38
char *sockaddr_to_astr(struct sockaddr  const  *sa , int salen ) ;
#line 42 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
IPADDR get_ipaddr(char *host ) 
{ 
  struct hostent *hp ;
  struct in_addr addr ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 48
  tmp___1 = inet_aton((char const   *)host, & addr);
  }
#line 48
  if (tmp___1) {
    {
#line 49
    tmp = ntohl(addr.s_addr);
    }
#line 49
    return ((IPADDR )tmp);
  } else {
    {
#line 50
    hp = gethostbyname((char const   *)host);
    }
#line 50
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 51
      return ((IPADDR )0);
    } else {
      {
#line 53
      tmp___0 = ntohl((uint32_t )*((UINT4 *)*(hp->h_addr_list + 0)));
      }
#line 53
      return ((IPADDR )tmp___0);
    }
  }
}
}
#line 60 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
char *ip_hostname(IPADDR ipaddr ) 
{ 
  struct hostent *hp ;
  UINT4 n_ipaddr ;
  uint32_t tmp ;
  struct in_addr in ;
  char *tmp___0 ;

  {
  {
#line 66
  tmp = htonl((uint32_t )ipaddr);
#line 66
  n_ipaddr = (UINT4 )tmp;
#line 67
  hp = gethostbyaddr((void const   *)((char *)(& n_ipaddr)), (__socklen_t )sizeof(struct in_addr ),
                     2);
  }
#line 69
  if (! hp) {
    {
#line 71
    in.s_addr = htonl((uint32_t )ipaddr);
#line 72
    tmp___0 = inet_ntoa(in);
    }
#line 72
    return (tmp___0);
  }
#line 74
  return (hp->h_name);
}
}
#line 77 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
IPADDR getmyip(void) 
{ 
  char myname[256] ;
  IPADDR tmp ;
  void *__cil_tmp3 ;

  {
  {
#line 82
  gethostname(myname, (size_t )sizeof(myname));
#line 83
  tmp = get_ipaddr(myname);
  }
#line 83
  return (tmp);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
int str2port(char *str ) 
{ 
  struct servent *serv ;
  char *p ;
  int port ;
  uint16_t tmp ;
  long l ;
  char *__cil_tmp7 ;

  {
  {
#line 94
  serv = getservbyname((char const   *)str, "tcp");
  }
#line 96
  if ((unsigned long )serv != (unsigned long )((void *)0)) {
    {
#line 97
    tmp = ntohs((uint16_t )serv->s_port);
#line 97
    port = (int )tmp;
    }
  } else {
    {
#line 101
    l = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& p),
               0);
    }
#line 103
    if (*p) {
#line 104
      return (-1);
    } else
#line 103
    if (l < 0L) {
#line 104
      return (-1);
    } else
#line 103
    if (l > 65535L) {
#line 104
      return (-1);
    }
#line 106
    port = (int )l;
  }
#line 109
  return (port);
}
}
#line 112 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
static size_t mu_stpcpy(char **pbuf , size_t *psize , char const   *src ) 
{ 
  size_t slen ;
  size_t tmp ;
  char *buf___1 ;
  size_t size ;

  {
  {
#line 115
  tmp = strlen(src);
#line 115
  slen = tmp;
  }
#line 116
  if ((unsigned long )pbuf == (unsigned long )((void *)0)) {
#line 117
    return (slen);
  } else
#line 116
  if ((unsigned long )*pbuf == (unsigned long )((void *)0)) {
#line 117
    return (slen);
  } else {
#line 119
    buf___1 = *pbuf;
#line 120
    size = *psize;
#line 121
    if (size > slen) {
#line 122
      size = slen;
    }
    {
#line 123
    memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)src,
           size);
#line 124
    *psize -= size;
#line 125
    *pbuf += size;
    }
#line 126
    if (*psize) {
#line 127
      *(*pbuf) = (char)0;
    } else {
#line 129
      *(*pbuf + -1) = (char)0;
    }
#line 130
    return (size);
  }
}
}
#line 137 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
void sockaddr_to_str(struct sockaddr  const  *sa , int salen , char *bufptr , size_t buflen ,
                     size_t *plen ) 
{ 
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  size_t len ;
  struct sockaddr_in s_in ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  uint16_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  struct sockaddr_un *s_un ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 143
  len = (size_t )0;
  {
#line 145
  if ((int const   )sa->sa_family == 2) {
#line 145
    goto case_2;
  }
#line 155
  if ((int const   )sa->sa_family == 1) {
#line 155
    goto case_1;
  }
#line 167
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 147
  s_in = *((struct sockaddr_in *)sa);
#line 148
  tmp = inet_ntoa(s_in.sin_addr);
#line 148
  tmp___0 = mu_stpcpy(& bufptr, & buflen, (char const   *)tmp);
#line 148
  len += tmp___0;
#line 149
  tmp___1 = mu_stpcpy(& bufptr, & buflen, ":");
#line 149
  len += tmp___1;
#line 150
  tmp___2 = ntohs(s_in.sin_port);
#line 150
  tmp___3 = umaxtostr((uintmax_t )tmp___2, buf___1);
#line 150
  tmp___4 = mu_stpcpy(& bufptr, & buflen, (char const   *)tmp___3);
#line 150
  len += tmp___4;
  }
#line 152
  goto switch_break;
  case_1: /* CIL Label */ 
#line 157
  s_un = (struct sockaddr_un *)sa;
#line 158
  if ((unsigned long )salen < (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)) {
#line 158
    tmp___8 = "";
  } else {
#line 158
    tmp___8 = (char const   *)(s_un->sun_path);
  }
#line 158
  if ((int const   )*(tmp___8 + 0) == 0) {
    {
#line 159
    tmp___5 = mu_stpcpy(& bufptr, & buflen, "anonymous socket");
#line 159
    len += tmp___5;
    }
  } else {
    {
#line 161
    tmp___6 = mu_stpcpy(& bufptr, & buflen, "socket ");
#line 161
    len += tmp___6;
#line 162
    tmp___7 = mu_stpcpy(& bufptr, & buflen, (char const   *)(s_un->sun_path));
#line 162
    len += tmp___7;
    }
  }
#line 164
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 168
  tmp___9 = mu_stpcpy(& bufptr, & buflen, "{Unsupported family: ");
#line 168
  len += tmp___9;
#line 169
  tmp___10 = umaxtostr((uintmax_t )sa->sa_family, buf___1);
#line 169
  tmp___11 = mu_stpcpy(& bufptr, & buflen, (char const   *)tmp___10);
#line 169
  len += tmp___11;
#line 170
  tmp___12 = mu_stpcpy(& bufptr, & buflen, "}");
#line 170
  len += tmp___12;
  }
  switch_break: /* CIL Label */ ;
  }
#line 172
  if (plen) {
#line 173
    *plen = len + 1U;
  }
#line 174
  return;
}
}
#line 176 "/home/wslee/benchmarks/textformat/dico-2.0/lib/iputil.c"
char *sockaddr_to_astr(struct sockaddr  const  *sa , int salen ) 
{ 
  size_t size ;
  char *p ;
  void *tmp ;

  {
  {
#line 182
  sockaddr_to_str(sa, salen, (char *)((void *)0), (size_t )0, & size);
#line 183
  tmp = xmalloc(size);
#line 183
  p = (char *)tmp;
#line 184
  sockaddr_to_str(sa, salen, p, size, (size_t *)((void *)0));
  }
#line 185
  return (p);
}
}
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/lib/appi18n.c"
void appi18n_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 27
  setlocale(6, "");
#line 28
  bindtextdomain("dico", "/usr/local/share/locale");
#line 29
  textdomain("dico");
  }
#line 30
  return;
}
}
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static int vl_exit___0(lt_user_data loader_data  __attribute__((__unused__)) ) ;
#line 49
static lt_module vm_open___0(lt_user_data loader_data  __attribute__((__unused__)) ,
                             char const   *filename , lt_dladvise advise ) ;
#line 51
static int vm_close___0(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ) ;
#line 52
static void *vm_sym___0(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ,
                        char const   *name ) ;
#line 55 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static lt_dlvtable *vtable___0  =    (lt_dlvtable *)0;
#line 60 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
lt_dlvtable *dlopen_LTX_get_vtable(lt_user_data loader_data ) 
{ 
  void *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 63
  if (! vtable___0) {
    {
#line 65
    tmp = lt__zalloc((size_t )sizeof(*vtable___0));
#line 65
    vtable___0 = (lt_dlvtable *)tmp;
    }
  }
#line 68
  if (vtable___0) {
#line 68
    if (! vtable___0->name) {
#line 70
      vtable___0->name = "lt_dlopen";
#line 74
      vtable___0->module_open = & vm_open___0;
#line 75
      vtable___0->module_close = & vm_close___0;
#line 76
      vtable___0->find_sym = & vm_sym___0;
#line 77
      vtable___0->dlloader_exit = & vl_exit___0;
#line 78
      vtable___0->dlloader_data = loader_data;
#line 79
      vtable___0->priority = (lt_dlloader_priority )0;
    }
  }
#line 82
  if (vtable___0) {
#line 82
    if ((unsigned long )vtable___0->dlloader_data != (unsigned long )loader_data) {
      {
#line 84
      tmp___0 = lt__error_string(3);
#line 84
      lt__set_last_error(tmp___0);
      }
#line 85
      return ((lt_dlvtable *)0);
    }
  }
#line 88
  return (vtable___0);
}
}
#line 57 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 61
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 65
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2))) dlsym)(void * __restrict  __handle ,
                                                                                    char const   * __restrict  __name ) ;
#line 83
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
#line 154 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static int vl_exit___0(lt_user_data loader_data  __attribute__((__unused__)) ) 
{ 


  {
#line 157
  vtable___0 = (lt_dlvtable *)((void *)0);
#line 158
  return (0);
}
}
#line 165 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static lt_module vm_open___0(lt_user_data loader_data  __attribute__((__unused__)) ,
                             char const   *filename , lt_dladvise advise ) 
{ 
  int module_flags ;
  lt_module module ;
  char *tmp ;

  {
#line 169
  module_flags = 1;
#line 172
  if (advise) {
#line 177
    if (advise->is_symglobal) {
#line 178
      module_flags |= 256;
    }
#line 187
    if (advise->is_symlocal) {
#line 188
      module_flags = module_flags;
    }
  }
  {
#line 201
  module = dlopen(filename, module_flags);
  }
#line 203
  if (! module) {
    {
#line 205
    tmp = dlerror();
#line 205
    lt__set_last_error((char const   *)tmp);
    }
  }
#line 208
  return (module);
}
}
#line 214 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static int vm_close___0(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ) 
{ 
  int errors ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 217
  errors = 0;
#line 219
  tmp___0 = dlclose(module);
  }
#line 219
  if (tmp___0 != 0) {
    {
#line 221
    tmp = dlerror();
#line 221
    lt__set_last_error((char const   *)tmp);
#line 222
    errors ++;
    }
  }
#line 225
  return (errors);
}
}
#line 231 "/home/wslee/benchmarks/textformat/dico-2.0/libltdl/loaders/dlopen.c"
static void *vm_sym___0(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ,
                        char const   *name ) 
{ 
  void *address ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 234
  tmp = dlsym((void */* __restrict  */)module, (char const   */* __restrict  */)name);
#line 234
  address = tmp;
  }
#line 236
  if (! address) {
    {
#line 238
    tmp___0 = dlerror();
#line 238
    lt__set_last_error((char const   *)tmp___0);
    }
  }
#line 241
  return (address);
}
}
#line 74 "./dicod.h"
char const   *program_version ;
#line 343
void dicod_capa_register(char const   *name , struct dicod_command *cmd___6 , int (*init)(void * ) ,
                         void *closure ) ;
#line 364
void register_xversion(void) ;
#line 381 "./dicod.h"
struct udb_def text_udb_def  ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/xversion.c"
static void dicod_xversion(dico_stream_t str , int argc , char **argv ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 22
  stream_writez(str, (char *)"110 ");
#line 23
  stream_writez(str, (char *)program_version);
#line 24
  dico_stream_write(str, (void const   *)"\r\n", (size_t )2);
  }
#line 25
  return;
}
}
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/xversion.c"
static struct dicod_command cmd[2]  = {      {(char *)"XVERSION", 1, 1, (char *)((void *)0), (char *)"show implementation and version info",
      & dicod_xversion}, 
        {(char *)((void *)0), 0, 0, (char *)0, (char *)0, (void (*)(dico_stream_t str ,
                                                                 int argc , char **argv ))0}};
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/xversion.c"
void register_xversion(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 35
  dicod_capa_register("xversion", cmd, (int (*)(void * ))((void *)0), (void *)0);
  }
#line 36
  return;
}
}
#line 72 "./dicod.h"
unsigned int inactivity_timeout ;
#line 361
void register_xidle(void) ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/xidle.c"
static void dicod_xidle(dico_stream_t str , int argc , char **argv ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 22
  stream_printf(str, "110 %lu second(s)\r\n", inactivity_timeout);
  }
#line 23
  return;
}
}
#line 28 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/xidle.c"
static struct dicod_command cmd___0[2]  = {      {(char *)"XIDLE", 1, 1, (char *)((void *)0), (char *)"report inactivity timeout, reset idle timer",
      & dicod_xidle}, 
        {(char *)((void *)0), 0, 0, (char *)0, (char *)0, (void (*)(dico_stream_t str ,
                                                                 int argc , char **argv ))0}};
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/xidle.c"
void register_xidle(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 33
  dicod_capa_register("xidle", cmd___0, (int (*)(void * ))((void *)0), (void *)0);
  }
#line 34
  return;
}
}
#line 219 "./dicod.h"
void ( /* format attribute */  config_error)(dicod_locus_t *locus___0 , int errcode ,
                                             char const   *fmt  , ...) ;
#line 387
void udb_init(void) ;
#line 388
int udb_create(dicod_user_db_t *pdb , char const   *urlstr , char const   *qpw , char const   *qgrp ,
               dicod_locus_t *locus___0 ) ;
#line 392
int udb_open(dicod_user_db_t db ) ;
#line 393
int udb_close(dicod_user_db_t db ) ;
#line 394
int udb_get_password(dicod_user_db_t db , char const   *key , char **pass ) ;
#line 395
int udb_get_groups(dicod_user_db_t db , char const   *key , dico_list_t *groups ) ;
#line 396
void udp_define(struct udb_def *dptr ) ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/udb.c"
int udb_open(dicod_user_db_t db ) 
{ 
  int tmp ;

  {
#line 33
  if (! db) {
#line 34
    return (1);
  }
#line 35
  if (! db->_db_open) {
#line 36
    return (0);
  }
  {
#line 37
  tmp = (*(db->_db_open))(& db->handle, db->url);
  }
#line 37
  return (tmp);
}
}
#line 40 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/udb.c"
int udb_close(dicod_user_db_t db ) 
{ 
  int rc ;

  {
#line 45
  if (! db->_db_close) {
#line 46
    rc = 0;
  } else {
    {
#line 48
    rc = (*(db->_db_close))(db->handle);
    }
  }
#line 49
  db->handle = (void *)0;
#line 50
  return (rc);
}
}
#line 53 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/udb.c"
int udb_get_password(dicod_user_db_t db , char const   *key , char **pass ) 
{ 
  int tmp ;

  {
  {
#line 56
  tmp = (*(db->_db_get_password))(db->handle, db->qpw, key, pass);
  }
#line 56
  return (tmp);
}
}
#line 59 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/udb.c"
int udb_get_groups(dicod_user_db_t db , char const   *key , dico_list_t *groups ) 
{ 
  int tmp ;

  {
  {
#line 62
  tmp = (*(db->_db_get_groups))(db->handle, db->qgrp, key, groups);
  }
#line 62
  return (tmp);
}
}
#line 65 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/udb.c"
dico_list_t udb_def_list  ;
#line 67 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/udb.c"
static int udb_def_cmp(void const   *item , void *data ) 
{ 
  struct udb_def  const  *def ;
  char const   *proto ;
  int tmp ;

  {
  {
#line 70
  def = (struct udb_def  const  *)item;
#line 71
  proto = (char const   *)data;
#line 72
  tmp = strcmp((char const   *)def->proto, proto);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/udb.c"
void udp_define(struct udb_def *dptr ) 
{ 


  {
#line 78
  if (! udb_def_list) {
    {
#line 79
    udb_def_list = xdico_list_create();
#line 80
    dico_list_set_comparator(udb_def_list, & udb_def_cmp);
    }
  }
  {
#line 82
  xdico_list_append(udb_def_list, (void *)dptr);
  }
#line 83
  return;
}
}
#line 85 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/udb.c"
int udb_create(dicod_user_db_t *pdb , char const   *urlstr , char const   *qpw , char const   *qgrp ,
               dicod_locus_t *locus___0 ) 
{ 
  dico_url_t url ;
  int rc ;
  struct udb_def *def ;
  struct dicod_user_db *uptr ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 95
  rc = dico_url_parse(& url, urlstr);
  }
#line 96
  if (rc) {
    {
#line 97
    tmp = gettext("%s: invalid URL");
#line 97
    config_error(locus___0, 0, (char const   *)tmp, urlstr);
    }
#line 98
    return (1);
  }
  {
#line 101
  tmp___0 = dico_list_locate(udb_def_list, (void *)url->proto);
#line 101
  def = (struct udb_def *)tmp___0;
  }
#line 102
  if (! def) {
    {
#line 103
    tmp___1 = gettext("%s: invalid URL: unknown protocol");
#line 103
    config_error(locus___0, 0, (char const   *)tmp___1, urlstr);
#line 104
    dico_url_destroy(& url);
    }
#line 105
    return (1);
  }
  {
#line 108
  tmp___2 = xzalloc((size_t )sizeof(*uptr));
#line 108
  uptr = (struct dicod_user_db *)tmp___2;
#line 110
  uptr->url = url;
#line 111
  uptr->qpw = qpw;
#line 112
  uptr->qgrp = qgrp;
#line 113
  uptr->_db_open = def->_db_open;
#line 114
  uptr->_db_close = def->_db_close;
#line 115
  uptr->_db_get_password = def->_db_get_password;
#line 116
  uptr->_db_get_groups = def->_db_get_groups;
#line 118
  *pdb = uptr;
  }
#line 119
  return (0);
}
}
#line 122 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/udb.c"
void udb_init(void) 
{ 


  {
  {
#line 125
  udp_define(& text_udb_def);
  }
#line 126
  return;
}
}
#line 497 "./dicod.h"
void stratcl_add_word(dico_list_t list , char const   *word ) ;
#line 498
void stratcl_add_cmp(dico_list_t list , enum cmp_op op , size_t len ) ;
#line 499
void stratcl_add_disable(dico_list_t list ) ;
#line 500
int stratcl_check_word(dico_list_t list , char const   *word ) ;
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stratcl.c"
void stratcl_add_word(dico_list_t list , char const   *word ) 
{ 
  struct stratcl *sp ;
  void *tmp ;

  {
  {
#line 41
  tmp = xmalloc((size_t )sizeof(*sp));
#line 41
  sp = (struct stratcl *)tmp;
#line 42
  sp->type = (enum stratcl_type )1;
#line 43
  sp->v.word = xstrdup(word);
#line 44
  xdico_list_append(list, (void *)sp);
  }
#line 45
  return;
}
}
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stratcl.c"
void stratcl_add_cmp(dico_list_t list , enum cmp_op op , size_t len ) 
{ 
  struct stratcl *sp ;
  void *tmp ;

  {
  {
#line 50
  tmp = xmalloc((size_t )sizeof(*sp));
#line 50
  sp = (struct stratcl *)tmp;
#line 51
  sp->type = (enum stratcl_type )2;
#line 52
  sp->v.wl.op = op;
#line 53
  sp->v.wl.len = len;
#line 54
  xdico_list_append(list, (void *)sp);
  }
#line 55
  return;
}
}
#line 57 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stratcl.c"
void stratcl_add_disable(dico_list_t list ) 
{ 
  struct stratcl *sp ;
  void *tmp ;

  {
  {
#line 60
  tmp = xmalloc((size_t )sizeof(*sp));
#line 60
  sp = (struct stratcl *)tmp;
#line 61
  sp->type = (enum stratcl_type )0;
#line 62
  xdico_list_append(list, (void *)sp);
  }
#line 63
  return;
}
}
#line 71 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stratcl.c"
static int check_word(void *item , void *data ) 
{ 
  struct stratcl *sp ;
  struct stratcl_check *cp ;
  int tmp ;

  {
#line 74
  sp = (struct stratcl *)item;
#line 75
  cp = (struct stratcl_check *)data;
  {
#line 78
  if ((unsigned int )sp->type == 0U) {
#line 78
    goto case_0;
  }
#line 82
  if ((unsigned int )sp->type == 1U) {
#line 82
    goto case_1;
  }
#line 86
  if ((unsigned int )sp->type == 2U) {
#line 86
    goto case_2;
  }
#line 77
  goto switch_break;
  case_0: /* CIL Label */ 
#line 79
  cp->res = 1;
#line 80
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 83
  tmp = strcmp((char const   *)sp->v.word, cp->word);
#line 83
  cp->res = tmp == 0;
  }
#line 84
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 88
  if ((unsigned int )sp->v.wl.op == 0U) {
#line 88
    goto case_0___0;
  }
#line 92
  if ((unsigned int )sp->v.wl.op == 1U) {
#line 92
    goto case_1___0;
  }
#line 96
  if ((unsigned int )sp->v.wl.op == 2U) {
#line 96
    goto case_2___0;
  }
#line 100
  if ((unsigned int )sp->v.wl.op == 3U) {
#line 100
    goto case_3;
  }
#line 104
  if ((unsigned int )sp->v.wl.op == 4U) {
#line 104
    goto case_4;
  }
#line 108
  if ((unsigned int )sp->v.wl.op == 5U) {
#line 108
    goto case_5;
  }
#line 87
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 89
  cp->res = cp->len == sp->v.wl.len;
#line 90
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 93
  cp->res = cp->len != sp->v.wl.len;
#line 94
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 97
  cp->res = cp->len < sp->v.wl.len;
#line 98
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 101
  cp->res = cp->len <= sp->v.wl.len;
#line 102
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 105
  cp->res = cp->len > sp->v.wl.len;
#line 106
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 109
  cp->res = cp->len >= sp->v.wl.len;
  switch_break___0: /* CIL Label */ ;
  }
#line 111
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 113
  return (cp->res);
}
}
#line 116 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stratcl.c"
int stratcl_check_word(dico_list_t list , char const   *word ) 
{ 
  struct stratcl_check s ;

  {
#line 121
  if (! list) {
#line 122
    return (0);
  }
  {
#line 123
  s.word = word;
#line 124
  s.len = strlen(word);
#line 125
  s.res = 0;
#line 126
  dico_list_iterate(list, & check_word, (void *)(& s));
  }
#line 127
  return (s.res);
}
}
#line 83 "./dicod.h"
int timing_option ;
#line 109 "./dicod.h"
struct dico_stat current_stat  ;
#line 109 "./dicod.h"
struct dico_stat total_stat  ;
#line 436
void begin_timing(char const   *name ) ;
#line 437
void report_timing(dico_stream_t stream , xdico_timer_t t , struct dico_stat *sp ) ;
#line 439
void report_current_timing(dico_stream_t stream , char const   *name ) ;
#line 21 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stat.c"
void clear_stats(void) 
{ 


  {
  {
#line 24
  total_stat.defines += current_stat.defines;
#line 25
  total_stat.matches += current_stat.matches;
#line 26
  total_stat.compares += current_stat.compares;
#line 27
  memset((void *)(& current_stat), 0, (size_t )sizeof(current_stat));
  }
#line 28
  return;
}
}
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stat.c"
void begin_timing(char const   *name ) 
{ 


  {
#line 33
  if (timing_option) {
    {
#line 34
    timer_start(name);
#line 35
    clear_stats();
    }
  }
#line 37
  return;
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stat.c"
void report_timing(dico_stream_t stream , xdico_timer_t t , struct dico_stat *sp ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 42
  dico_stream_write(stream, (void const   *)" [", (size_t )2);
  }
#line 43
  if (sp) {
    {
#line 44
    stream_printf(stream, "d/m/c = %lu/%lu/%lu ", sp->defines, sp->matches, sp->compares);
    }
  }
  {
#line 48
  tmp = timer_get_real(t);
#line 48
  timer_format_time(stream, tmp);
#line 49
  dico_stream_write(stream, (void const   *)"r ", (size_t )2);
#line 50
  tmp___0 = timer_get_user(t);
#line 50
  timer_format_time(stream, tmp___0);
#line 51
  dico_stream_write(stream, (void const   *)"u ", (size_t )2);
#line 52
  tmp___1 = timer_get_system(t);
#line 52
  timer_format_time(stream, tmp___1);
#line 53
  dico_stream_write(stream, (void const   *)"s]", (size_t )2);
  }
#line 54
  return;
}
}
#line 56 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/stat.c"
void report_current_timing(dico_stream_t stream , char const   *name ) 
{ 
  xdico_timer_t t ;
  xdico_timer_t tmp ;

  {
#line 59
  if (timing_option) {
    {
#line 60
    tmp = timer_stop(name);
#line 60
    t = tmp;
#line 61
    report_timing(stream, t, & current_stat);
#line 62
    clear_stats();
    }
  }
#line 64
  return;
}
}
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 441 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 465
extern int pause(void) ;
#line 558
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execv)(char const   *__path ,
                                                                                  char * const  *__argv ) ;
#line 614
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 623
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 953
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 115
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 197
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 204
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 214
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 370 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 126
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 60 "./dicod.h"
int foreground ;
#line 61
int single_process ;
#line 63
char *config_file ;
#line 65
char *pidfile_name ;
#line 66
dico_list_t listen_addr ;
#line 67
uid_t user_id ;
#line 68
gid_t group_id ;
#line 69
dico_list_t group_list ;
#line 70
unsigned int max_children ;
#line 71
unsigned int shutdown_timeout ;
#line 90 "./dicod.h"
unsigned long total_forks  ;
#line 98 "./dicod.h"
struct sockaddr server_addr  ;
#line 99 "./dicod.h"
int server_addrlen  ;
#line 100 "./dicod.h"
struct sockaddr client_addr  ;
#line 101 "./dicod.h"
int client_addrlen  ;
#line 250
int dicod_acl_check(dicod_acl_t acl , int result ) ;
#line 258
dicod_acl_t connect_acl ;
#line 298
void dicod_server(int argc , char **argv ) ;
#line 300
int dicod_loop(dico_stream_t str ) ;
#line 304
void dicod_server_cleanup(void) ;
#line 460
void run_lint(void) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
struct dicod_server *srvtab  ;
#line 28 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
size_t srvcount  ;
#line 29 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
int fdmax  ;
#line 31 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
pid_t *childtab  ;
#line 32 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
unsigned long num_children  ;
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
static int address_family_to_domain(int family ) 
{ 


  {
  {
#line 42
  if (family == 1) {
#line 42
    goto case_1;
  }
#line 45
  if (family == 2) {
#line 45
    goto case_2;
  }
#line 48
  goto switch_default;
  case_1: /* CIL Label */ 
#line 43
  return (1);
  case_2: /* CIL Label */ 
#line 46
  return (2);
  switch_default: /* CIL Label */ 
  {
#line 49
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 53 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
void open_sockets(void) 
{ 
  size_t i ;
  dico_iterator_t itr ;
  sockaddr_union_t *sp ;
  struct stat st ;
  int t ;
  int socklen ;
  char *p ;
  struct sockaddr_in *sp___0 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int fd ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 64
  srvcount = dico_list_count(listen_addr);
  }
#line 65
  if (srvcount == 0U) {
    {
#line 67
    tmp = xmalloc((size_t )sizeof(*sp___0));
#line 67
    sp___0 = (struct sockaddr_in *)tmp;
    }
#line 69
    if (! listen_addr) {
      {
#line 70
      listen_addr = xdico_list_create();
      }
    }
    {
#line 71
    sp___0->sin_family = (sa_family_t )2;
#line 72
    sp___0->sin_addr.s_addr = (in_addr_t )0;
#line 73
    sp___0->sin_port = htons((uint16_t )2628);
#line 74
    xdico_list_append(listen_addr, (void *)sp___0);
#line 75
    srvcount = (size_t )1;
    }
  }
  {
#line 77
  tmp___0 = xcalloc(srvcount, (size_t )sizeof(*(srvtab + 0)));
#line 77
  srvtab = (struct dicod_server *)tmp___0;
#line 78
  fdmax = 0;
#line 79
  itr = xdico_list_iterator(listen_addr);
#line 80
  i = (size_t )0;
#line 80
  tmp___1 = dico_iterator_first(itr);
#line 80
  sp = (sockaddr_union_t *)tmp___1;
  }
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! sp) {
#line 80
      goto while_break;
    }
    {
#line 82
    tmp___3 = address_family_to_domain((int )sp->s.sa_family);
#line 82
    tmp___4 = socket(tmp___3, 1, 0);
#line 82
    fd = tmp___4;
    }
#line 84
    if (fd == -1) {
      {
#line 85
      tmp___5 = __errno_location();
#line 85
      dico_log(4, *tmp___5, "socket");
      }
#line 86
      goto __Cont;
    }
    {
#line 90
    if ((int )sp->s.sa_family == 1) {
#line 90
      goto case_1;
    }
#line 115
    if ((int )sp->s.sa_family == 2) {
#line 115
      goto case_2;
    }
#line 89
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 91
    tmp___13 = stat((char const   */* __restrict  */)(sp->s_un.sun_path), (struct stat */* __restrict  */)(& st));
    }
#line 91
    if (tmp___13) {
      {
#line 92
      tmp___8 = __errno_location();
      }
#line 92
      if (*tmp___8 != 2) {
        {
#line 93
        tmp___6 = gettext("file %s exists but cannot be stat\'d");
#line 93
        tmp___7 = __errno_location();
#line 93
        dico_log(4, *tmp___7, (char const   *)tmp___6, sp->s_un.sun_path);
#line 96
        close(fd);
        }
#line 97
        goto __Cont;
      }
    } else
#line 99
    if (! ((st.st_mode & 61440U) == 49152U)) {
      {
#line 100
      tmp___9 = gettext("file %s is not a socket");
#line 100
      dico_log(4, 0, (char const   *)tmp___9, sp->s_un.sun_path);
#line 103
      close(fd);
      }
#line 104
      goto __Cont;
    } else {
      {
#line 105
      tmp___12 = unlink((char const   *)(sp->s_un.sun_path));
      }
#line 105
      if (tmp___12) {
        {
#line 106
        tmp___10 = gettext("cannot unlink file %s");
#line 106
        tmp___11 = __errno_location();
#line 106
        dico_log(4, *tmp___11, (char const   *)tmp___10, sp->s_un.sun_path);
#line 109
        close(fd);
        }
#line 110
        goto __Cont;
      }
    }
#line 112
    socklen = (int )sizeof(sp->s_un);
#line 113
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 116
    t = 1;
#line 117
    setsockopt(fd, 1, 2, (void const   *)(& t), (socklen_t )sizeof(t));
#line 118
    socklen = (int )sizeof(sp->s_in);
    }
#line 119
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 122
    tmp___15 = bind(fd, (struct sockaddr  const  */* __restrict  */)(& sp->s), (socklen_t )socklen);
    }
#line 122
    if (tmp___15 == -1) {
      {
#line 123
      p = sockaddr_to_astr((struct sockaddr  const  *)(& sp->s), socklen);
#line 124
      tmp___14 = __errno_location();
#line 124
      dico_log(4, *tmp___14, "cannot bind to %s", p);
#line 125
      free((void *)p);
#line 126
      close(fd);
      }
#line 127
      goto __Cont;
    }
    {
#line 130
    tmp___17 = listen(fd, 8);
    }
#line 130
    if (tmp___17 == -1) {
      {
#line 131
      p = sockaddr_to_astr((struct sockaddr  const  *)(& sp->s), socklen);
#line 132
      tmp___16 = __errno_location();
#line 132
      dico_log(4, *tmp___16, "cannot listen on %s", p);
#line 133
      free((void *)p);
#line 134
      close(fd);
      }
#line 135
      goto __Cont;
    }
#line 138
    (srvtab + i)->addr = & sp->s;
#line 139
    (srvtab + i)->addrlen = socklen;
#line 140
    (srvtab + i)->fd = fd;
#line 141
    i ++;
#line 142
    if (fd > fdmax) {
#line 143
      fdmax = fd;
    }
    __Cont: /* CIL Label */ 
    {
#line 80
    tmp___2 = dico_iterator_next(itr);
#line 80
    sp = (sockaddr_union_t *)tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  dico_iterator_destroy(& itr);
#line 146
  srvcount = i;
  }
#line 148
  if (srvcount == 0U) {
    {
#line 149
    tmp___18 = gettext("No sockets opened");
#line 149
    dico_die(1, 4, 0, (char const   *)tmp___18);
    }
  }
#line 150
  return;
}
}
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
void close_sockets(void) 
{ 
  size_t i ;

  {
#line 157
  i = (size_t )0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i < srvcount)) {
#line 157
      goto while_break;
    }
    {
#line 158
    close((srvtab + i)->fd);
#line 157
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  free((void *)srvtab);
#line 160
  srvtab = (struct dicod_server *)((void *)0);
#line 161
  srvcount = (size_t )0;
#line 162
  fdmax = 0;
  }
#line 163
  return;
}
}
#line 166 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
unsigned long find_pid(pid_t pid ) 
{ 
  unsigned long i ;

  {
#line 170
  i = 0UL;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < (unsigned long )max_children)) {
#line 170
      goto while_break;
    }
#line 171
    if (*(childtab + i) == pid) {
#line 172
      return (i);
    }
#line 170
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (0xffffffffffffffffUL);
}
}
#line 176 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
void register_child(pid_t pid ) 
{ 
  unsigned long i ;
  unsigned long tmp ;

  {
  {
#line 179
  tmp = find_pid(0);
#line 179
  i = tmp;
  }
#line 180
  if (i != 0xffffffffffffffffUL) {
#line 181
    *(childtab + i) = pid;
  }
#line 182
  num_children ++;
#line 183
  total_forks ++;
#line 184
  return;
}
}
#line 186 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
static void print_status(pid_t pid , int status___0 , int expect_term ) 
{ 
  char *tmp ;
  union __anonunion_74 __constr_expr_0 ;
  char *tmp___0 ;
  union __anonunion_75 __constr_expr_1 ;
  int prio ;
  union __anonunion_76 __constr_expr_2 ;
  union __anonunion_77 __constr_expr_3 ;
  char *tmp___1 ;
  union __anonunion_78 __constr_expr_4 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  union __anonunion_79 __constr_expr_5 ;
  union __anonunion_80 __constr_expr_6 ;
  union __anonunion_81 __constr_expr_7 ;
  union __anonunion_82 __constr_expr_8 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 189
  __constr_expr_8.__in = status___0;
#line 189
  if ((__constr_expr_8.__i & 127) == 0) {
#line 190
    __constr_expr_1.__in = status___0;
#line 190
    if ((__constr_expr_1.__i & 65280) >> 8 == 0) {
      {
#line 191
      tmp = gettext("%lu exited successfully");
#line 191
      dico_log(0, 0, (char const   *)tmp, (unsigned long )pid);
      }
    } else {
      {
#line 195
      __constr_expr_0.__in = status___0;
#line 195
      tmp___0 = gettext("%lu failed with status %d");
#line 195
      dico_log(4, 0, (char const   *)tmp___0, (unsigned long )pid, (__constr_expr_0.__i & 65280) >> 8);
      }
    }
  } else {
#line 199
    __constr_expr_7.__in = status___0;
#line 199
    if ((int )((signed char )((__constr_expr_7.__i & 127) + 1)) >> 1 > 0) {
#line 202
      if (expect_term) {
#line 202
        __constr_expr_2.__in = status___0;
#line 202
        if ((__constr_expr_2.__i & 127) == 15) {
#line 203
          prio = 0;
        } else {
#line 205
          prio = 4;
        }
      } else {
#line 205
        prio = 4;
      }
      {
#line 206
      __constr_expr_3.__in = status___0;
#line 206
      tmp___1 = gettext("%lu terminated on signal %d");
#line 206
      dico_log(prio, 0, (char const   *)tmp___1, (unsigned long )pid, __constr_expr_3.__i & 127);
      }
    } else {
#line 209
      __constr_expr_6.__in = status___0;
#line 209
      if ((__constr_expr_6.__i & 255) == 127) {
        {
#line 210
        __constr_expr_4.__in = status___0;
#line 210
        tmp___2 = gettext("%lu stopped on signal %d");
#line 210
        dico_log(4, 0, (char const   *)tmp___2, (unsigned long )pid, (__constr_expr_4.__i & 65280) >> 8);
        }
      } else {
#line 214
        __constr_expr_5.__in = status___0;
#line 214
        if (__constr_expr_5.__i & 128) {
          {
#line 215
          tmp___3 = gettext("%lu dumped core");
#line 215
          dico_log(4, 0, (char const   *)tmp___3, (unsigned long )pid);
          }
        } else {
          {
#line 218
          tmp___4 = gettext("%lu terminated with unrecognized status");
#line 218
          dico_log(4, 0, (char const   *)tmp___4, (unsigned long )pid);
          }
        }
      }
    }
  }
#line 220
  return;
}
}
#line 223 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
void cleanup_children(int term ) 
{ 
  pid_t pid ;
  int status___0 ;
  unsigned long i ;
  unsigned long tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 229
    pid = waitpid(-1, & status___0, 1);
    }
#line 229
    if (! (pid > 0)) {
#line 229
      goto while_break;
    }
    {
#line 230
    tmp = find_pid(pid);
#line 230
    i = tmp;
    }
#line 231
    if (i == 0xffffffffffffffffUL) {
      {
#line 232
      dico_log(1, 0, "subprocess %lu finished", (unsigned long )pid);
      }
    } else {
      {
#line 235
      print_status(pid, status___0, term);
      }
    }
#line 237
    *(childtab + i) = 0;
#line 238
    num_children --;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 244 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
void stop_all(int sig ) 
{ 
  unsigned long i ;

  {
#line 249
  if (! childtab) {
#line 250
    return;
  }
#line 251
  i = 0UL;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < (unsigned long )max_children)) {
#line 251
      goto while_break;
    }
#line 252
    if (*(childtab + i)) {
      {
#line 253
      kill(sig, *(childtab + i));
      }
    }
#line 251
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 256 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
void stop_children(void) 
{ 
  int i ;

  {
#line 260
  if (! childtab) {
#line 261
    return;
  }
  {
#line 262
  stop_all(15);
#line 263
  i = 0;
  }
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! ((unsigned int )i < shutdown_timeout)) {
#line 263
      goto while_break;
    }
    {
#line 264
    cleanup_children(1);
    }
#line 265
    if (num_children == 0UL) {
#line 266
      return;
    }
    {
#line 267
    sleep(1U);
#line 263
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 269
  stop_all(9);
  }
#line 270
  return;
}
}
#line 276 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
void check_pidfile(char *name ) 
{ 
  unsigned long pid ;
  FILE *fp ;
  FILE *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 280
  tmp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
#line 280
  fp = tmp;
  }
#line 282
  if (! fp) {
    {
#line 283
    tmp___0 = __errno_location();
    }
#line 283
    if (*tmp___0 == 2) {
#line 284
      return;
    }
    {
#line 285
    tmp___1 = gettext("Cannot open pidfile `%s\'");
#line 285
    tmp___2 = __errno_location();
#line 285
    dico_die(1, 4, *tmp___2, (char const   *)tmp___1, name);
    }
  }
  {
#line 287
  tmp___6 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lu",
                   & pid);
  }
#line 287
  if (tmp___6 != 1) {
    {
#line 288
    tmp___3 = gettext("Cannot get pid from pidfile `%s\'");
#line 288
    dico_log(4, 0, (char const   *)tmp___3, name);
    }
  } else {
    {
#line 290
    tmp___5 = kill((__pid_t )pid, 0);
    }
#line 290
    if (tmp___5 == 0) {
      {
#line 291
      tmp___4 = gettext("%s appears to run with pid %lu. If it does not, remove `%s\' and retry.");
#line 291
      dico_die(1, 4, 0, (char const   *)tmp___4, dico_program_name, pid, name);
      }
    }
  }
  {
#line 299
  fclose(fp);
#line 300
  tmp___9 = unlink((char const   *)name);
  }
#line 300
  if (tmp___9) {
    {
#line 301
    tmp___7 = gettext("Cannot unlink pidfile `%s\'");
#line 301
    tmp___8 = __errno_location();
#line 301
    dico_die(1, 4, *tmp___8, (char const   *)tmp___7, name);
    }
  }
#line 302
  return;
}
}
#line 304 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
void create_pidfile(char *name ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  __pid_t tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 307
  tmp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"w");
#line 307
  fp = tmp;
  }
#line 309
  if (! fp) {
    {
#line 310
    tmp___0 = gettext("Cannot create pidfile `%s\'");
#line 310
    tmp___1 = __errno_location();
#line 310
    dico_die(1, 4, *tmp___1, (char const   *)tmp___0, name);
    }
  }
  {
#line 311
  tmp___2 = getpid();
#line 311
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lu", (unsigned long )tmp___2);
#line 312
  fclose(fp);
  }
#line 313
  return;
}
}
#line 315 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
void remove_pidfile(char *name ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;

  {
  {
#line 318
  tmp___1 = unlink((char const   *)name);
  }
#line 318
  if (tmp___1) {
    {
#line 319
    tmp = gettext("Cannot unlink pidfile `%s\'");
#line 319
    tmp___0 = __errno_location();
#line 319
    dico_log(4, *tmp___0, (char const   *)tmp, name);
    }
  }
#line 320
  return;
}
}
#line 323 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
int restart  ;
#line 324 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
int stop  ;
#line 325 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
int need_cleanup  ;
#line 327 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
static void sig_stop(int sig ) 
{ 


  {
#line 330
  stop = 1;
#line 331
  return;
}
}
#line 333 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
static void sig_restart(int sig ) 
{ 


  {
#line 336
  restart = 1;
#line 337
  return;
}
}
#line 339 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
static void sig_child(int sig ) 
{ 


  {
#line 342
  need_cleanup = 1;
#line 343
  return;
}
}
#line 352 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
int handle_connection(int n ) 
{ 
  int status___0 ;
  int connfd ;
  int listenfd ;
  int *tmp ;
  int *tmp___0 ;
  char *p ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int status___1 ;
  dico_stream_t str ;
  pid_t pid ;
  __pid_t tmp___4 ;
  int *tmp___5 ;
  dico_stream_t str___0 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 355
  status___0 = 0;
#line 357
  listenfd = (srvtab + n)->fd;
#line 359
  server_addr = *((srvtab + n)->addr);
#line 360
  server_addrlen = (srvtab + n)->addrlen;
#line 362
  client_addrlen = (int )sizeof(client_addr);
#line 363
  connfd = accept(listenfd, (struct sockaddr */* __restrict  */)(& client_addr), (socklen_t */* __restrict  */)(& client_addrlen));
  }
#line 365
  if (connfd == -1) {
    {
#line 366
    tmp = __errno_location();
    }
#line 366
    if (*tmp == 4) {
#line 367
      return (-1);
    }
    {
#line 368
    tmp___0 = __errno_location();
#line 368
    dico_log(4, *tmp___0, "accept");
    }
#line 369
    return (-1);
  }
  {
#line 373
  tmp___3 = dicod_acl_check(connect_acl, 1);
  }
#line 373
  if (tmp___3 == 0) {
    {
#line 374
    tmp___1 = sockaddr_to_astr((struct sockaddr  const  *)(& client_addr), client_addrlen);
#line 374
    p = tmp___1;
#line 375
    tmp___2 = gettext("connection from %s denied");
#line 375
    dico_log(2, 0, (char const   *)tmp___2, p);
#line 378
    free((void *)p);
#line 379
    write(connfd, (void const   *)"530 Access denied\r\n", (size_t )(sizeof("530 Access denied\r\n") - 1UL));
#line 380
    close(connfd);
    }
#line 381
    return (0);
  }
#line 384
  if (single_process) {
    {
#line 388
    str = dico_fd_io_stream_create(connfd, connfd);
#line 389
    dico_stream_set_buffer(str, (enum dico_buffer_type )1, (size_t )6144);
#line 390
    status___1 = dicod_loop(str);
#line 391
    dico_stream_close(str);
#line 392
    dico_stream_destroy(& str);
    }
  } else {
    {
#line 394
    tmp___4 = fork();
#line 394
    pid = tmp___4;
    }
#line 395
    if (pid == -1) {
      {
#line 396
      tmp___5 = __errno_location();
#line 396
      dico_log(4, *tmp___5, "fork");
#line 397
      write(connfd, (void const   *)"420 Server temporarily unavailable\r\n", (size_t )(sizeof("420 Server temporarily unavailable\r\n") - 1UL));
      }
    } else
#line 398
    if (pid == 0) {
      {
#line 402
      close(listenfd);
#line 404
      signal(15, (void (*)(int  ))0);
#line 405
      signal(3, (void (*)(int  ))0);
#line 406
      signal(2, (void (*)(int  ))0);
#line 407
      signal(17, (void (*)(int  ))0);
#line 408
      signal(1, (void (*)(int  ))0);
#line 410
      str___0 = dico_fd_io_stream_create(connfd, connfd);
#line 411
      dico_stream_set_buffer(str___0, (enum dico_buffer_type )1, (size_t )6144);
#line 412
      status___0 = dicod_loop(str___0);
#line 413
      dico_stream_close(str___0);
#line 414
      dico_stream_destroy(& str___0);
#line 415
      exit(status___0);
      }
    } else {
      {
#line 417
      register_child(pid);
      }
    }
  }
  {
#line 420
  close(connfd);
  }
#line 421
  return (status___0);
}
}
#line 424 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
static int pre_restart_lint_internal(void) 
{ 
  pid_t pid ;
  time_t ts ;
  char *tmp ;
  int *tmp___0 ;
  int status___0 ;
  pid_t n ;
  __pid_t tmp___1 ;
  char *tmp___2 ;
  union __anonunion_83 __constr_expr_9 ;
  char *tmp___3 ;
  union __anonunion_84 __constr_expr_10 ;
  char *tmp___4 ;
  time_t tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 429
  pid = fork();
  }
#line 430
  if (pid == 0) {
    {
#line 431
    run_lint();
    }
  } else
#line 432
  if (pid == -1) {
    {
#line 433
    tmp = gettext("fork failed");
#line 433
    tmp___0 = __errno_location();
#line 433
    dico_log(4, *tmp___0, (char const   *)tmp);
    }
#line 434
    return (1);
  }
  {
#line 437
  ts = time((time_t *)((void *)0));
  }
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 440
    tmp___1 = waitpid(pid, & status___0, 1);
#line 440
    n = tmp___1;
    }
#line 441
    if (n == pid) {
#line 443
      __constr_expr_10.__in = status___0;
#line 443
      if ((__constr_expr_10.__i & 127) == 0) {
#line 444
        __constr_expr_9.__in = status___0;
#line 444
        if ((__constr_expr_9.__i & 65280) >> 8 == 0) {
#line 446
          return (0);
        } else {
          {
#line 448
          tmp___2 = gettext("refusing to restart due to errors in configuration file");
#line 448
          dico_log(2, 0, (char const   *)tmp___2);
          }
#line 451
          return (1);
        }
      } else {
        {
#line 454
        tmp___3 = gettext("refusing to restart due to unexpected return status of configuration checker");
#line 454
        dico_log(2, 0, (char const   *)tmp___3);
#line 457
        print_status(pid, status___0, 0);
        }
#line 458
        return (1);
      }
    } else
#line 460
    if (pid == 0) {
      {
#line 461
      tmp___5 = time((time_t *)((void *)0));
      }
#line 461
      if (tmp___5 - ts > 5L) {
        {
#line 462
        tmp___4 = gettext("refusing to restart: configuration checker did not exit within 5 seconds");
#line 462
        dico_log(2, 0, (char const   *)tmp___4);
#line 466
        kill(pid, 9);
        }
#line 467
        goto while_break;
      }
    } else {
      {
#line 469
      tmp___9 = __errno_location();
      }
#line 469
      if (*tmp___9 == 4) {
#line 470
        goto while_continue;
      } else {
        {
#line 469
        tmp___10 = __errno_location();
        }
#line 469
        if (*tmp___10 == 11) {
#line 470
          goto while_continue;
        } else {
          {
#line 472
          tmp___6 = gettext("waitpid failed");
#line 472
          tmp___7 = __errno_location();
#line 472
          dico_log(4, *tmp___7, (char const   *)tmp___6);
#line 473
          tmp___8 = gettext("refusing to restart");
#line 473
          dico_log(2, 0, (char const   *)tmp___8);
#line 474
          kill(pid, 9);
          }
#line 475
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  return (1);
}
}
#line 481 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
static int pre_restart_lint(void) 
{ 
  int rc ;
  void (*sf)(int  ) ;

  {
  {
#line 487
  sf = signal(17, (void (*)(int  ))0);
#line 488
  rc = pre_restart_lint_internal();
#line 489
  signal(17, sf);
  }
#line 490
  return (rc);
}
}
#line 493 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
int server_loop(void) 
{ 
  size_t i ;
  fd_set fdset ;
  int __d0 ;
  int __d1 ;
  int rc ;
  fd_set rdset ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdset.fds_bits[0]): "memory");
#line 499
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  i = (size_t )0;
  {
#line 500
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 500
    if (! (i < srvcount)) {
#line 500
      goto while_break___0;
    }
#line 501
    fdset.fds_bits[(srvtab + i)->fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << (srvtab + i)->fd % (8 * (int )sizeof(__fd_mask ));
#line 500
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 503
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 507
    if (need_cleanup) {
      {
#line 508
      cleanup_children(0);
#line 509
      need_cleanup = 1;
      }
    }
#line 512
    if (num_children > (unsigned long )max_children) {
      {
#line 513
      tmp = gettext("too many children (%lu)");
#line 513
      dico_log(4, 0, (char const   *)tmp, num_children);
#line 514
      pause();
      }
#line 515
      goto __Cont;
    }
    {
#line 518
    rdset = fdset;
#line 519
    rc = select(fdmax + 1, (fd_set */* __restrict  */)(& rdset), (fd_set */* __restrict  */)((void *)0),
                (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 520
    if (rc == -1) {
      {
#line 520
      tmp___3 = __errno_location();
      }
#line 520
      if (*tmp___3 == 4) {
#line 521
        if (stop) {
#line 522
          goto while_break___1;
        } else
#line 523
        if (restart) {
          {
#line 524
          tmp___0 = pre_restart_lint();
          }
#line 524
          if (tmp___0 == 0) {
#line 525
            goto while_break___1;
          } else {
#line 527
            restart = 0;
          }
        }
#line 529
        goto __Cont;
      } else {
#line 520
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 530
    if (rc < 0) {
      {
#line 531
      tmp___1 = gettext("select error");
#line 531
      tmp___2 = __errno_location();
#line 531
      dico_log(5, *tmp___2, (char const   *)tmp___1);
      }
#line 532
      return (1);
    }
#line 535
    i = (size_t )0;
    {
#line 535
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 535
      if (! (i < srvcount)) {
#line 535
        goto while_break___2;
      }
#line 536
      if ((rdset.fds_bits[(srvtab + i)->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << (srvtab + i)->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 537
        handle_connection((int )i);
        }
      }
#line 535
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 539
  return (0);
}
}
#line 542 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/server.c"
void dicod_server(int argc , char **argv ) 
{ 
  int rc ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  int i ;
  char *tmp___11 ;
  long tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 547
  tmp = gettext("%s started");
#line 547
  dico_log(1, 0, (char const   *)tmp, program_version);
  }
#line 549
  if (user_id) {
    {
#line 549
    tmp___0 = switch_to_privs(user_id, group_id, group_list);
    }
#line 549
    if (tmp___0) {
      {
#line 550
      dico_die(1, 5, 0, "exiting");
      }
    }
  }
#line 552
  if (! foreground) {
    {
#line 553
    check_pidfile(pidfile_name);
    }
  }
  {
#line 555
  signal(15, & sig_stop);
#line 556
  signal(3, & sig_stop);
#line 557
  signal(2, & sig_stop);
#line 558
  signal(17, & sig_child);
  }
#line 559
  if ((int )*(*(argv + 0) + 0) != 47) {
    {
#line 560
    tmp___1 = gettext("dicod started without full file name");
#line 560
    dico_log(3, 0, (char const   *)tmp___1);
#line 561
    tmp___2 = gettext("restart (SIGHUP) will not work");
#line 561
    dico_log(3, 0, (char const   *)tmp___2);
#line 562
    signal(1, & sig_stop);
    }
  } else
#line 563
  if ((int )*(config_file + 0) != 47) {
    {
#line 564
    tmp___3 = gettext("configuration file is not given with a full file name");
#line 564
    dico_log(3, 0, (char const   *)tmp___3);
#line 565
    tmp___4 = gettext("restart (SIGHUP) will not work");
#line 565
    dico_log(3, 0, (char const   *)tmp___4);
#line 566
    signal(1, & sig_stop);
    }
  } else {
    {
#line 568
    signal(1, & sig_restart);
    }
  }
#line 570
  if (! foreground) {
    {
#line 571
    tmp___7 = daemon(0, 0);
    }
#line 571
    if (tmp___7 == -1) {
      {
#line 572
      tmp___5 = gettext("Cannot become a daemon");
#line 572
      tmp___6 = __errno_location();
#line 572
      dico_die(1, 5, *tmp___6, (char const   *)tmp___5);
      }
    }
    {
#line 574
    create_pidfile(pidfile_name);
    }
  }
  {
#line 577
  open_sockets();
  }
#line 578
  if (! single_process) {
    {
#line 579
    tmp___8 = xcalloc(max_children, (size_t )sizeof(*(childtab + 0)));
#line 579
    childtab = (pid_t *)tmp___8;
    }
  }
  {
#line 581
  rc = server_loop();
#line 583
  stop_children();
#line 584
  free((void *)childtab);
#line 585
  dicod_server_cleanup();
#line 586
  close_sockets();
  }
#line 588
  if (rc) {
    {
#line 589
    tmp___9 = gettext("Exit code = %d, last error status");
#line 589
    tmp___10 = __errno_location();
#line 589
    dico_log(2, *tmp___10, (char const   *)tmp___9, rc);
    }
  }
  {
#line 591
  remove_pidfile(pidfile_name);
  }
#line 593
  if (restart) {
    {
#line 596
    tmp___11 = gettext("%s restarting");
#line 596
    dico_log(1, 0, (char const   *)tmp___11, program_version);
#line 597
    tmp___12 = sysconf(4);
#line 597
    i = (int )tmp___12;
    }
    {
#line 597
    while (1) {
      while_continue: /* CIL Label */ ;
#line 597
      if (! (i > 2)) {
#line 597
        goto while_break;
      }
      {
#line 598
      close(i);
#line 597
      i --;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 599
    execv((char const   *)*(argv + 0), (char * const  *)argv);
#line 600
    tmp___13 = gettext("Cannot restart");
#line 600
    tmp___14 = __errno_location();
#line 600
    dico_die(127, 32772, *tmp___14, (char const   *)tmp___13);
    }
  } else {
    {
#line 602
    tmp___15 = gettext("%s terminating");
#line 602
    dico_log(1, 0, (char const   *)tmp___15, program_version);
    }
  }
  {
#line 603
  exit(rc);
  }
}
}
#line 370 "./dicod.h"
void register_regex(void) ;
#line 658 "../gnu/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 662
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 667
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 670
extern void regfree(regex_t *__preg ) ;
#line 25 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/regex.c"
static int regex_sel(int cmd___6 , char const   *word , char const   *dict_word ,
                     void *closure ) 
{ 
  struct regex_closure *rp ;
  int rc ;
  char errbuf[512] ;
  char *tmp ;
  int tmp___0 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 28
  rp = (struct regex_closure *)closure;
  {
#line 32
  if (cmd___6 == 0) {
#line 32
    goto case_0;
  }
#line 41
  if (cmd___6 == 1) {
#line 41
    goto case_1;
  }
#line 45
  if (cmd___6 == 2) {
#line 45
    goto case_2;
  }
#line 31
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 33
  rc = regcomp((regex_t */* __restrict  */)(& rp->reg), (char const   */* __restrict  */)word,
               rp->flags);
  }
#line 34
  if (rc) {
    {
#line 36
    regerror(rc, (regex_t const   */* __restrict  */)(& rp->reg), (char */* __restrict  */)(errbuf),
             (size_t )sizeof(errbuf));
#line 37
    tmp = gettext("Regex error: %s");
#line 37
    dico_log(4, 0, (char const   *)tmp, errbuf);
    }
  }
#line 39
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 42
  tmp___0 = regexec((regex_t const   */* __restrict  */)(& rp->reg), (char const   */* __restrict  */)dict_word,
                    (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 42
  rc = tmp___0 == 0;
  }
#line 43
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 46
  rc = 0;
#line 47
  regfree(& rp->reg);
  }
#line 48
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 50
  return (rc);
}
}
#line 53 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/regex.c"
static struct regex_closure ext_closure  =    {1 | (1 << 1), {(unsigned char *)0, 0UL, 0UL, 0UL, (char *)0, (unsigned char *)0,
                   0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}};
#line 57 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/regex.c"
static struct regex_closure basic_closure  =    {1 | (1 << 1), {(unsigned char *)0, 0UL, 0UL, 0UL, (char *)0, (unsigned char *)0,
                   0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U}};
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/regex.c"
static struct dico_strategy re_strat  =    {(char *)"re", (char *)"POSIX 1003.2 (modern) regular expressions", & regex_sel,
    (void *)(& ext_closure), 0, (struct dico_list *)0};
#line 68 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/regex.c"
static struct dico_strategy regex_strat  =    {(char *)"regexp", (char *)"Old (basic) regular expressions", & regex_sel, (void *)(& basic_closure),
    0, (struct dico_list *)0};
#line 75 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/regex.c"
void register_regex(void) 
{ 


  {
  {
#line 78
  dico_strategy_add((dico_strategy_t const   )(& re_strat));
#line 79
  dico_strategy_add((dico_strategy_t const   )(& regex_strat));
  }
#line 80
  return;
}
}
#line 414 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execvp)(char const   *__file ,
                                                                                   char * const  *__argv ) ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 283
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 382
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 846
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 852
extern int pclose(FILE *__stream ) ;
#line 104 "../include/xdico.h"
int debug_level ;
#line 105
int debug_source_info ;
#line 106
dico_stream_t debug_stream ;
#line 62 "./dicod.h"
int log_to_stderr ;
#line 88
char const   *preprocessor ;
#line 89
char *debug_level_str ;
#line 314
void dicod_log_setup(void) ;
#line 316
void dicod_log_encode_envar(void) ;
#line 451
void include_path_setup(void) ;
#line 452
void add_include_dir(char *dir ) ;
#line 453
int pp_init(char const   *name ) ;
#line 454
void pp_done(void) ;
#line 455
int preprocess_config(char const   *extpp ) ;
#line 456
void pp_make_argcv(int *pargc , char const   ***pargv ) ;
#line 457
FILE *pp_extrn_start(int argc , char const   **argv , pid_t *ppid ) ;
#line 458
void pp_extrn_shutdown(pid_t pid ) ;
#line 459
size_t pp_fill_buffer(char *buf___1 , size_t size ) ;
#line 461
char *install_text(char const   *str ) ;
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
int yy_flex_debug ;
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static struct buffer_ctx *context_stack  ;
#line 43 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static char *linebuf  ;
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static size_t bufsize___0  ;
#line 45 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static char *putback_buffer  ;
#line 46 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static size_t putback_size  ;
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static size_t putback_max  ;
#line 49
static int push_source(char const   *name , int once ) ;
#line 50
static int pop_source(void) ;
#line 51
static int parse_include(char const   *text , int once ) ;
#line 53 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static void putback(char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 58
  if (! *str) {
#line 59
    return;
  }
  {
#line 60
  tmp = strlen(str);
#line 60
  len = tmp + 1U;
  }
#line 61
  if (len > putback_max) {
    {
#line 62
    putback_max = len;
#line 63
    tmp___0 = xrealloc((void *)putback_buffer, putback_max);
#line 63
    putback_buffer = (char *)tmp___0;
    }
  }
  {
#line 65
  strcpy((char */* __restrict  */)putback_buffer, (char const   */* __restrict  */)str);
#line 66
  putback_size = len - 1U;
  }
#line 67
  return;
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static size_t pp_line_stmt_size(void) 
{ 
  char nbuf[128] ;
  size_t n ;
  int tmp ;
  size_t n1 ;
  int tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 77
  tmp = snprintf((char */* __restrict  */)(nbuf), (size_t )sizeof(nbuf), (char const   */* __restrict  */)"%lu",
                 (unsigned long )context_stack->locus.line);
#line 77
  n = (size_t )tmp;
#line 79
  tmp___0 = snprintf((char */* __restrict  */)(nbuf), (size_t )sizeof(nbuf), (char const   */* __restrict  */)"%lu",
                     (unsigned long )context_stack->xlines + 1UL);
#line 79
  n1 = (size_t )tmp___0;
  }
#line 81
  if (context_stack->namelen == 0U) {
    {
#line 82
    context_stack->namelen = strlen((char const   *)context_stack->locus.file);
    }
  }
#line 85
  return (((11U + n) + n1) + context_stack->namelen);
}
}
#line 88 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static void pp_line_stmt(void) 
{ 
  char *p ;
  size_t ls_size ;
  size_t tmp ;
  size_t pb_size ;
  void *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 92
  tmp = pp_line_stmt_size();
#line 92
  ls_size = tmp;
#line 93
  pb_size = (putback_size + ls_size) + 1U;
  }
#line 95
  if (pb_size > putback_max) {
    {
#line 96
    putback_max = pb_size;
#line 97
    tmp___0 = xrealloc((void *)putback_buffer, putback_max);
#line 97
    putback_buffer = (char *)tmp___0;
    }
  }
  {
#line 100
  p = putback_buffer + putback_size;
#line 101
  (context_stack->xlines) ++;
#line 102
  snprintf((char */* __restrict  */)p, putback_max - putback_size, (char const   */* __restrict  */)"#line %lu \"%s\" %lu\n",
           (unsigned long )context_stack->locus.line, context_stack->locus.file, (unsigned long )context_stack->xlines);
#line 107
  putback_size += ls_size;
  }
#line 108
  return;
}
}
#line 114 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static int next_line(void) 
{ 
  ssize_t rc ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (putback_size) {
#line 121
      if (putback_size + 1U > bufsize___0) {
        {
#line 122
        bufsize___0 = putback_size + 1U;
#line 123
        tmp = xrealloc((void *)linebuf, bufsize___0);
#line 123
        linebuf = (char *)tmp;
        }
      }
      {
#line 125
      strcpy((char */* __restrict  */)linebuf, (char const   */* __restrict  */)putback_buffer);
#line 126
      rc = (ssize_t )putback_size;
#line 127
      putback_size = (size_t )0;
      }
    } else
#line 128
    if (! context_stack) {
#line 129
      return (0);
    } else {
      {
#line 131
      rc = getline((char **/* __restrict  */)(& linebuf), (size_t */* __restrict  */)(& bufsize___0),
                   (FILE */* __restrict  */)context_stack->infile);
      }
    }
#line 119
    if (rc == -1) {
      {
#line 119
      tmp___0 = pop_source();
      }
#line 119
      if (! (tmp___0 == 0)) {
#line 119
        goto while_break;
      }
    } else {
#line 119
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return (rc);
}
}
#line 136 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
size_t pp_fill_buffer(char *buf___1 , size_t size ) 
{ 
  size_t bufsize___1 ;
  char *p ;
  size_t len ;
  int is_line ;
  unsigned short const   **tmp ;
  size_t l ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 139
  bufsize___1 = size;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    tmp___9 = next_line();
    }
#line 141
    if (! (tmp___9 > 0)) {
#line 141
      goto while_break;
    }
#line 144
    is_line = 0;
#line 146
    p = linebuf;
    {
#line 146
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 146
      if (*p) {
        {
#line 146
        tmp = __ctype_b_loc();
        }
#line 146
        if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 146
          goto while_break___0;
        }
      } else {
#line 146
        goto while_break___0;
      }
#line 146
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 148
    if ((int )*p == 35) {
#line 150
      p ++;
      {
#line 150
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 150
        if (*p) {
          {
#line 150
          tmp___0 = __ctype_b_loc();
          }
#line 150
          if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 150
            goto while_break___1;
          }
        } else {
#line 150
          goto while_break___1;
        }
#line 150
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 152
      l = strlen((char const   *)p);
      }
#line 153
      if ((unsigned long )l >= sizeof("include_once")) {
        {
#line 153
        tmp___7 = memcmp((void const   *)p, (void const   *)"include_once", (size_t )(sizeof("include_once") - 1UL));
        }
#line 153
        if (tmp___7 == 0) {
          {
#line 153
          tmp___8 = __ctype_b_loc();
          }
#line 153
          if ((int const   )*(*tmp___8 + (int )*(p + (sizeof("include_once") - 1UL))) & 8192) {
            {
#line 154
            tmp___1 = parse_include((char const   *)linebuf, 1);
            }
#line 154
            if (tmp___1) {
              {
#line 155
              putback("/*include_once*/\n");
              }
            }
#line 156
            goto while_continue;
          } else {
#line 153
            goto _L___2;
          }
        } else {
#line 153
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 157
      if ((unsigned long )l >= sizeof("include")) {
        {
#line 157
        tmp___5 = memcmp((void const   *)p, (void const   *)"include", (size_t )(sizeof("include") - 1UL));
        }
#line 157
        if (tmp___5 == 0) {
          {
#line 157
          tmp___6 = __ctype_b_loc();
          }
#line 157
          if ((int const   )*(*tmp___6 + (int )*(p + (sizeof("include") - 1UL))) & 8192) {
            {
#line 158
            tmp___2 = parse_include((char const   *)linebuf, 0);
            }
#line 158
            if (tmp___2) {
              {
#line 159
              putback("/*include*/\n");
              }
            }
#line 160
            goto while_continue;
          } else {
#line 157
            goto _L___0;
          }
        } else {
#line 157
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 161
      if ((unsigned long )l >= sizeof("line")) {
        {
#line 161
        tmp___3 = memcmp((void const   *)p, (void const   *)"line", (size_t )(sizeof("line") - 1UL));
        }
#line 161
        if (tmp___3 == 0) {
          {
#line 161
          tmp___4 = __ctype_b_loc();
          }
#line 161
          if ((int const   )*(*tmp___4 + (int )*(p + (sizeof("line") - 1UL))) & 8192) {
#line 162
            is_line = 1;
          }
        }
      }
    }
    {
#line 165
    len = strlen((char const   *)linebuf);
    }
#line 167
    if (len > size) {
#line 168
      len = size;
    }
    {
#line 170
    memcpy((void */* __restrict  */)buf___1, (void const   */* __restrict  */)linebuf,
           len);
#line 171
    buf___1 += len;
#line 172
    size -= len;
    }
#line 174
    if (size == 0U) {
      {
#line 175
      putback((char const   *)(linebuf + len));
      }
#line 176
      goto while_break;
    }
#line 179
    if (! is_line) {
#line 179
      if (len > 0U) {
#line 179
        if ((int )*(linebuf + (len - 1U)) == 10) {
#line 180
          (context_stack->locus.line) ++;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return (bufsize___1 - size);
}
}
#line 188 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static struct buffer_ctx *ctx_lookup(struct stat *st ) 
{ 
  struct buffer_ctx *ctx ;

  {
#line 193
  if (! context_stack) {
#line 194
    return ((struct buffer_ctx *)((void *)0));
  }
#line 196
  ctx = context_stack->prev;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! ctx) {
#line 196
      goto while_break;
    }
#line 197
    if (ctx->id.i_node == st->st_ino) {
#line 197
      if (ctx->id.device == st->st_dev) {
#line 198
        goto while_break;
      }
    }
#line 196
    ctx = ctx->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (ctx);
}
}
#line 202 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
char const   *preprocessor  =    "";
#line 203 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static dico_list_t include_path  ;
#line 204 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static dico_list_t std_include_path  ;
#line 214 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static int find_include_file(void *item , void *data ) 
{ 
  char *dir ;
  struct file_data *dptr ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;

  {
  {
#line 217
  dir = (char *)item;
#line 218
  dptr = (struct file_data *)data;
#line 219
  tmp = strlen((char const   *)dir);
#line 219
  size = ((tmp + 1U) + dptr->namelen) + 1U;
  }
#line 220
  if (size > dptr->buflen) {
    {
#line 221
    dptr->buflen = size;
#line 222
    tmp___0 = xrealloc((void *)dptr->buf, dptr->buflen);
#line 222
    dptr->buf = (char *)tmp___0;
    }
  }
  {
#line 224
  strcpy((char */* __restrict  */)dptr->buf, (char const   */* __restrict  */)dir);
#line 225
  strcat((char */* __restrict  */)dptr->buf, (char const   */* __restrict  */)"/");
#line 226
  strcat((char */* __restrict  */)dptr->buf, (char const   */* __restrict  */)dptr->name);
#line 227
  tmp___2 = access((char const   *)dptr->buf, 0);
#line 227
  tmp___1 = tmp___2 == 0;
#line 227
  dptr->found = tmp___1;
  }
#line 227
  return (tmp___1);
}
}
#line 230 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
void include_path_setup(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
#line 233
  if (! include_path) {
    {
#line 234
    include_path = xdico_list_create();
    }
  }
  {
#line 235
  std_include_path = xdico_list_create();
#line 236
  dico_list_append(std_include_path, (void *)"/usr/local/share/dico/2.0/include");
#line 237
  dico_list_append(std_include_path, (void *)"/usr/local/share/dico/include");
  }
#line 238
  return;
}
}
#line 240 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
void add_include_dir(char *dir ) 
{ 


  {
#line 243
  if (! include_path) {
    {
#line 244
    include_path = xdico_list_create();
    }
  }
  {
#line 245
  xdico_list_append(include_path, (void *)dir);
  }
#line 246
  return;
}
}
#line 248 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static Hash_table *incl_sources  ;
#line 251 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static size_t incl_hasher(void const   *data , unsigned int n_buckets ) 
{ 
  struct input_file_ident  const  *id ;

  {
#line 254
  id = (struct input_file_ident  const  *)data;
#line 255
  return ((size_t )(((dev_t const   )id->i_node + id->device) % (unsigned long long const   )n_buckets));
}
}
#line 259 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static _Bool incl_compare(void const   *data1 , void const   *data2 ) 
{ 
  struct input_file_ident  const  *id1 ;
  struct input_file_ident  const  *id2 ;
  int tmp ;

  {
#line 262
  id1 = (struct input_file_ident  const  *)data1;
#line 263
  id2 = (struct input_file_ident  const  *)data2;
#line 264
  if (id1->device == id2->device) {
#line 264
    if (id1->i_node == id2->i_node) {
#line 264
      tmp = 1;
    } else {
#line 264
      tmp = 0;
    }
  } else {
#line 264
    tmp = 0;
  }
#line 264
  return ((_Bool )tmp);
}
}
#line 267 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static void incl_free(void *data ) 
{ 


  {
  {
#line 270
  free(data);
  }
#line 271
  return;
}
}
#line 273 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static int source_lookup(struct stat *st ) 
{ 
  struct input_file_ident *sample ;
  void *tmp ;
  struct input_file_ident *id ;
  void *tmp___0 ;

  {
  {
#line 276
  tmp = xmalloc((size_t )sizeof(*sample));
#line 276
  sample = (struct input_file_ident *)tmp;
#line 278
  sample->i_node = st->st_ino;
#line 279
  sample->device = st->st_dev;
  }
#line 281
  if (incl_sources) {
#line 281
    goto _L;
  } else {
    {
#line 281
    incl_sources = hash_initialize((size_t )0, (Hash_tuning const   *)0, & incl_hasher,
                                   & incl_compare, & incl_free);
    }
#line 281
    if (incl_sources) {
      _L: /* CIL Label */ 
      {
#line 281
      tmp___0 = hash_insert(incl_sources, (void const   *)sample);
#line 281
      id = (struct input_file_ident *)tmp___0;
      }
#line 281
      if (! id) {
        {
#line 287
        xalloc_die();
        }
      }
    } else {
      {
#line 287
      xalloc_die();
      }
    }
  }
#line 289
  if ((unsigned long )id != (unsigned long )sample) {
    {
#line 290
    free((void *)sample);
    }
#line 291
    return (1);
  }
#line 293
  return (0);
}
}
#line 297 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static Hash_table *text_table  ;
#line 300 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static size_t text_hasher(void const   *data , unsigned int n_buckets ) 
{ 
  size_t tmp ;

  {
  {
#line 303
  tmp = hash_string((char const   *)data, n_buckets);
  }
#line 303
  return (tmp);
}
}
#line 307 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static _Bool text_compare(void const   *data1 , void const   *data2 ) 
{ 
  int tmp ;

  {
  {
#line 310
  tmp = strcmp((char const   *)data1, (char const   *)data2);
  }
#line 310
  return ((_Bool )(tmp == 0));
}
}
#line 314 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
char *install_text(char const   *str ) 
{ 
  char *text ;
  char *s ;
  void *tmp ;

  {
  {
#line 319
  s = xstrdup(str);
  }
#line 321
  if (text_table) {
#line 321
    goto _L;
  } else {
    {
#line 321
    text_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & text_hasher,
                                 & text_compare, & incl_free);
    }
#line 321
    if (text_table) {
      _L: /* CIL Label */ 
      {
#line 321
      tmp = hash_insert(text_table, (void const   *)s);
#line 321
      text = (char *)tmp;
      }
#line 321
      if (! text) {
        {
#line 327
        xalloc_die();
        }
      }
    } else {
      {
#line 327
      xalloc_die();
      }
    }
  }
#line 329
  if ((unsigned long )text != (unsigned long )text) {
    {
#line 330
    free((void *)s);
    }
  }
#line 331
  return (text);
}
}
#line 335 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static int push_source(char const   *name , int once ) 
{ 
  FILE *fp ;
  struct buffer_ctx *ctx ;
  struct stat st ;
  int rc ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  void *tmp___11 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 341
  tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
#line 341
  rc = tmp;
  }
#line 343
  if (context_stack) {
#line 344
    if (rc) {
      {
#line 345
      tmp___0 = gettext("Cannot stat `%s\'");
#line 345
      tmp___1 = __errno_location();
#line 345
      config_error(& context_stack->locus, *tmp___1, (char const   *)tmp___0, name);
      }
#line 346
      return (1);
    }
#line 349
    if (context_stack->locus.file) {
#line 349
      if (context_stack->id.i_node == st.st_ino) {
#line 349
        if (context_stack->id.device == st.st_dev) {
          {
#line 350
          tmp___2 = gettext("Recursive inclusion");
#line 350
          config_error(& context_stack->locus, 0, (char const   *)tmp___2);
          }
#line 351
          return (1);
        }
      }
    }
    {
#line 354
    ctx = ctx_lookup(& st);
    }
#line 354
    if (ctx) {
      {
#line 355
      tmp___3 = gettext("Recursive inclusion");
#line 355
      config_error(& context_stack->locus, 0, (char const   *)tmp___3);
      }
#line 356
      if (ctx->prev) {
        {
#line 357
        tmp___4 = gettext("`%s\' already included here");
#line 357
        config_error(& (ctx->prev)->locus, 0, (char const   *)tmp___4, name);
        }
      } else {
        {
#line 361
        tmp___5 = gettext("`%s\' already included at top level");
#line 361
        config_error(& context_stack->locus, 0, (char const   *)tmp___5, name);
        }
      }
#line 364
      return (1);
    }
  } else
#line 366
  if (rc) {
    {
#line 367
    tmp___6 = gettext("Cannot stat `%s\'");
#line 367
    tmp___7 = __errno_location();
#line 367
    config_error((dicod_locus_t *)((void *)0), *tmp___7, (char const   *)tmp___6,
                 name);
    }
#line 368
    return (1);
  }
#line 371
  if (once) {
    {
#line 371
    tmp___8 = source_lookup(& st);
    }
#line 371
    if (tmp___8) {
#line 372
      return (-1);
    }
  }
  {
#line 374
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 375
  if (! fp) {
    {
#line 376
    tmp___9 = gettext("Cannot open `%s\'");
#line 376
    tmp___10 = __errno_location();
#line 376
    config_error(& context_stack->locus, *tmp___10, (char const   *)tmp___9, name);
    }
#line 377
    return (1);
  }
  {
#line 381
  tmp___11 = xmalloc((size_t )sizeof(*ctx));
#line 381
  ctx = (struct buffer_ctx *)tmp___11;
#line 382
  ctx->locus.file = install_text(name);
#line 383
  ctx->locus.line = 1;
#line 384
  ctx->xlines = (size_t )0;
#line 385
  ctx->namelen = strlen((char const   *)ctx->locus.file);
#line 386
  ctx->id.i_node = st.st_ino;
#line 387
  ctx->id.device = st.st_dev;
#line 388
  ctx->infile = fp;
#line 389
  ctx->prev = context_stack;
#line 390
  context_stack = ctx;
  }
#line 392
  if (yy_flex_debug) {
    {
#line 393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Processing file `%s\'\n",
            name);
    }
  }
  {
#line 395
  pp_line_stmt();
  }
#line 397
  return (0);
}
}
#line 400 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static int pop_source(void) 
{ 
  struct buffer_ctx *ctx ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 405
  if (! context_stack) {
#line 406
    return (1);
  }
  {
#line 408
  fclose(context_stack->infile);
#line 411
  ctx = context_stack->prev;
#line 412
  free((void *)context_stack);
#line 413
  context_stack = ctx;
  }
#line 415
  if (! context_stack) {
#line 416
    if (yy_flex_debug) {
      {
#line 417
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"End of input\n");
      }
    }
#line 418
    return (1);
  }
#line 421
  (context_stack->locus.line) ++;
#line 423
  if (yy_flex_debug) {
    {
#line 424
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Resuming file `%s\' at line %lu\n",
            context_stack->locus.file, (unsigned long )context_stack->locus.line);
    }
  }
  {
#line 427
  pp_line_stmt();
  }
#line 429
  return (0);
}
}
#line 435
static int try_file(char const   *name , int allow_cwd , int err_not_found , char **newp ) ;
#line 435 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static char *cwd  =    (char *)".";
#line 432 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static int try_file(char const   *name , int allow_cwd , int err_not_found , char **newp ) 
{ 
  struct file_data fd ;
  char *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 438
  fd.name = name;
#line 439
  fd.namelen = strlen(name);
#line 440
  fd.buf = (char *)((void *)0);
#line 441
  fd.buflen = (size_t )0;
#line 442
  fd.found = 0;
  }
#line 444
  if (allow_cwd) {
    {
#line 445
    dico_list_prepend(include_path, (void *)cwd);
#line 446
    dico_list_iterate(include_path, & find_include_file, (void *)(& fd));
#line 447
    dico_list_pop(include_path);
    }
  } else {
    {
#line 449
    dico_list_iterate(include_path, & find_include_file, (void *)(& fd));
    }
  }
#line 451
  if (! fd.found) {
    {
#line 452
    dico_list_iterate(std_include_path, & find_include_file, (void *)(& fd));
    }
#line 454
    if (! fd.found) {
#line 454
      if (err_not_found) {
        {
#line 455
        tmp = gettext("%s: No such file or directory");
#line 455
        config_error(& context_stack->locus, 0, (char const   *)tmp, name);
#line 457
        *newp = (char *)((void *)0);
        }
      }
    }
  }
#line 460
  if (fd.found) {
#line 461
    *newp = fd.buf;
  }
#line 462
  return (fd.found);
}
}
#line 465 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
static int parse_include(char const   *text , int once ) 
{ 
  int argc ;
  char **argv ;
  char *tmp ;
  char *p ;
  int rc ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t len ;
  int allow_cwd ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 470
  tmp = (char *)((void *)0);
#line 471
  p = (char *)((void *)0);
#line 472
  rc = 1;
#line 474
  tmp___3 = dico_argcv_get(text, "", (char const   *)((void *)0), & argc, & argv);
  }
#line 474
  if (tmp___3) {
    {
#line 475
    tmp___0 = gettext("Cannot parse include line");
#line 475
    config_error(& context_stack->locus, 0, (char const   *)tmp___0);
    }
  } else
#line 476
  if (argc != 2) {
    {
#line 477
    tmp___1 = gettext("invalid include statement");
#line 477
    config_error(& context_stack->locus, 0, (char const   *)tmp___1);
    }
  } else {
    {
#line 482
    p = *(argv + 1);
#line 483
    len = strlen((char const   *)p);
    }
#line 485
    if ((int )*(p + 0) == 60) {
#line 485
      if ((int )*(p + (len - 1U)) == 62) {
#line 486
        allow_cwd = 0;
#line 487
        *(p + (len - 1U)) = (char)0;
#line 488
        p ++;
      } else {
#line 490
        allow_cwd = 1;
      }
    } else {
#line 490
      allow_cwd = 1;
    }
#line 492
    if ((int )*(p + 0) != 47) {
      {
#line 492
      tmp___2 = try_file((char const   *)p, allow_cwd, 1, & tmp);
      }
#line 492
      if (tmp___2) {
#line 493
        p = tmp;
      }
    }
  }
#line 496
  if (p) {
    {
#line 497
    rc = push_source((char const   *)p, once);
    }
  }
  {
#line 498
  free((void *)tmp);
#line 499
  dico_argcv_free(argc, argv);
  }
#line 500
  return (rc);
}
}
#line 503 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
int pp_init(char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 506
  tmp = push_source(name, 0);
  }
#line 506
  return (tmp);
}
}
#line 509 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
void pp_done(void) 
{ 


  {
#line 512
  if (incl_sources) {
    {
#line 513
    hash_free(incl_sources);
    }
  }
#line 514
  if (text_table) {
    {
#line 515
    hash_free(text_table);
    }
  }
  {
#line 516
  free((void *)linebuf);
#line 517
  free((void *)putback_buffer);
  }
#line 518
  return;
}
}
#line 520 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
int preprocess_config(char const   *extpp ) 
{ 
  size_t i ;
  char buffer[512] ;
  int tmp ;
  FILE *outfile ;
  char *setup_file ;
  char *cmd___6 ;
  int tmp___0 ;
  unsigned int n ;
  char *tmp___1 ;
  int *tmp___2 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 526
  tmp = pp_init((char const   *)config_file);
  }
#line 526
  if (tmp) {
#line 527
    return (1);
  }
#line 528
  if (extpp) {
    {
#line 530
    setup_file = (char *)((void *)0);
#line 533
    tmp___0 = try_file("pp-setup", 1, 0, & setup_file);
    }
#line 533
    if (tmp___0) {
      {
#line 534
      asprintf((char **/* __restrict  */)(& cmd___6), (char const   */* __restrict  */)"%s %s -",
               extpp, setup_file);
      }
    } else {
#line 536
      cmd___6 = (char *)extpp;
    }
    {
#line 537
    while (1) {
      while_continue: /* CIL Label */ ;
#line 537
      if (debug_level >= 2) {
#line 537
        if (debug_source_info) {
          {
#line 537
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 537
            n = 537U;
#line 537
            dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c");
#line 537
            dico_stream_ioctl(debug_stream, 3, (void *)(& n));
            }
#line 537
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 537
        stream_printf(debug_stream, "Running preprocessor: `%s\'", cmd___6);
        }
      }
#line 537
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 538
    outfile = popen((char const   *)cmd___6, "w");
    }
#line 539
    if (! outfile) {
      {
#line 540
      tmp___1 = gettext("Unable to start external preprocessor `%s\'");
#line 540
      tmp___2 = __errno_location();
#line 540
      dico_log(4, *tmp___2, (char const   *)tmp___1, cmd___6);
      }
#line 543
      if (setup_file) {
        {
#line 544
        free((void *)setup_file);
#line 545
        free((void *)cmd___6);
        }
      }
#line 547
      return (1);
    }
    {
#line 550
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 550
      i = pp_fill_buffer(buffer, (size_t )sizeof(buffer));
      }
#line 550
      if (! i) {
#line 550
        goto while_break___1;
      }
      {
#line 551
      fwrite((void const   */* __restrict  */)(buffer), (size_t )1, i, (FILE */* __restrict  */)outfile);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 552
    pclose(outfile);
    }
#line 553
    if (setup_file) {
      {
#line 554
      free((void *)setup_file);
#line 555
      free((void *)cmd___6);
      }
    }
  } else {
    {
#line 558
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 558
      i = pp_fill_buffer(buffer, (size_t )sizeof(buffer));
      }
#line 558
      if (! i) {
#line 558
        goto while_break___2;
      }
      {
#line 559
      fwrite((void const   */* __restrict  */)(buffer), (size_t )1, i, (FILE */* __restrict  */)stdout);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 561
  pp_done();
  }
#line 562
  return (0);
}
}
#line 565 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
void pp_make_argcv(int *pargc , char const   ***pargv ) 
{ 
  size_t n ;
  int argc ;
  char const   **argv ;
  dico_iterator_t itr ;
  char *cp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 568
  n = (size_t )0;
#line 574
  n = dico_list_count(include_path);
#line 575
  argc = (int )(9U + 2U * n);
#line 576
  tmp = xcalloc((size_t )(argc + 1), (size_t )sizeof(*(argv + 0)));
#line 576
  argv = (char const   **)tmp;
#line 578
  argc = 0;
#line 579
  tmp___0 = argc;
#line 579
  argc ++;
#line 579
  *(argv + tmp___0) = dico_invocation_name;
#line 580
  tmp___1 = argc;
#line 580
  argc ++;
#line 580
  *(argv + tmp___1) = "-E";
#line 581
  tmp___2 = argc;
#line 581
  argc ++;
#line 581
  *(argv + tmp___2) = "--preprocessor";
#line 582
  tmp___3 = argc;
#line 582
  argc ++;
#line 582
  *(argv + tmp___3) = preprocessor;
#line 583
  tmp___4 = argc;
#line 583
  argc ++;
  }
#line 583
  if (log_to_stderr) {
#line 583
    *(argv + tmp___4) = "--stderr";
  } else {
#line 583
    *(argv + tmp___4) = "--syslog";
  }
  {
#line 584
  itr = xdico_list_iterator(include_path);
#line 585
  tmp___5 = dico_iterator_first(itr);
#line 585
  cp = (char *)tmp___5;
  }
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! cp) {
#line 585
      goto while_break;
    }
    {
#line 586
    tmp___7 = argc;
#line 586
    argc ++;
#line 586
    *(argv + tmp___7) = "-I";
#line 587
    tmp___8 = argc;
#line 587
    argc ++;
#line 587
    *(argv + tmp___8) = (char const   *)cp;
#line 585
    tmp___6 = dico_iterator_next(itr);
#line 585
    cp = (char *)tmp___6;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 589
  dico_iterator_destroy(& itr);
#line 590
  tmp___9 = argc;
#line 590
  argc ++;
#line 590
  *(argv + tmp___9) = "--config";
#line 591
  tmp___10 = argc;
#line 591
  argc ++;
#line 591
  *(argv + tmp___10) = (char const   *)config_file;
  }
#line 592
  if (debug_level) {
#line 593
    tmp___11 = argc;
#line 593
    argc ++;
#line 593
    *(argv + tmp___11) = "--debug";
#line 594
    tmp___12 = argc;
#line 594
    argc ++;
#line 594
    *(argv + tmp___12) = (char const   *)debug_level_str;
  }
#line 596
  *(argv + argc) = (char const   *)((void *)0);
#line 598
  *pargc = argc;
#line 599
  *pargv = argv;
#line 600
  return;
}
}
#line 602 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
FILE *pp_extrn_start(int argc , char const   **argv , pid_t *ppid ) 
{ 
  int pout[2] ;
  pid_t pid ;
  int i ;
  char *ppcmd ;
  FILE *fp ;
  unsigned int n ;
  long tmp ;
  int p[2] ;
  char *buf___1 ;
  size_t size ;
  FILE *fp___0 ;
  char *tmp___0 ;
  int *tmp___1 ;
  __ssize_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 608
  ppcmd = (char *)"unknown";
#line 609
  fp = (FILE *)((void *)0);
#line 611
  dico_argcv_string(argc, argv, & ppcmd);
  }
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 612
    if (debug_level >= 2) {
#line 612
      if (debug_source_info) {
        {
#line 612
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 612
          n = 612U;
#line 612
          dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c");
#line 612
          dico_stream_ioctl(debug_stream, 3, (void *)(& n));
          }
#line 612
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 612
      stream_printf(debug_stream, "Running preprocessor: `%s\'", ppcmd);
      }
    }
#line 612
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 614
  pipe((int *)(pout));
#line 615
  pid = fork();
  }
  {
#line 617
  if (pid == 0) {
#line 617
    goto case_0;
  }
#line 669
  if (pid == -1) {
#line 669
    goto case_neg_1___0;
  }
#line 674
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 618
  if (pout[1] != 1) {
    {
#line 619
    close(1);
#line 620
    dup2(pout[1], 1);
    }
  }
  {
#line 624
  tmp = sysconf(4);
#line 624
  i = (int )tmp;
  }
  {
#line 624
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 624
    if (! (i > 2)) {
#line 624
      goto while_break___1;
    }
    {
#line 625
    close(i);
#line 624
    i --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 627
  if (! log_to_stderr) {
    {
#line 629
    buf___1 = (char *)((void *)0);
#line 630
    size = (size_t )0;
#line 633
    signal(17, (void (*)(int  ))0);
#line 634
    pipe((int *)(p));
#line 635
    pid = fork();
    }
    {
#line 637
    if (pid == 0) {
#line 637
      goto case_0___0;
    }
#line 647
    if (pid == -1) {
#line 647
      goto case_neg_1;
    }
#line 653
    goto switch_default;
    case_0___0: /* CIL Label */ 
#line 638
    if (p[1] != 2) {
      {
#line 639
      close(2);
#line 640
      dup2(p[1], 2);
      }
    }
    {
#line 642
    close(p[0]);
#line 644
    execvp(*(argv + 0), (char * const  *)((char **)argv));
#line 645
    exit(127);
    }
    case_neg_1: /* CIL Label */ 
    {
#line 649
    dicod_log_setup();
#line 650
    tmp___0 = gettext("Cannot run `%s\'");
#line 650
    tmp___1 = __errno_location();
#line 650
    dico_log(4, *tmp___1, (char const   *)tmp___0, ppcmd);
#line 651
    exit(127);
    }
    switch_default: /* CIL Label */ 
    {
#line 655
    close(p[1]);
#line 656
    fp___0 = fdopen(p[0], "r");
#line 657
    dicod_log_setup();
    }
    {
#line 658
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 658
      tmp___2 = getline((char **/* __restrict  */)(& buf___1), (size_t */* __restrict  */)(& size),
                        (FILE */* __restrict  */)fp___0);
      }
#line 658
      if (! (tmp___2 > 0)) {
#line 658
        goto while_break___2;
      }
      {
#line 659
      dico_log(4, 0, "%s", buf___1);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 660
    exit(0);
    }
    switch_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 663
    execvp(*(argv + 0), (char * const  *)((char **)argv));
#line 664
    dicod_log_setup();
#line 665
    tmp___3 = gettext("Cannot run `%s\'");
#line 665
    dico_log(4, 0, (char const   *)tmp___3, ppcmd);
#line 666
    exit(127);
    }
  }
  case_neg_1___0: /* CIL Label */ 
  {
#line 671
  tmp___4 = gettext("Cannot run `%s\'");
#line 671
  dico_log(4, 0, (char const   *)tmp___4, ppcmd);
  }
#line 672
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 675
  close(pout[1]);
#line 676
  fp = fdopen(pout[0], "r");
  }
#line 677
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 679
  *ppid = pid;
#line 680
  return (fp);
}
}
#line 683 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
void pp_extrn_shutdown(pid_t pid ) 
{ 
  int status___0 ;

  {
  {
#line 687
  waitpid(pid, & status___0, 0);
  }
#line 688
  return;
}
}
#line 690 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/pp.c"
void run_lint(void) 
{ 
  size_t n ;
  int argc ;
  char const   **argv ;
  dico_iterator_t itr ;
  char *cp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 693
  n = (size_t )0;
#line 699
  n = dico_list_count(include_path);
#line 700
  argc = (int )(9U + 2U * n);
#line 701
  tmp = xcalloc((size_t )(argc + 1), (size_t )sizeof(*(argv + 0)));
#line 701
  argv = (char const   **)tmp;
#line 703
  argc = 0;
#line 704
  tmp___0 = argc;
#line 704
  argc ++;
#line 704
  *(argv + tmp___0) = dico_invocation_name;
#line 705
  tmp___1 = argc;
#line 705
  argc ++;
#line 705
  *(argv + tmp___1) = "--lint";
#line 706
  tmp___2 = argc;
#line 706
  argc ++;
#line 706
  *(argv + tmp___2) = "--preprocessor";
#line 707
  tmp___3 = argc;
#line 707
  argc ++;
#line 707
  *(argv + tmp___3) = preprocessor;
  }
#line 708
  if (log_to_stderr) {
#line 709
    tmp___4 = argc;
#line 709
    argc ++;
#line 709
    *(argv + tmp___4) = "--stderr";
  } else {
    {
#line 711
    dicod_log_encode_envar();
    }
  }
  {
#line 712
  itr = xdico_list_iterator(include_path);
#line 713
  tmp___5 = dico_iterator_first(itr);
#line 713
  cp = (char *)tmp___5;
  }
  {
#line 713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 713
    if (! cp) {
#line 713
      goto while_break;
    }
    {
#line 714
    tmp___7 = argc;
#line 714
    argc ++;
#line 714
    *(argv + tmp___7) = "-I";
#line 715
    tmp___8 = argc;
#line 715
    argc ++;
#line 715
    *(argv + tmp___8) = (char const   *)cp;
#line 713
    tmp___6 = dico_iterator_next(itr);
#line 713
    cp = (char *)tmp___6;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 717
  dico_iterator_destroy(& itr);
#line 718
  tmp___9 = argc;
#line 718
  argc ++;
#line 718
  *(argv + tmp___9) = "--config";
#line 719
  tmp___10 = argc;
#line 719
  argc ++;
#line 719
  *(argv + tmp___10) = (char const   *)config_file;
  }
#line 720
  if (debug_level) {
#line 721
    tmp___11 = argc;
#line 721
    argc ++;
#line 721
    *(argv + tmp___11) = "--debug";
#line 722
    tmp___12 = argc;
#line 722
    argc ++;
#line 722
    *(argv + tmp___12) = (char const   *)debug_level_str;
  }
  {
#line 724
  *(argv + argc) = (char const   *)((void *)0);
#line 726
  execv(*(argv + 0), (char * const  *)((char **)argv));
  }
#line 727
  return;
}
}
#line 431 "./dicod.h"
off_t total_bytes_out  ;
#line 432
dico_stream_t dicod_ostream_create(dico_stream_t str , dico_assoc_list_t headers ) ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ostream.c"
int option_mime ;
#line 32 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ostream.c"
static int print_headers(struct ostream *ostr ) 
{ 
  int rc ;
  char *enc ;
  dico_iterator_t itr ;
  struct dico_assoc *p ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  dico_stream_t str ;
  dico_stream_t tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 35
  rc = 0;
#line 38
  if (ostr->headers) {
    {
#line 42
    itr = dico_assoc_iterator(ostr->headers);
#line 43
    tmp = dico_iterator_first(itr);
#line 43
    p = (struct dico_assoc *)tmp;
    }
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 43
      if (! p) {
#line 43
        goto while_break;
      }
      {
#line 44
      tmp___1 = strlen(p->key);
#line 44
      dico_stream_write(ostr->transport, (void const   *)p->key, tmp___1);
#line 45
      dico_stream_write(ostr->transport, (void const   *)": ", (size_t )2);
#line 46
      tmp___2 = strlen((char const   *)p->value);
#line 46
      dico_stream_write(ostr->transport, (void const   *)p->value, tmp___2);
#line 47
      dico_stream_write(ostr->transport, (void const   *)"\r\n", (size_t )2);
#line 43
      tmp___0 = dico_iterator_next(itr);
#line 43
      p = (struct dico_assoc *)tmp___0;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 49
    dico_iterator_destroy(& itr);
    }
  }
  {
#line 52
  rc = dico_stream_write(ostr->transport, (void const   *)"\r\n", (size_t )2);
  }
#line 54
  if (rc == 0) {
    {
#line 54
    tmp___4 = dico_assoc_find(ostr->headers, "Content-transfer-encoding");
#line 54
    enc = (char *)tmp___4;
    }
#line 54
    if (enc) {
      {
#line 54
      tmp___5 = strcmp((char const   *)enc, "8bit");
      }
#line 54
      if (tmp___5) {
        {
#line 58
        tmp___3 = dico_codec_stream_create((char const   *)enc, 0, ostr->transport);
#line 58
        str = tmp___3;
        }
#line 61
        if (str) {
#line 62
          ostr->transport = str;
#line 63
          ostr->flags |= 2;
        }
      }
    }
  }
#line 66
  return (rc);
}
}
#line 70 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ostream.c"
static int ostream_write(void *data , char const   *buf___1 , size_t size , size_t *pret ) 
{ 
  struct ostream *ostr ;
  off_t nbytes ;
  off_t tmp ;
  int rc ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  off_t tmp___4 ;
  char *__cil_tmp14 ;

  {
  {
#line 73
  ostr = (struct ostream *)data;
#line 74
  tmp = dico_stream_bytes_out(ostr->transport);
#line 74
  nbytes = tmp;
  }
#line 77
  if (! (ostr->flags & 1)) {
#line 78
    if (option_mime) {
      {
#line 78
      tmp___1 = print_headers(ostr);
      }
#line 78
      if (tmp___1) {
        {
#line 79
        tmp___0 = dico_stream_last_error(ostr->transport);
        }
#line 79
        return (tmp___0);
      }
    }
#line 80
    ostr->flags |= 1;
  }
#line 82
  if ((int const   )*(buf___1 + 0) == 46) {
    {
#line 82
    tmp___3 = dico_stream_write(ostr->transport, (void const   *)".", (size_t )1);
    }
#line 82
    if (tmp___3) {
      {
#line 83
      tmp___2 = dico_stream_last_error(ostr->transport);
      }
#line 83
      return (tmp___2);
    }
  }
  {
#line 84
  *pret = size;
#line 85
  rc = dico_stream_write(ostr->transport, (void const   *)buf___1, size);
  }
#line 86
  if (rc == 0) {
    {
#line 87
    tmp___4 = dico_stream_bytes_out(ostr->transport);
#line 87
    total_bytes_out += tmp___4 - nbytes;
    }
  }
#line 89
  return (rc);
}
}
#line 92 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ostream.c"
static int ostream_flush(void *data ) 
{ 
  struct ostream *ostr ;
  int tmp ;

  {
  {
#line 95
  ostr = (struct ostream *)data;
#line 96
  tmp = dico_stream_flush(ostr->transport);
  }
#line 96
  return (tmp);
}
}
#line 99 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ostream.c"
static int ostream_destroy(void *data ) 
{ 
  struct ostream *ostr ;

  {
#line 102
  ostr = (struct ostream *)data;
#line 103
  if (ostr->flags & 2) {
    {
#line 104
    dico_stream_destroy(& ostr->transport);
    }
  }
  {
#line 105
  free(data);
  }
#line 106
  return (0);
}
}
#line 109 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ostream.c"
dico_stream_t dicod_ostream_create(dico_stream_t str , dico_assoc_list_t headers ) 
{ 
  struct ostream *ostr ;
  void *tmp ;
  dico_stream_t stream ;
  int rc ;
  int tmp___0 ;

  {
  {
#line 112
  tmp = xmalloc((size_t )sizeof(*ostr));
#line 112
  ostr = (struct ostream *)tmp;
#line 115
  tmp___0 = dico_stream_create(& stream, 2, (void *)ostr);
#line 115
  rc = tmp___0;
  }
#line 116
  if (rc) {
    {
#line 117
    xalloc_die();
    }
  }
  {
#line 118
  ostr->transport = str;
#line 119
  ostr->flags = 0;
#line 120
  ostr->headers = headers;
#line 121
  dico_stream_set_write(stream, & ostream_write);
#line 122
  dico_stream_set_flush(stream, & ostream_flush);
#line 123
  dico_stream_set_destroy(stream, & ostream_destroy);
#line 124
  dico_stream_set_buffer(stream, (enum dico_buffer_type )1, (size_t )1024);
  }
#line 125
  return (stream);
}
}
#line 354 "./dicod.h"
void register_mime(void) ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/mime.c"
int option_mime  ;
#line 21 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/mime.c"
void dicod_mime(dico_stream_t str , int argc , char **argv ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 24
  option_mime = 1;
#line 25
  stream_writez(str, (char *)"250 ok - using MIME headers\r\n");
  }
#line 26
  return;
}
}
#line 31 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/mime.c"
static struct dicod_command cmd___1[2]  = {      {(char *)"OPTION MIME", 2, 2, (char *)((void *)0), (char *)"use MIME headers",
      & dicod_mime}, 
        {(char *)((void *)0), 0, 0, (char *)0, (char *)0, (void (*)(dico_stream_t str ,
                                                                 int argc , char **argv ))0}};
#line 28 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/mime.c"
void register_mime(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 36
  dicod_capa_register("mime", cmd___1, (int (*)(void * ))((void *)0), (void *)0);
  }
#line 37
  return;
}
}
#line 345 "./dicod.h"
int dicod_capa_add(char const   *name ) ;
#line 357
void register_markup(void) ;
#line 358
void markup_flush_capa(void) ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/markup.c"
static void dicod_markup(dico_stream_t str , int argc , char **argv ) 
{ 
  char const   *p ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 23
  if (argc == 2) {
    {
#line 25
    stream_printf(str, "280 %s is current markup type\r\n", dico_markup_type);
    }
  } else {
    {
#line 27
    p = dico_markup_lookup((char const   *)*(argv + 2));
    }
#line 27
    if (p) {
      {
#line 28
      dico_markup_type = p;
#line 29
      stream_printf(str, "250 markup type set to %s\r\n", dico_markup_type);
      }
    } else {
      {
#line 31
      stream_writez(str, (char *)"500 invalid argument\r\n");
      }
    }
  }
#line 32
  return;
}
}
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/markup.c"
static struct dicod_command cmd___2[2]  = {      {(char *)"OPTION MARKUP", 2, 3, (char *)"type", (char *)"Set output markup type",
      & dicod_markup}, 
        {(char *)((void *)0), 0, 0, (char *)0, (char *)0, (void (*)(dico_stream_t str ,
                                                                 int argc , char **argv ))0}};
#line 34 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/markup.c"
void register_markup(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 42
  dicod_capa_register("markup", cmd___2, (int (*)(void * ))((void *)0), (void *)0);
#line 43
  tmp = dico_markup_register("none");
  }
#line 43
  if (tmp) {
    {
#line 44
    xalloc_die();
    }
  }
#line 45
  return;
}
}
#line 49 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/markup.c"
void markup_flush_capa(void) 
{ 
  dico_iterator_t itr ;
  char const   *p ;
  void *tmp ;
  void *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *str ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 55
  itr = xdico_list_iterator(dico_markup_list);
#line 56
  tmp = dico_iterator_first(itr);
#line 56
  p = (char const   *)tmp;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! p) {
#line 56
      goto while_break;
    }
    {
#line 57
    tmp___1 = strlen(p);
#line 57
    len = (size_t )(sizeof("markup-") + (unsigned long )tmp___1);
#line 58
    tmp___2 = xmalloc(len);
#line 58
    str = (char *)tmp___2;
#line 59
    tmp___3 = strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"markup-");
#line 59
    strcat((char */* __restrict  */)tmp___3, (char const   */* __restrict  */)p);
#line 60
    dicod_capa_register((char const   *)str, (struct dicod_command *)((void *)0),
                        (int (*)(void * ))((void *)0), (void *)0);
#line 61
    dicod_capa_add((char const   *)str);
#line 56
    tmp___0 = dico_iterator_next(itr);
#line 56
    p = (char const   *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  dico_iterator_destroy(& itr);
  }
#line 64
  return;
}
}
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
#line 367 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 181 "/usr/include/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 104 "../include/xdico.h"
int debug_level  ;
#line 105 "../include/xdico.h"
int debug_source_info  ;
#line 106 "../include/xdico.h"
dico_stream_t debug_stream  ;
#line 59 "./dicod.h"
int mode ;
#line 60 "./dicod.h"
int foreground  ;
#line 61 "./dicod.h"
int single_process  ;
#line 62 "./dicod.h"
int log_to_stderr  ;
#line 64 "./dicod.h"
int config_lint_option  ;
#line 66 "./dicod.h"
dico_list_t listen_addr  ;
#line 67 "./dicod.h"
uid_t user_id  ;
#line 68 "./dicod.h"
gid_t group_id  ;
#line 69 "./dicod.h"
dico_list_t group_list  ;
#line 73 "./dicod.h"
char *hostname  ;
#line 75 "./dicod.h"
char *initial_banner_text  ;
#line 77 "./dicod.h"
char *help_text  ;
#line 78 "./dicod.h"
char const   *server_info  ;
#line 80 "./dicod.h"
dico_list_t module_load_path  ;
#line 81 "./dicod.h"
dico_list_t modinst_list  ;
#line 82 "./dicod.h"
dico_list_t database_list  ;
#line 83 "./dicod.h"
int timing_option  ;
#line 84 "./dicod.h"
char *client_id  ;
#line 85 "./dicod.h"
char *user_name  ;
#line 86 "./dicod.h"
dico_list_t user_groups  ;
#line 87 "./dicod.h"
int transcript  ;
#line 89 "./dicod.h"
char *debug_level_str  ;
#line 91
char *access_log_format ;
#line 92
char *access_log_file ;
#line 93 "./dicod.h"
int identity_check  ;
#line 94 "./dicod.h"
char *identity_name  ;
#line 95 "./dicod.h"
char *ident_keyfile  ;
#line 96
long ident_timeout ;
#line 127
void get_options(int argc , char **argv , struct dicod_conf_override *conf ) ;
#line 225
void config_set_keywords(struct config_keyword *kwd ) ;
#line 226
int config_parse(char const   *name ) ;
#line 228
void config_lex_trace(int n ) ;
#line 236
int string_to_bool(char const   *string , int *pval ) ;
#line 237
int string_to_unsigned(uintmax_t *sval , char const   *string , uintmax_t maxval ,
                       dicod_locus_t *loc ) ;
#line 240
void format_docstring(FILE *stream , char const   *docstring___0 , int level ) ;
#line 241
void format_statement_array(FILE *stream , struct config_keyword *kwp , int n , int level ) ;
#line 243
void config_help(void) ;
#line 249
dicod_acl_t dicod_acl_create(char const   *name , dicod_locus_t *locus___0 ) ;
#line 252
int parse_acl_line(dicod_locus_t *locus___0 , int allow , dicod_acl_t acl , config_value_t *value ) ;
#line 255
int dicod_acl_install(dicod_acl_t acl , dicod_locus_t *locus___0 ) ;
#line 256
dicod_acl_t dicod_acl_lookup(char const   *name ) ;
#line 258 "./dicod.h"
dicod_acl_t connect_acl  ;
#line 301
int dicod_inetd(void) ;
#line 302
void dicod_init_strategies(void) ;
#line 303
void dicod_server_init(void) ;
#line 308
dicod_database_t *find_database(char const   *name ) ;
#line 309
void database_remove_dependent(dicod_module_instance_t *inst ) ;
#line 310
void dicod_database_free(dicod_database_t *dp ) ;
#line 311
size_t database_count(void) ;
#line 312
int database_iterate(int (*fun)(void *item , void *data ) , void *data ) ;
#line 313
int show_sys_info_p(void) ;
#line 315
void dicod_log_pre_setup(void) ;
#line 318
void check_db_visibility(void) ;
#line 319
void reset_db_visibility(void) ;
#line 321
int dicod_any_lang_list_p(dico_list_t list ) ;
#line 338
void dicod_init_command_tab(void) ;
#line 347
int dicod_capa_flush(void) ;
#line 350
void register_lang(void) ;
#line 351
int dicod_lang_check(dico_list_t *list ) ;
#line 367
void register_lev(void) ;
#line 385 "./dicod.h"
dicod_user_db_t user_db  ;
#line 399
void register_auth(void) ;
#line 403
void dicod_loader_init(void) ;
#line 416
void dicod_get_database_languages(dicod_database_t *db , dico_list_t *dlist ) ;
#line 466
void compile_access_log(void) ;
#line 474
int alias_install(char const   *kw , int argc , char **argv , dicod_locus_t *ploc ) ;
#line 485
void register_sasl(void) ;
#line 117 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 24 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
char *config_file  =    (char *)"/usr/local/etc/dicod.conf";
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
char *pidfile_name  =    (char *)"/usr/local/var/run/dicod.pid";
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int mode  =    0;
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
unsigned int max_children  =    64U;
#line 41 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
unsigned int shutdown_timeout  =    5U;
#line 43 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
unsigned int inactivity_timeout  =    0U;
#line 47 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
char const   *log_tag  ;
#line 48 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int log_facility  =    3 << 3;
#line 49 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int log_print_severity  ;
#line 55 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
dicod_acl_t show_sys_info  ;
#line 88 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
dicod_acl_t global_acl  ;
#line 104 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
long ident_timeout  =    3L;
#line 112 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int allow_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
             config_value_t *value , void *cb_data ) 
{ 
  dicod_acl_t acl ;
  char *tmp ;
  char *__cil_tmp8 ;

  {
#line 119
  acl = (dicod_acl_t )varptr;
#line 121
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 122
    tmp = gettext("Unexpected block statement");
#line 122
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 123
    return (1);
  }
  {
#line 125
  parse_acl_line(locus___0, 1, acl, value);
  }
#line 126
  return (0);
}
}
#line 129 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int deny_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
            config_value_t *value , void *cb_data ) 
{ 
  dicod_acl_t acl ;
  char *tmp ;
  char *__cil_tmp8 ;

  {
#line 136
  acl = (dicod_acl_t )varptr;
#line 137
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 138
    tmp = gettext("Unexpected block statement");
#line 138
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 139
    return (1);
  }
  {
#line 141
  parse_acl_line(locus___0, 0, acl, value);
  }
#line 142
  return (0);
}
}
#line 145 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int acl_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
           config_value_t *value , void *cb_data ) 
{ 
  void **pdata ;
  dicod_acl_t acl ;
  char *tmp ;
  char *tmp___0 ;
  dicod_locus_t defn_loc ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 152
  pdata = (void **)cb_data;
  {
#line 156
  if ((unsigned int )cmd___6 == 0U) {
#line 156
    goto case_0;
  }
#line 177
  if ((unsigned int )cmd___6 == 2U) {
#line 177
    goto case_2;
  }
#line 177
  if ((unsigned int )cmd___6 == 1U) {
#line 177
    goto case_2;
  }
#line 155
  goto switch_break;
  case_0: /* CIL Label */ 
#line 157
  if (value->type != 0) {
    {
#line 158
    tmp = gettext("ACL name must be a string");
#line 158
    config_error(locus___0, 0, (char const   *)tmp);
    }
  } else
#line 159
  if (! value->v.string) {
    {
#line 160
    tmp___0 = gettext("missing ACL name");
#line 160
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
  } else {
    {
#line 163
    acl = dicod_acl_create(value->v.string, locus___0);
#line 164
    tmp___3 = dicod_acl_install(acl, & defn_loc);
    }
#line 164
    if (tmp___3) {
      {
#line 165
      tmp___1 = gettext("redefinition of ACL %s");
#line 165
      config_error(locus___0, 0, (char const   *)tmp___1, value->v.string);
#line 168
      tmp___2 = gettext("location of the previous definition");
#line 168
      config_error(& defn_loc, 0, (char const   *)tmp___2);
      }
#line 170
      return (1);
    }
#line 172
    *pdata = (void *)acl;
  }
#line 174
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 178
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 180
  return (0);
}
}
#line 183 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
struct config_keyword kwd_acl[3]  = {      {"allow", "[all|authenticated|group <grp: list>] [from <addr: list>]", "Allow access",
      (enum config_data_type )1, (void *)0, (size_t )0, & allow_cb, (void *)0, (struct config_keyword *)0}, 
        {"deny",
      "[all|authenticated|group <grp: list>] [from <addr: list>]", "Deny access",
      (enum config_data_type )1, (void *)0, (size_t )0, & deny_cb, (void *)0, (struct config_keyword *)0}, 
        {(char const   *)((void *)0),
      (char const   *)0, (char const   *)0, 0U, (void *)0, 0U, (int (*)(enum cfg_callback_command cmd ,
                                                                        dicod_locus_t * ,
                                                                        void * , config_value_t * ,
                                                                        void * ))0,
      (void *)0, (struct config_keyword *)0}};
#line 195 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int apply_acl_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
                 config_value_t *value , void *cb_data ) 
{ 
  dicod_acl_t *pacl ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  dicod_acl_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 202
  pacl = (dicod_acl_t *)varptr;
#line 204
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 205
    tmp = gettext("Unexpected block statement");
#line 205
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 206
    return (1);
  }
#line 208
  if (value->type != 0) {
    {
#line 209
    tmp___0 = gettext("expected scalar value");
#line 209
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
#line 210
    return (1);
  }
  {
#line 212
  tmp___2 = dicod_acl_lookup(value->v.string);
#line 212
  *pacl = tmp___2;
  }
#line 212
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 213
    tmp___1 = gettext("no such ACL: `%s\'");
#line 213
    config_error(locus___0, 0, (char const   *)tmp___1, value->v.string);
    }
#line 215
    return (1);
  }
#line 217
  return (0);
}
}
#line 221 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int set_user(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
             config_value_t *value , void *cb_data ) 
{ 
  struct passwd *pw ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 230
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 231
    tmp = gettext("Unexpected block statement");
#line 231
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 232
    return (1);
  }
#line 235
  if (value->type != 0) {
    {
#line 236
    tmp___0 = gettext("expected scalar value but found list");
#line 236
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
#line 237
    return (1);
  }
  {
#line 240
  pw = getpwnam(value->v.string);
  }
#line 241
  if (! pw) {
    {
#line 242
    tmp___1 = gettext("%s: no such user");
#line 242
    config_error(locus___0, 0, (char const   *)tmp___1, value->v.string);
    }
#line 243
    return (1);
  }
#line 245
  user_id = pw->pw_uid;
#line 246
  group_id = pw->pw_gid;
#line 247
  return (0);
}
}
#line 250
static int set_supp_group(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                          void *varptr , config_value_t *value , void *cb_data ) ;
#line 256 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static int set_supp_group_iter(void *item , void *data ) 
{ 
  int tmp ;

  {
  {
#line 259
  tmp = set_supp_group((enum cfg_callback_command )2, (dicod_locus_t *)data, (void *)0,
                       (config_value_t *)item, (void *)0);
  }
#line 259
  return (tmp);
}
}
#line 266 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static int set_supp_group(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                          void *varptr , config_value_t *value , void *cb_data ) 
{ 
  char *tmp ;
  struct group *group ;
  struct group *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 273
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 274
    tmp = gettext("Unexpected block statement");
#line 274
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 275
    return (1);
  }
#line 278
  if (! group_list) {
    {
#line 279
    group_list = xdico_list_create();
    }
  }
#line 281
  if (value->type == 1) {
    {
#line 282
    dico_list_iterate(value->v.list, & set_supp_group_iter, (void *)locus___0);
    }
  } else {
    {
#line 284
    tmp___0 = getgrnam(value->v.string);
#line 284
    group = tmp___0;
    }
#line 285
    if (group) {
      {
#line 286
      xdico_list_append(group_list, (void *)group->gr_gid);
      }
    } else {
      {
#line 288
      tmp___1 = gettext("%s: unknown group");
#line 288
      config_error(locus___0, 0, (char const   *)tmp___1, value->v.string);
      }
#line 289
      return (1);
    }
  }
#line 292
  return (0);
}
}
#line 302
int set_mode(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
             config_value_t *value , void *cb_data ) ;
#line 302 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static struct xlat_tab tab[3]  = {      {(char *)"daemon", 0}, 
        {(char *)"inetd", 1}, 
        {(char *)((void *)0), 0}};
#line 295 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int set_mode(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
             config_value_t *value , void *cb_data ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 308
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 309
    tmp = gettext("Unexpected block statement");
#line 309
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 310
    return (1);
  }
#line 313
  if (value->type != 0) {
    {
#line 314
    tmp___0 = gettext("expected scalar value but found list");
#line 314
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
#line 315
    return (1);
  }
  {
#line 317
  tmp___2 = xlat_c_string(tab, value->v.string, 0, & mode);
  }
#line 317
  if (tmp___2) {
    {
#line 318
    tmp___1 = gettext("unknown mode");
#line 318
    config_error(locus___0, 0, (char const   *)tmp___1);
    }
#line 319
    return (1);
  }
#line 321
  return (0);
}
}
#line 324 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static struct xlat_tab syslog_facility_tab[15]  = 
#line 324
  {      {(char *)"USER", 1 << 3}, 
        {(char *)"DAEMON", 3 << 3}, 
        {(char *)"AUTH", 4 << 3}, 
        {(char *)"AUTHPRIV", 10 << 3}, 
        {(char *)"MAIL", 2 << 3}, 
        {(char *)"CRON", 9 << 3}, 
        {(char *)"LOCAL0", 16 << 3}, 
        {(char *)"LOCAL1", 17 << 3}, 
        {(char *)"LOCAL2", 18 << 3}, 
        {(char *)"LOCAL3", 19 << 3}, 
        {(char *)"LOCAL4", 20 << 3}, 
        {(char *)"LOCAL5", 21 << 3}, 
        {(char *)"LOCAL6", 22 << 3}, 
        {(char *)"LOCAL7", 23 << 3}, 
        {(char *)((void *)0), 0}};
#line 342 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int set_log_facility(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                     void *varptr , config_value_t *value , void *cb_data ) 
{ 
  char const   *str ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 351
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 352
    tmp = gettext("Unexpected block statement");
#line 352
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 353
    return (1);
  }
#line 355
  if (value->type != 0) {
    {
#line 356
    tmp___0 = gettext("expected scalar value but found list");
#line 356
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
#line 357
    return (1);
  }
  {
#line 359
  str = value->v.string;
#line 360
  tmp___1 = strncasecmp(str, "LOG_", (size_t )4);
  }
#line 360
  if (tmp___1 == 0) {
#line 361
    str += 4;
  }
  {
#line 362
  tmp___3 = xlat_c_string(syslog_facility_tab, str, 1, & log_facility);
  }
#line 362
  if (tmp___3) {
    {
#line 363
    tmp___2 = gettext("unknown syslog facility");
#line 363
    config_error(locus___0, 0, (char const   *)tmp___2);
    }
#line 364
    return (1);
  }
#line 366
  return (0);
}
}
#line 369 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static int cmp_modinst_ident(void const   *item , void *data ) 
{ 
  dicod_module_instance_t const   *inst ;
  int tmp ;

  {
#line 372
  inst = (dicod_module_instance_t const   *)item;
#line 373
  if (! inst->ident) {
#line 374
    return (1);
  }
  {
#line 375
  tmp = strcmp((char const   *)inst->ident, (char const   *)data);
  }
#line 375
  return (tmp);
}
}
#line 378 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int load_module_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                   void *varptr , config_value_t *value , void *cb_data ) 
{ 
  dicod_module_instance_t *inst ;
  void **pdata ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 386
  pdata = (void **)cb_data;
  {
#line 389
  if ((unsigned int )cmd___6 == 0U) {
#line 389
    goto case_0;
  }
#line 400
  if ((unsigned int )cmd___6 == 1U) {
#line 400
    goto case_1;
  }
#line 410
  if ((unsigned int )cmd___6 == 2U) {
#line 410
    goto case_2;
  }
#line 388
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 390
  tmp = xzalloc((size_t )sizeof(*inst));
#line 390
  inst = (dicod_module_instance_t *)tmp;
  }
#line 391
  if (value->type != 0) {
    {
#line 392
    tmp___0 = gettext("tag must be a string");
#line 392
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
  } else
#line 393
  if ((unsigned long )value->v.string == (unsigned long )((void *)0)) {
    {
#line 394
    tmp___1 = gettext("missing tag");
#line 394
    config_error(locus___0, 0, (char const   *)tmp___1);
    }
  } else {
    {
#line 396
    inst->ident = strdup(value->v.string);
    }
  }
#line 397
  *pdata = (void *)inst;
#line 398
  goto switch_break;
  case_1: /* CIL Label */ 
#line 401
  if (! modinst_list) {
    {
#line 402
    modinst_list = xdico_list_create();
#line 403
    dico_list_set_comparator(modinst_list, & cmp_modinst_ident);
    }
  }
  {
#line 405
  inst = (dicod_module_instance_t *)*pdata;
#line 406
  xdico_list_append(modinst_list, (void *)inst);
#line 407
  *pdata = (void *)0;
  }
#line 408
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 411
  tmp___2 = gettext("invalid use of block statement");
#line 411
  config_error(locus___0, 0, (char const   *)tmp___2);
  }
  switch_break: /* CIL Label */ ;
  }
#line 413
  return (0);
}
}
#line 416 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static int add_char_ptr(void *item , void *data ) 
{ 
  dico_list_t list ;
  char *tmp ;

  {
  {
#line 419
  list = (dico_list_t )data;
#line 420
  tmp = xstrdup((char const   *)*((char **)item));
#line 420
  xdico_list_append(list, (void *)tmp);
  }
#line 421
  return (0);
}
}
#line 425 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static void fix_lang_list(dicod_database_t *db , int n ) 
{ 
  dico_list_t newlist ;
  int tmp ;

  {
#line 429
  if (! db->langlist[n]) {
#line 430
    return;
  }
  {
#line 431
  newlist = xdico_list_create();
#line 432
  dico_list_set_free_item(newlist, & dicod_free_item, (void *)0);
#line 433
  dico_list_iterate(db->langlist[n], & add_char_ptr, (void *)newlist);
#line 434
  dico_list_destroy(& db->langlist[n]);
#line 435
  tmp = dicod_any_lang_list_p(newlist);
  }
#line 435
  if (tmp) {
    {
#line 436
    dico_list_destroy(& newlist);
    }
  }
#line 437
  db->langlist[n] = newlist;
#line 438
  db->flags |= 1;
#line 439
  return;
}
}
#line 441 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static int cmp_database_name(void const   *item , void *data ) 
{ 
  dicod_database_t const   *db ;
  int rc ;

  {
#line 444
  db = (dicod_database_t const   *)item;
#line 447
  if (! db->name) {
#line 448
    return (1);
  }
  {
#line 449
  rc = strcmp((char const   *)db->name, (char const   *)data);
  }
#line 450
  if (rc == 0) {
#line 450
    if (! db->visible) {
#line 451
      rc = 1;
    }
  }
#line 452
  return (rc);
}
}
#line 455 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static int set_database(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                        void *varptr , config_value_t *value , void *cb_data ) 
{ 
  dicod_database_t *dict ;
  void **pdata ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 463
  pdata = (void **)cb_data;
  {
#line 466
  if ((unsigned int )cmd___6 == 0U) {
#line 466
    goto case_0;
  }
#line 475
  if ((unsigned int )cmd___6 == 1U) {
#line 475
    goto case_1;
  }
#line 487
  if ((unsigned int )cmd___6 == 2U) {
#line 487
    goto case_2;
  }
#line 465
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 467
  tmp = xzalloc((size_t )sizeof(*dict));
#line 467
  dict = (dicod_database_t *)tmp;
  }
#line 468
  if (value->type != 0) {
    {
#line 469
    tmp___0 = gettext("tag must be a string");
#line 469
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
  } else
#line 470
  if (value->v.string) {
    {
#line 471
    dict->name = strdup(value->v.string);
    }
  }
#line 472
  *pdata = (void *)dict;
#line 473
  goto switch_break;
  case_1: /* CIL Label */ 
#line 476
  if (! database_list) {
    {
#line 477
    database_list = xdico_list_create();
#line 478
    dico_list_set_comparator(database_list, & cmp_database_name);
    }
  }
  {
#line 480
  dict = (dicod_database_t *)*pdata;
#line 481
  fix_lang_list(dict, 0);
#line 482
  fix_lang_list(dict, 1);
#line 483
  xdico_list_append(database_list, (void *)dict);
#line 484
  *pdata = (void *)0;
  }
#line 485
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 488
  tmp___1 = gettext("invalid use of block statement");
#line 488
  config_error(locus___0, 0, (char const   *)tmp___1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 490
  return (0);
}
}
#line 493 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int set_dict_handler(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                     void *varptr , config_value_t *value , void *cb_data ) 
{ 
  dicod_module_instance_t *inst ;
  dicod_database_t *db ;
  int rc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 501
  db = (dicod_database_t *)varptr;
#line 504
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 505
    tmp = gettext("Unexpected block statement");
#line 505
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 506
    return (1);
  }
#line 509
  if (value->type != 0) {
    {
#line 510
    tmp___0 = gettext("expected scalar value but found list");
#line 510
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
#line 511
    return (1);
  }
  {
#line 514
  db->command = (char *)value->v.string;
#line 515
  rc = dico_argcv_get(value->v.string, (char const   *)((void *)0), (char const   *)((void *)0),
                      & db->argc, & db->argv);
  }
#line 515
  if (rc) {
    {
#line 517
    tmp___1 = gettext("cannot parse command line `%s\'");
#line 517
    config_error(locus___0, rc, (char const   *)tmp___1, value->v.string);
#line 519
    dicod_database_free(db);
    }
#line 520
    return (1);
  }
  {
#line 523
  tmp___2 = dico_list_locate(modinst_list, (void *)*(db->argv + 0));
#line 523
  inst = (dicod_module_instance_t *)tmp___2;
  }
#line 524
  if (! inst) {
    {
#line 525
    tmp___3 = gettext("%s: handler not declared");
#line 525
    config_error(locus___0, 0, (char const   *)tmp___3, *(db->argv + 0));
    }
#line 527
    return (1);
  }
#line 529
  db->instance = inst;
#line 531
  return (0);
}
}
#line 534
int enable_capability(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                      void *varptr , config_value_t *value , void *cb_data ) ;
#line 540 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int set_capability(void *item , void *data ) 
{ 
  int tmp ;

  {
  {
#line 543
  tmp = enable_capability((enum cfg_callback_command )2, (dicod_locus_t *)data, (void *)0,
                          (config_value_t *)item, (void *)0);
  }
#line 543
  return (tmp);
}
}
#line 550 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int enable_capability(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                      void *varptr , config_value_t *value , void *cb_data ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 557
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 558
    tmp = gettext("Unexpected block statement");
#line 558
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 559
    return (1);
  }
#line 561
  if (value->type == 1) {
    {
#line 562
    dico_list_iterate(value->v.list, & set_capability, (void *)locus___0);
    }
  } else {
    {
#line 563
    tmp___1 = dicod_capa_add(value->v.string);
    }
#line 563
    if (tmp___1) {
      {
#line 564
      tmp___0 = gettext("unknown capability: %s");
#line 564
      config_error(locus___0, 0, (char const   *)tmp___0, value->v.string);
      }
    }
  }
#line 565
  return (0);
}
}
#line 568 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int set_defstrat(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
                 config_value_t *value , void *cb_data ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 575
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 576
    tmp = gettext("Unexpected block statement");
#line 576
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 577
    return (1);
  }
#line 579
  if (value->type != 0) {
    {
#line 580
    tmp___0 = gettext("expected scalar value but found list");
#line 580
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
#line 581
    return (1);
  }
  {
#line 583
  tmp___2 = dico_set_default_strategy(value->v.string);
  }
#line 583
  if (tmp___2) {
    {
#line 584
    tmp___1 = gettext("unknown strategy");
#line 584
    config_error(locus___0, 0, (char const   *)tmp___1);
    }
#line 585
    return (1);
  }
#line 587
  return (0);
}
}
#line 590 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int mime_headers_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                    void *varptr , config_value_t *value , void *cb_data ) 
{ 
  dico_assoc_list_t *pasc ;
  char const   *enc ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 597
  pasc = (dico_assoc_list_t *)varptr;
#line 600
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 601
    tmp = gettext("Unexpected block statement");
#line 601
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 602
    return (1);
  }
#line 605
  if (value->type != 0) {
    {
#line 606
    tmp___0 = gettext("expected scalar value");
#line 606
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
#line 607
    return (1);
  }
  {
#line 610
  tmp___4 = dico_header_parse(pasc, value->v.string);
  }
#line 610
  if (tmp___4) {
    {
#line 611
    tmp___1 = __errno_location();
#line 611
    tmp___2 = strerror(*tmp___1);
#line 611
    tmp___3 = gettext("cannot parse headers: %s");
#line 611
    config_error(locus___0, 0, (char const   *)tmp___3, tmp___2);
    }
  }
  {
#line 614
  enc = dico_assoc_find(*pasc, "Content-transfer-encoding");
  }
#line 614
  if (enc) {
    {
#line 615
    tmp___6 = strcmp(enc, "quoted-printable");
    }
#line 615
    if (! (tmp___6 == 0)) {
      {
#line 615
      tmp___7 = strcmp(enc, "base64");
      }
#line 615
      if (! (tmp___7 == 0)) {
        {
#line 615
        tmp___8 = strcmp(enc, "8bit");
        }
#line 615
        if (! (tmp___8 == 0)) {
          {
#line 618
          tmp___5 = gettext("unknown encoding type: %s");
#line 618
          config_error(locus___0, 0, (char const   *)tmp___5, enc);
          }
        }
      }
    }
  }
#line 621
  return (0);
}
}
#line 624 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
struct config_keyword kwd_load_module[2]  = {      {"command", "arg", "Command line.", (enum config_data_type )1, (void *)0, (size_t )((unsigned long )(& ((dicod_module_instance_t *)0)->command)),
      (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
               void * ))0, (void *)0, (struct config_keyword *)0}, 
        {(char const   *)((void *)0), (char const   *)0, (char const   *)0, 0U, (void *)0,
      0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
                   void * ))0, (void *)0, (struct config_keyword *)0}};
#line 630 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
struct config_keyword kwd_database[9]  = 
#line 630
  {      {"name", "word", "Dictionary name (a single word).", (enum config_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((dicod_database_t *)0)->name)), (int (*)(enum cfg_callback_command cmd ,
                                                                                        dicod_locus_t * ,
                                                                                        void * ,
                                                                                        config_value_t * ,
                                                                                        void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"description", "arg", "Short description, to be shown in reply to SHOW DB command.",
      (enum config_data_type )1, (void *)0, (size_t )((unsigned long )(& ((dicod_database_t *)0)->descr)),
      (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
               void * ))0, (void *)0, (struct config_keyword *)0}, 
        {"info", "arg", "Full description of the database, to be shown in reply to SHOW INFO command.",
      (enum config_data_type )1, (void *)0, (size_t )((unsigned long )(& ((dicod_database_t *)0)->info)),
      (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
               void * ))0, (void *)0, (struct config_keyword *)0}, 
        {"languages-from", "arg", "List of languages this database translates from.",
      (enum config_data_type )32769, (void *)0, (size_t )((unsigned long )(& ((dicod_database_t *)0)->langlist[0])),
      (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
               void * ))0, (void *)0, (struct config_keyword *)0}, 
        {"languages-to", "arg", "List of languages this database translates to.", (enum config_data_type )32769,
      (void *)0, (size_t )((unsigned long )(& ((dicod_database_t *)0)->langlist[1])),
      (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
               void * ))0, (void *)0, (struct config_keyword *)0}, 
        {"handler", "name", "Name of the handler for this database.", (enum config_data_type )1,
      (void *)0, (size_t )0, & set_dict_handler, (void *)0, (struct config_keyword *)0}, 
        {"visibility-acl",
      "arg: acl", "ACL controlling visibility of this database", (enum config_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((dicod_database_t *)0)->acl)), & apply_acl_cb,
      (void *)0, (struct config_keyword *)0}, 
        {"mime-headers", "text", "Additional MIME headers", (enum config_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((dicod_database_t *)0)->mime_headers)),
      & mime_headers_cb, (void *)0, (struct config_keyword *)0}, 
        {(char const   *)((void *)0), (char const   *)0, (char const   *)0, 0U, (void *)0,
      0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
                   void * ))0, (void *)0, (struct config_keyword *)0}};
#line 665 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
struct user_db_conf user_db_cfg  ;
#line 667 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
struct config_keyword kwd_user_db[3]  = {      {"password-resource", "arg", "Password file or query.", (enum config_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct user_db_conf *)0)->get_pw)),
      (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
               void * ))0, (void *)0, (struct config_keyword *)0}, 
        {"group-resource", "arg", "File containing user group information or a query to retrieve it.",
      (enum config_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct user_db_conf *)0)->get_groups)),
      (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
               void * ))0, (void *)0, (struct config_keyword *)0}, 
        {(char const   *)((void *)0), (char const   *)0, (char const   *)0, 0U, (void *)0,
      0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
                   void * ))0, (void *)0, (struct config_keyword *)0}};
#line 676 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int user_db_config(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                   void *varptr , config_value_t *value , void *cb_data ) 
{ 
  struct user_db_conf *cfg ;
  void **pdata ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 683
  cfg = (struct user_db_conf *)varptr;
#line 684
  pdata = (void **)cb_data;
  {
#line 687
  if ((unsigned int )cmd___6 == 0U) {
#line 687
    goto case_0;
  }
#line 697
  if ((unsigned int )cmd___6 == 1U) {
#line 697
    goto case_1;
  }
#line 701
  if ((unsigned int )cmd___6 == 2U) {
#line 701
    goto case_2;
  }
#line 686
  goto switch_break;
  case_0: /* CIL Label */ 
#line 688
  if (value->type != 0) {
    {
#line 689
    tmp = gettext("URL must be a string");
#line 689
    config_error(locus___0, 0, (char const   *)tmp);
    }
  } else
#line 690
  if (! value->v.string) {
    {
#line 691
    tmp___0 = gettext("empty URL");
#line 691
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
  } else {
    {
#line 693
    cfg->url = strdup(value->v.string);
    }
  }
#line 694
  *pdata = (void *)cfg;
#line 695
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 698
  udb_create(& user_db, (char const   *)cfg->url, (char const   *)cfg->get_pw, (char const   *)cfg->get_groups,
             locus___0);
  }
#line 699
  goto switch_break;
  case_2: /* CIL Label */ 
#line 702
  if (value->type != 0) {
    {
#line 703
    tmp___1 = gettext("URL must be a string");
#line 703
    config_error(locus___0, 0, (char const   *)tmp___1);
    }
  } else
#line 704
  if (! value->v.string) {
    {
#line 705
    tmp___2 = gettext("empty URL");
#line 705
    config_error(locus___0, 0, (char const   *)tmp___2);
    }
  }
  {
#line 706
  udb_create(& user_db, value->v.string, (char const   *)((void *)0), (char const   *)((void *)0),
             locus___0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 708
  return (0);
}
}
#line 712 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int alias_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
             config_value_t *value , void *cb_data ) 
{ 
  char **argv ;
  int argc ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 723
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 724
    tmp = gettext("Unexpected block statement");
#line 724
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 725
    return (1);
  }
#line 727
  if (value->type != 2) {
    {
#line 728
    tmp___0 = gettext("Not enough arguments for alias");
#line 728
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
#line 729
    return (1);
  }
  {
#line 731
  argc = (int )(value->v.arg.c - 1U);
#line 732
  tmp___1 = xcalloc((size_t )(argc + 1), (size_t )sizeof(*(argv + 0)));
#line 732
  argv = (char **)tmp___1;
#line 733
  i = 0;
  }
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! (i < argc)) {
#line 733
      goto while_break;
    }
#line 734
    if ((value->v.arg.v + (i + 1))->type != 0) {
      {
#line 735
      tmp___2 = gettext("argument %d has wrong type");
#line 735
      config_error(locus___0, 0, (char const   *)tmp___2, i + 1);
      }
#line 736
      return (1);
    }
#line 738
    *(argv + i) = (char *)(value->v.arg.v + (i + 1))->v.string;
#line 733
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 740
  *(argv + i) = (char *)((void *)0);
#line 741
  tmp___3 = alias_install((value->v.arg.v + 0)->v.string, argc, argv, locus___0);
  }
#line 741
  return (tmp___3);
}
}
#line 782 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static dico_list_t strat_forward  ;
#line 784 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static int flush_strat_forward_fn(void *item , void *data ) 
{ 
  dico_strategy_t strat ;
  dico_strategy_t p ;
  void *tmp ;

  {
  {
#line 787
  strat = (dico_strategy_t )item;
#line 788
  tmp = dico_list_locate(strat_forward, (void *)strat->name);
#line 788
  p = (dico_strategy_t )tmp;
  }
#line 789
  if (p) {
#line 789
    if (p->stratcl) {
#line 790
      strat->stratcl = p->stratcl;
#line 791
      p->stratcl = (dico_list_t )((void *)0);
    }
  }
#line 793
  return (0);
}
}
#line 796 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void flush_strat_forward(void) 
{ 


  {
  {
#line 799
  dico_strategy_iterate(& flush_strat_forward_fn, (void *)0);
#line 800
  dico_list_destroy(& strat_forward);
  }
#line 801
  return;
}
}
#line 803 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int strategy_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
                config_value_t *value , void *cb_data ) 
{ 
  void **pdata ;
  char *tmp ;
  char *tmp___0 ;
  dico_strategy_t strat ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 810
  pdata = (void **)cb_data;
  {
#line 813
  if ((unsigned int )cmd___6 == 0U) {
#line 813
    goto case_0;
  }
#line 837
  if ((unsigned int )cmd___6 == 1U) {
#line 837
    goto case_1;
  }
#line 840
  if ((unsigned int )cmd___6 == 2U) {
#line 840
    goto case_2;
  }
#line 812
  goto switch_break;
  case_0: /* CIL Label */ 
#line 814
  if (value->type != 0) {
    {
#line 815
    tmp = gettext("Section name must be a string");
#line 815
    config_error(locus___0, 0, (char const   *)tmp);
    }
  } else
#line 816
  if (! value->v.string) {
    {
#line 817
    tmp___0 = gettext("missing section name");
#line 817
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
  } else {
    {
#line 819
    tmp___1 = dico_list_locate(strat_forward, (void *)value->v.string);
#line 819
    strat = (dico_strategy_t )tmp___1;
    }
#line 821
    if (! strat) {
      {
#line 822
      strat = dico_strategy_create(value->v.string, "");
#line 823
      strat->stratcl = xdico_list_create();
      }
#line 824
      if (! strat_forward) {
        {
#line 825
        strat_forward = xdico_list_create();
#line 826
        dico_list_set_comparator(strat_forward, & dico_strat_name_cmp);
#line 828
        dico_list_set_free_item(strat_forward, & dico_strat_free, (void *)0);
        }
      }
      {
#line 831
      xdico_list_append(strat_forward, (void *)strat);
      }
    }
#line 833
    *pdata = (void *)strat;
  }
#line 835
  goto switch_break;
  case_1: /* CIL Label */ 
#line 838
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 841
  tmp___2 = gettext("Unexpected statement");
#line 841
  config_error(locus___0, 0, (char const   *)tmp___2);
  }
  switch_break: /* CIL Label */ ;
  }
#line 843
  return (0);
}
}
#line 846 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int strategy_deny_all_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                         void *varptr , config_value_t *value , void *cb_data ) 
{ 
  int bool ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 855
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 856
    tmp = gettext("Unexpected block statement");
#line 856
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 857
    return (1);
  }
#line 859
  if (value->type == 0) {
    {
#line 859
    tmp___1 = string_to_bool(value->v.string, & bool);
    }
#line 859
    if (tmp___1 == 0) {
#line 861
      if (bool) {
        {
#line 862
        stratcl_add_disable(*((dico_list_t *)varptr));
        }
      }
    } else {
      {
#line 864
      tmp___0 = gettext("Expected boolean value");
#line 864
      config_error(locus___0, 0, (char const   *)tmp___0);
      }
    }
  } else {
    {
#line 864
    tmp___0 = gettext("Expected boolean value");
#line 864
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
  }
#line 865
  return (0);
}
}
#line 873 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static int add_deny_word(void *item , void *data ) 
{ 
  char *word ;
  struct compile_pattern_closure *cpc ;

  {
  {
#line 876
  word = (char *)item;
#line 877
  cpc = (struct compile_pattern_closure *)data;
#line 878
  stratcl_add_word(cpc->list, (char const   *)word);
  }
#line 879
  return (0);
}
}
#line 882 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int strategy_deny_word_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                          void *varptr , config_value_t *value , void *cb_data ) 
{ 
  struct compile_pattern_closure cpc ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 891
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 892
    tmp = gettext("Unexpected block statement");
#line 892
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 893
    return (1);
  }
#line 895
  cpc.list = *((dico_list_t *)varptr);
#line 896
  cpc.locus = locus___0;
#line 897
  if (value->type == 1) {
    {
#line 898
    dico_list_iterate(value->v.list, & add_deny_word, (void *)(& cpc));
    }
  } else
#line 899
  if (value->type == 0) {
    {
#line 900
    add_deny_word((void *)value->v.string, (void *)(& cpc));
    }
  } else {
    {
#line 902
    tmp___0 = gettext("expected list or string");
#line 902
    config_error(locus___0, 0, (char const   *)tmp___0);
    }
  }
#line 903
  return (0);
}
}
#line 906 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int strategy_deny_length(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                         dico_list_t list , config_value_t *value , enum cmp_op op ) 
{ 
  char *tmp ;
  uintmax_t val ;
  int tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 913
  if ((unsigned int )cmd___6 != 2U) {
    {
#line 914
    tmp = gettext("Unexpected block statement");
#line 914
    config_error(locus___0, 0, (char const   *)tmp);
    }
#line 915
    return (0);
  }
#line 917
  if (value->type == 0) {
    {
#line 920
    tmp___0 = string_to_unsigned(& val, value->v.string, (uintmax_t )((size_t )-1),
                                 locus___0);
    }
#line 920
    if (tmp___0) {
#line 921
      return (0);
    }
    {
#line 922
    stratcl_add_cmp(list, op, (size_t )val);
    }
  } else {
    {
#line 924
    tmp___1 = gettext("Expected number");
#line 924
    config_error(locus___0, 0, (char const   *)tmp___1);
    }
  }
#line 925
  return (0);
}
}
#line 928 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int strategy_deny_length_lt_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                               void *varptr , config_value_t *value , void *cb_data ) 
{ 
  int tmp ;

  {
  {
#line 935
  tmp = strategy_deny_length(cmd___6, locus___0, *((dico_list_t *)varptr), value,
                             (enum cmp_op )2);
  }
#line 935
  return (tmp);
}
}
#line 939 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int strategy_deny_length_le_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                               void *varptr , config_value_t *value , void *cb_data ) 
{ 
  int tmp ;

  {
  {
#line 946
  tmp = strategy_deny_length(cmd___6, locus___0, *((dico_list_t *)varptr), value,
                             (enum cmp_op )3);
  }
#line 946
  return (tmp);
}
}
#line 950 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int strategy_deny_length_gt_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                               void *varptr , config_value_t *value , void *cb_data ) 
{ 
  int tmp ;

  {
  {
#line 957
  tmp = strategy_deny_length(cmd___6, locus___0, *((dico_list_t *)varptr), value,
                             (enum cmp_op )4);
  }
#line 957
  return (tmp);
}
}
#line 961 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int strategy_deny_length_ge_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                               void *varptr , config_value_t *value , void *cb_data ) 
{ 
  int tmp ;

  {
  {
#line 968
  tmp = strategy_deny_length(cmd___6, locus___0, *((dico_list_t *)varptr), value,
                             (enum cmp_op )5);
  }
#line 968
  return (tmp);
}
}
#line 972 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int strategy_deny_length_eq_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                               void *varptr , config_value_t *value , void *cb_data ) 
{ 
  int tmp ;

  {
  {
#line 979
  tmp = strategy_deny_length(cmd___6, locus___0, *((dico_list_t *)varptr), value,
                             (enum cmp_op )0);
  }
#line 979
  return (tmp);
}
}
#line 983 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int strategy_deny_length_ne_cb(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 ,
                               void *varptr , config_value_t *value , void *cb_data ) 
{ 
  int tmp ;

  {
  {
#line 990
  tmp = strategy_deny_length(cmd___6, locus___0, *((dico_list_t *)varptr), value,
                             (enum cmp_op )1);
  }
#line 990
  return (tmp);
}
}
#line 994 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
struct config_keyword kwd_strategy[9]  = 
#line 994
  {      {"deny-all", "arg: bool", "Deny all * and ! look ups", (enum config_data_type )1,
      (void *)0, (size_t )((unsigned long )(& ((struct dico_strategy *)0)->stratcl)),
      & strategy_deny_all_cb, (void *)0, (struct config_keyword *)0}, 
        {"deny-word", "cond", "Deny * and ! look-ups on these words.", (enum config_data_type )32769,
      (void *)0, (size_t )((unsigned long )(& ((struct dico_strategy *)0)->stratcl)),
      & strategy_deny_word_cb, (void *)0, (struct config_keyword *)0}, 
        {"deny-length-lt", "len: number", "Deny * and ! look-ups on words with length < <len>.",
      (enum config_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct dico_strategy *)0)->stratcl)),
      & strategy_deny_length_lt_cb, (void *)0, (struct config_keyword *)0}, 
        {"deny-length-le", "len: number", "Deny * and ! look-ups on words with length <= <len>.",
      (enum config_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct dico_strategy *)0)->stratcl)),
      & strategy_deny_length_le_cb, (void *)0, (struct config_keyword *)0}, 
        {"deny-length-gt", "len: number", "Deny * and ! look-ups on words with length > <len>.",
      (enum config_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct dico_strategy *)0)->stratcl)),
      & strategy_deny_length_gt_cb, (void *)0, (struct config_keyword *)0}, 
        {"deny-length-ge", "len: number", "Deny * and ! look-ups on words with length >= <len>.",
      (enum config_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct dico_strategy *)0)->stratcl)),
      & strategy_deny_length_ge_cb, (void *)0, (struct config_keyword *)0}, 
        {"deny-length-eq", "len: number", "Deny * and ! look-ups on words with length == <len>.",
      (enum config_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct dico_strategy *)0)->stratcl)),
      & strategy_deny_length_eq_cb, (void *)0, (struct config_keyword *)0}, 
        {"deny-length-ne", "len: number", "Deny * and ! look-ups on words with length != <len>.",
      (enum config_data_type )1, (void *)0, (size_t )((unsigned long )(& ((struct dico_strategy *)0)->stratcl)),
      & strategy_deny_length_ne_cb, (void *)0, (struct config_keyword *)0}, 
        {(char const   *)((void *)0), (char const   *)0, (char const   *)0, 0U, (void *)0,
      0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
                   void * ))0, (void *)0, (struct config_keyword *)0}};
#line 1035 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
struct config_keyword keywords[35]  = 
#line 1035
  {      {"user", "name", "Run with these user privileges.", (enum config_data_type )1,
      (void *)0, (size_t )0, & set_user, (void *)0, (struct config_keyword *)0}, 
        {"group", "name", "Supplementary group to retain with the user privileges.",
      (enum config_data_type )1, (void *)0, (size_t )0, & set_supp_group, (void *)0,
      (struct config_keyword *)0}, 
        {"mode", "arg: [daemon|inetd]", "Operation mode.", (enum config_data_type )1,
      (void *)0, (size_t )0, & set_mode, (void *)0, (struct config_keyword *)0}, 
        {"server-info", "text", "Server description to be shown in reply to SHOW SERVER command.",
      (enum config_data_type )1, (void *)(& server_info), 0U, (int (*)(enum cfg_callback_command cmd ,
                                                                       dicod_locus_t * ,
                                                                       void * , config_value_t * ,
                                                                       void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"show-sys-info", "arg: acl", "Show system information if arg matches.", (enum config_data_type )1,
      (void *)(& show_sys_info), (size_t )0, & apply_acl_cb, (void *)0, (struct config_keyword *)0}, 
        {"identity-check",
      "arg", "Enable identification check using AUTH protocol (RFC 1413)", (enum config_data_type )12,
      (void *)(& identity_check), 0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * ,
                                               void * , config_value_t * , void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"ident-timeout", "val", "Set timeout for AUTH I/O operations.", (enum config_data_type )6,
      (void *)(& ident_timeout), 0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * ,
                                              void * , config_value_t * , void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"ident-keyfile", "name", "Name of the file containing the keys for decrypting AUTH replies.",
      (enum config_data_type )1, (void *)(& ident_keyfile), 0U, (int (*)(enum cfg_callback_command cmd ,
                                                                         dicod_locus_t * ,
                                                                         void * ,
                                                                         config_value_t * ,
                                                                         void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"max-children", "arg", "Maximum number of children running simultaneously.",
      (enum config_data_type )5, (void *)(& max_children), (size_t )0, (int (*)(enum cfg_callback_command cmd ,
                                                                                dicod_locus_t * ,
                                                                                void * ,
                                                                                config_value_t * ,
                                                                                void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"log-tag", "arg", "Tag syslog diagnostics with this tag.", (enum config_data_type )1,
      (void *)(& log_tag), (size_t )0, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * ,
                                                void * , config_value_t * , void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"log-facility", "arg", "Set syslog facility. Arg is one of the following: user, daemon, auth, authpriv, mail, cron, local0 through local7 (case-insensitive), or a facility number.",
      (enum config_data_type )1, (void *)0, (size_t )0, & set_log_facility, (void *)0,
      (struct config_keyword *)0}, 
        {"log-print-severity", "arg", "Prefix diagnostics messages with their severity.",
      (enum config_data_type )12, (void *)(& log_print_severity), (size_t )0, (int (*)(enum cfg_callback_command cmd ,
                                                                                       dicod_locus_t * ,
                                                                                       void * ,
                                                                                       config_value_t * ,
                                                                                       void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"access-log-format", "fmt", "Set format string for access log file.", (enum config_data_type )1,
      (void *)(& access_log_format), 0U, (int (*)(enum cfg_callback_command cmd ,
                                                  dicod_locus_t * , void * , config_value_t * ,
                                                  void * ))0, (void *)0, (struct config_keyword *)0}, 
        {"access-log-file",
      "name", "Set access log file name.", (enum config_data_type )1, (void *)(& access_log_file),
      0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
                   void * ))0, (void *)0, (struct config_keyword *)0}, 
        {"transcript", "arg", "Log session transcript.", (enum config_data_type )12,
      (void *)(& transcript), 0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * ,
                                           void * , config_value_t * , void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"pidfile", "name", "Store PID of the master process in this file.", (enum config_data_type )1,
      (void *)(& pidfile_name), 0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * ,
                                             void * , config_value_t * , void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"shutdown-timeout", "seconds", "Wait this number of seconds for all children to terminate.",
      (enum config_data_type )5, (void *)(& shutdown_timeout), 0U, (int (*)(enum cfg_callback_command cmd ,
                                                                            dicod_locus_t * ,
                                                                            void * ,
                                                                            config_value_t * ,
                                                                            void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"inactivity-timeout", "seconds", "Set inactivity timeout.", (enum config_data_type )5,
      (void *)(& inactivity_timeout), 0U, (int (*)(enum cfg_callback_command cmd ,
                                                   dicod_locus_t * , void * , config_value_t * ,
                                                   void * ))0, (void *)0, (struct config_keyword *)0}, 
        {"listen",
      "addr", "Listen on these addresses.", (enum config_data_type )32784, (void *)(& listen_addr),
      0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
                   void * ))0, (void *)0, (struct config_keyword *)0}, 
        {"initial-banner-text", "text", "Display this text in the initial 220 banner",
      (enum config_data_type )1, (void *)(& initial_banner_text), 0U, (int (*)(enum cfg_callback_command cmd ,
                                                                               dicod_locus_t * ,
                                                                               void * ,
                                                                               config_value_t * ,
                                                                               void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"help-text", "text", "Display this text in reply to the HELP command. If text begins with a +, usual command summary is displayed before it.",
      (enum config_data_type )1, (void *)(& help_text), 0U, (int (*)(enum cfg_callback_command cmd ,
                                                                     dicod_locus_t * ,
                                                                     void * , config_value_t * ,
                                                                     void * ))0, (void *)0,
      (struct config_keyword *)0}, 
        {"hostname", "name", "Override the host name.", (enum config_data_type )1, (void *)(& hostname),
      0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
                   void * ))0, (void *)0, (struct config_keyword *)0}, 
        {"capability", "arg", "Request additional capabilities.", (enum config_data_type )32769,
      (void *)0, (size_t )0, & enable_capability, (void *)0, (struct config_keyword *)0}, 
        {"module-load-path",
      "path", "List of directories searched for database modules.", (enum config_data_type )32769,
      (void *)(& module_load_path), 0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * ,
                                                 void * , config_value_t * , void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"default-strategy", "name", "Set the name of the default matching strategy.",
      (enum config_data_type )1, (void *)0, (size_t )0, & set_defstrat, (void *)0,
      (struct config_keyword *)0}, 
        {"timing", "arg", "Provide timing information after successful completion of an operation.",
      (enum config_data_type )12, (void *)(& timing_option), 0U, (int (*)(enum cfg_callback_command cmd ,
                                                                          dicod_locus_t * ,
                                                                          void * ,
                                                                          config_value_t * ,
                                                                          void * ))0,
      (void *)0, (struct config_keyword *)0}, 
        {"visibility-acl", "arg: acl", "Set ACL to control visibility of all databases.",
      (enum config_data_type )1, (void *)(& global_acl), (size_t )0, & apply_acl_cb,
      (void *)0, (struct config_keyword *)0}, 
        {"connection-acl", "arg: acl", "Apply this ACL to incoming connections.", (enum config_data_type )1,
      (void *)(& connect_acl), (size_t )0, & apply_acl_cb, (void *)0, (struct config_keyword *)0}, 
        {"database",
      (char const   *)((void *)0), "Define a dictionary database.", (enum config_data_type )17,
      (void *)0, (size_t )0, & set_database, (void *)0, kwd_database}, 
        {"load-module", "name: string", "Load a module instance.", (enum config_data_type )17,
      (void *)0, (size_t )0, & load_module_cb, (void *)0, kwd_load_module}, 
        {"acl", "name: string", "Define an ACL.", (enum config_data_type )17, (void *)0,
      (size_t )0, & acl_cb, (void *)0, kwd_acl}, 
        {"user-db", "url: string", "Define user database for authentication.", (enum config_data_type )17,
      (void *)(& user_db_cfg), (size_t )0, & user_db_config, (void *)0, kwd_user_db}, 
        {"alias",
      "name: string", "Define a command alias.", (enum config_data_type )1, (void *)0,
      (size_t )0, & alias_cb, (void *)0, (struct config_keyword *)0}, 
        {"strategy", "name: string", "Additional configuration for strategy <name>",
      (enum config_data_type )17, (void *)0, (size_t )0, & strategy_cb, (void *)0,
      kwd_strategy}, 
        {(char const   *)((void *)0), (char const   *)0, (char const   *)0, 0U, (void *)0,
      0U, (int (*)(enum cfg_callback_command cmd , dicod_locus_t * , void * , config_value_t * ,
                   void * ))0, (void *)0, (struct config_keyword *)0}};
#line 1145 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static char docstring[93]  = 
#line 1145
  {      (char )'C',      (char )'o',      (char )'n',      (char )'f', 
        (char )'i',      (char )'g',      (char )'u',      (char )'r', 
        (char )'a',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'s', 
        (char )'t',      (char )'r',      (char )'u',      (char )'c', 
        (char )'t',      (char )'u',      (char )'r',      (char )'e', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'d',      (char )'i',      (char )'c', 
        (char )'o',      (char )'d',      (char )'.',      (char )'\n', 
        (char )'F',      (char )'o',      (char )'r',      (char )' ', 
        (char )'m',      (char )'o',      (char )'r',      (char )'e', 
        (char )' ',      (char )'i',      (char )'n',      (char )'f', 
        (char )'o',      (char )'r',      (char )'m',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )',',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )' ',      (char )'`',      (char )'i', 
        (char )'n',      (char )'f',      (char )'o',      (char )' ', 
        (char )'d',      (char )'i',      (char )'c',      (char )'o', 
        (char )' ',      (char )'c',      (char )'o',      (char )'n', 
        (char )'f',      (char )'i',      (char )'g',      (char )'u', 
        (char )'r',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'\'',      (char )'.', 
        (char )'\000'};
#line 1142 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void config_help(void) 
{ 


  {
  {
#line 1148
  format_docstring(stdout, (char const   *)(docstring), 0);
#line 1149
  format_statement_array(stdout, keywords, 1, 0);
  }
#line 1150
  return;
}
}
#line 1153 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int show_sys_info_p(void) 
{ 
  int tmp ;

  {
#line 1156
  if (! show_sys_info) {
#line 1157
    return (1);
  }
  {
#line 1158
  tmp = dicod_acl_check(show_sys_info, 1);
  }
#line 1158
  return (tmp);
}
}
#line 1161 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void reset_db_visibility(void) 
{ 
  dicod_database_t *db ;
  dico_iterator_t itr ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1167
  itr = xdico_list_iterator(database_list);
#line 1168
  tmp = dico_iterator_first(itr);
#line 1168
  db = (dicod_database_t *)tmp;
  }
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1168
    if (! db) {
#line 1168
      goto while_break;
    }
    {
#line 1169
    db->visible = 1;
#line 1168
    tmp___0 = dico_iterator_next(itr);
#line 1168
    db = (dicod_database_t *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1170
  dico_iterator_destroy(& itr);
  }
#line 1171
  return;
}
}
#line 1173 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void check_db_visibility(void) 
{ 
  dicod_database_t *db ;
  dico_iterator_t itr ;
  int global ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  dico_list_t list[2] ;
  int tmp___2 ;
  void *__cil_tmp9 ;

  {
  {
#line 1178
  tmp = dicod_acl_check(global_acl, 1);
#line 1178
  global = tmp;
#line 1180
  itr = xdico_list_iterator(database_list);
#line 1181
  tmp___0 = dico_iterator_first(itr);
#line 1181
  db = (dicod_database_t *)tmp___0;
  }
  {
#line 1181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1181
    if (! db) {
#line 1181
      goto while_break;
    }
    {
#line 1182
    tmp___2 = dicod_acl_check(db->acl, global);
    }
#line 1182
    if (tmp___2) {
      {
#line 1186
      dicod_get_database_languages(db, list);
#line 1187
      db->visible = dicod_lang_check((dico_list_t *)(list));
      }
    } else {
#line 1183
      db->visible = 0;
    }
    {
#line 1181
    tmp___1 = dico_iterator_next(itr);
#line 1181
    db = (dicod_database_t *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1190
  dico_iterator_destroy(& itr);
  }
#line 1191
  return;
}
}
#line 1194 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
dicod_database_t *find_database(char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 1197
  tmp = dico_list_locate(database_list, (void *)name);
  }
#line 1197
  return ((dicod_database_t *)tmp);
}
}
#line 1200 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static int _count_databases(void *item , void *data ) 
{ 
  dicod_database_t const   *db ;
  size_t *pcount ;

  {
#line 1203
  db = (dicod_database_t const   *)item;
#line 1204
  pcount = (size_t *)data;
#line 1205
  if (db->visible) {
#line 1206
    (*pcount) ++;
  }
#line 1207
  return (0);
}
}
#line 1210 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
size_t database_count(void) 
{ 
  size_t count ;

  {
  {
#line 1213
  count = (size_t )0;
#line 1214
  dico_list_iterate(database_list, & _count_databases, (void *)(& count));
  }
#line 1215
  return (count);
}
}
#line 1218 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int database_iterate(int (*fun)(void *item , void *data ) , void *data ) 
{ 
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  dicod_database_t *db ;
  int rc ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1221
  tmp = xdico_list_iterator(database_list);
#line 1221
  itr = tmp;
#line 1223
  rc = 0;
#line 1225
  tmp___0 = dico_iterator_first(itr);
#line 1225
  db = (dicod_database_t *)tmp___0;
  }
  {
#line 1225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1225
    if (rc == 0) {
#line 1225
      if (! db) {
#line 1225
        goto while_break;
      }
    } else {
#line 1225
      goto while_break;
    }
#line 1227
    if (db->visible) {
      {
#line 1228
      rc = (*fun)((void *)db, data);
      }
    }
    {
#line 1225
    tmp___1 = dico_iterator_next(itr);
#line 1225
    db = (dicod_database_t *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1230
  dico_iterator_destroy(& itr);
  }
#line 1231
  return (rc);
}
}
#line 1235 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void database_remove_dependent(dicod_module_instance_t *inst ) 
{ 
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  dicod_database_t *dp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;

  {
  {
#line 1238
  tmp = xdico_list_iterator(database_list);
#line 1238
  itr = tmp;
#line 1241
  tmp___0 = dico_iterator_first(itr);
#line 1241
  dp = (dicod_database_t *)tmp___0;
  }
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    if (! dp) {
#line 1241
      goto while_break;
    }
#line 1242
    if ((unsigned long )dp->instance == (unsigned long )inst) {
      {
#line 1243
      tmp___2 = gettext("removing database %s");
#line 1243
      dico_log(2, 0, (char const   *)tmp___2, dp->name);
#line 1244
      dico_iterator_remove_current(itr, (void **)((void *)0));
#line 1245
      dicod_database_free(dp);
      }
    }
    {
#line 1241
    tmp___1 = dico_iterator_next(itr);
#line 1241
    dp = (dicod_database_t *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1248
  dico_iterator_destroy(& itr);
  }
#line 1249
  return;
}
}
#line 1251 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void dicod_database_free(dicod_database_t *dp ) 
{ 


  {
  {
#line 1254
  dico_list_destroy(& dp->langlist[0]);
#line 1255
  dico_list_destroy(& dp->langlist[1]);
#line 1256
  dico_argcv_free(dp->argc, dp->argv);
#line 1257
  free((void *)dp);
  }
#line 1258
  return;
}
}
#line 1267
void syslog_log_printer(int lvl , int exitcode , int errcode , char const   *fmt ,
                        va_list ap ) ;
#line 1267 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
static struct __anonstruct_loglevels_73 loglevels[8]  = 
#line 1267
  {      {(char *)"Debug", 7}, 
        {(char *)"Info", 6}, 
        {(char *)"Notice", 5}, 
        {(char *)"Warning", 4}, 
        {(char *)"Error", 3}, 
        {(char *)"CRIT", 2}, 
        {(char *)"ALERT", 1}, 
        {(char *)"EMERG", 0}};
#line 1261 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void syslog_log_printer(int lvl , int exitcode , int errcode , char const   *fmt ,
                        va_list ap ) 
{ 
  char *s ;
  int prio ;
  char buf___1[512] ;
  int level ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1266
  prio = 6;
#line 1281
  level = 0;
#line 1283
  if (lvl & 32768) {
    {
#line 1284
    _dico_stderr_log_printer(lvl, exitcode, errcode, fmt, ap);
    }
  }
#line 1286
  s = loglevels[lvl & 255].prefix;
#line 1287
  prio = loglevels[lvl & 255].priority;
#line 1289
  if (log_print_severity) {
    {
#line 1290
    tmp = snprintf((char */* __restrict  */)(buf___1 + level), (size_t )(sizeof(buf___1) - (unsigned long )level),
                   (char const   */* __restrict  */)"%s: ", s);
#line 1290
    level += tmp;
    }
  }
  {
#line 1291
  tmp___0 = vsnprintf((char */* __restrict  */)(buf___1 + level), (size_t )(sizeof(buf___1) - (unsigned long )level),
                      (char const   */* __restrict  */)fmt, ap);
#line 1291
  level += tmp___0;
  }
#line 1292
  if (errcode) {
    {
#line 1293
    tmp___1 = strerror(errcode);
#line 1293
    tmp___2 = snprintf((char */* __restrict  */)(buf___1 + level), (size_t )(sizeof(buf___1) - (unsigned long )level),
                       (char const   */* __restrict  */)": %s", tmp___1);
#line 1293
    level += tmp___2;
    }
  }
  {
#line 1295
  syslog(prio, "%s", buf___1);
  }
#line 1296
  return;
}
}
#line 1299 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void dicod_log_setup(void) 
{ 


  {
#line 1302
  if (! log_to_stderr) {
    {
#line 1303
    openlog(log_tag, 1, log_facility);
#line 1304
    dico_set_log_printer(& syslog_log_printer);
    }
  }
#line 1306
  return;
}
}
#line 1315 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void dicod_log_encode_envar(void) 
{ 
  char *p ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1319
  asprintf((char **/* __restrict  */)(& p), (char const   */* __restrict  */)"%d:%d:%s",
           log_facility, log_print_severity, log_tag);
#line 1320
  setenv("__DICTD_LOGGING__", (char const   *)p, 1);
  }
#line 1321
  return;
}
}
#line 1323 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void dicod_log_pre_setup(void) 
{ 
  char *str ;
  char *tmp ;
  char *p ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 1326
  tmp = getenv("__DICTD_LOGGING__");
#line 1326
  str = tmp;
  }
#line 1327
  if (str) {
    {
#line 1329
    tmp___0 = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& p),
                      10);
#line 1329
    log_facility = (int )tmp___0;
    }
#line 1330
    if ((int )*p == 58) {
      {
#line 1331
      tmp___1 = strtoul((char const   */* __restrict  */)(p + 1), (char **/* __restrict  */)(& p),
                        10);
#line 1331
      log_print_severity = (int )tmp___1;
      }
#line 1332
      if ((int )*p == 58) {
#line 1333
        log_tag = (char const   *)(p + 1);
      }
    }
    {
#line 1335
    log_to_stderr = 0;
#line 1336
    dicod_log_setup();
    }
  }
#line 1338
  return;
}
}
#line 1341 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void init_conf_override(struct dicod_conf_override *ovr ) 
{ 


  {
#line 1344
  ovr->transcript = -1;
#line 1345
  return;
}
}
#line 1347 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
void apply_conf_override(struct dicod_conf_override *ovr ) 
{ 


  {
#line 1350
  if (ovr->transcript >= 0) {
#line 1351
    transcript = ovr->transcript;
  }
#line 1352
  return;
}
}
#line 1355 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/main.c"
int main(int argc , char **argv ) 
{ 
  int rc ;
  struct dicod_conf_override ovr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 1358
  rc = 0;
#line 1361
  appi18n_init();
#line 1362
  dico_set_program_name(*(argv + 0));
#line 1363
  set_quoting_style((struct quoting_options *)((void *)0), (enum quoting_style )5);
#line 1364
  log_tag = dico_program_name;
#line 1365
  dicod_log_pre_setup();
#line 1366
  debug_stream = dico_dbg_stream_create();
#line 1367
  hostname = xdico_local_hostname();
#line 1368
  dicod_init_command_tab();
#line 1369
  dicod_init_strategies();
#line 1370
  udb_init();
#line 1371
  register_auth();
#line 1372
  register_mime();
#line 1373
  register_lang();
#line 1374
  register_markup();
#line 1375
  register_xidle();
#line 1376
  register_xversion();
#line 1377
  register_lev();
#line 1378
  register_regex();
#line 1379
  include_path_setup();
#line 1380
  config_lex_trace(0);
#line 1381
  dico_argcv_quoting_style = (enum dico_argcv_quoting_style )1;
#line 1382
  init_conf_override(& ovr);
#line 1383
  get_options(argc, argv, & ovr);
  }
#line 1385
  if (mode == 2) {
    {
#line 1386
    tmp = preprocess_config(preprocessor);
    }
#line 1386
    return (tmp);
  }
  {
#line 1388
  config_set_keywords(keywords);
#line 1389
  tmp___0 = config_parse((char const   *)config_file);
  }
#line 1389
  if (tmp___0) {
    {
#line 1390
    exit(1);
    }
  }
  {
#line 1392
  apply_conf_override(& ovr);
#line 1394
  register_sasl();
#line 1395
  tmp___1 = dicod_capa_flush();
  }
#line 1395
  if (tmp___1) {
    {
#line 1396
    exit(1);
    }
  }
  {
#line 1397
  compile_access_log();
  }
#line 1398
  if (config_lint_option) {
    {
#line 1399
    exit(0);
    }
  }
  {
#line 1401
  dicod_log_setup();
#line 1403
  dicod_loader_init();
#line 1405
  begin_timing("server");
#line 1406
  dicod_server_init();
#line 1407
  flush_strat_forward();
#line 1408
  markup_flush_capa();
  }
  {
#line 1410
  if (mode == 0) {
#line 1410
    goto case_0;
  }
#line 1414
  if (mode == 1) {
#line 1414
    goto case_1;
  }
#line 1409
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1411
  dicod_server(argc, argv);
  }
#line 1412
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1415
  rc = dicod_inetd();
#line 1416
  dicod_server_cleanup();
  }
#line 1417
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1419
  return (rc);
}
}
#line 404 "./dicod.h"
int dicod_load_module(dicod_module_instance_t *inst ) ;
#line 405
int dicod_init_database(dicod_database_t *dp ) ;
#line 406
int dicod_open_database(dicod_database_t *dp ) ;
#line 407
int dicod_close_database(dicod_database_t *dp ) ;
#line 408
int dicod_free_database(dicod_database_t *dp ) ;
#line 412
char *dicod_get_database_descr(dicod_database_t *db ) ;
#line 413
void dicod_free_database_descr(dicod_database_t *db , char *descr ) ;
#line 414
char *dicod_get_database_info(dicod_database_t *db ) ;
#line 415
void dicod_free_database_info(dicod_database_t *db , char *info ) ;
#line 417
dico_list_t dicod_langlist_copy(dico_list_t src ) ;
#line 419
void dicod_match_word_db(dicod_database_t *db , dico_stream_t stream , dico_strategy_t const   strat ,
                         char const   *word ) ;
#line 421
void dicod_match_word_first(dico_stream_t stream , dico_strategy_t const   strat ,
                            char const   *word ) ;
#line 423
void dicod_match_word_all(dico_stream_t stream , dico_strategy_t const   strat , char const   *word ) ;
#line 425
void dicod_define_word_db(dicod_database_t *db , dico_stream_t stream , char const   *word ) ;
#line 427
void dicod_define_word_first(dico_stream_t stream , char const   *word ) ;
#line 428
void dicod_define_word_all(dico_stream_t stream , char const   *word ) ;
#line 464
void access_log_status(char const   *first , char const   *last ) ;
#line 20 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
static int _add_load_dir(void *item , void *unused ) 
{ 
  char *str ;
  int tmp ;

  {
  {
#line 23
  str = *((char **)item);
#line 24
  tmp = lt_dladdsearchdir((char const   *)str);
  }
#line 24
  return (tmp);
}
}
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_loader_init(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 30
  lt_dlinit();
#line 31
  lt_dladdsearchdir("/usr/local/lib/dico");
#line 32
  dico_list_iterate(module_load_path, & _add_load_dir, (void *)0);
  }
#line 33
  return;
}
}
#line 44 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
static int dicod_load_module0(dicod_module_instance_t *inst , int argc , char **argv ) 
{ 
  lt_dlhandle handle ;
  lt_dladvise advise ;
  struct dico_database_module *pmod ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 47
  handle = (lt_dlhandle )((void *)0);
#line 48
  advise = (lt_dladvise )((void *)0);
#line 51
  if (inst->handle) {
    {
#line 52
    tmp = gettext("module %s already loaded");
#line 52
    dico_log(4, 0, (char const   *)tmp, *(argv + 0));
    }
#line 53
    return (1);
  }
  {
#line 56
  tmp___0 = lt_dladvise_init(& advise);
  }
#line 56
  if (! tmp___0) {
    {
#line 56
    tmp___1 = lt_dladvise_ext(& advise);
    }
#line 56
    if (! tmp___1) {
      {
#line 56
      tmp___2 = lt_dladvise_global(& advise);
      }
#line 56
      if (! tmp___2) {
        {
#line 58
        handle = lt_dlopenadvise((char const   *)*(argv + 0), advise);
        }
      }
    }
  }
  {
#line 59
  lt_dladvise_destroy(& advise);
  }
#line 61
  if (! handle) {
    {
#line 62
    tmp___3 = lt_dlerror();
#line 62
    tmp___4 = gettext("cannot load module %s: %s");
#line 62
    dico_log(4, 0, (char const   *)tmp___4, *(argv + 0), tmp___3);
    }
#line 64
    return (1);
  }
  {
#line 67
  tmp___5 = lt_dlsym(handle, "module");
#line 67
  pmod = (struct dico_database_module *)tmp___5;
  }
#line 68
  if (! pmod) {
    {
#line 68
    lt_dlclose(handle);
#line 68
    tmp___6 = gettext("%s: faulty module: (%s) failed");
#line 68
    dico_log(4, 0, (char const   *)tmp___6, *(argv + 0), "pmod");
    }
#line 68
    return (1);
  }
#line 69
  if (! (pmod->dico_version <= 1U)) {
    {
#line 69
    lt_dlclose(handle);
#line 69
    tmp___7 = gettext("%s: faulty module: (%s) failed");
#line 69
    dico_log(4, 0, (char const   *)tmp___7, *(argv + 0), "pmod->dico_version <= DICO_MODULE_VERSION");
    }
#line 69
    return (1);
  }
#line 70
  if (! pmod->dico_init_db) {
    {
#line 70
    lt_dlclose(handle);
#line 70
    tmp___8 = gettext("%s: faulty module: (%s) failed");
#line 70
    dico_log(4, 0, (char const   *)tmp___8, *(argv + 0), "pmod->dico_init_db");
    }
#line 70
    return (1);
  }
#line 71
  if (! pmod->dico_free_db) {
    {
#line 71
    lt_dlclose(handle);
#line 71
    tmp___9 = gettext("%s: faulty module: (%s) failed");
#line 71
    dico_log(4, 0, (char const   *)tmp___9, *(argv + 0), "pmod->dico_free_db");
    }
#line 71
    return (1);
  }
#line 72
  if (! pmod->dico_match) {
    {
#line 72
    lt_dlclose(handle);
#line 72
    tmp___10 = gettext("%s: faulty module: (%s) failed");
#line 72
    dico_log(4, 0, (char const   *)tmp___10, *(argv + 0), "pmod->dico_match");
    }
#line 72
    return (1);
  }
#line 73
  if (! pmod->dico_define) {
    {
#line 73
    lt_dlclose(handle);
#line 73
    tmp___11 = gettext("%s: faulty module: (%s) failed");
#line 73
    dico_log(4, 0, (char const   *)tmp___11, *(argv + 0), "pmod->dico_define");
    }
#line 73
    return (1);
  }
#line 74
  if (! pmod->dico_output_result) {
    {
#line 74
    lt_dlclose(handle);
#line 74
    tmp___12 = gettext("%s: faulty module: (%s) failed");
#line 74
    dico_log(4, 0, (char const   *)tmp___12, *(argv + 0), "pmod->dico_output_result");
    }
#line 74
    return (1);
  }
#line 75
  if (! pmod->dico_result_count) {
    {
#line 75
    lt_dlclose(handle);
#line 75
    tmp___13 = gettext("%s: faulty module: (%s) failed");
#line 75
    dico_log(4, 0, (char const   *)tmp___13, *(argv + 0), "pmod->dico_result_count");
    }
#line 75
    return (1);
  }
#line 76
  if (! pmod->dico_free_result) {
    {
#line 76
    lt_dlclose(handle);
#line 76
    tmp___14 = gettext("%s: faulty module: (%s) failed");
#line 76
    dico_log(4, 0, (char const   *)tmp___14, *(argv + 0), "pmod->dico_free_result");
    }
#line 76
    return (1);
  }
#line 78
  if (pmod->dico_open) {
#line 78
    goto _L;
  } else
#line 78
  if (pmod->dico_close) {
    _L: /* CIL Label */ 
#line 79
    if (pmod->dico_open) {
#line 79
      if (! pmod->dico_close) {
        {
#line 79
        lt_dlclose(handle);
#line 79
        tmp___15 = gettext("%s: faulty module: (%s) failed");
#line 79
        dico_log(4, 0, (char const   *)tmp___15, *(argv + 0), "pmod->dico_open && pmod->dico_close");
        }
#line 79
        return (1);
      }
    } else {
      {
#line 79
      lt_dlclose(handle);
#line 79
      tmp___15 = gettext("%s: faulty module: (%s) failed");
#line 79
      dico_log(4, 0, (char const   *)tmp___15, *(argv + 0), "pmod->dico_open && pmod->dico_close");
      }
#line 79
      return (1);
    }
  }
#line 81
  if (pmod->dico_init) {
    {
#line 81
    tmp___17 = (*(pmod->dico_init))(argc, argv);
    }
#line 81
    if (tmp___17) {
      {
#line 82
      lt_dlclose(handle);
#line 83
      tmp___16 = gettext("%s: initialization failed");
#line 83
      dico_log(4, 0, (char const   *)tmp___16, *(argv + 0));
      }
#line 84
      return (1);
    }
  }
#line 87
  inst->module = pmod;
#line 88
  return (0);
}
}
#line 91 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
int dicod_load_module(dicod_module_instance_t *inst ) 
{ 
  int argc ;
  char **argv ;
  int rc ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 98
  tmp___0 = dico_argcv_get((char const   *)inst->command, (char const   *)((void *)0),
                           (char const   *)((void *)0), & argc, & argv);
  }
#line 98
  if (tmp___0) {
    {
#line 99
    tmp = gettext("cannot parse command line `%s\'");
#line 99
    dico_log(4, rc, (char const   *)tmp, inst->command);
    }
#line 101
    return (1);
  }
  {
#line 104
  rc = dicod_load_module0(inst, argc, argv);
#line 106
  dico_argcv_free(argc, argv);
  }
#line 108
  return (rc);
}
}
#line 111 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
int dicod_init_database(dicod_database_t *dp ) 
{ 
  dicod_module_instance_t *inst ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 114
  inst = dp->instance;
#line 116
  if ((inst->module)->dico_init_db) {
    {
#line 117
    dp->mod_handle = (*((inst->module)->dico_init_db))((char const   *)dp->name, dp->argc,
                                                       dp->argv);
    }
#line 119
    if (! dp->mod_handle) {
      {
#line 120
      tmp = gettext("cannot initialize database `%s\'");
#line 120
      dico_log(4, 0, (char const   *)tmp, dp->command);
      }
#line 122
      return (1);
    }
  }
#line 125
  return (0);
}
}
#line 128 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
int dicod_open_database(dicod_database_t *dp ) 
{ 
  dicod_module_instance_t *inst ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 131
  inst = dp->instance;
#line 133
  if ((inst->module)->dico_open) {
    {
#line 134
    tmp___0 = (*((inst->module)->dico_open))(dp->mod_handle);
    }
#line 134
    if (tmp___0) {
      {
#line 135
      tmp = gettext("cannot open database `%s\'");
#line 135
      dico_log(4, 0, (char const   *)tmp, dp->command);
      }
#line 137
      return (1);
    }
  }
#line 140
  return (0);
}
}
#line 143 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
int dicod_close_database(dicod_database_t *dp ) 
{ 
  int rc ;
  dicod_module_instance_t *inst ;

  {
#line 146
  rc = 0;
#line 148
  if (dp->mod_handle) {
#line 149
    inst = dp->instance;
#line 150
    if ((inst->module)->dico_close) {
      {
#line 151
      rc = (*((inst->module)->dico_close))(dp->mod_handle);
      }
    }
  }
#line 153
  return (rc);
}
}
#line 156 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
int dicod_free_database(dicod_database_t *dp ) 
{ 
  int rc ;
  dicod_module_instance_t *inst ;

  {
#line 159
  rc = 0;
#line 161
  if (dp->mod_handle) {
#line 162
    inst = dp->instance;
#line 163
    if ((inst->module)->dico_free_db) {
      {
#line 164
      rc = (*((inst->module)->dico_free_db))(dp->mod_handle);
#line 165
      dp->mod_handle = (dico_handle_t )((void *)0);
      }
    }
  }
#line 168
  return (rc);
}
}
#line 171 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
char *dicod_get_database_descr(dicod_database_t *db ) 
{ 
  dicod_module_instance_t *inst ;
  char *tmp ;

  {
#line 174
  if (db->descr) {
#line 175
    return (db->descr);
  } else {
#line 177
    inst = db->instance;
#line 178
    if ((inst->module)->dico_db_descr) {
      {
#line 179
      tmp = (*((inst->module)->dico_db_descr))(db->mod_handle);
      }
#line 179
      return (tmp);
    }
  }
#line 181
  return ((char *)((void *)0));
}
}
#line 184 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_free_database_descr(dicod_database_t *db , char *descr ) 
{ 


  {
#line 187
  if (descr) {
#line 187
    if ((unsigned long )descr != (unsigned long )db->descr) {
      {
#line 188
      free((void *)descr);
      }
    }
  }
#line 189
  return;
}
}
#line 191 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
char *dicod_get_database_info(dicod_database_t *db ) 
{ 
  dicod_module_instance_t *inst ;
  char *tmp ;

  {
#line 194
  if (db->info) {
#line 195
    return (db->info);
  } else {
#line 197
    inst = db->instance;
#line 198
    if ((inst->module)->dico_db_info) {
      {
#line 199
      tmp = (*((inst->module)->dico_db_info))(db->mod_handle);
      }
#line 199
      return (tmp);
    }
  }
#line 201
  return ((char *)((void *)0));
}
}
#line 204 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_free_database_info(dicod_database_t *db , char *info ) 
{ 


  {
#line 207
  if (info) {
#line 207
    if ((unsigned long )info != (unsigned long )db->info) {
      {
#line 208
      free((void *)info);
      }
    }
  }
#line 209
  return;
}
}
#line 211 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
static int _dup_lang_item(void *item , void *data ) 
{ 
  char *lang ;
  dico_list_t dst ;
  char *tmp ;

  {
  {
#line 214
  lang = (char *)item;
#line 215
  dst = (dico_list_t )data;
#line 216
  tmp = xstrdup((char const   *)lang);
#line 216
  xdico_list_append(dst, (void *)tmp);
  }
#line 217
  return (0);
}
}
#line 220 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
dico_list_t dicod_langlist_copy(dico_list_t src ) 
{ 
  dico_list_t dst ;
  dico_list_t tmp ;

  {
  {
#line 223
  tmp = xdico_list_create();
#line 223
  dst = tmp;
#line 224
  dico_list_set_free_item(dst, & dicod_free_item, (void *)0);
#line 225
  dico_list_iterate(src, & _dup_lang_item, (void *)dst);
  }
#line 226
  return (dst);
}
}
#line 229 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
int dicod_any_lang_list_p(dico_list_t list ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;

  {
#line 232
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 232
    tmp___3 = 1;
  } else {
    {
#line 232
    tmp = dico_list_count(list);
    }
#line 232
    if (tmp == 0U) {
#line 232
      tmp___3 = 1;
    } else {
      {
#line 232
      tmp___0 = dico_list_count(list);
      }
#line 232
      if (tmp___0 == 1U) {
        {
#line 232
        tmp___1 = dico_list_item(list, (size_t )0);
#line 232
        tmp___2 = strcmp((char const   *)tmp___1, "*");
        }
#line 232
        if (tmp___2 == 0) {
#line 232
          tmp___3 = 1;
        } else {
#line 232
          tmp___3 = 0;
        }
      } else {
#line 232
        tmp___3 = 0;
      }
    }
  }
#line 232
  return (tmp___3);
}
}
#line 238 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_get_database_languages(dicod_database_t *db , dico_list_t *dlist ) 
{ 
  dicod_module_instance_t *inst ;
  int tmp ;
  int tmp___0 ;

  {
#line 241
  if (! (db->flags & 1)) {
#line 242
    inst = db->instance;
#line 243
    if ((inst->module)->dico_db_lang) {
      {
#line 245
      (*((inst->module)->dico_db_lang))(db->mod_handle, (dico_list_t *)(db->langlist));
      }
#line 246
      if (db->langlist[0]) {
#line 246
        goto _L;
      } else
#line 246
      if (db->langlist[1]) {
        _L: /* CIL Label */ 
#line 247
        if (! db->langlist[0]) {
          {
#line 248
          db->langlist[0] = dicod_langlist_copy(db->langlist[1]);
          }
        } else
#line 249
        if (! db->langlist[1]) {
          {
#line 250
          db->langlist[1] = dicod_langlist_copy(db->langlist[0]);
          }
        }
      }
      {
#line 252
      tmp = dicod_any_lang_list_p(db->langlist[0]);
      }
#line 252
      if (tmp) {
        {
#line 253
        dico_list_destroy(& db->langlist[0]);
        }
      }
      {
#line 254
      tmp___0 = dicod_any_lang_list_p(db->langlist[1]);
      }
#line 254
      if (tmp___0) {
        {
#line 255
        dico_list_destroy(& db->langlist[1]);
        }
      }
    }
#line 257
    db->flags |= 1;
  }
#line 259
  *(dlist + 0) = db->langlist[0];
#line 260
  *(dlist + 1) = db->langlist[1];
#line 261
  return;
}
}
#line 264 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
static char nomatch[13]  = 
#line 264
  {      (char )'5',      (char )'5',      (char )'2',      (char )' ', 
        (char )'N',      (char )'o',      (char )' ',      (char )'m', 
        (char )'a',      (char )'t',      (char )'c',      (char )'h', 
        (char )'\000'};
#line 265 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
static size_t nomatch_len  =    (size_t )(sizeof(nomatch) - 1UL);
#line 273 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_word_first(dico_stream_t stream , char const   *word , dico_strategy_t const   strat ,
                      char const   *begfmt , char const   *endmsg , void (*proc)(dicod_database_t *db ,
                                                                                 dico_result_t res ,
                                                                                 char const   *word ,
                                                                                 dico_stream_t stream ,
                                                                                 void *data ,
                                                                                 size_t count ) ,
                      void *data , char const   *tid ) 
{ 
  dicod_database_t *db ;
  dico_iterator_t itr ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct dico_database_module *mp ;
  dico_result_t res ;
  dico_result_t tmp___2 ;
  dico_result_t tmp___3 ;
  dico_result_t tmp___4 ;
  size_t count ;
  size_t tmp___5 ;
  char *__cil_tmp21 ;

  {
  {
#line 282
  begin_timing(tid);
  }
#line 284
  if (strat) {
    {
#line 284
    tmp = stratcl_check_word(strat->stratcl, word);
    }
#line 284
    if (tmp) {
      {
#line 285
      access_log_status((char const   *)(nomatch), (char const   *)(nomatch));
#line 286
      dico_stream_writeln(stream, (char const   *)(nomatch), nomatch_len);
      }
#line 287
      return;
    }
  }
  {
#line 290
  itr = xdico_list_iterator(database_list);
#line 291
  tmp___0 = dico_iterator_first(itr);
#line 291
  db = (dicod_database_t *)tmp___0;
  }
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! db) {
#line 291
      goto while_break;
    }
#line 292
    if (db->visible) {
#line 293
      mp = (db->instance)->module;
#line 294
      if (strat) {
        {
#line 294
        tmp___2 = (*(mp->dico_match))(db->mod_handle, strat, word);
#line 294
        tmp___4 = tmp___2;
        }
      } else {
        {
#line 294
        tmp___3 = (*(mp->dico_define))(db->mod_handle, word);
#line 294
        tmp___4 = tmp___3;
        }
      }
#line 294
      res = tmp___4;
#line 299
      if (! res) {
#line 300
        goto __Cont;
      }
      {
#line 301
      count = (*(mp->dico_result_count))(res);
      }
#line 303
      if (count) {
#line 304
        if (strat) {
#line 305
          current_stat.matches = (unsigned long )count;
        } else {
#line 307
          current_stat.defines = (unsigned long )count;
        }
#line 308
        if (mp->dico_compare_count) {
          {
#line 309
          tmp___5 = (*(mp->dico_compare_count))(res);
#line 309
          current_stat.compares = (unsigned long )tmp___5;
          }
        }
        {
#line 310
        stream_printf(stream, begfmt, (unsigned long )count);
#line 311
        (*proc)(db, res, word, stream, data, count);
#line 312
        stream_writez(stream, (char *)endmsg);
#line 313
        report_current_timing(stream, tid);
#line 314
        dico_stream_write(stream, (void const   *)"\r\n", (size_t )2);
#line 315
        access_log_status(begfmt, endmsg);
#line 316
        (*(mp->dico_free_result))(res);
        }
#line 317
        goto while_break;
      } else {
        {
#line 319
        (*(mp->dico_free_result))(res);
        }
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 291
    tmp___1 = dico_iterator_next(itr);
#line 291
    db = (dicod_database_t *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 322
  dico_iterator_destroy(& itr);
  }
#line 323
  if (! db) {
    {
#line 324
    access_log_status((char const   *)(nomatch), (char const   *)(nomatch));
#line 325
    dico_stream_writeln(stream, (char const   *)(nomatch), nomatch_len);
    }
  }
#line 327
  return;
}
}
#line 335 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_word_all(dico_stream_t stream , char const   *word , dico_strategy_t const   strat ,
                    char const   *begfmt , char const   *endmsg , void (*proc)(dicod_database_t *db ,
                                                                               dico_result_t res ,
                                                                               char const   *word ,
                                                                               dico_stream_t stream ,
                                                                               void *data ,
                                                                               size_t count ) ,
                    void *data , char const   *tid ) 
{ 
  dicod_database_t *db ;
  dico_iterator_t itr ;
  dico_list_t reslist ;
  dico_list_t tmp ;
  size_t total ;
  struct dbres *rp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct dico_database_module *mp ;
  dico_result_t res ;
  dico_result_t tmp___3 ;
  dico_result_t tmp___4 ;
  dico_result_t tmp___5 ;
  size_t count ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  char *__cil_tmp28 ;

  {
  {
#line 343
  tmp = xdico_list_create();
#line 343
  reslist = tmp;
#line 344
  total = (size_t )0;
#line 347
  begin_timing(tid);
  }
#line 349
  if (strat) {
    {
#line 349
    tmp___0 = stratcl_check_word(strat->stratcl, word);
    }
#line 349
    if (tmp___0) {
      {
#line 350
      access_log_status((char const   *)(nomatch), (char const   *)(nomatch));
#line 351
      dico_stream_writeln(stream, (char const   *)(nomatch), nomatch_len);
      }
#line 352
      return;
    }
  }
  {
#line 355
  itr = xdico_list_iterator(database_list);
#line 356
  tmp___1 = dico_iterator_first(itr);
#line 356
  db = (dicod_database_t *)tmp___1;
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! db) {
#line 356
      goto while_break;
    }
#line 357
    if (db->visible) {
#line 358
      mp = (db->instance)->module;
#line 359
      if (strat) {
        {
#line 359
        tmp___3 = (*(mp->dico_match))(db->mod_handle, strat, word);
#line 359
        tmp___5 = tmp___3;
        }
      } else {
        {
#line 359
        tmp___4 = (*(mp->dico_define))(db->mod_handle, word);
#line 359
        tmp___5 = tmp___4;
        }
      }
#line 359
      res = tmp___5;
#line 364
      if (! res) {
#line 365
        goto __Cont;
      }
      {
#line 366
      count = (*(mp->dico_result_count))(res);
      }
#line 367
      if (! count) {
        {
#line 368
        (*(mp->dico_free_result))(res);
        }
#line 369
        goto __Cont;
      }
#line 372
      total += count;
#line 373
      if (mp->dico_compare_count) {
        {
#line 374
        tmp___6 = (*(mp->dico_compare_count))(res);
#line 374
        current_stat.compares += (unsigned long )tmp___6;
        }
      }
      {
#line 375
      tmp___7 = xmalloc((size_t )sizeof(*rp));
#line 375
      rp = (struct dbres *)tmp___7;
#line 376
      rp->db = db;
#line 377
      rp->res = res;
#line 378
      rp->count = count;
#line 379
      xdico_list_append(reslist, (void *)rp);
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 356
    tmp___2 = dico_iterator_next(itr);
#line 356
    db = (dicod_database_t *)tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  dico_iterator_destroy(& itr);
  }
#line 385
  if (total == 0U) {
    {
#line 386
    access_log_status((char const   *)(nomatch), (char const   *)(nomatch));
#line 387
    dico_stream_writeln(stream, (char const   *)(nomatch), nomatch_len);
    }
  } else {
    {
#line 389
    itr = xdico_list_iterator(reslist);
    }
#line 391
    if (strat) {
#line 392
      current_stat.matches = (unsigned long )total;
    } else {
#line 394
      current_stat.defines = (unsigned long )total;
    }
    {
#line 395
    stream_printf(stream, begfmt, (unsigned long )total);
#line 396
    tmp___8 = dico_iterator_first(itr);
#line 396
    rp = (struct dbres *)tmp___8;
    }
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 396
      if (! rp) {
#line 396
        goto while_break___0;
      }
      {
#line 397
      (*proc)(rp->db, rp->res, word, stream, data, rp->count);
#line 398
      (*((((rp->db)->instance)->module)->dico_free_result))(rp->res);
#line 399
      free((void *)rp);
#line 396
      tmp___9 = dico_iterator_next(itr);
#line 396
      rp = (struct dbres *)tmp___9;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 401
    stream_writez(stream, (char *)endmsg);
#line 402
    report_current_timing(stream, tid);
#line 403
    dico_stream_write(stream, (void const   *)"\r\n", (size_t )2);
#line 404
    dico_iterator_destroy(& itr);
#line 405
    access_log_status(begfmt, endmsg);
    }
  }
  {
#line 407
  dico_list_destroy(& reslist);
  }
#line 408
  return;
}
}
#line 410 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
static void print_matches(dicod_database_t *db , dico_result_t res , char const   *word ,
                          dico_stream_t stream , void *data , size_t count ) 
{ 
  size_t i ;
  struct dico_database_module *mp ;
  dico_stream_t ostr ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 416
  mp = (db->instance)->module;
#line 417
  ostr = (dico_stream_t )data;
#line 419
  i = (size_t )0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (i < count)) {
#line 419
      goto while_break;
    }
    {
#line 420
    stream_writez(ostr, db->name);
#line 421
    dico_stream_write(ostr, (void const   *)" \"", (size_t )2);
#line 422
    (*(mp->dico_output_result))(res, i, ostr);
#line 423
    dico_stream_write(ostr, (void const   *)"\"\r\n", (size_t )3);
#line 419
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  return;
}
}
#line 427 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_match_word_db(dicod_database_t *db , dico_stream_t stream , dico_strategy_t const   strat ,
                         char const   *word ) 
{ 
  struct dico_database_module *mp ;
  dico_result_t res ;
  size_t count ;
  dico_stream_t ostr ;
  size_t tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 431
  mp = (db->instance)->module;
#line 435
  begin_timing("match");
#line 436
  res = (*(mp->dico_match))(db->mod_handle, strat, word);
  }
#line 438
  if (! res) {
    {
#line 439
    access_log_status((char const   *)(nomatch), (char const   *)(nomatch));
#line 440
    dico_stream_writeln(stream, (char const   *)(nomatch), nomatch_len);
    }
#line 441
    return;
  }
  {
#line 444
  count = (*(mp->dico_result_count))(res);
  }
#line 445
  if (count == 0U) {
    {
#line 446
    access_log_status((char const   *)(nomatch), (char const   *)(nomatch));
#line 447
    dico_stream_writeln(stream, (char const   *)(nomatch), nomatch_len);
    }
  } else {
#line 451
    current_stat.matches = (unsigned long )count;
#line 452
    if (mp->dico_compare_count) {
      {
#line 453
      tmp = (*(mp->dico_compare_count))(res);
#line 453
      current_stat.compares = (unsigned long )tmp;
      }
    }
    {
#line 454
    stream_printf(stream, "152 %lu matches found: list follows\r\n", (unsigned long )count);
#line 456
    ostr = dicod_ostream_create(stream, (dico_assoc_list_t )((void *)0));
#line 457
    print_matches(db, res, word, stream, (void *)ostr, count);
#line 458
    dico_stream_close(ostr);
#line 459
    dico_stream_destroy(& ostr);
#line 460
    dico_stream_write(stream, (void const   *)".\r\n", (size_t )3);
#line 461
    stream_writez(stream, (char *)"250 Command complete");
#line 462
    report_current_timing(stream, "match");
#line 463
    dico_stream_write(stream, (void const   *)"\r\n", (size_t )2);
#line 464
    access_log_status("152", "250");
    }
  }
  {
#line 467
  (*(mp->dico_free_result))(res);
  }
#line 468
  return;
}
}
#line 470 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_match_word_first(dico_stream_t stream , dico_strategy_t const   strat ,
                            char const   *word ) 
{ 
  dico_stream_t ostr ;
  dico_stream_t tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 474
  tmp = dicod_ostream_create(stream, (dico_assoc_list_t )((void *)0));
#line 474
  ostr = tmp;
#line 475
  dicod_word_first(stream, word, strat, "152 %lu matches found: list follows\r\n",
                   ".\r\n250 Command complete", & print_matches, (void *)ostr, "match");
#line 479
  dico_stream_close(ostr);
#line 480
  dico_stream_destroy(& ostr);
  }
#line 481
  return;
}
}
#line 483 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_match_word_all(dico_stream_t stream , dico_strategy_t const   strat , char const   *word ) 
{ 
  dico_stream_t ostr ;
  dico_stream_t tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 487
  tmp = dicod_ostream_create(stream, (dico_assoc_list_t )((void *)0));
#line 487
  ostr = tmp;
#line 488
  dicod_word_all(stream, word, strat, "152 %lu matches found: list follows\r\n", ".\r\n250 Command complete",
                 & print_matches, (void *)ostr, "match");
#line 492
  dico_stream_close(ostr);
#line 493
  dico_stream_destroy(& ostr);
  }
#line 494
  return;
}
}
#line 498 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
static void print_definitions(dicod_database_t *db , dico_result_t res , char const   *word ,
                              dico_stream_t stream , void *data , size_t count ) 
{ 
  size_t i ;
  char *descr ;
  char *tmp ;
  struct dico_database_module *mp ;
  dico_stream_t ostr ;
  dico_assoc_list_t hdr ;
  char const   *tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 504
  tmp = dicod_get_database_descr(db);
#line 504
  descr = tmp;
#line 505
  mp = (db->instance)->module;
#line 506
  i = (size_t )0;
  }
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i < count)) {
#line 506
      goto while_break;
    }
#line 508
    hdr = (dico_assoc_list_t )((void *)0);
#line 510
    if (descr) {
#line 510
      tmp___0 = (char const   *)descr;
    } else {
#line 510
      tmp___0 = "";
    }
    {
#line 510
    stream_printf(stream, "151 \"%s\" %s \"%s\"\r\n", word, db->name, tmp___0);
    }
#line 512
    if (mp->dico_result_headers) {
#line 513
      if (db->mime_headers) {
        {
#line 514
        hdr = dico_assoc_dup(db->mime_headers);
        }
      } else {
        {
#line 516
        dico_header_parse(& hdr, (char const   *)((void *)0));
        }
      }
      {
#line 517
      (*(mp->dico_result_headers))(res, hdr);
#line 518
      ostr = dicod_ostream_create(stream, hdr);
      }
    } else {
      {
#line 520
      ostr = dicod_ostream_create(stream, db->mime_headers);
      }
    }
    {
#line 521
    (*(mp->dico_output_result))(res, i, ostr);
#line 522
    dico_stream_close(ostr);
#line 523
    dico_stream_destroy(& ostr);
#line 524
    dico_stream_write(stream, (void const   *)"\r\n.\r\n", (size_t )5);
#line 525
    dico_assoc_destroy(& hdr);
#line 506
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 527
  dicod_free_database_descr(db, descr);
  }
#line 528
  return;
}
}
#line 530 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_define_word_db(dicod_database_t *db , dico_stream_t stream , char const   *word ) 
{ 
  struct dico_database_module *mp ;
  dico_result_t res ;
  size_t count ;
  size_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 534
  mp = (db->instance)->module;
#line 538
  begin_timing("define");
#line 540
  res = (*(mp->dico_define))(db->mod_handle, word);
  }
#line 541
  if (! res) {
    {
#line 542
    access_log_status((char const   *)(nomatch), (char const   *)(nomatch));
#line 543
    dico_stream_writeln(stream, (char const   *)(nomatch), nomatch_len);
    }
#line 544
    return;
  }
  {
#line 547
  count = (*(mp->dico_result_count))(res);
  }
#line 548
  if (count == 0U) {
    {
#line 549
    access_log_status((char const   *)(nomatch), (char const   *)(nomatch));
#line 550
    dico_stream_writeln(stream, (char const   *)(nomatch), nomatch_len);
    }
  } else {
#line 552
    current_stat.defines = (unsigned long )count;
#line 553
    if (mp->dico_compare_count) {
      {
#line 554
      tmp = (*(mp->dico_compare_count))(res);
#line 554
      current_stat.compares = (unsigned long )tmp;
      }
    }
    {
#line 555
    stream_printf(stream, "150 %lu definitions found: list follows\r\n", (unsigned long )count);
#line 557
    print_definitions(db, res, word, stream, (void *)0, count);
#line 558
    stream_writez(stream, (char *)"250 Command complete");
#line 559
    report_current_timing(stream, "define");
#line 560
    dico_stream_write(stream, (void const   *)"\r\n", (size_t )2);
#line 561
    access_log_status("150", "250");
    }
  }
  {
#line 564
  (*(mp->dico_free_result))(res);
  }
#line 565
  return;
}
}
#line 567 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_define_word_first(dico_stream_t stream , char const   *word ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 570
  dicod_word_first(stream, word, (dico_strategy_t const   )((void *)0), "150 %lu definitions found: list follows\r\n",
                   "250 Command complete", & print_definitions, (void *)0, "define");
  }
#line 574
  return;
}
}
#line 576 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/loader.c"
void dicod_define_word_all(dico_stream_t stream , char const   *word ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 579
  dicod_word_all(stream, word, (dico_strategy_t const   )((void *)0), "150 %lu definitions found: list follows\r\n",
                 "250 Command complete", & print_definitions, (void *)0, "define");
  }
#line 583
  return;
}
}
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lev.c"
static int levenshtein_distance  =    1;
#line 21 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lev.c"
static int lev_sel(int cmd___6 , char const   *word , char const   *dict_word , void *closure ) 
{ 
  int dist ;
  int tmp ;

  {
#line 24
  if (cmd___6 == 1) {
    {
#line 25
    tmp = dico_levenshtein_distance(word, dict_word, (int )closure);
#line 25
    dist = tmp;
    }
#line 26
    if (dist < 0) {
#line 27
      return (0);
    }
#line 28
    return (dist <= levenshtein_distance);
  }
#line 30
  return (0);
}
}
#line 33 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lev.c"
static struct dico_strategy levstrat[4]  = {      {(char *)"lev", (char *)"Match headwords within given Levenshtein distance",
      & lev_sel, (void *)0, 0, (struct dico_list *)0}, 
        {(char *)"nlev", (char *)"Match headwords within given Levenshtein distance (normalized)",
      & lev_sel, (void *)1, 0, (struct dico_list *)0}, 
        {(char *)"dlev", (char *)"Match headwords within given Damerau-Levenshtein distance",
      & lev_sel, (void *)2, 0, (struct dico_list *)0}, 
        {(char *)"ndlev", (char *)"Match headwords within given Damerau-Levenshtein distance (normalized)",
      & lev_sel, (void *)3, 0, (struct dico_list *)0}};
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lev.c"
static void dicod_xlevdist(dico_stream_t str , int argc , char **argv ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 55
  tmp___0 = c_strcasecmp((char const   *)*(argv + 1), "tell");
  }
#line 55
  if (tmp___0 == 0) {
    {
#line 56
    stream_printf(str, "280 %d\r\n", levenshtein_distance);
    }
  } else {
    {
#line 57
    tmp = __ctype_b_loc();
    }
#line 57
    if ((int const   )*(*tmp + (int )*(*(argv + 1) + 0)) & 2048) {
#line 57
      if ((int )*(*(argv + 1) + 0) != 48) {
#line 57
        if ((int )*(*(argv + 1) + 1) == 0) {
          {
#line 58
          levenshtein_distance = atoi((char const   *)*(argv + 1));
#line 59
          stream_printf(str, "250 ok - Levenshtein threshold set to %d\r\n", levenshtein_distance);
          }
        } else {
          {
#line 62
          stream_writez(str, (char *)"500 invalid argument\r\n");
          }
        }
      } else {
        {
#line 62
        stream_writez(str, (char *)"500 invalid argument\r\n");
        }
      }
    } else {
      {
#line 62
      stream_writez(str, (char *)"500 invalid argument\r\n");
      }
    }
  }
#line 63
  return;
}
}
#line 69 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lev.c"
static struct dicod_command cmd___3[2]  = {      {(char *)"XLEV", 2, 2, (char *)"distance", (char *)"Set Levenshtein distance",
      & dicod_xlevdist}, 
        {(char *)((void *)0), 0, 0, (char *)0, (char *)0, (void (*)(dico_stream_t str ,
                                                                 int argc , char **argv ))0}};
#line 65 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lev.c"
void register_lev(void) 
{ 
  int i ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 74
  i = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )i < sizeof(levstrat) / sizeof(levstrat[0]))) {
#line 74
      goto while_break;
    }
    {
#line 75
    dico_strategy_add((dico_strategy_t const   )(& levstrat[i]));
#line 74
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  dico_set_default_strategy("nlev");
#line 77
  dicod_capa_register("xlev", cmd___3, (int (*)(void * ))((void *)0), (void *)0);
  }
#line 78
  return;
}
}
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
dico_list_t dicod_lang_lazy_prefs  ;
#line 20 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
dico_list_t dicod_lang_prefs[2]  ;
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
static int cmp_string_ci(void const   *a , void *b ) 
{ 
  int tmp ;

  {
  {
#line 25
  tmp = c_strcasecmp((char const   *)a, (char const   *)b);
  }
#line 25
  return (tmp);
}
}
#line 28 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
int dicod_lang_check(dico_list_t *list ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 31
  if (! *(list + 0)) {
#line 31
    if (! *(list + 1)) {
#line 32
      return (1);
    }
  }
#line 34
  if (dicod_lang_lazy_prefs) {
#line 35
    if (*(list + 0)) {
      {
#line 35
      tmp = dico_list_intersect_p(dicod_lang_lazy_prefs, *(list + 0), & cmp_string_ci);
      }
#line 35
      if (tmp) {
#line 37
        return (1);
      }
    }
#line 38
    if (*(list + 1)) {
      {
#line 38
      tmp___0 = dico_list_intersect_p(dicod_lang_lazy_prefs, *(list + 1), & cmp_string_ci);
      }
#line 38
      if (tmp___0) {
#line 40
        return (1);
      }
    }
#line 41
    return (0);
  }
#line 44
  if (dicod_lang_prefs[0]) {
#line 44
    if (*(list + 0)) {
      {
#line 44
      tmp___1 = dico_list_intersect_p(dicod_lang_prefs[0], *(list + 0), & cmp_string_ci);
      }
#line 44
      if (! tmp___1) {
#line 46
        return (0);
      }
    }
  }
#line 47
  if (dicod_lang_prefs[1]) {
#line 47
    if (*(list + 1)) {
      {
#line 47
      tmp___2 = dico_list_intersect_p(dicod_lang_prefs[1], *(list + 1), & cmp_string_ci);
      }
#line 47
      if (! tmp___2) {
#line 49
        return (0);
      }
    }
  }
#line 50
  return (1);
}
}
#line 53 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
void dicod_lang(dico_stream_t str , int argc , char **argv ) 
{ 
  int n ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 56
  dico_list_destroy(& dicod_lang_lazy_prefs);
#line 57
  dico_list_destroy(& dicod_lang_prefs[0]);
#line 58
  dico_list_destroy(& dicod_lang_prefs[1]);
  }
#line 59
  if (argc > 2) {
#line 60
    n = 0;
#line 63
    i = 2;
    {
#line 63
    while (1) {
      while_continue: /* CIL Label */ ;
#line 63
      if (! (i < argc)) {
#line 63
        goto while_break;
      }
#line 64
      if (n == 0) {
        {
#line 64
        tmp___0 = strcmp((char const   *)*(argv + i), ":");
        }
#line 64
        if (tmp___0 == 0) {
#line 65
          n = 1;
        } else {
#line 64
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 67
        if (! dicod_lang_prefs[n]) {
          {
#line 68
          dicod_lang_prefs[n] = xdico_list_create();
#line 69
          dico_list_set_free_item(dicod_lang_prefs[n], & dicod_free_item, (void *)0);
          }
        }
        {
#line 72
        tmp = xstrdup((char const   *)*(argv + i));
#line 72
        xdico_list_append(dicod_lang_prefs[n], (void *)tmp);
        }
      }
#line 63
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 75
    if (n == 0) {
#line 76
      dicod_lang_lazy_prefs = dicod_lang_prefs[0];
#line 77
      dicod_lang_prefs[0] = (dico_list_t )((void *)0);
    }
  }
  {
#line 80
  check_db_visibility();
#line 81
  stream_writez(str, (char *)"250 ok - set language preferences\r\n");
  }
#line 82
  return;
}
}
#line 84 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
static int _display_pref(void *item , void *data ) 
{ 
  dico_stream_t str ;
  char *__cil_tmp4 ;

  {
  {
#line 87
  str = (dico_stream_t )data;
#line 88
  stream_writez(str, (char *)" ");
#line 89
  stream_writez(str, (char *)item);
  }
#line 90
  return (0);
}
}
#line 93 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
static void show_lang_lists(dico_stream_t str , dico_list_t *list ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 96
  dico_list_iterate(*(list + 0), & _display_pref, (void *)str);
#line 97
  dico_stream_write(str, (void const   *)" :", (size_t )2);
#line 98
  dico_list_iterate(*(list + 1), & _display_pref, (void *)str);
#line 99
  dico_stream_write(str, (void const   *)"\r\n", (size_t )2);
  }
#line 100
  return;
}
}
#line 102 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
void dicod_show_lang_pref(dico_stream_t str , int argc , char **argv ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 105
  stream_writez(str, (char *)"280");
  }
#line 106
  if (dicod_lang_lazy_prefs) {
    {
#line 107
    dico_list_iterate(dicod_lang_lazy_prefs, & _display_pref, (void *)str);
#line 108
    dico_stream_write(str, (void const   *)"\r\n", (size_t )2);
    }
  } else {
    {
#line 110
    show_lang_lists(str, (dico_list_t *)(dicod_lang_prefs));
    }
  }
#line 111
  return;
}
}
#line 113 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
void dicod_show_lang_info(dico_stream_t str , int argc , char **argv ) 
{ 
  dicod_database_t *db ;
  dicod_database_t *tmp ;
  dico_list_t langlist[2] ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 116
  tmp = find_database((char const   *)*(argv + 3));
#line 116
  db = tmp;
  }
#line 117
  if (! db) {
    {
#line 118
    stream_writez(str, (char *)"550 invalid database, use SHOW DB for a list\r\n");
    }
  } else {
    {
#line 123
    dicod_get_database_languages(db, langlist);
#line 124
    stream_writez(str, (char *)"280");
#line 125
    show_lang_lists(str, (dico_list_t *)(langlist));
    }
  }
#line 127
  return;
}
}
#line 129 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
static int _show_database_lang(void *item , void *data ) 
{ 
  dicod_database_t *db ;
  dico_stream_t str ;
  dico_list_t langlist[2] ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 132
  db = (dicod_database_t *)item;
#line 133
  str = (dico_stream_t )data;
#line 135
  dicod_get_database_languages(db, langlist);
#line 136
  stream_printf(str, "%s", db->name);
#line 137
  show_lang_lists(str, (dico_list_t *)(langlist));
  }
#line 138
  return (0);
}
}
#line 141 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
void dicod_show_lang_db(dico_stream_t str , int argc , char **argv ) 
{ 
  size_t count ;
  size_t tmp ;
  dico_stream_t ostr ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 144
  tmp = database_count();
#line 144
  count = tmp;
  }
#line 145
  if (count == 0U) {
    {
#line 146
    stream_printf(str, "554 No databases present\r\n");
    }
  } else {
    {
#line 150
    stream_printf(str, "110 %lu databases present\r\n", (unsigned long )count);
#line 152
    ostr = dicod_ostream_create(str, (dico_assoc_list_t )((void *)0));
#line 153
    database_iterate(& _show_database_lang, (void *)ostr);
#line 154
    dico_stream_close(ostr);
#line 155
    dico_stream_destroy(& ostr);
#line 156
    stream_writez(str, (char *)".\r\n");
#line 157
    stream_writez(str, (char *)"250 ok\r\n");
    }
  }
#line 159
  return;
}
}
#line 164 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
static struct dicod_command cmd___4[6]  = {      {(char *)"OPTION LANG", 2, -1, (char *)"[list]", (char *)"define language preferences",
      & dicod_lang}, 
        {(char *)"SHOW LANG DB", 3, 3, (char *)((void *)0), (char *)"show databases with their language preferences",
      & dicod_show_lang_db}, 
        {(char *)"SHOW LANG DATABASES", 3, 3, (char *)((void *)0), (char *)"show databases with their language preferences",
      & dicod_show_lang_db}, 
        {(char *)"SHOW LANG INFO", 4, 4, (char *)"database", (char *)"show language preferences of a database",
      & dicod_show_lang_info}, 
        {(char *)"SHOW LANG PREF", 3, 3, (char *)((void *)0), (char *)"show server language preferences",
      & dicod_show_lang_pref}, 
        {(char *)((void *)0), 0, 0, (char *)0, (char *)0, (void (*)(dico_stream_t str ,
                                                                 int argc , char **argv ))0}};
#line 161 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/lang.c"
void register_lang(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 182
  dicod_capa_register("lang", cmd___4, (int (*)(void * ))((void *)0), (void *)0);
  }
#line 183
  return;
}
}
#line 129 "/usr/include/sys/socket.h"
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 190
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 470 "./dicod.h"
char *query_ident_name(struct sockaddr_in *srv_addr , struct sockaddr_in *clt_addr ) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 32 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
static char *ident_extract_username(char *reply ) 
{ 
  char *p ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 37
  p = strchr((char const   *)reply, ':');
  }
#line 38
  if (! p) {
#line 39
    return ((char *)((void *)0));
  }
#line 40
  if ((int )*(p + 1) != 32) {
#line 41
    return ((char *)((void *)0));
  } else {
    {
#line 40
    tmp = strncmp((char const   *)(p + 2), "USERID :", (size_t )(sizeof("USERID :") - 1UL));
    }
#line 40
    if (tmp) {
#line 41
      return ((char *)((void *)0));
    }
  }
  {
#line 42
  p += (2UL + sizeof("USERID :")) - 1UL;
#line 43
  p = strchr((char const   *)p, ':');
  }
#line 44
  if (! p) {
#line 45
    return ((char *)((void *)0));
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    p ++;
#line 46
    if (! ((int )*p == 32)) {
#line 46
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return (p);
}
}
#line 52 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
static int is_des_p(char const   *name ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 55
  tmp = strlen(name);
#line 55
  len = (int )tmp;
  }
#line 56
  if (len > 1) {
#line 56
    if ((int const   )*(name + 0) == 91) {
#line 56
      if ((int const   )*(name + (len - 1)) == 93) {
#line 56
        tmp___0 = 1;
      } else {
#line 56
        tmp___0 = 0;
      }
    } else {
#line 56
      tmp___0 = 0;
    }
  } else {
#line 56
    tmp___0 = 0;
  }
#line 56
  return (tmp___0);
}
}
#line 63 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
static void des_fixup_key_parity(unsigned char *key ) 
{ 
  int i ;

  {
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i < 8)) {
#line 67
      goto while_break;
    }
#line 68
    *(key + i) = (unsigned char )((int )*(key + i) & 254);
#line 69
    *(key + i) = (unsigned char )((int )*(key + i) | (1 ^ (((((((int )*(key + i) & ((1 << 4) - 1)) ^ (((int )*(key + i) >> 4) & ((1 << 4) - 1))) & ((1 << 2) - 1)) ^ (((((int )*(key + i) & ((1 << 4) - 1)) ^ (((int )*(key + i) >> 4) & ((1 << 4) - 1))) >> 2) & ((1 << 2) - 1))) & ((1 << 1) - 1)) ^ (((((((int )*(key + i) & ((1 << 4) - 1)) ^ (((int )*(key + i) >> 4) & ((1 << 4) - 1))) & ((1 << 2) - 1)) ^ (((((int )*(key + i) & ((1 << 4) - 1)) ^ (((int )*(key + i) >> 4) & ((1 << 4) - 1))) >> 2) & ((1 << 2) - 1))) >> 1) & ((1 << 1) - 1)))));
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
static void des_cbc_cksum(gl_des_ctx *ctx , unsigned char *buf___1 , size_t bufsize___1 ,
                          unsigned char *out , unsigned char *key ) 
{ 
  unsigned char *p ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *p___0 ;

  {
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (bufsize___1 > 0U)) {
#line 77
      goto while_break;
    }
#line 78
    if (bufsize___1 >= 8U) {
#line 79
      p = (unsigned char *)key;
#line 80
      tmp = p;
#line 80
      p ++;
#line 80
      tmp___0 = buf___1;
#line 80
      buf___1 ++;
#line 80
      *tmp = (unsigned char )((int )*tmp ^ (int )*tmp___0);
#line 81
      tmp___1 = p;
#line 81
      p ++;
#line 81
      tmp___2 = buf___1;
#line 81
      buf___1 ++;
#line 81
      *tmp___1 = (unsigned char )((int )*tmp___1 ^ (int )*tmp___2);
#line 82
      tmp___3 = p;
#line 82
      p ++;
#line 82
      tmp___4 = buf___1;
#line 82
      buf___1 ++;
#line 82
      *tmp___3 = (unsigned char )((int )*tmp___3 ^ (int )*tmp___4);
#line 83
      tmp___5 = p;
#line 83
      p ++;
#line 83
      tmp___6 = buf___1;
#line 83
      buf___1 ++;
#line 83
      *tmp___5 = (unsigned char )((int )*tmp___5 ^ (int )*tmp___6);
#line 84
      tmp___7 = p;
#line 84
      p ++;
#line 84
      tmp___8 = buf___1;
#line 84
      buf___1 ++;
#line 84
      *tmp___7 = (unsigned char )((int )*tmp___7 ^ (int )*tmp___8);
#line 85
      tmp___9 = p;
#line 85
      p ++;
#line 85
      tmp___10 = buf___1;
#line 85
      buf___1 ++;
#line 85
      *tmp___9 = (unsigned char )((int )*tmp___9 ^ (int )*tmp___10);
#line 86
      tmp___11 = p;
#line 86
      p ++;
#line 86
      tmp___12 = buf___1;
#line 86
      buf___1 ++;
#line 86
      *tmp___11 = (unsigned char )((int )*tmp___11 ^ (int )*tmp___12);
#line 87
      tmp___13 = p;
#line 87
      p ++;
#line 87
      tmp___14 = buf___1;
#line 87
      buf___1 ++;
#line 87
      *tmp___13 = (unsigned char )((int )*tmp___13 ^ (int )*tmp___14);
#line 88
      bufsize___1 -= 8U;
    } else {
#line 90
      p___0 = (unsigned char *)(key + bufsize___1);
#line 91
      buf___1 += bufsize___1;
      {
#line 93
      if (bufsize___1 == 7U) {
#line 93
        goto case_7;
      }
#line 95
      if (bufsize___1 == 6U) {
#line 95
        goto case_6;
      }
#line 97
      if (bufsize___1 == 5U) {
#line 97
        goto case_5;
      }
#line 99
      if (bufsize___1 == 4U) {
#line 99
        goto case_4;
      }
#line 101
      if (bufsize___1 == 3U) {
#line 101
        goto case_3;
      }
#line 103
      if (bufsize___1 == 2U) {
#line 103
        goto case_2;
      }
#line 105
      if (bufsize___1 == 1U) {
#line 105
        goto case_1;
      }
#line 92
      goto switch_break;
      case_7: /* CIL Label */ 
#line 94
      p___0 --;
#line 94
      buf___1 --;
#line 94
      *p___0 = (unsigned char )((int )*p___0 ^ (int )*buf___1);
      case_6: /* CIL Label */ 
#line 96
      p___0 --;
#line 96
      buf___1 --;
#line 96
      *p___0 = (unsigned char )((int )*p___0 ^ (int )*buf___1);
      case_5: /* CIL Label */ 
#line 98
      p___0 --;
#line 98
      buf___1 --;
#line 98
      *p___0 = (unsigned char )((int )*p___0 ^ (int )*buf___1);
      case_4: /* CIL Label */ 
#line 100
      p___0 --;
#line 100
      buf___1 --;
#line 100
      *p___0 = (unsigned char )((int )*p___0 ^ (int )*buf___1);
      case_3: /* CIL Label */ 
#line 102
      p___0 --;
#line 102
      buf___1 --;
#line 102
      *p___0 = (unsigned char )((int )*p___0 ^ (int )*buf___1);
      case_2: /* CIL Label */ 
#line 104
      p___0 --;
#line 104
      buf___1 --;
#line 104
      *p___0 = (unsigned char )((int )*p___0 ^ (int )*buf___1);
      case_1: /* CIL Label */ 
#line 106
      p___0 --;
#line 106
      buf___1 --;
#line 106
      *p___0 = (unsigned char )((int )*p___0 ^ (int )*buf___1);
      switch_break: /* CIL Label */ ;
      }
#line 108
      bufsize___1 = (size_t )0;
    }
    {
#line 110
    gl_des_ecb_crypt(ctx, (char const   *)key, (char *)key, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 114 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
static void des_string_to_key(char *buf___1 , size_t bufsize___1 , unsigned char *key ) 
{ 
  size_t i ;
  int j ;
  unsigned int temp ;
  unsigned char *p ;
  char *p_char ;
  char k_char[64] ;
  gl_des_ctx context ;
  char *pstr ;
  int forward ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned char *tmp___2 ;
  void *__cil_tmp17 ;

  {
  {
#line 125
  forward = 1;
#line 127
  p_char = k_char;
#line 128
  memset((void *)(k_char), 0, (size_t )sizeof(k_char));
#line 131
  pstr = buf___1;
#line 132
  i = (size_t )1;
  }
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i <= bufsize___1)) {
#line 132
      goto while_break;
    }
#line 134
    tmp = pstr;
#line 134
    pstr ++;
#line 134
    temp = (unsigned int )*tmp;
#line 136
    j = 0;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (j <= 6)) {
#line 136
        goto while_break___0;
      }
#line 137
      if (forward) {
#line 138
        tmp___0 = p_char;
#line 138
        p_char ++;
#line 138
        *tmp___0 = (char )((int )*tmp___0 ^ ((int )temp & 1));
      } else {
#line 140
        p_char --;
#line 140
        *p_char = (char )((int )*p_char ^ ((int )temp & 1));
      }
#line 141
      temp >>= 1;
#line 136
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 142
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 142
      j --;
#line 142
      if (! (j > 0)) {
#line 142
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 145
    if (i % 8U == 0U) {
#line 146
      forward = ! forward;
    }
#line 132
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  p_char = k_char;
#line 150
  p = (unsigned char *)key;
#line 152
  i = (size_t )0;
  {
#line 152
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 152
    if (! (i <= 7U)) {
#line 152
      goto while_break___2;
    }
#line 153
    temp = 0U;
#line 154
    j = 0;
    {
#line 154
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 154
      if (! (j <= 6)) {
#line 154
        goto while_break___3;
      }
#line 155
      tmp___1 = p_char;
#line 155
      p_char ++;
#line 155
      temp |= (unsigned int )((int )*tmp___1 << (1 + j));
#line 154
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 156
    tmp___2 = p;
#line 156
    p ++;
#line 156
    *tmp___2 = (unsigned char )temp;
#line 152
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 159
  des_fixup_key_parity(key);
#line 160
  gl_des_setkey(& context, (char const   *)key);
#line 161
  des_cbc_cksum(& context, (unsigned char *)buf___1, bufsize___1, key, key);
#line 162
  memset((void *)(& context), 0, (size_t )sizeof(context));
#line 163
  des_fixup_key_parity(key);
  }
#line 164
  return;
}
}
#line 166 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
static int decode64_buf(char const   *name , unsigned char **pbuf , size_t *psize ) 
{ 
  size_t namelen ;
  unsigned char *buf___1 ;
  size_t bufsize___1 ;
  size_t size ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 174
  name ++;
#line 175
  tmp = strlen(name);
#line 175
  namelen = tmp - 1U;
#line 177
  bufsize___1 = 3U * namelen + 1U;
#line 178
  tmp___0 = xmalloc(bufsize___1);
#line 178
  buf___1 = (unsigned char *)tmp___0;
#line 180
  dico_base64_decode(name, namelen, (char *)buf___1, bufsize___1, & size);
#line 183
  *(buf___1 + size) = (unsigned char)0;
#line 184
  tmp___1 = realloc((void *)buf___1, size + 1U);
#line 184
  *pbuf = (unsigned char *)tmp___1;
#line 185
  *psize = size;
  }
#line 186
  return (0);
}
}
#line 208 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
int ident_decrypt(char const   *file , char const   *name , struct ident_info *info ) 
{ 
  unsigned char *buf___1 ;
  size_t size ;
  int fd ;
  char keybuf[1024] ;
  union ident_data id ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int i ;
  unsigned char key[8] ;
  gl_des_ctx ctx ;
  ssize_t tmp___3 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 211
  buf___1 = (unsigned char *)((void *)0);
#line 212
  size = (size_t )0;
#line 217
  tmp = decode64_buf(name, & buf___1, & size);
  }
#line 217
  if (tmp) {
#line 218
    return (1);
  }
#line 220
  if (size != 24U) {
    {
#line 221
    tmp___0 = gettext("Incorrect length of IDENT DES packet");
#line 221
    dico_log(4, 0, (char const   *)tmp___0);
#line 223
    free((void *)buf___1);
    }
#line 224
    return (1);
  }
  {
#line 227
  fd = open(file, 0);
  }
#line 228
  if (fd < 0) {
    {
#line 229
    tmp___1 = gettext("Cannot open file %s");
#line 229
    tmp___2 = __errno_location();
#line 229
    dico_log(4, *tmp___2, (char const   *)tmp___1, file);
    }
#line 230
    return (1);
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    tmp___3 = read(fd, (void *)(keybuf), (size_t )sizeof(keybuf));
    }
#line 233
    if (! ((unsigned long )tmp___3 == sizeof(keybuf))) {
#line 233
      goto while_break;
    }
    {
#line 238
    des_string_to_key(keybuf, (size_t )sizeof(keybuf), (unsigned char *)(key));
#line 239
    gl_des_setkey(& ctx, (char const   *)(key));
#line 241
    memcpy((void */* __restrict  */)(id.chars), (void const   */* __restrict  */)buf___1,
           size);
#line 243
    gl_des_ecb_crypt(& ctx, (char const   *)((char *)(& id.longs[4])), (char *)(& id.longs[4]),
                     1);
#line 244
    id.longs[4] ^= id.longs[2];
#line 245
    id.longs[5] ^= id.longs[3];
#line 247
    gl_des_ecb_crypt(& ctx, (char const   *)((char *)(& id.longs[2])), (char *)(& id.longs[2]),
                     1);
#line 248
    id.longs[2] ^= id.longs[0];
#line 249
    id.longs[3] ^= id.longs[1];
#line 251
    gl_des_ecb_crypt(& ctx, (char const   *)((char *)(& id.longs[0])), (char *)(& id.longs[0]),
                     1);
#line 253
    i = 1;
    }
    {
#line 253
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 253
      if (! (i < 6)) {
#line 253
        goto while_break___0;
      }
#line 254
      id.longs[0] ^= id.longs[i];
#line 253
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    if (id.fields.checksum == 0U) {
#line 257
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  close(fd);
#line 260
  free((void *)buf___1);
  }
#line 261
  if (id.fields.checksum == 0U) {
    {
#line 262
    memmove((void *)info, (void const   *)(& id), (size_t )sizeof(*info));
    }
#line 263
    return (0);
  }
#line 265
  return (1);
}
}
#line 274 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
static void io_buffer_init(struct io_buffer *iob ) 
{ 


  {
#line 277
  iob->size = (size_t )0;
#line 278
  iob->level = (size_t )0;
#line 279
  iob->buffer = (char *)((void *)0);
#line 280
  return;
}
}
#line 282 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
static void io_buffer_free(struct io_buffer *iob ) 
{ 


  {
  {
#line 285
  free((void *)iob->buffer);
  }
#line 286
  return;
}
}
#line 290 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
static int recompute_timeout(struct timeval *start , struct timeval *tval ) 
{ 
  struct timeval now ;
  struct timeval diff ;
  struct timeval tmp ;
  int tmp___0 ;

  {
  {
#line 295
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    diff.tv_sec = now.tv_sec - start->tv_sec;
#line 296
    diff.tv_usec = now.tv_usec - start->tv_usec;
#line 296
    if (diff.tv_usec < 0L) {
#line 296
      (diff.tv_sec) --;
#line 296
      diff.tv_usec += 1000000L;
    }
#line 296
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  if (diff.tv_sec == tval->tv_sec) {
#line 297
    tmp___0 = diff.tv_usec < tval->tv_usec;
  } else {
#line 297
    tmp___0 = diff.tv_sec < tval->tv_sec;
  }
#line 297
  if (tmp___0) {
    {
#line 299
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 299
      tmp.tv_sec = tval->tv_sec - diff.tv_sec;
#line 299
      tmp.tv_usec = tval->tv_usec - diff.tv_usec;
#line 299
      if (tmp.tv_usec < 0L) {
#line 299
        (tmp.tv_sec) --;
#line 299
        tmp.tv_usec += 1000000L;
      }
#line 299
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 300
    *tval = tmp;
#line 301
    return (0);
  }
#line 303
  return (1);
}
}
#line 314 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
enum socket_io_retval socket_io(int fd , int conflag , long timeout , struct io_buffer *inb ,
                                struct io_buffer *outb ) 
{ 
  struct timeval tval ;
  struct timeval start ;
  int rc ;
  fd_set rd ;
  fd_set wr ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int val ;
  int len ;
  int tmp___3 ;
  int *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 320
  gettimeofday((struct timeval */* __restrict  */)(& start), (__timezone_ptr_t )((void *)0));
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! inb) {
#line 325
      if (! outb) {
#line 326
        return ((enum socket_io_retval )0);
      }
    }
    {
#line 328
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 328
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rd.fds_bits[0]): "memory");
#line 328
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 329
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 329
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& wr.fds_bits[0]): "memory");
#line 329
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 331
    if (inb) {
#line 332
      rd.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
    }
#line 333
    if (outb) {
#line 334
      wr.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
    }
    {
#line 336
    tval.tv_sec = timeout;
#line 337
    tval.tv_usec = (__suseconds_t )0;
#line 338
    tmp___0 = recompute_timeout(& start, & tval);
    }
#line 338
    if (tmp___0) {
      {
#line 339
      tmp = __errno_location();
#line 339
      *tmp = 110;
      }
#line 340
      return ((enum socket_io_retval )3);
    }
    {
#line 343
    rc = select(fd + 1, (fd_set */* __restrict  */)(& rd), (fd_set */* __restrict  */)(& wr),
                (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tval));
    }
#line 345
    if (rc == 0) {
      {
#line 346
      tmp___1 = __errno_location();
#line 346
      *tmp___1 = 110;
      }
#line 347
      return ((enum socket_io_retval )3);
    }
#line 350
    if (rc == -1) {
      {
#line 350
      tmp___2 = __errno_location();
      }
#line 350
      if (*tmp___2 == 4) {
#line 351
        goto __Cont;
      }
    }
#line 352
    if (rc < 0) {
#line 353
      return ((enum socket_io_retval )1);
    }
#line 354
    if (outb) {
#line 354
      if ((wr.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 355
        if (! conflag) {
          {
#line 357
          len = (int )sizeof(val);
#line 358
          tmp___3 = getsockopt(fd, 1, 4, (void */* __restrict  */)(& val), (socklen_t */* __restrict  */)(& len));
          }
#line 358
          if (tmp___3) {
#line 359
            return ((enum socket_io_retval )1);
          }
#line 360
          if (val) {
            {
#line 361
            tmp___4 = __errno_location();
#line 361
            *tmp___4 = val;
            }
#line 362
            return ((enum socket_io_retval )2);
          }
#line 364
          conflag = 1;
        }
        {
#line 366
        rc = write(fd, (void const   *)(outb->buffer + outb->level), outb->size - outb->level);
        }
#line 368
        if (rc < 1) {
#line 369
          return ((enum socket_io_retval )4);
        } else {
#line 371
          outb->level += (size_t )rc;
#line 372
          if (outb->level == outb->size) {
#line 373
            outb = (struct io_buffer *)((void *)0);
          }
        }
      }
    }
#line 376
    if (inb) {
#line 376
      if ((rd.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 377
        if (inb->size == inb->level) {
#line 378
          if (inb->size == 0U) {
#line 379
            inb->size = (size_t )16;
          }
          {
#line 380
          tmp___5 = x2realloc((void *)inb->buffer, & inb->size);
#line 380
          inb->buffer = (char *)tmp___5;
          }
        }
        {
#line 382
        rc = read(fd, (void *)(inb->buffer + inb->level), inb->size - inb->level);
        }
#line 383
        if (rc < 1) {
#line 384
          return ((enum socket_io_retval )4);
        } else {
#line 386
          inb->level += (size_t )rc;
#line 387
          if ((int )*(inb->buffer + (inb->level - 1U)) == 10) {
#line 388
            inb = (struct io_buffer *)((void *)0);
          }
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return ((enum socket_io_retval )0);
}
}
#line 395 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/ident.c"
char *query_ident_name(struct sockaddr_in *srv_addr , struct sockaddr_in *clt_addr ) 
{ 
  int fd ;
  int rc ;
  int conflag ;
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  struct sockaddr_in s ;
  struct io_buffer ib ;
  struct io_buffer ob ;
  char *name ;
  void (*sighan)(int  ) ;
  enum socket_io_retval retval ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  uint16_t tmp___9 ;
  uint16_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  struct ident_info info ;
  uint16_t tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int *tmp___29 ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;

  {
  {
#line 404
  name = (char *)((void *)0);
#line 408
  fd = socket(2, 1, 0);
  }
#line 409
  if (fd == -1) {
    {
#line 410
    tmp = gettext("cannot create socket for AUTH identification");
#line 410
    tmp___0 = __errno_location();
#line 410
    dico_log(4, *tmp___0, (char const   *)tmp);
    }
#line 412
    return ((char *)((void *)0));
  }
  {
#line 414
  rc = fcntl(fd, 3);
#line 415
  rc |= 2048;
#line 416
  fcntl(fd, 4, rc);
#line 418
  s.sin_family = (sa_family_t )2;
#line 419
  s.sin_addr.s_addr = srv_addr->sin_addr.s_addr;
#line 420
  s.sin_port = (in_port_t )0;
#line 421
  tmp___3 = bind(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& s)),
                 (socklen_t )sizeof(s));
  }
#line 421
  if (tmp___3 < 0) {
    {
#line 422
    tmp___1 = gettext("cannot bind AUTH socket");
#line 422
    tmp___2 = __errno_location();
#line 422
    dico_log(4, *tmp___2, (char const   *)tmp___1);
#line 424
    close(fd);
    }
#line 425
    return ((char *)((void *)0));
  }
  {
#line 428
  s = *clt_addr;
#line 429
  s.sin_port = htons((uint16_t )113);
#line 431
  tmp___8 = connect(fd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& s)),
                    (socklen_t )sizeof(s));
  }
#line 431
  if (tmp___8 == -1) {
    {
#line 432
    tmp___7 = __errno_location();
    }
#line 432
    if (*tmp___7 == 115) {
#line 433
      conflag = 0;
    } else {
      {
#line 435
      tmp___4 = inet_ntoa(s.sin_addr);
#line 435
      tmp___5 = gettext("cannot connect to AUTH server %s");
#line 435
      tmp___6 = __errno_location();
#line 435
      dico_log(4, *tmp___6, (char const   *)tmp___5, tmp___4);
#line 438
      close(fd);
      }
#line 439
      return ((char *)((void *)0));
    }
  } else {
#line 442
    conflag = 1;
  }
  {
#line 444
  sighan = signal(13, (void (*)(int  ))1);
#line 446
  io_buffer_init(& ib);
#line 447
  io_buffer_init(& ob);
#line 448
  tmp___9 = ntohs(srv_addr->sin_port);
#line 448
  tmp___10 = ntohs(clt_addr->sin_port);
#line 448
  asprintf((char **/* __restrict  */)(& ob.buffer), (char const   */* __restrict  */)"%u , %u\r\n",
           (int )tmp___10, (int )tmp___9);
#line 451
  ob.size = strlen((char const   *)ob.buffer);
#line 453
  retval = socket_io(fd, conflag, ident_timeout, & ib, & ob);
#line 454
  io_buffer_free(& ob);
  }
  {
#line 457
  if ((unsigned int )retval == 0U) {
#line 457
    goto case_0;
  }
#line 481
  if ((unsigned int )retval == 1U) {
#line 481
    goto case_1;
  }
#line 487
  if ((unsigned int )retval == 2U) {
#line 487
    goto case_2;
  }
#line 493
  if ((unsigned int )retval == 3U) {
#line 493
    goto case_3;
  }
#line 498
  if ((unsigned int )retval == 4U) {
#line 498
    goto case_4;
  }
#line 456
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 458
  trimnl(ib.buffer, ib.level);
#line 459
  name = ident_extract_username(ib.buffer);
  }
#line 460
  if (! name) {
    {
#line 461
    tmp___11 = inet_ntoa(s.sin_addr);
#line 461
    tmp___12 = gettext("Malformed IDENT response: `%s\', from %s");
#line 461
    dico_log(4, 0, (char const   *)tmp___12, ib.buffer, tmp___11);
    }
  } else {
    {
#line 464
    tmp___17 = is_des_p((char const   *)name);
    }
#line 464
    if (tmp___17) {
#line 465
      if (! ident_keyfile) {
        {
#line 466
        tmp___13 = gettext("Keyfile for AUTH responses not specified in config; use `ident-keyfile FILE\'");
#line 466
        dico_log(4, 0, (char const   *)tmp___13);
#line 469
        name = (char *)((void *)0);
        }
      } else {
        {
#line 472
        tmp___16 = ident_decrypt((char const   *)ident_keyfile, (char const   *)name,
                                 & info);
        }
#line 472
        if (tmp___16 == 0) {
          {
#line 473
          tmp___14 = ntohs(info.uid);
#line 473
          tmp___15 = umaxtostr((uintmax_t )tmp___14, buf___1);
#line 473
          name = xstrdup((char const   *)tmp___15);
          }
        } else {
#line 475
          name = (char *)((void *)0);
        }
      }
    } else {
      {
#line 478
      name = xstrdup((char const   *)name);
      }
    }
  }
#line 479
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 482
  tmp___18 = inet_ntoa(s.sin_addr);
#line 482
  tmp___19 = gettext("failure while communicating with AUTH server %s");
#line 482
  tmp___20 = __errno_location();
#line 482
  dico_log(4, *tmp___20, (char const   *)tmp___19, tmp___18);
  }
#line 485
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 488
  tmp___21 = inet_ntoa(s.sin_addr);
#line 488
  tmp___22 = gettext("cannot connect to AUTH server %s");
#line 488
  tmp___23 = __errno_location();
#line 488
  dico_log(4, *tmp___23, (char const   *)tmp___22, tmp___21);
  }
#line 491
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 494
  tmp___24 = inet_ntoa(s.sin_addr);
#line 494
  tmp___25 = gettext("no reply from AUTH server %s");
#line 494
  tmp___26 = __errno_location();
#line 494
  dico_log(4, *tmp___26, (char const   *)tmp___25, tmp___24);
  }
#line 496
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 499
  tmp___27 = inet_ntoa(s.sin_addr);
#line 499
  tmp___28 = gettext("I/O error while communicating with AUTH server %s");
#line 499
  tmp___29 = __errno_location();
#line 499
  dico_log(4, *tmp___29, (char const   *)tmp___28, tmp___27);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 504
  io_buffer_free(& ib);
  }
#line 505
  return (name);
}
}
#line 478 "./dicod.h"
int sasl_enable ;
#line 479 "./dicod.h"
dico_list_t sasl_enabled_mech  ;
#line 480 "./dicod.h"
dico_list_t sasl_disabled_mech  ;
#line 481 "./dicod.h"
char *sasl_service  ;
#line 482 "./dicod.h"
char *sasl_realm  ;
#line 483 "./dicod.h"
dico_list_t sasl_anon_groups  ;
#line 19 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/gsasl.c"
int sasl_enable  =    1;
#line 389 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/gsasl.c"
void register_sasl(void) 
{ 


  {
#line 393
  return;
}
}
#line 429 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 119 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 76 "./dicod.h"
int got_quit ;
#line 79 "./dicod.h"
char *msg_id  ;
#line 299
void replace_io_stream(dico_stream_t str ) ;
#line 305
int get_input_line(dico_stream_t str , char **buf___1 , size_t *size , size_t *rdbytes ) ;
#line 337
void dicod_handle_command(dico_stream_t str , int argc , char **argv ) ;
#line 346
void dicod_capa_iterate(int (*fun)(char const   * , int  , void * ) , void *closure ) ;
#line 400
void init_auth_data(void) ;
#line 467
void access_log_free_cache(void) ;
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static int print_capa(char const   *name , int enabled , void *data ) 
{ 
  struct capa_print *cp ;
  size_t tmp ;
  char *__cil_tmp6 ;

  {
#line 30
  cp = (struct capa_print *)data;
#line 31
  if (enabled) {
#line 32
    tmp = cp->num;
#line 32
    (cp->num) ++;
#line 32
    if (tmp) {
      {
#line 33
      dico_stream_write(cp->stream, (void const   *)".", (size_t )1);
      }
    }
    {
#line 34
    stream_writez(cp->stream, (char *)name);
    }
  }
#line 36
  return (0);
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static void output_capabilities(dico_stream_t str ) 
{ 
  struct capa_print cp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 43
  cp.num = (size_t )0;
#line 44
  cp.stream = str;
#line 45
  dico_stream_write(str, (void const   *)"<", (size_t )1);
#line 46
  dicod_capa_iterate(& print_capa, (void *)(& cp));
#line 47
  dico_stream_write(str, (void const   *)">", (size_t )1);
  }
#line 48
  return;
}
}
#line 58 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static void initial_banner(dico_stream_t str ) 
{ 
  time_t tmp ;
  __pid_t tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 61
  dico_stream_write(str, (void const   *)"220 ", (size_t )4);
#line 62
  stream_writez(str, hostname);
#line 63
  dico_stream_write(str, (void const   *)" ", (size_t )1);
  }
#line 64
  if (initial_banner_text) {
    {
#line 65
    stream_writez(str, initial_banner_text);
    }
  } else {
    {
#line 67
    stream_writez(str, (char *)program_version);
    }
  }
  {
#line 68
  dico_stream_write(str, (void const   *)" ", (size_t )1);
#line 69
  output_capabilities(str);
#line 70
  dico_stream_write(str, (void const   *)" ", (size_t )1);
#line 71
  tmp = time((time_t *)((void *)0));
#line 71
  tmp___0 = getpid();
#line 71
  asprintf((char **/* __restrict  */)(& msg_id), (char const   */* __restrict  */)"<%lu.%lu@%s>",
           (unsigned long )tmp___0, (unsigned long )tmp, hostname);
#line 75
  stream_writez(str, msg_id);
#line 76
  dico_stream_write(str, (void const   *)"\r\n", (size_t )2);
  }
#line 77
  return;
}
}
#line 79 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
int get_input_line(dico_stream_t str , char **buf___1 , size_t *size , size_t *rdbytes ) 
{ 
  int rc ;

  {
  {
#line 83
  alarm(inactivity_timeout);
#line 84
  rc = dico_stream_getline(str, buf___1, size, rdbytes);
#line 85
  alarm(0U);
  }
#line 86
  return (rc);
}
}
#line 89 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
void sig_alarm(int sig ) 
{ 


  {
  {
#line 92
  exit(1);
  }
}
}
#line 95 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static void load_modules(void) 
{ 
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  dicod_module_instance_t *inst ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 98
  tmp = xdico_list_iterator(modinst_list);
#line 98
  itr = tmp;
#line 101
  tmp___0 = dico_iterator_first(itr);
#line 101
  inst = (dicod_module_instance_t *)tmp___0;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! inst) {
#line 101
      goto while_break;
    }
    {
#line 103
    tmp___2 = dicod_load_module(inst);
    }
#line 103
    if (tmp___2) {
      {
#line 104
      database_remove_dependent(inst);
#line 105
      dico_iterator_remove_current(itr, (void **)((void *)0));
      }
    }
    {
#line 101
    tmp___1 = dico_iterator_next(itr);
#line 101
    inst = (dicod_module_instance_t *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  dico_iterator_destroy(& itr);
  }
#line 109
  return;
}
}
#line 111 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static void init_databases(void) 
{ 
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  dicod_database_t *dp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;

  {
  {
#line 114
  tmp = xdico_list_iterator(database_list);
#line 114
  itr = tmp;
#line 117
  tmp___0 = dico_iterator_first(itr);
#line 117
  dp = (dicod_database_t *)tmp___0;
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! dp) {
#line 117
      goto while_break;
    }
    {
#line 118
    tmp___3 = dicod_init_database(dp);
    }
#line 118
    if (tmp___3) {
      {
#line 119
      tmp___2 = gettext("removing database %s");
#line 119
      dico_log(2, 0, (char const   *)tmp___2, dp->name);
#line 120
      dico_iterator_remove_current(itr, (void **)((void *)0));
#line 121
      dicod_database_free(dp);
      }
    }
    {
#line 117
    tmp___1 = dico_iterator_next(itr);
#line 117
    dp = (dicod_database_t *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  dico_iterator_destroy(& itr);
  }
#line 125
  return;
}
}
#line 127 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static void open_databases(void) 
{ 
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  dicod_database_t *dp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;

  {
  {
#line 130
  tmp = xdico_list_iterator(database_list);
#line 130
  itr = tmp;
#line 133
  tmp___0 = dico_iterator_first(itr);
#line 133
  dp = (dicod_database_t *)tmp___0;
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! dp) {
#line 133
      goto while_break;
    }
    {
#line 134
    tmp___3 = dicod_open_database(dp);
    }
#line 134
    if (tmp___3) {
      {
#line 135
      tmp___2 = gettext("removing database %s");
#line 135
      dico_log(2, 0, (char const   *)tmp___2, dp->name);
#line 136
      dico_iterator_remove_current(itr, (void **)((void *)0));
#line 137
      dicod_database_free(dp);
      }
    }
    {
#line 133
    tmp___1 = dico_iterator_next(itr);
#line 133
    dp = (dicod_database_t *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  dico_iterator_destroy(& itr);
  }
#line 141
  return;
}
}
#line 143 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static void close_databases(void) 
{ 
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  dicod_database_t *dp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;

  {
  {
#line 146
  tmp = xdico_list_iterator(database_list);
#line 146
  itr = tmp;
#line 149
  tmp___0 = dico_iterator_first(itr);
#line 149
  dp = (dicod_database_t *)tmp___0;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! dp) {
#line 149
      goto while_break;
    }
    {
#line 150
    tmp___3 = dicod_close_database(dp);
    }
#line 150
    if (tmp___3) {
      {
#line 151
      tmp___2 = gettext("error closing database %s");
#line 151
      dico_log(2, 0, (char const   *)tmp___2, dp->name);
      }
    }
    {
#line 149
    tmp___1 = dico_iterator_next(itr);
#line 149
    dp = (dicod_database_t *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  dico_iterator_destroy(& itr);
  }
#line 154
  return;
}
}
#line 156 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
int soundex_sel(int cmd___6 , char const   *word , char const   *dict_word , void *closure ) 
{ 
  char *code___0 ;
  char dcode[5] ;
  int tmp ;
  void *__cil_tmp8 ;

  {
#line 159
  code___0 = (char *)closure;
  {
#line 163
  if (cmd___6 == 0) {
#line 163
    goto case_0;
  }
#line 167
  if (cmd___6 == 1) {
#line 167
    goto case_1;
  }
#line 171
  if (cmd___6 == 2) {
#line 171
    goto case_2;
  }
#line 162
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 164
  dico_soundex(word, (char *)code___0);
  }
#line 165
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 168
  dico_soundex(dict_word, (char *)(dcode));
#line 169
  tmp = strcmp((char const   *)(dcode), (char const   *)code___0);
  }
#line 169
  return (tmp == 0);
  case_2: /* CIL Label */ 
#line 172
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 174
  return (0);
}
}
#line 177 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
int all_sel(int cmd___6 , char const   *word , char const   *dict_word , void *closure ) 
{ 


  {
  {
#line 181
  if (cmd___6 == 0) {
#line 181
    goto case_0;
  }
#line 184
  if (cmd___6 == 1) {
#line 184
    goto case_1;
  }
#line 187
  if (cmd___6 == 2) {
#line 187
    goto case_2;
  }
#line 180
  goto switch_break;
  case_0: /* CIL Label */ 
#line 182
  goto switch_break;
  case_1: /* CIL Label */ 
#line 185
  return (1);
  case_2: /* CIL Label */ 
#line 188
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 190
  return (0);
}
}
#line 196 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static char code[5]  ;
#line 197 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static struct dico_strategy defstrat[4]  = {      {(char *)"exact", (char *)"Match words exactly", (int (*)(int  , char const   * ,
                                                               char const   * , void * ))0,
      (void *)0, 0, (struct dico_list *)0}, 
        {(char *)"prefix", (char *)"Match word prefixes", (int (*)(int  , char const   * ,
                                                                char const   * , void * ))0,
      (void *)0, 0, (struct dico_list *)0}, 
        {(char *)"soundex", (char *)"Match using SOUNDEX algorithm", & soundex_sel, (void *)(code),
      0, (struct dico_list *)0}, 
        {(char *)"all", (char *)"Match everything (experimental)", & all_sel, (void *)0,
      0, (struct dico_list *)0}};
#line 193 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
void dicod_init_strategies(void) 
{ 
  int i ;

  {
#line 204
  i = 0;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! ((unsigned long )i < sizeof(defstrat) / sizeof(defstrat[0]))) {
#line 204
      goto while_break;
    }
    {
#line 205
    dico_strategy_add((dico_strategy_t const   )(defstrat + i));
#line 204
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 208 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
void dicod_server_init(void) 
{ 
  dico_strategy_t tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 211
  load_modules();
#line 212
  init_databases();
#line 213
  tmp = (dico_strategy_t )dico_get_default_strategy();
  }
#line 213
  if (! tmp) {
    {
#line 214
    dico_set_default_strategy("lev");
    }
  }
#line 215
  return;
}
}
#line 217 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
void dicod_server_cleanup(void) 
{ 
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  dicod_database_t *dp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;

  {
  {
#line 220
  tmp = xdico_list_iterator(database_list);
#line 220
  itr = tmp;
#line 223
  tmp___0 = dico_iterator_first(itr);
#line 223
  dp = (dicod_database_t *)tmp___0;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! dp) {
#line 223
      goto while_break;
    }
    {
#line 224
    tmp___3 = dicod_free_database(dp);
    }
#line 224
    if (tmp___3) {
      {
#line 225
      tmp___2 = gettext("error freeing database %s");
#line 225
      dico_log(2, 0, (char const   *)tmp___2, dp->name);
      }
    }
    {
#line 223
    tmp___1 = dico_iterator_next(itr);
#line 223
    dp = (dicod_database_t *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 227
  dico_iterator_destroy(& itr);
  }
#line 228
  return;
}
}
#line 230 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static void log_connection(char const   *msg ) 
{ 
  char *p ;
  char *tmp ;
  unsigned int n ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 233
  if (debug_level) {
    {
#line 234
    tmp = sockaddr_to_astr((struct sockaddr  const  *)(& client_addr), client_addrlen);
#line 234
    p = tmp;
    }
#line 235
    if (debug_source_info) {
      {
#line 236
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 236
        n = 236U;
#line 236
        dico_stream_ioctl(debug_stream, 2, (void *)"/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c");
#line 236
        dico_stream_ioctl(debug_stream, 3, (void *)(& n));
        }
#line 236
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 237
    stream_writez(debug_stream, (char *)msg);
#line 238
    dico_stream_write(debug_stream, (void const   *)" ", (size_t )1);
    }
#line 239
    if (identity_name) {
      {
#line 240
      stream_printf(debug_stream, "%s@", identity_name);
      }
    }
    {
#line 241
    stream_writez(debug_stream, p);
#line 242
    dico_stream_write(debug_stream, (void const   *)"\n", (size_t )1);
#line 243
    free((void *)p);
    }
  }
#line 245
  return;
}
}
#line 247 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
static dico_stream_t iostr  ;
#line 249 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
void replace_io_stream(dico_stream_t str ) 
{ 


  {
#line 252
  iostr = str;
#line 253
  return;
}
}
#line 255 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
int dicod_loop(dico_stream_t str ) 
{ 
  char *buf___1 ;
  size_t size ;
  size_t rdbytes ;
  xdico_input_t input ;
  int argc ;
  char **argv ;
  dico_stream_t logstr ;
  dico_stream_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 258
  buf___1 = (char *)((void *)0);
#line 259
  size = (size_t )0;
#line 265
  begin_timing("dicod");
#line 266
  signal(14, & sig_alarm);
#line 267
  memset((void *)(& input), 0, (size_t )sizeof(input));
#line 268
  got_quit = 0;
  }
#line 269
  if (transcript) {
    {
#line 270
    tmp = dico_log_stream_create(0);
#line 270
    logstr = tmp;
    }
#line 271
    if (! logstr) {
      {
#line 272
      xalloc_die();
      }
    }
    {
#line 273
    str = xdico_transcript_stream_create(str, logstr, (char const   **)((void *)0));
    }
  }
  {
#line 275
  replace_io_stream(str);
  }
#line 277
  if (identity_check) {
#line 277
    if ((int )server_addr.sa_family == 2) {
      {
#line 278
      identity_name = query_ident_name((struct sockaddr_in *)(& server_addr), (struct sockaddr_in *)(& client_addr));
      }
    }
  }
  {
#line 280
  tmp___0 = gettext("connection from");
#line 280
  log_connection((char const   *)tmp___0);
#line 282
  open_databases();
#line 283
  check_db_visibility();
#line 284
  initial_banner(iostr);
#line 286
  input = xdico_tokenize_begin();
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! got_quit) {
      {
#line 287
      tmp___1 = get_input_line(iostr, & buf___1, & size, & rdbytes);
      }
#line 287
      if (! (tmp___1 == 0)) {
#line 287
        goto while_break;
      }
    } else {
#line 287
      goto while_break;
    }
    {
#line 288
    trimnl(buf___1, rdbytes);
#line 289
    xdico_tokenize_input(input, buf___1, & argc, & argv);
    }
#line 290
    if (argc == 0) {
#line 291
      goto while_continue;
    }
    {
#line 292
    dicod_handle_command(iostr, argc, argv);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  xdico_tokenize_end(& input);
#line 295
  close_databases();
#line 296
  init_auth_data();
#line 297
  access_log_free_cache();
#line 299
  tmp___2 = gettext("session finished:");
#line 299
  log_connection((char const   *)tmp___2);
  }
#line 300
  return (0);
}
}
#line 303 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dicod.c"
int dicod_inetd(void) 
{ 
  dico_stream_t str ;
  dico_stream_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 306
  tmp = dico_fd_io_stream_create(0, 1);
#line 306
  str = tmp;
  }
#line 308
  if (! str) {
#line 309
    return (1);
  }
  {
#line 310
  dico_stream_set_buffer(str, (enum dico_buffer_type )1, (size_t )6144);
#line 312
  client_addrlen = (int )sizeof(client_addr);
#line 313
  tmp___0 = getsockname(0, (struct sockaddr */* __restrict  */)(& client_addr), (socklen_t */* __restrict  */)(& client_addrlen));
  }
#line 313
  if (tmp___0 == -1) {
#line 314
    client_addrlen = 0;
  }
  {
#line 316
  server_addrlen = (int )sizeof(server_addr);
#line 317
  tmp___1 = getsockname(1, (struct sockaddr */* __restrict  */)(& server_addr), (socklen_t */* __restrict  */)(& server_addrlen));
  }
#line 317
  if (tmp___1 == -1) {
#line 318
    server_addrlen = 0;
  }
  {
#line 320
  tmp___2 = dicod_loop(str);
  }
#line 320
  return (tmp___2);
}
}
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dbtext.c"
static int dbtext_open(void **handle , dico_url_t url ) 
{ 
  char *dirname ;
  char *tmp ;
  struct stat st ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 25
  tmp = dico_url_full_path(url);
#line 25
  dirname = tmp;
  }
#line 27
  if (! dirname) {
    {
#line 28
    tmp___0 = gettext("cannot get path from URL `%s\'");
#line 28
    dico_log(4, 0, (char const   *)tmp___0, url->string);
    }
#line 29
    return (1);
  }
  {
#line 32
  tmp___3 = stat((char const   */* __restrict  */)dirname, (struct stat */* __restrict  */)(& st));
  }
#line 32
  if (tmp___3) {
    {
#line 33
    tmp___1 = gettext("cannot stat directory `%s\'");
#line 33
    tmp___2 = __errno_location();
#line 33
    dico_log(4, *tmp___2, (char const   *)tmp___1, dirname);
#line 34
    free((void *)dirname);
    }
#line 35
    return (1);
  }
#line 38
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 39
    tmp___4 = gettext("%s: not a directory");
#line 39
    dico_log(4, 0, (char const   *)tmp___4, dirname);
#line 40
    free((void *)dirname);
    }
#line 41
    return (1);
  }
  {
#line 44
  free((void *)dirname);
#line 45
  *handle = (void *)url;
  }
#line 46
  return (0);
}
}
#line 49 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dbtext.c"
static FILE *open_file(char const   *dir , char const   *file , char **pfname ) 
{ 
  char *full_name ;
  char *tmp ;
  FILE *fp ;
  FILE *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 52
  tmp = make_full_file_name(dir, file);
#line 52
  full_name = tmp;
#line 53
  tmp___0 = fopen((char const   */* __restrict  */)full_name, (char const   */* __restrict  */)"r");
#line 53
  fp = tmp___0;
  }
#line 54
  if (! fp) {
    {
#line 55
    tmp___1 = gettext("cannot open file `%s\'");
#line 55
    tmp___2 = __errno_location();
#line 55
    dico_log(4, *tmp___2, (char const   *)tmp___1, full_name);
#line 56
    free((void *)full_name);
    }
  } else {
#line 58
    *pfname = full_name;
  }
#line 59
  return (fp);
}
}
#line 62 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dbtext.c"
static char *find_key(FILE *fp , char const   *key , char **pbuf , size_t *psize ) 
{ 
  ssize_t size ;
  size_t keylen ;
  size_t tmp ;
  char *p ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;

  {
  {
#line 66
  tmp = strlen(key);
#line 66
  keylen = tmp;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 68
    size = getline((char **/* __restrict  */)pbuf, (size_t */* __restrict  */)psize,
                   (FILE */* __restrict  */)fp);
    }
#line 68
    if (! (size > 0)) {
#line 68
      goto while_break;
    }
    {
#line 69
    p = *pbuf;
#line 71
    trimnl(p, (size_t )size);
    }
    {
#line 72
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 72
      if (*p) {
        {
#line 72
        tmp___0 = __ctype_b_loc();
        }
#line 72
        if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 72
          goto while_break___0;
        }
      } else {
#line 72
        goto while_break___0;
      }
#line 73
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 74
    if (! *p) {
#line 75
      goto while_continue;
    } else
#line 74
    if ((int )*p == 35) {
#line 75
      goto while_continue;
    } else {
      {
#line 74
      tmp___1 = strlen((char const   *)p);
      }
#line 74
      if (tmp___1 < keylen) {
#line 75
        goto while_continue;
      }
    }
    {
#line 76
    tmp___4 = memcmp((void const   *)p, (void const   *)key, keylen);
    }
#line 76
    if (tmp___4 == 0) {
#line 77
      if ((int )*(p + keylen) == 0) {
#line 78
        return (p + keylen);
      } else {
        {
#line 79
        tmp___3 = __ctype_b_loc();
        }
#line 79
        if ((int const   )*(*tmp___3 + (int )*(p + keylen)) & 8192) {
#line 80
          p += keylen;
          {
#line 80
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 80
            if (*p) {
              {
#line 80
              tmp___2 = __ctype_b_loc();
              }
#line 80
              if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 80
                goto while_break___1;
              }
            } else {
#line 80
              goto while_break___1;
            }
#line 80
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 82
          return (p);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return ((char *)((void *)0));
}
}
#line 89 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dbtext.c"
static int dbtext_get_password(void *handle , char const   *qpw , char const   *key ,
                               char **ppass ) 
{ 
  dico_url_t url ;
  char *dir ;
  char *tmp ;
  char *full_name ;
  FILE *fp ;
  FILE *tmp___0 ;
  int rc ;
  char *buf___1 ;
  size_t size ;
  char *val ;
  char *tmp___1 ;

  {
  {
#line 93
  url = (dico_url_t )handle;
#line 94
  tmp = dico_url_full_path(url);
#line 94
  dir = tmp;
#line 96
  tmp___0 = open_file((char const   *)dir, qpw, & full_name);
#line 96
  fp = tmp___0;
  }
#line 99
  if (fp) {
    {
#line 100
    buf___1 = (char *)((void *)0);
#line 101
    size = (size_t )0;
#line 102
    tmp___1 = find_key(fp, key, & buf___1, & size);
#line 102
    val = tmp___1;
    }
#line 103
    if (val) {
      {
#line 104
      *ppass = xstrdup((char const   *)val);
      }
    } else {
#line 106
      *ppass = (char *)((void *)0);
    }
    {
#line 107
    fclose(fp);
#line 108
    free((void *)full_name);
#line 109
    free((void *)buf___1);
#line 110
    rc = 0;
    }
  } else {
#line 112
    rc = 1;
  }
  {
#line 113
  free((void *)dir);
  }
#line 114
  return (rc);
}
}
#line 117 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dbtext.c"
static int _free_group(void *item , void *data ) 
{ 


  {
  {
#line 120
  free(item);
  }
#line 121
  return (0);
}
}
#line 124 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dbtext.c"
static int dbtext_get_groups(void *handle , char const   *qgr , char const   *key ,
                             dico_list_t *pgroups ) 
{ 
  dico_url_t url ;
  char *dir ;
  char *tmp ;
  char *full_name ;
  FILE *fp ;
  FILE *tmp___0 ;
  int rc ;
  dico_list_t groups ;
  char *buf___1 ;
  size_t size ;
  char *val ;
  char *tmp___1 ;

  {
  {
#line 128
  url = (dico_url_t )handle;
#line 129
  tmp = dico_url_full_path(url);
#line 129
  dir = tmp;
#line 131
  tmp___0 = open_file((char const   *)dir, qgr, & full_name);
#line 131
  fp = tmp___0;
#line 133
  groups = (dico_list_t )((void *)0);
  }
#line 135
  if (fp) {
#line 136
    buf___1 = (char *)((void *)0);
#line 137
    size = (size_t )0;
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 140
      val = find_key(fp, key, & buf___1, & size);
      }
#line 140
      if (! val) {
#line 140
        goto while_break;
      }
#line 141
      if (! groups) {
        {
#line 142
        groups = xdico_list_create();
#line 143
        dico_list_set_free_item(groups, & _free_group, (void *)0);
        }
      }
      {
#line 145
      tmp___1 = xstrdup((char const   *)val);
#line 145
      xdico_list_append(groups, (void *)tmp___1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 148
    *pgroups = groups;
#line 149
    fclose(fp);
#line 150
    free((void *)full_name);
#line 151
    free((void *)buf___1);
#line 152
    rc = 0;
    }
  } else {
#line 154
    rc = 1;
  }
#line 155
  return (rc);
}
}
#line 158 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/dbtext.c"
struct udb_def text_udb_def  =    {"text", & dbtext_open, (int (*)(void * ))((void *)0), & dbtext_get_password, & dbtext_get_groups};
#line 795 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 101 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
int yyleng  ;
#line 102
FILE *yyin ;
#line 102
FILE *yyout ;
#line 201 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static YY_BUFFER_STATE yy_current_buffer  =    (YY_BUFFER_STATE )0;
#line 211 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static char yy_hold_char  ;
#line 213 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static int yy_n_chars  ;
#line 219 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static char *yy_c_buf_p  =    (char *)0;
#line 220 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static int yy_init  =    1;
#line 221 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static int yy_start  =    0;
#line 226 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static int yy_did_buffer_switch_on_eof  ;
#line 228
void yyrestart(FILE *input_file ) ;
#line 230
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 231
void yy_load_buffer_state(void) ;
#line 232
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 233
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 234
void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 235
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 238
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 239
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) ;
#line 240
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) ;
#line 242
static void *yy_flex_alloc(yy_size_t size ) ;
#line 243
static void *yy_flex_realloc(void *ptr , yy_size_t size ) ;
#line 244
static void yy_flex_free(void *ptr ) ;
#line 267 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
FILE *yyin  =    (FILE *)0;
#line 267 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
FILE *yyout  =    (FILE *)0;
#line 271 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
char *yytext  ;
#line 274
static yy_state_type yy_get_previous_state(void) ;
#line 275
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 276
static int yy_get_next_buffer(void) ;
#line 277
static void yy_fatal_error(char const   *msg ) ;
#line 291 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static short const   yy_accept[132]  = 
#line 291
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )2, 
        (short const   )2,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )33,      (short const   )31,      (short const   )28, 
        (short const   )29,      (short const   )31,      (short const   )9,      (short const   )30, 
        (short const   )13,      (short const   )13,      (short const   )31,      (short const   )13, 
        (short const   )28,      (short const   )9,      (short const   )2,      (short const   )4, 
        (short const   )3,      (short const   )32,      (short const   )27,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )19,      (short const   )32, 
        (short const   )28,      (short const   )0,      (short const   )14,      (short const   )0, 
        (short const   )9,      (short const   )8,      (short const   )13,      (short const   )1, 
        (short const   )11,      (short const   )0,      (short const   )12,      (short const   )28, 
        (short const   )0,      (short const   )9,      (short const   )9,      (short const   )9, 
        (short const   )2,      (short const   )3,      (short const   )3,      (short const   )5, 
        (short const   )0,      (short const   )27,      (short const   )0,      (short const   )0, 
        (short const   )19,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )17,      (short const   )15,      (short const   )16,      (short const   )11, 
        (short const   )10,      (short const   )11,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )9,      (short const   )9,      (short const   )9, 
        (short const   )0,      (short const   )18,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )9,      (short const   )9,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )22,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )9,      (short const   )9, 
        (short const   )9,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )20,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )9,      (short const   )6,      (short const   )9, 
        (short const   )9,      (short const   )0,      (short const   )0,      (short const   )25, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )21, 
        (short const   )0,      (short const   )6,      (short const   )0,      (short const   )0, 
        (short const   )9,      (short const   )7,      (short const   )0,      (short const   )26, 
        (short const   )0,      (short const   )23,      (short const   )0,      (short const   )0, 
        (short const   )7,      (short const   )0,      (short const   )24,      (short const   )0};
#line 310 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static int const   yy_ec[256]  = 
#line 310
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )1, 
        (int const   )4,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )5,      (int const   )1,      (int const   )6,      (int const   )7, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )8,      (int const   )8,      (int const   )9,      (int const   )1, 
        (int const   )8,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )14,      (int const   )14, 
        (int const   )14,      (int const   )14,      (int const   )14,      (int const   )14, 
        (int const   )14,      (int const   )14,      (int const   )11,      (int const   )8, 
        (int const   )15,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )16,      (int const   )16,      (int const   )16, 
        (int const   )16,      (int const   )16,      (int const   )16,      (int const   )16, 
        (int const   )16,      (int const   )16,      (int const   )16,      (int const   )16, 
        (int const   )16,      (int const   )16,      (int const   )16,      (int const   )16, 
        (int const   )16,      (int const   )16,      (int const   )16,      (int const   )16, 
        (int const   )16,      (int const   )16,      (int const   )16,      (int const   )16, 
        (int const   )16,      (int const   )16,      (int const   )16,      (int const   )1, 
        (int const   )17,      (int const   )1,      (int const   )1,      (int const   )16, 
        (int const   )1,      (int const   )16,      (int const   )16,      (int const   )16, 
        (int const   )16,      (int const   )18,      (int const   )16,      (int const   )16, 
        (int const   )16,      (int const   )19,      (int const   )16,      (int const   )16, 
        (int const   )20,      (int const   )16,      (int const   )21,      (int const   )16, 
        (int const   )16,      (int const   )16,      (int const   )16,      (int const   )16, 
        (int const   )16,      (int const   )16,      (int const   )16,      (int const   )16, 
        (int const   )16,      (int const   )16,      (int const   )16,      (int const   )8, 
        (int const   )1,      (int const   )8,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1};
#line 342 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static int const   yy_meta[22]  = 
#line 342
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )1,      (int const   )1,      (int const   )3,      (int const   )1, 
        (int const   )1,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )6,      (int const   )7,      (int const   )7,      (int const   )1, 
        (int const   )8,      (int const   )9,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8};
#line 349 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static short const   yy_base[163]  = 
#line 349
  {      (short const   )0,      (short const   )0,      (short const   )20,      (short const   )20, 
        (short const   )21,      (short const   )268,      (short const   )25,      (short const   )28, 
        (short const   )30,      (short const   )264,      (short const   )447,      (short const   )33, 
        (short const   )447,      (short const   )33,      (short const   )259,      (short const   )447, 
        (short const   )0,      (short const   )31,      (short const   )219,      (short const   )37, 
        (short const   )49,      (short const   )55,      (short const   )0,      (short const   )447, 
        (short const   )32,      (short const   )201,      (short const   )447,      (short const   )39, 
        (short const   )46,      (short const   )447,      (short const   )186,      (short const   )0, 
        (short const   )60,      (short const   )49,      (short const   )447,      (short const   )199, 
        (short const   )198,      (short const   )447,      (short const   )0,      (short const   )0, 
        (short const   )75,      (short const   )91,      (short const   )59,      (short const   )0, 
        (short const   )107,      (short const   )0,      (short const   )126,      (short const   )95, 
        (short const   )0,      (short const   )90,      (short const   )91,      (short const   )447, 
        (short const   )196,      (short const   )447,      (short const   )101,      (short const   )55, 
        (short const   )447,      (short const   )0,      (short const   )180,      (short const   )190, 
        (short const   )447,      (short const   )447,      (short const   )447,      (short const   )189, 
        (short const   )447,      (short const   )0,      (short const   )0,      (short const   )142, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )158, 
        (short const   )172,      (short const   )104,      (short const   )0,      (short const   )102, 
        (short const   )103,      (short const   )447,      (short const   )0,      (short const   )185, 
        (short const   )171,      (short const   )120,      (short const   )0,      (short const   )167, 
        (short const   )110,      (short const   )112,      (short const   )116,      (short const   )180, 
        (short const   )182,      (short const   )447,      (short const   )179,      (short const   )169, 
        (short const   )174,      (short const   )161,      (short const   )126,      (short const   )130, 
        (short const   )139,      (short const   )132,      (short const   )193,      (short const   )174, 
        (short const   )447,      (short const   )172,      (short const   )164,      (short const   )147, 
        (short const   )149,      (short const   )152,      (short const   )447,      (short const   )158, 
        (short const   )165,      (short const   )164,      (short const   )0,      (short const   )447, 
        (short const   )154,      (short const   )144,      (short const   )146,      (short const   )447, 
        (short const   )159,      (short const   )447,      (short const   )163,      (short const   )142, 
        (short const   )140,      (short const   )447,      (short const   )135,      (short const   )447, 
        (short const   )108,      (short const   )447,      (short const   )104,      (short const   )71, 
        (short const   )447,      (short const   )70,      (short const   )447,      (short const   )447, 
        (short const   )205,      (short const   )214,      (short const   )223,      (short const   )232, 
        (short const   )241,      (short const   )247,      (short const   )252,      (short const   )260, 
        (short const   )269,      (short const   )278,      (short const   )287,      (short const   )296, 
        (short const   )305,      (short const   )314,      (short const   )321,      (short const   )330, 
        (short const   )59,      (short const   )335,      (short const   )18,      (short const   )339, 
        (short const   )347,      (short const   )356,      (short const   )365,      (short const   )374, 
        (short const   )383,      (short const   )392,      (short const   )401,      (short const   )410, 
        (short const   )419,      (short const   )428,      (short const   )437};
#line 371 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static short const   yy_def[163]  = 
#line 371
  {      (short const   )0,      (short const   )131,      (short const   )1,      (short const   )132, 
        (short const   )132,      (short const   )133,      (short const   )133,      (short const   )134, 
        (short const   )134,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )135,      (short const   )136,      (short const   )131, 
        (short const   )137,      (short const   )137,      (short const   )131,      (short const   )138, 
        (short const   )131,      (short const   )136,      (short const   )139,      (short const   )131, 
        (short const   )140,      (short const   )141,      (short const   )131,      (short const   )141, 
        (short const   )142,      (short const   )131,      (short const   )143,      (short const   )144, 
        (short const   )131,      (short const   )135,      (short const   )131,      (short const   )145, 
        (short const   )136,      (short const   )131,      (short const   )137,      (short const   )137, 
        (short const   )131,      (short const   )146,      (short const   )138,      (short const   )20, 
        (short const   )131,      (short const   )21,      (short const   )21,      (short const   )136, 
        (short const   )139,      (short const   )140,      (short const   )140,      (short const   )131, 
        (short const   )141,      (short const   )131,      (short const   )141,      (short const   )142, 
        (short const   )131,      (short const   )144,      (short const   )143,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )147, 
        (short const   )131,      (short const   )40,      (short const   )148,      (short const   )146, 
        (short const   )149,      (short const   )150,      (short const   )44,      (short const   )131, 
        (short const   )131,      (short const   )46,      (short const   )46,      (short const   )136, 
        (short const   )141,      (short const   )131,      (short const   )151,      (short const   )67, 
        (short const   )149,      (short const   )131,      (short const   )71,      (short const   )131, 
        (short const   )152,      (short const   )136,      (short const   )141,      (short const   )151, 
        (short const   )131,      (short const   )131,      (short const   )153,      (short const   )131, 
        (short const   )154,      (short const   )131,      (short const   )152,      (short const   )155, 
        (short const   )136,      (short const   )141,      (short const   )131,      (short const   )153, 
        (short const   )131,      (short const   )156,      (short const   )154,      (short const   )157, 
        (short const   )131,      (short const   )155,      (short const   )131,      (short const   )155, 
        (short const   )158,      (short const   )159,      (short const   )98,      (short const   )131, 
        (short const   )160,      (short const   )131,      (short const   )156,      (short const   )131, 
        (short const   )157,      (short const   )131,      (short const   )157,      (short const   )161, 
        (short const   )158,      (short const   )131,      (short const   )159,      (short const   )131, 
        (short const   )160,      (short const   )131,      (short const   )162,      (short const   )161, 
        (short const   )131,      (short const   )162,      (short const   )131,      (short const   )0, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131};
#line 393 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static short const   yy_nxt[469]  = 
#line 393
  {      (short const   )0,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )11,      (short const   )11,      (short const   )13,      (short const   )14, 
        (short const   )15,      (short const   )16,      (short const   )16,      (short const   )16, 
        (short const   )17,      (short const   )16,      (short const   )16,      (short const   )18, 
        (short const   )19,      (short const   )10,      (short const   )19,      (short const   )19, 
        (short const   )19,      (short const   )19,      (short const   )20,      (short const   )23, 
        (short const   )23,      (short const   )20,      (short const   )68,      (short const   )21, 
        (short const   )26,      (short const   )24,      (short const   )24,      (short const   )29, 
        (short const   )27,      (short const   )29,      (short const   )30,      (short const   )32, 
        (short const   )30,      (short const   )32,      (short const   )32,      (short const   )34, 
        (short const   )39,      (short const   )50,      (short const   )53,      (short const   )40, 
        (short const   )51,      (short const   )31,      (short const   )38,      (short const   )31, 
        (short const   )38,      (short const   )38,      (short const   )35,      (short const   )43, 
        (short const   )56,      (short const   )32,      (short const   )43,      (short const   )34, 
        (short const   )44,      (short const   )45,      (short const   )37,      (short const   )54, 
        (short const   )45,      (short const   )56,      (short const   )32,      (short const   )57, 
        (short const   )32,      (short const   )32,      (short const   )35,      (short const   )78, 
        (short const   )38,      (short const   )46,      (short const   )38,      (short const   )38, 
        (short const   )57,      (short const   )130,      (short const   )128,      (short const   )47, 
        (short const   )63,      (short const   )63,      (short const   )64,      (short const   )63, 
        (short const   )63,      (short const   )63,      (short const   )63,      (short const   )63, 
        (short const   )65,      (short const   )65,      (short const   )65,      (short const   )65, 
        (short const   )65,      (short const   )65,      (short const   )63,      (short const   )65, 
        (short const   )63,      (short const   )65,      (short const   )65,      (short const   )65, 
        (short const   )65,      (short const   )66,      (short const   )37,      (short const   )131, 
        (short const   )50,      (short const   )67,      (short const   )131,      (short const   )51, 
        (short const   )53,      (short const   )37,      (short const   )53,      (short const   )130, 
        (short const   )69,      (short const   )70,      (short const   )84,      (short const   )125, 
        (short const   )70,      (short const   )37,      (short const   )75,      (short const   )37, 
        (short const   )95,      (short const   )36,      (short const   )36,      (short const   )53, 
        (short const   )76,      (short const   )71,      (short const   )81,      (short const   )85, 
        (short const   )86,      (short const   )81,      (short const   )92,      (short const   )72, 
        (short const   )73,      (short const   )37,      (short const   )96,      (short const   )73, 
        (short const   )95,      (short const   )106,      (short const   )97,      (short const   )53, 
        (short const   )107,      (short const   )109,      (short const   )123,      (short const   )74, 
        (short const   )74,      (short const   )108,      (short const   )37,      (short const   )121, 
        (short const   )108,      (short const   )128,      (short const   )36,      (short const   )79, 
        (short const   )66,      (short const   )115,      (short const   )117,      (short const   )119, 
        (short const   )131,      (short const   )118,      (short const   )119,      (short const   )106, 
        (short const   )126,      (short const   )125,      (short const   )107,      (short const   )69, 
        (short const   )81,      (short const   )106,      (short const   )117,      (short const   )81, 
        (short const   )107,      (short const   )118,      (short const   )117,      (short const   )123, 
        (short const   )121,      (short const   )118,      (short const   )103,      (short const   )82, 
        (short const   )82,      (short const   )88,      (short const   )89,      (short const   )115, 
        (short const   )88,      (short const   )100,      (short const   )90,      (short const   )104, 
        (short const   )103,      (short const   )101,      (short const   )100,      (short const   )91, 
        (short const   )88,      (short const   )89,      (short const   )98,      (short const   )88, 
        (short const   )93,      (short const   )90,      (short const   )131,      (short const   )83, 
        (short const   )64,      (short const   )77,      (short const   )91,      (short const   )110, 
        (short const   )111,      (short const   )59,      (short const   )110,      (short const   )53, 
        (short const   )112,      (short const   )37,      (short const   )62,      (short const   )59, 
        (short const   )53,      (short const   )113,      (short const   )22,      (short const   )22, 
        (short const   )22,      (short const   )22,      (short const   )22,      (short const   )22, 
        (short const   )22,      (short const   )22,      (short const   )22,      (short const   )25, 
        (short const   )25,      (short const   )25,      (short const   )25,      (short const   )25, 
        (short const   )25,      (short const   )25,      (short const   )25,      (short const   )25, 
        (short const   )28,      (short const   )28,      (short const   )28,      (short const   )28, 
        (short const   )28,      (short const   )28,      (short const   )28,      (short const   )28, 
        (short const   )28,      (short const   )33,      (short const   )41,      (short const   )33, 
        (short const   )33,      (short const   )33,      (short const   )33,      (short const   )33, 
        (short const   )33,      (short const   )33,      (short const   )36,      (short const   )36, 
        (short const   )36,      (short const   )36,      (short const   )36,      (short const   )36, 
        (short const   )36,      (short const   )36,      (short const   )36,      (short const   )38, 
        (short const   )38,      (short const   )38,      (short const   )38,      (short const   )38, 
        (short const   )42,      (short const   )42,      (short const   )42,      (short const   )42, 
        (short const   )42,      (short const   )48,      (short const   )37,      (short const   )48, 
        (short const   )131,      (short const   )48,      (short const   )48,      (short const   )48, 
        (short const   )48,      (short const   )48,      (short const   )49,      (short const   )26, 
        (short const   )49,      (short const   )49,      (short const   )49,      (short const   )49, 
        (short const   )49,      (short const   )49,      (short const   )49,      (short const   )52, 
        (short const   )52,      (short const   )52,      (short const   )52,      (short const   )52, 
        (short const   )52,      (short const   )52,      (short const   )52,      (short const   )52, 
        (short const   )55,      (short const   )131,      (short const   )55,      (short const   )55, 
        (short const   )55,      (short const   )55,      (short const   )55,      (short const   )55, 
        (short const   )55,      (short const   )58,      (short const   )131,      (short const   )131, 
        (short const   )58,      (short const   )58,      (short const   )58,      (short const   )58, 
        (short const   )58,      (short const   )58,      (short const   )60,      (short const   )131, 
        (short const   )60,      (short const   )60,      (short const   )60,      (short const   )60, 
        (short const   )60,      (short const   )60,      (short const   )60,      (short const   )61, 
        (short const   )61,      (short const   )61,      (short const   )61,      (short const   )61, 
        (short const   )61,      (short const   )61,      (short const   )61,      (short const   )61, 
        (short const   )68,      (short const   )131,      (short const   )68,      (short const   )131, 
        (short const   )131,      (short const   )68,      (short const   )68,      (short const   )63, 
        (short const   )63,      (short const   )63,      (short const   )63,      (short const   )63, 
        (short const   )63,      (short const   )63,      (short const   )63,      (short const   )63, 
        (short const   )80,      (short const   )131,      (short const   )80,      (short const   )80, 
        (short const   )87,      (short const   )131,      (short const   )87,      (short const   )87, 
        (short const   )94,      (short const   )94,      (short const   )94,      (short const   )94, 
        (short const   )94,      (short const   )94,      (short const   )94,      (short const   )94, 
        (short const   )94,      (short const   )99,      (short const   )99,      (short const   )99, 
        (short const   )99,      (short const   )99,      (short const   )99,      (short const   )99, 
        (short const   )99,      (short const   )99,      (short const   )102,      (short const   )131, 
        (short const   )102,      (short const   )102,      (short const   )102,      (short const   )102, 
        (short const   )102,      (short const   )102,      (short const   )102,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )105,      (short const   )105,      (short const   )105,      (short const   )105, 
        (short const   )114,      (short const   )114,      (short const   )114,      (short const   )114, 
        (short const   )114,      (short const   )114,      (short const   )114,      (short const   )114, 
        (short const   )114,      (short const   )116,      (short const   )116,      (short const   )116, 
        (short const   )116,      (short const   )116,      (short const   )116,      (short const   )116, 
        (short const   )116,      (short const   )116,      (short const   )120,      (short const   )120, 
        (short const   )120,      (short const   )120,      (short const   )120,      (short const   )120, 
        (short const   )120,      (short const   )120,      (short const   )120,      (short const   )122, 
        (short const   )122,      (short const   )122,      (short const   )122,      (short const   )122, 
        (short const   )122,      (short const   )122,      (short const   )122,      (short const   )122, 
        (short const   )124,      (short const   )124,      (short const   )124,      (short const   )124, 
        (short const   )124,      (short const   )124,      (short const   )124,      (short const   )124, 
        (short const   )124,      (short const   )127,      (short const   )127,      (short const   )127, 
        (short const   )127,      (short const   )127,      (short const   )127,      (short const   )127, 
        (short const   )127,      (short const   )127,      (short const   )129,      (short const   )129, 
        (short const   )129,      (short const   )129,      (short const   )129,      (short const   )129, 
        (short const   )129,      (short const   )129,      (short const   )129,      (short const   )9, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131};
#line 448 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static short const   yy_chk[469]  = 
#line 448
  {      (short const   )0,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )2,      (short const   )3, 
        (short const   )4,      (short const   )2,      (short const   )150,      (short const   )2, 
        (short const   )6,      (short const   )3,      (short const   )4,      (short const   )7, 
        (short const   )6,      (short const   )8,      (short const   )7,      (short const   )11, 
        (short const   )8,      (short const   )11,      (short const   )11,      (short const   )13, 
        (short const   )17,      (short const   )24,      (short const   )27,      (short const   )17, 
        (short const   )24,      (short const   )7,      (short const   )19,      (short const   )8, 
        (short const   )19,      (short const   )19,      (short const   )13,      (short const   )20, 
        (short const   )28,      (short const   )20,      (short const   )20,      (short const   )33, 
        (short const   )20,      (short const   )21,      (short const   )21,      (short const   )27, 
        (short const   )21,      (short const   )55,      (short const   )32,      (short const   )28, 
        (short const   )32,      (short const   )32,      (short const   )33,      (short const   )148, 
        (short const   )42,      (short const   )21,      (short const   )42,      (short const   )42, 
        (short const   )55,      (short const   )129,      (short const   )127,      (short const   )21, 
        (short const   )40,      (short const   )40,      (short const   )40,      (short const   )40, 
        (short const   )40,      (short const   )40,      (short const   )40,      (short const   )40, 
        (short const   )40,      (short const   )40,      (short const   )40,      (short const   )40, 
        (short const   )40,      (short const   )40,      (short const   )40,      (short const   )40, 
        (short const   )40,      (short const   )40,      (short const   )40,      (short const   )40, 
        (short const   )40,      (short const   )41,      (short const   )47,      (short const   )49, 
        (short const   )50,      (short const   )41,      (short const   )49,      (short const   )50, 
        (short const   )54,      (short const   )75,      (short const   )76,      (short const   )126, 
        (short const   )41,      (short const   )44,      (short const   )73,      (short const   )124, 
        (short const   )44,      (short const   )84,      (short const   )47,      (short const   )85, 
        (short const   )84,      (short const   )73,      (short const   )73,      (short const   )86, 
        (short const   )54,      (short const   )44,      (short const   )81,      (short const   )75, 
        (short const   )76,      (short const   )81,      (short const   )81,      (short const   )44, 
        (short const   )46,      (short const   )94,      (short const   )85,      (short const   )46, 
        (short const   )94,      (short const   )95,      (short const   )86,      (short const   )97, 
        (short const   )95,      (short const   )97,      (short const   )122,      (short const   )46, 
        (short const   )46,      (short const   )96,      (short const   )96,      (short const   )120, 
        (short const   )96,      (short const   )119,      (short const   )46,      (short const   )67, 
        (short const   )67,      (short const   )114,      (short const   )103,      (short const   )104, 
        (short const   )67,      (short const   )103,      (short const   )104,      (short const   )105, 
        (short const   )113,      (short const   )112,      (short const   )105,      (short const   )67, 
        (short const   )71,      (short const   )107,      (short const   )116,      (short const   )71, 
        (short const   )107,      (short const   )116,      (short const   )118,      (short const   )109, 
        (short const   )108,      (short const   )118,      (short const   )102,      (short const   )71, 
        (short const   )71,      (short const   )80,      (short const   )80,      (short const   )101, 
        (short const   )80,      (short const   )99,      (short const   )80,      (short const   )93, 
        (short const   )92,      (short const   )91,      (short const   )90,      (short const   )80, 
        (short const   )88,      (short const   )88,      (short const   )87,      (short const   )88, 
        (short const   )83,      (short const   )88,      (short const   )79,      (short const   )72, 
        (short const   )63,      (short const   )59,      (short const   )88,      (short const   )98, 
        (short const   )98,      (short const   )58,      (short const   )98,      (short const   )52, 
        (short const   )98,      (short const   )36,      (short const   )35,      (short const   )30, 
        (short const   )25,      (short const   )98,      (short const   )132,      (short const   )132, 
        (short const   )132,      (short const   )132,      (short const   )132,      (short const   )132, 
        (short const   )132,      (short const   )132,      (short const   )132,      (short const   )133, 
        (short const   )133,      (short const   )133,      (short const   )133,      (short const   )133, 
        (short const   )133,      (short const   )133,      (short const   )133,      (short const   )133, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )134,      (short const   )134,      (short const   )134, 
        (short const   )134,      (short const   )135,      (short const   )18,      (short const   )135, 
        (short const   )135,      (short const   )135,      (short const   )135,      (short const   )135, 
        (short const   )135,      (short const   )135,      (short const   )136,      (short const   )136, 
        (short const   )136,      (short const   )136,      (short const   )136,      (short const   )136, 
        (short const   )136,      (short const   )136,      (short const   )136,      (short const   )137, 
        (short const   )137,      (short const   )137,      (short const   )137,      (short const   )137, 
        (short const   )138,      (short const   )138,      (short const   )138,      (short const   )138, 
        (short const   )138,      (short const   )139,      (short const   )14,      (short const   )139, 
        (short const   )9,      (short const   )139,      (short const   )139,      (short const   )139, 
        (short const   )139,      (short const   )139,      (short const   )140,      (short const   )5, 
        (short const   )140,      (short const   )140,      (short const   )140,      (short const   )140, 
        (short const   )140,      (short const   )140,      (short const   )140,      (short const   )141, 
        (short const   )141,      (short const   )141,      (short const   )141,      (short const   )141, 
        (short const   )141,      (short const   )141,      (short const   )141,      (short const   )141, 
        (short const   )142,      (short const   )0,      (short const   )142,      (short const   )142, 
        (short const   )142,      (short const   )142,      (short const   )142,      (short const   )142, 
        (short const   )142,      (short const   )143,      (short const   )0,      (short const   )0, 
        (short const   )143,      (short const   )143,      (short const   )143,      (short const   )143, 
        (short const   )143,      (short const   )143,      (short const   )144,      (short const   )0, 
        (short const   )144,      (short const   )144,      (short const   )144,      (short const   )144, 
        (short const   )144,      (short const   )144,      (short const   )144,      (short const   )145, 
        (short const   )145,      (short const   )145,      (short const   )145,      (short const   )145, 
        (short const   )145,      (short const   )145,      (short const   )145,      (short const   )145, 
        (short const   )146,      (short const   )0,      (short const   )146,      (short const   )0, 
        (short const   )0,      (short const   )146,      (short const   )146,      (short const   )147, 
        (short const   )147,      (short const   )147,      (short const   )147,      (short const   )147, 
        (short const   )147,      (short const   )147,      (short const   )147,      (short const   )147, 
        (short const   )149,      (short const   )0,      (short const   )149,      (short const   )149, 
        (short const   )151,      (short const   )0,      (short const   )151,      (short const   )151, 
        (short const   )152,      (short const   )152,      (short const   )152,      (short const   )152, 
        (short const   )152,      (short const   )152,      (short const   )152,      (short const   )152, 
        (short const   )152,      (short const   )153,      (short const   )153,      (short const   )153, 
        (short const   )153,      (short const   )153,      (short const   )153,      (short const   )153, 
        (short const   )153,      (short const   )153,      (short const   )154,      (short const   )0, 
        (short const   )154,      (short const   )154,      (short const   )154,      (short const   )154, 
        (short const   )154,      (short const   )154,      (short const   )154,      (short const   )155, 
        (short const   )155,      (short const   )155,      (short const   )155,      (short const   )155, 
        (short const   )155,      (short const   )155,      (short const   )155,      (short const   )155, 
        (short const   )156,      (short const   )156,      (short const   )156,      (short const   )156, 
        (short const   )156,      (short const   )156,      (short const   )156,      (short const   )156, 
        (short const   )156,      (short const   )157,      (short const   )157,      (short const   )157, 
        (short const   )157,      (short const   )157,      (short const   )157,      (short const   )157, 
        (short const   )157,      (short const   )157,      (short const   )158,      (short const   )158, 
        (short const   )158,      (short const   )158,      (short const   )158,      (short const   )158, 
        (short const   )158,      (short const   )158,      (short const   )158,      (short const   )159, 
        (short const   )159,      (short const   )159,      (short const   )159,      (short const   )159, 
        (short const   )159,      (short const   )159,      (short const   )159,      (short const   )159, 
        (short const   )160,      (short const   )160,      (short const   )160,      (short const   )160, 
        (short const   )160,      (short const   )160,      (short const   )160,      (short const   )160, 
        (short const   )160,      (short const   )161,      (short const   )161,      (short const   )161, 
        (short const   )161,      (short const   )161,      (short const   )161,      (short const   )161, 
        (short const   )161,      (short const   )161,      (short const   )162,      (short const   )162, 
        (short const   )162,      (short const   )162,      (short const   )162,      (short const   )162, 
        (short const   )162,      (short const   )162,      (short const   )162,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131,      (short const   )131,      (short const   )131,      (short const   )131, 
        (short const   )131};
#line 503 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static yy_state_type yy_last_accepting_state  ;
#line 504 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static char *yy_last_accepting_cpos  ;
#line 507 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
int yy_flex_debug  =    1;
#line 509 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-lex.c"
static short const   yy_rule_linenum[32]  = 
#line 509
  {      (short const   )0,      (short const   )73,      (short const   )74,      (short const   )75, 
        (short const   )76,      (short const   )77,      (short const   )79,      (short const   )80, 
        (short const   )82,      (short const   )83,      (short const   )84,      (short const   )85, 
        (short const   )87,      (short const   )89,      (short const   )94,      (short const   )98, 
        (short const   )99,      (short const   )102,      (short const   )103,      (short const   )104, 
        (short const   )110,      (short const   )111,      (short const   )112,      (short const   )113, 
        (short const   )114,      (short const   )115,      (short const   )118,      (short const   )119, 
        (short const   )132,      (short const   )134,      (short const   )135,      (short const   )136};
#line 134 "./dicod.h"
dicod_locus_t locus  ;
#line 208
config_value_t *config_value_dup(config_value_t *input___0 ) ;
#line 216
int yylex(void) ;
#line 221
void ( /* format attribute */  config_warning)(dicod_locus_t *locus___0 , int errcode ,
                                               char const   *fmt  , ...) ;
#line 223
int config_lex_begin(char const   *name ) ;
#line 224
void config_lex_end(void) ;
#line 229
void line_begin(void) ;
#line 230
void line_add(char *text , size_t len ) ;
#line 231
void line_add_unescape_last(char *text , size_t len ) ;
#line 232
void line_finish(void) ;
#line 233
char *line_finish0(void) ;
#line 74 "config-gram.h"
YYSTYPE yylval ;
#line 26 "config-lex.l"
static char *multiline_delimiter  ;
#line 27 "config-lex.l"
static size_t multiline_delimiter_len  ;
#line 28 "config-lex.l"
static int multiline_unescape  ;
#line 29 "config-lex.l"
static int (*char_to_strip)(char  )  ;
#line 40 "config-lex.l"
size_t xlines  ;
#line 41 "config-lex.l"
static struct obstack stk  ;
#line 43
static void multiline_begin(char *p ) ;
#line 44
static void multiline_add(char *s ) ;
#line 45
static void multiline_finish(void) ;
#line 46
static char *multiline_strip_tabs(char *text ) ;
#line 47
static int ident(void) ;
#line 48
static int isemptystr(int off ) ;
#line 50
static void parse_line(char *text , dicod_locus_t *ploc , size_t *pxlines ) ;
#line 51
static void parse_line_cpp(char *text , dicod_locus_t *ploc , size_t *pxlines ) ;
#line 602 "config-lex.c"
int yywrap(void) ;
#line 740 "config-lex.c"
int yylex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  register YY_CHAR yy_c ;
  int tmp ;
  char *p ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 743
  yy_cp = (char *)((void *)0);
#line 743
  yy_bp = (char *)((void *)0);
#line 751
  if (yy_init) {
#line 753
    yy_init = 0;
#line 759
    if (! yy_start) {
#line 760
      yy_start = 1;
    }
#line 762
    if (! yyin) {
#line 763
      yyin = stdin;
    }
#line 765
    if (! yyout) {
#line 766
      yyout = stdout;
    }
#line 768
    if (! yy_current_buffer) {
      {
#line 769
      yy_current_buffer = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 772
    yy_load_buffer_state();
    }
  }
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    yy_cp = yy_c_buf_p;
#line 780
    *yy_cp = yy_hold_char;
#line 785
    yy_bp = yy_cp;
#line 787
    yy_current_state = yy_start;
#line 788
    yy_current_state += yy_current_buffer->yy_at_bol;
    yy_match: 
    {
#line 790
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 792
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 793
      if (yy_accept[yy_current_state]) {
#line 795
        yy_last_accepting_state = yy_current_state;
#line 796
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 798
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 798
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 798
          goto while_break___1;
        }
#line 800
        yy_current_state = (int )yy_def[yy_current_state];
#line 801
        if (yy_current_state >= 132) {
#line 802
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 804
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 805
      yy_cp ++;
#line 790
      if (! ((int const   )yy_base[yy_current_state] != 447)) {
#line 790
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 810
    yy_act = (int )yy_accept[yy_current_state];
#line 811
    if (yy_act == 0) {
#line 813
      yy_cp = yy_last_accepting_cpos;
#line 814
      yy_current_state = yy_last_accepting_state;
#line 815
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 818
    yytext = yy_bp;
#line 818
    yyleng = (int )(yy_cp - yy_bp);
#line 818
    yy_hold_char = *yy_cp;
#line 818
    *yy_cp = (char )'\000';
#line 818
    yy_c_buf_p = yy_cp;
    do_action: 
#line 823
    if (yy_flex_debug) {
#line 825
      if (yy_act == 0) {
        {
#line 826
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--scanner backing up\n");
        }
      } else
#line 827
      if (yy_act < 32) {
        {
#line 828
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting rule at line %d (\"%s\")\n",
                (int const   )yy_rule_linenum[yy_act], yytext);
        }
      } else
#line 830
      if (yy_act == 32) {
        {
#line 831
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting default rule (\"%s\")\n",
                yytext);
        }
      } else
#line 833
      if (yy_act == 33) {
        {
#line 834
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--(end of buffer or a NUL)\n");
        }
      } else {
        {
#line 836
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--EOF (start condition %d)\n",
                (yy_start - 1) / 2);
        }
      }
    }
    {
#line 841
    if (yy_act == 0) {
#line 841
      goto case_0;
    }
#line 848
    if (yy_act == 1) {
#line 848
      goto case_1;
    }
#line 75
    if (yy_act == 2) {
#line 75 "config-lex.l"
      goto case_2;
    }
#line 76
    if (yy_act == 3) {
#line 76
      goto case_3;
    }
#line 77
    if (yy_act == 4) {
#line 77
      goto case_4;
    }
#line 78
    if (yy_act == 5) {
#line 78
      goto case_5;
    }
#line 80
    if (yy_act == 6) {
#line 80
      goto case_6;
    }
#line 81
    if (yy_act == 7) {
#line 81
      goto case_7;
    }
#line 83
    if (yy_act == 8) {
#line 83
      goto case_8;
    }
#line 84
    if (yy_act == 9) {
#line 84
      goto case_9;
    }
#line 85
    if (yy_act == 10) {
#line 85
      goto case_10;
    }
#line 86
    if (yy_act == 11) {
#line 86
      goto case_11;
    }
#line 88
    if (yy_act == 12) {
#line 88
      goto case_12;
    }
#line 90
    if (yy_act == 13) {
#line 90
      goto case_13;
    }
#line 95
    if (yy_act == 14) {
#line 95
      goto case_14;
    }
#line 99
    if (yy_act == 16) {
#line 99
      goto case_16;
    }
#line 99
    if (yy_act == 15) {
#line 99
      goto case_16;
    }
#line 103
    if (yy_act == 18) {
#line 103
      goto case_18;
    }
#line 103
    if (yy_act == 17) {
#line 103
      goto case_18;
    }
#line 105
    if (yy_act == 19) {
#line 105
      goto case_19;
    }
#line 115
    if (yy_act == 25) {
#line 115
      goto case_25;
    }
#line 115
    if (yy_act == 24) {
#line 115
      goto case_25;
    }
#line 115
    if (yy_act == 23) {
#line 115
      goto case_25;
    }
#line 115
    if (yy_act == 22) {
#line 115
      goto case_25;
    }
#line 115
    if (yy_act == 21) {
#line 115
      goto case_25;
    }
#line 115
    if (yy_act == 20) {
#line 115
      goto case_25;
    }
#line 119
    if (yy_act == 26) {
#line 119
      goto case_26;
    }
#line 120
    if (yy_act == 27) {
#line 120
      goto case_27;
    }
#line 133
    if (yy_act == 28) {
#line 133
      goto case_28;
    }
#line 135
    if (yy_act == 29) {
#line 135
      goto case_29;
    }
#line 136
    if (yy_act == 30) {
#line 136
      goto case_30;
    }
#line 137
    if (yy_act == 31) {
#line 137
      goto case_31;
    }
#line 142
    if (yy_act == 32) {
#line 142
      goto case_32;
    }
#line 1028
    if (yy_act == 37) {
#line 1028 "config-lex.c"
      goto case_37;
    }
#line 1028
    if (yy_act == 36) {
#line 1028
      goto case_37;
    }
#line 1028
    if (yy_act == 35) {
#line 1028
      goto case_37;
    }
#line 1028
    if (yy_act == 34) {
#line 1028
      goto case_37;
    }
#line 1031
    if (yy_act == 33) {
#line 1031
      goto case_33;
    }
#line 1153
    goto switch_default;
    case_0: /* CIL Label */ 
#line 843
    *yy_cp = yy_hold_char;
#line 844
    yy_cp = yy_last_accepting_cpos;
#line 845
    yy_current_state = yy_last_accepting_state;
#line 846
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 849
    if (yyleng > 0) {
#line 849
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 73 "config-lex.l"
    yy_start = 3;
#line 74
    goto switch_break;
    case_2: /* CIL Label */ 
#line 76
    if (yyleng > 0) {
#line 76
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 75
    goto switch_break;
    case_3: /* CIL Label */ 
#line 77
    if (yyleng > 0) {
#line 77
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 76
    goto switch_break;
    case_4: /* CIL Label */ 
#line 78
    if (yyleng > 0) {
#line 78
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 76
    (locus.line) ++;
#line 77
    goto switch_break;
    case_5: /* CIL Label */ 
#line 79
    if (yyleng > 0) {
#line 79
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 77
    yy_start = 1;
#line 78
    goto switch_break;
    case_6: /* CIL Label */ 
#line 81
    if (yyleng > 0) {
#line 81
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 79
    parse_line_cpp(yytext, & locus, & xlines);
    }
#line 80
    goto switch_break;
    case_7: /* CIL Label */ 
#line 82
    if (yyleng > 0) {
#line 82
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 80
    parse_line(yytext, & locus, & xlines);
    }
#line 81
    goto switch_break;
    case_8: /* CIL Label */ 
#line 84
    if (yyleng > 0) {
#line 84
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 82
    (locus.line) ++;
#line 83
    goto switch_break;
    case_9: /* CIL Label */ 
#line 85
    if (yyleng > 0) {
#line 85
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 84
    goto switch_break;
    case_10: /* CIL Label */ 
#line 86
    if (yyleng > 0) {
#line 86
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 84
    (locus.line) ++;
#line 85
    goto switch_break;
    case_11: /* CIL Label */ 
#line 87
    if (yyleng > 0) {
#line 87
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 86
    goto switch_break;
    case_12: /* CIL Label */ 
#line 89
    if (yyleng > 0) {
#line 89
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 87
    tmp = ident();
    }
#line 87
    return (tmp);
#line 88
    goto switch_break;
    case_13: /* CIL Label */ 
#line 91
    if (yyleng > 0) {
#line 91
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 89
    line_begin();
#line 90
    line_add(yytext, (size_t )yyleng);
#line 91
    line_finish();
    }
#line 92
    return (259);
#line 93
    goto switch_break;
    case_14: /* CIL Label */ 
#line 96
    if (yyleng > 0) {
#line 96
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 94
    line_begin();
#line 95
    line_add(yytext + 1, (size_t )(yyleng - 2));
#line 96
    line_finish();
    }
#line 97
    return (260);
#line 98
    goto switch_break;
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
#line 100
    if (yyleng > 0) {
#line 100
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 99
    yy_start = 7;
#line 100
    line_begin();
#line 101
    line_add_unescape_last(yytext + 1, (size_t )(yyleng - 1));
    }
#line 102
    goto switch_break;
    case_18: /* CIL Label */ 
    case_17: /* CIL Label */ 
#line 104
    if (yyleng > 0) {
#line 104
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 103
    line_add_unescape_last(yytext, (size_t )yyleng);
    }
#line 104
    goto switch_break;
    case_19: /* CIL Label */ 
#line 106
    if (yyleng > 0) {
#line 106
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 104
    yy_start = 1;
#line 105
    if (yyleng > 1) {
      {
#line 106
      line_add(yytext, (size_t )(yyleng - 1));
      }
    }
    {
#line 107
    line_finish();
    }
#line 108
    return (260);
#line 109
    goto switch_break;
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_20: /* CIL Label */ 
#line 116
    if (yyleng > 0) {
#line 116
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 116
    yy_start = 5;
#line 116
    multiline_begin(yytext + 2);
#line 116
    (locus.line) ++;
    }
#line 117
    goto switch_break;
    case_26: /* CIL Label */ 
#line 120
    if (yyleng > 0) {
#line 120
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 118
    (locus.line) ++;
#line 119
    goto switch_break;
    case_27: /* CIL Label */ 
#line 121
    if (yyleng > 0) {
#line 121
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 119
    tmp___0 = multiline_strip_tabs(yytext);
#line 119
    p = tmp___0;
#line 121
    tmp___1 = strncmp((char const   *)p, (char const   *)multiline_delimiter, multiline_delimiter_len);
    }
#line 121
    if (! tmp___1) {
      {
#line 121
      tmp___2 = isemptystr((int )((p + multiline_delimiter_len) - yytext));
      }
#line 121
      if (tmp___2) {
        {
#line 124
        free((void *)multiline_delimiter);
#line 125
        multiline_delimiter = (char *)((void *)0);
#line 126
        yy_start = 1;
#line 127
        multiline_finish();
        }
#line 128
        return (261);
      }
    }
    {
#line 130
    (locus.line) ++;
#line 131
    multiline_add(p);
    }
#line 132
    goto switch_break;
    case_28: /* CIL Label */ 
#line 134
    if (yyleng > 0) {
#line 134
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 133
    goto switch_break;
    case_29: /* CIL Label */ 
#line 136
    if (yyleng > 0) {
#line 136
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 134
    (locus.line) ++;
#line 135
    goto switch_break;
    case_30: /* CIL Label */ 
#line 137
    if (yyleng > 0) {
#line 137
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 135
    return ((int )*(yytext + 0));
#line 136
    goto switch_break;
    case_31: /* CIL Label */ 
#line 138
    if (yyleng > 0) {
#line 138
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
#line 136
    if (((int )*(yytext + 0) & -128) == 0) {
      {
#line 136
      tmp___5 = __ctype_b_loc();
      }
#line 136
      if ((int const   )*(*tmp___5 + (int )*(yytext + 0)) & 16384) {
        {
#line 137
        tmp___3 = gettext("stray character %c");
#line 137
        config_error(& locus, 0, (char const   *)tmp___3, (int )*(yytext + 0));
        }
      } else {
        {
#line 139
        tmp___4 = gettext("stray character \\%03o");
#line 139
        config_error(& locus, 0, (char const   *)tmp___4, (int )((unsigned char )*(yytext + 0)));
        }
      }
    } else {
      {
#line 139
      tmp___4 = gettext("stray character \\%03o");
#line 139
      config_error(& locus, 0, (char const   *)tmp___4, (int )((unsigned char )*(yytext + 0)));
      }
    }
#line 141
    goto switch_break;
    case_32: /* CIL Label */ 
#line 143
    if (yyleng > 0) {
#line 143
      yy_current_buffer->yy_at_bol = (int )*(yytext + (yyleng - 1)) == 10;
    }
    {
#line 141
    fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1, (FILE */* __restrict  */)yyout);
    }
#line 142
    goto switch_break;
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
#line 1029 "config-lex.c"
    return (0);
    case_33: /* CIL Label */ 
#line 1034
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 1037
    *yy_cp = yy_hold_char;
#line 1040
    if (yy_current_buffer->yy_buffer_status == 0) {
#line 1051
      yy_n_chars = yy_current_buffer->yy_n_chars;
#line 1052
      yy_current_buffer->yy_input_file = yyin;
#line 1053
      yy_current_buffer->yy_buffer_status = 1;
    }
#line 1063
    if ((unsigned long )yy_c_buf_p <= (unsigned long )(yy_current_buffer->yy_ch_buf + yy_n_chars)) {
      {
#line 1067
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1069
      yy_current_state = yy_get_previous_state();
#line 1080
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1082
      yy_bp = yytext + 0;
      }
#line 1084
      if (yy_next_state) {
#line 1087
        yy_c_buf_p ++;
#line 1087
        yy_cp = yy_c_buf_p;
#line 1088
        yy_current_state = yy_next_state;
#line 1089
        goto yy_match;
      } else {
#line 1094
        yy_cp = yy_c_buf_p;
#line 1095
        goto yy_find_action;
      }
    } else {
      {
#line 1099
      tmp___6 = yy_get_next_buffer();
      }
      {
#line 1101
      if (tmp___6 == 1) {
#line 1101
        goto case_1___0;
      }
#line 1130
      if (tmp___6 == 0) {
#line 1130
        goto case_0___0;
      }
#line 1140
      if (tmp___6 == 2) {
#line 1140
        goto case_2___0;
      }
#line 1099
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1103
      yy_did_buffer_switch_on_eof = 0;
#line 1105
      tmp___7 = yywrap();
      }
#line 1105
      if (tmp___7) {
#line 1116
        yy_c_buf_p = yytext + 0;
#line 1118
        yy_act = (33 + (yy_start - 1) / 2) + 1;
#line 1119
        goto do_action;
      } else
#line 1124
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1125
        yyrestart(yyin);
        }
      }
#line 1127
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1131
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1134
      yy_current_state = yy_get_previous_state();
#line 1136
      yy_cp = yy_c_buf_p;
#line 1137
      yy_bp = yytext + 0;
      }
#line 1138
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1141
      yy_c_buf_p = yy_current_buffer->yy_ch_buf + yy_n_chars;
#line 1144
      yy_current_state = yy_get_previous_state();
#line 1146
      yy_cp = yy_c_buf_p;
#line 1147
      yy_bp = yytext + 0;
      }
#line 1148
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1150
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1154
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1169 "config-lex.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1171
  dest = yy_current_buffer->yy_ch_buf;
#line 1172
  source = yytext;
#line 1176
  if ((unsigned long )yy_c_buf_p > (unsigned long )(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1177
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1180
  if (yy_current_buffer->yy_fill_buffer == 0) {
#line 1182
    if (yy_c_buf_p - yytext == 1L) {
#line 1187
      return (1);
    } else {
#line 1195
      return (2);
    }
  }
#line 1202
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1204
  i = 0;
  {
#line 1204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1204
    if (! (i < number_to_move)) {
#line 1204
      goto while_break;
    }
#line 1205
    tmp = dest;
#line 1205
    dest ++;
#line 1205
    tmp___0 = source;
#line 1205
    source ++;
#line 1205
    *tmp = *tmp___0;
#line 1204
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1207
  if (yy_current_buffer->yy_buffer_status == 2) {
#line 1211
    yy_n_chars = 0;
#line 1211
    yy_current_buffer->yy_n_chars = yy_n_chars;
  } else {
#line 1215
    num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1218
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1218
      if (! (num_to_read <= 0)) {
#line 1218
        goto while_break___0;
      }
#line 1226
      b = yy_current_buffer;
#line 1228
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1231
      if (b->yy_is_our_buffer) {
#line 1233
        new_size = (int )(b->yy_buf_size * 2U);
#line 1235
        if (new_size <= 0) {
#line 1236
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1238
          b->yy_buf_size *= 2U;
        }
        {
#line 1240
        tmp___1 = yy_flex_realloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 1240
        b->yy_ch_buf = (char *)tmp___1;
        }
      } else {
#line 1247
        b->yy_ch_buf = (char *)0;
      }
#line 1249
      if (! b->yy_ch_buf) {
        {
#line 1250
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1253
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1255
      num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1260
    if (num_to_read > 8192) {
#line 1261
      num_to_read = 8192;
    }
    {
#line 1264
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1264
      if (preprocessor) {
        {
#line 1264
        tmp___2 = fread((void */* __restrict  */)(yy_current_buffer->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 1264
        yy_n_chars = (int )tmp___2;
        }
      } else {
        {
#line 1264
        tmp___3 = pp_fill_buffer(yy_current_buffer->yy_ch_buf + number_to_move, (size_t )num_to_read);
#line 1264
        yy_n_chars = (int )tmp___3;
        }
      }
#line 1264
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1267
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
#line 1270
  if (yy_n_chars == 0) {
#line 1272
    if (number_to_move == 0) {
      {
#line 1274
      ret_val = 1;
#line 1275
      yyrestart(yyin);
      }
    } else {
#line 1280
      ret_val = 2;
#line 1281
      yy_current_buffer->yy_buffer_status = 2;
    }
  } else {
#line 1287
    ret_val = 0;
  }
#line 1289
  yy_n_chars += number_to_move;
#line 1290
  *(yy_current_buffer->yy_ch_buf + yy_n_chars) = (char)0;
#line 1291
  *(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1293
  yytext = yy_current_buffer->yy_ch_buf + 0;
#line 1295
  return (ret_val);
}
}
#line 1301 "config-lex.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1306
  yy_current_state = yy_start;
#line 1307
  yy_current_state += yy_current_buffer->yy_at_bol;
#line 1309
  yy_cp = yytext + 0;
  {
#line 1309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1309
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1309
      goto while_break;
    }
#line 1311
    if (*yy_cp) {
#line 1311
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1311
      tmp = (int const   )1;
    }
#line 1311
    yy_c = (YY_CHAR )tmp;
#line 1312
    if (yy_accept[yy_current_state]) {
#line 1314
      yy_last_accepting_state = yy_current_state;
#line 1315
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1317
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1317
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1317
        goto while_break___0;
      }
#line 1319
      yy_current_state = (int )yy_def[yy_current_state];
#line 1320
      if (yy_current_state >= 132) {
#line 1321
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1323
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1309
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1326
  return (yy_current_state);
}
}
#line 1337 "config-lex.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1344
  yy_cp = yy_c_buf_p;
#line 1346
  yy_c = (YY_CHAR )1;
#line 1347
  if (yy_accept[yy_current_state]) {
#line 1349
    yy_last_accepting_state = yy_current_state;
#line 1350
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1352
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1352
      goto while_break;
    }
#line 1354
    yy_current_state = (int )yy_def[yy_current_state];
#line 1355
    if (yy_current_state >= 132) {
#line 1356
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1358
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1359
  yy_is_jam = yy_current_state == 131;
#line 1361
  if (yy_is_jam) {
#line 1361
    tmp = 0;
  } else {
#line 1361
    tmp = yy_current_state;
  }
#line 1361
  return (tmp);
}
}
#line 1486 "config-lex.c"
void yyrestart(FILE *input_file ) 
{ 


  {
#line 1492
  if (! yy_current_buffer) {
    {
#line 1493
    yy_current_buffer = yy_create_buffer(yyin, 16384);
    }
  }
  {
#line 1495
  yy_init_buffer(yy_current_buffer, input_file);
#line 1496
  yy_load_buffer_state();
  }
#line 1497
  return;
}
}
#line 1501 "config-lex.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 


  {
#line 1507
  if ((unsigned long )yy_current_buffer == (unsigned long )new_buffer) {
#line 1508
    return;
  }
#line 1510
  if (yy_current_buffer) {
#line 1513
    *yy_c_buf_p = yy_hold_char;
#line 1514
    yy_current_buffer->yy_buf_pos = yy_c_buf_p;
#line 1515
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
  {
#line 1518
  yy_current_buffer = new_buffer;
#line 1519
  yy_load_buffer_state();
#line 1526
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1527
  return;
}
}
#line 1531 "config-lex.c"
void yy_load_buffer_state(void) 
{ 


  {
#line 1536
  yy_n_chars = yy_current_buffer->yy_n_chars;
#line 1537
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
#line 1537
  yytext = yy_c_buf_p;
#line 1538
  yyin = yy_current_buffer->yy_input_file;
#line 1539
  yy_hold_char = *yy_c_buf_p;
#line 1540
  return;
}
}
#line 1544 "config-lex.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1553
  tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1553
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1554
  if (! b) {
    {
#line 1555
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1557
  b->yy_buf_size = (yy_size_t )size;
#line 1562
  tmp___0 = yy_flex_alloc(b->yy_buf_size + 2U);
#line 1562
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1563
  if (! b->yy_ch_buf) {
    {
#line 1564
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1566
  b->yy_is_our_buffer = 1;
#line 1568
  yy_init_buffer(b, file);
  }
#line 1570
  return (b);
}
}
#line 1575 "config-lex.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 


  {
#line 1581
  if (! b) {
#line 1582
    return;
  }
#line 1584
  if ((unsigned long )b == (unsigned long )yy_current_buffer) {
#line 1585
    yy_current_buffer = (YY_BUFFER_STATE )0;
  }
#line 1587
  if (b->yy_is_our_buffer) {
    {
#line 1588
    yy_flex_free((void *)b->yy_ch_buf);
    }
  }
  {
#line 1590
  yy_flex_free((void *)b);
  }
#line 1591
  return;
}
}
#line 1596 "config-lex.c"
void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1605
  yy_flush_buffer(b);
#line 1607
  b->yy_input_file = file;
#line 1608
  b->yy_fill_buffer = 1;
  }
#line 1616
  if (file) {
    {
#line 1616
    tmp = fileno(file);
#line 1616
    tmp___0 = isatty(tmp);
#line 1616
    b->yy_is_interactive = tmp___0 > 0;
    }
  } else {
#line 1616
    b->yy_is_interactive = 0;
  }
#line 1619
  return;
}
}
#line 1623 "config-lex.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 


  {
#line 1630
  if (! b) {
#line 1631
    return;
  }
#line 1633
  b->yy_n_chars = 0;
#line 1639
  *(b->yy_ch_buf + 0) = (char)0;
#line 1640
  *(b->yy_ch_buf + 1) = (char)0;
#line 1642
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1644
  b->yy_at_bol = 1;
#line 1645
  b->yy_buffer_status = 0;
#line 1647
  if ((unsigned long )b == (unsigned long )yy_current_buffer) {
    {
#line 1648
    yy_load_buffer_state();
    }
  }
#line 1649
  return;
}
}
#line 1654 "config-lex.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 1663
  if (size < 2U) {
#line 1667
    return ((YY_BUFFER_STATE )0);
  } else
#line 1663
  if ((int )*(base + (size - 2U)) != 0) {
#line 1667
    return ((YY_BUFFER_STATE )0);
  } else
#line 1663
  if ((int )*(base + (size - 1U)) != 0) {
#line 1667
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1669
  tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1669
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1670
  if (! b) {
    {
#line 1671
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 1673
  b->yy_buf_size = size - 2U;
#line 1674
  tmp___0 = base;
#line 1674
  b->yy_ch_buf = tmp___0;
#line 1674
  b->yy_buf_pos = tmp___0;
#line 1675
  b->yy_is_our_buffer = 0;
#line 1676
  b->yy_input_file = (FILE *)0;
#line 1677
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1678
  b->yy_is_interactive = 0;
#line 1679
  b->yy_at_bol = 1;
#line 1680
  b->yy_fill_buffer = 0;
#line 1681
  b->yy_buffer_status = 0;
#line 1683
  yy_switch_to_buffer(b);
  }
#line 1685
  return (b);
}
}
#line 1692 "config-lex.c"
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) 
{ 
  int len ;
  YY_BUFFER_STATE tmp ;

  {
#line 1699
  len = 0;
  {
#line 1699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1699
    if (! *(yy_str + len)) {
#line 1699
      goto while_break;
    }
#line 1699
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1702
  tmp = yy_scan_bytes(yy_str, len);
  }
#line 1702
  return (tmp);
}
}
#line 1709 "config-lex.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___1 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1722
  n = (yy_size_t )(len + 2);
#line 1723
  tmp = yy_flex_alloc(n);
#line 1723
  buf___1 = (char *)tmp;
  }
#line 1724
  if (! buf___1) {
    {
#line 1725
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 1727
  i = 0;
  {
#line 1727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1727
    if (! (i < len)) {
#line 1727
      goto while_break;
    }
#line 1728
    *(buf___1 + i) = (char )*(bytes + i);
#line 1727
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1730
  tmp___0 = (char)0;
#line 1730
  *(buf___1 + (len + 1)) = tmp___0;
#line 1730
  *(buf___1 + len) = tmp___0;
#line 1732
  b = yy_scan_buffer(buf___1, n);
  }
#line 1733
  if (! b) {
    {
#line 1734
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 1739
  b->yy_is_our_buffer = 1;
#line 1741
  return (b);
}
}
#line 1803 "config-lex.c"
static void yy_fatal_error(char const   *msg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1809
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1810
  exit(2);
  }
}
}
#line 1867 "config-lex.c"
static void *yy_flex_alloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1873
  tmp = malloc(size);
  }
#line 1873
  return (tmp);
}
}
#line 1877 "config-lex.c"
static void *yy_flex_realloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1891
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 1891
  return (tmp);
}
}
#line 1895 "config-lex.c"
static void yy_flex_free(void *ptr ) 
{ 


  {
  {
#line 1901
  free(ptr);
  }
#line 1902
  return;
}
}
#line 143 "config-lex.l"
pid_t pp_pid  ;
#line 145 "config-lex.l"
int yywrap(void) 
{ 


  {
#line 148
  if (yyin) {
    {
#line 149
    pp_extrn_shutdown(pp_pid);
    }
  } else {
    {
#line 151
    pp_done();
    }
  }
#line 152
  locus.file = (char *)((void *)0);
#line 153
  return (1);
}
}
#line 156 "config-lex.l"
int config_lex_begin(char const   *name ) 
{ 
  int fd ;
  int argc ;
  char const   **argv ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 159
  _obstack_begin(& stk, 0, 0, (void *(*)(long  ))(& malloc), & free);
  }
#line 160
  if (preprocessor) {
    {
#line 165
    fd = open(name, 0);
    }
#line 166
    if (fd == -1) {
      {
#line 167
      tmp = gettext("Cannot open `%s\'");
#line 167
      tmp___0 = __errno_location();
#line 167
      dico_log(4, *tmp___0, (char const   *)tmp, name);
      }
#line 168
      return (1);
    }
    {
#line 170
    close(fd);
#line 172
    pp_make_argcv(& argc, & argv);
#line 173
    yyin = pp_extrn_start(argc, argv, & pp_pid);
    }
#line 174
    if (! yyin) {
      {
#line 175
      tmp___1 = gettext("Unable to start external preprocessor `%s\'");
#line 175
      tmp___2 = __errno_location();
#line 175
      dico_log(4, *tmp___2, (char const   *)tmp___1, preprocessor);
      }
#line 178
      return (1);
    }
  } else {
    {
#line 181
    tmp___3 = pp_init(name);
    }
#line 181
    return (tmp___3);
  }
#line 183
  return (0);
}
}
#line 186 "config-lex.l"
void config_lex_end(void) 
{ 


  {
#line 189
  return;
}
}
#line 191 "config-lex.l"
static int isemptystr(int off ) 
{ 
  unsigned short const   **tmp ;
  int i ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (*(yytext + off)) {
      {
#line 194
      tmp = __ctype_b_loc();
      }
#line 194
      if (! ((int const   )*(*tmp + (int )*(yytext + off)) & 8192)) {
#line 194
        goto while_break;
      }
    } else {
#line 194
      goto while_break;
    }
#line 194
    off ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  if ((int )*(yytext + off) == 59) {
#line 198
    i = off + 1;
    {
#line 198
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 198
      if (! *(yytext + i)) {
#line 198
        goto while_break___0;
      }
      {
#line 199
      tmp___0 = __ctype_b_loc();
      }
#line 199
      if (! ((int const   )*(*tmp___0 + (int )*(yytext + i)) & 8192)) {
#line 200
        return (0);
      }
#line 198
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 201
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 201
      *(yytext + yyleng) = yy_hold_char;
#line 201
      yy_c_buf_p = yytext + off;
#line 201
      yy_hold_char = *yy_c_buf_p;
#line 201
      *yy_c_buf_p = (char )'\000';
#line 201
      yyleng = off;
#line 201
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 202
    return (1);
  }
#line 204
  return ((int )*(yytext + off) == 0);
}
}
#line 207 "config-lex.l"
static char *multiline_strip_tabs(char *text ) 
{ 
  int tmp ;

  {
#line 210
  if (char_to_strip) {
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;
#line 211
      if (*text) {
        {
#line 211
        tmp = (*char_to_strip)(*text);
        }
#line 211
        if (! tmp) {
#line 211
          goto while_break;
        }
      } else {
#line 211
        goto while_break;
      }
#line 211
      text ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 213
  return (text);
}
}
#line 216 "config-lex.l"
static void unescape_to_obstack(int c ) 
{ 
  int t ;
  int tmp ;
  struct obstack *__o ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct obstack *__o___0 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 219
  if (c != 10) {
    {
#line 220
    tmp = xdico_unquote_char(c);
#line 220
    t = tmp;
    }
#line 221
    if (t) {
#line 222
      __o = & stk;
#line 222
      if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
        {
#line 222
        _obstack_newchunk(__o, 1);
        }
      }
#line 222
      tmp___0 = __o->next_free;
#line 222
      (__o->next_free) ++;
#line 222
      *tmp___0 = (char )t;
    } else {
      {
#line 224
      tmp___1 = gettext("unknown escape sequence \'\\%c\'");
#line 224
      config_warning(& locus, 0, (char const   *)tmp___1, c);
#line 227
      __o___0 = & stk;
      }
#line 227
      if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
        {
#line 227
        _obstack_newchunk(__o___0, 1);
        }
      }
#line 227
      tmp___2 = __o___0->next_free;
#line 227
      (__o___0->next_free) ++;
#line 227
      *tmp___2 = (char )c;
    }
  }
#line 230
  return;
}
}
#line 232 "config-lex.l"
void line_add(char *text , size_t len ) 
{ 
  struct obstack *__o ;
  int __len ;

  {
#line 235
  __o = & stk;
#line 235
  __len = (int )len;
#line 235
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 235
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 235
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)text,
         (size_t )__len);
#line 235
  __o->next_free += __len;
  }
#line 236
  return;
}
}
#line 239 "config-lex.l"
void line_add_unescape_last(char *text , size_t len ) 
{ 
  struct obstack *__o ;
  int __len ;

  {
#line 242
  __o = & stk;
#line 242
  __len = (int )(len - 2U);
#line 242
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 242
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 242
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)text,
         (size_t )__len);
#line 242
  __o->next_free += __len;
#line 243
  unescape_to_obstack((int )*(text + (len - 1U)));
  }
#line 244
  return;
}
}
#line 246 "config-lex.l"
static void multiline_add(char *s ) 
{ 
  struct obstack *__o ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 249
  if (multiline_unescape) {
    {
#line 250
    while (1) {
      while_continue: /* CIL Label */ ;
#line 250
      if (! *s) {
#line 250
        goto while_break;
      }
#line 251
      if ((int )*s == 92) {
        {
#line 252
        unescape_to_obstack((int )*(s + 1));
#line 253
        s ++;
        }
      } else {
#line 255
        __o = & stk;
#line 255
        if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
          {
#line 255
          _obstack_newchunk(__o, 1);
          }
        }
#line 255
        tmp = __o->next_free;
#line 255
        (__o->next_free) ++;
#line 255
        *tmp = *s;
      }
#line 250
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 258
    tmp___0 = strlen((char const   *)s);
#line 258
    line_add(s, tmp___0);
    }
  }
#line 259
  return;
}
}
#line 261 "config-lex.l"
void line_begin(void) 
{ 


  {
#line 265
  return;
}
}
#line 267 "config-lex.l"
static int is_tab(char c ) 
{ 


  {
#line 270
  return ((int )c == 9);
}
}
#line 273 "config-lex.l"
static int is_ws(char c ) 
{ 
  int tmp ;

  {
#line 276
  if ((int )c == 9) {
#line 276
    tmp = 1;
  } else
#line 276
  if ((int )c == 32) {
#line 276
    tmp = 1;
  } else {
#line 276
    tmp = 0;
  }
#line 276
  return (tmp);
}
}
#line 279 "config-lex.l"
static void multiline_begin(char *p ) 
{ 
  char *q ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
#line 282
  if ((int )*p == 45) {
#line 283
    p ++;
#line 283
    if ((int )*p == 32) {
#line 284
      char_to_strip = & is_ws;
#line 285
      p ++;
    } else {
#line 287
      char_to_strip = & is_tab;
    }
  } else {
#line 289
    char_to_strip = (int (*)(char  ))((void *)0);
  }
#line 290
  if ((int )*p == 92) {
#line 291
    p ++;
#line 292
    multiline_unescape = 0;
  } else
#line 293
  if ((int )*p == 34) {
    {
#line 296
    p ++;
#line 297
    multiline_unescape = 0;
#line 298
    q = strchr((char const   *)p, '\"');
#line 299
    multiline_delimiter_len = (size_t )(q - p);
    }
  } else {
    {
#line 301
    multiline_delimiter_len = strcspn((char const   *)p, " \t");
#line 302
    multiline_unescape = 1;
    }
  }
  {
#line 306
  multiline_delimiter_len --;
#line 307
  tmp = xmalloc(multiline_delimiter_len + 1U);
#line 307
  multiline_delimiter = (char *)tmp;
#line 308
  memcpy((void */* __restrict  */)multiline_delimiter, (void const   */* __restrict  */)p,
         multiline_delimiter_len);
#line 309
  *(multiline_delimiter + multiline_delimiter_len) = (char)0;
#line 310
  line_begin();
  }
#line 311
  return;
}
}
#line 313 "config-lex.l"
void line_finish(void) 
{ 
  struct obstack *__o ;
  char *tmp ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 316
  __o = & stk;
#line 316
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 316
    _obstack_newchunk(__o, 1);
    }
  }
#line 316
  tmp = __o->next_free;
#line 316
  (__o->next_free) ++;
#line 316
  *tmp = (char)0;
#line 317
  __o1 = & stk;
#line 317
  __value = (void *)__o1->object_base;
#line 317
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 317
    __o1->maybe_empty_object = 1U;
  }
#line 317
  if (sizeof(int ) < sizeof(void *)) {
#line 317
    tmp___0 = __o1->object_base;
  } else {
#line 317
    tmp___0 = (char *)0;
  }
#line 317
  if (sizeof(int ) < sizeof(void *)) {
#line 317
    tmp___1 = __o1->object_base;
  } else {
#line 317
    tmp___1 = (char *)0;
  }
#line 317
  __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 317
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 317
    __o1->next_free = __o1->chunk_limit;
  }
#line 317
  __o1->object_base = __o1->next_free;
#line 317
  yylval.string = (char *)__value;
#line 318
  return;
}
}
#line 320 "config-lex.l"
char *line_finish0(void) 
{ 
  struct obstack *__o ;
  char *tmp ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 323
  __o = & stk;
#line 323
  if ((unsigned long )(__o->next_free + 1) > (unsigned long )__o->chunk_limit) {
    {
#line 323
    _obstack_newchunk(__o, 1);
    }
  }
#line 323
  tmp = __o->next_free;
#line 323
  (__o->next_free) ++;
#line 323
  *tmp = (char)0;
#line 324
  __o1 = & stk;
#line 324
  __value = (void *)__o1->object_base;
#line 324
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 324
    __o1->maybe_empty_object = 1U;
  }
#line 324
  if (sizeof(int ) < sizeof(void *)) {
#line 324
    tmp___0 = __o1->object_base;
  } else {
#line 324
    tmp___0 = (char *)0;
  }
#line 324
  if (sizeof(int ) < sizeof(void *)) {
#line 324
    tmp___1 = __o1->object_base;
  } else {
#line 324
    tmp___1 = (char *)0;
  }
#line 324
  __o1->next_free = tmp___0 + (((__o1->next_free - tmp___1) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 324
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 324
    __o1->next_free = __o1->chunk_limit;
  }
#line 324
  __o1->object_base = __o1->next_free;
#line 324
  return ((char *)__value);
}
}
#line 327 "config-lex.l"
static void multiline_finish(void) 
{ 


  {
  {
#line 330
  line_finish();
  }
#line 331
  return;
}
}
#line 333 "config-lex.l"
static int ident(void) 
{ 
  char *p ;
  unsigned short const   **tmp ;
  struct obstack *__o ;
  int __len ;
  size_t tmp___0 ;
  struct obstack *__o___0 ;
  char *tmp___1 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 338
  p = yytext;
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (*p) {
      {
#line 338
      tmp = __ctype_b_loc();
      }
#line 338
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 338
        goto while_break;
      }
    } else {
#line 338
      goto while_break;
    }
#line 338
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 340
  __o = & stk;
#line 340
  tmp___0 = strlen((char const   *)p);
#line 340
  __len = (int )tmp___0;
  }
#line 340
  if ((unsigned long )(__o->next_free + __len) > (unsigned long )__o->chunk_limit) {
    {
#line 340
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 340
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)p,
         (size_t )__len);
#line 340
  __o->next_free += __len;
#line 341
  __o___0 = & stk;
  }
#line 341
  if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
    {
#line 341
    _obstack_newchunk(__o___0, 1);
    }
  }
#line 341
  tmp___1 = __o___0->next_free;
#line 341
  (__o___0->next_free) ++;
#line 341
  *tmp___1 = (char)0;
#line 342
  __o1 = & stk;
#line 342
  __value = (void *)__o1->object_base;
#line 342
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 342
    __o1->maybe_empty_object = 1U;
  }
#line 342
  if (sizeof(int ) < sizeof(void *)) {
#line 342
    tmp___2 = __o1->object_base;
  } else {
#line 342
    tmp___2 = (char *)0;
  }
#line 342
  if (sizeof(int ) < sizeof(void *)) {
#line 342
    tmp___3 = __o1->object_base;
  } else {
#line 342
    tmp___3 = (char *)0;
  }
#line 342
  __o1->next_free = tmp___2 + (((__o1->next_free - tmp___3) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 342
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 342
    __o1->next_free = __o1->chunk_limit;
  }
#line 342
  __o1->object_base = __o1->next_free;
#line 342
  yylval.string = (char *)__value;
#line 343
  return (258);
}
}
#line 346 "config-lex.l"
void config_lex_trace(int n ) 
{ 


  {
#line 349
  yy_flex_debug = n;
#line 350
  return;
}
}
#line 352 "config-lex.l"
config_value_t *config_value_dup(config_value_t *input___0 ) 
{ 
  config_value_t *ptr ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 355
  __h = & stk;
#line 355
  __o = __h;
#line 355
  __len = (int )sizeof(*ptr);
#line 355
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
#line 355
    _obstack_newchunk(__o, __len);
    }
  }
#line 355
  __o->next_free += __len;
#line 355
  __o1 = __h;
#line 355
  __value = (void *)__o1->object_base;
#line 355
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 355
    __o1->maybe_empty_object = 1U;
  }
#line 355
  if (sizeof(int ) < sizeof(void *)) {
#line 355
    tmp = __o1->object_base;
  } else {
#line 355
    tmp = (char *)0;
  }
#line 355
  if (sizeof(int ) < sizeof(void *)) {
#line 355
    tmp___0 = __o1->object_base;
  } else {
#line 355
    tmp___0 = (char *)0;
  }
#line 355
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 355
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 355
    __o1->next_free = __o1->chunk_limit;
  }
#line 355
  __o1->object_base = __o1->next_free;
#line 355
  ptr = (config_value_t *)__value;
#line 356
  *ptr = *input___0;
#line 357
  return (ptr);
}
}
#line 361 "config-lex.l"
static int assign_locus(dicod_locus_t *ploc , char *name , char *line , size_t *pxlines ) 
{ 
  char *p ;
  int tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;

  {
#line 366
  if (name) {
#line 367
    if (pxlines) {
#line 367
      if (! ploc->file) {
#line 368
        *pxlines = (size_t )0;
      } else {
        {
#line 367
        tmp = strcmp((char const   *)name, (char const   *)ploc->file);
        }
#line 367
        if (tmp) {
#line 368
          *pxlines = (size_t )0;
        }
      }
    }
    {
#line 369
    ploc->file = install_text((char const   *)name);
    }
  }
  {
#line 371
  tmp___0 = strtoul((char const   */* __restrict  */)line, (char **/* __restrict  */)(& p),
                    10);
  }
#line 371
  if (pxlines) {
#line 371
    tmp___1 = *pxlines;
  } else {
#line 371
    tmp___1 = (size_t )0;
  }
#line 371
  ploc->line = (int )(tmp___0 - (unsigned long )tmp___1);
#line 372
  return ((int )*p != 0);
}
}
#line 375 "config-lex.l"
static void parse_line(char *text , dicod_locus_t *ploc , size_t *pxlines ) 
{ 
  int rc ;
  int argc ;
  char **argv ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *p ;
  unsigned long x ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 378
  rc = 1;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (*text) {
      {
#line 382
      tmp = __ctype_b_loc();
      }
#line 382
      if (! ((int const   )*(*tmp + (int )*text) & 8192)) {
#line 382
        goto while_break;
      }
    } else {
#line 382
      goto while_break;
    }
#line 383
    text ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 384
  text ++;
#line 386
  tmp___4 = dico_argcv_get((char const   *)text, "", (char const   *)((void *)0),
                           & argc, & argv);
  }
#line 386
  if (tmp___4) {
    {
#line 387
    tmp___0 = gettext("cannot parse #line line");
#line 387
    config_error(ploc, 0, (char const   *)tmp___0);
    }
  } else {
#line 389
    if (argc == 2) {
      {
#line 390
      rc = assign_locus(ploc, (char *)((void *)0), *(argv + 1), pxlines);
      }
    } else
#line 391
    if (argc == 3) {
      {
#line 392
      rc = assign_locus(ploc, *(argv + 2), *(argv + 1), pxlines);
      }
    } else
#line 393
    if (argc == 4) {
      {
#line 394
      rc = assign_locus(ploc, *(argv + 2), *(argv + 1), (size_t *)0);
      }
#line 395
      if (rc == 0) {
        {
#line 397
        tmp___1 = strtoul((char const   */* __restrict  */)*(argv + 3), (char **/* __restrict  */)(& p),
                          10);
#line 397
        x = tmp___1;
#line 398
        rc = (int )*p != 0;
        }
#line 399
        if (rc == 0) {
#line 400
          *pxlines = (size_t )x;
        }
      }
    } else {
      {
#line 403
      tmp___2 = gettext("invalid #line statement");
#line 403
      config_error(ploc, 0, (char const   *)tmp___2);
      }
    }
#line 405
    if (rc) {
      {
#line 406
      tmp___3 = gettext("malformed #line statement");
#line 406
      config_error(ploc, 0, (char const   *)tmp___3);
      }
    }
  }
  {
#line 408
  dico_argcv_free(argc, argv);
  }
#line 409
  return;
}
}
#line 411 "config-lex.l"
static void parse_line_cpp(char *text , dicod_locus_t *ploc , size_t *pxlines ) 
{ 
  int argc ;
  char **argv ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 417
  tmp___3 = dico_argcv_get((char const   *)text, "", (char const   *)((void *)0),
                           & argc, & argv);
  }
#line 417
  if (tmp___3) {
    {
#line 418
    tmp = gettext("cannot parse #line line");
#line 418
    config_error(ploc, 0, (char const   *)tmp);
    }
  } else
#line 419
  if (argc < 3) {
    {
#line 420
    tmp___0 = gettext("invalid #line statement");
#line 420
    config_error(ploc, 0, (char const   *)tmp___0);
    }
  } else {
    {
#line 422
    tmp___2 = assign_locus(ploc, *(argv + 2), *(argv + 1), pxlines);
    }
#line 422
    if (tmp___2) {
      {
#line 423
      tmp___1 = gettext("malformed #line statement");
#line 423
      config_error(ploc, 0, (char const   *)tmp___1);
      }
    }
  }
  {
#line 425
  dico_argcv_free(argc, argv);
  }
#line 426
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 305 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   * __restrict  __nptr ,
                                                        char ** __restrict  __endptr ,
                                                        int __base ) ;
#line 309
extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  __nptr ,
                                                         char ** __restrict  __endptr ,
                                                         int __base ) ;
#line 217 "./dicod.h"
int yyerror(char *s ) ;
#line 227
void config_gram_trace(int n ) ;
#line 74 "config-gram.h"
YYSTYPE yylval  ;
#line 21 "config-gram.y"
static struct config_keyword config_keywords  ;
#line 22 "config-gram.y"
static struct config_keyword *cursect  ;
#line 23 "config-gram.y"
static dico_list_t sections  ;
#line 24 "config-gram.y"
int config_error_count  ;
#line 26
void *target_ptr(struct config_keyword *kwp ) ;
#line 27
void stmt_begin(struct config_keyword *kwp , config_value_t tag ) ;
#line 28
void stmt_end(struct config_keyword *kwp ) ;
#line 29
struct config_keyword *find_keyword(char const   *ident___0 ) ;
#line 31
void process_ident(struct config_keyword *kwp , config_value_t *value ) ;
#line 395 "config-gram.c"
static yytype_uint8 const   yytranslate[262]  = 
#line 395 "config-gram.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )9,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6};
#line 429 "config-gram.c"
static yytype_uint8 const   yyprhs[32]  = 
#line 429
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )27,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )32,      (yytype_uint8 const   )34,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )41,      (yytype_uint8 const   )43,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )49,      (yytype_uint8 const   )51,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )58,      (yytype_uint8 const   )61,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )72,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77};
#line 438 "config-gram.c"
static yytype_int8 const   yyrhs[79]  = 
#line 438
  {      (yytype_int8 const   )14,      (yytype_int8 const   )0,      (yytype_int8 const   )-1,      (yytype_int8 const   )15, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )16,      (yytype_int8 const   )-1,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )-1,      (yytype_int8 const   )17,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )18,      (yytype_int8 const   )-1,      (yytype_int8 const   )20,      (yytype_int8 const   )22, 
        (yytype_int8 const   )7,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )19,      (yytype_int8 const   )8,      (yytype_int8 const   )15, 
        (yytype_int8 const   )9,      (yytype_int8 const   )30,      (yytype_int8 const   )-1,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )24,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )23,      (yytype_int8 const   )-1,      (yytype_int8 const   )24,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )23,      (yytype_int8 const   )24,      (yytype_int8 const   )-1,      (yytype_int8 const   )25, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )28,      (yytype_int8 const   )-1,      (yytype_int8 const   )6, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )4,      (yytype_int8 const   )-1,      (yytype_int8 const   )3, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )26,      (yytype_int8 const   )-1,      (yytype_int8 const   )27, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )5,      (yytype_int8 const   )-1,      (yytype_int8 const   )27, 
        (yytype_int8 const   )5,      (yytype_int8 const   )-1,      (yytype_int8 const   )10,      (yytype_int8 const   )11, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )10,      (yytype_int8 const   )29,      (yytype_int8 const   )11, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )10,      (yytype_int8 const   )29,      (yytype_int8 const   )12, 
        (yytype_int8 const   )11,      (yytype_int8 const   )-1,      (yytype_int8 const   )24,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )29,      (yytype_int8 const   )12,      (yytype_int8 const   )24,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )7,      (yytype_int8 const   )-1};
#line 451 "config-gram.c"
static yytype_uint8 const   yyrline[32]  = 
#line 451
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )74,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )90,      (yytype_uint8 const   )108,      (yytype_uint8 const   )113, 
        (yytype_uint8 const   )119,      (yytype_uint8 const   )124,      (yytype_uint8 const   )129,      (yytype_uint8 const   )136, 
        (yytype_uint8 const   )137,      (yytype_uint8 const   )138,      (yytype_uint8 const   )141,      (yytype_uint8 const   )155, 
        (yytype_uint8 const   )160,      (yytype_uint8 const   )167,      (yytype_uint8 const   )171,      (yytype_uint8 const   )175, 
        (yytype_uint8 const   )181,      (yytype_uint8 const   )186,      (yytype_uint8 const   )193,      (yytype_uint8 const   )194};
#line 463 "config-gram.c"
static char const   * const  yytname[32]  = 
#line 463
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"IDENT", 
        (char const   */* const  */)"STRING",      (char const   */* const  */)"QSTRING",      (char const   */* const  */)"MSTRING",      (char const   */* const  */)"\';\'", 
        (char const   */* const  */)"\'{\'",      (char const   */* const  */)"\'}\'",      (char const   */* const  */)"\'(\'",      (char const   */* const  */)"\')\'", 
        (char const   */* const  */)"\',\'",      (char const   */* const  */)"$accept",      (char const   */* const  */)"input",      (char const   */* const  */)"stmtlist", 
        (char const   */* const  */)"stmt",      (char const   */* const  */)"simple",      (char const   */* const  */)"block",      (char const   */* const  */)"@1", 
        (char const   */* const  */)"ident",      (char const   */* const  */)"tag",      (char const   */* const  */)"vallist",      (char const   */* const  */)"vlist", 
        (char const   */* const  */)"value",      (char const   */* const  */)"string",      (char const   */* const  */)"slist",      (char const   */* const  */)"slist0", 
        (char const   */* const  */)"list",      (char const   */* const  */)"values",      (char const   */* const  */)"opt_sc",      (char const   */* const  */)0};
#line 483 "config-gram.c"
static yytype_uint8 const   yyr1[32]  = 
#line 483
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )18,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )24,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )28,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30};
#line 492 "config-gram.c"
static yytype_uint8 const   yyr2[32]  = 
#line 492
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1};
#line 503 "config-gram.c"
static yytype_uint8 const   yydefact[39]  = 
#line 503
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )10,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )20,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )18,      (yytype_uint8 const   )0,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )17,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )24,      (yytype_uint8 const   )26,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )29,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )9};
#line 512 "config-gram.c"
static yytype_int8 const   yydefgoto[18]  = 
#line 512
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )26,      (yytype_int8 const   )7, 
        (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21,      (yytype_int8 const   )22, 
        (yytype_int8 const   )25,      (yytype_int8 const   )38};
#line 521 "config-gram.c"
static yytype_int8 const   yypact[39]  = 
#line 521
  {      (yytype_int8 const   )16,      (yytype_int8 const   )-14,      (yytype_int8 const   )27,      (yytype_int8 const   )16, 
        (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )20, 
        (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14, 
        (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )2,      (yytype_int8 const   )-14, 
        (yytype_int8 const   )-5,      (yytype_int8 const   )20,      (yytype_int8 const   )12,      (yytype_int8 const   )-14, 
        (yytype_int8 const   )-14,      (yytype_int8 const   )23,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14, 
        (yytype_int8 const   )-14,      (yytype_int8 const   )-1,      (yytype_int8 const   )21,      (yytype_int8 const   )-14, 
        (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )11, 
        (yytype_int8 const   )16,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )0, 
        (yytype_int8 const   )24,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14};
#line 530 "config-gram.c"
static yytype_int8 const   yypgoto[18]  = 
#line 530
  {      (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )1,      (yytype_int8 const   )-3, 
        (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14, 
        (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )-13, 
        (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14,      (yytype_int8 const   )-14, 
        (yytype_int8 const   )-14,      (yytype_int8 const   )-14};
#line 541 "config-gram.c"
static yytype_int8 const   yytable[34]  = 
#line 541
  {      (yytype_int8 const   )9,      (yytype_int8 const   )24,      (yytype_int8 const   )27,      (yytype_int8 const   )1, 
        (yytype_int8 const   )28,      (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12, 
        (yytype_int8 const   )13,      (yytype_int8 const   )36,      (yytype_int8 const   )30,      (yytype_int8 const   )31, 
        (yytype_int8 const   )14,      (yytype_int8 const   )23,      (yytype_int8 const   )10,      (yytype_int8 const   )11, 
        (yytype_int8 const   )12,      (yytype_int8 const   )13,      (yytype_int8 const   )34,      (yytype_int8 const   )1, 
        (yytype_int8 const   )-12,      (yytype_int8 const   )14,      (yytype_int8 const   )33,      (yytype_int8 const   )10, 
        (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13,      (yytype_int8 const   )8, 
        (yytype_int8 const   )29,      (yytype_int8 const   )32,      (yytype_int8 const   )14,      (yytype_int8 const   )37, 
        (yytype_int8 const   )9,      (yytype_int8 const   )35};
#line 549 "config-gram.c"
static yytype_uint8 const   yycheck[34]  = 
#line 549
  {      (yytype_uint8 const   )3,      (yytype_uint8 const   )14,      (yytype_uint8 const   )7,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )9,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )31,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )8,      (yytype_uint8 const   )10,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )32};
#line 559 "config-gram.c"
static yytype_uint8 const   yystos[39]  = 
#line 559
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )16,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )10,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )29,      (yytype_uint8 const   )19,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )5,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )11,      (yytype_uint8 const   )24,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )7,      (yytype_uint8 const   )30};
#line 690 "config-gram.c"
static void yy_symbol_value_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 


  {
#line 700
  if (! yyvaluep) {
#line 701
    return;
  }
  {
#line 710
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 711
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 713
  return;
}
}
#line 722 "config-gram.c"
static void yy_symbol_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 732
  if (yytype < 13) {
    {
#line 733
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"token %s (",
            yytname[yytype]);
    }
  } else {
    {
#line 735
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"nterm %s (",
            yytname[yytype]);
    }
  }
  {
#line 737
  yy_symbol_value_print(yyoutput, yytype, yyvaluep);
#line 738
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)")");
  }
#line 739
  return;
}
}
#line 748 "config-gram.c"
static void yy_stack_print(yytype_int16 *bottom , yytype_int16 *top ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 757
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    if (! ((unsigned long )bottom <= (unsigned long )top)) {
#line 758
      goto while_break;
    }
    {
#line 759
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            (int )*bottom);
#line 758
    bottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 760
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 761
  return;
}
}
#line 776 "config-gram.c"
static void yy_reduce_print(YYSTYPE *yyvsp , int yyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 785
  yynrhs = (int )yyr2[yyrule];
#line 787
  yylno = (unsigned long )yyrline[yyrule];
#line 788
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          yyrule - 1, yylno);
#line 791
  yyi = 0;
  }
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 791
    if (! (yyi < yynrhs)) {
#line 791
      goto while_break;
    }
    {
#line 793
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yyi + 1);
#line 794
    yy_symbol_print(stderr, (int )yyrhs[(int const   )yyprhs[yyrule] + (int const   )yyi],
                    (YYSTYPE const   */* const  */)(yyvsp + ((yyi + 1) - yynrhs)));
#line 797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 791
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 799
  return;
}
}
#line 809 "config-gram.c"
int yydebug  ;
#line 1054 "config-gram.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1066
  if (! yymsg) {
#line 1067
    yymsg = "Deleting";
  }
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1068
    if (yydebug) {
      {
#line 1068
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yymsg);
#line 1068
      yy_symbol_print(stderr, yytype, (YYSTYPE const   */* const  */)yyvaluep);
#line 1068
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1068
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1073
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1074
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1076
  return;
}
}
#line 1089
int yyparse(void) ;
#line 1098 "config-gram.c"
int yychar  ;
#line 1104 "config-gram.c"
int yynerrs  ;
#line 1125 "config-gram.c"
int yyparse(void) 
{ 
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned int yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  char *tmp___0 ;
  size_t n ;
  void *tmp___1 ;
  size_t i ;
  void *tmp___2 ;
  void *tmp___3 ;
  config_value_t *tmp___4 ;
  config_value_t *tmp___5 ;
  dico_iterator_t itr ;
  dico_iterator_t tmp___6 ;
  char *p ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  config_value_t *tmp___10 ;
  config_value_t *tmp___11 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
#line 1141
  yytoken = 0;
#line 1159
  yyss = yyssa;
#line 1164
  yyvs = yyvsa;
#line 1171
  yystacksize = 200U;
#line 1180
  yylen = 0;
  {
#line 1182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1182
    if (yydebug) {
      {
#line 1182
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 1182
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1184
  yystate = 0;
#line 1185
  yyerrstatus = 0;
#line 1186
  yynerrs = 0;
#line 1187
  yychar = -2;
#line 1194
  yyssp = yyss;
#line 1195
  yyvsp = yyvs;
#line 1197
  goto yysetstate;
  yynewstate: 
#line 1205
  yyssp ++;
  yysetstate: 
#line 1208
  *yyssp = (yytype_int16 )yystate;
#line 1210
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1213
    yysize = (unsigned int )((yyssp - yyss) + 1L);
#line 1242
    if (10000U <= yystacksize) {
#line 1243
      goto yyexhaustedlab;
    }
#line 1244
    yystacksize *= 2U;
#line 1245
    if (10000U < yystacksize) {
#line 1246
      yystacksize = 10000U;
    }
    {
#line 1249
    yyss1 = yyss;
#line 1250
    tmp = malloc((size_t )((unsigned long )yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL)));
#line 1250
    yyptr = (union yyalloc *)tmp;
    }
#line 1252
    if (! yyptr) {
#line 1253
      goto yyexhaustedlab;
    }
    {
#line 1254
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1254
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, (unsigned long )yysize * sizeof(*yyss));
#line 1254
      yyss = & yyptr->yyss;
#line 1254
      yynewbytes = (unsigned int )((unsigned long )yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL));
#line 1254
      yyptr += (unsigned long )yynewbytes / sizeof(*yyptr);
      }
#line 1254
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1255
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1255
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, (unsigned long )yysize * sizeof(*yyvs));
#line 1255
      yyvs = & yyptr->yyvs;
#line 1255
      yynewbytes___0 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL));
#line 1255
      yyptr += (unsigned long )yynewbytes___0 / sizeof(*yyptr);
      }
#line 1255
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1258
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1259
      free((void *)yyss1);
      }
    }
#line 1264
    yyssp = (yyss + yysize) - 1;
#line 1265
    yyvsp = (yyvs + yysize) - 1;
    {
#line 1268
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1268
      if (yydebug) {
        {
#line 1268
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                (unsigned long )yystacksize);
        }
      }
#line 1268
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1271
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1272
      goto yyabortlab;
    }
  }
  {
#line 1275
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1275
    if (yydebug) {
      {
#line 1275
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              yystate);
      }
    }
#line 1275
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1277
  goto yybackup;
  yybackup: 
#line 1288
  yyn = (int )yypact[yystate];
#line 1289
  if (yyn == -14) {
#line 1290
    goto yydefault;
  }
#line 1295
  if (yychar == -2) {
    {
#line 1297
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1297
      if (yydebug) {
        {
#line 1297
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 1297
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1298
    yychar = yylex();
    }
  }
#line 1301
  if (yychar <= 0) {
#line 1303
    yytoken = 0;
#line 1303
    yychar = yytoken;
    {
#line 1304
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1304
      if (yydebug) {
        {
#line 1304
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 1304
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 1308
    if ((unsigned int )yychar <= 261U) {
#line 1308
      yytoken = (int )yytranslate[yychar];
    } else {
#line 1308
      yytoken = 2;
    }
    {
#line 1309
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1309
      if (yydebug) {
        {
#line 1309
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 1309
        yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& yylval));
#line 1309
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 1309
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1314
  yyn += yytoken;
#line 1315
  if (yyn < 0) {
#line 1316
    goto yydefault;
  } else
#line 1315
  if (33 < yyn) {
#line 1316
    goto yydefault;
  } else
#line 1315
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1316
    goto yydefault;
  }
#line 1317
  yyn = (int )yytable[yyn];
#line 1318
  if (yyn <= 0) {
#line 1320
    if (yyn == 0) {
#line 1321
      goto yyerrlab;
    } else
#line 1320
    if (yyn == -13) {
#line 1321
      goto yyerrlab;
    }
#line 1322
    yyn = - yyn;
#line 1323
    goto yyreduce;
  }
#line 1326
  if (yyn == 8) {
#line 1327
    goto yyacceptlab;
  }
#line 1331
  if (yyerrstatus) {
#line 1332
    yyerrstatus --;
  }
  {
#line 1335
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1335
    if (yydebug) {
      {
#line 1335
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1335
      yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& yylval));
#line 1335
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1335
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1338
  if (yychar != 0) {
#line 1339
    yychar = -2;
  }
#line 1341
  yystate = yyn;
#line 1342
  yyvsp ++;
#line 1342
  *yyvsp = yylval;
#line 1344
  goto yynewstate;
  yydefault: 
#line 1351
  yyn = (int )yydefact[yystate];
#line 1352
  if (yyn == 0) {
#line 1353
    goto yyerrlab;
  }
#line 1354
  goto yyreduce;
  yyreduce: 
#line 1362
  yylen = (int )yyr2[yyn];
#line 1372
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1375
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1375
    if (yydebug) {
      {
#line 1375
      yy_reduce_print(yyvsp, yyn);
      }
    }
#line 1375
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1378
  if (yyn == 7) {
#line 1378
    goto case_7;
  }
#line 68
  if (yyn == 8) {
#line 68 "config-gram.y"
    goto case_8;
  }
#line 71
  if (yyn == 9) {
#line 71
    goto case_9;
  }
#line 74
  if (yyn == 10) {
#line 74
    goto case_10;
  }
#line 82
  if (yyn == 11) {
#line 82
    goto case_11;
  }
#line 89
  if (yyn == 13) {
#line 89
    goto case_13;
  }
#line 108
  if (yyn == 14) {
#line 108
    goto case_14;
  }
#line 115
  if (yyn == 15) {
#line 115
    goto case_15;
  }
#line 119
  if (yyn == 16) {
#line 119
    goto case_16;
  }
#line 126
  if (yyn == 17) {
#line 126
    goto case_17;
  }
#line 131
  if (yyn == 18) {
#line 131
    goto case_18;
  }
#line 136
  if (yyn == 22) {
#line 136
    goto case_22;
  }
#line 155
  if (yyn == 23) {
#line 155
    goto case_23;
  }
#line 162
  if (yyn == 24) {
#line 162
    goto case_24;
  }
#line 167
  if (yyn == 25) {
#line 167
    goto case_25;
  }
#line 173
  if (yyn == 26) {
#line 173
    goto case_26;
  }
#line 177
  if (yyn == 27) {
#line 177
    goto case_27;
  }
#line 181
  if (yyn == 28) {
#line 181
    goto case_28;
  }
#line 188
  if (yyn == 29) {
#line 188
    goto case_29;
  }
#line 1543 "config-gram.c"
  goto switch_default;
  case_7: /* CIL Label */ 
  {
#line 64 "config-gram.y"
  process_ident((yyvsp + -2)->kw, & (yyvsp + -1)->value);
  }
#line 66
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 68
  stmt_begin((yyvsp + -1)->kw, (yyvsp + 0)->value);
  }
#line 69
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 70
  stmt_end((yyvsp + -6)->kw);
  }
#line 72
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 76
  yyval.kw = find_keyword((char const   *)(yyvsp + 0)->string);
  }
#line 77
  if (! yyval.kw) {
    {
#line 78
    tmp___0 = gettext("Unknown keyword");
#line 78
    config_error(& locus, 0, (char const   *)tmp___0);
    }
  }
#line 80
  goto switch_break;
  case_11: /* CIL Label */ 
#line 84
  yyval.value.type = 0;
#line 85
  yyval.value.v.string = (char const   *)((void *)0);
#line 87
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 93
  n = dico_list_count((yyvsp + 0)->list);
  }
#line 93
  if (n == 1U) {
    {
#line 94
    tmp___1 = dico_list_item((yyvsp + 0)->list, (size_t )0);
#line 94
    yyval.value = *((config_value_t *)tmp___1);
    }
  } else {
    {
#line 98
    yyval.value.type = 2;
#line 99
    yyval.value.v.arg.c = n;
#line 100
    tmp___2 = xcalloc(n, (size_t )sizeof(*(yyval.value.v.arg.v + 0)));
#line 100
    yyval.value.v.arg.v = (struct config_value *)tmp___2;
#line 101
    i = (size_t )0;
    }
    {
#line 101
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 101
      if (! (i < n)) {
#line 101
        goto while_break___9;
      }
      {
#line 102
      tmp___3 = dico_list_item((yyvsp + 0)->list, i);
#line 102
      *(yyval.value.v.arg.v + i) = *((config_value_t *)tmp___3);
#line 101
      i ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  {
#line 104
  dico_list_destroy(& (yyvsp + 0)->list);
  }
#line 106
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 110
  yyval.list = xdico_list_create();
#line 111
  tmp___4 = config_value_dup(& (yyvsp + 0)->value);
#line 111
  xdico_list_append(yyval.list, (void *)tmp___4);
  }
#line 113
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 115
  tmp___5 = config_value_dup(& (yyvsp + 0)->value);
#line 115
  xdico_list_append((yyvsp + -1)->list, (void *)tmp___5);
  }
#line 117
  goto switch_break;
  case_16: /* CIL Label */ 
#line 121
  yyval.value.type = 0;
#line 122
  yyval.value.v.string = (char const   *)(yyvsp + 0)->string;
#line 124
  goto switch_break;
  case_17: /* CIL Label */ 
#line 126
  yyval.value.type = 1;
#line 127
  yyval.value.v.list = (yyvsp + 0)->list;
#line 129
  goto switch_break;
  case_18: /* CIL Label */ 
#line 131
  yyval.value.type = 0;
#line 132
  yyval.value.v.string = (char const   *)(yyvsp + 0)->string;
#line 134
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 143
  tmp___6 = xdico_list_iterator((yyvsp + 0)->list);
#line 143
  itr = tmp___6;
#line 145
  line_begin();
#line 146
  tmp___7 = dico_iterator_first(itr);
#line 146
  p = (char *)tmp___7;
  }
  {
#line 146
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 146
    if (! p) {
#line 146
      goto while_break___10;
    }
    {
#line 148
    tmp___9 = strlen((char const   *)p);
#line 148
    line_add(p, tmp___9);
#line 146
    tmp___8 = dico_iterator_next(itr);
#line 146
    p = (char *)tmp___8;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 149
  yyval.string = line_finish0();
#line 150
  dico_iterator_destroy(& itr);
#line 151
  dico_list_destroy(& (yyvsp + 0)->list);
  }
#line 153
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 157
  yyval.list = xdico_list_create();
#line 158
  xdico_list_append(yyval.list, (void *)(yyvsp + 0)->string);
  }
#line 160
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 162
  xdico_list_append((yyvsp + -1)->list, (void *)(yyvsp + 0)->string);
#line 163
  yyval.list = (yyvsp + -1)->list;
  }
#line 165
  goto switch_break;
  case_25: /* CIL Label */ 
#line 169
  yyval.list = (dico_list_t )((void *)0);
#line 171
  goto switch_break;
  case_26: /* CIL Label */ 
#line 173
  yyval.list = (yyvsp + -1)->list;
#line 175
  goto switch_break;
  case_27: /* CIL Label */ 
#line 177
  yyval.list = (yyvsp + -2)->list;
#line 179
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 183
  yyval.list = xdico_list_create();
#line 184
  tmp___10 = config_value_dup(& (yyvsp + 0)->value);
#line 184
  xdico_list_append(yyval.list, (void *)tmp___10);
  }
#line 186
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 188
  tmp___11 = config_value_dup(& (yyvsp + 0)->value);
#line 188
  xdico_list_append((yyvsp + -2)->list, (void *)tmp___11);
#line 189
  yyval.list = (yyvsp + -2)->list;
  }
#line 191
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1543 "config-gram.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1545
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1545
    if (yydebug) {
      {
#line 1545
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 1545
      yy_symbol_print(stderr, (int )yyr1[yyn], (YYSTYPE const   */* const  */)(& yyval));
#line 1545
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1545
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1547
  yyvsp -= yylen;
#line 1547
  yyssp -= yylen;
#line 1548
  yylen = 0;
  {
#line 1549
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1549
    if (yydebug) {
      {
#line 1549
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1549
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 1551
  yyvsp ++;
#line 1551
  *yyvsp = yyval;
#line 1558
  yyn = (int )yyr1[yyn];
#line 1560
  yystate = (int )((int const   )yypgoto[yyn - 13] + (int const   )*yyssp);
#line 1561
  if (0 <= yystate) {
#line 1561
    if (yystate <= 33) {
#line 1561
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 1562
        yystate = (int )yytable[yystate];
      } else {
#line 1564
        yystate = (int )yydefgoto[yyn - 13];
      }
    } else {
#line 1564
      yystate = (int )yydefgoto[yyn - 13];
    }
  } else {
#line 1564
    yystate = (int )yydefgoto[yyn - 13];
  }
#line 1566
  goto yynewstate;
  yyerrlab: 
#line 1574
  if (! yyerrstatus) {
    {
#line 1576
    yynerrs ++;
#line 1578
    yyerror((char *)"syntax error");
    }
  }
#line 1616
  if (yyerrstatus == 3) {
#line 1621
    if (yychar <= 0) {
#line 1624
      if (yychar == 0) {
#line 1625
        goto yyabortlab;
      }
    } else {
      {
#line 1629
      yydestruct("Error: discarding", yytoken, & yylval);
#line 1631
      yychar = -2;
      }
    }
  }
#line 1637
  goto yyerrlab1;
#line 1653
  yyvsp -= yylen;
#line 1653
  yyssp -= yylen;
#line 1654
  yylen = 0;
  {
#line 1655
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 1655
    if (yydebug) {
      {
#line 1655
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1655
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 1656
  yystate = (int )*yyssp;
#line 1657
  goto yyerrlab1;
  yyerrlab1: 
#line 1664
  yyerrstatus = 3;
  {
#line 1666
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 1668
    yyn = (int )yypact[yystate];
#line 1669
    if (yyn != -14) {
#line 1671
      yyn ++;
#line 1672
      if (0 <= yyn) {
#line 1672
        if (yyn <= 33) {
#line 1672
          if ((int const   )yycheck[yyn] == 1) {
#line 1674
            yyn = (int )yytable[yyn];
#line 1675
            if (0 < yyn) {
#line 1676
              goto while_break___14;
            }
          }
        }
      }
    }
#line 1681
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 1682
      goto yyabortlab;
    }
    {
#line 1685
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 1687
    yyvsp --;
#line 1687
    yyssp --;
#line 1688
    yystate = (int )*yyssp;
    }
    {
#line 1689
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1689
      if (yydebug) {
        {
#line 1689
        yy_stack_print(yyss, yyssp);
        }
      }
#line 1689
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
#line 1692
  if (yyn == 8) {
#line 1693
    goto yyacceptlab;
  }
#line 1695
  yyvsp ++;
#line 1695
  *yyvsp = yylval;
  {
#line 1699
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1699
    if (yydebug) {
      {
#line 1699
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1699
      yy_symbol_print(stderr, (int )yystos[yyn], (YYSTYPE const   */* const  */)yyvsp);
#line 1699
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1699
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1701
  yystate = yyn;
#line 1702
  goto yynewstate;
  yyacceptlab: 
#line 1709
  yyresult = 0;
#line 1710
  goto yyreturn;
  yyabortlab: 
#line 1716
  yyresult = 1;
#line 1717
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 1724
  yyerror((char *)"memory exhausted");
#line 1725
  yyresult = 2;
  }
  yyreturn: 
#line 1730
  if (yychar != 0) {
#line 1730
    if (yychar != -2) {
      {
#line 1731
      yydestruct("Cleanup: discarding lookahead", yytoken, & yylval);
      }
    }
  }
#line 1735
  yyvsp -= yylen;
#line 1735
  yyssp -= yylen;
  {
#line 1736
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 1736
    if (yydebug) {
      {
#line 1736
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1736
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 1737
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 1737
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 1737
      goto while_break___18;
    }
    {
#line 1739
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 1741
    yyvsp --;
#line 1741
    yyssp --;
    }
  }
  while_break___18: /* CIL Label */ ;
  }
#line 1744
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 1745
    free((void *)yyss);
    }
  }
#line 1752
  return (yyresult);
}
}
#line 199 "config-gram.y"
int yyerror(char *s ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 202
  config_error(& locus, 0, "%s", s);
  }
#line 203
  return (0);
}
}
#line 206 "config-gram.y"
void config_diag(dicod_locus_t *locus___0 , int category , int errcode , char const   *fmt ,
                 va_list ap ) 
{ 
  char *pfx ;
  char *newfmt ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 213
  if (category == 3) {
    {
#line 214
    pfx = gettext("warning: ");
    }
  } else {
#line 216
    pfx = (char *)((void *)0);
  }
#line 218
  if (! locus___0) {
#line 218
    goto _L;
  } else
#line 218
  if (! locus___0->file) {
    _L: /* CIL Label */ 
#line 219
    if (pfx) {
#line 219
      tmp = (char const   *)pfx;
    } else {
#line 219
      tmp = "";
    }
    {
#line 219
    asprintf((char **/* __restrict  */)(& newfmt), (char const   */* __restrict  */)"%s%s",
             tmp, fmt);
    }
  } else {
#line 221
    if (pfx) {
#line 221
      tmp___0 = (char const   *)pfx;
    } else {
#line 221
      tmp___0 = "";
    }
    {
#line 221
    asprintf((char **/* __restrict  */)(& newfmt), (char const   */* __restrict  */)"%s:%d: %s%s",
             locus___0->file, locus___0->line, tmp___0, fmt);
    }
  }
  {
#line 225
  dico_vlog(category, errcode, (char const   *)newfmt, ap);
#line 226
  free((void *)newfmt);
  }
#line 227
  return;
}
}
#line 229 "config-gram.y"
void ( /* format attribute */  config_warning)(dicod_locus_t *locus___0 , int errcode ,
                                               char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 234
  __builtin_va_start(ap, fmt);
#line 235
  config_diag(locus___0, 3, errcode, fmt, ap);
#line 236
  __builtin_va_end(ap);
  }
#line 237
  return;
}
}
#line 239 "config-gram.y"
void ( /* format attribute */  config_error)(dicod_locus_t *locus___0 , int errcode ,
                                             char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 244
  __builtin_va_start(ap, fmt);
#line 245
  config_diag(locus___0, 4, errcode, fmt, ap);
#line 246
  __builtin_va_end(ap);
#line 247
  config_error_count ++;
  }
#line 248
  return;
}
}
#line 250 "config-gram.y"
void config_set_keywords(struct config_keyword *kwd ) 
{ 


  {
#line 253
  config_keywords.kwd = kwd;
#line 254
  return;
}
}
#line 256 "config-gram.y"
int config_parse(char const   *name ) 
{ 
  int rc ;
  int tmp ;

  {
  {
#line 260
  tmp = config_lex_begin(name);
  }
#line 260
  if (tmp) {
#line 261
    return (1);
  }
  {
#line 262
  cursect = & config_keywords;
#line 263
  dico_list_destroy(& sections);
#line 264
  rc = yyparse();
#line 265
  config_lex_end();
  }
#line 266
  if (config_error_count) {
#line 267
    rc = 1;
  }
#line 268
  return (rc);
}
}
#line 271 "config-gram.y"
void config_gram_trace(int n ) 
{ 


  {
#line 274
  yydebug = n;
#line 275
  return;
}
}
#line 279 "config-gram.y"
void *target_ptr(struct config_keyword *kwp ) 
{ 
  char *base ;

  {
#line 284
  if (kwp->varptr) {
#line 285
    base = (char *)kwp->varptr + kwp->offset;
  } else
#line 286
  if (cursect) {
#line 286
    if (cursect->callback_data) {
#line 287
      base = (char *)cursect->callback_data + kwp->offset;
    } else {
#line 289
      base = (char *)((void *)0);
    }
  } else {
#line 289
    base = (char *)((void *)0);
  }
#line 290
  return ((void *)base);
}
}
#line 293 "config-gram.y"
void stmt_begin(struct config_keyword *kwp , config_value_t tag ) 
{ 
  void *target ;

  {
#line 298
  if (! sections) {
    {
#line 299
    sections = xdico_list_create();
    }
  }
  {
#line 300
  dico_list_prepend(sections, (void *)cursect);
  }
#line 301
  if (kwp) {
    {
#line 302
    target = target_ptr(kwp);
#line 303
    cursect = kwp;
    }
#line 304
    if (kwp->callback) {
      {
#line 305
      (*(kwp->callback))((enum cfg_callback_command )0, & locus, target, & tag, (void *)(& kwp->callback_data));
      }
    }
  } else {
#line 312
    cursect = kwp;
  }
#line 313
  return;
}
}
#line 315 "config-gram.y"
void stmt_end(struct config_keyword *kwp ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 318
  if (cursect) {
#line 318
    if (cursect->callback) {
#line 319
      if (kwp) {
        {
#line 319
        tmp = target_ptr(kwp);
#line 319
        tmp___0 = tmp;
        }
      } else {
#line 319
        tmp___0 = (void *)0;
      }
      {
#line 319
      (*(cursect->callback))((enum cfg_callback_command )1, & locus, tmp___0, (config_value_t *)((void *)0),
                             (void *)(& cursect->callback_data));
      }
    }
  }
  {
#line 324
  tmp___1 = dico_list_pop(sections);
#line 324
  cursect = (struct config_keyword *)tmp___1;
  }
#line 325
  return;
}
}
#line 327 "config-gram.y"
int fake_callback(enum cfg_callback_command cmd___6 , dicod_locus_t *locus___0 , void *varptr ,
                  config_value_t *value , void *cb_data ) 
{ 


  {
#line 334
  return (0);
}
}
#line 337 "config-gram.y"
static struct config_keyword fake  = 
#line 337
     {"*", (char const   *)((void *)0), (char const   *)((void *)0), (enum config_data_type )0,
    (void *)0, (size_t )0, & fake_callback, (void *)0, & fake};
#line 349 "config-gram.y"
struct config_keyword *find_keyword(char const   *ident___0 ) 
{ 
  struct config_keyword *kwp ;
  int tmp ;

  {
#line 354
  if (cursect) {
#line 354
    if ((unsigned long )cursect != (unsigned long )(& fake)) {
#line 355
      kwp = cursect->kwd;
      {
#line 355
      while (1) {
        while_continue: /* CIL Label */ ;
#line 355
        if (! kwp->ident) {
#line 355
          goto while_break;
        }
        {
#line 356
        tmp = strcmp(kwp->ident, ident___0);
        }
#line 356
        if (tmp == 0) {
#line 357
          return (kwp);
        }
#line 355
        kwp ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 359
      return (& fake);
    }
  } else {
#line 359
    return (& fake);
  }
#line 361
  return ((struct config_keyword *)((void *)0));
}
}
#line 364 "config-gram.y"
int string_to_signed(intmax_t *sval , char const   *string , intmax_t minval , intmax_t maxval ) 
{ 
  intmax_t t ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 371
  t = strtoimax((char const   */* __restrict  */)string, (char **/* __restrict  */)(& p),
                0);
  }
#line 372
  if (*p) {
    {
#line 373
    tmp = gettext("cannot convert `%s\' to number");
#line 373
    config_error(& locus, 0, (char const   *)tmp, string);
    }
#line 375
    return (1);
  } else
#line 376
  if (t < minval) {
    {
#line 377
    tmp___0 = gettext("%s: value out of allowed range %lli..%lli");
#line 377
    config_error(& locus, 0, (char const   *)tmp___0, string, minval, maxval);
    }
#line 380
    return (1);
  } else
#line 376
  if (t > maxval) {
    {
#line 377
    tmp___0 = gettext("%s: value out of allowed range %lli..%lli");
#line 377
    config_error(& locus, 0, (char const   *)tmp___0, string, minval, maxval);
    }
#line 380
    return (1);
  }
#line 382
  *sval = t;
#line 383
  return (0);
}
}
#line 386 "config-gram.y"
int string_to_unsigned(uintmax_t *sval , char const   *string , uintmax_t maxval ,
                       dicod_locus_t *loc ) 
{ 
  uintmax_t t ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 393
  t = strtoumax((char const   */* __restrict  */)string, (char **/* __restrict  */)(& p),
                0);
  }
#line 394
  if (*p) {
    {
#line 395
    tmp = gettext("cannot convert `%s\' to number");
#line 395
    config_error(loc, 0, (char const   *)tmp, string);
    }
#line 397
    return (1);
  } else
#line 398
  if (t > maxval) {
    {
#line 399
    tmp___0 = gettext("%s: value out of allowed range 0..%llu");
#line 399
    config_error(loc, 0, (char const   *)tmp___0, string, maxval);
    }
#line 402
    return (1);
  }
#line 404
  *sval = t;
#line 405
  return (0);
}
}
#line 408 "config-gram.y"
int string_to_bool(char const   *string , int *pval ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 411
  tmp___4 = strcmp(string, "yes");
  }
#line 411
  if (tmp___4 == 0) {
#line 415
    *pval = 1;
  } else {
    {
#line 411
    tmp___5 = strcmp(string, "true");
    }
#line 411
    if (tmp___5 == 0) {
#line 415
      *pval = 1;
    } else {
      {
#line 411
      tmp___6 = strcmp(string, "t");
      }
#line 411
      if (tmp___6 == 0) {
#line 415
        *pval = 1;
      } else {
        {
#line 411
        tmp___7 = strcmp(string, "1");
        }
#line 411
        if (tmp___7 == 0) {
#line 415
          *pval = 1;
        } else {
          {
#line 416
          tmp___0 = strcmp(string, "no");
          }
#line 416
          if (tmp___0 == 0) {
#line 420
            *pval = 0;
          } else {
            {
#line 416
            tmp___1 = strcmp(string, "false");
            }
#line 416
            if (tmp___1 == 0) {
#line 420
              *pval = 0;
            } else {
              {
#line 416
              tmp___2 = strcmp(string, "nil");
              }
#line 416
              if (tmp___2 == 0) {
#line 420
                *pval = 0;
              } else {
                {
#line 416
                tmp___3 = strcmp(string, "0");
                }
#line 416
                if (tmp___3 == 0) {
#line 420
                  *pval = 0;
                } else {
                  {
#line 422
                  tmp = gettext("%s: not a valid boolean value");
#line 422
                  config_error(& locus, 0, (char const   *)tmp, string);
                  }
#line 425
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 427
  return (0);
}
}
#line 430 "config-gram.y"
static int string_to_host(struct in_addr *in , char const   *string ) 
{ 
  struct hostent *hp ;
  int tmp ;

  {
  {
#line 433
  tmp = inet_aton(string, in);
  }
#line 433
  if (tmp == 0) {
    {
#line 436
    hp = gethostbyname(string);
    }
#line 437
    if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 438
      return (1);
    }
    {
#line 439
    memcpy((void */* __restrict  */)in, (void const   */* __restrict  */)*(hp->h_addr_list + 0),
           (size_t )sizeof(struct in_addr ));
    }
  }
#line 441
  return (0);
}
}
#line 444 "config-gram.y"
static int string_to_sockaddr(sockaddr_union_t *s , char const   *string ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  char *p ;
  char *tmp___1 ;
  size_t len ;
  struct sockaddr_in sa ;
  char *host ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  struct servent *serv ;
  unsigned long l ;
  char *q ;
  char *tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 447
  if ((int const   )*(string + 0) == 47) {
    {
#line 448
    tmp___0 = strlen(string);
    }
#line 448
    if ((unsigned long )tmp___0 >= sizeof(s->s_un.sun_path)) {
      {
#line 449
      tmp = gettext("%s: UNIX socket name too long");
#line 449
      config_error(& locus, 0, (char const   *)tmp, string);
      }
#line 452
      return (1);
    }
    {
#line 454
    s->s_un.sun_family = (sa_family_t )1;
#line 455
    strcpy((char */* __restrict  */)(s->s_un.sun_path), (char const   */* __restrict  */)string);
    }
  } else {
    {
#line 457
    tmp___1 = strchr(string, ':');
#line 457
    p = tmp___1;
#line 461
    sa.sin_family = (sa_family_t )2;
    }
#line 462
    if (p) {
#line 463
      len = (size_t )(p - (char *)string);
    } else {
      {
#line 465
      len = strlen(string);
      }
    }
#line 467
    if (len == 0U) {
#line 468
      sa.sin_addr.s_addr = (in_addr_t )0;
    } else {
      {
#line 470
      tmp___2 = xmalloc(len + 1U);
#line 470
      host = (char *)tmp___2;
#line 471
      memcpy((void */* __restrict  */)host, (void const   */* __restrict  */)string,
             len);
#line 472
      *(host + len) = (char)0;
#line 474
      tmp___4 = string_to_host(& sa.sin_addr, (char const   *)host);
      }
#line 474
      if (tmp___4) {
        {
#line 475
        tmp___3 = gettext("%s: not a valid IP address or hostname");
#line 475
        config_error(& locus, 0, (char const   *)tmp___3, host);
#line 478
        free((void *)host);
        }
#line 479
        return (1);
      }
      {
#line 481
      free((void *)host);
      }
    }
#line 484
    if (p) {
      {
#line 487
      p ++;
#line 488
      serv = getservbyname((char const   *)p, "tcp");
      }
#line 489
      if ((unsigned long )serv != (unsigned long )((void *)0)) {
#line 490
        sa.sin_port = (in_port_t )serv->s_port;
      } else {
        {
#line 496
        l = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& q),
                    0);
        }
#line 498
        if (*q) {
          {
#line 499
          tmp___5 = gettext("%s: not a valid port number");
#line 499
          config_error(& locus, 0, (char const   *)tmp___5, p);
          }
#line 501
          return (1);
        } else
#line 498
        if (l > 65535UL) {
          {
#line 499
          tmp___5 = gettext("%s: not a valid port number");
#line 499
          config_error(& locus, 0, (char const   *)tmp___5, p);
          }
#line 501
          return (1);
        }
        {
#line 503
        sa.sin_port = htons((uint16_t )l);
        }
      }
    } else {
      {
#line 506
      sa.sin_port = htons((uint16_t )2628);
      }
    }
#line 507
    s->s_in = sa;
  }
#line 509
  return (0);
}
}
#line 512 "config-gram.y"
static int string_convert(void *target , enum config_data_type type , char const   *string ) 
{ 
  uintmax_t uval ;
  intmax_t sval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 519
  if ((unsigned int )type == 0U) {
#line 519
    goto case_0;
  }
#line 522
  if ((unsigned int )type == 1U) {
#line 522
    goto case_1;
  }
#line 526
  if ((unsigned int )type == 2U) {
#line 526
    goto case_2;
  }
#line 533
  if ((unsigned int )type == 3U) {
#line 533
    goto case_3;
  }
#line 540
  if ((unsigned int )type == 12U) {
#line 540
    goto case_12;
  }
#line 543
  if ((unsigned int )type == 4U) {
#line 543
    goto case_4;
  }
#line 550
  if ((unsigned int )type == 5U) {
#line 550
    goto case_5;
  }
#line 557
  if ((unsigned int )type == 6U) {
#line 557
    goto case_6;
  }
#line 564
  if ((unsigned int )type == 7U) {
#line 564
    goto case_7;
  }
#line 571
  if ((unsigned int )type == 8U) {
#line 571
    goto case_8;
  }
#line 578
  if ((unsigned int )type == 10U) {
#line 578
    goto case_10;
  }
#line 582
  if ((unsigned int )type == 9U) {
#line 582
    goto case_9;
  }
#line 586
  if ((unsigned int )type == 11U) {
#line 586
    goto case_11;
  }
#line 594
  if ((unsigned int )type == 13U) {
#line 594
    goto case_13;
  }
#line 601
  if ((unsigned int )type == 15U) {
#line 601
    goto case_15;
  }
#line 609
  if ((unsigned int )type == 16U) {
#line 609
    goto case_16;
  }
#line 615
  if ((unsigned int )type == 17U) {
#line 615
    goto case_17;
  }
#line 615
  if ((unsigned int )type == 14U) {
#line 615
    goto case_17;
  }
#line 518
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 520
  abort();
  }
  case_1: /* CIL Label */ 
#line 523
  *((char const   **)target) = string;
#line 524
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 527
  tmp = string_to_signed(& sval, string, (intmax_t )-32768, (intmax_t )32767);
  }
#line 527
  if (tmp == 0) {
#line 528
    *((short *)target) = (short )sval;
  } else {
#line 530
    return (1);
  }
#line 531
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 534
  tmp___0 = string_to_unsigned(& uval, string, (uintmax_t )65535, & locus);
  }
#line 534
  if (tmp___0 == 0) {
#line 535
    *((unsigned short *)target) = (unsigned short )uval;
  } else {
#line 537
    return (1);
  }
#line 538
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 541
  tmp___1 = string_to_bool(string, (int *)target);
  }
#line 541
  return (tmp___1);
  case_4: /* CIL Label */ 
  {
#line 544
  tmp___2 = string_to_signed(& sval, string, (intmax_t )(-0x7FFFFFFF-1), (intmax_t )2147483647);
  }
#line 544
  if (tmp___2 == 0) {
#line 545
    *((int *)target) = (int )sval;
  } else {
#line 547
    return (1);
  }
#line 548
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 551
  tmp___3 = string_to_unsigned(& uval, string, (uintmax_t )4294967295U, & locus);
  }
#line 551
  if (tmp___3 == 0) {
#line 552
    *((unsigned int *)target) = (unsigned int )uval;
  } else {
#line 554
    return (1);
  }
#line 555
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 558
  tmp___4 = string_to_signed(& sval, string, (intmax_t )(-0x7FFFFFFF-1), (intmax_t )2147483647L);
  }
#line 558
  if (tmp___4 == 0) {
#line 559
    *((long *)target) = (long )sval;
  } else {
#line 561
    return (1);
  }
#line 562
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 565
  tmp___5 = string_to_unsigned(& uval, string, (uintmax_t )4294967295UL, & locus);
  }
#line 565
  if (tmp___5 == 0) {
#line 566
    *((unsigned long *)target) = (unsigned long )uval;
  } else {
#line 568
    return (1);
  }
#line 569
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 572
  tmp___6 = string_to_unsigned(& uval, string, (uintmax_t )4294967295U, & locus);
  }
#line 572
  if (tmp___6 == 0) {
#line 573
    *((size_t *)target) = (size_t )uval;
  } else {
#line 575
    return (1);
  }
#line 576
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 579
  tmp___7 = string_to_signed((intmax_t *)target, string, (-0x7FFFFFFFFFFFFFFF-1),
                             9223372036854775807LL);
  }
#line 579
  return (tmp___7);
  case_9: /* CIL Label */ 
  {
#line 583
  tmp___8 = string_to_unsigned((uintmax_t *)target, string, 0xffffffffffffffffULL,
                               & locus);
  }
#line 583
  return (tmp___8);
  case_11: /* CIL Label */ 
  {
#line 588
  tmp___9 = string_to_unsigned(& uval, string, (uintmax_t )((time_t )-1), & locus);
  }
#line 588
  if (tmp___9 == 0) {
#line 589
    *((time_t *)target) = (time_t )uval;
  } else {
#line 591
    return (1);
  }
#line 592
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 595
  tmp___11 = inet_aton(string, (struct in_addr *)target);
  }
#line 595
  if (tmp___11) {
    {
#line 596
    tmp___10 = gettext("%s: not a valid IP address");
#line 596
    config_error(& locus, 0, (char const   *)tmp___10, string);
    }
#line 597
    return (1);
  }
#line 599
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 602
  tmp___13 = string_to_host((struct in_addr *)target, string);
  }
#line 602
  if (tmp___13) {
    {
#line 603
    tmp___12 = gettext("%s: not a valid IP address or hostname");
#line 603
    config_error(& locus, 0, (char const   *)tmp___12, string);
    }
#line 605
    return (1);
  }
#line 607
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 610
  tmp___14 = string_to_sockaddr((sockaddr_union_t *)target, string);
  }
#line 610
  return (tmp___14);
  case_17: /* CIL Label */ 
  case_14: /* CIL Label */ 
  {
#line 616
  tmp___15 = gettext("INTERNAL ERROR at %s:%d");
#line 616
  config_error(& locus, 0, (char const   *)tmp___15, "config-gram.y", 617);
#line 618
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 620
  return (0);
}
}
#line 623 "config-gram.y"
size_t config_type_size[18]  = 
#line 623
  {      (size_t )0,      (size_t )sizeof(char *),      (size_t )sizeof(short ),      (size_t )sizeof(unsigned short ), 
        (size_t )sizeof(int ),      (size_t )sizeof(unsigned int ),      (size_t )sizeof(long ),      (size_t )sizeof(unsigned long ), 
        (size_t )sizeof(size_t ),      (size_t )sizeof(uintmax_t ),      (size_t )sizeof(intmax_t ),      (size_t )sizeof(time_t ), 
        (size_t )sizeof(int ),      (size_t )sizeof(struct in_addr ),      (size_t )0,      (size_t )sizeof(struct in_addr ), 
        (size_t )sizeof(sockaddr_union_t ),      (size_t )0};
#line 645 "config-gram.y"
void process_ident(struct config_keyword *kwp , config_value_t *value ) 
{ 
  void *target ;
  char *tmp ;
  dico_iterator_t itr ;
  dico_iterator_t tmp___0 ;
  enum config_data_type type ;
  int num ;
  void *p ;
  dico_list_t list ;
  dico_list_t tmp___1 ;
  config_value_t *vp ;
  size_t size ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *ptr ;
  void *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  dico_list_t list___0 ;
  dico_list_t tmp___7 ;
  enum config_data_type type___0 ;
  size_t size___0 ;
  void *ptr___0 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 650
  if (! kwp) {
#line 651
    return;
  }
  {
#line 653
  target = target_ptr(kwp);
  }
#line 655
  if (kwp->callback) {
    {
#line 656
    (*(kwp->callback))((enum cfg_callback_command )2, & locus, target, value, (void *)(& kwp->callback_data));
    }
  } else
#line 661
  if (value->type == 2) {
    {
#line 662
    tmp = gettext("too many arguments to `%s\'; missing semicolon?");
#line 662
    config_error(& locus, 0, (char const   *)tmp, kwp->ident);
    }
#line 665
    return;
  } else
#line 666
  if (value->type == 1) {
#line 667
    if ((unsigned int )kwp->type & 32768U) {
      {
#line 668
      tmp___0 = xdico_list_iterator(value->v.list);
#line 668
      itr = tmp___0;
#line 669
      type = (enum config_data_type )((unsigned int )kwp->type & 255U);
#line 670
      num = 1;
#line 672
      tmp___1 = xdico_list_create();
#line 672
      list = tmp___1;
#line 674
      p = dico_iterator_first(itr);
      }
      {
#line 674
      while (1) {
        while_continue: /* CIL Label */ ;
#line 674
        if (! p) {
#line 674
          goto while_break;
        }
#line 676
        vp = (config_value_t *)p;
#line 679
        if ((unsigned long )type >= sizeof(config_type_size) / sizeof(config_type_size[0])) {
          {
#line 681
          tmp___2 = gettext("INTERNAL ERROR at %s:%d: unhandled data type %d");
#line 681
          config_error(& locus, 0, (char const   *)tmp___2, "config-gram.y", 684,
                       (unsigned int )type);
#line 685
          abort();
          }
        } else {
#line 679
          size = config_type_size[type];
#line 679
          if (size == 0U) {
            {
#line 681
            tmp___2 = gettext("INTERNAL ERROR at %s:%d: unhandled data type %d");
#line 681
            config_error(& locus, 0, (char const   *)tmp___2, "config-gram.y", 684,
                         (unsigned int )type);
#line 685
            abort();
            }
          }
        }
#line 688
        if (vp->type != 0) {
          {
#line 689
          tmp___3 = gettext("%s: incompatible data type in list item #%d");
#line 689
          config_error(& locus, 0, (char const   *)tmp___3, kwp->ident, num);
          }
        } else {
          {
#line 693
          tmp___4 = xmalloc(size);
#line 693
          ptr = tmp___4;
#line 694
          tmp___5 = string_convert(ptr, type, vp->v.string);
          }
#line 694
          if (tmp___5 == 0) {
            {
#line 695
            xdico_list_append(list, ptr);
            }
          } else {
            {
#line 697
            free(ptr);
            }
          }
        }
        {
#line 674
        p = dico_iterator_next(itr);
#line 674
        num ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 700
      dico_iterator_destroy(& itr);
#line 701
      *((dico_list_t *)target) = list;
      }
    } else {
      {
#line 703
      tmp___6 = gettext("incompatible data type for `%s\'");
#line 703
      config_error(& locus, 0, (char const   *)tmp___6, kwp->ident);
      }
#line 705
      return;
    }
  } else
#line 707
  if ((unsigned int )kwp->type & 32768U) {
    {
#line 708
    tmp___7 = xdico_list_create();
#line 708
    list___0 = tmp___7;
#line 709
    type___0 = (enum config_data_type )((unsigned int )kwp->type & 255U);
    }
#line 713
    if ((unsigned long )type___0 >= sizeof(config_type_size) / sizeof(config_type_size[0])) {
      {
#line 715
      tmp___8 = gettext("INTERNAL ERROR at %s:%d: unhandled data type %d");
#line 715
      config_error(& locus, 0, (char const   *)tmp___8, "config-gram.y", 717, (unsigned int )type___0);
#line 718
      abort();
      }
    } else {
#line 713
      size___0 = config_type_size[type___0];
#line 713
      if (size___0 == 0U) {
        {
#line 715
        tmp___8 = gettext("INTERNAL ERROR at %s:%d: unhandled data type %d");
#line 715
        config_error(& locus, 0, (char const   *)tmp___8, "config-gram.y", 717, (unsigned int )type___0);
#line 718
        abort();
        }
      }
    }
    {
#line 720
    ptr___0 = xmalloc(size___0);
#line 721
    tmp___9 = string_convert(ptr___0, type___0, value->v.string);
    }
#line 721
    if (tmp___9) {
      {
#line 722
      free(ptr___0);
#line 723
      dico_list_destroy(& list___0);
      }
#line 724
      return;
    }
    {
#line 726
    xdico_list_append(list___0, ptr___0);
#line 727
    *((dico_list_t *)target) = list___0;
    }
  } else {
    {
#line 729
    string_convert(target, (enum config_data_type )((unsigned int )kwp->type & 255U),
                   value->v.string);
    }
  }
#line 730
  return;
}
}
#line 20 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-format.c"
static char const   *config_data_type_string(enum config_data_type type ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 24
  if ((unsigned int )type == 0U) {
#line 24
    goto case_0;
  }
#line 27
  if ((unsigned int )type == 1U) {
#line 27
    goto case_1;
  }
#line 39
  if ((unsigned int )type == 10U) {
#line 39
    goto case_10;
  }
#line 39
  if ((unsigned int )type == 9U) {
#line 39
    goto case_10;
  }
#line 39
  if ((unsigned int )type == 8U) {
#line 39
    goto case_10;
  }
#line 39
  if ((unsigned int )type == 7U) {
#line 39
    goto case_10;
  }
#line 39
  if ((unsigned int )type == 6U) {
#line 39
    goto case_10;
  }
#line 39
  if ((unsigned int )type == 5U) {
#line 39
    goto case_10;
  }
#line 39
  if ((unsigned int )type == 4U) {
#line 39
    goto case_10;
  }
#line 39
  if ((unsigned int )type == 3U) {
#line 39
    goto case_10;
  }
#line 39
  if ((unsigned int )type == 2U) {
#line 39
    goto case_10;
  }
#line 42
  if ((unsigned int )type == 11U) {
#line 42
    goto case_11;
  }
#line 45
  if ((unsigned int )type == 12U) {
#line 45
    goto case_12;
  }
#line 48
  if ((unsigned int )type == 13U) {
#line 48
    goto case_13;
  }
#line 51
  if ((unsigned int )type == 14U) {
#line 51
    goto case_14;
  }
#line 54
  if ((unsigned int )type == 15U) {
#line 54
    goto case_15;
  }
#line 57
  if ((unsigned int )type == 16U) {
#line 57
    goto case_16;
  }
#line 60
  if ((unsigned int )type == 17U) {
#line 60
    goto case_17;
  }
#line 23
  goto switch_break;
  case_0: /* CIL Label */ 
#line 25
  return ("void");
  case_1: /* CIL Label */ 
#line 28
  return ("string");
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 40
  return ("number");
  case_11: /* CIL Label */ 
#line 43
  return ("time");
  case_12: /* CIL Label */ 
#line 46
  return ("boolean");
  case_13: /* CIL Label */ 
#line 49
  return ("IPv4");
  case_14: /* CIL Label */ 
#line 52
  return ("CIDR");
  case_15: /* CIL Label */ 
#line 55
  return ("hostname");
  case_16: /* CIL Label */ 
#line 58
  return ("sock-addr");
  case_17: /* CIL Label */ 
#line 61
  return ("section");
  switch_break: /* CIL Label */ ;
  }
#line 63
  return ("UNKNOWN?");
}
}
#line 66 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-format.c"
static void format_level(FILE *stream , int level ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    tmp = level;
#line 69
    level --;
#line 69
    if (! tmp) {
#line 69
      goto while_break;
    }
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"  ");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-format.c"
void format_docstring(FILE *stream , char const   *docstring___0 , int level ) 
{ 
  size_t len ;
  size_t tmp ;
  int width ;
  size_t seglen ;
  char const   *p ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp11 ;

  {
  {
#line 76
  tmp = strlen(docstring___0);
#line 76
  len = tmp;
#line 77
  width = 78 - level * 2;
  }
#line 79
  if (width < 0) {
#line 80
    width = 78;
#line 81
    level = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! len) {
#line 84
      goto while_break;
    }
#line 88
    seglen = (size_t )0;
#line 88
    p = docstring___0;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if ((unsigned long )p < (unsigned long )(docstring___0 + width)) {
#line 88
        if (! *p) {
#line 88
          goto while_break___0;
        }
      } else {
#line 88
        goto while_break___0;
      }
#line 89
      if ((int const   )*p == 10) {
#line 90
        seglen = (size_t )(p - docstring___0);
#line 91
        goto while_break___0;
      }
      {
#line 93
      tmp___0 = __ctype_b_loc();
      }
#line 93
      if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 94
        seglen = (size_t )(p - docstring___0);
      }
#line 88
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 96
    if (seglen == 0U) {
#line 97
      seglen = (size_t )(p - docstring___0);
    } else
#line 96
    if ((int const   )*p == 0) {
#line 97
      seglen = (size_t )(p - docstring___0);
    }
    {
#line 99
    format_level(stream, level);
#line 100
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# ");
#line 101
    fwrite((void const   */* __restrict  */)docstring___0, seglen, (size_t )1, (FILE */* __restrict  */)stream);
#line 102
    fputc('\n', stream);
#line 103
    len -= seglen;
#line 104
    docstring___0 += seglen;
    }
#line 105
    if ((int const   )*docstring___0 == 10) {
#line 106
      docstring___0 ++;
#line 107
      len --;
    } else {
      {
#line 109
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 109
        if (*docstring___0) {
          {
#line 109
          tmp___1 = __ctype_b_loc();
          }
#line 109
          if (! ((int const   )*(*tmp___1 + (int )*docstring___0) & 8192)) {
#line 109
            goto while_break___1;
          }
        } else {
#line 109
          goto while_break___1;
        }
#line 110
        docstring___0 ++;
#line 111
        len --;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 116 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-format.c"
static void format_simple_statement(FILE *stream , struct config_keyword *kwp , int level ) 
{ 
  char *argstr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 121
  if (kwp->docstring) {
    {
#line 122
    format_docstring(stream, kwp->docstring, level);
    }
  }
  {
#line 123
  format_level(stream, level);
  }
#line 125
  if (kwp->argname) {
#line 126
    argstr = (char *)kwp->argname;
  } else {
#line 128
    argstr = (char *)"arg";
  }
  {
#line 130
  tmp___7 = strchr("<[", (int )*(argstr + 0));
  }
#line 130
  if (tmp___7) {
    {
#line 131
    tmp = gettext((char const   *)argstr);
#line 131
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s;\n",
            kwp->ident, tmp);
    }
  } else {
    {
#line 132
    tmp___6 = strchr((char const   *)argstr, ':');
    }
#line 132
    if (tmp___6) {
      {
#line 133
      tmp___0 = gettext((char const   *)argstr);
#line 133
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s <%s>;\n",
              kwp->ident, tmp___0);
      }
    } else {
      {
#line 135
      tmp___1 = gettext((char const   *)argstr);
#line 135
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s <%s: ",
              kwp->ident, tmp___1);
      }
#line 136
      if ((unsigned int )kwp->type & 32768U) {
        {
#line 137
        tmp___2 = config_data_type_string((enum config_data_type )((unsigned int )kwp->type & 255U));
#line 137
        tmp___3 = gettext(tmp___2);
#line 137
        fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"list of %s",
                tmp___3);
        }
      } else {
        {
#line 140
        tmp___4 = config_data_type_string(kwp->type);
#line 140
        tmp___5 = gettext(tmp___4);
#line 140
        fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
                tmp___5);
        }
      }
      {
#line 142
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)">;\n");
      }
    }
  }
#line 144
  return;
}
}
#line 146 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-format.c"
static void format_block_statement(FILE *stream , struct config_keyword *kwp , int level ) 
{ 
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 149
  if (kwp->docstring) {
    {
#line 150
    format_docstring(stream, kwp->docstring, level);
    }
  }
  {
#line 151
  format_level(stream, level);
#line 152
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s",
          kwp->ident);
  }
#line 153
  if (kwp->argname) {
    {
#line 154
    tmp = gettext(kwp->argname);
#line 154
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" <%s>",
            tmp);
    }
  }
  {
#line 155
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" {\n");
#line 156
  format_statement_array(stream, kwp->kwd, 0, level + 1);
#line 157
  format_level(stream, level);
#line 158
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"}\n");
  }
#line 159
  return;
}
}
#line 161 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/config-format.c"
void format_statement_array(FILE *stream , struct config_keyword *kwp , int n , int level ) 
{ 


  {
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! kwp->ident) {
#line 165
      goto while_break;
    }
#line 166
    if (n) {
      {
#line 167
      fputc('\n', stream);
      }
    }
#line 168
    if ((unsigned int )kwp->type == 17U) {
      {
#line 169
      format_block_statement(stream, kwp, level);
      }
    } else {
      {
#line 171
      format_simple_statement(stream, kwp, level);
      }
    }
#line 165
    kwp ++;
#line 165
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 76 "./dicod.h"
int got_quit  ;
#line 339
void dicod_add_command(struct dicod_command *cmd___6 ) ;
#line 340
void dicod_remove_command(char const   *name ) ;
#line 465
void access_log(int argc , char **argv ) ;
#line 475
int alias_expand(int argc , char **argv , int *pargc , char ***pargv ) ;
#line 82 "/usr/include/sys/utsname.h"
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
#line 22 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_quit(dico_stream_t str , int argc , char **argv ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 25
  got_quit = 1;
#line 26
  stream_writez(str, (char *)"221 bye");
#line 27
  report_current_timing(str, "dicod");
#line 28
  stream_writez(str, (char *)"\r\n");
  }
#line 29
  return;
}
}
#line 31
void dicod_show_std_help(dico_stream_t str ) ;
#line 33 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_help(dico_stream_t str , int argc , char **argv ) 
{ 
  char const   *text ;
  dico_stream_t ostr ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 36
  text = (char const   *)help_text;
#line 39
  stream_writez(str, (char *)"113 help text follows\r\n");
#line 40
  ostr = dicod_ostream_create(str, (dico_assoc_list_t )((void *)0));
  }
#line 42
  if (text) {
#line 43
    if ((int const   )*(text + 0) == 43) {
      {
#line 44
      dicod_show_std_help(ostr);
#line 45
      text ++;
      }
    }
    {
#line 47
    stream_write_multiline(ostr, text);
    }
  } else {
    {
#line 49
    dicod_show_std_help(ostr);
    }
  }
  {
#line 51
  stream_writez(ostr, (char *)"\r\n");
#line 52
  dico_stream_close(ostr);
#line 53
  dico_stream_destroy(& ostr);
#line 55
  stream_writez(str, (char *)".\r\n");
#line 56
  stream_writez(str, (char *)"250 ok\r\n");
  }
#line 57
  return;
}
}
#line 59 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_show_info(dico_stream_t str , int argc , char **argv ) 
{ 
  char *dbname ;
  dicod_database_t *dict ;
  dicod_database_t *tmp ;
  dico_stream_t ostr ;
  char *info ;
  char *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 62
  dbname = *(argv + 2);
#line 63
  tmp = find_database((char const   *)dbname);
#line 63
  dict = tmp;
  }
#line 64
  if (! dict) {
    {
#line 65
    stream_writez(str, (char *)"550 invalid database, use SHOW DB for a list\r\n");
    }
  } else {
    {
#line 68
    tmp___0 = dicod_get_database_info(dict);
#line 68
    info = tmp___0;
#line 69
    stream_printf(str, "112 information for %s\r\n", dbname);
#line 70
    ostr = dicod_ostream_create(str, (dico_assoc_list_t )((void *)0));
    }
#line 71
    if (info) {
      {
#line 72
      stream_write_multiline(ostr, (char const   *)info);
#line 73
      dicod_free_database_info(dict, info);
      }
    } else {
      {
#line 75
      stream_writez(ostr, (char *)"No information available.\r\n");
      }
    }
    {
#line 76
    stream_writez(ostr, (char *)"\r\n");
#line 77
    dico_stream_close(ostr);
#line 78
    dico_stream_destroy(& ostr);
#line 80
    stream_writez(str, (char *)".\r\n");
#line 81
    stream_writez(str, (char *)"250 ok\r\n");
    }
  }
#line 83
  return;
}
}
#line 85 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
static int _show_database(void *item , void *data ) 
{ 
  dicod_database_t *dict ;
  dico_stream_t str ;
  char *descr ;
  char *tmp ;
  char *pdescr ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 88
  dict = (dicod_database_t *)item;
#line 89
  str = (dico_stream_t )data;
#line 90
  tmp = dicod_get_database_descr(dict);
#line 90
  descr = tmp;
  }
#line 93
  if (descr) {
#line 93
    tmp___0 = (char const   *)descr;
  } else {
#line 93
    tmp___0 = "";
  }
  {
#line 93
  tmp___1 = utf8_quote(tmp___0, & pdescr);
  }
#line 93
  if (tmp___1) {
    {
#line 94
    xalloc_die();
    }
  }
  {
#line 95
  stream_printf(str, "%s \"%s\"\r\n", dict->name, pdescr);
#line 96
  dicod_free_database_descr(dict, descr);
#line 97
  free((void *)pdescr);
  }
#line 98
  return (0);
}
}
#line 101 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_show_databases(dico_stream_t str , int argc , char **argv ) 
{ 
  size_t count ;
  size_t tmp ;
  dico_stream_t ostr ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 104
  tmp = database_count();
#line 104
  count = tmp;
  }
#line 105
  if (count == 0U) {
    {
#line 106
    stream_printf(str, "554 No databases present\r\n");
    }
  } else {
    {
#line 110
    stream_printf(str, "110 %lu databases present\r\n", (unsigned long )count);
#line 112
    ostr = dicod_ostream_create(str, (dico_assoc_list_t )((void *)0));
#line 113
    database_iterate(& _show_database, (void *)ostr);
#line 114
    dico_stream_close(ostr);
#line 115
    dico_stream_destroy(& ostr);
#line 116
    stream_writez(str, (char *)".\r\n");
#line 117
    stream_writez(str, (char *)"250 ok\r\n");
    }
  }
#line 119
  return;
}
}
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
static int _show_strategy(void *item , void *data ) 
{ 
  dico_strategy_t sp ;
  dico_stream_t str ;
  char *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 124
  sp = (dico_strategy_t )item;
#line 125
  str = (dico_stream_t )data;
#line 127
  tmp = quotearg((char const   *)sp->descr);
#line 127
  stream_printf(str, "%s \"%s\"\r\n", sp->name, tmp);
  }
#line 129
  return (0);
}
}
#line 132 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_show_strategies(dico_stream_t str , int argc , char **argv ) 
{ 
  size_t count ;
  size_t tmp ;
  dico_stream_t ostr ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 135
  tmp = dico_strategy_count();
#line 135
  count = tmp;
  }
#line 136
  if (count == 0U) {
    {
#line 137
    stream_printf(str, "555 No strategies available\r\n");
    }
  } else {
    {
#line 141
    stream_printf(str, "111 %lu strategies present: list follows\r\n", (unsigned long )count);
#line 143
    ostr = dicod_ostream_create(str, (dico_assoc_list_t )((void *)0));
#line 144
    dico_strategy_iterate(& _show_strategy, (void *)ostr);
#line 145
    dico_stream_close(ostr);
#line 146
    dico_stream_destroy(& ostr);
#line 147
    stream_writez(str, (char *)".\r\n");
#line 148
    stream_writez(str, (char *)"250 ok\r\n");
    }
  }
#line 150
  return;
}
}
#line 152 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_show_server(dico_stream_t str , int argc , char **argv ) 
{ 
  dico_stream_t ostr ;
  struct utsname uts ;
  int tmp ;
  xdico_timer_t t ;
  double x ;
  double fph ;
  int tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 157
  stream_writez(str, (char *)"114 server information\r\n");
#line 158
  ostr = dicod_ostream_create(str, (dico_assoc_list_t )((void *)0));
#line 159
  stream_writez(str, (char *)"dicod ");
#line 160
  tmp = show_sys_info_p();
  }
#line 160
  if (tmp) {
    {
#line 162
    uname(& uts);
#line 163
    stream_printf(str, "(%s) on %s %s, ", "GNU dico 2.0", uts.sysname, uts.release);
    }
  } else {
    {
#line 166
    stream_writez(str, (char *)"server on ");
    }
  }
  {
#line 167
  stream_writez(str, hostname);
#line 168
  tmp___0 = show_sys_info_p();
  }
#line 168
  if (tmp___0) {
    {
#line 172
    stream_writez(str, (char *)" up ");
#line 173
    t = timer_stop("server");
#line 174
    x = timer_get_real(t);
#line 175
    timer_format_time(str, x);
    }
#line 176
    if (mode == 0) {
#line 176
      if (! single_process) {
#line 177
        x /= (double )3600;
#line 178
        if (x < 0.0001) {
#line 179
          fph = (double )0;
        } else {
#line 181
          fph = (double )(total_forks + 1UL) / x;
        }
        {
#line 182
        stream_printf(str, ", %lu forks (%.1f/hour)", total_forks, fph);
        }
      }
    }
  }
  {
#line 185
  stream_writez(str, (char *)"\r\n");
  }
#line 186
  if (server_info) {
    {
#line 187
    stream_write_multiline(ostr, server_info);
#line 188
    stream_writez(ostr, (char *)"\r\n");
    }
  }
  {
#line 190
  dico_stream_close(ostr);
#line 191
  dico_stream_destroy(& ostr);
#line 192
  stream_writez(str, (char *)".\r\n");
#line 193
  stream_writez(str, (char *)"250 ok\r\n");
  }
#line 194
  return;
}
}
#line 196 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_status(dico_stream_t str , int argc , char **argv ) 
{ 
  xdico_timer_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 199
  stream_writez(str, (char *)"210");
  }
#line 200
  if (timing_option) {
    {
#line 201
    tmp = timer_stop("dicod");
#line 201
    report_timing(str, tmp, & total_stat);
    }
  } else {
    {
#line 203
    stream_writez(str, (char *)" No timing data available");
    }
  }
  {
#line 204
  stream_writez(str, (char *)"\r\n");
  }
#line 205
  return;
}
}
#line 207 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_client(dico_stream_t str , int argc , char **argv ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 210
  xdico_assign_string(& client_id, *(argv + 1));
#line 211
  dico_log(1, 0, "Client info: %s", *(argv + 1));
#line 212
  stream_writez(str, (char *)"250 ok\r\n");
  }
#line 213
  return;
}
}
#line 215 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_match(dico_stream_t str , int argc , char **argv ) 
{ 
  char const   *dbname ;
  char const   *word ;
  dico_strategy_t strat ;
  dico_strategy_t tmp ;
  dicod_database_t *db ;
  dicod_database_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 218
  dbname = (char const   *)*(argv + 1);
#line 219
  word = (char const   *)*(argv + 3);
#line 220
  tmp = dico_strategy_find((char const   *)*(argv + 2));
#line 220
  strat = tmp;
#line 222
  total_bytes_out = (off_t )0;
  }
#line 223
  if (! strat) {
    {
#line 224
    stream_writez(str, (char *)"551 Invalid strategy, use SHOW STRAT for a list\r\n");
    }
  } else {
    {
#line 226
    tmp___2 = strcmp(dbname, "!");
    }
#line 226
    if (tmp___2 == 0) {
      {
#line 227
      dicod_match_word_first(str, (dico_strategy_t const   )strat, word);
      }
    } else {
      {
#line 228
      tmp___1 = strcmp(dbname, "*");
      }
#line 228
      if (tmp___1 == 0) {
        {
#line 229
        dicod_match_word_all(str, (dico_strategy_t const   )strat, word);
        }
      } else {
        {
#line 231
        tmp___0 = find_database(dbname);
#line 231
        db = tmp___0;
        }
#line 233
        if (! db) {
          {
#line 234
          stream_writez(str, (char *)"550 invalid database, use SHOW DB for a list\r\n");
          }
        } else {
          {
#line 237
          dicod_match_word_db(db, str, (dico_strategy_t const   )strat, word);
          }
        }
      }
    }
  }
  {
#line 239
  access_log(argc, argv);
  }
#line 240
  return;
}
}
#line 242 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_define(dico_stream_t str , int argc , char **argv ) 
{ 
  char *dbname ;
  char *word ;
  dicod_database_t *db ;
  dicod_database_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 245
  dbname = *(argv + 1);
#line 246
  word = *(argv + 2);
#line 248
  total_bytes_out = (off_t )0;
#line 249
  tmp___1 = strcmp((char const   *)dbname, "!");
  }
#line 249
  if (tmp___1 == 0) {
    {
#line 250
    dicod_define_word_first(str, (char const   *)word);
    }
  } else {
    {
#line 251
    tmp___0 = strcmp((char const   *)dbname, "*");
    }
#line 251
    if (tmp___0 == 0) {
      {
#line 252
      dicod_define_word_all(str, (char const   *)word);
      }
    } else {
      {
#line 254
      tmp = find_database((char const   *)dbname);
#line 254
      db = tmp;
      }
#line 256
      if (! db) {
        {
#line 257
        stream_writez(str, (char *)"550 invalid database, use SHOW DB for a list\r\n");
        }
      } else {
        {
#line 260
        dicod_define_word_db(db, str, (char const   *)word);
        }
      }
    }
  }
  {
#line 262
  access_log(argc, argv);
  }
#line 263
  return;
}
}
#line 266 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
struct dicod_command command_tab[13]  = 
#line 266
  {      {(char *)"DEFINE", 3, 3, (char *)"database word", (char *)"look up word in database",
      & dicod_define}, 
        {(char *)"MATCH", 4, 4, (char *)"database strategy word", (char *)"match word in database using strategy",
      & dicod_match}, 
        {(char *)"SHOW DB", 2, 2, (char *)((void *)0), (char *)"list all accessible databases",
      & dicod_show_databases}, 
        {(char *)"SHOW DATABASES", 2, 2, (char *)((void *)0), (char *)"list all accessible databases",
      & dicod_show_databases}, 
        {(char *)"SHOW STRAT", 2, 2, (char *)((void *)0), (char *)"list available matching strategies",
      & dicod_show_strategies}, 
        {(char *)"SHOW STRATEGIES", 2, 2, (char *)((void *)0), (char *)"list available matching strategies",
      & dicod_show_strategies}, 
        {(char *)"SHOW INFO", 3, 3, (char *)"database", (char *)"provide information about the database",
      & dicod_show_info}, 
        {(char *)"SHOW SERVER", 2, 2, (char *)((void *)0), (char *)"provide site-specific information",
      & dicod_show_server}, 
        {(char *)"CLIENT", 2, 2, (char *)"info", (char *)"identify client to server",
      & dicod_client}, 
        {(char *)"STATUS", 1, 1, (char *)((void *)0), (char *)"display timing information",
      & dicod_status}, 
        {(char *)"HELP", 1, 1, (char *)((void *)0), (char *)"display this help information",
      & dicod_help}, 
        {(char *)"QUIT", 1, 1, (char *)((void *)0), (char *)"terminate connection", & dicod_quit}, 
        {(char *)((void *)0),
      0, 0, (char *)0, (char *)0, (void (*)(dico_stream_t str , int argc , char **argv ))0}};
#line 299 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
static int _cmd_arg_cmp(void const   *item , void *data ) 
{ 
  struct dicod_command  const  *p ;
  struct locate_data  const  *datptr ;
  int i ;
  int off ;
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 302
  p = (struct dicod_command  const  *)item;
#line 303
  datptr = (struct locate_data  const  *)data;
#line 304
  off = 0;
#line 306
  i = 0;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (i < (int )datptr->argc)) {
#line 306
      goto while_break;
    }
    {
#line 307
    tmp = strlen((char const   *)*(datptr->argv + i));
#line 307
    len = (int )tmp;
#line 308
    tmp___0 = c_strncasecmp((char const   *)(p->keyword + off), (char const   *)*(datptr->argv + i),
                            (size_t )len);
    }
#line 308
    if (tmp___0 == 0) {
#line 309
      off += len;
#line 310
      if ((int )*(p->keyword + off) == 0) {
#line 311
        return (0);
      }
#line 312
      if ((int )*(p->keyword + off) == 32) {
#line 313
        off ++;
#line 314
        goto __Cont;
      }
    }
#line 317
    goto while_break;
    __Cont: /* CIL Label */ 
#line 306
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return (1);
}
}
#line 322 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
dico_list_t command_list  ;
#line 324 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_add_command(struct dicod_command *cmd___6 ) 
{ 


  {
#line 327
  if (! command_list) {
    {
#line 328
    command_list = xdico_list_create();
#line 329
    dico_list_set_comparator(command_list, & _cmd_arg_cmp);
    }
  }
  {
#line 331
  xdico_list_append(command_list, (void *)cmd___6);
  }
#line 332
  return;
}
}
#line 334 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
static int cmd_comp(void const   *a , void *b ) 
{ 
  struct dicod_command  const  *ca ;
  struct dicod_command  const  *cb ;
  int tmp ;

  {
  {
#line 337
  ca = (struct dicod_command  const  *)a;
#line 338
  cb = (struct dicod_command  const  *)b;
#line 339
  tmp = c_strcasecmp((char const   *)ca->keyword, (char const   *)cb->keyword);
  }
#line 339
  return (tmp);
}
}
#line 342 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_remove_command(char const   *name ) 
{ 
  struct dicod_command cmd___6 ;

  {
  {
#line 346
  cmd___6.keyword = (char *)name;
#line 347
  _dico_list_remove(command_list, (void *)(& cmd___6), & cmd_comp, (void **)((void *)0));
  }
#line 348
  return;
}
}
#line 350 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_init_command_tab(void) 
{ 
  struct dicod_command *p ;

  {
#line 355
  p = command_tab;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! p->keyword) {
#line 355
      goto while_break;
    }
    {
#line 356
    dicod_add_command(p);
#line 355
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 359 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
static int _print_help(void *item , void *data ) 
{ 
  struct dicod_command *p ;
  dico_stream_t str ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 362
  p = (struct dicod_command *)item;
#line 363
  str = (dico_stream_t )data;
#line 364
  tmp = strlen((char const   *)p->keyword);
#line 364
  len = (int )tmp;
#line 366
  stream_writez(str, p->keyword);
  }
#line 367
  if (p->param) {
    {
#line 368
    stream_printf(str, " %s", p->param);
#line 369
    tmp___0 = strlen((char const   *)p->param);
#line 369
    len = (int )((size_t )len + (tmp___0 + 1U));
    }
  }
#line 372
  if (len < 31) {
#line 373
    len = 31 - len;
  } else {
#line 375
    len = 0;
  }
  {
#line 376
  stream_printf(str, "%*.*s -- %s\r\n", len, len, "", p->help);
  }
#line 377
  return (0);
}
}
#line 380 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_show_std_help(dico_stream_t str ) 
{ 


  {
  {
#line 383
  dico_list_iterate(command_list, & _print_help, (void *)str);
  }
#line 384
  return;
}
}
#line 386 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
struct dicod_command *locate_command(int argc , char **argv ) 
{ 
  struct locate_data ld ;
  void *tmp ;

  {
  {
#line 390
  ld.argc = argc;
#line 391
  ld.argv = argv;
#line 392
  tmp = dico_list_locate(command_list, (void *)(& ld));
  }
#line 392
  return ((struct dicod_command *)tmp);
}
}
#line 395 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/commands.c"
void dicod_handle_command(dico_stream_t str , int argc , char **argv ) 
{ 
  struct dicod_command *cmd___6 ;
  int nargc ;
  char **nargv ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 399
  nargc = 0;
#line 400
  nargv = (char **)((void *)0);
#line 402
  tmp = alias_expand(argc, argv, & nargc, & nargv);
  }
#line 402
  if (tmp == 0) {
#line 403
    argc = nargc;
#line 404
    argv = nargv;
  }
  {
#line 407
  cmd___6 = locate_command(argc, argv);
  }
#line 408
  if (! cmd___6) {
    {
#line 409
    stream_writez(str, (char *)"500 unknown command\r\n");
    }
  } else
#line 410
  if (argc < cmd___6->minparam) {
    {
#line 412
    stream_writez(str, (char *)"501 wrong number of arguments\r\n");
    }
  } else
#line 410
  if (cmd___6->maxparam != -1) {
#line 410
    if (argc > cmd___6->maxparam) {
      {
#line 412
      stream_writez(str, (char *)"501 wrong number of arguments\r\n");
      }
    } else {
#line 410
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 413
  if (! cmd___6->handler) {
    {
#line 414
    stream_writez(str, (char *)"502 command is not yet implemented, sorry\r\n");
    }
  } else {
    {
#line 416
    (*(cmd___6->handler))(str, argc, argv);
    }
  }
  {
#line 418
  free((void *)nargv);
  }
#line 419
  return;
}
}
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 562
extern int putchar(int __c ) ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 447 "./dicod.h"
void print_help(void) ;
#line 448
void print_usage(void) ;
#line 175 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 139 "cmdline.opt"
static struct option long_options[21]  = 
#line 139 "cmdline.opt"
  {      {"config", 1, (int *)0, 256}, 
        {"foreground", 0, (int *)0, 'f'}, 
        {"stderr", 0, (int *)0, 257}, 
        {"syslog", 0, (int *)0, 258}, 
        {"preprocessor", 1, (int *)0, 259}, 
        {"no-preprocessor", 0, (int *)0, 260}, 
        {"include-dir", 1, (int *)0, 'I'}, 
        {"single-process", 0, (int *)0, 's'}, 
        {"inetd", 0, (int *)0, 'i'}, 
        {"transcript", 0, (int *)0, 'T'}, 
        {"no-transcript", 0, (int *)0, 261}, 
        {"debug", 1, (int *)0, 'x'}, 
        {"source-info", 0, (int *)0, 262}, 
        {"trace-grammar", 0, (int *)0, 263}, 
        {"trace-lex", 0, (int *)0, 264}, 
        {"config-help", 0, (int *)0, 265}, 
        {"lint", 0, (int *)0, 't'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"usage", 0, (int *)0, 266}, 
        {"version", 0, (int *)0, 267}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 139 "cmdline.opt"
static struct opthelp opthelp[22]  = 
#line 139
  {      {"--config", "FILE", 0, "Read this configuration file."}, 
        {"-f, --foreground", (char const   *)((void *)0), 0, "Operate in foreground."}, 
        {"--stderr",
      (char const   *)((void *)0), 0, "Output diagnostic to stderr."}, 
        {"--syslog", (char const   *)((void *)0), 0, "Output diagnostic to syslog (default)."}, 
        {"-E",
      (char const   *)((void *)0), 0, "Preprocess configuration file and exit"}, 
        {"--preprocessor", "PROG", 0, "Use PROG as a preprocessor for config file."}, 
        {"--no-preprocessor",
      (char const   *)((void *)0), 0, "Do not use external preprocessor."}, 
        {"-I, --include-dir", "DIR", 0, "Add the directory DIR to the list of directories to be searched for preprocessor include files"}, 
        {"-s, --single-process",
      (char const   *)((void *)0), 0, "Single-process mode."}, 
        {"-i, --inetd", (char const   *)((void *)0), 0, "Inetd mode."}, 
        {"-T, --transcript", (char const   *)((void *)0), 0, "Enable session transcript."}, 
        {"--no-transcript",
      (char const   *)((void *)0), 0, "Disable session transcript."}, 
        {"-x, --debug", "LEVEL-SPEC", 0, "Set debug verbosity level."}, 
        {"--source-info", (char const   *)((void *)0), 0, "Include source line information in the debugging output."}, 
        {"--trace-grammar",
      (char const   *)((void *)0), 0, "Trace parsing of configuration file."}, 
        {"--trace-lex", (char const   *)((void *)0), 0, "Trace config file lexer."}, 
        {"--config-help", (char const   *)((void *)0), 0, "Show configuration file summary."}, 
        {"-t, --lint",
      (char const   *)((void *)0), 0, "Check configuration file syntax and exit."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), 0, "Other options"}, 
        {"-h, --help", (char const   *)((void *)0), 0, "Give this help list"}, 
        {"--usage", (char const   *)((void *)0), 0, "Give a short usage message"}, 
        {"--version", (char const   *)((void *)0), 0, "Print program version"}};
#line 25 "cmdline.opt"
char const   *program_version  =    "dicod (GNU dico 2.0)";
#line 25 "cmdline.opt"
static char doc[15]  = 
#line 25
  {      (char )'A',      (char )' ',      (char )'D',      (char )'I', 
        (char )'C',      (char )'T',      (char )' ',      (char )'d', 
        (char )'a',      (char )'e',      (char )'m',      (char )'o', 
        (char )'n',      (char )'.',      (char )'\000'};
#line 25 "cmdline.opt"
static char args_doc[1]  = {      (char )'\000'};
#line 25 "cmdline.opt"
char const   *program_bug_address  =    "<bug-dico@gnu.org>";
#line 25 "cmdline.opt"
static void indent(size_t start , size_t col ) 
{ 


  {
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (start < col)) {
#line 25
      goto while_break;
    }
    {
#line 25
    putchar(' ');
#line 25
    start ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 25
  return;
}
}
#line 25 "cmdline.opt"
static void print_option_descr(char const   *descr , size_t lmargin , size_t rmargin ) 
{ 
  size_t s ;
  size_t i ;
  size_t width ;
  unsigned short const   **tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! *descr) {
#line 25
      goto while_break;
    }
#line 25
    s = (size_t )0;
#line 25
    width = rmargin - lmargin;
#line 25
    i = (size_t )0;
    {
#line 25
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 25
      if ((int const   )*(descr + i) == 0) {
#line 25
        goto _L;
      } else {
        {
#line 25
        tmp = __ctype_b_loc();
        }
#line 25
        if ((int const   )*(*tmp + (int )*(descr + i)) & 8192) {
          _L: /* CIL Label */ 
#line 25
          if (i > width) {
#line 25
            goto while_break___0;
          }
#line 25
          s = i;
#line 25
          if ((int const   )*(descr + i) == 0) {
#line 25
            goto while_break___0;
          }
        }
      }
#line 25
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 25
    printf((char const   */* __restrict  */)"%*.*s\n", s, s, descr);
#line 25
    descr += s;
    }
#line 25
    if (*descr) {
      {
#line 25
      indent((size_t )0, lmargin);
#line 25
      descr ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 25
  return;
}
}
#line 25 "cmdline.opt"
void print_help(void) 
{ 
  unsigned int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int n ;
  int tmp___3 ;
  char *cb ;
  char *ce ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 25
  tmp = gettext((char const   *)(args_doc));
#line 25
  tmp___0 = gettext("OPTION");
#line 25
  tmp___1 = gettext("Usage:");
#line 25
  printf((char const   */* __restrict  */)"%s %s [%s]... %s\n", tmp___1, "dicod",
         tmp___0, tmp);
  }
#line 25
  if (doc) {
#line 25
    if (doc[0]) {
      {
#line 25
      tmp___2 = gettext((char const   *)(doc));
#line 25
      print_option_descr((char const   *)tmp___2, (size_t )0, (size_t )79);
      }
    }
  }
  {
#line 25
  putchar('\n');
#line 25
  i = 0U;
  }
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! ((unsigned long )i < sizeof(opthelp) / sizeof(opthelp[0]))) {
#line 25
      goto while_break;
    }
#line 25
    if (opthelp[i].opt) {
      {
#line 25
      tmp___3 = printf((char const   */* __restrict  */)"  %s", opthelp[i].opt);
#line 25
      n = (unsigned int )tmp___3;
      }
#line 25
      if (opthelp[i].arg) {
        {
#line 25
        tmp___4 = strlen(opthelp[i].opt);
        }
#line 25
        if (tmp___4 == 2U) {
#line 25
          if (! opthelp[i].is_optional) {
            {
#line 25
            putchar(' ');
#line 25
            n ++;
            }
          }
        } else {
          {
#line 25
          putchar('=');
#line 25
          n ++;
          }
        }
#line 25
        if (opthelp[i].is_optional) {
#line 25
          cb = (char *)"[";
#line 25
          ce = (char *)"]";
        } else {
#line 25
          ce = (char *)"";
#line 25
          cb = ce;
        }
        {
#line 25
        tmp___5 = gettext(opthelp[i].arg);
#line 25
        tmp___6 = printf((char const   */* __restrict  */)"%s%s%s", cb, tmp___5, ce);
#line 25
        n += (unsigned int )tmp___6;
        }
      }
#line 25
      if (n >= 30U) {
        {
#line 25
        putchar('\n');
#line 25
        n = 0U;
        }
      }
      {
#line 25
      indent(n, (size_t )30);
#line 25
      tmp___7 = gettext(opthelp[i].descr);
#line 25
      print_option_descr((char const   *)tmp___7, (size_t )30, (size_t )79);
      }
    } else {
#line 25
      if (i) {
        {
#line 25
        putchar('\n');
        }
      }
      {
#line 25
      indent((size_t )0, (size_t )2);
#line 25
      tmp___8 = gettext(opthelp[i].descr);
#line 25
      print_option_descr((char const   *)tmp___8, (size_t )2, (size_t )79);
#line 25
      putchar('\n');
      }
    }
#line 25
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 25
  putchar('\n');
#line 25
  tmp___9 = gettext("Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options.");
#line 25
  print_option_descr((char const   *)tmp___9, (size_t )0, (size_t )79);
#line 25
  putchar('\n');
#line 25
  tmp___10 = gettext("Report bugs to %s.\n");
#line 25
  printf((char const   */* __restrict  */)tmp___10, program_bug_address);
  }
#line 25
  return;
}
}
#line 25 "cmdline.opt"
void print_usage(void) 
{ 
  unsigned int i ;
  int f ;
  unsigned int n ;
  char buf___1[80] ;
  char *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  size_t len ;
  size_t tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  size_t tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  size_t tmp___15 ;
  unsigned int tmp___16 ;
  size_t len___0 ;
  char const   *longopt ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  size_t tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  size_t tmp___26 ;
  unsigned int tmp___27 ;
  size_t tmp___28 ;
  unsigned int tmp___29 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 25
  f = 0;
#line 25
  tmp = gettext("Usage:");
#line 25
  tmp___0 = snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1),
                     (char const   */* __restrict  */)"%s %s ", tmp, "dicod");
#line 25
  n = (unsigned int )tmp___0;
#line 25
  i = 0U;
  }
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! ((unsigned long )i < sizeof(opthelp) / sizeof(opthelp[0]))) {
#line 25
      goto while_break;
    }
#line 25
    if (opthelp[i].opt) {
#line 25
      if (opthelp[i].descr) {
#line 25
        if ((int const   )*(opthelp[i].opt + 1) != 45) {
#line 25
          if ((unsigned long )opthelp[i].arg == (unsigned long )((void *)0)) {
#line 25
            if (f == 0) {
              {
#line 25
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 25
                if (n == 79U) {
                  {
#line 25
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
                    {
#line 25
                    buf___1[n] = (char)0;
#line 25
                    printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 25
                    n = 13U;
#line 25
                    memset((void *)(buf___1), ' ', n);
                    }
#line 25
                    goto while_break___1;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                }
#line 25
                tmp___1 = n;
#line 25
                n ++;
#line 25
                buf___1[tmp___1] = (char )'[';
#line 25
                goto while_break___0;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 25
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 25
                if (n == 79U) {
                  {
#line 25
                  while (1) {
                    while_continue___3: /* CIL Label */ ;
                    {
#line 25
                    buf___1[n] = (char)0;
#line 25
                    printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 25
                    n = 13U;
#line 25
                    memset((void *)(buf___1), ' ', n);
                    }
#line 25
                    goto while_break___3;
                  }
                  while_break___3: /* CIL Label */ ;
                  }
                }
#line 25
                tmp___2 = n;
#line 25
                n ++;
#line 25
                buf___1[tmp___2] = (char )'-';
#line 25
                goto while_break___2;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 25
              f = 1;
            }
            {
#line 25
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 25
              if (n == 79U) {
                {
#line 25
                while (1) {
                  while_continue___5: /* CIL Label */ ;
                  {
#line 25
                  buf___1[n] = (char)0;
#line 25
                  printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 25
                  n = 13U;
#line 25
                  memset((void *)(buf___1), ' ', n);
                  }
#line 25
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
              }
#line 25
              tmp___3 = n;
#line 25
              n ++;
#line 25
              buf___1[tmp___3] = (char )*(opthelp[i].opt + 1);
#line 25
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 25
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 25
  if (f) {
    {
#line 25
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 25
      if (n == 79U) {
        {
#line 25
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 25
          buf___1[n] = (char)0;
#line 25
          printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 25
          n = 13U;
#line 25
          memset((void *)(buf___1), ' ', n);
          }
#line 25
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 25
      tmp___4 = n;
#line 25
      n ++;
#line 25
      buf___1[tmp___4] = (char )']';
#line 25
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 25
  i = 0U;
  {
#line 25
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 25
    if (! ((unsigned long )i < sizeof(opthelp) / sizeof(opthelp[0]))) {
#line 25
      goto while_break___8;
    }
#line 25
    if (opthelp[i].opt) {
#line 25
      if (opthelp[i].descr) {
#line 25
        if ((int const   )*(opthelp[i].opt + 1) != 45) {
#line 25
          if (opthelp[i].arg) {
            {
#line 25
            tmp___5 = strlen(opthelp[i].arg);
            }
#line 25
            if (opthelp[i].is_optional) {
#line 25
              tmp___6 = 2;
            } else {
#line 25
              tmp___6 = 1;
            }
#line 25
            len = (5U + tmp___5) + (size_t )tmp___6;
#line 25
            if (n + len > 79U) {
              {
#line 25
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 25
                buf___1[n] = (char)0;
#line 25
                printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 25
                n = 13U;
#line 25
                memset((void *)(buf___1), ' ', n);
                }
#line 25
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
            }
#line 25
            tmp___7 = n;
#line 25
            n ++;
#line 25
            buf___1[tmp___7] = (char )' ';
#line 25
            tmp___8 = n;
#line 25
            n ++;
#line 25
            buf___1[tmp___8] = (char )'[';
#line 25
            tmp___9 = n;
#line 25
            n ++;
#line 25
            buf___1[tmp___9] = (char )'-';
#line 25
            tmp___10 = n;
#line 25
            n ++;
#line 25
            buf___1[tmp___10] = (char )*(opthelp[i].opt + 1);
#line 25
            if (opthelp[i].is_optional) {
              {
#line 25
              tmp___11 = n;
#line 25
              n ++;
#line 25
              buf___1[tmp___11] = (char )'[';
#line 25
              strcpy((char */* __restrict  */)(& buf___1[n]), (char const   */* __restrict  */)opthelp[i].arg);
#line 25
              tmp___12 = strlen(opthelp[i].arg);
#line 25
              n += tmp___12;
#line 25
              tmp___13 = n;
#line 25
              n ++;
#line 25
              buf___1[tmp___13] = (char )']';
              }
            } else {
              {
#line 25
              tmp___14 = n;
#line 25
              n ++;
#line 25
              buf___1[tmp___14] = (char )' ';
#line 25
              strcpy((char */* __restrict  */)(& buf___1[n]), (char const   */* __restrict  */)opthelp[i].arg);
#line 25
              tmp___15 = strlen(opthelp[i].arg);
#line 25
              n += tmp___15;
              }
            }
#line 25
            tmp___16 = n;
#line 25
            n ++;
#line 25
            buf___1[tmp___16] = (char )']';
          }
        }
      }
    }
#line 25
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 25
  i = 0U;
  {
#line 25
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 25
    if (! ((unsigned long )i < sizeof(opthelp) / sizeof(opthelp[0]))) {
#line 25
      goto while_break___10;
    }
#line 25
    if (opthelp[i].opt) {
#line 25
      if (opthelp[i].descr) {
#line 25
        if ((int const   )*(opthelp[i].opt + 1) == 45) {
#line 25
          longopt = opthelp[i].opt;
        } else
#line 25
        if ((int const   )*(opthelp[i].opt + 2) == 44) {
#line 25
          longopt = opthelp[i].opt + 4;
        } else {
#line 25
          goto __Cont;
        }
        {
#line 25
        tmp___17 = strlen(longopt);
        }
#line 25
        if (opthelp[i].arg) {
          {
#line 25
          tmp___18 = strlen(opthelp[i].arg);
          }
#line 25
          if (opthelp[i].is_optional) {
#line 25
            tmp___19 = 2;
          } else {
#line 25
            tmp___19 = 0;
          }
#line 25
          tmp___20 = (1U + tmp___18) + (size_t )tmp___19;
        } else {
#line 25
          tmp___20 = (size_t )0;
        }
#line 25
        len___0 = (3U + tmp___17) + tmp___20;
#line 25
        if (n + len___0 > 79U) {
          {
#line 25
          while (1) {
            while_continue___11: /* CIL Label */ ;
            {
#line 25
            buf___1[n] = (char)0;
#line 25
            printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 25
            n = 13U;
#line 25
            memset((void *)(buf___1), ' ', n);
            }
#line 25
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
        {
#line 25
        tmp___21 = n;
#line 25
        n ++;
#line 25
        buf___1[tmp___21] = (char )' ';
#line 25
        tmp___22 = n;
#line 25
        n ++;
#line 25
        buf___1[tmp___22] = (char )'[';
#line 25
        strcpy((char */* __restrict  */)(& buf___1[n]), (char const   */* __restrict  */)longopt);
#line 25
        tmp___23 = strlen(longopt);
#line 25
        n += tmp___23;
        }
#line 25
        if (opthelp[i].arg) {
#line 25
          tmp___24 = n;
#line 25
          n ++;
#line 25
          buf___1[tmp___24] = (char )'=';
#line 25
          if (opthelp[i].is_optional) {
            {
#line 25
            tmp___25 = n;
#line 25
            n ++;
#line 25
            buf___1[tmp___25] = (char )'[';
#line 25
            strcpy((char */* __restrict  */)(& buf___1[n]), (char const   */* __restrict  */)opthelp[i].arg);
#line 25
            tmp___26 = strlen(opthelp[i].arg);
#line 25
            n += tmp___26;
#line 25
            tmp___27 = n;
#line 25
            n ++;
#line 25
            buf___1[tmp___27] = (char )']';
            }
          } else {
            {
#line 25
            strcpy((char */* __restrict  */)(& buf___1[n]), (char const   */* __restrict  */)opthelp[i].arg);
#line 25
            tmp___28 = strlen(opthelp[i].arg);
#line 25
            n += tmp___28;
            }
          }
        }
#line 25
        tmp___29 = n;
#line 25
        n ++;
#line 25
        buf___1[tmp___29] = (char )']';
      }
    }
    __Cont: /* CIL Label */ 
#line 25
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 25
  while (1) {
    while_continue___12: /* CIL Label */ ;
    {
#line 25
    buf___1[n] = (char)0;
#line 25
    printf((char const   */* __restrict  */)"%s\n", buf___1);
#line 25
    n = 13U;
#line 25
    memset((void *)(buf___1), ' ', n);
    }
#line 25
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 25
  return;
}
}
#line 25 "cmdline.opt"
char const   version_etc_copyright[54]  = 
#line 25
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'5',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'6',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'7',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'8',      (char const   )' ', 
        (char const   )'S',      (char const   )'e',      (char const   )'r',      (char const   )'g', 
        (char const   )'e',      (char const   )'y',      (char const   )' ',      (char const   )'P', 
        (char const   )'o',      (char const   )'z',      (char const   )'n',      (char const   )'y', 
        (char const   )'a',      (char const   )'k',      (char const   )'o',      (char const   )'f', 
        (char const   )'f',      (char const   )'\000'};
#line 25 "cmdline.opt"
void print_version_only(char const   *program_version___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 25
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s\n",
          program_version___0);
#line 25
  tmp = gettext("(C)");
#line 25
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp);
#line 25
  fputc('\n', stream);
  }
#line 25
  return;
}
}
#line 25 "cmdline.opt"
void print_version(char const   *program_version___0 , FILE *stream ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 25
  print_version_only(program_version___0, stream);
#line 25
  tmp = gettext("License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 25
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stream);
  }
#line 25
  return;
}
}
#line 141 "cmdline.opt"
void get_options(int argc , char **argv , struct dicod_conf_override *conf ) 
{ 
  int c ;
  char *__cil_tmp5 ;

  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    c = getopt_long(argc, (char * const  *)argv, "fEI:siTx:th", (struct option  const  *)(long_options),
                    (int *)((void *)0));
    }
#line 144
    if (! (c != -1)) {
#line 144
      goto while_break;
    }
    {
#line 30
    if (c == 256) {
#line 30
      goto case_256;
    }
#line 36
    if (c == 102) {
#line 36
      goto case_102;
    }
#line 42
    if (c == 257) {
#line 42
      goto case_257;
    }
#line 48
    if (c == 258) {
#line 48
      goto case_258;
    }
#line 54
    if (c == 69) {
#line 54
      goto case_69;
    }
#line 60
    if (c == 259) {
#line 60
      goto case_259;
    }
#line 66
    if (c == 260) {
#line 66
      goto case_260;
    }
#line 73
    if (c == 73) {
#line 73
      goto case_73;
    }
#line 79
    if (c == 115) {
#line 79
      goto case_115;
    }
#line 85
    if (c == 105) {
#line 85
      goto case_105;
    }
#line 91
    if (c == 84) {
#line 91
      goto case_84;
    }
#line 97
    if (c == 261) {
#line 97
      goto case_261;
    }
#line 103
    if (c == 120) {
#line 103
      goto case_120;
    }
#line 110
    if (c == 262) {
#line 110
      goto case_262;
    }
#line 116
    if (c == 263) {
#line 116
      goto case_263;
    }
#line 122
    if (c == 264) {
#line 122
      goto case_264;
    }
#line 128
    if (c == 265) {
#line 128
      goto case_265;
    }
#line 135
    if (c == 116) {
#line 135
      goto case_116;
    }
#line 139
    if (c == 104) {
#line 139
      goto case_104;
    }
#line 139
    if (c == 266) {
#line 139
      goto case_266;
    }
#line 139
    if (c == 267) {
#line 139
      goto case_267;
    }
#line 144
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 144
    exit(1);
    }
    case_256: /* CIL Label */ 
#line 31
    config_file = optarg;
#line 32
    goto switch_break;
    case_102: /* CIL Label */ 
#line 37
    foreground = 1;
#line 38
    goto switch_break;
    case_257: /* CIL Label */ 
#line 43
    log_to_stderr = 1;
#line 44
    goto switch_break;
    case_258: /* CIL Label */ 
#line 49
    log_to_stderr = 0;
#line 50
    goto switch_break;
    case_69: /* CIL Label */ 
#line 55
    mode = 2;
#line 56
    goto switch_break;
    case_259: /* CIL Label */ 
#line 61
    preprocessor = (char const   *)optarg;
#line 62
    goto switch_break;
    case_260: /* CIL Label */ 
#line 67
    preprocessor = (char const   *)((void *)0);
#line 68
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 74
    add_include_dir(optarg);
    }
#line 75
    goto switch_break;
    case_115: /* CIL Label */ 
#line 80
    single_process = 1;
#line 81
    goto switch_break;
    case_105: /* CIL Label */ 
#line 86
    mode = 1;
#line 87
    goto switch_break;
    case_84: /* CIL Label */ 
#line 92
    conf->transcript = 1;
#line 93
    goto switch_break;
    case_261: /* CIL Label */ 
#line 98
    conf->transcript = 0;
#line 99
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 104
    debug_level_str = optarg;
#line 105
    debug_level = atoi((char const   *)optarg);
    }
#line 106
    goto switch_break;
    case_262: /* CIL Label */ 
#line 111
    debug_source_info = 1;
#line 112
    goto switch_break;
    case_263: /* CIL Label */ 
    {
#line 117
    config_gram_trace(1);
    }
#line 118
    goto switch_break;
    case_264: /* CIL Label */ 
    {
#line 123
    config_lex_trace(1);
    }
#line 124
    goto switch_break;
    case_265: /* CIL Label */ 
    {
#line 129
    config_help();
#line 130
    exit(0);
    }
#line 131
    goto switch_break;
    case_116: /* CIL Label */ 
#line 136
    config_lint_option = 1;
#line 137
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 139
    print_help();
#line 139
    exit(0);
    }
#line 139
    goto switch_break;
    case_266: /* CIL Label */ 
    {
#line 139
    print_usage();
#line 139
    exit(0);
    }
#line 139
    goto switch_break;
    case_267: /* CIL Label */ 
    {
#line 139
    print_version(program_version, stdout);
#line 139
    exit(0);
    }
#line 139
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 28 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/capa.c"
static dico_list_t capa_list  ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/capa.c"
static int _cmp_capa_name(void const   *item , void *data ) 
{ 
  struct dicod_capa  const  *cp ;
  int tmp ;

  {
  {
#line 33
  cp = (struct dicod_capa  const  *)item;
#line 34
  tmp = strcmp((char const   *)cp->name, (char const   *)((char *)data));
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/capa.c"
void dicod_capa_register(char const   *name , struct dicod_command *cmd___6 , int (*init)(void * ) ,
                         void *closure ) 
{ 
  struct dicod_capa *cp ;
  void *tmp ;

  {
  {
#line 41
  tmp = xmalloc((size_t )sizeof(*cp));
#line 41
  cp = (struct dicod_capa *)tmp;
#line 42
  cp->name = name;
#line 43
  cp->cmd = cmd___6;
#line 44
  cp->init = init;
#line 45
  cp->closure = closure;
#line 46
  cp->enabled = 0;
  }
#line 47
  if (! capa_list) {
    {
#line 48
    capa_list = xdico_list_create();
#line 49
    dico_list_set_comparator(capa_list, & _cmp_capa_name);
    }
  }
  {
#line 51
  xdico_list_append(capa_list, (void *)cp);
  }
#line 52
  return;
}
}
#line 54 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/capa.c"
int dicod_capa_add(char const   *name ) 
{ 
  struct dicod_capa *cp ;
  void *tmp ;

  {
  {
#line 57
  tmp = dico_list_locate(capa_list, (void *)name);
#line 57
  cp = (struct dicod_capa *)tmp;
  }
#line 58
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 59
    return (1);
  }
#line 60
  cp->enabled = 1;
#line 61
  return (0);
}
}
#line 64 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/capa.c"
int dicod_capa_flush(void) 
{ 
  dico_iterator_t itr ;
  struct dicod_capa *cp ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct dicod_command *cmd___6 ;

  {
  {
#line 70
  itr = xdico_list_iterator(capa_list);
#line 71
  tmp = dico_iterator_first(itr);
#line 71
  cp = (struct dicod_capa *)tmp;
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! cp) {
#line 71
      goto while_break;
    }
#line 72
    if (cp->enabled) {
#line 73
      if (cp->init) {
        {
#line 73
        tmp___1 = (*(cp->init))(cp->closure);
        }
#line 73
        if (tmp___1) {
#line 74
          return (1);
        }
      }
#line 75
      if (cp->cmd) {
#line 77
        cmd___6 = cp->cmd;
        {
#line 77
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 77
          if (! cmd___6->keyword) {
#line 77
            goto while_break___0;
          }
          {
#line 78
          dicod_add_command(cmd___6);
#line 77
          cmd___6 ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 71
    tmp___0 = dico_iterator_next(itr);
#line 71
    cp = (struct dicod_capa *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (0);
}
}
#line 90 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/capa.c"
static int _iter_helper(void *item , void *data ) 
{ 
  struct dicod_capa *cp ;
  struct iter_data *dp ;
  int tmp ;

  {
  {
#line 93
  cp = (struct dicod_capa *)item;
#line 94
  dp = (struct iter_data *)data;
#line 95
  tmp = (*(dp->fun))(cp->name, cp->enabled, dp->closure);
  }
#line 95
  return (tmp);
}
}
#line 98 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/capa.c"
void dicod_capa_iterate(int (*fun)(char const   * , int  , void * ) , void *closure ) 
{ 
  struct iter_data dat ;

  {
  {
#line 102
  dat.fun = fun;
#line 103
  dat.closure = closure;
#line 104
  dico_list_iterate(capa_list, & _iter_helper, (void *)(& dat));
  }
#line 105
  return;
}
}
#line 20 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/auth.c"
static int verify_apop(char const   *password , char const   *user_digest ) 
{ 
  int i ;
  struct md5_ctx md5context ;
  unsigned char md5digest[16] ;
  char buf___1[sizeof(md5digest) * 2UL + 1UL] ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 29
  md5_init_ctx(& md5context);
#line 30
  tmp = strlen((char const   *)msg_id);
#line 30
  md5_process_bytes((void const   *)msg_id, tmp, & md5context);
#line 31
  tmp___0 = strlen(password);
#line 31
  md5_process_bytes((void const   *)password, tmp___0, & md5context);
#line 32
  md5_finish_ctx(& md5context, (void *)(md5digest));
#line 34
  i = 0;
#line 34
  p = buf___1;
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < 16)) {
#line 34
      goto while_break;
    }
    {
#line 35
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%02x", (int )md5digest[i]);
#line 34
    i ++;
#line 34
    p += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 36
  tmp___1 = strcmp(user_digest, (char const   *)(buf___1));
  }
#line 36
  return (tmp___1);
}
}
#line 39 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/auth.c"
static int auth(char const   *username , char const   *authstr ) 
{ 
  int rc ;
  char *password ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 42
  rc = 1;
#line 45
  tmp___0 = udb_open(user_db);
  }
#line 45
  if (tmp___0) {
    {
#line 46
    tmp = gettext("failed to open user database");
#line 46
    dico_log(4, 0, (char const   *)tmp);
    }
#line 47
    return (1);
  }
  {
#line 49
  tmp___4 = udb_get_password(user_db, username, & password);
  }
#line 49
  if (tmp___4) {
    {
#line 50
    tmp___1 = gettext("failed to get password for `%s\' from the database");
#line 50
    dico_log(4, 0, (char const   *)tmp___1, username);
    }
  } else
#line 54
  if (! password) {
    {
#line 55
    tmp___2 = gettext("no such user `%s\'");
#line 55
    dico_log(4, 0, (char const   *)tmp___2, username);
#line 56
    rc = 1;
    }
  } else {
    {
#line 58
    rc = verify_apop((char const   *)password, authstr);
    }
#line 59
    if (rc) {
      {
#line 60
      tmp___3 = gettext("authentication failed for `%s\'");
#line 60
      dico_log(4, 0, (char const   *)tmp___3, username);
      }
    } else {
      {
#line 63
      user_name = xstrdup(username);
#line 64
      udb_get_groups(user_db, username, & user_groups);
      }
    }
    {
#line 66
    free((void *)password);
    }
  }
  {
#line 69
  udb_close(user_db);
  }
#line 70
  return (rc);
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/auth.c"
void dicod_auth(dico_stream_t str , int argc , char **argv ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 76
  tmp = auth((char const   *)*(argv + 1), (char const   *)*(argv + 2));
  }
#line 76
  if (tmp == 0) {
    {
#line 77
    stream_writez(str, (char *)"230 Authentication successful");
#line 78
    check_db_visibility();
    }
  } else {
    {
#line 80
    stream_writez(str, (char *)"531 Access denied, use \"SHOW INFO\" for server information");
    }
  }
  {
#line 83
  dico_stream_write(str, (void const   *)"\r\n", (size_t )2);
  }
#line 84
  return;
}
}
#line 86 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/auth.c"
static int auth_init(void *ptr ) 
{ 
  char *__cil_tmp2 ;

  {
#line 89
  if ((unsigned long )user_db == (unsigned long )((void *)0)) {
    {
#line 90
    dico_log(4, 0, "auth capability required but user database is not configured");
    }
#line 92
    return (1);
  }
#line 94
  return (0);
}
}
#line 100 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/auth.c"
static struct dicod_command cmd___5[2]  = {      {(char *)"AUTH", 3, 3, (char *)"user string", (char *)"provide authentication information",
      & dicod_auth}, 
        {(char *)((void *)0), 0, 0, (char *)0, (char *)0, (void (*)(dico_stream_t str ,
                                                                 int argc , char **argv ))0}};
#line 97 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/auth.c"
void register_auth(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 105
  dicod_capa_register("auth", cmd___5, & auth_init, (void *)0);
  }
#line 106
  return;
}
}
#line 109 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/auth.c"
void init_auth_data(void) 
{ 


  {
  {
#line 112
  free((void *)user_name);
#line 113
  user_name = (char *)((void *)0);
#line 114
  free((void *)client_id);
#line 115
  client_id = (char *)((void *)0);
#line 116
  free((void *)identity_name);
#line 117
  identity_name = (char *)((void *)0);
#line 118
  dico_list_destroy(& user_groups);
#line 119
  reset_db_visibility();
  }
#line 120
  return;
}
}
#line 27 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/alias.c"
static Hash_table *alias_table  ;
#line 30 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/alias.c"
static size_t alias_hasher(void const   *data , unsigned int n_buckets ) 
{ 
  struct alias  const  *ap ;
  size_t tmp ;

  {
  {
#line 33
  ap = (struct alias  const  *)data;
#line 34
  tmp = hash_string((char const   *)ap->kw, n_buckets);
  }
#line 34
  return (tmp);
}
}
#line 38 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/alias.c"
static _Bool alias_compare(void const   *data1 , void const   *data2 ) 
{ 
  struct alias  const  *ap1 ;
  struct alias  const  *ap2 ;
  int tmp ;

  {
  {
#line 41
  ap1 = (struct alias  const  *)data1;
#line 42
  ap2 = (struct alias  const  *)data2;
#line 43
  tmp = strcmp((char const   *)ap1->kw, (char const   *)ap2->kw);
  }
#line 43
  return ((_Bool )(tmp == 0));
}
}
#line 46 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/alias.c"
int alias_install(char const   *kw , int argc , char **argv , dicod_locus_t *ploc ) 
{ 
  struct alias *sample ;
  void *tmp ;
  struct alias *ap ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 49
  tmp = xmalloc((size_t )sizeof(*sample));
#line 49
  sample = (struct alias *)tmp;
#line 52
  sample->kw = (char *)kw;
#line 53
  sample->argc = argc;
#line 54
  sample->argv = argv;
#line 55
  sample->locus = *ploc;
  }
#line 57
  if (alias_table) {
#line 57
    goto _L;
  } else {
    {
#line 57
    alias_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & alias_hasher,
                                  & alias_compare, (void (*)(void * ))((void *)0));
    }
#line 57
    if (alias_table) {
      _L: /* CIL Label */ 
      {
#line 57
      tmp___0 = hash_insert(alias_table, (void const   *)sample);
#line 57
      ap = (struct alias *)tmp___0;
      }
#line 57
      if (! ap) {
        {
#line 63
        xalloc_die();
        }
      }
    } else {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 65
  if ((unsigned long )ap != (unsigned long )sample) {
    {
#line 66
    free((void *)sample);
#line 67
    tmp___1 = gettext("alias `%s\' already defined");
#line 67
    config_error(ploc, 0, (char const   *)tmp___1, sample->kw);
#line 68
    tmp___2 = gettext("this is the location of the previous definition");
#line 68
    config_error(& ap->locus, 0, (char const   *)tmp___2);
    }
#line 70
    return (1);
  }
#line 72
  return (0);
}
}
#line 75 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/alias.c"
static int list_alias_cmp(void const   *a , void *b ) 
{ 
  struct alias  const  *ap1 ;
  struct alias  const  *ap2 ;
  int tmp ;

  {
  {
#line 78
  ap1 = (struct alias  const  *)a;
#line 79
  ap2 = (struct alias  const  *)b;
#line 80
  tmp = strcmp((char const   *)ap1->kw, (char const   *)ap2->kw);
  }
#line 80
  return (tmp);
}
}
#line 83 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/alias.c"
int alias_expand(int argc , char **argv , int *pargc , char ***pargv ) 
{ 
  struct alias sample ;
  struct alias *ap ;
  dico_list_t alist ;
  void *tmp ;
  void *tmp___0 ;
  int pos ;
  int nargc ;
  char **nargv ;
  dico_iterator_t itr ;
  dico_iterator_t tmp___1 ;
  char *kw ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int i ;
  int tmp___7 ;

  {
#line 87
  alist = (dico_list_t )((void *)0);
#line 89
  if (! alias_table) {
#line 90
    return (1);
  }
#line 92
  sample.kw = *(argv + 0);
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    tmp___0 = hash_lookup((Hash_table const   *)alias_table, (void const   *)(& sample));
#line 92
    ap = (struct alias *)tmp___0;
    }
#line 92
    if (! ap) {
#line 92
      goto while_break;
    }
#line 93
    if (alist) {
      {
#line 93
      tmp = dico_list_locate(alist, (void *)ap);
      }
#line 93
      if (tmp) {
#line 94
        goto while_break;
      }
    }
#line 95
    sample.kw = *(ap->argv + 0);
#line 96
    if (! alist) {
      {
#line 97
      alist = xdico_list_create();
#line 98
      dico_list_set_comparator(alist, & list_alias_cmp);
      }
    }
    {
#line 100
    xdico_list_append(alist, (void *)ap);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  if (alist) {
    {
#line 107
    tmp___1 = xdico_list_iterator(alist);
#line 107
    itr = tmp___1;
#line 110
    nargc = 1;
#line 111
    tmp___2 = dico_iterator_first(itr);
#line 111
    ap = (struct alias *)tmp___2;
    }
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      if (! ap) {
#line 111
        goto while_break___0;
      }
      {
#line 112
      nargc += ap->argc - 1;
#line 111
      tmp___3 = dico_iterator_next(itr);
#line 111
      ap = (struct alias *)tmp___3;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 114
    pos = nargc;
#line 115
    nargc += argc - 1;
#line 116
    tmp___4 = xcalloc((size_t )(nargc + 1), (size_t )sizeof(*(nargv + 0)));
#line 116
    nargv = (char **)tmp___4;
#line 118
    memcpy((void */* __restrict  */)(nargv + pos), (void const   */* __restrict  */)(argv + 1),
           (size_t )((unsigned long )argc * sizeof(*(argv + 0))));
#line 119
    pos --;
#line 120
    tmp___5 = dico_iterator_first(itr);
#line 120
    ap = (struct alias *)tmp___5;
    }
    {
#line 120
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 120
      if (! ap) {
#line 120
        goto while_break___1;
      }
#line 122
      i = ap->argc - 1;
      {
#line 122
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 122
        if (! (i > 0)) {
#line 122
          goto while_break___2;
        }
#line 123
        tmp___7 = pos;
#line 123
        pos --;
#line 123
        *(nargv + tmp___7) = *(ap->argv + i);
#line 122
        i --;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 124
      kw = *(ap->argv + 0);
#line 120
      tmp___6 = dico_iterator_next(itr);
#line 120
      ap = (struct alias *)tmp___6;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 126
    *(nargv + pos) = kw;
#line 127
    *pargc = nargc;
#line 128
    *pargv = nargv;
#line 129
    dico_list_destroy(& alist);
    }
#line 130
    return (0);
  }
#line 132
  return (1);
}
}
#line 51 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
dicod_acl_t dicod_acl_create(char const   *name , dicod_locus_t *locus___0 ) 
{ 
  dicod_acl_t acl ;
  void *tmp ;

  {
  {
#line 54
  tmp = xmalloc((size_t )sizeof(*(acl + 0)));
#line 54
  acl = (dicod_acl_t )tmp;
#line 55
  acl->name = xstrdup(name);
#line 56
  acl->locus = *locus___0;
#line 57
  acl->list = dico_list_create();
  }
#line 58
  return (acl);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static struct dicod_sockaddr *create_acl_sockaddr(int family , int len ) 
{ 
  struct dicod_sockaddr *p ;
  void *tmp ;

  {
  {
#line 64
  tmp = xzalloc((size_t )sizeof(*p));
#line 64
  p = (struct dicod_sockaddr *)tmp;
#line 65
  p->salen = len;
#line 66
  p->sa.sa_family = (sa_family_t )family;
  }
#line 67
  return (p);
}
}
#line 73 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static int _parse_token(struct acl_entry *entry , config_value_t *value ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 76
  tmp___1 = strcmp(value->v.string, "all");
  }
#line 76
  if (! (tmp___1 == 0)) {
    {
#line 76
    tmp___2 = strcmp(value->v.string, "any");
    }
#line 76
    if (! (tmp___2 == 0)) {
      {
#line 79
      tmp = strcmp(value->v.string, "auth");
      }
#line 79
      if (tmp == 0) {
#line 81
        entry->authenticated = 1;
      } else {
        {
#line 79
        tmp___0 = strcmp(value->v.string, "authenticated");
        }
#line 79
        if (tmp___0 == 0) {
#line 81
          entry->authenticated = 1;
        } else {
#line 83
          return (1);
        }
      }
    }
  }
#line 84
  return (0);
}
}
#line 87 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static int _parse_sockaddr(struct acl_entry *entry , config_value_t *value ) 
{ 
  struct dicod_sockaddr *sptr ;
  char const   *string ;
  char *tmp ;
  size_t len ;
  struct sockaddr_un *s_un ;
  char *tmp___0 ;
  struct in_addr addr ;
  struct sockaddr_in *s_in ;
  char *p ;
  char *tmp___1 ;
  struct hostent *hp ;
  struct hostent *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *q ;
  unsigned int netlen ;
  unsigned long tmp___6 ;
  struct in_addr addr___0 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 93
  if (value->type != 0) {
    {
#line 94
    tmp = gettext("expected string but found list");
#line 94
    config_error(& entry->locus, 0, (char const   *)tmp);
    }
#line 95
    return (1);
  }
#line 98
  string = value->v.string;
#line 100
  if ((int const   )*(string + 0) == 47) {
    {
#line 104
    len = strlen(string);
    }
#line 105
    if ((unsigned long )len >= sizeof(s_un->sun_path)) {
      {
#line 106
      tmp___0 = gettext("socket name too long: `%s\'");
#line 106
      config_error(& entry->locus, 0, (char const   *)tmp___0, string);
      }
#line 109
      return (1);
    }
    {
#line 111
    sptr = create_acl_sockaddr(1, (int )sizeof(s_un));
#line 112
    s_un = (struct sockaddr_un *)(& sptr->sa);
#line 113
    memcpy((void */* __restrict  */)(s_un->sun_path), (void const   */* __restrict  */)string,
           len);
#line 114
    s_un->sun_path[len] = (char)0;
    }
  } else {
    {
#line 118
    tmp___1 = strchr(string, '/');
#line 118
    p = tmp___1;
    }
#line 120
    if (p) {
#line 121
      *p = (char)0;
    }
    {
#line 123
    tmp___4 = inet_aton(string, & addr);
    }
#line 123
    if (tmp___4 == 0) {
      {
#line 124
      tmp___2 = gethostbyname(string);
#line 124
      hp = tmp___2;
      }
#line 125
      if (! hp) {
        {
#line 126
        tmp___3 = gettext("cannot resolve host name: `%s\'");
#line 126
        config_error(& entry->locus, 0, (char const   *)tmp___3, string);
        }
#line 129
        if (p) {
#line 130
          *p = (char )'/';
        }
#line 131
        return (1);
      }
      {
#line 133
      memcpy((void */* __restrict  */)(& addr.s_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
             (size_t )sizeof(addr.s_addr));
      }
    }
    {
#line 135
    addr.s_addr = ntohl(addr.s_addr);
#line 137
    sptr = create_acl_sockaddr(2, (int )sizeof(s_in));
#line 138
    s_in = (struct sockaddr_in *)(& sptr->sa);
#line 139
    s_in->sin_addr = addr;
    }
#line 141
    if (p) {
      {
#line 142
      tmp___5 = p;
#line 142
      p ++;
#line 142
      *tmp___5 = (char )'/';
#line 146
      tmp___6 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)(& q),
                        10);
#line 146
      netlen = (unsigned int )tmp___6;
      }
#line 147
      if ((int )*q == 0) {
#line 148
        if (netlen == 0U) {
#line 149
          sptr->netmask = 0U;
        } else {
          {
#line 151
          sptr->netmask = (unsigned int )(4294967295UL >> (32U - netlen));
#line 152
          sptr->netmask <<= 32U - netlen;
#line 153
          sptr->netmask = htonl(sptr->netmask);
          }
        }
      } else
#line 155
      if ((int )*q == 46) {
        {
#line 158
        tmp___8 = inet_aton((char const   *)p, & addr___0);
        }
#line 158
        if (tmp___8 == 0) {
          {
#line 159
          tmp___7 = gettext("invalid netmask: `%s\'");
#line 159
          config_error(& entry->locus, 0, (char const   *)tmp___7, p);
          }
#line 162
          return (1);
        }
#line 164
        sptr->netmask = addr___0.s_addr;
      } else {
        {
#line 166
        tmp___9 = gettext("invalid netmask: `%s\'");
#line 166
        config_error(& entry->locus, 0, (char const   *)tmp___9, p);
        }
#line 169
        return (1);
      }
    } else {
#line 172
      sptr->netmask = 4294967295U;
    }
  }
  {
#line 174
  xdico_list_append(entry->sockaddrs, (void *)sptr);
  }
#line 175
  return (0);
}
}
#line 178 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static int _parse_from(struct acl_entry *entry , size_t argc , config_value_t *argv ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  dico_iterator_t itr ;
  dico_iterator_t tmp___4 ;
  config_value_t *p ;
  int rc ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 181
  if (argc == 0U) {
#line 182
    return (0);
  } else
#line 183
  if (argv->type == 1) {
    {
#line 184
    tmp = gettext("expected `from\', but found list");
#line 184
    config_error(& entry->locus, 0, (char const   *)tmp);
    }
#line 185
    return (1);
  } else {
    {
#line 186
    tmp___1 = strcmp(argv->v.string, "from");
    }
#line 186
    if (tmp___1) {
      {
#line 187
      tmp___0 = gettext("expected `from\', but found `%s\'");
#line 187
      config_error(& entry->locus, 0, (char const   *)tmp___0, argv->v.string);
      }
#line 189
      return (1);
    }
  }
#line 191
  argc --;
#line 192
  argv ++;
#line 194
  if (argc == 0U) {
    {
#line 195
    tmp___2 = gettext("unexpected end of statement after `from\'");
#line 195
    config_error(& entry->locus, 0, (char const   *)tmp___2);
    }
#line 197
    return (1);
  }
  {
#line 200
  entry->sockaddrs = xdico_list_create();
  }
#line 201
  if (argv->type == 0) {
    {
#line 202
    tmp___3 = _parse_sockaddr(entry, argv);
    }
#line 202
    if (tmp___3) {
#line 203
      return (1);
    }
  } else {
    {
#line 205
    tmp___4 = xdico_list_iterator(argv->v.list);
#line 205
    itr = tmp___4;
#line 207
    rc = 0;
#line 208
    tmp___5 = dico_iterator_first(itr);
#line 208
    p = (config_value_t *)tmp___5;
    }
    {
#line 208
    while (1) {
      while_continue: /* CIL Label */ ;
#line 208
      if (! p) {
#line 208
        goto while_break;
      }
      {
#line 209
      tmp___7 = _parse_sockaddr(entry, p);
#line 209
      rc += tmp___7;
#line 208
      tmp___6 = dico_iterator_next(itr);
#line 208
      p = (config_value_t *)tmp___6;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 210
    if (rc) {
#line 211
      return (rc);
    }
  }
#line 214
  if (argc - 1U) {
    {
#line 215
    tmp___8 = gettext("junk after `from\' list");
#line 215
    config_warning(& entry->locus, 0, (char const   *)tmp___8);
    }
#line 217
    return (1);
  }
#line 219
  return (0);
}
}
#line 222 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static int _parse_sub_acl(struct acl_entry *entry , size_t argc , config_value_t *argv ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 225
  if (argc == 0U) {
#line 226
    return (0);
  }
  {
#line 227
  tmp___2 = strcmp(argv->v.string, "acl");
  }
#line 227
  if (tmp___2 == 0) {
#line 228
    argc --;
#line 229
    argv ++;
#line 230
    if (argc == 0U) {
      {
#line 231
      tmp = gettext("expected ACL name, but found end of statement");
#line 231
      config_error(& entry->locus, 0, (char const   *)tmp);
      }
#line 233
      return (1);
    }
#line 236
    if (argv->type != 0) {
      {
#line 237
      tmp___0 = gettext("expected string, but found list");
#line 237
      config_error(& entry->locus, 0, (char const   *)tmp___0);
      }
#line 239
      return (1);
    }
    {
#line 242
    entry->acl = dicod_acl_lookup(argv->v.string);
    }
#line 244
    if (! entry->acl) {
      {
#line 245
      tmp___1 = gettext("ACL not defined: `%s\'");
#line 245
      config_error(& entry->locus, 0, (char const   *)tmp___1, argv->v.string);
      }
#line 247
      return (1);
    }
#line 249
    argc --;
#line 250
    argv ++;
  }
  {
#line 252
  tmp___3 = _parse_from(entry, argc, argv);
  }
#line 252
  return (tmp___3);
}
}
#line 255 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static int _parse_group(struct acl_entry *entry , size_t argc , config_value_t *argv ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 258
  tmp___0 = strcmp(argv->v.string, "group");
  }
#line 258
  if (tmp___0 == 0) {
#line 259
    argc --;
#line 260
    argv ++;
#line 261
    if (argc == 0U) {
      {
#line 262
      tmp = gettext("expected group list, but found end of statement");
#line 262
      config_error(& entry->locus, 0, (char const   *)tmp);
      }
#line 264
      return (1);
    }
#line 266
    if (argv->type == 0) {
      {
#line 267
      entry->groups = xdico_list_create();
#line 268
      xdico_list_append(entry->groups, (void *)argv->v.string);
      }
    } else {
#line 270
      entry->groups = argv->v.list;
    }
#line 271
    argc --;
#line 272
    argv ++;
  }
  {
#line 274
  tmp___1 = _parse_sub_acl(entry, argc, argv);
  }
#line 274
  return (tmp___1);
}
}
#line 277 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static int _parse_acl(struct acl_entry *entry , size_t argc , config_value_t *argv ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;

  {
#line 280
  if ((argv + 0)->type != 0) {
    {
#line 281
    tmp = gettext("expected string but found list");
#line 281
    config_error(& entry->locus, 0, (char const   *)tmp);
    }
#line 282
    return (1);
  } else {
    {
#line 283
    tmp___2 = _parse_token(entry, argv);
    }
#line 283
    if (tmp___2 == 0) {
      {
#line 284
      tmp___0 = _parse_sub_acl(entry, argc - 1U, argv + 1);
      }
#line 284
      return (tmp___0);
    } else {
      {
#line 286
      tmp___1 = _parse_group(entry, argc, argv);
      }
#line 286
      return (tmp___1);
    }
  }
}
}
#line 289 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
int parse_acl_line(dicod_locus_t *locus___0 , int allow , dicod_acl_t acl , config_value_t *value ) 
{ 
  struct acl_entry *entry ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 293
  tmp = xzalloc((size_t )sizeof(*entry));
#line 293
  entry = (struct acl_entry *)tmp;
#line 295
  entry->locus = *locus___0;
#line 296
  entry->allow = allow;
  }
  {
#line 299
  if (value->type == 0) {
#line 299
    goto case_0;
  }
#line 307
  if (value->type == 2) {
#line 307
    goto case_2;
  }
#line 312
  if (value->type == 1) {
#line 312
    goto case_1;
  }
#line 298
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 300
  tmp___1 = _parse_token(entry, value);
  }
#line 300
  if (tmp___1) {
    {
#line 301
    tmp___0 = gettext("unknown word `%s\'");
#line 301
    config_error(& entry->locus, 0, (char const   *)tmp___0, value->v.string);
    }
#line 303
    return (1);
  }
#line 305
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 308
  tmp___2 = _parse_acl(entry, value->v.arg.c, value->v.arg.v);
  }
#line 308
  if (tmp___2) {
#line 309
    return (1);
  }
#line 310
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 313
  tmp___3 = gettext("unexpected list");
#line 313
  config_error(locus___0, 0, (char const   *)tmp___3);
  }
#line 314
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 316
  xdico_list_append(acl->list, (void *)entry);
  }
#line 317
  return (0);
}
}
#line 323 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static int cmp_group_name(void const   *item , void *data ) 
{ 
  int tmp ;

  {
  {
#line 326
  tmp = strcmp((char const   *)((char *)item), (char const   *)((char *)data));
  }
#line 326
  return (tmp);
}
}
#line 332 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static int _check_sockaddr(void *item , void *data ) 
{ 
  struct dicod_sockaddr *sptr ;
  int *pres ;
  struct sockaddr_in *sin_clt ;
  struct sockaddr_in *sin_item ;
  uint32_t tmp ;
  struct sockaddr_un *sun_clt ;
  struct sockaddr_un *sun_item ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 335
  sptr = (struct dicod_sockaddr *)item;
#line 336
  pres = (int *)data;
#line 338
  if ((int )sptr->sa.sa_family != (int )client_addr.sa_family) {
#line 339
    return (0);
  }
  {
#line 342
  if ((int )sptr->sa.sa_family == 2) {
#line 342
    goto case_2;
  }
#line 355
  if ((int )sptr->sa.sa_family == 1) {
#line 355
    goto case_1;
  }
#line 341
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 344
  sin_clt = (struct sockaddr_in *)(& client_addr);
#line 345
  sin_item = (struct sockaddr_in *)(& sptr->sa);
#line 347
  tmp = ntohl(sin_clt->sin_addr.s_addr);
  }
#line 347
  if (tmp == (sin_item->sin_addr.s_addr & sptr->netmask)) {
#line 349
    *pres = 1;
#line 350
    return (1);
  }
#line 352
  goto switch_break;
  case_1: /* CIL Label */ 
#line 357
  sun_clt = (struct sockaddr_un *)(& client_addr);
#line 358
  sun_item = (struct sockaddr_un *)(& sptr->sa);
#line 360
  if ((unsigned long )client_addrlen < (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)) {
#line 360
    tmp___0 = "";
  } else {
#line 360
    tmp___0 = (char const   *)(sun_clt->sun_path);
  }
#line 360
  if (*(tmp___0 + 0)) {
#line 360
    if ((unsigned long )sptr->salen < (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)) {
#line 360
      tmp___1 = "";
    } else {
#line 360
      tmp___1 = (char const   *)(sun_item->sun_path);
    }
#line 360
    if (*(tmp___1 + 0)) {
      {
#line 360
      tmp___2 = strcmp((char const   *)(sun_clt->sun_path), (char const   *)(sun_item->sun_path));
      }
#line 360
      if (tmp___2 == 0) {
#line 363
        *pres = 1;
#line 364
        return (1);
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 368
  return (0);
}
}
#line 371 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static int _acl_check(struct acl_entry *ent ) 
{ 
  int result ;

  {
#line 374
  result = 1;
#line 376
  if (ent->authenticated) {
#line 377
    result = (unsigned long )user_name != (unsigned long )((void *)0);
#line 378
    if (! result) {
#line 379
      return (result);
    }
  }
#line 382
  if (ent->groups) {
    {
#line 383
    result = dico_list_intersect_p(ent->groups, user_groups, & cmp_group_name);
    }
#line 385
    if (! result) {
#line 386
      return (result);
    }
  }
  {
#line 389
  result = dicod_acl_check(ent->acl, 1);
  }
#line 390
  if (! result) {
#line 391
    return (result);
  }
#line 393
  if (ent->sockaddrs) {
    {
#line 394
    result = 0;
#line 395
    dico_list_iterate(ent->sockaddrs, & _check_sockaddr, (void *)(& result));
    }
  }
#line 398
  return (result);
}
}
#line 401 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static int _acl_check_cb(void *item , void *data ) 
{ 
  struct acl_entry *ent ;
  int *pres ;
  int result ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 404
  ent = (struct acl_entry *)item;
#line 405
  pres = (int *)data;
#line 406
  tmp = _acl_check(ent);
#line 406
  result = tmp;
  }
#line 407
  if (debug_level > 10) {
#line 408
    if (result) {
      {
#line 408
      tmp___0 = gettext("MATCHES");
#line 408
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 408
      tmp___1 = gettext("does not match");
#line 408
      tmp___2 = tmp___1;
      }
    }
    {
#line 408
    dico_log(0, 0, "%s:%d: %s", ent->locus.file, ent->locus.line, tmp___2);
    }
  }
#line 414
  if (result) {
#line 415
    *pres = ent->allow;
#line 416
    return (1);
  }
#line 418
  return (0);
}
}
#line 421 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
int dicod_acl_check(dicod_acl_t acl , int result ) 
{ 


  {
#line 424
  if (acl) {
    {
#line 425
    dico_list_iterate(acl->list, & _acl_check_cb, (void *)(& result));
    }
  }
#line 426
  return (result);
}
}
#line 432 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static Hash_table *acl_table  ;
#line 435 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static size_t acl_hasher(void const   *data , unsigned int n_buckets ) 
{ 
  struct dicod_acl  const  *p ;
  size_t tmp ;

  {
  {
#line 438
  p = (struct dicod_acl  const  *)data;
#line 439
  tmp = hash_string((char const   *)p->name, n_buckets);
  }
#line 439
  return (tmp);
}
}
#line 443 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
static _Bool acl_compare(void const   *data1 , void const   *data2 ) 
{ 
  struct dicod_acl  const  *p1 ;
  struct dicod_acl  const  *p2 ;
  int tmp ;

  {
  {
#line 446
  p1 = (struct dicod_acl  const  *)data1;
#line 447
  p2 = (struct dicod_acl  const  *)data2;
#line 448
  tmp = strcasecmp((char const   *)p1->name, (char const   *)p2->name);
  }
#line 448
  return ((_Bool )(tmp == 0));
}
}
#line 451 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
int dicod_acl_install(dicod_acl_t acl , dicod_locus_t *locus___0 ) 
{ 
  dicod_acl_t ret ;
  void *tmp ;

  {
#line 455
  if (acl_table) {
#line 455
    goto _L;
  } else {
    {
#line 455
    acl_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & acl_hasher,
                                & acl_compare, (void (*)(void * ))0);
    }
#line 455
    if (acl_table) {
      _L: /* CIL Label */ 
      {
#line 455
      tmp = hash_insert(acl_table, (void const   *)acl);
#line 455
      ret = (dicod_acl_t )tmp;
      }
#line 455
      if (! ret) {
        {
#line 460
        xalloc_die();
        }
      }
    } else {
      {
#line 460
      xalloc_die();
      }
    }
  }
#line 462
  if ((unsigned long )ret != (unsigned long )acl) {
#line 463
    if (locus___0) {
#line 464
      *locus___0 = ret->locus;
    }
#line 465
    return (1);
  }
#line 467
  return (0);
}
}
#line 470 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/acl.c"
dicod_acl_t dicod_acl_lookup(char const   *name ) 
{ 
  struct dicod_acl samp ;
  void *tmp ;

  {
#line 474
  if (! acl_table) {
#line 475
    return ((dicod_acl_t )((void *)0));
  }
  {
#line 476
  samp.name = (char *)name;
#line 477
  tmp = hash_lookup((Hash_table const   *)acl_table, (void const   *)(& samp));
  }
#line 477
  return ((dicod_acl_t )tmp);
}
}
#line 248 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
#line 92 "./dicod.h"
char *access_log_file  ;
#line 21 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static char status[2][4]  ;
#line 23 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
void access_log_status(char const   *first , char const   *last ) 
{ 


  {
  {
#line 26
  memcpy((void */* __restrict  */)(status[0]), (void const   */* __restrict  */)first,
         (size_t )3);
#line 27
  status[0][3] = (char)0;
  }
#line 28
  if ((int const   )*(last + 0) == 46) {
#line 29
    last += 3;
  }
  {
#line 30
  memcpy((void */* __restrict  */)(status[1]), (void const   */* __restrict  */)last,
         (size_t )3);
#line 31
  status[1][3] = (char)0;
  }
#line 32
  return;
}
}
#line 70 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
char *access_log_format  =    (char *)"%h %l %u %t \"%r\" %>s %b";
#line 84 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
dico_list_t access_log_prog  ;
#line 92 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void add_instr(void (*prt)(FILE *fp , struct alog_instr *instr , int argc ,
                                  char **argv ) , char const   *fmt , size_t fmtsize ) 
{ 
  struct alog_instr *p ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 96
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 97
    fmtsize = (size_t )0;
  }
#line 98
  if (fmtsize) {
#line 98
    tmp = fmtsize + 1U;
  } else {
#line 98
    tmp = (size_t )0;
  }
  {
#line 98
  tmp___0 = xzalloc((size_t )(sizeof(*p) + (unsigned long )tmp));
#line 98
  p = (struct alog_instr *)tmp___0;
#line 99
  p->prt = prt;
  }
#line 100
  if (fmtsize) {
    {
#line 101
    p->arg = (char *)(p + 1);
#line 102
    memcpy((void */* __restrict  */)p->arg, (void const   */* __restrict  */)fmt,
           fmtsize);
#line 103
    *(p->arg + fmtsize) = (char)0;
    }
  } else {
#line 105
    p->arg = (char *)((void *)0);
  }
  {
#line 106
  xdico_list_append(access_log_prog, (void *)p);
  }
#line 107
  return;
}
}
#line 109 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void print_str(FILE *fp , char const   *arg ) 
{ 
  size_t len ;
  char *__cil_tmp4 ;

  {
#line 113
  if (! arg) {
#line 114
    arg = "-";
#line 115
    len = (size_t )1;
  } else {
    {
#line 117
    len = strlen(arg);
    }
  }
  {
#line 118
  fwrite((void const   */* __restrict  */)arg, len, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 119
  return;
}
}
#line 121 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_print(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 


  {
  {
#line 124
  print_str(fp, (char const   *)instr->arg);
  }
#line 125
  return;
}
}
#line 130 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static char *sockaddr_to_hostname(struct sockaddr *sa , int resolve ) 
{ 
  struct sockaddr_in *s_in ;
  char *ret ;
  struct hostent *hp ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 137
  if ((int )sa->sa_family == 2) {
#line 137
    goto case_2;
  }
#line 150
  if ((int )sa->sa_family == 1) {
#line 150
    goto case_1;
  }
#line 154
  goto switch_default;
  case_2: /* CIL Label */ 
#line 138
  s_in = (struct sockaddr_in *)sa;
#line 139
  if (resolve) {
    {
#line 141
    hp = gethostbyaddr((void const   *)((char *)(& s_in->sin_addr)), (__socklen_t )sizeof(s_in->sin_addr),
                       2);
    }
#line 144
    if (hp) {
      {
#line 145
      tmp = xstrdup((char const   *)hp->h_name);
      }
#line 145
      return (tmp);
    }
  }
  {
#line 147
  tmp___0 = inet_ntoa(s_in->sin_addr);
#line 147
  ret = xstrdup((char const   *)tmp___0);
  }
#line 148
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 151
  ret = xstrdup("localhost");
  }
#line 152
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 155
  ret = xstrdup("{unsupported family}");
  }
  switch_break: /* CIL Label */ ;
  }
#line 158
  return (ret);
}
}
#line 161 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static char *sockaddr_to_portname(struct sockaddr *sa , int salen ) 
{ 
  struct sockaddr_in *s_in ;
  struct sockaddr_un *s_un ;
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *ret ;
  char const   *tmp ;
  uint16_t tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 170
  if ((int )sa->sa_family == 1) {
#line 170
    goto case_1;
  }
#line 178
  if ((int )sa->sa_family == 2) {
#line 178
    goto case_2;
  }
#line 183
  goto switch_default;
  case_1: /* CIL Label */ 
#line 171
  s_un = (struct sockaddr_un *)sa;
#line 172
  if ((unsigned long )salen < (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)) {
#line 172
    tmp = "";
  } else {
#line 172
    tmp = (char const   *)(s_un->sun_path);
  }
#line 172
  if ((int const   )*(tmp + 0) == 0) {
    {
#line 173
    ret = xstrdup("{AF_UNIX}");
    }
  } else {
    {
#line 175
    ret = xstrdup((char const   *)(s_un->sun_path));
    }
  }
#line 176
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 179
  s_in = (struct sockaddr_in *)sa;
#line 180
  tmp___0 = ntohs(s_in->sin_port);
#line 180
  tmp___1 = umaxtostr((uintmax_t )tmp___0, buf___1);
#line 180
  ret = xstrdup((char const   *)tmp___1);
  }
#line 181
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 184
  ret = xstrdup("{unsupported family}");
  }
  switch_break: /* CIL Label */ ;
  }
#line 186
  return (ret);
}
}
#line 189 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_remote_ip(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  char *__cil_tmp5 ;

  {
#line 192
  if (! instr->cache) {
#line 193
    if (client_addrlen == 0) {
      {
#line 194
      instr->cache = xstrdup("stdin");
      }
    } else {
      {
#line 196
      instr->cache = sockaddr_to_hostname(& client_addr, 0);
      }
    }
  }
  {
#line 198
  print_str(fp, (char const   *)instr->cache);
  }
#line 199
  return;
}
}
#line 201 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_local_ip(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  char *__cil_tmp5 ;

  {
#line 204
  if (! instr->cache) {
#line 205
    if (server_addrlen == 0) {
      {
#line 206
      instr->cache = xstrdup("stdin");
      }
    } else {
      {
#line 208
      instr->cache = sockaddr_to_hostname(& server_addr, 0);
      }
    }
  }
  {
#line 210
  print_str(fp, (char const   *)instr->cache);
  }
#line 211
  return;
}
}
#line 213 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_response_size(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *tmp ;
  void *__cil_tmp7 ;

  {
  {
#line 217
  tmp = umaxtostr((uintmax_t )total_bytes_out, buf___1);
#line 217
  print_str(fp, (char const   *)tmp);
  }
#line 218
  return;
}
}
#line 220 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_response_size_clf(FILE *fp , struct alog_instr *instr , int argc ,
                                   char **argv ) 
{ 
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *tmp ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 225
  if (total_bytes_out) {
    {
#line 226
    tmp = umaxtostr((uintmax_t )total_bytes_out, buf___1);
#line 226
    print_str(fp, (char const   *)tmp);
    }
  } else {
    {
#line 228
    print_str(fp, "-");
    }
  }
#line 229
  return;
}
}
#line 231 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_client(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 


  {
  {
#line 234
  print_str(fp, (char const   *)client_id);
  }
#line 235
  return;
}
}
#line 237 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_time_ms(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  xdico_timer_t t ;
  xdico_timer_t tmp ;
  double s ;
  double tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp11 ;

  {
  {
#line 241
  tmp = timer_get((char const   *)*(argv + 0));
#line 241
  t = tmp;
#line 242
  tmp___0 = timer_get_real(t);
#line 242
  s = tmp___0;
#line 243
  tmp___1 = umaxtostr((uintmax_t )(s * 1e6), buf___1);
#line 243
  print_str(fp, (char const   *)tmp___1);
  }
#line 244
  return;
}
}
#line 246 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_remote_host(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  char *__cil_tmp5 ;

  {
#line 249
  if (! instr->cache) {
#line 250
    if (client_addrlen == 0) {
      {
#line 251
      instr->cache = xstrdup("stdin");
      }
    } else {
      {
#line 253
      instr->cache = sockaddr_to_hostname(& client_addr, 1);
      }
    }
  }
  {
#line 255
  print_str(fp, (char const   *)instr->cache);
  }
#line 256
  return;
}
}
#line 258 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_command_verb(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 


  {
  {
#line 261
  print_str(fp, (char const   *)*(argv + 0));
  }
#line 262
  return;
}
}
#line 264 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_command_verb_abbr(FILE *fp , struct alog_instr *instr , int argc ,
                                   char **argv ) 
{ 
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 268
  tmp___4 = strcasecmp((char const   *)*(argv + 0), "DEFINE");
  }
#line 268
  if (tmp___4 == 0) {
#line 268
    tmp___3 = "d";
  } else {
    {
#line 268
    tmp___2 = strcasecmp((char const   *)*(argv + 0), "MATCH");
    }
#line 268
    if (tmp___2 == 0) {
#line 268
      tmp___1 = "m";
    } else {
#line 268
      tmp___1 = "?";
    }
#line 268
    tmp___3 = tmp___1;
  }
  {
#line 268
  print_str(fp, tmp___3);
  }
#line 271
  return;
}
}
#line 273 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_logname(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 


  {
  {
#line 276
  print_str(fp, (char const   *)identity_name);
  }
#line 277
  return;
}
}
#line 279 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_strategy(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  char *__cil_tmp5 ;

  {
#line 282
  if (argc == 4) {
    {
#line 283
    print_str(fp, (char const   *)*(argv + 2));
    }
  } else {
    {
#line 285
    print_str(fp, "-");
    }
  }
#line 286
  return;
}
}
#line 288 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_server_port(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  char *__cil_tmp5 ;

  {
#line 291
  if (server_addrlen == 0) {
    {
#line 292
    print_str(fp, "-");
    }
  } else
#line 293
  if (! instr->cache) {
    {
#line 294
    instr->cache = sockaddr_to_portname(& server_addr, server_addrlen);
    }
  }
  {
#line 295
  print_str(fp, (char const   *)instr->cache);
  }
#line 296
  return;
}
}
#line 298 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_pid(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  __pid_t tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 301
  tmp = getpid();
#line 301
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lu", (unsigned long )tmp);
  }
#line 302
  return;
}
}
#line 304 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_database(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 


  {
  {
#line 307
  print_str(fp, (char const   *)*(argv + 1));
  }
#line 308
  return;
}
}
#line 310 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_request(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  char *str ;
  int tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 314
  tmp = dico_argcv_string(argc, (char const   **)argv, & str);
  }
#line 314
  if (tmp) {
    {
#line 315
    print_str(fp, "-");
    }
  } else {
    {
#line 317
    print_str(fp, (char const   *)str);
#line 318
    free((void *)str);
    }
  }
#line 320
  return;
}
}
#line 322 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_token(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  unsigned int n ;
  int tmp ;
  int tmp___0 ;

  {
#line 325
  if (instr->arg) {
    {
#line 325
    tmp = atoi((char const   *)instr->arg);
#line 325
    tmp___0 = tmp;
    }
  } else {
#line 325
    tmp___0 = 0;
  }
#line 325
  n = (unsigned int )tmp___0;
#line 326
  if (n > (unsigned int )argc) {
#line 327
    n = 0U;
  }
  {
#line 328
  print_str(fp, (char const   *)*(argv + n));
  }
#line 329
  return;
}
}
#line 331 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_status(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  unsigned int n ;
  int tmp ;
  int tmp___0 ;

  {
#line 334
  if (instr->arg) {
    {
#line 334
    tmp = atoi((char const   *)instr->arg);
#line 334
    tmp___0 = tmp;
    }
  } else {
#line 334
    tmp___0 = 0;
  }
#line 334
  n = (unsigned int )tmp___0;
#line 335
  if (n > (unsigned int )argc) {
#line 336
    n = 0U;
  }
  {
#line 337
  print_str(fp, (char const   *)(status[n]));
  }
#line 338
  return;
}
}
#line 340 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_time(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  struct tm tm ;
  time_t t ;
  time_t tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp9 ;

  {
  {
#line 344
  tmp = time((time_t *)((void *)0));
#line 344
  t = tmp;
#line 345
  localtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)(& tm));
  }
#line 346
  if (instr->arg) {
#line 346
    tmp___0 = (char const   *)instr->arg;
  } else {
#line 346
    tmp___0 = "[%d/%b/%Y:%H:%M:%S %z]";
  }
  {
#line 346
  fprintftime(fp, tmp___0, (struct tm  const  *)(& tm), 0, 0);
  }
#line 348
  return;
}
}
#line 350 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_process_time(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  char buf___1[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  xdico_timer_t t ;
  xdico_timer_t tmp ;
  double tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp10 ;

  {
  {
#line 354
  tmp = timer_get((char const   *)*(argv + 0));
#line 354
  t = tmp;
#line 355
  tmp___0 = timer_get_real(t);
#line 355
  tmp___1 = umaxtostr((uintmax_t )tmp___0, buf___1);
#line 355
  print_str(fp, (char const   *)tmp___1);
  }
#line 356
  return;
}
}
#line 358 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_remote_user(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 


  {
  {
#line 361
  print_str(fp, (char const   *)user_name);
  }
#line 362
  return;
}
}
#line 364 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_conf_hostname(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 


  {
  {
#line 367
  print_str(fp, (char const   *)hostname);
  }
#line 368
  return;
}
}
#line 370 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_hostname(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 
  char *__cil_tmp5 ;

  {
#line 373
  if (! instr->cache) {
#line 374
    if (server_addrlen == 0) {
      {
#line 375
      instr->cache = xstrdup("stdin");
      }
    } else {
      {
#line 377
      instr->cache = sockaddr_to_hostname(& server_addr, 0);
      }
    }
  }
  {
#line 379
  print_str(fp, (char const   *)instr->cache);
  }
#line 380
  return;
}
}
#line 382 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static void alog_word(FILE *fp , struct alog_instr *instr , int argc , char **argv ) 
{ 


  {
  {
#line 385
  print_str(fp, (char const   *)*(argv + (argc - 1)));
  }
#line 386
  return;
}
}
#line 388 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static struct alog_tab alog_tab[25]  = 
#line 388
  {      {'%', & alog_print, 0}, 
        {'a', & alog_remote_ip, 0}, 
        {'A', & alog_local_ip, 0}, 
        {'B', & alog_response_size, 0}, 
        {'b', & alog_response_size_clf, 0}, 
        {'C', & alog_client, 0}, 
        {'d', & alog_command_verb_abbr, 0}, 
        {'D', & alog_time_ms, 0}, 
        {'h', & alog_remote_host, 0}, 
        {'H', & alog_command_verb, 0}, 
        {'l', & alog_logname, 0}, 
        {'m', & alog_strategy, 0}, 
        {'p', & alog_server_port, 0}, 
        {'P', & alog_pid, 0}, 
        {'q', & alog_database, 0}, 
        {'r', & alog_request, 0}, 
        {'R', & alog_token, 1}, 
        {'s', & alog_status, 1}, 
        {'t', & alog_time, 1}, 
        {'T', & alog_process_time, 0}, 
        {'u', & alog_remote_user, 0}, 
        {'v', & alog_conf_hostname, 0}, 
        {'V', & alog_hostname, 0}, 
        {'W', & alog_word, 0}, 
        {0, (void (*)(FILE *fp , struct alog_instr *instr , int argc , char **argv ))0,
      0}};
#line 449 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static struct alog_tab *find_alog_entry(int c ) 
{ 
  struct alog_tab *p ;

  {
#line 454
  p = alog_tab;
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if (! p->ch) {
#line 454
      goto while_break;
    }
#line 455
    if (p->ch == c) {
#line 456
      return (p);
    }
#line 454
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  return ((struct alog_tab *)((void *)0));
}
}
#line 460 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
void compile_access_log(void) 
{ 
  char *p ;
  char const   *fmt ;
  size_t len ;
  char *arg ;
  size_t arglen ;
  struct alog_tab *tptr ;
  char *q ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 464
  fmt = (char const   *)access_log_format;
#line 467
  access_log_prog = xdico_list_create();
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 469
    p = strchr(fmt, '%');
    }
#line 469
    if (! p) {
#line 469
      goto while_break;
    }
#line 470
    arg = (char *)((void *)0);
#line 474
    len = (size_t )(p - (char *)fmt);
#line 475
    if (len) {
      {
#line 476
      add_instr(& alog_print, fmt, len);
      }
    }
#line 477
    p ++;
#line 478
    if ((int )*p == 62) {
#line 478
      if ((int )*(p + 1) == 115) {
#line 479
        arg = (char *)"1";
#line 480
        arglen = (size_t )1;
#line 481
        p ++;
      } else {
#line 478
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 482
    if ((int )*p == 123) {
      {
#line 483
      tmp = strchr((char const   *)(p + 1), '}');
#line 483
      q = tmp;
      }
#line 485
      if (! q) {
        {
#line 486
        tmp___0 = gettext("log format error (near char %d): missing terminating `}\'");
#line 486
        dico_log(4, 0, (char const   *)tmp___0, p - access_log_format);
#line 490
        add_instr(& alog_print, (char const   *)(p - 1), (size_t )2);
#line 491
        fmt = (char const   *)(p + 1);
        }
#line 492
        goto while_continue;
      }
#line 494
      arglen = (size_t )((q - p) - 1L);
#line 495
      arg = p + 1;
#line 496
      p = q + 1;
    }
    {
#line 499
    tptr = find_alog_entry((int )*p);
    }
#line 500
    if (! tptr) {
      {
#line 501
      tmp___1 = gettext("log format error (near char %d): unknown format char `%c\'");
#line 501
      dico_log(4, 0, (char const   *)tmp___1, p - access_log_format, (int )*p);
#line 506
      add_instr(& alog_print, fmt, (size_t )((p - (char *)fmt) + 1L));
      }
    } else {
#line 508
      if (arg) {
#line 508
        if (! tptr->allow_fmt) {
          {
#line 509
          tmp___2 = gettext("log format warning (near char %d): format char `%c\' does not take arguments");
#line 509
          dico_log(4, 0, (char const   *)tmp___2, p - access_log_format, (int )*p);
#line 515
          arg = (char *)((void *)0);
          }
        }
      }
#line 517
      if (tptr->ch == 37) {
#line 519
        arg = (char *)"%";
#line 520
        arglen = (size_t )1;
      }
      {
#line 522
      add_instr(tptr->prt, (char const   *)arg, arglen);
      }
    }
#line 524
    fmt = (char const   *)(p + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 526
  len = strlen(fmt);
  }
#line 527
  if (len) {
    {
#line 528
    add_instr(& alog_print, fmt, len);
    }
  }
#line 529
  return;
}
}
#line 531 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
void format_access_log(FILE *fp , int argc , char **argv ) 
{ 
  dico_iterator_t itr ;
  dico_iterator_t tmp ;
  struct alog_instr *p ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 534
  tmp = xdico_list_iterator(access_log_prog);
#line 534
  itr = tmp;
#line 537
  tmp___0 = dico_iterator_first(itr);
#line 537
  p = (struct alog_instr *)tmp___0;
  }
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! p) {
#line 537
      goto while_break;
    }
    {
#line 539
    (*(p->prt))(fp, p, argc, argv);
#line 537
    tmp___1 = dico_iterator_next(itr);
#line 537
    p = (struct alog_instr *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 540
  fputc('\n', fp);
#line 541
  dico_iterator_destroy(& itr);
  }
#line 542
  return;
}
}
#line 544 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
void access_log(int argc , char **argv ) 
{ 
  FILE *fp ;
  char *tmp ;
  int *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 549
  if (! access_log_file) {
#line 550
    return;
  }
  {
#line 551
  fp = fopen((char const   */* __restrict  */)access_log_file, (char const   */* __restrict  */)"a");
  }
#line 552
  if (! fp) {
    {
#line 553
    tmp = gettext("cannot open access log file `%s\'");
#line 553
    tmp___0 = __errno_location();
#line 553
    dico_log(4, *tmp___0, (char const   *)tmp, access_log_file);
    }
#line 555
    return;
  }
  {
#line 557
  format_access_log(fp, argc, argv);
#line 558
  fclose(fp);
  }
#line 559
  return;
}
}
#line 561 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
static int free_cache(void *item , void *data ) 
{ 
  struct alog_instr *p ;

  {
#line 564
  p = (struct alog_instr *)item;
#line 565
  if (p->cache) {
    {
#line 566
    free((void *)p->cache);
#line 567
    p->cache = (char *)((void *)0);
    }
  }
#line 569
  return (0);
}
}
#line 572 "/home/wslee/benchmarks/textformat/dico-2.0/dicod/accesslog.c"
void access_log_free_cache(void) 
{ 


  {
  {
#line 575
  dico_list_iterate(access_log_prog, & free_cache, (void *)0);
  }
#line 576
  return;
}
}
